<div class="post-text" itemprop="text">
<p>I have created a recursion function to iterate through JSON data, which can consist of key and value pairs where the value is a list or dictionary.  In this case, I would like to use the recursion function to eventually return the key and single value that is not a list or dictionary.  I am attempting to store each value currently in the <em>collect</em> variable, which is a dictionary, to view where the data is passing through. However, there are two issues I have with missing values:</p>
<h1>1  There is an example of 'id' and 'fee' not captured in <em>collect</em>.</h1>
<h1>2  When iterating through list values, only the last index is captured.  The key name used in this case appends the index number, so each key name should be unique.</h1>
<p>Would you be able to identify the cause of these issues?  If you could provide insights from the following it would be greatly appreciated.</p>
<p>The following are steps to reproduce the issue.</p>
<p>The data, which can be copied into a text file and saved as myfile.JSON.</p>
<pre><code>{
  "output": {
    "id": "ABC",
    "fee": 155.47,
    "details": [
      {
       "sales": 1000,
       "cost": 200.50,
       "card": [
         {
            "a": 0.01,
            "up": 100.25555,
            "down": 90.25555
         },
         {
           "b": 0.02, 
           "up": 101.25, 
           "down": 80.25
         }
        ]
       },
      {
        "sales": 1100,
        "cost": 300.75,
        "card": [
          {
           "a": 0.01,
          "up": 110.75111,
          "down": 80.7111
          },
          {
           "b": 0.02, 
           "up": 102.25111, 
           "down": 70.50111
           }
          ]
         }
       ],
   "percent": 0.25,
   "sales_start": 1000}}



# The following loads the file to a variable

import json

with open ('myfile.json',"r") as f:
    data = json.load(f)


# Create the recursion function

collect = {}

def myfunc(x, max_level, level=0, keystr='output'):
    global collect
    collect = {}

    if level &lt;= max_level:
        level += 1
        if isinstance(x, dict):
            for k, v in x.items():
                knames = keystr + '-' + k
                if isinstance(v, (dict,list)):
                    myfunc(x[k], max_level, level, knames)  
                    collect.update({'Case1' + '-' + knames + '-lev'+str(level): v})
                else:
                    collect.update({'Case2' + '-' + knames + '-lev'+str(level): v})

        elif isinstance(x, list):
            for i in range(len(x)):
                if isinstance(x[i], (dict, list)):
                    knames = keystr + '-idx'+str(i)
                    myfunc(x[i], max_level, level, knames)
                    collect.update({'Case3' + '-' + knames : x[i]})
                else:
                    collect.update({'Case4' + '-' + knames : x[i]})
        else:
            for k, v in x.items():
                knames = keystr + '-' + k
                collect.update({'Case5' + '_' + knames + '-lev'+str(level): v})  
                return x    
</code></pre>
<p>The function created has a max_level, to control how deep into the nest I would like to return key value pairs for.
Stitching together strings will help identify how deep we are into the nest and create unique key names.</p>
<pre><code># Run the recursion function and output collect

    x = data['output']
    myfunc(x, 0)
    collect
</code></pre>
<p>This outputs the following: </p>
<pre><code>{'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000}
</code></pre>
<p>This is issue #1 with the output above is missing:
'id': 'ABC',
'fee': 155.47</p>
<pre><code># Re-run function creation portion above to reset collection, then the following
myfunc(x, 1)
collect
</code></pre>
<p>The max_level controls how far into the JSON to nest into.  The above returns the following:</p>
<pre><code>{'Case3-output-details-idx1': {'sales': 1100,
  'cost': 300.75,
  'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
   {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]},
 'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000}
</code></pre>
<p>This is issue #2 with the output above only returning 'Case3-output-details-idx1' and is missing 'Case3-output-details-idx0'.  For any number of index values only the last one is returned.</p>
<p>--------Confirmations below, although without recursion function.</p>
<p>The code below simulates the recursion and shows the correct output.  My data file is much larger and there will be multiple files with different combinations of dictionaries and lists, so using recursion is desired.</p>
<pre><code>x = data['output']
max_level = 0
level = 0
collect = {}
keystr = 'output'



if level &lt;= max_level:
    level += 1
    if isinstance(x, dict):
        for k, v in x.items():
            knames = keystr + '-' + k
            if isinstance(v, (dict,list)):

                collect.update({'Case1' + '-' + knames + '-lev'+str(level): v})
            else:
                collect.update({'Case2' + '-' + knames + '-lev'+str(level): v})

    elif isinstance(x, list):
        for i in range(len(x)):
            if isinstance(x[i], (dict, list)):
                knames = keystr + '-idx'+str(i)

                collect.update({'Case3' + '-' + knames : x[i]})
            else:
                collect.update({'Case4' + '-' + knames : x[i]})
else:
        for k, v in x.items():
            knames = keystr + '-' + k
            collect.update({'Case5' + '_' + knames + '-lev'+str(level): v})  

collect
</code></pre>
<p>The output is below and shows the id and fee are returned:</p>
<pre><code>{'Case2-output-id-lev1': 'ABC',
 'Case2-output-fee-lev1': 155.47,
 'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000}





# Trying to simulate looking one level into the nest

x = data['output']['details']
max_level = 1
level = 1
keystr = 'output'
collect = {}


if level &lt;= max_level:
    level += 1
    if isinstance(x, dict):
        for k, v in x.items():
            knames = keystr + '-' + k
            if isinstance(v, (dict,list)):

                collect.update({'Case1' + '-' + knames + '-lev'+str(level): v})
            else:
                collect.update({'Case2' + '-' + knames + '-lev'+str(level): v})

    elif isinstance(x, list):
        for i in range(len(x)):
            if isinstance(x[i], (dict, list)):
                knames = keystr + '-idx'+str(i)

                collect.update({'Case3' + '-' + knames : x[i]})
            else:
                collect.update({'Case4' + '-' + knames : x[i]})
    else:
        for k, v in x.items():
            knames = keystr + '-' + k
            collect.update({'Case5' + '_' + knames + '-lev'+str(level): v}) 

collect
</code></pre>
<p>The code above outputs the following with 'Case3-output-idx0' and 'Case3-output-idx1'</p>
<pre><code>{'Case3-output-idx0': {'sales': 1000,
  'cost': 200.5,
  'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
   {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
 'Case3-output-idx1': {'sales': 1100,
  'cost': 300.75,
  'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
   {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}}            
</code></pre>
<p>Thank you very much for reviewing.</p>
</div>
<div class="post-text" itemprop="text">
<p>After looking further at the issues, the recursion with myfunc() seems to overwrite the variable <em>collect</em>, even though it is specified to be a global variable in the function:</p>
<pre><code>global collect
collect = {}
</code></pre>
<p>By removing this and using a regular global variable outside the function, the <em>collect</em> variable is able to capture all the values.  The code below helps narrow down the issue.</p>
<pre><code>### Issue 1 simplified
# Comment out myfunc() recursion allows id and fee to pass through

collect = {}

def myfunc(x, max_level, level=0, keystr='output'):
    global collect
    collect = {}
    if level &lt;= max_level:
        level += 1
        if isinstance(x, dict):
            for k, v in x.items():
                knames = keystr + '-' + k
                if isinstance(v, (dict,list)):
                    #myfunc(x[k], max_level, level, knames)  
                    collect.update({'Case1' + '-' + knames + '-lev'+str(level): v})
                else:
                    collect.update({'Case2' + '-' + knames + '-lev'+str(level): v})

x = data['output']
myfunc(x, 0)
collect


# Output with id and fee

{'Case2-output-id-lev1': 'ABC',
 'Case2-output-fee-lev1': 155.47,
 'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000}
</code></pre>
<p>When the myfunc() is not commented out below, the recursion seems to overwrite what had initially been stored in <em>collect</em>, which are the id and fee values.</p>
<pre><code>collect = {}

def myfunc(x, max_level, level=0, keystr='output'):
    global collect
    collect = {}
    if level &lt;= max_level:
        level += 1
        if isinstance(x, dict):
            for k, v in x.items():
                knames = keystr + '-' + k
                if isinstance(v, (dict,list)):
                    myfunc(x[k], max_level, level, knames)  
                    collect.update({'Case1' + '-' + knames + '-lev'+str(level): v})
                else:
                    collect.update({'Case2' + '-' + knames + '-lev'+str(level): v})


x = data['output']
myfunc(x, 0)
collect                    


# Output missing id and fee

{'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000}
</code></pre>
<p>To solve for this the global variable inside the function can be removed.</p>
<pre><code>### collect outside function

collect = {}

def myfunc(x, max_level, level=0, keystr='output'):
    if level &lt;= max_level:
        level += 1
        if isinstance(x, dict):
            for k, v in x.items():
                knames = keystr + '-' + k
                if isinstance(v, (dict,list)):
                    myfunc(x[k], max_level, level, knames)  
                    collect.update({'Case1' + '-' + knames + '-lev'+str(level): v})
                else:
                    collect.update({'Case2' + '-' + knames + '-lev'+str(level): v})

x = data['output']
myfunc(x, 0)
collect            

# Outputs id and fee

{'Case2-output-id-lev1': 'ABC',
 'Case2-output-fee-lev1': 155.47,
 'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000}
</code></pre>
<p>Now with the rest of the code:</p>
<pre><code>collect = {}

def myfunc(x, max_level, level=0, keystr='output'):
    if level &lt;= max_level:
        level += 1
        if isinstance(x, dict):
            for k, v in x.items():
                knames = keystr + '-' + k
                if isinstance(v, (dict,list)):
                    myfunc(x[k], max_level, level, knames)  
                    collect.update({'Case1' + '-' + knames + '-lev'+str(level): v})
                else:
                    collect.update({'Case2' + '-' + knames + '-lev'+str(level): v})

        elif isinstance(x, list):
            for i in range(len(x)):
                if isinstance(x[i], (dict, list)):
                    knames = keystr + '-idx'+str(i)
                    myfunc(x[i], max_level, level, knames)
                    collect.update({'Case3' + '-' + knames : x[i]})
                else:
                     collect.update({'Case4' + '-' + knames : x[i]})
        else:
            for k, v in x.items():
                knames = keystr + '-' + k
                collect.update({'Case5' + '_' + knames + '-lev'+str(level): v})  

x = data['output']
myfunc(x, 0)
collect       


# Outputs

{'Case2-output-id-lev1': 'ABC',
 'Case2-output-fee-lev1': 155.47,
 'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000}
</code></pre>
<p>Then we can nest into the JSON one level further with the following where each index value of 'Case2-output-details-idx0 and 'Case2-output-details-idx1 values are returned, which addresses issue #2.  Now all values are returned.</p>
<pre><code>x = data['output']
myfunc(x, 2) # Nest in one layer further
collect

{'Case2-output-id-lev1': 'ABC',
 'Case2-output-fee-lev1': 155.47,
 'Case1-output-details-lev1': [{'sales': 1000,
   'cost': 200.5,
   'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
    {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
  {'sales': 1100,
   'cost': 300.75,
   'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
    {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}],
 'Case2-output-percent-lev1': 0.25,
 'Case2-output-sales_start-lev1': 1000,
 'Case2-output-details-idx0-sales-lev3': 1000,
 'Case2-output-details-idx0-cost-lev3': 200.5,
 'Case1-output-details-idx0-card-lev3': [{'a': 0.01,
   'up': 100.25555,
   'down': 90.25555},
  {'b': 0.02, 'up': 101.25, 'down': 80.25}],
 'Case3-output-details-idx0': {'sales': 1000,
  'cost': 200.5,
  'card': [{'a': 0.01, 'up': 100.25555, 'down': 90.25555},
   {'b': 0.02, 'up': 101.25, 'down': 80.25}]},
 'Case2-output-details-idx1-sales-lev3': 1100,
 'Case2-output-details-idx1-cost-lev3': 300.75,
 'Case1-output-details-idx1-card-lev3': [{'a': 0.01,
   'up': 110.75111,
   'down': 80.7111},
  {'b': 0.02, 'up': 102.25111, 'down': 70.50111}],
 'Case3-output-details-idx1': {'sales': 1100,
  'cost': 300.75,
  'card': [{'a': 0.01, 'up': 110.75111, 'down': 80.7111},
   {'b': 0.02, 'up': 102.25111, 'down': 70.50111}]}}
</code></pre>
</div>
<span class="comment-copy">You don't seem to have actually shown your full recursive code. Note, the most common issue we see here with recursive functions is failing to return the value from the recursion call.</span>
<span class="comment-copy">Yes, the return statement incomplete at this time.  Data filtering will be added and the return statement will be modified.  For now the return x can be commented out, and the issue still exists with returning values from the collect variable.</span>
