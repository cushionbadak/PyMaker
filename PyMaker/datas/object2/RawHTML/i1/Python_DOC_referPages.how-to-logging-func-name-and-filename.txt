<div class="post-text" itemprop="text">
<p>I packaged a class Logger.</p>
<pre><code>class Logger:
    def __init__(self, logfile):
        self.log_file = logfile

    def debug(self, message):
        logging.basicConfig(level=logging.DEBUG,
                            format='%(asctime)-15s %(levelname)s %(module)s %(funcName)s %(lineno)d %(message)s',
                            datefmt='%a, %d %b %Y %H:%M:%S',
                            filename=self.log_file,
                            filemode='w')
        logging.debug(message)
</code></pre>
<p>Then i create logger instance in main function.
Then i used this logger in another class file file1.</p>
<pre><code>  def is_path_valid(self, dc_path):
      self.logger.debug('Entering with parameter dc_path: %s' %(dc_path))
</code></pre>
<p>But this log written in log file is "Tue, 19 Mar 2019 05:41:15 DEBUG <strong><em>logger debug</em></strong> 14 Entering with parameter dc_path: /disks". 
What i expected is "Tue, 19 Mar 2019 05:41:15 DEBUG <strong><em>file1 is_path_valid</em></strong> #line_number Entering with parameter dc_path: /disks"</p>
<p>How should i do?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could eventually use the <a href="https://docs.python.org/3/library/traceback.html" rel="nofollow noreferrer">traceback</a> module:</p>
<pre><code>import traceback

def your_method(param):
    print(traceback.format_stack())  # the stacktrace formatted
    print(traceback.extract_stack())  # the stacktrace as a list, you could only get the last item

your_method(1)
</code></pre>
<p>You could achieve that by transforming your debug() method by something like that:</p>
<pre><code>def debug(self, message):
    logging.debug('%s - %s', traceback.extract_stack()[-1], message)
</code></pre>
<blockquote>
<p>NB: you don't need to call the <code>basicConfig</code> method each time you call the debug() method, just call it when your logger in instanciated; See more about good practices with logging there: <a href="https://realpython.com/python-logging/" rel="nofollow noreferrer">https://realpython.com/python-logging/</a></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/2/library/logging.html" rel="nofollow noreferrer">logging Python official module</a> in the section <a href="https://docs.python.org/2/library/logging.html#logrecord-attributes" rel="nofollow noreferrer">LogRecord attributes</a> and in order to get the expected log output:</p>
<blockquote>
<p>Tue, 19 Mar 2019 05:41:15 DEBUG file1 is_path_valid #line_number
  Entering with parameter dc_path: /disks</p>
</blockquote>
<p>Your format log record attributes should looks like this:</p>
<pre><code>'%(asctime)-15s %(levelname)s %(module)s %(filename)s %(lineno)d %(message)s'
</code></pre>
<p>Notice the change from <code>funcName</code> to <code>filename</code> because what you are looking for is the file name and also you'll obtain: Filename portion of pathname.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have fixed this problem and don't need to write own logger class.</p>
</div>
<span class="comment-copy">Why create your own logger class, which, in this example at least, does not provide anything extra above the normal logging module. With the latter, you set the logger for a package or module (not the default root logger, i.e., not with <code>logging.basicConfig</code>), and inside the module, you use <code>logger = logging.getLogger(__name__)</code>.</span>
<span class="comment-copy">Your custom logger only exposes one of the log levels, and reconfigures logging every time something is <code>debug</code>ged. I'd recommend looking at <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">the docs</a> and sticking to more conventional patterns like that mentioned above.</span>
<span class="comment-copy">Aside: don't use the <code>%</code> to concatenate your logging string with the variable(s) to be logged. Use <code>logger.debug('Entering with parameter dc_path: %s', (dc_path))</code> (comma instead of the second <code>%</code> sign). This saves some time behind the scenes, since the formatting is <i>only</i> done when the logging level is used.</span>
<span class="comment-copy">I just pasted part code in this logger class(such as error level print logging.exception). I need to log data in several modules, so i think it is better to create own logger class.</span>
<span class="comment-copy">Thanks. But if it is too heavy to get track stack? i want to find an easy way.</span>
<span class="comment-copy">Why would it be "too heavy to get the stacktrace"?</span>
<span class="comment-copy">I think traceback.extract_stack()[-1] should be slow, and i don't need to get stack trace, just want to use logging to log info.</span>
<span class="comment-copy">No, it is not the root cause, and i also tried filename but it is still logger.py not calling module filename in log file.</span>
