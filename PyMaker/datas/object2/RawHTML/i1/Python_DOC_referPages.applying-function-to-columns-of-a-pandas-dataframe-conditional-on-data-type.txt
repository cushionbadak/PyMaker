<div class="post-text" itemprop="text">
<p>I want to use the common pattern to apply a function to every column in a Pandas DataFrame, but the function should work conditional on the column data type.</p>
<p>Sounds simple enough. But I found a weird behavior in testing for the data type and I cannot find anywhere in the docs or googling the reason for it.</p>
<p>Consider this repex:</p>
<pre><code>import pandas as pd

toydf = pd.DataFrame(dict(
    A = [1, 2, 3],
    B = [1.1, 1.2, 1.3],
    C = ['1', '2', '3'],
    D = [True, True, False]
))
</code></pre>
<p>Checking individually the dtypes they are <code>dtype('int64'), dtype('float64'), dtype('O'), dtype('bool')</code></p>
<p>But if I use the <code>apply</code> function, all columns passed to the function are <code>dtype: object</code>.</p>
<pre><code>def dtype_fn(the_col):
    print(the_col)
    return(the_col.dtype)

toydf.apply(dtype_fn)

toydf.apply(dtype_fn)
0    1
1    2
2    3
Name: A, dtype: object
0    1.1
1    1.2
2    1.3
Name: B, dtype: object
0    1
1    2
2    3
Name: C, dtype: object
0     True
1     True
2    False
Name: D, dtype: object
Out[167]: 
A    object
B    object
C    object
D    object
dtype: object
</code></pre>
<p>Why is this?, what I am doing wrong?, why the columns does not retain the original data types?</p>
<p>Here's an approach that works and produced my desired output: (but for encapsulation reasons, I don't like it)</p>
<pre><code>def dtype_fn2(col_name):
    return(toydf[col_name].dtype)

[dtype_fn2(col) for col in toydf.columns]

Out[173]: [dtype('int64'), dtype('float64'), dtype('O'), dtype('bool')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The actual input to your <code>dtype_fn</code> is a Pandas Series object. You can access the underlying type by modifying your method slightly.</p>
<pre><code>def dtype_fn(the_col):
    print(the_col.values.dtype)
    return(the_col.values.dtype)
</code></pre>
<p>For more info about why this is the case, you can have a look at this <a href="https://stackoverflow.com/questions/45307792/pandas-reporting-series-to-be-an-object-when-its-a-decimal">answer</a>. There it says </p>
<blockquote>
<p>This is not an error but is due to the numpy dtype representation:
  <a href="https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html" rel="nofollow noreferrer">https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html</a>.</p>
</blockquote>
</div>
<span class="comment-copy">After doing some more reading, what happens is that when you do the apply over those columns, since multiple columns of different type are in question here, pandas will choose the "common denominator" among those columns.  In your example, if you remove the "string" and "boolean" columns, you will stop getting "object" as your type and get float64.  That being said, I don't know a way around this, and I learned something new today thanks to this adventure :)</span>
<span class="comment-copy">thanks for the answer and the pointer to the other SO question. I have actually seen that answer, but I thought it was slightly different issue, since they are dealing with non-native numpy/pandas data types. In my case I am using built-in numpy/pandas data types. I tried your solution modifying the function to get dtype after getting the values, but I still get object dtype for what should have been int64 or float64.</span>
<span class="comment-copy">and yes, the input to the function is a Pandas Series object. That's also why I thought simply getting the <code>the_col.dtype</code> should work. Because if I do it individually I would get the Pandas series object simply like <code>toydf["A"]</code>, whose <b>type</b> <code>type(toy["A"])</code> is indeed pandas.core.series.Series, but it's <b>dtype</b> <code>toy["A"].dtype</code> gives me the data type I am interested in (<code>int64</code>)</span>
<span class="comment-copy">Hmm, yes you are correct. Strange, I was so sure that this would work I didn't even think of running it myself! I guess you taught me something new today :)</span>
