<div class="post-text" itemprop="text">
<p>I have multiple sample files (&gt;20) that look like:</p>
<pre><code>chr startpos    endpos
1   14930   818094
1   818161  31595422
2   35593931    35865807
2   35868158    104785784
</code></pre>
<p>And I would like to output regions that are common among samples. E.g. if sample 1 has:</p>
<pre><code>1   14900   818000
</code></pre>
<p>sample 2:</p>
<pre><code>1   15000   605000
</code></pre>
<p>sample 3:</p>
<pre><code>1   25000   705000
</code></pre>
<p>I would like to output:</p>
<pre><code>1   25000   605000
</code></pre>
<p>I would also like to include a majority rule such that e.g if 10 out of totally 20 samples have a minimal region -&gt; output the region. I.e. I would like to have it flexible how many samples that need to have the region for it to be printed to the output.</p>
<p>Does anyone have a python solution for this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure whether this a question for the Unix &amp; Linux stackexchange. It sounds more like a general programming question. </p>
<p>However, I'd encourage you to look into using <code>pandas</code>. </p>
<p>You can import your sample file as a dataframe, specifying tab delineation as follows:</p>
<pre><code>import pandas as pd
df = pd.read_csv('/tmp/samplefile.csv',sep='\t')
</code></pre>
<p>If you know that startpos will always be smaller than endpos, you could find the output you're looking for by taking the maximum of <code>df['startpos']</code> and the minimum of <code>df['endpos']</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are tools meant specifically for working with BED format data, which you would be well-served by learning. <a href="https://bedtools.readthedocs.io/en/latest/#" rel="nofollow noreferrer">bedtools</a> is probably the most common and easiest to pickup, and it has a <a href="https://daler.github.io/pybedtools/index.html" rel="nofollow noreferrer">python wrapper</a> available if you absolutely have to use python.</p>
<p>The multiIntersectBed tool is what you probably want, and should be pretty straightforward to use:</p>
<p>Example usage:</p>
<pre><code>== Input files: ==

 $ cat a.bed
 chr1  6   12
 chr1  10  20
 chr1  22  27
 chr1  24  30

 $ cat b.bed
 chr1  12  32
 chr1  14  30

 $ cat c.bed
 chr1  8   15
 chr1  10  14
 chr1  32  34

 $ cat sizes.txt
 chr1  5000

== Multi-intersect the files: ==

 $ multiIntersectBed -i a.bed b.bed c.bed
chr1    6       8       1       1       1       0       0
chr1    8       12      2       1,3     1       0       1
chr1    12      15      3       1,2,3   1       1       1
chr1    15      20      2       1,2     1       1       0
chr1    20      22      1       2       0       1       0
chr1    22      30      2       1,2     1       1       0
chr1    30      32      1       2       0       1       0
chr1    32      34      1       3       0       0       1

== Multi-intersect the files, with a header line (titles are the file names): ==

 $ multiIntersectBed -header -i a.bed b.bed c.bed
 chrom  start   end     num     list    a.bed   b.bed   c.bed
 chr1   6       8       1       1       1       0       0
 chr1   8       12      2       1,3     1       0       1
 chr1   12      15      3       1,2,3   1       1       1
 chr1   15      20      2       1,2     1       1       0
 chr1   20      22      1       2       0       1       0
 chr1   22      30      2       1,2     1       1       0
 chr1   30      32      1       2       0       1       0
 chr1   32      34      1       3       0       0       1

== Multi-intersect the files, with a header line and custom names: ==

 $ multiIntersectBed -header -i a.bed b.bed c.bed -names A B C
 chrom  start   end     num     list    A       B       C
 chr1   6       8       1       A       1       0       0
 chr1   8       12      2       A,C     1       0       1
 chr1   12      15      3       A,B,C   1       1       1
 chr1   15      20      2       A,B     1       1       0
 chr1   20      22      1       B       0       1       0
 chr1   22      30      2       A,B     1       1       0
 chr1   30      32      1       B       0       1       0
 chr1   32      34      1       C       0       0       1

== Multi-intersect the files, showing empty regions (note, requires -g): ==

 $ multiIntersectBed -header -i a.bed b.bed c.bed -names A B C -empty -g sizes.txt
 chrom  start   end     num     list    A       B       C
 chr1   0       6       0       none    0       0       0
 chr1   6       8       1       A       1       0       0
 chr1   8       12      2       A,C     1       0       1
 chr1   12      15      3       A,B,C   1       1       1
 chr1   15      20      2       A,B     1       1       0
 chr1   20      22      1       B       0       1       0
 chr1   22      30      2       A,B     1       1       0
 chr1   30      32      1       B       0       1       0
 chr1   32      34      1       C       0       0       1
 chr1   34      5000    0       none    0       0       0
</code></pre>
<p>You can then filter by the 4th column to meet your stipulated condition for the regions.</p>
</div>
<span class="comment-copy">This question is not really about Unix/Linux, but about programming (coding, algorithms) so it's more appropriate for Stack Overflow rather than this site.</span>
<span class="comment-copy">Also note that people at Stack Exchange will typically not want to do your work/homework for you. These are volunteers here, who are happy to help, but you need to show you're making an effort too. So try to solve this on your own and, when you get stumped, ask a question specific about what is happening that is unexpected. You're more likely to get useful answers (and to learn!) that way.</span>
<span class="comment-copy">Yes, sorry, my bad</span>
<span class="comment-copy">google search for "bedtools"- bedtools intersect might be a good place to start</span>
<span class="comment-copy">Thanks for the start, I'll try it out</span>
