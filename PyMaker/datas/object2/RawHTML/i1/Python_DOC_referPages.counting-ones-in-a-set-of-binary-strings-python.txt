<div class="post-text" itemprop="text">
<p>I have a large set (100 000) of binary strings (fixed length k) like this:
"011100001111000010", "111011011110000100" etc. Some binary strings include leading zeros. 
I'd like to obtain a list <strong>L</strong> of length k such that a[i] = the number of binary strings having 1 on ith place. For example:</p>
<p>Input:</p>
<pre><code>"1011"
"0111"
"0111"
</code></pre>
<p>Output:</p>
<pre><code>[1,2,3,3]
</code></pre>
<p>Since the number of binary strings is very big (100000+) and k is around 100 using nested for loops seems to be very inefficient. What would be the most efficient (or at least more efficient) way to tackle this?</p>
</div>
<div class="post-text" itemprop="text">
<p>There can be no faster way than looping over every character at least once, since you have to look at every character to know which counters to increment for every string. The only case where this is not true would be if you had some <em>a priori</em> additional knowledge about characteristics about the strings (i.e., if they were sorted according to some ordering, etc.).</p>
<p>So you'd have to use 2 loops: One looping over all strings, and one inner loop looping over all characters inside the current string. Then just increment the i-th counter if the string has a 1 as the i-th character.</p>
<p><strong>Edit</strong>: Note that the problem is <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" rel="nofollow noreferrer">embarrassingly parallel</a>, so it is very easy to parallelise it using threading. Although it will not make it asymptotically faster, you can probably speed it up by the number of concurrent threads your CPU supports. Just note that efficient multithreaded programming is by no means simple for those unfamiliar with it.</p>
</div>
<span class="comment-copy">Thank you for your reply. I am aware that I need to somehow check all characters - however I'm not sure whether using 2 simple for loops is optimal. Perhaps it would be better to say convert all strings into numpy arrays and then simply add them all up.</span>
<span class="comment-copy">@BGa Even if you did that, nothing would change about the fact that every character (or bit) of every string has to be accessed once. So you still have an <a href="https://en.wikipedia.org/wiki/Asymptotic_computational_complexity" rel="nofollow noreferrer">asymptotic complexity</a> of <i>O(NÂ·k)</i>, where <i>N</i> is the number of strings, and <i>k</i> the string length. Note that in complexity theory, <i>O(n)</i> is the same as <i>O(1000n + 10000)</i>, as constant factors are simply ignored.</span>
