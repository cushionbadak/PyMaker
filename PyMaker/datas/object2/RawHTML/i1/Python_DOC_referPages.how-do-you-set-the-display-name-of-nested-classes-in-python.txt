<div class="post-text" itemprop="text">
<p>I have a scenario where I've got multiple nested classes all with the same name, and debugging it is driving me nuts.</p>
<p>Here's a sketch:</p>
<pre><code>class Reference(object):
    # common functionality here

class Fruit(object):
    # common functionality here

class Apple(Fruit):
    class Ref(Reference):
        # specific functionality here

class Orange(Fruit):
    class Ref(Reference):
        # specific functionality here

# like 6 more fruits
</code></pre>
<p>My problem: any operation that lists the classname of a reference object shows it as <code>mymodule.Ref</code> and not, say, <code>mymodule.Apple.Ref</code>, which would be much more helpful.</p>
<p>Is there a way to tell Python to use a better name for instances of my nested classes? in default <code>__str__</code> but also in <code>__type__</code>, etc.</p>
<p>Bonus details:</p>
<ul>
<li>flattening the class structure and/or using unique names would do it, but (a) that adds namespace clutter, and (b) there are bits in Fruit that use <code>cls.Ref</code>/<code>self.Ref</code>. Suboptimal.</li>
<li>it's a legacy 2.7 research system, if that matters. Actually, if 3 has fixed this that would be a useful addition to my bucket of arguments to upgrade us...</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Actually Python 3 did fix this with <a href="https://www.python.org/dev/peps/pep-3155/" rel="nofollow noreferrer"><code>__qualname__</code></a>. Time to upgrade.</p>
<p><a href="https://www.python.org/dev/peps/pep-3155/#example-with-nested-classes" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-3155/#example-with-nested-classes</a></p>
<p>According to the PEP rationale (<em>PEP 3155 -- Qualified name for classes and functions</em>), what you want is not possible in 2.7.</p>
</div>
<span class="comment-copy">This just isn't something you would ever do in Python.</span>
<span class="comment-copy">@DanielRoseman Django does it with the nested class Meta.</span>
