<div class="post-text" itemprop="text">
<p>Still new to Python and need a little help here. I've found some answers for iterating through a list of dictionaries but not for nested dictionaries in a list of dictionaries. </p>
<p>Here is the a rough structure of a single dictionary within the dictionary list</p>
<pre><code>[{ 'a':'1',
'b':'2',
'c':'3',
'd':{ 'ab':'12',
      'cd':'34',
      'ef':'56'},
'e':'4',
'f':'etc...'
}]



dict_list = [{ 'a':'1', 'b':'2', 'c':'3', 'd':{ 'ab':'12','cd':'34', 'ef':'56'}, 'e':'4', 'f':'etc...'}, { 'a':'2', 'b':'3', 'c':'4', 'd':{ 'ab':'23','cd':'45', 'ef':'67'}, 'e':'5', 'f':'etcx2...'},{},........,{}]
</code></pre>
<p>That's more or less what I am looking at although there are some keys with lists as values instead of a dictionary but I don't think I need to worry about them right now although code that would catch those would be great.</p>
<p>Here is what I have so far which does a great job of iterating through the json and returning all the values for each 'high level' key.</p>
<pre><code>import ujson as json

with open('test.json', 'r') as f:
    json_text = f.read()

dict_list = json.loads(json_text)

for dic in dict_list:
    for val in dic.values():
        print(val)
</code></pre>
<p>Here is the first set of values that are returned when that loop runs</p>
<pre><code>1
2
3
{'ab':'12','cd':'34','ef':'56'}
4
etc...
</code></pre>
<p>What I need to be able to do pick specific values from the top level and go one level deeper and grab specific values in that nested dictionary and append them to a list(s). I'm sure I am missing a simple solution. Maybe I'm looking at multiple loops?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about checking for the instance type using <code>isinstance</code> (of course only works for one level deeper). Might not be the best way though</p>
<pre><code>for dic in dict_list:
    for val in dic.values():
        if not isinstance(val, dict):
            print(val)
        else:    
            for val2 in val.values():
                print (val2)

# 1
# 2
# 3
# 12
# 34
# 56
# 4
# etc...
# 2
# 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Following the ducktype style encouraged with Python, just guess everything has a <code>.values</code> member, and catch it if they do not:</p>
<pre><code>import ujson as json

with open('test.json', 'r') as f:
    json_text = f.read()

dict_list = json.loads(json_text)

for dic in dict_list:
    for val in dic.values():
        try:
            for l2_val in val.values():
                print(l2_val)
        except AttributeError:
            print(val)
</code></pre>
<p><a href="https://stackoverflow.com/a/55186045/6881240">Bazingaa's</a> solution would be faster if inner dictionaries are expected to be rare.</p>
<p>Of course, any more "deep" and you would need some recursion probably:</p>
<pre><code>def print_dict(d):
    for val in d.values():
       try:
           print_dict(val)
        except AttributeError:
           print(val)
</code></pre>
</div>
<span class="comment-copy">You can use a recursive function for that, the base condition will be that a value is primitive.</span>
<span class="comment-copy">This is the faster solution if inner dictionaries are expected to be rare (compared to duck typing).</span>
<span class="comment-copy">@kabanus: Here based on the data list in the question, I assumed that there is only one level of nested dictionaries. For multiple nested depths, your recursion is the way to go. +1 on your solution</span>
<span class="comment-copy">@Bazingaa Yes. Only one level deep. At least as far as I can tell. There is 40K plus dictionaries in this dataset.</span>
<span class="comment-copy">@MixedBeans: For just one level deep, my answer should work fine</span>
<span class="comment-copy">@Bazingaa Thanks. I added a little more detail to what output I was looking for  right after I posted. I didn't expect such fast responses. I only had the print statement to see what was being returned.</span>
<span class="comment-copy">It should be <code>l2_val</code> instead of <code>l2-val</code></span>
<span class="comment-copy">@Bazingaa thanks for the catch.</span>
<span class="comment-copy">And then of course <code>print(l2_val)</code></span>
<span class="comment-copy">@Bazingaa I should have just compiled it through you :) thanks!</span>
