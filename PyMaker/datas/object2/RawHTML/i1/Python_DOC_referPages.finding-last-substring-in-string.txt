<div class="post-text" itemprop="text">
<p>I'm trying to code a function to find the last substring in a string. I don't want a solution in any other code, I need to do it using my own procedure for course homework.</p>
<p>Most tests work, although when testing <code>aa</code> in <code>aaaaa</code> it fails. I understand why because its starting from a position with only <code>a</code> left, but how can I fix this?</p>
<pre><code>def find_last(s, c):
    last_position = 0
    result = -1

    while True:
        next_position = s.find(c, last_position)
        if next_position == -1:
            break
        result = next_position
        last_position = next_position + len(c)

    return result

print(find_last("aaaaa", "aa")) # should output 3 but doesn't?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are allowed to use built-in functions, you could do this:</p>
<pre><code>idx = s[::-1].find(c[::-1])
return len(s) - (idx + len(c)) if idx &gt;= 0 else -1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is this line:</p>
<pre><code>last_position = next_position + len(c)
</code></pre>
<p>This is skipping potential matches.  As it is, your code considers only the first, third, and fifth positions for matches.  As you say, the right answer comes from checking the fourth position (index == 3).  But you're skipping that because you move the length of the test string each time, rather than moving forward by only one character.</p>
<p>I think you want:</p>
<pre><code>last_position = next_position + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's because you're increasing next_position with length of found substring thus missing last match.</p>
<pre><code>def find_last(s, c):
    last_position = 0
    result = -1

    while True:
        next_position = s.find(c, last_position)
        if next_position == -1:
            break
        result = next_position
        #last_position = next_position + len(c)
        last_position += 1

    return result

print(find_last("aaaaa", "aa")) # -&gt; 3
</code></pre>
<p>You could also use built-in python function <a href="https://docs.python.org/3/library/stdtypes.html#str.rindex" rel="nofollow noreferrer"><code>rindex()</code></a> which will return first index counting from end of string</p>
<pre><code>print("aaaaa".rindex("aa")) # -&gt; 3
</code></pre>
</div>
<span class="comment-copy">I sincerely like that you don't want code as an answer for this homework. I'll give you the nudge you need instead. You can try printing the <code>aaaaa</code> string from the end. Think: indexing by length of the string, then slowly building the substring from the end and checking along the way. ;)</span>
<span class="comment-copy">Why canâ€™t you just reverse the str and do what you are doing.</span>
<span class="comment-copy"><code>aaaaa</code> wont always be the same, it needs to work for any string. I think @JeromeMontino also thought it was only for <code>aaaaa</code> not sure.</span>
<span class="comment-copy">You can actually do this for any line, not just <code>aaaaa</code>. If you don't want to use built-in methods, you can either reverse as Raman pointed out and check from the reversed version OR you work backwards the string's index using its length as initial index and decrementing and checking along the way.</span>
<span class="comment-copy">For brownie points, you might want to stop using <code>str.find</code> and replace it with string slicing and comparison.</span>
