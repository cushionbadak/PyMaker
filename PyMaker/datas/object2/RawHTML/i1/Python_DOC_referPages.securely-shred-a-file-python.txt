<div class="post-text" itemprop="text">
<p>How can I securely remove a file using python? The function <code>os.remove(path)</code> only removes the directory entry, but I want to securely remove the file, similar to the apple feature called "Secure Empty Trash" that randomly overwrites the file.</p>
<p>What function securely removes a file using this method?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://en.wikipedia.org/wiki/Srm_%28Unix%29" rel="noreferrer">srm</a> to securely remove files.  You can use Python's <a href="http://docs.python.org/2/library/os.html#os.system" rel="noreferrer">os.system()</a> function to call srm.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>srm</code>, sure, you can always easily implement it in Python. Refer to <a href="http://en.wikipedia.org/wiki/Gutmann_method" rel="nofollow noreferrer">wikipedia</a> for the data to overwrite the file content with. Observe that depending on actual storage technology, data patterns may be quite different. Furthermore, if you file is located on a <a href="http://en.wikipedia.org/wiki/Log-structured_file_system" rel="nofollow noreferrer">log-structured file system</a> or even on a file system with copy-on-write optimisation, like btrfs, your goal may be <a href="https://unix.stackexchange.com/questions/62345/securely-delete-files-on-btrfs-filesystem">unachievable</a> from user space.</p>
<p>After you are done mashing up the disk area that was used to store the file, remove the file handle with <code>os.remove()</code>.</p>
<p>If you also want to erase any trace of the file name, you can try to allocate and reallocate a whole bunch of randomly named files in the same directory, though depending on directory inode structure (linear, btree, hash, etc.) it may very tough to guarantee you actually overwrote the old file name.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can very easily write a function in Python to overwrite a file with random data, even repeatedly, then delete it.  Something like this:</p>
<pre><code>import os

def secure_delete(path, passes=1):
    with open(path, "ba+") as delfile:
        length = delfile.tell()
        for i in range(passes):
            delfile.seek(0)
            delfile.write(os.urandom(length))
    os.remove(path)
</code></pre>
<p>Shelling out to <code>srm</code> is likely to be faster, however.</p>
</div>
<div class="post-text" itemprop="text">
<p>So at least in Python 3 using @kindall's solution I only got it to append. Meaning the entire contents of the file were still intact and every pass just added to the overall size of the file. So it ended up being [Original Contents][Random Data of that Size][Random Data of that Size][Random Data of that Size] which is not the desired effect obviously. </p>
<p>This trickery worked for me though. I open the file in append to find the length, then reopen in r+ so that I can seek to the beginning (in append mode it seems like what caused the undesired effect is that it was not actually possible to seek to 0)</p>
<p>So check this out:</p>
<pre><code>def secure_delete(path, passes=3):
with open(path, "ba+", buffering=0) as delfile:
    length = delfile.tell()
delfile.close()
with open(path, "br+", buffering=0) as delfile:
    #print("Length of file:%s" % length)
    for i in range(passes):
        delfile.seek(0,0)
        delfile.write(os.urandom(length))
        #wait = input("Pass %s Complete" % i)
    #wait = input("All %s Passes Complete" % passes)
    delfile.seek(0)
    for x in range(length):
        delfile.write(b'\x00')
    #wait = input("Final Zero Pass Complete")
os.remove(path) #So note here that the TRUE shred actually renames to file to all zeros with the length of the filename considered to thwart metadata filename collection, here I didn't really care to implement
</code></pre>
<p>Un-comment the prompts to check the file after each pass, this looked good when I tested it with the caveat that the filename is not shredded like the real shred -zu does</p>
</div>
<span class="comment-copy">this is not a feature of a programming language. this is a feature of the file system/ operating system / storage device.</span>
<span class="comment-copy">IIRC, what Secure Erase Trash actually does is to unlink all the files, then do a single-pass random erasure immediately, then kick off a standard 35-pass erasure in the background.</span>
<span class="comment-copy">Thank you, i will accept your answer.</span>
<span class="comment-copy">I'd use <code>subprocess.check_call</code> rather than <code>os.system</code>, for all the usual reasons. There's no need for the performance hit, hijacking potential, etc. in spawning a shell, and it's better to automatically check that the call succeeded than to forget to do it manually and assume you've secure-erased files when you really haven't.</span>
<span class="comment-copy">This served me well. Thanks.</span>
<span class="comment-copy">+1. But note that there are at some platforms/filesystems where you <i>can</i> do a secure erase from user space, but only by using some special API provided by the kernel/libc/fs. Which means using <code>srm</code> will work, but nothing you write in Python (unless you <code>ctypes</code> the special API) will.</span>
<span class="comment-copy">Meanwhile, it's probably worth looking at the <code>srm</code> for your platform (or, on a platform that doesn't have it, at least at some <code>srm</code>). For example, the source from <a href="http://www.opensource.apple.com/source/srm/srm-7/srm/src/" rel="nofollow noreferrer">OS X 10.8</a> is pretty simple if you know C at all, and understand <code>fts</code> (which is like Python's <code>os.walk</code>); there's almost nothing else tricky there.</span>
<span class="comment-copy">That is a good idea, but is there an advantage to using <code>random.seed()</code> instead of <code>os.urandom(n)</code></span>
<span class="comment-copy"><code>os.urandom</code> will probably be (a lot) faster since you can get more than one byte at a time. You'll want to generate the random data in chunks (maybe 256K to 1MB at a time) to avoid needing to hold all the random data in memory. That will probably be about as fast as <code>srm</code>.</span>
<span class="comment-copy">This won't be nearly as secure as using <code>srm</code>, and it may not be nearly as fast either. The Gutman algorithm has been standardized for decades for a good reason. And <code>srm</code> on some platforms will take advantage of the built-in "Secure Erase" on some hard drives.</span>
<span class="comment-copy"><code>srm</code> is, however, a solution only on platforms that have <code>srm</code>. My point is, there is no reason you couldn't implement whatever secure erasure algorithm you want in Python. My example wasn't meant to be canonical or anything, I didn't even test it.</span>
<span class="comment-copy">Nice, but pylint complains: <code>"ba+" is not a valid mode for open. (bad-open-mode)</code></span>
