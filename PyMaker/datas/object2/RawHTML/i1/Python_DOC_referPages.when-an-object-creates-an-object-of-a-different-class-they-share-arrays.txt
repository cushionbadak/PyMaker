<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a>
<span class="question-originals-answer-count">
                    24 answers
                </span>
</li>
</ul>
</div>
<p>When an object is used to create another object from a different class, it seems that arrays passed on as parameters are actually shared between both classes. Integers don't exhibit this sort of behaviour. I don't know how to explain it further, hopefully the code will speak for itself. Is this behaviour intended, and if it is, how is it possible to make the arrays separate?</p>
<pre><code>class foo:
    def __init__(self, array, integer):
        self.list = array
        self.list[0] = self.list[0] + 1
        self.number = integer
        self.number = self.number + 1
        print('list: ' + str(self.list[0]))
        print('number: ' + str(self.number))
class bar:
    def __init__(self):
        self.objects = []
        self.defaultarray = [1]
        self.defaultnumber = 1
        for i in range(0,3):
            print('default list: ' + str(self.defaultarray))
            self.objects.append(foo(self.defaultarray, self.defaultnumber))

item = bar()   

#expected result:
#default list: [1]
#list: 2, number: 2
#default list: [1]
#list: 2, number: 2
#default list: [1]
#list: 2, number: 2

#actual result:
#default list: [1]
#list: 2, number: 2
#default list: [2]
#list: 3, number: 2
#default list: [3]
#list: 4, number: 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I actually wasn't aware of this behavior, but from what I can tell, Python passes arrays by reference rather than value when instantiating. This means, as you can tell from your code example, that you will be mutating the array from both objects.</p>
<p>If you're strictly looking to pass a copy of the array and not have both objects mutate it, you can use:</p>
<pre><code>self.objects.append(foo(self.defaultarray.copy(), self.defaultnumber))
</code></pre>
<p>If you're familiar with C, think of Python passing the address of the array to the object. Both objects reference the same address, therefore both mutate the same array. I hope this helps alleviate some of the mystery surrounding what's actually going on here.</p>
</div>
<span class="comment-copy">I'm not sure what you're expecting? You're passing the same list to each instance of <code>foo</code> (the one defined at <code>self.defaultarray = [1]</code>) then mutating it in foo <code>self.list[0] = self.list[0] + 1</code></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a> - The question title is misleading, but the most voted answer explains what you are seeing.</span>
<span class="comment-copy">Why not initialize with a <i>copy</i> of the list that you pass the constructor?</span>
<span class="comment-copy">Read this: <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">" Integers don't exhibit this sort of behaviour. " Very important to understand, both <code>int</code> objects and <code>list</code> objects <i>have the exact same behavior with regards to the evaluation strategy</i>, however, you simply cannot mutate an <code>int</code> object, but you can mutate a <code>list</code> object</span>
<span class="comment-copy"><i>everything</i> is passed by reference. Nothing is passed by value in Python.</span>
<span class="comment-copy">Python passes by assignment.  However for objects, the reference is passed by value so you're allowed to mutate the object within methods.  <a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" title="how do i pass a variable by reference">stackoverflow.com/questions/986006/â€¦</a></span>
<span class="comment-copy">@AdamSmith nothing in Python is passed by reference. Frequently, passing a reference is incorrectly described as "pass by reference" but that is not what pass by reference means. The defining characteristic of pass by reference is that assignments to variables are seen <i>in the caller</i>. E.g. <code>def Foo(&amp;a):  a = 42</code> then <code>x = 0; Foo(x); print(x)</code> would print <code>42</code>, using a non-existent pass by reference function. Nothing in python can do this.</span>
<span class="comment-copy">@rayryeng just to be clear, <i>everything</i> is an object in Python. The evaluation strategy of python functions don't change based on the type of the objects. It always works the same.</span>
<span class="comment-copy">@AdamSmith no, it does not match the behavior I was highlighting. This would work in call by reference, but it also works in call by sharing (assignment), which also doesn't copy arguments passed as parameters. In call by reference, the argument is just an alias to the <i>variable</i> that gets passed. So again, most importantly, assignments are seen in the caller. If not the "defining" characteristic I would call it "distinguishing". One could  write a <code>def swap(&amp;a, &amp;b)</code> and pass in <code>x = 1; y = 2; swap(1, 2); print(x, y)</code> and get <code>2 1</code>. try that in Python. Or Java, or Javascript etc</span>
