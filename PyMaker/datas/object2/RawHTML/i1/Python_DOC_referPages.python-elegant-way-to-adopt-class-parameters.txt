<div class="post-text" itemprop="text">
<p>Assume I have many expression similar to</p>
<pre><code>class X:
    def __init__(self, a,b,c,d,e,f):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f
</code></pre>
<p>Is there an elegant way to rewrite this?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Starting from Python 3.7, It could be done using <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">data classes</a></p>
<pre><code>@dataclass
class X:
    a: int
    b: str
    c: float
    # etc...
</code></pre>
<p>The <code>dataclass</code> decorator automatically generates the suitable <code>__init__</code> method.</p>
<hr/>
<p>As @Lie Ryan commented, you could also use <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a>:</p>
<pre><code>&gt;&gt;&gt; X = namedtuple('X', ('a', 'b', 'c'))
&gt;&gt;&gt; x = X(1, 2, 3)
&gt;&gt;&gt; x
X(a=1, b=2, c=3)
&gt;&gt;&gt; x.a
1
</code></pre>
<p>It can even be inherited to add or overload methods:</p>
<pre><code>&gt;&gt;&gt; class X(namedtuple('XSuper', ('a', 'b', 'c'))):
...     def __repr__(self):
...         return 'pouet'
...     
&gt;&gt;&gt; x = X(1, 2, 3)
&gt;&gt;&gt; x
pouet
&gt;&gt;&gt; x.a
1
</code></pre>
<hr/>
<p>The answer from <a href="https://stackoverflow.com/a/55259615/2696355">fountainhead</a> is also a nice version-agnostic trick.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class X:
    def __init__(self, a,b,c,d,e,f):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f

class X:
    def __init__(self, *args):
        arglist = ['a', 'b', 'c', 'd']
        for i in range(0, len(arglist):
            try:
                setattr(self, arglist[i], args[i])
            except IndexError:
                raise Exception('Arg {} needs to be given a value'.format(arglist[i]))
</code></pre>
<p>Does not look like the most elegant thing everbut the longer the list the more simplified, also you only need to modify arglist and it will be reflected. Bad thing, you lose the signature (any non runtime checks you could make are lost, e.g. your IDE will freak out</p>
<p>Other suggestions include enumerate (cleaner way to work with indices).</p>
<p>Or you could just use zip, and do the check at the begginign:</p>
<pre><code>class X:
    def __init__(self, *args):
        arglist = ['a', 'b', 'c', 'd']
        if len(arglist) != len(args):
           raise CustomExceptino('Too few/many arguments...')
        for keyval_tuple in zip(arglist, args):
            setattr(self, keyval_tuple[0], keyval_tuple[1])
</code></pre>
<p>Note that you can still add arguments that don't behave this way:</p>
<pre><code>    class X:
        def __init__(self, special_arg, *args):
            self.special_consequence = self.do_sth_with_special_arg(special_arg)
            arglist = ['a', 'b', 'c', 'd']
            if len(arglist) != len(args):
               raise CustomExceptino('Too few/many arguments...')
            for keyval_tuple in zip(arglist, args):
                setattr(self, keyval_tuple[0], keyval_tuple[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try this:</p>
<pre><code>class X:
    def __init__(self, a,b,c,d,e,f):
        all_l = locals() # Let this be the first statement.
        for l in all_l:
            if (l != 'self'):
                self.__dict__[l] = all_l[l]
</code></pre>
<p>Output:</p>
<pre><code>x = X(10,20,30,40,50,60)
print (x.d)

40
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try using named <a href="https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3" rel="nofollow noreferrer">generic arguments</a>:</p>
<pre><code>class X:
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)       
</code></pre>
<p>and then:</p>
<pre><code>x = X(a=1, b=2, c=3, d=4, e=5, f=6)
</code></pre>
<p>But this is not good practice, as it gives you no control on what is actually passed.</p>
<p>Or:</p>
<pre><code>class X:
    def __init__(self, *args):
        for key, value in zip(['a', 'b', 'c', 'd', 'e', 'f'], args):
            setattr(self, key, value)    
</code></pre>
<p>and then:</p>
<pre><code>x = X(1, 2, 3, 4, 5, 6)
</code></pre>
<p>BUT, as the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Zen of Python</a> says:</p>
<blockquote>
<p>explicit is better than implicit</p>
</blockquote>
<p>and your original code is good enough for that!</p>
<p><strong>EDIT</strong></p>
<p>Just to avoid overwriting <em>dangerous</em> properties, replace</p>
<pre><code>setattr(self, key, value)    
</code></pre>
<p>with</p>
<pre><code>if not hasattr(self, key):
    setattr(self, key, value)
</code></pre>
</div>
<span class="comment-copy">starting from Python 3.7, you could use data-classes: <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">docs.python.org/3/library/dataclasses.html</a></span>
<span class="comment-copy">okay Tryph, this is what I searched for. Put into an answer and I will check it as solving the problem.</span>
<span class="comment-copy">In older versions, there are also <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a> or <a href="https://pypi.org/project/attrs/" rel="nofollow noreferrer">attrs</a>.</span>
<span class="comment-copy">prefer using <code>enumerate</code> builtin instead of <code>range(0, len(arglist)</code></span>
<span class="comment-copy">he is asking for args, not kwargs</span>
<span class="comment-copy">You can add a statement like: <code>assert set(kwargs.keys()).issubset({'a', 'b', 'c', 'd', 'e', 'f'})</code> or <code>if not set(kwargs.keys()).issubset({'a', 'b', 'c', 'd', 'e', 'f'}): raise ArgumentError()</code> to enforce what can be passed into the class.</span>
<span class="comment-copy">@E.Serra: <code>*args</code> can be handled similarly with <code>zip(['a', 'b', 'c', 'd', 'e', 'f'], args)</code> instead of <code>kwargs.items()</code></span>
<span class="comment-copy">I think that, as far as the OP's reasons are not clear, the best way to achieve that assignements is to be expicit. Any other solution wouldn't be "pythonic"</span>
<span class="comment-copy">That would make whatever passed as kwarg work, and give no room for args/kwargs that don't behave as self.arg =arg</span>
