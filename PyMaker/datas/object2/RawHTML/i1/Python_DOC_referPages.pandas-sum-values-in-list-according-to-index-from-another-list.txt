<div class="post-text" itemprop="text">
<p>I am trying to find the most pythonic way to tackle down my problem in the short time as possible since I am dealing with a large amount of data. My problem is the following:</p>
<p>I have two lists</p>
<pre><code>a = [12,34,674,2,0,5,6,8]
b = ['foo','bar','bar','foo','foo','bar','foo','foo']
</code></pre>
<p>I want to say python: if 'bar' is in b, take all the indexes and sum all values in list a with those indexes. </p>
<p>This is what I have done so far:</p>
<pre><code>idx = [i for i, j in enumerate(a) if j == 'bar'] 
</code></pre>
<p>but then I am stacked. I am considering using some wired for loops. Do you have any idea?</p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>numpy</code>:</p>
<pre><code>import numpy as np

a = np.array(a)
b = np.array(b)

a[b == 'bar'].sum()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>np.bincount</code>. Computes both sums ('foo' and 'bar').</p>
<pre><code>sum_foo, sum_bar = np.bincount(np.char.equal(b, 'bar'), a)
sum_foo
# 28.0
sum_bar
# 713.0
</code></pre>
<p>Note <code>np.char.equal</code> works on both lists and arrays. If b is an array, then <code>b == 'bar'</code> can be used instead and is a bit faster.</p>
<p>Timings:</p>
<p>Even though this computes both sums it is actually pretty fast:</p>
<pre><code>timeit(lambda: np.bincount(b == 'bar', a))
# 2.406161994993454
</code></pre>
<p>Compare for example with the numpy masking method:</p>
<pre><code>timeit(lambda: a[b == 'bar'].sum())
# 5.642918559984537
</code></pre>
<p>On larger arrays masking becomes slightly faster which is expected since <code>bincount</code> does essentially 2x the work. Still <code>bincount</code> takes less than 2x the time, so if you happen to need both sums ('foo' and 'bar'), <code>bincount</code> is still faster.</p>
<pre><code>aa = np.repeat(a, 1000)
bb = np.repeat(b, 1000)
timeit(lambda: aa[bb == 'bar'].sum(), number=1000)
# 0.07860603698645718
timeit(lambda:np.bincount(bb == 'bar', aa), number=1000)
# 0.11229897901648656
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use:</p>
<pre><code>l = [x for x,y in zip(a,b) if y == 'bar']
</code></pre>
<p>If you want indexes:</p>
<pre><code>l = [i for (i,x),y in zip(enumerate(a),b) if y == 'bar']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is simple to do in <code>pandas</code>:</p>
<pre><code>In[5]:
import pandas as pd
a = [12,34,674,2,0,5,6,8]
b = ['foo','bar','bar','foo','foo','bar','foo','foo']
df = pd.DataFrame({'a':a, 'b':b})
df

Out[5]: 
     a    b
0   12  foo
1   34  bar
2  674  bar
3    2  foo
4    0  foo
5    5  bar
6    6  foo
7    8  foo

In [8]: df.loc[df['b']=='bar','a'].sum()
Out[8]: 713
</code></pre>
<p>So here we take your lists and construct a <code>dict</code> in place for the <code>data</code> arg for the <code>DataFrame</code> ctor:</p>
<pre><code>df = pd.DataFrame({'a':a, 'b':b})
</code></pre>
<p>Then we just mask the df using <code>loc</code> where we select the rows where <code>'b' == 'bar'</code> and select the column <code>'a'</code> and call <code>sum()</code>:</p>
<pre><code>df.loc[df['b']=='bar','a'].sum()
</code></pre>
</div>
<span class="comment-copy">sum([a[i] for i, j in enumerate(b) if j == 'bar'] ).. ?</span>
<span class="comment-copy">This will likely be the fastest method +1</span>
<span class="comment-copy">Oh yeah, that's right.</span>
