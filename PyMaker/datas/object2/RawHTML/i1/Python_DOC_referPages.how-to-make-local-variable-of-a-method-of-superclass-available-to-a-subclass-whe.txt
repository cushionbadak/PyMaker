<div class="post-text" itemprop="text">
<p>As you can see the code, I have a super class  <code>bar_for_foo_mixin()</code> and I have a subclass <code>myfoo(bar_for_foo_mixin):</code> I am computing a operation <code>self.Z = X+Y</code> in <code>bar()</code> method of superclass.</p>
<p>Now I want the self.z = 0 updated to the computation done in bar() method and inheirt this value to the subclass <code>myfoo(bar_for_foo_mixin):</code> and use it inside subclass.</p>
<pre><code>class bar_for_foo_mixin():
    def __init__(self):
        self.z = 0

    def bar(self, q):
        x = 2
        y = 8
        self.z = x + y + q


class oldfoo():
    def __init__(self):
        pass

    var = bar_for_foo_mixin()
    var.bar(10)


class myfoo(bar_for_foo_mixin):
    def __init__(self):
        super(myfoo, self).__init__()

    def hello(self):
        print("hello", self.z)


final = myfoo()
final.hello()
</code></pre>
<p>Result of the code:</p>
<pre><code>hello 0
</code></pre>
<p>Expected result:</p>
<pre><code>hello 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>bar_for_foo_mixin</code> instance stored in your <code>oldfoo.var</code> class variable is a completely separate instance from the <code>myfoo</code> object you instantiated in the main program, so their instance variable <code>z</code> would not be shared.</p>
<p>If you would like a variable to be shared across all instances of a class, you should make it a class variable instead, and make methods that are dedicated to updating class variables, such as <code>bar_for_foo_mixin.bar</code>, a class method instead:</p>
<pre><code>class bar_for_foo_mixin():
    z = 0

    @classmethod
    def bar(cls, q):
        x = 2
        y = 8
        cls.z = x + y + q


class oldfoo():
    def __init__(self):
        pass

    var = bar_for_foo_mixin()
    var.bar(10)


class myfoo(bar_for_foo_mixin):
    def __init__(self):
        super(myfoo, self).__init__()

    def hello(self):
        print("hello", self.z)

final = myfoo()
final.hello()
</code></pre>
<p>This outputs:</p>
<pre><code>hello 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're not even calling the <code>bar</code> method by the new <code>final</code> variable:</p>
<pre><code>class bar_for_foo_mixin():
    def __init__(self):
        self.z = 0

    def bar(self, q):
        x = 2
        y = 8
        self.z = x + y + q

class myfoo(bar_for_foo_mixin):
    def __init__(self):
        super(myfoo, self).__init__()

    def hello(self):
        print("hello", self.z)

final = myfoo()
final.bar(10) # &lt;== call it to take effect
final.hello() # ==&gt; hello 20
</code></pre>
</div>
<span class="comment-copy">So I need to make it as a classmethod. Thanks @blhsing</span>
<span class="comment-copy">I am new to this OOP, Is there a way that I can call the bar method in oldfoo(): class with argument 10 and compute the z and store it  to a variable and pass the stored value to subclass myfoo():</span>
<span class="comment-copy">@VamsiNimmala Methods are called per object, the <code>z</code> attribute will be different for each instance, e.g.: creating instances <code>a = myfoo()</code>, <code>b = myfoo()</code> and <code>c = myfoo()</code>, then calling <code>bar</code> on each <code>a.bar(10); b.bar(20); c.bar(30)</code> (with different values), calling <code>hello</code> method then will show that they each have a different value for the <code>z</code> attribute: <code>a.hello(); b.hello(); c.hello()</code> results in <code>hello 20</code>, <code>hello 30</code> and <code>hello 40</code>.</span>
