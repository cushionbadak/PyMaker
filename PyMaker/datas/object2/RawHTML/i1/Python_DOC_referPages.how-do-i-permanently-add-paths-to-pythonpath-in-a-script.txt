<div class="post-text" itemprop="text">
<p>I've tried reading through questions about sibling imports and even the
<a href="http://docs.python.org/tutorial/modules.html#intra-package-references" rel="noreferrer">package documentation</a>, but I've yet to find an answer.</p>
<p>With the following structure:</p>
<pre><code>├── LICENSE.md
├── README.md
├── api
│   ├── __init__.py
│   ├── api.py
│   └── api_key.py
├── examples
│   ├── __init__.py
│   ├── example_one.py
│   └── example_two.py
└── tests
│   ├── __init__.py
│   └── test_one.py
</code></pre>
<p>How can the scripts in the  <code>examples</code> and <code>tests</code> directories import from the
<code>api</code> module and be run from the commandline?</p>
<p>Also, I'd like to avoid the ugly <code>sys.path.insert</code> hack for every file. Surely
this can be done in Python, right?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Seven years after</h2>
<p>Since I wrote the answer below, modifying <code>sys.path</code> is still a quick-and-dirty trick that works well for private scripts, but there has been several improvements</p>
<ul>
<li><a href="https://stackoverflow.com/a/50193944/760767">Installing</a> the package (in a virtualenv or not) will give you what you want, though I would suggest using pip to do it rather than using setuptools directly (and using <code>setup.cfg</code> to store the metadata)</li>
<li><a href="https://stackoverflow.com/a/23542795/760767">Using the <code>-m</code> flag</a> and running as a package works too (but will turn out a bit awkward if you want to convert your working directory into an installable package).</li>
<li>For the tests, specifically, <a href="https://pytest.org" rel="noreferrer">pytest</a> is able to find the api package in this situation and takes care of the <code>sys.path</code> hacks for you</li>
</ul>
<p>So it really depends on what you want to do. In your case, though, since it seems that your goal is to make a proper package at some point, installing through <code>pip -e</code> is probably your best bet, even if it is not perfect yet.</p>
<h2>Old answer</h2>
<p>As already stated elsewhere, the awful truth is that you have to do ugly hacks to allow imports from siblings modules or parents package from a <code>__main__</code> module. The issue is detailed in <a href="http://www.python.org/dev/peps/pep-0366/" rel="noreferrer">PEP 366</a>. <a href="http://www.python.org/dev/peps/pep-3122/" rel="noreferrer">PEP 3122</a> attempted to handle imports in a more rational way but Guido has rejected it one the account of</p>
<blockquote>
<p>The only use case seems to be running scripts that happen
  to be living inside a module's directory, which I've always seen as an
  antipattern.</p>
</blockquote>
<p>(<a href="http://mail.python.org/pipermail/python-3000/2007-April/006793.html" rel="noreferrer">here</a>)</p>
<p>Though, I use this pattern on a regular basis with</p>
<pre><code># Ugly hack to allow absolute import from the root folder
# whatever its name is. Please forgive the heresy.
if __name__ == "__main__" and __package__ is None:
    from sys import path
    from os.path import dirname as dir

    path.append(dir(path[0]))
    __package__ = "examples"

import api
</code></pre>
<p>Here <code>path[0]</code> is your running script's parent folder and <code>dir(path[0])</code> your top level folder.</p>
<p>I have still not been able to use relative imports with this, though, but it does allow absolute imports from the top level (in your example <code>api</code>'s parent folder).</p>
</div>
<div class="post-text" itemprop="text">
<h1>Tired on sys.path hacks?</h1>
<p>There are plenty of <code>sys.path.append</code> -hacks available, but I found an alternative way of solving the problem in hand: The <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html" rel="nofollow noreferrer">setuptools</a>. I am not sure if there are edge cases which do not work well with this. The following is tested with Python 3.6.5, (Anaconda, conda 4.5.1), Windows 10 machine.</p>
<hr/>
<h1>Setup</h1>
<p>The starting point is the file structure you have provided, wrapped in a folder called <code>myproject</code>.</p>
<pre><code>.
└── myproject
    ├── api
    │   ├── api_key.py
    │   ├── api.py
    │   └── __init__.py
    ├── examples
    │   ├── example_one.py
    │   ├── example_two.py
    │   └── __init__.py
    ├── LICENCE.md
    ├── README.md
    └── tests
        ├── __init__.py
        └── test_one.py
</code></pre>
<p>I will call the <code>.</code> the root folder, and in my example case it is located at <code>C:\tmp\test_imports\</code>.</p>
<h2>api.py</h2>
<p>As a test case, let's use the following ./api/api.py</p>
<pre><code>def function_from_api():
    return 'I am the return value from api.api!'
</code></pre>
<h2>test_one.py</h2>
<pre><code>from api.api import function_from_api

def test_function():
    print(function_from_api())

if __name__ == '__main__':
    test_function()
</code></pre>
<h2>Try to run test_one:</h2>
<pre><code>PS C:\tmp\test_imports&gt; python .\myproject\tests\test_one.py
Traceback (most recent call last):
  File ".\myproject\tests\test_one.py", line 1, in &lt;module&gt;
    from api.api import function_from_api
ModuleNotFoundError: No module named 'api'
</code></pre>
<h2>Also trying relative imports wont work:</h2>
<p>Using <code>from ..api.api import function_from_api</code> would result into</p>
<pre><code>PS C:\tmp\test_imports&gt; python .\myproject\tests\test_one.py
Traceback (most recent call last):
  File ".\tests\test_one.py", line 1, in &lt;module&gt;
    from ..api.api import function_from_api
ValueError: attempted relative import beyond top-level package
</code></pre>
<hr/>
<h1>Steps</h1>
<h2>1) Make a setup.py file to the root level directory</h2>
<p>The contents for the <code>setup.py</code> would be*</p>
<pre><code>from setuptools import setup, find_packages

setup(name='myproject', version='1.0', packages=find_packages())
</code></pre>
<h2>2) Use a virtual environment</h2>
<p><em>If you are familiar with virtual environments, activate one, and skip to the next step.</em> Usage of virtual environments are not <em>absolutely</em> required, but they will <em>really</em> help you out in the long run (when you have more than 1 project ongoing..). The most basic steps are (run in the root folder)</p>
<ul>
<li>Create virtual env

<ul>
<li><code>python -m venv venv</code></li>
</ul></li>
<li>Activate virtual env

<ul>
<li><code>source ./venv/bin/activate</code> (Linux, macOS) or <code>./venv/Scripts/activate</code> (Win)</li>
</ul></li>
</ul>
<p>To learn more about this, just Google out "python virtual env tutorial" or similar. You probably never need any other commands than creating, activating and deactivating. </p>
<p>Once you have made and activated a virtual environment, your console should give the name of the virtual environment in parenthesis</p>
<pre><code>PS C:\tmp\test_imports&gt; python -m venv venv
PS C:\tmp\test_imports&gt; .\venv\Scripts\activate
(venv) PS C:\tmp\test_imports&gt;
</code></pre>
<p>and your folder tree should look like this**</p>
<pre><code>.
├── myproject
│   ├── api
│   │   ├── api_key.py
│   │   ├── api.py
│   │   └── __init__.py
│   ├── examples
│   │   ├── example_one.py
│   │   ├── example_two.py
│   │   └── __init__.py
│   ├── LICENCE.md
│   ├── README.md
│   └── tests
│       ├── __init__.py
│       └── test_one.py
├── setup.py
└── venv
    ├── Include
    ├── Lib
    ├── pyvenv.cfg
    └── Scripts [87 entries exceeds filelimit, not opening dir]
</code></pre>
<h2>3) pip install your project in editable state</h2>
<p>Install your top level package <code>myproject</code> using <code>pip</code>. The trick is to use the <code>-e</code> flag when doing the install. This way it is installed in an editable state, and all the edits made to the .py files will be automatically included in the installed package. </p>
<p>In the root directory, run</p>
<p><code>pip install -e .</code> (note the dot, it stands for "current directory")</p>
<p>You can also see that it is installed by using <code>pip freeze</code></p>
<pre><code>(venv) PS C:\tmp\test_imports&gt; pip install -e .
Obtaining file:///C:/tmp/test_imports
Installing collected packages: myproject
  Running setup.py develop for myproject
Successfully installed myproject
(venv) PS C:\tmp\test_imports&gt; pip freeze
myproject==1.0
</code></pre>
<h2>4) Add <code>myproject.</code> into your imports</h2>
<p>Note that you will have to add <code>myproject.</code> only into imports that would not work otherwise. Imports that worked without the <code>setup.py</code> &amp; <code>pip install</code> will work still work fine. See an example below.</p>
<hr/>
<h1>Test the solution</h1>
<p>Now, let's test the solution using <code>api.py</code> defined above, and <code>test_one.py</code> defined below.</p>
<h2>test_one.py</h2>
<pre><code>from myproject.api.api import function_from_api

def test_function():
    print(function_from_api())

if __name__ == '__main__':
    test_function()
</code></pre>
<h2>running the test</h2>
<pre><code>(venv) PS C:\tmp\test_imports&gt; python .\myproject\tests\test_one.py
I am the return value from api.api!
</code></pre>
<hr/>
<p>* See the <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html" rel="nofollow noreferrer">setuptools docs</a> for more verbose setup.py examples.</p>
<p>** In reality, you could put your virtual environment anywhere on your hard disk.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another alternative that I insert at top of the Python files in <code>tests</code> folder:</p>
<pre><code># Path hack.
import sys, os
sys.path.insert(0, os.path.abspath('..'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need and shouldn't hack <code>sys.path</code> unless it is necessary and in this case it is not. Use:</p>
<pre><code>import api.api_key # in tests, examples
</code></pre>
<p>Run from the project directory: <code>python -m tests.test_one</code>.</p>
<p>You should probably move <code>tests</code> (if they are api's unittests) inside <code>api</code> and run <code>python -m api.test</code> to run all tests (assuming there is <code>__main__.py</code>) or <code>python -m api.test.test_one</code> to run <code>test_one</code> instead. </p>
<p>You could also remove <code>__init__.py</code> from <code>examples</code> (it is not a Python package) and run the examples in a virtualenv where <code>api</code> is installed e.g., <code>pip install -e .</code> in a virtualenv would install inplace <code>api</code> package if you have proper <code>setup.py</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't yet have the comprehension of Pythonology necessary to see the intended way of sharing code amongst unrelated projects without a sibling/relative import hack.  Until that day, this is my solution.  For <code>examples</code> or <code>tests</code> to import stuff from <code>..\api</code>, it would look like: </p>
<pre><code>import sys.path
import os.path
# Import from sibling directory ..\api
sys.path.append(os.path.dirname(os.path.abspath(__file__)) + "/..")
import api.api
import api.api_key
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For siblings package imports, you can use either the <em>insert</em> or the <em>append</em> method of the <em>[sys.path][2]</em> module:</p>
<pre><code>if __name__ == '__main__' and if __package__ is None:
    import sys
    from os import path
    sys.path.append( path.dirname( path.dirname( path.abspath(__file__) ) ) )
    import api
</code></pre>
<p>This will work if you are launching your scripts as follows:</p>
<pre><code>python examples/example_one.py
python tests/test_one.py
</code></pre>
<p>On the other hand, you can also use the relative import:</p>
<pre><code>if __name__ == '__main__' and if __package__ is not None:
    import ..api.api
</code></pre>
<p>In this case you will have to launch your script with the <a href="https://docs.python.org/2/using/cmdline.html#cmdoption-m" rel="nofollow">'-m' argument</a> (note that, in this case, you must not give the <em>'.py'</em> extension):</p>
<pre><code>python -m packageName.examples.example_one
python -m packageName.tests.test_one
</code></pre>
<p>Of course, you can mix the two approaches, so that your script will work no matter how it is called:</p>
<pre><code>if __name__ == '__main__':
    if __package__ is None:
        import sys
        from os import path
        sys.path.append( path.dirname( path.dirname( path.abspath(__file__) ) ) )
        import api
    else:
        import ..api.api
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just in case someone using Pydev on Eclipse end up here: you can add the sibling's parent path (and thus the calling module's parent) as an external library folder using <em>Project-&gt;Properties</em> and setting <em>External Libraries</em> under the left menu <em>Pydev-PYTHONPATH</em>. Then you can import from your sibling, e. g. <code>from sibling import some_class</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to look to see how the import statements are written in the related code.  If <code>examples/example_one.py</code> uses the following import statement:</p>
<pre><code>import api.api
</code></pre>
<p>...then it expects the root directory of the project to be in the system path.</p>
<p>The easiest way to support this without any hacks (as you put it) would be to run the examples from the top level directory, like this:</p>
<pre><code>PYTHONPATH=$PYTHONPATH:. python examples/example_one.py 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>TLDR</strong></p>
<p>This method does not require setuptools, path hacks, additional command line arguments, or specifying the top level of the package in every single file of your project.</p>
<p>Just make a script in the parent directory of whatever your are calling to be your <code>__main__</code> and run everything from there.  For further explanation continue reading.</p>
<p><strong>Explanation</strong></p>
<p>This can be accomplished without hacking a new path together, extra command line args, or adding code to each of your programs to recognize its siblings.</p>
<p>The reason this fails as I believe was mentioned before is the programs being called have their <code>__name__</code> set as <code>__main__</code>.  When this occurs the script being called accepts itself to be on the top level of the package and refuses to recognize scripts in sibling directories.</p>
<p>However, everything under the top level of the directory will still recognize <strong>ANYTHING ELSE</strong> under the top level.  This means the <strong>ONLY</strong> thing you have to do to get files in sibling directories to recognize/utilize each other is to call them from a script in their parent directory.</p>
<p><strong>Proof of Concept</strong>
In a dir with the following structure:</p>
<pre><code>.
|__Main.py
|
|__Siblings
   |
   |___sib1
   |   |
   |   |__call.py
   |
   |___sib2
       |
       |__callsib.py
</code></pre>
<p><code>Main.py</code> contains the following code:</p>
<pre><code>import sib1.call as call


def main():
    call.Call()


if __name__ == '__main__':
    main()
</code></pre>
<p>sib1/call.py contains:</p>
<pre><code>import sib2.callsib as callsib


def Call():
    callsib.CallSib()


if __name__ == '__main__':
    Call()
</code></pre>
<p>and sib2/callsib.py contains:</p>
<pre><code>def CallSib():
    print("Got Called")

if __name__ == '__main__':
    CallSib()
</code></pre>
<p>If you reproduce this example you will notice that calling <code>Main.py</code> will result in "Got Called" being printed as is defined in <code>sib2/callsib.py</code>  even though <code>sib2/callsib.py</code> got called through <code>sib1/call.py</code>.  However if one were to directly call <code>sib1/call.py</code> (after making appropriate changes to the imports) it throws an exception.  Even though it worked when called by the script in its parent directory, it will not work if it believes itself to be on the top level of the package.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you should avoid having files with the same name as the module itself. It may break other imports.</p>
<p>When you import a file, first the interpreter checks the current directory and then searchs global directories.</p>
<p>Inside <code>examples</code> or <code>tests</code> you can call:</p>
<pre><code>from ..api import api
</code></pre>
</div>
<span class="comment-copy">I recommend skipping past all the <code>sys.path</code> hacks and reading <a href="https://stackoverflow.com/a/50193944/1222951">the only actual <i>solution</i></a> that's been posted thus far (after 7 years!).</span>
<span class="comment-copy">By the way, there's still room for another good solution: Separating executable code from library code; most of the time a script inside a package shouldn't <i>be</i> executable to begin with.</span>
<span class="comment-copy">This is so helpful, both the question and the answers. I am just curious, how come "Accepted Answer" is not the same as the one awarded the bounty in this case?</span>
<span class="comment-copy">Also works with path.append('..')</span>
<span class="comment-copy">you don't <i>have to</i> if you <a href="http://stackoverflow.com/a/23542795/4279">run from a project directory using <code>-m</code> form or if you install the package</a> (pip and virtualenv make it easy)</span>
<span class="comment-copy">How does pytest find the api package for you? Amusingly, I found this thread because I'm running into this problem specifically with pytest and sibling package importing.</span>
<span class="comment-copy">Thanks for the detailed post. Here is my problem. If I do everything you said and I do a pip freeze, I get a line <code>-e git+https://username@bitbucket.org/folder/myproject.git@f65466656XXXXX#egg=myproject</code> Any Idea on how to resolve?</span>
<span class="comment-copy">Why doesn't the relative import solution work? I believe you, but I'm trying to understand Python's convoluted system.</span>
<span class="comment-copy">I have not digged into this so deeply to understand <i>why</i> it does not work; I just see that relative imports beyond top-level package are not allowed. I have also noticed that making pip-installable packages out of my python packages/apps have made my python experience better. But that's of course very subjective :)</span>
<span class="comment-copy">+1 really simple and it worked perfectly. You need to add the parent class to the import (ex api.api, examples.example_two) but I prefer it that way.</span>
<span class="comment-copy">I think it's worth mentioning to newbies (like myself) that <code>..</code> here is relative to the directory you're executing from---not the directory containing that test/example file. I'm executing from the project directory, and I needed <code>./</code> instead. Hope this helps someone else.</span>
<span class="comment-copy">@JoshDetwiler, yes absoluely. I was not aware of that. Thanks.</span>
<span class="comment-copy">what if tests are not unittests for api?</span>
<span class="comment-copy">@Alex the answer does not assume that tests are API tests <i>except</i> for the paragraph where it says  explicitly <i>"if they are api's unittests"</i>.</span>
<span class="comment-copy">unfortunately then you are stuck with running from root dir and PyCharm still does not find the file for its nice functions</span>
<span class="comment-copy">@mhstnsc: it is not correct. You should be able to run <code>python -m api.test.test_one</code> from anywhere when the virtualenv is activated. If you can't configure PyCharm to run your tests, try to ask a new Stack Overflow question (if you can't find an existing question on this topic).</span>
<span class="comment-copy">@jfs I missed the virtual env path but i don't want to use anything more than shebang line to run this stuff from any directory ever. Its not about running with PyCharm. Devs with PyCharm would know also they have completion and jump through functions which i could not make it work with any solution.</span>
<span class="comment-copy">This would still give you the api parent directory and you wouldn't need the "/.." concatenation  sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(<b>file</b>))))</span>
<span class="comment-copy">I was using the Click framework which doesn't have the <code>__file__</code> global so I had to use the following: <code>sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0]))))</code> But it works in any directory now</span>
<span class="comment-copy">With Python 2.7.1 I get the following: <code>$  python examples/example.py  Traceback (most recent call last):   File "examples/example.py", line 3, in &lt;module&gt;     from api.api import API ImportError: No module named api.api</code>. I also get the same with <code>import api.api</code>.</span>
<span class="comment-copy">Updated my answer...you <b>do</b> have to add the current directory to the import path, no way around that.</span>
<span class="comment-copy">I get the following with Python 2.7.1: <code>Traceback (most recent call last):   File "example_one.py", line 3, in &lt;module&gt;     from ..api import api ValueError: Attempted relative import in non-package</code></span>
<span class="comment-copy">Oh, then you should add a <code>__init__.py</code> file to the top level directory. Otherwise Python can't treat it as a module</span>
<span class="comment-copy">It won't work. The issue is not that the parent folder is not a package, it is that since the module's <code>__name__</code> is <code>__main__</code> instead of <code>package.module</code>, Python can't see its parent package, so <code>.</code> points to nothing.</span>
