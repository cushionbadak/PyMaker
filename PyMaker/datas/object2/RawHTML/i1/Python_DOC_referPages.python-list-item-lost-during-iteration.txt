<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1207406/how-to-remove-items-from-a-list-while-iterating">How to remove items from a list while iterating?</a>
<span class="question-originals-answer-count">
                    23 answers
                </span>
</li>
</ul>
</div>
<p>I've been trying to figure out why I lose the second item in my list each time I iterate through it.</p>
<pre><code>def main():
    _data = [0,1,3,0,5,5]
    print(_data)
    # Convert items in the list into strings
    for item in _data:
        item = str(item)
        print(item)
        _data.append(item)
        _data.pop(0)
    print(_data)
main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best you can expect when changing an object you're iterating over is unexpected behaviour.</p>
<p>Create a second, empty list and add the elements converted as strings from the first list to the second, in order to avoid this.</p>
</div>
<span class="comment-copy"><code>_data.pop(0)</code> won't update the <code>for item in _data:</code> iterator position, which advances from <code>index</code> to <code>index + 1</code> each step. <code>_data.pop(0)</code> means all remaining elements have shifted position from <code>index</code> to <code>index - 1</code>, so effectively what was at <code>index + 1</code> before is now at <code>index</code> and is skipped. Don't iterate and delete at the same time!</span>
<span class="comment-copy">what exactly are you trying to do</span>
<span class="comment-copy">Fwiw, you can get the result you want (convert items to strings) with <code>_data = list(map(str, _data))</code>, or if you prefer list comprehensions <code>_data = [str(item) for item in _data]</code>. Both of these actually create a new list instead of editing the existing one in place, but that is most times the best practice for these cases (you could also iterate index values and change elements in place, but it's usually less idiomatic).</span>
<span class="comment-copy">Not  that you need to delete anything. If you want to update <code>_data</code> in place, use <code>_data[:] = [str(item) for item in _data]</code>, or just assign to the index with <code>for i, item in enumerate(_data): _data[i] = str(item)</code>.</span>
<span class="comment-copy">@jdehesa: it can't be optimised, a new list is created. The slice assignment does then know not to just empty the current list, but to copy across the references (it has a new list to reference and compare item count with).</span>
<span class="comment-copy">They don't need to create a second list <i>at all</i>, because they don't need to delete anything. They are simply replacing all items with their <code>str()</code> conversion, in a very inefficient manner (quadratic time, doubling the list length takes 4 times as long to process).</span>
