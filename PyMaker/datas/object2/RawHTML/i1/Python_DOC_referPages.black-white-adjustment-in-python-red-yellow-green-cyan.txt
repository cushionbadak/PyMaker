<div class="post-text" itemprop="text">
<p>I did lot's of research but I didn't find anything (but I also don't know what kind of keywords to search for exactly). I want to be able to convert an input <strong>RGB</strong> image to <strong>grayscale</strong> but I want to be able to add more or less <strong>Reds/Yellows/Greens/Cyans/Blues/Magentas</strong> like in <strong>Photoshop</strong>. Do you know what are the equation or where I can found these equations so that I can implemented my own optimized RGB to Grayscale conversion?</p>
<p><strong>Edit</strong>:
In Photoshop it is called <strong>Black/White adjustment layer</strong>. I have found something but actually it doesn't seem to work. Here is my implementation (in comments are the resources needed to understand the algorithm):</p>
<pre class="lang-py prettyprint-override"><code>import numpy as np
import scipy.misc
import matplotlib.pyplot as plt


%matplotlib inline

# Adapted from the answers of Ivan Kuckir and Royi here:
# https://dsp.stackexchange.com/questions/688/what-is-the-algorithm-behind-photoshops-black-and-white-adjustment-layer?newreg=77420cc185fd44099d8be961e736eb0c

def rgb2hls(img):
    """Adapted to use numpy from
       https://github.com/python/cpython/blob/2.7/Lib/colorsys.py"""
    r, g, b = img[:, :, 0], img[:, :, 1], img[:, :, 2]

    maxc = np.max(img, axis=-1)
    minc = np.min(img, axis=-1)
    l = (minc + maxc) / 2

    mask = np.ones_like(r)
    mask[np.where(minc == maxc)] = 0
    mask = mask.astype(np.bool)

    smask = np.greater(l, 0.5).astype(np.float32)

    s = (1.0 - smask) * ((maxc - minc) / (maxc + minc)) + smask * ((maxc - minc) / (2.0 - maxc - minc))
    s[~mask] = 0
    rc = np.where(mask, (maxc - r) / (maxc - minc), 0)
    gc = np.where(mask, (maxc - g) / (maxc - minc), 0)
    bc = np.where(mask, (maxc - b) / (maxc - minc), 0)

    rmask = np.equal(r, maxc).astype(np.float32)
    gmask = np.equal(g, maxc).astype(np.float32)
    rgmask = np.logical_or(rmask, gmask).astype(np.float32)

    h = rmask * (bc - gc) + gmask * (2.0 + rc - bc) + (1.0 - rgmask) * (4.0 + gc - rc)
    h = np.remainder(h / 6.0, 1.0)
    h[~mask] = 0
    return np.stack([h, l, s], axis=-1)


def black_and_white_adjustment(image, weights):  
    # normalize input image to (0, 1) if uint8
    if 'uint8' in (image).dtype.name:
        image = image / 255

    # linearly remap input coeff [-200, 300] to [-2.5, 2.5]
    weights = (weights - 50) / 100
    n_weights = len(weights)
    h, w = image.shape[:2]

    # convert rgb to hls
    hls_img = rgb2hls(image)

    output = np.zeros((h, w), dtype=np.float32)

    # see figure 9 of https://en.wikipedia.org/wiki/HSL_and_HSV
    # to understand the algorithm
    for y in range(h):
        for x in range(w):
            hue_val = 6 * hls_img[y, x, 0]

            # Use distance on a hexagone (maybe circular distance is better?)
            diff_val = min(abs(0 - hue_val), abs(1 - (0 - hue_val)))
            luminance_coeff = weights[0] * max(0, 1 - diff_val)

            for k in range(1, n_weights):
                luminance_coeff += weights[k] * max(0, 1 - abs(k - hue_val))

            # output[y, x] = min(max(hls_img[y, x, 1] * (1 + luminance_coeff), 0), 1)
            output[y, x] = hls_img[y, x, 1] * (1 + luminance_coeff)


    return output


image = scipy.misc.imread("your_image_here.png")
w = np.array([40, 85, 204, 60, 20, 80])
out = black_and_white_adjustment(image, w)
plt.figure(figsize=(15, 20))
plt.imshow(out, cmap='gray')
</code></pre>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an attempt using <code>PIL</code> rather than <code>numpy</code>. It should be easy to convert. Without a copy of Photoshop to compare with, I can't guarantee it matches the output exactly but it does produce the exact values for the sample shown in your link. The values <code>r_w, y_w, g_w, c_w, b_w, m_w</code> are the weights to be applied to each color, with 1.0 equating to 100% in the corresponding Photoshop slider. Naturally they can also be negative.</p>
<pre><code>from PIL import Image
im = Image.open(r'c:\temp\temp.png')
def ps_black_and_white(im, weights):
    r_w, y_w, g_w, c_w, b_w, m_w = [w/100 for w in weights]
    im = im.convert('RGB')
    pix = im.load()
    for y in range(im.size[1]):
        for x in range(im.size[0]):
            r, g, b = pix[x, y]
            gray = min([r, g, b])
            r -= gray
            g -= gray
            b -= gray
            if r == 0:
                cyan = min(g, b)
                g -= cyan
                b -= cyan
                gray += cyan * c_w + g * g_w + b * b_w
            elif g == 0:
                magenta = min(r, b)
                r -= magenta
                b -= magenta
                gray += magenta * m_w + r * r_w + b * b_w
            else:
                yellow = min(r, g)
                r -= yellow
                g -= yellow
                gray += yellow * y_w + r * r_w + g * g_w
            gray = max(0, min(255, int(round(gray))))
            pix[x, y] = (gray, gray, gray)
    return im
</code></pre>
<p>Using this provided test image, here are some example results.</p>
<p><a href="https://i.stack.imgur.com/Loocz.png" rel="nofollow noreferrer"><img alt="color test image" src="https://i.stack.imgur.com/Loocz.png"/></a></p>
<pre><code>ps_black_and_white(im, [-17, 300, -100, 300, -200, 300])
</code></pre>
<p><a href="https://i.stack.imgur.com/6zeeN.png" rel="nofollow noreferrer"><img alt="-17, 300, -100, 300, -200, 300" src="https://i.stack.imgur.com/6zeeN.png"/></a></p>
<pre><code>ps_black_and_white(im, [40, 60, 40, 60, 20, 80])
</code></pre>
<p><a href="https://i.stack.imgur.com/Md2bR.png" rel="nofollow noreferrer"><img alt="40, 60, 40, 60, 20, 80" src="https://i.stack.imgur.com/Md2bR.png"/></a></p>
<pre><code>ps_black_and_white(im, [106, 65, 17, 17, 104, 19])
</code></pre>
<p><a href="https://i.stack.imgur.com/ginw0.png" rel="nofollow noreferrer"><img alt="106, 65, 17, 17, 104, 19" src="https://i.stack.imgur.com/ginw0.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I answer my own question by adding the <strong>numpy/scipy</strong> version of the code, if it can be of any interest for anybody in the future. <strong>If you want to upvote an answer, you should upvote the answer of Mark Ransom !</strong></p>
<pre class="lang-py prettyprint-override"><code>import numpy as np
import scipy.misc
import matplotlib.pyplot as plt

%matplotlib inline

def black_and_white_adjustment(img, weights):
    rw, yw, gw, cw, bw, mw = weights / 100

    h, w = img.shape[:2]
    min_c = np.min(img, axis=-1).astype(np.float)
    # max_c = np.max(img, axis=-1).astype(np.float)

    # Can try different definitions as explained in the Ligtness section from
    # https://en.wikipedia.org/wiki/HSL_and_HSV
    # like: luminance = (min_c + max_c) / 2 ...
    luminance = min_c 
    diff = img - min_c[:, :, None]

    red_mask = (diff[:, :, 0] == 0)
    green_mask = np.logical_and((diff[:, :, 1] == 0), ~red_mask)
    blue_mask = ~np.logical_or(red_mask, green_mask)

    c = np.min(diff[:, :, 1:], axis=-1)
    m = np.min(diff[:, :, [0, 2]], axis=-1)
    yel = np.min(diff[:, :, :2], axis=-1)

    luminance = luminance + red_mask * (c * cw + (diff[:, :, 1] - c) * gw + (diff[:, :, 2] - c) * bw) \
                + green_mask * (m * mw + (diff[:, :, 0] - m) * rw + (diff[:, :, 2] - m) * bw)  \
                + blue_mask * (yel * yw + (diff[:, :, 0] - yel) * rw + (diff[:, :, 1] - yel) * gw)

    return np.clip(luminance, 0, 255).astype(np.uint8)

input_img = scipy.misc.imread("palette.jpg")

weights = np.array([106, 65, 17, 17, 104, 19])
bw_image = black_and_white_adjustment(input_img, weights)

plt.figure(figsize=(15, 20))
plt.imshow(bw_image, cmap="gray")
</code></pre>
<p>This code is faster as it uses vect operations.</p>
</div>
<span class="comment-copy">As in selective color or blending into a range of pixels?</span>
<span class="comment-copy">As an example to understand the question more precisely. You can use <b>photopea</b>. A photoshop free tool online. You load an image and then go to <b>Image</b> -&gt; <b>Adjustment</b> -&gt; <b>Black/White</b>. There you have 6 cursors and you can adjust cyan/blue/magenta/yellow/... I'm wondering how I can code such a thing? I don't know what to look for to start</span>
<span class="comment-copy">Sorry for the late response, this should be possible with PILLOW the forked Python Imaging Library. I'm working on an example and will post it as an answer once complete. In the mean time <a href="https://pillow.readthedocs.io/en/3.0.0/index.html" rel="nofollow noreferrer">here</a> is the docs if you wish to look yourself</span>
<span class="comment-copy">I found somebody that asked the same question. Apparently the developer of Photopea answered the question (<a href="https://dsp.stackexchange.com/questions/688/what-is-the-algorithm-behind-photoshops-black-and-white-adjustment-layer?newreg=77420cc185fd44099d8be961e736eb0c" title="what is the algorithm behind photoshops black and white adjustment layer">dsp.stackexchange.com/questions/688/â€¦</a>). I have reimplemented what he said in python (I also used the answer of Royi and matlab) but the output doesn't match the output of photopea</span>
<span class="comment-copy">Can you add your adaptation to your answer?</span>
<span class="comment-copy"><b>Thank you</b> !! It actually works quite well (even though it doesn't perfectly match the result in Photoshop). I have tried different definitions of the lightness (the variable you named <code>gray</code> in your code) but I couldn't make it matches perfectly Photoshop. I also translated your code using <code>numpy</code> and <code>scipy</code>. I will wait a bit. If nobody can figure out how to perfectly match Photoshop I will accept your answer. I will also post the code that uses <code>numpy</code></span>
<span class="comment-copy">@priseJack if you can post a picture with a bunch of color squares that don't match, I can tweak this formula.</span>
<span class="comment-copy">I don't have photoshop here. I will do tomorrow and update this comment with a link to some results. Thanks a lot</span>
<span class="comment-copy">@priseJack I made a change that <i>might</i> fix it, I added the two lines with <code>grayw</code>. It's rough when neither of us has the ability to compare the results!</span>
<span class="comment-copy">Hello. I tried with the change you have made on my palette. It is worse. So I uploaded a comparison between photoshop and your algorithm (first version). Everything is here: <a href="https://imgur.com/a/nKLVcMR" rel="nofollow noreferrer">imgur.com/a/nKLVcMR</a></span>
