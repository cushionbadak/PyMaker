<div class="post-text" itemprop="text">
<p>I have made a function that makes histograms plot the way I like it (with error bars!).</p>
<pre><code>def histoPlot(h,fmt='.',lighter_error=0.75,**kwargs):
#fig, ax = plt.subplots(1)
ax = plt.axes()
# Get the current color in the cycle     #https://stackoverflow.com/questions/28779559/how-to-set-same-color-for-markers-and-lines-in-a-matplotlib-plot-loop

color = next(ax._get_lines.prop_cycler)['color']
if all(h.uncertainties != None):
    # plot the error bar https://matplotlib.org/gallery/statistics/errorbar_features.html?highlight=error%20plot
    ax.errorbar(u.midpoints(h.bins), h.counts, yerr=h.uncertainties,color = lighten_color(color,lighter_error),fmt=fmt )
# plot the histogram
ax.step(h.bins,np.append(h.counts,h.counts[-1:]),where='post',color=color,**kwargs)
</code></pre>
<p>This is perfect for me now, I can use it to make a complex plot in a simple line</p>
<p><code>histoPlot(histo1,fmt=',')</code></p>
<p>I can also stack one plot upon the other by putting two lines in the same cell</p>
<pre><code>histoPlot(histo1,fmt=',')`
histoPlot(histo2,fmt=',')
</code></pre>
<p>but I get a warning</p>
<pre><code>MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
  warnings.warn(message, mplDeprecation, stacklevel=1)
</code></pre>
<p>I have been able to send away the warning (following <a href="https://stackoverflow.com/questions/46933824/matplotlib-adding-an-axes-using-the-same-arguments-as-a-previous-axes">Matplotlib: Adding an axes using the same arguments as a previous axes</a>), but only at the price of making my function fail to be stackable. That is to say that each call of the function makes a new frame with a new plot. How can I get rid of this warning and still be able to stack my plots?</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual way would be by returning the axes</p>
<pre class="lang-py prettyprint-override"><code>def histoPlot(h,fmt='.',lighter_error=0.75, ax=None, **kwargs):
    #fig, ax = plt.subplots(1)
    if ax is None:
        ax = plt.axes()
    # ...
    return ax

ax = histoPlot(histo1,fmt=',')
histoPlot(histo2,fmt=',', ax=ax)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are defining a new axis object every time inside your function using <code>ax = plt.axes()</code>. If you want to plot all the histograms in the same figure, you will have to pass that particular axis object. Below is a sample answer explaining this</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np; np.random.seed(121)

fig, ax = plt.subplots()

def histoPlot(ax):
    ax.hist(np.random.normal(0, 1, 1000), bins=100)

histoPlot(ax)
histoPlot(ax)
histoPlot(ax)
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/8ZFDT.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/8ZFDT.png"/></a></p>
</div>
<span class="comment-copy">Very clear and to the point. Thanks you!</span>
<span class="comment-copy">I actually prefer this answer to mine (we cross-posted), but made mine more <code>pyplot-ish</code>...</span>
