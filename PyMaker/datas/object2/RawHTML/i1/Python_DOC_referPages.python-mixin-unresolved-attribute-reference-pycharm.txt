<div class="post-text" itemprop="text">
<p>I am using a mixin to separate a range of functionality to a different class. This Mixin is only supposed to be mixable with the only child class:</p>
<pre><code>class Mixin:
    def complex_operation(self):
        return self.foo.capitalize()

class A(Mixin):
    def __init__(self):
        self.foo = 'foo'
</code></pre>
<p>in my method <code>Mixin.complex_operation</code> PyCharm gives warning 'Unresolved Attribute Reference foo'. </p>
<p>Am I using the mixin pattern correctly? <strong>Is there a better way?</strong> (I would like to have type hints and autocompletion in my mixins, and I would like to have multiple mixins.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Declare the necesary fields in the Mixin like:</p>
<pre><code>class Mixin:
    foo = None
    def complex_operation(self):
        return self.foo.capitalize() 
</code></pre>
<p>This way the mixin actually declares the fields a class must have to be able to use this mixin. Warnings by the IDE disappear as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>So just to compiling my thoughts from the comments for everyone else: 
The problem is keeping the two classes intrinsically connected while separating functionality. Here are my solutions: </p>
<h2>1) Make a module</h2>
<p>Have another file, say <code>mixin.py</code>, that has <code>complex_operation</code> as a function. Instead of accepting <code>self</code> as a parameter, have it take a string:</p>
<pre><code># mixin.py

def complex_operation (foo: str) -&gt; str: return foo.capitalize()

# main.py

from ai import complex_operation
class A: 
    def __init__(self): self.foo = "foo"
print (complex_operation (A().foo))
</code></pre>
<h2>2) Make a class to accept another class as a parameter</h2>
<p>In <code>Mixin</code>'s <code>__init__</code> function, add a parameter to accept an <code>A</code>, and then use that in its methods:</p>
<pre><code># mixin.py

class Mixin: 
    def __init__(self, a: A): self.a = a
    def complex_operation(self): return self.a.foo.capitalize()

# main.py

from mixin import Mixin
class A:
    def __init__(self): self.foo = "foo"

print (Mixin (A()).complex_operation())
</code></pre>
</div>
<span class="comment-copy">I copy-and-pasted your code and <code>print (A().complex_operation())</code> printed "Foo". Is there more code we should see? As for a better way, inheritance is fine for mixins, and type hints + autocompletion is completely dependent on your choice of IDE.</span>
<span class="comment-copy">Yes, it works - but as mentioned IDE complains and I have no autocompletion...</span>
<span class="comment-copy">Which IDE are you using? It shouldn't be evaluating the variables in a function because even Python doesn't do that -- for this reason exactly.</span>
<span class="comment-copy">I am using PyCharm. It does check if I am using existing variables or not, but ofcourse it lets me execute code even if it suspects it has a problem.</span>
<span class="comment-copy">I don't know much about PyCharm, but it seems as though it expects <code>self</code> to have <code>foo</code>, but <code>Mixin</code>s don't have it. And it has a point -- not every class that uses this mixin is guarenteed to have a <code>foo</code>. Maybe you want <code>foo</code> to be a class attribute (or at least set in the <code>__init__</code>) of <code>Mixin</code> instead of <code>A</code>.</span>
<span class="comment-copy">I like the module solution for some cases. one should keep this possibility in mind.</span>
