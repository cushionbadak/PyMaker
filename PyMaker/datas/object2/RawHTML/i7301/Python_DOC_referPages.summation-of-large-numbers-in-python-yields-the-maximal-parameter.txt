<div class="post-text" itemprop="text">
<p>In my program I use numpy to get number's exponents, then I use the sum function to summarize them.
I've noticed that summarizing those large numbers, with or without numpy, results in the largest parameter being returned, unchanged.</p>
<pre><code>exp_joint_probabilities=[  1.57171938e+81,   1.60451506e+56,   1.00000000e+00]
exp_joint_probabilities.sum()
=&gt; 1.571719381352921e+81
</code></pre>
<p>The same with just python:</p>
<pre><code>(1.57171938e+81+1.60451506e+56+1.00000000e+00)==1.57171938e+81
=&gt;True
</code></pre>
<p>Is this a problem with approximation? Should I use a larger datatype to represent the numbers?
How can I get a more accurate result for these kind of calculations?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>1.57171938e+81</code> is a number with 81 digits, of which you only enter the first 9. <code>1.60451506e+56</code> is a much much much smaller number, with only 56 digits.</p>
<p>What kind of answer are you expecting? The first utterly dwarfs the second. If you want something of a similar precision to your original numbers (and that's what you get using floats), then the answer is simply correct.</p>
<p>You could use ints:</p>
<pre><code>&gt;&gt;&gt; a = int(1.57171938e+81)
&gt;&gt;&gt; b = int(1.60451506e+56)
&gt;&gt;&gt; a
571719379999999945626903548020224083024251666384876684446269499489505292916359168L
&gt;&gt;&gt; b
160451506000000001855754747064077065047170486040598151168L
&gt;&gt;&gt; a+b
1571719379999999945626903708471730083024253522139623748523334546659991333514510336L
</code></pre>
<p>But how useful that is is up to you.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">the <code>decimal</code> standard library</a>:</p>
<pre><code>from decimal import Decimal

a = Decimal(1.57171938e+81)
b = Decimal(1.60451506e+56)
d = a + b
print(d)
print(d &gt; a and d &gt; b)
</code></pre>
<p>Output:</p>
<pre><code>1.571719379999999945626903708E+81
True
</code></pre>
<p>You could convert it back to a float afterwards, but this will cause the same problem as before.</p>
<pre><code>f = float(d)
print(f)
print(f &gt; a and f &gt; b)
</code></pre>
<p>Output:</p>
<pre><code>1.57171938e+81
False
</code></pre>
<p>Note that if you store <code>Decimal</code>s in your <code>numpy</code> arrays, you will lose fast vectorized operations, as <a href="https://stackoverflow.com/a/7772386/2124834"><code>numpy</code> does not recognize <code>Decimal</code> objects</a>. Though it does work:</p>
<pre><code>import numpy as np

a = np.array([1.57171938e+81, 1.60451506e+56, 1.00000000e+00])
d = np.vectorize(Decimal)(a)  # convert values to Decimal
print(d.sum())
print(d.sum() &gt; d[0]
</code></pre>
<p>Output:</p>
<pre><code>1.571719379999999945626903708E+81
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It does seem to be a problem with approximation:</p>
<pre><code>&gt;&gt;&gt; 1.57171938e+81 + 1.60451506e+65 &gt; 1.57171938e+81
&lt;&lt;&lt; True

&gt;&gt;&gt; 1.57171938e+81 + 1.60451506e+64 &gt; 1.57171938e+81
&lt;&lt;&lt; False
</code></pre>
<p>You can get arount this by casting to int:</p>
<pre><code>&gt;&gt;&gt; int(1.57171938e+81) + int(1.60451506e+64) &gt; int(1.57171938e+81)
&lt;&lt;&lt; True
</code></pre>
</div>
<span class="comment-copy">You are still first converting the numbers to the 64bit float approximations and then those approximate values to Decimal. To directly convert the input to Decimal give them as strings, <code>a = Decimal("1.57171938e+81")</code> and <code>b = Decimal("1.60451506e+56")</code> then <code>a+b</code> gives the more correct result <code>Decimal('1.571719380000000000000000160E+81')</code></span>
<span class="comment-copy">The <code>long</code> cast does not work in Python 3.x. Casting to <code>int</code> does work there and I believe that also works in Python 2.x.</span>
<span class="comment-copy"><code>int</code> confirmed to work for this purpose in Python 2.7</span>
<span class="comment-copy">Oh, i didn't know that <code>int</code> worked in this case, i'll edit my answer, thanks.</span>
