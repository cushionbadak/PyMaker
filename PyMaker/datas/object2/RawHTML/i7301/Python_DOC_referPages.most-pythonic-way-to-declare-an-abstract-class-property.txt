<div class="post-text" itemprop="text">
<p>Assume you're writing an abstract class and one or more of its non-abstract class methods require the concrete class to have a specific class attribute; e.g., if instances of each concrete class can be constructed by matching against a different regular expression, you might want to give your ABC the following:</p>
<pre><code>@classmethod
def parse(cls, s):
    m = re.fullmatch(cls.PATTERN, s)
    if not m:
        raise ValueError(s)
    return cls(**m.groupdict())
</code></pre>
<p>(Maybe this could be better implemented with a custom metaclass, but try to ignore that for the sake of the example.)</p>
<p>Now, because overriding of abstract methods &amp; properties is checked at instance creation time, not subclass creation time, trying to use <code>abc.abstractmethod</code> to ensure concrete classes have <code>PATTERN</code> attributes won't work â€” but surely there should be <em>something</em> there to tell anyone looking at your code "I didn't forget to define <code>PATTERN</code> on the ABC; the concrete classes are supposed to define their own."  The question is: Which <em>something</em> is the most Pythonic?</p>
<ol>
<li><p><strong>Pile of decorators</strong></p>
<pre><code>@property
@abc.abstractmethod
def PATTERN(self):
    pass
</code></pre>
<p>(Assume Python 3.4 or higher, by the way.)  This can be very misleading to readers, as it implies that <code>PATTERN</code> should be an instance property instead of a class attribute.</p></li>
<li><p><strong>Tower of decorators</strong></p>
<pre><code>@property
@classmethod
@abc.abstractmethod
def PATTERN(cls):
    pass
</code></pre>
<p>This can be very confusing to readers, as <code>@property</code> and <code>@classmethod</code> normally can't be combined; they only work together here (for a given value of "work") because the method is ignored once it's overridden.</p></li>
<li><p><strong>Dummy value</strong></p>
<pre><code>PATTERN = ''
</code></pre>
<p>If a concrete class fails to define its own <code>PATTERN</code>, <code>parse</code> will only accept empty input.  This option isn't widely applicable, as not all use cases will have an appropriate dummy value.</p></li>
<li><p><strong>Error-inducing dummy value</strong></p>
<pre><code>PATTERN = None
</code></pre>
<p>If a concrete class fails to define its own <code>PATTERN</code>, <code>parse</code> will raise an error, and the programmer gets what they deserve.</p></li>
<li><p><strong>Do nothing.</strong>  Basically a more hardcore variant of #4.  There can be a note in the ABC's docstring somewhere, but the ABC itself shouldn't have anything in the way of a <code>PATTERN</code> attribute.</p></li>
<li><p>Other???</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python &gt;= 3.6 Version</strong></p>
<p>(Scroll down for a version that works for Python &lt;= 3.5).</p>
<p>If you are fortunate enough to only be using Python 3.6 and not have to worry about backwards compatibility, you can use the new <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer"><code>__init_subclass__</code></a> method which was introduced in Python 3.6 to <a href="https://www.python.org/dev/peps/pep-0487/" rel="nofollow noreferrer">make customizing class creation easier without resorting to metaclasses</a>.  When defining a new class, it is called as the last step before the class object is created.</p>
<p>In my opinion, the most pythonic way to use this would be to make a class decorator that accepts the attributes to make abstract, thus making it explicit to the user what they need to define.</p>
<pre><code>from custom_decorators import abstract_class_attributes

@abstract_class_attributes('PATTERN')
class PatternDefiningBase:
    pass

class LegalPatternChild(PatternDefiningBase):
    PATTERN = r'foo\s+bar'

class IllegalPatternChild(PatternDefiningBase):
    pass
</code></pre>
<p>The traceback might be as follows, and occurs at subclass creation time, not instantiation time.</p>
<pre><code>NotImplementedError                       Traceback (most recent call last)
...
     18     PATTERN = r'foo\s+bar'
     19 
---&gt; 20 class IllegalPatternChild(PatternDefiningBase):
     21     pass

...

&lt;ipython-input-11-44089d753ec1&gt; in __init_subclass__(cls, **kwargs)
      9         if cls.PATTERN is NotImplemented:
     10             # Choose your favorite exception.
---&gt; 11             raise NotImplementedError('You forgot to define PATTERN!!!')
     12 
     13     @classmethod

NotImplementedError: You forgot to define PATTERN!!!
</code></pre>
<p>Before showing how the decorator is implemented, it is instructive to show how you could implement this without the decorator. The nice thing here is that if needed you could make your base class an abstract base class without having to do any work (just inherit from <code>abc.ABC</code> or make the metaclass <code>abc.ABCMeta</code>).</p>
<pre><code>class PatternDefiningBase:
    # Dear programmer: implement this in a subclass OR YOU'LL BE SORRY!
    PATTERN = NotImplemented

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)

        # If the new class did not redefine PATTERN, fail *hard*.
        if cls.PATTERN is NotImplemented:
            # Choose your favorite exception.
            raise NotImplementedError('You forgot to define PATTERN!!!')

    @classmethod
    def sample(cls):
        print(cls.PATTERN)

class LegalPatternChild(PatternDefiningBase):
    PATTERN = r'foo\s+bar'
</code></pre>
<p>Here is how the decorator could be implemented.</p>
<pre><code># custom_decorators.py

def abstract_class_attributes(*names):
    """Class decorator to add one or more abstract attribute."""

    def _func(cls, *names):
        """ Function that extends the __init_subclass__ method of a class."""

        # Add each attribute to the class with the value of NotImplemented
        for name in names:
            setattr(cls, name, NotImplemented)

        # Save the original __init_subclass__ implementation, then wrap
        # it with our new implementation.
        orig_init_subclass = cls.__init_subclass__

        def new_init_subclass(cls, **kwargs):
            """
            New definition of __init_subclass__ that checks that
            attributes are implemented.
            """

            # The default implementation of __init_subclass__ takes no
            # positional arguments, but a custom implementation does.
            # If the user has not reimplemented __init_subclass__ then
            # the first signature will fail and we try the second.
            try:
                orig_init_subclass(cls, **kwargs)
            except TypeError:
                orig_init_subclass(**kwargs)

            # Check that each attribute is defined.
            for name in names:
                if getattr(cls, name, NotImplemented) is NotImplemented:
                    raise NotImplementedError(f'You forgot to define {name}!!!')

        # Bind this new function to the __init_subclass__.
        # For reasons beyond the scope here, it we must manually
        # declare it as a classmethod because it is not done automatically
        # as it would be if declared in the standard way.
        cls.__init_subclass__ = classmethod(new_init_subclass)

        return cls

    return lambda cls: _func(cls, *names)
</code></pre>
<hr/>
<p><strong>Python &lt;= 3.5 Version</strong></p>
<p>If you are not fortunate enough to only be using Python 3.6 and not have to worry about backwards compatibility, you will have to use a metaclass. Even though this is perfectly valid Python, one could debate how <em>pythonic</em> the solution is because metaclasses are hard to wrap your brain around, but I think it hits most of the points of <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">The Zen of Python</a> so I think it's not so bad.</p>
<pre><code>class RequirePatternMeta(type):
    """Metaclass that enforces child classes define PATTERN."""

    def __init__(cls, name, bases, attrs):
        # Skip the check if there are no parent classes,
        # which allows base classes to not define PATTERN.
        if not bases:
            return
        if attrs.get('PATTERN', NotImplemented) is NotImplemented:
            # Choose your favorite exception.
            raise NotImplementedError('You forgot to define PATTERN!!!')

class PatternDefiningBase(metaclass=RequirePatternMeta):
    # Dear programmer: implement this in a subclass OR YOU'LL BE SORRY!
    PATTERN = NotImplemented

    @classmethod
    def sample(cls):
        print(cls.PATTERN)

class LegalPatternChild(PatternDefiningBase):
    PATTERN = r'foo\s+bar'

class IllegalPatternChild(PatternDefiningBase):
    pass
</code></pre>
<p>This behaves exactly like the Python &gt;= 3.6 <code>__init_subclass__</code> method shown above (except the traceback will look bit different because it is routed through a different set of methods before failing).</p>
<p>Unlike the <code>__init_subclass__</code> method, if you want to make a subclass an abstract base class you will have to do just a bit of extra work (you'll have to compose the metaclass with <code>ABCMeta</code>).</p>
<pre><code>from abs import ABCMeta, abstractmethod

ABCRequirePatternMeta = type('ABCRequirePatternMeta', (ABCMeta, RequirePatternMeta), {})

class PatternDefiningBase(metaclass=ABCRequirePatternMeta):
    # Dear programmer: implement this in a subclass OR YOU'LL BE SORRY!
    PATTERN = NotImplemented

    @classmethod
    def sample(cls):
        print(cls.PATTERN)

    @abstractmethod
    def abstract(self):
        return 6

class LegalPatternChild(PatternDefiningBase):
    PATTERN = r'foo\s+bar'

    def abstract(self):
        return 5

class IllegalPatternChild1(PatternDefiningBase):
    PATTERN = r'foo\s+bar'

print(LegalPatternChild().abstract())
print(IllegalPatternChild1().abstract())

class IllegalPatternChild2(PatternDefiningBase):
    pass
</code></pre>
<p>Outputs just as you'd expect.</p>
<pre><code>5
TypeError: Can't instantiate abstract class IllegalPatternChild1 with abstract methods abstract
# Then the NotImplementedError if it kept on going.
</code></pre>
</div>
<span class="comment-copy">Is <i>pythonic</i> subjective?</span>
<span class="comment-copy">I have <i>read</i> that this is one of the things metaclasses are good for - enforcing the <i>look</i> and <i>feel</i> of objects that use it.</span>
<span class="comment-copy">@wwii Yes, they can be used for that also, but in this case this is more than just look and feel. Like an abstract base class, it is enforcing that a particular class attribute is defined at definition-time which is more than just look or feel.</span>
<span class="comment-copy">.. That's pretty much what I meant by  look and feel - I should be more precise. thnx</span>
<span class="comment-copy">Since <code>NotImplemented</code> is a singleton, usually better to compare with <code>is</code></span>
