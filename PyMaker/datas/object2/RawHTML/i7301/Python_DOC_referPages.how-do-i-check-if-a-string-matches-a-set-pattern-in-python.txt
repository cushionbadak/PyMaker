<div class="post-text" itemprop="text">
<p>I want to match a string to a specific pattern or set of words, like below:</p>
<p><code>the apple is red</code> is the query and
<code>the apple|orange|grape is red|orange|violet</code> is the pattern to match.
The pipes would represent words that would substitute each other. The pattern could also be grouped like <code>[launch app]|[start program]</code>. I would like the module to return True or False whether the query matches the pattern, naturally.</p>
<p>What is the best way to accomplish this if there is not a library that does this already? If this can be done with simple regex, great; however I know next to nothing about regex. I am using Python 2.7.11</p>
</div>
<div class="post-text" itemprop="text">
<p>please let me know if this correctly answers your question.</p>
<pre><code>import re

string = 'the apple is red'

re.search(r'^the (apple|orange|grape) is (red|orange|violet)', string)
</code></pre>
<p>Here's an example of it running:</p>
<pre><code>In [20]: re.search(r'^the (apple|orange|grape) is (red|orange|violet)', string). groups()
Out[20]: ('apple', 'red')
</code></pre>
<p>If there are no matches then <code>re.search()</code> will return nothing.</p>
<p>You may know "next to nothing about regex" but you nearly wrote the pattern.</p>
<p>The sections within the parentheses can also have their own regex patterns, too. So you could match "apple" and "apples" with</p>
<p><code>r'the (apple[s]*|orange|grape)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>re</code> based solutions for this kind of problem work great. But it would sure be nice if there were an easy way to pull data out of strings in Python without have to learn regex (or to learn it AGAIN, which what I always end up having to do since my brain is broken). </p>
<p>Thankfully, <a href="https://stackoverflow.com/users/288169/richard-jones">someone</a> took the time to write <code>parse</code>. </p>
<h2><code>parse</code></h2>
<p><a href="https://pypi.python.org/pypi/parse" rel="nofollow noreferrer"><code>parse</code> is a nice package</a> for this kind of thing. It uses regular expressions under the hood, but the API is based on the <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer"><code>string</code> format specification mini-language</a>, which most Python users will already be familiar with. </p>
<p>For a format spec you will use over and over again, you'd use <code>parse.compile</code>. Here is an example: </p>
<pre><code>&gt;&gt;&gt; import parse
&gt;&gt;&gt; theaisb_parser = parse.compile('the {} is {}')
&gt;&gt;&gt; fruit, color = theaisb_parser.parse('the apple is red')
&gt;&gt;&gt; print(fruit, color)
apple red
</code></pre>
<h2><code>parmatter</code></h2>
<p>I <a href="https://pypi.python.org/pypi/parmatter" rel="nofollow noreferrer">have put a package I created for my own use on pypi </a> in case others find it useful. It make things just a little bit nicer. It makes heavy usage of <code>parse</code>. The idea is to combine <a href="https://docs.python.org/3.4/library/string.html#string-formatting" rel="nofollow noreferrer">the functionality of a <code>string.Formatter</code></a> and a <code>parse.Parser</code> into a single object, which I have called a <code>parmatter</code> (also the package name). </p>
<p>The package contains a number of useful custom parmatter types. <code>StaticParmatter</code> has a precompiled parsing specification (similar to the object from <code>parse.compile</code> above). Use it like this: </p>
<pre><code>&gt;&gt;&gt; from parmatter import StaticParmatter
&gt;&gt;&gt; theaisb = StaticParmatter('the {} is {}')
&gt;&gt;&gt; print(theaisb.format('lizard', 'chartreuse'))
the lizard is chartreuse
&gt;&gt;&gt; fruit, color = theaisb.unformat('the homynym is ogive')
&gt;&gt;&gt; print(fruit, color)
homynym ogive
</code></pre>
<p>Note that for "unformatting", the <code>parse</code> package uses the method name <code>parse</code>. However, my package uses <code>unformat</code>. The reason for this is that <code>parmatter</code> classes are subclassed from <code>string.Formatter</code>, and <code>string.Formatter</code> already has a <code>.parse()</code> method (which provides different functionality). Additionally, I think <code>unformat</code> is a more  intuitive method name, anyway. </p>
<p>EDIT: see also my <a href="https://stackoverflow.com/a/44266675/2437514">previous answer to another question</a>, which discusses these packages as well. </p>
</div>
<span class="comment-copy">Ok so I could use that and if it does not return <code>None</code> it is True.</span>
<span class="comment-copy">Yep, that's correct.</span>
<span class="comment-copy"><code>if re.search(r"sleep (mode|computer)", speech.lower()) is not None:</code> Yep it worked. Thank you!</span>
<span class="comment-copy">Great, happy to help!</span>
<span class="comment-copy">Guess it's time to do extensive homework on regex.</span>
