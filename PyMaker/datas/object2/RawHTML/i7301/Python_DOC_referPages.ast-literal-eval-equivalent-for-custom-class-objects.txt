<div class="post-text" itemprop="text">
<p><code>ast.literal_eval</code> works well for evaluating python's inbuilt types:</p>
<pre><code>In [42]: import ast

In [43]: ast.literal_eval('[1, 2, 3, "4", None, (5, 4, 3)]')
Out[43]: [1, 2, 3, '4', None, (5, 4, 3)]
</code></pre>
<p>It fails for custom class objects:</p>
<pre><code>In [44]: class Foo():
    ...:     def __init__(self, val):
    ...:         self.val = val
    ...:  

In [45]: ast.literal_eval('[Foo(1), Foo(2), Foo(3)]')
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-47-a3bd4f494d5d&gt; in &lt;module&gt;()
----&gt; 1 ast.literal_eval('[Foo(1), Foo(2), Foo(3)]')
</code></pre>
<p>But, <code>eval</code> works just fine:</p>
<pre><code>In [46]: eval('[Foo(1), Foo(2), Foo(3)]')
Out[46]: 
[&lt;__main__.Foo at 0x107e13940&gt;,
 &lt;__main__.Foo at 0x107e131d0&gt;,
 &lt;__main__.Foo at 0x107e13160&gt;]
</code></pre>
<p>How can I combine the safety of <code>ast.literal_eval</code> with the functionality of <code>eval</code> for custom objects?</p>
<p>I've looked at <a href="https://stackoverflow.com/questions/25867475/ast-literal-eval-for-variables-in-python">this</a> but this pertains to variables that already exist.</p>
</div>
<div class="post-text" itemprop="text">
<p>if your data was like this -</p>
<pre><code>'["Foo(1)", "Foo(2)", "Foo(3)"]'
</code></pre>
<p>literal_eval would have worked. 
Because it would think that Foo(1) and others are strings and would recognize them.</p>
<pre><code>'[Foo(1), Foo(2), Foo(3)]'
</code></pre>
<p>As far as I know, this cannot be used as argument in literal_eval.</p>
<p>From <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">docs</a>, </p>
<blockquote>
<p>Safely evaluate an expression node or a string containing a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and None.</p>
</blockquote>
</div>
<span class="comment-copy">function calls are not <i>literals</i>. A literal is a <i>string literal</i>, an <i>integer literal</i>, <code>True</code>, <code>False</code>, <code>None</code>, <i>list literal</i>, <i>tuple literal</i>, <i>set literal</i> and <i>dictionary literal</i>.</span>
<span class="comment-copy">e.g. <code>ast.literal_eval('dict()')</code> fails as well. Since you could have overwritten <code>dict(..)</code> in your code. All calls - regardless whether these are builtins or not - will fail.</span>
<span class="comment-copy">@WillemVanOnsem So bottom line, there's no solution?</span>
<span class="comment-copy">You can construct a custom <code>ast</code> that will allow certain things. But i would use whitelisting instead of blacklisting.</span>
