<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1089018/why-cant-decimal-numbers-be-represented-exactly-in-binary">Why can't decimal numbers be represented exactly in binary?</a>
<span class="question-originals-answer-count">
                    20 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>
<span class="question-originals-answer-count">
                    28 answers
                </span>
</li>
</ul>
</div>
<p>Here is my code,</p>
<pre><code> s = 0
 for i in range(10):
   s += 0.1
 print (s)
</code></pre>
<p>The output is 0.9999999999999999, Why not output 0.9?</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider this fraction.</p>
<p><code>1/2</code> </p>
<p>What will be it's output? <code>0.5</code> simple right. </p>
<p>Now for <code>1/3</code> what will be the output?</p>
<p><code>0.3</code> seems okay because </p>
<p><code>3 x 0.3 = 0.9</code></p>
<p>More accurately,</p>
<p><code>3 x 0.33 = 0.99</code></p>
<p>or even more</p>
<p><code>3 x 0.333 = 0.999</code></p>
<p>Hell if you do the same for say 10 decimal points you still get,</p>
<p><code>3 x 0.33333333333 = 0.99999999999</code></p>
<p>As you see we are getting more and more nearer to the value <code>1</code> but never
are we <strong>exactly equal</strong>. So that means we are getting more and more accurate with such high precisions.</p>
<p><strong>However</strong> you won't normally require such precisions for your simple programs. See what <a href="https://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow noreferrer">Python docs</a> say about it,</p>
<blockquote>
<p>0.999999999 , That is more digits than most people find useful, so Python keeps the number of digits manageable by displaying a rounded value instead</p>
</blockquote>
<p><strong>But</strong></p>
<blockquote>
<p>It’s important to realize that this is, in a real sense, an illusion: the value in the machine is not exactly 1/10, you’re simply rounding the display of the true machine value. This fact becomes apparent as soon as you try to do arithmetic with these values</p>
</blockquote>
<p>What this means basically is just because you see</p>
<pre><code>&gt;&gt;&gt;0.1
0.1 
</code></pre>
<p>in the interpreter doesn't mean it is <strong>just</strong> <code>0.1</code> the true value in the machine would be something like,</p>
<pre><code>0.1000000000000000055511151231257827021181583404541015625
</code></pre>
<p>Try this in your interpreter,</p>
<pre><code>&gt;&gt;&gt; 0.1
0.1
&gt;&gt;&gt; 0.2
0.2
&gt;&gt;&gt; 0.1+0.2
0.30000000000000004
&gt;&gt;&gt; 
</code></pre>
<p>So this is what is happening to all those <code>0.1+0.2+0.3...</code> to finally get your</p>
<p><code>0.999999999</code></p>
<p>For more reference, see <a href="https://www.youtube.com/watch?v=pQs_wx8eoQ8" rel="nofollow noreferrer">this</a> YouTube video.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code iterates from <code>0</code> to <code>9</code>, in total 10 iterations. </p>
<p>This gives <code>10 • 0.1 = 1</code>, but because of python float accuracy adding <code>0.1</code> ten times results in <code>0.99999</code>.</p>
</div>
<span class="comment-copy">Also read <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">What happens if you start with 0.0?</span>
