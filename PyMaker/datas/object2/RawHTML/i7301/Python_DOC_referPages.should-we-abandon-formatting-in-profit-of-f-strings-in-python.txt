<div class="post-text" itemprop="text">
<p>I really like to delve into code style and it's interesting to know whether from now on in all cases it would be better to use the new style.</p>
<p>I'm using a lot the <code>.format()</code> in my Python 3.5 projects, and I'm afraid that it will be deprecated during the next Python versions because of this new kind of string literals. </p>
<pre><code>&gt;&gt;&gt; name = "Test"
&gt;&gt;&gt; f"My app name is {name}."
'My app name is Test.'
</code></pre>
<p>Does the formatted string feature come to fully replace the old <code>format()</code> ?</p>
<p>I understand that it based on the idea that: </p>
<blockquote>
<p>Simple is better than complex.</p>
</blockquote>
<p>However, what about performance issues, does any difference exist between them? Or it's just an simple look of the same feature?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><em>I'm afraid that it will be deprecated during the next Python versions</em></p>
</blockquote>
<p>Don't be, <code>str.format</code> does not appear (nor has a reason) to be leaving any time soon, the PEP that introduced <code>f</code>prefixed-strings even <a href="https://www.python.org/dev/peps/pep-0498/#abstract" rel="nofollow noreferrer">states in its Abstract</a>:</p>
<blockquote>
<p>This PEP does not propose to remove or deprecate any of the existing string formatting mechanisms.</p>
</blockquote>
<p>Formatted strings were introduced to address some of the shortcomings other methods for formatting strings had; not to throw the old methods away and force god-knows how many projects to use f-string's if they want their code to work for Python 3.6+.</p>
<hr/>
<p>As for the performance of these, it seems my initial suspicion that they might be slower is wrong, f-strings seem to easily outperform their <code>.format</code> counterparts:</p>
<pre><code>➜ cpython git:(master) ./python -m timeit -s "a = 'test'" "f'formatting a string {a}'"
500000 loops, best of 5: 628 nsec per loop
➜ cpython git:(master) ./python -m timeit "'formatting a string {a}'.format(a='test')"
100000 loops, best of 5: 2.03 usec per loop
</code></pre>
<p>These were done against the master branch of the CPython repository as of this writing; they are definitely subject to change:</p>
<ul>
<li><code>f-strings</code>, as a new feature, might have possible optimizations </li>
<li>Optimizations to CPython might make <code>.format</code> faster (e.g <a href="https://bugs.python.org/issue26110" rel="nofollow noreferrer">Speedup method calls 1.2x</a>) </li>
</ul>
<p>But really, don't worry about speed so much, worry about what is more readable to you and to others.</p>
<p>In many cases, that's going to be <code>f-strings</code>, but <a href="https://stackoverflow.com/questions/44780357/how-to-use-newline-n-in-f-string-to-format-output-in-python-3-6">there's some cases</a> where <code>format</code> is better. </p>
</div>
<div class="post-text" itemprop="text">
<p>To build on Jim's answer and address your performance concern, I used python's <code>dis</code> module to compare the bytecode instructions for two syntactically different, but functionally equivalent functions.</p>
<pre><code>import dis

def f1():
    a = "test"
    return f"{a}"

def f2():
    return "{a}".format(a='test')

print(dis.dis(f1))
print(dis.dis(f2))
</code></pre>
<p>The result of which is:</p>
<pre> 11           0 LOAD_CONST               1 ('test')
              2 STORE_FAST               0 (a)

 12           4 LOAD_FAST                0 (a)
              6 FORMAT_VALUE             0
              8 RETURN_VALUE
None
 15           0 LOAD_CONST               1 ('{a}')
              2 LOAD_ATTR                0 (format)
              4 LOAD_CONST               2 ('test')
              6 LOAD_CONST               3 (('a',))
              8 CALL_FUNCTION_KW         1
             10 RETURN_VALUE
None</pre>
<p>One can see that the f-string handles the formatting without attribute or function calls, which can impose type checking and memory overhead. According to <code>timeit</code> this results in a roughly 3x performance gain (for my specific functions)</p>
<pre>&gt;&gt;&gt; timeit.timeit('f1()', 'from __main__ import f1', number=100000)
0.012325852433775708
&gt;&gt;&gt; timeit.timeit('f2()', 'from __main__ import f2', number=100000)
0.036395029920726074</pre>
</div>
<div class="post-text" itemprop="text">
<p>One thing not mentioned (which makes deprecation of the old techniques impossible) is that interpolation is for string literals only.  Meaning, the string is rendered once at runtime.  The template can not be used again with updated variables, for example:</p>
<pre><code>str_template.format(args)
</code></pre>
<p>Another case is i18n, where string.Template is used.  Many use cases would be impossible without the older techniques.  Enjoy string interpolation, but don't use it where it is not appropriate, i.e. places where you need a reusable template.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to keep supporting python 3.5 you could use <code>fstring</code></p>
<p><code>pip install fstring</code></p>
<pre><code>from fstring import fstring

x = 1

y = 2.0

plus_result = "3.0"

print fstring("{x}+{y}={plus_result}")

# Prints: 1+2.0=3.0
</code></pre>
</div>
<span class="comment-copy">wait a minute, who says <code>.format()</code> will be depreciated? I doubt that</span>
<span class="comment-copy">No one, I agree. one of the things that I'm wondering about.. for future use.</span>
<span class="comment-copy">After Python 3's initial release, the community learned the hard way exactly how painful it is to introduce compatibility-breaking changes into new versions, and I don't think they're going to repeat that decision again lightly. Maybe when Python 4 comes out in 1,983 years...</span>
<span class="comment-copy">@Kevin thanks. I wish so.</span>
<span class="comment-copy">Probably worth reading <a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow noreferrer">PEP 498</a> if you want the full version of the reasoning behind the feature.</span>
<span class="comment-copy">What about performance improvements ? Any different in the internal implementation?</span>
<span class="comment-copy">@nivhanin and Jim, I did a brief speed investigation, however it would be interesting to poke around the source code, I'd bet they actually share a lot of code between them even though the bytecode produced by <code>dis</code> is relatively different. If I were to guess, as the string becomes longer and has more complicated formatting rules, the difference between the two will shrink.</span>
<span class="comment-copy">@Aaron Good point. I would like to see the results published here ;)</span>
<span class="comment-copy">I find your speed comparisons interesting, as it is significantly different on my machine (Python 3.6.2 from Anaconda): the fstring version takes 0.0845usec while the format version takes 0.555usec. So while you see a factor ~3, I see a factor ~6. Odd.</span>
<span class="comment-copy">Amazing job. Thanks!</span>
<span class="comment-copy">@Aaron What this dis really do? Also; how do you get those info from that printed texts?</span>
<span class="comment-copy">@Vicrobot <code>dis</code> is short for disassemble. It takes a the bytecode of a compiled function, and decodes the python virtual machine instructions (binary data) into human readable words. The python virtual machine is a <a href="https://en.wikipedia.org/wiki/Stack_machine" rel="nofollow noreferrer">stack based vm</a> so all the "LOAD" and "STORE" commands refer to pushing and pulling data from the stack. More information on the <code>dis</code> library can be found <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">isn't better to use <code>.format</code> instead? this <code>fstring</code> is not straight port of python 3.6 f-strings and not support formatting</span>
