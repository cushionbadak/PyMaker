<div class="post-text" itemprop="text">
<p>Hi I am little confused about scoping of variables in python. kindly explain difference between below snipts. </p>
<p>i)</p>
<pre><code>class Test(object):
    a_var = 1

    def a_func(self):
      self.a_var = self.a_var + 1
      print(self.a_var, '[ a_var inside a_func() ]')


   if __name__=='__main__':
     t=Test()
     t.a_func()
</code></pre>
<p>O/P: 2 [ a_var inside a_func() ]</p>
<pre><code>class Test(object):
    a_var = 1

    def a_func(self):
      a_var = a_var + 1
      print(a_var, '[ a_var inside a_func() ]')


if __name__=='__main__':
   t=Test()
   t.a_func()
</code></pre>
<p>o/p:UnboundLocalError: local variable 'a_var' referenced before assignment</p>
<p>Why is LEGB rule not applied in second case,should it not get value from enclosedesope that is class. kindly explain. Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>This might seem weird (and it is), but <strong>you don't get a closure over <code>class</code>, it's only over <code>def</code></strong>.  The "<strong>e</strong>nclosing" scope referred to in L<strong>E</strong>GB is just talking about function definitions; class blocks don't count here.  </p>
<p>That strange behaviour is an artifact of the way in which classes were added to Python historically.  The class scope is not a real scope.  Python didn't always have classes, and the spooky "intermediate scope" just exists during the class definition: internally, the code under the class body is more or less just run through <code>exec</code> under a temporary scope with the result being assigned to the class name.  This was a very simple "bolt-on" approach to get OOP into the language, at the time, and it's also the reason why Python has the explicit <code>self</code> thing as an intentional language design choice.  </p>
<p>To access the <code>a_var</code> from the "class scope" from inside a method, you will have to use attribute access via either <code>self.a_var</code> or <code>Test.a_var</code>.  Both should work.  You may also access it directly at the class level, during the class definition, but since you are still inside the temporary scope that is just another example of a local access (<strong>L</strong>EGB).  </p>
<p>This is documented (albeit not particularly clearly) under the <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">execution model</a> section.  </p>
<blockquote>
<p>Class definition blocks and arguments to exec() and eval() are special in the context of name resolution. A class definition is an executable statement that may use and define names. These references follow the normal rules for name resolution with an exception that unbound local variables are looked up in the global namespace. The namespace of the class definition becomes the attribute dictionary of the class. <strong>The scope of names defined in a class block is limited to the class block</strong>; it does not extend to the code blocks of methods â€“ this includes comprehensions and generator expressions since they are implemented using a function scope.</p>
</blockquote>
</div>
<span class="comment-copy">Thanks now i am clear, from where you get this type of info i didn't found it in some books " This might seem weird (and it is), but you don't get a closure over class, it's only over def. The "enclosing" scope referred to in LEGB is just talking about function definitions; class blocks don't count here." Can u provide me link to some good articles where i can get clear concept related to class, variables and access methods and tricky varible initialization inside class. Thanks</span>
<span class="comment-copy">I added a docs reference.</span>
