<div class="post-text" itemprop="text">
<p>I want to write some Python code that when called from the context of a type behaves like an <code>@classmethod</code>, however when called on an instance of an object the first argument is behaves as normal, with <code>self</code> referencing the current instance. I.e. I want to write:</p>
<pre><code>class Foo(object):
    @something # &lt;- does this exist? How can I even write it?
    def bar(self_or_class):
        print(repr(self_or_class))

Foo.bar() # Should print: &lt;class '__main__.Foo'&gt;
inst = Foo()
inst.bar() # Should print:  &lt;__main__.Foo at 0x....&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I once wrote a code snippet in <a href="https://www.daniweb.com/programming/software-development/code/406393/mixedmethod-mixes-class-and-instance-method-into-one" rel="nofollow noreferrer">daniweb</a> about this</p>
<pre><code>from __future__ import print_function
from functools import partial

class mixedmethod(object):
    """This decorator mutates a function defined in a class into a 'mixed' class and instance method.

    Usage:

        class Spam:

            @mixedmethod
            def egg(self, cls, *args, **kwargs):
                if self is None:
                    pass # executed if egg was called as a class method (eg. Spam.egg())
                else:
                    pass # executed if egg was called as an instance method (eg. instance.egg())
    The decorated methods need 2 implicit arguments: self and cls, the former being None when
    there is no instance in the call. This follows the same rule as __get__ methods in python's
    descriptor protocol.
    """
    def __init__(self, func):
        self.func = func
    def __get__(self, instance, cls):
        return partial(self.func, instance, cls)

if __name__ == '__main__':

    class Spam(object):

        @mixedmethod
        def ham(self, cls, *args):
            if self is None:
                print("Spam.ham() was called as a class method with {0}.".format((self, cls)+ args))
            else:
                print("Spam.ham() was called as an instance method with {0}.".format((self, cls) + args))

        def __repr__(self):
            return '&lt;Spam instance&gt;'
    egg = Spam()
    egg.ham(5)
    Spam.ham(5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After some research I managed to do this. The first thing I found is that you can actually <a href="https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">implement <code>@classmethod</code> in pure Python</a>, as referenced in the documentation.</p>
<p>With that knowledge it's fairly simple to adapt the code to test if <code>obj</code> exists: </p>
<pre><code>class something(object):
    ''' 
    This works like @classmethod, except the first argument is either class or self if it's available
    '''
    def __init__(self, f):
        self.f = f

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        def newfunc(*args, **kwargs):
            return self.f(klass if obj is None else obj, *args, **kwargs)
        return newfunc
</code></pre>
<p>All we have to do over and above the example in the documentation is check if <code>obj</code> is <code>None</code> and favour <code>obj</code> over <code>klass</code> if it is not.</p>
</div>
<span class="comment-copy">I wish I'd found that an hour ago</span>
<span class="comment-copy">@Flexo The only drawback of this idea is that is not really useful. One can as well write a class method and an instance method with a different name. Normally, client code knows whether the argument is a type or an instance.</span>
<span class="comment-copy">The use I have is in cross language interoperability. I.e. to make a 1:1 mapping of behaviour between Python proxies to other languages you have to do this.</span>
<span class="comment-copy">@Flexo that's a nice use case!</span>
