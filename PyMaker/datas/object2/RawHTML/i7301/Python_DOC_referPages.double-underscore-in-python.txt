<div class="post-text" itemprop="text">
<pre><code>class A(object):
    def __get(self):
        pass

    def _m(self):
        return self.__get()


class B(A):
    def _m(self):
        return str(self.__get())

print(A()._m())
print(B()._m())
</code></pre>
<p>Why <code>print(A()._m())</code> prints <code>None</code>, but <code>print(B()._m())</code> raises <code>AttributeError: 'B' object has no attribute '_B__get'</code>?</p>
<p>I thought that double underscore prevents method overriding.</p>
<p><strong>UPDATE</strong></p>
<p>You write that <code>__get</code> is private.</p>
<p>Then why does the following work?</p>
<pre><code>class A(object):
    def __get(self):
        pass

    def _m(self):
        return self.__get()


class B(A):
    pass

print(A()._m())
print(B()._m())
</code></pre>
<p>Why does this code doesn't raise <code>AttributeError</code> and prints <code>None</code> two times?</p>
</div>
<div class="post-text" itemprop="text">
<p>Leading double underscore names are <code>private</code> (meaning not available to derived classes)</p>
<p>This is not foolproof.  It is implemented by mangling the name.  <a href="https://docs.python.org/3/tutorial/classes.html#private-variables-and-class-local-references" rel="nofollow noreferrer">Python Documentation</a> says:</p>
<blockquote>
<p>Any identifier of the form __spam (at least two leading underscores,
  at most one trailing underscore) is textually replaced with
  _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard
  to the syntactic position of the identifier, so it can be used to
  define class-private instance and class variables, methods, variables
  stored in globals, and even variables stored in instances. private to
  this class on instances of other classes.</p>
</blockquote>
<p>Thus <code>__get</code> is actually mangled to <code>_A__get</code> in class A.  When class B attempts to reference <code>__get</code>, it gets mangled to <code>_B__get</code> which doesn't match.</p>
<p>In other words __plugh defined in class Xyzzy means "unless you are running as class Xyzzy, thou shalt not touch the __plugh."</p>
</div>
<div class="post-text" itemprop="text">
<p>For <code>_ _methodName()</code> member function of class A, </p>
<p>Call this member function from outside of class A, you can only call <code>_A__methodName()</code> (trying call <code>__methodName()</code> will generate error.)</p>
<p>If Calling this member function inside class A, you can use both <code>_A__methodName()</code> and <code>__methodName()</code>.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">Name mangling</a>. Your call to <code>self.__get()</code> in <code>B</code> is really calling <code>self._B__get()</code>, which does not exist. Unless you want this behavior, don't use leading double underscores.</span>
<span class="comment-copy">Check out <a href="https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-a-single-and-a-double-underscore-before-an-object-name?rq=1">what is the meaning of a single and a double underscore before an object name</a> and some of the linked questions as there are some detailed explanations.</span>
<span class="comment-copy">Re your update: Because you are calling __get from a method defined in class A.  That's perfectly legal in any language that supports the concept of private -- in fact that is the most common use case of private methods.</span>
<span class="comment-copy"><i>"Leading double underscore names are <code>private</code> (meaning not available to derived classes)"</i>  Please don't do this. There's noting called private in Python, those names are (pseudoprivate)  and not private.</span>
<span class="comment-copy">@direprobs The PURPOSE of the leading underscores is to hide the symbols from everone except the defining class.  In MANY other languages this concept is referred to a being "private".  Hence I used  a single word for the concept that should be well recognized.   Also I explained the implementation details and mentioned the lack of foolproofness.  How else would you suggest conveying the concept?</span>
<span class="comment-copy">That's the problem. The word private would suggest private like it's in Java for example, the variable cannot be accessed from outside the class. You said the variable won't be available to the derived class which is absolutely wrong.</span>
<span class="comment-copy">Note that the official python documentation I quoted calls this concept -- um -- 'class-private'</span>
