<div class="post-text" itemprop="text">
<pre><code>class Foo(object):
     def __init__(self):
         self.a = 1
         self.c = 0
     def __getattr__(self, name):
         self.c += 1
         print('getattribute')
         if hasattr(self, name) is False:
             print("No")
             return None
         return super(Foo, self).__getattr__(self, name)

fo = Foo()
print(fo.a)
print(fo.b)
print(fo.c)
</code></pre>
<p>Running the above programs prints "getattribute" and "no" multiple times. <code>__getattr__</code> is called multiple times. 333 to be exact. <code>self.c</code> prints 333.</p>
<p>What I want to achieve is to have a class that doesn't raise an error if a class variable or method is not declared in the class.</p>
<p>Whats the possible reason for this?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>hasattr</code> just tries to get the attribute and returns <code>False</code> if it can’t. Whether it can’t is determined in Python 3 by an attempt throwing an <code>AttributeError</code>, and in Python 2 by an attempt throwing <em>any</em> error. (This includes <code>RecursionError</code>s and is why it fails silently after 333 calls. Python 2 is not a sane language; upgrade to 3 if possible.)</p>
<p>Instead, you can return the alternative value on an <code>AttributeError</code> yourself:</p>
<pre><code>def __getattr__(self, name):
    try:
        return super(Foo, self).__getattr__(self, name)
    except AttributeError:
        return None
</code></pre>
<p>This can potentially hide other <code>AttributeError</code>s, but it’s difficult to avoid doing that just by the nature of Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>hasattr is a shortcut to call getattr and see if it raises an exception (which means attribute does not exist) or not (which means it exists)</p>
<p>cf : <a href="https://docs.python.org/3/library/functions.html#hasattr" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#hasattr</a></p>
<p>getattr calls __getattr__ so you are doing a recursive call</p>
<p>I think a possible workaround would be to use: </p>
<pre><code>name in self.__dict__
</code></pre>
<p>instead of:</p>
<pre><code>hasattr(self, name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is because running <code>hasattr(self, name)</code> calls <code>self.__getattr__(name)</code> (aka <code>getattr(self, name)</code>) - <a href="https://docs.python.org/3/library/functions.html#hasattr" rel="nofollow noreferrer">reference</a>.</p>
<p>So when doing <code>hasattr(self, name)</code> within <code>__getattr__</code> it calls <code>self.__getattr__(name)</code>, here comes the unwanted recursion.</p>
<p>I would fix it with:</p>
<pre><code>class Foo(object):
     def __init__(self):
         self.a = 1
         self.c = 0
     def __getattr__(self, name):
         self.__dict__['c'] += 1
         print('getattribute')
         try:
             return self.__dict__[name]
         except KeyError:
             print('No')
             return None

fo = Foo()
print(fo.a)
print(fo.b)
print(fo.c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem comes from <code>print(fo.b)</code>.
Since <code>b</code> is not defined as a member of <code>Foo</code>, <code>fo.b</code> results in a call to <code>fo.__getattr__('b')</code>.</p>
<p>Then, <code>hasattr(self, name)</code>, which is tantamount to <code>hasattr(fo, 'b')</code> calls itself <code>gettatr(fo, 'b')</code>, as stated in <a href="https://docs.python.org/3/library/functions.html#hasattr" rel="nofollow noreferrer">hte documentation</a>.</p>
<p>Hence an infinite recursion, resulting in a <code>RecursionError</code> in Python 3.</p>
<hr/>
<p>Since getting <code>fo.b</code> does not really make sense if you know that <code>Foo</code> does not have a <code>b</code> member, a first fix I would suggest is to define that member.</p>
<pre><code>class Foo(object):
    def __init__(self):
        ...
        self.b = 1
        ...
</code></pre>
<p>Your code then outputs</p>
<pre><code>1
1
0
</code></pre>
<p>A more clever fix would be to check if the <code>name</code> argument passed to <code>__getattr__</code> is <code>'b'</code>, or depending to your needs, different from <code>'a'</code> and <code>'c'</code>.
In this situation, you can force <code>__getattr__</code> to define the requested unfound member.</p>
<pre><code>class Foo(object):
    ...
    def __getattr__(self, name):
    if name == 'b':
        self.b = 2
        return self.b
    else:
        ...
</code></pre>
<p>Alternatively:</p>
<pre><code>class Foo(object):
    ...
    def __getattr__(self, name):
    if name not in ('a', 'c'):
        self.b = 2
        return self.b
    else:
        ...
</code></pre>
</div>
<span class="comment-copy"><code>hasattr</code> just tries to get the attribute and catches an <code>AttributeError</code>. You can use a <code>try: return super().__getattr__(self, name) except AttributeError: return None</code>. That can potentially hide other <code>AttributeError</code>s, but it’s difficult to avoid doing that just by the nature of Python.</span>
<span class="comment-copy">Create singleton class.</span>
<span class="comment-copy">@Ryan thanks. Your solution works. It turns out hasattr calls getattr internally. But wouldn't this should have resulted into an infinite loop? Why 333 calls only?</span>
<span class="comment-copy">@MishaVacic How that would solve the issue and help me achieve no <code>AttributeError</code> class?</span>
<span class="comment-copy">@Ryan can you add your comment as an answer and explain the questions in my comment so that I can mark your answer as correct?</span>
<span class="comment-copy">Thanks! +1 for Python3. Unfortunately, can't use Python 3 for this project(organizations project). I will mark this answer.</span>
<span class="comment-copy">@AmitTripathi: The original code works on Python 2. <code>__getattribute__</code> wouldn’t be right for something overriding <code>__getattr__</code>.</span>
<span class="comment-copy">yes it works but not in the way you would expect. The above code raises <code>AttributeError 'super' object has no attribute '__getattr__'</code> in Python 2 because <code>object</code> doesn't have <code>__getattr__</code> in Python 2. So my edit was correct!</span>
<span class="comment-copy">@AmitTripathi: That’s fine, though, since it will catch the <code>AttributeError</code> for <code>__getattr__</code> as well if it doesn’t exist later in the MRO.</span>
<span class="comment-copy">@AmitTripathi: Right, but only if you’re inheriting from <code>object</code> or something else that doesn’t implement <code>__getattr__</code>. (If you are and you can guarantee that that will never change, feel free to just <code>return None</code> – it will work.)</span>
<span class="comment-copy">Arount gave the answer</span>
<span class="comment-copy">Yes makes sense. Can you explain why 333 calls not infinite calls?</span>
<span class="comment-copy">AFAIK <code>__getattr__</code> is only called as a last resort when object is not found anywhere.</span>
<span class="comment-copy">Not true. <code>fo.c</code> does <b>not</b> call <code>fo.__getattr__('c')</code>. <a href="https://docs.python.org/3.6/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer">docs.python.org/3.6/reference/datamodel.html#object.__getattr__</a></span>
<span class="comment-copy">Ok guys, let me correct that</span>
<span class="comment-copy">Yes, just tested it. <b>getattr</b> is not called in case variable is defined either in class or in parent class.</span>
<span class="comment-copy">I think it's fixed</span>
