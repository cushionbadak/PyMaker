<div class="post-text" itemprop="text">
<p>I have a custom class,</p>
<pre><code>class A:
    def __init__(self, a, b):
        self.a = a
        self.b = b
</code></pre>
<p>The class is not iterable or indexable or anything like that. If at all possible, I would like to keep it that way. Is it possible to have something like the following work?</p>
<pre><code>&gt;&gt;&gt; x = A(1, 2)
&gt;&gt;&gt; min(x)
1
&gt;&gt;&gt; max(x)
2
</code></pre>
<p>What got me thinking about this is that <a href="https://docs.python.org/3/library/functions.html#min" rel="noreferrer"><code>min</code></a> and <a href="https://docs.python.org/3/library/functions.html#max" rel="noreferrer"><code>max</code></a> are listed as "Common Sequence Operations" in the <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="noreferrer">docs</a>. Since <a href="https://docs.python.org/3/library/stdtypes.html#range" rel="noreferrer"><code>range</code></a> is considered to be a sequence type by the very same docs, I was thinking that there must be some sort of optimization that is possible for <code>range</code>, and that perhaps I could take advantage of it.</p>
<p>Perhaps there is a magic method that I am not aware of that would enable this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes.  When <code>min</code> takes one arguments it assumes it to be an iterable, iterates over it and takes the minimum value. So,</p>
<pre><code>class A:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __iter__(self):
        yield self.a
        yield self.b
</code></pre>
<p>Should work.</p>
<p>Additional Note: If you don't want to use <code>__iter__</code>, I don't know of way to do that.  You probably want to create your own min function, that calls some <code>__min__</code> method if there is one in the argument it is passed to and calls the old <code>min</code> else.</p>
<pre><code>oldmin = min
def min( *args )
  if len(args) == 1 and hasattr( args[0], '__min__' ):
    return args[0].__min__()
  else:
    return oldmin( *args )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are no <code>__min__</code> and <code>__max__</code> special methods*. This is kind of a shame since <code>range</code> has seen some <a href="https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3">pretty nice optimizations in Python 3</a>. You can do this: </p>
<pre><code>&gt;&gt;&gt; 1000000000000 in range(1000000000000)
False
</code></pre>
<p>But don't try this unless you want to wait a long time: </p>
<pre><code>&gt;&gt;&gt; max(range(1000000000000))
</code></pre>
<p>However creating your own <code>min</code>/<code>max</code> functions is a pretty good idea, as suggested by <a href="https://stackoverflow.com/a/45308284/2437514">LÃ¦rne</a>. </p>
<p>Here is how I would do it. UPDATE: removed the dunder name <code>__min__</code> in favor of <code>_min</code>, as recommended by <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8</a>:</p>
<blockquote>
<p>Never invent such names; only use them as documented</p>
</blockquote>
<p>Code:</p>
<pre><code>from functools import wraps

oldmin = min

@wraps(oldmin)
def min(*args, **kwargs)
    try:
        v = oldmin(*args, **kwargs)
    except Exception as err:
        err = err
    try:
        arg, = args
        v = arg._min()
    except (AttributeError, ValueError):
        raise err
    try:
        return v
    except NameError:
        raise ValueError('Something weird happened.')
</code></pre>
<p>I think this way is maybe a little bit better because it handles some corner cases the other answer hasn't considered. </p>
<p>Note that an iterable object with a <code>_min</code> method will still be consumed by <code>oldmin</code> as per usual, but the return value is overridden by the special method. </p>
<p>HOWEVER, if the <code>_min</code> method requires the iterator to still be available for consumption, this will need to be tweaked because the iterator is getting consumed by <code>oldmin</code> first. </p>
<p>Note also that if the <code>__min</code> method is simply implemented by calling <code>oldmin</code>, things will still work fine (even though the iterator was consumed; this is because <code>oldmin</code> raises a <code>ValueError</code> in this case). </p>
<p>* Such methods are often called "magic", but this is not the preferred terminology. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Since <code>range</code> is considered to be a sequence type by the very same docs, I was thinking that there must be some sort of optimization that is possible for <code>range</code>, and that perhaps I could take advantage of it.</p>
</blockquote>
<p>There's no optimization going on for ranges and there are no specialized magic methods for <code>min</code>/<code>max</code>. </p>
<p>If you peek at <a href="https://github.com/python/cpython/blob/302bbbe9ba5c72559913e2ea006c921f698a729d/Python/bltinmodule.c#L1505" rel="nofollow noreferrer">the implementation for <code>min</code>/<code>max</code></a> you'll see that after some argument parsing is done, <a href="https://github.com/python/cpython/blob/302bbbe9ba5c72559913e2ea006c921f698a729d/Python/bltinmodule.c#L1535" rel="nofollow noreferrer">a call to <code>iter(obj)</code></a> (i.e  <code>obj.__iter__()</code>) is made to grab an iterator:</p>
<pre><code>it = PyObject_GetIter(v);
if (it == NULL) {
    return NULL;
}
</code></pre>
<p>then <a href="https://github.com/python/cpython/blob/302bbbe9ba5c72559913e2ea006c921f698a729d/Python/bltinmodule.c#L1542" rel="nofollow noreferrer">calls to <code>next(it)</code></a> (i.e <code>it.__next__</code>) are performed in a loop to grab values for comparisons:</p>
<pre><code>while (( item = PyIter_Next(it) )) {
    /* Find min/max  */
</code></pre>
<blockquote>
<p>Is it possible to have something like the following work?</p>
</blockquote>
<p>No, if you want to use the built-in <code>min</code>* the only option you have is implementing the iterator protocol.</p>
<hr/>
<p>*By patching <code>min</code>, you can of-course, make it do anything you want. Obviously at the cost of operating in Pythonland. If, though, you think you can utilize some optimizations, I'd suggest you create a <code>min</code> method rather than re-defining the built-in <code>min</code>.</p>
<p>In addition, if you only have ints as instance variables and you don't mind a different call, you can always use <code>vars</code> to grab the <code>instance.__dict__</code> and then supply it's <code>.values()</code> to <code>min</code>:</p>
<pre><code>&gt;&gt;&gt; x = A(20, 4)
&gt;&gt;&gt; min(vars(x).values())
4
</code></pre>
</div>
<span class="comment-copy">do you mean make it work without defining <code>__iter__</code>/<code>__next__</code>? I'm not sure I understand your confusion.</span>
<span class="comment-copy">When you say "the class is not iterable", do you mean "the class is not iterable but I'm willing to make it iterable", or "the class is not iterable and it absolutely must remain that way"?</span>
<span class="comment-copy">"I was thinking that there must be some sort of optimization that is possible for range" Interestingly, this appears to not be the case; while a O(1) min/max algorithm should be theoretically possible for range objects, the <a href="https://github.com/python/cpython/blob/master/Python/bltinmodule.c#L1505" rel="nofollow noreferrer">implementation</a> appears to be O(N) regardless of the type of input.</span>
<span class="comment-copy">If you don't mind telling, I'm a bit curios about why you don't want your object to be iterable so badly. Is it to keep users from doing something dumb? Perhaps there is a better way?</span>
<span class="comment-copy">@ChristianDean. I was working on something equivalent to <code>range</code> for <code>float</code> numbers. I came up with a solution where it is iterable when <code>step</code> is specified and not iterable otherwise. It would still provide a valid containment test and a few other things, so <code>min</code> and <code>max</code> would make sense, even if the step is not there. I guess I will just have to allow it to iterate over the bounds if there is no explicit step.</span>
<span class="comment-copy"><a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8 forbids</a> the creation of your own dunder methods. Use <code>__min</code> instead.</span>
<span class="comment-copy">Correction: <code>_min</code> since <code>__min</code> gets name-mangled.</span>
<span class="comment-copy">What did I miss, why can't you just call the method <code>min</code> instead of any underline variant? It doesn't seem to be a "magical" method or anything, it's just a method that will be called elsewhere outside of the standard library.</span>
<span class="comment-copy">@Mephy It's a good point. I suppose the original idea was to emulate the special method name approach employed by the standard library, but this isn't really necessary. <code>.min()</code> would work fine. Using underscores is a way of saying "there is something special about this method", though.</span>
<span class="comment-copy"><code>'__min__' in dir(args[0])</code> is a bad way of writing <code>hasttr(args[0], '__min__')</code>.  The semantics of <code>dir()</code> are not well defined, and it's also very slow to first create a list of all attribute names and then linearly scanning it, when all you need is a single dictionary look-up.</span>
<span class="comment-copy"><code>__min</code> gets name-mangled, so it's really awkward to name a method that.</span>
<span class="comment-copy">@user2357112 Yeah that's true. I'll change it to just <code>_min</code>.</span>
<span class="comment-copy">That makes sense, disappointing as it is. I will ask another question on how to identify the caller so that I can raise an exception if anyone but <code>min</code> or <code>max</code> tries to grab the iterator. I hope that you don't mind me giving the points to the other guy.</span>
<span class="comment-copy">@MadPhysicist I don't think you need to post another question for that. Unless someone reading the comment here disagrees with me, I think if you do something like this to check it should suffice: <a href="https://pastebin.com/AFNGcWHw" rel="nofollow noreferrer">pastebin.com/AFNGcWHw</a></span>
<span class="comment-copy">@MadPhysicist: Can't do that. (The fact that you're even trying is a giant "reconsider your design decisions" red flag.)</span>
<span class="comment-copy">@user2357112 Are you saying no to trying to <i>catch</i> <code>min</code>/<code>max</code> being the callers?</span>
<span class="comment-copy">@idjaw: You can't detect whether you're being called from <code>min</code>/<code>max</code>.</span>
