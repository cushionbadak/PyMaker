<div class="post-text" itemprop="text">
<p>I am new to python/coding in general. I was struggling some time to produce the code below (pretty proud of it) but I am now having performance problems – don’t know how to solve them.</p>
<p>My task is the following: 
Each product has a delivery hour and a production timestamp. Production time can be from 1 day 15:00 before delivery until 30 min before delivery. I want to aggregate production time to 15 min intervals for each delivery hour and perform several simple operations for produced units within each interval 
(not all of them are built in functions ) 
 -Volume Weighted Average Price, Total Quantity(sum), Standard Deviation etc. </p>
<p>My Problem: 
The Dataset consists of around 11 million Data points. Calculating the values for a 6 month period took me more than 24 hours. I tried to loop through the sql query and only imported 15 min periods but it was even worse </p>
<p>My Question: 
Do you see any way to improve the performance of this operation?
it would be amazing &lt;3</p>
<hr/>
<p>The Original Input Data looks like thís:</p>
<p><code>Column StartOfDelivery EndOfDelivery     ProductionDateTime    PriceEURpMW QuantityMW  p*Q
73  2017-01-03 01:00:00 2017-01-03 02:00:00 2017-01-02 19:03:00   37,4         20    748
80  2017-01-03 01:00:00 2017-01-03 02:00:00 2017-01-02 19:08:00   35,9         25    897,5
86  2017-01-03 01:00:00 2017-01-03 02:00:00 2017-01-02 19:23:00   36,3         1     36,3 
94  2017-01-03 01:00:00 2017-01-03 02:00:00 2017-01-02 19:24:00   35,3         0,4   14,12
915 2017-01-03 02:00:00 2017-01-03 03:00:00 2017-01-02 23:47:00   33,7         5     168,5
929 2017-01-03 02:00:00 2017-01-03 03:00:00 2017-01-02 23:50:00   32,6         0,3   9,78
340 03.01.2017 02:00:00 2017-01-03 03:00:00 2017-01-02 22:17:00   34           7,9   268,6
345 2017-01-03 02:00:00 2017-01-03 03:00:00 2017-01-02 22:19:00   34           0,8   27,2</code></p>
<hr/>
<p>The Output Data looks like this:</p>
<pre><code>index   StartDelivery   Production(intervall)   Quantity    VWAP
17  2017-01-03 01:00:00 2017-01-02 19:00:00       45       36,56666667
18  2017-01-03 01:00:00 2017-01-02 19:15:00       1,4      36,01428571
...
69  2017-01-03 02:00:00 2017-01-02 22:15:00       8,7      34
70  2017-01-03 02:00:00 2017-01-02 23:45:00       5,3      33,63773585
</code></pre>
<hr/>
<p>My Code so far:</p>
<pre><code>import mysql.connector
import numpy as np
import pandas as pd
import datetime




conn=mysql.connector.connect(user='AriHeck',password='none',host='local',database='DataEvaluation', port=3308)
df = pd.read_sql("select StartOfDelivery,EndOfDelivery,ProdDateTime,PriceEURpMW,QuantityMW, PriceEURpMW*QuantityMW as 'p*Q'  from `Production`\
where timestampdiff(hour,StartOfDelivery,EndOfDelivery)=1 AND StartOfDelivery &gt;= '2017-01-03 01:00:00'  AND StartOfDelivery &lt; '2017-01-03 03:00:00'", con=conn)

#Delivery Time Loop
dt=datetime.datetime.strptime('2017-01-03 01:00:00', "%Y-%m-%d %H:%M:%S") 
end_date=datetime.datetime.strptime('2017-01-05 00:00:00', "%Y-%m-%d %H:%M:%S")

#Dummies loops
incr_delivery_loop=datetime.timedelta(hours=1)
incr_production_loop=datetime.timedelta(minutes=15)
delta_start=datetime.timedelta(days=1) 
delta_end=datetime.timedelta(minutes=30)

#Dummies Data
a=1
delivery_array=[0]*a
production_array=[0]*a
time_remaining_array=[0]*a
VWAP_array=np.zeros(a)
quantity_array=np.zeros(a)

#Start Delivery time loop
while (dt &lt;= end_date):

    #Production Time Loop: 
        #Start Production: 1 Day before delivery 15:00 (3:00 PM), End Production 30 mins before delivery
    prod_time=(dt-delta_start).replace(hour=15)
    end_prod=dt-delta_end 

    while (prod_time&lt;=end_prod):

        quantity=df[(df['StartOfDelivery']==dt)&amp; (df['ProdDateTime']&gt;=prod_time) &amp; (df['ProdDateTime']&lt;(prod_time+incr_production_loop))].QuantityMW.sum()
        if (quantity==0):
            VWAP=0        
        else:   
            #Calculate  Volume Weighted Average Price
            pq_total=df[(df['StartOfDelivery']==dt)&amp; (df['ProdDateTime']&gt;=prod_time) &amp; (df['ProdDateTime']&lt;(prod_time+incr_production_loop))]['p*Q'].sum()
            VWAP=pq_total/quantity

        #Save values to  arrays
        VWAP_array=np.append(VWAP_array,VWAP)
        quantity_array=np.append(quantity_array,quantity)
        delivery_array.append(dt)
        production_array.append(prod_time)

       #Increments
        prod_time=prod_time+incr_production_loop

    dt=dt+incr_delivery_loop
#END LOOPS

#Save to Dataframe 
WAP_dict={'TimeOfDelivery':delivery_array,
          'ProductionDateTime':production_array,
          'VWAP':VWAP_array,
          'Quantity':quantity_array,} 
df_WAP=pd.DataFrame(WAP_dict)
df_WAP=df_WAP[['TimeOfDelivery','ProductionDateTime','Quantity','VWAP']]


#Output
print(df_WAP.head(50)) 
</code></pre>
<p>python 3.4, Windows 10, eclipse IDE</p>
</div>
<div class="post-text" itemprop="text">
<p>Welcome to python! <a href="https://docs.python.org/3/library/profile.html" rel="nofollow noreferrer">Profiling</a> your code would be a great starting point :)</p>
<p>That said, as your dataset grows, every call to:</p>
<pre><code>df['some_column']==some_variable
</code></pre>
<p>Gets more expensive. If your performance is good when working on 2 days of data but drops off when you scale up to 6 months, that is probably the culprit.</p>
<p>Try pre-sorting the data by adding <code>order by StartOfDelivery</code> to the end your SQL query. Then split your dataframe into a list of dataframes where each subframe contains only the records for the 15 minute increment you need inside the loop's body.</p>
<p>You can then iterate over that list as your main loop instead of:</p>
<pre><code>while (dt &lt;= end_date):
</code></pre>
<p>That should cut out all the dataframe filtering and make your execution time scale linearly(ish) with data set size.</p>
</div>
<span class="comment-copy">Surely your database management system's aggregate functions would be a better place to start</span>
