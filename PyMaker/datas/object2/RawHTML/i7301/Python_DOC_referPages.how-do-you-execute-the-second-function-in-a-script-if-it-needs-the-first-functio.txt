<div class="post-text" itemprop="text">
<p>I think this is basic and I've seen multiple versions of the question I am asking although they are all not exactly what I am facing.</p>
<p>I have a script with two functions currently, and I want the ability to evoke just the second function but it needs to run the first function. My script is still messy so I am using an example:</p>
<pre><code>def func1(input):    # Does something with input data
    my_list = []
    for i in input:
        my_list.append(i)
    return my_list  # Returns a list

func1_list = func1(x) # Save the result from func1 into a variable

def func2(func1_list):   
    my_final_list = []       # This function just edits the first list          
    for val in my_list:       # Results from func2 are needed later on         
        temp = val**3
        my_final_list.append(temp)
    return my_final_list
</code></pre>
<p>Is there a way to execute the second function without having to call the first function when importing a script? I have no clue where to input the func1_list variable in func2 so that anyone can just go straight to func2 and run it (and it will automatically execute func1 anyways).</p>
<p>EDIT:
Both func1 and func2 should be able to be executed individually - func2 relies on func1. Both will show information (func2 just showing modified information). Example: func1 will run some input and show the raw result, whereas func2 will take that raw result and modify it. I'd want the ability to see the raw and modified result if needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want <code>func1_list = func1(x)</code> to only invoke when directly executing your script, you'll need to modify your script a bit so it is ignored when called from a module. You'll use an if condition like this:</p>
<pre><code>if __name__ == '__main__':
    func1_list = func1(x) # Save the result from func1 into a variable
</code></pre>
<p><code>__name__</code> equals <code>__main__</code> only when the script is invoked directly, so it will not execute when called from a module.</p>
<hr/>
<p>For a detailed description of how it works, look <a href="https://stackoverflow.com/questions/419163/what-does-if-name-main-do">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are trying to import your script, you must follow the best practices and conventions.</p>
<p>Without starting to build a full-package, you need to, at least, ensure that you do not execute code that is not requested when importing the module.</p>
<p>Either you wrap your code into a <code>class</code>, or you remove function calls from within the root of your module and you provided an <code>init_function()</code> which must be called to prepare the environment.</p>
<p>There is no shame in using an init_function() and a lot of libraries do that. </p>
<p>However, I recommend that you structure your code within <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">Python classes</a>. Example of <code>FunctionsManager.py</code>:</p>
<pre><code>class FunctionsManager:
    def __init__(self):  
        self.func1_list = self.func1(x) # Save the result from func1 into a variable

    def func1(self, input):    # Does something with input data
        my_list = []
        for i in input:
            my_list.append(i)
        return my_list  # Returns a list

    def func2(self, func1_list):   
        my_final_list = []       # This function just edits the first list          
        for val in my_list:       # Results from func2 are needed later on         
            temp = val**3
            my_final_list.append(temp)
        return my_final_list
</code></pre>
<p>And then in your main code:</p>
<pre><code>from FunctionsManager import FunctionsManager

manager = FunctionsManager() # Calls __init__() and so func1()
result = manager.func2(yourlist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Note, your question is basically asking for a primer on <a href="https://en.wikipedia.org/wiki/Dependency_injection" rel="nofollow noreferrer">dependency injection</a>.  You would probably do well to read up on it.  It's language-agnostic - it applies as nicely to Java as it does to Python.</em></p>
<p>There are several different approaches you can take for this; the best choice depends on your needs and what the functions involved do (which is why I was asking all the questions in the comment).</p>
<p>The simplest form of what you're looking for is to just have one function invoke the other.  (COLDSPEED made reference to this.):</p>
<pre><code>def func1(input):
    # do some magic to my_list with input
    return my_list

def func2(input):
    func1_list = func1(input)
    # do some magic to make func2's my_list
    return my_list
</code></pre>
<p>In that case, func1 and func2 are both able to be called.  The importing code doesn't have to worry about calling func1 before func2 - that's taken care of by func2.</p>
<p>Before I get into your other choices, you mentioned that both functions output information.  It's a good practice to separate your calculations from your output of them.  So, <strong>DON'T</strong> do this:</p>
<pre><code>def func1(input):
    # do some magic to my_list with input
    print("func1: Stuff from my list...")
    return my_list

def func2(input):
    func1_list = func1(input)
    print("func2: Stuff from my list...")
    # do some magic to make func2's my_list
    return my_list
</code></pre>
<p>Because then calling <code>func2</code> would print out the "func1" line and the "func2" line.  Instead, separate the logic from the output.  It may seem more complicated, but it gives you more building blocks to play with:</p>
<pre><code>def func1(input):
    # do some magic to my_list with input
    return my_list

def func2(input):
    func1_list = func1(input)
    # do some magic to make func2's my_list
    return my_list

def output_func1(input):
    func1_list = func1(input)
    print("func1_list stuff")

def output_func2(input):
    func2_list = func2(input)
    print("func2_list stuff")
</code></pre>
<p>Now you have a lot of reusable functions that don't generate a lot of noise.</p>
<p>This is a good step, and you can use this easily.  What happens if <code>func1</code> takes an hour to run?  You don't want to run it again if it's already been run.  Then you want to use module variables to save state.  Something like this:</p>
<pre><code>func1_results = None

def func1(input):
    # do some magic to my_list with input
    func1_results = my_list
    return my_list

def func2(input):
    if not func1_results:
        func1(input) # this will only run if func1 hasn't been called yet
    # do some magic to make func2's my_list
    return my_list  # you could similarly make a construct to save these results   
</code></pre>
<p>Now you get code calling its dependencies only if it needs to.  We're getting better.  But we're passing input into func2, and we only care about it in func1.  You could make a module variable <code>input</code> that func1 refers to, and your importing code could set it before calling any of the funcs:</p>
<pre><code>input = None
def func1():
    # do some magic to my_list with module variable input
</code></pre>
<p>And invoke it as:</p>
<pre><code>import my_funcs
my_funcs.input = "Happy happy input!"
my_funcs.func1() # or just my_funcs.func2(), etc.
</code></pre>
<p>This could be nice, but it's dangerous - what if the importing code doesn't set <code>input</code>?  The solution to that is what Fabien mentioned about having a class:</p>
<pre><code>class FuncRunner(object):
    def __init__(self, input):
        self.input = input
        self.func1_results = None
    def func1(self):
        # do some magic to local my_list with input
        self.func1_results = my_list
        return my_list
    def func2(self):
        if not self.func1_results:
            self.func1()
        # do some magic to make func2's my_list
        # maybe save the result as self.func2_results ?
        return my_list
</code></pre>
<p>This would be invoked as:</p>
<pre><code>from my_funcs import FuncRunner
runner = FuncRunner("Happy happy input!")
foo = runner.func1()  # or foo = runner.func2(), as per your needs
</code></pre>
<p>This does the nice thing of not letting you run functions without constructing the object, and the way the <code>__init__</code> is structured, you can't create the object without passing <code>input</code>.  The results found by <code>func1</code> are stored within the object, so they're always associated together.  In your case, this is likely the cleanest way to do what you want.</p>
</div>
<span class="comment-copy">Remove <code>func1_list = func1(x)</code> from the module scope of your code, then you can import without having <code>func1</code> called.</span>
<span class="comment-copy">Write a wrapper that performs the <code>func1_list = func1(x)</code> before invoking <code>func2</code>?</span>
<span class="comment-copy">Functions are closures so you could simply remove the <code>func1_list</code> parameter from the function (and change  <code>for val in my_list</code> to <code>for val in func1_list</code>, or even better: <code>return [val**3 for val in func1_list]</code>. Alternatively you can make <code>func2</code> call <code>func1</code>.</span>
<span class="comment-copy">I think you need to step back a bit and explain what you're really trying to do.  The question as is doesn't really make a lot of sense, and it's difficult to understand what fundamental problem you're trying to solve.</span>
<span class="comment-copy">Pretty sure that if you ever end up calling <code>func2</code>, <code>my_list</code> will give a <code>NameError</code></span>
<span class="comment-copy">Oh I have heard of this, never truly understood it. But what does it mean when you say it is invoked directly? I import my script so is that not it being called directly? I also just tried putting the variables within the function and that seems to work but I am not sure if that is best practise.</span>
<span class="comment-copy">If the file is called <code>A.py</code>, then running <code>python A.py</code> will cause the line to execute. But doing <code>import A</code> in <code>B.py</code> won't.</span>
<span class="comment-copy">@DNAngel Look at the official <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer">docs</a>. It doesn't get any more official than that.</span>
<span class="comment-copy">Ohh okay I will have to play around this. I am getting confused on how to make my func2 use the same object in func1 so that it can work on the same dataset. i.e. def func2(input)</span>
<span class="comment-copy">@DNAngel Inside the if condition, call <code>func2(func1_list)</code>. Also, if this answer helps, you can <i>accept it</i> (click on the grey check mark).</span>
<span class="comment-copy">Thank you for the information. Classes always scared me (lol) but I do want to learn following best practises. I am a complete noob with classes but I will read up on it again and try to edit my functions accordingly! Nothing ventured, nothing gained!</span>
<span class="comment-copy">Yes, all my encouragements for you on this path :-) You will see it's easier than expected! Enjoy Python</span>
