<div class="post-text" itemprop="text">
<p>I know, the title sounds a bit confusing, and as a newbie in Python I didn't know how to put it a better way.</p>
<p>Here's what I want to do:</p>
<p>My script will read csv files (spreadsheets) and create new spreadsheets from them that won't contain anything else but numbers. Basically, this script gets rid of unwanted character strings by deleting the rows and columns that contain them. I managed to create a functioning script, although it can only be applied to a single file. Put it another way, I would need to change the input file name inside the script each time I want to run it on another csv file.</p>
<p>My files have names of this type: "MODEL<strong>XXXXXXXXX</strong>__NAME<strong>Y</strong>_alfa<strong>Z</strong>.csv" where X, Y and Z are numbers.
I want to pass these files' name as an input to my Python script, so I've used the sys.argv[1] syntax in order to achieve that. 
Here is an example of what my code looks like:</p>
<pre><code>import csv
import sys

strings_to_remove = ['string1','string2']

with open(sys.argv[1],'rb') as oldfile, open('NAMEY_alfaZ_test1.csv','w+b') as newfile:
    for line in oldfile:
        if not in any(strings_to_remove in line for strings_to_remove in strings_to_remove):
            newfile.write(line)
</code></pre>
<p>I run my script like this: </p>
<pre><code>python script.py MODELXXXXXXXXX_NAMEY_alfaZ.csv
</code></pre>
<p>Now what I'd like to do is automate my script, that is to get rid of the "MODELXXXXXXXXX" part and not having to write "NAME<strong>Y</strong>_alfa<strong>Z</strong>" for the output file each time I want to apply my script to another file.</p>
<p>Is there any way to do that?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Since the <code>MODELXXXXX...</code> part in your file name is separated with a double underscore from the rest of the file name, you can just slice off everything from the beginning to those two underscores from your input file name to get the output file name, e.g.:</p>
<pre><code>input_file = sys.argv[1]  # e.g. MODELXXXXXXXXX__NAMEY_alfaZ.csv
output_file = input_file[input_file.find("__")+2:]  # you get NAMEY_alfaZ.csv
</code></pre>
<p>Then you can just use those two instead of the hard-coded values in your <code>open()</code> statements.</p>
<p><strong>EDIT</strong> - If you want to also modify the base name without the extension, you can extend it to something like this:</p>
<pre><code>input_file = sys.argv[1]  # e.g. MODELXXXXXXXXX__NAMEY_alfaZ.csv
file_extension = input_file[input_file.rfind("."):]  # in case we have multiple extensions
base_name = input_file[input_file.find("__") + 2:-len(file_extension)]
output_file = base_name + file_extension  # you get NAMEY_alfaZ.csv
# but you can also generate your output file names
output_file1 = base_name + "_test1" + file_extension  # NAMEY_alfaZ_test1.csv
output_file2 = base_name + "_test2" + file_extension  #  NAMEY_alfaZ_test2.csv
# etc.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the filenames don't contain multiple <code>__</code>'s, then you could use:</p>
<pre><code>import sys
input_file = sys.argv[1]
output_file = input_file.split("__")[1]
</code></pre>
<p>In case the double underscore was a typing mistake, you can use:</p>
<pre><code>import sys
input_file = sys.argv[1]
output_file = ''.join(input_file.split("_")[1:])
</code></pre>
<p>That way, it removes the first item from the list (so "MODELXXXXXXXXX"), and then joins the list back together.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your input file names have a regular format, so I would suggest you the use of <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">Python regular expressions</a> to extract the relevant information.</p>
<p>In your case, you could prepare the regular expression as follows:</p>
<pre><code>re_input = re.compile('MODEL(?P&lt;model&gt;\d+)__NAME(?P&lt;name&gt;\d)_alfa(?P&lt;alpha&gt;\d).csv')
</code></pre>
<p>Then you can match and extract the information you want using <code>match</code> and <code>group</code>.</p>
<p>For example, to get the <code>model</code> you do:</p>
<pre><code>match = re_input.match(input_file)
model = match.group('model')
</code></pre>
<p>Your example should be something like:</p>
<pre><code>import re
import csv
import sys

strings_to_remove = ['string1','string2']

re_input = re.compile('MODEL(?P&lt;model&gt;\d+)__NAME(?P&lt;name&gt;\d)_alfa(?P&lt;alpha&gt;\d).csv')

input_file = sys.argv[1]

match = re_input.match(input_file)
model = match.group('model')
name = match.group('name')
alpha = match.group('alpha')

output_file = 'NAME{}_alpha{}_test1.csv'.format(name, alpha)
with open(input_file, 'rb') as oldfile, open(output_file, 'w+b') as newfile:
    for line in oldfile:
        if not in any(strings_to_remove in line for strings_to_remove in strings_to_remove):
            newfile.write(line)
</code></pre>
<p>You might want to adjust the regular expression, for instance, changing <code>\d</code> to <code>\d+</code> or vice-versa to match the number of digits in your file name.</p>
</div>
<span class="comment-copy">in your script, the ouput name is always the same. I'd imagine that it must be a variant of the input name... What name goes to what? Plus look up "glob" in Python or use shell globbing?</span>
<span class="comment-copy">Wouldn't it be easier if we just point the directory where those files exist and use <code>os.listdir(path)</code> to get a list of all files? Then you could iterate through them.</span>
<span class="comment-copy">Hi Henno &amp; arif,  The output name is not always the same, but the names definitely share the same structure.  And yes, I planned to use a loop, but I wanted to understand how to substitute the file name first</span>
<span class="comment-copy">Thank you for your answer. I haven't tested your solution yet, but will it be possible to add the 'test1', 'test2',... particle at the end of the output_file name? I plan to create several subfiles in the script, called "NAMEY_alfaZ_test1.csv", "NAMEY_alfaZ_test2.csv" and so on</span>
<span class="comment-copy">@Bean_from_accounts - check the update above</span>
<span class="comment-copy">Very handy! Thanks again</span>
<span class="comment-copy">After playing around with your solution, there seems to be a wee typo. It should be :  file_extension = input_file[input_file.rfind("."):]   in order to specify that we're keeping whatever's after the dot. After modifying your piece of code, it works perfectly well!</span>
<span class="comment-copy">@Bean_from_accounts - oops, sorry about that, I was first extracting the base_name only but added the extension capture to make it more extensible, but, alas, I forgot to update the line. Fixed.</span>
<span class="comment-copy">However,  in the example <code>python script.py MODELXXXXXXXXX_NAMEY_alfaZ.csv</code>  there's only single underscore before "NAME". Either this is a typo or the double underscore was, and I suspect the latter. If I'm right, then your solution won't work.</span>
<span class="comment-copy">@Błotosmętek Edited, now reflects that scenario as well.</span>
<span class="comment-copy">That's a solution I'll keep on hand, thanks John!</span>
