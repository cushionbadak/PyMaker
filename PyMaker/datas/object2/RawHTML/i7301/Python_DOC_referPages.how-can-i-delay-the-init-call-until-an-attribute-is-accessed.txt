<div class="post-text" itemprop="text">
<p>I have a test framework that requires test cases to be defined using the following class patterns:</p>
<pre><code>class TestBase:
    def __init__(self, params):
        self.name = str(self.__class__)
        print('initializing test: {} with params: {}'.format(self.name, params))

class TestCase1(TestBase):
    def run(self):
        print('running test: ' + self.name)
</code></pre>
<p>When I create and run a test, I get the following:</p>
<pre><code>&gt;&gt;&gt; test1 = TestCase1('test 1 params')
initializing test: &lt;class '__main__.TestCase1'&gt; with params: test 1 params
&gt;&gt;&gt; test1.run()
running test: &lt;class '__main__.TestCase1'&gt;
</code></pre>
<p>The test framework searches for and loads all <code>TestCase</code> classes it can find, instantiates each one, then calls the <code>run</code> method for each test.</p>
<pre><code>load_test(TestCase1(test_params1))
load_test(TestCase2(test_params2))
...
load_test(TestCaseN(test_params3))

...

for test in loaded_tests:
    test.run()
</code></pre>
<p>However, I now have some test cases for which I don't want the <code>__init__</code> method called until the time that the <code>run</code> method is called, but I have little control over the framework structure or methods.  How can I delay the call to <code>__init__</code> <strong>without redefining the <code>__init__</code> or <code>run</code> methods</strong>?</p>
<hr/>
<h2>Update</h2>
<p>The speculations that this originated as an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a> are correct.  A coworker asked me this question a while back when I was maintaining said test framework.  I inquired further about what he was <em>really</em> trying to achieve and we figured out a simpler workaround that didn't involve changing the framework or introducing metaclasses, etc.</p>
<p>However, I still think this is a question worth investigating:  if I wanted to create new objects with "lazy" initialization ("lazy" as in lazy evaluation generators such as <code>range</code>, etc.) what would be the best way of accomplishing it?  My best attempt so far is listed below, I'm interested in knowing if there's anything simpler or less verbose.</p>
</div>
<div class="post-text" itemprop="text">
<h2>First Solutionï¼š<em>use property.the elegant way of setter/getter in python.</em></h2>
<pre><code>class Bars(object):
    def __init__(self):
        self._foo = None

    @property
    def foo(self):
        if not self._foo:
            print("lazy initialization")
            self._foo =  [1,2,3]
        return self._foo

if __name__ == "__main__":
    f = Bars()
    print(f.foo)
    print(f.foo)
</code></pre>
<h2>Second Solution:<em>the proxy solution,and always implement by decorator.</em></h2>
<p>In short, Proxy is a wrapper that wraps the object you need. Proxy could provide additional functionality to the object that it wraps and doesn't change the object's code. It's a surrogate which provide the abitity of control access to a object.there is the code come form <a href="https://stackoverflow.com/questions/3012421/python-memoising-deferred-lookup-property-decorator/6849299#6849299">user Cyclone</a>.</p>
<pre><code>class LazyProperty:
    def __init__(self, method):
        self.method = method
        self.method_name = method.__name__

    def __get__(self, obj, cls):
        if not obj:
            return None
        value = self.method(obj)
        print('value {}'.format(value))
        setattr(obj, self.method_name, value)
        return value

class test:
    def __init__(self):
        self._resource = None

    @LazyProperty
    def resource(self):
        print("lazy")
        self._resource = tuple(range(5))
        return self._resource
if __name__ == '__main__':
    t = test()
    print(t.resource)
    print(t.resource)
    print(t.resource)
</code></pre>
<blockquote>
<p>To be used for true one-time calculated lazy properties. I like it because it avoids sticking extra attributes on objects, and once activated does not waste time checking for attribute presence</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<h2>Metaclass option</h2>
<p>You can intercept the call to <code>__init__</code> using a metaclass.  Create the object with <code>__new__</code> and overwrite the <code>__getattribute__</code> method to check if <code>__init__</code> has been called or not and call it if it hasn't.</p>
<pre><code>class DelayInit(type):

    def __call__(cls, *args, **kwargs):

        def init_before_get(obj, attr):
            if not object.__getattribute__(obj, '_initialized'):
                obj.__init__(*args, **kwargs)
                obj._initialized = True
            return object.__getattribute__(obj, attr)

        cls.__getattribute__ = init_before_get

        new_obj = cls.__new__(cls, *args, **kwargs)
        new_obj._initialized = False
        return new_obj

class TestDelayed(TestCase1, metaclass=DelayInit):
    pass
</code></pre>
<p>In the example below, you'll see that the init print won't occur until the <code>run</code> method is executed.</p>
<pre><code>&gt;&gt;&gt; new_test = TestDelayed('delayed test params')
&gt;&gt;&gt; new_test.run()
initializing test: &lt;class '__main__.TestDelayed'&gt; with params: delayed test params
running test: &lt;class '__main__.TestDelayed'&gt;
</code></pre>
<hr/>
<h2>Decorator option</h2>
<p>You could also use a decorator that has a similar pattern to the metaclass above:</p>
<pre><code>def delayinit(cls):

    def init_before_get(obj, attr):
        if not object.__getattribute__(obj, '_initialized'):
            obj.__init__(*obj._init_args, **obj._init_kwargs)
            obj._initialized = True
        return object.__getattribute__(obj, attr)

    cls.__getattribute__ = init_before_get

    def construct(*args, **kwargs):
        obj = cls.__new__(cls, *args, **kwargs)
        obj._init_args = args
        obj._init_kwargs = kwargs
        obj._initialized = False
        return obj

    return construct

@delayinit
class TestDelayed(TestCase1):
    pass
</code></pre>
<p>This will behave identically to the example above.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, there is no way that you can avoid calling <code>__init__</code> when you instantiate a class <code>cls</code>. If calling <code>cls(args)</code> returns an instance of <code>cls</code>, then the language guarantees that <code>cls.__init__</code> will have been called.</p>
<p>So the only way to achieve something similar to what you are asking is to introduce another class that will postpone the calling of <code>__init__</code> in the original class until an attribute of the instantiated class is being accessed.</p>
<p>Here is one way:</p>
<pre><code>def delay_init(cls):
    class Delay(cls):
        def __init__(self, *arg, **kwarg):
            self._arg = arg
            self._kwarg = kwarg
        def __getattribute__(self, name):
            self.__class__ = cls
            arg = self._arg
            kwarg = self._kwarg
            del self._arg
            del self._kwarg
            self.__init__(*arg, **kwarg)
            return getattr(self, name)
    return Delay
</code></pre>
<p>This wrapper function works by catching any attempt to access an attribute of the instantiated class. When such an attempt is made, it changes the instance's <code>__class__</code> to the original class, calls the original <code>__init__</code> method with the arguments that were used when the instance was created, and then returns the proper attribute. This function can be used as decorator for your <code>TestCase1</code> class:</p>
<pre><code>class TestBase:
    def __init__(self, params):
        self.name = str(self.__class__)
        print('initializing test: {} with params: {}'.format(self.name, params))


class TestCase1(TestBase):
    def run(self):
        print('running test: ' + self.name)


&gt;&gt;&gt; t1 = TestCase1("No delay")
initializing test: &lt;class '__main__.TestCase1'&gt; with params: No delay
&gt;&gt;&gt; t2 = delay_init(TestCase1)("Delayed init")
&gt;&gt;&gt; t1.run()
running test: &lt;class '__main__.TestCase1'&gt;
&gt;&gt;&gt; t2.run()
initializing test: &lt;class '__main__.TestCase1'&gt; with params: Delayed init
running test: &lt;class '__main__.TestCase1'&gt;
&gt;&gt;&gt; 
</code></pre>
<p>Be careful where you apply this function though. If you decorate <code>TestBase</code> with <code>delay_init</code>, it will not work, because it will turn the <code>TestCase1</code> instances into <code>TestBase</code> instances.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my answer I'd like to focus on cases when one wants to instantiate a class whose initialiser (dunder init) has side effects. For instance, <a href="http://pysftp.readthedocs.io/en/release_0.2.9/pysftp.html#pysftp.Connection" rel="nofollow noreferrer"><code>pysftp.Connection</code></a>, creates an SSH connection, which may be undesired until it's actually used.</p>
<p>In a great blog series about conceiving of <a href="https://pypi.python.org/pypi/wrapt" rel="nofollow noreferrer"><code>wrapt</code></a> package (nit-picky decorator implementaion), the author describes <a href="https://github.com/GrahamDumpleton/wrapt/blob/master/blog/02-the-interaction-between-decorators-and-descriptors.md#transparent-object-proxy" rel="nofollow noreferrer">Transparent object proxy</a>. This code can be customised for the subject in question.</p>
<pre><code>class LazyObject:

    _factory = None
    '''Callable responsible for creation of target object'''

    _object = None
    '''Target object created lazily'''

    def __init__(self, factory):
        self._factory = factory

    def __getattr__(self, name):
        if not self._object:
            self._object = self._factory()

        return getattr(self._object, name)
</code></pre>
<p>Then it can be used as:</p>
<pre><code>obj = LazyObject(lambda: dict(foo = 'bar'))
obj.keys()  # dict_keys(['foo'])
</code></pre>
<p>But <code>len(obj)</code>, <code>obj['foo']</code> and other language constructs which invoke Python object protocols (dunder methods, like <code>__len__</code> and <code>__getitem__</code>) will not work. However, for many cases, which are limited to regular methods, this is a  solution.</p>
<p>To proxy object protocol implementations, it's possible to use neither <code>__getattr__</code>, nor <code>__getattribute__</code> (to do it in a generic way). The latter's documentation <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer">notes</a>:</p>
<blockquote>
<p>This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">Special method lookup</a>. </p>
</blockquote>
<p>As a complete solution is demanded, there are examples of manual implementations like <em>werkzeug</em>'s <a href="https://github.com/pallets/werkzeug/blob/8a84b62/werkzeug/local.py#L254" rel="nofollow noreferrer"><code>LocalProxy</code></a> and <em>django</em>'s <a href="https://github.com/django/django/blob/stable/1.7.x/django/utils/functional.py#L337" rel="nofollow noreferrer"><code>SimpleLazyObject</code></a>. However a clever workaround is <a href="https://stackoverflow.com/a/9059858/2072035">possible</a>.</p>
<p>Luckily there's a dedicated package (based on <em>wrapt</em>) for the exact use case, <a href="https://pypi.python.org/pypi/lazy-object-proxy" rel="nofollow noreferrer">lazy-object-proxy</a> which is described in <a href="https://blog.ionelmc.ro/2015/01/12/proxying-objects-in-python/" rel="nofollow noreferrer">this blog post</a>.</p>
<pre><code>from lazy_object_proxy import Proxy

obj = Proxy(labmda: dict(foo = 'bar'))
obj.keys()     # dict_keys(['foo'])
len(len(obj))  # 1
obj['foo']     # 'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One alternative would be to write a wrapper that takes a class as input and returns a class with delayed initialization until any member is accessed. This could for example be done as this:</p>
<pre><code>def lazy_init(cls):
    class LazyInit(cls):
        def __init__(self, *args, **kwargs):
            self.args = args
            self.kwargs = kwargs
            self._initialized = False

        def __getattr__(self, attr):
            if not self.__dict__['_initialized']:
                cls.__init__(self,
                             *self.__dict__['args'], **self.__dict__['kwargs'])
                self._initialized = True

            return self.__dict__[attr]

    return LazyInit
</code></pre>
<p>This could then be used as such</p>
<pre><code>load_test(lazy_init(TestCase1)(test_params1))
load_test(lazy_init(TestCase2)(test_params2))
...
load_test(lazy_init(TestCaseN)(test_params3))

...

for test in loaded_tests:
    test.run()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Answering your original question (and the problem I think you are actually trying to solve), "How can I delay the <strong>init</strong> call until an attribute is accessed?": don't call <strong>init</strong> until you access the attribute.</p>
<p>Said another way: you can make the class initialization simultaneous with the attribute call. What you seem to actually want is 1) create a collection of <code>TestCase#</code> classes along with their associated parameters; 2) run each test case.</p>
<p>Probably your original problem came from thinking you had to initialize all your <code>TestCase</code> classes in order to create a list of them that you could iterate over. But in fact you can store class objects in <code>lists</code>, <code>dicts</code> etc. That means you can do whatever method you have for finding all <code>TestCase</code> classes and store those class objects in a <code>dict</code> with their relevant parameters. Then just iterate that <code>dict</code> and call each class with its <code>run()</code> method.</p>
<p>It might look like:</p>
<pre><code>tests = {TestCase1: 'test 1 params', TestCase2: 'test 2 params', TestCase3: 'test 3 params'}

for test_case, param in tests.items():
    test_case(param).run()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Overridding <code>__new__</code></h2>
<p>You could do this by overriding <code>__new__</code> method and replacing <code>__init__</code> method with a custom function.</p>
<pre><code>def init(cls, real_init):
    def wrapped(self, *args, **kwargs):
        # This will run during the first call to `__init__`
        # made after `__new__`. Here we re-assign the original
        # __init__ back to class and assign a custom function
        # to `instances.__init__`.
        cls.__init__ = real_init
        def new_init():
            if new_init.called is False:
                real_init(self, *args, **kwargs)
                new_init.called = True
        new_init.called = False
        self.__init__ = new_init
    return wrapped


class DelayInitMixin(object):
    def __new__(cls, *args, **kwargs):
        cls.__init__ = init(cls, cls.__init__)
        return object.__new__(cls)


class A(DelayInitMixin):
    def __init__(self, a, b):
        print('inside __init__')
        self.a = sum(a)
        self.b = sum(b)

    def __getattribute__(self, attr):
        init = object.__getattribute__(self, '__init__')
        if not init.called:
            init()
        return object.__getattribute__(self, attr)

    def run(self):
        pass

    def fun(self):
        pass
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; a = A(range(1000), range(10000))    
&gt;&gt;&gt; a.run()
inside __init__    
&gt;&gt;&gt; a.a, a.b
(499500, 49995000)    
&gt;&gt;&gt; a.run(), a.__init__()
(None, None)    
&gt;&gt;&gt; b = A(range(100), range(10000))    
&gt;&gt;&gt; b.a, b.b
inside __init__
(4950, 49995000)    
&gt;&gt;&gt; b.run(), b.__init__()
(None, None)
</code></pre>
<h2>Using cached properties</h2>
<p>The idea is to do the heavy calculation only once by caching results. This approach will lead to much more readable code if the whole point of delaying initialization is improving performance.</p>
<p>Django comes with a nice decorator called <a href="https://docs.djangoproject.com/en/1.11/ref/utils/#django.utils.functional.cached_property" rel="nofollow noreferrer"><code>@cached_property</code></a>. I tend to use it a lot in both code and unit-tests for caching results of heavy properties.</p>
<p>A <code>cached_property</code> is a <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="nofollow noreferrer">non-data descriptor</a>. Hence once the key is set in instance's dictionary, the access to property would always get the value from there.</p>
<pre><code>class cached_property(object):
    """
    Decorator that converts a method with a single self argument into a
    property cached on the instance.

    Optional ``name`` argument allows you to make cached properties of other
    methods. (e.g.  url = cached_property(get_absolute_url, name='url') )
    """
    def __init__(self, func, name=None):
        self.func = func
        self.__doc__ = getattr(func, '__doc__')
        self.name = name or func.__name__

    def __get__(self, instance, cls=None):
        if instance is None:
            return self
        res = instance.__dict__[self.name] = self.func(instance)
        return res
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code>class A:
    @cached_property
    def a(self):
        print('calculating a')
        return sum(range(1000))

    @cached_property
    def b(self):
        print('calculating b')
        return sum(range(10000))
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.a
calculating a
499500
&gt;&gt;&gt; a.b
calculating b
49995000
&gt;&gt;&gt; a.a, a.b
(499500, 49995000)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you can use a wrapper class to hold the real class you want to instance, and use call <code>__init__</code> yourself in your code, like(Python 3 code):</p>
<pre><code>class Wrapper:
    def __init__(self, cls):
        self.cls = cls
        self.instance = None

    def your_method(self, *args, **kwargs):
        if not self.instance:
            self.instnace = cls()
        return self.instance(*args, **kwargs)

class YourClass:
    def __init__(self):
        print("calling __init__")
</code></pre>
<p>but it's a dump way, but without any trick.</p>
</div>
<span class="comment-copy">Is it just to delay some heavy initialization related to <code>self.name</code>?</span>
<span class="comment-copy">For some of the cases, yes.</span>
<span class="comment-copy">Then better make them properties and do the heavy work in their getters. It sounds like a <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a> right now.</span>
<span class="comment-copy">While there is no way to achieve what you ask without the alterations you forbid, with a little more insight into your requirements I think someone might be able to help you.</span>
<span class="comment-copy">Can you add a superclass or a metaclass to <code>TestBase</code>?</span>
<span class="comment-copy">Read your question, but why don't you just make the <code>run</code> method your initializer, which is lazy? I have some methods that perform very expensive operations (e.g. network access) that do this. All you have to do is make an instance method lazy, and once it does its work, you just make that method replace itself with a non-lazy method. Maybe I'll write an answer soon over what I did with my program.</span>
