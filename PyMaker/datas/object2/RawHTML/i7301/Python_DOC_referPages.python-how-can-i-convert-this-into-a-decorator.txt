<div class="post-text" itemprop="text">
<p>I cant't for the life of me figure out how to make this into a decorator.
Any help or an example would be awesome.</p>
<p><strong>Here is the code</strong></p>
<pre><code>import datetime    

def time_func(function, *args, **kwargs):
  '''
  Add the execution time to a functions attributes 
  '''
  # Start the clock.
  start = datetime.datetime.now()
  # Execute the function and record the results.
  function_result = function(*args, **kwargs)
  # Calculate the elapsed time and add it to the function
  # attributes.
  function.elapsed = datetime.datetime.now() - start
  # Returned the function with the added elapsed attribute 
  return function_result
</code></pre>
<p><strong>Here is an example use</strong></p>
<pre><code>.. import datetime 
..  
..  
.. def time_func(function, *args, **kwargs): 
..   ''' 
..   Add the execution time to a functions attributes  
..   ''' 
..   # Start the clock. 
..   start = datetime.datetime.now() 
..   # Execute the function and record the results. 
..   function_result = function(*args, **kwargs) 
..   # Calculate the elapsed time and add it to the function 
..   # attributes. 
..   function.elapsed = datetime.datetime.now() - start 
..   # Returned the function with the added elapsed attribute  
..   return function_result 
..    
..  
.. def f(name): 
..   print name 
..    
.. time_func(f, 'foo') 
.. print f.elapsed 
.. 
foo
0:00:00.000115
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A decorator is simply a function that takes a function and returns a function.</p>
<pre><code>import datetime

def time_func(function):
    # create a new function based on the existing one,
    # that includes the new timing behaviour
    def new_func(*args, **kwargs):
        # Start the clock.
        start = datetime.datetime.now()
        # Execute the function and record the results.
        function_result = function(*args, **kwargs)
        # Calculate the elapsed time and add it to the function
        # attributes.
        new_func.elapsed = datetime.datetime.now() - start
        # Returned the function with the added elapsed attribute 
        return function_result
    return new_func
</code></pre>
<p>Usage:</p>
<pre><code>@time_func
def f(name):
    print(name)

f('foo')
print(f.elapsed)
&gt; foo
&gt; 0:00:00.000045
</code></pre>
<p>Check out <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a> to further improve the decorator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Define an inner function:</p>
<pre><code>import datetime    

def time_func(function):
    '''
    Add the execution time to a functions attributes 
    '''
    def func(*args, **kwargs):
        start = datetime.datetime.now()
        function_result = function(*args, **kwargs)
        func.elapsed = datetime.datetime.now() - start
        return function_result
    return func

@time_func
def f(name):
    print name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A common way to make decorators is to use two nested functions:</p>
<pre><code>def time_func(function):
  def wrapper(*args, **kwargs):
      start = datetime.datetime.now()
      function_result = function(*args, **kwargs)
      wrapper.elapsed = datetime.datetime.now() - start
      return function_result
   return wrapper
</code></pre>
<p>The only major between this code and your original (other than stripping out the comments for space) is that the <code>function</code> is supplied by a call to the outer function while the other arguments are supplied to the wrapper function. We also need to save the <code>elapsed</code> time on the <code>wrapper</code> function instead of the original function (since the original will not be accessible any more when you a decorator).</p>
</div>
<span class="comment-copy">check this <a href="https://stackoverflow.com/a/44846831/6655211">post</a></span>
<span class="comment-copy">have you thought about using the <code>timeit</code> module?</span>
<span class="comment-copy">This doesn't work since <code>function.elapsed</code> saves the result to the old function instead of the wrapped one. Instead, use <code>wrapper.elapsed</code>.</span>
<span class="comment-copy">Thanks, I've edited my answer to correct that.</span>
