<div class="post-text" itemprop="text">
<pre><code>def second_largest(nums):
    the, sec = 0, 0
    if nums[0] &gt; nums[1]:
        the, sec = nums[0], nums[1]
    else:
        the, sec = nums[1], nums[0]

    for num in nums:
        if num &gt; sec:
            if num &gt;= the:
                the, sec = num, the
            else:
                sec = num
    return sec
</code></pre>
<p>This is my code to get second largest element from the list.
I assumed that a list has at least two elements. 
However, it gives me 'gamma' not 'delta' from the input below.</p>
<pre><code>print(second_largest(['alpha', 'gamma','beta','delta']))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You've initialized the largest and second-largest values to the first two items in the appropriate order, but then you're including them again in the loop. If the largest value was also one of the first two values, it will take up both slots after that point. You can fix it by creating an iterator from the list explicitly and advancing it for the first two elements:</p>
<pre><code>def second_largest(nums):
    it = iter(nums)
    sec, the = sorted((next(it), next(it)))

    for num in it:
        if num &gt; sec:
            if num &gt;= the:
                the, sec = num, the
            else:
                sec = num

    return sec
</code></pre>
<p>By not using indexed access, this also has the advantage of working on any iterable.</p>
<p>For real-world use, see <a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer"><code>heapq.nlargest</code></a>, which even has specific optimizations in CPython for small numbers of elements.</p>
</div>
<div class="post-text" itemprop="text">
<p>a simple way is to find max and remove it. finding the max is on o(n)</p>
<pre><code>&gt;&gt;&gt; x=['alpha', 'gamma','beta','delta']
&gt;&gt;&gt; m=x[0]
&gt;&gt;&gt; for i in x:
    if i &gt; m:
        m=i

&gt;&gt;&gt; x.remove(m)
</code></pre>
<p>and for second time:</p>
<pre><code>&gt;&gt;&gt; m=x[0]
&gt;&gt;&gt; for i in x:
    if i &gt; m:
        m=i
&gt;&gt;&gt; print(m) #scond max
</code></pre>
<p>o(n)+...+o(n) -&gt;  L * o(n) -&gt; o(n) </p>
</div>
<span class="comment-copy">Well, write your algorithm on paper. What do you get?</span>
<span class="comment-copy">Why not just <code>sorted(['alpha', 'gamma','beta','delta'], reverse=True)[1]</code> ?</span>
<span class="comment-copy">@zwer: That has worse time and space complexity.</span>
<span class="comment-copy">@zwer: Who says it's premature? There's a better-than-even chance that this is a homework assignment with getting O(n) as a goal, anyway.</span>
<span class="comment-copy">If we're optimizing with builtins, see <code>heapq.nlargest</code></span>
<span class="comment-copy">Does this work as intended? <code>second_largest(['alpha', 'gamma','beta','delta', 'echo'])</code>  returns <code>echo</code></span>
<span class="comment-copy">@cricket_007: Yeah, because "g" comes after "e".</span>
<span class="comment-copy">@cricket_007 Yes. echo is correct answer.</span>
<span class="comment-copy">Hmm. It's getting late, I guess ;)</span>
