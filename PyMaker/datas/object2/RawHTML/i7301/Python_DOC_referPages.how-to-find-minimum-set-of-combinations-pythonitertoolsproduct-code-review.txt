<div class="post-text" itemprop="text">
<p><strong>How can I improve this code, without computing all possible combinations returned by itertools.product function.
Is there any other solutions to do it efficiently.</strong></p>
<p>This is what I have tried: </p>
<pre><code>import itertools

mylist = [[1,2,3],[1,3,4],[1,2,3]]

k = [set(i) for i in list(itertools.product(*mylist))]
k = sorted(k)
D_all = list(k for k, _ in itertools.groupby(k))
D_all.sort(key=len)


# Finding and displaying the minimum order-split combination
l = len(D_all[0])
print("Minimum number of Distributor Combination found is: {}".format(l))
print("The Possible combinations of {} are: ".format(l))
D_best = []
c = 0
for n,i in enumerate(D_all):

    if len(i)&lt;=l:
        c +=1
        print("{}:{}".format(c,i))
        D_best.append(i)
        if len(i)&gt;l+1: break
</code></pre>
<blockquote>
<p>output:</p>
</blockquote>
<pre><code>Minimum number of Distributor Combination found is: 1
The Possible combinations of 1 are: 
1:{'1'}
2:{'3'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe I have it. You can take advantage of the fact that <code>itertools.product</code> <code>yields</code> its <code>tuple</code>s in a <em>deterministic</em> way; you know beforehand when all the <em>singletons</em> would be yielded. You just have to calculate when that will happen.</p>
<pre><code>from itertools import islice, product
from functools import reduce

mylist = [[1, 2, 3], [1, 3, 4], [1, 2, 3]]

stop_cond = (len(mylist[0]) - 1) * reduce(lambda x, y: len(x) * len(y), mylist[1:])
pivot = mylist[0][-1]
stop_cond += reduce(lambda x, y: (x.index(pivot) + 1) * (y.index(pivot) + 1), mylist[1:])

k = [set(item) for item in islice(product(*mylist), stop_cond)]
print(k)  #[{1}, {1, 2}, {1, 3}, {1, 3}, {1, 2, 3}, {1, 3}, {1, 4}, {1, 2, 4}, {1, 3, 4}, {1, 2}, {1, 2}, {1, 2, 3}, {1, 2, 3}, {2, 3}, {2, 3}, {1, 2, 4}, {2, 4}, {2, 3, 4}, {1, 3}, {1, 2, 3}, {1, 3}, {1, 3}, {2, 3}, {3}]
</code></pre>
<p>In this case, the last singleton would be <code>{3}</code> because <code>3</code> appears on the last position of the first <code>list</code> (i call that <code>pivot</code> in the code). To get its singleton you have to get all others first and that takes 3 * 3 yields for each. That is 9 + 9 = 18. Now for the last, you just need to find its index in the remaining lists (in a 1-index based system) and multiply those together.</p>
</div>
<span class="comment-copy">This isn't really clear. If you only want the "singletons" (which I assume you mean length 1 sets) why to even bother with <code>.product</code>? You can simply take individual elements from the lists.</span>
<span class="comment-copy">It is not clear to me exactly you are looking for.</span>
<span class="comment-copy">@DeepSpace The way I understand it is that OP wants to get whatever <code>.product</code> gives him until all the singletons are <code>yield</code>ed and then stop.</span>
<span class="comment-copy">@DeepSpace it sure sounds like it is, in the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">docs</a>. "The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the inputâ€™s iterables are sorted, the product tuples are emitted in sorted order."</span>
<span class="comment-copy">@DeepSpace I would assume it is, which would make this problem easier since you just have to know how many results you have to draw from it. If it is not you have to check for the singletons. Drawing <b>24</b> elements should cut it in this case.</span>
<span class="comment-copy">Then use <code>islice()</code> instead of a <code>enumerate()</code> and a test each time to simply limit how many items are produced.</span>
<span class="comment-copy">@MartijnPieters Thanks for the feedback!</span>
