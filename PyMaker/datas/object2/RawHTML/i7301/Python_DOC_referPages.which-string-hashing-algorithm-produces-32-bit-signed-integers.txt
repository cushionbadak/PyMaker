<div class="post-text" itemprop="text">
<p>I want to hash strings of variable length (6-60 characters long) to 32-bit <a href="https://www.postgresql.org/docs/9.5/static/datatype-numeric.html" rel="nofollow noreferrer">signed integers</a> in order to save disk space in PostgreSQL.</p>
<p>I don't want to encrypt any data, and the hashing function needs to be reproducible and callable from Python. The problem is that I can only find Algorithms that produce <strong>unsigned integers</strong> (like CityHash), which therefore produce values of up to 2^32 instead of 2^31.</p>
<p>This is what I have thus far:</p>
<pre><code>import math
from cityhash import CityHash32

string_ = "ALPDAKQKWTGDR"
hashed_string = CityHash32(string_)
print(hashed_string, len(str(hashed_string)))
max_ = int(math.pow(2, 31) - 1)
print(hashed_string &gt; max_)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ryan answered the question in the comments. Simply subtract 2147483648 (= 2^31) from the hash result.</p>
<pre><code>CityHash32(string_) - math.pow(2, 31)
</code></pre>
<p>or</p>
<pre><code>CityHash64(string_) - math.pow(2, 63)
</code></pre>
<p>Ryan also mentioned that using SHA-512 and truncating the result to the desired number of digits will lead to less collisions than the method above. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>create or replace function int_hash(s text)
returns int as $$

    select ('x' || left(md5(s), 8))::bit(32)::int
    ;
$$ language sql immutable;

select int_hash('1');
  int_hash  
------------
 -993377736
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I typically wouldn't use a 32-bit hash except for very low cardinality because it of course risks collisions a lot more than a 64-bit hash would. Databases readily support bigint 8-byte (64-bit) integers. Consider <a href="https://preshing.com/images/small-probabilities.png" rel="nofollow noreferrer">this table</a> for some hash collision probabilities.</p>
<p>If you're using Python â‰¥3.6, you absolutely don't need to use a third-party package for this, and you don't need to subtract an offset either, since you can <strong>directly generate a signed 64-bit or <a href="https://docs.python.org/3/library/hashlib.html#shake-variable-length-digests" rel="nofollow noreferrer">variable bit-length hash</a> utilizing <code>shake_128</code></strong>:</p>
<pre><code>import hashlib
from typing import Dict, List


class Int8Hash:

    BYTES = 8
    BITS = BYTES * 8
    BITS_MINUS1 = BITS - 1
    MIN = -(2**BITS_MINUS1)
    MAX = 2**BITS_MINUS1 - 1

    @classmethod
    def as_dict(cls, texts: List[str]) -&gt; Dict[int, str]:
        return {cls.as_int(text): text for text in texts}  # Intentionally reversed.

    @classmethod
    def as_int(cls, text: str) -&gt; int:
        seed = text.encode()
        hash_digest = hashlib.shake_128(seed).digest(cls.BYTES)
        hash_int = int.from_bytes(hash_digest, byteorder='big', signed=True)
        assert cls.MIN &lt;= hash_int &lt;= cls.MAX
        return hash_int

    @classmethod
    def as_list(cls, texts: List[str]) -&gt; List[int]:
        return [cls.as_int(text) for text in texts]
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; Int8Hash.as_int('abc')
6377388639837011804
&gt;&gt;&gt; Int8Hash.as_int('xyz')
-1670574255735062145

&gt;&gt;&gt; Int8Hash.as_list(['p', 'q'])
[-539261407052670282, -8666947431442270955]
&gt;&gt;&gt; Int8Hash.as_dict(['i', 'j'])
{8695440610821005873: 'i', 6981288559557589494: 'j'}
</code></pre>
<p>To generate a 32-bit hash instead, set <code>Int8Hash.BYTES</code> to 4.</p>
<p>Disclaimer: I have not written a statistical unit test to verify that this implementation returns uniformly distributed integers.</p>
</div>
<span class="comment-copy">Just interpret the unsigned integer as a signed integer?</span>
<span class="comment-copy">@Ryan The result has to be between -2147483648 and +2147483647. How will your suggestion help? Can you please give me an example.</span>
<span class="comment-copy">Subtract 2147483648.</span>
<span class="comment-copy">@Ryan Looks like a simple solution. I guess it would lead to the same amount of collisions as the original value and less than truncating a longer hash?</span>
<span class="comment-copy">Well, it gets you 32 bits. There are other points to consider, though. What do you do with the strings that lets you throw them away and only store their hashes?</span>
<span class="comment-copy">@Scoots The way it is broken has nothing to do with the question other than that with 4 bytes only the collision rate will be high.</span>
