<div class="post-text" itemprop="text">
<p>The slow function (as seen in the code comments) weighs in at a whopping total of 11 seconds for a trivial request right now; an order of magnitude higher than the 10 second time limit the calling API has.</p>
<p>Optimizations are not possible as some of these API's are third party. What I believe I need is to get a way to either offload the API calls into an asynchronous task (instead of the normal sequential programming), process or thread which can happen in its own time. </p>
<pre><code>@app.route('/webhook', methods=['POST'])
def webhook():
    # Get JSON request 
    jsonRequest = request.get_json(silent=True, force=True)

    # Call slow function and get the result
    appResult = process_request(jsonRequest)
    appResult = json.dumps(appResult, indent=4)

    # Make a JSON response 
    jsonResponse = make_response(appResult)
    jsonResponse.headers['Content-Type'] = 'application/json'

    return jsonResponse



def process_request(req):

# Call a separate function here or do it all in this one (API Calls, processing etc)

# Return a value        
    return {
  "version": "1.0",
  "response": {
    "shouldEndSession": True,
    "outputSpeech": {
      "type": "PlainText",
      "text": "Return String"
    },
    "card": {
      "type": "Simple",
      "title": "Title",
      "content": "Return String"
    }
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is how it was resolved:</p>
<pre><code>newThread = threading.Thread(target=api_processing_thread, args=[jsonRequest])

newThread.start()
</code></pre>
</div>
<span class="comment-copy">maybe try <code>celery</code>?</span>
<span class="comment-copy">If you want to try and run this asynchronously, you should try <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> as it's official. Personally I tried to use it but found it didn't support my needs and ended up doing multi-threading instead but it seemed pretty powerful.</span>
<span class="comment-copy">11 isn't an order of magnitude larger than 10. Is that a typo or are you trying to shave 1 second off?</span>
<span class="comment-copy">You could design your service to subscribe to a hook that is notified upon completion of the task.  Or more hackishly, upon receiving a request to perform a task, immediately return a number, designating some request ID, then constantly ping the service until finished.  The metaphor for this would be getting a number while standing in line at the DMV.  Also you should identify your bottleneck because if your task is by nature serial, you can't async it away.</span>
<span class="comment-copy">@Russley Shaw That's a pretty interesting idea!</span>
