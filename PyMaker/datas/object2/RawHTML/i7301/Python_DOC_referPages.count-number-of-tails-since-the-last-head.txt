<div class="post-text" itemprop="text">
<p>Consider a sequence of coin tosses: 1, 0, 0, 1, 0, 1 where tail = 0 and head = 1.</p>
<p>The desired output is the sequence: 0, 1, 2, 0, 1, 0</p>
<p>Each element of the output sequence counts the number of tails since the last head.</p>
<p>I have tried a naive method:</p>
<pre><code>def timer(seq):
    if seq[0] == 1: time = [0]
    if seq[0] == 0: time = [1]
    for x in seq[1:]:
        if x == 0: time.append(time[-1] + 1)
        if x == 1: time.append(0)
    return time
</code></pre>
<p><strong>Question</strong>: Is there a better method?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using NumPy:</p>
<pre><code>import numpy as np 
seq = np.array([1,0,0,1,0,1,0,0,0,0,1,0])
arr = np.arange(len(seq))
result = arr - np.maximum.accumulate(arr * seq)
print(result)
</code></pre>
<p>yields</p>
<pre><code>[0 1 2 0 1 0 1 2 3 4 0 1]
</code></pre>
<hr/>
<p><em>Why <code>arr - np.maximum.accumulate(arr * seq)</code>?</em> The desired output seemed related to a simple progression of integers:</p>
<pre><code>arr = np.arange(len(seq))
</code></pre>
<p>So the natural question is, if <code>seq = np.array([1, 0, 0, 1, 0, 1])</code> and the expected result is <code>expected = np.array([0, 1, 2, 0, 1, 0])</code>, then what value of <code>x</code> makes</p>
<pre><code>arr + x = expected
</code></pre>
<p>Since</p>
<pre><code>In [220]: expected - arr
Out[220]: array([ 0,  0,  0, -3, -3, -5])
</code></pre>
<p>it looks like <code>x</code> should be the cumulative max of <code>arr * seq</code>:</p>
<pre><code>In [234]: arr * seq
Out[234]: array([0, 0, 0, 3, 0, 5])

In [235]: np.maximum.accumulate(arr * seq)
Out[235]: array([0, 0, 0, 3, 3, 5])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong><em>Step 1:</em></strong> Invert <code>l</code>:</p>
<pre><code>In [311]: l = [1, 0, 0, 1, 0, 1]

In [312]: out = [int(not i) for i in l]; out
Out[312]: [0, 1, 1, 0, 1, 0]
</code></pre>
<p><strong><em>Step 2:</em></strong> List comp; add previous value to current value if current value is 1.</p>
<pre><code>In [319]: [out[0]] + [x + y if y else y for x, y in zip(out[:-1], out[1:])]
Out[319]: [0, 1, 2, 0, 1, 0]
</code></pre>
<p>This gets rid of windy ifs by zipping adjacent elements.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a>:</p>
<pre><code>&gt;&gt;&gt; a = [1, 0, 0, 1, 0, 1]
&gt;&gt;&gt; b = [1 - x for x in a]
&gt;&gt;&gt; list(accumulate(b, lambda total,e: total+1 if e==1 else 0))
[0, 1, 2, 0, 1, 0]
</code></pre>
<p><code>accumulate</code> is only defined in Python 3. There's the equivalent Python code in the above documentation, though, if you want to use it in Python 2.</p>
<p>It's required to invert <code>a</code> because the first element returned by <code>accumulate</code> is the first list element, independently from the accumulator function:</p>
<pre><code>&gt;&gt;&gt; list(accumulate(a, lambda total,e: 0))
[1, 0, 0, 0, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The required output is an array with the same length as the input and none of the values are equal to the input. Therefore, the algorithm must be at least O(n) to form the new output array. Furthermore for this specific problem, you would also need to scan all the values for the input array. All these operations are O(n) and  it will not get any more efficient. Constants may differ but your method is already in O(n) and will not go any lower.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>reduce</code>:</p>
<p><code>time = reduce(lambda l, r: l + [(l[-1]+1)*(not r)], seq, [0])[1:]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I try to be clear in the following code and differ from the original in using an explicit accumulator. </p>
<pre><code>&gt;&gt;&gt; s = [1,0,0,1,0,1,0,0,0,0,1,0]
&gt;&gt;&gt; def zero_run_length_or_zero(seq):
    "Return the run length of zeroes so far in the sequnece or zero"
    accumulator, answer = 0, []
    for item in seq:
        accumulator = 0 if item == 1 else accumulator + 1
        answer.append(accumulator)
    return answer

&gt;&gt;&gt; zero_run_length_or_zero(s)
[0, 1, 2, 0, 1, 0, 1, 2, 3, 4, 0, 1]
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">Is there something <i>wrong</i> with your method?  What do you mean by "success" and "failure"?</span>
<span class="comment-copy">Success = head, failure = tail. I've changed the title in case it's confusing.</span>
<span class="comment-copy">Is there an error in your code? This question should be on <i>Code Review</i>.</span>
<span class="comment-copy">You will get an index error if you pass in an empty sequence, but other than that it looks fine to me.</span>
<span class="comment-copy">great Pythonic answer!</span>
<span class="comment-copy">@nutmeg64 Thanks, appreciate it :)</span>
<span class="comment-copy">Nice analysis. However, the constants may be reduced substantially if the looping can be done internally by functions or methods that run at C speed, rather than using a Python <code>for</code> loop.</span>
