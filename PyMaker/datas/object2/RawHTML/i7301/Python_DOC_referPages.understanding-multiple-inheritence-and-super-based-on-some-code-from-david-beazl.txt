<div class="post-text" itemprop="text">
<p>I watched a <a href="https://www.youtube.com/watch?v=js_0wjzuMfc" rel="nofollow noreferrer">screencast</a> from David Beazly in which he implemeneted type checking using multiple or more specifically diamond inheritence. I thought that his approach looked really cool but it also confused me and I simply can't figure out how it is working. Here is the code im talking about:</p>
<pre><code>class Contract:
    @classmethod
    def check(cls, value):
        pass


class Integer(Contract):
    @classmethod
    def check(cls, value):
        assert isinstance(value, int), 'Expected int'
        super().check(value)


class Positive(Contract):
    @classmethod
    def check(cls, value):
        assert value &gt; 0, 'Must be &gt; 0'
        super().check(value)


class PositiveInteger(Positive, Integer):
    pass
</code></pre>
<p>And here it is in action:</p>
<pre><code>&gt;&gt;&gt; PositiveInteger.check(-3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in check
AssertionError: Must be &gt; 0
&gt;&gt;&gt; PositiveInteger.check(4.88)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in check
  File "&lt;stdin&gt;", line 4, in check
AssertionError: Expected int
</code></pre>
<p>My Questions are:</p>
<ol>
<li><p>Why is the definition of a base class Contract with a method check needed to make this work?</p></li>
<li><p>I have a basic understanding of what super does. I know it lets us avoid calling the base class explicitly and somehow deals with multiple inheritence. But what does it do in this example exactly?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Let's go through it line by line like a debugger.</p>
<pre><code>PositiveInteger.check(x)

# Method resolution order:
# PositiveInteger, Positive, Integer, Contract (from Positive), Contract (from Integer)

# Look through MRO for .check() method. Found in Positive.

assert x &gt; 0
super().check(value)

# super() checks for next .check() method in MRO. Found in Integer

assert isinstance(x, int)
super().check(value)

# super() checks for next .check() method in MRO. Found in Contract

pass
</code></pre>
<p>To easily find the method resolution order, use <a href="https://docs.python.org/3/library/inspect.html#inspect.getmro" rel="nofollow noreferrer"><code>inspect.getmro()</code></a>.</p>
<p>If you had explicitly used the base class, after <code>Positive</code>, the base class is <code>Contract</code>, so <code>Integer</code> would never be called.</p>
<p>You need to define <code>.check()</code> in <code>Contract</code> as when you call the last <code>super()</code>, if <code>Contract</code> didn't have the <code>.check()</code> method, it would have raised an <code>AttributeError</code>, as <code>super()</code> wouldn't have been able to find it.</p>
</div>
<span class="comment-copy">Related, if not duplicate: <a href="https://stackoverflow.com/questions/3277367/how-does-pythons-super-work-with-multiple-inheritance">How does Python's super() work with multiple inheritance?</a></span>
<span class="comment-copy">@NickT: I am aware of this thread and I did read it but it didn't help me understanding this problem</span>
<span class="comment-copy">I think the idea is that somewhere in the MRO there should/must be a method so you put it in the base class - even if it doesn't do anything or just raises a NotImplemented exception.</span>
<span class="comment-copy">Take a look at the practical Advice section of <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">Python's super() considered super!</a></span>
<span class="comment-copy">@wwii: I think I did express myself unclear. Could you have a look at my comment at Artyer's answer?</span>
