<div class="post-text" itemprop="text">
<p>I need to iterate over the product of a generator with itself, excluding the diagonal.  I'm attempting to use <code>itertools.tee</code> to consume the same generator twice</p>
<pre><code>def pairs_exclude_diagonal(it):
    i1, i2 = itertools.tee(it, 2)
    for x in i1:
        for y in i2:
            if x != y:
                yield (x, y)
</code></pre>
<p>This does not work</p>
<pre><code>In [1]: for (x, y) in pairs_exclude_diagonal(range(3)):
   ...:     print(x, y)
0 1
0 2
</code></pre>
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer">documentation for tee</a> states:</p>
<blockquote>
<p>Return n independent iterators from a single iterable.</p>
</blockquote>
<p>What's the proper way to do this?</p>
<p>(I'm using python3.6.1)</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you want to use <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a>.</p>
<pre><code>In [1]: import itertools

In [2]: for x, y in itertools.permutations(range(3), 2):
   ...:     print(x, y)
   ...:     
0 1
0 2
1 0
1 2
2 0
2 1
</code></pre>
<p>If you <em>really</em> want to do it using <code>tee</code>, you will have to turn the second iterable into a <code>list</code> so that it is not exhausted on the second time through the outer <code>for</code> loop:</p>
<pre><code>In [14]: def pairs_exclude_diagonal(it):
    ...:     i1, i2 = itertools.tee(it, 2)
    ...:     l2 = list(i2)
    ...:     for x in i1:
    ...:         for y in l2:
    ...:             if x != y:
    ...:                 yield (x, y)
    ...:                 

In [15]: for (x, y) in pairs_exclude_diagonal(range(3)):
    ...:     print(x, y)
    ...:     
0 1
0 2
1 0
1 2
2 0
2 1
</code></pre>
<p>Note that this is pretty pointless, since calling <code>list</code> on an iterator loads it into memory and defeats the purpose of having an iterator in the first place.</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue is that you're trying to reuse the <code>i2</code> iterator. After it's been iterated once, it's exhausted and so you won't be able to iterate on it again. When you try, it yields nothing.</p>
<p>I think rather than <code>tee</code> (which is not very efficient for this purpose anyway), you should use <code>itertools.product</code> to generate all pairs (before filtering out the ones you want to skip):</p>
<pre><code>def pairs_exclude_diagonal(it):
    for x, y in itertools.product(it, repeat=2):
        if x != y:
            yield (x, y)
</code></pre>
</div>
<span class="comment-copy">This answer is a bit better than mine (which I'll keep up for the explanation of the issue with the questioner's code, not so much for my solution). I'd say your <code>tee</code> solution is pretty pointless though. If you're going to call <code>list</code> on one of the iterators, you might as well just call it on the <code>it</code> argument directly and use it for both loops.</span>
<span class="comment-copy">@Blckknght I 100% agree that the <code>tee</code> solution is pointless.  I thought about explaining that... but then I didn't.  I'll add a bit about that now.</span>
<span class="comment-copy">I had somehow got it in my head that I had tried <code>product</code> and it had the same issue.  Just tried and it works just fine.  DoH.</span>
<span class="comment-copy">Also, of course on using the <code>it2</code> twice.  Thanks for pointing that out.</span>
<span class="comment-copy">I get an unpacking error for this recipe unless I use <code>repeat=2</code> in <code>product</code>. This works as-is for you?</span>
<span class="comment-copy">I had to do the same.  The docs for <code>product</code> also clearly specify to provide that argument when "compute[ing] the product of an iterable with itself".</span>
<span class="comment-copy">Whoops, yeah, that's an error. I'll edit the answer. I think @SethMMorton's answer using <code>itertools.permutations</code> is probably better than doing filtering on the values yielded by <code>product</code>.</span>
