<div class="post-text" itemprop="text">
<p>Can I run this swagger server</p>
<pre><code>app = connexion.App(__name__, specification_dir='./swagger/')
app.app.json_encoder = JSONEncoder
app.add_api('swagger.yaml', arguments={'title': ''})

app.run(port=8080)
</code></pre>
<p>and this websocket server </p>
<pre><code>from autobahn.twisted.websocket import WebSocketServerProtocol
import sys

from twisted.python import log
from twisted.internet import reactor
log.startLogging(sys.stdout)

from autobahn.twisted.websocket import WebSocketServerFactory
factory = WebSocketServerFactory()
factory.protocol = MyServerProtocol

reactor.listenTCP(9000, factory)
reactor.run()
</code></pre>
<p>in two different threads, in python? Ultimately, when an <code>id</code> is posted to my swagger API, I want to forward this <code>id</code> to my websocket server and then send it through an existing matching connection to my websocket client. So i thought that if I ran those two in two threads, maybe I could share this <code>id</code> as a variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you choose to run the Twisted reactor in a non-main thread, you'll have to disable its signal handling (because Python only allows signal handlers in the main thread).  This will disable some functionality but if you're not using that functionality this should be fine.</p>
<p>Just start the reactor this way:</p>
<pre><code>reactor.run(installSignalHandlers=False)
</code></pre>
<p>This will let you run your Twisted code in a non-main thread (all in the same thread, so threadsafey issues should be minimized or eliminated).  That will, in turn, allow you to run your Swagger code in the main thread where it should work fine (because that's what you normally do).</p>
<p>Alternatively, you could put the Swagger code in a non-main thread and Twisted in the main thread.  I don't know if there are steps you need to take to be able to run the Swagger code in a non-main thread.</p>
<p>When it comes time to start passing data between the threads, you don't just want a variable that gets written by one and read by the other.  That would be a great step towards having non-thread-safe code.  Instead, use one or more of the Twisted APIs for messaging between threads.  For example, <code>reactor.callFromThread</code> is thread-safe (you're allowed to call it from any thread safely) and can be used to send a message from the Swagger thread to the Twisted reactor thread.  Something like:</p>
<pre><code>reactor.callFromThread(process_received_id, id)
</code></pre>
<p>Now <code>process_received_id(id)</code> will execute in the Twisted reactor thread "soon" and you can do whatever you want, confident you don't have thread-safety issues because it's just <em>as if</em>, from the perspective of <code>process_received_id</code>, you're in a single-threaded application.</p>
</div>
<span class="comment-copy">Unless something in Swagger or Twisted websocket actively prevents threads, as long as both remain running in the background of your service there is no reason why it wouldn't work. However, given the different scopes, it might be a better idea to do a separation of concerns and have them both run as separate instances by using some form of IPC to exchange data between those two. There are a several built-in ways to do it listed on <a href="https://docs.python.org/3/library/ipc.html" rel="nofollow noreferrer">Interprocess Communication and Networking</a> and there is a metric ton of ways to do it through external resources.</span>
