<div class="post-text" itemprop="text">
<p>How can I access the local variables of a super class method in an overridden method in the subclass? </p>
<pre><code>class Foo(object):
    def foo_method(self):
        x = 3

class Bar(Foo):
    def foo_method(self):
        super().foo_method()
        print(x) # Is there a way to access x, besides making x an attribute of the class?
</code></pre>
<p>The code below gives a <code>NameError: name 'x' is not defined</code></p>
<pre><code>bar = Bar()
bar.foo_method()
</code></pre>
<p>This isn't surprising, and it can be fixed by making <code>x</code> an instance attribute, but can <code>x</code> be accessed as-is in <code>Bar.foo_method</code> more directly?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Summary</h2>
<blockquote>
<p>Q. ... can x be accessed as-is in Bar.foo_method more directly?</p>
</blockquote>
<p>As written, <strong>the answer is no</strong>.</p>
<p>By the time the <code>super().foo_method()</code> has returned, the stack frame for that method has been wrapped-up and the local variables are gone.  There is nothing to access.</p>
<h2>Alternative solution:  return statement</h2>
<p>The easiest solution to sharing the data is to have <code>foo_method</code> return <em>x</em>:</p>
<pre><code>class Foo(object):
    def foo_method(self):
        x = 3
        return x

class Bar(Foo):
    def foo_method(self):
        x = super().foo_method()
        print(x)
</code></pre>
<h2>Alternative solution:  dynamic scoping</h2>
<p>If you're looking for something akin to <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping" rel="nofollow noreferrer">dynamic scoping</a>, the easiest solution is to pass in a shared namespace:</p>
<pre><code>class Foo(object):
    def foo_method(self, ns):
        x = 3
        ns['x'] = 3

class Bar(Foo):
    def foo_method(self):
        ns = {}
        super().foo_method(ns)
        x = ns['x']
        print(x)
</code></pre>
<p>If you want to simulate dynamic scoping in nested calls, consider using <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><em>collections.ChainMap()</em></a>. </p>
</div>
<span class="comment-copy">You canâ€™t do that. Why do you need to?</span>
<span class="comment-copy">I don't need to do it.  I just want to know if it's possible.  Usually when a feature of Python is hard to find, then it means there is a better way to do it.</span>
<span class="comment-copy">In theory, you <i>shouldn't</i> know the internal workings of a class/method unless it specifically exposes those as public properties.</span>
<span class="comment-copy">I like the dynamic scoping edit.  Since this only really matters when you can't change the signature and return type, then maybe ns should be an optional keyword argument, and add the <code>x</code> key only if it is not <code>None</code>.</span>
