<div class="post-text" itemprop="text">
<p>I am familiar with try, except. However I'm looking for a more general method that just runs a simple command before the script stops running after any error is raised.</p>
<p>For example if I'm using xlsxwriter:</p>
<pre><code>import xlsxwriter
wb = xlssxwriter.Workbook
ws = wb.add_worksheet()
for i in range (len(list)):
    ws.write(i,0,"Hello World!")

#If this script fails, run ws.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what context managers are for (the <code>with</code> statement). The Workbook class actually provides what is necessary.</p>
<p>It is as simple as</p>
<pre><code>with xlsxwriter.Workbook('hello_world.xlsx') as workbook:
    worksheet = workbook.add_worksheet()
    [...]
</code></pre>
<p>See <a href="http://xlsxwriter.readthedocs.io/workbook.html" rel="nofollow noreferrer">Workbook documentation</a></p>
<hr/>
<p>In case you want to do other things as well, the <code>try ... except ... else ... finally</code> statement(s) are what you need. See <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow noreferrer">documentation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>For the specific case of calling a <code>close</code> method (where the object doesn't support the context management protocol natively, so you can't use it bare in a <code>with</code> statement), you can improve a bit on <code>try</code>/<code>finally</code> by <a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing" rel="nofollow noreferrer">using <code>contextlib.closing</code></a> to wrap it such that it's <code>with</code> statement compatible, replacing your code:</p>
<pre><code>ws = wb.add_worksheet()
for i in range (len(list)):
    ws.write(i,0,"Hello World!")
</code></pre>
<p>with (adding <code>import contextlib</code> to the top of your file):</p>
<pre><code>with contextlib.closing(wb.add_worksheet()) as ws:
    for i in range(len(list)):
        ws.write(i,0,"Hello World!")
</code></pre>
<p>That calls <code>close</code> unconditionally when the block is exited, whether by exception, <code>return</code>, or just naturally leaving the block without error or <code>return</code>ing (which is usually what you want). If for some reason you only want to call it when you have an exception, you can do:</p>
<pre><code>ws = wb.add_worksheet()
try:
    for i in range (len(list)):
        ws.write(i,0,"Hello World!")
except:  # Okay to use bare except because we re-raise after cleanup
    ws.close()
    raise  # Re-raise whatever exception led us here now that cleanup is done
</code></pre>
<p>That will only <code>close</code> when an exception occurs, and will reraise the exception (because continuing silently in this scenario is probably wrong).</p>
</div>
<div class="post-text" itemprop="text">
<p>Well. In general this is solved by:</p>
<pre><code>try:
     code that produces error
finally:
     cleanup()
</code></pre>
</div>
<span class="comment-copy">As Joonatan Samuel suggested in his answer, you probably want to run ws.close() regardless of success or failure (which is what finally will give you). If you want it to run only on failure, use except instead.</span>
<span class="comment-copy">Great and simple solution!</span>
<span class="comment-copy">I like the power of contextlib, this is probably applicable to a wide variety of methods</span>
