<div class="post-text" itemprop="text">
<p>Say I have these lists:</p>
<pre><code>a = [1, 2, 3, 4]
b = [6,7]
c = ['a', 'b', 'c']
</code></pre>
<p>I would like to create a 3-Dimensional data structure that contains new lists combining all the elements of each list together in all possible ways. I would then like to access these new list using matrix like indexing. </p>
<p>So for example, say f is a function that does what I want. Then I could do this:</p>
<pre><code>m = f(a,b,c)
</code></pre>
<p>Then m[0][0][0] would give [1,6,'a'], m[1][0][0] would give [2,6,'a'], and so on. </p>
<p>Basically, I know I can already do this using nested for loops.</p>
<pre><code>jList = []
for j in a:
    kList = []
    for k in b:
        lList = []
        for l in c:
            o = [j,k,l]
            lList.append(o)
        kList.append(lList)
    jList.append(kList)
</code></pre>
<p>This gives me a list of lists of lists of lists.</p>
<pre><code>[[[[1, 6, 'a'], [1, 6, 'b'], [1, 6, 'c']], 
  [[1, 7, 'a'], [1, 7, 'b'], [1, 7, 'c']]], 
 [[[2, 6, 'a'], [2, 6, 'b'], [2, 6, 'c']], 
  [[2, 7, 'a'], [2, 7, 'b'], [2, 7, 'c']]], 
 [[[3, 6, 'a'], [3, 6, 'b'], [3, 6, 'c']], 
  [[3, 7, 'a'], [3, 7, 'b'], [3, 7, 'c']]], 
 [[[4, 6, 'a'], [4, 6, 'b'], [4, 6, 'c']], 
  [[4, 7, 'a'], [4, 7, 'b'], [4, 7, 'c']]]]
</code></pre>
<p>This is fine, but I have to do this for dimensions higher than 3, and the many nested for loops just seems like it can't possibly be the best or most efficient way to build this type of data structure. I can't help but thinking there must be a better solution, something in some library like the function I made up above, maybe numpy function, but I've done a lot of searching and have not found something for lists of varying sizes and data types like I have. </p>
<p>Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> to take the cartesian product of the lists, then use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html" rel="nofollow noreferrer"><code>numpy.reshape</code></a> for <em>reshaping</em>, taking the last dimension from the number of lists, then to the length of the innermost list and up until the length of the outermost:</p>
<pre><code>&gt;&gt;&gt; args = a,b,c
&gt;&gt;&gt; np.array(list(product(*args))).reshape(len(a), len(b), len(c), len(args))
array([[[['1', '6', 'a'],
         ['1', '6', 'b'],
         ['1', '6', 'c']],

        [['1', '7', 'a'],
         ['1', '7', 'b'],
         ['1', '7', 'c']]],


       [[['2', '6', 'a'],
         ['2', '6', 'b'],
         ['2', '6', 'c']],

        [['2', '7', 'a'],
         ['2', '7', 'b'],
         ['2', '7', 'c']]],


       [[['3', '6', 'a'],
         ['3', '6', 'b'],
         ['3', '6', 'c']],

        [['3', '7', 'a'],
         ['3', '7', 'b'],
         ['3', '7', 'c']]],


       [[['4', '6', 'a'],
         ['4', '6', 'b'],
         ['4', '6', 'c']],

        [['4', '7', 'a'],
         ['4', '7', 'b'],
         ['4', '7', 'c']]]],
      dtype='&lt;U21')
</code></pre>
<p>You can generate the shape on the fly by using: <code>tuple(map(len, args)) + (len(args),)</code> (suggested by @StevenRumbalski), so that you now have:</p>
<pre><code>&gt;&gt;&gt; np.array(list(product(*args))).reshape(tuple(map(len, args)) + (len(args),))
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt;&gt; np.array(list(product(*args))).reshape(tuple(map(len, args)) + (-1,))
</code></pre>
<p>Without needing to specify the last dimension.</p>
</div>
<div class="post-text" itemprop="text">
<p>Vanilla Python.</p>
<pre><code>from itertools import product

a = [1, 2, 3, 4]
b = [6,7]
c = ['a', 'b', 'c']
data = [a,b,c]
dims = [range(len(i)) for i in data]
keys = product(*dims)
vals = (list(val) for val in product(*data))
space = dict(zip(keys,vals))
for key in space:
    print "{} -&gt; {}".format(key, space[key])
</code></pre>
<pre><code>(3, 0, 2) -&gt; [4, 6, 'c']
(0, 1, 1) -&gt; [1, 7, 'b']
(0, 1, 2) -&gt; [1, 7, 'c']
(1, 0, 1) -&gt; [2, 6, 'b']
(1, 0, 0) -&gt; [2, 6, 'a']
(2, 0, 1) -&gt; [3, 6, 'b']
(2, 0, 0) -&gt; [3, 6, 'a']
(3, 1, 0) -&gt; [4, 7, 'a']
(3, 1, 1) -&gt; [4, 7, 'b']
(0, 0, 2) -&gt; [1, 6, 'c']
(2, 0, 2) -&gt; [3, 6, 'c']
(0, 0, 1) -&gt; [1, 6, 'b']
(0, 0, 0) -&gt; [1, 6, 'a']
(2, 1, 2) -&gt; [3, 7, 'c']
(1, 1, 1) -&gt; [2, 7, 'b']
(1, 0, 2) -&gt; [2, 6, 'c']
(1, 1, 0) -&gt; [2, 7, 'a']
(2, 1, 0) -&gt; [3, 7, 'a']
(2, 1, 1) -&gt; [3, 7, 'b']
(1, 1, 2) -&gt; [2, 7, 'c']
(3, 0, 0) -&gt; [4, 6, 'a']
(3, 1, 2) -&gt; [4, 7, 'c']
(3, 0, 1) -&gt; [4, 6, 'b']
(0, 1, 0) -&gt; [1, 7, 'a']
</code></pre>
</div>
<span class="comment-copy">So, you want <code>itertools.product</code>.</span>
<span class="comment-copy"><code>list(itertools.product(a, b c))</code> won't give you the nesting you're looking for, but otherwise it seems perfect.  Also, this is easily expandable.  <code>lists = [a, b, c]</code> then call <code>list(itertools.product(*lists))</code>.  If you later want to add a fourth iterable you can do <code>lists.append(d)</code> and call <code>list(itertools.product(*lists))</code>.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Isn't the grouping into sublists supposed to be part of the problem?</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ: Not an exact duplicate as the OP wants a differently shaped result.</span>
<span class="comment-copy">Alright, my bad. Reopened it now.</span>
<span class="comment-copy"><code>new_shape = list(map(len, args)) + [len(args)]</code> then <code>.reshape(*new_shape)</code> would make this generic.</span>
