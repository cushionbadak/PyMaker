<div class="post-text" itemprop="text">
<p>Consider the following directory structure,</p>
<pre><code>parent
├── __init__.py
├── mod1.py
├── mod2.py
└── mod3.py
</code></pre>
<p>Contents of the files and python version are,</p>
<pre><code>$ cat __init__.py 
from . import mod1
hello = "parent Hello"

$ cat mod1.py
from . import mod2
hello = "parent.mod1 Hello"

$ cat mod2.py
hello = "parent.mod2 hello"

$ cat mod3.py
hello = "parent.mod3 Hello"

$ python3 -V
Python 3.5.2
</code></pre>
<p>Now in an interactive session I get the following behavior,</p>
<pre><code>&gt;&gt;&gt; import parent
&gt;&gt;&gt; parent.mod1
&lt;module 'parent.mod1' from '/home/codeman/mydata/local/tmp/parent/mod1.py'&gt;
&gt;&gt;&gt; parent.mod2
&lt;module 'parent.mod2' from '/home/codeman/mydata/local/tmp/parent/mod2.py'&gt;
&gt;&gt;&gt; parent.mod3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: module 'parent' has no attribute 'mod3'
</code></pre>
<p>Why is <code>parent.mod2</code> accessible when I had only imported <code>mod1</code> in the <code>parent/__int__.py</code> file ? (is it a bug?)</p>
<p>I understand that AttributeError with <code>parent.mod3</code> occurs because only the modules imported in the <code>__init__.py</code> file are accessible when plainly importing the parent using <code>import parent</code> syntax.</p>
</div>
<div class="post-text" itemprop="text">
<p>Whenever you import a module, Python creates a module object and stores it in the <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code></a> dictionary. Subsequent imports of that same module will reuse the module object from <code>sys.modules</code>. Additionally, each time you import a <em>sub</em>module, the attribute is added to the parent module object.</p>
<p>There's one instance of <code>sys.modules</code> for a given Python process, and therefore <em>in general</em> there's only one instance of every module per Python process. It means that if you have access to a module object, you also have access to its submodules that have been imported anywhere within the current process.</p>
<p>In this particular case, <code>import package</code> runs <em>package/__init__.py</em>, which imports <code>package.mod1</code>, which imports <code>package.mod2</code>. As a result, <code>mod1</code> and <code>mod2</code> are added to the "shared" <code>parent</code> module object, and you can access them.</p>
</div>
<span class="comment-copy"><code>mod2</code> is accessible, because you imported it in <code>mod1</code></span>
<span class="comment-copy">@vaultah shouldn't is be visible only inside <code>parent.mod1</code>? I haven't imported it in the <code>__init__.py</code>.</span>
<span class="comment-copy">The short answer is: it doesn't matter where you import it. The <code>mod2</code> attribute is added to the "shared" <code>parent</code> module object. If you have the <code>parent</code> object, you can access the <code>mod2</code> attribute everywhere.</span>
<span class="comment-copy">@vaultah that makes sense. Thanks!</span>
<span class="comment-copy">The last line of second para sums up the whole thing. Thanks! After the stmt <code>from x.y import z</code>, I see x and y being imported too in sys.modules. Can their import be avoided (for speedup) if z is a submodule/package which doesn't require the processing of <code>__init__.py</code> of parent modules?</span>
<span class="comment-copy">@codeman48 each <code>__init__.py</code> should only be ran once, so unless they need a lot of resources (and they should not), I wouldn't worry about it. Anyway, I am not aware of a clean way to do that. If <code>z</code> is only peripheral to <code>x</code>/<code>y</code>, I would consider splitting <code>x</code> (or its submodules) into <a href="https://www.python.org/dev/peps/pep-0420/" rel="nofollow noreferrer">namespace packages</a> (these are defined without <code>__init__.py</code> files).</span>
