<div class="post-text" itemprop="text">
<p>In general, I am trying to use Bash to read from the command line instead of Python so that I have tab-completion functionality. I want to do this in the simplest way possible. However, I am having trouble getting the following code to work and I want to understand what is causing the issue.</p>
<p>Python Script:</p>
<pre><code>from subprocess import call
call(['read', '-ep', 'Path:', 'temporaryPath'])
print temporaryPath
</code></pre>
<p>Error Traceback:</p>
<pre><code>Traceback (most recent call last):
  File "tmp.py", line 2, in &lt;module&gt;
    call(['read', '-ep', 'Path:', 'temporaryPath'])
  File "/usr/lib64/python2.6/subprocess.py", line 478, in call
    p = Popen(*popenargs, **kwargs)
  File "/usr/lib64/python2.6/subprocess.py", line 642, in __init__
    errread, errwrite)
  File "/usr/lib64/python2.6/subprocess.py", line 1238, in _execute_child
    raise child_exception
OSError: [Errno 2] No such file or directory
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're trying to call <code>read</code> which is a shell builtin:</p>
<pre><code>$ type read
read is a shell builtin
</code></pre>
<p>And this particular shell builtin have no equivalent program:</p>
<pre><code>$ which read
$ 
</code></pre>
<p>So Python won't be able to find it in your <code>PATH</code> environment variable, according to <code>strace</code>:</p>
<pre><code>[pid 17266] execve("/usr/local/bin/read", ["read", "-ep", "Path:", "temporaryPath"], [/* 70 vars */]) = -1 ENOENT (No such file or directory)
[pid 17266] execve("/usr/bin/read", ["read", "-ep", "Path:", "temporaryPath"], [/* 70 vars */]) = -1 ENOENT (No such file or directory)
[pid 17266] execve("/bin/read", ["read", "-ep", "Path:", "temporaryPath"], [/* 70 vars */]) = -1 ENOENT (No such file or directory)
[pid 17266] execve("/usr/local/games/read", ["read", "-ep", "Path:", "temporaryPath"], [/* 70 vars */]) = -1 ENOENT (No such file or directory)
[pid 17266] execve("/usr/games/read", ["read", "-ep", "Path:", "temporaryPath"], [/* 70 vars */]) = -1 ENOENT (No such file or directory)
[â€¦]
[pid 17266] write(4, "OSError:", 8 &lt;unfinished ...&gt;
</code></pre>
<p>But if you explicitly ask Python to use a shell to execute your command, the shell itself will be able to run its builtin <code>read</code>:</p>
<pre><code>$ python3
Python 3.5.3 (default, Jan 19 2017, 14:11:04) 
[GCC 6.3.0 20170118] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; subprocess.call('read', shell=True)
/bin/sh: 1: read: arg count
2
&gt;&gt;&gt; subprocess.call('read foo', shell=True)
hello world
0
</code></pre>
<p>You now have a new problem: The shell builtin <code>read</code> is storing the read value as a shell variable, which will diseapear with the shell dying right after the call to <code>subprocess.call</code>.</p>
<p>Oh and in the <code>read</code> shell builtin you don't have completion neither. You should probably just use <a href="https://docs.python.org/3/library/functions.html#input" rel="nofollow noreferrer">input</a> if you want to interactively ask something to the user, or if no interaction are needed, just use <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">argparse</a> to parse what the user is giving as command line arguments, this way the user will have some shell completion while typing the arguments, typically not on the flags, as the user shell don't know them, but on the paths.</p>
</div>
<span class="comment-copy"><code>read</code> is a bash builtin, not a binary.</span>
<span class="comment-copy">Thanks for showing me argparse, it looks like a really robust way to accomplish what I want.  Also, I understand now why call would require the <code>shell=True</code>, but why doesn't the following work? <code>call('read -ep \"Path: \" temporaryPath; export temporaryPath', shell=True)</code></span>
<span class="comment-copy"><code>export</code> does not allow you to modify the environment of the calling process. Nothing will ever allow you to modify the env of your calling process. But you can still <code>echo $temporaryPath</code> and get the value from the process stdout (don't do it, better use <code>input</code>, even better use <code>argparse</code>).</span>
<span class="comment-copy">Ahh, now that seems so obvious. Thanks!</span>
