<div class="post-text" itemprop="text">
<p>I have some code which is supposed to be a thread-safe python/c++ api. I am using the macros <code>Py_BEGIN_ALLOW_THREADS</code> and <code>Py_END_ALLOW_THREADS</code>, which expand to create save thread state and create a lock. I am releasing the lock just before method exit; once inside of <code>if</code> statement scope, and once at method scope.</p>
<p>Why does this not compile? It generates the error: <code>error: _save was not declared in this scope</code> at the second <code>Py_END_ALLOW_THREADS</code> macro.</p>
<pre><code>uint8_t SerialBuffer::push_msg() {

#if defined (UBUNTU)
  Py_BEGIN_ALLOW_THREADS
#endif

  if (_type == ARRAY) {
      // array access
  } else if (_type == PRIORITY_QUEUE) {
      // queue access
  } else {

    // Placing the return statement in the preprocessor directive
    // has no effect.
#if defined (UBUNTU)
    Py_END_ALLOW_THREADS
#endif

    return FAIL;
  }

#if defined (UBUNTU)
  Py_END_ALLOW_THREADS
#endif

  return SUCCESS;
}
</code></pre>
<p>I have also tried putting the <code>return</code> statement inside of the <code>#if</code> directive scope, and this generates the same error. However, this works:</p>
<pre><code>uint8_t SerialBuffer::push_msg() {

#if defined (UBUNTU)
  Py_BEGIN_ALLOW_THREADS
#endif

  if (_type == ARRAY) {
      // array access
  } else if (_type == PRIORITY_QUEUE) {
      // queue access
  } else {
    // NOTE lack of #if directive here.
    // Even though if this code executes the code below will not.
    // Seems like a relatively simple problem for lambda calculus, no?
    return FAIL;
  }

#if defined (UBUNTU)
  Py_END_ALLOW_THREADS
#endif

  return SUCCESS;
}
</code></pre>
<p>Edit: I'm aware that the second example does not do thread clean-up; however, it compiles.</p>
<p>Edit2:
<code>Py_BEGIN_ALLOW_THREADS</code> expands to <code>{ PyThreadState *_save; _save = PyEval_SaveThread();</code></p>
<p><code>Py_END_ALLOW_THREADS</code> expands to <code>PyEval_RestoreThread(_save); }</code>
NOTE the scoping braces prepending <code>BEGIN</code> and appending <code>END</code>. Why is it the logical choice for the macro expansion to include scoping?</p>
</div>
<div class="post-text" itemprop="text">
<p>The preprocessor expands the macro, <code>Py_BEGIN_ALLOW_THREADS</code>, into code that creates a local object named <code>_save</code>.</p>
<p>The preprocessor expands the macro, <code>Py_END_ALLOW_THREADS</code>, into code that uses <code>_save</code> to do thread clean-up tasks.</p>
<p>If you put <code>Py_BEGIN_ALLOW_THREADS</code> inside the else block, the code created by <code>Py_END_ALLOW_THREADS</code> can't see the local <code>_save</code> object, so you get an error message.</p>
<p>On a related topic, I recommend putting <code>Py_BEGIN_ALLOW_THREADS</code> and <code>Py_END_ALLOW_THREADS</code> where if the first one executes, then so does the second one. Your second version of the function will not do the thread clean-up tasks for <code>Py_END_ALLOW_THREADS</code> if you have an array type or a priority-queue type.</p>
<p>Try this:</p>
<pre><code>uint8_t SerialBuffer::push_msg() {

#if defined (UBUNTU)
  Py_BEGIN_ALLOW_THREADS
#endif
  uint8_t response = FAIL;

  if (_type == ARRAY) {
      // array access
      response = SUCCESS;
  } else if (_type == PRIORITY_QUEUE) {
      // queue access
      response = SUCCESS;
  }

#if defined (UBUNTU)
  Py_END_ALLOW_THREADS
#endif

  return response;
}
</code></pre>
<p>In this version, the default response is FAIL, so you don't even need the final else section. The other if statements only set the response to SUCCESS if all goes well.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" rel="nofollow noreferrer">[Python 3]: <strong>Py_BEGIN_ALLOW_THREADS</strong></a> (<strong>emphasis</strong> is mine):</p>
<blockquote>
<p>This macro expands to <code>{ PyThreadState *_save; _save = PyEval_SaveThread();</code>. Note that it contains an opening brace; <strong>it must be matched</strong> with a following <a href="https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS" rel="nofollow noreferrer">Py_END_ALLOW_THREADS</a> macro. See above for further discussion of this macro.</p>
</blockquote>
<p>So, the answer to the compile error is pretty clear:</p>
<ul>
<li><p>After preprocessing, the 2<sup>nd</sup> <em>Py_END_ALLOW_THREADS</em> produces invalid code (and the enclosing in <code>#if defined (UBUNTU)</code> is irrelevant, as it will never work when <em>UBUNTU</em> is defined, and it will always work when it isn't):</p>
<ul>
<li>Referencing (inexistent) "<em>_save</em>" </li>
<li>An extra closing brace ("<em>}</em>")</li>
</ul></li>
</ul>
<p>The common usecase for the 2 macros is also exemplified int he above page:</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>PyThreadState *_save;
_save = PyEval_SaveThread();

... Do some blocking I/O operation ...

PyEval_RestoreThread(_save);
</code></pre>
</blockquote>
<p><strong>Why it was designed this way (to include scoping)</strong>? Probably to fail when used <strong>like you did</strong>, because that can cause hard to find errors (your example is pretty simple, but in a more complex piece code with many branches requiring just as many <em>Py_END_ALLOW_THREADS</em>, imagine what would mean to miss one, or to call it twice).</p>
<p>In order to fix your problem, you must redesign your code to either:</p>
<ul>
<li>Not directly return on failure, but flag it, return (in one place) at the end, and place the <em>Py_END_ALLOW_THREADS</em>, just before returning</li>
<li>Call the macro pair inside each (or where required) of the <em>if</em> branches (<em>ARRAY</em>, <em>PRIORITY_QUEUE</em>, ...)</li>
<li>Use (the dreaded) <em>goto</em></li>
</ul>
</div>
<span class="comment-copy">Do you mean a directive? <code>Py_BEGIN_ALLOW_THREADS</code> isn't in an if statement. I should think an <code>#if</code> directive is valid, as the preprocessor will see the same macro definition in all valid cases.</span>
<span class="comment-copy">@errolflynn Thanks. I corrected the answer to say "the else block" instead of "an if statement".</span>
<span class="comment-copy">Your style is good. However, there are other cases where I should like to return early to prevent excessive code from running. Do you know why my example doesn't work?</span>
<span class="comment-copy"><code>Py_BEGIN_ALLOW_THREADS</code> isn't in the <code>else</code> block. It is in the method scope. The variable <code>_save</code> should be visible through the entire method.</span>
<span class="comment-copy">@errolflynn Oof! I clearly misread the original code snippet! I have an idea. Send the preprocessed source code to a a file and then check the file for what the preprocessor puts inside that function. You can do that with this command line. <code>g++ -E file.cpp &gt; file.pp</code></span>
