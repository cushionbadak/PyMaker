<div class="post-text" itemprop="text">
<p>I tried to compute <code>math.exp(9500)</code> but encountered an <code>OverflowError: math range error</code> (it's roughly 6.3e4125). From <a href="https://stackoverflow.com/questions/4050907/python-overflowerror-math-range-error">this question</a> it seems like it's due to a too large float, the accepted answer says "(...) is slightly outside of the range of a double, so it causes an overflow".</p>
<p>I know that Python can deal with arbitrarily large integers (long type), is there a way to deal with arbitrarily large floats in the same manner ?</p>
<p><strong>Edit :</strong> my original question was about using integers for calculating exp(n) but as Eric Duminil said, the simplest way to do that would be <code>3**n</code> which doesn't provide any useful result. I know realize this question might be similar to <a href="https://stackoverflow.com/questions/11522933/python-floating-point-arbitrary-precision-available/">this one</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think it's possible to approximate <code>exp()</code> with integers. If you use <code>3**n</code> instead of <code>2.71828182845905**n</code>, your calculations will be completely useless.</p>
<p>One possible solution would be to use <a href="http://docs.sympy.org/latest/modules/evalf.html" rel="nofollow noreferrer"><code>Sympy</code></a>. According to the documentation:</p>
<blockquote>
<p>There is essentially no upper precision limit</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; exp(9500)
exp(9500)
&gt;&gt;&gt; exp(9500).evalf()
6.27448493490172e+4125
</code></pre>
<p>You can also specify the desired precision:</p>
<pre><code>&gt;&gt;&gt; exp(9500).evalf(1000)
6.274484934901720177929867046175406311474380389941415760684209191232450360090766458256588885184199320756050569665785657269735313171886975309933254563488343491718198237894473901620914303565550450204805537225888529509352754121292701357622411614860860409639719786022989336837263283678476008817556351031696366815467221836948040042378034720460820127399855873232167818091083005170669482845098735176209372328114732133251096196535355946589133977397512846130629857604295369747597459602137604440011394793443041829253598478244189078131130488653468669559814695095974271938947640276013215753183113041899037415404445478806695965167014404297848725756879184380559837391976534521522360723388582608454995349380217499779247330557664230806254642768796486899322646423713763772064068933790640394967085887914192401473425799354391464743910233873602389444180426155866237536459654917521713769608318128404177877383203786348495822099924812081683286880293701785567962687838594752986160305764297117036426951203418854463404773701882e+4125
</code></pre>
<p>With <code>exp(9500).evalf(5000)</code>, you even get the integer closest to <code>exp(9500)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's snother way to calculate the result with Python:</p>
<pre><code>exp(9500)
</code></pre>
<p>is too big.</p>
<p>But <code>log10(exp(9500))</code> isn't. You cannot calculate it this way in Python, but <code>log10(exp(9500))</code> is <code>log(exp(9500))/ln(10)</code>, which is <code>9500/ln(10)</code>:</p>
<pre><code>&gt;&gt;&gt; from math import log
&gt;&gt;&gt; 9500/log(10)
4125.797578080892
&gt;&gt;&gt; int(9500/log(10))
4125
&gt;&gt;&gt; 10**(9500/log(10) % 1)
6.274484934896202
</code></pre>
<p>This way, you can calculate that <code>exp(9500)</code> is <code>6.27448493 * 10**4125</code> in plain Python, without any library!</p>
</div>
<div class="post-text" itemprop="text">
<p>try <code>long</code> type.</p>
<p><code>int</code> type has been remove from python since 3.0 version.</p>
</div>
<span class="comment-copy">I'm afraid to even ask what kind of problem would require computing <code>exp(9500)</code>...</span>
<span class="comment-copy">The problem itself doesn't but I'm doing matrix multiplications repeatedly  : A * B, but B gets more sparse overtime, A remains constant. I was trying to calculate the number of multiplications needed depending on the variation of B's sparsity, in that case the number of "empty" lines of B was growing logarithmically from 1 to 9500 which gives us a total number of multiplications that looks a bit like "sum for i from 1 to n of (A-lines * B-columns * ln( (exp(9500)/n) * i )).</span>
<span class="comment-copy">In that case, you should probably just simplify the formula: <code>log((exp(9500)/n)*i)</code> is <code>9500 + log(i/n)</code>, or <code>9500 + log(i) - log(n)</code>. Then everything will work in normal double-precision floating-point.</span>
<span class="comment-copy">@MarkDickinson That's right ! I completely forgot to simplify that... I just tried it and Python doesn't complain anymore. Yet the same formula gives me 3.7323287594132553 * 10^9 with Python and 3.757328759413250...Ã—10^9 with Wolfram Alpha. I'm wondering if that's just a rounding error ?</span>
<span class="comment-copy">@potato: Yes, it's just a rounding error.</span>
<span class="comment-copy">Thanks a lot, that's exactly what I was looking for. Also your solution provides much more and my question was probably not very well written, I re-wrote part of it to be more precise and explicit.</span>
<span class="comment-copy">You should provide it in comments not in answer. Read the documentation pal @Mojann</span>
<span class="comment-copy">This is incorrect - <code>int</code> is still here (though <code>long</code> is probably more appropriate for this problem.) <a href="https://docs.python.org/3/library/stdtypes.html" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html</a></span>
<span class="comment-copy">Im asking this question because the result of <code>math.exp</code> is a float. Python already implicitly converts <code>int</code> to <code>long</code> when needed.</span>
<span class="comment-copy">How could a <code>long</code> integer type could help in order to calculate <code>2.71828182845905**n</code>?</span>
