<div class="post-text" itemprop="text">
<p>I want to do something (more than just substitution) with substrings matching a pattern in a longer string. If an assignment were an expression returning a value, as in C and most other programming languages, this would be (using C syntax with Python semantics):</p>
<pre><code>  while ( match = re.search( pat, str ) ) {
       /* do something to the string, using the match object,
          in addition to removing or replacing the substring
       */
    }
</code></pre>
<p>or more verbosely, avoiding the use of an assignment as an expression:</p>
<pre><code>for ( match = re.search( pat, str );
      match;
      match = re.search( pat, str ) ) {
   /* do something to the string, using the match object */
}
</code></pre>
<p>At least one of these is possible in most programming languages: C, C++, Java, Perl, Javascript, ... but neither of them seems to be possible in Python. Is there a pythonic equivalent (not involving a kludgey mess with a break or continue statement)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You may be looking for <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="noreferrer">finditer</a>:</p>
<blockquote>
<p>Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result unless they touch the beginning of another match.</p>
</blockquote>
<pre><code>#!/usr/bin/env python3

import re

s = "abcabcabc";
it = re.finditer("(\w)", s)
for m in it:
    print(m.groups())
</code></pre>
<pre class="lang-none prettyprint-override"><code> $ ./t.py
('a',)
('b',)
('c',)
('a',)
('b',)
('c',)
('a',)
('b',)
('c',)
</code></pre>
</div>
<span class="comment-copy">The answer depends. What are you looping over? There is definitely NO one to one mapping, but there certainly are pythonic equivalents. If you can be a bit more precise with what you want... because as it stands this question is too broad.</span>
<span class="comment-copy">This only scans the string once, so it won't work in the general case; almost any change to the string inside the loop will break it, for example replacing the matched pattern by something which has a different length.</span>
<span class="comment-copy">Maybe you can given an example which illustrates the behavior you want and ask how to implement it in Python. I am not willing to play "guess what the OP wants".</span>
