<div class="post-text" itemprop="text">
<p>Let's say I have two dicts where the values are lists (or sets are also fine since the contents are unique). For example:</p>
<pre><code>dic1 = {'math': ['algebra', 'trigonometry', 'geometry']}
dic2 = {'math': ['calculus'], 'science': ['physics']}
dic2.update(dic1)
</code></pre>
<p>My desired output would be this:</p>
<pre><code>{'math': ['algebra', 'trigonometry', 'geometry', 'calculus'], 'science': ['physics']}
</code></pre>
<p>but instead I get:</p>
<pre><code>{'math': ['algebra', 'trigonometry', 'geometry'], 'science': ['physics']}
</code></pre>
<p>Essentially I want to combine the contents when merging the two dicts (I don't want to override but rather retain both). Is there a simple way to do this? Note: In this this example I gave, there are only two dictionaries. Although I did not write the code yet, I would ultimately want to loop over several dictionaries and do this process of merging/updating in the loop, which might be helpful while suggesting an approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be expressed with a simple one-liner:</p>
<pre><code>&gt;&gt;&gt; {k: dic1.get(k, []) + dic2.get(k, []) for k in (set(dic1) | set(dic2))}
{'science': ['physics'], 'math': ['algebra', 'trigonometry', 'geometry', 'calculus']}
</code></pre>
<p>This combines three techniques:</p>
<ul>
<li>The <a href="https://docs.python.org/3/library/stdtypes.html#set.union" rel="nofollow noreferrer">union</a> of two sets combines the keys and eliminates duplicates.</li>
<li>The <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">dict.get()</a> method supplies a default empty list for missing keys.</li>
<li>The <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionary comprehension</a> builds the new dictionary.</li>
</ul>
<p>Python's core toolkit often provides elegant solutions to basic elementary data manipulation problems.  I'm frequently amazed at how well the tools combine together.</p>
<p>How this helps :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>To avoid duplicates if you are merging multiple dicts of lists:</p>
<pre><code>def updateDict(dict1, dict2):
   for key in dict1:
      if key in dict2:
         prev_values = set(dict1[key]) # create set to retain only unique values in list
         prev_values.update(dict2[key])
         dict1[key] = list(prev_values)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a dict comprehension that will work if <code>dic1</code> doesn't contain keys that aren't in <code>dic2</code>:</p>
<pre><code>dic3 = {k: v + dic1.get(k, list()) for k, v in dic2.items()}
</code></pre>
<p>Additionally, to make sure that any missing keys from <code>dic1</code> get added to the dict, you could add a <code>for</code> loop after that.</p>
<pre><code>for k, v in dic1.items():
    if k not in dic3:
        dic3.update({k: v})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't know a straightfoward way, but this should work:</p>
<pre><code>def combine_dicts(dict1,dict2):
    dict = {}
    for key1,list1 in dict1.items():
        for key2,list2 in dict2.items():
           if key1 == key2:
               dict[key1] = list1.extend(list2)
    return dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>dict1 = {'math': ['algebra', 'trigonometry', 'geometry']}
dict2 = {'math': ['calclus'], 'science': ['physics']}
for key, value in dict1.items():
    dict2.setdefault(key, []).extend(value)

&gt;&gt;&gt; print(dict2)
{'science': ['physics'], 'math': ['calclus', 'algebra', 'trigonometry', 'geometry']}
</code></pre>
<p>In case you want to retain both dictionary values do this</p>
<pre><code>from copy import deepcopy

dict1 = {'math': ['algebra', 'trigonometry', 'geometry']}
dict2 = {'math': ['calclus'], 'science': ['physics'], 'lol':['lol1']}
dict3 = deepcopy(dict2)
for key, value in dict1.items():
    dict3.setdefault(key, []).extend(value)

&gt;&gt;&gt;print(dict2)
{'science': ['physics'], 'math': ['calclus']}
&gt;&gt;&gt;print(dict3)
{'science': ['physics'], 'math': ['calclus', 'algebra', 'trigonometry', 'geometry']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create your own dictionary class to get the desired behaviour. I'm not sure what is the best way, but here is one possibility:</p>
<pre><code>import collections

class ListDict(collections.UserDict):
    def update(self, other):
        if isinstance(other, collections.Mapping):
            for key, value in other.items():
                self.data.setdefault(key, []).extend(value)
        else:
            raise NotImplementedError()

dic1 = ListDict({'math': ['algebra', 'trigonometry', 'geometry']})
dic2 = ListDict({'math': ['calculus'], 'science': ['physics']})
dic2.update(dic1)
print(dic2)
</code></pre>
<p>Output:</p>
<pre><code>{'math': ['calculus', 'algebra', 'trigonometry', 'geometry'], 'science': ['physics']}
</code></pre>
<p>Note that this is just a start that implements the desired behaviour. Depending on what you use it for, you might want to add more functionality. For example, only one of <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer">the ways of calling <code>update</code></a> is implemented.</p>
<p>In order to prevent duplicate values in the resulting collections, you might want to use sets instead:</p>
<pre><code>import collections

class SetDict(collections.UserDict):
    def update(self, other):
        if isinstance(other, collections.Mapping):
            for key, value in other.items():
                self.data[key] = self.data.get(key, set()).union(value)
        else:
            raise NotImplementedError()

dic3 = SetDict({'math': ['algebra', 'trigonometry']})  # may contain lists ...
dic4 = SetDict({'math': {'algebra', 'geometry'}})  # ... or sets
dic4.update(dic3)
print(dic4)
</code></pre>
<p>Output:</p>
<pre><code>{'math': {'algebra', 'geometry', 'trigonometry'}}
</code></pre>
</div>
<span class="comment-copy">Is it safe to assume that dic1 will not have any keys that dic2 doesn't? If so, <code>dic3 = {k: v + dic1.get(k, list()) for k, v in dic2.items()}</code></span>
<span class="comment-copy">That's a good question! Thanks for asking. No, there could be the case that dic1 and dic2 share common keys, such as the example above where the share <code>math</code>.</span>
<span class="comment-copy">Sorry, that's not what I meant. I meant <code>dic1</code> ONLY contains keys that are in <code>dic2</code>. I think I phrased that weird</span>
<span class="comment-copy">FYI I updated my answer to reflect how you could make sure that's not a problem if it is the case.</span>
