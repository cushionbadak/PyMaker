<div class="post-text" itemprop="text">
<p>I am trying to not match words that are followed or preceded by an XML tag.</p>
<pre><code>import re

strTest = "&lt;random xml&gt;hello this was successful price&lt;random xml&gt;"

for c in re.finditer(r'(?&lt;![&lt;&gt;])(\b\w+\b)(?&lt;!=[&lt;&gt;])(\W+)',strTest):
     c1 = c.group(1)
     c2 = c.group(2)
     if ('&lt;' != c2[0]) and ('&lt;' != c.group(1)[len(c.group(1))-1]):
          print c1
</code></pre>
<p>Result is:</p>
<pre><code>xml
this
was
successful
xml
</code></pre>
<p>Wanted Result:</p>
<pre><code>this
was
successful
</code></pre>
<p>I have been trying negative lookahead and negative lookbehind assertions. I'm not sure if this is the right approach, I would appreciate any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, to answer your question directly:</p>
<p>I do it by examining each 'word' consisting of a sequence of characters containing (mainly) alphabetics or '&lt;' or '&gt;'. When the regex offers them to <code>some_only</code> I look for one of the latter two characters. If neither appears I print the 'word'.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; strTest = "&lt;random xml&gt;hello this was successful price&lt;random xml&gt;"
&gt;&gt;&gt; def some_only(matchobj):
...     if '&lt;' in matchobj.group() or '&gt;' in matchobj.group():
...         pass
...     else:
...         print (matchobj.group())
...         pass
... 
&gt;&gt;&gt; ignore = re.sub(r'[&lt;&gt;\w]+', some_only, strTest)
this
was
successful
</code></pre>
<p>This works for your test string; however, as others have already mentioned, using a regex on xml will usually lead to many woes.</p>
<p>To use a more conventional approach I had to tidy away a couple of errors in that xml string, namely to change <code>random xml</code> to <code>random_xml</code> and to using a proper closing tag. </p>
<p>I prefer to use the lxml library.</p>
<pre><code>&gt;&gt;&gt; strTest = "&lt;random_xml&gt;hello this was successful price&lt;/random_xml&gt;"
&gt;&gt;&gt; from lxml import etree
&gt;&gt;&gt; tree = etree.fromstring(strTest)
&gt;&gt;&gt; tree.text
'hello this was successful price'
&gt;&gt;&gt; tree.text.split(' ')[1:-1]
['hello', 'this', 'was', 'successful', 'price']
&gt;&gt;&gt; tree.text.split(' ')[1:-1]
['this', 'was', 'successful']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'll give it a shot.  Since we are already doing more than just a regex, put it into a list and drop the first/last items:</p>
<pre><code>import re

strTest = "&lt;random xml&gt;hello this was successful price&lt;random xml&gt;"

thelist = []

for c in re.finditer(r'(?&lt;![&lt;&gt;])(\b\w+\b)(?&lt;!=[&lt;&gt;])(\W+)',strTest):
     c1 = c.group(1)
     c2 = c.group(2)
     if ('&lt;' != c2[0]) and ('&lt;' != c.group(1)[len(c.group(1))-1]):
          thelist.append(c1)

thelist = thelist[1:-1]

print (thelist)
</code></pre>
<p>result:</p>
<pre><code>['this', 'was', 'successful']
</code></pre>
<p>I would personally try to parse the XML instead, but since you have this code already up this slight modification could do the trick.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple way to do it, with a list, but I am supposing the  followed or preceded word by an XML tag and the proper tag are not separated by an space:</p>
<pre><code>test = "&lt;random xml&gt;hello this was successful price&lt;random xml&gt;"

test = test.split()

new_test = []
for val in test:
  if "&lt;" not in val and "&gt;" not in val:
   new_test.append(val)

print(new_test)
</code></pre>
<p>The result will be:</p>
<pre><code>['this', 'was', 'successful']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>My soultion...</h3>
<p>I don't see the need to use <code>regex</code> at all, you could solve it in a one-line list comprehension:</p>
<pre><code>words = [w for w in test.split() if "&lt;" not in w and "&gt;" not in w]
</code></pre>
</div>
<span class="comment-copy">You don't use regex to parse XML. Ever. Use an XML parser. Python has one <a href="https://docs.python.org/3/library/xml.etree.elementtree.html" rel="nofollow noreferrer">built in</a>. Or install <a href="http://lxml.de/" rel="nofollow noreferrer">lxml</a>.</span>
<span class="comment-copy"><b><a href="https://stackoverflow.com/a/1732454/1954610">Don't use Regexp to parse XML</a></b>. Use an XML parser.</span>
<span class="comment-copy"><a href="http://www.rexegg.com/regex-best-trick.html#thetrick" rel="nofollow noreferrer">A trick</a> can be: Match what you don't want, but <a href="http://www.regular-expressions.info/brackets.html" rel="nofollow noreferrer">capture</a> what you need. <a href="https://regex101.com/r/bpaYAY/1" rel="nofollow noreferrer"><code>\w*\s*&lt;[^&gt;]*&gt;\s*\w*|(\w+)</code></a></span>
<span class="comment-copy">I really like this solution, but I only want to use stdlib. How could this be done using xml.etree.ElementTree. BTW I am running Python 2.7.</span>
<span class="comment-copy">@Bman425, it's basically identical. <code>import xml.etree.ElementTree as ET; tree = ET.fromstring(strTest); print tree.text.split(' ')[1:-1]</code></span>
<span class="comment-copy">BTW, there's probable some work that could be done here to improve this answer's applicability -- descending the tree looking for elements and incorporating <code>.tail</code> as well as <code>.text</code>, for example; the OP's sample input is clearly inadequate to their actual intent.</span>
<span class="comment-copy">Agreed. My concern would be that this might easily go beyond the OP's skills level. As it is, simple question, simple answer.</span>
<span class="comment-copy">This works well for the example I put, but I am worried it will not scale well. I agree that I should try using an XML parser.</span>
