<div class="post-text" itemprop="text">
<p>I have a list of lists of lists with strings, something like this (representing chapters, paragraphs and sentences of a text)):</p>
<pre><code>[ [[ ['chp1p1s1'], ['chp1p1s2'], ['chp1p1s3'] ],
   [ ['chp1p2s1'], ['chp1p2s2'], ['chp1p2s3'] ]],
  [[ ['chp2p1s1'], ['chp2p1s2'], ['chp2p1s3'] ],
   [ ['chp2p2s1'], ['chp2p2s2'], ['chp2p2s3'] ]] ]
</code></pre>
<p>I know how to flatten this list completly (for example by <code>[x for y in z for x in y]</code>), but what I would like to do is to flatten it partially, to finally look like this:</p>
<pre><code>[ [ ['chp1p1s1'], ['chp1p1s2'], ['chp1p1s3'],
    ['chp1p2s1'], ['chp1p2s2'], ['chp1p2s3'] ],
  [ ['chp2p1s1'], ['chp2p1s2'], ['chp2p1s3'],
    ['chp2p2s1'], ['chp2p2s2'], ['chp2p2s3'] ] ]
</code></pre>
<p>I managed to solve this by some for loops:</p>
<pre><code>semiflattend_list=list()
for chapter in chapters:
    senlist=list()
    for paragraph in chapter:
        for sentences in paragraph:
            senlist.append(sentences)
    semiflattend_list.append(senlist)
</code></pre>
<p>But I wonder if there is a better, shorter solution? (I don't think, <code>zip</code> is a way to go, because my lists are different in size.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest change I can see is using the <code>itertools.chain</code> method:</p>
<pre><code>q = [
     [[ ['chp1p1s1'], ['chp1p1s2'], ['chp1p1s3'] ],
       [ ['chp1p2s1'], ['chp1p2s2'], ['chp1p2s3'] ]],
     [[ ['chp2p1s1'], ['chp2p1s2'], ['chp2p1s3'] ],
       [ ['chp2p2s1'], ['chp2p2s2'], ['chp2p2s3'] ]]
    ]

r = [list(itertools.chain(*g)) for g in q]
print(r)

[[['chp1p1s1'], ['chp1p1s2'], ['chp1p1s3'], ['chp1p2s1'], ['chp1p2s2'], ['chp1p2s3']],
 [['chp2p1s1'], ['chp2p1s2'], ['chp2p1s3'], ['chp2p2s1'], ['chp2p2s2'], ['chp2p2s3']]]
</code></pre>
<p>So, what does <code>[list(itertools.chain(*g)) for g in q]</code> mean:</p>
<pre><code># If I only had this
[g for g in q]
# I would get the same I started with.
# What I really want is to expand the nested lists

# * before an iterable (basically) converts the iterable into its parts.
func foo(bar, baz):
   print( bar + " " + baz )

lst = ["cat", "dog"]
foo(*lst) # prints "cat dog"

# itertools.chain accepts an arbitrary number of lists, and then outputs 
# a generator of the results:
c = itertools.chain([1],[2])
# c is now &lt;itertools.chain object at 0x10e1fce10&gt;
# You don't want an generator though, you want a list. Calling `list` converts that:
o = list( c )
# o is now [1,2]
# Now, together:
myList = [[2],[3]]
flattened = list(itertools.chain(*myList))
# flattened is now [2,3]
</code></pre>
</div>
<span class="comment-copy">The examples you gave is actually a tuple of two different lists, which I don't think is what you meant. You are messing up the parentheses or a comma, maybe, but we need a reporducible example</span>
<span class="comment-copy">This actually solved it! Could you maybe please explain this asterisk/splat operator? In the <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">doc</a> it doesn't explain to me how this could help here.</span>
