<div class="post-text" itemprop="text">
<p>I have a list of items with properties <code>"Type"</code> and <code>"Time"</code> that I want to quickly sum the time for each <code>"Type"</code> and append to another list. The list looks like this:</p>
<pre><code>Items = [{'Name': A, 'Type': 'Run', 'Time': 5},  
          {'Name': B, 'Type': 'Walk', 'Time': 15},  
          {'Name': C, 'Type': 'Drive', 'Time': 2},
          {'Name': D, 'Type': 'Walk', 'Time': 17},  
          {'Name': E, 'Type': 'Run', 'Time': 5}]
</code></pre>
<p>I want to do something that works like this:</p>
<pre><code>Travel_Times=[("Time_Running","Time_Walking","Time_Driving")]
Run=0
Walk=0
Drive=0    

for I in Items:
    if I['Type'] == 'Run':
       Run=Run+I['Time']
    elif I['Type'] == 'Walk': 
       Walk=Walk+I['Time']           
    elif I['Type'] == 'Drive': 
       Drive=Drive+I['Time']           

Travel_Times.append((Run,Walk,Drive))    
</code></pre>
<p>With <code>Travel_Times</code> finally looking like this:</p>
<pre><code>print(Travel_Times)
[("Time_Running","Time_Walking","Time_Driving")
 (10,32,2)]
</code></pre>
<p>This seems like something that should be easy to do efficiently with either a list comprehension or something similar to <code>collections.Counter</code>, but I can't figure it out. The best way I have figured is to use a separate list comprehension for each "Type" but that requires iterating through the list repeatedly. I would appreciate any ideas on how to speed it up. </p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that case is very important in Python :</p>
<ul>
<li><code>For</code> isn't a valid statement</li>
<li><code>Travel_times</code> isn't the same as <code>Travel_Times</code></li>
<li>there's no <code>:</code> after <code>elif</code></li>
<li><code>Travel_Times.append(...</code> has a leading space, which confuses Python</li>
<li><code>items</code> has one <code>[</code> too many</li>
<li><code>A</code> isn't defined</li>
</ul>
<p>Having said that, a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> works just fine for your example :</p>
<pre><code>from collections import Counter

time_counter = Counter()

items = [{'Name': 'A', 'Type': 'Run', 'Time': 5},  
          {'Name': 'B', 'Type': 'Walk', 'Time': 15},  
          {'Name': 'C', 'Type': 'Drive', 'Time': 2},
          {'Name': 'D', 'Type': 'Walk', 'Time': 17},  
          {'Name': 'E', 'Type': 'Run', 'Time': 5}]

for item in items:
    time_counter[item['Type']] += item['Time']

print(time_counter)
# Counter({'Walk': 32, 'Run': 10, 'Drive': 2})
</code></pre>
<p>To get a list of tuples :</p>
<pre><code>[tuple(time_counter.keys()), tuple(time_counter.values())]
# [('Run', 'Drive', 'Walk'), (10, 2, 32)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dict to keep track of the total times. Using the <code>.get()</code> method, you can tally up the total times. If the key for the activity doesn't already exist, set its tally to zero and count up from there.</p>
<pre><code>items = [{'Name': 'A', 'Type': 'Run', 'Time': 5},  
          {'Name': 'B', 'Type': 'Walk', 'Time': 15},  
          {'Name': 'C', 'Type': 'Drive', 'Time': 2},
          {'Name': 'D', 'Type': 'Walk', 'Time': 17},  
          {'Name': 'E', 'Type': 'Run', 'Time': 5}]

totals = {}

for item in items:
    totals[item['Type']] = totals.get(item['Type'], 0) + item['Time']

for k, v in totals.items():
    print("Time {}ing:\t {} mins".format(k, v))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>Counter</code> from <code>collections</code> along with <code>chain</code> and <code>repeat</code> from <code>itertools</code>:</p>
<pre><code>from itertools import chain, repeat
from collections import Counter

from_it = chain.from_iterable
res = Counter(from_it(repeat(d['Type'], d['Time']) for d in Items))
</code></pre>
<p>This small snippet results in a <code>Counter</code> instance containing the sums:</p>
<pre><code>print(res)
Counter({'Drive': 2, 'Run': 10, 'Walk': 32})
</code></pre>
<p>It uses <code>repeat</code> to, obviously, repeat the <code>d['Type']</code> for <code>d['Time']</code> times and then feeds all these to <code>Counter</code> for the summation using <code>chain.from_iterable</code>.</p>
<hr/>
<p>If your <code>Items</code> list has many entries, you can again use <code>chain.from_iterable</code> to chain these all together:</p>
<pre><code>res = Counter(from_it(repeat(d['Type'], d['Time']) for d in from_it(Items)))
</code></pre>
<p>This will get you a sum of all types in all the nested lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow noreferrer"><code>reduce</code></a> with <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>:</p>
<pre><code># from functools import reduce # Python 3

d = reduce(lambda x, y: x + Counter({y['Type']: y['Time']}), Items, Counter())          
print(d)
# Counter({'Walk': 32, 'Run': 10, 'Drive': 2})
</code></pre>
<p>It simply builds up the <code>Counter</code> updating each <code>Type</code> using the corresponding <code>Time</code> value.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a brief way of expressing what you'd like in one line. By the way, your list <code>Items</code> doesn't need to be double bracketed:</p>
<pre><code>&gt;&gt;&gt; Items = [{'Type': 'Run', 'Name': 'A', 'Time': 5}, 
         {'Type': 'Walk', 'Name': 'B', 'Time': 15}, 
         {'Type': 'Drive', 'Name': 'C', 'Time': 2}, 
         {'Type': 'Walk', 'Name': 'D', 'Time': 17}, 
         {'Type': 'Run', 'Name': 'E', 'Time': 5}]
&gt;&gt;&gt; zip(("Time_Running","Time_Walking","Time_Driving"), (sum(d['Time'] for d in Items if d['Type'] == atype) for atype in 'Run Walk Drive'.split()))
[('Time_Running', 10), ('Time_Walking', 32), ('Time_Driving', 2)]
</code></pre>
<p>Here I zipped your output labels to a generator that calculates the sum for each of the three transportation types you have listed. For your exact output you could just use:</p>
<pre><code>&gt;&gt;&gt; [("Time_Running","Time_Walking","Time_Driving"), tuple(sum(d['Time'] for d in Items if d['Type'] == atype) for atype in 'Run Walk Drive'.split())]
[('Time_Running', 'Time_Walking', 'Time_Driving'), (10, 32, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're willing to abuse generators for their side effects:</p>
<pre><code>from collections import Counter
count = Counter()
# throw away the resulting elements, as .update does the work for us
[_ for _ in (count.update({item['Type']:item['Time']}) for item in items) if _]

&gt;&gt;&gt; count
Counter({'Walk': 32, 'Run': 10, 'Drive': 2})
</code></pre>
<p>This works because <code>Counter.update()</code> returns <code>None</code>. <code>if None</code> will always evaluate <code>False</code> and throw out that element. So this generates a side effect empty list <code>[]</code> as the only memory overhead. <code>if False</code> would work equally well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use a dictionary! Note that in python it is idomatic to use <code>snake_case</code> for variables and keys.</p>
<pre><code>travel_times = {'run': 0, 'walk': 0, 'drive': 0}
for item in items:
    action, time = item['type'], item['time']
    travel_times[action] += time
</code></pre>
</div>
<span class="comment-copy">@ roganjosh.  The actual code calculates and summarizes an Items list for about 1.1 different paths, with each having between 1 and 250 Items in it. My original solution, runs in 2860 seconds. Roganjosh's solution (with a dictionary) runs in 1285 seconds (2.2 times faster) and Eric Dumhill's solution (using Counter) runs in 899 seconds (3.2 times faster than my code).</span>
<span class="comment-copy">I also tested it with a smaller subset of only 3000 paths and got nearly identical % speed improvements.</span>
<span class="comment-copy">I corrected the formatting issues. I am typing this at work and didn't have the actual code or data handy.</span>
<span class="comment-copy">This seems quite inefficient with lots of lookups</span>
<span class="comment-copy">@PeterWood It was the recommended method by Raymond Hettinger in one of his keynotes. I tested it against <code>Counter</code> and it actually was marginally faster. For this particular application, I'm not sure how it performs, I will <code>timeit</code></span>
<span class="comment-copy">@PeterWood You might want to check I tested correctly. I tested <code>Counter</code> method by Eric: <code>10000 loops, best of 3: 14.7 µs per loop</code> vs my method: <code>100000 loops, best of 3: 5.58 µs per loop</code>. However, I think this is a bit artificial due to overhead of calling <code>Counter()</code>. For larger data structures, it might level out.</span>
<span class="comment-copy">@PeterWood and for the <code>chain</code>/<code>repeat</code> method: <code>10000 loops, best of 3: 86.5 µs per loop</code></span>
<span class="comment-copy">Within 2 hours of posting my question I have 5 answers, a discussion about which should work better and @roganjosh even tested the solutions for performance. You guys rock!</span>
<span class="comment-copy">At least on Python 2.7, I get <code>TypeError: string indices must be integers, not str</code>.</span>
<span class="comment-copy">@roganjosh I'm not certain if something changed from <code>2.7</code> to <code>3.x</code> since I don't use <code>2</code> that much . From what I understand, it works fine in <code>3.x</code> for you, right? <i>Update</i>: Can't verify the failure in <code>2.7</code>.</span>
<span class="comment-copy">Unfortunately, Enthought Canopy has me confined to 2.7 so it's not easy for me to switch and test. I need to find out what part it's unhappy about, it seems a pretty big change to give that kind of error between 2 and 3...</span>
<span class="comment-copy">I think you both have different test data. Jim has his own list nested in another, while rogan just has the list of dicts :) Typo from OP</span>
<span class="comment-copy">@MosesKoledoye ah, makes sense, we chose different paths to fix the unbalanced <code>[</code> :)</span>
<span class="comment-copy">@EricDuminil good point - I've updated the wording. Perhaps faster in WPM ;)</span>
