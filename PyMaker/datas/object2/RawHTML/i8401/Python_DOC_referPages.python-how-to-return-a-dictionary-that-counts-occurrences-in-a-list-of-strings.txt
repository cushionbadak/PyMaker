<div class="post-text" itemprop="text">
<p>I'm trying to make a function that counts occurrences of the first letters of a list of strings and returns them as a dictionary. </p>
<p>For example:</p>
<blockquote>
<p>list=["banana","ball", "cat", "hat"]</p>
<p>dictionary would look like: {b:2, c:1, h:1}</p>
</blockquote>
<p>Here is the code I have which iterates but doesn't count properly. That's where I'm getting stuck. How do I update the values to be count?</p>
<pre><code>def count_starts(text):
    new_list=[]
    for word in range(len(text)):
        for letter in text[word]:
            if letter[0]=='':
                new_list.append(None)
            else:
                new_list.append(letter[0])

    new_dict= {x:new_list.count(x) for x in new_list}


    return new_dict
</code></pre>
<p>Also, how can I avoid the out of range error given the following format:</p>
<pre><code>def count_starts(text):
    import collections
    c=collections.Counter(x[0] for x in text)
    return c
</code></pre>
<p>Also, what do I need to do if the list contains "None" as a value? I need to count None. </p>
</div>
<div class="post-text" itemprop="text">
<p>Problem with your code is that you seem to iterate on all letters of the word. <code>letter[0]</code> is a substring of the letter (which is a string).</p>
<p>You'd have to do it more simply, no need for a double loop, take each first letter of your words:</p>
<pre><code>for word in text:
    if word:  # to filter out empty strings
        first_letter = word[0]
</code></pre>
<p>But once again <a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer"><code>collections.Counter</code></a> taking a generator comprehension to extract first letter is the best choice and one-liner (with an added condition to filter out empty strings):</p>
<pre><code>import collections
c = collections.Counter(x[0] for x in ["banana","ball", "cat", "", "hat"] if x)
</code></pre>
<p><code>c</code> is now a dict: <code>Counter({'b': 2, 'h': 1, 'c': 1})</code></p>
<p>one variant to insert <code>None</code> instead of filtering out empty values would be:</p>
<pre><code>c = collections.Counter(x[0] if x else None for x in ["banana","ball", "cat", "", "hat"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_list=["banana","ball", "cat", "hat"] 

my_dict = dict()

for word in my_list:
   try:
      my_dict[word[0]] += 1
   except KeyError:
      my_dict[word[0]] = 1
</code></pre>
<p>This increases the value of the key by 1 for the already existing key, and if they key has not been found before it creates it with the value 1</p>
<p>Alternative:</p>
<pre><code>my_list=["banana","ball", "bubbles", "cat", "hat"] 
my_dict = dict()

for word in my_list:
    if word[0] in my_dict.keys():
        my_dict[word[0]] += 1
    else:
        my_dict[word[0]] = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Also, what do I need to do if the list contains "None" as a value? I
  need to count None.</p>
</blockquote>
<p>removing None</p>
<pre><code>lst_no_Nones = [x for x in lis if x != None]
</code></pre>
<p>count None</p>
<pre><code>total_None = (sum(x != None for x in lst))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you need counter:</p>
<pre><code> from collections import Counter
 lst = ["banana","ball", "cat", "hat"]
 dct = Counter(lst)
</code></pre>
<p>Now, dct stores the number of times every element in lst occurs. </p>
<p>dct = {'b': 2, 'h': 1, 'c': 1}</p>
</div>
<span class="comment-copy"><code>c = collections.Counter(x[0] for x in ["banana","ball", "cat", "hat"])</code> =&gt; <code>Counter({'b': 2, 'h': 1, 'c': 1})</code></span>
<span class="comment-copy">What is collections and how are you defining things? That's tripping me up.</span>
<span class="comment-copy">that's a standard module.</span>
<span class="comment-copy">oh I see! I've never used that module before!</span>
<span class="comment-copy">How can I avoid out of range error with this format?</span>
<span class="comment-copy">@Rawing that's not an option as some of my test cases are empty strings.</span>
<span class="comment-copy">@KelseyGreenwood I understand. The test doesn't have empty strings. But I have added a filter &amp; added empty string to demonstrate the efficiency of the filter.</span>
<span class="comment-copy"><code>None</code> is also filtered. You cannot take first letter of <code>None</code> (don't mix it up with <code>"None"</code> as string). Of course, if your list is a list of floats or something else than string, that won't work, but that's expected.</span>
<span class="comment-copy">There are many better ways to do this. Counter, defaultdict, <code>.get</code>, setdefault, <code>if</code>...</span>
<span class="comment-copy">Of course they are, but I decided to gave an answer that I thought it's closer to the experience Kelsey seems to have with Python. No offense, please.</span>
<span class="comment-copy">@RaduIordache I haven't even learned try and except yet so I appreciate the effort!</span>
<span class="comment-copy">@KelseyGreenwood - I have edited my answer with an alternative using if and else instead of try an except. Hope you'll find it useful.</span>
<span class="comment-copy">How can I put that in my current format?</span>
