<div class="post-text" itemprop="text">
<p>In the following code whith goal to do a wordcount, the add_counts function is concurrently called as a thread, is this operation of reading and updating threadsafe, this <a href="https://stackoverflow.com/questions/6953351/thread-safety-in-pythons-dictionary">answer</a> says that the dictionary update may be threadsafe but what about reading and updating like below: </p>
<pre><code>word_counts={}

@concurrent
def add_counts(line):
    for w in line.split():

        word_counts[w] = word_counts.get(w, 0) + 1

for line in somebigfile:
    add_counts(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Reading and updating is not thread-safe ­­­– here's an example that you can try to use locally to see the effect in practice:</p>
<pre><code>from threading import Thread


def add_to_counter(ctr):
    for i in range(100000):
        ctr['ctr'] = ctr.get('ctr', 0) + 1


ctr = {}

t1 = Thread(target=add_to_counter, args=(ctr,))
t2 = Thread(target=add_to_counter, args=(ctr,))

t1.start()
t2.start()
t1.join()
t2.join()

print(ctr['ctr'])
</code></pre>
<p>The results obviously depend on the scheduling and other system/timing-dependent details, but on my system I consistently get different numbers under <code>200000</code>.</p>
<h1>Solution 1: Locks</h1>
<p><a href="https://stackoverflow.com/questions/1312331/using-a-global-dictionary-with-threads-in-python">You could require the threads to acquire a lock every time before they modify the dictionary.</a> This slows down the program execution somewhat.</p>
<h1>Solution 2: Sum the counters at the end</h1>
<p>Depending on your exact use case, you might be able to assign a separate counter to each thread, and sum the counts together after the threads have finished counting. The dictionary-like <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> allows you to easily add two counters together (here's the above example modified to use Counters):</p>
<pre><code>from collections import Counter
from threading import Thread


def add_to_counter(counter):
    for i in range(100000):
        counter['ctr'] = counter.get('ctr', 0) + 1


ctr1 = Counter()
ctr2 = Counter()

t1 = Thread(target=add_to_counter, args=(ctr1,))
t2 = Thread(target=add_to_counter, args=(ctr2,))

t1.start()
t2.start()
t1.join()
t2.join()

ctr = ctr1 + ctr2

print(ctr['ctr'])
</code></pre>
</div>
<span class="comment-copy">In solution 1 how can i make the locks more granular rather then locking entire dict?</span>
<span class="comment-copy">in second solution I am using python futures so have no control over passing multiple counters as no control over threads</span>
<span class="comment-copy">@stackit I'm not sure if there is a good way to guard against access to one dictionary key with a lock – if there is, hopefully someone else can point you to it. Possibly you could combine the two suggested solutions by maintaining thread-local <code>Counter</code> objects, and at suitable intervals, locking the shared dictionary to add the newest counts to it from the current thread?</span>
<span class="comment-copy">Yes, thats what I was just thinking</span>
