<div class="post-text" itemprop="text">
<p>If I define the <code>__iter__</code> method as follows, it won't work:</p>
<pre><code>class A:

    def __init__(self):
        self.__iter__ = lambda: iter('text')


for i in A().__iter__():
    print(i)

iter(A())
</code></pre>
<p>Result:</p>
<pre><code>t
e
x
t
Traceback (most recent call last):
  File "...\mytest.py", line 10, in &lt;module&gt;
    iter(A())
TypeError: 'A' object is not iterable
</code></pre>
<p>As you can see, calling <code>A().__iter__()</code> works, but <code>A()</code> is not iterable.</p>
<p>However if I define <code>__iter__</code> for the class, then it will work:</p>
<pre><code>class A:

    def __init__(self):

        self.__class__.__iter__ = staticmethod(lambda: iter('text'))
        # or:
        # self.__class__.__iter__ = lambda s: iter('text')


for i in A():
    print(i)

iter(A())

# will print:
# t
# e
# x
# t
</code></pre>
<p>Does anyone know why python has been designed like this? i.e. why <code>__iter__</code> as instance variable does not work? Don't you find it unintuitive?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is done by design. You can find the thorough description here: <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#special-method-lookup</a></p>
<p>Short answer: the special method must be set on the class object itself in order to be consistently invoked by the interpreter. </p>
<p>Long answer: the idea behind this is to speed up well-known constructions. In your example: </p>
<pre><code>class A:
    def __init__(self):
        self.__iter__ = lambda: iter('text')
</code></pre>
<p>How often are you going to write a code like this in real life? So, what Python does - it skips a dictionary lookup of the instance, i.e. <code>iter(A())</code> simply does not "see" that <code>self.__iter__</code>, which is actually <code>self.__dict__['__iter__']</code> in this case. </p>
<p>It also skips all the <code>__getattribute__</code> instance and metaclass lookup gaining a significant speedup.</p>
</div>
<span class="comment-copy">I think the way you try to do it in very unintuitive, why don't you just override <b>iter</b> as a method ? <a href="http://stackoverflow.com/questions/4019971/how-to-implement-iter-self-for-a-container-object-python" title="how to implement iter self for a container object python">stackoverflow.com/questions/4019971/â€¦</a></span>
<span class="comment-copy">Seems to be an old-style vs new-style class issue. Your code does not work with new-style classes.</span>
<span class="comment-copy">@PyNico In the particular case that I'm currently working on, I prefer to define <code>__iter__</code> inside <code>__init__</code> because it's implementation depends on the instantiation arguments.</span>
<span class="comment-copy">I've rewritten the answer to make it more comprehensible. Please tell if you have any questions, or something is not clear.</span>
<span class="comment-copy">This is probably also related to why <code>(1, 2, 3)[2]</code> is much more faster than direct calling of <code>(1, 2, 3).__getitem__(2)</code> (in the latter python also looks inside instance attributes). Great answer, thank you so much.</span>
