<div class="post-text" itemprop="text">
<p>I have a list of a few hundred amino acid sequences called aa_seq, it looks like this: ['AFYIVHPMFSELINFQNEGHECQCQCG', 'KVHSLPGMSDNGSPAVLPKTEFNKYKI', 'RAQVEDLMSLSPHVENASIPKGSTPIP', 'TSTNNYPMVQEQAILSCIEQTMVADAK',...].
Each sequence is 27 letters long. I have to determine the most used amino acid for every position (1-27) and at what frequency that is.</p>
<p>So far I have:</p>
<pre><code>   count_dict = {} 
   counter = count_dict.values()
   aa_list = ['A', 'C', 'D', 'E' ,'F' ,'G' ,'H' ,'I' ,'K' ,'L' ,    #one-letter code for amino acids
       'M' ,'N' ,'P' ,'Q' ,'R' ,'S' ,'T' ,'V' ,'W' ,'Y']
   for p in range(0,26):                       #first round:looks at the first position in each sequence
        for s in range(0,len(aa_seq)):          #goes through all sequences of the list 
             for item in aa_list:                #and checks for the occurrence of each amino acid letter (=item)
                  if item in aa_seq[s][p]:
                      count_dict[item]            #if that letter occurs at the respective position, make it a key in the dictionary
                      counter += 1                #and increase its counter (the value, as definded above) by one 
    print count_dict
</code></pre>
<p>It says KeyError: 'A', and it's pointing to the line count_dict[item]. So the item of the aa_list apparently can't be added as a key this way..? How do I do that? And it also gave an error "'int' object is not iterable" concerning the counter. How else can the counter be increased?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noreferrer" title="Counter">Counter</a> class</p>
<pre><code>&gt;&gt;&gt; from collections import Counter

&gt;&gt;&gt; l = ['AFYIVHPMFSELINFQNEGHECQCQCG', 'KVHSLPGMSDNGSPAVLPKTEFNKYKI', 'RAQVEDLMSLSPHVENASIPKGSTPIP', 'TSTNNYPMVQEQAILSCIEQTMVADAK']
&gt;&gt;&gt; s = [Counter([l[j][i] for j in range(len(l))]).most_common()[0] for i in range(27)]
&gt;&gt;&gt; s
[('A', 1),
 ('A', 1),
 ('Y', 1),
 ('I', 1),
 ('N', 1),
 ('Y', 1),
 ('P', 2),
 ('M', 4),
 ('S', 2),
 ('Q', 1),
 ('E', 2),
 ('Q', 1),
 ('I', 1),
 ('I', 1),
 ('A', 1),
 ('Q', 1),
 ('A', 1),
 ('I', 1),
 ('I', 1),
 ('Q', 1),
 ('E', 2),
 ('C', 1),
 ('Q', 1),
 ('A', 1),
 ('Q', 1),
 ('I', 1),
 ('I', 1)]
</code></pre>
<p>However i might be way to inefficient if you have large data sets.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Modified code</h1>
<p>Here's a modified, working version of your code. It's not efficient but it should  output the correct result.</p>
<p>A few notes :</p>
<ul>
<li>You need one counter for each index. So you should initialize your dict inside the first loop.</li>
<li><code>range(0,26)</code> only has 26 elements : from 0 to 25 (inclusive).</li>
<li><a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> helps you define <code>0</code> for each start value.</li>
<li>you need to increment the counter with <code>count_dict[item] += 1</code></li>
<li>At the end of each loop, you need to find the key (amino acid) with the highest value (occurences).</li>
</ul>
<hr/>
<pre><code>from collections import defaultdict

aa_seq = ['AFYIVHPMFSELINFQNEGHECQCQCG', 'KVHSLPGMSDNGSPAVLPKTEFNKYKI',
          'RAQVEDLMSLSPHVENASIPKGSTPIP', 'TSTNNYPMVQEQAILSCIEQTMVADAK']
aa_list = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L',  # one-letter code for amino acids
           'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']

for p in range(27):                  # first round:looks at the first position in each sequence
    count_dict = defaultdict(int)    # initialize counter with 0 as default value
    for s in range(0, len(aa_seq)):  # goes through all sequences of the list
        # and checks for the occurrence of each amino acid letter (=item)
        for item in aa_list:
            if item in aa_seq[s][p]:
                # if that letter occurs at the respective position, make it a
                # key in the dictionary
                count_dict[item] += 1
    print(max(count_dict.items(), key=lambda x: x[1]))
</code></pre>
<p>It outputs :</p>
<pre><code>('R', 1)
('S', 1)
('Y', 1)
('S', 1)
('E', 1)
('P', 1)
('P', 2)
('M', 4)
...
</code></pre>
<h1>Alternative with Counter</h1>
<p>You don't need that many loops, you just need to iterate once over every character of every sequence.</p>
<p>Also, there's no need to reinvent the wheel: <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> and <a href="https://docs.python.org/2/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>most_common</code></a> are better alternatives than <code>defaultdict</code> and <code>max</code>.</p>
<pre><code>from collections import Counter

aa_seqs = ['AFYIVHPMFSELINFQNEGHECQCQCG', 'KVHSLPGMSDNGSPAVLPKTEFNKYKI', 'RAQVEDLMSLSPHVENASIPKGSTPIP', 'TSTNNYPMVQEQAILSCIEQTMVADAK']

counters = [Counter() for i in range(27)]

for aa_seq in aa_seqs:
    for (i, aa) in enumerate(aa_seq):
        counters[i][aa] += 1

most_commons = [counter.most_common()[0] for counter in counters]
print(most_commons)
</code></pre>
<p>It outputs :</p>
<blockquote>
<p>[('K', 1), ('A', 1), ('Y', 1), ('N', 1), ('N', 1), ('Y', 1), ('P', 2),
  ('M', 4), ('S', 2), ('Q', 1), ('E', 2), ('G', 1), ('H', 1), ('N', 1),
  ('L', 1), ('N', 1), ('N', 1), ('I', 1), ('G', 1), ('H', 1), ('E', 2),
  ('G', 1), ('N', 1), ('K', 1), ('Y', 1), ('K', 1), ('G', 1)]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>to add an item to a dictionnary, you must initialize it to a value :</p>
<pre><code>if item not in count_dict:
    count_dict[item]=0
</code></pre>
<p>you can use the <a href="https://www.tutorialspoint.com/python/dictionary_setdefault.htm" rel="nofollow noreferrer">setdefault</a> function to perform this as a one-liner:</p>
<pre><code>count_dict.setdefault(item,0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is how you tally items in a dictionary quickly, just add that to whatever code you've created</p>
<pre><code>count_dict = {} 

aa_list = ['A', 'C', 'D', 'E' ,'F' ,'G' ,'H' ,'I' ,'K' ,'L' ,
       'M' ,'N' ,'P' ,'Q' ,'R' ,'S' ,'T' ,'V' ,'W' ,'Y']

for element in aa_list:
    count_dict[element]=(count_dict).get(element,0)+1

print (count_dict)
</code></pre>
</div>
<span class="comment-copy">What are you trying to with <code>count_dict[item]</code>? Even if <code>item</code> did exist within that dictionary, all that would do would be to look up the value and immediately throw it away; you don't assign anything there.</span>
<span class="comment-copy">Plus, <code>counter</code> is defined as a list of the values in count_dict at the start; it is an empty list, because count_dict is empty. So <code>counter += 1</code> makes no sense, because you can't add an integer to a list.</span>
<span class="comment-copy">Unlike in a language like c++ where you can initialize dictionary (map) entries simply by referencing them, in python you need to explicitly initialize dictionary entries.</span>
<span class="comment-copy">Ah ok that makes sense, with the counters. How else can I count the occurrence of the key and store it as the value?</span>
<span class="comment-copy">Ah that's cool, I can try that. But what does the <code>most_common()[0] </code> do, because the output just gives the number of all letters..?</span>
<span class="comment-copy">@ccaarroo: The list is the desired information. The first tuple is the most common character at index 0 in the sequences, with 1 occurence. You can see that <code>M</code> is present 4 times at index 7 for example.</span>
<span class="comment-copy"><code>most_common([n])</code> prints out the n most common elements as a list. Hence  <code>most_common()[0]</code> prints out the single most common element at the position i.</span>
<span class="comment-copy">Just because iterating over list in pure python is slow. When people talk about "amino acid sequences"  I immediately think of gigabytes of data. So something using numpy arrays or cython might be the way to go.</span>
<span class="comment-copy">Yeah but one liners difficult to understand for python novices. So there is some value to your solution too.</span>
