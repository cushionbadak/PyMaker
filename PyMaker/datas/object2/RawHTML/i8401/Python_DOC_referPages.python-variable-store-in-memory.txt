<div class="post-text" itemprop="text">
<pre><code>a=[1234,1234] #list

a      
[1234, 1234] 

id(a[0])      
38032480

id(a[1])      
38032480

b=1234 #b is a variable of integer type

id(b)      
38032384
</code></pre>
<p>Why id(b) is not same as id(a[0]) and id(a[1]) in python ?    </p>
</div>
<div class="post-text" itemprop="text">
<p>When the CPython REPL executes a line, it will:</p>
<ol>
<li>parse, and compile it to a code object of bytecode, and then</li>
<li>execute the bytecode.</li>
</ol>
<p>The compilation result can be checked through the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; dis.dis('a = [1234, 1234, 5678, 90123, 5678, 4321]')
  1           0 LOAD_CONST               0 (1234)
              2 LOAD_CONST               0 (1234)
              4 LOAD_CONST               1 (5678)
              6 LOAD_CONST               2 (90123)
              8 LOAD_CONST               1 (5678)
             10 LOAD_CONST               3 (4321)
             12 BUILD_LIST               6
             14 STORE_NAME               0 (a)
             16 LOAD_CONST               4 (None)
             18 RETURN_VALUE
</code></pre>
<p>Note that all 1234s are loaded with "<code>LOAD_CONST 0</code>", and all 5678s are are loaded with "<code>LOAD_CONST 1</code>". These refer to the constant table associated with the code object. Here, the table is <code>(1234, 5678, 90123, 4321, None)</code>.</p>
<p><strong>The compiler knows that all the copies of 1234 in the code object are the same</strong>, so will only allocate one object to all of them.</p>
<p>Therefore, as OP observed, <code>a[0]</code> and <code>a[1]</code> do indeed refer to the same object: the same constant from the constant table of the code object of that line of code.</p>
<p>When you execute <code>b = 1234</code>, this will again be compiled and executed, <strong>independent of the previous line, so a different object will be allocated.</strong></p>
<p>(You may read <a href="http://akaptur.com/blog/categories/python-internals/" rel="nofollow noreferrer">http://akaptur.com/blog/categories/python-internals/</a> for a brief introduction for how code objects are interpreted)</p>
<hr/>
<p>Outside of the REPL, when you execute a <code>*.py</code> file, each function is compiled into separate code objects, so when we run:</p>
<pre><code>a = [1234, 1234]
b = 1234
print(id(a[0]), id(a[1]))
print(id(b))

a = (lambda: [1234, 1234])()
b = (lambda: 1234)()
print(id(a[0]), id(a[1]))
print(id(b))
</code></pre>
<p>We may see something like:</p>
<pre><code>4415536880 4415536880
4415536880
4415536912 4415536912
4415537104
</code></pre>
<ul>
<li>The first three numbers share the same address 4415536880, and they belong to the constants of the "__main__" code object</li>
<li>Then <code>a[0]</code> and <code>a[1]</code> have addresses 4415536912 of the first lambda.</li>
<li>The <code>b</code> has address 4415537104 of the second lambda.</li>
</ul>
<hr/>
<p>Also note that this result is valid for CPython only. Other implementations have different strategies on allocating constants. For instance, running the above code in PyPy gives:</p>
<pre><code>19745 19745
19745
19745 19745
19745
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no rule or guarantee stating that the id(a[0]) should be equal to the id(a[1]), so the question itself is moot. The question you should be asking is why <code>id(a[0])</code> and <code>id(a[1])</code> are in fact the same.<br/>
If you do <code>a.append(1234)</code> followed by <code>id(a[2])</code> you may or may not get the same id. As <code>@hiro protagonist</code> has pointed out, these are just internal optimizations that you shouldn't depend upon.</p>
</div>
<div class="post-text" itemprop="text">
<p>A Python list is very much unlike a C array.</p>
<p>A C array is just a block of contiguous memory, so the address of its first (0-th) element is the address of the array itself, by definition. Array access in C is just pointer arithmetic, and the <code>[]</code> notation is just a thin crust of syntactic sugar over that pointer arithmetic. An expression <code>int x[]</code> is just another form of <code>int * x</code>.</p>
<p>For the sake of the example, let's assume that in in Python, <code>id(x)</code> is a "memory address of X", as <code>*x</code> would be in C. (This is not true for all Python implementations, and not even guaranteed in CPython. It's just an unique number.)</p>
<p>In C, an <code>int</code> is just an architecture-dependent number of bytes, so for <code>int x = 1</code> the expression <code>*x</code> points to these bytes. 
Everything in Python is an object, <em>including numbers</em>. This is why <code>id(1)</code> refers to an object of type <code>int</code> describing number <code>1</code>. You can call its methods: <code>(1).__str__()</code> will return a string <code>'1'</code>.</p>
<p>So, when you have <code>x = [1, 2, 3]</code>, <code>id(x)</code> is a "pointer" to a <code>list</code> object with three elements. The <code>list</code> object itself is pretty complex. But <code>x[0]</code> is not the bytes that comprise the integer value 1; it's internally a <em>reference</em> to an <code>int</code> object for number 1. Thus <code>id(x[0])</code> is a "pointer" to that object.</p>
<p>In C terms, the elements of the array could be seen as pointers to the objects stored in it, not the objects themselves.</p>
<p>Since there's no point to have two objects representing the same number 1, <code>id(1)</code> is always the same during a Python interpreter run. An illustration:</p>
<pre><code>x = [1, 2, 3]
y = [1, 100, 1000]

assert id(x) != id(y)  # obviously
assert id(x[0]) == id(y[0]) == id(1) # yes, the same int object
</code></pre>
<p>CPython actually preallocates objects for a few most-used small numbers (<a href="https://docs.python.org/2/c-api/int.html#c.PyInt_FromLong" rel="nofollow noreferrer">see comments here</a>). For larger numbers, it's not so, which <a href="https://stackoverflow.com/q/306313/223424">can lead to two 'copies' of a larger number having different <code>id()</code> values</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You must note that: id() actually gives id of the value of variables or literals. For every literal/value that is used in your program (even when within the id() itself), id() returns (attempts to return) an unique identifier for the literal/variable within the program life-cycle. This can be used by:</p>
<ul>
<li>User: to check if two objects/variables are the same as in: a is b </li>
<li>Python: to optimise memory i.e. avoid unwanted duplications of same stuff in memory</li>
</ul>
<p>As for your case, it isn't even guaranteed that a[0] and a[1] will give the same id though the value of both can be the same. It depends on the order/chronology of creation of literals/variables in the python program lifecycle and internally handled by python. </p>
<p>Case 1:</p>
<pre><code>Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; a=[1234,1234] 
&gt;&gt;&gt; id(a[0])
52687424
&gt;&gt;&gt; id(a[1])
52687424
</code></pre>
<p>Case 2 (Note that at the end of case , a[0] and a[1] have same value but different ids):</p>
<pre><code>Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; a=[1,1234]
&gt;&gt;&gt; id(1)
1776174736
&gt;&gt;&gt; id(1234)
14611088
&gt;&gt;&gt; id(a[0])
1776174736
&gt;&gt;&gt; id(a[1])
14611008
&gt;&gt;&gt; a[0]=1234
&gt;&gt;&gt; id(1234)
14611104
&gt;&gt;&gt; id(a[0])
14611152
&gt;&gt;&gt; id(a[1])
14611008
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">In python,value 1234 have to get only one memory location .why id(b) show different memory location.answer the question plzz.</span>
<span class="comment-copy">not really an answer but some insight on interning (for strings): <a href="http://guilload.com/python-string-interning/" rel="nofollow noreferrer">guilload.com/python-string-interning</a> . it seems like the list constructor does some interning by default.</span>
<span class="comment-copy">@hiroprotagonist I think it's the <code>int</code> constructor doing the interning, not <code>list</code>.</span>
<span class="comment-copy">but in Python , if I write a=1 ; b=1; both id(a) ==id(b) but now it gives different output.</span>
<span class="comment-copy">@aman-tyagi: interning of integers is not guaranteed! if i remember correctly, integers from -5 to 255 are interned (have the same id) in the standard CPython interpreter; the rest may or may not be interned. and this is an implementation detail and should never be relied upon. always compare integers with <code>==</code> and never with <code>is</code> to get reliable results.</span>
<span class="comment-copy">so you agree that this has to do with the <code>list</code> constructor and not the <code>int</code> constructor? (don't want to be smart about it; just curious) +1 anyway! thanks for the answer.</span>
<span class="comment-copy">@hiroprotagonist Actually neither, it has to do with the compiler. By the time the list constructor is called, it is already seeing two identical objects.</span>
<span class="comment-copy">oh, ok! sorry, that should have been obvious from the disassembled code... thanks!</span>
