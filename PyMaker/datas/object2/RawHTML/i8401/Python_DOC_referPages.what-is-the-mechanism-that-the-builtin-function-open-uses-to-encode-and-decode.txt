<div class="post-text" itemprop="text">
<p>I have a little confusion about <code>open</code>. I'm running Windows 10, when I call <code>sys.getfilesystemencoding</code> I get <code>mbcs</code> so if I pass the filename to <code>open</code> for example:</p>
<pre><code>open('Meow!.txt')
</code></pre>
<p>Supposedly, the encoding for the source file is utf-8. Does <code>open</code> encodes the filename <code>'Meow!.txt'</code> with <code>mbcs</code> encoding which is set to the default Windows ANSI codepage? And then passes the requests to the OS?</p>
<ul>
<li><p>Generally speaking, what happens when you pass filename to <code>open</code> as unicode in 2.X and <code>str</code> in 3.X? </p></li>
<li><p>Is it true when the filename is passed as a <code>bytes</code> object in 3.X or <code>str</code> in 2.X, overrides the default automatic encoding of the filename?</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Here's what happens internally when using the builtin <code>open</code> in 2.7 to be precise: </p>
<p>Python sets a constant that names the default encoding of filenames, this constant is called <code>Py_FileSystemDefaultEncoding</code> and varies per-platform. Ultimately, when its value is set to Null, Python will try to get the default encoding of the platform if there's any: </p>
<pre><code> /*bltinmodule.c*/

/* The default encoding used by the platform file system APIs
   Can remain NULL for all platforms that don't have such a concept
*/

    #if defined(MS_WINDOWS) &amp;&amp; defined(HAVE_USABLE_WCHAR_T)
    const char *Py_FileSystemDefaultEncoding = "mbcs";
    #elif defined(__APPLE__)
    const char *Py_FileSystemDefaultEncoding = "utf-8";
    #else
    const char *Py_FileSystemDefaultEncoding = NULL; /* use default */
    #endif
</code></pre>
<p><code>Py_FileSystemDefaultEncoding</code> uses "mbcs" (Multi-byte-character-set) Windows encoding, you can check the value of <code>Py_FileSystemDefaultEncoding</code> using <code>sys.getfilesystemencoding()</code> call:</p>
<blockquote>
<p><em>Python 2.7 Documentation: <code>sys.getfilesystemencoding()</code></em> </p>
<p>On Windows NT+, file names are Unicode natively, so no conversion is performed. <code>getfilesystemencoding()</code> still returns 'mbcs', as this is the encoding that applications should use when they explicitly want to convert Unicode strings to byte strings that are equivalent when used as file names.</p>
</blockquote>
<p>So for example let's assume when a filename with Chinese characters, for simplicity I'm going to use U+5F08 Chinese chess CJK for the filename that I'm going to write: </p>
<pre><code>&gt;&gt;&gt; f = open(u'\u5F08.txt', 'w')
&gt;&gt;&gt; f
&lt;open file u'\u5f08', mode 'w' at 0x000000000336B1E0&gt;
</code></pre>
<ul>
<li>Generally speaking, what happens when you pass filename to <code>open</code> as unicode in 2.X and <code>str</code> in 3.X?</li>
</ul>
<p>This answer is platform-dependent. For instance, in Windows, there's no need to convert Unicode strings to any encoding, not even with the default filesystem encoding "mbcs", to prove that: </p>
<pre><code>&gt;&gt;&gt; f = open(u'\u5F08.txt'.encode('mbcs'), 'w')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IOError: [Errno 22] invalid mode ('w') or filename: '?.txt'
</code></pre>
<p>By the way, even if you use 'utf-8' encoding, you'll not get the correct filename: </p>
<pre><code>&gt;&gt;&gt; f = open(u'\u5F08.txt'.encode('utf8'), 'w')
</code></pre>
<p>This will give you <strong>å¼ˆ.txt</strong> filename if you check that on Windows instead of <strong>弈.txt</strong>. In conclusion, there's no conversion for Unicode filenames apparently. I think this rule applies to <code>str</code> too. Since <code>str</code> in 2.X is a raw byte string, Python won't pick encoding magically **I cannot verify this however and it might be possible that Python will decode <code>str</code> with "mbcs" encoding. It's possible to verify that I believe by using characters outside "mbcs" code pages character set, but this is again will depend on your Windows locale settings. So much is encapsulated at the lower level in Windows implementation. If memory serves, I think "mbcs" now is considered legacy for Windows APIs.   Python 3.6 uses UTF-8 instead, unless the legacy mode is enabled. </p>
<p>Really though, it seems the issue is deep into Windows APIs and their implementation, rather than the implementation of Python itself. </p>
</div>
<span class="comment-copy">You can force the encoding with <code>open("file_name", 'r', encoding="utf-8")</code> otherwise you can open your file like what you've done then decode your data into utf8 by using <code>f.read().decode("utf-8")</code>. Check this <a href="https://docs.python.org/3/howto/unicode.html#reading-and-writing-unicode-data" rel="nofollow noreferrer">link from official documentation</a></span>
<span class="comment-copy">@ChihebNexus: That specifies the encoding for the file contents, not the file name.</span>
<span class="comment-copy">@ChihebNexus, <code>encoding</code> argument in <code>open</code> specifies the encoding of the file content, not the filename. My questions is related to the encoding of the (filename): <code>Mewo!.txt</code></span>
<span class="comment-copy">@user2357112, you're right. I misunderstood the question. Thanks for pointing it to me.</span>
<span class="comment-copy">I was about to post a brief answer, but I changed my mind quickly. I read the code for <code>codecs.open</code> in 2.X but <code>codecs.open</code> uses <code>__builtin__.open</code> and passes filename as is without encoding. So the encoding of the filename must technically be handled by <code>__builtin__.open</code> or <code>builtin.open</code> in 3.X. So I looked for the C code of the builtin <code>open</code>, but I couldn't find it.</span>
