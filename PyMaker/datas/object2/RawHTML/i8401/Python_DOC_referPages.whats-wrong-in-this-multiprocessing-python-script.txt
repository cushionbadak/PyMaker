<div class="post-text" itemprop="text">
<p>I am writting a simple messaging program (for 2 users) that works on the terminal.</p>
<p>For its implementation, I decided to create 2 processes, one for the server (waits for the message to arrive from the other user), and another one for the client (just sends the message to the server process of the other user)</p>
<p>The fact is that when I run it, I get the following error:</p>
<pre><code>C:\&gt;python message.py

&gt; Process Process-2:
Traceback (most recent call last):
File "C:\Python27\lib\multiprocessing\process.py", line 258, in_bootstrap
self.run()
File "C:\Python27\lib\multiprocessing\process.py", line 114, in run
self._target(*self._args, **self._kwargs)
File "C:\message.py", line 12, in send_messages
message = raw_input('&gt; ')
EOFError

Process Process-1:
Traceback (most recent call last):
File "C:\Python27\lib\multiprocessing\process.py", line 258, in 
_bootstrap
self.run()
File "C:\Python27\lib\multiprocessing\process.py", line 114, in run
self._target(*self._args, **self._kwargs)
File "C:\message.py", line 25, in receive_messages
message = sc.recv(1024)
error: [Errno 10054] An existing connection was forcibly closed by the 
remote host
</code></pre>
<p>This is my Python code</p>
<pre><code>from multiprocessing import Process
import socket

direction = "localhost"

global s
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
def send_messages():
   s.connect((direction, 5124))
   while True:
       message = raw_input('&gt; ')
       s.send(message)
       if message == 'close':
           break
   print 'Bye'
   s.close()

def receive_messages():
   s.bind(("localhost",5124))
   s.listen(2)
   sc, addr = s.accept()

   while True:
       message = sc.recv(1024)
       print message
   sc.close()
   s.close()

if __name__ == '__main__':

   p1 = Process(target = receive_messages)
   p1.start()
   p2 = Process(target = send_messages)
   p2.start()
   p1.join()
   p2.join()
</code></pre>
<p>NOTE 1: There can be some indentation errors due to cut and paste from my text editor to stackoverflow.</p>
<p>NOTE 2: I am working on Windows 10</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/multiprocessing.html?highlight=sys.stdin.close#all-start-methods" rel="nofollow noreferrer">the documentation</a>:</p>
<blockquote>
<p><em>Beware of replacing sys.stdin with a “file like object”</em></p>
<p>multiprocessing originally unconditionally called:</p>
</blockquote>
<pre><code>os.close(sys.stdin.fileno())
</code></pre>
<blockquote>
<p>in the <code>multiprocessing.Process._bootstrap()</code> method — this resulted in issues with processes-in-processes. This has been changed to:</p>
</blockquote>
<pre><code>sys.stdin.close()
sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)
</code></pre>
<blockquote>
<p>Which solves the fundamental issue of processes colliding with each other resulting in a bad file descriptor error, but introduces a potential danger to applications which replace <code>sys.stdin()</code> with a “file-like object” with output buffering. This danger is that if multiple processes call <code>close()</code> on this file-like object, it could result in the same data being flushed to the object multiple times, resulting in corruption.</p>
</blockquote>
<p>The bottom line is that your <code>Process</code>es are closing <code>stdin</code> unless you subclass them and avoid doing so.</p>
<p>You might consider using one (capital-P) Process to handle communications, and then doing the input/output in your original (lowercase) process:</p>
<pre><code>if __name__ == '__main__':

   p1 = Process(target = receive_messages)
   p1.start()

   send_messages()

   p1.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/5697305/python-command-line-input-in-a-process">See this question.</a></p>
<p>When you spawn a thread in Python, <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">it closes stdin</a>. You can't use a subprocess to collect standard input. Use the main thread to collect input instead and post them to the Queue from the main thread. It may be possible to pass the stdin to another thread, but you likely need to close it in your main thread.</p>
<p>Maybe you can work around this by using fdopen() to reopen stdin in the subprocess. <a href="https://stackoverflow.com/questions/7489967/python-using-stdin-in-child-process/15766145#15766145">See this answer</a>.</p>
<p>Here is an example from your code:</p>
<pre><code>from multiprocessing import Process
import socket
import sys
import os

direction = "localhost"

# I got this error
# error: [Errno 106] Transport endpoint is already connected
# when I run your code ,so I made some change
# You can ignore it if everything is ok when your code run

global s1
s1 = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

global s2
s2 = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

def send_messages(fileno):
    s1.connect((direction, 5104))
    sys.stdin = os.fdopen(fileno)  # open stdin in this process
    while True:
        message = ''
        message = raw_input('&gt; ')
        s1.send(message)
        if message == 'close':
            break

    print 'Bye'
    s1.close()

def receive_messages():
    s2.bind(("localhost",5104))
    s2.listen(2)
    sc, addr = s2.accept()

    while True:
        message = sc.recv(1024)
        if message == 'close':
            print 'Bye!'
            break
        print message

    sc.close()
    s2.close()

if __name__ == '__main__':
    fn = sys.stdin.fileno()  # get original file descriptor
    p1 = Process(target = receive_messages)
    p1.start()
    p2 = Process(target = send_messages, args=(fn,))
    p2.start()
    p1.join()
    p2.join()
</code></pre>
<p>I tested it,and it worked.</p>
</div>
<div class="post-text" itemprop="text">
<p>The error you are receiving basically means your <code>raw_input</code> is receiving an empty input. That condition raises the EOFError you can read about it in the <a href="https://docs.python.org/3.5/library/exceptions.html#EOFError" rel="nofollow noreferrer">built-in-exceptions section</a> of the documentation. </p>
<p>I've never tried something like this with multiprocessing before but i would imagine that is where your problem lies. Perhaps make sure your logic is working as expected in a single process before moving to multiprocess, but i still feel like trying to start multiple processes to receive user input is gonna be a headache.  </p>
</div>
