<div class="post-text" itemprop="text">
<p>I’m iterating through a file’s lines with <code>enumerate()</code>, and sometimes would need to start the iterating at a specific file line, so I attempted <code>testfile.seek()</code>, e.g. if I want to start iterating the file again at line 10 then <code>testfile.seek(10)</code>:</p>
<pre><code>test_file.seek(10)

for i, line in enumerate(test_file):
    …
</code></pre>
<p>Yet the <code>test_file</code> always keep iterating starting at the very first line 0. 
What could I be doing wrong? Why isn’t the <code>seek()</code> working? Any better implementations would be appreciated as well.</p>
<p>Thank you in advance and will be sure to upvote/accept answer</p>
</div>
<div class="post-text" itemprop="text">
<p>Ordinary files are sequences of <em>characters</em>, at the file system level and as far as Python is concerned; there's no low-level way to jump to a particular line. The <a href="https://docs.python.org/3/library/io.html#io.IOBase.seek" rel="nofollow noreferrer"><code>seek()</code></a> command counts the offset in bytes, not lines. (In principle, an explicit seek offset should only be used if the file was opened in binary mode. Seeking on a text file is <a href="https://docs.python.org/3/library/io.html#io.TextIOBase.seek" rel="nofollow noreferrer">"undefined behavior"</a>, since logical characters can take more than one byte.)</p>
<p>Your only option if you want to skip a number of lines is to read and discard them. Since iterating over a file object fetches it one line at a time, a compact way to get your code to work is with <a href="https://docs.python.org/3.6/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice()</code></a>:</p>
<pre><code>from itertools import islice

skipped = islice(test_file, 10, None)  # Skip 10 lines, i.e. start at index 10
for i, line in enumerate(skipped, 11):
    print(i, line, end="")
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Personally i would just use an if statement. rudimentary perhaps but it is atleast very easy to understand.</p>
<pre><code>with open("file") as fp:
for i, line in enumerate(fp):
    if i &gt;= 10:
        # do stuff.
</code></pre>
<hr/>
<p>Edit: islice:
The comparisons done here: <a href="https://stackoverflow.com/questions/19189961/python-fastest-access-to-line-in-file">Python fastest access to line in file</a> are better than i am capable of. combined with the itertools manual: <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">https://docs.python.org/2/library/itertools.html</a> i doubt you'd need much more</p>
</div>
<div class="post-text" itemprop="text">
<p>A native Python way of doing this would  be use <code>zip</code> to iterate over unnecessary lines.</p>
<pre><code>with open("text.txt","r") as test_file:
    for _ in zip(range(10), test_file): pass
    for i, line in enumerate(test_file,start=10):
        print(i, line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't use <code>seek()</code> to got to a beginning of a particular line unless you know the byte-offset of the first character of the desired line.</p>
<p>One simple way to do it would be to use the <a href="https://docs.python.org/2/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>islice()</code></a> iterator in the <code>itertools</code> module.</p>
<p>For example, say you had a very test input file that looked like this:</p>
<pre class="lang-none prettyprint-override"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
...
</code></pre>
<p>Sample code:</p>
<pre><code>from __future__ import print_function
from itertools import islice

with open('test_file.txt') as test_file:
    for i, line in enumerate(islice(test_file, 9, None), 10):
        print('line #{}: {}'.format(i, line), end='')
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>line #10: 10
line #11: 11
line #12: 12
line #13: 13
line #14: 14
line #15: 15
line #16: 16
line #17: 17
line #18: 18
line #19: 19
line #20: 20
line #21: 21
line #22: 22
...
</code></pre>
<p>Note <code>islice()</code> counts from zero, which is why it's first argument was <code>9</code> and not <code>10</code>. Also this is not as fast as <code>seek()</code> would be because <code>islice()</code> actually reads all the lines up until it gets to the one you want to start at.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only way the <a href="https://docs.python.org/3/library/io.html#io.TextIOBase.seek" rel="nofollow noreferrer"><code>seek</code></a> method is going to help you is if all the lines in the file are of the same length, which you know ahead of time and your file is either binary or at least ascii-only text (i.e. no unicode characters allowed). Then you really could do</p>
<pre><code>test_file.seek(10 * (length_of_line + 1), os.SEEK_SET)
</code></pre>
<p>This is because <code>seek</code> will move the internal file pointer by a fixed number of bytes, not lines. The <code>+1</code> above is to account for newline characters. You would likely have to make it <code>+2</code> on a windows machine.</p>
<p>This will not work if your file is non-ascii because some lines may be the same length in characters but actually contain a different number of bytes, making the call to <code>seek</code> yield undefined results.</p>
<p>There are a few legitimate ways you can skip the first 10 lines:</p>
<ol>
<li><p>Read the whole file into a <code>list</code> and discard the first 10 lines:</p>
<pre><code>with open(...) as test_file:
    test_data = list(test_file)[10:]
</code></pre>
<p>Now <code>test_data</code> contains all the lines in your file besides the first 10.</p></li>
<li><p>Discard lines from the file as you read it in a <code>for</code> loop using <code>enumerate</code>:</p>
<pre><code>with open(...) as test_file:
    for lineno, line in test_file:
        if lineno &lt; 10:
            continue
        # Do something with the line
</code></pre>
<p>This method has the advantage of stripping the trailing newlines from each line before handing them off to you. This is functionally similar to using <code>itertools.islice</code> as some of the other answers suggest.</p></li>
<li><p>Use some really arcane low-level stuff to actually read 10 newline characters from the file before proceeding normally. You may have to specify the encoding of the file up-front for this to work correctly with text I/O, but it should work out-of-the-box for ASCII files (see <a href="https://stackoverflow.com/a/2988278/2988730">here</a> for more details):</p>
<pre><code>newline_count = 10
with open(..., encoding='utf-8') as test_file:
    while newline_count &gt; 0:
        next_char = test_file.read(1)
        if next_char == '\n':
            newline_count -= 1
    # You have skipped 10 lines, so process normally here.
</code></pre>
<p>This option is not particularly robust. It does not handle the case where there are fewer than 10 lines gracefully, and it re-implements the internal machinery of the built-in file iterator very crudely. The only possible advantage it offers is that it does not buffer entire lines like the iterator does.</p></li>
</ol>
</div>
<span class="comment-copy">Doesn't <code>seek(10)</code> go to the 10th byte in your file?</span>
<span class="comment-copy">Have you read <a href="https://docs.python.org/3.4/library/io.html#io.TextIOBase.seek" rel="nofollow noreferrer">the docs</a> for the seek method?</span>
<span class="comment-copy">I think it would be wise to mention that you are concerned with efficiency in particular. that way you might be more likely to get answers talking about linecache / islice which i think is the fastest options.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/19189961/python-fastest-access-to-line-in-file">Python fastest access to line in file</a></span>
<span class="comment-copy">I think you're right. To find the 10th line, Python must first find 9 newline characters, which could be anywhere.</span>
<span class="comment-copy"><code>iseek</code>? or you meant <code>islice</code></span>
<span class="comment-copy">Dammit, yes of course @MosesKoledoye :-) Thanks for catching it.</span>
<span class="comment-copy">;-) and thanks for beating me to the missed <code>import</code> fix</span>
<span class="comment-copy">I'd say that line numbers aren't 0-indexed. OP probably wants to skip 9 lines.</span>
<span class="comment-copy">but would prefer seek() for optimization. so they it wouldn't need to iterate through unnecessary lines</span>
<span class="comment-copy">@JoKo Ah if efficiency is a consideration then i would reccomend itertools.islice. Then you don't even need to load the used lines into memory.</span>
<span class="comment-copy">do you mind showing an example with <code>itertools.islice</code> as well?</span>
<span class="comment-copy">@Jo Ko: You can't.  A line is defined by certain characters, and SOMETHING has to read them to know where they are, unless you've built an external index for your file.</span>
<span class="comment-copy">Yeah, <code>islice</code> doesn't prevent each line being loaded into memory, it just lazily iterates over lines. Which so does this solution, but <code>islice</code> is for taking <i>slices</i>.</span>
<span class="comment-copy">Unless it is a binary file, <code>test_file.seek(10 * (length_of_line + 1))</code> is undefined. From the Python docs: "offset must either be a number returned by <code>TextIOBase.tell()</code>, or zero. Any other offset value produces undefined behaviour."</span>
<span class="comment-copy">@iafisher. Good catch. Fixed.</span>
<span class="comment-copy">I think it is still wrong. The <code>whence</code> argument (the second one) defaulted to <code>os.SEEK_SET</code> anyway; the problem is that the <code>offset</code> argument (the first one), can only be 0 or a value returned by a call to <code>tell</code>. This is the same restriction as <a href="http://en.cppreference.com/w/c/io/fseek" rel="nofollow noreferrer">in C's fseek function</a>.</span>
<span class="comment-copy">@iafisher. You are right. I think that the problem arises for non-ascii text files because even low-level functions like <code>read(1)</code> can return a multi-byte character as a single unit. I will add a notation for that similar to the one I did in item #3.</span>
<span class="comment-copy">@iafisher. Let me know if you approve of the latest edit. I think it corrects the issue you noticed.</span>
