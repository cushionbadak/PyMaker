<div class="post-text" itemprop="text">
<p>This is a program that has the first input for the number of elements in the input array , the second input is the input array and the third input is the numbers to be counted in the list </p>
<pre><code>num = int(input())
array = input()
lissst = array.split() 
lissst = [int(a) for a in lissst]
num_query = int(input())
i = num_query
while i &gt; 0:
    queries = int(input())
    x = lissst.count(queries)
    if x &gt; 0:
        print (x) 
    elif x == 0:
        print("NOT PRESENT")
    i = i - 1
</code></pre>
<p>Input format is as shown below:</p>
<p>6 </p>
<p>1 1 1 2 2 0 </p>
<p>6 
1 </p>
<p>2</p>
<p>1</p>
<p>0</p>
<p>3</p>
<p>4</p>
<p>Output layout is as follows:</p>
<p>3</p>
<p>2</p>
<p>3</p>
<p>1</p>
<p>NOT PRESENT</p>
<p>NOT PRESENT</p>
<p>I need to reduce execution time for large inputs, any tips on how to do so for this particular problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>Slowness probably comes from here:</p>
<pre><code>x = lissst.count(queries)
</code></pre>
<p>since <code>list.count</code> has to read the whole list each time.</p>
<p>You can speed it up by putting each number from the input array in a dictionary (number -&gt; how often it appeared in the array). Below I use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>, which is just a convenient wrapper around dicts:</p>
<pre><code>from collections import Counter

num = int(input())

array = input()
array = [int(a) for a in array.split()]
counter = Counter(array)

i = int(input())

while i &gt; 0:
    query = int(input())
    x = counter[query]
    if x &gt; 0:
        print (x) 
    else:
        print("NOT PRESENT")
    i -= 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>to answer on the query number faster, you can build a dictionary mapping of number -&gt; count.</p>
<p>when receiving query number, use the dictionary mapping to return the result in O(1) amortized (instead of O(n) of the original naive solution)</p>
<p><strong>build the mapping</strong> <code>O(n)</code>:</p>
<pre><code>num2count = {}
for i in my_array:
    if not i in num2count:
        num2count[i] = 1
    else:
        num2count[i] += 1
</code></pre>
<p><strong>answer a query "how many times x in array"</strong> <code>O(1)</code> on average</p>
<pre><code>counts = num2count.get(x, 0)
</code></pre>
<p><strong>Your code updated</strong></p>
<pre><code>num = int(input())
array = input()
lissst = array.split() 
lissst = [int(a) for a in lissst]

num2count = {}
for i in lissst:
    if not i in num2count:
        num2count[i] = 1
    else:
        num2count[i] += 1

num_query = int(input())
i = num_query
while i &gt; 0:
    queries = int(input())
    x = num2count.get(queries, 0)
    if x &gt; 0:
        print (x) 
    elif x == 0:
        print("NOT PRESENT")
    i = i - 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the existing answers, you could try Pypy: <a href="https://pypy.org" rel="nofollow noreferrer">https://pypy.org</a></p>
<p>“If you want your code to run faster, you should probably just use PyPy.” — Guido van Rossum (creator of Python)</p>
</div>
<span class="comment-copy">Thanks for the answer! It reduces the time but could you explain how this differs from the method i used and also if you have any other methods of reducing time complexity of such problems.</span>
<span class="comment-copy">@MadalitsoPhiri You used <code>count()</code> method, which have time complexity <code>O(n)</code>, in cycle, so time complexity of counting is <code>O(i*n)</code>. In RafG's answer counter is used outside the cycle, and in cycle <code>counter[query]</code> is used, which have time compexity <code>O(1)</code>. So, time complexity of counting in this case is <code>O(n)</code>.</span>
