<div class="post-text" itemprop="text">
<p>I'm planning to use Adafruit PN532 nfc <a href="https://www.adafruit.com/product/364" rel="nofollow noreferrer">https://www.adafruit.com/product/364</a> breakout card in my project.</p>
<p>Is there a way to write a non blocking-code in python (using interrupts ?) in a way to avoid a loop as in this code sample ?</p>
<p><a href="https://github.com/adafruit/Adafruit_Python_PN532/blob/master/examples/readmifare.py" rel="nofollow noreferrer">https://github.com/adafruit/Adafruit_Python_PN532/blob/master/examples/readmifare.py</a></p>
</div>
<div class="post-text" itemprop="text">
<p>(with respect to my comments..) While <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> is a bit lighter weight, <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer"><code>threading</code></a> also has an event calling system, and is currently a bit better documented (threading has been around longer than asyncio and is a bit less abstract). As I understand it, you want to be able to read from a blocking resource while working on some other task. In this case we will create a thread to wait for a card to be read, while slowly printing a text file to stdout. This is just an example of how to do something like that. There are many ways to accomplish a similar result.</p>
<pre><code>import binascii
import time
import threading
from collections import deque #use as a fifo queue

queue = deque() #queue to pass information from thread to main process
queue_lock = threading.Lock() #prevent possible issues from 
txt_file = '50_shades_of_grey.txt' #don't ask ;)
running = True

def nfc_reader():
    #copied from adafruit example
    import Adafruit_PN532 as PN532
    CS   = 18
    MOSI = 23
    MISO = 24
    SCLK = 25

    pn532 = PN532.PN532(cs=CS, sclk=SCLK, mosi=MOSI, miso=MISO)
    pn532.begin()
    ic, ver, rev, support = pn532.get_firmware_version()
    print(f'Found PN532 with firmware version: {ver}.{rev}')
    pn532.SAM_configuration()

    # Main loop to detect cards and read a block.
    print('Waiting for MiFare card...')
    while True:
        if not running: #cheap way to kill a thread nicely (cheap ain't pretty)
            return
        #don't bother specifying a timeout, they forgot to support it in the library
        uid = pn532.read_passive_target() 
        # Try again if no card is available.
        if uid is None:
            continue
        print('Found card with UID: 0x{0}'.format(binascii.hexlify(uid)))
        # Authenticate block 4 for reading with default key (0xFFFFFFFFFFFF).
        if not pn532.mifare_classic_authenticate_block(uid, 4, PN532.MIFARE_CMD_AUTH_B,
                                                       [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]):
            print('Failed to authenticate block 4!')
            continue
        # Read block 4 data.
        data = pn532.mifare_classic_read_block(4)
        if data is None:
            print('Failed to read block 4!')
            continue
        # make sure our queue is free
        with queue_lock:
            # replaced print with deque.append
            queue.append(f'Read block 4: 0x{binascii.hexlify(data[:4])}')
        #optionally emit some sort of signal that data is ready. In our case the main loop will chech periodically on it's own

# Main program
nfc_thread = threading.Thread(target=nfc_reader)
nfc_thread.start()

with open(txt_file, 'r') as f:
    while True: #also cheap, but easy
        if queue: #bool(deque) works like bool(list)
            with queue_lock:
                print("we found a card!")
                print(queue.popleft())
                continue
        try:
            print(next(f)) #otherwise go back to more interesting matters
        except StopIteration:
            running = False
            nfc_thread.join()
            break
        time.sleep(.9) #notice loop time will be less than timeout on nfc read.
                       #  you could put the printing of the *book* into another thread
                       #  and use events to immediately call your return from your 
                       #  nfc reader</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's the code I've tried based on @Aaron answer</p>
<pre><code>import binascii
import time
import threading
from collections import deque #use as a fifo queue
import RPi.GPIO as GPIO
import Adafruit_PN532 as PN532

queue = deque() #queue to pass information from thread to main process
queue_lock = threading.Lock() #prevent possible issues from 
running = True

def nfc_reader():
    CS   = 18
    MOSI = 23
    MISO = 24
    SCLK = 25

    pn532 = PN532.PN532(cs=CS, sclk=SCLK, mosi=MOSI, miso=MISO)
    pn532.begin()
    ic, ver, rev, support = pn532.get_firmware_version()
    print('Found PN532 with firmware version: {0}.{1}'.format(ver, rev))
    pn532.SAM_configuration()

    while True:
        if not running: #cheap way to kill a thread nicely (cheap ain't pretty)
            return

        uid = pn532.read_passive_target()
        if uid is None:
            continue
        #print('card read')
        message = 'Read card\n{0}'.format(binascii.hexlify(uid))

        # make sure our queue is free
        with queue_lock:
            # replaced print with deque.append
            queue.append(message)
            time.sleep(1)
        #optionally emit some sort of signal that data is ready. In our case the main loop will chech periodically on it's own

# Main program
nfc_thread = threading.Thread(target=nfc_reader)
nfc_thread.start()


while True: #also cheap, but easy
    if queue: #bool(deque) works like bool(list)
        with queue_lock:
            print("we found a card!")
            print(queue.popleft())
            continue
    time.sleep(.9) #notice loop time will be less than timeout on nfc read.
                   #  you could put the printing of the *book* into another thread
                   #  and use events to immediately call your return from your 
                   #  nfc reader
</code></pre>
</div>
<span class="comment-copy">you need to look up event loops and event driven coding style. Python 3.x's asyncio module has a basic event handler class built in. <a href="https://docs.python.org/3/library/asyncio-eventloop.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-eventloop.html</a></span>
<span class="comment-copy">Ultimately something must be blocking to wait for an event, and the event handler sends that event to the correct callback function for processing. As long as the callbacks return *immediately, there is no problem. If you need to patch together a solution from an api you can't or don't want to change. Put the blocking call inside a thread and have the thread update a value and the callback poll that value (with locks and whatever safety stuff you want)</span>
<span class="comment-copy">Interestingly, the timeout keyword in the adafruit library is ignored</span>
<span class="comment-copy">I did try your code without the 'book reading' base :) Thanks for your answer. Now I'm asking myself how to keep the program without running an infinite loop in the core..</span>
<span class="comment-copy">If your main thread quits before any of the child threads you'll have orphans. These will likely continue to run until they encounter an error (silently) or you run out of memory (not enough room at the orphanage). Ultimately something has to keep the main thread going until you're done with the extra threads. Note that while the main thread has to still be alive, that doesn't mean it has to take up any significant amount of cpu or ram... Event listeners can bring cpu down to near 0% while silently waiting</span>
<span class="comment-copy">alternately you can classify your threads as "daemons" which will be unceremoniously deleted as soon as the main thread finishes. things like file read/writes should not be done in daemon threads because file handles could be left open if the thread is terminated at the wrong time.</span>
<span class="comment-copy">@ObscurMoirage I also forgot to add something to stop everything when we get to the end of our book... I'll do that real quick</span>
<span class="comment-copy">Thanks that's really helpful ! Trying to do this with asyncio caused me headackes</span>
