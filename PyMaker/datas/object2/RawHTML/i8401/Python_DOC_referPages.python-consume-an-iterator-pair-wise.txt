<div class="post-text" itemprop="text">
<p>I am trying to understand Python's iterators in the context of the <a href="http://pysam.readthedocs.io/en/latest/api.html" rel="nofollow noreferrer">pysam module</a>. By using the <code>fetch</code> method on a so called AlignmentFile class one get a proper iterator <code>iter</code> consisting of records from the file <code>file</code>. I can the use various methods to access each record (iterable), for instance the name with <code>query_name</code>:   </p>
<pre><code>import pysam
iter = pysam.AlignmentFile(file, "rb", check_sq=False).fetch(until_eof=True)
for record in iter:
  print(record.query_name)
</code></pre>
<p>It happens that records come in pairs so that one would like something like: </p>
<pre><code>while True:
  r1 = iter.__next__() 
  r2 = iter.__next__()
  print(r1.query_name)     
  print(r2.query_name)
</code></pre>
<p>Calling <strong>next</strong>() is probably not the right way for million of records, but how can one use a for loop to consume the same iterator in pairs of iterables. I looked at the grouper recipe from <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> and the SOs <a href="https://stackoverflow.com/questions/8991506/iterate-an-iterator-by-chunks-of-n-in-python">Iterate an iterator by chunks (of n) in Python? [duplicate]</a> (even a duplicate!) and <a href="https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks">What is the most “pythonic” way to iterate over a list in chunks?</a> but cannot get it to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, don't use the variable name <code>iter</code>, because that's already the name of a builtin function.</p>
<p>To answer your question, simply use <code>itertools.izip</code> (Python 2) or <code>zip</code> (Python 3) on the iterator.</p>
<p>Your code may look as simple as</p>
<pre><code>for next_1, next_2 in zip(iterator, iterator):
    # stuff
</code></pre>
<p>edit: whoops, my original answer was the correct one all along, don't mind the itertools recipe.</p>
<p>edit 2: Consider <code>itertools.izip_longest</code> if you deal with iterators that could yield an uneven amount of objects:</p>
<pre><code>&gt;&gt;&gt; from itertools import izip_longest
&gt;&gt;&gt; iterator = (x for x in (1,2,3))
&gt;&gt;&gt; 
&gt;&gt;&gt; for next_1, next_2 in izip_longest(iterator, iterator):
...     next_1, next_2
... 
(1, 2)
(3, None)
</code></pre>
</div>
<span class="comment-copy"><i>"cannot get it to work"</i> - what precisely did you try, and what went wrong? Give a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>. Note you should generally call <code>next(thing)</code>, not <code>thing.__next__()</code>.</span>
<span class="comment-copy">Yes so I have one iterator only that I want to go through adding every second iterable into r1 and r2.</span>
<span class="comment-copy">@user3375672 there's nothing preventing you from providing the same argument twice to <code>zip</code>, i.e. <code>iterator_1 == iterator_2</code>.</span>
