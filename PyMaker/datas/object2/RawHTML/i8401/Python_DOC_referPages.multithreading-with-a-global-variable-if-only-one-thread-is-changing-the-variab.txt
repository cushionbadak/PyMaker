<div class="post-text" itemprop="text">
<p>As titled, several thread accessing one variable, and only one thread will change the variable, and all the others will just read its value. Like this:</p>
<p><strong>Thread 1</strong>:</p>
<pre><code>while True:
    a += 1
</code></pre>
<p><strong>Thread 2, 3, 4,...</strong>:</p>
<pre><code>print a
</code></pre>
<p>In this case, only Thread 1 is changing variable <code>a</code>. Will any serious problems happen?</p>
<p>I found a similar C/C++ tagged question titled "<a href="https://stackoverflow.com/questions/18016806/in-which-cases-do-i-need-to-lock-a-variable-from-simultaneous-access"><strong><em>in which cases do I need to lock a variable from simultaneous access?</em></strong></a>", and it seems from the answer, that the only thing I need to worry about is that the <code>a</code> acquired from the other thread might not be as updated.</p>
<p>I'm asking, other than that I might not get the newest a value, is it possible something more serious will happen and crush the code if I don't lock the variable while accessing it?</p>
<p>I don't think this is language related, but if it matters, I'm specifically interested in the case for Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generally speaking, how catastrophic a problem it would be would depend on what the consequences were of one of the other threads obtaining the wrong value.</p>
<p>The answer may indeed be computer-language related: See the <a href="https://en.wikipedia.org/wiki/Race_condition#Software" rel="nofollow noreferrer"><strong>Software</strong> section</a> in the general Wikipedia article on <a href="https://en.wikipedia.org/wiki/Race_condition" rel="nofollow noreferrer"><strong><em>Race condition</em></strong></a>.</p>
<p>Related to that is the fact that, thanks to the "<a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow noreferrer">GIL</a>", for the most part Python programs don't do real multithreading since the interpreter isn't thread-safe.</p>
</div>
<div class="post-text" itemprop="text">
<p>Irrespective of the language, updating a variable by two separate threads will affect the value.  But printing the values will not.  The only issue is all the threads (2 onwards) will print different values.</p>
<p>Think this is happening in a database.  One person can update the dB, but many can read it.  </p>
</div>
<span class="comment-copy">As long as no race conditions can occur for the specific variable, then there shouldn't be a need to lock it.</span>
<span class="comment-copy">No problems. Each thread will get the newest value at the point in time where they read it.</span>
<span class="comment-copy">@JacobG. Integers are immutable in Python. The statement <code>a+=1</code> creates a new integer and changes <code>a</code> to refer to it.</span>
<span class="comment-copy">...except... classes implement <code>+=</code> with the <code>__iadd__</code> method. For integers you are safe. But mutable containers may act oddly. Suppose this was a list and you are extending it. Another thread iterating it may have problems. For instance, <code>len(somelist)</code> followed by <code>for i in somelist</code> may iterate more items.</span>
<span class="comment-copy">@tdelaney. No, the threads may not necessarily get the "newest value" at the time they read it. Different caches may have different versions of the value. All that can be guaranteed is that the thread won't get an older version of the variable than the version that it had read previously. So if thread 1 set <code>a</code> to 1, then 2, then 3, 4, 5, and thread 2 read the value 2 from <code>a</code>, then the next time thread 2 reads a value, it will be either 2,3,4, or 5, but not 1. And then there's another problem--if <code>a</code> isn't altered atomically, thread 2 can read a weird value if it reads while thread 1 writes.</span>
<span class="comment-copy">Does this mean that since python has a GIL, so it's safe in python to operate in this way because it will lock the variable in default anyway?</span>
<span class="comment-copy">@beedrill: In your trivial example code, yes. Updating a more complex type might not however, because the GIL might be released and reacquired during the update process. Note that creating and using a <code>threading.Lock</code> to prevent concurrent access problems is super easy in Python: i.e.: a <code>with my_lock:</code> will acquire the lock before and release it after the following suite of statements execute.</span>
<span class="comment-copy">This is not true. For example, imagine if <code>a+=1</code> is implemented as follows: 1) Store the value of <code>a</code>. 2) Destroy the <code>a</code> object. 3) Create a new integer object with the value we stored plus 1. 4) Make <code>a</code> refer to that new object. -- Now, what happens if another thread tries to access the value of <code>a</code> after step 1 but before step 4?</span>
<span class="comment-copy">This is not the way in which the languages are implemented.  a+= 1, will work as follows: The value of a is copied to the register of the processor.  It will be incremented by 1 and a will be updated.  a is residing in the main memory of the computer.  The increment is happening at the register level.  The register value will be written back to the memory location of a. When another thread is accessing the value of a between these 3 steps, it will get the old value of a.  No other reading threads can CHANGE the value of a. In no way a will be "destroyed" as claimed by you</span>
<span class="comment-copy">Do you mean some languages happen to be implemented that way? Or do you mean all languages are guaranteed to be implemented that way? If the former, isn't is crazy to rely on that? If the latter, where can I find such a marvelous, broad guarantee documented? (And how do you know all computers for all time will even have registers? Or are you suggesting that it's okay to write code that might fail when a person upgrades their CPU?)</span>
<span class="comment-copy">I think the question is about normal computer usage.  If a person is using a normal computer which has an intel processor, a+=1 is implemented as I said.  Please refer to any "Computer Organization" course material.   From wikipedia "Almost all computers, whether load/store architecture or not, load data from a larger memory into registers where it is used for arithmetic operations and is manipulated or tested by machine instructions. Manipulated data is then often stored back to main memory, either by the same instruction or by a subsequent one. "</span>
<span class="comment-copy">No, absolutely not! The question is about python, a language that has a specification that allows you to write code that will work correctly no matter what CPU, operating system, or library it happens to run on.</span>
