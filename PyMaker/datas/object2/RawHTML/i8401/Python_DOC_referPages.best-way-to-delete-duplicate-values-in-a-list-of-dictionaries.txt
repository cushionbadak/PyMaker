<div class="post-text" itemprop="text">
<p>I have a list of dictionaries, and those dictionaries have another nested dictionary. Here is an example:</p>
<pre><code>reports = [
            {'00T2A00003mDvq9': {'subject': 'dupe1', 'due_date': '4/5/2017'}}
            {'00T2A00003mDvq8': {'subject': 'dupe2', 'due_date': '4/7/2017'}}
            {'00T2A00003mDvq7': {'subject': 'dupe1', 'due_date': '4/3/2017'}}
          ]
</code></pre>
<p>So each dict in the list has a unique id and values associated with it.</p>
<p>I need a way to iterate through these dictionaries and if any of them have an exact match in the <code>'subject'</code> field then I want to delete/remove the entire dict with the <strong>latest</strong> date.</p>
<p>So, using the example above, after iterating through the list and de-duping, I need the result to look like this.</p>
<pre><code>reports = [
            {'00T2A00003mDvq8': {'subject': 'dupe2', 'due_date': '4/7/2017'}}
            {'00T2A00003mDvq9': {'subject': 'dupe1', 'due_date': '4/3/2017'}}
          ]
</code></pre>
<p>It deletes the first instance of <code>'dupe1'</code> because it is the later date.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is made more difficult because you don't know the key values (unique ids) of the dictionaries in <code>reports</code>. Since each one consists of only one item, you can use <code>next(iter(dict.values()))</code> with Python 3 to get the single nested dictionary associated with it—which I called <code>checkout</code> in the code below to give it a name.</p>
<p>Given that, the approach I would use would be to first create a dictionary that groups the elements in <code>reports</code> by subject—which then gives you something like this to work with (<strong>note:</strong> I changed the sample <code>reports</code> data so the first has more than one with a duplicate <code>'subject'</code>):</p>
<pre class="lang-none prettyprint-override"><code>{
    'dupe1': [
        {'00T2A00003mDvq9': {'due_date': '4/5/2017', 'subject': 'dupe1'}},
        {'00T2A00003mDvq7': {'due_date': '4/3/2017', 'subject': 'dupe1'}},
        {'00T2A00003mDvq6': {'due_date': '4/6/2017', 'subject': 'dupe1'}}
    ],
    'dupe2': [
        {'00T2A00003mDvq8': {'due_date': '4/7/2017', 'subject': 'dupe2'}}
    ]
}
</code></pre>
<p>The lists of reports associated with each subject can then be sorted by date (using a <code>lambda</code> based on the same <code>next(iter(dict.values()))</code> trick), and given the now ordered contents of that, it's easy to update the list and remove any duplicates in accordance to your desires.</p>
<pre><code>from time import strptime
from pprint import pprint

DATE_FMT = '%m/%d/%Y'
reports = [
    {'00T2A00003mDvq9': {'subject': 'dupe1', 'due_date': '4/5/2017'}},
    {'00T2A00003mDvq8': {'subject': 'dupe2', 'due_date': '4/7/2017'}},
    {'00T2A00003mDvq7': {'subject': 'dupe1', 'due_date': '4/3/2017'}},
    {'00T2A00003mDvq6': {'subject': 'dupe1', 'due_date': '4/6/2017'}},  # + a third duplicate
]

by_subject = {}
for report in reports:
    checkout = next(iter(report.values()))  # get single subdictionary in each dictionary
    by_subject.setdefault(checkout['subject'], []).append(report)

for records in by_subject.values():
    records.sort(key=lambda rpt: strptime(next(iter(rpt.values()))['due_date'], DATE_FMT))

# Update reports list in-place.
del reports[:]
for subject, records in by_subject.items():
    reports.append(records[0])  # only keep oldest (deletes all newer than first)

print('Deduped reports:')
pprint(reports)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Deduped reports:
[{'00T2A00003mDvq7': {'due_date': '4/3/2017', 'subject': 'dupe1'}},
 {'00T2A00003mDvq8': {'due_date': '4/7/2017', 'subject': 'dupe2'}}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you're completely stuck, here's a start. One problem is that for each <code>dict</code>, the key is different and unknown. It looks like there's only one pair in each dict, so you can get <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer"><code>items()</code></a> and take the first one:</p>
<pre><code>reports = [ 
    {'00T2A00003mDvq9': {'subject': 'dupe1', 'due_date': '4/5/2017'}},
    {'00T2A00003mDvq8': {'subject': 'dupe2', 'due_date': '4/7/2017'}},
    {'00T2A00003mDvq7': {'subject': 'dupe1', 'due_date': '4/3/2017'}}
]

def get_subject(some_dict):
    return list(some_dict.items())[0][1]['subject']

reports.sort(key=get_subject)
print(reports)
# [{'00T2A00003mDvq9': {'due_date': '4/5/2017', 'subject': 'dupe1'}}, {'00T2A00003mDvq7': {'due_date': '4/3/2017', 'subject': 'dupe1'}}, {'00T2A00003mDvq8': {'due_date': '4/7/2017', 'subject': 'dupe2'}}]
</code></pre>
<p><code>reports</code> is now sorted by subject. You can then use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> to get reports grouped by subject.</p>
<p>For each group, you can use <code>sort</code> again, this time with <code>due_date</code>. You'll have to take care though, you cannot sort dates alphabetically, you'll need to extract <code>year,month,day</code> in this order or convert the string to a <code>datetime</code> object with <a href="https://docs.python.org/2/library/datetime.html#datetime.datetime.strptime" rel="nofollow noreferrer"><code>strptime</code></a>.</p>
<p>Once your results are grouped by <code>subject</code> and sorted by <code>due_date</code>, just get the first element of each group. Done!</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the final solution that I went with. Based off @martineau's answer, but I'm guessing its only because im using Python3.     </p>
<pre><code>from time import strptime

DATE_FMT = '%m/%d/%Y'
reports = [
    {'00T2A00003mDvq9': {'subject': 'dupe1', 'due_date': '4/5/2017'}},
    {'00T2A00003mDvq8': {'subject': 'dupe2', 'due_date': '4/7/2017'}},
    {'00T2A00003mDvq7': {'subject': 'dupe1', 'due_date': '4/3/2017'}},
    {'00T2A00003mDvq6': {'subject': 'dupe1', 'due_date': '4/6/2017'}},  # + third duplicate
]

DATE_FMT = '%m/%d/%Y'

    by_subject = {}
    for report in reports:
        topic = list(report.values())[0]
        # assuming only one element in each dictionary
        by_subject.setdefault(topic['subject'], []).append(report)

    for records in by_subject.values():
        records.sort(key=lambda rec: strptime(list(rec.values())[0]['due_date'], DATE_FMT))

    reports = []

    for subject, records in by_subject.items():

        if len(records) &gt; 1:
            while len(records) != 1:
                del records[-1]
        reports.extend(records)
</code></pre>
</div>
<span class="comment-copy">What have you tried and what precisely is the problem with it?</span>
<span class="comment-copy">I've seen a couple examples that iterate though a list of dictionaries, but none with nested dictionaries like I have above.</span>
<span class="comment-copy">That's not what I asked; SO isn't a code-writing service, you're expected to put some effort into an actual implementation yourself. Additionally, please don't revert legitimate edits; ask <b>one question</b> at a time (preferably after reading <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a>).</span>
<span class="comment-copy">If I knew the solution or knew how to go about it I wouldn't be posting here. From SO about us page: "With your help, we're working together to build a library of detailed answers to every question about programming.". I'm not looking for a code-writing service. I'm looking for an answer to my question. And I threw the bonus question in here because I'm guessing if it was sorted, it would be easier to do what I'm looking for</span>
<span class="comment-copy">Could you show me somewhere that has an answer related to the question above?</span>
<span class="comment-copy">This almost works and is going in the right direction. One problem is I can have many duplicates, this one only deletes 1. Also, I don't need to keep the de-duped reports. Looking to keep the original list minus the duplicates.</span>
<span class="comment-copy">Your question says "I want to delete/remove <b>the</b> entire dict with the latest date" (emphasis mine) which seems to indicate deleting only one. Regardless, I've updated my answer according (I think) based on your feedback.</span>
<span class="comment-copy">I posted my final solution. I think your's didn't fully work because I'm using python3, but it's almost exactly your answer. Thank you!</span>
<span class="comment-copy">Yep, missed the Python 3 tag, sorry. Trivial to fix, though (see updated answer)...and you're welcome.</span>
<span class="comment-copy">Also it would be a good idea to use datetime for date sorting, instead of reimplementing the wheel. <a href="http://stackoverflow.com/questions/466345/converting-string-into-datetime">You can write datetimes to strings and parse them again to datetime objects if necessary.</a>.</span>
