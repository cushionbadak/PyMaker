<div class="post-text" itemprop="text">
<p>I have a csv file (see [1] below) that has non ascii text in it (for instance a name like <code>Antonio Melé</code>. The file has a list of books with URLs, excerpts and comments.</p>
<p>In Python 3.5 I open and process the file like so:</p>
<pre><code># -*- coding: utf-8 -*-
import codecs
import csv 
import pdb


def select_book_matching_keyword(books, kw):
    """
    Will select the csv rows for which any column has matching keyword in it

    Snippet from csv file:
    `Django By Example,Antonio Melé,Using class-based ...`

        `Antonio Melé`  
           becomes  
        `b'Antonio Mel\xc3\xa9'`
    """
    selected_books = []
    for book in books:
        kw_in_any_column = [column for column in book if kw in column.decode()]
        # &gt;&gt; Without the `column.decode()` above I cannot
        #    run this list comprehension (that is if I 
        #    write `if kw in column` instead of `if kw in column.decode()
        if kw_in_any_column:
            # print(book)
            selected_books.append(book) 
    return selected_books


if __name__=='__main__':
    f = codecs.open('safari-annotations-export-3.csv', 'r', 'utf-8')
    reader = csv.reader(f)
    books = []

    for row in reader:
        book_utf8 = [column.encode("utf-8") for column in row]
        books.append(book_utf8)
        print(book_utf8)

pdb.set_trace()
</code></pre>
<p>Now printing the rows of the csv (see <code>print(book_utf8)</code> above) will give me results like:</p>
<p><code>[b'Django By Example', b'Antonio Mel\xc3\xa9', b'Using class-based views', b'2017-03-08', b'https://www.safaribooksonline.com/library/view/django-by-example/9781784391911/', b'https://www.safaribooksonline.com/library/view/django-by-example/9781784391911/ch01s09.html', b'https://www.safaribooksonline.com/a/django-by-example/5869158/', b'Using class-based views', b'']</code></p>
<p>First off, I have a byte prefix. Why? (Python 3.x treats strings as unicode by default, Python 2.7 treats it as byte by default.)</p>
<p>And then I have this: <code>b'Antonio Mel\xc3\xa9'</code> instead of <code>Antonio Melé</code>.</p>
<p>I know that I have not fully grasped the concept of encoding in Python. Read many posts here on SO, but still I don't really get it.</p>
<ul>
<li>So if my csv file has special characters, I need to open it as <code>utf-8</code>? I did that.</li>
<li>Then, if I iterate over the csv reader, get all the rows and append them to a list (without encoding the columns), then try to print it, I get an error (see [2] below). Why can't I print that list?</li>
</ul>
<hr/>
<p>[1] <a href="https://www.dropbox.com/s/ya93q7wcjmfxgse/safari-annotations-export-3.csv?dl=0" rel="nofollow noreferrer">csv file with utf-8 text</a></p>
<p>[2] Trying to print a list of rows of the csv file without encoding the colums of the row will give me an error:</p>
<p><code>(snip)
['Learning jQuery Deferreds', 'Terry Jones...', '2. The jQuery Deferred API', '2017-04-06', 'https://www.safaribooksonline.com/library/view/learning-jquery-deferreds/9781449369385/', 'https://www.safaribooksonline.com/library/view/learning-jquery-deferreds/9781449369385/ch02.html', 'https://www.safaribooksonline.com/a/learning-jquery-deferreds/6635517/', 'More Terminology: Resolve, Reject and Progress', '']
*** UnicodeEncodeError: 'ascii' codec can't encode character '\u2019' in position 368: ordinal not in range(128)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Typically, all encoding/decoding is done when communicating with the outer world. In your example, there are two communication steps:</p>
<ul>
<li>you read from a file opened with <code>codecs.open()</code>,</li>
<li>you write out the result using the <code>print()</code> built-in.</li>
</ul>
<p>Between this, you should always work with decoded strings, ie. type <code>str</code> (Python 2's <code>unicode</code>).</p>
<h2>Reading from an on-disk file</h2>
<p>The first point goes well, initially: You open the file with the correct encoding and let <code>csv</code> do the format parsing.
This makes sure that the bytes found on the disk are correctly decoded into strings, without you having to use a <code>decode</code> method.
(As a side note, you can omit <code>codecs</code> here and just use the built-in <code>open(filename, 'r', encoding='utf-8')</code>, but it effectively does the same thing.)</p>
<p>But then, you re-encode the strings with the following line:</p>
<pre><code>book_utf8 = [column.encode("utf-8") for column in row]
</code></pre>
<p>You shouldn't do this. Now you have to process <code>bytes</code> instead of strings.
Note:</p>
<pre><code>&gt;&gt;&gt; 'Antonio Melé'.encode('utf-8')
b'Antonio Mel\xc3\xa9'
</code></pre>
<p>The <code>bytes</code> type has common features with strings, but they are incompatible.
That's why you have to <code>decode</code> each element in the <code>select_book_matching_keyword</code> function (which is not used in your code snippet, btw.), so that the membership test is done between strings and strings, not strings and bytes.</p>
<p>One of the differences between the two types is that <code>print()</code> uses the <code>repr</code> form to display <code>bytes</code>, thus the output will include quotes and the <code>b</code> prefix:</p>
<pre><code>&gt;&gt;&gt; print(b'Antonio Mel\xc3\xa9')
b'Antonio Mel\xc3\xa9'
</code></pre>
<p>Compare to printing strings:</p>
<pre><code>&gt;&gt;&gt; print('Antonio Melé')
Antonio Melé
</code></pre>
<h2>Writing text or data to STDOUT</h2>
<p>This brings us to the next problem: Writing data to STDOUT using <code>print()</code>.
If you try the above line, you probably get an exception:</p>
<pre><code>&gt;&gt;&gt; print('Antonio Melé')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 11: ordinal not in range(128)
</code></pre>
<p>The problem is that, apparently, <code>'ascii'</code> encoding is used.
Now, how do you specify the encoding?
It's clear when using <code>open</code> to write to a file on disk:</p>
<pre><code>f = open(filename, 'w', encoding='utf8')
f.write('Antonio Melé')
f.close()
</code></pre>
<p>But you can't tell <code>print</code> what encoding to use.
The reason for that is that it uses a file handle that is already open, ie. <code>sys.stdout</code>. In my case, this is:</p>
<pre><code>&gt;&gt;&gt; sys.stdout
&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;
</code></pre>
<p>but you probably see <code>encoding='ascii'</code> or something like <code>'ANSI_X3.4-1968'</code>.</p>
<p>You have two possibilities:</p>
<ul>
<li>You write the output to a disk file, and don't use <code>print</code> at all.</li>
<li>You change the encoding of <code>sys.stdout</code>.<br/>
(More precisely, you replace it with a new TextIOWrapper around the underlying bytes-based STDOUT stream.)</li>
</ul>
<p>The first possibility is obvious, I hope.
For the second one, you need one additional line of code (provided that <code>sys</code> is imported):</p>
<pre><code>sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer)
</code></pre>
<p>Now <code>print</code> will encode strings with UTF-8.</p>
<p>However, you might still have trouble:
It's quite likely that your terminal isn't configured to accept and properly display UTF-8 text, or that it doesn't even support Unicode.
If that is the case, you either get garbled characters on screen, or maybe another exception.
But that problem is outside Python, you'll have to fix it through the terminal config, or by switching to a different one.</p>
</div>
<span class="comment-copy">(1) you get bytes in the list because you <code>encode()</code> each column. Don't do that. (2) If you don't encode, you're getting a UnicodeEncodeError because, presumably, your environment (locale etc.) is set to ASCII, or maybe because your terminal can't handle Unicode. Try writing into an open file rather than using <code>print()</code>.</span>
<span class="comment-copy">Man, absolutely fantastic answer! Thanks a million times! Going through your examples I realize that my terminal emulator iTerm2 on my mac has a problem printing unicode characters (even though the settings are correctly set to utf-8). That's why I can't even type a German Umlaut into my terminal, neither into my Python REPL. - <code>sys.stdout</code> returns the same output as yours btw. - I think the terminal issue overlapped with my poor understanding of encoding. That's why I could not debug and understand the details. - Again, thanks a lot! - Do you have any recommended reading about this topic?</span>
<span class="comment-copy">This is why I absolutely love StackOverflow! And the Python community!</span>
<span class="comment-copy">I'm glad it helped. I have to admit, though, I don't really know a comprehensive, easy-to-read introduction on encodings. <a href="https://docs.python.org/3/library/codecs.html#encodings-and-unicode" rel="nofollow noreferrer">This section in the codecs doc</a> gives some details about the mapping bytes–strings. <a href="http://www.unicode.org/notes/tn23/" rel="nofollow noreferrer">This tutorial</a> hosted at Unicode covers a wide range of Unicode-related topics, but it's actually a slide show with text meant for lecturers.</span>
