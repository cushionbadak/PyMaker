<div class="post-text" itemprop="text">
<p>Is there any ultimate difference between the following two code snippets? The first assigns a value to a variable in a function and then returns that variable. The second function just returns the value directly.</p>
<p>Does Python turn them into equivalentÂ bytecode? Is one of them faster?</p>
<p><strong>Case 1</strong>:</p>
<pre><code>def func():
    a = 42
    return a
</code></pre>
<p><strong>Case 2</strong>:</p>
<pre><code>def func():
    return 42
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, <em>it doesn't</em>.</p>
<p>The compilation to CPython byte code is only passed through a small <a href="https://github.com/python/cpython/blob/master/Python/peephole.c" rel="noreferrer">peephole optimizer</a> that is designed to do only basic optimizations (See <a href="https://github.com/python/cpython/blob/master/Lib/test/test_peepholer.py" rel="noreferrer">test_peepholer.py</a> in the test suite for more on these optimizations).</p>
<p>To take a look at what's actually going to happen, use <code>dis</code>* to see the instructions generated. For the first function, containing the assignment:</p>
<pre><code>from dis import dis
dis(func)
  2           0 LOAD_CONST               1 (42)
              2 STORE_FAST               0 (a)

  3           4 LOAD_FAST                0 (a)
              6 RETURN_VALUE
</code></pre>
<p>While, for the second function:</p>
<pre><code>dis(func2)
  2           0 LOAD_CONST               1 (42)
              2 RETURN_VALUE
</code></pre>
<p>Two more (fast) instructions are used in the first: <a href="https://docs.python.org/3/library/dis.html#opcode-STORE_FAST" rel="noreferrer"><code>STORE_FAST</code></a> and <a href="https://docs.python.org/3/library/dis.html#opcode-LOAD_FAST" rel="noreferrer"><code>LOAD_FAST</code></a>. These make a quick store and grab of the value in the <code>fastlocals</code> array of the current execution frame. Then, in both cases, a <code>RETURN_VALUE</code> is performed. So, the second is ever so <em>slightly</em> faster due to less commands needed to execute.</p>
<p>In general, be aware that the CPython compiler is <em>conservative</em> in the optimizations it performs. It isn't and <em>doesn't try to be</em> as smart as other compilers (which, in general, also have much more information to work with). The main design goal, apart from obviously being correct, is to a) keep it simple and b) be as swift as possible in compiling these so you don't even notice that a compilation phase exists.</p>
<p>In the end, you shouldn't trouble yourself with small issues like this one. The benefit in speed is tiny, constant and, dwarfed by the overhead introduced by the fact that Python is interpreted. </p>
<p><sub>*<a href="https://docs.python.org/3/library/dis.html" rel="noreferrer"><code>dis</code></a> is a little Python module that dis-assembles your code, you can use it to see the Python bytecode that the VM will execute.</sub> </p>
<p><strong>Note:</strong> As also stated in a comment by @Jorn Vernee, this is specific to the CPython implementation of Python. Other implementations might do more aggressive optimizations if they so desire, CPython doesn't.</p>
</div>
<div class="post-text" itemprop="text">
<p>Both are basically the same except that in the first case the object <code>42</code> is simply aassigned to a variable named <code>a</code> or, in other words, names (i.e. <code>a</code>) refer to values (i.e. <code>42</code>) . It doesn't do any assignment technically, in the sense that it never copies any data.</p>
<p>While <code>return</code>ing, this named binding <code>a</code> is returned in the first case while the object <code>42</code> is return in the second case.</p>
<p>For more reading, refer <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">this great article by Ned Batchelder</a></p>
</div>
<span class="comment-copy">If you use <code>dis.dis(..)</code> on both you see that <b>there is a difference</b>, so yes. But in most <i>real world</i> applications the overhead of this compared to the delay of the processing in the function is not that much.</span>
<span class="comment-copy">There are two possibilities: (a) You are going to call this function many (i.e. at least a million) times in a tight loop. In that case you shouldn't be calling a Python function at all, but instead should vectorize your loop using something like the numpy library. (b) You are not going to call this function that many times. In that case the difference in speed between these function is too little to be worth worrying about.</span>
<span class="comment-copy"><a href="https://meta.stackoverflow.com/questions/347869/do-we-encourage-nonsense-questions">This question is being discussed on meta.</a></span>
<span class="comment-copy">Not a python person (c++) so I do not know how it works under the hood but shouldn't the first case get optimized to the second case?  A decent C++ compiler would make that optimization.</span>
<span class="comment-copy">@NathanOliver it really doesn't, Python will do as told here without even attempting to play it smart.</span>
<span class="comment-copy">The fact that @NathanOliver's <i>perfectly reasonable and intelligent</i> guess at an answer to this question is completely wrong is, to my eyes, proof that this isn't a "self-explanatory", "nonsense", "stupid" question that can be answered by "taking a moment to think", as TigerhawkT3 would have us believe. It's a valid, interesting question that I wasn't certain of the answer to despite having been a professional Python programmer for years.</span>
<span class="comment-copy">Python's compiler is at best 'conservative', not 'very conservative'. The main design goal is not to be "as swift as possible ... so you don't even notice that a compilation phase exists." That is secondary, after "keep it simple". A function with large constants like "1&lt;&lt;(2**34)" and "b'x'*(2**32)" take several seconds to compile, and generate GB-sized constants, even if the function is never run. The large string will even be discarded by the compiler. Proposed fixes for these cases have been rejected as they would make the compiler too complex.</span>
<span class="comment-copy">@AndrewDalke thanks for the insiders comment on this, I tweaked the wording to address the issues you pointed out.</span>
