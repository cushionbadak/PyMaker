<div class="post-text" itemprop="text">
<p>I am trying to implement a python code where I need to run an external executable file. After some research I found <code>subprocess</code> module and tried it. However, when I run the code, the subprocess exits and returns a <code>CompletedProcess</code> object, which is not okay for me because the .exe I am working with is actually a <strong>continuous</strong> program where it takes input and generates output until it is closed. (My program will be sending its inputs and recieving the outputs.)</p>
<p>So this code fails.</p>
<pre><code>import subprocess

proc = subprocess.run("some.exe", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
print(proc) # To see what it is.
</code></pre>
<p>It captures the programs first output in stdout but then quits, rather than expecting new input.</p>
<p>I am also having a problem with the terminology here, this executable I am using is capable of running commands while still being able to recieve new commands, is this called <strong>asynchronous</strong> or <strong>Non-blocking</strong> ?</p>
<p><strong>To my question</strong>, what is the correct way of handling this ? There are a lot of questions in SO close to this but I could not be sure which were answering my problem or answering it in a modern way (There are very old questions).</p>
<p>It would appear <code>subprocess</code> module undergone some changes with Python 3.6.1 <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">https://docs.python.org/3/library/subprocess.html</a></p>
<p>So it would be best if you could provide the solution in the newest way, or at least mention the newer way and how it operates.</p>
<p>I am working on Windows 10, Python 3.6.1</p>
<p><strong>Edit1:</strong> I have come across <code>subprocess.Popen</code>, which may be what I need, but I am yet to discover how it is properly used.</p>
<p><strong>Edit2:</strong> The module <code>pexpect</code> seems to be designed for these kind of problems, but I am not sure if using this going to make my time much easier. Any suggestions appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the docs:</p>
<blockquote>
<p>subprocess.run()</p>
<p>Run the command described by args. Wait for command to complete, then return a CompletedProcess instance.</p>
</blockquote>
<p>Since your subprocess doesn't end after initially calling it, you cannot use <code>run</code> but need to use <code>Popen</code> instead.</p>
<p>You could use something like this:</p>
<pre><code>import subprocess
p = subprocess.Popen(exe_path,
                     stdin=subprocess.PIPE, 
                     stdout=subprocess.PIPE,
                     stderr=subprocess.STDOUT)
while p.poll() is None:
    p.stdin.write(some_command)
    p.stdin.flush()
    out = p.stdout.readline()
</code></pre>
<p>But note that this can lead to a deadlock as described in the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.stderr" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p><strong>Warning</strong> Use communicate() rather than .stdin.write, .stdout.read or .stderr.read to avoid deadlocks due to any of the other OS pipe buffers filling up and blocking the child process.</p>
</blockquote>
<p>Unfortunately you cannot use <code>communicate</code> because this would require you to call the process with all input. I'd give it a try with the version above and see if the buffers really cause problems in your application.</p>
</div>
<span class="comment-copy">Can these "inputs" simply be written into the command for the subprocess call?</span>
<span class="comment-copy">@JacobIRR, Yes, forgive me for not mentioning, this is a console application and recieves inputs from stdin directly. I can directly run it and test the inputs, which I need my Python application to do instead of me.</span>
<span class="comment-copy">But the inputs are not pre-determined, I can't give all the inputs when I call the program in the beginning.</span>
<span class="comment-copy">Thanks for the answer, I also came across this just before you posted the answer, seems like the only easy solution to my problem. I just need to wrap up these in some function. However I would appreciate more knowledge about this deadlock situation and how to avoid it.</span>
<span class="comment-copy">see <a href="http://stackoverflow.com/questions/2381751/can-someone-explain-pipe-buffer-deadlock">here</a> for an explanation of the deadlock problem. The solution proposed <a href="http://stackoverflow.com/questions/375427/non-blocking-read-on-a-subprocess-pipe-in-python">here</a> might help avoiding deadlocks by using a separate thread that reads data from the buffer to prevent fill-up.</span>
