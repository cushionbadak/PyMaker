<div class="post-text" itemprop="text">
<p>I'm trying to make a dive table that has some numbers that aren't in a pattern that I can see so I have to manually add all the values, but I need to grab the input and round it to the nearest number in the dictionary.</p>
<p>I'll need to convert the input back to string for the output to be correct:</p>
<p>CODE:</p>
<pre><code>class DepthTable:

    def __init__(self):
        self.d35 = {"10": "A",
                    "19": "B",
                    "25": "C",
                    "29": "D",
                    "32": "E",
                    "36": "F",
                   }



    def getpressureGroup(self, depth, time):

        if depth == "35":
            output = self.d35[time]
        else:
            output = "No info for that depth"
        print(output)


if __name__ == "__main__":
    depthtable = DepthTable()
    print("Please enter Depth (Use numbers!)")
    depth = input()
    print("Please Enter time!")
    time = input()
    depthtable.getpressureGroup(depth,time)
</code></pre>
<p>So when the "player" inputs the number 15 for time, I need to round it UP to 19 (Always up even if it's 13 or something like that.) I don't see how I can do this with round() or I might have to make a function that checks EVERY number..</p>
</div>
<div class="post-text" itemprop="text">
<p>Using your idea of a "function that checks EVERY number", an instance variable <code>keys</code> can be used to get the key if it exists, or the next highest key:</p>
<pre><code>class DepthTable:

    def __init__(self):
        self.d35 = {10: "A",
                    19: "B",
                    25: "C",
                    29: "D",
                    32: "E",
                    36: "F",
                   }

        self.keys = self.d35.keys()


    def getpressureGroup(self, depth, time):
        if depth == 35:
            rtime = min([x for x in self.keys if x &gt;= time]) # if exists get key, else get next largest
            output = self.d35[rtime]
        else:
            output = "No info for that depth"
        print(output)


if __name__ == "__main__":
    depthtable = DepthTable()
    print("Please enter Depth (Use numbers!)")
    depth = int(input())
    print("Please Enter time!")
    time = int(input())
    depthtable.getpressureGroup(depth,time)
</code></pre>
<p>Demo:</p>
<pre><code>Please enter Depth (Use numbers!)
35
Please Enter time!
13
B
</code></pre>
<hr/>
<pre><code>Please enter Depth (Use numbers!)
35
Please Enter time!
19
B
</code></pre>
<hr/>
<pre><code>Please enter Depth (Use numbers!)
35
Please Enter time!
10
A
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Convert the <code>d35</code> dictionary to a sorted list and step through it:</p>
<pre><code>In [4]: d35 = {"10": "A",
   ...:                     "19": "B",
   ...:                     "25": "C",
   ...:                     "29": "D",
   ...:                     "32": "E",
   ...:                     "36": "F",
   ...:                    }

In [5]: sorted(d35.items())
Out[5]: [('10', 'A'), ('19', 'B'), ('25', 'C'), ('29', 'D'), ('32', 'E'), ('36', 'F')]

In [7]: time = 15

In [11]: for max_time, group_name in sorted(d35.items()):
    ...:     if int(max_time) &gt;= time:
    ...:         break
    ...:

In [12]: max_time
Out[12]: '19'

In [13]: group_name
Out[13]: 'B'
</code></pre>
<p>Modifying your method gives this. I added an else to the for loop to handle times not covered by any group.</p>
<pre><code>def getpressureGroup(self, depth, time):

    if depth == "35":
        for max_time, group_name in sorted(self.d35.items()):
            if int(max_time) &gt;= time:
                output = group_name
                break
        else:
            output = "No info for that depth"
    else:
        output = "No info for that depth"
    print(output)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try using <code>cut</code> from the <code>pandas</code> module.</p>
<p>More or less, it is made to separate continuous variables into discrete categories, like depths into pressure groups.</p>
<p>You need to specify an array of bins to cut your data into, which you can then label.</p>
<p>So, as an example:</p>
<pre><code>import pandas as pd
import numpy as np

timestocut = [0, 4, 8, 12, 16, 20, 24, 28, 32, 36]
pd.cut(timestocut, bins = np.array([-1,10,19,25,29,32, np.inf]), labels = np.array(['A','B','C','D','E','F']), right = True)
</code></pre>
<p>giving:</p>
<pre><code>[A, A, A, B, B, C, C, D, E, F]
Categories (6, object): [A &lt; B &lt; C &lt; D &lt; E &lt; F]
</code></pre>
<p>You can see the bins has -1, so we include 0, and <code>np.inf</code> to catch anything up to infinite.</p>
<p>Integrating this into your code is up to you - personally I would remove the dict and use this mapping.</p>
</div>
<div class="post-text" itemprop="text">
<p>For large lists use standard bisect module or any other dichotomy package.
Check the friendly python docs for excact instructions how to solve your task with bisect</p>
<p><a href="https://docs.python.org/2/library/bisect.html#other-examples" rel="nofollow noreferrer">https://docs.python.org/2/library/bisect.html#other-examples</a></p>
<p>If you have numpy, try digitize, seems easier than pandas cut</p>
<p><a href="https://stackoverflow.com/questions/14947909/python-checking-to-which-bin-a-value-belongs/14947961">Python: Checking to which bin a value belongs</a></p>
<p>Yet for such short list, I would just use simple branching </p>
<pre><code>if 1&lt;x&lt;=18:
    ...
elif 18&lt;x&lt;=28:
    ...
elif
</code></pre>
<p>Or, for greater speed build case by case array or a dictionary 
{ "1":"19", "2":"19" ... "20": "25" ...} programmatically,</p>
<p>Say with an activestate dictionary inversion snippet</p>
<p><a href="http://code.activestate.com/recipes/415100-invert-a-dictionary-where-values-are-lists-one-lin/" rel="nofollow noreferrer">http://code.activestate.com/recipes/415100-invert-a-dictionary-where-values-are-lists-one-lin/</a></p>
<pre><code>def invert(d):
   return dict( (v,k) for k in d for v in d[k] ) 

d35 = {"10": "A",
                    "19": "B",
                    "25": "C",
                    "29": "D",
                    "32": "E",
                    "36": "F",
                   }

dlist = d35.keys().sort()
d1 = {}
low = -1
for n in dlist[1:]:
    up = int(n) + 1

    interval = range(low, up)
    low = up
    d1[ dlist[i] ] = map(str, interval)


 result = invert(d1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> and <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html" rel="nofollow noreferrer"><code>pandas.cut</code></a> (as mentioned in other answers) will work, you could do it with just vanilla Python (no imported modules) by looping through the cutoff values. (This is the approach in <a href="https://stackoverflow.com/a/43399898/95852">@Harvey's answer</a>, just presented as a program rather than an interactive session.)</p>
<pre><code>d35 = {
    10: "A",
    19: "B",
    25: "C",
    29: "D",
    32: "E",
    36: "F",
}

def pressure_group(time):
    for cutoff in sorted(d35.items()):
        if cutoff[0] &gt;= time:
            return cutoff[1]
    return None  # or pick something else for "too high!"
</code></pre>
<p>This is a little more verbose than using the modules mentioned, but perhaps easier to follow and understand what's going on, because you're doing it all yourself (which I think is often a good idea, especially if you are trying to learn programming).</p>
<p>Each time through the loop, <code>cutoff</code> is a pair from the <code>d35</code> dictionary. Since the pairs are sorted from lowest to highest, you can just stop at the first one which is greater or equal to the input. If the loop finishes (because the input is higher than the highest cutoff), I chose to return <code>None</code>, but you could return some other value, or raise an exception.</p>
</div>
<span class="comment-copy">why not under the if loop and under the variable output, use an if to check if the number is greater than some number and less than some other number so the case for fifteen would be greater than 10 or less than 19 if those conditions are met change time to equal 19? Does that make sense?</span>
<span class="comment-copy">Well I mean that would make it a large code for this kind of stuff, the actual dive table has A-Z each with 20 time stamps..</span>
<span class="comment-copy">So the problem is that you need to drive each number up to the smallest value at least as large as that number?</span>
<span class="comment-copy">I don't understand you very well, but I basically need to have a safeguard, since it's diving you want to be safe so we round up the numbers instead of down in usual math like 11 will go up to 19 not 10 but 9 goes to 10.</span>
<span class="comment-copy">How about using <code>cut</code> from pandas: <code>import pandas as pd</code> then :<code>pd.cut([time], bins = np.array([0,10,19,25,29,32, np.inf]), labels = np.array(['A','B','C','D','E','F']), right = True)</code></span>
<span class="comment-copy">Nice. And since you're not using <code>self.keys</code> anywhere else, you could really just skip keeping around a variable for it, and use <code>self.d35.keys()</code> directly in the comprehension. Speaking of which, you could also do away with the comprehension and just have the "naked" generator expression. Anyway, those are just nits. This is about as quick and direct a solution to OP's problem as it gets.</span>
<span class="comment-copy">great observations @JohnY, thank you for your feedback</span>
<span class="comment-copy">Can you put this into a .py file I'm not very good at looking at code, It'll be easier for me</span>
<span class="comment-copy">Sorry, but I still don't really understand... I'm new to python and not that good with seeing what the code does without running it.</span>
<span class="comment-copy">so take a look now, the function pd.cut has turned timestocut (<code>[0, 4, 8, 12, 16, 20, 24, 28, 32, 36]</code>) to the output (<code>[A, A, A, B, B, C, C, D, E, F]</code>) by binning them, based on the given bins, and them labeling each bin with the given labels.</span>
<span class="comment-copy">So what does <code>np.array([-1,10,19,25,29,32, np.inf])</code> do?</span>
<span class="comment-copy">that's a numpy array, which gives us the bins. So, anything between -1 and 10 is in bin1, between 10 and 19 is in bin2 etc etc. Then the bins are labelled using the next array, which holds the names.</span>
<span class="comment-copy">okay I think I got it, I'll try it out. EDIT: It can't find <code>arrays</code> in <code>np.arrays</code> am I just being dumb?</span>
<span class="comment-copy">Yikes! I'll still keep this answer open to see if anyone has a better answer than brute forcing this, but the chances don't seem too great.</span>
<span class="comment-copy">I mean you are checking the range of where a number exists, That's the logic in what I'm seeing. I don't see how else you could do it without checking x1 and x2</span>
<span class="comment-copy">I see, it seems like there might some kind of library like what @jermycg said</span>
<span class="comment-copy">yes looks like it ! good luck!</span>
<span class="comment-copy">@ReefLoans <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">docs.python.org/3/library/bisect.html</a></span>
