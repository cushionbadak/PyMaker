<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/207000/what-is-the-difference-between-class-and-instance-attributes">What is the difference between class and instance attributes?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I am trying to create a class with various data which are read in from several files. The usual way is probably to define a constructor (<code>__init__</code>) and read data inside this routine, e.g.,</p>
<pre><code>from SomeOtherMod import reader   # some data reader

class Myclass:

    def __init__( self ):
        self.N = reader.readN()
        self.data = reader.readdata()
        self.foo = self.data.foo()
        self.bar = self.data.bar()
        ...    # more data to read and associated properties follow

    def othefunc( self ):
        ...    # use self.N, self.data, ...
</code></pre>
<p>But it also seems that I can write the same thing in a header part of the class without using <code>__init__</code>, e.g.,</p>
<pre><code>class Myclass:

    N = reader.readN()
    data = reader.readdata()
    foo = data.foo()
    bar = data.bar()
    ...

    def otherfunc( self ):
        ...
</code></pre>
<p>which looks more terse than the first code. So I am wondering whether this second code is a valid way for defining various fields of a Python class? Is it considered bad practice to do so, or is there any difference between the first and second approaches? I would appreciate any suggestions because I'm still new to Python. Thanks much!</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes - they are very different - when you assign to  <code>self.attribute</code> inside a method you are making it an instance attribute- while when you assign to  <code>attribute</code> in the class body, you are creating a class attribute.
Class attributes are shared among all instances. </p>
<p>In some circumstances, but not always, you may want exactly that. WHht you have to keep in mind is that if yu change a class attribute, it will be changed for all instances of that class at once.</p>
<p>Of course, there is a natural decurrence of the way Python deal with attribute retrieval and assignment that makes assignments in the class body quite handy. If there is a value that should be the default for all instances of a class - say, employee Payout - but that should be customized at some point in the life cycle of the object, that happens naturally:</p>
<pre><code>class Employee:
    payout = 100

e1 = Employee()
e2 = Employee()

print(e1.payout, e2.payout) 
# Payout is read from the class as it does not exist in any instance
# Python prints 100, 100

e1.payout = 120
# Now, an "payout" attribute is created in the "e1" instance
print(e1.payout, e2.payout)
# shows 120, 100

# And the outpt of the following lines will make
# really clear what is going on:
print(e1.__class__.__dict__, e2.__class__.__dict__)
# shows "{'payout': 100, ...}, {'payout': 100, ...} 
print(e1.__dict__, e2.__dict__)
# shows "{'payout': 120}, {} 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the first approach, N, data, foo and bar are easy members of the instances of Myclass. Each Myclass object has its own and changing one will have no effect on the other instances:</p>
<pre><code>class X():
  def __init__(self):
    self.x = []

a = X()
b = X()
a.x.append(1)
a.x != b.x
</code></pre>
<p>In the second approach, they are members of the class. You can still access them through the instances, but they will be shared by all the instances.</p>
<pre><code>class X():
  x = []

a = X()
b = X()
a.x.append(1)
a.x == b.x == [1]
</code></pre>
<p>Both are valid code, but they serve different purposes</p>
</div>
<div class="post-text" itemprop="text">
<p>There are important differences between the two approaches.  In some use cases you can do it either way, but they are definitely not equivalent.  </p>
<p>With the first method, the statements inside the <code>__init__</code> method are not executed until you instantiate an instance of the class; i.e., until your code executes a statement of the form <code>a = MyClass()</code>.</p>
<p>With the second method, the statements inside the class definition block are executed the first time the interpreter reaches the code.  That's probably at (or near) the beginning of your program, and will occur when you import a module containing the class definition.  That may, or may not, be OK for your application.</p>
<p>Also, read the link provided in a comment by juanpa.arrivilaga, or this one: <a href="https://stackoverflow.com/questions/206734/why-do-attribute-references-act-like-this-with-python-inheritance">Why do attribute references act like this with Python inheritance?</a></p>
</div>
<span class="comment-copy">The first method defines instance attributes which can vary between instances of the class.  The second method defines class attributes which would be shared by all instances of the class. <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">9. Classes</a>. ... <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html</a></span>
<span class="comment-copy">You can think of class attributes like "static attributes" in languages like Java or C++</span>
<span class="comment-copy">Hmm, really...   Acutually, while I read some introductory book on Python, I still cannot understand how instance and class fields are distinguished (syntactically) in Python, except for the usage {Classname}.{fieldname}. I will check this more...</span>
<span class="comment-copy">As an aside, <code>__init__()</code> is not a constructor - it initializes instance attributes. <a href="http://stackoverflow.com/questions/6578487/init-as-a-constructor"><code>__init__</code> as a constructor?</a></span>
<span class="comment-copy">OK, thank you very much! I will check the difference of class and instance fields more closely. I hope I could upvote the answers but cannot still ... Anyway, thanks much!</span>
