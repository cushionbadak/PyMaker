<div class="post-text" itemprop="text">
<pre><code>import time
def clock(func):
   def clocked(*args):
       t0 = time.perf_counter()
       result = func(*args) 
       elapsed = time.perf_counter() - t0
       name = func.__name__
       arg_str = ', '.join(repr(arg) for arg in args)
       print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_str, result))
       return result
   return clocked
</code></pre>
<p>this is the decorator.</p>
<pre><code>@clock
def factorial(n):
    return 1 if n &lt; 2 else n*factorial(n-1)
</code></pre>
<p>the parts of result is:</p>
<pre><code>[0.00000191s] factorial(1) -&gt; 1
[0.00004911s] factorial(2) -&gt; 2
[0.00008488s] factorial(3) -&gt; 6
[0.00013208s] factorial(4) -&gt; 24
[0.00019193s] factorial(5) -&gt; 120
[0.00026107s] factorial(6) -&gt; 720
6! = 720
</code></pre>
<p>how this decorator works when the argument is recursive function? why the decorator can be executed for many times. how it works?</p>
</div>
<div class="post-text" itemprop="text">
<p>In your example, the <code>clock</code> decorator is executed once, when it replaces the original version of <code>factorial</code> with the clocked version. The original <code>factorial</code> is recursive and therefore the decorated version is recursive too. And so you get the timing data printed for each recursive call - the decorated <code>factorial</code> calls itself, not the original version, because the name <code>factorial</code> now refers to the decorated version.</p>
<hr/>
<p>It's a good idea to use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a> in decorators. This copies various attributes of the original function to the decorated version.</p>
<p>For example, without <code>wraps</code>:</p>
<pre><code>import time

def clock(func):
    def clocked(*args):
        ''' Clocking decoration wrapper '''
        t0 = time.perf_counter()
        result = func(*args) 
        elapsed = time.perf_counter() - t0
        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_str, result))
        return result
    return clocked

@clock
def factorial(n):
    ''' Recursive factorial '''
    return 1 if n &lt; 2 else n * factorial(n-1)

print(factorial.__name__, factorial.__doc__)
</code></pre>
<p><strong>output</strong></p>
<pre><code>clocked  Clocking decoration wrapper 
</code></pre>
<p>With <code>wraps</code>:</p>
<pre><code>import time
from functools import wraps

def clock(func):
    @wraps(func)
    def clocked(*args):
        ''' Clocking decoration wrapper '''
        t0 = time.perf_counter()
        result = func(*args) 
        elapsed = time.perf_counter() - t0
        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_str, result))
        return result
    return clocked

@clock
def factorial(n):
    ''' Recursive factorial '''
    return 1 if n &lt; 2 else n * factorial(n-1)

print(factorial.__name__, factorial.__doc__)
</code></pre>
<p><strong>output</strong></p>
<pre><code>factorial  Recursive factorial 
</code></pre>
<p>which is what we'd get if we did <code>print(factorial.__name__, factorial.__doc__)</code> on the undecorated version.</p>
<hr/>
<p>If you don't want the <code>clock</code>-decorated recursive function to print the timing info for all of the recursive calls, it gets a bit tricky. </p>
<p>The simplest way is to not use the decorator syntax and just call <code>clock</code> as a normal function so we get a new name for the clocked version of the function:</p>
<pre><code>def factorial(n):
    return 1 if n &lt; 2 else n * factorial(n-1)

clocked_factorial = clock(factorial)

for n in range(7):
    print('%d! = %d' % (n, clocked_factorial(n)))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[0.00000602s] factorial(0) -&gt; 1
0! = 1
[0.00000302s] factorial(1) -&gt; 1
1! = 1
[0.00000581s] factorial(2) -&gt; 2
2! = 2
[0.00000539s] factorial(3) -&gt; 6
3! = 6
[0.00000651s] factorial(4) -&gt; 24
4! = 24
[0.00000742s] factorial(5) -&gt; 120
5! = 120
[0.00000834s] factorial(6) -&gt; 720
6! = 720
</code></pre>
<p>Another way is to wrap the recursive function in a non-recursive function and apply the decorator to the new function.</p>
<pre><code>def factorial(n):
    return 1 if n &lt; 2 else n * factorial(n-1)

@clock
def nr_factorial(n):
    return factorial(n)

for n in range(3, 7):
    print('%d! = %d' % (n, nr_factorial(n)))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[0.00001018s] nr_factorial(3) -&gt; 6
3! = 6
[0.00000799s] nr_factorial(4) -&gt; 24
4! = 24
[0.00000801s] nr_factorial(5) -&gt; 120
5! = 120
[0.00000916s] nr_factorial(6) -&gt; 720
6! = 720
</code></pre>
<p>Another way is to modify the decorator so that it keeps track of whether it's executing the top level of the recursion or one of the inner levels, and only print the timing info for the top level. This version uses the <code>nonlocal</code> directive so it only works in Python 3, not Python 2.</p>
<pre><code>def rclock(func):
    top = True
    @wraps(func)
    def clocked(*args):
        nonlocal top
        if top:
            top = False
            t0 = time.perf_counter()
            result = func(*args) 
            elapsed = time.perf_counter() - t0
            name = func.__name__
            arg_str = ', '.join(repr(arg) for arg in args)
            print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_str, result))
        else:
            result = func(*args)
            top = True
        return result
    return clocked

@rclock
def factorial(n):
    return 1 if n &lt; 2 else n * factorial(n-1)

for n in range(3, 7):
    print('%d! = %d' % (n, factorial(n))) 
</code></pre>
<p><strong>output</strong></p>
<pre><code>[0.00001253s] factorial(3) -&gt; 6
3! = 6
[0.00001205s] factorial(4) -&gt; 24
4! = 24
[0.00001227s] factorial(5) -&gt; 120
5! = 120
[0.00001422s] factorial(6) -&gt; 720
6! = 720
</code></pre>
<p>The <code>rclock</code> function can be used on non-recursive functions, but it's a little more efficient to just use the original version of <code>clock</code>.</p>
<hr/>
<p>Another handy function in <code>functools</code> that you should know about if you're using recursive functions is <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>lru_cache</code></a>. This keeps a cache of recently computed results so they don't need to be re-computed. This can enormously speed up recursive functions. Please see the docs for details.</p>
<p>We can use <code>lru_cache</code> in conjunction with <code>clock</code> or <code>rclock</code>.</p>
<pre><code>@lru_cache(None)
@clock
def factorial(n):
    return 1 if n &lt; 2 else n * factorial(n-1)

for n in range(3, 7):
    print('%d! = %d' % (n, factorial(n)))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[0.00000306s] factorial(1) -&gt; 1
[0.00017850s] factorial(2) -&gt; 2
[0.00022049s] factorial(3) -&gt; 6
3! = 6
[0.00000542s] factorial(4) -&gt; 24
4! = 24
[0.00000417s] factorial(5) -&gt; 120
5! = 120
[0.00000409s] factorial(6) -&gt; 720
6! = 720
</code></pre>
<p>As you can see, even though we used the plain <code>clock</code> decorator only a single line of timing info gets printed for the factorials of 4, 5, and 6 because the smaller factorials are read from the cache instead of being re-computed.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you apply a decorator to a function, the function is passed as a parameter to the decorator. Whether the function is recursive or not does not matter.</p>
<p>The code</p>
<pre><code>@clock
def factorial(n):
    return 1 if n &lt; 2 else n*factorial(n-1)
</code></pre>
<p>is equivalent to</p>
<pre><code>def factorial(n):
    return 1 if n &lt; 2 else n*factorial(n-1)
factorial = clock(factorial)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe it helps to assume the "syntactic sugar" point of view.
This is from <a href="https://www.python.org/dev/peps/pep-0318/" rel="nofollow noreferrer">PEP 318</a> with modifications (I simplified the example)</p>
<blockquote>
<p>The current syntax for function decorators as implemented in Python 2.4a2 is:</p>
</blockquote>
<pre><code>@dec
def func(arg1, arg2, ...):
    pass
</code></pre>
<blockquote>
<p>This is equivalent to:</p>
</blockquote>
<pre><code>def func(arg1, arg2, ...):
    pass
func = dec(func)
</code></pre>
<p>As you can see the decorator function is called only once and the wrapper it returns is assigned to the name of the decorated function.</p>
<p>Thus whenever the original function is called by its name (for example in a recursion) the wrapper (but not the decorator function) is called instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>The decorated function is passed to the decorator as an argument and returned another function to replace the original one, the returned function is no recursive function, but when you call it, it'll call the original recursive function:</p>
<pre><code>def clock(func):
  def clocked(*args):
   t0 = time.perf_counter()
   result = func(*args) # You call your original recursive function here
   elapsed = time.perf_counter() - t0
   name = func.__name__
   arg_str = ', '.join(repr(arg) for arg in args)
   print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_str, result))
   return result
return clocked
</code></pre>
<p>When you call your decorated function <code>factorial</code>, what you actually called is <code>clocked</code>, and it actually call <code>factorial</code> in the following line:</p>
<pre><code>result = func(*args)
</code></pre>
<p>The decorator is executed only once.</p>
<p>For understanding, you can think your function becomes to the following one after <code>@clock</code>:</p>
<pre><code>def factorial(*args):
    def _factorial(n):
        return 1 if n &lt; 2 else n*_factorial(n-1)
    t0 = time.perf_counter()
    result = _factorial(*args)
    elapsed = time.perf_counter() - t0
    name = _factorial.__name__
    arg_str = ', '.join(repr(arg) for arg in args)
    print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_str, result))
    return result
</code></pre>
</div>
<span class="comment-copy">By "iterable" do you mean "recursive"?</span>
<span class="comment-copy">sorry, it should be recursive</span>
<span class="comment-copy">Just a comment on terminology, <code>clock</code> is a decorator and is only called once. <code>factorial</code> is decorated with the <code>clocked</code> wrapper by the <code>clock</code> decorator. So it is the <code>clocked</code> wrapper that is called every time. The reason it is called many times is because Python has late binding, so the recursive call to <code>factorial()</code> is not bound to a function until it is executed and by that time <code>factorial = clock(factorial)</code>, i.e. a decorated form of <code>factorial</code>.</span>
<span class="comment-copy">mean that the decorated function is recursive,and it will be called for many times? and print information for each time?</span>
<span class="comment-copy">@DeanWang I've just added a lot more info to my answer. I hope you find it useful.</span>
<span class="comment-copy">thanks for your answer a lot</span>
<span class="comment-copy">i am confused for why the function can be passed as a parameter to the decorator for many times.</span>
<span class="comment-copy">@DeanWang the function is only passed to the decorator once</span>
<span class="comment-copy">for each time the functions is called, the decorator will be executed,right? recursive is called for many times,and decorator be executed many times, right?</span>
<span class="comment-copy">@Code-Apprentice python uses late binding the <code>factorial()</code> call inside the function will call the decorated <code>factorial</code> not the vanilla <code>factorial</code>, even in your second example.</span>
<span class="comment-copy">@DeanWang You are correct. That is why you see the output in your question.</span>
<span class="comment-copy">mean that the decorated function is recursive,and it will be called for many times? and print information for each time?</span>
<span class="comment-copy">The decorated function will call for many times, just like it's not decorated and call it normally. The logic to print information is in your wrapper function <code>clock</code>, it will be called only once.</span>
<span class="comment-copy">@DeanWang, I updated my answer for easier understanding, check it out</span>
