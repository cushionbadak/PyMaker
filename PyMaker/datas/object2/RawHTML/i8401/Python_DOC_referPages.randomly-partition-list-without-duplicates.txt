<div class="post-text" itemprop="text">
<p>I've got an array that contains each of a set of numbers <code>n</code> times. Example with <code>n=2</code>:</p>
<pre><code>[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
</code></pre>
<p>What I would like is a partition of this array in which the members of the partition</p>
<ul>
<li>contain elements that are drawn randomly from the array</li>
<li>contain no duplicates</li>
<li>contain the same number of elements (up to rounding) <code>k</code></li>
</ul>
<p>Example output for <code>k=4</code>:</p>
<pre><code>[[3,0,2,1], [0,1,4,2], [3,4]]
</code></pre>
<p>Invalid output for <code>k=4</code>:</p>
<pre><code>[[3,0,2,2], [3,1,4,0], [1,4]]
</code></pre>
<p>(this is a partition but the first element of the partition contains duplicates)</p>
<p>What's the most pythonic way of achieving this?</p>
</div>
<div class="post-text" itemprop="text">
<p>A combination of <a href="https://docs.python.org/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and <a href="https://docs.python.org/library/random.html#random.sample" rel="nofollow noreferrer"><code>random.sample</code></a> can be used:</p>
<pre><code>from collections import Counter
import random

def random_partition(seq, k):
    cnts = Counter(seq)
    # as long as there are enough items to "sample" take a random sample
    while len(cnts) &gt;= k:
        sample = random.sample(list(cnts), k)
        cnts -= Counter(sample)
        yield sample

    # Fewer different items than the sample size, just return the unique
    # items until the Counter is empty
    while cnts:
        sample = list(cnts)
        cnts -= Counter(sample)
        yield sample
</code></pre>
<p>This is a generator that <code>yield</code>s the samples, so you can simply cast it to a <code>list</code>:</p>
<pre><code>&gt;&gt;&gt; l = [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]

&gt;&gt;&gt; list(random_partition(l, 4))
[[1, 0, 2, 4], [1, 0, 2, 3], [3, 4]]

&gt;&gt;&gt; list(random_partition(l, 2))
[[1, 0], [3, 0], [1, 4], [2, 3], [4, 2]]

&gt;&gt;&gt; list(random_partition(l, 6))
[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]

&gt;&gt;&gt; list(random_partition(l, 4))
[[4, 1, 0, 3], [1, 3, 4, 0], [2], [2]]
</code></pre>
<p>The last case shows that this method can give weird results if the "random" part in the function returns the "wrong" samples. If that shouldn't happen or at least not often you need to figure out how the samples could be weighted (for example using <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a>) to minimize that possibility.</p>
</div>
<span class="comment-copy">Your partitioning is not well defined yet. What do you do in the case that k &gt; L/n (where L is the total number of elements). For example, in your array, what would you return for k=6?</span>
<span class="comment-copy">Maybe read your input into a <code>Counter</code>, then decrement <code>k</code> random entries in that <code>Counter</code>, keeping track of which ones (these are the sublists in your output).  Then keep doing that until all entries are exhausted.  I'd be worried that for some values of <code>n</code> and <code>k</code>, and the size of the set, the number of sublists in your output could be random.  I don't know if that woiuld be a problem, but it's something to watch</span>
