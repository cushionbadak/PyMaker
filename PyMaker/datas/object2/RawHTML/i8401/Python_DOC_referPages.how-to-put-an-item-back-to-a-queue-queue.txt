<div class="post-text" itemprop="text">
<p>How do you return an item to a queue.Queue? This would be useful in threading or multiprocessing if the task fails, so that the task can not be lost.</p>
<p>The <a href="https://docs.python.org/3/library/queue.html#queue.Queue.get" rel="nofollow noreferrer">docs for queue.Queue.get()</a> say that the function can "Remove and return an item from the queue," but I believe the use of the word "return" here refers to the function returning the item to the calling thread, not placing it back into the item queue.  This is demonstrated by the below sample code just blocks infinitely on the main thread's second <code>queue.Queue.get()</code> call, instead of making it to the <code>print()</code> call in the thread.</p>
<pre><code>import time
import threading
import queue


def threaded_func():
    thread_task = myqueue.get()
    print('thread_task: ' + thread_task)

myqueue = queue.Queue()
myqueue.put('some kind of task')
main_task = myqueue.get()
print('main_task: ' + main_task)

t = threading.Thread(target=threaded_func)
t.daemon = True
t.start()

time.sleep(5)
myqueue.get()   # This blocks indefinitely
</code></pre>
<p>I have to believe that there is a simple way to put the task back, so what is it?  Calling <code>task_done()</code> and then <code>put()</code> with the task to put it back into the queue in two operations is not atomic and so could result in a lost item.</p>
<p>One possible, but clunky, solution would be to just try to execute the task again, but then you'd have to add a few extra lines to handle that complexity and I'm not even sure that all failed tasks could necessarily recover in that way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not all failed tasks can recover. You shouldn't retry them unless there is some reason to think they will pass at a later date. For instance, if your work item is a URL and connection failed count, you could implement some sort of a max-retries thing.</p>
<p>Your biggest problem is that you haven't implemented a viable worker model yet. You need 2 queues to have a bidirectional conversation with a worker. One to post work items and one to receive status. Once you have that, the receiver can always decide to cram that message back on the work queue. Here is an example with a lazy worker that just passes what its told.</p>
<pre><code>import threading
import queue

def worker(in_q, out_q):
    while True:
        try:
            task, data = in_q.get()
            print('worker', task, data)
            if task == "done":
                return
            elif task == "pass this":
                out_q.put(("pass", data))
            else:
                out_q.put(("fail", data))
        except Exception as e:
            print('worker exception', e)
            out_q.put("exception", data)

in_que = queue.Queue()
out_que = queue.Queue()

work_thread = threading.Thread(target=worker, args=(in_que, out_que))
work_thread.start()

# lets make every other task a fail
in_que.put(('pass this', 0))
in_que.put(('fail this', 1))
in_que.put(('pass this', 2))
in_que.put(('fail this', 3))
in_que.put(('pass this', 4))
in_que.put(('fail this', 5))

pending_tasks = 6

while pending_tasks:
    status, data = out_que.get()
    if status == "pass":
        pending_tasks -= 1
    else:
        # make failing tast pass
        in_que.put(('pass this', data))

in_que.put(("done", None))
work_thread.join()
print('done')
</code></pre>
</div>
<span class="comment-copy">You're explaining the problem, but not really explaining the overall goal. So what are you even trying to accomplish here?</span>
<span class="comment-copy">It's to not lose a work item that failed, to be able to process it later. My specific use is in calling REST API URLs, when some problem not innate to the work item URL may cause it to fail.</span>
<span class="comment-copy">My demo code is just to illustrate the inability to put an item back on the queue, it's not my actual worker code.</span>
<span class="comment-copy">whoops, I didn't know keyboard enter would create the post instead of newline. I also wanted to say that I can see your code is using a second queue and counting down the items from the first queue and requeuing them if they failed. I see this extra queue and handling logic as an unnecessary complexity when one could just return an item back into the main queue, which is what my original question is about. So are you saying that one cannot return an item to the queue?</span>
<span class="comment-copy">Well, sure. All I did was put the message back on the main queue. The other queue was there to handle returns from the thread. Your code can't possibly work... that get on the main thread is supposed to do what, exactly? So I wrote code that did. "Can't work" to "works" is perhaps the minimum complexity.</span>
