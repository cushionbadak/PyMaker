<div class="post-text" itemprop="text">
<p>Is there anyway to do the equivalent of this? </p>
<pre><code>my_list = [try: my_dict["some_key"] except KeyError: 0 for my_dict in my_list]
</code></pre>
<p>Since dictionaries throw KeyErrors I want to catch the error if the element in the list does not have a "some_key" property. I know I could create a defaultdict by importing collections and sidestepping the exception, but I want to know if this is possible with out of the box dictionaries.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you can't. You can put only <code>for</code> loops, <code>if</code>'s and <code>else</code>'s.</p>
<p>What you <em>can</em> do, though, is use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="noreferrer"><code>.get()</code></a>, which never throws a KeyError:</p>
<pre><code>my_list = [my_dict.get("some_key", 0) for my_dict in my_list]
</code></pre>
<p>The second argument is the default value in case the key does not exist. If you don't specify a default, the default default is None.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you can not do this directly in a list comprehension.  You must factor the try/except logic out into a separate function, and then call the function.  </p>
<p>There is an easy alternative for the use case shown in your question, though, using <code>dict.get</code>:</p>
<pre><code>my_list = [my_dict.get('some_key', 0) for my_dict in my_list]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As other answers mentioned you can not use an try-except inside a list comprehension. But as a tricky approach you can use <code>collections.defaultdict()</code> and override the <code>__missing__</code> attribute in order to catch the exceptions. Here is an example:</p>
<pre><code>from collections import defaultdict


class Mydefaultdict(defaultdict):
    def __init__(self, *args, **kwargs):
        super(Mydefaultdict, self).__init__(*args, **kwargs)

    def __getitem__(self, key):
        try:
            return defaultdict.__getitem__(self, key)
        except KeyError:
            return self.__missing__(key)

    def __missing__(self, key):
        # Instead of printing you can catch your exceptions in any way you like
        print("{} doesn't exist".format(key))
        if self.default_factory:
            return self.default_factory()  # You can rturn whatever you want here
</code></pre>
<p>Demo:</p>
<pre><code>d = Mydefaultdict(None, {4: 'b', 1: 'a'})
print([d[i] for i in [1, 2]])

2 doesn't exist
['a', None]
</code></pre>
</div>
<span class="comment-copy">Thanks I ended up using this</span>
<span class="comment-copy">Would it be faster with an if argument to check if the key is in dict instead of trying all keys with get?</span>
<span class="comment-copy">@Varlor Using the value if the key exists and 0 if not is exactly what <code>get</code> does. Doing it manually might not be noticeably slower, but I don't think it would be faster.</span>
<span class="comment-copy">Or merely use <code>defaultdict(int)</code></span>
<span class="comment-copy">@zondo No! we just want to override the <code>__missing__</code> method. Using <code>int</code> as the default factory function won't give us the desire behavior.</span>
<span class="comment-copy">The desired behavior is to get a 0 when the key doesn't exist. Adding the key may be undesired, though.</span>
