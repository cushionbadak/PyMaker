<div class="post-text" itemprop="text">
<p>I have a problem with <code>return self</code></p>
<pre><code>class Fib: 
    def __init__(self, max):
        self.max = max
    def __iter__(self): 
        self.a = 0
        self.b = 1
        return self
    def __next__(self):
        fib = self.a
        if fib &gt; self.max:
            raise StopIteration
        self.a, self.b = self.b, self.a + self.b
        return fib
</code></pre>
<p>I have already seen this question <a href="https://stackoverflow.com/questions/37320751/in-python-does-return-self-return-a-copy-of-the-object-or-a-pointer">return self problem</a> but I can't understand what the benefit is of <code>return self</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Returning <code>self</code> from a method simply means that your method returns a reference to the instance object on which it was called. This can sometimes be seen in use with object oriented APIs that are designed as a <a href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noreferrer">fluent interface</a> that encourages <a href="https://en.wikipedia.org/wiki/Method_cascading" rel="noreferrer">method cascading</a>. So, for example, </p>
<pre><code>&gt;&gt;&gt; class Counter(object):
...     def __init__(self, start=1):
...         self.val = start
...     def increment(self):
...         self.val += 1
...         return self
...     def decrement(self):
...         self.val -= 1
...         return self
...
&gt;&gt;&gt; c = Counter()
</code></pre>
<p>Now we can use method cascading:</p>
<pre><code>&gt;&gt;&gt; c.increment().increment().decrement()
&lt;__main__.Counter object at 0x1020c1390&gt;
</code></pre>
<p>Notice, the last call to <code>decrement()</code> returned <code>&lt;__main__.Counter object at 0x1020c1390&gt;</code>, which <em>is</em> <code>self</code>.
Now:</p>
<pre><code>&gt;&gt;&gt; c.val
2
&gt;&gt;&gt;
</code></pre>
<p>Notice, you cannot do this if you did not return <code>self</code>:</p>
<pre><code>&gt;&gt;&gt; class Counter(object):
...     def __init__(self, start=1):
...         self.val = start
...     def increment(self):
...         self.val += 1
...         # implicitely return `None`
...     def decrement(self):
...         self.val -= 1
...         # implicitely return `None`
...
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; c.increment().increment()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'increment'
&gt;&gt;&gt; c
&lt;__main__.Counter object at 0x1020c15f8&gt;
&gt;&gt;&gt; c.val
2
&gt;&gt;&gt;
</code></pre>
<p>Notice, not everyone is a fan of "method cascading" design. Python built-ins do not tend do this, so, <code>list</code> for example:</p>
<pre><code>&gt;&gt;&gt; x = list()
&gt;&gt;&gt; x.append(1).append(2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'append'
&gt;&gt;&gt;
</code></pre>
<p>The one place you <em>do</em> often see this is when your class implements the <code>iterator</code> protocol, where <code>iter</code> on an iterator returns <code>self</code> by convention, although this is suggested by <a href="https://docs.python.org/3/tutorial/classes.html#iterators" rel="noreferrer">the docs</a>:</p>
<blockquote>
<p>Having seen the mechanics behind the iterator protocol, it is easy to
  add iterator behavior to your classes. Define an <code>__iter__()</code> method
  which returns an object with a <code>__next__()</code> method. If the class
  defines <code>__next__()</code>, then <code>__iter__()</code> can just return <code>self</code>:</p>
<pre><code>class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
</code></pre>
</blockquote>
<p>Notice, this in effect makes your iterator only useful for a single pass:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; it = iter(x)
&gt;&gt;&gt; list(it)
[1, 2, 3, 4]
&gt;&gt;&gt; list(it)
[]
&gt;&gt;&gt; next(it)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is needlessly complex code. Pay little attention to it. There's no reason on earth to implement it this way.</p>
<p>That being said, what it does is this:</p>
<pre><code>class Fib: 

    """Implements the Fibonacci sequence."""

    def __init__(self, max_):
        self.max = max_

    def __iter__(self):
        """Initializes and returns itself as an iterable."""

        self.a = 0
        self.b = 1
        return self

    def __next__(self):
        """What gets run on each execution of that iterable."""

        fib = self.a
        if fib &gt; self.max:
            raise StopIteration
        self.a, self.b = self.b, self.a + self.b  # increment
        return fib
</code></pre>
<p>This is all much easier to express as:</p>
<pre><code>def fib(max_):
    a, b = 0, 1
    while b &lt;= max_:
        out = a
        a, b = b, a+b
        yield out
</code></pre>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; fib_obj = Fib(20)
&gt;&gt;&gt; for n in fib_obj:
...     print(n)

&gt;&gt;&gt; for n in Fib(20):
...     print(n)

&gt;&gt;&gt; for n in fib(20):
...     print(n)
# all give....
0
1
1
2
3
5
8
13
</code></pre>
</div>
<span class="comment-copy">Define benefit?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer"><code>__iter__</code> in the documentation</a>. You can start reading there. Short answer: <code>__iter__</code> returns <code>self</code> because it's needed for an iterator.</span>
<span class="comment-copy">@Elliot RobertsWhat is the use of ?</span>
<span class="comment-copy"><code>return self</code> would return the object that the method was called from.</span>
<span class="comment-copy">Thank you, good explanation</span>
<span class="comment-copy">@AmrElgendy you're welcome. I have added one more bit of information at the end, so check out the latest edit.</span>
<span class="comment-copy">I'd imagine it's possible to modify the code and make your iterator reusable. Reset <code>index</code> to <code>len(data)</code> just before you raise StopIteration.</span>
<span class="comment-copy">@Timir you probably wouldn't want to do that though, then it would become an infinite iterator. In general, iterators <i>should not be re-usable</i>.</span>
<span class="comment-copy">Is that mean <code>self.a = 0         self.b = 1</code> Will be implemented for one time ??</span>
<span class="comment-copy">@AmrElgendy <code>__iter__</code> is run once to initialize an iterator (that is, an object with a <code>__next__</code> method) and <code>self.a</code> and <code>self.b</code> are used in that <code>__next__</code> method. It's a silly way to implement the object.</span>
<span class="comment-copy">sorry , this is last question What I understand is <code>__iter__</code> implement for one time when calling it from <code>__next__</code>  that's right ??</span>
<span class="comment-copy">@AmrElgendy no, but you're digging way deeper into the language than you probably need to be. If you're interested, read the official docs.</span>
