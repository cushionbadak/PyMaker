<div class="post-text" itemprop="text">
<p>For mutable types, such as list, instead of using <code>if else</code>, we can deal with missing key issues like this:</p>
<pre><code>dic = {'key1':[1, 2], 'key2':[1]}
dic.setdefault('key3', []).append(1)
</code></pre>
<p>which only checks <code>'key3'</code> in <code>dic</code> only once.</p>
<p>But for immutable types, such as integer, we cannot use <code>setdefault()</code> like this:</p>
<pre><code>dic = {'key1':3, 'key2':5}
dic.setdefault('key3', 0) += 1
</code></pre>
<p>Since <code>setdefault()</code> will return the integer <code>0</code> instead of variable <code>dic['key3']</code></p>
<p>I'm not sure how to deal with it elegantly, for example the best I can do is like this:</p>
<pre><code>dic = {'key1':3, 'key2':5}
dic['key3'] = 1 if 'key3' not in dic else dic['key3'] + 1
</code></pre>
<p>But this code checks <code>'key3'</code> in <code>dic</code> twice and also use extra memory for <code>dic['key3'] + 1</code> if <code>'key3'</code> exists.</p>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <strong>use <code>.get(..)</code></strong> to specify a <em>default value</em>, like:</p>
<pre><code>dic['key3'] = dic<b>.get('key3',0)</b> + 1</code></pre>
<p><code>.get(key,default=None)</code> performs a lookup on the dictionary. In case it fails to find the <code>key</code>, it will return the <code>default</code>.</p>
<p>But I think in this case, you better <strong>use a <code>Counter</code></strong>:</p>
<pre><code><b>from collections import Counter</b>

counter = <b>Counter(</b>{'key1':3, 'key2':5}<b>)</b>
counter['key3'] <b>+= 1</b></code></pre>
<p>A counter <em>assumes</em> that if a key is not present in the database, its value is zero.</p>
</div>
<span class="comment-copy">Use a <a href="https://docs.python.org/3/library/collections.html#defaultdict-objects" rel="nofollow noreferrer"><code>collections.defaultdict(int)</code></a>? Note that this is really about mutability vs immutability - a <code>tuple</code> is still iterable, but would have the same problem you see with integers. Also checking <code>'key3' in dic</code> twice is really not a big deal; lookups by key in a dictionary are <code>O(1)</code> because it's a hash table (see <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68" rel="nofollow noreferrer">this classic PyCon talk</a> for more info).</span>
<span class="comment-copy">Thanks much for your reply!</span>
<span class="comment-copy">Yes, <code>Counter</code> is better than <code>defaultdict(int)</code>.</span>
<span class="comment-copy">Thanks! <code>counter</code> works just fine when the default value is zero. But I think <code>dic['key3'] = dic.get('key3',0) + 1</code> still checks <code>dic</code> twice and uses extra memory.</span>
<span class="comment-copy">@DongxuZhang: no usually <code>.get(..)</code> has its own efficient implementation: it works faster than <code>dic['key3'] if 'key3' in dic else 0</code>. And <code>dic['a'] += 1</code> will also check the dictionary twice.</span>
<span class="comment-copy">@WillemVanOnsem Oh, I see. since integer is immutable, <code>+=</code>  will falls back to calling  <code>__add__</code>. Thanks~</span>
