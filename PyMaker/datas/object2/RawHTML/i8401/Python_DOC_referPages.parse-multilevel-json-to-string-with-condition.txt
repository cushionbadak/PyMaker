<div class="post-text" itemprop="text">
<p>I have this nested json item that I just want to flatten out to a comma separated string (i.e. parkinson:5, billy mays:4)so I can store in a database if needed for future analysis.  I wrote out the function below but am wondering if there's a more elegant way using list comprehension (or something else). I found this post but I'm not sure how to adapt it for my needs (<a href="https://stackoverflow.com/questions/25445791/python-parse-json-values-by-multilevel-keys">Python - parse JSON values by multilevel keys</a>).</p>
<p>Data looks like this:</p>
<pre class="lang-json prettyprint-override"><code>{'persons':
     [{'name': 'parkinson', 'sentiment': '5'},
      {'name': 'knott david', 'sentiment': 'none'},
      {'name': 'billy mays', 'sentiment': '4'}],
 'organizations':
      [{'name': 'piper jaffray companies', 'sentiment': 'none'},
       {'name': 'marketbeat.com', 'sentiment': 'none'},
       {'name': 'zacks investment research', 'sentiment': 'none'}]
 'locations': []
}
</code></pre>
<p>Here's my code:</p>
<pre><code>def parse_entities(data):
    results = ''
    for category in data.keys():
    # for c_id, category in enumerate(data.keys()):
        entity_data = data[category]
        for e_id, entity in enumerate(entity_data):
            if not entity_data[e_id]['sentiment'] == 'none':
                results = results + (data[category][e_id]['name'] + ":" +
                                     data[category][e_id]['sentiment'] + ",")

    return results
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, the most important thing to make your code shorter and nicer to look at is to use your own variables. Be aware that <code>entity_data = data[category]</code> and <code>entity = entity_data[e_id]</code>. So you can write <code>entity['name']</code> instead of <code>data[category][e_id]['name']</code>.</p>
<p>Secondly, if you want something like</p>
<pre><code>for category in data.keys():
    entity_data = data[category]
</code></pre>
<p>you can make it shorter and easier to read by changing it to</p>
<pre><code>for category, entity_data in data.items():
</code></pre>
<p>But you don't even need that here, you can just use the <code>data.values()</code> iterator to get the values. When combining these improvements your code looks like this:</p>
<pre><code>def parse_entities(data):
    results = ''
    for entity_data in data.values():
        for entity in entity_data:
            if entity['sentiment'] != 'none':
                results += entity['name'] + ":" + entity['sentiment'] + ","
    return results
</code></pre>
<p>(I have also changed <code>results = results + ...</code> to <code>results += ...</code> and <code>if not entity['sentiment'] == 'none'</code> to <code>if entity['sentiment'] != 'none'</code>, because it is shorter and doesn't lower the readability)</p>
<p>When you have this it is much easier to make it even shorter and more elegant by using list comprehension:</p>
<pre><code>def parse_entities(data):
    return ",".join([entity['name'] + ":" + entity['sentiment']
                     for entity_data in data.values()
                     for entity in entity_data
                     if not entity['sentiment'] == 'none'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe something like this will work?</p>
<pre><code>def parse_entities(data):
    results = []
    for category in data.keys():
        results += list(map(lambda x: '{0}:{1}'.format(x['name'], x['sentiment']),
                            filter(lambda i: i['sentiment'] != 'none', data[category])))
    return ','.join(results)

if __name__ == '__main__':
    print(parse_entities(data))
</code></pre>
<p>With the output looking like this</p>
<pre><code>parkinson:5,billy mays:4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This might be a way to do it. Even though using a 'proper library' (depending on your actual use case) makes more sense.</p>
<pre><code>data = {
 'persons':
     [{'name': 'parkinson', 'sentiment': '5'},
      {'name': 'knott david', 'sentiment': 'none'},
      {'name': 'billy mays', 'sentiment': '4'}],
 'organizations':
      [{'name': 'piper jaffray companies', 'sentiment': 'none'},
       {'name': 'marketbeat.com', 'sentiment': 'none'},
       {'name': 'zacks investment research', 'sentiment': 'none'}],
 'locations': []
}

import itertools

# eq. = itertools.chain.from_iterable(data.values())
dicts = itertools.chain(*data.values())
pairs = [":".join([d['name'], d['sentiment']])
         for d in dicts if d['sentiment'] != 'none']
result = ",".join(pairs)

print(result)

# parkinson:5,billy mays:4

# short, but less readable version
result = ",".join([":".join([d['name'], d['sentiment']])
                   for d in itertools.chain(*data.values())
                   if d['sentiment'] != 'none'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a problem where we need to perform the 3 separate tasks:</p>
<ol>
<li>Filter out unqualified rows of data</li>
<li>Flatten the dict of lists into a simple list</li>
<li>Transform each dictionary object into a simple tuple, ready for formatting</li>
</ol>
<p>Here is the code:</p>
<pre><code>def parse_entities(data):
    new_data = [
        (row['name'], row['sentiment'])        # 3. Transform
        for rows in data.values()              # 2. Flatten
            for row in rows                    # 2. Flatten
                if row['sentiment'] != 'none'  # 1. Filter
    ]

    # e.g, new_data = [('parkinson', '5'), ('billy mays', '4')]

    return ','.join('{}:{}'.format(*row) for row in new_data)

#
# test code
#
data = {
    'locations': [],
    'organizations': [
        {'name': 'piper jaffray companies', 'sentiment': 'none'},
        {'name': 'marketbeat.com', 'sentiment': 'none'},
        {'name': 'zacks investment research', 'sentiment': 'none'}
    ],
    'persons': [
        {'name': 'parkinson', 'sentiment': '5'},
        {'name': 'knott david', 'sentiment': 'none'},
        {'name': 'billy mays', 'sentiment': '4'}
    ],
}
print parse_entities(data)
</code></pre>
<p>Output:</p>
<pre><code>parkinson:5,billy mays:4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> that does it:</p>
<pre><code>data = {'persons': [
            {'name': 'parkinson', 'sentiment': '5'},
            {'name': 'knott david', 'sentiment': 'none'},
            {'name': 'billy mays', 'sentiment': '4'}],
        'organizations': [
            {'name': 'piper jaffray companies', 'sentiment': 'none'},
            {'name': 'marketbeat.com', 'sentiment': '99'},
            {'name': 'zacks investment research', 'sentiment': 'none'}],
        'locations': []
}

results = ','.join(entity['name'] + ':' + entity['sentiment']
                    for category, entity_data in data.items()
                        for entity in entity_data if entity['sentiment'] is not 'none')


print(results)  # -&gt; parkinson:5,billy mays:4,marketbeat.com:99
</code></pre>
<p>Note: I changed the sample data slightly to make sure it handled data in more than one <code>category</code> the same as your code.</p>
</div>
<span class="comment-copy">Why not use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">csv library</a>?</span>
<span class="comment-copy">Can I use it to parse through the data and combine it into one long string?  I'm not trying to save it as a file, I just want a comma separated string.  I've updated my question.</span>
<span class="comment-copy">This is what I was looking for.  I'm selecting this as the accepted answer because it creates the short function I was looking for using list comprehension and I you explained how you transformed my along with the reasons why.</span>
<span class="comment-copy">@Phillip Thank you for accepting my answer :)</span>
<span class="comment-copy"><code>'none'</code> should be filtered out.</span>
<span class="comment-copy">Thanks, good point, i totally missed that. I updated it now</span>
