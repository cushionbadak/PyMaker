<div class="post-text" itemprop="text">
<p>I'm looking for an efficient way to take a specific part of an object inside of a list in order to manipulate it.</p>
<p>For example, if I have</p>
<pre><code>l = (('a', 1, 2, 3), ('b', 4, 5, 6), ('c', 7, 8, 9))
</code></pre>
<p>printing the index will result in</p>
<pre><code>&gt;&gt;&gt;print(l)
(('a', 1, 2, 3), ...)
</code></pre>
<p>I am wondering if there is a way in which I can grab only the first two things (eg 'a' and '1') from each object in the list in order to get</p>
<pre><code>&gt;&gt;&gt;print(l)
(('a', 1), ('b', 4), ('c', 7))
</code></pre>
<p>and return/manipulate them? I realize that I could copy the index into another list, then print out/return the first two indices's of the copy, but when scaling up this will be a pain. </p>
<p>Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>very simple using slicing in a generator comprehension, converted to <code>tuple</code>:</p>
<pre><code>l = (('a', 1, 2, 3), ('b', 4, 5, 6), ('c', 7, 8, 9))

l = tuple(z[:2] for z in l)

print(l)
</code></pre>
<p>result:</p>
<pre><code>(('a', 1), ('b', 4), ('c', 7))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may <em>slice</em> the nested tuples with the <em>generator comprehension</em> as:</p>
<pre><code>&gt;&gt;&gt; l = (('a', 1, 2, 3), ('b', 4, 5, 6), ('c', 7, 8, 9))

&gt;&gt;&gt; tuple(i[:2] for i in l)
(('a', 1), ('b', 4), ('c', 7))
</code></pre>
<p>If it is not mandatory to have a final value as <code>tuple</code>, you may simple write a <em>list comprehension</em> as:</p>
<pre><code>&gt;&gt;&gt; [i[:2] for i in l]
[('a', 1), ('b', 4), ('c', 7)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Tuples are <a href="https://en.wikipedia.org/wiki/Immutable_object" rel="nofollow noreferrer">immutable</a> in python. In a nutshell this means that the interior elements cannot be replaced / modified.</p>
<p>However, if you're looking to access the first two you can do this:</p>
<pre><code>l = (('a', 1, 2, 3), ('b', 4, 5, 6), ('c', 7, 8, 9))
x = tuple([(fst, snd) for (fst, snd, thrd, frth) in l])
</code></pre>
<p>Sometimes you will find <code>_</code> to indicate an unused (but still unpacked) value:</p>
<pre><code>l = (('a', 1, 2, 3), ('b', 4, 5, 6), ('c', 7, 8, 9))
x = tuple([(fst, snd) for (fst, snd, _, _) in l])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is just a sample of what you can do with iterable unpacking and the little used keyword arguments to <a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer"><code>print</code></a>. Please don't select this answer.</p>
<pre><code>l = (('a', 1, 2, 3), ('b', 4, 5, 6), ('c', 7, 8, 9))
print(*(x[:2] for x in l), sep=', ')
</code></pre>
<p>This will not print the outer parentheses or allow you to manipulate the result directly, but you can always store the contents of the generator into a list.</p>
<p>This is something that the other answers neglect to mention explicitly. The generator comprehension <code>(x[:2] for x in l)</code> can only be iterated through only once, but the list comprehension <code>[x[:2] for x in l]</code> is just a list and can be manipulated as many times as you wish.</p>
<p>The example above can be rewritten as follows if you want to work with the filtered data after printing it: </p>
<pre><code>l = (('a', 1, 2, 3), ('b', 4, 5, 6), ('c', 7, 8, 9))
g = [x[:2] for x in l]
print(*g, sep=', ')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another one:</p>
<pre><code>print([i[:2] for i in l])
</code></pre>
</div>
<span class="comment-copy">Slicing would be more general, but this works. +1</span>
<span class="comment-copy">You can do <code>*_</code> instead of <code>_, _</code></span>
<span class="comment-copy">@MadPhysicist that's useful, thank you.</span>
<span class="comment-copy">Looks like OP is using Py3. This is clearly Py2.</span>
<span class="comment-copy">Now it's 3.x :)</span>
<span class="comment-copy">Nice modification :)</span>
