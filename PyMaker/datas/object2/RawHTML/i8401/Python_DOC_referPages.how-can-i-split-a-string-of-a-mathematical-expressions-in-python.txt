<div class="post-text" itemprop="text">
<p>I made a program which convert infix to postfix in python. The problem is when I introduce the arguments.
If i introduce something like this: (this will be a string)</p>
<pre><code>( ( 73 + ( ( 34 - 72 ) / ( 33 - 3 ) ) ) + ( 56 + ( 95 - 28 ) ) )
</code></pre>
<p>it will split it with .split() and the program will work correctly.
But I want the user to be able to introduce something like this:</p>
<pre><code>((73 + ( (34- 72 ) / ( 33 -3) )) + (56 +(95 - 28) ) )
</code></pre>
<p>As you can see I want that the blank spaces can be trivial but the program continue splitting the string by parentheses, integers (not digits) and operands.</p>
<p>I try to solve it with a <code>for</code> but I don't know how to catch the whole number (73 , 34 ,72)  instead one digit by digit (7, 3 , 3 , 4 , 7 , 2)</p>
<p>To sum up, what I want is split a string like <code>((81 * 6) /42+ (3-1))</code>  into:</p>
<pre><code>[(, (, 81, *, 6, ), /, 42, +, (, 3, -, 1, ), )]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Tree with <code>ast</code></h1>
<p>You could use <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer"><code>ast</code></a> to get a tree of the expression :</p>
<pre><code>import ast

source = '((81 * 6) /42+ (3-1))'
node = ast.parse(source) 

def show_children(node, level=0):
    if isinstance(node, ast.Num):
        print(' ' * level + str(node.n))
    else:
        print(' ' * level + str(node))
    for child in ast.iter_child_nodes(node):
        show_children(child, level+1)

show_children(node)
</code></pre>
<p>It outputs :</p>
<pre><code>&lt;_ast.Module object at 0x7f56abbc5490&gt;
 &lt;_ast.Expr object at 0x7f56abbc5350&gt;
  &lt;_ast.BinOp object at 0x7f56abbc5450&gt;
   &lt;_ast.BinOp object at 0x7f56abbc5390&gt;
    &lt;_ast.BinOp object at 0x7f56abb57cd0&gt;
     81
     &lt;_ast.Mult object at 0x7f56abbd0dd0&gt;
     6
    &lt;_ast.Div object at 0x7f56abbd0e50&gt;
    42
   &lt;_ast.Add object at 0x7f56abbd0cd0&gt;
   &lt;_ast.BinOp object at 0x7f56abb57dd0&gt;
    3
    &lt;_ast.Sub object at 0x7f56abbd0d50&gt;
    1
</code></pre>
<p>As @user2357112 wrote in the comments : <code>ast.parse</code> interprets Python syntax, not mathematical expressions. <code>(1+2)(3+4)</code> would be parsed as a function call and list comprehensions would be accepted even though they probably shouldn't be considered a valid mathematical expression.</p>
<h1>List with a regex</h1>
<p>If you want a flat structure, a regex could work :</p>
<pre><code>import re

number_or_symbol = re.compile('(\d+|[^ 0-9])')
print(re.findall(number_or_symbol, source))
# ['(', '(', '81', '*', '6', ')', '/', '42', '+', '(', '3', '-', '1', ')', ')']
</code></pre>
<p>It looks for either :</p>
<ul>
<li>multiple digits</li>
<li>or any character which isn't a digit or a space</li>
</ul>
<p>Once you have a list of elements, you could check if the syntax is correct, for example with a <a href="https://docs.python.org/2/tutorial/datastructures.html#using-lists-as-stacks" rel="nofollow noreferrer"><code>stack</code></a> to check if parentheses are matching, or if every element is a known one.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to implement a very simple tokenizer for your input. You have the following types of tokens:</p>
<ul>
<li>(</li>
<li>)</li>
<li>+</li>
<li>-</li>
<li>*</li>
<li>/</li>
<li>\d+</li>
</ul>
<p>You can find them in your input string separated by all sorts of white space.</p>
<p>So a first step is to process the string from start to finish, and extract these tokens, and then do your parsing on the tokens, rather than on the string itself.</p>
<p>A nifty way to do this is to use the following regular expression: <code>'\s*([()+*/-]|\d+)'</code>. You can then:</p>
<pre><code>import re

the_input='(3+(2*5))'
tokens = []
tokenizer = re.compile(r'\s*([()+*/-]|\d+)')
current_pos = 0
while current_pos &lt; len(the_input):
  match = tokenizer.match(the_input, current_pos)
  if match is None:
     raise Error('Syntax error')
  tokens.append(match.group(1))
  current_pos = match.end()
print(tokens)
</code></pre>
<p>This will print <code>['(', '3', '+', '(', '2', '*', '5', ')', ')']</code></p>
<p>You could also use <code>re.findall</code> or <code>re.finditer</code>, but then you'd be skipping non-matches, which are syntax errors in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>It actual would be pretty trivial to hand-roll a simple expression tokenizer. And I'd think you'd learn more that way as well. </p>
<p>So for the sake of education and learning, Here is a trivial expression tokenizer implementation which can be extended. It works based upon the <a href="https://en.wikipedia.org/wiki/Maximal_munch" rel="noreferrer">"maximal-much"</a> rule. This means it acts "greedy", trying to consume as many characters as it can to construct each token.</p>
<p>Without further ado, here is the tokenizer:</p>
<pre><code>class ExpressionTokenizer:
    def __init__(self, expression, operators):
        self.buffer = expression
        self.pos = 0
        self.operators = operators

    def _next_token(self):
        atom = self._get_atom()

        while atom and atom.isspace():
            self._skip_whitespace()
            atom = self._get_atom()

        if atom is None:
            return None
        elif atom.isdigit():
            return self._tokenize_number()
        elif atom in self.operators:
            return self._tokenize_operator()
        else:
            raise SyntaxError()

    def _skip_whitespace(self):
        while self._get_atom():
            if self._get_atom().isspace():
                self.pos += 1
            else:
                break

    def _tokenize_number(self):
        endpos = self.pos + 1
        while self._get_atom(endpos) and self._get_atom(endpos).isdigit():
            endpos += 1
        number = self.buffer[self.pos:endpos]
        self.pos = endpos
        return number

    def _tokenize_operator(self):
        operator = self.buffer[self.pos]
        self.pos += 1
        return operator

    def _get_atom(self, pos=None):
        pos = pos or self.pos
        try:
            return self.buffer[pos]
        except IndexError:
            return None

    def tokenize(self):
        while True:
            token = self._next_token()
            if token is None:
                break
            else:
                yield token
</code></pre>
<p>Here is a demo the usage:</p>
<pre><code>tokenizer = ExpressionTokenizer('((81 * 6) /42+ (3-1))', {'+', '-', '*', '/', '(', ')'})
for token in tokenizer.tokenize():
    print(token)
</code></pre>
<p>Which produces the output:</p>
<pre><code>(
(
81
*
6
)
/
42
+
(
3
-
1
)
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quick regex answer:
<code>re.findall(r"\d+|[()+\-*\/]", str_in)</code></p>
<p>Demonstration:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; str_in = "((81 * 6) /42+ (3-1))"
&gt;&gt;&gt; re.findall(r"\d+|[()+\-*\/]", str_in)
['(', '(', '81', '*', '6', ')', '/', '42', '+', '(', '3', '-', '1', 
')', ')']
</code></pre>
<p>For the nested parentheses part, you can use a stack to keep track of the level.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use <code>re</code> module, you can try this:</p>
<pre><code>s="((81 * 6) /42+ (3-1))"

r=[""]

for i in s.replace(" ",""):
    if i.isdigit() and r[-1].isdigit():
        r[-1]=r[-1]+i
    else:
        r.append(i)
print(r[1:])
</code></pre>
<p>Output:</p>
<pre><code>['(', '(', '81', '*', '6', ')', '/', '42', '+', '(', '3', '-', '1', ')', ')']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This does not provide quite the result you want but might be of interest to others who view this question. It makes use of the <strong>pyparsing</strong> library.</p>
<pre><code># Stolen from http://pyparsing.wikispaces.com/file/view/simpleArith.py/30268305/simpleArith.py
# Copyright 2006, by Paul McGuire
# ... and slightly altered

from pyparsing import *

integer = Word(nums).setParseAction(lambda t:int(t[0]))
variable = Word(alphas,exact=1)
operand = integer | variable

expop = Literal('^')
signop = oneOf('+ -')
multop = oneOf('* /')
plusop = oneOf('+ -')
factop = Literal('!')

expr = operatorPrecedence( operand,
    [("!", 1, opAssoc.LEFT),
     ("^", 2, opAssoc.RIGHT),
     (signop, 1, opAssoc.RIGHT),
     (multop, 2, opAssoc.LEFT),
     (plusop, 2, opAssoc.LEFT),]
    )

print (expr.parseString('((81 * 6) /42+ (3-1))'))
</code></pre>
<p>Output:</p>
<pre><code>[[[[81, '*', 6], '/', 42], '+', [3, '-', 1]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using grako:</p>
<pre><code>start = expr $;
expr = calc | value;
calc = value operator value;
value = integer | "(" @:expr ")" ;
operator = "+" | "-" | "*" | "/";
integer = /\d+/;
</code></pre>
<p>grako transpiles to python. </p>
<p>For this example, the return value looks like this:</p>
<pre><code>['73', '+', ['34', '-', '72', '/', ['33', '-', '3']], '+', ['56', '+', ['95', '-', '28']]]
</code></pre>
<p>Normally you'd use the generated semantics class as a template for further processing.</p>
</div>
<div class="post-text" itemprop="text">
<p>To provide a more verbose regex approach that you could easily extend:</p>
<pre><code>import re

solution = []
pattern = re.compile('([\d\.]+)')

s = '((73 + ( (34- 72 ) / ( 33 -3) )) + (56 +(95 - 28) ) )'

for token in re.split(pattern, s):
    token = token.strip()
    if re.match(pattern, token):
        solution.append(float(token))
        continue
    for character in re.sub(' ', '', token):
        solution.append(character)
</code></pre>
<p>Which will give you the result:</p>
<pre><code> solution = ['(', '(', 73, '+', '(', '(', 34, '-', 72, ')', '/', '(', 33, '-', 3, ')', ')', ')', '+', '(', 56, '+', '(', 95, '-', 28, ')', ')', ')']
</code></pre>
</div>
<span class="comment-copy">The word for what you're doing is "tokenizing" - I've replaced your <a href="https://stackoverflow.com/questions/tagged/list">list</a> tag with <a href="https://stackoverflow.com/questions/tagged/tokenize">tokenize</a>.</span>
<span class="comment-copy">regex isn't that good for nested brackets. grako is good but may be heavyweight if this is all you need to do. I like grako because you end up with readable code.</span>
<span class="comment-copy">Thanks for the question, it helped me reach the silver Python badge!</span>
<span class="comment-copy">Have a look at <a href="http://docs.sympy.org/dev/modules/parsing.html" rel="nofollow noreferrer"><code>sympy</code>'s parsing</a></span>
<span class="comment-copy">@MichaelGrazebrook It's still reasonable to use regex to get the tokens, and then you can validate the brackets in a later stage (maybe with a parser library, maybe with a hand-written recursive descent or shunting yard parser)</span>
<span class="comment-copy">Watch out - <code>ast.parse</code> parses <i>Python</i> syntax, not mathematical expressions. For example, <code>(1+2)(3+4)</code> gets parsed as a function call, <code>3^4</code> is treated as XOR, and <code>[x**2 for x in range(5)]</code> is treated as a perfectly ordinary input instead of nonsense that should be rejected.</span>
<span class="comment-copy">I've seen calculators which were pretty picky about leaving <code>*</code> out with parens but I cannot remember any concrete example. AFAIK, <code>^</code>  also isn't used by every single calculator. Still, you make a very good point. I tried to integrate it into the answer. Thanks</span>
<span class="comment-copy">@EricDuminil oops. I should have used = instead of += when updating current_pos, as match.end() is relative to the whole string, not current_pos. I've also added an example.</span>
<span class="comment-copy">It works fine now. <code>input</code> shouldn't be used as a variable name, though.</span>
<span class="comment-copy">@EricDuminil Thanks for your reminding, I fixed the index error by adding a empty string.</span>
<span class="comment-copy">Pyparsing is no longer hosted on wikispaces.com. Go to <a href="https://github.com/pyparsing/pyparsing" rel="nofollow noreferrer">github.com/pyparsing/pyparsing</a></span>
