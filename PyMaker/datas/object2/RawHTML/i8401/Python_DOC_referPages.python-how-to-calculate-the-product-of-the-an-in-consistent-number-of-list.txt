<div class="post-text" itemprop="text">
<p>I have a question, for example I have lists</p>
<pre><code>a = [1,2,3,4,5,6,7,8,9,10]
b = [10,9,8,7,6,5,4,3,2,1]
c = [3,4,5,6,10,4,6,7,4,3]
d = [5,4,5,6,8,4,3,2,4,50]
</code></pre>
<p>I want to calculate the product of these four list.</p>
<p>Actually maybe it seems simply, we just write</p>
<pre><code>e = []
for i in range(0, len(a)):
   e.append(a[i] * b[i] * c[i] * d[i])
</code></pre>
<p>but the problem is, what if I have an in consistent number of list? sometimes I have 1 lists, 8 lists, 4 lists, or maybe 25 lists. I want to write a code that calculate the product of an in consistent number of list in same index automatically.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can put your lists in a bigger list (list of lists):</p>
<pre><code>super_list = [a, b, c, d] # add any more lists you want
</code></pre>
<p>and then:</p>
<pre><code>result = []
for i in xrange(0, len(a)):
    p = 1
    for sub_list in super_list:
        p *= sub_list[i]
    result.append(p)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>zip</code> these lists and use <code>reduce</code> to multiply the elements:</p>
<pre><code>a = [1,2,3,4,5,6,7,8,9,10]
b = [10,9,8,7,6,5,4,3,2,1]
c = [3,4,5,6,10,4,6,7,4,3]
d = [5,4,5,6,8,4,3,2,4,50]

print([reduce(lambda x,y:x*y,i) for i in zip(a,b,c,d)])
</code></pre>
<p>Result:</p>
<pre><code>[150, 288, 600, 1008, 2400, 480, 504, 336, 288, 1500]
</code></pre>
<p>If you're using Python3.x, you need <code>from functools import reduce</code> to import <code>reduce</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this</p>
<pre><code>map(lambda x: reduce(lambda y, z: y * z, x), zip(a, b, c, d))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could write a function that can be overloaded with an arbitrary number of arguments and use that to do the multiplication. Something like:</p>
<pre><code>def list_product(*args):
  if len(args) == 0: #need at least one argument!
    return []
  arg_length = len(args[0])
  for arg in args: #make sure all arrays have the same length
    if arg_length != len(arg):
      return []

  out = []
  for i in range(0, arg_length):
    temp = 1
    for arr in args:
      temp *= arr[i]
    out.append(temp)
  return out  

print(list_product([1,2,3],[4,5,6])) 
# [4, 10, 18]
</code></pre>
<p>This has the advantage of being reusable. It seems like you may want to use this in a variety of places with a variety of arrays. Once you have this function, it's easy to use it with other arrays.</p>
<pre><code>a = [1,2,3,4]
b = [4,5,6,7]
c = [1,2,2,1]
list_product(a,b,c) # gives [4,20,36,28]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>*args</code> parameter mechanism to collect all the lists into one tuple of all the lists:</p>
<pre><code>def product_of_lists(*args):

    result = []
</code></pre>
<p>Now you have a way to call a function to do what you want.</p>
<p>Next, use <code>zip</code> to iterate over each value in each list, in turn. That is, <code>zip(a,b,c)</code> will produce a tuple of (a[0], b[0], c[0]), then another tuple of (a<a href="https://docs.python.org/3/library/functools.html?highlight=functools.reduce#functools.reduce" rel="nofollow noreferrer">1</a>, b<a href="https://docs.python.org/3/library/functools.html?highlight=functools.reduce#functools.reduce" rel="nofollow noreferrer">1</a>, c<a href="https://docs.python.org/3/library/functools.html?highlight=functools.reduce#functools.reduce" rel="nofollow noreferrer">1</a>), etc.</p>
<pre><code>    for t in zip(*args):
</code></pre>
<p>Using the <code>*args</code> in this context flattens the tuple of args into a bunch of separate parameters, as though you had written <code>zip(args[0], args[1], ...)</code>.</p>
<p>At this point, <code>t</code> is a tuple that you need to multiply.</p>
<p>You can use <a href="https://docs.python.org/3/library/functools.html?highlight=functools.reduce#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> to apply a function that accumulates a value across an iterable (and tuples are iterables!). Like so:</p>
<pre><code>functools.reduce(lambda a,b: calc(a,b), t)
</code></pre>
<p>This would apply the lambda to each pair of values: (t[0], t<a href="https://docs.python.org/3/library/functools.html?highlight=functools.reduce#functools.reduce" rel="nofollow noreferrer">1</a>), then (result-of-previous, t[n]), etc.</p>
<p>So, in your case, you can write your own lambda function to do multiplication:</p>
<pre><code>        r = functools.reduce(lambda a,b: a*b, t)
</code></pre>
<p>Or, you could import operator and use the operator.mul function, which does exactly this:</p>
<pre><code>        r = functools.reduce(operator.mul, t)
</code></pre>
<p>Then capture the result:</p>
<pre><code>        result.append(r)

    return result
</code></pre>
<p>Putting it all together:</p>
<pre><code>import functools

def product_of_lists(*args):
    result = []
    for t in zip(*args):
        r = functools.reduce(lambda a,b: a*b, t)
        result.append(r)
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With Python 3, define a product function (useful in many cases):</p>
<pre><code>def rp(seq):
    return 1 if len(seq)==0 else seq[0]*rp(seq[1:])
</code></pre>
<p>then compute the result directly</p>
<pre><code>result = [rp(x) for x in zip(a,b,c,d)]
</code></pre>
<p>or by using a list of lists:</p>
<pre><code>super_list = [a,b,c,d]
result = [rp(x) for x in zip(*super_list)]
</code></pre>
</div>
<span class="comment-copy">Many thanks, but maybe a typo 'xrange' should be 'range'</span>
<span class="comment-copy">@ArifDarmawan Python 2 vs. Python 3. <code>xrange</code> is appropriate for Python 2.</span>
<span class="comment-copy">@mitch I am using python 3</span>
<span class="comment-copy">Sure. I'm just saying, that's why they opted for <code>xrange</code> - they are using Python 2.</span>
