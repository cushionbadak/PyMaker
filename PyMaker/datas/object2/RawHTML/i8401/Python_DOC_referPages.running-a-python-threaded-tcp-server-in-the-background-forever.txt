<div class="post-text" itemprop="text">
<p>Being rather new to socket programming and threading in general, my issue might be stemming from a misunderstanding of how they work. I am trying to create something that acts as both a client and a server using threading.</p>
<p>Following:
<a href="https://docs.python.org/3/library/socketserver.html#asynchronous-mixins" rel="nofollow noreferrer">https://docs.python.org/3/library/socketserver.html#asynchronous-mixins</a></p>
<p>I created a client class to go with the server and executed both from a main class. The server supposedly launches normally and doesn't give any errors but when I try to connect from the client, it fails on the following:</p>
<pre><code>    # In client connection
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.connect((ip, port))
</code></pre>
<p>the error I am getting is:</p>
<pre><code>Traceback (most recent call last):
  File "./&lt;project&gt;", line 61, in &lt;module&gt;
    client.start_client(serverInfo)
  File "/home/&lt;username&gt;/Documents/Github/project/client.py", line 54, in &lt;startclient&gt;
    &lt;connectionMethod&gt;(cmd)
  File "/home/&lt;username&gt;/Documents/Github/project/client.py", line 112, in &lt;connectionMethod&gt;
    sock.connect((remoteHOST,remotePORT))
    ConnectionRefusedError: [Errno 111] Connection refused
</code></pre>
<p>Even when I modify the server from the code in the referenced python page (just to run on a specific port, 1234), and try to connect to that port with </p>
<pre><code>with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    sock.connect(('127.0.0.1',1234))
    sock.sendall('Test message')
</code></pre>
<p>I get the same problem</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
ConnectionRefusedError: [Errno 111] Connection refused
</code></pre>
<p>Why is the server refusing connections? No firewall rules or iptables are in place, running the example that has the client and socket together as is from the site works but even removing the <code>server.shutdown()</code> line it still kills itself immediately.</p>
<p>Am I missing something?</p>
<p>The behaviour I am expecting is:</p>
<pre><code>./programA
&lt;server starts on port 30000&gt;
</code></pre>
<h1> </h1>
<pre><code>./programB
&lt;server starts on port 30001&gt;
&lt;client starts&gt;
</code></pre>
<p>--- input/output ---</p>
<p>FROM CLIENT A:</p>
<pre><code>/connect 127.0.0.1 30001
CONNECTED TO 127.0.0.1 30001
</code></pre>
<p>ON CLIENT B:</p>
<pre><code>CONNECTION FROM 127.0.0.1 30000
</code></pre>
<p>Basically once the clients connect the first time they can communicate with each other by typing into a prompt which just creates another socket targeting the 'remote' IP and PORT to send off the message (instant messaging). The sockets are afterwords left to close because they aren't actually responsible for receiving anything back.</p>
<p>I would appreciate any help I can get on this.</p>
</div>
<div class="post-text" itemprop="text">
<p><br/>
The reason why even removing <code>server.shutdown()</code> is not helping is because when the main thread exists, the server thread exists immediately because you probably have not removed <code>server_thread.daemon=True</code>. <br/>If you change it to <code>server_thread.daemon=False</code> then also even after main thread terminates, the program will not return to terminal immediately but it will not kill the server either even after last line of the main program gets executed.<br/>I am not sure if you can run a server completely in the background forever using simple python script but I do not think it is possible.<br/><br/>You can call the script with '&amp;' option: <code>python3 &lt;file&gt;.py &amp;</code> which will run the python script in background(this works with Ubuntu at least)(<a href="https://askubuntu.com/questions/396654/how-to-run-the-python-program-in-the-background-in-ubuntu-machine">https://askubuntu.com/questions/396654/how-to-run-the-python-program-in-the-background-in-ubuntu-machine</a>) but it probably is not the answer you are looking for.</p>
</div>
<div class="post-text" itemprop="text">
<p>Incidentally, I've made something of a breakthrough. While I'm not entirely sure <em>why</em> it does it, threadedTCPServer (as it is on the python docs) is basically unusable for this purpose and won't act right while actually in a thread. Instead I opted to manually build a socket server like so:
</p>
<pre><code>import threading
import socket

def simpleServer():
    HOST = '127.0.0.1'
    PORT = 3000
    sock = socket.socket()
    sock.bind((HOST,PORT))

    s.listen(5)
    while True:
        conn, addr = s.accept()
        msg = str(conn.recv(1024),'utf8')
        c.send(bytes('GOT: {0}'.format(msg),'utf8')
        c.close()

if __name__ == '__main__':

    server_thread = threading.Thread(target=simpleServer)
    server_thread.start()

    # Make connections based on '&lt;ip&gt;:&lt;port&gt;:&lt;msg&gt;'
    while True:
        cmd = input('&gt;&gt; ')

        try:
            parts = cmd.split(':')
            ip = parts[0]
            port = parts[1]
            msg = parts[2]

            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.connect((ip,port))
                sock.sendall(bytes(msg,'utf8'))
                print(str(sock.recv(1024),'utf8'))

        except Exception as e:
            print(e)
</code></pre>
<p>The code is pretty basic (and probably not the best) but I have just tested it and it is definitely working for now. I adapted this code based on a solution I saw in: <a href="https://stackoverflow.com/questions/16130786/why-am-i-getting-the-error-connection-refused-in-python-sockets">Why am I getting the error "connection refused" in Python? (Sockets)</a></p>
<p>I do have to readapt a large portion of code but I think it should definitely work, I'll report back after implementation.</p>
</div>
<span class="comment-copy">You could either make each client also a server , or let the main server handle all connections by specifying a client identifier</span>
<span class="comment-copy">@t.m.adam I phrased it poorly but each client <i>was</i> also a server. Essentially the client prompt was a class and threaded server was a class. The issue came from the threadedTCPServer socketserver example as given on the python docs. It simply does not work for actually listening beyond maybe an instant. I managed to solve my problem by using standard sockets and binding instead. I'm not sure if there are any problems with not using a "ThreadingMixIn" or their specific version in socketserver but so far I have not encountered any. I will mark my solution below for now since it seems to work.</span>
<span class="comment-copy">Yeah not quite what I was hoping for. Essentially its an instant messaging program, which I have seen done but I'm not quite sure how they got the clients to be the only things you have to start other than making each client also the server. The server portion of the programs handles collection and storage of information that is crucial for the operation.</span>
<span class="comment-copy">I did try to remove that daemon line (I forgot to mention it) and the result is that the server "stays up" but still cannot be connected to. With threads I think though it <i>should</i> be possible in theory as the server would execute on its own thread while the client executes on another.</span>
