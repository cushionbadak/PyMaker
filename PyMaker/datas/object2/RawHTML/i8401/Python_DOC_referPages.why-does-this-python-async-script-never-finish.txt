<div class="post-text" itemprop="text">
<p>I created a MCVE example of a much larger code base that I am working on, so some things look to be a funky way of doing things, but they are just the minimal versions, so not everything makes sense as far as WHY I am doing it this way. I already know some work-arounds, and at this point am mostly just curious as to why I am seeing this behaviour. </p>
<p>I have the following script which has an async function that waits for a future. The script then intercepts a signal to set the future result:</p>
<pre><code>import asyncio
import time
import signal

f = asyncio.Future()
loop = asyncio.get_event_loop()

async def wait_till_signal():
    await f

def send_stop():
    print('stopping', time.time())
    f.set_result(True)
    print('sent')
    print(f.result())

def handle_signal(s, a):
    print('sending stop', time.time())
    send_stop()

signal.signal(signal.SIGINT, handle_signal)

loop.run_until_complete(wait_till_signal())
</code></pre>
<p>This script correctly gets the interrupt, and appears to set the future correctly, but for some reason the script never terminates.</p>
<p>To reproduce for you, just run the script, then hit ctrl+c. For some reason it never stops.</p>
<p>Now here is where it gets weird. If you add the following to the top of the script (after defining the loop), then the script stops just fine.</p>
<pre><code>async def do_nothing_useful():
     for i in range(30):
         await asyncio.sleep(1)

loop.create_task(do_nothing_useful())
</code></pre>
<p>Why is the coroutine not getting the future in the first case, but it gets it correctly in the second case?</p>
<hr/>
<p>Also, another weird thing is that if you set the <code>send_stop</code> function to be async, and add it as a task, it never gets called. (This follows the same behaviour as above. If the do_nothing_useful() function is on the loop, everything works fine, but without it, it doesnt)</p>
<p>Here is the version where the send_stop is never called:</p>
<pre><code>import asyncio
import time
import signal

f = asyncio.Future()

async def wait_till_signal():
    await f

async def send_stop():
    # this is async only because we are trying to try out crazy things
    print('stopping', time.time())
    f.set_result(True)
    print('sent')
    print(f.result())


def handle_signal(s, a):
    print('sending stop', time.time())
    loop.create_task(send_stop())


signal.signal(signal.SIGINT, handle_signal)

loop = asyncio.get_event_loop()
loop.run_until_complete(wait_till_signal())
print('done')
</code></pre>
<p>and the script never prints <code>stopping</code>.</p>
<hr/>
<p>I have tried this on python 3.5.3 and 3.6 on linux</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct method to add a signal handler that wakes up a loop is by using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.add_signal_handler" rel="nofollow noreferrer"><code>loop.add_signal_handler</code></a>. This will make sure <code>select()</code> wakes up to handle the signal.</p>
</div>
<span class="comment-copy">just out of curiosity, what operating system are you running this on?</span>
<span class="comment-copy">@user1767754 linux</span>
<span class="comment-copy">Yep. That works great. Any idea why setting the result isnt triggering anything though?</span>
