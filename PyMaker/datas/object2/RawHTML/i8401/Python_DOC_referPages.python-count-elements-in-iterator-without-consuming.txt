<div class="post-text" itemprop="text">
<p>Given an iterator <code>it</code>, I would like a function <code>it_count</code> that returns the count of elements that iterator produces, without destroying the iterator.  For example:</p>
<pre><code>ita = iter([1, 2, 3])
print(it_count(ita))
print(it_count(ita))
</code></pre>
<p>should print</p>
<pre><code>3
3
</code></pre>
<p>It has been pointed out that this may not be a well-defined question for <em>all</em> iterators, so I am not looking for a completely general solution, but it should function as anticipated on the example given.</p>
<hr/>
<p>Okay, let me clarify further to my specific case.  Given the following code:</p>
<pre><code>ita = iter([1, 2, 3])
itb, itc = itertools.tee(ita)
print(sum(1 for _ in itb))
print(sum(1 for _ in itc))
</code></pre>
<p>...can we write the <code>it_count</code> function described above, so that it will function in this manner?  Even if the answer to the question is "That cannot be done," that's still a perfectly valid answer.  It doesn't make the question bad.  And the proof that it is impossible would be far from trivial...</p>
</div>
<div class="post-text" itemprop="text">
<p>Not possible. Until the iterator has been completely consumed, it doesn't <em>have</em> a concrete element count.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only way to get the length of an arbitary iterator is by iterating over it, so the basic question here is ill-defined. You can't get the length of any iterator without iterating over it. </p>
<p>Also the iterator itself may change it's contents while being iterated over, so the count may not be constant anyway.</p>
<hr/>
<p>But there are possibilities that might do what you ask, be warned none of them is foolproof or really efficient:</p>
<p>When using python 3.4 or later you can use <a href="https://docs.python.org/library/operator.html#operator.length_hint" rel="nofollow noreferrer"><code>operator.length_hint</code></a> and hope the iterator supports it (be warned: not many iterators do! And it's only meant as a hint, the actual length might be different!):</p>
<pre><code>&gt;&gt;&gt; from operator import length_hint

&gt;&gt;&gt; it_count = length_hint

&gt;&gt;&gt; ita = iter([1, 2, 3])
&gt;&gt;&gt; print(it_count(ita))
3
&gt;&gt;&gt; print(it_count(ita))
3
</code></pre>
<hr/>
<p>As alternative: You can use <a href="https://docs.python.org/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a> but read the documentation of that carefully before using it. It may solve your issue but it won't really solve the underlying problem.</p>
<pre><code>import itertools

def it_count(iterator):
    return sum(1 for _ in iterator)

ita = iter([1, 2, 3])
it1, it2 = itertools.tee(ita, 2)
print(it_count(it1))  # 3
print(it_count(it2))  # 3
</code></pre>
<p>But this is less efficient (memory and speed) than casting it to a <code>list</code> and using <code>len</code> on it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have not been able to come up with an exact solution (because iterators may be immutable types), but here are my best attempts.  I believe the second should be faster, according to the <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer">documentation</a> (final paragraph of <code>itertools.tee</code>).</p>
<p><strong>Option 1</strong></p>
<pre><code>def it_count(it):
   tmp_it, new_it = itertools.tee(it)
   return sum(1 for _ in tmp_it), new_it
</code></pre>
<p><strong>Option 2</strong></p>
<pre><code>def it_count2(it):
   lst = list(it)
   return len(lst), lst
</code></pre>
<p>It functions well, but has the slight annoyance of returning the pair rather than simply the count.</p>
<pre><code>ita = iter([1, 2, 3])
count, ita = it_count(ita)
print(count)

Output: 3

count, ita = it_count2(ita)
print(count)

Output: 3

count, ita = it_count(ita)
print(count)

Output: 3

print(list(ita))

Output: [1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no generic way to do what you want. An iterator may not have a well defined length (e.g. <code>itertools.count</code> which iterates forever). Or it might have a length that's expensive to calculate up front, so it won't let you know how far you have to go until you've reached the end (e.g. a file object, which can be iterated yielding lines, which are not easy to count without reading the whole file's contents).</p>
<p>Some kinds of iterators might implement a <code>__length_hint__</code> method that returns an estimated length, but that length may not be accurate. And not all iterators will implement that method at all, so you probably can't rely upon it (it does work for list iterators, but not for many others).</p>
<p>Often the best way to deal with the whole contents of an iterator is to dump it into a list or other container. After you're done doing whatever operation you need (like calling <code>len</code> on it), you can iterate over the list again. Obviously this requires the iterator to be finite (and for all of its contents to fit into memory), but that's the limitation you have to deal with.</p>
<p>If you only need to peek ahead by a few elements, you might be able to use <code>itertools.tee</code>, but it's no better than dumping into a list if you need to consume the whole contents (since it keeps the values seen by one of its returned iterators but another in a data structure similar to a <code>deque</code>). It wouldn't be any use for finding the length of the iterator.</p>
</div>
<span class="comment-copy">What have you tried so far? What's tripping you up?</span>
<span class="comment-copy">Instead of giving <i>abstract</i> examples (which obviously leads to people telling you that this can't be done for the <i>general</i> case), can you please describe what specific kind of iterator you're actually dealing with, and why you need to do this?</span>
<span class="comment-copy">Please don't change the original intention of the question, please post a new question instead if you have "follow-up"-questions.</span>
<span class="comment-copy">It's not a follow-up or modification of the original question.  It's a clarification for people who didn't understand the intent.</span>
<span class="comment-copy">The major point of an iterator is that it is executed lazily, you get elements from it as they are needed and doesn't necessarily have a well defined length (so the question isn't ill-defined, the functionality you are asking for is ill-defined) If you were really constructing your iterator from a list literal you'd just get the <code>len</code> of the list so what iterator are you actually wondering about?</span>
<span class="comment-copy">Okay, then I only require the solution to work for deterministic iterators (or other technical conditions of relevant memory modification, etc...)</span>
<span class="comment-copy">"you need to know in advance how many "subiterators" you need" - it's poorly documented, but <a href="http://stackoverflow.com/questions/30232531/in-python-can-i-lazily-generate-copies-of-an-iterator-using-tee">you can actually generate all the tees you want</a> as long as you kept a copy you didn't advance.</span>
<span class="comment-copy">ah, yeah, totally forgot that <code>tee</code> supports <code>copy</code>.</span>
<span class="comment-copy">I was looking into <code>itertools.tee</code>, however, the original iterator will still be consumed.</span>
<span class="comment-copy">@Apollys Then you need <a href="http://stackoverflow.com/a/43400952/5393381">user2357112</a>s answer: It's not possible.</span>
<span class="comment-copy">This may work in some cases but just to give you two examples where it probably won't work: <code>ita = itertools.count()</code> or <code>l = [1, 2, 3]; ita = map(l.append, l)</code>? Note that these approaches technically "consume" the iterator.</span>
<span class="comment-copy">Of course there's no answer if the generator continues "infinitely," that's why I clarified the question.</span>
<span class="comment-copy">But based on your example you could just use <code>operator.length_hint</code>. What "subset" of iterators are we talking about?</span>
<span class="comment-copy">My clarification does elucidate that... ones for which cloning the iterator using <code>tee</code> and then computing <code>sum(1 for _ in cloned_it)</code> works.</span>
<span class="comment-copy"><code>tee</code> doesn't actually use a <code>deque</code> - it stores elements in a specialized <a href="https://en.wikipedia.org/wiki/Unrolled_linked_list" rel="nofollow noreferrer">unrolled, singly-linked list</a>. See <code>teedataobject</code> and <code>teeobject</code> in <a href="https://github.com/python/cpython/blob/master/Modules/itertoolsmodule.c#L378" rel="nofollow noreferrer"><code>Modules/itertoolsmodule.c</code></a>.</span>
<span class="comment-copy">You're right that it's not exactly a <code>deque</code>, but the linked list implementation for the <code>teeobject</code> isn't that different than <a href="https://github.com/python/cpython/blob/master/Modules/_collectionsmodule.c#L71" rel="nofollow noreferrer">the implementation of <code>deque</code></a> which uses a doubly linked list of 64-value blocks.</span>
