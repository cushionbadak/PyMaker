<div class="post-text" itemprop="text">
<p>I have this simple python script called <code>myMain.py</code> to execute another python program automatically with incremental number, and I'm running it on CentOS 7:</p>
<pre><code>#!/usr/bin/python

import os
import sys
import time

def main():
    step_indicator = ""
    arrow = "&gt;"
    step = 2
    try:
        for i in range(0,360, step):
            step_percentage = float(i)/360.0 * 100
            if i % 10 == 0:
                step_indicator += "="
            os.system("python myParsePDB.py -i BP1.pdb -c 1 -s %s" % step)
            print("step_percentage%s%s%.2f" % (step_indicator,arrow,step_percentage)+"%")
    except KeyboardInterrupt:
        print("Stop me!")
        sys.exit(0)


if __name__ == "__main__":
    main()
</code></pre>
<p>For now I only know this script is single thread safe, but I can't terminate it with <code>Ctrl+C</code> keyboard interruption.</p>
<p>I have read some relative questions: such as <a href="https://stackoverflow.com/a/11816038/3781320">Cannot kill Python script with Ctrl-C</a> and <a href="https://stackoverflow.com/q/1364173/3781320">Stopping python using ctrl+c</a> I realized that <code>Ctrl+Z</code> does not kill the process, it only pauses the process and keep the process in background. <code>Ctrl+Break</code> does work for my case either, I think it only terminates my main thread but keeps the child process. </p>
<p>I also noticed that calling <code>os.system()</code> will spawn a child process from the current executing process. At the same time, I also have <code>os</code> file I/O functions and <code>os.system("rm -rf legacy/*")</code> will be invoked in <code>myParsePDB.py</code> which means this <code>myParsePDB.py</code> child process will spawn child process as well. Then, if I want to catch <code>Ctrl+C</code> in <code>myMain.py</code>, should I daemon only <code>myMain.py</code> or should I daemon each process when they spawn?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a general problem that could raise when dealing with signal handling. Python signal is not an exception, it's a wrapper of operating system signal. Therefore, signal processing in python depends on operating system, hardware and many conditions. However, how to deal with these problem is similar. </p>
<p>According to this tutorial, I'll quote the following paragraphs: <a href="https://pymotw.com/2/signal/" rel="nofollow noreferrer">signal â€“ Receive notification of asynchronous system events</a></p>
<blockquote>
<p>Signals are an operating system feature that provide a means of
  notifying your program of an event, and having it handled
  asynchronously. They can be generated by the system itself, or sent
  from one process to another. Since signals interrupt the regular flow
  of your program, it is possible that some operations (especially I/O)
  may produce error if a signal is received in the middle.</p>
<p>Signals are identified by integers and are defined in the operating
  system C headers. Python exposes the signals appropriate for the
  platform as symbols in the signal module. For the examples below, I
  will use SIGINT and SIGUSR1. Both are typically defined for all Unix
  and Unix-like systems.</p>
</blockquote>
<p>In my code:</p>
<p><code>os.system("python myParsePDB.py -i BP1.pdb -c 1 -s %s" % step)</code> inside the for loop will be executed for a bit of time and will spend some time on I/O files. If the keyboard interrupt is passing too fast and do not catch asynchronously after writing files, the signal might be blocked in operating system, so my execution will still remain the <code>try</code> clause for loop. (Errors detected during execution are called exceptions and are not unconditionally fatal: <a href="https://docs.python.org/2/tutorial/errors.html" rel="nofollow noreferrer">Python Errors and Exceptions</a>).</p>
<p>Therefore the simplest way to make them asynchonous is wait:</p>
<pre><code>try:
    for i in range(0,360, step):
        os.system("python myParsePDB.py -i BP1.pdb -c 1 -s %s" % step)
        time.sleep(0.2)
except KeyboardInterrupt:
    print("Stop me!")
    sys.exit(0)
</code></pre>
<p>It might hurt performance but it guaranteed that the signal can be caught after waiting the execution of <code>os.system()</code>. You might also want to use other sync/async functions to solve the problem if better performance is required.</p>
<p>For more unix signal reference, please also look at: <a href="http://man7.org/linux/man-pages/man7/signal.7.html" rel="nofollow noreferrer">Linux Signal Manpage</a></p>
</div>
<span class="comment-copy">is it necessary to run <code>myParsePDB</code> in a subprocess? couldn't you just write it as a normal module with functions you can call from this script instead of using <code>os.system</code>? You should be able to do <code>rm</code> functionality with <a href="https://docs.python.org/3/library/shutil.html#shutil.rmtree" rel="nofollow noreferrer"><code>shutil.rmtree</code></a></span>
<span class="comment-copy">@TadhgMcDonald-Jensen It is necessary to run <code>myParsePDB</code>. <code>rm</code> is just a tiny part in <code>myParsePDB</code>.</span>
