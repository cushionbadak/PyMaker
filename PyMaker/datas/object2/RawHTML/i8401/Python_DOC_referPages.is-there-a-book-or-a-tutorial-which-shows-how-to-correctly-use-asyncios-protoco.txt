<div class="post-text" itemprop="text">
<p>Is there a book or a tutorial which shows how to correctly use asyncio's Protocol? All the examples on the web mix IO right into protocol definition! </p>
<p>I want to write a parser which does frame decoding and converts the message to a python data structure. Once this data structure is parsed, I want to <em>pass this on to the client</em>. </p>
<pre><code>[       ]--&gt;[*protocol parser*]--&gt;[high level api]--&gt;[           ]
[network]                                            [client code]
[       ]&lt;--[*protocol parser*]&lt;--[high level api]&lt;--[           ]
</code></pre>
<p>Correspondingly, the client of the higher level API passes in a python data structure, the high level API feeds that data structure passes it to my protocl, which converts it to the correct byte/text representation and passes it on to the transport layer.</p>
<p>I'm assuming this is the purpose of abstracting out the Protocol class in the first place. I don't want to respond to the other side of the connection from within the protocol, yet this is what most web tutorials show!</p>
<p>Further, I would like to understand which high level interface is proffered in the python world, is it callbacks, stream interface or something else?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I want to write a parser which does frame decoding and converts the message to a python data structure. Once this data structure is parsed, I want to pass this on to the client.</p>
<pre><code>[       ]--&gt;[*protocol parser*]--&gt;[high level api]--&gt;[           ]
[network]                                            [client code]
[       ]&lt;--[*protocol parser*]&lt;--[high level api]&lt;--[           ]
</code></pre>
<p>Correspondingly, the client of the higher level API passes in a python data structure, the high level API feeds that data structure passes it to my protocl, which converts it to the correct byte/text representation and passes it on to the transport layer.</p>
</blockquote>
<p>You can approach a protocol implementation from two different angles:</p>
<ol>
<li><p>Use <strong>low-level</strong> <code>asyncio.Protocol</code>. For that, we have two APIs: <code>loop.create_server</code> and <code>loop.create_connection</code>. The former is used to create servers that can be exposed to the network and accept client connections (e.g. an HTTP server.) The latter can be used to implement a client (e.g. an API client, a database driver, etc).</p>
<p>The core idea of <code>Protocol</code> is pretty simple: it can implement a <code>connection_made()</code> method, that is called by <code>loop.create_server</code> or by <code>loop.create_connection</code>, once the connection is made. The protocol will receive an instance of the <code>Transport</code> object, which it can use to send data back to the client.</p>
<p>It also can implement <code>data_received()</code> method, which will be called by the event loop when there is incoming data to process. The general approach is to write a buffer abstraction for the protocol you are implementing, that can parse the data. Once the buffer has enough data to parse and process, you can either put the result into an <code>asyncio.Queue</code> or schedule some asyncio tasks.  For example:</p>
<pre><code>class MyProtocolBuffer:
    """Primitive protocol parser"""

    def __init__(self):
        self.buf = b''  # for real code use bytearray
                        # or list of memoryviews

    def feed_data(data):
        self.buf += data

    def has_complete_message(self):
        # Implement your parsing logic here...

    def read_message(self):
        # ...and here.


class MyProtocol:
    def __init__(self, loop, queue: asyncio.Queue):
        self.buffer = MyProtocolReadBuffer()

    def data_received(self, data):
        self.buffer.feed_data(data)
        while self.buffer.has_complete_message():
            message = self.buffer.read_message()
            queue.put_nowait(message)


async def main(host, port):
    queue = asyncio.Queue()

    loop = asyncio.get_event_loop()       
    transport, protocol = await loop.create_connection(
        lambda: MyProtocol(loop, queue),
        host, port)

    try:
        while True:
            message = await queue.get()
            # This is where you implement your "high level api"
            # or even "client code".
            print(f'received message {message!r}')
    finally:
        transport.close()


loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main(host, port))
finally:
    loop.close()
</code></pre>
<p><strong>Mind that this is a low-level asyncio API.</strong>  It's intended to be used by framework and library authors. For instance, asyncpg, a high-performance asyncio PostgreSQL driver uses these APIs.</p>
<p>You can read more about protocols here: <a href="https://docs.python.org/3/library/asyncio-protocol.html#protocols" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-protocol.html#protocols</a>.  A good example of successfully using these APIs is the asyncpg library: <a href="https://github.com/magicstack/asyncpg" rel="nofollow noreferrer">https://github.com/magicstack/asyncpg</a>.</p></li>
<li><p>Use <strong>high-level</strong> asyncio streams. Streams allow you to implement protocols using async/await syntax. Two main APIs: <code>asyncio.open_connection()</code> and <code>asyncio.start_server()</code>. Let's re-implement the above example using <code>open_connection()</code>:</p>
<pre><code>async def main():
    reader, writer = await asyncio.open_connection(host, port)

    message_line = await reader.readline()
    # Implement the rest of protocol parser using async/await
    # and `reader.readline()`, `reader.readuntil()`, and
    # `reader.readexactly()` methods.

    # Once you have your message you can put in an asyncio.Queue,
    # or spawn asyncio tasks to process incoming messages.

    # This is where you implement your "high level api"
    # or even "client code".

loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main(host, port))
finally:
    loop.close()        
</code></pre></li>
</ol>
<hr/>
<p>I would recommend to always draft your first implementation of some protocol using streams, especially if you are new to networking and asyncio. You can build faster code using low-level APIs, bug with streams you'll get a working program much faster and the code base will be easier to maintain.  Ideally you should just stick to using async/await and high-level asyncio APIs.</p>
</div>
<span class="comment-copy">As a SO user with 3.7 k reputation, we expect you to know what is <a href="https://stackoverflow.com/help/on-topic">off-topic</a> for StackOverflow</span>
<span class="comment-copy">Please don't remove this question. I think that the current asyncio documentation doesn't explain how to implement protocol parsers clearly, and I think that this subjects deserves to be covered in more detail on SO. Please see my answer below.</span>
<span class="comment-copy">The answer below is from a core contributor and is very relevant for lots of users. Please don't remove it.</span>
<span class="comment-copy">thanks for the detailed answer. I'm getting the feeling that asyncio Protocl has a slightly different purpose than what I expected. I thought the idea was to start to implement something like Node's stream[1] infrastructure where data coming from and going to the network can be intercepted for encoding/decoding, logging, etc.  [1]<a href="https://nodejs.org/api/stream.html#stream_implementing_a_transform_stream" rel="nofollow noreferrer">nodejs.org/api/â€¦</a></span>
