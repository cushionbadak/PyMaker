<div class="post-text" itemprop="text">
<p>What would be the best way to initialize attributes and check provided parameters when initializing a python class? Suppose that there are multiple parameters in the <code>__init__()</code> and some of them have to comply to certain rules. There is also the need to have setters and getters for some of them. I can think of the option from below. How does it look to you? Are there any better options?</p>
<p>Option: Initialize attributes <code>None</code> and call the setter, where the check is performed.</p>
<pre><code>class A(object):
    def __init__(self, p1=None, ..., pn=None):
        self._p1 = None
        ...
        self._pn = None

        if p1 is not None:
            self.p1 = p1
        ...
        if pn is not None:
            self.pn = pn

    @p1.setter
    def p1(self, p1):
        # If p1 is int we can just take it
        if isinstance(p1, int):
            self._p1 = p1
        # If p1 is str we have to obtain it differently
        elif isinstance(p1, str):
            self._p1 = self._gen_some_p_from_str(p1)
        else:
            raise Exception('Incorrect p1 type provided.')
    ...
    @pn.setter
    def pn(self, pn):
        # If pn instance of SomeOtherClass it should be also great
        if isinstance(pn, SomeOtherClass):
            if pn.great():
                self._pn = pn
            else:
                raise exception('pn not great')
        # pn can be also str, and then we should get it
        elif isinstance(pn, str):
             self._pn = self._get_some_other_p_from_str(pn)
        else:
            raise Exception('Incorrect pn type provided.')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need to run the validation on each assign, property is your way.</p>
<p>Keep in mind that this might have a performance issue when you will have many assignments(like in a loop).</p>
<p>Your issue can be solved by validate the input only on the initiation of the class, you better have a <code>clean</code> or <code>validate</code> method on your class, then call it in the end of the <code>__init__</code> func. </p>
<p>Using this method you can call your <code>clean</code> method whenever you need, and omit the call where performance are more important than the validation(This is how <a href="https://docs.djangoproject.com/en/1.10/ref/forms/validation/#cleaning-and-validating-fields-that-depend-on-each-other" rel="nofollow noreferrer">django forms</a> works).</p>
<p>In your case, your are trying to do overloading/dispatching, take a look at the <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer">docs</a></p>
</div>
<span class="comment-copy">Get rid of the checks. Write proper documentation/docstrings. From here it's garbage in -&gt; garbage out.</span>
<span class="comment-copy">Why downvoted? Please explaine</span>
<span class="comment-copy">I don't know who actually did the downvote.</span>
<span class="comment-copy">Thanks for the answer, but could you detail it a bit? I need different validation functions for different arguments and I was thinking if it is possible to remove the if in the <code>__init__()</code> and keep the <code>_*</code> at the same time.</span>
<span class="comment-copy">But then every time you will call <code>pq=something</code> your validation will apply, this might be costly when running this on multiple attributes, multiple times(like in a for loop). your can define a <code>clean</code> method so you can control when the validation occurs - you if this fits for your situation better then me,</span>
