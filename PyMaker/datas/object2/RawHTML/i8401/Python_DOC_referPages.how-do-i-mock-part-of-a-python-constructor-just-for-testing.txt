<div class="post-text" itemprop="text">
<p>I am new to Python, so I apologize if this is a duplicate or overly simple question. I have written a coordinator class that calls two other classes that use the kafka-python library to send/read data from Kafka. I want to write a unit test for my coordinator class but I'm having trouble figuring out how to best to go about this. I was hoping that I could make an alternate constructor that I could pass my mocked objects into, but this doesn't seem to be working as I get an error that test_mycoordinator cannot be resolved. Am I going about testing this class the wrong way? Is there a pythonic way I should be testing it?</p>
<p>Here is what my test class looks like so far:</p>
<pre><code>import unittest
from mock import Mock
from mypackage import mycoordinator

class MyTest(unittest.TestCase):

    def setUpModule(self):
        # Create a mock producer
        producer_attributes = ['__init__', 'run', 'stop']
        mock_producer = Mock(name='Producer', spec=producer_attributes)

        # Create a mock consumer
        consumer_attributes = ['__init__', 'run', 'stop']
        data_out = [{u'dataObjectID': u'test1'},
                    {u'dataObjectID': u'test2'},
                    {u'dataObjectID': u'test3'}]
        mock_consumer = Mock(
            name='Consumer', spec=consumer_attributes, return_value=data_out)

        self.coor = mycoordinator.test_mycoordinator(mock_producer, mock_consumer)

    def test_send_data(self):
        # Create some data and send it to the producer
        count = 0
        while count &lt; 3:
            count += 1
            testName = 'test' + str(count)
            self.coor.sendData(testName , None)
</code></pre>
<p>And here is the class I am trying to test:</p>
<pre><code>class MyCoordinator():
    def __init__(self):
        # Process Command Line Arguments using argparse  
        ...

        # Initialize the producer and the consumer
        self.myproducer = producer.Producer(self.servers,
                                            self.producer_topic_name)

        self.myconsumer = consumer.Consumer(self.servers,
                                            self.consumer_topic_name)

    # Constructor used for testing -- DOES NOT WORK
    @classmethod
    def test_mycoordinator(cls, mock_producer, mock_consumer):
        cls.myproducer = mock_producer
        cls.myconsumer = mock_consumer

    # Send the data to the producer
    def sendData(self, data, key):
        self.myproducer.run(data, key)

    # Receive data from the consumer
    def getData(self):
        data = self.myconsumer.run()
        return data
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no need to provide a separate constructor. Mocking <em>patches your code</em> to replace objects with mocks. Just use the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="noreferrer"><code>mock.patch()</code> decorator</a> on your test methods; it'll pass in references to the generated mock objects.</p>
<p>Both <code>producer.Producer()</code> and <code>consumer.Consumer()</code> are then mocked out <em>before</em> you create the instance:</p>
<pre><code>import mock

class MyTest(unittest.TestCase):
    @mock.patch('producer.Producer', autospec=True)
    @mock.patch('consumer.Consumer', autospec=True)
    def test_send_data(self, mock_consumer, mock_producer):
        # configure the consumer instance run method
        consumer_instance = mock_consumer.return_value
        consumer_instance.run.return_value = [
            {u'dataObjectID': u'test1'},
            {u'dataObjectID': u'test2'},
            {u'dataObjectID': u'test3'}]

        coor = MyCoordinator()
        # Create some data and send it to the producer
        for count in range(3):
            coor.sendData('test{}'.format(count) , None)

        # Now verify that the mocks have been called correctly
        mock_producer.assert_has_calls([
            mock.Call('test1', None),
            mock.Call('test2', None),
            mock.Call('test3', None)])
</code></pre>
<p>So the moment <code>test_send_data</code> is called, the <code>mock.patch()</code> code replaces the <code>producer.Producer</code> reference with a mock object. Your <code>MyCoordinator</code> class then uses those mock objects rather than the real code. calling <code>producer.Producer()</code> returns a new mock object (the same object that <code>mock_producer.return_value</code> references), etc.</p>
<p>I've made the assumption that <code>producer</code> and <code>consumer</code> are top-level module names. If they are not, provide the full import path. From the <code>mock.patch()</code> documentation:</p>
<blockquote>
<p><em>target</em> should be a string in the form <code>'package.module.ClassName'</code>. The target is imported and the specified object replaced with the new object, so the target must be importable from the environment you are calling <code>patch()</code> from. The target is imported when the decorated function is executed, not at decoration time.</p>
</blockquote>
</div>
<span class="comment-copy">wher edoes <code>mycordinator</code> come from in your <code>setUpModule</code>?</span>
<span class="comment-copy">@dm03514 sorry, I had a typo when I was changing the names I've edited the question to fix the import statement</span>
<span class="comment-copy">How does @mock.patch('consumer.Consumer', autospec=True) mock the consumer class I wrote? More specifically how does it know what I want mocked? I'm seeing an error when I try and run the test (ImportError: No module named consumer). My class Consumer is in consumer.py which is in mypackage. So do I need to specify the full path to the Consumer class in the patch somehow?</span>
<span class="comment-copy">@jencoston: You didn't include where <code>consumer</code> came from in your code; I made the assumption that that was the name of the module. If <code>consumer</code> is inside a package, provide the full name of the import: <code>mock.patch('package.consumer.Consumer')</code>. <code>mock.patch</code> will import the module and patch the name (last part of the path).</span>
