<div class="post-text" itemprop="text">
<p>I am writing a function that is taking some output and based on its contents populates a dictionary with objects.
Objects can be of 2 groups and depending on which section of the text document the function is going thru, in the outputs I identify type1 or type 2 objects and populate them with relevant data. Type 1 objects usually sit in State1 document section. Type2 objects - in State2
I am mostly relying on elif statements and process every line of the input text file (that goes into a function as a list) looking for its contents with regular expressions.
However the code is becoming unmanageable - i am funneling every line into all the ifs.
Is there a way to make this code better?</p>
<pre class="lang-py prettyprint-override"><code>def func(list):

    #defining function related variables
    state = ''
    state1_specific_value1 = ''
    state1_specific_value2 = ''
    state1_specific_value3 = ''
    state2_specific_value1 = ''
    state2_specific_value2 = ''
    state2_specific_value3 = ''

    for i in list:

        if REGEXP_DICTIONARY['state1_regexp'].match(i):
          # processing state1 section
          state = 'State1'
        elif REGEXP_DICTIONARY['state2_regexp'].match(i):
          # processing state2 section
          state = 'State2'
        elif REGEXP_DICTIONARY['interesting_line1_regexp'].match(i):
          # detecting some special conditions for a jar. Is it twistable?
          # not dependent on state
          jar_dict[jar].Twistable = True

        elif REGEXP_DICTIONARY['type'].match(i):
            jar_type = clean(i.replace("  blablabla ", "")) # quick clean up jar related string to get jar's name.
            #
            # making decisions based on State delivered from previous lines and Type detected
            #
            if (state == "State1" and type == "Type1"):
                debug("We detected State1 and Type 1")
            elif (state == "State2" and type == "Type2"):
                debug("We detected State2 and Type 2")
            else:
                debug ("inconsistency detected: type is {}, state is {}". format(type, state))

        # State 1 Type1 related block
        elif REGEXP_DICTIONARY['type1_state1_related regexp'].match(i) and state == "State1"
         #do_something

        elif ...
        elif ... 
        elif ... 
        elif ...

        #
        # State 2 Type2 related block
        elif REGEXP_DICTIONARY['type2_state2_related regexp'].match(i) and state == "State2":
            #do_something
        elif ...
        elif ... 
        elif ... 
        elif ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you should split your code into small logical pieces, each with 1 action. Something like that:</p>
<pre class="lang-py prettyprint-override"><code>def _get_object_type(obj):
    """I'm getting type of one object"""
    ...

def _process_type_1(type_1_object):
    """I'm processing type 1 objects"""
    ...

def _process_type_2(type_2_object):
    """I'm processing type 2 objects"""
    ...

def _process_object(obj, obj_type):
    """I'm processing object by types"""
    if obj_type == "type_1":
        __process_type_1(obj)
    if obj_type == "type_2":
        __process_type_2(obj)
    ...

def populate(raw_input):
    """I'm populating populated dict from raw_input"""
    populated = {}

    for elem in raw_input:
        elem_type = _get_object_type(elem)
        processed_elem = _process_object(elem, elem_type)
        ...    
</code></pre>
<p>So your code will be much cleaner and you can easy understand every little piece of your code :).</p>
</div>
<div class="post-text" itemprop="text">
<p>The python <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code></a> module supports <em>named groups</em> using this syntax: <code>(?P&lt;name&gt;...)</code></p>
<p>This means you could create regexes like so:</p>
<pre><code>state1_regexp = r"(?P&lt;state1&gt;some text that matches state1)"
state2_regexp = r"(?P&lt;state2&gt;some different text for state2)"
</code></pre>
<p>Then you could paste your regexes together as a giant alternation:</p>
<pre><code>all_states = '|'.join([state1_regexp, state2_regexp])
</code></pre>
<p>Now you have a regex like this:</p>
<pre><code>(?P&lt;state1&gt;...) | (?P&lt;state2&gt;...)
</code></pre>
<p>If you match the one all-encompassing regex, you'll get a result if any of the patterns hit:</p>
<pre><code>m = re.search(all_states, text)
</code></pre>
<p>You can access these with the <code>m.groupdict()</code> method, which returns a dictionary that contains all the <em>named</em> subgroups, and their matches. If a named subgroup key has a value of <code>None</code>, it didn't match.</p>
<pre><code>states = { k:v for k,v in m.groupdict().items() if v is not None}
</code></pre>
<p>Here's a demo version:</p>
<pre><code>import re
state1 = r'(?P&lt;state1&gt;foo)'
state2 = r'(?P&lt;state2&gt;bar)'
all_re = '|'.join([state1, state2])
text = "eat your own foo"
m = re.search(all_re, text)
states = {k:v for k,v in m.groupdict().items() if v is not None}
print(states)
</code></pre>
<p>Once you have a <code>states</code> dictionary, you can confirm that it only has one key (only one state matches at a time). Or not - maybe it's possible for two states to match at once!</p>
<p>Regardless, you can iterate through the keys and invoke state-specific code using attribute names or a function-lookup dict or whatever technique you like:</p>
<pre><code>def handle_state1():
    pass
def handle_state2():
    pass
dispatch = {
    'state1' : handle_state1,
    'state2' : handle_state2,
}

for k in states.keys():
    dispatch[k]()
</code></pre>
</div>
