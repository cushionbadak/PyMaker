<div class="post-text" itemprop="text">
<p>The input is the precision to which pi is calculated and I need to output the value of calculated pi and the number of terms to reach that value. </p>
<p>This is the code that I have made and it is supposed to print out (3.33968, 5). Could someone check where I have went wrong? </p>
<pre><code>t_precisionstr = input("Precision Value for Taylor: ")
t_precision = float(t_precisionstr)



t_list = []
def taylor(t_precision):
    t_number1 = 0
    t_number2 = 1
    t_final = 0
    while t_final &lt;= abs(m.pi - t_precision):
        t_number1 = t_number1 + 1
        t_answer = t_number2 + ((-1)**t_number1 / (2*t_number1+1))
        print(t_answer)
        t_number = t_number1 + t_number2
        t_number2 = 0
        t_list.append(t_answer)
        t_final = 4 * (sum(t_list))
        return(t_final,t_number+1)
print(taylor(t_precision))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the first issue is that your code is difficult to read and therefore difficult to debug. It's always better to use meaningful variable names and to try to minimize declaration of unnecessary ones.</p>
<p>Here is a working implementation of your problem as stated by the title, e.g. calculating pi up to a given precision:</p>
<pre><code># Pi/4 = 1 - 1/3 + 1/5 - 1/7 + ...
import numpy as np

def taylor(precision):

    t_pi, factor, error, order = 0, 0, np.pi, 0

    while (error &gt;= precision):
        t_pi += 4 * (-1)**factor / (2*factor + 1)
        error = abs(np.pi - t_pi)
        order += 1
        factor += 1

    return t_pi, order

taylor(0.2)

&gt;&gt;&gt; (3.3396825396825403, 5)
</code></pre>
<p>And this is the corrected version of your code:</p>
<pre><code>def taylor(t_precision):
    t_list = []
    t_number = 0
    t_final = 0
    while t_precision &lt;= abs(np.pi - t_final):

        t_answer = (-1)**t_number / (2*t_number+1)
        print(t_answer)

        t_list.append(t_answer)
        t_final = 4 * (sum(t_list))
        t_number = t_number + 1


    return (t_final,t_number)

t_precision = 0.2
taylor(t_precision)

&gt;&gt;&gt; (3.3396825396825403, 5)
</code></pre>
<p>The errors were:</p>
<ul>
<li><p>The condition of the <code>while</code> loop. You are checking the your final approximation against the difference between the actual value of pi and the desired precision. e.g. if you approximation is <code>2.6</code> and the precision <code>0.1</code> then the condition is already true, while the error is bigger than the precision required</p></li>
<li><p>The <code>return</code> statement is wrongly indented, so the loop exits at the first execution no matter what.</p></li>
</ul>
</div>
<span class="comment-copy">Show the mathematical formula which you are trying to emulate. Biggest problem I see right now is that you unconditionally return at the end of the loop body so there's no iterations. I also don't think you should be allowed to use <code>math.pi</code> in your answer, the point is that you're calculating π without knowing it already.</span>
<span class="comment-copy">Your first algorithm is incorrect, and doesn't work as intended... Try it yourself with <code>n==5</code> for example.</span>
<span class="comment-copy">The number of iterations was just an example as the user is suppose to just only input a precision value to which π should be calculated, i.e., the absolute difference of the approximation to the Python constant. It should output the value and also the number of iterations it took to reach that value</span>
<span class="comment-copy">@Tony see edit. Would have been clearer if you posted the value of <code>t_precision</code> instead of the <code>input(...)</code> which does not help.</span>
<span class="comment-copy">Oh i see. Thank you for your help</span>
