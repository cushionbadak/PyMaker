<div class="post-text" itemprop="text">
<p>Say I were to make a Python class where one of the function outputs is needed for several other functions but is a very slow process. Is there a way to then make this output an attribute or global variable for the rest of the functions to use but not have to rerun the slow function?</p>
<p>For example here is a class where the slow function is called by the next two functions:</p>
<p>class test_class:</p>
<pre><code>    def __init__(self, A):
            self.a = A

    def some_function(self):
            """ Function to show that the slow function feeds of another function first """
            a = self.a
            a*=2
            return a

    def slow_function(self): 
            """ Imagine this is a very slow function """
            test_value = self.some_function()
            test_value*=2
            return test_value

    def using_slow_function(self): 
            """ Calls the very slow function and then operates on the output """
            b = self.slow_function()
            b *=2
            return b

    def using_slow_function_again(self):
            """ Calls the very slow function and then operates on the output """
            c = self.slow_function()
            c *= 2
            return c
</code></pre>
<p>So it's clear that if <code>slow_function</code> was say opening a file or a slow convolution process then running it multiple times will be a big time sink. </p>
<p>If the output of <code>slow_function</code> could instead be made into an attribute then that would help, but I'm not sure how to do this midway through a class. </p>
<p>Any help would be greatly appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can assign attributes in an initialised python object at any time.</p>
<p>They don’t have to be done at initialisation, and you can even assign them from outside the object. </p>
<pre><code>&gt;&gt;&gt; class A:
...     def __init__(self):
...         self.a = 1
...     def thing(self):
...         self.b = 2
... 
&gt;&gt;&gt; c=A()
&gt;&gt;&gt; c.a
1
&gt;&gt;&gt; c.b
Traceback (most recent call last):
  module __main__ line 141
traceback.print_exc()
  module &lt;module&gt; line 1
c.b
AttributeError: 'A' object has no attribute 'b'
&gt;&gt;&gt; c.thing()
&gt;&gt;&gt; c.b
2
&gt;&gt;&gt; c.c = 3
&gt;&gt;&gt; c.c
3
</code></pre>
<p>EDIT: as per @roganjosh’s comment, you can assign it as <code>none</code> during initialisation. Not only will you not get <code>AttributeError</code>s, it’s easier to keep track of all attributes. </p>
<pre><code>&gt;&gt;&gt; class A:
...     def __init__(self):
...         self.a = 1
...         self.b = None
...     def thing(self):
...         if self.b is None:
...             self.b = 2
... 
&gt;&gt;&gt; c=A()
&gt;&gt;&gt; c.b
None
&gt;&gt;&gt; c.thing()
&gt;&gt;&gt; c.b
2
&gt;&gt;&gt; c.b = 3
&gt;&gt;&gt; c.thing()
&gt;&gt;&gt; c.b
3
</code></pre>
</div>
<span class="comment-copy">Sure. Just set the output as an attribute rather than <code>return</code> it from the method</span>
<span class="comment-copy">In init, set <code>self.long_function_result = None</code>. The time any of the other methods are used, you can check whether <code>self.long_function_result</code> is not None. If it is, call the long function and update <code>self.long_function_result</code>. If it's not None, just grab the value. Methods don't have to return anything, you can use them to update the state of an object</span>
<span class="comment-copy">Works perfectly, thank you!</span>
<span class="comment-copy">Yeah, it's definitely better to try not have attributes spring into existence after the object has been created. It also allows you to call <code>dir</code> on any instance of the object and see all the named attributes without ever having called a method.</span>
<span class="comment-copy">@roganjosh I can see an use for it if you have an object where you only want an attribute to be available after a specific method is called. Rare though.</span>
