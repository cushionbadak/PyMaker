<div class="post-text" itemprop="text">
<p>The recommended way to use asyncio for a socket server is:</p>
<pre><code>import asyncio

async def handle_client(reader, writer):
    request = (await reader.read(100)).decode()
    response = "Data received." 
    writer.write(response.encode())

async def main():
    loop.create_task(asyncio.start_server(handle_client, 'localhost', 15555))

loop = asyncio.get_event_loop()
loop.create_task(main())
loop.run_forever()
</code></pre>
<p>This works fine, but now I need to receive appropriate client request and then use aiohttp library to fetch data from a 3rd party restful API.</p>
<p>This requires creating a session variable as follows:</p>
<pre><code>from aiohttp import ClientSession

session = ClientSession()
</code></pre>
<p>But this also should be inside a coroutine itself, so I'll put it inside main:</p>
<pre><code>async def main():
    session = ClientSession()
    loop.create_task(asyncio.start_server(handle_client, '', 55555))
</code></pre>
<p>Now I need to pass the session variable to the aiohttp get coroutine to fetch the rest API data:</p>
<pre><code>async with session.get(url, params=params) as r:
    try:
        return await r.json(content_type='application/json')
    except aiohttp.client_exceptions.ClientResponseError:
        ....
</code></pre>
<p>My question is how can I pass the session variable to handle_client coroutine, if it insists on only having reader,writer parameters, and globals don't help me because sessions must exist inside coroutines?      </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a temporary function or a lambda:</p>
<pre><code>async def main():
    session = aiohttp.ClientSession()
    await asyncio.start_server(lambda r, w: handle_client(r, w, session),
                               '', 55555)
</code></pre>
<p>This works because even though the <code>lambda</code> is not technically a coroutine, it behaves like one - it is a callable that returns a <a href="https://docs.python.org/3/library/asyncio-task.html#coroutine" rel="nofollow noreferrer">coroutine object</a> when invoked.</p>
<p>For larger programs you might prefer a class-based approach with a class encapsulating the state shared by multiple clients without having to pass it from coroutine to coroutine. For example:</p>
<pre><code>class ClientContext:
    def __init__(self, session):
        self.session = session

    async def handle_client(self, reader, writer):
        # ... here you get reader and writer, but also have
        # session etc as self.session ...

async def main():
    ctx = ClientContext(aiohttp.ClientSession())
    await asyncio.start_server(ctx.handle_client), '', 55555)
</code></pre>
</div>
<span class="comment-copy">Thanks for the reply. I can't find any Python documentation verifying that coroutines for lambda function is supported. However, to my amazement, the code actually works when you pass a lambda returning a named coroutine as the parameter to <i>start_server</i>! I have my doubts about the second part of your answer though as session variables should only exist inside coroutines...</span>
<span class="comment-copy">@JSStuball In case of <code>start_server</code> it is explicitly documented that its callback can be a plain callback. But in this case the lambda invokes the coroutine (this is a legitimate thing to do - you get the coroutine object) and returns the resulting coroutine object. This makes it functionally equivalent to a coroutine function and it works just fine. You're of course right that the lambda is not a <i>real</i> coroutine, for example it cannot contain <code>await</code>.</span>
<span class="comment-copy">@JSStuball I've fixed the typo in the class example, where <code>handle_client</code> should also be a coroutine.</span>
<span class="comment-copy">@JSStuball I create it in the <code>main()</code> coroutine, just like your code does. The created instance gets <b>passed</b> to the <code>ClientContext</code> constructor, but that is of no consequence.</span>
<span class="comment-copy">@JSStuball I haven't actually checked this, but I suspect that all <code>ClientSession</code> cares about is that <i>some</i> coroutine is running while it is being created (the code seems to <a href="https://github.com/aio-libs/aiohttp/blob/e021a01c2f00b058eb3fb3a2d8f3e1f3a89fc2c9/aiohttp/client.py#L122" rel="nofollow noreferrer">confirm</a> that). In other words, I figure there would be no warning even if <code>ClientSession</code> were instantiated in <code>ClientContext.__init__</code>.</span>
