<div class="post-text" itemprop="text">
<p>I have a the following data structure:</p>
<pre><code>a = [('customerA', '1.0.0'), ('customerB', '1.0.0'), ('customerC', '1.0.1')]
b = (('customerB', '1.1.0'), ('customerC', '1.0.1'))
</code></pre>
<p>I want the results to be something like this:</p>
<pre><code>[('customerA', None), ('customerB', '1.0.0', '1.1.0'), ('customerC', '1.0.1', '1.0.1')]
</code></pre>
<p>or even skip non existing customers entirely:</p>
<pre><code>[('customerB', '1.0.0', '1.1.0'), ('customerC', '1.0.1', '1.0.1')]
</code></pre>
<p>The <code>zip</code> function won't help in this case because <code>b</code> comes from <code>MySQLCursor.fetchall()</code> with <code>WHERE</code> clause for the customer name so it won't match with <code>a</code> if the customer doesn't exist:</p>
<pre><code>&gt;&gt;&gt; [a + (b[1],) for a, b in zip(a, b)]
[('customerA', '1.0.0', '1.1.0'), ('customerB', '1.0.0', '1.0.1')]
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; for a, b in itertools.zip_longest(a, b):
...     print(a, b)
... 
('customerA', '1.0.0') ('customerB', '1.1.0')
('customerB', '1.0.0') ('customerC', '1.0.1')
('customerC', '1.0.1') None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried to do it directly?</p>
<pre><code>customers_a = dict(a)
result = [(customer, customers_a[customer], version) for customer, version in b if customer in customers_a]
</code></pre>
<p>Now, <code>result</code> is exactly</p>
<pre><code>&gt;&gt;&gt; result
[('customerB', '1.0.0', '1.1.0'), ('customerC', '1.0.1', '1.0.1')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>collections</code>.</p>
<p><strong>Demo:</strong></p>
<pre><code>import collections
a = [('customerA', '1.0.0'), ('customerB', '1.0.0'), ('customerC', '1.0.1')]
b = (('customerB', '1.1.0'), ('customerC', '1.0.1'))

checkDict = dict(b)
d = collections.defaultdict(list)
for i in (a + list(b)):
    if i[0] in checkDict.keys():
        d[i[0]].append(i[1])
print(d)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>defaultdict(&lt;type 'list'&gt;, {'customerC': ['1.0.1', '1.0.1'], 'customerB': ['1.0.0', '1.1.0']})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [11]: a = [('customerA', '1.0.0'), ('customerB', '1.0.0'), ('customerC', '1.0.1')]
    ...: b = (('customerB', '1.1.0'), ('customerC', '1.0.1'))

In [12]: ad = dict(a)

In [13]: bd = dict(b)

In [14]: [(k, ad.get(k), bd.get(k)) for k in set(ad.keys()) &amp; set(bd.keys())]
Out[14]: [('customerC', '1.0.1', '1.0.1'), ('customerB', '1.0.0', '1.1.0')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could always try <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; x = [('customerA', '1.0.0'), ('customerB', '1.0.0'), ('customerC', '1.0.1')]
&gt;&gt;&gt; y = (('customerB', '1.1.0'), ('customerC', '1.0.1'))
&gt;&gt;&gt; [(a, b, d) for (a, b), (c, d) in product(x, y) if a == c]
[('customerB', '1.0.0', '1.1.0'), ('customerC', '1.0.1', '1.0.1')]
</code></pre>
<p><strong>Note:</strong> This assumes that only only one customer pair exists between the two data structures. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to exclude customers that are only in <code>a</code> you can do it using a list comprehension:</p>
<pre><code>a = [('customerA', '1.0.0'), ('customerB', '1.0.0'), ('customerC', '1.0.1')]
b = (('customerB', '1.1.0'), ('customerC', '1.0.1'))

result = [(ca, x, y) for (ca, x) in a for (cb, y) in b if ca == cb]
# [('customerB', '1.0.0', '1.1.0'), ('customerC', '1.0.1', '1.0.1')]
</code></pre>
</div>
<span class="comment-copy">Will <code>b</code> ever contain customer names that <code>a</code> doesn't contain? If so, what should happen? Will either of the data structures ever contain more than one element with the same customer name? If so, what should happen? Are customer names always in alphabetical order? If not, are they at least always in the same order as in the other data structure (not counting ones that don't appear in both)?</span>
