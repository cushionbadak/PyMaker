<div class="post-text" itemprop="text">
<p>I am a student in Data Science but have little code experience so far.</p>
<p>My issue is: how can I obtain a list of dicts from a string, that already is in the form of a list of dicts but is seen by pandas as a string?</p>
<p>Here is the dataset (credits):
<a href="https://www.kaggle.com/tmdb/tmdb-movie-metadata/data" rel="nofollow noreferrer">https://www.kaggle.com/tmdb/tmdb-movie-metadata/data</a></p>
<p>In the columns 'cast' and 'crew' I have cells like this:</p>
<pre><code>[
{"credit_id": "52fe420dc3a36847f800012d", "department": "Directing", "gender": 1, "id": 3110, "job": "Director", "name": "Allison Anders"}, 
{"credit_id": "52fe420dc3a36847f80001c9", "department": "Writing", "gender": 1, "id": 3110, "job": "Writer", "name": "Allison Anders"}
]
</code></pre>
<p>(obviously there are dozens of dicts for each cell)</p>
<p>My main problem is that, after I have loaded the file and created a data frame, the cells of these two columns (cast and crew) are seen by pandas as strings, and not as a list of dicts, and so I cannot perform the operations I need.</p>
<pre><code>creditsB = pd.read_csv('folder\\tmdb_5000_credits.csv')
creditsDF = pd.DataFrame(creditsB)
type(creditsDF.loc[0,'crew'])
# str
</code></pre>
<p>And if I try to apply list() on it, it just creates a list of single characters.</p>
<pre><code>dct = list(creditsDF.loc[0,'crew'])
dct
 # output:
 ['[',
 '{',
 '"',
 'c',
 'r',
 'e',
 # and so on
</code></pre>
<p>How can I make python understand it's actually a list of dicts, and treat it as well?</p>
<p>I have to do some basic operations like "for each movie, compute the number of cast members" or "for each movie, compute the number of directors". These would be really easy if I just solved this big issue.</p>
<p>Thanks in advance for any help!</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to append dict in list</p>
<pre><code> movies = [ {"credit_id": "52fe420dc3a36847f800012d", "department": "Directing", "gender": 1, "id": 3110, "job": "Director", "name": "Allison Anders"}, {"credit_id": "52fe420dc3a36847f80001c9", "department": "Writing", "gender": 1, "id": 3110, "job": "Writer", "name": "Allison Anders"} ]

    for movie in movies:
        print movie["name"]

    # count movies in list
    print len(movies)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So you have list of dictionaries, but they appear in your dataframe as strings. This is <em>extremely</em> inefficient. You should aim to improve the workflow <em>upstream</em> so that you read dictionaries directly into Python.</p>
<p>However, given what you have, you can utilise <code>ast.literal_eval</code> to read your strings literally. Then feed into <code>pd.DataFrame</code>. This works because <code>pd.DataFrame</code> accepts a list of dictionaries directly.</p>
<p>Once in a dataframe, you can:</p>
<ul>
<li>Count the number of dictionaries via <code>len(df.index)</code>.</li>
<li>Use Pandas Boolean indexing to filter, e.g. <code>df.loc[df['job'] == 'Director', 'name']</code> will filter for names of directors.</li>
</ul>
<p>Here's an example:</p>
<pre><code>import pandas as pd
from itertools import chain
from ast import literal_eval

s = pd.Series(['[{"credit_id": "52fe420dc3a36847f800012d", "department": "Directing", "gender": 1, "id": 3110, "job": "Director", "name": "Allison Anders"},{"credit_id": "52fe420dc3a36847f80001c9", "department": "Writing", "gender": 1, "id": 3110, "job": "Writer", "name": "DEF GHI"}]',
               '[{"credit_id": "52fe420dc3a36847f800012e", "department": "Costume", "gender": 0, "id": 4110, "job": "Dresser", "name": "A B"},{"credit_id": "52fe420dc3a36847f80001c8", "department": "Videography", "gender": 1, "id": 3111, "job": "Other", "name": "Joe Smith"}]',
               '[{"credit_id": "52fe420dc3a36847f800012f", "department": "Music", "gender": 1, "id": 5110, "job": "Composer", "name": "C D"},{"credit_id": "52fe420dc3a36847f80001c7", "department": "Production", "gender": 0, "id": 3112, "job": "Writer", "name": "Ben Andrews"}]'])

print(s)

# 0    [{"credit_id": "52fe420dc3a36847f800012d", "de...
# 1    [{"credit_id": "52fe420dc3a36847f800012e", "de...
# 2    [{"credit_id": "52fe420dc3a36847f800012f", "de...
# dtype: object

chained = chain.from_iterable(literal_eval(i) for i in s)

df = pd.DataFrame(list(chained))

print(df)

#                   credit_id   department  gender    id       job  \
# 0  52fe420dc3a36847f800012d    Directing       1  3110  Director   
# 1  52fe420dc3a36847f80001c9      Writing       1  3110    Writer   
# 2  52fe420dc3a36847f800012e      Costume       0  4110   Dresser   
# 3  52fe420dc3a36847f80001c8  Videography       1  3111     Other   
# 4  52fe420dc3a36847f800012f        Music       1  5110  Composer   
# 5  52fe420dc3a36847f80001c7   Production       0  3112    Writer   

#              name  
# 0  Allison Anders  
# 1         DEF GHI  
# 2             A B  
# 3       Joe Smith  
# 4             C D  
# 5     Ben Andrews  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">ast.literal_eval</a>:</p>
<pre><code>import ast

text = '''
[
{"credit_id": "52fe420dc3a36847f800012d", "department": "Directing", "gender": 1, "id": 3110, "job": "Director", "name": "Allison Anders"}, 
{"credit_id": "52fe420dc3a36847f80001c9", "department": "Writing", "gender": 1, "id": 3110, "job": "Writer", "name": "Allison Anders"}
]
'''

dicts = ast.literal_eval(text)
# [{'name': 'Allison Anders', 'department': 'Directing', 'credit_id': '52fe420dc3a36847f800012d', 'gender': 1, 'job': 'Director', 'id': 3110}, 
# {'name': 'Allison Anders', 'department': 'Writing', 'credit_id': '52fe420dc3a36847f80001c9', 'gender': 1, 'job': 'Writer', 'id': 3110}]
print(len(dicts))
# 2
print(dicts[0]['department'])
# Directing
</code></pre>
<p>For efficient applying changes, try <a href="https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.apply.html#pandas-dataframe-apply" rel="nofollow noreferrer">apply</a>:</p>
<pre><code>df['col'] = df['col'].apply(lambda x: ast.literal_eval(x))
</code></pre>
<p>Extracting desired fields from dictionaries:</p>
<pre><code>dicts = ast.literal_eval(text)
[d['department'] for d in dicts]
# ['Directing', 'Writing']
</code></pre>
</div>
<span class="comment-copy">Could you elaborate on the first part? As it's written, this <i>is</i> a list of dicts; that is, something like <code>a = [{"a": 2}, {"a": 3}]</code> will work exactly as you would expect.</span>
<span class="comment-copy">Thanks for your comment! My problem is that for python it is not a list of dicts... I have written more in the question</span>
<span class="comment-copy">What is the relation between the list of dictionaries and <code>df</code>, which I assume is a pandas <code>DataFrame</code>? What is <code>crew</code>, which is not defined elsewhere in the question? If you could set up a <a href="https://stackoverflow.com/help/mcve">minimal, complete, and verifiable example</a> of the issue you're facing, that would be helpful.</span>
<span class="comment-copy">Did it, sorry it's my first post here</span>
<span class="comment-copy">Thank you for the answer, but the dicts are already in square brackets, so your way would not work.... I need a way to make python understand they are lists of dicts and not strings, and do that in a for loop</span>
<span class="comment-copy">Thanks for your answer, but my problem is that the list of dicts is inside a cell, it's not the data frame...</span>
<span class="comment-copy">So are mine... Notice that each element in my series is a list of dictionaries represented as a string. There are no "cells" in Pandas. Only series and dataframes.</span>
<span class="comment-copy">It's hard to tell from the example, but I wouldn't be surprised if what they're sitting on is JSON; if so, parsing it as such could be preferable from having to deal with the security considerations that come with <code>literal_eval</code>.</span>
<span class="comment-copy">How do you propose OP searches a series of lists of dictionaries? For example, how would they extract the names of all directors?</span>
<span class="comment-copy">@jpp thanks for the notice, let me check again the questions!</span>
