<div class="post-text" itemprop="text">
<p>I have a list of strings: <code>ls = ['a','b','c']</code> and another one, with larger strings, guaranteed to include one and only one strings from <code>ls</code>: <code>ls2 = ['1298a', 'eebbbd', 'qcqcq321']"</code>.</p>
<p>How can I find, for a given string from <code>ls2</code>, what is the index of the corresponding string from <code>ls</code>?</p>
<p>I can use:</p>
<pre><code>for s in ls:
    for ss in ls2:
        if s in ss:
            print (s,ss,ls.index(s))

a 1298a 0
b eebbbd 1
c qcqcq321 2
</code></pre>
<p>but it there something nicer?</p>
<p><strong>EDIT (hope it clarifies):</strong></p>
<p>The actual case I'm working on has a bigger 1st list, and a smaller 2nd:</p>
<pre><code>ls  = ['apo','b','c','d25','egg','f','g']
ls2 = ['apoip21', 'oiujohuid25']
</code></pre>
<p>and I want to get the result <code>0,3</code> because the 1st item in <code>ls2</code> has the 1st item from <code>ls</code>, while the 2nd in <code>ls2</code> has the 4th in <code>ls</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't look like you can get away from <code>O(m * n * p)</code> complexity (where <code>m = len(ls)</code>, <code>n = len(ls2)</code>, <code>p = max(map(len, ls2))</code>) without further information about your data. You can definitely reduce your current loop from <code>O(m<sup>2</sup> * n * p)</code> by keeping track of the current index using <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>. Also, don't forget about early termination:</p>
<pre><code>for string in ls2:
    for index, key in enumerate(ls):
        if key in string:
            print(key, string, index)
            break
</code></pre>
<p>Notice that I swapped the inner and outer loop to make the <code>break</code> work properly: you definitely want to check each element of <code>ls2</code>, but only the minimum number of elements in <code>ls</code>.</p>
<p>Here are some timings I accumulated on the different <code>O(m * n * p)</code> solutions presented here. Thanks to @thierry-lathuille for the test data:</p>
<pre><code>ls = ['g', 'j', 'z', 'a', 'rr', 'ttt', 'b', 'c', 'd', 'f']
ls2 = ['1298a', 'eebbb', 'qcqcq321', 'mlkjmd', 'dùmlk', 'lof',
       'erreee', 'bmw', 'ottt', 'jllll', 'lla' ]

def with_table():
    table = {key: index for index, key in enumerate(ls)}
    result = {}
    for string in ls2:
        for key in ls:
            if key in string:
                result[string] = table[key]
    return result

def with_enumerate():
    result = {}
    for string in ls2:
        for index, key in enumerate(ls):
            if key in string:
                result[string] = index
                break
    return result

def with_dict_comp():
    return {string: index for string in ls2 for index, key in enumerate(ls) if key in string}

def with_itertools():
    result = {}
    for (index, key), string in itertools.product(enumerate(ls), ls2):
        if key in string:
            result[string] = index
    return result
</code></pre>
<p></p>
<pre><code>%timeit with_table()
4.89 µs ± 61.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

%timeit with_enumerate()
5.27 µs ± 66.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

%timeit with_dict_comp()
6.9 µs ± 83.8 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

%timeit with_itertools()
17.5 ns ± 0.193 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)
</code></pre>
<p>As it turns out, creating a lookup table for the indices is slightly faster than computing them on the fly with <code>enumerate</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your codes time complexity is O(n^4), you can make it O(n^3) by using dict.  </p>
<pre><code>ls = ['a','b','c']
ls2 = ['1298a', 'eebbbd', 'qcqcq321']
word_dict=dict()
for i in range(len(ls)):    #time complexity O(n)

    word_dict[ls[i]]=i
for s in ls:    #O(n)
    for ss in ls2:  #O(n)
        if s in ss: #O(n)
            print(s,ss,word_dict[s]) #O(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a dict comprehension:</p>
<pre><code>ls  = ['apo','b','c','d25','egg','f','g']
ls2 = ['apoip21', 'oiujohuid25']

result = { string : index for index, i in enumerate(ls) for string in ls2 if i in string }
# {'apoip21': 0, 'oiujohuid25': 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, if I interpret the "nicer" request as "written in a more compact way", then I suggest all loops and conditions packed in a list comprehension:</p>
<pre><code>&gt;&gt;&gt; ls  = ['apo','b','c','d25','egg','f','g']
&gt;&gt;&gt; ls2 = ['apoip21', 'oiujohuid25']

&gt;&gt;&gt; [ls.index(s) for s in ls for s2 in ls2 if s in s2]
[0, 3]
</code></pre>
<p>But it does not improve the complexity, if "nicer" was to be understood as "less complex"...</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use these two improvements:</p>
<pre><code>ls = ['a','b','c']
ls2 = ['1298a', 'eebbbd', 'qcqcq321']

# preprocess ls to avoid calling ls.index each time:
indices = {ss:index for index, ss in enumerate(ls)}

for s in ls2:
    for ss in ls:
        if ss in s:
            print(ss, s, indices[ss])
            # as s is guaranteed to include only one of the substrings,
            # we don't have to test the other substrings once we found a match
            break


# a 1298a 0
# b eebbbd 1
# c qcqcq321 2     
</code></pre>
<hr/>
<p>Some timings:</p>
<p>Breaking out of the loop once the match has been found always improves the speed.
The overhead due to the creation of the dict of indices makes it slower for very small lists, but is already faster with lists shorter than the ones used in the timings:</p>
<pre><code>ls = ['g', 'j', 'z', 'a', 'rr', 'ttt', 'b', 'c', 'd', 'f']
ls2 = ['1298a', 'eebbb', 'qcqcq321', 'mlkjmd', 'dùmlk', 'lof', 'erreee', 'bmw', 'ottt', 'jllll', 'lla' ]

def original():
    for s in ls:
        for ss in ls2:
            if s in ss:
                out = (s,ss,ls.index(s))


def with_break():

    for s in ls2:
        for ss in ls:
            if ss in s:
                out = (ss, s, ls.index(ss))
                # as s is guaranteed to include only one of the substrings,
                # we don't have to test the other substrings once we found a match
                break


def with_break_and_dict():
    # preprocess ls to avoid calling ls.index each time:
    indices = {ss:index for index, ss in enumerate(ls)}

    for s in ls2:
        for ss in ls:
            if ss in s:
                out = (ss, s, indices[ss])
                # as s is guaranteed to include only one of the substrings,
                # we don't have to test the other substrings once we found a match
                break
</code></pre>
<p>Timing results:</p>
<pre><code>%timeit original()
%timeit with_break()
%timeit with_break_and_dict()


# 100000 loops, best of 3: 12.8 µs per loop
# 100000 loops, best of 3: 9.5 µs per loop
# 100000 loops, best of 3: 8.49 µs per loop
</code></pre>
</div>
<span class="comment-copy">@DunPeal. Every question is an algorithm question. There may be language features that simplify the algorithm though.</span>
<span class="comment-copy">You could probably play with map and try to get this into a clever 1 liner.  But for me, even though it has 2 for loops, this is pretty readable and that is more important to me.  Unless you are having performance problems.</span>
<span class="comment-copy">Would you mind editing your question to reflect that?</span>
<span class="comment-copy">Also, are the elements of <code>ls</code> always one character long? If not, could you add that to your example as well?</span>
<span class="comment-copy">Hum, might have been nice to define <code>nicer</code> clearer: shorter? Or less complex?</span>
<span class="comment-copy">This is no improvement on what OP is doing. You could just enumerate your list to get the same info with one fewer loop.</span>
<span class="comment-copy">time complexity reduced here.</span>
<span class="comment-copy">No it's not. OP has O(n^2) solution as well. Yours just adds an extra layer of overhead.</span>
<span class="comment-copy">"in" operator takes O(n), finding index in the last line takes O(n),two loops take O(n^2). So it's O(n^4).</span>
<span class="comment-copy">Actually it's <code>O(m * n * p)</code>, where <code>m = len(ls)</code>, <code>n = len(ls2)</code>, and <code>p = max(len(x) for x in ls2)</code></span>
<span class="comment-copy">You've violated OP's first assumption: only one element of <code>ls</code> per element of <code>ls2</code>.</span>
<span class="comment-copy">Your result is backwards. The keys should be elements in <code>ls2</code></span>
<span class="comment-copy">Same complexity, but much better now.</span>
<span class="comment-copy">@MadPhysicist Yes, it actually answers the question now :)</span>
<span class="comment-copy">As discussed under <a href="https://stackoverflow.com/a/50743104/2988730">@TaohidulIslam's answer</a>, you are suggesting adding more overhead, not adding an improvement. Also you answer is almost identical.</span>
<span class="comment-copy">@MadPhysicist See the timings</span>
<span class="comment-copy">The first one is not a fair comparison. See the answer I posted. See if <code>enumerate</code> makes it faster than a lookup table. I bet it does.</span>
<span class="comment-copy">Also, would be interesting to see the <code>itertools.product</code> version.</span>
<span class="comment-copy">I added more timings to my answer. Looks like you're right. The lookup table is better than my original solution.</span>
