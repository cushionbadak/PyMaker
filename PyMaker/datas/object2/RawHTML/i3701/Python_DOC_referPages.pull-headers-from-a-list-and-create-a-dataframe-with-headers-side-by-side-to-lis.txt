<div class="post-text" itemprop="text">
<p>After scraping a website, I ended up with a list which looks like this:</p>
<pre><code>data = ['\xa0header1', 'element1', 'element2', 'element3', '\xa0header2', 'element4', 'element5']
</code></pre>
<p>and so on.</p>
<p>I want to create a panda dataframe with the data I scraped that looks like this:</p>
<pre><code>          A         B
   0  element1   header1
   1  element2   header1
   2  element3   header1
   3  element4   header2
   4  element5   header2
</code></pre>
<p>So, basically, I want to show in the next column the header which is above a group of elements of the initial list. </p>
<p>How can it be done, considering the special character in front of the headers makes it easy to look them up in the list?</p>
</div>
<div class="post-text" itemprop="text">
<h3>itertools groupby + repeat + chain</h3>
<p>This is one solution using the <a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="nofollow noreferrer"><code>itertools</code></a> module. In essence these are the only operations we need to undertake:</p>
<ol>
<li><strong>Group</strong> items according to whether they start with <code>\xa0</code>.</li>
<li><strong>Repeat</strong> headers for each list within your list of lists after grouping.</li>
<li><strong>Chain</strong> results for series <code>A</code> and <code>B</code> to remove nested lists.</li>
</ol>
<p>Crucially, these operations are already implemented lazily and efficiently in the standard library, so there's no need to reproduce in pure Python (although this, in itself, is a good learning exercise).</p>
<p>Complete solution:</p>
<pre><code>from itertools import chain, groupby, repeat

chainer = chain.from_iterable

data = ['\xa0header1', 'element1', 'element2', 'element3',
        '\xa0header2', 'element4', 'element5']

def condition(x):
    return x.startswith('\xa0')

# create list of lists for elements
elements = [list(j) for i, j in groupby(data, key=condition) if not i]

# create list of headers
headers = [next(j) for i, j in groupby(data, key=condition) if i]

# chain list of lists, and use repeat for headers
df = pd.DataFrame({'A': list(chainer(LoL)),
                   'B': list(chainer(repeat(i, j) for i, j in \
                             zip(headers, map(len, elements))))})

print(df)

          A         B
0  element1   header1
1  element2   header1
2  element3   header1
3  element4   header2
4  element5   header2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative solution is to use <code>collections.defaultdict</code> to create a dictionary mapping headers to elements. Potentially more intuitive than <code>itertools.groupby</code> and requires only one pass.</p>
<pre><code>from collections import defaultdict
from itertools import chain, repeat

chainer = chain.from_iterable

data = ['\xa0header1', 'element1', 'element2', 'element3',
        '\xa0header2', 'element4', 'element5']

# create dictionary of lists
# each key a separate header; values are list of elements
d = defaultdict(list)

for item in data:
    if item.startswith('\xa0'):
        key = item.strip()
    else:
        d[key].append(item)

# chain list of lists, and use repeat for headers
df = pd.DataFrame({'A': list(chainer(d.values())),
                   'B': list(chainer(repeat(i, j) for i, j in \
                             zip(d.keys(), map(len, d.values()))))})

print(df)

          A        B
0  element1  header1
1  element2  header1
2  element3  header1
3  element4  header2
4  element5  header2
</code></pre>
</div>
<span class="comment-copy">Thank you for providing a solution. However, maybe I was not clear enough but the headers actually include words like \xa0Eggs or \xa0Plates for example that I want to extract and put in the next colmun instead of enumerating.</span>
<span class="comment-copy">@SdJunk, See update.</span>
<span class="comment-copy">Thank you @jpp. It works exactly as intended now.</span>
