<div class="post-text" itemprop="text">
<p><strong>why this question ?</strong></p>
<p>I was trying to answer this question: <a href="https://stackoverflow.com/questions/50724875/check-if-all-values-exist-as-keys-in-dictionary">Check if All Values Exist as Keys in Dictionary</a> with something better than a generator comprehension fed to <code>all</code> (python loops, even in comprehensions, slow down execution compared to implicit loops that some functions perform):</p>
<pre><code>all(i in bar for i in foo)
</code></pre>
<p>where <code>bar</code> is a dictionary and <code>foo</code> is a list by using <code>set.issubset</code> (with a conversion to <code>set</code> of <code>foo</code> to be able to use <code>foo.issubset(bar)</code>), and didn't succeed to beat the times of the <code>all</code> solution (unless both containers are converted to <code>set</code>s).</p>
<p><strong>my question:</strong></p>
<p>From the documentation of <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>set</code></a>:</p>
<blockquote>
<p>Note, the non-operator versions of union(), intersection(), difference(), and symmetric_difference(), issubset(), and issuperset() methods will <strong>accept any iterable as an argument</strong>. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like set('abc') &amp; 'cbs' in favor of the more readable set('abc').intersection('cbs').</p>
</blockquote>
<p>Okay but the performance really depends on the type of argument, even if the complexity does not (<a href="https://stackoverflow.com/questions/27674289/the-complextiy-of-python-issubset">The complextiy of Python issubset()</a>):</p>
<pre><code>import timeit
foo = {i for i in range(1, 10000, 2)}
bar = foo - {400}
n=10000
x = timeit.timeit(setup="foo = {str(i) for i in range(1, 10000, 2)};bar = foo - {'400'}",stmt="bar.issubset(foo)",number=n)
print("issubset(set)",x)
x = timeit.timeit(setup="foo = {str(i) for i in range(1, 10000, 2)};bar = foo - {'400'};foo=list(foo)",stmt="bar.issubset(foo)",number=n)
print("issubset(list)",x)
x = timeit.timeit(setup="foo = {str(i):i for i in range(1, 10000, 2)};bar = set(foo) - {'400'}",stmt="bar.issubset(foo)",number=n)
print("issubset(dict)",x)
x = timeit.timeit(setup="foo = {str(i):i for i in range(1, 10000, 2)}.keys();bar = set(foo) - {'400'}",stmt="bar.issubset(foo)",number=n)
print("issubset(dict_keys)",x)
</code></pre>
<p>my results (Python 3.4):</p>
<pre><code>issubset(set) 1.6141405847648826
issubset(list) 3.698748032058883
issubset(dict) 3.6300025109004244
issubset(dict_keys) 4.224299651223102
</code></pre>
<p>So if a <code>set</code> is passed as the argument, the result is very fast.</p>
<p>Using a <code>list</code> is much slower. I figured out that it was because of the hash that must be done on the strings is costly. So I changed my test inputs with integers like this:</p>
<pre><code>foo = {i for i in range(1, 10000, 2)}
bar = foo - {400}
</code></pre>
<p>and the results were globally faster but still a huge time difference:</p>
<pre><code>issubset(set) 0.5981848205989139
issubset(list) 1.7991591232742143
issubset(dict) 1.889119736960271
issubset(dict_keys) 2.2531574114632678
</code></pre>
<p>I also tried to change <code>dict</code> by <code>dict.keys()</code> as in python 3 the keys is said to be (<a href="https://www.python.org/dev/peps/pep-3106/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-3106/</a>) "a set-like or unordered container object".</p>
<p>But in that case, the result is even worse than with <code>dict</code> or <code>list</code>.</p>
<p><strong>So why does passing a <code>set</code> beats passing a <code>list</code> or a <code>dict</code> or a <code>dict_keys</code> object?</strong> I don't see anything mentionned in the documentation about this.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://github.com/python/cpython/blob/v3.6.5/Objects/setobject.c#L1777" rel="nofollow noreferrer"><code>set.issubset</code> algorithm</a> requires a set to work with (frozensets and subclasses count); if you pass it something else, it will make a set. It's basically <code>all(elem in other for elem in self)</code>, and it needs to know that <code>elem in other</code> is efficient and means what it means for sets. The only way it knows how to guarantee that is to ensure <code>other</code> is a set. Making a set is expensive.</p>
<p>(I've glossed over some details. If you want to know exactly what's going on, particularly if you have a weird set subclass, read the source code in the link.)</p>
</div>
<span class="comment-copy">Please use <code>timeit</code> for benchmarking, taking a delta with <code>time.time()</code> is not reliable.</span>
<span class="comment-copy">@wim done. I may lack experience at doing clear <code>timeit</code> benchmarks. the results are comparable.</span>
<span class="comment-copy">I expected it probably could be made to work with dict key views (which are sufficiently set-like) but nobody bothered to implement that in CPython yet.</span>
<span class="comment-copy">simple but somehow disappointing answer :)</span>
<span class="comment-copy">Seems like <code>PyAnySet_Check</code> does allow for frozenset and set subclasses.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre: As wim said, <code>frozenset</code>s count as sets for the purpose of this check. (The same exact routine is used for <code>set.issubset</code> and <code>frozenset.issubset</code>, and it accepts the same argument types regardless of the type of <code>self</code>.)</span>
