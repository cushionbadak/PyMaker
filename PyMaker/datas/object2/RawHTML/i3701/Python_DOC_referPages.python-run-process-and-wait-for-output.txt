<div class="post-text" itemprop="text">
<p>I want to run a program, wait for it's output, send inputs to it and repeat until a condition.  </p>
<p>All I could find was questions about waiting for a program to finish, which is NOT the case. The process will still be running, it just won't be giving any (new) outputs.  </p>
<p>Program output is in stdout and in a log file, either can be used.<br/>
Using linux.</p>
<p>Code so far:  </p>
<pre><code>import subprocess

flag = True
vsim = subprocess.popen(['./run_vsim'], 
                        stdin=subprocess.pipe,
                        shell=true, 
                        cwd='path/to/program')
while flag:
    with open(log_file), 'r') as f:
        for l in f:
            if condition:
                break
    vsim.stdin.write(b'do something\n')
    vsim.stdin.flush()
vsim.stdin.write(b'do something else\n')
vsim.stdin.flush()
</code></pre>
<p>As is, the "do something" input is being sent multiple times even before the program finished starting up. Also, the log file is read before the program finishes running the command from the last while iteraction. That causes it to buffer the inputs, so I keeps executing the commands even after the condition as been met.  </p>
<p>I could use <code>time.sleep</code> after each <code>stdin.write</code> but since the time needed to execute each command is variable, I would need to use times longer than necessary making the python script slower. Also, that's a dumb solution to this.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using python3, you can try updating your code to use <code>subprocess.run</code> instead. It should wait for your task to complete and return the output. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use commands instead of subprocess. Here is an example with ls command:</p>
<pre><code>import commands 
status_output = commands.getstatusoutput('ls ./')
print status_output[0] #this will print the return code (0 if everything is fine)
print status_output[1] #this will print the output (list the content of the current directory)
</code></pre>
</div>
<span class="comment-copy">Does the subprocess print some kind of standard "done" message indicating it's finished processing? If so, you can probably use <a href="https://pexpect.readthedocs.io/en/stable/" rel="nofollow noreferrer"><code>pexpect</code></a>.</span>
<span class="comment-copy">Have you considered <a href="https://docs.python.org/3/library/concurrency.html" rel="nofollow noreferrer">threading, multiprocessing</a>, or <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a>?</span>
<span class="comment-copy">Does the process dump data to the pipe or does it dribble it - when you get data how do you know you got all of it?  Are you saying that the process never terminates?</span>
<span class="comment-copy">@Linuxios not that I know of, but I'll look into it.</span>
<span class="comment-copy">@wwii I haven't but I will read the docs. I'm pretty sure it is multi-threading as is, if it wasn't the python script would wait for the child process to run (I could be wrong, never worked with threading before)</span>
<span class="comment-copy">Like I said in the question, the task process is still running, it just doesn't give any new outputs since it's waiting for inputs.</span>
<span class="comment-copy">From the docs:   Deprecated since version 2.6: The commands module has been removed in Python 3. Use the subprocess module instead. Question has python-3x tag</span>
<span class="comment-copy">and it has python tag</span>
