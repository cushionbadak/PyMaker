<div class="post-text" itemprop="text">
<p>I'm trying to access an instance attribute (<code>inst_baseA / inst_baseB</code>) of <code>Base</code> class from an instance of <code>ClassB</code>, depending on an attribute of the instance (<code>self.x</code> of object ClassB).</p>
<p>Here is my code:</p>
<pre><code>class Base(object):
    def __init__(self):
        self.inst_baseA = 'base_B'
        self.inst_baseB = 'base_A'


class ClassA(object):
    def __init__(self):
        self.node = Base()


class ClassB(ClassA):
    def __init__(self):
        super(ClassB, self).__init__()
        self.x = 'base_A'
</code></pre>
<p>This is what I tried first:</p>
<pre><code>&gt;&gt;&gt; b = ClassB()
&gt;&gt;&gt; getattr(b, 'node.inst_{}'.format(b.x))

Traceback (most recent call last):
  File "&lt;pyshell#26&gt;", line 1, in &lt;module&gt;
    getattr(b, 'node.inst_{}'.format(b.x))
AttributeError: 'ClassB' object has no attribute 'node.inst_base_A'
</code></pre>
<p>I overcome this if I chain calls to getattr:</p>
<pre><code>&gt;&gt;&gt; getattr(getattr(b, 'node'), b.x)
'base_A'
</code></pre>
<p><em>Out of curiosity</em>: Is there a way to get an attribute of the Base class from grandchildren class besides doing <em>two</em> calls to <code>getattr</code>?</p>
<hr/>
<p>Update: the reason I need it is I'm trying to:
- Get an attribute fron grandparent class (either inst_baseA or inst_baseB)
- Depending on an attribute on my instance (the value of x)</p>
<p>So my code is actually something like: <code>getattr(self, 'node.{}'.format(self.x))</code>. I didn't explain it correctly at the first time, hope it makes more sense now.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>operator.attrgetter</code></a>, but it's really not meant for this kind of thing, so the syntax is pretty awkward:</p>
<pre><code>&gt;&gt;&gt; operator.attrgetter('node.inst_base')(b)
'base'
</code></pre>
<p>But this is really quite unintuitive, so to avoid confusing people who read your code, it's probably better to roll your own multi-getattr instead:</p>
<pre><code>def get_multi_attr(obj, attrs):
    for attr in attrs.split('.'):
        obj = getattr(obj, attr)
    return obj
</code></pre>
<pre><code>&gt;&gt;&gt; get_multi_attr(b, 'node.inst_base')
'base'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">[Python]: <strong>getattr</strong>(<em>object, name[, default]</em>)</a>:</p>
<blockquote>
<p>Return the value of the named attribute of <em>object</em>. <em>name</em> must be a string. If the string is the name of one of the objectâ€™s attributes, the result is the value of that attribute. For example, <code>getattr(x, 'foobar')</code> is equivalent to <code>x.foobar</code>.</p>
</blockquote>
<p><code>node.inst_base</code> is <strong>not</strong> an attribute of <code>b</code>, but:</p>
<ul>
<li><code>node</code> is an attribute of <code>b</code></li>
<li><code>inst_base</code> is an attribute of <code>b.node</code></li>
</ul>
<p>So, you need one <code>getattr</code> call for each "nesting" level. </p>
<p>Considering that I've pasted your code in the interpreter's interactive window:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; getattr(b, 'node.inst_base')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'ClassB' object has no attribute 'node.inst_base'
&gt;&gt;&gt;
&gt;&gt;&gt; getattr(getattr(b, "node", None), "inst_base", None)
'base'
</code></pre>
</blockquote>
<p>Or, to take things further, you can create a getter that works with "nested" attribute names:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; def getattr_nested(obj, nested_attr):
...     attrs = nested_attr.split(".")
...     ret = obj
...     for attr in attrs:
...             ret = getattr(ret, attr, None)
...             if ret is None:
...                     return None
...     return ret
...
&gt;&gt;&gt;
&gt;&gt;&gt; getattr_nested(b, "node.inst_base")
'base'
&gt;&gt;&gt; getattr_nested(b, "node.inst_base2")
&gt;&gt;&gt; getattr_nested(b, "node")
&lt;__main__.Base object at 0x0000021A2A593D30&gt;
</code></pre>
</blockquote>
<p>But that's probably highly inefficient (and also, doesn't handle corner cases), and you'd better use @Aran-Fey's suggestion.</p>
</div>
<span class="comment-copy"><code>getattr(b.node, 'inst_base')</code> or even simpler <code>b.node.inst_base</code>?</span>
<span class="comment-copy">@MSeifert I've updated my question to reflect my situation. I didn't do it right on the first time :)</span>
<span class="comment-copy">Why not just <code>getattr(self.node, self.x)</code>?</span>
<span class="comment-copy">@Aran-Fey this works.. don't know how I didn't see it myself. Thanks a lot</span>
<span class="comment-copy">thanks. I've updated my question to reflect my situation better. Can you check it please?</span>
