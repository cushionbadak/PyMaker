<div class="post-text" itemprop="text">
<p>After reading this <a href="https://stackoverflow.com/questions/85451/pythons-time-clock-vs-time-time-accuracy">Python's time.clock() vs. time.time() accuracy?
</a> and <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="nofollow noreferrer">time.process_time()</a>, among others, I'm pretty confused. </p>
<p>I need CPU time spend grinding out an algorithm. I want the time right before the call and right after it returns.</p>
<pre><code>start = time.time() or time.process_time()
sorted = algorithm(stuff)
end = time.time() or time.process_time()
elapsed = end - start * (1e9)
</code></pre>
<p><code>time.process_time()</code> seems like a great candidate, but I have no idea what units it returns on a Mac, can't seem to find a straight answer, and I need to convert to nanoseconds. I tried time.time() and the answer seemed wildly wrong. Thoughts on what I can do here?</p>
</div>
<div class="post-text" itemprop="text">
<p>For benchmarking python code, consider using the bundled <a href="https://docs.python.org/2/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a> (also in <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">Python 3</a>) package. It has a few advantages over doing it yourself: repeating the test multiple times to allow for OS/System things outside your control, disables garbage collection to prevent skewing of results, and uses the most accurate timer available for the current system (including Python 3.3+'s <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer"><code>perf_counter</code></a>).</p>
<p>You don't mention which Python version you're using, but if you are on 3.3+, <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer"><code>perf_counter</code></a> will give you the most precise timer available.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/time.html#time.process_time" rel="nofollow noreferrer"><code>process_time</code></a> says pretty clearly what units it returns: "Return the value (in fractional seconds)…" As a general rule, time functions in Python that return a float are seconds, time functions that return an int are nanos iff they end in <code>_ns</code>. But rather than guessing, the docs (or <code>help</code> in your interactive interpreter) will always tell you the answer.</span>
<span class="comment-copy">I guess that's as good as it gets then. We don't know what fraction? No tenths, hundredths, etc? Just wanted to get my multiplier right, but it will be close enough for government work. EDIT: Just saw your clarification above very nice.</span>
<span class="comment-copy">Meanwhile, <code>time.time()</code> is just wall clock time. If you want that, it's usually easier to use <code>datetime</code> and not have to worry about units and epochs and so on. But wall clock time has little to do with how much CPU time you've spent.  What you want is either <code>time.process_time</code> or <code>os.times</code> or a third-party lib.</span>
<span class="comment-copy">For more extra information other than the python docs you've already posted. You can take a look to the <a href="https://github.com/python/cpython/blob/master/Modules/timemodule.c#L1075" rel="nofollow noreferrer">source code</a></span>
<span class="comment-copy">@Ryan What do you mean by what fraction? It’s in seconds. It’s a float, so it’s got a few dozen bits of precision. But how accurate it is depends entirely on what your platform provides.</span>
<span class="comment-copy">This is definitely the right answer for benchmarking, but I don’t know whether the OP is benchmarking, profiling, accounting, or…?</span>
