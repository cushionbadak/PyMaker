<div class="post-text" itemprop="text">
<p>I have a numpy array that is split by each row:</p>
<pre><code>splitArray:


[[0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0]]
</code></pre>
<p>I was hoping to merge said splitArray every 4 rows, and the last subarray not necessarily having to be 4, but just the remainder of what's left. </p>
<p>Below is the array I hope to have:</p>
<pre><code>joinedArray:


[[0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0],
 [0,   0,   0,   0,   0,   0,  0,
  0,   0,   0,   0,   0,   0,  0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a pure Numpythonic approach you can find all the desired indexes for splitting your array by creating a range from chunking number to number of rows with the chunking number as the<code>step</code> arg of the <code>range</code>. Then use <code>np.split()</code> to split your array:</p>
<pre><code>In [24]: def chunk_array(arr, ch):
    ...:     x = arr.shape[0]
    ...:     return np.split(a, np.arange(ch, x, ch))
    ...: 
    ...: 
</code></pre>
<p>Demo:</p>
<pre><code>In [25]: chunk_array(a, 4)
Out[25]: 
[array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]), array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]), array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]), array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]])]

In [26]: chunk_array(a, 3)
Out[26]: 
[array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]), array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]), array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]), array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]), array([[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]])]
</code></pre>
<p>If you want the chunked arrays to be concatenated you can use @jpp's answer with <code>np.concatenate()</code> and <code>map</code> or slightly different in a list comprehension.</p>
<pre><code>In [75]: def chunk_array(arr, ch):
    ...:     x = arr.shape[0]
    ...:     return [np.concatenate(subs) for subs in np.split(arr, np.arange(ch, x, ch))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a list-comp:</p>
<pre><code>[a[i:i+4] for i in range(0, len(a), 4)]
#[array([[0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0]]),
# array([[0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0]]),
# array([[0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0]]),
# array([[0, 0, 0, 0, 0, 0, 0],
#        [0, 0, 0, 0, 0, 0, 0]])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That can be done using the infamous <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">grouper</a> recipe.</p>
<pre><code>&gt;&gt;&gt; from itertools import zip_longest
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; 
&gt;&gt;&gt; data = [7 * [0] for i in range(14)]
&gt;&gt;&gt; i=iter(data); list(map(np.concatenate, zip_longest(*4*(i,), fillvalue=[])))
[array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0]), array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0]), array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0]), array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>np.concatenate</code> with <code>np.split</code>. If required, you can adjust the below example to output a list of lists instead of a list of arrays.</p>
<p>As mentioned, a single jagged <code>numpy</code> array is not a good idea.</p>
<pre><code>A = np.zeros((14, 3))

res = list(map(np.concatenate, np.split(A, np.arange(4, A.shape[0], 4))))

print(res)

[array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
 array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
 array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]),
 array([ 0.,  0.,  0.,  0.,  0.,  0.])]
</code></pre>
</div>
<span class="comment-copy">Unless you want to convert back to <code>list</code> rather than <code>np.array</code>, you can't have rows of unequal length.</span>
<span class="comment-copy"><code>numpy</code> does not do well with jagged arrays</span>
<span class="comment-copy">This doesn't actually push the work down to C any more than the list comprehension does, though; <code>numpy.split</code> iterates at Python level and slices the array the same way the list comprehension does, but with extra overhead.</span>
<span class="comment-copy">@user2357112 Yes, but <code>np.split</code> is functional, Numpythonic and more adjustable with other Numpy function. Also another important point in order to prevent future users from heading in a wrong direction is that the term "list comprehension iterations perform at C" or "pushes down the work to C" (as it's mentioned in many books, SO answers, blog posts, etc.)  is one of the most pervasive, utterly false myths about Python. The list comprehension is faster because suspending and resuming a function's frame is slow, not because there's anything particularly special about list comprehensions.</span>
<span class="comment-copy">I started off with this (in fact, my <code>np.split</code> implementation is identical), but then OP's desired output is something else. Should question be modified or answer clarified as to what we're aiming for?</span>
<span class="comment-copy">@jpp You're completely right. I didn't notice that as even the other answer with list comprehension doesn't concatenate the sub-arrays. Let me update the answer. I  still don't know why your answer is not accepted tho :)) but thanks for mentioning this.</span>
<span class="comment-copy">If you're using a slice, the end <code>[start:end]</code> may safely exceed the length of the object in which case it's simply converted to -1. you can safely omit  the <code>min()</code> statement with just <code>a[i:i+4]</code></span>
<span class="comment-copy">@Aaron Cool, I think I really new that just couldn't quite remember - probably from traversing them backwards or something!</span>
