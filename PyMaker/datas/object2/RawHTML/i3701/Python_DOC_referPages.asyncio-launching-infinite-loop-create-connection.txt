<div class="post-text" itemprop="text">
<p>I've been trying trying with no luck to create a endless chain of client instances.</p>
<p>I'm developing an asyncio app, this app among many others things, like running a server with loop.create_server(),  needs every 10 seconds to connect to a list of servers, send some data and then disconnect.</p>
<p>I keep getting 2 errors: "runtimeError: Event loop is running." or "asyncio &gt; Task was destroyed but it is pending!"</p>
<p>The code down below works.</p>
<pre class="lang-py prettyprint-override"><code>import asyncio
from tcp.client import Client


def send_to_peers(data):
    for index in range(1, 3): #this for-loop just for simulating a list of peers
    try:
        loop = asyncio.get_event_loop()
        coro = loop.create_connection(lambda: Client(), '127.0.0.1', 10000 + index)
        _, proto = loop.run_until_complete(coro)
        msg = data + "-" + str(index) + "\n"
        proto.transport.write(str.encode(msg))
        proto.transport.close()
    except ConnectionRefusedError as exc:
        print(exc)

def infinite():
    for index in range(5): #again this should be a While True:
        #there should be here an asyncio.sleep(10)
        send_to_peers(str(index))

infinite()
</code></pre>
<p>But when I call it from the main_loop things start to break.</p>
<pre><code>async def infinite_loop():
    for index in range(5):
        print("loop n " + str(index))
        task = asyncio.Task(send_to_peers(str(index)))
        await asyncio.sleep(10)
        task.cancel()
        with suppress(asyncio.CancelledError):
            await task

main_loop = asyncio.get_event_loop()
main_loop.run_until_complete(infinite_loop())
main_loop.run_forever()
</code></pre>
<p>I've tried to giving the main_loop to send_to_peers , giving it to the Client(loop) class,I tried to stoop &amp; close the loop, delete the task, use weird combination of ensure_future but nothing works.</p>
<p>I googled as much as I could, I read it is not good to nest infinite loops but i didn't find any other way.</p>
<p>My last hope is to use threading but even if I think it will work, it won't be an elegant solution, nor the right one.</p>
<p>I'm used to work with Node so please excuse me if i made a silly mistake, I thought that after 2 weeks i could make it but here I am.</p>
<p>I would really appreciate any help. I'm stuck. Thanks!</p>
<p>PS:
The Client() class is very basic:</p>
<pre><code>import asyncio
import logging
import sys

logging.basicConfig(
    level=logging.DEBUG,
    format='%(name)s &gt; %(message)s',
    stream=sys.stderr
)

class Client(asyncio.Protocol):

    def __init__(self):
        self.log = logging.getLogger('client')
        self.address = None
        self.transport = None

    def connection_made(self, transport):
        self.transport = transport
        self.address = transport.get_extra_info('peername')
        self.log.debug('{}:{} connected'.format(*self.address))

    def data_received(self, data):
            self.log.debug('{}:{} just sent {!r}'.format(*self.address, data))

    def eof_received(self):
        self.log.debug('{}:{} sent EOF'.format(*self.address))

    def connection_lost(self, error=""):
        self.log.debug('{}:{} disconnected'.format(*self.address))
        self.transport.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I keep getting 2 errors: "runtimeError: Event loop is running." or "asyncio &gt; Task was destroyed but it is pending!"</p>
</blockquote>
<p>As you discovered, asyncio event loops <a href="https://bugs.python.org/msg225883" rel="nofollow noreferrer">do not nest</a>.</p>
<p>To remove the nesting, you should define <code>send_to_peers</code> as a coroutine using <code>async def</code>. Inside it <code>loop.run_until_complete(coro)</code> should be changed to <code>await coro</code>. Once <code>send_to_peers</code> is a coroutine, you can call it:</p>
<ul>
<li><p>from blocking code such as <code>infinite</code> using <code>loop.run_until_complete(send_to_peers(...))</code></p></li>
<li><p>from async code such as <code>infinite_loop</code> using <code>await send_to_peers(...)</code>.</p></li>
</ul>
<p>In case of <code>infinite_loop</code>, you can implement the timeout using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer"><code>asyncio.wait_for</code></a>:</p>
<pre><code>try:
    await asyncio.wait_for(send_to_peers(str(index)), 10)
except asyncio.TimeoutError:
    # ... timeout ...
</code></pre>
</div>
<span class="comment-copy">Thank you so much! I was completely stuck for too long and i was quite desperate. Today i tested it and it works like a charm. thanks for telling me about the asyncio.wait_for, that surely did the trick! Here is the working snippet code: <a href="https://pastebin.com/tJEQaBGZ" rel="nofollow noreferrer">pastebin.com/tJEQaBGZ</a> . This project is the first "not tiny" one I'm doing with Python by myself and now it is starting to work thanks to you! It's a gossip protocol ( <a href="https://github.com/CalogeroMandracchia/gossip-protocol" rel="nofollow noreferrer">github.com/CalogeroMandracchia/gossip-protocol</a>) and I'm in the early phase of developing since I can only work on it after work. Again: thanks!</span>
