<div class="post-text" itemprop="text">
<p>I want to make a histogram of all the intervals between repeated values in a list.  I wrote some code that works, but it's using a for loop with if statements. I often find that if one can manage to write a version using clever slicing and/or predefined python (numpy) methods, that one can get much faster Python code than using for loops, but in this case I can't think of any way of doing that.  Can anyone suggest a faster or more pythonic way of doing this?</p>
<pre><code># make a 'histogram'/count of all the intervals between repeated values
def hist_intervals(a):
    values = sorted(set(a))  # get list of which values are in a

    # setup the dict to hold the histogram
    hist, last_index = {}, {}
    for i in values:
        hist[i] = {}
        last_index[i] = -1   # some default value

    # now go through the array and find intervals
    for i in range(len(a)):
        val = a[i]
        if last_index[val] != -1:   # do nothing if it's the first time
            interval = i - last_index[val]
            if interval in hist[val]:
                hist[val][interval] += 1
            else:
                hist[val][interval] = 1
        last_index[val] = i
    return hist

# example list/array
a = [1,2,3,1,5,3,2,4,2,1,5,3,3,4]

histdict = hist_intervals(a)

print("histdict = ",histdict)

# correct answer for this example
answer = {  1: {3:1, 6:1},
            2: {2:1, 5:1},
            3: {1:1, 3:1, 6:1},
            4: {6:1},
            5: {6:1}
            }
print("answer =   ",answer)
</code></pre>
<p>Sample output:</p>
<pre><code>histdict =  {1: {3: 1, 6: 1}, 2: {5: 1, 2: 1}, 3: {3: 1, 6: 1, 1: 1}, 4: {6: 1}, 5: {6: 1}}
answer =    {1: {3: 1, 6: 1}, 2: {2: 1, 5: 1}, 3: {1: 1, 3: 1, 6: 1}, 4: {6: 1}, 5: {6: 1}}
</code></pre>
<p>^ note: I don't care about the ordering in the dict, so this solution is acceptable, but I want to be able to run on <em>really</em> large arrays/lists and I'm suspecting my current method will be slow. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can eliminate the setup loop by a carefully constructed <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>.  Then you're just left with a single scan over the input list, which is as good as it gets.  Here I change the resultant <code>defaultdict</code> back to a regular  <code>Dict[int, Dict[int, int]]</code>, but that's just so it prints nicely.</p>
<pre><code>from collections import defaultdict

def count_intervals(iterable):
    # setup

    last_seen = {}
    hist = defaultdict(lambda: defaultdict(int))

    # The actual work
    for i, x in enumerate(iterable):
        if x in last_seen:
            hist[x][i-last_seen[x]] += 1
        last_seen[x] = i

    return hist

a = [1,2,3,1,5,3,2,4,2,1,5,3,3,4]

hist = count_intervals(a)
for k, v in hist.items():
    print(k, dict(v))

# 1 {3: 1, 6: 1}
# 3 {3: 1, 6: 1, 1: 1}
# 2 {5: 1, 2: 1}
# 5 {6: 1}
# 4 {6: 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is an obvious change to make in terms of data structures. instead of using a dictionary of dictionaries for <code>hist</code> use a <code>defaultdict</code> of <code>Counter</code> this lets the code become</p>
<pre><code>from collections import defaultdict, Counter

# make a 'histogram'/count of all the intervals between repeated values
def hist_intervals(a):
    values = sorted(set(a))  # get list of which values are in a

    # setup the dict to hold the histogram
    hist, last_index = defaultdict(Counter), {}

    # now go through the array and find intervals
    for i, val in enumerate(a):
        if val in last_index
            interval = i - last_index[val]
            hist[val].update((interval,))
        last_index[val] = i
    return hist
</code></pre>
<p>this will be faster as the <code>if</code>'s are written in C, and will also be cleaner.</p>
</div>
<span class="comment-copy">I think a defaultdict of Counters makes more sense here, but it's pretty similar.</span>
<span class="comment-copy">@OscarSmith If you're not using the nice constructor for <code>Counter</code>s, there's no real difference beyond being explicit.</span>
<span class="comment-copy">If we edit @PatrickHaugh's solution so that it returns an actual dict instead of just printing to the console, then the benchmarks are...  Original solution took time of  0.712121740999919 Oscar's solution took time of  3.2474601769999936 Patrick's solution took time of  0.47523080800010575   Interesting that my original turned out to be not all <i>that</i> slow, but still slower than it needed to be.</span>
<span class="comment-copy">@sh37211 What does that benchmark look like without the conversion to dicts? I ask because <code>defaultdict</code>s can be treated like dicts in most contexts.</span>
<span class="comment-copy">Why are you doing <code>sorted(set(a))</code>?  That seems like unnecessarily taking the soolution from <code>O(n)</code> to <code>O(nlog(n))</code></span>
<span class="comment-copy">oh good point. I just didn't change it bc I didn't notice.</span>
<span class="comment-copy">@OscarSmith Thanks for your answer but I timed yours and mine on 1000000 iterations, and yours seems about 5 times slower: "Original solution took time of  0.7265636739998627 Oscar's solution took time of  3.9991242279998005"</span>
<span class="comment-copy">hm, that's weird. What version of python are you using? I think counters might have gotten a really big speed boost in one of the newer versions.</span>
<span class="comment-copy">@OscarSmith Python 3.5 on Google Colab.  If I use Python 3.6 on my Mac laptop, the numbers are: "Original solution took time of  0.8187828499940224 Oscar's solution took time of  3.2331941279699095 Patrick's solution took time of  0.5057042780099437"   That's using "from timeit import default_timer as timer"</span>
