<div class="post-text" itemprop="text">
<p>I am attempting to use Python for the following task: given a set of integers <code>S</code>, produce <code>S + S</code>, the set of integers expressible as <code>s1 + s2</code> for <code>s1</code>, <code>s2</code> members of <code>S</code> (not necessarily distinct).</p>
<p>I am using the following code:</p>
<pre><code>def sumList(l):
    # generates a list of numbers which are sums of two elements of l
    sumL = []
    howlong = len(l)
    for i in range(howlong):
        for j in range(i+1):
            if not l[i]+l[j] in sumL:
                sumL.append(l[i]+l[j])
    return sumL
</code></pre>
<p>This works fine for short enough lists, but when handed a longer list (say, 5000 elements between 0 and 20000) goes incredibly slowly (20+ minutes).</p>
<p>Question: what is making this slow? My guess is that asking whether the sum is already a member of the list is taking some time, but I am a relative newcomer to both Python and programming, so I am not sure. I am also looking for suggestions on how to perform the task of producing <code>S + S</code> in a quick fashion.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has a built-in type <code>set</code> that has very fast lookups.  You can't store duplicates or unhashable objects in a set, but since you want a set of integers, it's perfect for your needs.  In the below, I also use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> to generate the pairs.</p>
<pre><code>from itertools import product

def sums(l):
    return {x+y for x, y in product(l, repeat=2)}

print(sums([1, 2, 3, 4]))
# {2, 3, 4, 5, 6, 7, 8}
</code></pre>
<p>As to why your existing solution is so slow, you might want to look up the term "algorithmic complexity".  Basically, it's a way of categorizing algorithms into general groups based on how well they scale to many inputs.  Your algorithm is a <code>O(n^3)</code> algorithm (it will do about <code>n^3</code> comparisons).  In comparison, the <code>set</code> solution is <code>O(n^2)</code>. It accomplished this by discarding the need to check if a particular sum is already in the <code>set</code>.</p>
</div>
<span class="comment-copy">Yes, the list lookup isn't a great way to do this -- try Python's <a href="https://docs.python.org/2/library/sets.html" rel="nofollow noreferrer"><code>set</code></a> module.</span>
<span class="comment-copy">Thank you for your explanation and assistance.</span>
