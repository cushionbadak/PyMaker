<div class="post-text" itemprop="text">
<p>Seeing the following code:</p>
<pre><code>class Super:
    powers = 'no power'
    def __init__(self, name):
        self.name = name

    def add_power(self, power):
        self.powers = power

dog = Super('dog')
cat = Super('cat')

dog.add_power("bark")
print (dog.powers) # print bark
print (cat.powers) # print no power
</code></pre>
<p>it looks like python's class variable is independent to each instance because change dog instance's <code>powers</code> variable from no power to bark does not affect the cat instance's <code>powers</code> variable</p>
<p>However, by doing this:</p>
<pre><code>class Super:
    powers = ["no power"]
    def __init__(self, name):
        self.name = name

    def add_power(self, power):
        self.powers.append(power) 

dog = Super('dog')
cat = Super('cat')

dog.add_power("bark")
print (dog.powers) # print ['no power', 'bark']
print (cat.powers) # print ['no power', 'bark']  # why cat.powers is also affected???
</code></pre>
<p>The example shows powers variable (it is a list this time) is static since append an element to dog instance's <code>powers</code> also affects cat instance's <code>powers</code>.</p>
<p>I also experimented with changing the powers to an int and increment powers by 1 by calling add_power, and they don't affect each other. So I am really confused why appending an element to a list which is a class variable affects other instances.</p>
</div>
<div class="post-text" itemprop="text">
<p>An instance variable name can <em>shadow</em> a class variable of the same name.  </p>
<pre><code>&gt;&gt;&gt; class A:
...     var = 'class var'
...     
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; vars(a)  # no instance variables
{}
&gt;&gt;&gt; a.var  # attribute lookup resolved at the class level
'class var'
&gt;&gt;&gt; a.var = 'instance var'  # create an instance variable
&gt;&gt;&gt; vars(a)  # the name `var` now exists in the instance dict
{'var': 'instance var'}
&gt;&gt;&gt; a.var  # attribute lookup resolved at the instance level
'instance var'
&gt;&gt;&gt; type(a).var  # note: the class variable still exists!
'class var'
&gt;&gt;&gt; del a.var  # deletes from the instance dict
&gt;&gt;&gt; a.var  # ..but the name `var` remains available at the class level
'class var'
&gt;&gt;&gt; vars(a)  # instance dict is again empty
{}
</code></pre>
<p>It's not the case that the class variable is "static" (<code>A.var</code> can be modified or deleted via normal attribute access).  What's happening instead is: accessing <code>a.var</code> first tries the name <code>var</code> in the instance's namespace (<code>a.__dict__</code>), and if that fails then the lookup falls back to checking in the class's namespace (<code>A.__dict__</code>).</p>
<p>The reason  you don't see the same behaviour when using a list on the class object is that <strong>this line is not an <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment" rel="nofollow noreferrer">assignment statement</a></strong></p></div>
<span class="comment-copy">Related:  <a href="https://stackoverflow.com/q/39108996/674039">How to specify a variable as a member variables of a class or of an instance of the class?</a></span>
<span class="comment-copy">The difference is the top one is using and <b>replacing</b> a class string, and the bottom is using and <b>appending</b> a class list: just because you added something to the class list via <code>dog</code> doesn't make it not a class list.</span>
<span class="comment-copy">Excellent answer. I can't believe this isn't a mega-dupe.</span>
