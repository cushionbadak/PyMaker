<div class="post-text" itemprop="text">
<p>I am trying to figure out how to properly send a CTRL-C signal on Windows using Python. Earlier I was messing around with youtube-dl and embedded it into a PyQt Qthread to do the processing and created a stop button to stop the thread but when trying to download a livestream I was unable to get FFMPEG to stop even after closing the application and I'd have to manually kill the process which breaks the video every time.<br/>
I knew I'd have to send it a CTRL-C signal somehow and ended up using this.   </p>
<pre><code>os.kill(signal.CTRL_C_EVENT, 0)
</code></pre>
<p>I was actually able to get it to work but if you try to download more than one video and try to stop one of the threads with the above signal it would kill all the downloads.<br/>
Is there any way to send the signal to just one thread without effecting the others?<br/>
Here is an example of some regular Python code with 2 seperate threads where the CTRL-C signal is fired in thread_2 after 10 seconds which ends up killing thread_1.</p>
<pre><code>import os
import signal
import threading
import time
import youtube_dl

def thread_1():
    print("thread_1 running")
    url = 'https://www.cbsnews.com/common/video/cbsn_header_prod.m3u8'
    path = 'C:\\Users\\Richard\\Desktop\\'
    ydl_opts = {
        'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
        'outtmpl': '{0}%(title)s-%(id)s.%(ext)s'.format(path),
        'nopart': True,
    }
    ydl_opts = ydl_opts
    with youtube_dl.YoutubeDL(ydl_opts) as ydl:
        try:
            ydl.download([url])
        except KeyboardInterrupt:
            print('stopped')

def thread_2():
    print("thread_2 running")
    time.sleep(10)
    os.kill(signal.CTRL_C_EVENT, 0)

def launch_thread(target, message, args=[], kwargs={}):
    def thread_msg(*args, **kwargs):
        target(*args, **kwargs)
        print(message)
    thread = threading.Thread(target=thread_msg, args=args, kwargs=kwargs)
    thread.start()
    return thread

if __name__ == '__main__':
    thread1 = launch_thread(thread_1, "finished thread_1")
    thread2 = launch_thread(thread_2, "finished thread_2")
</code></pre>
<p>Does anyone have any suggestions or ideas? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not possible to send signals to another thread, so you need to do something else.</p>
<p>You could possibly raise an exception in another thread, using this hack (for which I won't copy the source here because it comes with an MIT license):
<a href="http://tomerfiliba.com/recipes/Thread2/" rel="nofollow noreferrer">http://tomerfiliba.com/recipes/Thread2/</a></p>
<p>With that, you could send a KeyboardInterrupt exception to the other thread, which is what happens with Ctrl-C anyway.</p>
<p>While it seems like this would do what you want, it would still break the video which is currently downloading.</p>
<hr/>
<p>On the other hand, since you seem to only be interested in killing all threads when the main thread exits, that can be done in a much simpler way:</p>
<p>Configure all threads as <a href="https://docs.python.org/3/library/threading.html#threading.Thread.daemon" rel="nofollow noreferrer">daemons</a>, e.g.:</p>
<pre><code>thread = threading.Thread(target=thread_msg, args=args, kwargs=kwargs)
thread.daemon = True
thread.start()
</code></pre>
<p>These threads will exit when the main thread exits, without any additional intervention needed from you.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there any way to send the signal to just one thread without effecting the others?</p>
</blockquote>
<p>I am not a Python expert, but if I was trying to solve your problem, after reading about <a href="https://docs.python.org/3.6/library/signal.html#signals-and-threads" rel="nofollow noreferrer">signal handling in Python3</a>, I would start planning to use multiple processes instead of using multiple threads within a single process.</p>
</div>
<span class="comment-copy">In Windows <code>os.kill(signal.CTRL_C_EVENT, 0)</code> sends Ctrl+C to every process that's attached to the console. (Some Python dev didn't understand that this should have been implemented as <code>killpg</code>, not <code>kill</code>.) The console doesn't send this to any existing thread. In each process, it creates a new thread that executes the <code>CtrlRoutine</code> export of kernel32.dll. This function walks the registered control handler functions. The C runtime has a handler that connects this to <code>SIGINT</code> and <code>SIGBREAK</code>. In turn, Python's signal handler sets a flag that causes the main thread to call the registered function.</span>
<span class="comment-copy">Thanks for the explanation. At first I did not realize how some of the signals worked but after a ton of reading and trial and error I think I found a decent solution for what I was trying to do. I am pretty new to threads and processes but I learned about the package multiprocessing and I am getting close to what I was trying to do. Now that I can get the PID of every process individually I can use <code>ctypes.windll.kernel32.GenerateConsoleCtrlEvent(1, PID)</code> which seems to work perfect to get the processes to exit cleanly.</span>
<span class="comment-copy"><code>os.kill(PGID, CTRL_BREAK_EVENT)</code> calls <code>GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, PGID)</code>. This sends the Ctrl+Break event to processes in a given group, but only if they're attached to the same console as the caller. The console <i>does not</i> send control events to individual processes, just to process groups. A group gets created via the <code>CREATE_NEW_PROCESS_GROUP</code> flag when calling <code>CreateProcess</code>. The group ID (PGID) is the process ID (PID) of the lead process. If you send to a PID that's not also a PGID, the console has undefined behavior, which acts like sending to group 0 (all processes).</span>
<span class="comment-copy">When a new group is created via <code>CREATE_NEW_PROCESS_GROUP</code>, the lead process initially has Ctrl+C disabled (i.e. <code>CtrlRoutine</code> ignores it), which gets inherited by all of its child process, and so on. OTOH, initially Ctrl+Break is enabled for the group. Ctrl+C can be enabled manually in the lead process by having it call <code>SetConsoleCtrlHandler(NULL, FALSE)</code>.</span>
<span class="comment-copy">Thanks a lot, I appreciate the info. I have been trying to read about all of this all day.</span>
<span class="comment-copy">Thanks for your response but I think you misunderstood me, I don't want to kill all the threads at once. I want to be able to stop just one while the others run uneffected.</span>
<span class="comment-copy">That's an interesting link you posted as well, thanks for sharing it.</span>
<span class="comment-copy">@Richard In that case, either send the exception, or just set a flag and check in the thread. If you want to stop <code>ydl.download([url])</code> while it is running, you probably need to send an exception. Or look in that library for a method which can be stopped without an exception.</span>
<span class="comment-copy">I am currently using except KeyboardInterrupt: if that is what you mean and it does work but if I start multiple downloads in seperate threads and then try to stop one, it stops everything. I don't know, I guess I will have to play around with it a bit more but so far have been unable to stop the other threads from stopping at the same time.</span>
<span class="comment-copy">I tried that a bit earlier and had a similar result but I think if I am unable to achieve what I am looking for with threads then I will try multiple processes.</span>
