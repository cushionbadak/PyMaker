<div class="post-text" itemprop="text">
<p>I just found this issue through debugging my code. I had a list of messages as strings that I was trying to concatenate together, and I wanted to add a newline to the end of every message.</p>
<p>Approach 1:</p>
<pre><code>total_str = ""
for m in messages:
    total_str = total_str + m + "\n"
</code></pre>
<p>This was extremely slow - after around the 100,000th message, adding each message took about 2-3s, and around the 300,000th message, this process basically stopped.</p>
<p>Approach 2:</p>
<pre><code>total_str = ""
for m in messages:
    tmp = m + "\n"
    total_str = total_str + tmp
</code></pre>
<p>This approach finished concatenating all 1.6 million messages in less than a second.</p>
<p>What I'm wondering is why is the second approach so much faster than the first?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>a + b + c</code> isn't a single operation that joins <code>a</code>, <code>b</code>, and <code>c</code> into a single string. It is <em>two</em> operations, <code>t = a + b</code> and <code>t + c</code>, which means copying the contents of <code>a</code> <em>twice</em>; once to copy <code>a</code> into <code>t</code>, and again when <code>t</code> gets copied into the result of <code>t + c</code>. Since, in your example, <code>a</code> is the string that keeps getting longer, you are at <em>best</em> doubling the amount of data being copied at each step.</p>
<p>The best approach is to avoid all the temporary str object created by <code>+</code>, and use <code>join</code>:</p>
<pre><code>total_str = "\n".join(messages)
</code></pre>
<p><code>join</code> operates with each string directly, without the need to iteratively append them to an initial empty string one at a time. <code>join</code> figures out, by scanning <code>messages</code>, how long the resulting string needs to be, allocates enough memory for it, then sequentially copies the data from each element of <code>messages</code> into place one at a time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, since <code>a = a + b + c</code> is executed as <code>a = (a + b) + c</code>, one can see that the order of computation is the following:</p>
<ul>
<li><code>tmp_1 = a + b</code>. This has to copy the huge string <code>a</code> because strings are immutable.</li>
<li><code>a = tmp_1 + c</code>. This has to copy the (even more) huge string <code>tmp_1</code> because strings are immutable.</li>
</ul>
<p>So, there are <em>two</em> huge copies involved, while in the second version, <code>a = a + tmp</code> (like in your second example), only <em>one</em> such copy is needed. The latter approach will obviously be faster.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str" rel="nofollow noreferrer">Python's strings</a> are immutable and contiguous. The former means they can't be modified, and the latter means they're stored in one place in memory. This is unlike e.g. a <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" rel="nofollow noreferrer">rope data structure</a>, where appending data is a cheap operation that need only form a new node for the end. It means that the concatenation operation must copy <em>both</em> input strings each time, and with something like <code>total_str = total_str + m + "\n"</code>, since <code>+</code> is <a href="https://docs.python.org/3/reference/expressions.html#evaluation-order" rel="nofollow noreferrer">left associative</a>, copies all of <code>total_str</code> twice. The usual solution is keeping all the small strings until the whole set is completed, and using <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>str.join</code></a> to perform the concatenations in one pass. This would only copy each component string once, instead of a geometric (proportional to square) number of times. Another option, to build a buffer as you go along, is to use <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow noreferrer"><code>io.StringIO</code></a>. That will give you a file-like object, a bit like a <code>StringBuilder</code> in some other languages, from which you can extract the final string. We also have operations like <a href="https://docs.python.org/3/library/io.html#io.IOBase.writelines" rel="nofollow noreferrer"><code>writelines</code></a> that can accept iterables, so the join may not be needed at all. </p>
<p>My guess as for why the second implementation managed to be so much faster (not just about twice as fast), is that there are optimizations in place that can sometimes permit CPython not to perform the copy of the left operand at all. <a href="https://hg.python.org/cpython/file/tip/Objects/unicodeobject.c#l11318" rel="nofollow noreferrer"><code>PyUnicode_Append</code></a> appears to have precisely such an optimization, based on <code>unicode_modifiable</code>, wherein it can mutate an object if the reference count is precisely 1, the string has never been hashed, and a few other conditions. This would typically apply to a local variable where you use <code>+=</code>, and presumably the compiler managed to generate such behaviour when there wasn't a second operator in the same assignment. </p>
</div>
<span class="comment-copy">Bonus: <code>total_str += m + '\n'</code> is <i>also</i> faster than approach #1.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str.join</a></span>
<span class="comment-copy">Your implementation is suffering from the performance issues associated with concatenating immutable strings in a for loop like this; the behavior is polynomial time. However, I suspect that the peep-hole optimizer in the CPython runtime is able to optimize the version with the temporary variable. This is an implementation detail that shouldn't be relied on. Use <code>messages.append("")</code> then <code>'\n'.join(messages)</code></span>
<span class="comment-copy">@juanpa.arrivillaga I don't think that's an optimization. I think it's the exact opposite. CPython is stupid enough to perform <code>a + b + c</code> as <code>(a + b) + c</code>, which results in the long string <code>a</code> being copied twice. (whereas <code>a + (b + c)</code> would only copy it once)</span>
<span class="comment-copy">Good answer, except it's not so obvious that <code>a + b</code> has to create a copy of <code>a</code>. You may want to explain that part in a bit more detail.</span>
