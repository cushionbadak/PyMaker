<div class="post-text" itemprop="text">
<p>I have a list of dictionary in this form : </p>
<pre><code>[
{'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8}, 

{'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8},

{'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8},
]
</code></pre>
<p>and I want to sum the values in this by key for each element in the list like that : </p>
<pre><code>    {
     'signal_8': 3,
     'signal_1': 21,
     'signal_10': 15,
     'signal_5': 6,
     'signal_2': 15,
     'signal_6': 9,
     'signal_4': 27,
     'signal_3': 18,
     'signal_9': 12,
     'signal_7': 24
    }
</code></pre>
<p>what I have tried is the following : </p>
<pre><code>    result = {}
    sm = 0
    for elm in original_list:
        for k,v in elm.items():
            sm += v
            result[k] = sm
    print(result)
</code></pre>
<p>but it still doesn't work.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you want is the <code>Counter</code> collection type. The Python docs on <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections</a> describe it best, but essentially a <code>Counter</code> is a special kind of dictionary where all the values are integers. You can pass any key, including nonexistent ones, and add to them. For example:</p>
<pre><code>from collections import Counter

original_list = [
    {'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8}, 
    {'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8},
    {'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8},
]

result = Counter()

for elem in original_list:
    for key, value in elem.items():
        result[key] += value

print(result)
</code></pre>
<p><strong>Edit: @timgeb provides a variation on this answer which makes native use of the <code>update()</code> method on <code>Counter</code> objects. I would recommend that as the best answer here</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Similar to daveruinseverything's answer, I'd solve this with a <code>Counter</code>, but make use of its <code>update</code> method.</p>
<p>Let <code>signals</code> be your list of dicts.</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; for d in signals:
...     c.update(d)
... 
&gt;&gt;&gt; c
Counter({'signal_4': 27, 'signal_7': 24, 'signal_1': 21, 'signal_3': 18, 'signal_10': 15, 'signal_2': 15, 'signal_9': 12, 'signal_6': 9, 'signal_5': 6, 'signal_8': 3})
</code></pre>
<blockquote>
<p>For Op's sake, can you briefly describe what's happening here?</p>
</blockquote>
<p>A <code>Counter</code> works similar to a <code>dict</code>, but its <code>update</code> method adds values to the values of pre-existing keys instead of overriding them.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that you are summing <code>sm</code> and <code>v</code> no matter the key. Below you can find a reformatted version of your code that works. It simply adds the values from each element from the list to the result object:</p>
<pre><code>from collections import defaultdict

result = defaultdict(int)

for elm in original_list:
    for k, v in elm.items():
        result[k] += v
print(result)
</code></pre>
<p>Or, with a one liner you can have:</p>
<pre><code>result = {key: sum(e[key] for e in original_list) for key in original_list[0].keys()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>, you could do something like</p>
<pre><code>merged_list = sorted(p for l in original_list for p in l.items())
groups = groupby(merged_list, key=lambda p: p[0])
result = {signal: sum(pair[1] for pair in pairs) for signal, pairs in groups}
</code></pre>
<p>If you can assume that each dictionary contains the exact same keys, the above can be simplified to</p>
<pre><code>{k: sum(d[k] for d in original_list) for k in original_list[0]}
</code></pre>
<p>Note also that the data analysis library <a href="https://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a> makes operations such as these trivial:</p>
<pre><code>In [70]: import pandas as pd

In [72]: pd.DataFrame(original_list).sum()
Out[72]:
signal_1     21
signal_10    15
signal_2     15
signal_3     18
signal_4     27
signal_5      6
signal_6      9
signal_7     24
signal_8      3
signal_9     12
dtype: int64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Can you try below code </p>
<pre><code>basedict=siglist[0]
for k in basedict.keys():
    result=[currdict[k] for currdict in siglist]
    endval=sum(result)
    print("Key %s and sum of values %d"%(k,endval))
</code></pre>
<p>Output</p>
<pre><code>Key signal_9 and sum of values 12
Key signal_2 and sum of values 15
Key signal_8 and sum of values 3
Key signal_5 and sum of values 6
Key signal_7 and sum of values 24
Key signal_10 and sum of values 15
Key signal_1 and sum of values 21
Key signal_6 and sum of values 9
Key signal_4 and sum of values 27
Key signal_3 and sum of values 18
</code></pre>
<p>Note :- As we are sure that all keys in all dictionaries are same this solution works well. If you have a dictionary with non matching elements then it would result in <code>KeyError</code> . So be aware of that limitation</p>
</div>
<div class="post-text" itemprop="text">
<p>Your current code uses one accumulating sum for all the signals, when instead you need a seperate the sum for each signal. </p>
<p>If you want your original code to work, you need to first check if the key exists in <code>result</code>, and initialise it 0 beforehand if it isn't. Then accumulate the sum for the respective key. </p>
<p><strong>Code:</strong></p>
<pre><code>result = {}
for elm in original_list:
    for k, v in elm.items():

        # Initialise it if it doesn't exist
        if k not in result:
            result[k] = 0

        # accumulate sum seperately 
        result[k] += v

print(result)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>{'signal_9': 12, 'signal_8': 3, 'signal_1': 21, 'signal_3': 18, 'signal_2': 15, 'signal_5': 6, 'signal_4': 27, 'signal_7': 24, 'signal_6': 9, 'signal_10': 15}
</code></pre>
<p><strong>Note:</strong> As others have shown, to avoid initialising yourself, you can use <a href="https://docs.python.org/3.6/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a> or <a href="https://docs.python.org/3.6/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a> instead. </p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>original_list = [
{'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8}, 

{'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8},

{'signal_8': 1, 'signal_1': 7, 'signal_10': 5, 'signal_5': 2, 'signal_2': 5, 'signal_6': 3, 'signal_4': 9, 'signal_3': 6, 'signal_9': 4, 'signal_7': 8},
]
print({k:sum([x[k] for x in original_list if k in x]) for i in original_list for k,v in i.items()})
</code></pre>
<p>Output:</p>
<pre><code>{'signal_8': 3, 'signal_1': 21, 'signal_10': 15, 'signal_5': 6, 'signal_2': 15, 'signal_6': 9, 'signal_4': 27, 'signal_3': 18, 'signal_9': 12, 'signal_7': 24}
</code></pre>
<p><em>Note that if there are missing signals, it will just consider it as zero</em></p>
</div>
<span class="comment-copy">Why would it work? You have a single number for all the different signals. Look into <code>collections.Counter</code> or <code>.defaultdict</code>.</span>
<span class="comment-copy">I don't understand what <code>test</code> means in your code. Can you please <a href="https://stackoverflow.com/help/mcve">create a minimal, complete and verifiable example</a>?</span>
<span class="comment-copy">@daveruinseverything sorry that was just a spelling mistake I correct it now</span>
<span class="comment-copy">Upvoting this, because it's probably the solution I'd use in my actual code. For Op's sake, can you briefly describe what's happening here?</span>
<span class="comment-copy">Having it around can be good for readability, but it's worth noting that iterating over a dictionary is the same as iterating over its keys, so <code>.keys()</code> could be removed here.</span>
<span class="comment-copy">@fuglede, that is a valid observation. Usage of <code>.keys()</code> is a personal preference that.</span>
<span class="comment-copy">This is a correct solution, but I wouldn't necessarily recommend it. It's difficult to read / parse, and would be difficult to maintain.</span>
<span class="comment-copy">I don't disagree; were I to use it in any sort of shared code, I'd also split it up a bit; let's just go ahead and do that.</span>
<span class="comment-copy">Why would you <code>zip</code> a dictionary's keys and values together? That's what items, which the OP is <i>already using</i>, is for. Also you don't need to create a list given that you can iterate over a zip object.</span>
<span class="comment-copy">@jonrsharpe You are absolutely right, i will edit my answer, and also give an simpler answer</span>
<span class="comment-copy">@jonrsharpe Now it's much better</span>
<span class="comment-copy">This answer has terrible complexity (<code>O(n^2 * m)</code>, where n is the number of dictionaries and m the number of signals per dictionary; it calculates the same value multiple times and only the last one ends up in the output), isn't terribly readable and will throw an error if any dictionary is missing any of the signals. @saul you should really look again at the others.</span>
<span class="comment-copy">This will fail the moment the keys are not the same in each dictionary. And if they are indeed the same, you can avoid looping over all of them and just use <code>original_list[0]</code> instead. Note also that since you never use the values, <code>k, v in i.items()</code> can be boiled down to <code>k in i</code>, and that you don't need to create the list of values to sum over it.</span>
