<div class="post-text" itemprop="text">
<p>The following is my source code and its output from the Win10 command line. </p>
<pre><code>from ctypes import *
class eH():
    x= c_uint(0)
    print (type(x) == c_uint)
print (type(eH.x) == c_uint)
print (eH.x)
print (type(eH.x))
print (type(eH.x) == c_ulong)
print (c_uint == c_ulong)
print (c_int == c_long)
print ("\nEnd of eH prints\n#####")

class eHardware(Structure):
    _fields_= [("xyz", c_uint)]
a= eHardware()
a.xyz= eH.x
print (a.xyz)
print (a.xyz == eH.x)
print (type(a.xyz))
print (type(c_uint(a.xyz)))
</code></pre>
<p>The command line output is in the link: <a href="https://pastebin.com/umWUDEuy" rel="nofollow noreferrer">https://pastebin.com/umWUDEuy</a></p>
<p>First thing I noticed is that c_uint == c_ulong outputs True. Does that mean ctypes dynamically assign types on the fly and treat them as same in memory? Would this design has any implication if I want to port the similar script to a type-sensitive language, say C.</p>
<p>Second, in line 17 I assign a.xyz = eH.x, but in line 19 a.xyz == eH.x evaluates to False. Also, the type of a.xyz is been converted to int, while eH.x is of type c_uint (or c_ulong as it always evaluates to when type() is called)
Thanks in advance for the responses.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>First thing I noticed is that c_uint == c_ulong outputs True.</p>
</blockquote>
<p>This is explained right at the top of <a href="https://docs.python.org/3/library/ctypes.html#return-types" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>Note: Some code samples reference the ctypes <code>c_int</code> type. On platforms where <code>sizeof(long) == sizeof(int)</code> it is an alias to <code>c_long</code>. So, you should not be confused if <code>c_long</code> is printed if you would expect <code>c_int</code> — they are actually the same type.</p>
</blockquote>
<p>If you're wondering why it does this, it's to improve interaction with C code.</p>
<p>C is a weakly typed language—<code>int</code> and <code>long</code> are always distinct types, but you can always implicitly cast between them via the complicated integer promotion and narrowing rules.<sup>1</sup> On many platforms, <code>int</code> and <code>long</code> happen to be both 32 bits, so these rules don't matter much, but on other platforms, <code>long</code> is 64 bits,<sub>2</sub> so they do. Which makes it really easy to write code that works on your machine, but segfaults on someone else's by screwing up the stack (possibly even in a way that can be exploited by attackers).</p>
<p><code>ctypes</code> attempts to reign this in by explicitly defining that <code>c_int</code> is an alias to <code>c_long</code> if and only if they're the same size. So:</p>
<ul>
<li>If you're careful to always use <code>c_int</code> when the C function you're calling wants <code>int</code> and <code>c_long</code> when it wants <code>long</code>, your code will be portable, just like in C.</li>
<li>If you mix and match them arbitrarily, and that happens to be safe on your machine, it'll work on your machine, just like in C.</li>
<li>If you mix and match them arbitrarily, and then try to run them on a machine where that isn't safe, you should get an exception out of <code>ctypes</code> rather than a segfault.</li>
</ul>
<hr/>
<blockquote>
<p>Does that mean ctypes dynamically assign types on the fly and treat them as same in memory?</p>
</blockquote>
<p>I suppose it depends on what you mean by "on the fly". If you look at <a href="https://github.com/python/cpython/blob/master/Lib/ctypes/__init__.py#L176" rel="nofollow noreferrer">the source</a>, you'll see that when the module is compiled, it does this:</p>
<pre><code>if _calcsize("i") == _calcsize("l"):
    # if int and long have the same size, make c_int an alias for c_long
    c_int = c_long
    c_uint = c_ulong
else:
    class c_int(_SimpleCData):
        _type_ = "i"
    _check_size(c_int)

    class c_uint(_SimpleCData):
        _type_ = "I"
    _check_size(c_uint)
</code></pre>
<p>Of course usually, when you <code>import ctypes</code>, you're getting a pre-compiled <code>ctypes.pyc</code> file,<sup>3</sup> so the definition of <code>c_int</code> one way or the other is frozen into that <code>pyc</code>. So, in that sense, you don't have to worry about it being dynamic. But you can always delete the <code>.pyc</code> file, or tell Python not to use them at all. Or you can even monkeypatch <code>ctypes.c_int</code> to be something else, if you really want to. So, in that sense, it's definitely dynamic if you want it to be.<sup>4</sup></p>
<hr/>
<blockquote>
<p>Would this design has any implication if I want to port the similar script to a type-sensitive language, say C.</p>
</blockquote>
<p>Well, the whole point of the design is to match C (and, in particular, the implementation-defined details of the C compiler used to build your CPython interpreter) as closely as possible while at the same time working around a few of the pitfalls of dealing with C. So, it's pretty rare that you design an interface with <code>ctypes</code> and then implement it with C; usually it's the other way around. But occasionally, it does happen (usually something to do with multiprocessing shared memory mapped to numpy arrays…).</p>
<p>In that case, just follow the same rules: make sure to keep <code>c_int</code> and <code>c_long</code> straight in your Python code, and match them to <code>int</code> and <code>long</code> in your C code, and things will work. You will definitely want to enable (and read) warnings in your C compiler to attempt to catch when you're mixing them up. And be prepared for occasional segfaults or memory corruption during debugging, but then you always need to be prepared for that in C.<sup>5</sup></p>
<hr/>
<blockquote>
<p>Also, the type of a.xyz is been converted to int, while eH.x is of type c_uint</p>
</blockquote>
<p>The conversions to native types when you access struct members, pass arguments into C functions and return values out, etc. are pretty complicated. 95% of the time it just does what you want, and it's better to not worry about it. </p>
<p>The first time you hit the other 5% (usually it's because you have a <code>c_char_p</code> that you want to treat as a pointer rather than a string…), there's really no substitute for reading through the docs and learning about the default conversions and <code>_as_parameter_</code> and <code>_CData</code> classes and <code>restype</code> vs. <code>errcheck</code> and so on. And doing a bit of experimentation in the interactive interpreter, and maybe reading the source.<sup>6</sup></p>
<hr/>
<p><sub>1.  Most modern compilers will warn about narrowing conversions, and even let you optionally turn them into errors.</sub></p>
<p><sub>2. In the old days, when <code>ctypes</code> was first designed, it was more common for <code>int</code> to be 16 bits, but the effect is the same.</sub></p>
<p><sub>3. If you use a Windows or Mac Python installer, or an RPM or DEB binary package, or a Python that came preinstalled on your system, the stdlib was almost always compiled at the time of building the binary package, on someone else's machine. If you build from source, it's usually compiled at build or install time on your machine. If not, it usually gets compiled the first time you <code>import ctypes</code>.</sub></p>
<p><sub>4. Although I don't know why you'd want it to be. Easier to just define your own type with a different name…</sub></p>
<p><sub>5. You might want to consider using a language that's statically typed, and C-compatible, but has a much stricter and stronger type system than C, like Rust, or at least C++ or D. Then the compiler can do a lot more to help you make sure you're getting things right. But the tradeoffs here are really the same as they always are in choosing between C and another language; there's nothing all that <code>ctypes</code>-specific involved.</sub></p>
<p><sub>6. And finally throwing your hands in the air and declaring that from now on you're only ever going to use <code>cffi</code> instead of <code>ctypes</code>, which lasts until the first time you run into one of <code>cffi</code>'s quirks…</sub></p>
</div>
<span class="comment-copy">great answer, thank you. btw, does this mean that even by defining the <i>field</i> in myClass(Structure), types of the values are still not guaranteed to be preserved, say c_uint, since python might convert it into int or sth else?</span>
<span class="comment-copy">@nakamurayuristeph The struct itself will always have a <code>c_uint</code> in it. If you pass it to a C function, store it in a <code>multiprocessing.sharedctypes</code>, copy it, cast it to an array of bytes, whatever, it's going to be 4 (or whatever for your platform, but probably 4) bytes representing an unsigned integer in the appropriate endianness. But when you access the struct's fields to try to do Python work on them, they may get "boxed up" in Python values. This usually isn't a problem; it's only when you need to, e.g., tell <code>ctypes</code> to get a pointer to a member of a struct that you have to be careful.</span>
