<div class="post-text" itemprop="text">
<p>I am looking for a code to copy the generator and then continue with the new generator. It is like a bifurcation of a generator. </p>
<pre><code>def Generator():
    myNumbers=range(3)
    for i in myNumbers:
        yield i

for i in Generator():
    bifurcatedGenerator = Generator
    for j in bifurcatedGenerator():
        print (i, j)
</code></pre>
<p>this code gives as output:</p>
<pre><code>0 0
0 1
0 2
1 0
1 1
1 2 &lt;- wrong
2 0
2 1 &lt;- wrong
2 2 &lt;- wrong
</code></pre>
<p>whereas the disiered output should be: (The bifurcated generator needs to be a new instance, but continue at the same point as the old generator stopped.)</p>
<pre><code>0 0
0 1
0 2
1 1
1 2
2 2
</code></pre>
<p>The application itself is much more complicated, this here is just a code example.</p>
<p>Important (only for myself) is a semanticly beautiful solution which is nicely readable to third parties.Efficiency is not so important</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not use a generator with a start parameter (and a stop one while you are at it)?</p>
<pre><code>def Generator(start=0, stop=3):
    for i in range(start, stop):
        yield i

for i in Generator():
    for j in Generator(start=i):
        print (i, j)
</code></pre>
<p>Also gives the output:</p>
<pre><code>0 0
0 1
0 2
1 1
1 2
2 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some people will tell you to use <code>itertools.tee</code>. Do not use <code>itertools.tee</code>.</p>
<h2>Use a <code>list</code></h2>
<p>To keep track of the previous states of your generator, you need to store previously yielded values in a <code>list</code>. This is what the function <code>itertools.tee</code> does when it copies a generator.</p>
<p>Unfortunately, this removes all memory-advantage of using a generator. So you are better to use a <code>list</code>.</p>
<pre><code>def generator():
    yield from range(3)

lst = list(generator())

for i in range(len(lst)):
    for j in range(i, len(lst)):
        print(lst[i], lst[j])
</code></pre>
<p>Output:</p>
<pre><code>0 0
0 1
0 2
1 1
1 2
2 2
</code></pre>
<h2>Why not using <code>itertools.tee</code> then?</h2>
<p>It is still possible to use <code>itertools.tee</code>, but you should not.</p>
<pre><code>from itertools import tee

def generator():
    yield from range(3)

lst = list(generator())

main_gen, bif_gen = tee(generator())

for i in main_gen:
    for j in bif_gen:
        print(i, j)
    _, bif_gen = tee(main_gen) # Yes, you *must* use the second item here
</code></pre>
<p>The reason the previous code works is subtle and is actually linked to the fact that <code>itertools.tee</code> returns the same <code>tee</code> object as first output value when given a <code>tee</code> object. This is why the second generator should be used.</p>
<p>This, coupled to the fact that the <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer">doc</a> explicitly specifies that a <code>list</code> is better in this situation, demonstrates that the first solution must be preferred:</p>
<blockquote>
<p>This itertool may require significant auxiliary storage (depending on
  how much temporary data needs to be stored). In general, if one
  iterator uses most or all of the data before another iterator starts,
  it is faster to use <code>list()</code> instead of <code>tee()</code>.</p>
</blockquote>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/21315207/deep-copying-a-generator-in-python">deep-copying a generator in python</a></span>
<span class="comment-copy">That's now really beautiful.</span>
<span class="comment-copy">Why not just use range actually..? If this is your actual workcase, using a generator is pointless.</span>
<span class="comment-copy">@OlivierMelan√ßon:You are absolutly right, The main point of my question was differen:  this was only a simple example for a more complicated code, which I am programming now. Anyway, thanks for your input, it was valuable and got me further.</span>
<span class="comment-copy">Rather than relying on the completely undocumented fact that teeing a tee reuses the underlying tee structure of the input, you could use the barely documented fact that tees are copyable with <code>copy.copy</code>.</span>
<span class="comment-copy">(The only documentation that tees are copyable is in the <code>tee_lookahead</code> example in the Python 2 docs, at the end of the <a href="https://docs.python.org/2/library/itertools.html#recipes" rel="nofollow noreferrer">itertools recipes</a>.)</span>
<span class="comment-copy">I am looking for a beautiful solution (efficency is not so important). So I like your itertools.tee solution. Your line lst = list(generator()) is not necessary.</span>
<span class="comment-copy">@user2357112 The whole point is that it is documented that tee <i>should not</i> be used here</span>
<span class="comment-copy">@MarcelSonderegger No, the whole point here is that you <i>must not</i> use tee, it could backfire</span>
