<div class="post-text" itemprop="text">
<p>I am trying to encode logic to filter a Pandas dataframe. I'd like to encode the logic as a dictionary, with the subgroup name as the key, and the function to filter for the subgroup as the value:</p>
<pre><code>analytics_table_mappings = {
"Jets Fans": BaseFilter.for_jets_fans,
"Patriots Fans": BaseFilter.for_patriots_fans,
...
}
</code></pre>
<p>My <code>BaseFilter.for_jets_fans</code> and <code>BaseFilter.for_patriots_fans</code> are static methods that contain the logic to filter my dataframe for each group of fans.</p>
<p>However, I'd like to create a function <code>BaseFilter.for_team_fans</code> that accepts a <code>team</code> string parameter to designate which team's fans to filter for.</p>
<p>My current attempt is to encoding something like this </p>
<pre><code>analytics_table_mappings = {
"Jets Fans": {"func": BaseFilter.for_team_fans, "args": "Jets"},
"Patriots Fans":  {"func": BaseFilter.for_team_fans, "args": "Patriots"},
...
}
</code></pre>
<p><strong>My question: Is there a more elegant, less convoluted, more maintainable way of doing this?</strong> For context, I'm a data scientist, and this is part of a large model that I eventually need to hand off to my engineering team to maintain and upkeep. They've asked me to limit the amount of domain specific language (DSL) to help soften the learning curve and increase the code base maintainability. I feel like using </p>
<pre><code>"Jets Fans": {"func": BaseFilter.for_team_fans, "args": "Jets"},
"Patriots Fans":  {"func": BaseFilter.for_team_fans, "args": "Patriots"}, 
</code></pre>
<p>has the potential to quickly evolve into a very complex and unmanageable DSL. The reason why I am encoding my filtering logic is because the types of metrics that we filter for, and how we filter for them- are likely to evolve frequently, so instead of hardcoding them into my code base, I separated the filter logic out into separate <code>configurations.py</code> files that are comprised of dictionaries (ie. <code>analytics_table_mappings</code>). Thus, I'd like to keep flexibility in my filter logic while still making it maintainable for my engineers. </p>
<p>Add on:</p>
<p>I also need to be capable of handling instances where multiple parameters must be passed. For instance:</p>
<pre><code>    "Jets Fans": {"func": BaseFilter.for_team_fans, "args": "Jets"},
    "Patriots Fans":  {"func": BaseFilter.for_team_fans, "args": "Patriots"},
"NFC Fans": {"func": BaseFilter.for_team_fans, "args": ["Bears", "Packers", ...]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can consider <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow noreferrer"><code>functools.partialmethod</code></a>, which allows you to specify any number of <code>args</code> or <code>kwargs</code>:</p>
<pre><code>from functools import partialmethod

mappings = {'Jets Fans': partialmethod(BaseFilter.for_jets_fans, 'Jets'),
            'Patriots Fans': partialmethod(BaseFilter.for_patriots_fans, 'Patriots'),
            'NFC Fans': partialmethod(BaseFilter.for_team_fans, 'Bears', 'Packers')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>BaseFilter.for_team_fans</code> is the common base function for every entry in your <code>analytics_table_mappings</code> dict, then you can factor it out. Since that leaves only one property, the dict could be reduced to a simple <code>key: args</code> pairing, such as</p>
<pre><code>analytics_table_mappings = {
    "Jets Fans": "Jets",
    "Patriots Fans": "Patriots",
    "NFC Fans": ["Bears", "Packers", ...]
}
</code></pre>
<p>and then maybe incorporate the logic into a simple class:</p>
<pre><code>class Teams:
    analytics_table_mappings = {
        "Jets Fans": "Jets",
        "Patriots Fans": "Patriots",
        "NFC Fans": ["Bears", "Packers", ...]
    }

    @classmethod
    def get_teams(cls, fan_type):
        if fan_type not in cls.analytics_table_mappings:
            return 'Invalid fan type: {}'.format(fan_type)
        teams = cls.analytics_table_mappings[fan_type]
        if not isinstance(teams, list):
            teams = [teams]
        return [cls.for_team_fans(team) for team in teams]

    def for_team_fans(team_name):
        # your logic here
        return team_name


print(Teams().get_teams("Jets Fans"))
&gt;&gt; ['Jets']

print(Teams().get_teams("Patriots Fans"))
&gt;&gt; ['Patriots']

print(Teams().get_teams("NFC Fans"))
&gt;&gt; ['Bears', 'Packers', ...]

print(Teams().get_teams("Argonauts Fans"))
&gt;&gt; Invalid fan type: Argonauts Fans
</code></pre>
</div>
