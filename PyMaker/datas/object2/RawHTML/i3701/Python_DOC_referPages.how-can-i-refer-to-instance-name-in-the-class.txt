<div class="post-text" itemprop="text">
<p>in this code:</p>
<pre><code>class X:
    def __init__(self, y=None):
        self.y = y
        self.z = []
        try:
            y.z.append(self)
        except:
            pass

a = X()
b = X(a)
c = X(a)

print(a.z)
</code></pre>
<p>I want to print [b, c] but it prints something like this </p>
<pre><code>out: &lt;__main__.x object at 0x01775E70&gt;, &lt;__main__.x object at 0x01775E90&gt;]
</code></pre>
<p>how i can fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Impossible*. Names refer to values unidirectionally. You cannot go from a value to a name. Consider many names refering to the same value, e.g. <code>a = b = 1</code>. What would be the <em>true</em> name of the value <code>1</code>? There is none, all names are equal.</p>
<p>*without inspecting the source code. And as I said, what should happen to how <code>a.z</code> is displayed if you then assign <code>c = b</code>? What you are trying to do is fruitless and if you really need it you have a design issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want <code>print</code> to display a text for an object, you need to implement the <a href="https://docs.python.org/2.7/reference/datamodel.html#object.__str__" rel="nofollow noreferrer">__str__</a> method:</p>
<pre><code>class X:
    def __init__(self, name, y=None):
        self.name = name
        self.y = y
        self.z = []
        try:
            y.z.append(self)
        except:
            pass

    def __repr__(self):
        return self.name


a = X("a")
b = X("b", a)
c = X("c", a)

print(a.z)
</code></pre>
<p>Or did you want print to use the name of the reference of the object?</p>
</div>
<span class="comment-copy">Please take a look at the code in your question and fix the indentation</span>
<span class="comment-copy">What's there to fix? That's how python represents <code>b</code> and <code>c</code>.</span>
<span class="comment-copy">i want to it sends back me just right [b,c] not the addresses of them</span>
<span class="comment-copy"><code>b</code> and <code>c</code> are objects (instances of X), how do you expect for Python to know how you want them represented? If you want a custom representation, read on <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>__repr__()</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__()</code></a> <i>magic</i> methods.</span>
<span class="comment-copy">Do not use code as data. If you want your objects to have a <code>.name</code> attribute, then give them a <code>.name</code> attribute.</span>
<span class="comment-copy">A nitpick - not impossible but very impractical (and mostly useless). The assignment can be backtracked by inspecting the previous frame to pick up the name it's being assigned to - sort of a simplified version of <a href="https://stackoverflow.com/a/45113210/7553525"><b>this</b></a> without the back-assignment. It's still very, very not recommended.</span>
<span class="comment-copy">i know that but in this case i want those names, what can i do for that?</span>
<span class="comment-copy">@zwer satisfied? :)</span>
<span class="comment-copy">@papay you can't in any way that would make sense.</span>
<span class="comment-copy">@timgeb - Very ðŸ˜‹</span>
<span class="comment-copy">this code also print "[&lt;__main__.X object at 0x01777D70&gt;, &lt;__main__.X object at 0x01777D90&gt;]"</span>
<span class="comment-copy">Fixed it, list.__str__ display the object inside the list using their __repr__method</span>
