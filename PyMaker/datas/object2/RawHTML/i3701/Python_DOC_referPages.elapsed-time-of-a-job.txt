<div class="post-text" itemprop="text">
<p>I've put some code together to do my work. It works fine but it needs to work every 4 or 5 secs. So taking account into 4-5secs rule I have added the below code into my existing code.</p>
<pre><code>#my code starts
import time, json, requests
start = time.process_time()

--- def 2 functions and do something with them ---

while True:
   with open('out.txt', 'a') as f:
        print("the result") +
              time.strftime('%Y-%m-%d %H:%M:%S',
                            time.localtime(time.time())), file=f)
  print(time.process_time() - start)
  time.sleep(2)
</code></pre>
<p>With this added code I am defining a variable called <code>start</code> at the beginning and deduct this variable from the current time at the end with <code>time.process_time() - start</code>. This way I aim to calculate how many secs have passed since the beginning. As a result of this code here:</p>
<pre><code>print(time.process_time() - start)
</code></pre>
<p>I see a 1.1 secs average time on my terminal window.</p>
<p>So after 2 secs of sleep time this code runs again that takes 1.1 avg. to complete and appends the new result and current time to the <code>out.txt</code> file.</p>
<p>My question is:</p>
<p>I expect the time at the end of the line in out.txt 3.1 secs greater than the previous one (2 secs sleep time plus 1.1 run time) but it gives me 10 secs difference between lines which I can't understand.</p>
<p>Why do I get 10 secs difference between the two results, 
and how can I reduce this to 3.1 secs?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure exactly what you're trying to accomplish here, but I'm pretty sure <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="nofollow noreferrer"><code>process_time</code></a> is not the function you want to use for it. That function returns:</p>
<blockquote>
<p>â€¦ the value (in fractional seconds) of the sum of the system and user CPU time of the current process. It does not include time elapsed during sleep.</p>
</blockquote>
<p>So, if you do 1.1 seconds of work and sleep for 2 seconds, you'll get back about 1.1, not 3.1, just like you're seeing.<sup>1</sup> If you want walk clock time, not processor time, don't use this function.</p>
<p>What <em>should</em> you use? It depends on what you're trying to do. If you want to benchmark code, use <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a>. For profiling, use <a href="https://docs.python.org/3/library/profile.html" rel="nofollow noreferrer"><code>profile</code></a>. For general-purpose wall-clock time processing, you usually want <a href="https://docs.python.org/3/library/datetime.html" rel="nofollow noreferrer"><code>datetime</code></a>. If you want an in-process job scheduler, there are a zillion choices on PyPI with different strengths and weaknesses. The <a href="https://docs.python.org/3/library/time.html" rel="nofollow noreferrer"><code>time</code></a> module has most of the low-level stuff you'd need to build those other modules, and functions that mimic C APIs if you're familiar with dealing with <code>struct tm</code> and the like, but otherwise it usually shouldn't be the first place you look. But if you do want to use <code>time</code> here, I suspect it would be <code>time</code> or <code>monotonic</code> you want here, not <code>process_time</code>.</p>
<hr/>
<p><sub>1. I don't know why you got the 10 seconds. But in your posted code, you're not actually repeating the slow work each time through the <code>while True:</code> loop, you're just writing a line to a file and sleeping 2 seconds again. So I assume your real code is significantly different, and whatever we're looking for is part of those differences.</sub></p>
</div>
<span class="comment-copy">What exactly are you trying to measure here? <code>process_time()</code> is CPU time used, not wall-clock time. So if, for example, you spend 2 seconds in a <code>time.sleep()</code>, it should be a fraction of a millisecond, while if you use up 4 cores doing GIL-free numpy operations for 1 second, it might be around 1 second or it might be around 4.</span>
<span class="comment-copy">Meanwhile, whatever you're trying to do, you probably want to use higher-level functions. If you want to benchmark code, use <code>timeit</code>. If you want to profile code, use <code>profile</code>. If you want to write a scheduler, unless it needs sub-milli precision, use <code>datetime</code>. (Or, better, grab an existing one off PyPI.) And so on.</span>
<span class="comment-copy">I tried to calculate time and reduce the time if it is possible. timeit and profile gave me another vision.Thank you</span>
