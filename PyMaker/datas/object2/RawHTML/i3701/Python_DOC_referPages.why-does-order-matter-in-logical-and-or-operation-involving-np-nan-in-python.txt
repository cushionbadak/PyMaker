<div class="post-text" itemprop="text">
<p>Bool value of np.NaN is True. Then why and/or operation behaves so random in python.</p>
<pre><code>bool(np.nan) == True
</code></pre>
<p>If <code>True or np.nan</code> evaluates to <code>True</code> then why does <code>np.nan or True</code> evaluate to <code>nan</code>? And this is completely reverse for and operation:</p>
<p><code>True and np.nan</code> is <code>nan</code> while <code>np.nan and True</code> is <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is due to the way the interpreter evaluates expressions with <code>and</code>/<code>or</code>:</p>
<ul>
<li><p><code>or</code> expressions:</p>
<p>If the first operand is <code>True</code> or equivalent to <code>True</code>, the second operand is not evaluated and the value of the first operand is returned.</p>
<p>If the first operand is <code>False</code> or equivalent to <code>False</code>, the second operand is evaluated and returned</p>
<p><em>Examples:</em></p>
<blockquote>
<p><code>True or np.nan</code>: <code>bool(True)</code> is <code>True</code>, therefore return <code>True</code></p>
<p><code>np.nan or True</code>: <code>bool(np.nan)</code> is <code>True</code>, therefore return <code>np.nan</code></p>
<p><code>False or np.nan</code>: <code>bool(False)</code> is <code>False</code>, therefore return <code>np.nan</code> </p>
</blockquote></li>
<li><p><code>and</code> expressions:</p>
<p>If the first operand is <code>False</code> or equivalent to <code>False</code>, the second operand is not evaluated and the value of the first operand is returned</p>
<p>If the first operand is <code>True</code> or equivalent to <code>True</code>, the second operand is evaluated and returned</p>
<p><em>Examples:</em></p>
<blockquote>
<p><code>True and np.nan</code>: <code>bool(True)</code> is <code>True</code>, therefore return <code>np.nan</code></p>
<p><code>np.nan and True</code>: <code>bool(np.nan)</code> is <code>True</code>, therefore return <code>True</code></p>
<p><code>False and np.nan</code>: <code>bool(False)</code> is <code>False</code>, therefore return <code>False</code></p>
</blockquote></li>
</ul>
</div>
<span class="comment-copy">I have trouble understanding your examples and the question itself. Anyway due to operator precedence <code>x and y == z</code> is equivalent to <code>x and (y == z)</code>. Thus obviously is not the same as <code>y and x == z</code>.</span>
<span class="comment-copy">See this SO Post... <a href="https://stackoverflow.com/q/43925797/6361531">stackoverflow.com/q/43925797/6361531</a></span>
<span class="comment-copy">In addition to Jacques' explanation, this is called <a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="nofollow noreferrer">short circuiting</a>. Try <code>2 or 1/0</code> for example, this will return <code>2</code> because the first operand is Trueish and its value is 2. But if you change the order it will raise a ZeroDivisionError.</span>
<span class="comment-copy">But why at times np.NaN is replaced with True, while at times it is still np.NaN?</span>
<span class="comment-copy">It is not replaced by <code>True</code>: depending on whether the first operand is true-ish or not, the first or second operand is returned.</span>
