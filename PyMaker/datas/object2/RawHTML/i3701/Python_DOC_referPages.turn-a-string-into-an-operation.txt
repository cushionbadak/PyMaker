<div class="post-text" itemprop="text">
<p>Is there any way to convert a string with variables into an operation??</p>
<p>For example</p>
<pre><code>a = 3
b = 7

str = 'a * b'

# *MAGIC SOLUTION TO TURN IT INTO AN OPERATION*

print (str) # Prints 21
</code></pre>
<p>Please, <em>don't give others solutions for the problem</em>, because I know it's very easy to do by a diferent way. But <strong>I really need it for a harder problem</strong> </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this safely by using in-built <code>operator</code> package, and using <code>globals</code></p>
<pre><code>from operator import sub, add, truediv, mul
import re

def string_eval(str_):
     operators = {'-': sub, '+': add, '/': truediv, '*': mul}
     pattern = re.compile(r'(.*?)\s*([*\/+-])\s*(.*)')  
     splited = re.search(pattern, str_).groups()
     if len(splited) == 3:
         a, ope, b = splited
         val_a = globals()[a]
         val_b = globals()[b]
         return operators[ope](val_a, val_b)
</code></pre>
<p>Now for this to work you have to declare the variables first</p>
<pre><code>&gt;&gt;&gt; a = 45
&gt;&gt;&gt; b = 25
&gt;&gt;&gt; string_eval('a - b')
20
&gt;&gt;&gt; string_eval('a * b')
1125
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.6+, you can use <a href="https://www.python.org/dev/peps/pep-0498/?" rel="nofollow noreferrer">literal string interpolation</a>.</p>
<pre><code>a = 3
b = 7

print(f'{a * b}') # prints: '21'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming "don't give others solutions for the problem, because I know it's very easy to do by a diferent way" is referring to <code>eval</code> as the easy answer you don't want.</p>
<p>But really, what you want is almost certainly a function that parses and interprets an expression in some language, just like <code>eval</code> does, it's just that you want a simpler and more restricted language than Python, maybe just basic arithmetic expressions.</p>
<p>As <a href="https://stackoverflow.com/a/50752860/908494">Olivier Melançon's answer shows</a>, Python also comes with an interpreter for a limited subset of Python in the f-string evaluator, and as <a href="https://stackoverflow.com/a/50752804/908494">jedwards' answer shows</a>, there are readily-available interpreters for what are effectively similar languages to such a subset.</p>
<hr/>
<p>But if you want to handle exactly the language you want in exactly the way you want, you have to do it yourself. And it's not actually as scary as it sounds. I'll use Python's own <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer"><code>ast</code></a> module for parsing, but then write my own interpreter. This works as long as you really want a strict subset of Python, but if you want something different—e.g., <code>^</code> for exponentiation (which has the wrong precedence and associativity), or variables that aren't valid Python identifiers, etc., you'll have to build the parser too.</p>
<pre><code>import ast
import operator

ops = {
    ast.Add: operator.add, 
    ast.Sub: operator.sub,
    ast.Mult: operator.mul,
    ast.Div: operator.truediv,
}
def interpret(expr, env):
    if isinstance(expr, ast.Expr):
        return interpret(expr.value, env)
    elif isinstance(expr, ast.BinOp):
        op = ops[type(expr.op)]
        return op(interpret(expr.left, env), interpret(expr.right, env))
    elif isinstance(expr, ast.Num):
        return expr.n
    elif isinstance(expr, ast.Name):
        val = env[expr.id]
        if isinstance(val, (bool, int, float, complex)):
            return val
        raise ValueError(val)
    else:
        raise ValueError(expr)
def evaluate(s, env=None):
    if env is None: env = globals()
    tree = ast.parse(s)
    return interpret(tree.body[0], env)
</code></pre>
<p>Now, you can evaluate anything using the basic 4 arithmetic operators, parentheses, numeric constants, or the names of global variables whose values are numbers, but nothing else:</p>
<pre><code>&gt;&gt;&gt; a = 3
&gt;&gt;&gt; b = 7
&gt;&gt;&gt; evaluate('a * b')
21
&gt;&gt;&gt; evaluate('3*a + 2*(b+10)')
32
&gt;&gt;&gt; evaluate('__import__("os")')
ValueError: &lt;_ast.Call object at 0x109210da0&gt;
&gt;&gt;&gt; evaluate('a * b', {'a': 10, 'b': 1j})
10j
&gt;&gt;&gt; evaluate('-2')
ValueError: &lt;_ast.UnaryOp object at 0x1092fc5c0&gt;
</code></pre>
<p>Obviously the error handling could be nicer, and I probably should have handled at least unary <code>-</code> in case you want negative numbers… but this should be enough to get the point across. And reading the <code>ast</code> docs linked above, it should be clear how to extend this further.</p>
<hr/>
<p>On the other hand, <a href="https://stackoverflow.com/a/50753082/908494">Bijoy's answer</a> is an even simpler parser and interpreter. It won't handle more complicated expressions—but if you don't want it to, that's a feature, not a bug.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the sympy library (<a href="http://docs.sympy.org/latest/tutorial/basic_operations.html" rel="nofollow noreferrer">docs</a>) is one approach:</p>
<pre><code>from sympy import Symbol, sympify

# Define symbols
a = Symbol('a')
b = Symbol('b')

# Parse the string into an equation
eqn = sympify('a * b')

# Substitute values for variables
eqn = eqn.subs(a, 3)
eqn = eqn.subs(b, 7)

print(eqn) # Prints 21
</code></pre>
<p>Or, even closer to what you had written (but I like it considerably less):</p>
<pre><code>from sympy import sympify

a = 3
b = 7

# Parse the string into an equation
eqn = sympify('a * b', locals = locals())

print(eqn) # Prints 21
</code></pre>
<p><strong>EDIT NOTE</strong>: Obligatory mention of disappointment, <a href="http://docs.sympy.org/latest/modules/core.html#sympy.core.sympify.sympify" rel="nofollow noreferrer"><code>sympify</code>, the string-to-equation parsing command, using <code>eval()</code></a>.  :sad face:</p>
<p>That being said, sympy is a helpful library worth considering, and you can certainly build an equation without using <code>sympify</code>.</p>
</div>
<span class="comment-copy">You might be interested in <a href="http://www.sympy.org/en/index.html" rel="nofollow noreferrer">sympy</a>.  (<a href="http://docs.sympy.org/latest/tutorial/basic_operations.html" rel="nofollow noreferrer">Examples in docs</a>, look for Symbol, sympify and subs)</span>
<span class="comment-copy">Fair warning, any answer suggesting <code>eval</code> will be unconditionally downvoted.</span>
<span class="comment-copy">@Poppinyoshi <a href="https://stackoverflow.com/questions/1832940/why-is-using-eval-a-bad-practice" title="why is using eval a bad practice">stackoverflow.com/questions/1832940/…</a></span>
<span class="comment-copy">@What does this mean? <code>Please, don't give others solutions for the problem, because I know it's very easy to do by a diferent way</code></span>
<span class="comment-copy">How do we know which "other solutions" to not provide? If you know of some solutions, what is wrong with them that is causing you to look for something different?</span>
<span class="comment-copy">One question: why are you using <code>get</code> instead of <code>[]</code>? That may prevent <code>KeyError</code> exceptions, but it's only going to get you a <code>TypeError</code> instead (either from trying to call <code>None</code>, or trying to pass <code>None</code> to an operator function), and I don't think that's any clearer to the user.</span>
<span class="comment-copy">@AGNGazer Somewhat surprisingly, <a href="https://regex101.com/r/jnvbpw/1" rel="nofollow noreferrer">it looks like I did get it right</a>. :) (EDIT: no I didn't, but thanks to Bijoy <a href="https://regex101.com/r/jnvbpw/3" rel="nofollow noreferrer">now I think I did</a>…)</span>
<span class="comment-copy">@abarnert add <code>-</code> too after <code>+</code>, then it works well for add, sub, mul and div.</span>
<span class="comment-copy">You really need to switch to <code>[]</code> as @abarnert suggested. Better crash than return <code>None</code></span>
<span class="comment-copy">lol that was a nice loophole, got rid of <code>get()</code>.</span>
<span class="comment-copy">This is awesome!</span>
