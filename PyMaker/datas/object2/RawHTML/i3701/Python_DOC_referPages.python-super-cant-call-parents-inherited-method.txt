<div class="post-text" itemprop="text">
<p>I have a question in Python that seems very complex to me, that combines inheritance, recursion, and the super() function.</p>
<p>First of all, I am using Python 3, and I have a structure of deep inheritance.</p>
<p>In the very first parent class I declare a method, and I want that method to be called from each child class in the hierarchy, but with different inputs for each of them. </p>
<p>The use of that structure seems very pythonic to me and it really saves me from a lot of code repetition.</p>
<p>A simplified sample of my code is shown below:</p>
<pre><code>class ClassA(object):
    def __init__(self):
        self.attr = 'a'


    @classmethod
    def _classname(cls):
        return cls.__name__


    def method1(self):
        if self._classname() != 'ClassA': #don't call it for the very first parent class
            super().method1()
        print(self.attr)

class ClassB(ClassA):
    def __init__(self):
        self.attr = 'b'


class ClassC(ClassB):
    def __init__(self):
        self.attr = 'c'


inst1 = ClassC()
inst1.method1()
</code></pre>
<p>I expect that code to print </p>
<pre><code>'a'
'b'
'c'
</code></pre>
<p>Instead it raises an attribute error:</p>
<pre><code>super().method1()
AttributeError: 'super' object has no attribute 'method1'
</code></pre>
<p>I know that it is a complex problem, but I have tried to divide it. I tried to remove the recursion part, but I do not get any better.</p>
<p>Based on the various attempts I have done, I believe that I am very close to the cause of the problem, and it seems to me like a syntax problem or something that simple.</p>
<p>Thanks!!</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm afraid you have built up the wrong mental model on how Python instances and classes relate. Classes only provide a series of attributes for instances to 'inherit', not separate namespaces for instance attributes to live in. When you look up an attribute on an instance and the attribute doesn't exist on the instance itself, a search is done of the classes that back the instance, with the 'nearest' class with that attribute winning over others. <code>super()</code> just lets you reach attributes with the same name but defined on a next class in that same layered search space.</p>
<p>In order for <code>super()</code> to work correctly, <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic/19609168#19609168">Python records what class the <code>method1</code> function was defined on</a>. Here that's <code>ClassA</code>, and <code>super()</code> will <em>only</em> find attributes on the parent classes of <code>ClassA</code>. In your example, <code>ClassC</code> and <code>ClassB</code> had already been searched and they didn't have a <code>method1</code> attribute, so <code>ClassA.method1</code> is being used, but there is no further <code>method1</code> attribute in the rest of the layers that are searched (only <code>object</code> remains, and there is no <code>object.method1</code>).</p>
<p>You don't need to use <code>super()</code> when subclasses are not overriding a method, nor can you do what you want with <code>super()</code> anyway. Note that the <code>ClassB</code> and <code>ClassC</code> subclasses do not get a copy of the method at all, there is no <code>ClassC.method1</code> direct attribute that needs to account for <code>ClassB.method1</code> to exist, etc. Again, what happens when looking up attributes on an instance is that <em>all</em> class objects in the inheritance hierarchy of the instance are inspected for that attribute, in a specific order.</p>
<p>Take a look at your subclasses:</p>
<pre><code>&gt;&gt;&gt; inst1
&lt;__main__.ClassC object at 0x109a9dfd0&gt;
&gt;&gt;&gt; type(inst1)
&lt;class '__main__.ClassC'&gt;
&gt;&gt;&gt; type(inst1).__mro__
(&lt;class '__main__.ClassC'&gt;, &lt;class '__main__.ClassB'&gt;, &lt;class '__main__.ClassA'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>The <code>__mro__</code> attribute gives you the <em>method resolution order</em> of your <code>ClassC</code> class object; it is this order that attributes are searched for, and that <code>super()</code> uses to further search for attributes. To find <code>inst1.method</code>, Python will step through each of the objects in <code>type(inst1).__mro__</code> and will return the first hit, so <code>ClassA.method1</code>.</p>
<p>In your example, you used <code>super()</code> in the <code>ClassA.method1()</code> definition. Python has attached some information to that function object to help further searches of attributes:</p>
<pre><code>&gt;&gt;&gt; ClassA.method1.__closure__
(&lt;cell at 0x109a3fee8: type object at 0x7fd7f5cd5058&gt;,)
&gt;&gt;&gt; ClassA.method1.__closure__[0].cell_contents
&lt;class '__main__.ClassA'&gt;
&gt;&gt;&gt; ClassA.method1.__closure__[0].cell_contents is ClassA
True
</code></pre>
<p>When you call <code>super()</code> the closure I show above is used to start a search along the <code>type(self).__mro__</code> sequence, <em>starting at the next object past the one named in the closure</em>. It doesn't matter that there are subclasses here, so even for your <code>inst1</code> object everything is skipped an only <code>object</code> is inspected:</p>
<pre><code>&gt;&gt;&gt; type(inst1).__mro__.index(ClassA)  # where is ClassA in the sequence?
2
&gt;&gt;&gt; type(inst1).__mro__[2 + 1:]  # `super().method1` will only consider these objects, *past* ClassA
(&lt;class 'object'&gt;,)
</code></pre>
<p>At no point are <code>ClassB</code> or <code>ClassC</code> involved here anymore. The MRO depends on the class hierarchy of the current instance, and you can make radical changes when you start using <em>multiple inheritance</em>. Adding in extra classes into a hierarchy can alter the MRO enough to insert something between <code>ClassA</code> and <code>object</code>:</p>
<pre><code>&gt;&gt;&gt; class Mixin(object):
...     def method1(self):
...         print("I am Mixin.method1!")
...
&gt;&gt;&gt; class ClassD(ClassA, Mixin): pass
...
&gt;&gt;&gt; ClassD.__mro__
(&lt;class '__main__.ClassD'&gt;, &lt;class '__main__.ClassA'&gt;, &lt;class '__main__.Mixin'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; ClassD.__mro__[ClassD.__mro__.index(ClassA) + 1:]
(&lt;class '__main__.Mixin'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p><code>ClassD</code> inherits from <code>ClassA</code> <strong>and</strong> from <code>Mixin</code>. <code>Mixin</code> inherits from <code>object</code> <em>too</em>. Python follows some <a href="https://www.python.org/download/releases/2.3/mro/" rel="nofollow noreferrer">complicated rules</a> to put all classes in the hierarchy into a logical linear order, and <code>Mixin</code> ends up between <code>ClassA</code> and <code>object</code> because it inherits from the latter, and not the former.</p>
<p>Because <code>Mixin</code> is injected into the MRO <em>after</em> <code>ClassA</code>, calling <code>Class().method1()</code> changes how <code>super().method1()</code> behaves, and suddenly calling that method will do something different:</p>
<pre><code>&gt;&gt;&gt; ClassD().method1()
I am Mixin.method1!
a
</code></pre>
<p>Remember, it helps to see classes as a <em>layered search space</em> for attributes on instances! <code>instance.attribute</code> is searched for along the classes if the attribute doesn't exist on the instance itself. <code>super()</code> just let you search for the same attribute along the remainder of that search space.</p>
<p>This lets you <em>reuse method implementations</em> when implementing a method with the same name in a subclass. That's the whole point of <code>super()</code>!</p>
<p>There are other problems with your code.</p>
<ul>
<li><p>When looking up methods, they are <em>bound to the object they were looked up on</em>. <code>instance.method</code> <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">binds the method to <code>instance</code></a>, so that when you call <code>instance.method()</code>, Python knows what to pass into the method as <code>self</code>.  For <code>classmethod</code> objects, <code>self</code> is replaced with <code>type(self)</code>, unless you did <code>ClassObject.attribute</code>, at which point <code>ClassObject</code> is used.</p>
<p>So your <code>_classname</code> method will <em>always</em> be producing <code>ClassC</code> for <code>inst1</code>, as the <code>cls</code> object that is passed in is that of the current instance. <code>super()</code> doesn't change what class <code>classmethod</code>s are bound to when accessed on an instance! It'll <em>always</em> be <code>type(self)</code>.</p></li>
<li><p>You also forgot to call <code>super()</code> in the <code>ClassB</code> and <code>ClassC</code> <code>__init__</code> methods, so for <code>inst1</code>, only <code>ClassC.__init__</code> is ever actually used. The <code>ClassB.__init__</code> and <code>ClassC.__init__</code> implementations are never called. You'd have to add a call to <code>super().__init__()</code> in both for that to happen, at which point there are three <code>self.attr = ...</code> assignments on the same instance, and only the one that executes last will remain. There is no separate <code>self</code> for each of the classes that make up the code for the instance, so there are no separate <code>self.attr</code> attributes with different values.</p>
<p>Again, that's because <code>inst1.__init__()</code> is called, <code>__init__</code> is bound to <code>inst</code> for the <code>self</code> argument, and even if you used <code>super().__init__()</code> the <code>self</code> that is passed on remains <code>inst1</code>.</p></li>
</ul>
<p>What you want to achieve is something entirely different from an attribute search across all of the classes. Printing all class names can be done with a loop over <code>__mro__</code> instead:</p>
<pre><code>class ClassA(object):
    def method2(self):
        this_class = __class__   # this uses the same closure as super()!
        for cls in type(self).__mro__:
            print(cls.__name__)
            if cls is this_class:
                break


class ClassB(ClassA): pass
class ClassC(ClassB): pass
</code></pre>
<p>This then produces:</p>
<pre><code>&gt;&gt;&gt; inst1 = ClassC()
&gt;&gt;&gt; inst1.method2()
ClassC
ClassB
ClassA
</code></pre>
<p>If you have to print <code>'c'</code>, <code>'b'</code>, <code>'a'</code> you can add extra attributes to each class:</p>
<pre><code>class ClassA(object):
    _class_attr = 'a'

    def method2(self):
        this_class = __class__   # this uses the same closure as super()!
        for cls in type(self).__mro__:
            if hasattr(cls, '_class_attr'):
                print(cls._class_attr)

class ClassB(ClassA):
    _class_attr = 'b'

class ClassC(ClassB):
    _class_attr = 'c'
</code></pre>
<p>and you'll get</p>
<pre><code>c
b
a
</code></pre>
<p>printed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thats because you're trying to access Method1() on Object_class</p>
<pre><code>def method1(self):
    # this will print the class name you're calling from, if you are confused.
    print(self._classname()) 
    print(self.attr)
</code></pre>
<p>You've written an if-else which satisfies when you're instantialize with Class C and access method1().</p>
<p>To print a,b,c, you will need override the method in every class.. and calling super from them. 
However, this will still have a problem. Because the self attribute carries the instance of Class C, not Class B or A. So, they can't access the attribute that you're initializing in the <strong>init</strong> func. </p>
<p>Final code looks like this</p>
<pre><code>class ClassA(object):
    def __init__(self):
        self.attr = 'a'


    @classmethod
    def _classname(cls):
        return cls.__name__


    def method1(self):
        print(self._classname())
        #don't call it for the very first parent class
        #super().method1()
        print(self.attr)

class ClassB(ClassA):
    def __init__(self):
        self.attr = 'b'

    def method1(self):
        print(self._classname())
        print(self.attr)
        super().method1()


class ClassC(ClassB):
    def __init__(self):
       self.attr = 'c'

    def method1(self):
        print(self._classname())
        print(self.attr)
        super().method1()


inst1 = ClassC()
inst1.method1()
</code></pre>
</div>
<span class="comment-copy">The <i>final code</i> you posted will print <code>c c c</code>, because at <b>all times</b> the <code>cls</code> object that <code>_classname</code> is bound to is <code>ClassC</code>. <code>super().method1()</code> doesn't change the type of <code>self</code>!</span>
