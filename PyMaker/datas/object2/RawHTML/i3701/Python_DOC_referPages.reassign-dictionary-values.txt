<div class="post-text" itemprop="text">
<p>I have a dictionary like</p>
<pre><code>{'A': 0, 'B': 1, 'C': 2, 'D': 3, etc}
</code></pre>
<p>How can I remove elements from this dictionary without creating gaps in values, in case the dictionary is not ordered? </p>
<p><strong>An example:</strong></p>
<p>I have a big matrix, where rows represent words, and columns represent documents where these words are encountered. I store the words and their corresponding indices as a dictionary. E.g. for this matrix</p>
<pre><code>2 0 0
1 0 3
0 5 1
4 1 2
</code></pre>
<p>the dictionary would look like:</p>
<pre><code>words = {'apple': 0, 'orange': 1, 'banana': 2, 'pear': 3}
</code></pre>
<p>If I remove the words <code>'apple'</code> and <code>'banana'</code>, the matrix would contain only two rows. So the value of <code>'orange'</code> in the dictionary should now equal <code>0</code> and not <code>1</code>, and the value of <code>'pear'</code> should be <code>1</code> instead of <code>3</code>. </p>
<p>In Python 3.6+ dictionaries are ordered, so I can just write something like this to reassign the values:</p>
<pre><code>i = 0
for k, v in words.items():
  v = i
  i += 1
</code></pre>
<p>or, alternatively</p>
<pre><code>words = dict(zip(terms.keys(), range(0, matrix.shape[0])))
</code></pre>
<p>I think, this is far from being the most efficient way to change the values, and it wouldn't work with unordered dictionaries. How to do it efficiently? Is there any way to easily reassign the values in case the dictionary is not ordered?</p>
</div>
<div class="post-text" itemprop="text">
<p>Turn the dict into a sorted list and then build a new dict without the words you want to remove:</p>
<pre><code>import itertools

to_remove = {'apple', 'banana'}

# Step 1: sort the words
ordered_words = [None] * len(words)
for word, index in words.items():
    ordered_words[index] = word
# ordered_words: ['apple', 'orange', 'banana', 'pear']

# Step 2: Remove unwanted words and create a new dict
counter = itertools.count()
words = {word: next(counter) for word in ordered_words if word not in to_remove}
# result: {'orange': 0, 'pear': 1}
</code></pre>
<p>This has a runtime of O(n) because manually ordering the list  with indexing operations is a linear operation, as opposed to <a href="https://docs.python.org/3/library/functions.html#sorted" rel="noreferrer"><code>sorted</code></a> which would be O(n log n).</p>
<p>See also the documentation for <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="noreferrer"><code>itertools.count</code></a> and <a href="https://docs.python.org/3/library/functions.html#next" rel="noreferrer"><code>next</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use your existing logic, using a representation of the dictionary that is sorted:</p>
<pre><code>import operator

words = {'apple': 0, 'orange': 1, 'banana': 2, 'pear': 3}
sorted_words = sorted(words.items(), key=operator.itemgetter(1))

for i, (k, v) in enumerate(sorted_words):
    words[k] = i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Initially we have</p>
<p><code>words = {'apple': 0, 'orange': 1, 'banana': 2, 'pear': 3}</code></p>
<p>To reorder based on from minimum to maximum, you may use <code>sorted</code> and dictionary comprehension.</p>
<p><code>std = sorted(words, key=lambda x: words[x])</code></p>
<p><code>newwords = { word : std.index(word) for word in std }</code></p>
<p>Does this okay..? </p>
</div>
<div class="post-text" itemprop="text">
<p>You could always keep an inverted dictionary that maps indices to words, and use that as a reference for keeping the order of the original dictionary. Then you could remove the words, and rebuild the dictionary again:</p>
<pre><code>words = {'apple': 0, 'orange': 1, 'banana': 2, 'pear': 3}

# reverse dict for index -&gt; word mappings
inverted = {i: word for word, i in words.items()}

remove = {'apple', 'banana'}

# sort/remove the words
new_words = [inverted[i] for i in range(len(inverted)) if inverted[i] not in remove]

# rebuild new dictionary
new_dict = {word: i for i, word in enumerate(new_words)}

print(new_dict)
</code></pre>
<p>Which Outputs:</p>
<pre><code>{'orange': 0, 'pear': 1}
</code></pre>
<p><strong>Note:</strong> Like the accepted answer, this is also <code>O(n)</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>You are using the wrong tool (<code>dict</code>) for the job, you should use a <code>list</code></p>
<pre><code>class vocabulary:
    def __init__(self, *words):
        self.words=list(words)
    def __getitem__(self, key):
        try:
             return self.words.index(key)
        except ValueError:
            print (key + " is not in vocabulary")
    def remove(self, word):
        if type(word)==int:
           del self.words[word]
           return
        return self.remove(self[word])

words = vocabulary("apple" ,"banana", "orange")
print (words["banana"]) # outputs 1
words.remove("apple")
print (words["banana"]) # outputs 0
</code></pre>
<h1>A note on complexity</h1>
<p>I had several comments mentioning that a <code>dict</code> is more efficient because it's lookup time is <code>O(1)</code> and the lookup time of a <code>list</code> is <code>O(n)</code>.</p>
<p>This is simply <strong>not true</strong> in this case.</p>
<p>The <code>O(1)</code> guarantee of a hash table (<code>dict</code> in python), is a result of an amortised complexity, meaning, that you average a common usage of lookup table that is <strong>generated once</strong>, assuming that your hash function is balanced.</p>
<p>This amortised calculation does not take into account deleting the entire dictionary and regenerating it every time you remove an item, as some of the other answers suggest.</p>
<p>The <code>list</code> implementation and the <code>dict</code> implementation have the same worst-case complexity of <code>O(n)</code>.</p>
<p>Yet, the <code>list</code> implementation could be optimised with two lines of python (<code>bisect</code>) to have a worst-case complexity of <code>O(log(n))</code></p>
</div>
<span class="comment-copy">So to sum it up, you have a dictionary where the values are ascending numbers, and you want to remove some elements from that dict without introducing any gaps in those numbers? Are you sure you aren't storing your data backwards? Why not use <code>words = ['apple', 'orange', 'banana', 'pear']</code>?</span>
<span class="comment-copy">@Aran-Fey exactly! And it's important to keep the order of the elements, e.g. if A has higher value than B in the old dictionary, it should also be higher in the new one. I could use a list, but I have to search for indices very often, so I'm not sure whether that would be efficient.  I didn't get the question about storing the data backwards, could you please explain?</span>
<span class="comment-copy">You're storing your data as a word-&gt;index mapping; I was suggesting to do it the other way round: index-&gt;word.</span>
<span class="comment-copy">@Aran-Fey ah, I get it. Usually I search for indices of words, and not for words corresponding to indices, so word -&gt; index is better for this task.</span>
<span class="comment-copy">Could I ask you to remove all that stuff about a matrix and rows and columns from the question and reduce the question to just <i>"How can I remove elements from this dict without creating gaps"</i>? There's <i>a lot</i> of unnecessary information here that makes the question needlessly difficult to understand.</span>
<span class="comment-copy">Nice solution. An alternative to <code>itertools.count</code> here is <code>enumerate</code>: <code>words = {word: i for i, word in enumerate(i for i in ordered_words if i not in to_remove)}</code></span>
<span class="comment-copy">@jpp: â€¦or using higher-order functions instead of generator expressions: <code>dict(zip(itertools.filterfalse(to_remove.__contains__, ordered_words), itertools.count()))</code></span>
<span class="comment-copy">Instead of the the second loop <code>words.update(zip(map(operator.itemgetter(0), sorted_words), itertools.count())))</code> looks a bit more pythonic than manual index counting.</span>
<span class="comment-copy">The OP said that they will often have to look up the index of a word, so your solution is very ineffecient. The OP's code has a O(1) lookup time, yours has O(n). In fact it's even <i>more</i> inefficient because it can only delete elements one by one, and every individual deletion is a O(n) operation.</span>
<span class="comment-copy">Would searching for an index be as quick as in a dictionary?</span>
<span class="comment-copy">Don't confuse worst case complexity with amortised complexity, it the user removes more words than she looks up - then the <code>"O(1)"</code> is not guaranteed at all, since regenerating the entire dictionary is very costly.</span>
