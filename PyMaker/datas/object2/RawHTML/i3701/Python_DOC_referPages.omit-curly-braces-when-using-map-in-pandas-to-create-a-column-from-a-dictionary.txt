<div class="post-text" itemprop="text">
<p>I'm not sure if my title is clear enough, but I have the following issue: I want to use <code>.map</code> to create a new column from a dictionary in my dataframe. This is working as intended, except for one problem: the function extracts a whole string with curly braces from the dictionary, instead of just the values. I googled extensively and couldn't find a tutorial that would lead to a different result or an answer to this question. Example:</p>
<p>df:</p>
<pre><code>  col1
0  a
1  b
2  c
</code></pre>
<p>dict:</p>
<pre><code>{ a : {'value' : 2},
  b : {'value' : 4},
  c : {'value' : 1}}
</code></pre>
<p>Now I want to use .map to create a new column with values that correspond to col1, like this:</p>
<pre><code>  col1  col_new
0  a       2
1  b       4
2  c       1
</code></pre>
<p>Instead, what I get is this:</p>
<pre><code>  col1     col_new
0  a    {'value' : 2}
1  b    {'value' : 4}
2  c    {'value' : 1}
</code></pre>
<p>This is the .map command that I use:</p>
<pre><code>df["new_col"] = df.col1.map(dict)
</code></pre>
<p>I tried using <code>to_numeric</code>, but that didn't have any effect and I guess that it doesn't have anything to do with numeric/string types of data.</p>
<p>Any help would be appreciated, as a self-taught data analyst who is just starting out with Python, I still have trouble finding the answers in the documentation sometimes.</p>
</div>
<div class="post-text" itemprop="text">
<p>What's happening is your dictionary values are themselves dictionaries.</p>
<p>So <code>pd.Series.map</code> will only map to dictionary values. It can't do anything else. There are some workarounds.</p>
<h3>Use itemgetter to extract values</h3>
<p>This will extract the value for the "value" key in each dictionary.</p>
<pre><code>from operator import itemgetter

df['new_col'] = df['col1'].map(d).apply(itemgetter('value'))
</code></pre>
<h3>Restructure your dictionary before mapping</h3>
<p>Construct a new dictionary with the key-mapping your desire before mapping your series.</p>
<pre><code>d = {k: v['value'] for k, v in d.items()}
df['new_col'] = df['col1'].map(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unless you intend to reconstruct your <code>dict</code> before <code>.map()</code>, the below approach would fit. </p>
<pre><code>df['new_col'] = df['col1'].apply(lambda x: dict_[x]['value'])
</code></pre>
<p>Output:</p>
<pre><code>  col1  new_col
0   a   2
1   b   4
2   c   1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That values in the dictionary are set to the column of dataframe</p>
<pre><code>dic = { 'a' : 2, 'b' : 4, 'c' : 1}
df["new_col"] = df.col1.map(dict)
</code></pre>
<p>This should work fine.</p>
</div>
<span class="comment-copy">Side note: it is a bad idea to name your dictionary <code>dict</code>. It overrides the functionality of inbuilt <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow noreferrer">dict</a>.</span>
<span class="comment-copy">I don't actually call it that, it was mostly for the purposes of this simple example. Thanks for the info though, I wasn't aware and I might have done that at some point in the future.</span>
<span class="comment-copy">This makes sense, so maybe we can rewind to how the dictionary was initially created from a dataframe and fix this procedure first:  <code>dfA.set_index("col_abc").T.to_dict("dict")</code></span>
<span class="comment-copy">@DataWiz, Sure, but note that <code>pd.Series.map</code> can be used with <i>another series</i> directly. You probably don't need a dictionary at all.</span>
<span class="comment-copy">Anything I can modify about this code? <code>dfA</code> has 2 columns, the first of which is <code>col_abc</code>, used to create the index of the dictionary, and the second of which is <code>value</code>, used for the values. Right now this code adds the column name to each value, creating what you described as a dictionary within a dictionary.</span>
<span class="comment-copy">Just use <code>s = dfA.set_index('col_abc')['value']</code> and then <code>df['new_col'] = df['col1'].map(s)</code>.</span>
