<div class="post-text" itemprop="text">
<p>After reading A LOT of data on the subject I still couldn't find any actual solution to my problem (there might not be any).</p>
<p><strong>My problem is as following:</strong></p>
<p>In my project I have multiple drivers working with various hardware's (IO managers, programmable loads, power supplies and more).</p>
<p>Initializing connection to these hardware's is costly (in time), and I cant open and then close the connection for every communication iteration between us.</p>
<p>Meaning <strong>I cant</strong> do this (Assuming programmable load implements enter / exit):</p>
<pre><code>start of code...

with programmable_load(args) as program_instance:
     programmable_load_instance.do_something()

rest of code...
</code></pre>
<p>So I went for a different solution :</p>
<pre><code>class programmable_load():
    def __init__(self):
         self.handler = handler_creator()
    def close_connection(self):
         self.handler.close_connection()
         self.handler = None
    def __del__(self):
         if (self.handler != None):
             self.close_connection()
</code></pre>
<p>For obvious reasons I dont 'trust' the destructor to actually get called so I explicitly call close_connection() when I want to end my program (for all drivers).</p>
<p>The problem happens when I abruptly terminate the process, for example when I run via debug mode and quit debugging.</p>
<p>In these cases the process terminates without running through any destructors.
I understand that the OS will clear all memory unused at this point, but is there any way to clear the memory in an organized manner?</p>
<p>and if not, is there a way to make the quit debugging function pass through a certain set of functions? Does the python process know it got a quite debugging event or does it treat it as a normal termination?</p>
<p><strong>Operating system: Windows</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>I haven't tested properly as I don't have wingide installed over here so I can't grant you this will work but what about using <a href="https://docs.microsoft.com/en-us/windows/console/setconsolectrlhandler" rel="nofollow noreferrer">setconsolectrlhandler</a>? For instance, try something like this:</p>
<pre><code>import os
import sys
import win32api


if __name__ == "__main__":
    def callback(sig, func=None):
        print("Exit handler called!")

    try:
        win32api.SetConsoleCtrlHandler(callback, True)
    except Exception as e:
        print("Captured exception", e)
        sys.exit(1)

    print("Press to quit")
    input()
    print("Bye!")
</code></pre>
<p>It'll be able to handle <code>CTRL+C</code> and <code>CTRL+BREAK</code> signals:</p>
<p><a href="https://i.stack.imgur.com/OxsAB.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/OxsAB.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686722(v=vs.85).aspx" rel="nofollow noreferrer">this documentation</a>:</p>
<blockquote>
<p>If a process is terminated by <code>TerminateProcess</code>, all threads of the
  process are terminated immediately <strong>with no chance to run additional
  code.</strong></p>
</blockquote>
<p>(Emphasis mine.) This implies that there is nothing you can do in this case.</p>
<p>As detailed <a href="https://bugs.python.org/issue26350#msg260201" rel="nofollow noreferrer">here</a>, signals don't work very well on ms-windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>As was mentioned in a comment, you could use <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer">atexit</a> to do the cleanup. But that only works if the process is asked to close (e.g. QUIT signal on Linux) and not just killed (as is likely the case when stopping the debugging session). Similarily if you force your computer to turn off (e.g. long press power button or remove power) then it won't be called either. There is no 'solution' to that for obvious reasons. Your program can't expect to be called when the power suddenly goes off or when it is forcefully killed. The point of forcefully killing is to definitely kill the process now. If it first called your clean-up code then you could delay that which defeats the purpose. That is why there are signals such as to ask your process to stop. This is not Python specific. The same concept also applies across operating systems.</p>
<p>Bonus (design suggestion, not a solution): I would argue that you can still make use of the context manager (using <code>with</code>). Your problem is not unique. Database connections are usually kept alive for longer as well. It is a question of the scope. Move the context further up to the application level. Then it is clear what the boundary is and you don't need any magic (you are probably also aware of @contextmanager to make that a breeze).</p>
</div>
<span class="comment-copy">do you want to have a cleanup even on stopping of debugging session?</span>
<span class="comment-copy">@AzatIbrakov I would like it on every process termination, but on the stop of a debugging session would also be very good.</span>
<span class="comment-copy">don't know about debugging session, but take a look at <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer"><code>atexit</code> module</a></span>
<span class="comment-copy">On which OS? I think you can play with signal traps on Unix.</span>
<span class="comment-copy">Split your program in two: One process will manage physical connections and will serve as a proxy, and the other is you program logic. This way once your logic process will be killed, the comm. manager will be able to detect this and exit gracefully.</span>
<span class="comment-copy">It seems like its working with 'ctrl+c', is this completely equivalent to process termination? It doesn't work via the quit debugging for some reason (But I haven't had the time to check that properly yet). Thanks alot for the answer!</span>
<span class="comment-copy">The problem is that even while using the 'with' statement the connection wont be closed on process termination, or am I wrong?</span>
<span class="comment-copy">@Rohi why do you think it wouldn't be closed? It depends on your application of course. If something else is blocking and never returning that you are calling within the <code>with</code> block then that obviouslty won't work. But you can fix that.</span>
<span class="comment-copy">If you meant that the connection won't be closed on forced process termination then you are right. Nothing will allow you to do that from the same process as outlined in the first paragrah. In that case your process would get killed without any code being executed within your process. If it did still call your code then you could still keep the process alive with that which defeats the purpose of forcefully killing your process... but the cleanup will be called when the process gracefully terminates.</span>
<span class="comment-copy">This is exactly my problem, causing the closing of connection in an ordinary manner is quite simple (and is done in multiple applications). I am looking for a solution when it is not a standard close (Specifically for 'quit debugging' purposes).</span>
<span class="comment-copy">@Rohi as mentioned, you won't find a solution to that with the same process for the aforementioned reasons. You could use another process to monitor the to be killed process but obviously without access to the variables. Not sure why you need a solution to that. What do you think the point of forcfully killing the process is? It is up to the OS to clean up local resources like memory and for the remote service to handle connection loses. My 'bonus' was not a solution but a counter to not being able to use a context manager.</span>
