<div class="post-text" itemprop="text">
<p>Im trying to do a program that counts some things of a C program, the problem I have, is that Im trying to count lines with:</p>
<pre><code>def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)
</code></pre>
<p>It doesnt count me the lines, here is an example of the input and the output:</p>
<pre><code>for
if
else
switch
exit
Number of if´s: 1
Number of for´s: 1
Number of While´s: 0
Number of else´s: 1
Number of switche´s: 1
Number of lines: 1
</code></pre>
<p>But everytime I press enter to write a new line of code it doesnt get counted, also if I press enter without writing anything, this error appears: </p>
<blockquote>
<p>Traceback (most recent call last):   File
  "C:/Users/User/PycharmProjects/practicas/firma_digital.py", line 80,
  in 
      if tok.type is not None: AttributeError: 'NoneType' object has no attribute 'type'</p>
</blockquote>
<p>Here is all my code:</p>
<pre><code>import ply.lex as lex
import ply.yacc as yacc
FinishProgram=0
Enters=0
Fors=0
Whiles=0
ifs=0
elses=0
Switches=0

reserved = {
   'if' : 'IF',
   'for' : 'FOR',
   'while': 'WHILE',
   'else': 'ELSE',
   'switch': 'SWITCH'
}
tokens = [
    'ID',
    'COLON',
    'SEMICOLON',

    ]+ list(reserved.values()) #Palabras reservadas

t_COLON= r','
t_SEMICOLON=r';'


def t_ID(t):
    r'[a-zA-Z_][a-zA-Z0-9_]*'
    t.type = reserved.get(t.value, 'ID')
    return t

t_ignore=r' '

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

def t_error(t):
    print("This thing failed")
    t.lexer.skip(1)

lexer=lex.lex()


#def p_gram_sets(p):
 #   '''

  #  gram : SETS SEMICOLON
   #      | empty
    #'''
    #if p[1]:
     #   print(p[1])
      #  print("SETS")



def p_empty(p):
    '''
    empty :
    '''
    p[0]=None





def p_error(p):
    print("Syntax error in input!")


parser=yacc.yacc()

while FinishProgram==0:
    s=input('')
    lexer.input(s)
    tok = lexer.token()

    if tok.type is not None:
        if tok.type=='IF':
            ifs+=1
        elif tok.type=='FOR':
            Fors+=1
        elif tok.type=='WHILE':
            Whiles+=1
        elif tok.type=='ELSE':
            elses+=1
        elif tok.type=='SWITCH':
            Switches+=1

    #parser.parse(s)
    if "exit" in s:
        print("Number of if´s: "+ str(ifs) + "\n"+"Number of for´s: "+str(Fors)+"\n"+"Number of While´s: "+str(Whiles)+"\n"+"Number of else´s: "+str(elses)+"\n"+"Number of switche´s: "+str(Switches)+"\n"+"Number of lines: "+str(tok.lineno))
        FinishProgram=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not that ply is not counting the newline characters. It's never seeing them, because you call it repeatedly using <code>input()</code>.</p>
<p>From the Python docs (emphasis added):</p>
<blockquote>
<p>input([prompt])</p>
<p>If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (<strong>stripping a trailing newline</strong>), and returns that.</p>
</blockquote>
<p>The normal usage of <code>lex.lex</code> is to </p>
<p>Additionally, you are printing</p>
<pre><code>... + str(tok.lineno)
</code></pre>
<p>rather than</p>
<pre><code>... + str(lexer.lineno)
</code></pre>
<p>After the last token is tokenised, <code>lex.lex</code> returns <code>None</code>, so you can expect <code>tok</code> to be <code>Null</code> when your loop terminates, and therefore it is an error to try to extract it's <code>lineno</code> attribute. (However, in your case it only happens if the line you just tried to tokenise was empty, because you only use the first token on each line.) You want the line count recorded in the lexer object, which is the count you update in your action.</p>
<p>If you want to work on an entire file (which is the usual case for parsers, other than line-by-line calculators), you need to read the entire contents of the file (or stdin, as the case may be). For non-interactive use, you would generally do that with the file object's <code>read</code> function. If you wanted to test your lexer, you would then use the fact that the <code>lex</code> function implements Python's iteration protocol, so it will work in a <code>for</code> statement. So your main loop would be something like:</p>
<pre><code>import sys
lexer.input(sys.stdin.read())
for tok in lexer:
  # Update counts
</code></pre>
<p>and you would terminate the input by typing an end-of-file character at the beginning of a line (control-D on Linux or control-Z on Windows).</p>
<p>Personally, I would implement the token type counting with a <a href="https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict
counts = defaultdict(int)
for tok in lexer:
  counts[tok.type] += 1
for type, count in counts.items():
  print ("Number of %s's: %d\n" % (type, count))
# Or: print('\n'.join("Number of %s's: %d\n" % (type, count) for type, count in counts.items())
print ("Number of lines: %d\n" % lexer.lineno)
</code></pre>
</div>
<span class="comment-copy">Thanks for the tips and the great explanation about lineno, but for the purpose of this program, a university project I need to write the C programs in the console.</span>
<span class="comment-copy">@Sebas: The console is <code>stdin</code>.</span>
<span class="comment-copy">Tried the for that you suggest with the lexer.input(sys.stdin.read()) but it stills doesnt count any line</span>
<span class="comment-copy">Yeah, the use of sys.stdin.read() means that you have to terminate the input with an EOF. Sorry. I'll fix that.</span>
<span class="comment-copy">One last thing, it also start printing me as if an error happened in lexer with every reserved word I use like if, else, any idea why is that happening?-------- Fixed, I was placing the new line function after the error one, thank you very much for all :)</span>
