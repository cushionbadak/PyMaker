<div class="post-text" itemprop="text">
<p>I'm playing with Python <code>multiprocessing</code> module to have a (read-only) array shared among multiple processes. My goal is to use <code>multiprocessing.Array</code> to allocate the data and then have my code <em>forked</em> (<code>forkserver</code>) so that each worker can read straight from the array to do their job.</p>
<p>While reading the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming" rel="nofollow noreferrer">Programming guidelines</a> I got a bit confused.</p>
<p>It is first said:</p>
<blockquote>
<p>Avoid shared state</p>
<p>As far as possible one should try to avoid shifting large amounts of
     data between processes.</p>
<p>It is probably best to stick to using queues or pipes for
     communication between processes rather than using the lower level
     synchronization primitives.</p>
</blockquote>
<p>And then, a couple of lines below:</p>
<blockquote>
<p>Better to inherit than pickle/unpickle</p>
<p>When using the spawn or forkserver start methods many types from
     multiprocessing need to be picklable so that child processes can use
     them. However, one should generally avoid sending shared objects to
     other processes using pipes or queues. Instead you should arrange the
     program so that a process which needs access to a shared resource
     created elsewhere can inherit it from an ancestor process.</p>
</blockquote>
<p>As far as I understand, <em>queues</em> and <em>pipes</em> pickle objects. If so, aren't those two guidelines conflicting?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <strong>second</strong> guideline is the one relevant to your use case.</p>
<p>The first is reminding you that this isn't threading where you manipulate shared data structures with locks (or atomic operations).  If you use <code>Manager.dict()</code> (which is actually <code>SyncManager.dict</code>) for everything, every read and write has to access the manager's process, and you also need the synchronization typical of threaded programs (which itself may come at a higher cost from being cross-process).</p>
<p>The second guideline suggests inheriting shared, read-only objects via <code>fork</code>; in the <em>forkserver</em> case, this means you have to create such objects before the call to <code>set_start_method</code>, since all workers are children of a process created at that time.</p>
<p>The reports on the usability of such sharing are <a href="https://stackoverflow.com/questions/659865/multiprocessing-sharing-a-large-read-only-object-between-processes?rq=1">mixed at best</a>, but if you can use a <em>small number</em> of any of the C-like array types (like <code>numpy</code> or the standard <code>array</code> module), you should see good performance (because the majority of pages will never be written to deal with reference counts).  Note that you do <strong>not</strong> need <code>multiprocessing.Array</code> here (though it may work fine), since you do not need <em>writes</em> in one concurrent process to be visible in another.</p>
</div>
