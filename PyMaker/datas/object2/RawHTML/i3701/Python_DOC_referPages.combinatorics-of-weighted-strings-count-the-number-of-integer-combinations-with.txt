<div class="post-text" itemprop="text">
<p>Given a list of integers e.g.</p>
<pre><code>l = [3, 5, 8, 13]
</code></pre>
<p>and an integer e.g.</p>
<pre><code>m = 13
</code></pre>
<p>count the number of integer combinations that have sum=m e.g.</p>
<pre><code>combinations = len([[8, 5], [5, 8], [13], [3, 5, 5], [5, 5, 3], [3, 5, 3], ...])
</code></pre>
<p>For small values of m, I can use this recursion (Fibonacci-like linear recurrence relation):</p>
<pre><code>def RecursiveCount(m, integers):
    count = 0
    if m &lt; 0:
        return 0
    if m == 0:
        return 1
    for i in integers:
        count += RecursiveCount(m-i, integers)
    return count
</code></pre>
<p>But for larger l and m, it gets to slow and it´s proposed to use dynamic programming to memorize already solved combinations to reduce the recursive calls. Unfortunately, I'm not able to implement this. I tried reading this, but it didn´t help <a href="https://bio.informatik.uni-jena.de/wp/wp-content/uploads/2014/09/book_handout_3.pdf" rel="nofollow noreferrer">https://bio.informatik.uni-jena.de/wp/wp-content/uploads/2014/09/book_handout_3.pdf</a></p>
<p>Edit: The learning outcome would be the greatest, if I would be able to implement it using dynamic programming</p>
</div>
<div class="post-text" itemprop="text">
<p>A straightforward search time for this is <code>O(n * k)</code>, where <code>n</code> is the sum and <code>k</code> is the number of integers in the list. The search space can be confined to <code>O(max(list))</code> but for convenience we can just use <code>O(n)</code>.</p>
<p>Python code:</p>
<pre class="lang-py prettyprint-override"><code>def f(n, nums):
  m = [0 for i in range(n + 1)]

  for s in range(min(nums), n + 1):
    for c in nums:
      if c == s:
        m[s] += 1
      if c &lt; s:
        m[s] += m[s - c]

  return m[n]
</code></pre>
<p><a href="https://repl.it/@gl_dbrqn/FatherlyEdibleTriggers" rel="nofollow noreferrer">Output</a>:</p>
<pre class="lang-py prettyprint-override"><code>nums = (3, 5, 8, 13, 15, 20)
m = 200

t0 = time.time()
x = num_seq_sum(m, nums) # jdehesa's code
t1 = time.time()

print(x, t1-t0) # 233354368688517335733 4.085544586181641

t0 = time.time()
x = f(m, nums)
t1 = time.time()
print(x, t1-t0) # 233354368688517335733 0.0004315376281738281

t0 = time.time()
x = RecursiveCount(m, nums) # using @functools.lru_cache()
t1 = time.time()
print(x, t1-t0) # 233354368688517335733 0.0006241798400878906
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can easily add memoization by adding the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>@functools.lru_cache</code></a> decorator to your recursive function.</p>
<pre><code>@functools.lru_cache()
def RecursiveCount(m, integers):
    ...
</code></pre>
<p>This will automatically cache the results for certain parameters and check that cache first before calling the function again, dramatically reducing the number of calls, and hence runtime. However, this requires all the parameters to be hashable, i.e. you'd have to pass <code>integers</code> as a <code>tuple</code>.</p>
<p>Example for <code>RecursiveCount(20, tuple(range(1, 10))))</code>: Result: 518,145; function call without memoization: 4,672,513; with memoization: 29.</p>
<p>(If this is for an exercise in DP, this is probably not an option, but otherwise this works well in practice.)</p>
</div>
<div class="post-text" itemprop="text">
<p>This solution doesn't use dynamic programming but is significantly faster:</p>
<pre><code>import math
from functools import reduce

def num_seq_sum(m, nums):
    if m == 0:
        return 1
    # Avoid repeated numbers
    nums = list(set(nums))
    # Begin with no numbers picked
    base = [0] * len(nums)
    return sum(_seqs_sum_rec(m, nums, base, 0))

def _seqs_sum_rec(m, nums, current, i):
    if i &gt;= len(nums):
        raise StopIteration
    # Try without adding current number, add next numbers
    yield from _seqs_sum_rec(m, nums, current, i + 1)
    # Try adding current number
    n = nums[i]
    # While we can fit more copies of current number
    while m &gt; n:
        current[i] += 1
        m -= n
        yield from _seqs_sum_rec(m, nums, current, i + 1)
    # If we can fit exactly one more
    if m == n:
        current[i] += 1
        # Number of permutations of the current combination
        yield _num_permutations(current)
    # Undo additions for parent call
    current[i] = 0

def _num_permutations(comb):
    return math.factorial(sum(comb)) // reduce(lambda a, b: a * b, (math.factorial(c) for c in comb), 1)

nums = [3, 5, 8, 13]
m = 13

print(RecursiveCount(m, nums) == num_seq_sum(m, nums))
# True
</code></pre>
<p>A small performance test:</p>
<pre><code>nums = [1, 3, 5, 8, 10, 15]
m = 30

%timeit RecursiveCount(m, nums)
# 1.48 s ± 6.86 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
%timeit num_seq_sum(m, nums)
# 4.77 ms ± 85.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<span class="comment-copy">But it's not exactly combinations, right? Seems you can repeat elements from your set as many times as you want.</span>
<span class="comment-copy">Yes, it just needs to be a unique sequence</span>
<span class="comment-copy">For a "cheap" solution, you could just try to annotate your function with <code>@functools.lru_cache()</code> to get memoization.</span>
<span class="comment-copy">Also, you can reduce complexity by only considering sorted combinations, and later "expanding" those to all their permutations.</span>
<span class="comment-copy">Wow, that's it. Thanks</span>
<span class="comment-copy">This is an implementation of the "consider only sorted numbers, expand permutations later" idea from comments, right? Nice. Are <code>m</code> and <code>nums</code> in the performance test the small values from the quesiton? How about somewhat larger values for <code>m</code> and more numbers to choose from?</span>
<span class="comment-copy">@tobias_k It does implement the idea of finding sorted combinations and count permutations later, and also it works slightly different, the number of recursion levels is the number of different possible values, not the length of the resulting sequences. Test cases go quickly from "a few milliseconds" to "forever", but I've added a slightly bigger example (for example, if I add <code>20</code> to <code>nums</code> and set <code>m = 40</code> in the current test the original version doesn't seem to ever end).</span>
<span class="comment-copy">A potential problem with trying to enumerate actual combinations or other more generalized partitions is that their number gets unwieldy very quickly compared with just relying on n and k. (@tobias_k)</span>
