<div class="post-text" itemprop="text">
<p>By using the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow noreferrer">map</a> function in the <code>multiprocessing</code> library I see no difference in execution time when using more than 2 processes. I'm running the program using 4 cores. </p>
<p>The actual code is pretty straight forward and calculates the first 4000 fibonacci numbers 4 times (= the amount of cores). It distributes the work evenly between N cores (e.g. when using a Pool with 2 processes, each process will calculate the first 4000 fibonacci numbers twice). This whole process is done for N = 1 up to the amount of cores. </p>
<p>The output, with in every row the amount of cores and the corresponding execution time in seconds, is: </p>
<ol>
<li>3,147</li>
<li>1,72</li>
<li>1,896</li>
<li>1.899</li>
</ol>
<p>Does anyone know why there is no decrease in execution time given more than 2 cores?  The actual code is:</p>
<pre><code>import multiprocessing
from time import time


def F(_):
    for n in range(4 * 10 ** 3):
        a, b = 0, 1
        for i in range(0, n):
            a, b = b, a + b
    return


def pool_fib():
    n_cores = multiprocessing.cpu_count()
    args = list(range(multiprocessing.cpu_count()))
    for i in range(1, n_cores + 1):
        with multiprocessing.Pool(i) as p:
            start = time()
            p.map(F, args)
            print(i, time() - start)


if __name__ == '__main__':
    pool_fib()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Provided you are using a fairly modern CPU (e.g. any Intel Core processor), <code>multiprocessing.cpu_count()</code> won't give you the number of physical cores your machine has, but the number of hyper-threads. In a nutshell, hyper-threading allows a single physical core to have <code>n</code> (most commonly, two) pipelines, which fools your OS into thinking you've got <code>n</code> times the number of cores you really have. This is helpful, when you are doing some stuff that might starve a core with data (most notably, IO or RAM lookups caused by cache-misses), but your workload is purely arithmetic and it is not likely to starve your CPU, resulting in little to no gains from hyper-threading. And the little gains you might get will be overshadowed by multiprocessing overhead, which is quite significant.</p>
<p>P.S.</p>
<p>I usually post this sort of things as comments, but I've exceeded the comment size limitation. By the way, if you've chosen the Fibonacci series for something more that just an example, you might want to consider a faster algorithm: <a href="https://stackoverflow.com/questions/38445069/fast-fibonacci-computation/38445336#38445336">Fast Fibonacci computation</a></p>
</div>
<span class="comment-copy">Off-topic, but note that for small numbers (like <code>4 * 10**3</code>) it's probably clearer to write the number (<code>4000</code>) and for large numbers, (<code>4 * 10**10</code> maybe) the "e" notation is a literal in Python (<code>4e10</code>) though it does produce a float (<code>for n in range(int(4e10)): ...</code>)</span>
<span class="comment-copy">Noted, I agree.</span>
<span class="comment-copy">This is almost certainly the right answer. Concurrency carries its own overhead, and spinning off too many concurrent processes will harm execution speed, not help it.</span>
<span class="comment-copy">Thanks for the answer. This is indeed correct!  Also, thanks for the link but this was indeed just an illustration.</span>
