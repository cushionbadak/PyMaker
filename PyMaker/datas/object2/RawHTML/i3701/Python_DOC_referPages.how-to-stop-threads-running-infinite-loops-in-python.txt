<div class="post-text" itemprop="text">
<p>I've made a program which has a main thread that spawns many other threads by subclassing the threading.Thread class. </p>
<p>Each such child thread runs an infinite while loop, and inside the loop I check a condition. If the condition is true, I make the thread sleep for 1 second using time.sleep(1) and if it's false, then the thread performs some computation.</p>
<p>The program itself works fine and I've achieved what I wanted to do, my only remaining problem is that I seem unable to stop the threads after my work is done. I want the user to be able to kill all the threads by pressing a button or giving a keyboard interrupt like Ctrl+C.</p>
<p>For this I had tried using the signal module and inserted a conditon in the threads' loops that breaks the loop when the main thread catches a signal but it didn't work for some reason. Can anyone please help with this?</p>
<p><strong>EDIT:</strong> This is some of the relevant code snippets:</p>
<pre><code>def sighandler(signal,frame):
    BaseThreadClass.stop_flag = True
class BaseThreadClass(threading.Thread):
    stop_flag = False
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self,*args):
        while True:
            if condition:
               time.sleep(1)
            else:
               #do computation and stuff
            if BaseThreadClass.stop_flag:
               #do cleanup
               break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your basic method does work, but you've still not posted enough code to show the flaw. I added a few lines of code to make it runnable and produced a result like:</p>
<pre><code>$ python3 test.py
thread alive
main alive
thread alive
main alive
^CSignal caught
main alive
thread alive
main alive
main alive
main alive
^CSignal caught
^CSignal caught
main alive
^Z
[2]+  Stopped                 python3 test.py
$ kill %2
</code></pre>
<p>The problem demonstrated above involves the signal handler telling all the threads to exit, <em>except</em> the main thread, which still runs and still catches interrupts. The full source of this variant of the sample snippet is:</p>
<pre><code>import threading, signal, time

def sighandler(signal,frame):
    BaseThreadClass.stop_flag = True
    print("Signal caught")

class BaseThreadClass(threading.Thread):
    stop_flag = False
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self,*args):
        while True:
            if True:
               time.sleep(1)
               print("thread alive")
            else:
               #do computation and stuff
               pass
            if BaseThreadClass.stop_flag:
               #do cleanup
               break

signal.signal(signal.SIGINT, sighandler)

t = BaseThreadClass()
t.start()

while True:
    time.sleep(1)
    print("main alive")
</code></pre>
<p>The problem here is that the main thread never checks for the quit condition. But as you never posted what the main thread does, nor how the signal handler is activated, or information regarding whether threads may go a long time without checking the quit condition... I still don't know what went wrong in your program. The <a href="https://docs.python.org/3/library/signal.html#example" rel="nofollow noreferrer">signal example</a> shown in the library documentation raises an exception in order to divert the main thread. </p>
<p>Signals are a rather low level concept for this task, however. I took the liberty of writing a somewhat more na√Øve version of the main thread:</p>
<pre><code>try:
    t = BaseThreadClass()
    t.start()
    while True:
        time.sleep(1)
        print("main alive")
except KeyboardInterrupt:
    BaseThreadClass.stop_flag = True
    t.join()
</code></pre>
<p>This version catches the exception thrown by the default interrupt handler, signals the thread to stop, and waits for it to do so. It might even be appropriate to change the <code>except</code> clause to a <code>finally</code>, since we could want to clean the threads up on other errors too. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to do this kind of "cooperative" polled-shutdown, you can use a <code>threading.Event</code> to signal:</p>
<pre><code>import threading
import time

def proc1():
    while True:
        print("1") # payload
        time.sleep(1)

        # have we been signalled to stop?
        if not ev1.wait(0): break 

    # do any shutdown etc. here
    print ("T1 exiting")

ev1 = threading.Event()
ev1.set()

thread1 = threading.Thread(target=proc1)
thread1.start()

time.sleep(3)

# signal thread1 to stop
ev1.clear()
</code></pre>
<p>But be aware that if the "payload" does something blocking like network or file IO, that op will not be interrupted. You can do those blocking ops with a timeout, but that obviously will complicate your code.</p>
</div>
<span class="comment-copy">Get the thread by <code>id</code> and kill them once job done.</span>
<span class="comment-copy">I tried reading your code but it didn't work for some reason. Can anyone please help with this? One thing I do know, <a href="https://docs.python.org/3/library/signal.html#signals-and-threads" rel="nofollow noreferrer">signals aren't for inter-thread communication</a>.</span>
<span class="comment-copy">@mankur the threads use sockets, files etc so I want to perform cleanup before killing them abruptly.</span>
<span class="comment-copy">Ah yes, I think you hit the nail on the head. The main thread was still alive, leading me to think that the threads weren't dying. Thanks.</span>
