<div class="post-text" itemprop="text">
<p>What is the Python equivalent of Perl's <code>chomp</code> function, which removes the last character of a string if it is a newline?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try the method <code>rstrip()</code> (see doc <a href="http://docs.python.org/2/library/stdtypes.html#str.rstrip" rel="noreferrer">Python 2</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="noreferrer">Python 3</a>)</p>
<pre><code>&gt;&gt;&gt; 'test string\n'.rstrip()
'test string'
</code></pre>
<p>Python's <code>rstrip()</code> method strips <em>all</em> kinds of trailing whitespace by default, not just one newline as Perl does with <a href="http://perldoc.perl.org/functions/chomp.html" rel="noreferrer"><code>chomp</code></a>.</p>
<pre><code>&gt;&gt;&gt; 'test string \n \r\n\n\r \n\n'.rstrip()
'test string'
</code></pre>
<p>To strip only newlines:</p>
<pre><code>&gt;&gt;&gt; 'test string \n \r\n\n\r \n\n'.rstrip('\n')
'test string \n \r\n\n\r '
</code></pre>
<p>There are also the methods <code>lstrip()</code> and <code>strip()</code>:</p>
<pre><code>&gt;&gt;&gt; s = "   \n\r\n  \n  abc   def \n\r\n  \n  "
&gt;&gt;&gt; s.strip()
'abc   def'
&gt;&gt;&gt; s.lstrip()
'abc   def \n\r\n  \n  '
&gt;&gt;&gt; s.rstrip()
'   \n\r\n  \n  abc   def'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>And I would say the "pythonic" way to get lines without trailing newline characters is splitlines().</p>
<pre><code>&gt;&gt;&gt; text = "line 1\nline 2\r\nline 3\nline 4"
&gt;&gt;&gt; text.splitlines()
['line 1', 'line 2', 'line 3', 'line 4']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The canonical way to strip end-of-line (EOL) characters is to use the string rstrip() method removing any trailing \r or \n.  Here are examples for Mac, Windows, and Unix EOL characters.</p>
<pre><code>&gt;&gt;&gt; 'Mac EOL\r'.rstrip('\r\n')
'Mac EOL'
&gt;&gt;&gt; 'Windows EOL\r\n'.rstrip('\r\n')
'Windows EOL'
&gt;&gt;&gt; 'Unix EOL\n'.rstrip('\r\n')
'Unix EOL'
</code></pre>
<p>Using '\r\n' as the parameter to rstrip means that it will strip out any trailing combination of '\r' or '\n'.  That's why it works in all three cases above.</p>
<p>This nuance matters in rare cases.  For example, I once had to process a text file which contained an HL7 message.  The HL7 standard requires a trailing '\r' as its EOL character.  The Windows machine on which I was using this message had appended its own '\r\n' EOL character.  Therefore, the end of each line looked like '\r\r\n'.  Using rstrip('\r\n') would have taken off the entire '\r\r\n' which is not what I wanted.  In that case, I simply sliced off the last two characters instead.</p>
<p>Note that unlike Perl's <code>chomp</code> function, this will strip all specified characters at the end of the string, not just one:</p>
<pre><code>&gt;&gt;&gt; "Hello\n\n\n".rstrip("\n")
"Hello"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note that rstrip doesn't act exactly like Perl's chomp() because it doesn't modify the string. That is, in Perl:</p>
<pre><code>$x="a\n";

chomp $x
</code></pre>
<p>results in <code>$x</code> being <code>"a"</code>.</p>
<p>but in Python:</p>
<pre><code>x="a\n"

x.rstrip()
</code></pre>
<p>will mean that the value of <code>x</code> is <strong>still</strong> <code>"a\n"</code>. Even <code>x=x.rstrip()</code> doesn't always give the same result, as it strips all whitespace from the end of the string, not just one newline at most.</p>
</div>
<div class="post-text" itemprop="text">
<p>I might use something like this:</p>
<pre><code>import os
s = s.rstrip(os.linesep)
</code></pre>
<p>I think the problem with <code>rstrip("\n")</code> is that you'll probably want to make sure the line separator is portable. (some antiquated systems are rumored to use <code>"\r\n"</code>). The other gotcha is that <code>rstrip</code> will strip out repeated whitespace. Hopefully <code>os.linesep</code> will contain the right characters. the above works for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may use <code>line = line.rstrip('\n')</code>. This will strip all newlines from the end of the string, not just one.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = s.rstrip()
</code></pre>
<p>will remove all newlines at the end of the string <code>s</code>. The assignment is needed because <code>rstrip</code> returns a new string instead of modifying the original string. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>"line 1\nline 2\r\n...".replace('\n', '').replace('\r', '')
&gt;&gt;&gt; 'line 1line 2...'
</code></pre>
<p>or you could always get geekier with regexps :)</p>
<p>have fun!</p>
</div>
<div class="post-text" itemprop="text">
<p>This would replicate exactly perl's chomp (minus behavior on arrays) for "\n" line terminator:</p>
<pre><code>def chomp(x):
    if x.endswith("\r\n"): return x[:-2]
    if x.endswith("\n") or x.endswith("\r"): return x[:-1]
    return x
</code></pre>
<p>(Note: it does not modify string 'in place'; it does not strip extra trailing whitespace; takes \r\n in account)</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use strip:</p>
<pre><code>line = line.strip()
</code></pre>
<p>demo:</p>
<pre><code>&gt;&gt;&gt; "\n\n hello world \n\n".strip()
'hello world'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Careful with <code>"foo".rstrip(os.linesep)</code>: That will only chomp the newline characters for the platform where your Python is being executed. Imagine you're chimping the lines of a Windows file under Linux, for instance:</p>
<pre><code>$ python
Python 2.7.1 (r271:86832, Mar 18 2011, 09:09:48) 
[GCC 4.5.0 20100604 [gcc-4_5-branch revision 160292]] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import os, sys
&gt;&gt;&gt; sys.platform
'linux2'
&gt;&gt;&gt; "foo\r\n".rstrip(os.linesep)
'foo\r'
&gt;&gt;&gt;
</code></pre>
<p>Use <code>"foo".rstrip("\r\n")</code> instead, as Mike says above.</p>
</div>
<div class="post-text" itemprop="text">
<p>An <a href="http://docs.python.org/2/library/stdtypes.html#file.next" rel="noreferrer">example in Python's documentation</a> simply uses <code>line.strip()</code>.</p>
<p>Perl's <code>chomp</code> function removes one linebreak sequence from the end of a string only if it's actually there.</p>
<p>Here is how I plan to do that in Python, if <code>process</code> is conceptually the function that I need in order to do something useful to each line from this file:</p>
<pre><code>import os
sep_pos = -len(os.linesep)
with open("file.txt") as f:
    for line in f:
        if line[sep_pos:] == os.linesep:
            line = line[:sep_pos]
        process(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>rstrip doesn't do the same thing as chomp, on so many levels. Read <a href="http://perldoc.perl.org/functions/chomp.html" rel="noreferrer">http://perldoc.perl.org/functions/chomp.html</a> and see that chomp is very complex indeed.</p>
<p>However, my main point is that chomp removes at most 1 line ending, whereas rstrip will remove as many as it can.</p>
<p>Here you can see rstrip removing all the newlines:</p>
<pre><code>&gt;&gt;&gt; 'foo\n\n'.rstrip(os.linesep)
'foo'
</code></pre>
<p>A much closer approximation of typical Perl chomp usage can be accomplished with re.sub, like this:</p>
<pre><code>&gt;&gt;&gt; re.sub(os.linesep + r'\Z','','foo\n\n')
'foo\n'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't program in Python, but I came across an <a href="http://www.python.org/doc/faq/programming/#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" rel="nofollow noreferrer">FAQ</a> at python.org advocating S.rstrip("\r\n") for python 2.2 or later.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

r_unwanted = re.compile("[\n\t\r]")
r_unwanted.sub("", your_text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>workaround solution for special case:</p>
<p>if the newline character is the last character (as is the case with most file inputs), then for any element in the collection you can index as follows: </p>
<pre><code>foobar= foobar[:-1]
</code></pre>
<p>to slice out your newline character. </p>
</div>
<div class="post-text" itemprop="text">
<p>If your question is to clean up all the line breaks in a multiple line str object (oldstr), you can split it into a list according to the delimiter '\n' and then join this list into a new str(newstr).</p>
<p><code>newstr = "".join(oldstr.split('\n'))</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like there is not a perfect analog for perl's <a href="http://perldoc.perl.org/functions/chomp.html" rel="noreferrer">chomp</a>.  In particular, <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="noreferrer">rstrip</a> cannot handle multi-character newline delimiters like <code>\r\n</code>. However, <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="noreferrer">splitlines</a> does <a href="https://stackoverflow.com/a/275659/3780389">as pointed out here</a>.
Following <a href="https://stackoverflow.com/a/43641128/3780389">my answer</a> on a different question, you can combine <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="noreferrer">join</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="noreferrer">splitlines</a> to remove/replace all newlines from a string <code>s</code>:</p>
<pre><code>''.join(s.splitlines())
</code></pre>
<p>The following removes <em>exactly one <strong>trailing</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>I find it convenient to have be able to get the chomped lines via in iterator, parallel to the way you can get the un-chomped lines from a file object. You can do so with the following code:</p>
<pre><code>def chomped_lines(it):
    return map(operator.methodcaller('rstrip', '\r\n'), it)
</code></pre>
<p>Sample usage:</p>
<pre><code>with open("file.txt") as infile:
    for line in chomped_lines(infile):
        process(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm bubbling up my regular expression based answer from one I posted earlier in the comments of another answer.  I think using <code>re</code> is a clearer more explicit solution to this problem than <code>str.rstrip</code>.</p>
<pre><code>&gt;&gt;&gt; import re
</code></pre>
<p>If you want to remove one or more <em>trailing</em> newline chars:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'[\n\r]+$', '', '\nx\r\n')
'\nx'
</code></pre>
<p>If you want to remove newline chars everywhere (not just trailing):</p>
<pre><code>&gt;&gt;&gt; re.sub(r'[\n\r]+', '', '\nx\r\n')
'x'
</code></pre>
<p>If you want to remove only 1-2 trailing newline chars (i.e., <code>\r</code>, <code>\n</code>, <code>\r\n</code>, <code>\n\r</code>, <code>\r\r</code>, <code>\n\n</code>)</p>
<pre><code>&gt;&gt;&gt; re.sub(r'[\n\r]{1,2}$', '', '\nx\r\n\r\n')
'\nx\r'
&gt;&gt;&gt; re.sub(r'[\n\r]{1,2}$', '', '\nx\r\n\r')
'\nx\r'
&gt;&gt;&gt; re.sub(r'[\n\r]{1,2}$', '', '\nx\r\n')
'\nx'
</code></pre>
<p>I have a feeling what most people really want here, is to remove just <em>one</em> occurrence of a trailing newline character, either <code>\r\n</code> or <code>\n</code> and nothing more.</p>
<pre><code>&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\n\n', count=1)
'\nx\n'
&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\r\n\r\n', count=1)
'\nx\r\n'
&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\r\n', count=1)
'\nx'
&gt;&gt;&gt; re.sub(r'(?:\r\n|\n)$', '', '\nx\n', count=1)
'\nx'
</code></pre>
<p>(The <code>?:</code> is to create a non-capturing group.)</p>
<p>(By the way this is <em>not</em> what <code>'...'.rstrip('\n', '').rstrip('\r', '')</code> does which may not be clear to others stumbling upon this thread.  <code>str.rstrip</code> strips as many of the trailing characters as possible, so a string like <code>foo\n\n\n</code> would result in a false positive of <code>foo</code> whereas you may have wanted to preserve the other newlines after stripping a single trailing one.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use : </p>
<pre><code>line = line.rstrip("\n")
</code></pre>
<p>or</p>
<pre><code>line = line.strip("\n")
</code></pre>
<p>You don't need any of this complicated stuff</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; '   spacious   '.rstrip()
'   spacious'
&gt;&gt;&gt; "AABAA".rstrip("A")
  'AAB'
&gt;&gt;&gt; "ABBA".rstrip("AB") # both AB and BA are stripped
   ''
&gt;&gt;&gt; "ABCABBA".rstrip("AB")
   'ABC'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are three types of line endings that we normally encounter: <code>\n</code>, <code>\r</code> and <code>\r\n</code>. A rather simple regular expression in <a href="https://docs.python.org/2/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a>, namely <code>r"\r?\n?$"</code>, is able to catch them all.</p>
<p>(And we <em>gotta catch 'em all</em>, am I right?)</p>
<pre><code>import re

re.sub(r"\r?\n?$", "", the_text, 1)
</code></pre>
<p>With the last argument, we limit the number of occurences replaced to one, mimicking chomp to some extent. Example:</p>
<pre><code>import re

text_1 = "hellothere\n\n\n"
text_2 = "hellothere\n\n\r"
text_3 = "hellothere\n\n\r\n"

a = re.sub(r"\r?\n?$", "", text_1, 1)
b = re.sub(r"\r?\n?$", "", text_2, 1)
c = re.sub(r"\r?\n?$", "", text_3, 1)
</code></pre>
<p>... where <code>a == b == c</code> is <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are concerned about speed (say you have a looong list of strings) and you know the nature of the newline char, string slicing is actually faster than rstrip. A little test to illustrate this:</p>
<pre><code>import time

loops = 50000000

def method1(loops=loops):
    test_string = 'num\n'
    t0 = time.time()
    for num in xrange(loops):
        out_sting = test_string[:-1]
    t1 = time.time()
    print('Method 1: ' + str(t1 - t0))

def method2(loops=loops):
    test_string = 'num\n'
    t0 = time.time()
    for num in xrange(loops):
        out_sting = test_string.rstrip()
    t1 = time.time()
    print('Method 2: ' + str(t1 - t0))

method1()
method2()
</code></pre>
<p>Output:</p>
<pre><code>Method 1: 3.92700004578
Method 2: 6.73000001907
</code></pre>
</div>
<div class="post-text" itemprop="text">
<hr/>
<p>This will work both for windows and linux (bit expensive with re sub if you are looking for only re solution)</p>
<pre><code>import re 
if re.search("(\\r|)\\n$", line):
    line = re.sub("(\\r|)\\n$", "", line)
</code></pre>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p>A catch all:</p>
<pre><code>line = line.rstrip('\r|\n')
</code></pre>
</div>
<span class="comment-copy">See also <a href="http://stackoverflow.com/questions/2572/is-it-poor-etiquette-to-answer-your-own-question" title="is it poor etiquette to answer your own question">stackoverflow.com/questions/2572/…</a></span>
<span class="comment-copy">OK, I've redone it so that people don't mark you down too much :)  Welcome to Stack Overflow, apart from a few strange rules like this one, it's a pretty friendly and sensible place!</span>
<span class="comment-copy">@Sorin Sbarnea  rstrip('\n') works with Python3.</span>
<span class="comment-copy">What is the "last character of a value"? What does chomp do: remove all trailing newlines, or <i>one</i> trailing newline?</span>
<span class="comment-copy">Superset: any string instead of just newline: <a href="http://stackoverflow.com/questions/1038824/how-do-i-remove-a-substring-from-the-end-of-a-string-in-python" title="how do i remove a substring from the end of a string in python">stackoverflow.com/questions/1038824/…</a></span>
<span class="comment-copy">I'm not a Python person so I don't have the answer to this, but Perl's chomp() actually removes the input record separator from the end. That's a newline on Unixy things, but may be different (e.g. Windows) and it's mutable. Is there a way to remove that value only once from the end of a string?</span>
<span class="comment-copy">brian d foy: Python doesn't have an input record separator like awk and Perl have.</span>
<span class="comment-copy">Is \n sufficient?  &gt;&gt;&gt; "test string\r\n".rstrip("\n") 'test string\r'</span>
<span class="comment-copy">@csde_rats, that's not true: OS X uses <code>\n</code> for newlines just like Unix. (Prior to OS X, MacOS did use <code>\r</code> as a line separator, but that ended 10 years ago.)</span>
<span class="comment-copy">@briandfoy Python has built-in support for Universal newlines (only when reading, not when writing). You open the file in either "U" or "rU" mode, and then regardless of Windows, Linux, Mac, whatever, by the time the text reaches your python code, any style of newline has been replaced with "\n". See: <a href="http://www.python.org/dev/peps/pep-0278/" rel="nofollow noreferrer">python.org/dev/peps/pep-0278</a></span>
<span class="comment-copy">Not if you use fd.readlines() or the like.</span>
<span class="comment-copy">note: <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="nofollow noreferrer"><code>str.splitlines()</code> treats as newlines many characters (not just <code>\r</code>, <code>\n</code>)</a></span>
<span class="comment-copy">Note that modern Mac OS X apps use \n. Only old Carbon apps originally written for Mac OS use \r.</span>
<span class="comment-copy">Thanks for the clarification.  Of course, the rstrip('\r\n') still works in that case too.</span>
<span class="comment-copy">There's also <a href="http://docs.python.org/library/os.html#os.linesep" rel="nofollow noreferrer"><code>os.linesep</code></a>, which contains the EOL sequence for the current OS.</span>
<span class="comment-copy">This is the best answer: It <i>only</i> strips newlines, and does it correctly for the most common platforms.</span>
<span class="comment-copy">plus +1 For using <code>\n</code> and <code>\r</code></span>
<span class="comment-copy">Also, strip() removes repeated characters, whereas chop/chomp only removes one newline</span>
<span class="comment-copy">Ah yes, strings are immutable, thanks for the reminder!</span>
<span class="comment-copy">This won't work however if you are trying to clean up user submitted content in a web application. The user content could come from any source and contain any newline chars.</span>
<span class="comment-copy">Good point, except that you may be processing 'foreign' files (from antiquated systems) on your modern os.</span>
<span class="comment-copy">Keep in mind also that if you are reading a file in text mode, this won't work on a Windows system either, because the trailing character will always be converted to '\n'.</span>
<span class="comment-copy">This worked great for me trying to quickly turn a text file with line endings into one line of text.  I'm a newbie, so not sure if there's a better way to do it, but it worked, thanks!  (Strip seemed to only work from the ends, not internally)</span>
<span class="comment-copy">Why not just use one replace statement, like <code>.replace('\n|\r', '')</code>?</span>
<span class="comment-copy">@Doorknob doesn't work</span>
<span class="comment-copy">Just in case anyone else wants to use the idea from @DoorknobofSnow, it's just a small change to use the regex module: <code>import re</code> <code>re.sub('\n|\r', '', '\nx\n\r\n')</code> ==&gt; <code>'x'</code>.</span>
<span class="comment-copy">Using this and regex technique as @TaylorEdmiston mentioned should be the proper answer.</span>
<span class="comment-copy">Tried this solution but it strips off leading blanks in the line.</span>
<span class="comment-copy">@Tarik you can use rstrip</span>
<span class="comment-copy">rstrip will delete all trailing whitespace, unlike chomp which only deletes at most one newline.</span>
<span class="comment-copy">The other thing to note is that it does not remove at most one newline, but all newlines, unlike <code>chomp</code>.</span>
<span class="comment-copy">Finally, an answer that only removes it <i>once</i> (like the actual chomp...) and is OS portable!</span>
<span class="comment-copy">Kudos, you're the only one that pointed out this very important detail. However, as someone above noted, using os.linesep won't work if you're reading files from a different system. This might take a bit more work in Python, actually inspecting the end of the line.</span>
<span class="comment-copy">This is also going to remove tab whitespace, which the original question does not request. ( Due to the \t character )</span>
<span class="comment-copy">Sometimes the newline is not <i>a</i> last character, but the last ones, specially on windows, as others have pointed out.</span>
<span class="comment-copy">please put some description in your answer</span>
<span class="comment-copy">Note: With <code>operator.methodcaller</code> and <code>map</code> (<code>itertools.imap</code> on Py2) you can push this work to the C layer, avoiding Python level generator code (and thereby running a bit faster, though admittedly I/O overhead is likely to mask small gains): <code>for line in map(operator.methodcaller('rstrip', '\r\n'), infile):</code>. It could be still be factored out as <code>def chomped_lines(it): return map(operator.methodcaller('rstrip', '\r\n'), it)</code>.</span>
<span class="comment-copy">Thanks @ShadowRanger. I have updated the code accordingly.</span>
<span class="comment-copy">You could skip the non-capturing group, even for your final approach, with the regex <code>r'\r?\n$'</code>. Likely more efficient, since regex engines have a harder time optimizing alternations. Also note that if you're going to do this many times, it will be significantly faster (especially if you're intermingling with other <code>re</code> uses) to <code>re.compile</code> the expression once up front, then use the <code>sub</code> method of the compiled regex object; module functions are Python level and check a cache for compiled regexes first (creating/caching if missing), then call the matching method; skipping that lookup helps.</span>
<span class="comment-copy">Also, side-note: Since you're trying to match the <code>\n</code> directly, you might want to use <code>\Z</code> over <code>$</code> (or just match <code>\r?$</code>, since <code>$</code> implicitly can match just before the newline at the end of a string).</span>
<span class="comment-copy">Note that this is not the same as chomp.</span>
<span class="comment-copy">The example I needed! So rstrip("\r\n") will strip both '\n' and '\r' in any combination at the end of the line!</span>
<span class="comment-copy">@Agostino No need to provide <code>"\r\n"</code> For example: <code>'     spacious   \n\r\n\r  \n\n'.rstrip()</code> produces <code>'     spacious'</code></span>
<span class="comment-copy">@olibre the code you suggest will also strip other blank/space characters, which might not be what one needs. In fact, I only needed to strip combinations of eol characters. Still, thanks for pointing this out.</span>
<span class="comment-copy">You don't even need full fledged regular expressions. <code>rstrip("\r\n")</code> is a catch-all. Try <code>print(text_2.rstrip('\r\n'))</code>.</span>
<span class="comment-copy">@Agostino : True, given that <code>str.rstrip()</code> solves the problem. It depends on which needs you have. This solution is specifically made for the cases when you need to remove just the last <code>"\n"</code>, <code>"\r"</code> or <code>"\r\n"</code> but not all of them (if there are multiple <code>"\n"</code> in the string). <code>re.sub(r"\r?\n?$", "", text_1, 1)</code> returns <code>"hellothere\n\n"</code> and <code>text_1.rstrip("\r\n")</code> returns <code>"hellothere"</code> which is a different string.</span>
<span class="comment-copy">What I  am trying to say is: that <code>str.strip()</code> is a catch-all is sometimes the very problem.</span>
<span class="comment-copy">I know I should probably use "global loops" inside of the functions, but this works as well.</span>
<span class="comment-copy">This test is wrong and not fair.. In <code>method1</code> you are just chopping off the last character, no matter what, in <code>method2</code> the <code>.rstrip()</code> first checks, if the end of the String contains undesired characters and chops them off, only if some were found. Please implement some check for characters in <code>method1</code> and test agin!</span>
<span class="comment-copy">As I said in the intro to the answer: If you know the nature of the newline char, then this is useful. If you don't then yes, you obviously need to implement some sort of character check - or just use rstrip. I did not mean to be "unfair" to rstrip, but simply illustrate a not so insignificant difference that may be worth considering in some situations.</span>
<span class="comment-copy">Why use <code>re.search</code> where you just need <code>re.sub</code>?</span>
<span class="comment-copy"><code>rstrip</code> does not take regular expression. <code>"hi|||\n\n".rstrip("\r|\n")</code> returns <code>"hi"</code></span>
