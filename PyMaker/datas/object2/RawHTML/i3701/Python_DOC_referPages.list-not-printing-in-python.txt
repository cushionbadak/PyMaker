<div class="post-text" itemprop="text">
<p>I'm writing a code to understand inheritance and here is what I did so far.</p>
<pre><code>class Master:

    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name
        self.full_name = first_name + last_name
        self.email_id = (first_name + last_name + '@vit.com').lower()

class Student(Master):

    def __init__(self, first_name, last_name, reg_num):
        super().__init__(first_name, last_name)
        self.reg_num = reg_num

    def __str__(self):
        return self.first_name + " " + self.last_name

class Proctor(Master):

    def __init__(self, first_name, last_name, students=None):
        super().__init__(first_name, last_name)
        if students is None:
            self.students = []
        else:
            self.students = students


stud_1 = Student('kishan', 'B', '16BEI0067')
proctor_1 = Proctor('Mani', 'Mozhi', [stud_1])

print(proctor_1.students)
</code></pre>
<p>When the last print statement excutes, instead of getting the details of <strong>stud_1</strong>, I get <strong>[&lt;__main__.student object at 0x7f362206a908&gt;]</strong></p>
<p>What is going wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to add an <code>__str__()</code> method to your student class to indicate how it should be printed:</p>
<pre><code>class Student(Master):
    def __init__(self, first_name, last_name, reg_num):
        super().__init__(first_name, last_name)
        self.reg_num = reg_num

    def __str__(self):
        return self.first_name + " " + self.last_name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are printing the object itself, not the attributes.
To print those you have to either go through the list with a for loop and call the attributes in this way:</p>
<pre><code>for s in proctor_1.students:
    print(s.first_name, s.last_name)  # and so on
</code></pre>
<p>Or you could implement the <code>__str__</code> dunder method:</p>
<pre><code>def __str__(self):
    return s.first_name + " " + s.last_name
</code></pre>
<p>(Or however you want the output to look like.)</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a number of ways that you could print the attributes of an object in Python. Here's one other way. This will print the attributes of the object:</p>
<pre><code>for attr in dir(proctor_1):
    if hasattr(proctor_1, attr):
        print("proctor_1.%s = %s" % (attr, getattr(proctor_1, attr)))
</code></pre>
<p>You could also wrap this in a <code>dump</code> function and then call <code>dump(obj)</code> to print out the attributes.</p>
</div>
<span class="comment-copy">That is to be expected, you need to <code>def __repr__(self):</code> to see a better string representation of your <code>student</code> objects (which incidentally should be named <code>Student</code> by convention). <a href="https://stackoverflow.com/q/1984162/866333">stackoverflow.com/q/1984162/866333</a></span>
<span class="comment-copy">Class names usually capitalized, this helps separate them from lowercase instance names.</span>
<span class="comment-copy">@EvgenyPogrebnyak Thanks for pointing that out!</span>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/pprint.html#pprint.pprint" rel="nofollow noreferrer"><b><code>pprint</code></b></a> to pretty-print the contents of the list.</span>
<span class="comment-copy">Now, inspite of adding the <b>str</b> to my students method, I still get the same object output, just a different RAM address.</span>
<span class="comment-copy">This looks like an inspection approach, good forr unknown object, but OP is writing own class, are you sure this is good for him?</span>
