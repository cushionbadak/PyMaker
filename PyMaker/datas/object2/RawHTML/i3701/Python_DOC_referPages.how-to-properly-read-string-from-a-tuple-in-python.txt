<div class="post-text" itemprop="text">
<p>I am using python to read data from a sensor. the measurement are sent through UDP. I wrote a small function to read the 816 bytes messages:</p>
<pre><code>def _recvdata(tcp, _row):
    string = ''
    bytes_read = 0
    #bytes_n = _row - bytes_read
    while bytes_read &lt; _row:
        try:
            chunk = tcp.recvfrom(_row - bytes_read)
        except socket.timeout:
            print("Receiver timeout")
            return None
        bytes_read += len(chunk[0])
        string += chunk[0]
    print(int(chunk[0], 16))
    return chunk[0]
</code></pre>
<p>the returned tuple chunk contains the the measurement in chunk[0] and the ip address in chunk[0].
The element I'm interested in is chunk[0], but the weird probleme I have is when I print it or return it, it shows me unreadable data like this:</p>
<blockquote>
<p>        √ø√ÆP               -  7  A  K                 &lt;     <br/>
  √ø√Æc               -  7  A  K                 &lt;             √ø√Æv<br/>
  2  7  A              7                √ø√Æ‚Ä∞n  n  2           2  Z 
  U  ‚Äö  d  P  P  F          7       √ø√Æ‚Ä∫      P  &lt;     A  K     
    #  #  2      #  7       √ø√Æ¬Æ      P  &lt;     A  K        # </p>
<h1>2      #  (       √ø√Æ√Å(  (        -    F    A  </h1>
<p>&lt;                 √ø√Æ√îd  d  #    #  A  K  #    -  -  U  U  A<br/>
    (  #  P  √ø√Æ√¶d  #  #    #  A  K  #    -  -  U  U  A          ( </p>
<h1>P   √ÑVi   !"#$%&amp;'()√ø√Æ√πP  ‚Äö  ‚Äö  K  U  A  2  d  A  ¬†  2  _  _  Z     U       √ø√ÆZ  &lt;  &lt;  F  7  A     7  7  2    </h1>
<p>P  (  7         (  √ø√Æ         P  s  d  K  A  U  (  -  s  s  (  d 
  7     #  &lt;  #  √ø√Æ1         P  s  d  K  A  U  (  -  s  s  (  d  7<br/>
  #</p>
</blockquote>
<p>but then when I print the whole tuples chunk, the characters are shown correctly:</p>
<blockquote>
<p>'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f
  !"#$%&amp;\'()\xff\xee\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee&amp;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xeeK\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xeeq\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee\x83\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee\x96\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee\xa9\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee\xbc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xee\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00v\xedt\x00\x00'</p>
</blockquote>
<p>I don't know how to print the latter using chunk[0] only. I have tried:</p>
<ul>
<li>binascii.unhexlify</li>
<li>int(chunk[0], 16)</li>
</ul>
<p>When I type type(chunk[0]), it returns str. but then I would guess it's a sting of hex values ?
thanks for any help </p>
</div>
<div class="post-text" itemprop="text">
<p>Would <code>print(chunck[0].encode('utf-8'))</code> give you proper output?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need the hex representation of the characters, you should return the hex representation of a <a href="https://docs.python.org/3/library/functions.html#func-bytes" rel="nofollow noreferrer"><code>bytes</code></a> object:</p>
<pre><code>res = bytes(chunk[0]).hex()
</code></pre>
</div>
<span class="comment-copy">Interesting. How does the actual sending of the data is being handled from the sensor? Might i suggest attempting to connect to it using simple telnet client <code>telnet [ADDR] [PORT]</code> and then seeing if any data sent from the sesnsor makes sense.</span>
<span class="comment-copy">I actually could not use telnet to read the packet. but the hex format looks more correct, in the sensor's documentation, to get a proper reading of the angle for example, they ask me the following:  exchange the 2 bytes : 0x16 0x18 get 2 bytes integer: 0x618 then transform to decimal system:1560 then multiply by 0.01 to get angle</span>
<span class="comment-copy">There's actually a python module that you could try out to: <a href="https://docs.python.org/2/library/struct.html" rel="nofollow noreferrer">docs.python.org/2/library/struct.html</a> In particular, the <code>unpack</code> function or the <code>unpack_from</code> one.</span>
<span class="comment-copy">Try <code>return bytes(chunk[0])</code></span>
<span class="comment-copy">bytes(chunk[0]) returns the same characters...</span>
<span class="comment-copy">no it will print an error: UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 42: ordinal not in range(128)</span>
<span class="comment-copy">Updated, you should now get a string of hex values.</span>
