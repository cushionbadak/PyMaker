<div class="post-text" itemprop="text">
<p>My question is I have a parent process A, and I set up a daemon thread as a RPC server like TaskRPCServer(Thread). Then I would like to spawn a child process using Python multiprocessing.Process object. Eg: B = Process(), B.start(). Dese B will have the same daemon thread as A?  Is there a way that I can force B not have the daemon thread running in A?  Because there is some cases that a lot of process will listen to the RPC ports. Or if my design was wrong, how can I do it correctly?  Thank you!  </p>
</div>
<div class="post-text" itemprop="text">
<p>When you fork a child, it starts with only one thread. This is <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html" rel="nofollow noreferrer">defined by POSIX</a>:<sup>1</sup></p>
<blockquote>
<p>A process shall be created with a single thread. If a multi-threaded process calls fork(), the new process shall contain a replica of the calling thread and its entire address space, possibly including the states of mutexes and other resources. </p>
</blockquote>
<p>So, your child process will not have the daemon thread. You don't have to do anything to force it not to.</p>
<hr/>
<p>You can test this yourself pretty easily:</p>
<pre><code>import threading
import os
import time

def threadfunc():
    while True:
        print(os.getpid())
        time.sleep(1)

def main():
    t = threading.Thread(target=threadfunc)
    t.start()
    pid = os.fork()
    if pid:
        print(f'Forked {pid}; sleep time')
        time.sleep(5)
    else:
        print(f'Forked child; sleep time')
        time.sleep(5)

main()
</code></pre>
<p>If you run this, you'll see something like this:</p>
<pre><code>12345
Forked 12346; sleep time
Forked child; sleep time
12345
12345
12345
</code></pre>
<p>Notice that the daemon thread printed 12345, the PID of the parent process, 5 times, and nobody ever printed 12346, the PID of the child process.</p>
<hr/>
<p>But meanwhile, even though it the problem you're asking about doesn't exist, there <em>are</em> sometimes problems mixing <code>fork</code> and threads, and <code>multiprocessing</code> gives you a way around those problems, as described in <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">Contexts and start methods</a>.</p>
<p><code>multiprocessing.set_start_method('forkserver')</code> guarantees that your child processes are spun up from a clean state as far as threading, mutexes, etc.<sup>2</sup> It also protects you from accidentally sharing file handles. (The third option, <code>spawn</code>, is usually only needed if you want to make sure your code runs the same on Unix and Windows.)</p>
<hr/>
<p><sub>1. This may not be true for some very old Unix platforms, but it will be true for any macOS, Linux, *BSD, etc. that support POSIX threading at least back to <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fork.html" rel="nofollow noreferrer">2004</a>, and probably earlier, but I can't find the older POSIX/SUS specs free and legal online anywhereâ€¦</sub></p>
<p><sub>2. Besides the problems the POSIX docs warn about, there are murkier problems with things like trying to run a Cocoa main loop while multiprocessing from a background thread.</sub></p>
</div>
