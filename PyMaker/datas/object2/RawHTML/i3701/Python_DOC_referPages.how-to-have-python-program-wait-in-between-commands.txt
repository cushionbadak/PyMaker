<div class="post-text" itemprop="text">
<p>I'm using python 3 on Komodo, and I want for there to be a time delay between the execution of commands. However, using the code below, all of the print commands are launched at the same time, but it does show that the time after all the commands are executed is two seconds greater than the time before the commands are executed. Is there a way for the first line to be printed, wait a second, second line be printed, wait a second, and have third and fourth lines be print? </p>
<pre><code>import time
from time import sleep

t=time.asctime(time.localtime(time.time()));
print(t)

time.sleep(1)

print('Good Night')

time.sleep(1)

print('I"m back')
t=time.asctime(time.localtime(time.time()));
print(t)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By default, <a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer"><code>print</code></a> prints to <a href="https://docs.python.org/3/library/sys.html#sys.stdout" rel="nofollow noreferrer"><code>sys.stdout</code></a>, which is line-buffered when writing to an interactive terminal,<sup>1</sup> but block-buffered when writing to a file.</p>
<p>So, when you run your code with <code>python myscript.py</code> from your Terminal or Command Prompt, you will see each line appear as it's printed, as desired. </p>
<p>But if you run it with, say, <code>python myscript.py &gt;outfile</code>, nothing will get written until the buffer fills up (or until the script exits, if that never happens). Normally, that's fine. But apparently, however you're running your script in Komodo, it looks like a regular file, not an interactive terminal, to Python.</p>
<hr/>
<p>It's possible that you can fix that just by using or configuring Komodo differently.</p>
<p>I don't know much about Komodo, but I do see that there's <a href="https://community.komodoide.com/packages/addons/terminal/" rel="nofollow noreferrer">an addon for embedding a terminal</a>; maybe if you use that instead of sending output to the builtin JavaScript (?) console, things will work better, but I really have no idea.</p>
<hr/>
<p>Alternatively, you can make sure that the output buffer is flushed after each line by doing it manually, e.g., by passing the <a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer"><code>flush</code> argument to <code>print</code></a>:</p>
<pre><code>print(t, flush=True)
</code></pre>
<hr/>
<p>If you really want to, you can even replace <code>print</code> in your module with a function that always does this:</p>
<pre><code>import builtins
import functools
print = functools.partial(builtins.print, flush=True)
</code></pre>
<p>â€¦ but you probably don't want to do that.</p>
<hr/>
<p>Alternatively, you can replace <code>sys.stdout</code> with a line-buffered file object over the raw stdout, just by calling <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>open</code></a> on its underlying raw file or file descriptor:</p>
<pre><code>sys.stdout = open(sys.stdout.fileno(), buffering=1)
</code></pre>
<hr/>
<p>If you search around Stack Overflow or the web, you'll find a lot of suggestions to disable buffering. And you <em>can</em> force Python to use unbuffered output with the <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-u" rel="nofollow noreferrer"><code>-u</code></a> flag or the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONUNBUFFERED" rel="nofollow noreferrer"><code>PYTHONUNBUFFERED</code></a> environment variable. But that may not do any good in Python 3.<sup>2</sup></p>
<hr/>
<p><sup>1. As <a href="https://docs.python.org/3/library/sys.html#sys.stdout" rel="nofollow noreferrer"><code>sys.stdout</code></a> explains, it's just a regular text file, like those returned by <code>open</code>. As explained in <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>open</code></a>, this distinction is made by calling <a href="https://docs.python.org/3/library/os.html#os.isatty" rel="nofollow noreferrer"><code>isatty</code></a>.</sup></p>
<p><sup>2. Python 2's <code>stdout</code> is just a thin wrapper around the C stdio object, so if you open it unbuffered, there's no buffering. Python 3's <code>stdout</code> is a hefty wrapper around the raw file descriptor that does its own buffering and decoding (see the <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer"><code>io</code></a> docs for details), so <code>-u</code> will make <code>sys.stdout.buffer.raw</code> unbuffered, but <code>sys.stdout</code> itself will still be buffered, as explained in the <code>-u</code> docs.</sup></p>
</div>
<span class="comment-copy">You are probably facing the output buffering. Check this out: <a href="https://stackoverflow.com/questions/107705/disable-output-buffering" title="disable output buffering">stackoverflow.com/questions/107705/disable-output-buffering</a></span>
<span class="comment-copy">@EugeneSh. Unfortunately, that question is pretty 2.x-centric, and most of the answers are wrong or irrelevant for Python 3, so I think it may just confuse people.</span>
<span class="comment-copy">@EugeneSh. Then again, maybe we should close this one as a dup and add a proper 3.x answer and/or edit the top answer(s) on that one?</span>
<span class="comment-copy">@abarnert Maybe you are right. I am not a python expert, just identified a language-agnostic problem here.</span>
<span class="comment-copy">@EugeneSh. If it helps: Python 2's <code>stdout</code> is just a wrapper around the C stdio object; Python 3's <code>stdout</code> is a Python object that manually buffers and transcodes on top of the raw file descriptor. But meanwhile, you should have some insight into whether it makes more sense to keep this question separate, or merge them .</span>
