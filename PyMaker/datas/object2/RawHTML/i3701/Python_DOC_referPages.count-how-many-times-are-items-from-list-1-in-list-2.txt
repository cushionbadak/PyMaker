<div class="post-text" itemprop="text">
<p>I have 2 lists:</p>
<pre><code>1. ['a', 'b', 'c']
2. ['a', 'd', 'a', 'b']
</code></pre>
<p>And I want dictionary output like this:</p>
<pre><code>{'a': 2, 'b': 1, 'c': 0}
</code></pre>
<p>I already made it:</p>
<pre><code>#b = list #1
#words = list #2

c = {}
for i in b:
    c.update({i:words.count(i)})
</code></pre>
<p>But it is very slow, I need to process like 10MB txt file.</p>
<p>EDIT: Entire code, currently testing so unused imports..</p>
<pre><code>import string
import os
import operator
import time
from collections import Counter
def getbookwords():

    a = open("wu.txt", encoding="utf-8")

    b = a.read().replace("\n", "").lower()
    a.close()

    b.translate(string.punctuation)

    b = b.split(" ")
    return b

def wordlist(words):

    a = open("wordlist.txt")
    b = a.read().lower()
    b = b.split("\n")

    a.close()

    t = time.time()
    #c = dict((i, words.count(i)) for i in b )

    c  = Counter(words)
    result = {k: v for k, v in c.items() if k in set(b)}
    print(time.time() - t)

    sorted_d = sorted(c.items(), key=operator.itemgetter(1))    
    return(sorted_d)

print(wordlist(getbookwords()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>@Makalone</strong>, above answers are appreciable. You can also try the below code sample which uses Python's <code>Counter()</code> from <code>collections</code> module. </p>
<blockquote>
<p>You can try it at <a href="http://rextester.com/OTYG56015" rel="nofollow noreferrer">http://rextester.com/OTYG56015</a>.</p>
</blockquote>
<h3>Python code »</h3>
<pre><code>from collections import Counter

list1 = ['a', 'b', 'c']
list2 = ['a', 'd', 'a', 'b']
counter = Counter(list2)

d = {key: counter[key] for key in set(list1)}
print(d)
</code></pre>
<h3>Output »</h3>
<pre><code>{'a': 2, 'c': 0, 'b': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since speed is currently an issue, it might be worth considering not passing through the list for each thing you want to count. The <code>set()</code> function allows you to only use the <strong>unique</strong> keys in your list <code>words</code>.</p>
<p>An important thing to remember for speed in all cases is the line <strong><code>unique_words = set(b)</code></strong>. Without this, <strong>an entire pass</strong> through your list is being done to create a set from <code>b</code> <strong>at every iteration</strong> in whichever kind of data structure you happen to use.</p>
<pre><code>c = {k:0 for k in set(words)}
for w in words:
    c[w] += 1
unique_words = set(b)
c = {k:counts[k] for k in c if k in unique_words}
</code></pre>
<p>Alternatively, <code>defaultdicts</code> can be used to eliminate some of the initialization.</p>
<pre><code>from collections import defaultdict

c = defaultdict(int)
for w in words:
    c[w] += 1
unique_words = set(b)
c = {k:counts[k] for k in c if k in unique_words}
</code></pre>
<p>For completeness sake, I do like the <code>Counter</code> based solutions in the other answers (like from Reut Sharabani). The code is cleaner, and though I haven't benchmarked it I wouldn't be surprised if a built-in counting class is faster than home-rolled solutions with dictionaries.</p>
<pre><code>from collections import Counter

c = Counter(words)
unique_words = set(b)
c = {k:v for k, v in c.items() if k in unique_words}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and move <code>b</code> to a <code>set</code>, not a <code>list</code>:</p>
<pre><code>from collections import Counter

c = Counter(words)
b = set(b)
result = {k: v for k, v in c.items() if k in b}
</code></pre>
<p>Also, if you can read the words lazily and not create an intermediate list that should be faster.</p>
<p><code>Counter</code> provides the functionality you want (counting items), and filtering the result against a <code>set</code> uses hashing which should be a lot faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collection.Counter</code> on a generator that skips ignored keys using a <code>set</code> lookup.</p>
<pre><code>from collections import Counter

keys = ['a', 'b', 'c']
lst = ['a', 'd', 'a', 'b']

unique_keys = set(keys)
count = Counter(x for x in lst if x in unique_keys)

print(count) # Counter({'a': 2, 'b': 1})

# count['c'] == 0
</code></pre>
<p>Note that <code>count['c']</code> is not printed, but is still <code>0</code> by default in a <code>Counter</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an example I just coughed up in repl. Assuming you're not counting duplicates in list two. We create a hash table using a dictionary. For each item in the list were matching two, we create a key value pair with the item being the key and we set the value to 0.</p>
<p>Next we iterate through the second list, for each value, we check if the value has been defined already, if it has been, than we increment the value using the key. Else, we ignore.</p>
<p>Least amount of iterations possible. You hit each item in each list only once.</p>
<pre class="lang-py prettyprint-override"><code>x = [1, 2, 3, 4, 5];
z = [1, 2, 2, 2, 1];
y = {};

for n in x:
  y[n] = 0; //Set the value to zero for each item in the list

for n in z:
  if(n in y): //If we defined the value in the hash already, increment by one 
    y[n] += 1;

print(y)
</code></pre>
</div>
<span class="comment-copy">Can you show how you read the file? Don't read it to a list if you don't have to.</span>
<span class="comment-copy">How slow is "slow"?</span>
<span class="comment-copy">It is taking more than 60 seconds... Currently testing the 1st answer</span>
<span class="comment-copy">Whoa... This works! &lt;2 seconds. Thanks!</span>
<span class="comment-copy">The <code>for key in list1</code> bit can be sped up with a hash structure like <code>set(list1)</code> as in the other answers. This may have worked fine for OP's original data, but malicious counter-examples can make this perform exceptionally bad.</span>
<span class="comment-copy"><b>@Musgrave</b>, thanks for your suggestion and edit. I thought <b>list1</b> will be taken as unique set of keys. This is good to use <b>set()</b> as user can also use duplicated elements which can cause performance issue.</span>
<span class="comment-copy"><code>defaultdict</code> would work here too!</span>
<span class="comment-copy">Thank you! Amazing how I forget about simple solutions to problems sometimes.</span>
<span class="comment-copy">Tried, takes too long!</span>
<span class="comment-copy">Share the code.</span>
<span class="comment-copy">Already someone said that, too slow!</span>
<span class="comment-copy">@MakaloneLOgman No, it is not the same, it is slightly more efficient since it uses a generator comprehension to skip the counting of words that are not in the keys</span>
<span class="comment-copy">Ok...... But I also just copy-pasted-tested-it rn, and took &gt;60seconds</span>
<span class="comment-copy">@MakaloneLOgman That was because I forgot to create the set outside the loop. This solution will be way way faster</span>
