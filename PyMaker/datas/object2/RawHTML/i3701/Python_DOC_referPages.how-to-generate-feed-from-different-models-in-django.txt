<div class="post-text" itemprop="text">
<p>So, I have two models called apartments and jobs. It's easy to display contents of both models separately, but what I can't figure out is how to display the mix feed of both models based on the date.</p>
<pre><code>jobs = Job.objects.all().order_by('-posted_on')
apartments = Apartment.objects.all().order_by('-date')
</code></pre>
<p>The posted date on job is represented by 'posted_by' and the posted date on apartment is represented by 'date'. How can I combine both of these and sort them according to the date posted? I tried combining both of these models in a simpler way like:</p>
<pre><code>new_feed = list(jobs) + list(apartments)
</code></pre>
<p>This just creates the list of both of these models, but they are not arranged based on date. </p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest two ways to achieve that.</p>
<p>With <a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#union" rel="nofollow noreferrer"><code>union()</code></a> <strong>New in Django 1.11.</strong><br/>
Uses <em>SQLâ€™s UNION</em> operator to combine the results of two or more QuerySets</p>
<blockquote>
<p>You need to to make sure that you have a unique name for the ordered field
  Like <code>date</code> field for <code>job</code> and also <code>apartment</code></p>
</blockquote>
<pre><code>jobs = Job.objects.all().order_by('-posted_on')
apartments = Apartment.objects.all().order_by('-date')

new_feed = jobs.union(apartments).order_by('-date')
</code></pre>
<blockquote>
<p>Note with this options, you need to have the same field name to order them.</p>
</blockquote>
<p>Or<br/>
With <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>chain()</code></a>, used for treating consecutive sequences as a single sequence and use <code>sorted()</code> with <code>lambda</code> to sort them</p>
<pre><code>from itertools import chain

# remove the order_by() in each queryset, use it once with sorted
jobs = Job.objects.all()
apartments = Apartment.objects.all()
result_list = sorted(chain(job, apartments),
                key=lambda instance: instance.date)

</code></pre>
<p>With this option, you don't really need to rename or change one of your field names, just add a property method, let's choose the Job Model</p>
<pre><code>class Job(models.Model):
    ''' fields '''
    posted_on = models.DateField(......)

    <b>@property
    def date(self):
         return self.posted_on</b>
</code></pre>
<p>So now, both of your models have the attribute <code>date</code>, you can use <code>chain()</code></p>
<pre><code>result_list = sorted(chain(job, apartments),
                     key=lambda instance: <b>instance.date</b>)</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A good way to do that is to use adapter design pattern. The idea is that we introduce an auxiliary data structure that can be used for the purpose of sorting these model objects. This method has several benefits over trying to fit both models to have the identically named attribute used for sorting. The most important is that the change won't affect any other code in your code base. </p>
<p>First, you fetch your objects as you do but you don't have to fetch them sorted, you can fetch all of them in arbitrary order. You may also fetch just top 100 of them in the sorted order. Just fetch what fits your requirements here:</p>
<pre><code>jobs = Job.objects.all()
apartments = Apartment.objects.all()
</code></pre>
<p>Then, we build an auxiliary list of tuples (attribute used for sorting, object), so:</p>
<pre><code>auxiliary_list = ([(job.posted_on, job) for job in jobs] 
                + [(apartment.date, apartment) for apartment in apartments])
</code></pre>
<p>now, it's time to sort. We're going to sort this auxiliary list. By default, python sort() method sorts tuples in lexicographical order, which mean it will use the first element of the tuples i.e. posted_on and date attributes for ordering. Parameter reverse is set to True for sorting in decreasing order i.e. as you want them in your feed. </p>
<pre><code>auxiliary_list.sort(reverse=True)
</code></pre>
<p>now, it's time to return only second elements of the sorted tuples:</p>
<pre><code>sorted_feed = [obj for _, obj in auxiliary_list]
</code></pre>
<p>Just keep in mind that if you expect your feed to be huge then sorting these elements in memory is not the best way to do this, but I guess this is not your concern here.</p>
</div>
<span class="comment-copy">It's important to have the same field name, so Django will not have trouble to filter and order both</span>
<span class="comment-copy">@BibekBhandari no if this sorting will be the only reason to do that. You can solve your problem without introducing artificial date field to Job model</span>
<span class="comment-copy">@BibekBhandari, updated my answer</span>
<span class="comment-copy">you can reverse the queryset with the argument <code>reverse</code> like <code>key=lambda instance: instance.date, reverse=True</code></span>
<span class="comment-copy">Sorry instead of <code>reversed</code> it's <code>reverse</code>, a typo</span>
<span class="comment-copy">Will work well, but not the best a faster way, this <code>for job in jobs</code> will require more memory, also this <code>for apartment in apartments</code>. then your sort them, finally you loop through them once again.</span>
<span class="comment-copy">great explanation. Thank you. Can you tell me how to know which model the data is related to from that sorted_feed, when i display it in the front end using django language templating</span>
<span class="comment-copy">Agreed, but why doing this hard work, while <code>union()</code> or <code>chain()</code> exists? I would never suggest to loop through queryset wit <code>for</code> loop.</span>
<span class="comment-copy">@Lemayzeur I'm also a big fan of efficiency, but if these lists are not extremely large for a standard website standards, I find much more important to have a clean code and this method hides all sorting burden from the code and doesn't require any changes in existing code. I answered assuming that these lists of objects doesn't have over hundred thousands items. Also, one can make code I provided more efficient using iterators instead of lists and indices instead of objects in the tuples. I used the simplest structures for the purpose of explanation and readability</span>
<span class="comment-copy">@BibekBhandari you can use python built-in isinstance method to make a test <a href="https://docs.python.org/2/library/functions.html#isinstance" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#isinstance</a></span>
