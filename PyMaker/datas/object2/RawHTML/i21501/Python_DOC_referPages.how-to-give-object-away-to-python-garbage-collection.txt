<div class="post-text" itemprop="text">
<p>There are several threads on Python garbage collection in SO, and after reading about five, plus some doc on line, i am still not sure as to how garbage collection works and how i should manage objects which i am not using. In fact somewhere i read one should not do anything about collecting garbage, others tell one should <code>del</code> objects, while others again explain de-referencing an object is enough for Python to collect it as garbage.</p>
<p>So, at the risk of creating a duplicate, i will ask the question again, but differently, hoping to get more comprehensive and clearer information.</p>
<p>In my case i want to make a small simulation with objects representing people. Several instances of the <code>Person()</code> class will be created. It should exist for some time until it virtually "dies" while other instances will be created.</p>
<p>Now how do i make this <code>Person()</code> instance "die" (assuming many many of these instances will be created and i don't want these instances to hang out like ghosts)?</p>
<p>There are several ways i can reference an object:</p>
<pre><code>john = Person('john')
</code></pre>
<p>or</p>
<pre><code>people = []
people.append(Person('john'))
</code></pre>
<p>or</p>
<pre><code>people = {}
people['john'] = Person('john')
</code></pre>
<p>What is the best way to keep my program clean, freeing resources optimally? And what is the best way then to reference my object so i can control the deletion of the object?</p>
</div>
<div class="post-text" itemprop="text">
<p>I find that most programs create and dispose of objects quite naturally, so I never normally worry about it.</p>
<p>Some examples:</p>
<pre><code>person = Person('john')
person = Person('james')
# Whoops! 'john' has died!

people = []
people.append(Person('john'))
# ...
# All 'Persons' live in people
people = []
# Now all 'Persons' are dead (including the list that referenced them)

class House():
    def setOwner(self, person):
        self.owner = person

house.setOwner(people[0])
# Now a House refers to a Person
people = []
# Now all 'Persons' are dead, except the one that house.owner refers to.
</code></pre>
<p>What I assume you are after is this:</p>
<pre><code>people = {}
people['john'] = Person('john')

def removePerson(personName):
    del people[personName]

removePerson('john')
</code></pre>
<p>In this case <code>people</code> is the master list and you can control when a <code>Person</code> gets added and removed from the list (its a dictionary).</p>
<p>You may have to think through the concept of a person being created and then dying very thoroughly:  Once created how does the person first interact with the simulation.  Upon death, how should you untangle the references?  (Its ok for a person to refer to other stuff, its things like <code>House</code> in my example that would keep a person alive.  You could have other objects hold on to just the name of the person).</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe this also can help:</p>
<pre><code>&gt;&gt;&gt; # Create a simple object with a verbose __del__ to track gc.
&gt;&gt;&gt; class C:
...     def __del__(self):
...         print "delete object"
... 
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; # Delete the object c successfully.
&gt;&gt;&gt; del c
delete object
&gt;&gt;&gt; # Deletion of an object when it go out of the scope where it was defined.
&gt;&gt;&gt; def f():
...     c = C()
...
&gt;&gt;&gt; f()
delete object
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; # Create another reference of the object.
&gt;&gt;&gt; b = c
&gt;&gt;&gt; # The object wasn't destructed the call of del only decremented the object reference. 
&gt;&gt;&gt; del c
&gt;&gt;&gt; # Now the reference counter of the object reach 0 so the __del__ was called. 
&gt;&gt;&gt; del b
delete object
&gt;&gt;&gt; # Create now a list that hold all the objects.
&gt;&gt;&gt; l = [C(), C()]
&gt;&gt;&gt; del l
delete object
delete object
&gt;&gt;&gt; # Create an object that have a cyclic reference.
&gt;&gt;&gt; class C:
...     def __init__(self):
...         self.x = self
...     def __del__(self):
...         print "delete object"
... 
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; # Run the garbage collector to collect object.
&gt;&gt;&gt; gc.collect()
9
&gt;&gt;&gt; # the gc.garbage contain object that the gc found unreachable and could not be freed.  
&gt;&gt;&gt; gc.garbage
[&lt;__main__.C instance at 0x7ff588d84368&gt;]
&gt;&gt;&gt; # Break the cyclic reference.
&gt;&gt;&gt; c.x = None
&gt;&gt;&gt; # And now we can collect this object.
&gt;&gt;&gt; del c
delete object
&gt;&gt;&gt; # Create another object with cyclic reference.
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; # When closing the interactive python interpreter the object will be collected.
delete object
</code></pre>
<p>Refrences : <a href="http://docs.python.org/reference/datamodel.html#object.__del__" rel="noreferrer"><strong>del</strong> method</a> ; <a href="http://docs.python.org/library/gc.html" rel="noreferrer">gc module</a> ; <a href="http://docs.python.org/library/weakref.html" rel="noreferrer">weakref module</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>None of this really has anything to do with garbage collection.</strong></p>
<p>Python's main method of memory management uses <em>reference counting</em>.</p>
<p>In all cases above, Python keeps a count of all the references to the object, and when there are none left, the object is deleted (similar to <code>std::shared_pointer</code> in C++).</p>
<p><strong>References get decreased</strong> when</p>
<ol>
<li>the object holding them is either explicitly <strong>deleted (via <code>del</code>)</strong></li>
<li>or goes out of scope <a href="http://www.saltycrane.com/blog/2008/01/python-variable-scope-notes/" rel="noreferrer">(see also here (esp. ex. 8))</a>.</li>
</ol>
<p>In your case, this applies to either the <code>john</code> object, or either of the <code>people</code> containers. They go out of scope at the end of the function that created them (assuming they are not <code>return</code>ed to the calling function). The vast majority of the time, you can just let them go out of scope - it's only when you create really heavy objects or collections - say inside a big loop - that you might want to consider explicitly using <code>del</code>.</p>
<p><strong>Garbage collection</strong> really only comes into play when there are <em>reference cycles</em>
- for instance, when an object refers to itself. Like:</p>
<pre><code>a = []
a.append(a)
</code></pre>
<p>Again, this happens automatically, and you shouldn't need to do anything special.</p>
</div>
<div class="post-text" itemprop="text">
<p>Previous answers are correct but here is what is recommended according to <a href="https://docs.python.org/3/tutorial/stdlib2.html" rel="nofollow noreferrer">python 3.7 Document</a>:</p>
<p>"Python does automatic memory management (reference counting for most objects and garbage collection to eliminate cycles). The memory is freed shortly after the last reference to it has been eliminated."</p>
<p>If you really have to do this because of memory management issues you are experiencing with a particular case then import the <strong>gc</strong> library and just do this</p>
<pre><code>     del self.someInstanceOfyourClass
             gc.collect()
</code></pre>
<p>here is a simple example <a href="https://github.com/nanoseconds/PythonTest/blob/master/test.py" rel="nofollow noreferrer">https://github.com/nanoseconds/PythonTest/blob/master/test.py</a></p>
</div>
<span class="comment-copy">Check the gc module: <a href="http://docs.python.org/library/gc.html" rel="nofollow noreferrer">docs.python.org/library/gc.html</a></span>
<span class="comment-copy">The short answer is: You don't. It takes it itself when you don't use (have a reference to) it any more. Or perhaps later or never. GC is not deterministic, the only guarantee is that you won't run out of memory if there's garbage to be reused (except in some circumstances with conservative GCs, but neither Python nor in any other memory-managed language has to use these; only languages with pointer arithmetic or a way for pointers to escape as integers etc. need those). And unless you understand that and why you usually don't need to worry at all, you should leave it at that.</span>
<span class="comment-copy">This question could equally apply to ruby, Smalltalk, Java, C# or VB6 and perhaps many others.</span>
<span class="comment-copy">Thanks for this one :)</span>
<span class="comment-copy">Thanks :) all answers were really good, i picked up Quamrana's because he gave an answer that was more consistent with the question's example.</span>
<span class="comment-copy">@Benjamin: Glad you get your answer :)</span>
<span class="comment-copy">Thanks :) all answers were really good, i picked up Quamrana's because he gave an answer that was more consistent with the question's example.</span>
