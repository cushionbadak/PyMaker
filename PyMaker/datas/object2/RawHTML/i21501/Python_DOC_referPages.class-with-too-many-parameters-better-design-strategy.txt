<div class="post-text" itemprop="text">
<p>I am working with models of neurons. One class I am designing is a cell class which is a topological description of a neuron (several compartments connected together). It has many parameters but they are all relevant, for example:</p>
<p>number of axon segments, apical bifibrications, somatic length, somatic diameter, apical length, branching randomness, branching length and so on and so on... there are about 15 parameters in total!</p>
<p>I can set all these to some default value but my class looks crazy with several lines for parameters. This kind of thing must happen occasionally to other people too, is there some obvious better way to design this or am I doing the right thing?</p>
<p><strong>UPDATE:</strong>
As some of you have asked I have attached my code for the class, as you can see this class has a huge number of parameters (&gt;15) but they are all used and are necessary to define the topology of a cell. The problem essentially is that the physical object they create is very complex. I have attached an image representation of objects produced by this class. How would experienced programmers do this differently to avoid so many parameters in the definition?</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/XYXBw.png"/></p>
<pre><code>class LayerV(__Cell):

    def __init__(self,somatic_dendrites=10,oblique_dendrites=10,
                somatic_bifibs=3,apical_bifibs=10,oblique_bifibs=3,
                L_sigma=0.0,apical_branch_prob=1.0,
                somatic_branch_prob=1.0,oblique_branch_prob=1.0,
                soma_L=30,soma_d=25,axon_segs=5,myelin_L=100,
                apical_sec1_L=200,oblique_sec1_L=40,somadend_sec1_L=60,
                ldecf=0.98):

        import random
        import math

        #make main the regions:
        axon=Axon(n_axon_seg=axon_segs)

        soma=Soma(diam=soma_d,length=soma_L)

        main_apical_dendrite=DendriticTree(bifibs=
                apical_bifibs,first_sec_L=apical_sec1_L,
                L_sigma=L_sigma,L_decrease_factor=ldecf,
                first_sec_d=9,branch_prob=apical_branch_prob)

        #make the somatic denrites

        somatic_dends=self.dendrite_list(num_dends=somatic_dendrites,
                       bifibs=somatic_bifibs,first_sec_L=somadend_sec1_L,
                       first_sec_d=1.5,L_sigma=L_sigma,
                       branch_prob=somatic_branch_prob,L_decrease_factor=ldecf)

        #make oblique dendrites:

        oblique_dends=self.dendrite_list(num_dends=oblique_dendrites,
                       bifibs=oblique_bifibs,first_sec_L=oblique_sec1_L,
                       first_sec_d=1.5,L_sigma=L_sigma,
                       branch_prob=oblique_branch_prob,L_decrease_factor=ldecf)

        #connect axon to soma:
        axon_section=axon.get_connecting_section()
        self.soma_body=soma.body
        soma.connect(axon_section,region_end=1)

        #connect apical dendrite to soma:
        apical_dendrite_firstsec=main_apical_dendrite.get_connecting_section()
        soma.connect(apical_dendrite_firstsec,region_end=0)

        #connect oblique dendrites to apical first section:
        for dendrite in oblique_dends:
            apical_location=math.exp(-5*random.random()) #for now connecting randomly but need to do this on some linspace
            apsec=dendrite.get_connecting_section()
            apsec.connect(apical_dendrite_firstsec,apical_location,0)

        #connect dendrites to soma:
        for dend in somatic_dends:
            dendsec=dend.get_connecting_section()
            soma.connect(dendsec,region_end=random.random()) #for now connecting randomly but need to do this on some linspace

        #assign public sections
        self.axon_iseg=axon.iseg
        self.axon_hill=axon.hill
        self.axon_nodes=axon.nodes
        self.axon_myelin=axon.myelin
        self.axon_sections=[axon.hill]+[axon.iseg]+axon.nodes+axon.myelin
        self.soma_sections=[soma.body]
        self.apical_dendrites=main_apical_dendrite.all_sections+self.seclist(oblique_dends)
        self.somatic_dendrites=self.seclist(somatic_dends)
        self.dendrites=self.apical_dendrites+self.somatic_dendrites
        self.all_sections=self.axon_sections+[self.soma_sections]+self.dendrites
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this approach:</p>
<pre><code>class Neuron(object):

    def __init__(self, **kwargs):
        prop_defaults = {
            "num_axon_segments": 0, 
            "apical_bifibrications": "fancy default",
            ...
        }

        for (prop, default) in prop_defaults.iteritems():
            setattr(self, prop, kwargs.get(prop, default))
</code></pre>
<p>You can then create a <code>Neuron</code> like this:</p>
<pre><code>n = Neuron(apical_bifibrications="special value")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd say there is nothing wrong with this approach - if you need 15 parameters to model something, you need 15 parameters. And if there's no suitable default value, you have to pass in all 15 parameters when creating an object. Otherwise, you could just set the default and change it later via a setter or directly.</p>
<p>Another approach is to create subclasses for certain common kinds of neurons (in your example) and provide good defaults for certain values, or derive the values from other parameters.</p>
<p>Or you could encapsulate parts of the neuron in separate classes and reuse these parts for the actual neurons you model. I.e., you could write separate classes for modeling a synapse, an axon, the soma, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could perhaps use a Python"dict" object ?
<a href="http://docs.python.org/tutorial/datastructures.html#dictionaries">http://docs.python.org/tutorial/datastructures.html#dictionaries</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Having so many parameters suggests that the class is probably doing too many things.</p>
<p>I suggest that you want to divide your class into several classes, each of which take some of your parameters. That way each class is simpler and won't take so many parameters.</p>
<p>Without knowing more about your code, I can't say exactly how you should split it up.</p>
</div>
<div class="post-text" itemprop="text">
<p>Looks like you could cut down the number of arguments by constructing objects such as <code>Axon</code>, <code>Soma</code> and <code>DendriticTree</code> outside of the LayerV constructor, and passing those objects instead.</p>
<p>Some of the parameters are only used in constructing e.g. <code>DendriticTree</code>, others are used in other places as well, so the problem it's not as clear cut, but I would definitely try that approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>could you supply some example code of what you are working on?  It would help to get an idea of what you are doing and get help to you sooner.</p>
<p>If it's just the arguments you are passing to the class that make it long, you don't have to put it all in <code>__init__</code>.  You can set the parameters after you create the class, or pass a dictionary/class full of the parameters as an argument.</p>
<pre><code>class MyClass(object):

    def __init__(self, **kwargs):
        arg1 = None
        arg2 = None
        arg3 = None

        for (key, value) in kwargs.iteritems():
            if hasattr(self, key):
                setattr(self, key, value)

if __name__ == "__main__":

    a_class = MyClass()
    a_class.arg1 = "A string"
    a_class.arg2 = 105
    a_class.arg3 = ["List", 100, 50.4]

    b_class = MyClass(arg1 = "Astring", arg2 = 105, arg3 = ["List", 100, 50.4])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After looking over your code and realizing I have no idea how any of those parameters relate to each other (soley because of my lack of knowledge on the subject of neuroscience) I would point you to a very good book on object oriented design.  Building Skills in Object Oriented Design by Steven F. Lott is an excellent read and I think would help you, and anyone else in laying out object oriented programs.</p>
<p>It is released under the Creative Commons License, so is free for you to use, here is a link of it in PDF format <a href="http://homepage.mac.com/s_lott/books/oodesign/build-python/latex/BuildingSkillsinOODesign.pdf" rel="nofollow">http://homepage.mac.com/s_lott/books/oodesign/build-python/latex/BuildingSkillsinOODesign.pdf</a></p>
<p>I think your problem boils down to the overall design of your classes.  Sometimes, though very rarely, you need a whole lot of arguments to initialize, and most of the responses here have detailed other ways of initialization, but in a lot of cases you can break the class up into more easier to handle and less cumbersome classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is similar to the other solutions that iterate through a default dictionary, but it uses a more compact notation:</p>
<pre><code>class MyClass(object):

    def __init__(self, **kwargs):
        self.__dict__.update(dict(
            arg1=123,
            arg2=345,
            arg3=678,
        ), **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Can you give a more detailed use case ? Maybe a prototype pattern will work:</p>
<p>If there are some similarities in groups of objects, a prototype pattern might help. 
Do you have a lot of cases where one population of neurons is just like another except different in some way ? ( i.e. rather than having a small number of discrete classes,
you have a large number of classes that slightly differ from each other. ) </p>
<p>Python is a classed based language, but just as you can simulate class based 
programming in a prototype based language like Javascript, you can simulate 
prototypes by giving your class a CLONE method, that creates a new object and
populates its ivars from the parent. Write the clone method so that keyword parameters
passed to it override the "inherited"  parameters, so you can call it with something
like: </p>
<pre><code>new_neuron = old_neuron.clone( branching_length=n1, branching_randomness=r2 )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have never had to deal with this situation, or this topic. Your description implies to me that you may find, as you develop the design, that there are a number of additional classes that will become relevant - compartment is the most obvious. If these do emerge as classes in their own right, it is probable that some of your parameters become parameters of these additional classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could create a class for your parameters.</p>
<p>Instead passing a bunch of parameters, you pass one class.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion, in your case the easy solution is to pass higher order objects as parameter. </p>
<p>For example, in your <code>__init__</code> you have a <code>DendriticTree</code> that uses several arguments from your main class <code>LayerV</code>: </p>
<pre><code>main_apical_dendrite = DendriticTree(
    bifibs=apical_bifibs,
    first_sec_L=apical_sec1_L,
    L_sigma=L_sigma,
    L_decrease_factor=ldecf,
    first_sec_d=9, 
    branch_prob=apical_branch_prob
)
</code></pre>
<p>Instead of passing these 6 arguments to your <code>LayerV</code> you would pass the <code>DendriticTree</code> object directly (thus saving 5 arguments).</p>
<p>You probably want to have this values accessible everywhere, therefore you will have to save this <code>DendriticTree</code>: </p>
<pre><code>class LayerV(__Cell):
    def __init__(self, main_apical_dendrite, ...):
        self.main_apical_dendrite = main_apical_dendrite        
</code></pre>
<p>If you want to have a default value too, you can have: </p>
<pre><code>class LayerV(__Cell):
    def __init__(self, main_apical_dendrite=None, ...):
        self.main_apical_dendrite = main_apical_dendrite or DendriticTree()
</code></pre>
<p>This way you delegate what the default <code>DendriticTree</code> should be to the class dedicated to that matter instead of having this logic in the higher order class that <code>LayerV</code>.</p>
<p>Finally, when you need to access the <code>apical_bifibs</code> you used to pass to <code>LayerV</code> you just access it via <code>self.main_apical_dendrite.bifibs</code>.</p>
<p>In general, even if the class you are creating is not a clear composition of several classes, your goal is to find a logical way to split your parameters. Not only to make your code cleaner, but mostly to help people understand what these parameter will be used for. In the extreme cases where you can't split them, I think it's totally ok to have a class with that many parameters. If there is no clear way to split arguments, then you'll probably end up with something even less clear than a list of 15 arguments. </p>
<p>If you feel like creating a class to group parameters together is overkill, then you can simply use <a href="https://docs.python.org/3.7/library/collections.html" rel="nofollow noreferrer"><code>collections.namedtuple</code></a> which can have default values as <a href="https://stackoverflow.com/a/18348004/1720199">shown here</a>. </p>
</div>
<span class="comment-copy">@Chris Walton: Please post your answer as an answer so we can upvote it and comment on it.</span>
<span class="comment-copy">Looking at your code... There's not too much I would change. You could put the parameters into a separate class or dict, that would also simplify providing sets of defaults. Or you could create the axon, soma and main dendrite in the function/method where the the neuron is created, then pass the object in (instead of the parameters). But I think the class is fine as it is. I'd leave it and revisit here when you hit problems.</span>
<span class="comment-copy">Thanks for the advice onitake!</span>
<span class="comment-copy">The <code>for</code> loop can be replaced by the two lines <code>self.__dict__.update(prop_defaults); self.__dict__.update(kwargs)</code>.  Alternatively, you can replace the <code>if</code> statement by <code>setattr(self, prop, kwargs.get(prop, default))</code>.</span>
<span class="comment-copy">@Sven Marnach: Your first proposition is not equivalent: consider a case where <code>kwargs</code> contains non-properties. I like the second approach, though!</span>
<span class="comment-copy">@blubb What happens if the user instantiates with a useless/unrecognized parameter?</span>
<span class="comment-copy">But, what is wrong with the OP's original, old-school implementation? It is more readable than this answer's approach. I would suggest following @onitake 's <a href="http://stackoverflow.com/a/5899352/728675">answer</a></span>
<span class="comment-copy">This is a terrible solution. It means someone using your code has to go into the actual source code to determine what is required/not required. This is a horrible python anti-pattern  Just split the class <b>init</b> method into multiple lines and maintain it that way. Much more user friendly.</span>
<span class="comment-copy">Basically, use a dict as a parameter block. This simplifies code where you need to create a series of objects, with mostly the same parameters.</span>
<span class="comment-copy">Dictionaries don't make IDE code completion easy. So you could set a property with a name 'aba' when you meant 'abb', I personally prefer collections.namedtuple instead. <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">I disagree. Usually many parameters are an indication for poor problem decomposition, but in scientific domains this does not hold in my experience. If you need to model a function with 10 degrees of freedom you have to have 10 parameters, that's just it...</span>
<span class="comment-copy">@Simon Stelling: However.  In some cases, there really aren't 15 degrees of freedom, but two overlapping models, each with 10 degrees of freedom.  The "consider decomposing" doesn't mean "decompose blindly".  It means that the superficial description of 15 attributes may be decomposable based on the application.  There's no way to make the complexity go away.  However, it might be compartmentalized.</span>
<span class="comment-copy">@Simon, that may well be the case. But its at least worth considering if it can be broken down.</span>
<span class="comment-copy"><code>self.__dict__ = kwargs</code> is a bad idea, as you mention. In my answer there's a simple solution to this issue.</span>
<span class="comment-copy">Yeah, we both answered at the same time and I was being hasty.  I fixed that.</span>
<span class="comment-copy">it's a detail, but you'd rather use <code>if hasattr(self, key):</code> than <code>self.__dict__.keys()</code></span>
<span class="comment-copy">Ahh, I knew there was a command for that, I just couldn't remember it off the top of my head.  Thanks.</span>
<span class="comment-copy">26AUG2018: link nolonger works.</span>
<span class="comment-copy">The book can now be found here: <a href="http://www.itmaybeahack.com/homepage/books/oodesign.html#book-oodesign" rel="nofollow noreferrer">itmaybeahack.com/homepage/books/oodesign.html#book-oodesign</a></span>
<span class="comment-copy">It doesn't help if you create only one "parameter class", since then you have just delegated the problem to that new class.</span>
<span class="comment-copy">As Simon points out this just seems to me to add a layer of complication without really reducing complexity.</span>
