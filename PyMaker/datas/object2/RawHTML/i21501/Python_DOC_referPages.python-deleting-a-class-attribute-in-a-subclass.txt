<div class="post-text" itemprop="text">
<p>I have a subclass and I want it to <em>not</em> include a class attribute that's present on the base class.</p>
<p>I tried this, but it doesn't work:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     x = 5
&gt;&gt;&gt; class B(A):
...     del x
Traceback (most recent call last):
  File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt;
    class B(A):
  File "&lt;pyshell#1&gt;", line 2, in B
    del x
NameError: name 'x' is not defined
</code></pre>
<p>How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Think carefully about why you want to do this; you probably don't. Consider not making B inherit from A.</p>
<p>The idea of subclassing is to specialise an object. In particular, children of a class should be valid instances of the parent class:</p>
<pre><code>&gt;&gt;&gt; class foo(dict): pass
&gt;&gt;&gt; isinstance(foo(), dict)
... True
</code></pre>
<p>If you implement this behaviour (with e.g. <code>x = property(lambda: AttributeError)</code>), you are breaking the subclassing concept, and this is Bad.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>delattr(class, field_name)</code> to remove it from the class definition.</p>
<p>Full example:</p>
<pre><code># python 3
class A:  
    def __init__(self):
        self.field_to_keep = "keep this in B"
        self.field_to_delete = "don't want this in B"

class B(A):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        delattr(self, 'field_to_delete')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to delete it. Just override it. </p>
<pre><code>class B(A):
   x = None
</code></pre>
<p>or simply don't reference it.</p>
<p>Or consider a different design (instance attribute?).</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you could set <code>x</code> as <code>property</code> and raise AttributeError whenever someone try to access it.</p>
<pre><code>&gt;&gt;&gt; class C:
        x = 5

&gt;&gt;&gt; class D(C):
        def foo(self):
             raise AttributeError
        x = property(foo)

&gt;&gt;&gt; d = D()
&gt;&gt;&gt; print(d.x)
File "&lt;pyshell#17&gt;", line 3, in foo
raise AttributeError
AttributeError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>None of the answers had worked for me.</p>
<p>For example <code>delattr(SubClass, "attrname")</code> (or its exact equivalent, <code>del SubClass.attrname</code>) won't "hide" a parent method, because this is not how method resolution work. It would fail with <code>AttributeError('attrname',)</code> instead, as the subclass doesn't have <code>attrname</code>. And, of course, replacing attribute with <code>None</code> doesn't actually remove it.</p>
<p>Let's consider this base class:</p>
<pre><code>class Spam(object):
    # Also try with `expect = True` and with a `@property` decorator
    def expect(self):
        return "This is pretty much expected"
</code></pre>
<p>I know only two only ways to subclass it, hiding the <code>expect</code> attribute:</p>
<ol>
<li><p>Using a descriptor class that <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="noreferrer">raises <code>AttributeError</code> from <code>__get__</code></a>. On attribute lookup, there will be an exception, generally indistinguishable from a lookup failure.</p>
<p>The simplest way is just declaring a property that raises <code>AttributeError</code>. This is essentially what @JBernardo had suggested.</p>
<pre><code>class SpanishInquisition(Spam):
    @property
    def expect(self):
        raise AttributeError("Nobody expects the Spanish Inquisition!")

assert hasattr(Spam, "expect") == True
# assert hasattr(SpanishInquisition, "expect") == False  # Fails!
assert hasattr(SpanishInquisition(), "expect") == False
</code></pre>
<p>However, this only works for instances, and not for the classes (the <code>hasattr(SpanishInquisition, "expect") == True</code> assertion would be broken).</p>
<p>If you want all the assertions above to hold true, use this:</p>
<pre><code>class AttributeHider(object):
    def __get__(self, instance, owner):
        raise AttributeError("This is not the attribute you're looking for")

class SpanishInquisition(Spam):
    expect = AttributeHider()

assert hasattr(Spam, "expect") == True
assert hasattr(SpanishInquisition, "expect") == False  # Works!
assert hasattr(SpanishInquisition(), "expect") == False
</code></pre>
<p>I believe this is the most elegant method, as the code is clear, generic and compact. Of course, one should <strong>really</strong> think twice if removing the attribute is what they really want.</p></li>
<li><p>Overriding attribute lookup <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="noreferrer">with <code>__getattribute__</code> magic method</a>. You can do this either in a subclass (or a mixin, like in the example below, as I wanted to write it just once), and that would hide attribute on the subclass <em>instances</em>. If you want to hide the method from the subclass as well, you need to use metaclasses.</p>
<pre><code>class ExpectMethodHider(object):
    def __getattribute__(self, name):
        if name == "expect":
            raise AttributeError("Nobody expects the Spanish Inquisition!")
        return super().__getattribute__(name)

class ExpectMethodHidingMetaclass(ExpectMethodHider, type):
    pass

# I've used Python 3.x here, thus the syntax.
# For Python 2.x use __metaclass__ = ExpectMethodHidingMetaclass
class SpanishInquisition(ExpectMethodHider, Spam,
                         metaclass=ExpectMethodHidingMetaclass):
    pass

assert hasattr(Spam, "expect") == True
assert hasattr(SpanishInquisition, "expect") == False
assert hasattr(SpanishInquisition(), "expect") == False
</code></pre>
<p>This looks worse (more verbose and less generic) than the method above, but one may consider this approach as well.</p>
<p>Note, this does <strong>not</strong> work on special ("magic") methods (e.g. <code>__len__</code>), because those bypass <code>__getproperty__</code>. Check out <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="noreferrer">Special Method Lookup</a> section of the Python documentation for more details. If this is what you need to undo, just override it and call <code>object</code>'s implementation, skipping the parent.</p></li>
</ol>
<p>Needless to say, this only applies to the "new-style classes" (the ones that inherit from <code>object</code>), as magic methods and descriptor protocols aren't supported there. Hopefully, those are a thing of the past.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm had the same problem as well, and I thought I had a valid reason to delete the class attribute in the subclass:  my superclass (call it A) had a read-only property that provided the value of the attribute, but in my subclass (call it B), the attribute was a read/write instance variable.  I found that Python was calling the property function even though I thought the instance variable should have been overriding it.  I could have made a separate getter function to be used to access the underlying property, but that seemed like an unnecessary and inelegant cluttering of the interface namespace (as if that really matters).</p>
<p>As it turns out, the answer was to create a new abstract superclass (call it S) with the original common attributes of A, and have A and B derive from S.  Since Python has duck typing, it does not really matter that B does not extend A, I can still use them in the same places, since they implicitly implement the same interface.</p>
</div>
<div class="post-text" itemprop="text">
<p>Trying to do this is probably a bad idea, but...</p>
<p>It doesn't seem to be do this via "proper" inheritance because of how looking up <code>B.x</code> works by default. When getting <code>B.x</code> the <code>x</code> is first looked up in <code>B</code> and if it's not found there it's searched in <code>A</code>, but on the other hand when setting or deleting <code>B.x</code> only <code>B</code> will be searched. So for example</p>
<pre><code>&gt;&gt;&gt; class A:
&gt;&gt;&gt;     x = 5

&gt;&gt;&gt; class B(A):
&gt;&gt;&gt;    pass

&gt;&gt;&gt; B.x
5

&gt;&gt;&gt; del B.x
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;  
AttributeError: class B has no attribute 'x'

&gt;&gt;&gt; B.x = 6
&gt;&gt;&gt; B.x
6

&gt;&gt;&gt; del B.x
&gt;&gt;&gt; B.x
5
</code></pre>
<p>Here we see that first we doesn't seem to be able to delete <code>B.x</code> since it doesn't exist (<code>A.x</code> exists and is what gets served when you evaluate <code>B.x</code>). However by setting <code>B.x</code> to 6 the <code>B.x</code> will exist, it can be retrieved by <code>B.x</code> and deleted by <code>del B.x</code> by which it ceases to exist so after that again <code>A.x</code> will be served as response to <code>B.x</code>.</p>
<p>What you <strong>could</strong> do on the other hand is to use metaclasses to make <code>B.x</code> raise <code>AttributeError</code>:</p>
<pre><code>class NoX(type):
    @property
    def x(self):
        raise AttributeError("We don't like X")

class A(object):
    x = [42]

class B(A, metaclass=NoX):
    pass

print(A.x)
print(B.x)
</code></pre>
<p>Now of course purists may yell that this breaks the LSP, but it's not that simple. It all boils down to if you consider that you've created a subtype by doing this. The <code>issubclass</code> and <code>isinstance</code> methods says yes, but LSP says no (and many programmers would assume "yes" since you inherit from <code>A</code>).</p>
<p>The LSP means that if <code>B</code> is a subtype of <code>A</code> then we could use <code>B</code> whenever we could use <code>A</code>, but since we can't do this while doing this construct we could conclude that <code>B</code> actually isn't a subtype of <code>A</code> and therefore LSP isn't violated.</p>
</div>
<span class="comment-copy">This breaks <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">LSP</a>. Why do you want to do this?</span>
<span class="comment-copy">The <code>x</code> class variable of <code>B</code> that you want to delete is really stored in <code>A.__dict__</code>, so if you managed to delete it, you would also delete <code>A.x</code>. Therefore, the closest you can come is <i>hiding</i> <code>A.x</code> it by giving <code>B</code> an <code>x</code> class variable too, as @Keith suggests in his answer.</span>
<span class="comment-copy">@JBernardo: There isn't much of a connection between LSP and static typing. LSP is a sound principle because it makes class hierarchies behave in a predictable and coherent manner. This applies equally to statically- and dynamically-typed languages, regardless of whether they provide the means to violate LSP.</span>
<span class="comment-copy">I generally hate non-answers reducing to "Don't do this awesome and interesting thing, because I'm a responsible adult and... &lt;hand-waving&gt;!" This is no exception. While preserving <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">Liskov substitutibility</a> is vital to sane development, every rule was intended to be broken. We're all adults, here. <b>Thanks.</b></span>
<span class="comment-copy">I generally agree with @CecilCurry , because I encountered similar answers to my other questions before, and I hate them. Yet in this particular case I would say deleting a parent attribute is not awesome and interesting in the first place, so a kindly reminder of <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">LSP</a> is not nonsense. I ended up upvoting both this answer and CecilCurry 's comment.</span>
<span class="comment-copy">I find answers pointing out to widely accepted principals of programming very beneficial, because I am learning. I also know every rule has some sort of flexibility so take them as guidelines.</span>
<span class="comment-copy">I'm not subclassing - I'm deleting a setting from a settings class in my test to check correct error handling - so this is exactly what I need!</span>
<span class="comment-copy">It would be helpful to have a fully coded example. Can this be filled out?  I'm not sure where this goes in the code.</span>
<span class="comment-copy">+1 because it answers the question AND suggests design change.</span>
<span class="comment-copy"><b>This doesn't answer the question at all.</b> Setting an attribute to <code>None</code> does <i>not</i> delete that attribute, which should be fairly obvious. Deleting attributes is what <code>del</code> and <code>delattr()</code> do. <a href="https://stackoverflow.com/users/1594534/bhushan">Bhushan</a>'s succinct <a href="https://stackoverflow.com/a/15920132/2809027">response</a> appears to be the only actual answer to this question.</span>
<span class="comment-copy">@CecilCurry the deeper question is why does the OP think he needs to delete it? Anyway, it's a bad design.</span>
<span class="comment-copy">@Keith, perhaps the base class was poorly designed and the user wants to fix it without copying the entire source code.  As an example, Django's AuthenticationForm is supposedly a "base class for authenticating users", but it defines username and password form fields, which makes it useless for non-password authentication.  Deleting those attributes preserves all of the base class' methods for reuse while getting rid of the junk that shouldn't have been in a base class in the first place.</span>
<span class="comment-copy"><code>AttributeError</code> would be more consistent.</span>
<span class="comment-copy">You're right. Edited.</span>
<span class="comment-copy">This is the <i>only</i> actually working solution at the moment. Except, of course, that it "removes" attributes only on subclass <i>instances</i>, and not on the subclasses themselves.</span>
