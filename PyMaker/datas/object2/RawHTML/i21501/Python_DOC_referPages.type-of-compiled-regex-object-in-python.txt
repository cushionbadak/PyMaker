<div class="post-text" itemprop="text">
<p>What is the type of the compiled regular expression in python?</p>
<p>In particular, I want to evaluate</p>
<pre><code>isinstance(re.compile(''), ???)
</code></pre>
<p>to be true, for introspection purposes.</p>
<p>One solution I had was, have some global constant <code>REGEX_TYPE = type(re.compile(''))</code>, but it doesn't seem very elegant.</p>
<p><strong>EDIT:</strong> The reason I want to do this is because I have list of strings and compiled regex objects. I want to "match" a string against list, by</p>
<ul>
<li>for each string in the list, try to check for string equality.</li>
<li>for each regex in the list, try to check whether the string matches the given pattern.</li>
</ul>
<p>and the code that I came up with was:</p>
<pre><code>for allowed in alloweds:
    if isinstance(allowed, basestring) and allowed == input:
        ignored = False
        break
    elif isinstance(allowed, REGEX_TYPE) and allowed.match(input):
        ignored = False
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When the type of something isn't well specified, there's nothing wrong with using the <code>type</code> builtin to discover the answer at runtime:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; retype = type(re.compile('hello, world'))
&gt;&gt;&gt; isinstance(re.compile('goodbye'), retype)
True
&gt;&gt;&gt; isinstance(12, retype)
False
&gt;&gt;&gt; 
</code></pre>
<p>Discovering the type at runtime protects you from having to access private attributes and against future changes to the return type.  There's nothing inelegant about using <code>type</code> here, though there may be something inelegant about wanting to know the type at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.5 introduced the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer"><code>typing</code></a> module. Included therein is <a href="https://docs.python.org/3/library/typing.html#typing.Pattern" rel="nofollow noreferrer"><code>typing.Pattern</code></a>, a <code>_TypeAlias</code>.</p>
<p>Starting with Python 3.6, you can simply do:</p>
<pre><code>from typing import Pattern

my_re = re.compile('foo')
assert isinstance(my_re, Pattern)
</code></pre>
<p>In 3.5, there used to be a <a href="http://bugs.python.org/issue25830" rel="nofollow noreferrer">bug</a> requiring you to do this:</p>
<pre><code>assert issubclass(type(my_re), Pattern)
</code></pre>
<p>Which isn’t guaranteed to work according to the documentation and test suite.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to compare a compiled regular expression with 're._pattern_type'</p>
<pre><code>import re
pattern = r'aa'
compiled_re = re.compile(pattern)
print isinstance(compiled_re, re._pattern_type)

&gt;&gt;True
</code></pre>
<p>Gives True, at least in version 2.7</p>
</div>
<div class="post-text" itemprop="text">
<p><em><strong>Disclaimer:</strong> This isn't intended as a direct answer for your specific needs, but rather something that may be useful as an alternative approach</em></p>
<hr/>
<p>You can keep with the ideals of duck typing, and use <code>hasattr</code> to determine if the object has certain properties that you want to utilize. For example, you could do something like:</p>
<pre><code>if hasattr(possibly_a_re_object, "match"): # Treat it like it's an re object
    possibly_a_re_object.match(thing_to_match_against)
else:
    # alternative handler
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Prevention is better than cure. Don't create such a heterogeneous list in the first place. Have a <strong>set</strong> of allowed strings and a list of compiled regex objects. This should make your checking code look better and run faster:</p>
<pre><code>if input in allowed_strings:
    ignored = False
else:
    for allowed in allowed_regexed_objects:
        if allowed.match(input):
            ignored = False
            break
</code></pre>
<p>If you can't avoid the creation of such a list, see if you have the opportunity to examine it once and build the two replacement objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>As an illustration of polymorphism, an alternate solution is to create wrapper classes which implement a common method.</p>
<pre><code>class Stringish (str):
    def matches (self, input):
        return self == input

class Regexish (re):
    def matches (self, input):
        return self.match(input)
</code></pre>
<p>Now your code can iterate over a list of <code>alloweds</code> containing objects instantiating either of these two classes completely transparently:</p>
<pre><code>for allowed in alloweds:
    if allowed.matches(input):
        ignored = False
        break
</code></pre>
<p>Notice also how some code duplication goes away (though your original code could have been refactored to fix that separately).</p>
</div>
<div class="post-text" itemprop="text">
<p>FYI an example of such code is in BeautifulSoup:  <a href="http://www.crummy.com/software/BeautifulSoup" rel="nofollow">http://www.crummy.com/software/BeautifulSoup</a> and uses the 'hasattr' technique.
In the spirit of the "alternative approach", you might also encapsulate your string search in a regexp by doing this:
    regexp = re.compile(re.escape(your_string))
therefore having a list of only regular expressions.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is another <em>not the answer to the question, but it solves the problem</em> response. Unless your_string contains regular expression special characters,</p>
<pre><code>if re.match(your_string,target_string):
</code></pre>
<p>has the same effect as</p>
<pre><code>if your_string == target_string:
</code></pre>
<p>So drop back one step and use uncompiled regular expression patterns in your list of allowed. This is undoubtedly slower than using compiled regular expressions, but it will work with only the occasional unexpected outcome, and that only if you allow users to supply the allowed items</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; regex = re.compile('foo')
&gt;&gt;&gt; regex
&lt;_sre.SRE_Pattern object at 0x10035d960&gt;
</code></pre>
<p>Well - _sre is a C extension doing the pattern matching...you may look in the _sre C source. </p>
<p>Why do you care?</p>
<p>Or you try something like this (for whatever reason - I don't care):</p>
<pre><code>&gt;&gt;&gt; regex1 = re.compile('bar')
&gt;&gt;&gt; regex2 = re.compile('foo')
&gt;&gt;&gt; type(regex1) == type(regex2)
True
</code></pre>
</div>
<span class="comment-copy">Python is all about duct typing. This is a violation of Python's spirit.</span>
<span class="comment-copy">That may be the best way <b>if</b> you really have to check the type. As far as I remember, there's only <code>re._pattern_type</code> which propably starts with an underscore for a reason.</span>
<span class="comment-copy">ad.match(input) ??? Do you mean allowed.match(input)?</span>
<span class="comment-copy">@ultimatebuster: or perhaps <code>duck taping</code> :)</span>
<span class="comment-copy">I love this about SO: every time I have a question, no matter how specific or obscure, there's a SO answer for it. I might as well just search SO instead of Google.</span>
<span class="comment-copy">Using the type discovered by this approach is not always right - an implementation might use one or more types to support a given feature. Unlikely with regexes, but some factories might return one type now and many types later. But that's just another form of breaking the duck typing support expectations by checking types.</span>
<span class="comment-copy">How is that different from any other type?  Anything you call in Python might return anything else.  That's why <b>there may be something inelegant about wanting to know the type at all</b>.</span>
<span class="comment-copy">@Rosh: this is a pragmatical answer to the point of the OP's question. Jean-Paul did say it's not a good practice in the end, but as a direct answer it's a good one. ++</span>
<span class="comment-copy">This bug appears to be fixed as of 2016-09-27, according to the linked issue.</span>
<span class="comment-copy">I had to use <code>from typing import Pattern</code> in order to access <code>Pattern</code>.</span>
<span class="comment-copy">@Rotareti thanks, <code>typing.re</code> got removed in 3.6 I think</span>
<span class="comment-copy">Also works in python 3.4</span>
<span class="comment-copy">This is the ideal way to handle this, thank you very much!</span>
<span class="comment-copy">Type hinting is now a thing :)</span>
<span class="comment-copy">This probably is most sane answer.</span>
<span class="comment-copy">The for-loop could be simplified to <code>ignored = not any(allowed.match(input) for allowed in allowed_regexed_objects))</code>.</span>
<span class="comment-copy">This answer is constructive, which is good, but it doesn't answer the original question.</span>
<span class="comment-copy">I really really like this answer for some reason. This really highlights how to leverage duck-typing to maintain both pythonicity and abstraction (DRY). (I also had a similar need for a generic text search where the search predicate could either be a list of strings to match or a regex). I may change <code>str</code> to <code>basestring</code> since in Py2, both <code>unicode</code> and <code>str</code> inherit from <code>basestring</code>.</span>
<span class="comment-copy">Unfortunately doesn't work in Py27, <code>re</code> is a classless module that cannot be simply extended with a class inheritance model.</span>
<span class="comment-copy">You can work around that, it doesn't <i>have</i> to inherit from <code>re</code>; the main thing is to have a method by the same name with two different implementations.</span>
<span class="comment-copy">yeah for the <code>Regexish</code>, inherit from <code>object</code>, then just call <code>re</code> in <code>__init__</code> to create an <code>re</code> object by composition (since, as you say, you only need to implement <code>matches</code> or <code>search</code></span>
<span class="comment-copy">The <code>_sre</code> module doesn't have such attribute here.</span>
<span class="comment-copy">" such attribute here"? What nonsense comment is that? Why the down votes...</span>
<span class="comment-copy">@AndreasJung “No such attribute” means that <code>from _sre import SRE_Pattern</code> doesn’t work. The downvotes are probably 1. because of your attitude: “I don’t care” – what? And 2. because you didn’t actually answer the question.</span>
