<div class="post-text" itemprop="text">
<p>I need to send a message of bytes in Python and I need to convert an unsigned integer number to a byte array. How do you convert an integer value to an array of four bytes in Python? Like in C:</p>
<pre><code>uint32_t number=100;
array[0]=(number &gt;&gt;24) &amp; 0xff;
array[1]=(number &gt;&gt;16) &amp; 0xff;
array[2]=(number &gt;&gt;8) &amp; 0xff;
array[3]=number &amp; 0xff;
</code></pre>
<p>Can someone show me how? It is strange to me at first to program without types. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/6187699/how-to-convert-integer-value-to-array-of-four-bytes-in-python/6187741#6187741">Sven</a> has you answer. However, byte shifting numbers (as in your question) is also possible in Python:</p>
<pre><code>&gt;&gt;&gt; [hex(0x12345678 &gt;&gt; i &amp; 0xff) for i in (24,16,8,0)]
['0x12', '0x34', '0x56', '0x78']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at the <code>struct</code> module.  Probably all you need is <code>struct.pack("I", your_int)</code> to pack the integer in a string, and then place this string in the message.  The format string <code>"I"</code> denotes an unsigned 32-bit integer.</p>
<p>If you want to unpack such a string to a tuple of for integers, you can use <code>struct.unpack("4b", s)</code>:</p>
<pre><code>&gt;&gt;&gt; struct.unpack("4b", struct.pack("I", 100))
(100, 0, 0, 0)
</code></pre>
<p>(The example is obviously on a little-endian machine.)</p>
</div>
<div class="post-text" itemprop="text">
<p>This is kind of an old thread, but in Python 3.2+ now you can simply say:</p>
<pre><code>number = 100
number.to_bytes(4, byteorder = 'big')
</code></pre>
<p>or <code>byteorder = 'little'</code> as per your needs. Documentation <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case anyone looks at this question sometime later ...<br/>
This statement should be equivalent to the code in the original question:</p>
<pre><code>&gt;&gt;&gt; tuple( struct.pack("!I", number) )
('\x00', '\x00', '\x00', 'd')
</code></pre>
<p>And I don't think it matters what the host byte order is.<br/>
If your integers are larger than int32, you can use <code>"!Q"</code> in the call to <code>pack()</code> for int64 (if your system supports <code>Q</code>).<br/>
And <code>list()</code> or even <code>bytearray()</code> will work in place of <code>tuple()</code>.</p>
<p>Note, the result is a sequence of <code>str</code> objects (each holding a single byte), not integers.  If you must have a list of integers, you can do this:</p>
<pre><code>[ ord(c) for c in struct.pack("!I", number) ]
[0, 0, 0, 100]
</code></pre>
<p>... or this:</p>
<pre><code>&gt;&gt;&gt; map( ord, tuple( struct.pack("!I", number) ) )
[0, 0, 0, 100]
</code></pre>
<p>But using <code>map()</code> starts making things a bit messy.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can pretty much do the same thing:</p>
<pre><code>&gt;&gt;&gt; number = 100
&gt;&gt;&gt; array[0] = (number&gt;&gt;24) &amp; 0xff
&gt;&gt;&gt; array[1] = (number&gt;&gt;16) &amp; 0xff
&gt;&gt;&gt; array[2] = (number&gt;&gt;8) &amp; 0xff
&gt;&gt;&gt; array[3] = number &amp; 0xff
</code></pre>
<p>or you can do something shorter:</p>
<pre><code>&gt;&gt;&gt; array = [(number&gt;&gt;(8*i))&amp;0xff for i in range(3,-1,-1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It can be done with <code>ctypes</code> as well. It's especially useful for converting floating point numbers to bytes. Example:</p>
<pre><code>&gt;&gt;&gt; bytes(ctypes.c_uint32(0x20))
b' \x00\x00\x00'
&gt;&gt;&gt; bytes(ctypes.c_double(1))
b'\x00\x00\x00\x00\x00\x00\xf0?'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>And for completeness: you can also use the <a href="https://docs.python.org/2.7/library/array.html" rel="nofollow noreferrer"><code>array</code></a> module:</p>
<pre><code>&gt;&gt;&gt; from array import array
&gt;&gt;&gt; a = array('I', [100]) # note that 'I' and such are machine-dependent.
&gt;&gt;&gt; a.tostring()
'\d\x00\x00\x00'
&gt;&gt;&gt; a.byteswap()
&gt;&gt;&gt; a.tostring()
'\x00\x00\x00\d'
</code></pre>
</div>
<span class="comment-copy">Depending on the machine this code runs on, the host byte order is probably not what you want. Use "!I" to serialize an unsigned int to network byteorder.</span>
