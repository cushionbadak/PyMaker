<div class="post-text" itemprop="text">
<p>EDIT: I am running python 2.6</p>
<p>I want to achieve something like this:</p>
<pre><code>def foo():
   try:
       raise IOError('Stuff ')
   except:
       raise

def bar(arg1):
    try:
       foo()
    except Exception as e:
       e.message = e.message + 'happens at %s' % arg1
       raise

bar('arg1')
</code></pre>
<pre class="lang-none prettyprint-override"><code>Traceback...
  IOError('Stuff Happens at arg1')
</code></pre>
<p>But what I get is:</p>
<pre class="lang-none prettyprint-override"><code>Traceback..
  IOError('Stuff')
</code></pre>
<p>Any clues as to how to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd do it like this so changing its type in <code>foo()</code> won't require also changing it in <code>bar()</code>.</p>
<pre><code>def foo():
    try:
        raise IOError('Stuff')
    except:
        raise

def bar(arg1):
    try:
        foo()
    except Exception as e:
        raise type(e)(e.message + ' happens at %s' % arg1)

bar('arg1')
</code></pre>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "test.py", line 13, in &lt;module&gt;
    bar('arg1')
  File "test.py", line 11, in bar
    raise type(e)(e.message + ' happens at %s' % arg1)
IOError: Stuff happens at arg1
</code></pre>
<p><strong>Update 1</strong></p>
<p>Here's a slight modification that preserves the original traceback:</p>
<pre><code>...
def bar(arg1):
    try:
        foo()
    except Exception as e:
        import sys
        raise type(e), type(e)(e.message +
                               ' happens at %s' % arg1), sys.exc_info()[2]

bar('arg1')
</code></pre>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "test.py", line 16, in &lt;module&gt;
    bar('arg1')
  File "test.py", line 11, in bar
    foo()
  File "test.py", line 5, in foo
    raise IOError('Stuff')
IOError: Stuff happens at arg1
</code></pre>
<p><strong>Update 2</strong></p>
<p>For Python 3.x, the code in my first update is syntactically incorrect plus the idea of having a <code>message</code> attribute on <code>BaseException</code> was <a href="http://www.python.org/dev/peps/pep-0352/#retracted-ideas" rel="noreferrer">retracted in a change to PEP 352</a> on 2012-05-16 (my first update was posted on 2012-03-12). So currently, in Python 3.5.2 anyway, you'd need to do something along these lines to preserve the traceback and not hardcode the type of exception in function <code>bar()</code>. Also note that there will be the line:</p>
<pre class="lang-none prettyprint-override"><code>During handling of the above exception, another exception occurred:
</code></pre>
<p>in the traceback messages displayed.</p>
<pre><code># for Python 3.x
...
def bar(arg1):
    try:
        foo()
    except Exception as e:
        import sys
        raise type(e)(str(e) +
                      ' happens at %s' % arg1).with_traceback(sys.exc_info()[2])

bar('arg1')
</code></pre>
<p><strong>Update 3</strong></p>
<p>A commenter asked if there was a way that would work in both Python 2 and 3. Although the answer might seem to be "No" due to the syntax differences, there <em>is</em> a way around that by using a helper function like <a href="http://pythonhosted.org/six/index.html#six.reraise" rel="noreferrer"><code>reraise()</code></a> in the <a href="https://pypi.python.org/pypi/six/" rel="noreferrer"><code>six</code></a> add-on module. So, if you'd rather not use the library for some reason, below is a simplified standalone version.</p>
<p>Note too, that since the exception is reraised within the <code>reraise()</code> function, that will appear in whatever traceback is raised, but the final result is what you want.</p>
<pre><code>import sys

if sys.version_info.major &lt; 3:  # Python 2?
    # Using exec avoids a SyntaxError in Python 3.
    exec("""def reraise(exc_type, exc_value, exc_traceback=None):
                raise exc_type, exc_value, exc_traceback""")
else:
    def reraise(exc_type, exc_value, exc_traceback=None):
        if exc_value is None:
            exc_value = exc_type()
        if exc_value.__traceback__ is not exc_traceback:
            raise exc_value.with_traceback(exc_traceback)
        raise exc_value

def foo():
    try:
        raise IOError('Stuff')
    except:
        raise

def bar(arg1):
    try:
       foo()
    except Exception as e:
        reraise(type(e), type(e)(str(e) +
                                 ' happens at %s' % arg1), sys.exc_info()[2])

bar('arg1')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case you came here searching for a solution for Python3 <a href="https://docs.python.org/3/library/exceptions.html#TypeError" rel="noreferrer">the manual</a>  says:</p>
<blockquote>
<p>When raising a new exception (rather than using a bare <code>raise</code> to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using from with raise:</p>
</blockquote>
<pre><code>raise new_exc from original_exc
</code></pre>
<hr/>
<p>Example:</p>
<pre><code>    try:
        return [permission() for permission in self.permission_classes]
    except TypeError as e:
        raise TypeError("Make sure your view's 'permission_classes' are iterable. "
                        +"If you use '()' to generate a set with a single element "
                        +"make sure that there is a comma behind the one (element,).") from e
</code></pre>
<p>Which looks like this in the end:</p>
<pre><code>    2017-09-06 16:50:14,797 [ERROR] django.request: Internal Server Error: /v1/sendEmail/
    Traceback (most recent call last):
    File "venv/lib/python3.4/site-packages/rest_framework/views.py", line 275, in get_permissions
        return [permission() for permission in self.permission_classes]
    TypeError: 'type' object is not iterable 

    The above exception was the direct cause of the following exception:

    Traceback (most recent call last):
        # Traceback removed...
    TypeError: Make sure your view's Permission_classes are iterable. If 
         you use parens () to generate a set with a single element make 
         sure that there is a (comma,) behind the one element.
</code></pre>
<p>Turning a totally nondescript TypeError into a nice message with hints towards a solution without messing up the original Exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you don't want to or can't modify foo(), you can do this:</p>
<p></p>
<pre><code>try:
    raise IOError('stuff')
except Exception as e:
    if len(e.args) &gt;= 1:
        e.args = (e.args[0] + ' happens',) + e.args[1:]
    raise
</code></pre>
<p>This is indeed the only solution here that solves the problem in Python 3 without an ugly and confusing "During handling of the above exception, another exception occurred" message.</p>
<p>In case the re-raising line should be added to the stack trace, writing <code>raise e</code> instead of <code>raise</code> will do the trick.</p>
</div>
<div class="post-text" itemprop="text">
<p>One handy approach that I used is to use class attribute as storage for details,
as class attribute is accessible both from class object and class instance: </p>
<pre><code>class CustomError(Exception):
    details = None
</code></pre>
<p>Then in your code:</p>
<pre><code>exc = CustomError('Some message')
exc.details('Details -- add whatever you want')
raise exc
</code></pre>
<p>And when catching an error:</p>
<pre><code>except CustomError, e:
    # Do whatever you want with the exception instance
    print e
    print e.details
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unlike previous answers, this works in the face of exceptions with really bad <code>__str__</code>.
It <em>does</em> modify the type however, in order to factor out unhelpful <code>__str__</code> implementations.</p>
<p>I'd still like to find an additional improvement that doesn't modify the type.</p>
<pre><code>from contextlib import contextmanager
@contextmanager
def helpful_info():
    try:
        yield
    except Exception as e:
        class CloneException(Exception): pass
        CloneException.__name__ = type(e).__name__
        CloneException.__module___ = type(e).__module__
        helpful_message = '%s\n\nhelpful info!' % e
        import sys
        raise CloneException, helpful_message, sys.exc_traceback


class BadException(Exception):
    def __str__(self):
        return 'wat.'

with helpful_info():
    raise BadException('fooooo')
</code></pre>
<p>The original traceback and type (name) are preserved.</p>
<pre><code>Traceback (most recent call last):
  File "re_raise.py", line 20, in &lt;module&gt;
    raise BadException('fooooo')
  File "/usr/lib64/python2.6/contextlib.py", line 34, in __exit__
    self.gen.throw(type, value, traceback)
  File "re_raise.py", line 5, in helpful_info
    yield
  File "re_raise.py", line 20, in &lt;module&gt;
    raise BadException('fooooo')
__main__.BadException: wat.

helpful info!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I will provide a snippet of code that I use often whenever I want to add extra info to an exception.  I works both in Python 2.7 and 3.6.  </p>
<pre><code>import sys
import traceback

try:
    a = 1
    b = 1j

    # The line below raises an exception because
    # we cannot compare int to complex.
    m = max(a, b)  

except Exception as ex:
    # I create my  informational message for debugging:
    msg = "a=%r, b=%r" % (a, b)

    # Gather the information from the original exception:
    exc_type, exc_value, exc_traceback = sys.exc_info()

    # Format the original exception for a nice printout:
    traceback_string = ''.join(traceback.format_exception(
        exc_type, exc_value, exc_traceback))

    # Re-raise a new exception of the same class as the original one, 
    # using my custom message and the original traceback:
    raise type(ex)("%s\n\nORIGINAL TRACEBACK:\n\n%s\n" % (msg, traceback_string))
</code></pre>
<p>The code above results in the following output: </p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-6-09b74752c60d&gt; in &lt;module&gt;()
     14     raise type(ex)(
     15         "%s\n\nORIGINAL TRACEBACK:\n\n%s\n" %
---&gt; 16         (msg, traceback_string))

TypeError: a=1, b=1j

ORIGINAL TRACEBACK:

Traceback (most recent call last):
  File "&lt;ipython-input-6-09b74752c60d&gt;", line 7, in &lt;module&gt;
    m = max(a, b)  # Cannot compare int to complex
TypeError: no ordering relation is defined for complex numbers
</code></pre>
<p><br/> </p>
<p>I know this deviates a little from the example provided in the question, but nevertheless I hope someone finds it useful. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can define your own exception that inherits from another and create it's own constructor to set value.</p>
<p>For example:</p>
<pre><code>class MyError(Exception):
   def __init__(self, value):
     self.value = value
     Exception.__init__(self)

   def __str__(self):
     return repr(self.value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe</p>
<pre><code>except Exception as e:
    raise IOError(e.message + 'happens at %s'%arg1)
</code></pre>
</div>
<span class="comment-copy">The real question is <i>why</i>?</span>
<span class="comment-copy">While looking for documentation for the Exception <code>message</code> attribute I found this SO question, <a href="http://stackoverflow.com/questions/1272138/baseexception-message-deprecated-in-python-2-6">BaseException.message deprecated in Python 2.6</a>, which seems to indicate its use is now discouraged (and why it's not in the docs).</span>
<span class="comment-copy">sadly, that link doesn't seem to work anymore.</span>
<span class="comment-copy">@MichaelScottCuthbert here's a good alternative: <a href="http://www.itmaybeahack.com/book/python-2.6/html/p02/p02c07_exceptions.html" rel="nofollow noreferrer">itmaybeahack.com/book/python-2.6/html/p02/…</a></span>
<span class="comment-copy">Here's a really good <a href="http://www.itmaybeahack.com/book/python-2.6/html/p02/p02c07_exceptions.html" rel="nofollow noreferrer">explanation</a> of what the status of the message attribute is and its relationship to the args attribute and <a href="http://legacy.python.org/dev/peps/pep-0352/" rel="nofollow noreferrer">PEP 352</a>. It's from the free book <i>Building Skills in Python</i> by Steven F. Lott.</span>
<span class="comment-copy">That loses the backtrace, kind of defeating the point of adding information to an existing exception. Also, it doesn't work exceptions with ctor that takes &gt;1 arguments (the type is something you cannot control from the place where you catch the exception).</span>
<span class="comment-copy">@Václav: It's fairly easy to prevent losing the backtrace -- as shown in the update I added. While this still doesn't handle every conceivable exception, it does work for cases similar to what was shown in the OP's question.</span>
<span class="comment-copy">This isn't <i>quite</i> right. If type(e) overrides <code>__str__</code>, you may get undesirable results. Also note that the second argument is passed to the constructor given by the first argument, which yields a somewhat nonsensical <code>type(e)(type(e)(e.message)</code>. Thirdly, <a href="http://www.python.org/dev/peps/pep-0352/#retracted-ideas" rel="nofollow noreferrer">e.message is deprecated</a> in favor of e.args[0].</span>
<span class="comment-copy">so, there isn't a portable way that works in both Python 2 and 3?</span>
<span class="comment-copy">@joshsvoss: Just to make it lazily imported (delayed until actually needed) -- ideally exceptions are cases not conforming to the general rule -- however moving it to the top of the function or module would be fine, too.</span>
<span class="comment-copy">This is the best solution, since the resulting exception points back to the original cause, supply more detail.</span>
<span class="comment-copy">but in this case if the exception changes in foo, I have to change bar as well right.?</span>
<span class="comment-copy">If you catch Exception (edited above), you can catch any standard library exception (as well as those that inherit from Exception and call Exception.__init__).</span>
<span class="comment-copy">to be more complete/cooperative, include the other parts of the original tuple: <code>e.args = ('mynewstr' + e.args[0],) + e.args[1:]</code></span>
<span class="comment-copy">@nmz787 This is the <i>best</i> solution for Python 3 in fact. What exactly is your error?</span>
<span class="comment-copy">@Dubslow and martineau I incorporated your suggestions into an edit.</span>
<span class="comment-copy">Not really useful since the OP is requesting that the details be printed as part of the stack trace when the original exception is thrown and not caught.</span>
<span class="comment-copy">Doesn't address need to change/append something to the <code>message</code> of the original exception (but could be fixed, I think).</span>
