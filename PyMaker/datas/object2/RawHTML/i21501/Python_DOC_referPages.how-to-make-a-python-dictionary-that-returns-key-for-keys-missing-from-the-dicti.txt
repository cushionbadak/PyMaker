<div class="post-text" itemprop="text">
<p>I want to create a python dictionary that returns me the key value for the keys are missing from the dictionary.</p>
<p>Usage example:</p>
<pre><code>dic = smart_dict()
dic['a'] = 'one a'
print(dic['a'])
# &gt;&gt;&gt; one a
print(dic['b'])
# &gt;&gt;&gt; b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dict</code>s have a <a href="http://docs.python.org/library/stdtypes.html#dict"><code>__missing__</code></a> hook for this:</p>
<pre><code>class smart_dict(dict):
    def __missing__(self, key):
        return key
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you just use</p>
<pre><code>dic.get('b', 'b')
</code></pre>
<p>Sure, you can subclass <code>dict</code> as others point out, but I find it handy to remind myself every once in a while that <code>get</code> can have a default value!</p>
<p>If you want to have a go at the <code>defaultdict</code>, try this:</p>
<pre><code>dic = defaultdict()
dic.__missing__ = lambda key: key
dic['b'] # should set dic['b'] to 'b' and return 'b'
</code></pre>
<p>except... well: <code>AttributeError: ^collections.defaultdict^object attribute '__missing__' is read-only</code>, so you will have to subclass:</p>
<pre><code>from collections import defaultdict
class KeyDict(defaultdict):
    def __missing__(self, key):
        return key

d = KeyDict()
print d['b'] #prints 'b'
print d.keys() #prints []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first respondent mentioned <code>defaultdict</code>,
but you can define <code>__missing__</code> for any subclass of <code>dict</code>:</p>
<pre><code>&gt;&gt;&gt; class Dict(dict):
        def __missing__(self, key):
            return key


&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d['a']
1
&gt;&gt;&gt; d['z']
'z'
</code></pre>
<p>Also, I like the second respondent's approach:</p>
<pre><code>&gt;&gt;&gt; d = dict(a=1, b=2)
&gt;&gt;&gt; d.get('z', 'z')
'z'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Congratulations.</strong> You too have discovered the uselessness of the
standard <code>collections.defaultdict</code> type. If that execrable midden heap of <a href="https://en.wikipedia.org/wiki/Code_smell" rel="noreferrer">code smell</a>
offends your delicate sensibilities as much as it did mine, this is your lucky
StackOverflow day.</p>
<p>Thanks to the forbidden wonder of the <a href="https://docs.python.org/3/library/functions.html#type" rel="noreferrer">3-parameter
variant</a> of the <code>type()</code>
builtin, crafting a non-useless default dictionary type is both fun and profitable.</p>
<h2>What's Wrong with dict.__missing__()?</h2>
<p>Absolutely nothing, assuming you like excess boilerplate and the shocking silliness of <code>collections.defaultdict</code> â€“ which <em>should</em> behave as expected but really doesn't. To be fair, <a href="https://stackoverflow.com/users/95612/jochen-ritzel">Jochen
Ritzel</a>'s <a href="https://stackoverflow.com/a/6229253/2809027">accepted
solution</a> of subclassing <code>dict</code> and
implementing the <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="noreferrer">optional <code>__missing__()</code>
method</a> <em>is</em> a fantastic
workaround for small-scale use cases only requiring a single default dictionary.</p>
<p>But boilerplate of this sort scales poorly. If you find yourself instantiating
multiple default dictionaries, each with their own slightly different logic for
generating missing key-value pairs, an industrial-strength alternative
automating boilerplate is warranted.</p>
<p>Or at least nice. Because why not fix what's broken?</p>
<h2>Introducing DefaultDict</h2>
<p>In less than ten lines of pure Python (excluding docstrings, comments, and
whitespace), we now define a <code>DefaultDict</code> type initialized with a user-defined
callable generating default values for missing keys. Whereas the callable passed
to the standard <code>collections.defaultdict</code> type uselessly accepts <em>no</em>
parameters, the callable passed to our <code>DefaultDict</code> type usefully accepts the
following two parameters:</p>
<ol>
<li>The current instance of this dictionary.</li>
<li>The current missing key to generate a default value for.</li>
</ol>
<p>Given this type, solving <a href="https://stackoverflow.com/users/99834/sorin">sorin</a>'s
question reduces to a single line of Python:</p>
<pre><code>&gt;&gt;&gt; dic = DefaultDict(lambda self, missing_key: missing_key)
&gt;&gt;&gt; dic['a'] = 'one a'
&gt;&gt;&gt; print(dic['a'])
one a
&gt;&gt;&gt; print(dic['b'])
b
</code></pre>
<p>Sanity. <em>At last.</em></p>
<h2>Code or It Didn't Happen</h2>
<pre><code>def DefaultDict(keygen):
    '''
    Sane **default dictionary** (i.e., dictionary implicitly mapping a missing
    key to the value returned by a caller-defined callable passed both this
    dictionary and that key).

    The standard :class:`collections.defaultdict` class is sadly insane,
    requiring the caller-defined callable accept *no* arguments. This
    non-standard alternative requires this callable accept two arguments:

    #. The current instance of this dictionary.
    #. The current missing key to generate a default value for.

    Parameters
    ----------
    keygen : CallableTypes
        Callable (e.g., function, lambda, method) called to generate the default
        value for a "missing" (i.e., undefined) key on the first attempt to
        access that key, passed first this dictionary and then this key and
        returning this value. This callable should have a signature resembling:
        ``def keygen(self: DefaultDict, missing_key: object) -&gt; object``.
        Equivalently, this callable should have the exact same signature as that
        of the optional :meth:`dict.__missing__` method.

    Returns
    ----------
    MappingType
        Empty default dictionary creating missing keys via this callable.
    '''

    # Global variable modified below.
    global _DEFAULT_DICT_ID

    # Unique classname suffixed by this identifier.
    default_dict_class_name = 'DefaultDict' + str(_DEFAULT_DICT_ID)

    # Increment this identifier to preserve uniqueness.
    _DEFAULT_DICT_ID += 1

    # Dynamically generated default dictionary class specific to this callable.
    default_dict_class = type(
        default_dict_class_name, (dict,), {'__missing__': keygen,})

    # Instantiate and return the first and only instance of this class.
    return default_dict_class()


_DEFAULT_DICT_ID = 0
'''
Unique arbitrary identifier with which to uniquify the classname of the next
:func:`DefaultDict`-derived type.
'''
</code></pre>
<p>The key <sup><em>...get it, <strong>key</strong>?</em></sup> to this arcane wizardry is the call to
the <a href="https://docs.python.org/3/library/functions.html#type" rel="noreferrer">3-parameter variant</a>
of the <code>type()</code> builtin:</p>
<pre><code>type(default_dict_class_name, (dict,), {'__missing__': keygen,})
</code></pre>
<p>This single line dynamically generates a new <code>dict</code> subclass aliasing the
optional <code>__missing__</code> method to the caller-defined callable. Note the distinct
lack of boilerplate, reducing <code>DefaultDict</code> usage to a single line of Python.</p>
<p>Automation for the egregious win.</p>
</div>
<div class="post-text" itemprop="text">
<p>I agree this should be easy to do, and also easy to set up with different defaults or functions that transform a missing value somehow.</p>
<p>Inspired by <a href="https://stackoverflow.com/users/2809027/cecil-curry">Cecil Curry</a>'s <a href="https://stackoverflow.com/a/44126972/2965879">answer</a>, I asked myself: why not have the default-generator (either a constant or a callable) as a member of the class, instead of generating different classes all the time? Let me demonstrate:</p>
<pre><code># default behaviour: return missing keys unchanged
dic = FlexDict()
dic['a'] = 'one a'
print(dic['a'])
# 'one a'
print(dic['b'])
# 'b'

# regardless of default: easy initialisation with existing dictionary
existing_dic = {'a' : 'one a'}
dic = FlexDict(existing_dic)
print(dic['a'])
# 'one a'
print(dic['b'])
# 'b'

# using constant as default for missing values
dic = FlexDict(existing_dic, default = 10)
print(dic['a'])
# 'one a'
print(dic['b'])
# 10

# use callable as default for missing values
dic = FlexDict(existing_dic, default = lambda missing_key: missing_key * 2)
print(dic['a'])
# 'one a'
print(dic['b'])
# 'bb'
print(dic[2])
# 4
</code></pre>
<p>How does it work? Not so difficult:</p>
<pre><code>class FlexDict(dict):
    '''Subclass of dictionary which returns a default for missing keys.
    This default can either be a constant, or a callable accepting the missing key.
    If "default" is not given (or None), each missing key will be returned unchanged.'''
    def __init__(self, content = None, default = None):
        if content is None:
            super().__init__()
        else:
            super().__init__(content)
        if default is None:
            default = lambda missing_key: missing_key
        self.default = default # sets self._default

    @property
    def default(self):
        return self._default

    @default.setter
    def default(self, val):
        if callable(val):
            self._default = val
        else: # constant value
            self._default = lambda missing_key: val

    def __missing__(self, x):
        return self.default(x)
</code></pre>
<p>Of course, one can debate whether one wants to allow changing the default-function after initialisation, but that just means removing <code>@default.setter</code> and absorbing its logic into <code>__init__</code>.</p>
<p>Enabling introspection into the current (constant) default value could be added with two extra lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>Subclass <code>dict</code>'s <code>__getitem__</code> method.  For example, <a href="https://stackoverflow.com/questions/2390827/how-to-properly-subclass-dict-and-override-get-set">How to properly subclass dict and override __getitem__ &amp; __setitem__</a></p>
</div>
<span class="comment-copy">I was expecting to be able to get this behavior with <code>collections.defautldict()</code> but for some reason I'm missing something about how it works.</span>
<span class="comment-copy">There's a number of ways to do this. One possibly important distinction / consideration is whether or not they also add the missing key to the underlying dictionary.</span>
<span class="comment-copy">Furthermore the docs say "defaultdict objects support [<code>__missing__</code>] in addition to the standard dict operations" which is just wrong.</span>
<span class="comment-copy">Why is that wrong?  I'd guess <b>missing</b> is the primary method by which defaultdict works</span>
<span class="comment-copy">Why subclass <code>defaultdict</code> vs subclassing <code>dict</code>?</span>
<span class="comment-copy">Cool, didn't know the 3-parameter variant! I agree with your sentiment (so <code>defaultdict</code> needs a PEP?), however I guess most people would just need a "sane" <code>defaultdict</code> without the industrial strength class generation. Actually, why create many classes at all? Why not have the default (callable) as a member of the class? This inspired me to write <a href="https://stackoverflow.com/a/47790669/2965879">stackoverflow.com/a/47790669/2965879</a>.</span>
