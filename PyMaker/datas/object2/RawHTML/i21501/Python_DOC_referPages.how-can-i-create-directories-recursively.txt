<div class="post-text" itemprop="text">
<p>Is there a Python method to create directories recursively? I have this path:</p>
<pre><code>/home/dail/
</code></pre>
<p>I would like to create</p>
<pre><code>/home/dail/first/second/third
</code></pre>
<p>Can I do it recursively or I have to create one directory after the other?</p>
<p>The same thing for:</p>
<p><strong>chmod</strong> and <strong>chown</strong> can I do it recursively without assign permissions for each file/dir?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/os.html#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a> is what you need. For <code>chmod</code> or <code>chown</code> you'll have to use <code>os.walk</code> and use it on every file/dir yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>a fresh answer to a very old question:</p>
<p>starting from python 3.2 you can do this:</p>
<pre><code>import os
path = '/home/dail/first/second/third'
os.makedirs(path, exist_ok=True)
</code></pre>
<p>thanks to the <a href="https://docs.python.org/3/library/os.html#os.makedirs" rel="noreferrer"><code>exist_ok</code> flag</a> this will not even complain if the directory exists (depending on your needs....).</p>
<hr/>
<p>starting from python 3.4 (which includes the <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer">pathlib module</a>) you can do this:</p>
<pre><code>from pathlib import Path
path = Path('/home/dail/first/second/third')
path.mkdir(parents=True)
</code></pre>
<hr/>
<p>starting from python 3.5 <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer"><code>mkdir</code> also has an <code>exist_ok</code> flag</a> - setting it to <code>True</code> will raise no exception if the directory exists:</p>
<pre><code>path.mkdir(parents=True, exist_ok=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my implementation for your reference:</p>
<pre><code>def _mkdir_recursive(self, path):
    sub_path = os.path.dirname(path)
    if not os.path.exists(sub_path):
        self._mkdir_recursive(sub_path)
    if not os.path.exists(path):
        os.mkdir(path)
</code></pre>
<p>Hope this help!</p>
</div>
<div class="post-text" itemprop="text">
<p>I agree with <a href="https://stackoverflow.com/a/6004084/119775">Cat Plus Plus</a>'s answer.  However, if you know this will only be used on Unix-like OSes, you can use external calls to the shell commands <code>mkdir</code>, <code>chmod</code>, and <code>chown</code>. Make sure to pass extra flags to recursively affect directories:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; subprocess.check_output(['mkdir', '-p', 'first/second/third']) 
# Equivalent to running 'mkdir -p first/second/third' in a shell (which creates
# parent directories if they do not yet exist).

&gt;&gt;&gt; subprocess.check_output(['chown', '-R', 'dail:users', 'first'])
# Recursively change owner to 'dail' and group to 'users' for 'first' and all of
# its subdirectories.

&gt;&gt;&gt; subprocess.check_output(['chmod', '-R', 'g+w', 'first'])
# Add group write permissions to 'first' and all of its subdirectories.
</code></pre>
<p><strong>EDIT</strong> I originally used <code>commands</code>, which was a bad choice since it is deprecated and vulnerable to injection attacks. (For example, if a user gave input to create a directory called <code>first/;rm -rf --no-preserve-root /;</code>, one could potentially delete all directories).</p>
<p><strong>EDIT 2</strong> If you are using Python less than 2.7, use <code>check_call</code> instead of <code>check_output</code>. See the <a href="http://docs.python.org/library/subprocess.html#convenience-functions" rel="nofollow noreferrer"><code>subprocess</code> documentation</a> for details.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using <a href="https://docs.python.org/2/library/os.html#os.makedirs" rel="nofollow noreferrer">os.makedirs</a>:</p>
<pre><code>import os
import errno

try:
    os.makedirs(&lt;path&gt;)
except OSError as e:
    if errno.EEXIST != e.errno:
        raise
</code></pre>
</div>
<span class="comment-copy">superset: also check if exists: <a href="http://stackoverflow.com/questions/600268/mkdir-p-functionality-in-python" title="mkdir p functionality in python">stackoverflow.com/questions/600268/â€¦</a></span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/4753338/python-creating-folder-tree-dynamically-from-a-string">Python creating folder tree dynamically from a string</a></span>
<span class="comment-copy">Specifically: os.makedirs(os.path.join("/home/dail", "first", "second", "third"))</span>
<span class="comment-copy">note, <code>exist_ok=True</code> is convenient to save having to check if it exists first every time.</span>
<span class="comment-copy">Note that the <code>exist_ok</code> parameter was only added in Python 3.2</span>
<span class="comment-copy">Wow, very nice description and multiple options taking care of multiple python versions. Thanks you very much !</span>
<span class="comment-copy">If the first folder doesn't exist this function will result in stack overflow (<code>if not os.path.exists(sub_path)</code> will always be true and call itself). But as long as the first dir exist this seems to be working.</span>
<span class="comment-copy">There is one issue, the <code>commands</code> module from the docs: Deprecated since version 2.6: The commands module has been removed in Python 3.0. Use the subprocess module instead.</span>
<span class="comment-copy">@A A: Thanks.  Been using python2.6 still, didn't notice.  Will edit shortly.</span>
<span class="comment-copy">But that's not Python, it's a shell script! If you can write a solution in Python that's pretty simple, and even portable, do it that way. ;)</span>
<span class="comment-copy">@Rosh: I agree 100% that its python calling the *nix shell commands and isn't portable (and said so).  But I often find myself writing quick python scripts that I'll only use on my own linux boxes.  Calling shell commands may be simpler for those purposes, when you can accomplish what you want with a flag (e.g., -R rather than a <code>walk</code> double-for loop--(second loop for files in each <code>walk</code>ed dir)).  Sure I could have written them in bash, but I feel python's syntax is convenient (easily defining functions/classes) and having access to all the command line flags is convenient for me.</span>
<span class="comment-copy">forking is always a bad idea if it can be done inline.</span>
<span class="comment-copy">Welcome to Stack Overflow! Thank you for this code snippet, which may provide some immediate help.  A proper explanation <a href="//meta.stackexchange.com/q/114762">would greatly improve</a> its educational value by showing <i>why</i> this is a good solution to the problem, and would make it more useful to future readers with similar, but not identical, questions.  Please <a href="https://stackoverflow.com/posts/44305026/edit">edit</a> your answer to add explanation, and give an indication of what limitations and assumptions apply.</span>
<span class="comment-copy">I would say this answer is the correct one for Python 2.x, since it handles errors correctly and doesn't asks for file system for path twice (as with <code>os.path.exists</code> approach).</span>
