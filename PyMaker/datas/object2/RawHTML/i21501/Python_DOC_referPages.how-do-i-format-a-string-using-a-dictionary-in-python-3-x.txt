<div class="post-text" itemprop="text">
<p>I am a big fan of using dictionaries to format strings. It helps me read the string format I am using as well as let me take advantage of existing dictionaries. For example:</p>
<pre><code>class MyClass:
    def __init__(self):
        self.title = 'Title'

a = MyClass()
print 'The title is %(title)s' % a.__dict__

path = '/path/to/a/file'
print 'You put your file here: %(path)s' % locals()
</code></pre>
<p>However I cannot figure out the python 3.x syntax for doing the same (or if that is even possible). I would like to do the following</p>
<pre><code># Fails, KeyError 'latitude'
geopoint = {'latitude':41.123,'longitude':71.091}
print '{latitude} {longitude}'.format(geopoint)

# Succeeds
print '{latitude} {longitude}'.format(latitude=41.123,longitude=71.091)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this good for you?</p>
<pre><code>geopoint = {'latitude':41.123,'longitude':71.091}
print('{latitude} {longitude}'.format(**geopoint))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To unpack a dictionary into keyword arguments, use <code>**</code>. Also,, new-style formatting supports referring to attributes of objects and items of mappings:</p>
<pre><code>'{0[latitude]} {0[longitude]}'.format(geopoint)
'The title is {0.title}s'.format(a) # the a from your first example
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As Python 3.0 and 3.1 are EOL'ed and no one uses them, you can and should use <a href="https://docs.python.org/3/library/stdtypes.html#str.format_map" rel="noreferrer"><code>str.format_map(mapping)</code></a> (Python 3.2+):</p>
<blockquote>
<p>Similar to <code>str.format(**mapping)</code>, <strong>except that mapping is used directly and not copied to a <code>dict</code></strong>. This is useful if for example mapping is a <code>dict</code> subclass.</p>
</blockquote>
<p>What this means is that you can use for example a <code>defaultdict</code> that would set (and return) a default value for keys that are missing:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; vals = defaultdict(lambda: '&lt;unset&gt;', {'bar': 'baz'})
&gt;&gt;&gt; 'foo is {foo} and bar is {bar}'.format_map(vals)
'foo is &lt;unset&gt; and bar is baz'
</code></pre>
<p>Even if the mapping provided is a <code>dict</code>, not a subclass, this would probably still be slightly faster.</p>
<p>The difference is not big though, given</p>
<pre><code>&gt;&gt;&gt; d = dict(foo='x', bar='y', baz='z')
</code></pre>
<p>then </p>
<pre><code>&gt;&gt;&gt; 'foo is {foo}, bar is {bar} and baz is {baz}'.format_map(d)
</code></pre>
<p>is about 10 ns (2 %) faster than</p>
<pre><code>&gt;&gt;&gt; 'foo is {foo}, bar is {bar} and baz is {baz}'.format(**d)
</code></pre>
<p>on my Python 3.4.3. The difference would probably be larger as more keys are in the dictionary, and </p>
<hr/>
<p>Note that the format language is much more flexible than that though; they can contain indexed expressions, attribute accesses and so on, so you <em>can</em> format a whole object, or 2 of them:</p>
<pre><code>&gt;&gt;&gt; p1 = {'latitude':41.123,'longitude':71.091}
&gt;&gt;&gt; p2 = {'latitude':56.456,'longitude':23.456}
&gt;&gt;&gt; '{0[latitude]} {0[longitude]} - {1[latitude]} {1[longitude]}'.format(p1, p2)
'41.123 71.091 - 56.456 23.456'
</code></pre>
<hr/>
<p>Starting from 3.6 you can use the interpolated strings too:</p>
<pre><code>&gt;&gt;&gt; f'lat:{p1["latitude"]} lng:{p1["longitude"]}'
'lat:41.123 lng:71.091'
</code></pre>
<p>You just need to remember to use the <em>other</em> quote characters within the nested quotes. Another upside of this approach is that it is much faster than <a href="https://stackoverflow.com/a/38362140/918959">calling a formatting method.</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>print("{latitude} {longitude}".format(**geopoint))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the question is specific to Python 3, here's using <a href="https://www.python.org/dev/peps/pep-0498/" rel="noreferrer">the new f-string syntax</a>:</p>
<pre><code>&gt;&gt;&gt; geopoint = {'latitude':41.123,'longitude':71.091}
&gt;&gt;&gt; print(f'{geopoint["latitude"]} {geopoint["longitude"]}')
41.123 71.091
</code></pre>
<p>Note the outer single quotes and inner double quotes (you could also do it the other way around).</p>
</div>
<div class="post-text" itemprop="text">
<p>The Python 2 syntax works in Python 3 as well:</p>
<pre><code>&gt;&gt;&gt; class MyClass:
...     def __init__(self):
...         self.title = 'Title'
... 
&gt;&gt;&gt; a = MyClass()
&gt;&gt;&gt; print('The title is %(title)s' % a.__dict__)
The title is Title
&gt;&gt;&gt; 
&gt;&gt;&gt; path = '/path/to/a/file'
&gt;&gt;&gt; print('You put your file here: %(path)s' % locals())
You put your file here: /path/to/a/file
</code></pre>
</div>
<span class="comment-copy">This works in Python 2.6 as well.</span>
<span class="comment-copy">Tried this and it worked. But I don't understand the use of the 'pointer notation'. I know Python doesn't use pointers, is this an example of kwargs?</span>
<span class="comment-copy">@HomunculusReticulli That is a format parameter (Minimum field width), not a pointer to a pointer C++ style. <a href="http://docs.python.org/release/2.4.4/lib/typesseq-strings.html" rel="nofollow noreferrer">docs.python.org/release/2.4.4/lib/typesseq-strings.html</a></span>
<span class="comment-copy">Python 3.2 introduced <a href="https://docs.python.org/3.4/library/stdtypes.html#str.format_map" rel="nofollow noreferrer"><code>format_map</code></a>. <i>Similar to <code>str.format(**mapping)</code>, except that <code>mapping</code> is used directly and not copied to a <code>dict</code>. This is useful if for example <code>mapping</code> is a dict subclass</i></span>
<span class="comment-copy">@NityeshAgarwal it spreads the dictionary with the name=value pairs as individual arguments i.e. <code>print(**geopoint)</code> is same as <code>print(longitude=71.091, latitude=41.123)</code>. In many languages, it is known as <i>splat operator</i>. In JavaScript, it's called <i>spread operator</i>. In python, there is no particular name given to this operator.</span>
<span class="comment-copy">I find this answer better, as adding the positional index for the placeholder makes the code more explicit, and easier to use. Especially if one has something like this: <code>'{0[latitude]} {1[latitude]} {0[longitude]} {1[longitude]}'.format(geopoint0, geopoint1)</code></span>
<span class="comment-copy">This is useful if you're using a <code>defaultdict</code> and don't have all the keys</span>
<span class="comment-copy">Nice one, Is there any performance improvements over <code>format</code>? (Given that it is not copied to a dict)</span>
<span class="comment-copy">@BhargavRao not much, 2 % :D</span>
<span class="comment-copy">I would say that use of the f-string is more aligned to python3 approach.</span>
