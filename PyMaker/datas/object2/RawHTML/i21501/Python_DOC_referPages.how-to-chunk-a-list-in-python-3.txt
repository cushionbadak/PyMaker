<div class="post-text" itemprop="text">
<p>I found the following code that is compatible with python2</p>
<pre><code>from itertools import izip_longest
def grouper(n, iterable, padvalue=None):
  "grouper(3, 'abcdefg', 'x') --&gt; ('a','b','c'), ('d','e','f'), ('g','x','x')"
  return izip_longest(*[iter(iterable)]*n, fillvalue=padvalue)
</code></pre>
<p>However, <strong>this isn't working with Python 3</strong>. I get the following error</p>
<pre><code>ImportError: cannot import name izip_longest
</code></pre>
<p>Can someone help?</p>
<p>I'd like to convert my list of <code>[1,2,3,4,5,6,7,8,9]</code> to <code>[[1,2,3],[4,5,6],[7,8,9]]</code></p>
<h2>Edit</h2>
<h3>Now Python3 compatible</h3>
<p>Code below is adapted from the selected answer. Simply change name from <code>izip_longest</code> to <code>zip_longest</code>.</p>
<pre><code>from itertools import zip_longest
def grouper(n, iterable, padvalue=None):
  "grouper(3, 'abcdefg', 'x') --&gt; ('a','b','c'), ('d','e','f'), ('g','x','x')"
  return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3's <code>itertools</code> there is a function called <code>zip_longest</code>. It should do the same as <code>izip_longest</code> from Python 2.</p>
<p>Why the change in name? You might also notice that <code>itertools.izip</code> is now gone in Python 3 - that's because in Python 3, the <code>zip</code> built-in function now returns an iterator, whereas in Python 2 it returns a list. Since there's no need for the <code>izip</code> function, it also makes sense to rename the <code>_longest</code> variant for consistency.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">the doc</a>:</p>
<pre><code>&gt;&gt;&gt; s = [1,2,3,4,5,6,7,8,9]
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; list(zip(*[iter(s)]*n))
[(1, 2, 3), (4, 5, 6), (7, 8, 9)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After all that discussion above, here's a python3 solution that I believe gives safer, more predicable results.</p>
<pre><code>def chunker(iter, size):
    chunks = [];
    if size &lt; 1:
        raise ValueError('Chunk size must be greater than 0.')
    for i in range(0, len(iter), size):
        chunks.append(iter[i:(i+size)])
    return chunks

example = [1,2,3,4,5,6,7,8,9]
print(' 1: ' + str(chunker(example, 1)))
print(' 3: ' + str(chunker(example, 3)))
print(' 4: ' + str(chunker(example, 4)))
print(' 8: ' + str(chunker(example, 8)))
print(' 9: ' + str(chunker(example, 9)))
print('10: ' + str(chunker(example, 10)))
</code></pre>
<p>The results are:</p>
<pre><code>$ python3 iter_chunk.py 
 1: [[1], [2], [3], [4], [5], [6], [7], [8], [9]]
 3: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
 4: [[1, 2, 3, 4], [5, 6, 7, 8], [9]]
 8: [[1, 2, 3, 4, 5, 6, 7, 8], [9]]
 9: [[1, 2, 3, 4, 5, 6, 7, 8, 9]]
10: [[1, 2, 3, 4, 5, 6, 7, 8, 9]]
</code></pre>
</div>
<span class="comment-copy">Read the docs!  The Python 3 version of the <code>itertools</code> module documentation has the updated recipe for <code>grouper</code>:  <a href="http://docs.python.org/py3k/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">docs.python.org/py3k/library/itertools.html#itertools-recipes</a></span>
<span class="comment-copy">Be aware that  <code>len(s) % n != 0</code> will result in missing members as the given recipe does not handle remainders. For example, <code>n = 8</code> will result in <code>[(1, 2, 3, 4), (5, 6, 7, 8)]</code>. Where's 9? In the same vein, :  <code>n &gt; len(s)</code> will result in <code>[]</code>.</span>
<span class="comment-copy">Would work by replacing zip with itertools.zip_longest as necesarry.</span>
<span class="comment-copy">With  <code>n = 8</code> and itertools.zip_longest, we get<code>[(1, 2, 3, 4), (5, 6, 7, 8), (9, None, None, None)]</code>. We do get the 9 back, but now you must mitigate <code>None</code>s. And, with <code>n &gt; len(s)</code> we are still left with <code>[]</code>. PHP's implementation of <code>array_chunk()</code> always seemed intuitive, where you get back (in Python parlance) for <code>n = 8</code>, <code>[(1, 2, 3, 4), (5, 6, 7, 8), (9)]</code> and for <code>n &gt; len(s)</code> you get back the original array as the sole member of an outer array.  This way you always end up with something you can safely put through two nested loops without much caveating.</span>
<span class="comment-copy">@JasonGabler: zip_longest has a <code>fillvalue</code> keyword argument that allows you to specify a fill value other than <code>None</code>.</span>
