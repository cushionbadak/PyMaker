<div class="post-text" itemprop="text">
<p>Are the <code>else</code> and <code>finally</code> sections of exception handling redundant? For example, is there any difference between the following two code snippets?</p>
<pre><code>try:
    foo = open("foo.txt")
except IOError:
    print("error")
else:
    print(foo.read())
finally:
    print("finished")
</code></pre>
<p>and </p>
<pre><code>try:
    foo = open("foo.txt")
    print(foo.read())
except IOError:
    print("error")
print("finished")
</code></pre>
<p>More generally, can't the contents of <code>else</code> always be moved into the <code>try</code>, and can't the contents of <code>finally</code> just be moved outside the try/catch block? If so, what is the purpose of <code>else</code> and <code>finally</code>? Is it just to enhance readability?</p>
</div>
<div class="post-text" itemprop="text">
<p>The idea is that you keep the code for which you are handling exceptions as small as possible. Anything in the <code>else</code> block <em>could</em> get moved into the <code>try</code>, yes, but then you might end up catching an exception when you really want it to be raised. You may have successfully opened the file, but if the <code>read</code> causes an <code>IOError</code> and it's in the <code>try</code>, that will be caught too.</p>
<p>From the <a href="http://docs.python.org/tutorial/errors.html#handling-exceptions" rel="noreferrer">horse's mouth</a>:</p>
<blockquote>
<p>The use of the <code>else</code> clause is better than adding additional code to the <code>try</code> clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the <code>try ... except</code> statement.</p>
</blockquote>
<p>As the other two answers have already said, the <code>finally</code> block is there for code that will get executed whether or not there is an exception raised <em>anywhere</em>, including inside the <code>else</code> or the <code>except</code>, and whether or not that exception is handled. The canonical use case for this is making absolutely sure that a file handle is closed, no matter what.*</p>
<p>The <a href="http://docs.python.org/tutorial/errors.html#defining-clean-up-actions" rel="noreferrer">official phrasing</a> of this:</p>
<blockquote>
<p>When an exception has occurred in the <code>try</code> clause and has not been handled by an <code>except</code> clause (or it has occurred in a <code>except</code> or <code>else</code> clause), it is re-raised after the <code>finally</code> clause has been executed. The <code>finally</code> clause is also executed “on the way out” when any other clause of the <code>try</code> statement is left via a <code>break</code>, <code>continue</code>, or <code>return</code> statement.</p>
</blockquote>
<hr/>
<p>*This <em>particular</em> use has been somewhat obviated by context managers (<code>with...as</code> blocks).</p>
</div>
<div class="post-text" itemprop="text">
<p><code>finally</code> is executed regardless of whether the statements in the try block fail or succeed. <code>else</code> is executed only if the statements in the try block don't raise an exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>No matter what happens, the block in the <code>finally</code> <strong>always</strong> gets executed. Even if an exception wasn't handled or the exception handlers themselves generate new exceptions.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you move the contents of the <code>else</code> block inside the <code>try</code> block, you will also catch exceptions that might happen during the <code>else</code> block.  If the line</p>
<pre><code>print(foo.read())
</code></pre>
<p>in your example throws an <code>IOError</code>, your first code snippet won't catch that error, while your second snippet will.  You try to keep <code>try</code> blocks as small as possible generally to really only catch the exceptions you want to catch.</p>
<p>The <code>finally</code> block gets always executed, no matter what.  If for example the <code>try</code> block contains a <code>return</code> statement, a <code>finally</code> block will still be executed, while any code beneath the whole <code>try</code>/<code>except</code> block won't.</p>
</div>
<span class="comment-copy">Perfect Example :</span>
<span class="comment-copy">Yes, this is what I was looking for.</span>
<span class="comment-copy">I <i>did</i> tend to agree with you re: <i>canonical use case for this is making absolutely sure that a file handle is closed</i>. However, when I read <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow noreferrer">docs 3.6.4</a> it states else is best suited for closing the file handle, because it would only run IF opening it was successful - makes sense.  This changes my <i>previous</i> thought process a bit.</span>
<span class="comment-copy">I'm not finding the statement you describe at your link, @Mark. There is a code block with a <code>close()</code> call in an <code>else:</code>, but nothing that says it's preferred. Calling <code>close()</code> on a file object that's not open is a no-op AFAIK, so there's no worry there. More importantly, as said, the <code>finally</code> runs <b>even if an error occurs in the <code>else</code> block</b>. If there is other code in the <code>else</code> that could throw, you are in danger of a <code>close()</code> there being skipped.</span>
<span class="comment-copy">@JoshCaswell In a file close scenario it becomes a no-op, but that may not be for all scenarios - thus as they are explaining the benefit of <i>else</i> <i>It is useful for code that must be executed if the try clause does not raise an exception</i>.  Agreed it is a wash in this specific scenario to use <i>else</i> or <i>finally</i> due to behavior of file handle close.</span>
<span class="comment-copy">Concise and good!</span>
<span class="comment-copy">wow, this was so much easier to understand, thank you Sire! :)</span>
