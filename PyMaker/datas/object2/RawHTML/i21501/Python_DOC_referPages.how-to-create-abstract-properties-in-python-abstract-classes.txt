<div class="post-text" itemprop="text">
<p>In the following code, I create a base abstract class <code>Base</code>. I want all the classes that inherit from <code>Base</code> to provide the <code>name</code> property, so I made this property an <code>@abstractmethod</code>.</p>
<p>Then I created a subclass of <code>Base</code>, called <code>Base_1</code>, which is meant to supply some functionality, but still remain abstract. There is no <code>name</code> property in <code>Base_1</code>, but nevertheless python instatinates an object of that class without an error. How does one create abstract properties?</p>
<pre><code>from abc import ABCMeta, abstractmethod
class Base(object):
    __metaclass__ = ABCMeta
    def __init__(self, strDirConfig):
        self.strDirConfig = strDirConfig

    @abstractmethod
    def _doStuff(self, signals):
        pass

    @property    
    @abstractmethod
    def name(self):
        #this property will be supplied by the inheriting classes
        #individually
        pass


class Base_1(Base):
    __metaclass__ = ABCMeta
    # this class does not provide the name property, should raise an error
    def __init__(self, strDirConfig):
        super(Base_1, self).__init__(strDirConfig)

    def _doStuff(self, signals):
        print 'Base_1 does stuff'


class C(Base_1):
    @property
    def name(self):
        return 'class C'


if __name__ == '__main__':
    b1 = Base_1('abc')  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since <a href="https://docs.python.org/3/whatsnew/3.3.html#abc" rel="noreferrer">Python 3.3</a> a bug was fixed meaning the <code>property()</code> decorator is now correctly identified as abstract when applied to an abstract method.</p>
<p>From <a href="https://docs.python.org/3/library/abc.html#abc.abstractproperty" rel="noreferrer">python docs</a>:</p>
<pre><code>class C(ABC):
    @property
    @abstractmethod
    def my_abstract_property(self):
        ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Until <a href="https://docs.python.org/3/whatsnew/3.3.html#abc" rel="noreferrer">Python 3.3</a>, you cannot nest <code>@abstractmethod</code> and <code>@property</code>.</p>
<p>Use <code>@abstractproperty</code> to create abstract properties (<a href="http://docs.python.org/library/abc.html#abc.abstractproperty" rel="noreferrer">docs</a>).</p>
<pre><code>from abc import ABCMeta, abstractmethod, abstractproperty

class Base(object):
    # ...
    @abstractproperty
    def name(self):
        pass
</code></pre>
<p>The code now raises the correct exception:</p>
<pre>
Traceback (most recent call last):
  File "foo.py", line 36, in 
    b1 = Base_1('abc')  
TypeError: Can't instantiate abstract class Base_1 with abstract methods name
</pre>
</div>
<span class="comment-copy">Gotcha: If you forget to use decorator <code>@property</code> in <code>class C</code>, <code>name</code> will revert to a method.</span>
<span class="comment-copy">actually this answer is wrong for younger pythons: since 3.3, <code>@abstractproperty</code> is deprecated in favor of a combination like OP’s.</span>
<span class="comment-copy">From the 3.3 docs: <a href="http://docs.python.org/3/library/abc.html#abc.abstractproperty" rel="nofollow noreferrer">docs.python.org/3/library/abc.html#abc.abstractproperty</a></span>
<span class="comment-copy">thanks, codeape. i’ll update the answer accordingly.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/abc.html#abc.abstractproperty" rel="nofollow noreferrer">@abstractproperty in the Python 2 docs</a></span>
<span class="comment-copy">so until 3.3, just <code>raise NotImplementedError</code></span>
