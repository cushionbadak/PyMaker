<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3899645/list-extend-and-list-comprehension">list.extend and list comprehension</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I'm not experienced in Python, and I often write code that (simplified) looks like this:</p>
<pre><code>accumulationList = []
for x in originalList:
    y = doSomething(x)
    accumulationList.append(y)
return accumulationList
</code></pre>
<p>Then after my test passes, I refactor to </p>
<pre><code>return [doSomething(x) for x in originalList]
</code></pre>
<p>But suppose it turns out a little different, and my loop looks like this:</p>
<pre><code>accumulationList = []
for x in originalList:
    y = doSomething(x)
    accumulationList.extend(y)
return accumulationList
</code></pre>
<p>where the <code>doSomething</code> list returns a list. What is the most Pythonic way to accomplish this? Obviously, the previous list comprehension would give a list of lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Much simpler and cleaner with list comprehension:</p>
<pre><code>[y for x in originalList for y in doSomething(x)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you mean something like this?</p>
<pre><code>accumulationList = []
for x in originalList:
    accumulationList.extend(doSomething(x))
return accumulationList
</code></pre>
<p>or shorter code (but not optimal):</p>
<pre><code>return sum((doSomething(x) for x in originalList), [])
</code></pre>
<p>or the same:</p>
<pre><code>return sum(map(doSomething, originalList), [])
</code></pre>
<p>Thanks to @eyquem for the hint (if using Python 2.x):</p>
<pre><code>import itertools as it

return sum(it.imap(doSomething, originalList), [])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's in-place add operator (<code>+=</code>, available as <code>iadd</code> in <code>operator</code> module) is equivalent of <code>.extend</code> for list. Pair it with <code>reduce</code> to get what you want.</p>
<pre><code>import operator

reduce(operator.iadd, (doSomething(x) for x in originalList)
, accumulation_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the answers involving add or iadd run in quadratic time, which probably isn't good.  I'd try:</p>
<pre><code>from itertools import chain
accumulation_list = list(chain.from_iterable(doSomething(x) for x in originalList))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there is special syntax for this case. But you could make the for loop shorter:</p>
<pre><code>accumulationList += doSomething(x)
</code></pre>
<p>If you insist, you could use functional programming to flatten the list:</p>
<pre><code>result = reduce(lambda a,b: a+b, [[i,i*2] for i in range(3)])
</code></pre>
<p>But I wouldn't call this pythonic, I think it's harder to read than a for loop.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://en.wikipedia.org/wiki/Functional_programming" rel="nofollow noreferrer">Functionally</a>, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain</code></a> with <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a>. For an input list <code>L</code>:</p>
<pre><code>res = list(chain.from_iterable(map(doSomething, L)))
</code></pre>
<p>If you need an iterator, simply remove the <code>list</code> call. Here's a demo:</p>
<pre><code>def doSomething(value):
    return [value * i for i in range(1, 4)]

def original(originalList):
    accumulationList = []
    for x in originalList:
        y = doSomething(x)
        accumulationList.extend(y)
    return accumulationList

def new(L):
    return list(chain.from_iterable(map(doSomething, L)))

x = [1, 2, 3]

assert original(x) == new(x)

print(new(x))

[1, 2, 3, 2, 4, 6, 3, 6, 9]
</code></pre>
</div>
<span class="comment-copy">@chris_rands -- It seems a little odd to mark a question as a dupe 7.5 years after it was asked -- it doesn't serve the purpose of directing the OP to the duplicate, and the questions are not quite similar enough the merging is an option. /shrug</span>
<span class="comment-copy">Great improvement! Back when I asked the question, I wouldn't have though to use a nested list comprehension.</span>
<span class="comment-copy"><code>return sum(map(doSomething, originalList)), [])</code> better with <b>imap</b> if Python 2. Right if Python 3</span>
