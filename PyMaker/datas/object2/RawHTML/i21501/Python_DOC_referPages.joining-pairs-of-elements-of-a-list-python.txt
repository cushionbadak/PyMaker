<div class="post-text" itemprop="text">
<p>I know that a list can be joined to make one long string as in:</p>
<pre><code>x = ['a', 'b', 'c', 'd']
print ''.join(x)
</code></pre>
<p>Obviously this would output:</p>
<pre><code>'abcd'
</code></pre>
<p>However, what I am trying to do is simply join the first and second strings in the list, then join the third and fourth and so on. In short, from the above example instead achieve an output of:</p>
<pre><code>['ab', 'cd']
</code></pre>
<p>Is there any simple way to do this? I should probably also mention that the lengths of the strings in the list will be unpredictable, as will the number of strings within the list, though the number of strings will always be even. So the original list could just as well be: </p>
<pre><code>['abcd', 'e', 'fg', 'hijklmn', 'opq', 'r'] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use slice notation with steps:</p>
<pre><code>&gt;&gt;&gt; x = "abcdefghijklm"
&gt;&gt;&gt; x[0::2] #0. 2. 4...
'acegikm'
&gt;&gt;&gt; x[1::2] #1. 3. 5 ..
'bdfhjl'
&gt;&gt;&gt; [i+j for i,j in zip(x[::2], x[1::2])] # zip makes (0,1),(2,3) ...
['ab', 'cd', 'ef', 'gh', 'ij', 'kl']
</code></pre>
<p>Same logic applies for lists too. String lenght doesn't matter, because you're simply adding two strings together.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use an iterator.  </p>
<p><strong>List comprehension:</strong></p>
<pre><code>&gt;&gt;&gt; si = iter(['abcd', 'e', 'fg', 'hijklmn', 'opq', 'r'])
&gt;&gt;&gt; [c+next(si, '') for c in si]
['abcde', 'fghijklmn', 'opqr']
</code></pre>
<ul>
<li>Very efficient for memory usage.</li>
<li>Exactly one traversal of s</li>
</ul>
<p><strong>Generator expression:</strong></p>
<pre><code>&gt;&gt;&gt; si = iter(['abcd', 'e', 'fg', 'hijklmn', 'opq', 'r'])
&gt;&gt;&gt; pair_iter = (c+next(si, '') for c in si)
&gt;&gt;&gt; pair_iter # can be used in a for loop
&lt;generator object at 0x4ccaa8&gt;
&gt;&gt;&gt; list(pair_iter) 
['abcde', 'fghijklmn', 'opqr']
</code></pre>
<ul>
<li>use as an iterator</li>
</ul>
<p><strong>Using map, str.__add__, iter</strong></p>
<pre><code>&gt;&gt;&gt; si = iter(['abcd', 'e', 'fg', 'hijklmn', 'opq', 'r'])
&gt;&gt;&gt; map(str.__add__, si, si)
['abcde', 'fghijklmn', 'opqr']
</code></pre>
<p><a href="http://docs.python.org/library/functions.html#next" rel="noreferrer">next(iterator[, default])</a> is available starting in Python 2.6</p>
</div>
<div class="post-text" itemprop="text">
<p>just to be pythonic :-)</p>
<pre><code>&gt;&gt;&gt; x = ['a1sd','23df','aaa','ccc','rrrr', 'ssss', 'e', '']
&gt;&gt;&gt; [x[i] + x[i+1] for i in range(0,len(x),2)]
['a1sd23df', 'aaaccc', 'rrrrssss', 'e']
</code></pre>
<p>in case the you want to be alarmed if the list length is odd you can try:</p>
<pre><code>[x[i] + x[i+1] if not len(x) %2 else 'odd index' for i in range(0,len(x),2)]
</code></pre>
<p>Best of Luck</p>
</div>
<div class="post-text" itemprop="text">
<p>Without building temporary lists:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; s = 'abcdefgh'
&gt;&gt;&gt; si = iter(s)
&gt;&gt;&gt; [''.join(each) for each in itertools.izip(si, si)]
['ab', 'cd', 'ef', 'gh']
</code></pre>
<p>or:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; s = 'abcdefgh'
&gt;&gt;&gt; si = iter(s)
&gt;&gt;&gt; map(''.join, itertools.izip(si, si))
['ab', 'cd', 'ef', 'gh']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; lst =  ['abcd', 'e', 'fg', 'hijklmn', 'opq', 'r'] 
&gt;&gt;&gt; print [lst[2*i]+lst[2*i+1] for i in range(len(lst)/2)]
['abcde', 'fghijklmn', 'opqr']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well I would do it this way as I am no good with Regs..</p>
<p><strong>CODE</strong></p>
<pre><code>t = '1. eat, food\n\
7am\n\
2. brush, teeth\n\
8am\n\
3. crack, eggs\n\
1pm'.splitlines()

print [i+j for i,j in zip(t[::2],t[1::2])]
</code></pre>
<p><strong>output:</strong> </p>
<pre><code>['1. eat, food   7am', '2. brush, teeth   8am', '3. crack, eggs   1pm']  
</code></pre>
<p>Hope this helps :)</p>
</div>
<span class="comment-copy"><i>“I should probably also mention that the lengths of the strings in the list will be unpredictable”</i> – So does the length matter? I.e. do you just want to join every pair of list elements, or do you actually want to look at the content and join as long as the resulting element stays below some special length limit?</span>
<span class="comment-copy">simply join every pair, i just thought that having not knowing the number of pairs could be a problem</span>
<span class="comment-copy">There is no doubt that kevpie's answer is far better. In this one, <code>x[:::2]</code> creates an object, <code>x[1::2]</code> creates another object, these creations being probably based on calculation of indexes under the hood, and a call to a function with these two objects passed as arguments is necessary before being able to obtain the successive pairs of elements that must be concatenated. While in kevpie's answer, there's just the creation of one iterator and then the iteration skips from element to element of the untouched list without having to take care of the indexes, and that's far more pythonic.</span>
<span class="comment-copy">@eyquem, using <code>itertools.islice</code> instead of [], eliminates the intermediate objects. But since both answers works on same conditions and returns same, they are both right. And <code>zip(i[::2], i[1::2])</code> looks so sweet to me, so, why not? :)</span>
<span class="comment-copy">This only works on <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer">sequences</a>, while @kevpie's answer is more general and works on any <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">iterable</a>.</span>
<span class="comment-copy">By far, the best answer. See my comment to utdemir's answer.</span>
<span class="comment-copy">Nice, but considering my code leaves me starting with the original list anyway, i think ill opt for utdmr's....thank you though</span>
