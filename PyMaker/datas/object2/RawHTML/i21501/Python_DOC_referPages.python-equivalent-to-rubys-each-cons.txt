<div class="post-text" itemprop="text">
<p>Is there a Pythonic equivalent to Ruby's <code>#each_cons</code>?</p>
<p>In Ruby you can do this:</p>
<pre><code>array = [1,2,3,4]
array.each_cons(2).to_a
=&gt; [[1,2],[2,3],[3,4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For such things, <code>itertools</code> is the module you should be looking at:</p>
<pre><code>from itertools import tee, izip

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b)
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; list(pairwise([1, 2, 3, 4]))
[(1, 2), (2, 3), (3, 4)]
</code></pre>
<p>For an even more general solution, consider this:</p>
<pre><code>def split_subsequences(iterable, length=2, overlap=0):
    it = iter(iterable)
    results = list(itertools.islice(it, length))
    while len(results) == length:
        yield results
        results = results[length - overlap:]
        results.extend(itertools.islice(it, length - overlap))
    if results:
        yield results
</code></pre>
<p>This allows arbitrary lengths of subsequences and arbitrary overlapping. Usage:</p>
<pre><code>&gt;&gt; list(split_subsequences([1, 2, 3, 4], length=2))
[[1, 2], [3, 4]]
&gt;&gt; list(split_subsequences([1, 2, 3, 4], length=2, overlap=1))
[[1, 2], [2, 3], [3, 4], [4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there is one, I looked through the built-in module <code>itertools</code>, which is where I would expect it to be. You can simply create one though:</p>
<pre><code>def each_cons(x, size):
    return [x[i:i+size] for i in range(len(x)-size+1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution for lists (Python2):</p>
<pre><code>import itertools
def each_cons(xs, n):
    return itertools.izip(*(xs[i:] for i in xrange(n)))
</code></pre>
<p><strong>Edit:</strong> With Python 3 <a href="https://docs.python.org/ja/2.7/library/itertools.html#itertools.izip" rel="nofollow noreferrer"><code>itertools.izip</code></a> is no longer, so you use plain <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a>:</p>
<pre><code>def each_cons(xs, n):
    return zip(*(xs[i:] for i in range(n)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A quick one-liner:</p>
<pre><code>a = [1, 2, 3, 4]

out = [a[i:i + 2] for i in range(len(a) - 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python can surely do this. If you don't want to do it so eagerly, use itertool's islice and izip. Also, its important to remember that normal slices will create a copy so if memory usage is important you should also consider the itertool equivalents.</p>
<p><code>each_cons = lambda l: zip(l[:-1], l[1:])</code></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>UPDATE:</strong> Nevermind my answer below, just use <a href="http://toolz.readthedocs.org/en/latest/_modules/toolz/itertoolz.html#sliding_window" rel="nofollow"><code>toolz.itertoolz.sliding_window()</code></a> -- it will do the right thing.</p>
<hr/>
<p>For a truly lazy implementation that preserves the behavior of Ruby's <code>each_cons</code> when the sequence/generator has insufficient length:</p>
<pre><code>import itertools
def each_cons(sequence, n):
    return itertools.izip(*(itertools.islice(g, i, None)
                          for i, g in
                          enumerate(itertools.tee(sequence, n))))
</code></pre>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; print(list(each_cons(xrange(5), 2)))
[(0, 1), (1, 2), (2, 3), (3, 4)]
&gt;&gt;&gt; print(list(each_cons(xrange(5), 5)))
[(0, 1, 2, 3, 4)]
&gt;&gt;&gt; print(list(each_cons(xrange(5), 6)))
[]
&gt;&gt;&gt; print(list(each_cons((a for a in xrange(5)), 2)))
[(0, 1), (1, 2), (2, 3), (3, 4)]
</code></pre>
<p>Note that the tuple unpacking used on the arguments for izip is applied to a tuple of size <code>n</code> resulting of <code>itertools.tee(xs, n)</code> (that is, the "window size"), and not the sequence we want to iterate.</p>
</div>
<div class="post-text" itemprop="text">
<p>Same as elias's code, but works for python 2 and 3:</p>
<pre><code>try:
    from itertools import izip  # python 2
except ImportError:
    from builtins import zip as izip  # python 3

from itertools import islice, tee

def each_cons(sequence, n):
    return izip(
        *(
            islice(g, i, None)
            for i, g in
            enumerate(tee(sequence, n))
        )
    )
</code></pre>
</div>
<span class="comment-copy">Why would you ever need to do this? Just wondering ;)</span>
<span class="comment-copy">I'm doing a moving average of a list. #each_cons is how I would do it in Ruby, so I'm wondering how Pythonistas do it.</span>
<span class="comment-copy">For a truly equivalent to Ruby's each_cons, use <a href="http://toolz.readthedocs.org/en/latest/_modules/toolz/itertoolz.html#sliding_window" rel="nofollow noreferrer"><code>toolz.itertoolz.sliding_window()</code></a>.</span>
<span class="comment-copy">Python 3: <a href="http://docs.python.org/py3k/library/itertools.html" rel="nofollow noreferrer">docs.python.org/py3k/library/itertools.html</a> - Py2: <a href="http://docs.python.org/library/itertools.html" rel="nofollow noreferrer">docs.python.org/library/itertools.html</a></span>
<span class="comment-copy">The general solution here does not behave like <code>each_cons</code> when you have a sequence with insufficient length (each_cons returns nil). The implementation in snipsnipsnip's answer seems more appropriated in this regard.</span>
<span class="comment-copy"><code>list(split_subsequences([1, 2, 3, 4, 5, 6], length=3, overlap=1))</code> should return <code>[[1,2,3],[2,3,4],[3,4,5],[4,5,6]]</code> and not <code>[[1, 2, 3], [3, 4, 5], [5, 6]]</code>.</span>
<span class="comment-copy">+1 for generic answer. Mine worked for <code>2</code>, but after modifying it for an arbitrary <code>cons</code>, it looked like yours.</span>
<span class="comment-copy">In general solutions that work also for iterables are preferrable, but well, it's ok for sequences. Nit-picking: <code>x</code> is a collection, so better <code>xs</code> (naming is very important, even in examples. I'd even say it's <i>more</i> important in examples :)).</span>
<span class="comment-copy">nice solution, thanks! =)</span>
<span class="comment-copy">This solution does not work if the argument xs is a generator, moreover it is not really lazy because of the slice <code>xs[i:]</code>.</span>
<span class="comment-copy">You're right, I could write <code>islice(xs, i, None)</code> instead of <code>xs[i:]</code>. I preferred latter for some reason: a) The question was about lists. b) <a href="http://c2.com/cgi/wiki?PrematureGeneralization" rel="nofollow noreferrer">I use <code>each_cons</code> for lists most of the time</a>. c) In case <code>xs</code> is a list, sliced lists will have shared memory, so it may be memory efficient than doing it lazy.</span>
<span class="comment-copy">Yeah, you're right, I know. =) It's just that Ruby's <code>#each_cons</code> works for everything, so I thought I should point it out. I've posted a lazy solution for those who need one.</span>
<span class="comment-copy">For a moment I deleted my answer, seeing that your approach adding islice worked with an <code>xrange()</code>. It still failed with a plain generator, though. This little piece of code is very beautiful, thanks again for sharing.</span>
