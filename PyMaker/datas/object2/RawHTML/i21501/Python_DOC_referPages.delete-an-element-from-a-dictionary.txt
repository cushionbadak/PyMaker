<div class="post-text" itemprop="text">
<p>Is there a way to delete an item from a dictionary in Python?</p>
<p>Additionally, how can I delete an item from a dictionary to return a copy (i.e., not modifying the original)?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/reference/simple_stmts.html#the-del-statement" rel="noreferrer"><code>del</code> statement</a> removes an element:</p>
<pre><code>del d[key]
</code></pre>
<p>However, this mutates the existing dictionary so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a <em>new</em> dictionary, make a copy of the dictionary:</p>
<pre><code>def removekey(d, key):
    r = dict(d)
    del r[key]
    return r
</code></pre>
<p>The <code>dict()</code> constructor makes a <em>shallow copy</em>. To make a deep copy, see the <a href="https://docs.python.org/library/copy.html" rel="noreferrer"><code>copy</code> module</a>.</p>
<hr/>
<p>Note that making a copy for every dict <code>del</code>/assignment/etc. means you're going from constant time to linear time, and also using linear space. For small dicts, this is not a problem. But if you're planning to make lots of copies of large dicts, you probably want a different data structure, like a HAMT (as described in <a href="https://stackoverflow.com/a/50341031/908494">this answer</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/library/stdtypes.html#dict.pop" rel="noreferrer"><code>pop</code></a> mutates the dictionary.</p>
<pre><code> &gt;&gt;&gt;lol = {"hello":"gdbye"}
 &gt;&gt;&gt;lol.pop("hello")
    'gdbye'
 &gt;&gt;&gt; lol
     {}
</code></pre>
<p>If you want to keep the original you could just copy it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your solution is best way to do it. But if you want another solution, you can create a new dictionary with using the keys from old dictionary without including your specified key, like this:</p>
<pre><code>&gt;&gt;&gt; a
{0: 'zero', 1: 'one', 2: 'two', 3: 'three'}
&gt;&gt;&gt; {i:a[i] for i in a if i!=0}
{1: 'one', 2: 'two', 3: 'three'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/tutorial/datastructures.html#the-del-statement" rel="noreferrer">del statement</a> is what you're looking for. If you have a dictionary named foo with a key called 'bar', you can delete 'bar' from foo like this:</p>
<pre><code>del foo['bar']
</code></pre>
<p>Note that this permanently modifies the dictionary being operated on. If you want to keep the original dictionary, you'll have to create a copy beforehand:</p>
<pre><code>&gt;&gt;&gt; foo = {'bar': 'baz'}
&gt;&gt;&gt; fu = dict(foo)
&gt;&gt;&gt; del foo['bar']
&gt;&gt;&gt; print foo
{}
&gt;&gt;&gt; print fu
{'bar': 'baz'}
</code></pre>
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="noreferrer"><code>dict</code></a> call makes a shallow copy. If you want a deep copy, use <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="noreferrer"><code>copy.deepcopy</code></a>.</p>
<p>Here's a method you can copy &amp; paste, for your convenience:</p>
<pre><code>def minus_key(key, dictionary):
    shallow_copy = dict(dictionary)
    del shallow_copy[key]
    return shallow_copy
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There're a lot of nice answers, but I want to emphasize one thing.</p>
<p>You can use both <a href="https://docs.python.org/3/library/stdtypes.html#dict.pop" rel="noreferrer"><code>dict.pop()</code></a> method and a more generic <a href="https://docs.python.org/3/tutorial/datastructures.html#the-del-statement" rel="noreferrer"><code>del</code> statement</a> to remove items from a dictionary. They both mutate the original dictionary, so you need to make a copy (see details below).</p>
<p><strong>And both of them will raise a <a href="https://docs.python.org/3/library/exceptions.html#KeyError" rel="noreferrer"><code>KeyError</code></a> if the key you're providing to them is not present in the dictionary:</strong></p>
<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
del d[key_to_remove]  # Raises `KeyError: 'c'`
</code></pre>
<p>and</p>
<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
d.pop(key_to_remove)  # Raises `KeyError: 'c'`
</code></pre>
<p>You have to take care of this:</p>
<p><strong>by capturing the exception:</strong></p>
<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
try:
    del d[key_to_remove]
except KeyError as ex:
    print("No such key: '%s'" % ex.message)
</code></pre>
<p>and</p>
<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
try:
    d.pop(key_to_remove)
except KeyError as ex:
    print("No such key: '%s'" % ex.message)
</code></pre>
<p><strong>by performing a check:</strong></p>
<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
if key_to_remove in d:
    del d[key_to_remove]
</code></pre>
<p>and</p>
<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
if key_to_remove in d:
    d.pop(key_to_remove)
</code></pre>
<p><strong>but with <code>pop()</code> there's also a much more concise way - provide the default return value:</strong></p>
<pre><code>key_to_remove = "c"
d = {"a": 1, "b": 2}
d.pop(key_to_remove, None)  # No `KeyError` here
</code></pre>
<p>Unless you use <code>pop()</code> to get the value of a key being removed you may provide anything, not necessary <code>None</code>.
Though it might be that using <code>del</code> with <code>in</code> check is <strong>slightly</strong> faster due to <code>pop()</code> being a function with its own complications causing overhead. Usually it's not the case, so <code>pop()</code> with default value is good enough.</p>
<hr/>
<p>As for the main question, you'll have to make a copy of your dictionary, to save the original dictionary and have a new one without the key being removed.</p>
<p>Some other people here suggest making a full (deep) copy with <a href="https://docs.python.org/3/library/copy.html?#copy.deepcopy" rel="noreferrer"><code>copy.deepcopy()</code></a>, which might be an overkill, a "normal" (shallow) copy, using <a href="https://docs.python.org/3/library/copy.html?#copy.copy" rel="noreferrer"><code>copy.copy()</code></a> or <a href="https://docs.python.org/3/library/stdtypes.html#dict.copy" rel="noreferrer"><code>dict.copy()</code></a>, might be enough. The dictionary keeps a reference to the object as a value for a key. So when you remove a key from a dictionary this reference is removed, not the object being referenced. The object itself may be removed later automatically by the garbage collector, if there're no other references for it in the memory. Making a deep copy requires more calculations compared to shallow copy, so it decreases code performance by making the copy, wasting memory and providing more work to the GC, sometimes shallow copy is enough.</p>
<p>However, if you have mutable objects as dictionary values and plan to modify them later in the returned dictionary without the key, you have to make a deep copy.</p>
<p><strong>With shallow copy:</strong></p>
<pre><code>def get_dict_wo_key(dictionary, key):
    """Returns a **shallow** copy of the dictionary without a key."""
    _dict = dictionary.copy()
    _dict.pop(key, None)
    return _dict


d = {"a": [1, 2, 3], "b": 2, "c": 3}
key_to_remove = "c"

new_d = get_dict_wo_key(d, key_to_remove)
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3], "b": 2}
new_d["a"].append(100)
print(d)  # {"a": [1, 2, 3, 100], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2}
new_d["b"] = 2222
print(d)  # {"a": [1, 2, 3, 100], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2222}
</code></pre>
<p><strong>With deep copy:</strong></p>
<pre><code>from copy import deepcopy


def get_dict_wo_key(dictionary, key):
    """Returns a **deep** copy of the dictionary without a key."""
    _dict = deepcopy(dictionary)
    _dict.pop(key, None)
    return _dict


d = {"a": [1, 2, 3], "b": 2, "c": 3}
key_to_remove = "c"

new_d = get_dict_wo_key(d, key_to_remove)
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3], "b": 2}
new_d["a"].append(100)
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2}
new_d["b"] = 2222
print(d)  # {"a": [1, 2, 3], "b": 2, "c": 3}
print(new_d)  # {"a": [1, 2, 3, 100], "b": 2222}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d = {1: 2, '2': 3, 5: 7}
del d[5]
print 'd = ', d
</code></pre>
<p>Result: d = {1: 2, '2': 3}</p>
</div>
<div class="post-text" itemprop="text">
<p>Simply call del d['key'].</p>
<p>However, in production, it is always a good practice to check if 'key' exists in d.</p>
<pre><code>if 'key' in d:
    del d['key']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>… how can I delete an item from a dictionary to return a copy (i.e., not modifying the original)?</p>
</blockquote>
<p>A <code>dict</code> is the wrong data structure to use for this.</p>
<p>Sure, copying the dict and popping from the copy works, and so does building a new dict with a comprehension, but all that copying takes time—you've replaced a constant-time operation with a linear-time one. And all those copies alive at once take space—linear space per copy.</p>
<p>Other data structures, like <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie" rel="noreferrer">hash array mapped tries</a>, are designed for exactly this kind of use case: adding or removing an element returns a copy <em>in logarithmic time, sharing most of its storage with the original</em>.<sup>1</sup></p>
<p>Of course there are some downsides. Performance is logarithmic rather than constant (although with a large base, usually 32-128). And, while you can make the non-mutating API identical to <code>dict</code>, the "mutating" API is obviously different. And, most of all, there's no HAMT batteries included with Python.<sup>2</sup></p>
<p>The <a href="https://pypi.org/project/pyrsistent/" rel="noreferrer"><code>pyrsistent</code></a> library is a pretty solid implementation of HAMT-based dict-replacements (and various other types) for Python. It even has a nifty <a href="http://pyrsistent.readthedocs.io/en/latest/intro.html#evolvers" rel="noreferrer">evolver API</a> for porting existing mutating code to persistent code as smoothly as possible. But if you want to be explicit about returning copies rather than mutating, you just use it like this:</p>
<pre><code>&gt;&gt;&gt; from pyrsistent import m
&gt;&gt;&gt; d1 = m(a=1, b=2)
&gt;&gt;&gt; d2 = d1.set('c', 3)
&gt;&gt;&gt; d3 = d1.remove('a')
&gt;&gt;&gt; d1
pmap({'a': 1, 'b': 2})
&gt;&gt;&gt; d2
pmap({'c': 3, 'a': 1, 'b': 2})
&gt;&gt;&gt; d3
pmap({'b': 2})
</code></pre>
<p>That <code>d3 = d1.remove('a')</code> is exactly what the question is asking for.</p>
<p>If you've got mutable data structures like <code>dict</code> and <code>list</code> embedded in the <code>pmap</code>, you'll still have aliasing issues—you can only fix that by going immutable all the way down, embedding <code>pmap</code>s and <code>pvector</code>s.</p>
<hr/>
<p><sub>1. HAMTs have also become popular in languages like Scala, Clojure, Haskell because they play very nicely with lock-free programming and software transactional memory, but neither of those is very relevant in Python.</sub></p>
<p><sub>2. In fact, there <em>is</em> an HAMT in the stdlib, used in the implementation of <a href="https://docs.python.org/3.7/library/contextvars.html" rel="noreferrer"><code>contextvars</code></a>. <a href="https://www.python.org/dev/peps/pep-0550/#appendix-hamt-performance-analysis" rel="noreferrer">The earlier withdrawn PEP explains why.</a> But this is a hidden implementation detail of the library, not a public collection type.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>No, there is no other way than</p>
<pre><code>def dictMinus(dct, val):
   copy = dct.copy()
   del copy[val]
   return copy
</code></pre>
<p>However, often creating copies of only slightly altered dictionaries is probably not a good idea because it will result in comparatively large memory demands. It is usually better to log the old dictionary(if even necessary) and then modify it.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; def delete_key(dict, key):
...     del dict[key]
...     return dict
... 
&gt;&gt;&gt; test_dict = {'one': 1, 'two' : 2}
&gt;&gt;&gt; print delete_key(test_dict, 'two')
{'one': 1}
&gt;&gt;&gt;
</code></pre>
<p>this doesn't do any error handling, it assumes the key is in the dict, you might want to check that first and <code>raise</code> if its not</p>
</div>
<div class="post-text" itemprop="text">
<p>Here a top level design approach:</p>
<pre><code>def eraseElement(d,k):
    if isinstance(d, dict):
        if k in d:
            d.pop(k)
            print(d)
        else:
            print("Cannot find matching key")
    else:
        print("Not able to delete")


exp = {'A':34, 'B':55, 'C':87}
eraseElement(exp, 'C')
</code></pre>
<p>I'm passing the dictionary and the key I want into my function, validates if it's a dictionary and if the key is okay, and if both exist, removes the value from the dictionary and prints out the left-overs.</p>
<p>Output: <code>{'B': 55, 'A': 34}</code></p>
<p>Hope that helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>nice one-liner to check if the key is present, delete it, return the value, or default:</p>
<pre><code>ret_val = ('key' in body and body.pop('key')) or 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Below code snippet will help you definitely, I have added comments in each line which will help you in understanding the code.</p>
<pre><code>def execute():
   dic = {'a':1,'b':2}
   dic2 = remove_key_from_dict(dic, 'b')  
   print(dict2)           # {'a': 1}
   print(dict)            # {'a':1,'b':2}

def remove_key_from_dict(dictionary_to_use, key_to_delete):
   copy_of_dict = dict(dictionary_to_use)     # creating clone/copy of the dictionary
   if key_to_delete in copy_of_dict :         # checking given key is present in the dictionary
       del copy_of_dict [key_to_delete]       # deleting the key from the dictionary 
   return copy_of_dict                        # returning the final dictionary
</code></pre>
<p>or you can also use dict.pop()</p>
<pre><code>d = {"a": 1, "b": 2}

res = d.pop("c")  # No `KeyError` here
print (res)       # this line will not execute
</code></pre>
<p>or the better approach is</p>
<pre><code>res = d.pop("c", "key not found")
print (res)   # key not found
print (d)     # {"a": 1, "b": 2}

res = d.pop("b", "key not found")
print (res)   # 2
print (d)     # {"a": 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another variation using list comprehension:</p>
<pre><code>original_d = {'a': None, 'b': 'Some'}
d = dict((k,v) for k, v in original_d.iteritems() if v)
# result should be {'b': 'Some'}
</code></pre>
<p>The approach is based on an answer from this post:
<a href="https://stackoverflow.com/questions/12118695/efficient-way-to-remove-keys-with-empty-values-from-a-dict">Efficient way to remove keys with empty strings from a dict</a></p>
</div>
<span class="comment-copy">Why do you need a function that returns a dictionary, when you can just modify the dictionary directly?</span>
<span class="comment-copy">The <a href="https://docs.python.org/2/library/stdtypes.html#dict.pop" rel="nofollow noreferrer">dictionary <code>pop</code> method</a> changes the dictionary <i>in-place</i>. Therefore it alters the <i>reference</i> to the dictionary that was passed from the caller to the "helper function". So the "helper function" doesn't need to return anything, since the original reference to the dictionary in the caller will already be altered. Don't assign the return from <code>dict.pop()</code> to anything if you don't need it. EG: <code>do stuff with my_dict; my_dict.pop(my_key, None); do more stuff with my_dict # now doesn't have my_key</code>. Use <code>deepcopy(my_dict)</code> if needed.</span>
<span class="comment-copy">Since the original title disagreed with the details and specifically excluded the obvious solution <code>d.pop()</code>, I fixed the title to ask the question specified in the details.</span>
<span class="comment-copy">We should add a caveat asking if you <b>really</b> want to do this, as if you do it N times on a dictionary with E elements you'll leak(/use) O(N*E) memory with all the deep copies. If you merely want a read-only (shallow copy), do <code>d.pop(key)</code>. But if anything ever modifies the shallow copy, you have a <a href="https://stackoverflow.com/questions/2465921/how-to-copy-a-dictionary-and-only-edit-the-copy">well-known problem with aliasing</a>. It helps if you tell us the wider context. (Is anything else ever modifying the dict values? Are you trying to destructively iterate over a list? if not, what?)</span>
<span class="comment-copy">"Why do you need a function that returns a dictionary, when you can just modify the dictionary directly?" Perhaps because you want to write pure functions that <i>don't</i> modify their parameters?</span>
<span class="comment-copy">thats a great point about the mutability of dictionaries +1 - though i can't think of a time when i wanted copies of the dictionary, i've always relied on 'everyones' copy being the same. great point.</span>
<span class="comment-copy">@tMC If you edit the <code>dict</code> as you're looping through it, it'll give you an error: <code>RuntimeError: dictionary changed size during iteration</code></span>
<span class="comment-copy">What about <code>pop</code> method which in fact does the same? Isn't it more pythonic? (being dict's method, not special reserved word)?</span>
<span class="comment-copy">This answer has a weakness, it could be misleading. Readers may misunderstand that dict(d) can give them a copy with 'd'. But it's an incomplete copy. When only doing del keys operations, that's OK. But when you want to do something else to a nested dict, modifying 'r' using that copy method may cause change to the original 'd'. To get an authentic copy, you need first ' import copy ', and then 'r = copy.deepcopy(d) '.</span>
<span class="comment-copy">@Zen: Fair enough, I have added a note about shallow vs. deep copy.</span>
<span class="comment-copy">Also works in <code>lambda</code>s (while <code>del</code> doesn't).</span>
<span class="comment-copy">"del" is ok, but "pop" seems more "Pythonic", in my opinion.</span>
<span class="comment-copy">@ivanleoncz why?</span>
<span class="comment-copy"><code>pop</code> returns the value that was 'popped', which allows you to use this value for whatever further reason. If it's not more "Pythonic", I'd say that seems better, for sure :). It's not a dict, but it works the same way for both: <a href="https://github.com/ivanlmj/python-prototypes/blob/master/3.4/pop_list.py" rel="nofollow noreferrer">github.com/ivanlmj/python-prototypes/blob/master/3.4/…</a></span>
<span class="comment-copy">Really cool.  I like the quick method to filter a dictionary without defining a new function.</span>
<span class="comment-copy">Worth mentioning that only works on 2.7+</span>
<span class="comment-copy">For those not familiar with comprehensions, you can also do something like this: <code>{i:a[i] for i in a if i not in [0, 1, 2]}</code> if you want to remove several elements.</span>
<span class="comment-copy">Better would be <code>{k:v for k,v in a.items() if k != 0}</code> I think.</span>
<span class="comment-copy">The best solution for removing an item by key and returning the result of the new dict in the same line. For example if you need to use an an already constructed dict without a single item as <code>**kwargs</code>, <code>some_function(**{k:v for k,v in some_dict.items() if k not 'some_key'})</code></span>
<span class="comment-copy">@pythonian29033 , actually, <b>no</b>. The accepted answer works as expected — it returns the dict without one key. The approach from this answer mutates original dict;) There is a significat difference</span>
<span class="comment-copy">@arussell84, why <code>&gt;&gt;&gt;</code> is often used in the python-examples? Yeah, python-doc contains a lot of such things. But such code is <b>not convenient for copypaste</b>. I am confused...</span>
<span class="comment-copy">@maxkoryukov yup it does! but that function and this answer is exactly the same, with the exception of that answer being inside of a function.  and you must not have been coding in python for a while, the <code>&gt;&gt;&gt;</code> mimics the listening notation from python in cli mode</span>
<span class="comment-copy">@pythonian29033 about <code>&gt;&gt;&gt;</code>. Yes, it is REPL-style, but let's talk frankly: the only one man had wrote this sample, and 1000 have read this. I think, it would be great to write examples in the way allowing easy copy and run. I don't like to remove this angle brackets by hand. Or copy line by line.. So I don't understand: why this angles are still there))) May be I don't know something?</span>
<span class="comment-copy">I've added a function that can be copy/pasted, for your convenience.</span>
<span class="comment-copy">Hmm, no, in production it is better to follow <a href="https://docs.python.org/2/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> ideology. Just remove key in <code>try-except</code> block. At least, this will be an atomic operation;)</span>
<span class="comment-copy">And if you want to be concise — use <code>d.pop('key', None)</code> , it is oneliner. But the actual question was about getting the dictionary without one key, and not about modifying the dict. So <a href="https://stackoverflow.com/a/5844700/1115187">comprehensions</a> - is a good choice here;)</span>
<span class="comment-copy">You have a good point about memory usage; I never thought of that.</span>
<span class="comment-copy">How is your method any different than just <code>del test_dict[key]</code>?</span>
<span class="comment-copy">Will give wrong results for falsy values.</span>
<span class="comment-copy">If you're going to answer a years-old question that already has a simple, appropriate, accepted answer, at least make sure your answer is right. This doesn't do what the OP asked for.</span>
<span class="comment-copy">I don't generally check dates on questions I think could have valuable info added to them. Additionally, per one of the comments on the question I linked to: "Usually this is exactly what someone wants and is probably what the OP needs, but it is not what the OP asked for" <a href="http://stackoverflow.com/questions/12118695/efficient-way-to-remove-keys-with-empty-values-from-a-dict#comment16203889_12118700" title="efficient way to remove keys with empty values from a dict%23comment16203889_12118700">stackoverflow.com/questions/12118695/…</a> I knew it wasn't a direct answer to the question; rather an expansion to the options.</span>
<span class="comment-copy">This answer, although not complete, lets us learn that we can remove items with if conditions too. just changing <code>if v</code> to <code>if k is not 'a'</code> answers the op. But i don't think that's an efficient way, this removes the element in O(n) rather than O(log n) as pop or del does.</span>
