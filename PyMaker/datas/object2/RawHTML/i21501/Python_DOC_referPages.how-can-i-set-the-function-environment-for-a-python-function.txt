<div class="post-text" itemprop="text">
<p>In Lua, there's a built-in function called <code>setfenv()</code>, which allows you to supply a table of variables as an environment for a function.  Here's an example that uses it:</p>
<pre class="lang-lua prettyprint-override"><code>foo = 1
function f()
    print(blech) --Note that no variable named blech has been defined.
end
variableTable = {blech = foo}
setfenv(f, variableTable)
f() -- This will work and print 1, because blech has been defined as foo's value in the variableTable
</code></pre>
<p>My motivation for doing this is that it allows me to set up a platform so that users can write easy-to-understand scripts in Lua (they can write nullary functions and can simply trust that variables will be there for them).  It also provides an elegant method of excluding modules and functions that I don't want them to use for security reason (e.g. if you define a variable table that doesn't have the os module defined, there's no way a more knowledgeable user could use it maliciously).</p>
<p>I would like to be able to achieve the same thing in Python.  Is there something similar that can be done in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>There's <code>exec</code>:</p>
<pre><code>def foo():
    print bar

exec foo.func_code in {"bar": "baz"}
</code></pre>
<p>This isn't particularly good style (I would even say that it is particularly bad).  It makes the implementation of <code>foo</code> difficult to understand since it relies on knowing about the special way in which it will be called.  Instead, pass arguments to functions.</p>
<p>This <em>does not</em> provide any measure of security.  As a first approximation, Python does not include any restricted execution capabilities.  Nothing stops a user from supplying this definition of foo instead:</p>
<pre><code>def foo():
    import os
    os.system("rm -rf /")
</code></pre>
<p>Just because you didn't supply <code>os</code> in the mapping doesn't mean they can't go get it themselves.  If you really need restricted execution, then you might want to stick with Lua, or at least investigate <a href="http://codespeak.net/pypy/dist/pypy/doc/sandbox.html" rel="nofollow">PyPy sandboxed mode</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why would you ever want to do that? Did your code become <em>too readable</em>?<br/>
Just pass a dict or a struct with your 'env' to the function.</p>
<p><strong>EDIT</strong>: read your motivation. First part i cannot understand (writing lua scripts in python? what does that mean?), the second is plain wrong. This is no way to restrict enviroment. For one, you can still <code>import os</code>.<br/>
Restricted execution is kinda a complex topic. Some stuff i know of:  </p>
<ol>
<li>Python restricted module - <a href="http://docs.python.org/library/restricted.html" rel="nofollow">http://docs.python.org/library/restricted.html</a>. Deprecated.  </li>
<li>An outdated wiki page - <a href="http://wiki.python.org/moin/SandboxedPython" rel="nofollow">http://wiki.python.org/moin/SandboxedPython</a>. Nothing insanely useful there.  </li>
<li>PyPy. This is probably the way to go. PyPy sandbox docs: <a href="http://codespeak.net/pypy/dist/pypy/doc/sandbox.html" rel="nofollow">http://codespeak.net/pypy/dist/pypy/doc/sandbox.html</a></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure why you'd want to do this, but here is one hacky way:</p>
<pre><code>def foo():
    print bar
foo.func_globals['bar'] = 1
foo()
</code></pre>
<p>Caveat: This is not something I recommend doing.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know of any sane way to do that. Just use function arguments.</p>
<pre><code>def f(blech):
    print(blech)
</code></pre>
<p>If you want it to have many variables, stick them in a <code>dict</code> and pass that.</p>
<pre><code>def f(vars):
    print(vars['blech'])
    print(vars['fizz'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can have your function take an extra value that is a blob of keyword arguments:</p>
<pre><code>def printKeyValuePairs(preface, **kwargs):
    print preface + "\n"

    for k,v in kwargs.iteritems():
        print k + ": " + v + "\n"

# usage
printKeyValuePairs("Here are my key-value pairs:", One=1, Two=2, Three=3)
# prints:
# Here are my key-value pairs:
# One: 1
# Two: 2
# Three: 3
# (note that the above lines could be ordered any which way... might want to
# sort first if it matters)
</code></pre>
</div>
<span class="comment-copy">Iâ€™ve used this to execute a (short) <i>file</i>, where there is no parameter list, to good effect.</span>
<span class="comment-copy">Thanks for the answer.  I made an edit a little while ago explaining my motivation for doing this; maybe you know of a different way of achieving this goal?</span>
<span class="comment-copy">I see, so you'd want something like <a href="http://docs.python.org/library/functions.html#execfile" rel="nofollow noreferrer"><code>execfile()</code></a>, where you can specify your own values for <code>globals</code> on the call. The restricted execution part will be harder; here is some <a href="http://lwn.net/Articles/321872/" rel="nofollow noreferrer">background on how work to revive it and make it work</a>.</span>
<span class="comment-copy">That just has the same effect as assigning <code>bar</code> outside the function.</span>
<span class="comment-copy">As of Python 3.6, the order of keyword arguments is <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep468" rel="nofollow noreferrer">guaranteed to be preserved</a>.</span>
