<div class="post-text" itemprop="text">
<p>I find myself writing a lot of functions that I want to be able to operate on arguments <code>x, y, ...</code>, <strong>and</strong> on collections of e.g. <code>[(x1, y1, ...), (x2, y2, ...), ...]</code>.</p>
<p>Is there a clear and simple decorator, pattern or technique for writing functions like this? </p>
<p>Here's an arbitrary example:</p>
<pre><code>def awesome(func):
    # ???

@awesome
def mult(a, b):
    return a * b

mult(3, 4)                      # should return 12
mult((3, 4))                    # should return 12 or possibly (12,)
mult(((3, 4), (2, 3), [3, 3]))  # should return (12, 6, 9)
mult([(3, 4), [4, 5]])          # should return (12, 20)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.4 introduces <a href="http://python.org/dev/peps/pep-0443/" rel="nofollow">single-dispatch generic functions</a> with the <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow"><code>@singledispatch</code></a> decorator, providing a simple way to implement different behaviours when calling the same function with different argument types. For example, to allow your <code>mult()</code> function to accept iterables:</p>
<pre><code>from functools import singledispatch
from collections.abc import Iterable

@singledispatch
def mult(a, b):
    return a * b

@mult.register(Iterable)
def _(it):
    return [mult(a, b) for a, b in it]
</code></pre>
<p>The 'base' version of your function is decorated with <code>@singledispatch</code>, transforming it into a generic function. Next, a function <code>_()</code> is defined to call <code>mult()</code> on each element in an iterable, and registered to the generic function with <code>@mult.register()</code>.</p>
<p>Although the example above uses <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow"><code>collections.abc.Iterable</code></a> for the sake of maximum generality, it's also possible to register a function for multiple concrete types:</p>
<pre><code>@mult.register(list)
@mult.register(tuple)
def _(it):
    return [mult(a, b) for a, b in it]
</code></pre>
<p>Using the technique above, it's possible to write a decorator <code>@takes_iterable</code> which transforms an arbitrary function into a generic function, and registers another function to it to handle iterables appropriately:</p>
<pre><code>def takes_iterable(func):
    generic = singledispatch(func)
    @generic.register(Iterable)
    def _(it):
        return [func(*args) for args in it]
    return generic

@takes_iterable
def mult(a, b):
    return a * b
</code></pre>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; mult(17,23)
391
&gt;&gt;&gt; mult([(11, 29), (13, 23), (17, 19)])
[319, 299, 323]
</code></pre>
<p><strong>CAVEAT</strong>: As pointed out by Blckknght in comments, you'll get unexpected results if you call a function decorated with <code>@takes_iterable</code> intending it to run in "single" mode, but passing it an argument that happens to be iterable, like a string.</p>
<p>That's really a result of the ambiguity inherent in the behaviour requested in the question rather than the implementation outlined here, but it's worth bearing in mind when considering whether to use this technique.</p>
</div>
<span class="comment-copy">The whole idea is not great since you'd end up with no idea what goes in and out of this function, which makes it harder to find bugs. Just type the <code>(mul(*x) for x in xs)</code></span>
<span class="comment-copy">yup, that makes sense. UP.</span>
<span class="comment-copy">Why don't we just use ducttyping and operator overloading? Seems much more intuitive and pythonic</span>
<span class="comment-copy">One complexity to this is that strings are iterable. So if the original function takes a single string as its argument, there's no way for the code to tell if <code>func("abc")</code> should be a single call or three calls <code>func("a"); func("b"); func("c")</code>.</span>
<span class="comment-copy">@Blckknght that's a good point (expanding on Jochen Ritzel's <a href="http://stackoverflow.com/questions/6128227/can-a-python-decorator-make-a-function-able-to-operate-on-single-objects-and-col/24111648?noredirect=1#comment7111301_6128227">comment</a> above). I've updated the answer with a caveat to that effect.</span>
