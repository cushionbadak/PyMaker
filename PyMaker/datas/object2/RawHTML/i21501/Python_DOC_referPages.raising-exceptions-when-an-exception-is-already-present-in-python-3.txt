<div class="post-text" itemprop="text">
<p>What happens to my first exception (<code>A</code>) when the second (<code>B</code>) is raised in the following code?</p>
<pre><code>class A(Exception): pass
class B(Exception): pass

try:
    try:
        raise A('first')
    finally:
        raise B('second')
except X as c:
    print(c)
</code></pre>
<p>If run with <code>X = A</code> I get:</p>
<pre>Traceback (most recent call last):
  File "raising_more_exceptions.py", line 6, in 
    raise A('first')
__main__.A: first

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "raising_more_exceptions.py", line 8, in 
    raise B('second')
__main__.B: second</pre>
<p>But if <code>X = B</code> I get:</p>
<pre>second</pre>
<h1>Questions</h1>
<ol>
<li>Where did my first exception go?</li>
<li>Why is only the outermost exception catchable?</li>
<li>How do I peel off the outermost exception and reraise the earlier exceptions?</li>
</ol>
<h1>Update0</h1>
<p>This question specifically addresses Python 3, as its exception handling is quite different to Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Answering to question 3, you can use:</p>
<pre><code>raise B('second') from None
</code></pre>
<p>Which will remove the exception <code>A</code> traceback.</p>
<pre><code>Traceback (most recent call last):
  File "raising_more_exceptions.py", line 8, in 
    raise B('second')
__main__.B: second
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Pythons exception handling will only deal with one exception at a time. However, exception objects are subject to the same variable rules and garbage collection as everything else. Hence, if you save the exception object in a variable somewhere you can deal with it later, even if another exception is raised.</p>
<p>In your case, when an exception is raised during the "finally" statement, Python 3 will print out the traceback of the first exception before the one of the second exception, to be more helpful.</p>
<p>A more common case is that you want to raise an exception during an explicit exception handling. Then you can "save" the exception in the next exception. Just pass it in as a parameter:</p>
<pre><code>&gt;&gt;&gt; class A(Exception):
...     pass
... 
&gt;&gt;&gt; class B(Exception):
...     pass
... 
&gt;&gt;&gt; try:
...     try:
...         raise A('first')
...     except A as e:
...         raise B('second', e)
... except Exception as c:
...     print(c.args[1])
... 
first
</code></pre>
<p>As you see you can now access the original exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>The 'causing' exception is available as c.__context__ in your last exception handler. Python is using this information to render a more useful traceback. Under Python 2.x the original exception would have been lost, this is for Python 3 only.</p>
<p>Typically you would use this to throw a consistent exception while still keeping the original exception accessible (although it's pretty cool that it happens automatically from an exception handler, I didn't know that!):</p>
<pre><code>try:
    do_something_involving_http()
except (URLError, socket.timeout) as ex:
    raise MyError('Network error') from ex
</code></pre>
<p>More info (and some other pretty useful things you can do) here: <a href="http://docs.python.org/3.3/library/exceptions.html">http://docs.python.org/3.3/library/exceptions.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I believe all the ingredients to answer your question(s) are already in the existing answers. Let me combine and elaborate.</p>
<p>Let me repeat your question's code to provide line number references:</p>
<pre><code> 1  class A(Exception): pass
 2  class B(Exception): pass
 3 
 4  try:
 5      try:
 6          raise A('first')
 7      finally:
 8          raise B('second')
 9  except X as c:
10      print(c)
</code></pre>
<p>So to answer your questions:</p>
<ol>
<li>Where did my first exception go?</li>
</ol>
<p>Your first exception <code>A</code> is raised in line 6. The <code>finally</code> clause in line 7 is <em>always</em> executed as soon as the <code>try</code> block (lines 5-6) is left, regardless if it is left because of successful completion or because of a raised exception.
While the <code>finally</code> clause is being executed, line 8 raises another exception <code>B</code>. As Lennart and Ignazio have pointed out, only one exception, the one that is most recently being raised, can be kept track of. So as soon as <code>B</code> is raised, the overall <code>try</code> block (lines 4-8) is quit and the exception <code>B</code> is being caught by the <code>except</code> statement in line 9 if it matches (if <code>X</code> is <code>B</code>).</p>
<ol start="2">
<li>Why is only the outermost exception catchable?</li>
</ol>
<p>Hopefully this is clear now from my explanation of 1. You could catch the inner/lower/first exception, though. To merge in Lennart's answer, slightly modified, here's how to catch both:</p>
<pre><code>class A(Exception): pass
class B(Exception): pass
try:
    try:
        raise A('first')
    except A as e:
        raise B('second', e)
except Exception as c:
    print(c)
</code></pre>
<p>The output is:</p>
<pre><code>('second', A('first',))
</code></pre>
<ol start="3">
<li>How do I peel off the outermost exception and reraise the earlier exceptions?</li>
</ol>
<p>In Lennart's example the solution to this question is the line <code>except A as e</code> where the inner/lower/first exception is being caught and stored in variable <code>e</code>.</p>
<p>As a general gut-feeling of when to catch exceptions, when to ignore them, and when to re-raise, maybe <a href="https://stackoverflow.com/q/2913819/923794">this question and Alex Martelli's answer</a> help.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>It got thrown out.</li>
<li>Only one exception can be "active" at a time per thread.</li>
<li>You can't, unless you encapsulate the earlier exception in the later exception somehow.</li>
</ol>
</div>
<span class="comment-copy">The answers seem to be neglecting the fact that I'm still getting a full traceback when the exception is not caught. Please explain?</span>
<span class="comment-copy">Thanks, this solved my issue... wanted to raise a custom exception from a KeyError in a base class method. My List is a sub class attribute and sub class objects are dynamically generated. The default KeyError trackback didn't say which sub class the error occurred in, so I wanted to suppress it and raise a new exception with more info. "Raise X from None" allows me to do this.</span>
<span class="comment-copy">If you want to save original traceback you can use: raise OtherException(...).with_traceback(tb) as described in docs <a href="https://docs.python.org/3/library/exceptions.html#BaseException" rel="nofollow noreferrer">docs.python.org/3/library/exceptions.html#BaseException</a></span>
<span class="comment-copy">Can you answer part 1?</span>
<span class="comment-copy">@Matt: It doesn't go anywhere. I do realize I had a brainfart and updated my answer, though.</span>
<span class="comment-copy">How does one handle this situation in doctests?</span>
<span class="comment-copy">Or can use <code>raise x from y</code>?</span>
<span class="comment-copy">If you only support Python 3, yes. Which is reasonable now, but not in 2011.</span>
<span class="comment-copy">If it got thrown out, why am I getting a full traceback when the exception is not caught?</span>
<span class="comment-copy">Because the tool that you're using to run the script has installed a global exception handler, and it has noticed the double exception.</span>
<span class="comment-copy">What tool.....?</span>
<span class="comment-copy">I see now, Python 3.x has different behavior. It is the interpreter itself catching it. In 2.x the first exception is silently dropped.</span>
