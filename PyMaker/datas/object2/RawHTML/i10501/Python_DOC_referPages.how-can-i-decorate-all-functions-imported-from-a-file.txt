<div class="post-text" itemprop="text">
<p>I have created many functions that are divided into different files, now I would like to apply the same decorator for all of them without modifying the files and without applying the decorators one by one.</p>
<p>I have tried to use <a href="https://stackoverflow.com/questions/6307761/how-can-i-decorate-all-functions-of-a-class-without-typing-it-over-and-over-for">this explanation</a> written by delnan, but I got no success for imported functions.</p>
<p>About the decorator, it must update a list every time a function within a class is executexecuted with the function arguments and values, just like <a href="https://stackoverflow.com/questions/39154006/update-a-list-every-time-a-function-within-a-class-is-executexecuted-with-the-fu">this other question</a> I asked.</p>
<p>Any suggestions to help me with this issue?
Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>A little bit of introspection (<a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow"><code>dir()</code></a>) and dynamic look-up with <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr()</code></a> and <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow"><code>setattr()</code></a>.</p>
<p>First we iterate over all names found in module and <a href="https://docs.python.org/3/library/types.html#types.FunctionType" rel="nofollow">check for objects that look like functions</a>. After that we simply reassign old function with decorated one.</p>
<p><strong>main.py:</strong></p>
<pre><code>import types
import functools

def decorate_all_in_module(module, decorator):
    for name in dir(module):
        obj = getattr(module, name)
        if isinstance(obj, types.FunctionType):
            setattr(module, name, decorator(obj))

def my_decorator(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        print(f)
        return f(*args, **kwargs)
    return wrapper

import mymod1
decorate_all_in_module(mymod1, decorator)
</code></pre>
<p><strong>mymod1.py</strong>:</p>
<pre><code>def f(x):
    print(x)


def g(x, y):
    print(x + y)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&lt;function f at 0x101e309d8&gt;
2
&lt;function g at 0x101e30a60&gt;
7
</code></pre>
<p>Process does not goes that smooth if you use star imports (<code>from mymod import *</code>). Reason is simple - because all names are in one huge bag and there no differentiation on where they come from, you need a lot of additional tricks to find what exactly you want to patch. But, well, that's why we use namespaces - <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow">because they are one honking great idea</a>.</p>
</div>
<span class="comment-copy">How are you doing the import? Are you just doing the module, or are you doing individual functions or an <code>from foo import *</code> etc...</span>
<span class="comment-copy">Are they just functions or are they methods of classes in the files?</span>
<span class="comment-copy">The imports are done like <code>from modules import module1</code> and they are just function inside  files.</span>
<span class="comment-copy">Thank you for the help.</span>
<span class="comment-copy">Thank you for your help, it worked fine.  In fact, I asked this question to complete <a href="http://stackoverflow.com/questions/39154006/update-a-list-every-time-a-function-within-a-class-is-executexecuted-with-the-fu">another question</a> I had asked. I thought I could solve my problem from this, but it was not the case. I would like my decorator to save the args and function name every time some function from the imported class is ran. Could you help me with this new subject?</span>
<span class="comment-copy">You want do decorate all methods of class? Process is fairly similar, you do <code>dir(class)</code> and look for methods and not functions. I'm quite sure you can figure that out yourself based on template above.</span>
<span class="comment-copy">Ok, thank you so much.  I have used python as a free tool to replace Matlab, until now I have used it only as a numerical tool. I see I still have a lot to learn, but nothing to take away my will to learn it. Again, thank you.</span>
