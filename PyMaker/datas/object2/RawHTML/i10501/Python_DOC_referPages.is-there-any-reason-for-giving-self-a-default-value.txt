<div class="post-text" itemprop="text">
<p>I was browsing through some code, and I noticed a line that caught my attention. The code is similar to the example below</p>
<pre><code>class MyClass:
    def __init__(self):
        pass

    def call_me(self=''):
        print(self)
</code></pre>
<p>This looks like any other class that I have seen, however a <code>str</code> is being passed in as default value for <code>self</code>. </p>
<p>If I print out <code>self</code>, it behaves as normal</p>
<pre><code>&gt;&gt;&gt; MyClass().call_me()
&lt;__main__.MyClass object at 0x000002A12E7CA908&gt;
</code></pre>
<p>This has been bugging me and I cannot figure out why this would be used. Is there any reason to why a <code>str</code> instance would be passed in as a default value for <code>self?</code></p>
</div>
<div class="post-text" itemprop="text">
<p><em>Not really</em>, it's just an <em>odd</em> way of making it not raise an error when called via the class:</p>
<pre><code>MyClass.call_me()
</code></pre>
<p>works fine since, even though nothing is implicitly passed as with instances, the default value for that argument is provided. If no default was provided, when called, this would of course raise the <code>TypeError</code> for args we all love. As to why he chose an empty string as the value, <em>only he knows</em>.</p>
<p>Bottom line, this is more <em>confusing</em> than it is practical. If you need to do something similar I'd advice a simple <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="noreferrer"><code>staticmethod</code></a> with a default argument to achieve a similar effect. </p>
<p>That way <em>you don't stump anyone reading your code</em> (like the developer who wrote this did with you ;-):</p>
<pre><code>@staticmethod
def call_me(a=''):
    print(a)
</code></pre>
<p>If instead you need access to class attributes you could always opt for the <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="noreferrer"><code>classmethod</code></a> decorator. Both these (<code>class</code> and <code>static</code> decorators) also serve a secondary purpose of making your intent crystal clear to others reading your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is yes. That way, you can call the function as: </p>
<pre><code>MyClass.call_me()
</code></pre>
<p>without instantiating <code>MyClass</code>, that will print an empty string.</p>
<p>To give a longer answer, we need to look at what is going on behind the scenes.</p>
<p>When you create an instance of the class, <code>__new__</code> and <code>__init__</code> are called to create it, that is:</p>
<pre><code>a = MyClass()
</code></pre>
<p>is roughly equivalent to:</p>
<pre><code>a = MyClass.__new__(MyClass)
MyClass.__init__(a)
</code></pre>
<p>Whenever you use some method on a created instance <code>a</code>:</p>
<pre><code>a.call_me()
</code></pre>
<p>It is "replaced" with <code>MyClass.call_me(a)</code>.</p>
<p>So, having a default parameter for <code>call_me</code> allows you to call this function not only as a method of an instance, in which case <code>self</code> is an instance itself, but also as a static class method.</p>
<p>That way, instead of <code>MyClass.call_me(a)</code>, just <code>MyClass.call_me()</code> is called. Because the argument list is empty, the default argument is assigned to <code>self</code> and the desired result (empty string) is printed.</p>
</div>
<span class="comment-copy">Sounds like someone wanted to have <code>MyClass.call_me()</code> work too. Not a particularly good idea however, they could have made it a <code>classmethod</code> instead.</span>
<span class="comment-copy">If <code>call_me</code> is called from the class itself and not from an instance, then <code>''</code> is passed as the instance, and the method call will not raise an error.</span>
