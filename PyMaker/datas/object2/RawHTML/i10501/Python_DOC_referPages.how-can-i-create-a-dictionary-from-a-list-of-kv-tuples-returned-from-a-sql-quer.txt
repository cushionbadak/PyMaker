<div class="post-text" itemprop="text">
<p>My SQL (sqlite3) query is along the lines of this:</p>
<pre><code>SELECT id, name FROM mytable;
</code></pre>
<p>This returns a ton of rows.  I would like to create a dictionary from these results, where I can lookup the name given an id.</p>
<p>Other answers I've found seem to create dictionaries based on SQL results, but they use the column label as the key -- I have no interest in that.</p>
<p>Example table:</p>
<pre><code>id    | name
------+--------
foo   | bar
baz   | foobar
</code></pre>
<p>Desired dict:</p>
<pre><code>{
    'foo': 'bar',
    'baz': 'foobar'
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The result returned from cursor is a list of 2-elements tuples so you can just convert that to a dictionary as the first item of each tuple is a unique value:</p>
<pre><code>result = dict(cursor.execute("SELECT id, name FROM mytable"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can loop over the rows (the <a href="https://docs.python.org/3/library/sqlite3.html#module-sqlite3" rel="nofollow">result cursor is iterable</a>), <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow">unpack</a> the key and value, then assemble the result using a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow">dict comprehension</a>:</p>
<pre><code>desired_dict = {k:v for k, v in c.execute('SELECT id, name FROM MyTable')}
</code></pre>
<p>I like using dict comprehensions because I can do additional processing to the results before adding to the dictionary (for example changing case, converting to decimal or datetime, etc).</p>
<p>That said, if you want to go directly to the dict, <em>ozgur</em> has the shorter, faster way which is to call <a href="https://docs.python.org/3/library/functions.html#func-dict" rel="nofollow"><em>dict()</em></a> directly:</p>
<pre><code>desired_dict = dict(c.execute('SELECT id, name FROM MyTable'))
</code></pre>
<p>Here's an actual sample session demonstrating the process start to finish:</p>
<pre><code>&gt;&gt;&gt; import sqlite3
&gt;&gt;&gt; c = sqlite3.connect('tmp.db')
&gt;&gt;&gt; c.execute('CREATE TABLE MyTable (id text, name text)')
&lt;sqlite3.Cursor object at 0x106227f80&gt;
&gt;&gt;&gt; c.execute("INSERT INTO MyTable VALUES ('abc', 'Alpha')")
&lt;sqlite3.Cursor object at 0x106283810&gt;
&gt;&gt;&gt; c.execute("INSERT INTO MyTable VALUES ('def', 'Beta')")
&lt;sqlite3.Cursor object at 0x106227f80&gt;
&gt;&gt;&gt; c.execute("INSERT INTO MyTable VALUES ('ghi', 'Gamma')")
&lt;sqlite3.Cursor object at 0x106283810&gt;
&gt;&gt;&gt; c.commit()
&gt;&gt;&gt; c.close()
&gt;&gt;&gt; 
&gt;&gt;&gt; c = sqlite3.connect('tmp.db')
&gt;&gt;&gt; {k:v for k, v in c.execute('SELECT id, name FROM MyTable')}
{'ghi': 'Gamma', 'def': 'Beta', 'abc': 'Alpha'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Suppose you get your sql query result in Python, something like</p>
<p><code>db_conn = sqlite3.connect('text.db')
cur = db_conn.cursor()
cur.execute('''select id, name from mytable''')</code></p>
<p>Then you can get all the query results in the return of <code>cur.fetchall()</code>.
The result will be a list of tuples, each tuple will be like (<em>id</em>,<em>name</em>).</p>
<p>Knowing this, then it is a piece of cake to transform it into an dictionary,just:</p>
<p><code>mydict = {}
for item in cur.fetchall():
    mydict[item[0]] = item[1]
</code></p>
</div>
<span class="comment-copy">Give a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> please.</span>
<span class="comment-copy">@JulienBernu done.</span>
<span class="comment-copy">Use a <a href="https://docs.python.org/3/reference/expressions.html?highlight=displays#displays-for-lists-sets-and-dictionaries" rel="nofollow noreferrer"><code>dictionary comprehension</code></a></span>
<span class="comment-copy">I tried this, didn't work.  I get this error: ValueError: dictionary update sequence element #0 has length 1; 2 is required</span>
<span class="comment-copy">Nope, the query I listed is verbatim the same query (with a different table name, but that's it).</span>
<span class="comment-copy">How does the query result look like?</span>
<span class="comment-copy">It seems to be returning a list of dicts.  So I think the error is related to the fact that there's only one element (a dict) that's returned.</span>
<span class="comment-copy">I figured out the problem.  I was using a row_factory (provided from another answer) that was messing with the output.  Thanks for your help.</span>
<span class="comment-copy">Using your original suggestion, I get this error: ValueError: need more than 1 value to unpack</span>
<span class="comment-copy">@ComtriS I added an actual session to demonstrate all the steps start to finish.  How that helps you work out the kinks :-)</span>
