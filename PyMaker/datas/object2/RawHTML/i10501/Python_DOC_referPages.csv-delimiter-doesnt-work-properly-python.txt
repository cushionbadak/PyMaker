<div class="post-text" itemprop="text">
<pre><code>import csv

base='eest1@mail.ru,username1\
test2@gmail.com,username2\
test3@gmail.com,username3\
test4@rambler.ru,username4\
test5@ya.ru,username5'

parsed=csv.reader(base, delimiter=',')
for p in parsed:
    print p
</code></pre>
<p>Returns:</p>
<pre><code>['e']
['e']
['s']
['t']
['1']
['@']
['m']
['a']
['i']
['l']
['.']
['r']
['u']
['', ''] 
</code></pre>
<p>etc...</p>
<p>How I can get data separated by comma ?
('test1@gmail.com', 'username1'),
('test2@gmail.com', 'username2'),
...</p>
</div>
<div class="post-text" itemprop="text">
<p>I think csv only works with file like objects.  You can use StringIO in this case.</p>
<pre><code>import csv
import StringIO

base='''eest1@mail.ru,username
test2@gmail.com,username2
test3@gmail.com,username3
test4@rambler.ru,username4
test5@ya.ru,username5'''

parsed=csv.reader(StringIO.StringIO(base), delimiter=',')
for p in parsed:
    print p
</code></pre>
<p>OUTPUT</p>
<pre><code>['eest1@mail.ru', 'username']
['test2@gmail.com', 'username2']
['test3@gmail.com', 'username3']
['test4@rambler.ru', 'username4']
['test5@ya.ru', 'username5']
</code></pre>
<p>Also, your example string does not have newlines, so you would get</p>
<pre><code>['eest1@mail.ru', 'usernametest2@gmail.com', 'username2test3@gmail.com', 'username3test4@rambler.ru', 'username4test5@ya.ru', 'username5']
</code></pre>
<p>You can use the <code>'''</code> like I did, or change your <code>base</code> like</p>
<pre><code>base='eest1@mail.ru,username\n\
test2@gmail.com,username2\n\
test3@gmail.com,username3\n\
test4@rambler.ru,username4\n\
test5@ya.ru,username5'
</code></pre>
<p><strong>EDIT</strong><br/>
According to the docs, the argument can be either a file-like objet OR a list.  So this works too</p>
<pre><code>parsed=csv.reader(base.splitlines(), delimiter=',')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quoting <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow">official docs on csv module</a> (<strong>emphasis mine</strong>):</p>
<blockquote>
<p><code>csv.reader(csvfile, dialect='excel', **fmtparams)</code></p>
<p>Return a reader object which will iterate over lines in the given
  <code>csvfile</code>. <strong><code>csvfile</code> can be any object which supports the iterator
  protocol and returns a string each time its <code>__next__()</code> method is
  called â€” file objects and list objects are both suitable.</strong></p>
</blockquote>
<p>Strings supports iterator, but it yields <em>characters</em> from string one by one, not lines from multi-line string.</p>
<pre><code>&gt;&gt;&gt; s = "abcdef"
&gt;&gt;&gt; i = iter(s)
&gt;&gt;&gt; next(i)
'a'
&gt;&gt;&gt; next(i)
'b'
&gt;&gt;&gt; next(i)
'c'
</code></pre>
<p>So the task is to create iterator, which would yield <em>lines</em> and not <em>characters</em> on each iterations. Unfortunately, your string literal is not a multiline string.</p>
<pre><code>base='eest1@mail.ru,username1\
test2@gmail.com,username2\
test3@gmail.com,username3\
test4@rambler.ru,username4\
test5@ya.ru,username5'
</code></pre>
<p>is equivalent to:</p>
<pre><code>base = 'eest1@mail.ru,username1test2@gmail.com,username2test3@gmail.com,username3test4@rambler.ru,username4test5@ya.ru,username5
</code></pre>
<p>Esentially you do not have information required to parse that string correctly. Try using multiline string literal instead:</p>
<pre><code>base='''eest1@mail.ru,username1
test2@gmail.com,username2
test3@gmail.com,username3
test4@rambler.ru,username4
test5@ya.ru,username5'''
</code></pre>
<p>After this change you may split your string by newlines characters and everything should work fine:</p>
<pre><code>parsed=csv.reader(base.splitlines(), delimiter=',')
for p in parsed:
    print(p)
</code></pre>
</div>
