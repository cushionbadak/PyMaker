<div class="post-text" itemprop="text">
<p>In my real-life problem, I multiply the size of a widget, with a <code>size_hint</code> which can be anything from <code>0.</code> to <code>1.</code>. Assuming the minimum size of a widget is <code>0</code> and the max size is <code>10,000</code>, on which digit should I expect the error to occur, when I multiply <code>size * size_hint</code>? </p>
<p>For example* on <code>0.1</code> the error occurs on the.. </p>
<pre><code>&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; Decimal.from_float(.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')
#                           ^ 
#                           |_ here 
</code></pre>
<p>.. 18th decimal digit.</p>
<p>On the other hand, the error below occurs on the 14th decimal </p>
<pre><code>&gt;&gt;&gt; 1001*.2
200.20000000000002
</code></pre>
<p><strong>Questions</strong>:   </p>
<ul>
<li>Is there a way to determine on which exactly decimal digit the error will occur? </li>
<li>Is there a difference between Python 2 and Python 3?</li>
</ul>
<p>Using decimals instead of floats is not a option, and that both <code>size</code> and <code>size_hint</code> are provided by the user.</p>
<hr/>
<p>*<sub>  I used <a href="https://docs.python.org/3.5/library/fractions.html" rel="nofollow"><code>Fraction</code></a> since <code>&gt;&gt;&gt; 0.1</code> is displayed as.. <code>0.1</code> in the console, but I think this is related to how it's printed, not how it's stored. </sub></p>
</div>
<div class="post-text" itemprop="text">
<p>If we assume that the size of the widget is stored exactly, then there are 2 sources of error: the conversion of <code>size_hint</code> from decimal -&gt; binary, and the multiplication. In Python, these should both be correctly rounded to nearest, so each should have relative error of half an ulp (<a href="https://en.wikipedia.org/wiki/Unit_in_the_last_place" rel="nofollow">unit in the last place</a>). Since the second operation is a multiplication we can just add the bounds to get a total relative error which will be bounded 1 ulp, or 2<sup>-53</sup>.</p>
<p>Converting to decimal:</p>
<pre><code>&gt;&gt;&gt; math.trunc(math.log10(2.0**-53))
-15
</code></pre>
<p>this means you should be accurate to 15 significant figures.</p>
<p>There shouldn't be any difference between Python 2 and 3: Python has long been fairly strict about floating point behaviour, the only change I'm aware of is the behaviour of the <code>round</code> function, which isn't used here.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer the decimal to double-precision floating-point conversion part of your question...</p>
<p>The conversion of decimal fractions between 0.0 and 0.1 will be good to <a href="http://www.exploringbinary.com/decimal-precision-of-binary-floating-point-numbers/" rel="nofollow">15-16 decimal digits</a> (Note: you start counting at the first non-zero digit after the point.)</p>
<p>0.1 = 0.1000000000000000055511151231257827021181583404541015625 is good to 16 digits (rounded to 17 it is 0.10000000000000001; rounded to 16 it is 0.1).</p>
<p>0.2 = 0.200000000000000011102230246251565404236316680908203125 is also good to 16 digits.</p>
<p>(An example only good to 15 digits:</p>
<p>0.81 = 0.810000000000000053290705182007513940334320068359375)</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend you take a read to <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-485-a-function-for-testing-approximate-equality" rel="nofollow">pep485</a></p>
<p>Using <code>==</code> operator to compare floating-point values is not the right way to go, instead consider using <a href="https://docs.python.org/3/library/math.html#math.isclose" rel="nofollow">math.isclose</a> or <a href="https://docs.python.org/3/library/cmath.html#cmath.isclose" rel="nofollow">cmath.isclose</a>, here's a little example using your values:</p>
<pre><code>try:
    from math import isclose

    v1 = 101 * 1 / 5
    v2 = 101 * (1 / 5)
except:
    v1 = float(101) * float(1) / float(5)
    v2 = float(101) * (float(1) / float(5))

    def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
        return abs(a - b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)

print("v1==v2 {0}".format(v1 == v2))
print("isclose(v1,v2) {0}".format(isclose(v1, v2)))
</code></pre>
<p>As you can see, I'm explicitly casting to float in <strong>python 2.x</strong> and using the function provided in the documentation, with <strong>python 3.x</strong> I just use directly your values and the provided function from math module.</p>
</div>
<span class="comment-copy">15th digit is the last one that is guaranteed to be correct on any single decimal number. The errors accumulate, however. However if your number is a negative power of 2 it can be much more precise...</span>
<span class="comment-copy">@AnttiHaapala Are you sure? In the case of <code>1001*.2</code> the last correct digit is the 13th. Also, the <code>size_hint</code> is provided by the user and so powers of 2 aren't an option.</span>
<span class="comment-copy">@Fermiparadox the last digit <code>2</code> is the <i>17th</i> significant digit.</span>
<span class="comment-copy">@AnttiHaapala 17th significant? Shouldn't the <code>0</code> preceding the last <code>2</code> be considered significant so that <code>2</code> is rounded to <code>0</code>? I m having a hard time understanding what you mean by 15th digit. In my 2 examples, where do i start counting to 15, so that I detect the first "incorrect" (that is, that should be rounded) digit?</span>
<span class="comment-copy">@AnttiHaapala I think i got it. You meant to say that up to 15 <i>significant</i> digits or more will be correct.</span>
<span class="comment-copy">Doesn't this contradict the 2 examples in my question? First one has an error on the 18th decimal. Unless i misunderstood something.</span>
<span class="comment-copy">ah, I misunderstood. The 15 is just a lower bound, to figure out the exact number you would have to do something similar to your above calculation.</span>
<span class="comment-copy"><i>"..will be good to 15-16 decimal digits"</i> - I m assuming you mean  "significant" digits. Also, does the same hold true for floats in the <code>0.1</code> to <code>10000.</code> range?</span>
<span class="comment-copy">Yes, significant digits; and yes, 15-16 digits over that range too.</span>
<span class="comment-copy">I m afraid this does not answer either of my questions. The example at the top was provided just to show an issue i encountered, but if it is confusing i can remove it.</span>
<span class="comment-copy">@Fermiparadox The issue you found is because you're not comparing correctly floating point values, as I've already mentioned don't use <code>==</code> operator. Regarding to your questions 1) you could compare the string representation of your floating-point values to know the exact digit (unrecommended &amp; slow), nobody does that and 2) read <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">this</a></span>
<span class="comment-copy">@Fermiparadox Also, I'd recommend you take a read to <a href="http://gamedevs.org/uploads/numerical-robustness-geometric-calculations.pdf" rel="nofollow noreferrer">this</a>, it isn't python related though</span>
<span class="comment-copy">Thanks for the links, but as i already said the example was somewhat irrelevant of the actual goals of my question. I removed it in order to prevent further confusion.</span>
<span class="comment-copy">Relax dude, i only dved because this doesn't answer the question, not to punish you or anything. You can (being a grown adult) remove your answer, or change it so that it <i>does</i> answer the question. I don't care about rep, i ve deleted even  my upvoted posts if they are bad. Future visitors get deceived if votes are used for revenge.</span>
