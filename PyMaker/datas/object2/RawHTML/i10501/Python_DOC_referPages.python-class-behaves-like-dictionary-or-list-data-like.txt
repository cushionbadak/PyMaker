<div class="post-text" itemprop="text">
<p>In python3 console, input those:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version_info
sys.version_info(major=3, minor=4, micro=3, releaselevel='final', serial=0)
&gt;&gt;&gt; type(sys.version_info)  # this is class type
&lt;class 'sys.version_info'&gt;
&gt;&gt;&gt; sys.version_info[0:2]  # ?? But it acts like a list-data-like
(3, 4)
</code></pre>
<p>My questions are:</p>
<ol>
<li>How can a class act like dictionary-or-list-data-like? </li>
<li>May give an example to construct a class like this? </li>
<li>Is there some documentation about
this?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Python contains several methods for <a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types" rel="nofollow">emulating container types</a> such as dictionaries and lists. </p>
<p>In particular, consider the following class:</p>
<pre><code> class MyDict(object):
     def __getitem__(self, key):
          # Called for getting obj[key]

     def __setitem__(self, key, value):
          # Called for setting obj[key] = value
</code></pre>
<p>If you write</p>
<pre><code>obj = MyDict()
</code></pre>
<p>Then</p>
<pre><code>obj[3]
</code></pre>
<p>will call the first method, and</p>
<pre><code>obj[3] = 'foo'
</code></pre>
<p>will call the second method.</p>
<p>If you further want to support </p>
<pre><code>len(obj)
</code></pre>
<p>then you just need to add the method</p>
<pre><code>def __len__(self):
    # Return here the logical length
</code></pre>
<hr/>
<p>Here is an example of a (very inefficient) dictionary implemented by a list</p>
<pre><code>class MyDict(object):
    def __init__(self, seq=None):
        self._vals = list(seq) if seq is not None else []

    def __getitem__(self, key):
        return [v[1] for v in self._vals if v[0] == key][0]

    def __setitem__(self, key, val):
        self._vals = [v for v in self._vals if v[0] != key]
        self._vals.append((key, val))

    def __len__(self):
        return len(self._vals)
</code></pre>
<p>You can use it pretty much like a regular <code>dict</code>:</p>
<pre><code>obj = MyDict()
obj[2] = 'b'
&gt;&gt;&gt; obj[2]
'b'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's quite easy ... All you need to do is define a <code>__getitem__</code> method that handles slicing or integer/string lookup.  You can do pretty much whatever you want...</p>
<pre><code>class Foo(object):
    def __init__(self, bar, baz):
        self.bar = bar
        self.baz = baz
    def __getitem__(self, ix):
        return (self.bar, self.baz).__getitem__(ix)
</code></pre>
<p>Here's a cheat sheet of what will be passed to <code>__getitem__</code> as <code>ix</code> in the following situations:</p>
<pre><code>f[1]  # f.__getitem__(1)
f[1:]  # f.__getitem__(slice(1, None, None))
f[1:, 2]  # f.__getitem__( (slice(1, None, None), 2) )
f[1, 2]  # f.__getitem__( (1, 2) )
f[(1, 2)]  # f.__getitem__( (1, 2) )
</code></pre>
<p>The trick (which can be slightly non-trivial) is simply writing <code>__getitem__</code> so that it looks at the type of the object that was passed and then does the right thing.  For my answer, I cheated by creating a <code>tuple</code> in my <code>__getitem__</code> and then I called <code>__getitem__</code> on the tuple (since it already does the right thing in all of the cases that I wanted to support)</p>
<p>Here's some example usage:</p>
<pre><code>&gt;&gt;&gt; f = Foo(1, 2)
&gt;&gt;&gt; f[1]
2
&gt;&gt;&gt; f[0]
1
&gt;&gt;&gt; f[:]
(1, 2)
</code></pre>
<p>note that you don't <em>typically</em> need to even do this yourself.  You can create a <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow">named tuple</a> to do the job for you:</p>
<pre><code>from collections import namedtuple
Foo = namedtuple('Foo', 'bar, baz')
</code></pre>
<p>And usage is pretty much the same:</p>
<pre><code>&gt;&gt;&gt; f = Foo(1, 2)
&gt;&gt;&gt; f[1]
2
&gt;&gt;&gt; f[0]
1
&gt;&gt;&gt; f[:]
(1, 2)
</code></pre>
<p>The main difference here is that our namedtuple is immutable.  Once created, we can't change it's members.</p>
</div>
<div class="post-text" itemprop="text">
<p>i think in python like ECMAScript (aka javascript) class is a dictionary or <strong>associative array</strong>(<a href="https://en.wikipedia.org/wiki/Associative_array" rel="nofollow">associative array</a>). since you can add a property or method to your class at runtime.(<a href="http://slides.com/alirezaafzalaghaei/introduction-to-javascript#/7/3" rel="nofollow">see</a>)</p>
<pre><code>class A(object):
    def __init__(self):
        self.x = 0
a = A()
a.y=5
print a.y # 5
</code></pre>
<p>if you want write a class like that you can use <code>__getitem__</code> and <code>__setitem__</code> methods:</p>
<pre><code>class A(object):
    class B(object):
        def __init__(self, x, y):
            self.vals = (x, y)
        def __getitem__(self, key):
            return self.vals[key]
        def __setitem__(self, key, val):
            self.vals[key] = val
        def __len__(self):
            return len(self.__vals)
    def __init__(self, x, y):
        self.b = self.B(x,y)



a = A('foo','baz')

print type(a.b) # __main__.b     __main__ because we run script straightly
print a.b[:]    # ('foo', 'baz')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve the same behaviour by overriding <strong>getitem</strong>() and <strong>setitem</strong>() in your class.</p>
<pre><code>    class Example:
        def __getitem__(self, index):
            return index ** 2

    &gt;&gt;&gt; X = Example()
    &gt;&gt;&gt; X[2]                                
    &gt;&gt;&gt; 4
</code></pre>
<p>You can override <strong>setitem</strong>() too in your class for achieving the setter kind of thing. </p>
</div>
<span class="comment-copy">Note, this isn't behaving like a dictionary ... It's behaving a lot more like a sequence with named members.</span>
<span class="comment-copy">Yes, I agree with you. It's my mistake.@mgilson</span>
