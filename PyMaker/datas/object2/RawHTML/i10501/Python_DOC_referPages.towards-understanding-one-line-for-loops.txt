<div class="post-text" itemprop="text">
<p>After reading <a href="https://stackoverflow.com/questions/12920214/python-for-syntax-block-code-vs-single-line-generator-expressions">this</a> question, I have this PySpark code:</p>
<pre><code>model = KMeansModel(model.Cs[0])
first_split = split_vecs.map(lambda x: x[0])
model.computeCost(first_split)
model = KMeansModel(model.Cs[1])
second_split = split_vecs.map(lambda x: x[1])
model.computeCost(second_split)
</code></pre>
<p>Can I write this into a one-liner for loop? Or these loops are restricted in having <em>only one</em> line in their body?</p>
<p>Note: I am not looking for code-only answers, I want to learn, so please, explain. :)</p>
<hr/>
<p>Here is my tragic attempt:</p>
<pre><code>model.computeCost(split) for i in range(2): # &lt;- the semicolon here doesn't feel right..Where to put the other lines?
</code></pre>
<hr/>
<p>Edit:</p>
<p>Yes, I know that I can write a regular <a class="post-tag" href="/questions/tagged/for-loop" rel="tag" title="show questions tagged 'for-loop'">for-loop</a>, but I would like to understand one-liner for loops. This is for experimenting. You see, when reading others' people code, I see them often, and I am not comfortable with them... :/</p>
</div>
<div class="post-text" itemprop="text">
<p>A list comprehension version of what you did in that example would be:</p>
<pre><code>[KMeansModel(model.Cs[i]).computeCost(split_vecs.map(lambda x: x[i])) for i in range(2)]
</code></pre>
<p>This is no different than:</p>
<pre><code>results = []
for i in range(2):
    results.append(KMeansModel(model.Cs[i]).computeCost(split_vecs.map(lambda x: x[i])))
</code></pre>
<p>So for each <code>i</code>, it appends the returning value of that chained expression to the list. For this example, it happened to work because your three lines could be chained together. You are calling <code>computeCost()</code> method on the object you created with <code>KMeansModel(model.Cs[0])</code> and the parameter for that is <code>split_vecs.map(lambda x: x[0])</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could wrap the three distinct functions you have (KMeansModel,split_vec.map, and computeCost) in another function, like so:</p>
<pre><code>def master_fx(var):
    return fx_C(fx_B(fx_A(var)))
</code></pre>
<p>Now that it looks nice, you can either use list comprehension:</p>
<pre><code>[master_fx(element) for element in range(2)]
</code></pre>
<p>Or a for loop (on one or more lines -- it generally makes no difference, except in terms of readability. I say generally because I do get an error when I try to put another control structure on the same line, as in:</p>
<pre><code>for i in range(2): if i%2==0: print(i)
</code></pre>
<p>However, for readability's sake, you probably wouldn't want something like the line above anyway)</p>
<p>Probably the most important difference is that a for loop is just a control structure whereas list comprehension is a fancy kind of list over which you can define operations. That is why in an interactive interpreter such as ipython, you have to print the output (element and i in the examples above) of a for loop but not of list comprehension.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're calling "one-liner for loops" are actually called"list comprehensions", "dictionary comprehensions", or "<a href="https://docs.python.org/3/tutorial/classes.html#generators" rel="nofollow">generator</a> expressions". They are more limited than for-loops, and work as follows:</p>
<pre><code># List comprehension
result = [expression for name in iterable]
# equivalent to:
result = []
for name in iterable:
    result.append(expression)

# Dictionary comprehension
result = {key_expression: value_expression for name in iterable}
# equivalent to:
result = {}
for name in iterable:
    result[key_expression] = value_expression

# Generator expression
result = (expression for name in iterable)
# equivalent to
def anonymous_generator():
    for name in iterable:
        yield expression
result = anonymous_generator()
</code></pre>
<p>You can nest them, they aren't actually required to be one line. For a (probably-not-useful) example, list comprehensions could be used to get a list of all possible pairs of elements from a list <code>listA</code> and elements from lists in a dict <code>dictB</code> keyed by things from <code>listA</code> (the line break is not required, but helps readability):</p>
<pre><code>pairs = [(a, b) for a in listA
                for b in dictB[a]]
# equivalent to:
pairs = []
for a in listA:
    for b in dictB[a]:
        pairs.append(a, b)
</code></pre>
<p>However, the main limitation of them is that you can't call arbitrary functions - the only places you can put expressions are when saying what iterables you're using and what to output into the result. Side-effects of any functions you call in that will happen, though! For your specific case, you can't do it in any of those simply, because you keep re-assigning model and you can't do that in the middle of a comprehension. It's probably possible to twist things around enough to get the same effect (by writing other functions that do the assignment as a side-effect before returning the correct value), but in this case not really worth it.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is untested, but it looks like it could work for you</p>
<pre><code>computedCost = [KMeansModel(model.Cs[i]).computeCost(x[i]) for i in xrange(2)]
</code></pre>
<p>What it does is create a list of results after performing computeCost() on the results of <code>KMeansModel()</code>.  the <code>xrange for loop</code> just returns the values for i</p>
</div>
<div class="post-text" itemprop="text">
<p>Try it without the semi colon. Though honestly I wouldn't recommend using one line for statements outside of generator expressions</p>
</div>
<span class="comment-copy">What advantage will your one-liner offer over a regular for-loop? Or you want a comprehension?</span>
<span class="comment-copy">@MosesKoledoye check my update. It's mostly for understanding them, so that when I meet them in others' people code I will be comfortable. I do not have the experience to answer your second question, improvise! :)</span>
<span class="comment-copy">I think by "one-line for loop" you are taking about list comprehensions.</span>
<span class="comment-copy">Hmm it could be @DanielRoseman, which means that the answer to my question is No, right? You see, I don't really know <a href="https://stackoverflow.com/questions/tagged/python">python</a> that's why I am trying to learn..And ask bad question(s), I guess :/</span>
<span class="comment-copy">Cool, thanks!!! It surprises me that I have 3.5 answers, in a question of 0 score. :P</span>
<span class="comment-copy">Thank you very much of your explanation David! Such a lovely feeling to see a good answer like this, even though my question is 0 scored!</span>
<span class="comment-copy">But where should the other lines would go? Did you read my whole comment? Well, I don't really know Python, so I am trying to understand what is the principal behind this..</span>
<span class="comment-copy">@gsamaras just do regular for loop?</span>
<span class="comment-copy">That won't actually help, as OP using <code>split</code> as the argument to the <code>computeCost</code> function, while the for loop sets <code>i</code>.</span>
<span class="comment-copy">If by one-liner loops you mean list comprehensions, you cannot do assignment in them.</span>
<span class="comment-copy">@gsamaras For this specific question, I honestly don't know because I don't know the returning values. But it's not a matter of lines. You can always do something like <code>[KMeansModel(model.Cs[i]).computeCost(split_vecs.map(lambda x: x[i])) for i in range(2)]</code> but would it work for that library? I don't know.</span>
