<div class="post-text" itemprop="text">
<p>At the moment I have a little <code>flask</code> project that calls another python file. I'm fully aware that this way is kinda awful, and so, I want to swap it for a function call while maintaining <strong>the prints getting yelded to the website</strong>. </p>
<pre><code>def get_Checks():
    root = request.url_root

    def func():
        yield ("Inicio &lt;br&gt;")
        with subprocess.Popen(r"python somefile.py", stdout=subprocess.PIPE, bufsize=1,
                              universal_newlines=True) as p:
            for line in p.stdout:
                yield (line + "&lt;br&gt;")

    return Response(func())
</code></pre>
<p>I've tryed to replace the file call with the function directly but it just prints it to the console.</p>
<p>I really appreciate any help you can provide.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that all the printing you want to grab is done within the same module, You can monkey-patch the <code>print</code> function of the other module. In the example below, I use a context manager to revert the original print function after the grabbing is done.</p>
<p>This is <code>mod1</code>, the module with the misbehaving function.</p>
<pre><code>def bogus_function():
    print('Hello World!')
    print('Line 2')
</code></pre>
<p>This is <code>mod2</code>, the module using <code>mod1.bogus_function()</code></p>
<pre><code>import io
import functools
import contextlib

import mod1

@contextlib.contextmanager
def grab_stdout(module, fd):
    def monkey_print(*args, **kwargs):
        kwargs['file'] = fd
        print(*args, **kwargs)

    setattr(module, 'print', monkey_print)
    try:
        yield
    finally:
        setattr(module, 'print', print)

def line_generator():
    fd = io.StringIO()
    with grab_stdout(mod1, fd):
        mod1.bogus_function()
    fd.seek(0)

    for line in fd:
        yield line.rstrip('\r\n') + '&lt;br&gt;'

for t in enumerate(line_generator()):
    print('line %d: %r' % t)
</code></pre>
<p>The <code>grab_stdout()</code> context manager redirects print calls of <code>module</code> to the file-like object <code>fd</code>. In the function <code>line_generator()</code>, <code>grab_stdout()</code> is used to store the print output of <code>bogus_function</code> in the <code>StringIO</code> object <code>fd</code>. The rest should be self-explanatory.</p>
<p>If you don't know exactly whether print is called in other modules in the call tree of the function in question, you can modify <code>grab_stdout</code> as follows:</p>
<pre><code>import builtins
print_orig = builtins.print

@contextlib.contextmanager
def grab_stdout_global(fd):
    def monkey_print(*args, **kwargs):
        kwargs['file'] = fd
        print_orig(*args, **kwargs)

    builtins.print = monkey_print
    try:
        yield
    finally:
        builtins.print = print_orig
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple way would be to temporarily change <code>sys.stdout</code> to a file-like object, call the function, then restore <code>sys.stdout</code>. The output will be available in the file-like object.</p>
<p>Here is a working Flask app that demonstrates the method:</p>
<pre><code>import sys
from io import StringIO
from flask import Flask, request, Response
import somefile

app = Flask(__name__)

@app.route("/")
def hello():
    def func():
        yield ("Inicio &lt;br&gt;")

        try:
            _stdout = sys.stdout
            sys.stdout = output = StringIO()
            somefile.main()
            output.seek(0)
            for line in output:
                sys.stdout = _stdout
                yield '{}&lt;br&gt;'.format(line.rstrip())
                sys.stdout = output
        finally:
            sys.stdout.close()    # close the StringIO object
            sys.stdout = _stdout  # restore sys.stdout

    return Response(func())

if __name__ == "__main__":
    app.run()
</code></pre>
<p>Here a <a href="https://docs.python.org/3/library/io.html?highlight=pipe#io.StringIO" rel="nofollow"><code>io.StringIO</code></a> object is used to collect the standard output produced by the function, and then the lines are yielded from that object. The <code>finally</code> ensures that the original <code>sys.stdout</code> is restored afterwards. There is some additional complexity around the <code>yield</code> statement because <code>yield</code> returns control to the calling code for which stdout must be restored in case the caller also wants to print to stdout.</p>
<p>It's assumed that the function in <code>somefile.py</code> is the "main" function, and that invocation of it is guarded by a <code>if __name__ == '__main__':</code> test, something like this:</p>
<pre><code>def main():
    for i in range(10):
        print(i)

if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">Damm, that's more complex than what I anticipated, but let me give it a try.</span>
<span class="comment-copy">It's working but it prints the newline(\n) at the end of every line, any way of getting rid of it. (aside from replace at the end)</span>
<span class="comment-copy">nvm, removing the enumerate did the trick.</span>
<span class="comment-copy">@EndermanAPM Alright, I only added the print loop with enumerate to demonstrate that it works.</span>
<span class="comment-copy">@EndermanAPM To remove newlines, just use <code>line.rstrip('\r\n')</code></span>
<span class="comment-copy">This is not working for me :S It just dones't print anything anywhere.</span>
<span class="comment-copy">@EndermanAPM: possibly you are trying this out in the interactive interpreter? If that is the case then fooling about with <code>stdout</code> will also affect your interpreter's <code>stdout</code>. This code is intended to be executed as a script, not interactively. It definitely works in a Flask app - see updated answer.</span>
<span class="comment-copy">@EndermanAPM: BTW, is there a reason that you can not simply update the function in <code>somefile.py</code> to have it yield those lines rather than print them? Then you could just call it as a generator.</span>
<span class="comment-copy">No, I'm not running from the interactive interpreter and I suppose i could rewrite <code>somefile.py</code>.</span>
<span class="comment-copy">Does the full Flask app that I added to my answer work? (It does for me)</span>
