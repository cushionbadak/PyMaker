<div class="post-text" itemprop="text">
<p>Sorry for creating this question but I have been stuck on this question for a while.</p>
<p>Basically I'm trying to take a list:</p>
<pre><code>numbers=[1, 2, -1, -2, 4, 5]
</code></pre>
<p>And subset this list into a list of list that display positive/negative movements (or trends)</p>
<p>The end result is to have:</p>
<pre><code>subset_list = [[1, 2], [-1, -2], [4, 5]] 
</code></pre>
<p>Basically I have been using nested while functions to append a positive movement to the subset, and when the condition is not met, the subset is appended to subset_list and then evaluates if there is a negative movement.</p>
<p>I keep getting an <code>IndexError</code>, and so far <code>subset_list</code> only contains <code>[[1, 2]]</code></p>
<p>Here is my code:</p>
<pre><code>numbers = [1,2,-1,-2,4,5]

subset = []
subset_list = []
subset.append(numbers[0])

i = 1
while i &lt; (len(numbers)):
    if numbers[i] &lt;= numbers[i+1]:
        subset.append(numbers[i])
        i+= 1
        while subset[-1] &lt;= numbers[i] or numbers[i] &lt;= numbers[i+1]:
            subset.append(numbers[i])
            i += 1
        subset_list.append(subset)
        subset = []
        i += 1
    if numbers[i] &gt; numbers[i+1]:
        subset.append(numbers[i])
        i+= 1
        while subset[-1] &lt;= numbers[i] or numbers[i] &lt;= numbers[i+1]:
            subset.append(numbers[i])
            i+= 1
        subset_list.append(subset)
        subset = []
        i += 1
</code></pre>
<p>Thanks!</p>
<p>-Jake</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what I came up with. It is close to what you have but a little easier to read. I avoid having to increment the index counter <code>i</code> as much which is <em>probably</em> where you went wrong.</p>
<pre><code>n= [1,2,-1,-2,4,5]
out=[]
i=1
tmp=[n[0]]
while i &lt; len(n):
        if n[i] &gt;= 0 and tmp[-1] &gt;= 0:
                tmp.append(n[i])
        elif n[i] &lt; 0 and tmp[-1] &lt; 0:
                tmp.append(n[i])
        else:
                out.append(tmp)
                tmp = [n[i]]
        i = i + 1
if len(tmp) &gt; 0: # typo fix was &gt; 1
        out.append(tmp)

print(out)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a way to re-write this:</p>
<pre><code>
numbers=[1,2,-1,-2,4,5] 


direction = True  # positive or negative
prevdirection = True
res = [[numbers[0]]]

for previtem, item in zip(numbers[:-1], numbers[1:]):
    direction = True if item - previtem &gt; 0 else False
    if direction != prevdirection:
        res.append([])
    prevdirection = direction
    res[-1].append(item)

print(res)    

</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python, one tends not to use the actual indexes in a list very often. Try a for-loop instead, plus a check to see whether the trend changed or not (this treats zero as a distinct trend from positive or negative - you can pretty simply change <code>same_direction</code> to group it one way or the other):</p>
<pre><code>def same_direction(num1, num2):
    # both numbers are positive, both are negative, or both are zero
    return ((num1 &gt; 0 and num2 &gt; 0) or
            (num1 &lt; 0 and num2 &lt; 0) or
            (num1 == num2))

numbers = [1, 2, -1, -2, 4, 5]
result = [[]] #list with one sublist ready
last_number = 0
for num in numbers:
    if same_direction(num, last_direction):
        # No need for a new sublist, put new number in last sublist
        result[-1].append(num)
    else:
        # trend changed, new sublist and put the number in it
        result.append([num])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If change in trends always go through the sign change, you can "group" items based on a sign using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt;
&gt;&gt;&gt; [list(v) for _, v in groupby(numbers, lambda x: x &lt; 0)]
[[1, 2], [-1, -2], [4, 5]]
</code></pre>
<p>We are using <a href="https://stackoverflow.com/questions/1739514/underscore-as-variable-name-in-python"><code>_</code> as a variable name</a> for a "throw-away" variable since we don't need the grouping key in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution:</p>
<pre><code>numbers = [1,2,-1,-2,4,5, 3, 2]

subset = []
subset_list = []
subset.append(numbers[0])


forward = 1

for i in range(0, len(numbers) - 1):
    if ( forward == 1 ):
        if numbers[i] &lt;= numbers[i+1]:
            subset.append(numbers[i+1])
        else:
            subset_list.append(subset)
            subset = []
            subset.append(numbers[i+1])
            forward = 0
    else:
        if numbers[i] &gt;= numbers[i+1]:
            subset.append(numbers[i+1])
        else:
            subset_list.append(subset)
            subset = []
            subset.append(numbers[i+1])
            forward = 1

subset_list.append(subset)

print(*subset)          
print(*subset_list)
</code></pre>
<p>Unfortunately, I only have python 3 on my system so my answer is in python 3.</p>
</div>
<span class="comment-copy">Wow Liam thank you so much this works perfectly! After looking over your code vs mine; it looks like the reason that your's works is because you're evaluating everything within a single if statement whereas mine had two. I never thought to evaluate tmp as [n[i]]</span>
<span class="comment-copy">Glad I could help. If you think my answer is the one that works, mark it as the answer.</span>
<span class="comment-copy">But, what about, say, <code>numbers=[1,2,2,2,4,5]</code> input?</span>
<span class="comment-copy">You are right.. I understood that there is only go up and go down. Remaining at the same number was not defined. This can be fixed by replacing &lt; with &lt;= or the like.</span>
<span class="comment-copy">The OP didn't want to group by positive or negative, but according to direction change  going up or down.</span>
<span class="comment-copy">@IsraelUnterman you are right, probably not the best example to demonstrate the problem though. Thanks!</span>
