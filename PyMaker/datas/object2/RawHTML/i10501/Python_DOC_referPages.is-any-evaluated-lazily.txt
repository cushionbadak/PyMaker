<div class="post-text" itemprop="text">
<p>I am writing a script in which i have to test numbers against a number of conditions. If <strong>any</strong> of the conditions are met i want to return <code>True</code> and i want to do that the fastest way possible.</p>
<p>My first idea was to use <code>any()</code> instead of nested <code>if</code> statements or multiple <code>or</code> linking my conditions. Since i would be satisfied if any of the conditions were <code>True</code> i could really benefit from <code>any()</code> being lazy and returning True as soon as it could.</p>
<p>Based on the fact that the following print happens instantly and not after 10 (= 0 + 1 + 2 + 3 + 4) seconds i assume it is. Is that the case or am i somehow mistaken?</p>
<pre><code>import time

def some(sec):
    time.sleep(sec)
    return True

print(any(some(x) for x in range(5)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <code>any()</code> and <code>all()</code> short-circuit, aborting as soon as the outcome is clear: See the <a href="https://docs.python.org/3/library/functions.html#all">docs</a>:</p>
<blockquote>
<p><strong>all(iterable)</strong></p>
<p>Return True if all elements of the iterable are true (or if the
  iterable is empty). Equivalent to:</p>
<pre><code>def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
</code></pre>
<p><strong>any(iterable)</strong></p>
<p>Return True if any element of the iterable is true. If the iterable is
  empty, return False. Equivalent to:</p>
<pre><code>def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>While the <a href="https://docs.python.org/2.7/library/functions.html#all" rel="nofollow"><code>all()</code></a> and <a href="https://docs.python.org/2.7/library/functions.html#any" rel="nofollow"><code>any()</code></a> functions short-circuit on the first "true" element of an iterable, the iterable itself may be constructed in a non-lazy way. Consider this example:</p>
<pre><code>&gt;&gt; any(x == 100 for x in range(10**8))
True
</code></pre>
<p>This will take several seconds to execute in Python 2 as <code>range(10**8)</code> constructs a list of 10**8 elements. The same expression runs instantly in Python 3, where <code>range()</code> is lazy.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Tim correctly mentioned, <code>any</code> and <code>all</code> do short-circuit, but in your code, what makes it <em>lazy</em> is the use of <a href="https://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehension">generators</a>. For example, the following code would not be lazy:</p>
<pre><code>print(any([slow_operation(x) for x in big_list]))
</code></pre>
<p>The list would be fully constructed and calculated, and only then passed as an argument to <code>any</code>.</p>
<p>Generators, on the other hand, are iterables that calculate each item on demand. They can be <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow noreferrer">expressions</a>, <a href="https://www.python.org/dev/peps/pep-0255/" rel="nofollow noreferrer">functions</a>, or sometimes manually implemented as lazy <a href="https://docs.python.org/3/tutorial/classes.html#iterators" rel="nofollow noreferrer">iterators</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it's lazy as demonstrated by the following:</p>
<pre><code>def some(x, result=True):
    print(x)
    return result

&gt;&gt;&gt; print(any(some(x) for x in range(5)))
0
True

&gt;&gt;&gt; print(any(some(x, False) for x in range(5)))
0
1
2
3
4
False
</code></pre>
<p>In the first run <code>any()</code> halted after testing the first item, i.e. it short circuited the evaluation.</p>
<p>In the second run <code>any()</code> continued testing until the sequence was exhausted.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, and here is an experiment that shows it even more definitively than your timing experiment:</p>
<pre><code>import random

def some(x):
    print(x, end = ', ')
    return random.random() &lt; 0.25

for i in range(5):
    print(any(some(x) for x in range(10)))
</code></pre>
<p>typical run:</p>
<pre><code>0, 1, 2, True
0, 1, True
0, True
0, 1, 2, 3, True
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, False
</code></pre>
</div>
<span class="comment-copy">Yes - it's lazy...</span>
<span class="comment-copy">thanks! The same holds for <code>all()</code> i imagine</span>
<span class="comment-copy">Yes, correct...</span>
<span class="comment-copy">I think <i>lazy</i> is probably the wrong term here - they will <i>short circuit</i> as soon as possible is probably more accurate</span>
<span class="comment-copy">You could have looked up <a href="https://docs.python.org/2/library/functions.html#any" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#any</a> , which shows the pseudocode for it (that's clearly lazy), but of course you could really benefit from being lazy :-)</span>
<span class="comment-copy">i usually find the docs bad but in this case it is beyond clear. Thanks a lot! Also this is exactly what i had in mind in terms of <i>lazy evaluation</i>. how is <i>short-circuiting</i> any different ?</span>
<span class="comment-copy">The generator expression is lazy in the sense that it only calls <code>some(x)</code> when the next item is requested. <code>any/all</code> short-circuit in the sense that it will only request items until the outcome is clear. You could say that <code>any([some(x) for x in range(5)])</code> still short-circuits, but isn't lazy since the list comprehension results in <code>some</code> being called on all elements of <code>range(x)</code> before <code>any</code> begins, but <code>any</code> will still stop examining the input list as soon as possible.</span>
<span class="comment-copy">Good observation</span>
<span class="comment-copy">I find this confusing because I know that <code>range()</code> creates the full list in python2, but then you wrap it in a generator, which is lazy</span>
<span class="comment-copy">@Chris_Rands: When you use a <i>generator expression</i>, like in the example above, the <code>for</code>-expression is immediately evaluated. Hence, <code>range()</code> constructs a full list even before the generator is run.</span>
<span class="comment-copy">nice one. Thanks!</span>
