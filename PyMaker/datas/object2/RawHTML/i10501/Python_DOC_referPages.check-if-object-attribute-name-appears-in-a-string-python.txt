<div class="post-text" itemprop="text">
<p>I want to:</p>
<ul>
<li>check whether a string contains an object property</li>
<li>if it does then access the attribute</li>
</ul>
<p>So for an object of class </p>
<pre><code>class Person(object):
    name = ""
    age = 0
    major = ""

    def __init__(self, name="", surname="", father="", age =0):
        self.name = name
        self.surname = surname
        self.father = father
        self.age = age
        self.identity = name +" "+ surname
    def __str__(self):
        return self.identity

    __repr__ = __str__
</code></pre>
<p>and object</p>
<pre><code>person = Person("Earl", "Martin", "Jason", 40)
</code></pre>
<p>I would like for string "What is the name"
to return person.name 
(I already know which object the string is about)</p>
<p>The most basic solution would be to do cases for each property being there but the actual code has quite a few and I am sure I don't manually have to write them out, I am just new to programming so I am not sure what syntax is used for this</p>
<p>Any help appreciated </p>
</div>
<div class="post-text" itemprop="text">
<p>As others have noted, <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr</code></a> is generally useful.</p>
<p><a href="https://docs.python.org/3/library/functions.html#hasattr" rel="nofollow"><code>hasattr</code></a> is of lesser utility; internally, it's basically a <code>getattr</code> call in a <code>try</code>/<code>except AttributeError:</code> block (if <code>AttributeError</code> occurs, it returns <code>False</code>, no exception means <code>True</code>), so if you're considering code like:</p>
<pre><code>if hasattr(myobj, attrname):
    attr = getattr(myobj, attrname)
    ...
</code></pre>
<p>just use:</p>
<pre><code>try:
    attr = getattr(myobj, attrname)
except AttributeError:
    pass
else:
    ...
</code></pre>
<p>to avoid doubling the number of LEG<strong>B</strong> lookups, function calls and attribute lookups.</p>
<p>Alternatively, for repeatedly pulling named attribute(s), <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow"><code>operator.attrgetter</code></a> basically lets you make an optimized version of <code>getattr</code> that pre-binds the attribute name to lookup (making it ideal for use with stuff like the <code>map</code> and <code>filter</code> functions, as it makes them more efficient than their equivalent listcomps/genexprs).</p>
<p>On top of those, depending on what your goal is, <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow">the <code>dir</code></a> and (slightly less reliably, due to issues with classes <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__" rel="nofollow">that use <code>__slots__</code> to define a known set of variables to reduce memory usage and prevent auto-vivification</a>) <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow"><code>vars</code> function</a>s may be useful.</p>
<p>For example, in your example case of pulling any attributes corresponding to a word from a string, you could do a bulk identification of legal attribute names using <code>vars()</code>/<code>dir()</code> and your choice of <code>filter</code> or <code>set</code> operations (or a mix) depending on the importance of order, uniqueness, etc.:</p>
<pre><code>from future_builtins import filter  # Only on Py2, not Py3
import operator
import re

def query_obj(obj, querystr):
    # Extract list of legal attribute names from string
    words = re.findall(r'\w+', querystr)

    # Reduce to names present on object's __dict__; no need to construct temporaries
    attrnames = filter(vars(obj).__contains__, words)
    # Alternate if __slots__ might be an issue (temp list &amp; frozenset):
    attrnames = filter(frozenset(dir(obj)).__contains__, words)
    # Or combine the two to be sure (on Py3, use .keys() instead of .viewkeys())
    # (temp list and set):
    attrnames = filter((vars(obj).viewkeys() | dir(obj)).__contains__, words)

    # Convenient way to get all names discovered at once; returns single object
    # for single attr, tuple of objects for multiple attrs:
    return operator.attrgetter(*attrnames)(obj)

    # If you want a tuple unconditionally, use this instead:
    return tuple(getattr(obj, name) for name in attrnames)

    # Or to only return the first attribute encountered, raising StopIteration
    # if no attributes are found:
    return next(getattr(obj, name) for name in attrnames)
</code></pre>
<p>Then usage is:</p>
<pre><code>&gt;&gt;&gt; person = Person("Earl", "Martin", "Jason", 40)
&gt;&gt;&gt; query_obj(person, "What is the name?")
'Earl'  # Would be ('Earl',) in unconditional tuple case
&gt;&gt;&gt; query_obj(person, "What is the name and surname?")
('Earl', 'Martin')  # Would be 'Earl' in single return case
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are looking for the function <code>hasattr()</code> and <code>getattr()</code>.</p>
<p>To check whether the attribute exists:</p>
<pre><code>hasattr(Person(), 'string')
</code></pre>
<p>And to call the attribute:</p>
<pre><code>getattr(Person(), 'string')
</code></pre>
</div>
<span class="comment-copy">The string "what is the surname" <i>also</i> contains the property name <code>"name"</code>.  I assume you'd rather return the <code>surname</code> in that case but the question (as written) is ambiguous.  Also, what do you want to do with strings with obviously contain multiple property names?  (e.g. "What is the name and surname?")</span>
<span class="comment-copy">@mgilson thank you for pointing it out; yes your interpretation is correct; and as for the second question I can only return single string so probably whichever comes first</span>
<span class="comment-copy">@mgilson: Greediness is a decent solution there; just pull the first complete "word" (e.g. matching regex <code>r'\w+'</code> with even handles underscores) from the string that happens to be an attribute on the object. If you never see <code>name</code> as a standalone word, you won't even check for it. Safer than trying to do <code>name in query</code> checks that will match partial words in the query string.</span>
<span class="comment-copy">Thank you for a well explained solution, also for pointing out flaw with LBYL pattern, which I was unknowingly following; an attribute is almost certain to be present in in the string my case, so  EAFP pattern would be preferred.</span>
<span class="comment-copy">FYI: There are some who argue that you should <i>almost never</i> use <a href="https://hynek.me/articles/hasattr/" rel="nofollow noreferrer"><code>hasattr</code></a> and instead prefer variants on the more verbose <code>if getattr(obj, string, sentinel) is sentinel</code>.</span>
<span class="comment-copy">@mgilson: I argue against <code>hasattr</code>, but not in favor of a different <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow noreferrer">LBYL</a> solution that requires a double lookup in the success case. <code>attr = getattr(obj, string, sentinel)</code> then <code>if attr is not sentinel:</code> is fine though, you just need to store the result before the <code>if</code> check. The flaw w/<code>hasattr</code> is that it's doubling the work in the success case (you still need <code>getattr</code>, and it's doing the same work as <code>getattr</code> itself), so using an <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP pattern</a> with <code>getattr</code> avoids that complication.</span>
<span class="comment-copy">@ShadowRanger -- Sure.  I think that this really depends on the object you're working with.  Attribute lookup should <i>usually</i> be fast, so doubling up on the lookup isn't necessarily a bad thing (unless you have an object where you know attribute lookup <i>could</i> be expensive).  Also, there are a number of cases where you just want to know if an attribute is present, but not do anything with it's value (this is used a lot in <code>__subclasshook__</code> for example).  And obviously EAFP is usually preferred :-).  My final defense is that I did say "variants of" :-P</span>
<span class="comment-copy">@mgilson: I know. I'm just an inveterate <a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself" rel="nofollow noreferrer">DRY</a>er, and I find the pattern of using both <code>hasattr</code> and <code>getattr</code> one after another irksome (I agree it would be unusual for it to be more than a few microseconds to repeat the lookup). I also agree that <code>hasattr</code> has a reasonable place in the type checking machinery (of course, duck typing is usually better, but I'm not a purist there; if the duck typing wouldn't blow up until it's at a confusing and hard to recover point in the function, type checking is totally cool). I accept your defense! :-)</span>
