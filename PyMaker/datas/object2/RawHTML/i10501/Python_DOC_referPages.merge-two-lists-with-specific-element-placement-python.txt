<div class="post-text" itemprop="text">
<p>I have two lists of objects. Each list is already sorted by a property of the object that is of the datetime type. I would like to combine the two lists into one sorted list. Is the best way just to do a sort or is there a smarter way to do this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>People seem to be over complicating this.. Just combine the two lists, then sort them:</p>
<pre><code>&gt;&gt;&gt; l1 = [1, 3, 4, 7]
&gt;&gt;&gt; l2 = [0, 2, 5, 6, 8, 9]
&gt;&gt;&gt; l1.extend(l2)
&gt;&gt;&gt; sorted(l1)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>..or shorter (and without modifying <code>l1</code>):</p>
<pre><code>&gt;&gt;&gt; sorted(l1 + l2)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>..easy! Plus, it's using only two built-in functions, so assuming the lists are of a reasonable size, it should be quicker than implementing the sorting/merging in a loop. More importantly, the above is much less code, and very readable.</p>
<p>If your lists are large (over a few hundred thousand, I would guess), it may be quicker to use an alternative/custom sorting method, but there are likely other optimisations to be made first (e.g not storing millions of <code>datetime</code> objects)</p>
<p>Using the <code>timeit.Timer().repeat()</code> (which repeats the functions 1000000 times), I loosely benchmarked it against <a href="https://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464454">ghoseb's</a> solution, and <code>sorted(l1+l2)</code> is substantially quicker:</p>
<p><code>merge_sorted_lists</code> took..</p>
<pre><code>[9.7439379692077637, 9.8844599723815918, 9.552299976348877]
</code></pre>
<p><code>sorted(l1+l2)</code> took..</p>
<pre><code>[2.860386848449707, 2.7589840888977051, 2.7682540416717529]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>is there a smarter way to do this in Python</p>
</blockquote>
<p>This hasn't been mentioned, so I'll go ahead - there is a <a href="https://github.com/python/cpython/blob/3.7/Lib/heapq.py#L314" rel="noreferrer">merge stdlib function</a> in the heapq module of python 2.6+. If all you're looking to do is getting things done, this might be a better idea. Of course, if you want to implement your own, the merge of merge-sort is the way to go.</p>
<pre><code>&gt;&gt;&gt; list1 = [1, 5, 8, 10, 50]
&gt;&gt;&gt; list2 = [3, 4, 29, 41, 45, 49]
&gt;&gt;&gt; from heapq import merge
&gt;&gt;&gt; list(merge(list1, list2))
[1, 3, 4, 5, 8, 10, 29, 41, 45, 49, 50]
</code></pre>
<p>Here's <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="noreferrer">the documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Long story short, unless <code>len(l1 + l2) ~ 1000000</code> use:</p>
<pre><code>L = l1 + l2
L.sort()
</code></pre>
<p><img alt="merge vs. sort comparison" src="https://i.stack.imgur.com/XsRdj.png"/></p>
<p>Description of the figure and source code can be found <a href="https://stackoverflow.com/questions/464960/code-golf-combining-multiple-sorted-lists-into-a-single-sorted-list#464967">here</a>. </p>
<p>The figure was generated by the following command:</p>
<pre><code>$ python make-figures.py --nsublists 2 --maxn=0x100000 -s merge_funcs.merge_26 -s merge_funcs.sort_builtin
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is simply merging. Treat each list as if it were a stack, and continuously pop the smaller of the two stack heads, adding the item to the result list, until one of the stacks is empty. Then add all remaining items to the resulting list.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a slight flaw in <a href="https://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464454">ghoseb's</a> solution, making it O(n**2), rather than O(n).<br/>
The problem is that this is performing:</p>
<pre><code>item = l1.pop(0)
</code></pre>
<p>With linked lists or deques this would be an O(1) operation, so wouldn't affect complexity, but since python lists are implemented as vectors, this copies the rest of the elements of l1 one space left, an O(n) operation.  Since this is done each pass through the list, it turns an O(n) algorithm into an O(n**2) one.  This can be corrected by using a method that doesn't alter the source lists, but just keeps track of the current position.</p>
<p>I've tried out benchmarking a corrected algorithm vs a simple sorted(l1+l2) as suggested by <a href="https://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464538">dbr</a></p>
<pre><code>def merge(l1,l2):
    if not l1:  return list(l2)
    if not l2:  return list(l1)

    # l2 will contain last element.
    if l1[-1] &gt; l2[-1]:
        l1,l2 = l2,l1

    it = iter(l2)
    y = it.next()
    result = []

    for x in l1:
        while y &lt; x:
            result.append(y)
            y = it.next()
        result.append(x)
    result.append(y)
    result.extend(it)
    return result
</code></pre>
<p>I've tested these with lists generated with</p>
<pre><code>l1 = sorted([random.random() for i in range(NITEMS)])
l2 = sorted([random.random() for i in range(NITEMS)])
</code></pre>
<p>For various sizes of list, I get the following timings (repeating 100 times):</p>
<pre><code># items:  1000   10000 100000 1000000
merge  :  0.079  0.798 9.763  109.044 
sort   :  0.020  0.217 5.948  106.882
</code></pre>
<p>So in fact, it looks like dbr is right, just using sorted() is preferable unless you're expecting very large lists, though it does have worse algorithmic complexity.  The break even point being at around a million items in each source list (2 million total).</p>
<p>One advantage of the merge approach though is that it is trivial to rewrite as a generator, which will use substantially less memory (no need for an intermediate list).</p>
<p><strong>[Edit]</strong>
I've retried this with a situation closer to the question - using a list of objects containing a field "<code>date</code>" which is a datetime object.
The above algorithm was changed to compare against <code>.date</code> instead, and the sort method was changed to:</p>
<pre><code>return sorted(l1 + l2, key=operator.attrgetter('date'))
</code></pre>
<p>This does change things a bit.  The comparison being more expensive means that the number we perform becomes more important, relative to the constant-time speed of the implementation.  This means merge makes up lost ground, surpassing the sort() method at 100,000 items instead.  Comparing based on an even more complex object (large strings or lists for instance) would likely shift this balance even more.</p>
<pre><code># items:  1000   10000 100000  1000000[1]
merge  :  0.161  2.034 23.370  253.68
sort   :  0.111  1.523 25.223  313.20
</code></pre>
<p>[1]: Note: I actually only did 10 repeats for 1,000,000 items and scaled up accordingly as it was pretty slow.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is simple merging of two sorted lists. Take a look at the sample code below which merges two sorted lists of integers.</p>
<pre><code>#!/usr/bin/env python
## merge.py -- Merge two sorted lists -*- Python -*-
## Time-stamp: "2009-01-21 14:02:57 ghoseb"

l1 = [1, 3, 4, 7]
l2 = [0, 2, 5, 6, 8, 9]

def merge_sorted_lists(l1, l2):
    """Merge sort two sorted lists

    Arguments:
    - `l1`: First sorted list
    - `l2`: Second sorted list
    """
    sorted_list = []

    # Copy both the args to make sure the original lists are not
    # modified
    l1 = l1[:]
    l2 = l2[:]

    while (l1 and l2):
        if (l1[0] &lt;= l2[0]): # Compare both heads
            item = l1.pop(0) # Pop from the head
            sorted_list.append(item)
        else:
            item = l2.pop(0)
            sorted_list.append(item)

    # Add the remaining of the lists
    sorted_list.extend(l1 if l1 else l2)

    return sorted_list

if __name__ == '__main__':
    print merge_sorted_lists(l1, l2)
</code></pre>
<p>This should work fine with datetime objects. Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from datetime import datetime
from itertools import chain
from operator import attrgetter

class DT:
    def __init__(self, dt):
        self.dt = dt

list1 = [DT(datetime(2008, 12, 5, 2)),
         DT(datetime(2009, 1, 1, 13)),
         DT(datetime(2009, 1, 3, 5))]

list2 = [DT(datetime(2008, 12, 31, 23)),
         DT(datetime(2009, 1, 2, 12)),
         DT(datetime(2009, 1, 4, 15))]

list3 = sorted(chain(list1, list2), key=attrgetter('dt'))
for item in list3:
    print item.dt
</code></pre>
<p>The output:</p>
<pre><code>2008-12-05 02:00:00
2008-12-31 23:00:00
2009-01-01 13:00:00
2009-01-02 12:00:00
2009-01-03 05:00:00
2009-01-04 15:00:00
</code></pre>
<p>I bet this is faster than any of the fancy pure-Python merge algorithms, even for large data. Python 2.6's <code>heapq.merge</code> is a whole another story.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's sort implementation "timsort" is specifically optimized for lists that contain ordered sections.  Plus, it's written in C.  </p>
<p><a href="http://bugs.python.org/file4451/timsort.txt" rel="nofollow">http://bugs.python.org/file4451/timsort.txt</a><br/>
<a href="http://en.wikipedia.org/wiki/Timsort" rel="nofollow">http://en.wikipedia.org/wiki/Timsort</a></p>
<p>As people have mentioned, it may call the comparison function more times by some constant factor (but maybe call it more times in a shorter period in many cases!).</p>
<blockquote>
<p>I would never rely on this, however. – Daniel Nadasi</p>
</blockquote>
<p>I believe the Python developers are committed to keeping timsort, or at least keeping a sort that's O(n) in this case.</p>
<blockquote>
<p>Generalized sorting (i.e. leaving apart radix sorts from limited value domains)<br/>
  cannot be done in less than O(n log n) on a serial machine. – Barry Kelly</p>
</blockquote>
<p>Right, sorting in the general case can't be faster than that.  But since O() is an upper bound, timsort being O(n log n) on arbitrary input doesn't contradict its being O(n) given sorted(L1) + sorted(L2).</p>
</div>
<div class="post-text" itemprop="text">
<p>Recursive implementation is below. Average performance is O(n).</p>
<pre><code>def merge_sorted_lists(A, B, sorted_list = None):
    if sorted_list == None:
        sorted_list = []

    slice_index = 0
    for element in A:
        if element &lt;= B[0]:
            sorted_list.append(element)
            slice_index += 1
        else:
            return merge_sorted_lists(B, A[slice_index:], sorted_list)

    return sorted_list + B
</code></pre>
<p>or generator with improved space complexity:</p>
<pre><code>def merge_sorted_lists_as_generator(A, B):
    slice_index = 0
    for element in A:
        if element &lt;= B[0]:
            slice_index += 1
            yield element       
        else:
            for sorted_element in merge_sorted_lists_as_generator(B, A[slice_index:]):
                yield sorted_element
            return        

    for element in B:
        yield element
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def merge_sort(a,b):

    pa = 0
    pb = 0
    result = []

    while pa &lt; len(a) and pb &lt; len(b):
        if a[pa] &lt;= b[pb]:
            result.append(a[pa])
            pa += 1
        else:
            result.append(b[pb])
            pb += 1

    remained = a[pa:] + b[pb:]
    result.extend(remained)


return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An implementation of the merging step in Merge Sort that iterates through both lists:</p>
<pre><code>def merge_lists(L1, L2):
    """
    L1, L2: sorted lists of numbers, one of them could be empty.

    returns a merged and sorted list of L1 and L2.
    """

    # When one of them is an empty list, returns the other list
    if not L1:
        return L2
    elif not L2:
        return L1

    result = []
    i = 0
    j = 0

    for k in range(len(L1) + len(L2)):
        if L1[i] &lt;= L2[j]:
            result.append(L1[i])
            if i &lt; len(L1) - 1:
                i += 1
            else:
                result += L2[j:]  # When the last element in L1 is reached,
                break             # append the rest of L2 to result.
        else:
            result.append(L2[j])
            if j &lt; len(L2) - 1:
                j += 1
            else:
                result += L1[i:]  # When the last element in L2 is reached,
                break             # append the rest of L1 to result.

    return result

L1 = [1, 3, 5]
L2 = [2, 4, 6, 8]
merge_lists(L1, L2)               # Should return [1, 2, 3, 4, 5, 6, 8]
merge_lists([], L1)               # Should return [1, 3, 5]
</code></pre>
<p>I'm still learning about algorithms, please let me know if the code could be improved in any aspect, your feedback is appreciated, thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, the naive approach (combine 2 lists into large one and sort) will be O(N*log(N)) complexity. On the other hand, if you implement the merge manually (i do not know about any ready code in python libs for this, but i'm no expert) the complexity will be O(N), which is clearly faster.
The idea is described wery well in post by Barry Kelly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the 'merge' step of merge sort, it runs in O(n) time.</p>
<p>From <a href="http://en.wikipedia.org/wiki/Merge_sort" rel="nofollow noreferrer">wikipedia</a> (pseudo-code):</p>
<pre><code>function merge(left,right)
    var list result
    while length(left) &gt; 0 and length(right) &gt; 0
        if first(left) ≤ first(right)
            append first(left) to result
            left = rest(left)
        else
            append first(right) to result
            right = rest(right)
    end while
    while length(left) &gt; 0 
        append left to result
    while length(right) &gt; 0 
        append right to result
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to do it in a manner more consistent with learning what goes on in the iteration try this</p>
<pre><code>def merge_arrays(a, b):
    l= []

    while len(a) &gt; 0 and len(b)&gt;0:
        if a[0] &lt; b[0]: l.append(a.pop(0))    
        else:l.append(b.pop(0))

    l.extend(a+b)
    print( l )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random

    n=int(input("Enter size of table 1")); #size of list 1
    m=int(input("Enter size of table 2")); # size of list 2
    tb1=[random.randrange(1,101,1) for _ in range(n)] # filling the list with random
    tb2=[random.randrange(1,101,1) for _ in range(m)] # numbers between 1 and 100
    tb1.sort(); #sort the list 1 
    tb2.sort(); # sort the list 2
    fus=[]; # creat an empty list
    print(tb1); # print the list 1
    print('------------------------------------');
    print(tb2); # print the list 2
    print('------------------------------------');
    i=0;j=0;  # varialbles to cross the list
    while(i&lt;n and j&lt;m):
        if(tb1[i]&lt;tb2[j]):
            fus.append(tb1[i]); 
            i+=1;
        else:
            fus.append(tb2[j]);
            j+=1;

    if(i&lt;n):
        fus+=tb1[i:n];
    if(j&lt;m):
        fus+=tb2[j:m];

    print(fus);

  # this code is used to merge two sorted lists in one sorted list (FUS) without
  #sorting the (FUS)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have used merge step of the merge sort. But I have used <strong>generators</strong>.  <em>Time complexity</em> <strong>O(n)</strong></p>
<pre><code>def merge(lst1,lst2):
    len1=len(lst1)
    len2=len(lst2)
    i,j=0,0
    while(i&lt;len1 and j&lt;len2):
        if(lst1[i]&lt;lst2[j]):
                yield lst1[i]
                i+=1
        else:
                yield lst2[j]
                j+=1
    if(i==len1):
        while(j&lt;len2):
                yield lst2[j]
                j+=1
    elif(j==len2):
        while(i&lt;len1):
                yield lst1[i]
                i+=1
l1=[1,3,5,7]
l2=[2,4,6,8,9]
mergelst=(val for val in merge(l1,l2))
print(*mergelst)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def compareDate(obj1, obj2):
    if obj1.getDate() &lt; obj2.getDate():
        return -1
    elif obj1.getDate() &gt; obj2.getDate():
        return 1
    else:
        return 0



list = list1 + list2
list.sort(compareDate)
</code></pre>
<p>Will sort the list in place. Define your own function for comparing two objects, and pass that function into the built in sort function.</p>
<p>Do NOT use bubble sort, it has horrible performance.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is my solution in <strong>linear time</strong> without editing l1 and l2:</p>
<pre><code>def merge(l1, l2):
  m, m2 = len(l1), len(l2)
  newList = []
  l, r = 0, 0
  while l &lt; m and r &lt; m2:
    if l1[l] &lt; l2[r]:
      newList.append(l1[l])
      l += 1
    else:
      newList.append(l2[r])
      r += 1
  return newList + l1[l:] + l2[r:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code has time complexity O(n) and can merge lists of any data type, given a quantifying function as the parameter <code>func</code>. It produces a new merged list and does not modify either of the lists passed as arguments.</p>
<pre><code>def merge_sorted_lists(listA,listB,func):
    merged = list()
    iA = 0
    iB = 0
    while True:
        hasA = iA &lt; len(listA)
        hasB = iB &lt; len(listB)
        if not hasA and not hasB:
            break
        valA = None if not hasA else listA[iA]
        valB = None if not hasB else listB[iB]
        a = None if not hasA else func(valA)
        b = None if not hasB else func(valB)
        if (not hasB or a&lt;b) and hasA:
            merged.append(valA)
            iA += 1
        elif hasB:
            merged.append(valB)
            iB += 1
    return merged
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hope this helps. Pretty Simple and straight forward:</p>
<p>l1 = [1, 3, 4, 7]</p>
<p>l2 = [0, 2, 5, 6, 8, 9]</p>
<p>l3 = l1 + l2</p>
<p>l3.sort()</p>
<p>print (l3)</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
</div>
<span class="comment-copy">Finally a sane answer, taking actual <i>benchmarking</i> into account. :-)  --- Also, 1 line to maintain instead of 15-20 is much to be preferred.</span>
<span class="comment-copy">Sorting a very short list created by appending two lists will indeed be very fast, as the constant overheads will dominate. Try doing this for lists with several million items, or files on disk with several billion items, and you'll soon find out why merging is preferable.</span>
<span class="comment-copy">@Barry: If you have "several billion items" and a speed requisite, <i>anything</i> in Python is the wrong answer.</span>
<span class="comment-copy">@Deestan: I disagree - there are times when speed will be dominated by other factors.  Eg. if you're sorting data on-disk (merge 2 files), IO times will likely dominate and python's speed won't matter much, just the number of operations you do (and hence the algorithm).</span>
<span class="comment-copy">Seriously?  Benchmarking a sort function with a 10 entry list??</span>
<span class="comment-copy">I've added link to heapq.py. <code>merge()</code> is implemented as a pure python function so It is easy to port it to older Python versions.</span>
<span class="comment-copy">Does this work for dictionaries as well ??</span>
<span class="comment-copy">I added a link to the docs for convenience.</span>
<span class="comment-copy">Though right, this solution seems to be one order of magnitude slower than the <code>sorted(l1+l2)</code> solution.</span>
<span class="comment-copy">The selling point for <code>heapq.merge</code> is that it doesn't require either the inputs or the outputs to be <code>list</code>; it can consume iterators/generators and produces a generator, so huge inputs/outputs (not stored in RAM at once) can be combined without swap thrashing. It also handles merging an arbitrary number of input iterables with lower overhead than might be expected (it uses a heap to coordinate the merging, so the overhead scales with the log of the number of iterables, not linearly, but as noted, that doesn't matter for the "two iterable" case).</span>
<span class="comment-copy">You're comparing it against a golfed solution, not one that's actually trying to be efficient.</span>
<span class="comment-copy">@OrangeDog I don't understand what you are talking about. The point of the answer is that adding two lists and sorting them may be faster for small input than heapq.merge() from Python 2.6 (despite <code>merge()</code> being O(n) in time, O(1) in space and the sorting is O(n log n) in time, and the whole algorithm is O(n) in space here)¶ The comparison has only historical value now.</span>
<span class="comment-copy">this answer has nothing to do with <code>heapq.merge</code>, you're comparing <code>sort</code> against somebody's code-golf submission.</span>
<span class="comment-copy">@OrangeDog <b>wrong</b>. <a href="https://gist.github.com/zed/51074#file-merge_funcs-py" rel="nofollow noreferrer"><code>merge_26()</code></a> is from Python 2.6 heapq module.</span>
<span class="comment-copy">you're the one who said "the source code can be found here" and linked to a code-golf answer. Don't blame people for thinking that the code that can be found there is what you tested.</span>
<span class="comment-copy">A merge sort is indeed the optimal solution.</span>
<span class="comment-copy">But is it faster than using Python's built-in sort?</span>
<span class="comment-copy"><a href="http://en.wikipedia.org/wiki/Merge_sort" rel="nofollow noreferrer">en.wikipedia.org/wiki/Merge_sort</a> and <a href="http://en.wikipedia.org/wiki/Merge_algorithm" rel="nofollow noreferrer">en.wikipedia.org/wiki/Merge_algorithm</a></span>
<span class="comment-copy">This is simply a merge, not a merge sort.</span>
<span class="comment-copy">@akaihola: If <code>len(L1 + L2) &lt; 1000000</code> then <code>sorted(L1 + L2)</code> is faster <a href="http://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python/482848#482848" title="combining two sorted lists in python">stackoverflow.com/questions/464342/…</a></span>
<span class="comment-copy">Thanks for the fix. Would be great if you can exactly point out the flaw and your fix :)</span>
<span class="comment-copy">@ghoseb: I gave a brief description as a comment on your post, but I've now updated the answer to give more details - essentially l.pop() is an O(n) operation for lists. It's fixable by tracking position in some other manner (alternatively by popping from the tail instead, and reversing at the end)</span>
<span class="comment-copy">Can you bench mark these same tests but comparing the dates like the question is requiring? I'm guessing this extra method will take up a fair amount of time relatively.</span>
<span class="comment-copy">I'd say the difference is due to the fact that sort() is implemented in c/c++ and compiled vs our merge() that is being interpreted. merge() should be faster on equal terms.</span>
<span class="comment-copy">Good point Drakosha. Show's that benchmarking is indeed the only way to know for certain.</span>
<span class="comment-copy">Unfortunately this is counterproductive - normally merge would be O(n), but because you're popping from the left of each list (an O(n) operation), you're actually making it an O(n**2) process - worse than the naive sorted(l1+l2)</span>
<span class="comment-copy">@Brian I actually think that this solution is the cleanest of all and I believe you're right on O(n) complexity of popping the first element from the list. You can eliminate that problem by using deque from collections, which gives you O(1) when popping an item from either side. <a href="https://docs.python.org/2/library/collections.html#collections.deque" rel="nofollow noreferrer">docs.python.org/2/library/collections.html#collections.deque</a></span>
<span class="comment-copy">@Brian, <code>head, tail = l[0], l[1:]</code> also will have O(n**2) complexity?</span>
<span class="comment-copy">@Brian: As an alternative to <code>collections.deque</code>, it could also be solved by creating <code>l1</code> and <code>l2</code> in reverse order (<code>l1 = l1[::-1]</code>, <code>l2 = l2[::-1]</code>), then working from the right-hand side rather than the left, replacing <code>if l1[0] &lt;= l2[0]:</code> with <code>if l1[-1] &lt;= l2[-1]:</code>, replacing <code>pop(0)</code> with  <code>pop()</code> and changing <code>sorted_list.extend(l1 if l1 else l2)</code> to <code>sorted_list.extend(reversed(l1 if l1 else l2))</code></span>
<span class="comment-copy">As a point of interest, the python sorting algorithm is very good, so the performance would likely be better than O(n log n), since the algorithm often takes advantage of regularities in the input data. I would never rely on this, however.</span>
<span class="comment-copy">Then we both agree on it :)</span>
<span class="comment-copy">Generalized sorting (i.e. leaving apart radix sorts from limited value domains) cannot be done in less than O(n log n) on a serial machine.</span>
<span class="comment-copy">pop(0) is linear, so this version is accidentally quadratic</span>
<span class="comment-copy">It's not clear whether this is an answer to the question, let alone whether it actually does? Can you provide some sort of explanation?</span>
<span class="comment-copy">Sory but I didn't understand  what you whant !</span>
<span class="comment-copy">You'll note that the higher voted answers (and most of the others) have some text that explain what's happening in the answer and <i>why</i> that answer is an answer to the question..</span>
<span class="comment-copy">because it merge two list in  one sorted list and this is the answer of the question</span>
<span class="comment-copy">Merge sort will definately be faster, but a little more complicated if you have to implement it yourself. I <i>think</i> python uses quicksort.</span>
<span class="comment-copy">No, Python uses timsort.</span>
<span class="comment-copy">OP didn't ask how to add and sort lists, was asking if there was a better or more "Python" way of doing it within their context.</span>
