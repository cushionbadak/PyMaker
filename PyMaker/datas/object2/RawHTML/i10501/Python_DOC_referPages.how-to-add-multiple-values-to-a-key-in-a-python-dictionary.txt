<div class="post-text" itemprop="text">
<p>I am trying to create a dictionary from the values in the <code>name_num</code> dictionary where the length of the list is the new key and the <code>name_num</code> dictionary key and value are the value. So:</p>
<pre><code>name_num = {"Bill": [1,2,3,4], "Bob":[3,4,2], "Mary": [5, 1], "Jim":[6,17,4], "Kim": [21,54,35]}
</code></pre>
<p>I want to create the following dictionary:</p>
<pre><code>new_dict = {4:{"Bill": [1,2,3,4]}, 3:{"Bob":[3,4,2], "Jim":[6,17,4], "Kim": [21,54,35]}, 2:{"Mary": [5, 1]}}
</code></pre>
<p>I've tried many variations, but this code gets me the closest:</p>
<pre><code>for mykey in name_num:
    new_dict[len(name_num[mykey])] = {mykey: name_num[mykey]}
</code></pre>
<p>Output:</p>
<pre><code>new_dict = {4:{"Bill": [1,2,3,4]}, 3:{"Jim":[6,17,4]}, 2:{"Mary": [5, 1]}}
</code></pre>
<p>I know I need to loop through the code somehow so I can add the other values to key 3.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://en.wikipedia.org/wiki/Associative_array" rel="noreferrer">Dictionary</a>, associative array or map (many names, basically the same functionality) property is that keys are unique.</p>
<p>The keys you wish to have, which are integers, are not unique if lengths are the same, that's why your code doesn't work. Putting a new value for existing key means replacing the old value.</p>
<p>You have to add key-value pairs to the existing value dictionaries.</p>
<pre><code>for mykey in name_num:
    length = len(name_num[mykey])
    if length in new_dict: # key already present in new dictionary
        new_dict[length][mykey] = name_num[mykey]
    else:
        new_dict[length] = {mykey: name_num[mykey]}
</code></pre>
<p>should do the trick</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a good use case for <a href="https://docs.python.org/3/library/collections.html" rel="noreferrer"><code>defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict
name_num = {
    'Bill': [1, 2, 3, 4],
    'Bob': [3, 4, 2],
    'Mary': [5, 1],
    'Jim': [6, 17, 4],
    'Kim': [21, 54, 35],
}

new_dict = defaultdict(dict)
for name, nums in name_num.items():
    new_dict[len(nums)][name] = nums

print(dict(new_dict))
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>{
    2: {'Mary': [5, 1]},
    3: {'Bob': [3, 4, 2], 'Jim': [6, 17, 4], 'Kim': [21, 54, 35]},
    4: {'Bill': [1, 2, 3, 4]}
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just an alternative to others; you can sort by length and use <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; result = {}
&gt;&gt;&gt; f = lambda t: len(t[1])
&gt;&gt;&gt; for length, groups in itertools.groupby(sorted(name_num.items(), key=f), key=f):
...     result[length] = dict((k, v) for k, v in groups)
&gt;&gt;&gt; print result
{
    2: {'Mary': [5, 1]},
    3: {'Bob': [3, 4, 2], 'Jim': [6, 17, 4], 'Kim': [21, 54, 35]},
    4: {'Bill': [1, 2, 3, 4]}
}
</code></pre>
<p>In a worst case scenario where each inner list has a different length, this performs <code>O(n^2)</code> which is fairly inefficient compared to other solutions posted above.</p>
</div>
<span class="comment-copy">Thanks Jezor.  I am new to Python.  That clears up a lot of confusion on how to add data to a dictionary.</span>
<span class="comment-copy">Karin, nicely done.  I'm new to the defaultdict.  I suppose once you create a default dictionary, it's just a matter of filling it in with data.</span>
<span class="comment-copy">Yes - a default dict basically allows you to set a default value for a dictionary key if you try to access the key and it doesn't exist yet. It comes in handy quite a bit :)</span>
<span class="comment-copy">I didn't expect the <code>defaultdict</code> to keep the value just because it was accessed</span>
<span class="comment-copy">@Bergi That would be inconsistent with mutable values. For example if you had: <code>d = defaultdict(list); value = d[non_existent_key]; value.append(1)</code> you'd expect to have the pair <code>non_existent_key: [1]</code> in the dictionary, but if <code>defaultdict</code> doesn't keep the default value created when accessing you'd always end up with <code>[]</code>. The property of <code>defaultdict</code> is that when you try to access in any way a non existing key that key is added with the default value. The only thing that doesn't trigger key creation is checking like <code>key in the_dict</code>.</span>
<span class="comment-copy">@Bergi Basically the idea of <code>defaultdict</code> was developed when people where using the <code>setdefault</code> method of the normal <code>dict</code> class. You use it like this: <code>d.setdefault(key, default_value)</code>. This is like a get but if the key doesn't exists it adds it and assigns the value of <code>default_value</code>. Problem: the function call always creates that default value and can thus be quite slow. <code>defaultdict</code> is an optimized dictionary where each get call is basically a <code>setdefault</code> call but it can avoid creating the default value when the key exists, for maximum concisesness and speed.</span>
