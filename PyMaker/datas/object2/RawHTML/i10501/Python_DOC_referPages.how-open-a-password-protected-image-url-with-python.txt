<div class="post-text" itemprop="text">
<p>Im trying to do a HTTPS GET with basic authentication using python. Im very new to python and the guides seem to use diffrent librarys to do things. (http.client, httplib and urllib). Can anyone show me how its done? How can you tell the standard library to use?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 the following will work.  I am using the lower level <a href="http://docs.python.org/py3k/library/http.client.html">http.client</a> from the standard library.  Also check out section 2 of <a href="http://www.ietf.org/rfc/rfc2617.txt">rfc2617</a> for details of basic authorization.  This code won't check the certificate is valid, but will set up a https connection.  See the <a href="http://docs.python.org/py3k/library/http.client.html">http.client</a> docs on how to do that.</p>
<pre><code>from http.client import HTTPSConnection
from base64 import b64encode
#This sets up the https connection
c = HTTPSConnection("www.google.com")
#we need to base 64 encode it 
#and then decode it to acsii as python 3 stores it as a byte string
userAndPass = b64encode(b"username:password").decode("ascii")
headers = { 'Authorization' : 'Basic %s' %  userAndPass }
#then connect
c.request('GET', '/', headers=headers)
#get the response back
res = c.getresponse()
# at this point you could check the status etc
# this gets the page text
data = res.read()  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the power of Python and lean on one of the best libraries around: <a href="http://docs.python-requests.org/en/master/" rel="noreferrer">requests</a></p>
<pre><code>import requests

r = requests.get('https://my.website.com/rest/path', auth=('myusername', 'mybasicpass'))
print(r.text)
</code></pre>
<p>Variable r (requests response) has a lot more parameters that you can use.  Best thing is to pop into the interactive interpreter and play around with it, and/or read <a href="http://docs.python-requests.org/en/master/" rel="noreferrer">requests</a> docs.</p>
<pre><code>ubuntu@hostname:/home/ubuntu$ python3
Python 3.4.3 (default, Oct 14 2015, 20:28:29)
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get('https://my.website.com/rest/path', auth=('myusername', 'mybasicpass'))
&gt;&gt;&gt; dir(r)
['__attrs__', '__bool__', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__nonzero__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_content', '_content_consumed', 'apparent_encoding', 'close', 'connection', 'content', 'cookies', 'elapsed', 'encoding', 'headers', 'history', 'iter_content', 'iter_lines', 'json', 'links', 'ok', 'raise_for_status', 'raw', 'reason', 'request', 'status_code', 'text', 'url']
&gt;&gt;&gt; r.content
b'{"battery_status":0,"margin_status":0,"timestamp_status":null,"req_status":0}'
&gt;&gt;&gt; r.text
'{"battery_status":0,"margin_status":0,"timestamp_status":null,"req_status":0}'
&gt;&gt;&gt; r.status_code
200
&gt;&gt;&gt; r.headers
CaseInsensitiveDict({'x-powered-by': 'Express', 'content-length': '77', 'date': 'Fri, 20 May 2016 02:06:18 GMT', 'server': 'nginx/1.6.3', 'connection': 'keep-alive', 'content-type': 'application/json; charset=utf-8'})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Update: OP uses Python 3. So adding an example using <a href="http://code.google.com/p/httplib2/" rel="noreferrer">httplib2</a></p>
<pre><code>import httplib2

h = httplib2.Http(".cache")

h.add_credentials('name', 'password') # Basic authentication

resp, content = h.request("https://host/path/to/resource", "POST", body="foobar")
</code></pre>
<p>The below works for python 2.6:</p>
<p>I use <code>pycurl</code> a lot in production for a process which does upwards of 10 million requests per day.</p>
<p>You'll need to import the following first.</p>
<pre><code>import pycurl
import cStringIO
import base64
</code></pre>
<p>Part of the basic authentication header consists of the username and password encoded as Base64. </p>
<pre><code>headers = { 'Authorization' : 'Basic %s' % base64.b64encode("username:password") }
</code></pre>
<p>In the HTTP header you will see this line <code>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=</code>. The encoded string changes depending on your username and password.</p>
<p>We now need a place to write our HTTP response to and a curl connection handle.</p>
<pre><code>response = cStringIO.StringIO()
conn = pycurl.Curl()
</code></pre>
<p>We can set various curl options. For a complete list of options, <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html" rel="noreferrer">see this</a>. The linked documentation is for the libcurl API, but the options does not change for other language bindings.</p>
<pre><code>conn.setopt(pycurl.VERBOSE, 1)
conn.setopt(pycurlHTTPHEADER, ["%s: %s" % t for t in headers.items()])

conn.setopt(pycurl.URL, "https://host/path/to/resource")
conn.setopt(pycurl.POST, 1)
</code></pre>
<p>If you do not need to verify certificate. <strong>Warning:</strong> This is insecure. Similar to running <code>curl -k</code> or <code>curl --insecure</code>.</p>
<pre><code>conn.setopt(pycurl.SSL_VERIFYPEER, False)
conn.setopt(pycurl.SSL_VERIFYHOST, False)
</code></pre>
<p>Call <code>cStringIO.write</code> for storing the HTTP response.</p>
<pre><code>conn.setopt(pycurl.WRITEFUNCTION, response.write)
</code></pre>
<p>When you're making a POST request.</p>
<pre><code>post_body = "foobar"
conn.setopt(pycurl.POSTFIELDS, post_body)
</code></pre>
<p>Make the actual request now.</p>
<pre><code>conn.perform()
</code></pre>
<p>Do something based on the HTTP response code.</p>
<pre><code>http_code = conn.getinfo(pycurl.HTTP_CODE)
if http_code is 200:
   print response.getvalue()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A correct way to do <a href="http://en.wikipedia.org/wiki/Basic_access_authentication" rel="noreferrer">basic auth</a> in Python3 <a href="https://docs.python.org/3.3/library/urllib.request.html" rel="noreferrer"><code>urllib.request</code></a> with certificate validation follows.</p>
<p>Note that <a href="https://pypi.python.org/pypi/certifi" rel="noreferrer"><code>certifi</code></a> is not mandatory. You can use your OS bundle (likely *nix only) or distribute <a href="https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/included/" rel="noreferrer">Mozilla's CA Bundle</a> yourself. Or if the hosts you communicate with are just a few, concatenate CA file yourself from the hosts' CAs, which can reduce the risk of <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noreferrer">MitM</a> attack caused by another corrupt CA.</p>
<pre><code>#!/usr/bin/env python3


import urllib.request
import ssl

import certifi


context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
context.verify_mode = ssl.CERT_REQUIRED
context.load_verify_locations(certifi.where())
httpsHandler = urllib.request.HTTPSHandler(context = context)

manager = urllib.request.HTTPPasswordMgrWithDefaultRealm()
manager.add_password(None, 'https://domain.com/', 'username', 'password')
authHandler = urllib.request.HTTPBasicAuthHandler(manager)

opener = urllib.request.build_opener(httpsHandler, authHandler)

# Used globally for all urllib.request requests.
# If it doesn't fit your design, use opener directly.
urllib.request.install_opener(opener)

response = urllib.request.urlopen('https://domain.com/some/path')
print(response.read())
</code></pre>
</div>
<span class="comment-copy">Do you want to ensure that the certificate is valid?</span>
<span class="comment-copy">Check out <a href="http://stackoverflow.com/questions/635113/python-urllib2-basic-http-authentication-and-tr-im" title="python urllib2 basic http authentication and tr im">stackoverflow.com/questions/635113/…</a> . It seems to cover exactly what you're looking for.</span>
<span class="comment-copy">The <code>request</code> method documentation[1] mentions that "Strings are encoded as "ISO-8859-1", the default charset for HTTP". So i suggest to decode with "ISO-8859-1" instead of "ASCII".  [1] <a href="https://docs.python.org/3/library/http.client.html#http.client.HTTPConnection.request" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">To use variables instead of <code>b"username:password"</code>, use: <code>bytes(username + ':' + password, "utf-8")</code>.</span>
<span class="comment-copy">@jgomo3: The <code>.decode("ascii")</code> is only for the <code>bytes</code> -&gt; <code>str</code> conversion.  The result of <code>b64encode</code> is ASCII-only anyway.</span>
<span class="comment-copy">Thanks for your help ..</span>
<span class="comment-copy">Now I understand why they say <code>request</code> is for humans!</span>
<span class="comment-copy">Didn't work, I got the following error:     raise SSLError(e) requests.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:600)</span>
<span class="comment-copy">That seems to be for pyhthon 2.5 im using 3</span>
<span class="comment-copy">Are you using easy install or pip ? Is the pycurl package unavailable for python 3 ?</span>
<span class="comment-copy">Updated with an httplib2. This is available for python 3.</span>
<span class="comment-copy">For those who are new: the above example is missing a dot: "pycurl.HTTPHEADER" (I would edit but it's 1 character and minimum is 6).</span>
<span class="comment-copy">OP said GET, not POST</span>
<span class="comment-copy">This is great. Certificate verification is important when sending plain text credentials (HTTP Basic Auth). You need to make sure your TLS layer (HTTPS) is secure then because you’re relying on that layer to be secure.</span>
