<div class="post-text" itemprop="text">
<p>I need a hash function to take a sequence of decimal numbers and return a decimal number as hash value.</p>
<p>for example:</p>
<pre><code>&gt;&gt; def my_simple_hash(*args):
    return reduce(lambda x1, x2: 2*x1 + x2,  args) 

&gt;&gt;&gt; my_simple_hash(1,3,4)
14
&gt;&gt;&gt; my_simple_hash(1,4,3)
15
&gt;&gt;&gt; my_simple_hash(4,3,1)
23
</code></pre>
<p>My questions are:</p>
<ol>
<li>does python has a built-in lib to do this more efficiently?  </li>
<li>how could I make the output hash value in a relative small range?</li>
</ol>
<p>Question 2 explanation:</p>
<p>because 1, 3, 4 has six different combinations as following:</p>
<pre><code>1,3,4
1,4,3
3,1,4
3,4,1
4,1,3
4,3,1
</code></pre>
<p>the corresponding output is <code>[14, 15, 18, 21, 21, 23]</code>, and I expect the hash values of the <code>six</code> output would be something like <code>[1,2,3,4,6]</code>(a small range)</p>
<p>any suggestions would be appreciated. 
thanks in advance :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just want to hash a number sequence you can do</p>
<pre><code>def my_hash(*args):
    return hash(args)
</code></pre>
<p>which returns the <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow">hash</a> (for the current run of the program) of the args-tuple (<code>hash</code> is fast and well tested for builtin-types) - but this is still most often a large number.</p>
<p>For getting a smaller value you can take the modulo like</p>
<pre><code>def my_hash(*args):
    return hash(args)%10 # or whatever number you like
</code></pre>
<p>Actually you could also use</p>
<pre><code>def my_hash(*args):
    return sum(args)%10 # or whatever number you like
</code></pre>
<p>which doesnt change between runs of the program but <code>sum</code> does not distribute the results evenly at all.</p>
<p><strong>Warning: These are not cryptographical hashes</strong></p>
</div>
<span class="comment-copy">I would generally advise not to roll your own, and instead go with a hash thatâ€™s virtually guaranteed not to have collisions (<code>hashlib.sha256()</code>).</span>
<span class="comment-copy">That strongly depends on what you want - sha256 is a cryptographic hash function that is relatively slow to calculate, takes bytes-input and produces bytes output. good non-cryptographic hashes are fast to compute, have an even distribution of resulting values and not too many collisions.</span>
<span class="comment-copy">What do you intend to do with this hash? How large is the domain of the input integers, what's a typical size of an input sequence, and how large should the range of the output be? How important is collision avoidance? Your needs may be satisfied by a variant of <a href="https://en.wikipedia.org/wiki/Format-preserving_encryption" rel="nofollow noreferrer">format-preserving encryption</a>, either a full cryptographic-strength implementation, or a faster, simpler version.</span>
<span class="comment-copy">@PM2Ring, I want to use a single decimal num to identify a sequence of numbers.</span>
<span class="comment-copy">hi, @janbrohl, does python2 have a similar function like <code>hash</code>?</span>
<span class="comment-copy">Yes (<a href="https://docs.python.org/2/library/functions.html#hash" rel="nofollow noreferrer">same name</a>) - It possibly returns different values but it is essentially the same</span>
<span class="comment-copy">Most stuff didnt change (much) from Python 2.7 to 3.x and <i>simple</i> programs work on both requiring ony minimal changes (or none at all)</span>
<span class="comment-copy">thanks for your answer. :-)</span>
<span class="comment-copy">I marked the answer as accepted, but for the second question, the output will be in range 0 to 9 if I use <code>%10</code> and thus cause collisions. I will use a dict to map every hash values to my desire numbers.</span>
