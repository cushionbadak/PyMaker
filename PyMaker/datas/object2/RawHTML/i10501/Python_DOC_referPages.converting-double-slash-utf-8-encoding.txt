<div class="post-text" itemprop="text">
<p>I cannot get this to work!  I have a text file from a save game file parser with a bunch of UTF-8 Chinese names in it in byte form, like this in the source.txt:</p>
<p>\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89</p>
<p>But, no matter how I import it into Python (3 or 2), I get this string, at best:</p>
<p>\\xe6\\x89\\x8e\\xe5\\x8a\\xa0\\xe6\\x8b\\x89</p>
<p>I have tried, like other threads have suggested, to re-encode the string as UTF-8 and then decode it with unicode escape, like so:</p>
<pre><code>stringName.encode("utf-8").decode("unicode_escape")
</code></pre>
<p>But then it messes up the original encoding, and gives this as the string:</p>
<p>'æ\x89\x8eå\x8a\xa0æ\x8b\x89' (printing this string results in: æå æ )</p>
<p>Now, if I manually copy and paste b + the original string in the filename and encode this, I get the correct encoding.  For example:</p>
<pre><code>b'\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89'.encode("utf-8")
</code></pre>
<p>Results in:  '扎加拉'</p>
<p>But, I can't do this programmatically.  I can't even get rid of the double slashes.  </p>
<p>To be clear, source.txt contains single backslashes.  I have tried importing it in many ways, but this is the most common: </p>
<pre><code>with open('source.txt','r',encoding='utf-8') as f_open:
    source = f_open.read()
</code></pre>
<p>Okay, so I clicked the answer below (I think), but here is what works:</p>
<pre><code>from ast import literal_eval
decodedString = literal_eval("b'{}'".format(stringVariable)).decode('utf-8')
</code></pre>
<p>I can't use it on the whole file because of other encoding issues, but extracting each name as a string (stringVariable) and then doing that works!  Thank you!</p>
<p>To be more clear, the original file is not just these messed up utf encodings.  It only uses them for certain fields.  For example, here is the beginning of the file:</p>
<pre><code>{'m_cacheHandles': ['s2ma\x00\x00CN\x1f\x1b"\x8d\xdb\x1fr \\\xbf\xd4D\x05R\x87\x10\x0b\x0f9\x95\x9b\xe8\x16T\x81b\xe4\x08\x1e\xa8U\x11',
                's2ma\x00\x00CN\x1a\xd9L\x12n\xb9\x8aL\x1d\xe7\xb8\xe6\xf8\xaa\xa1S\xdb\xa5+\t\xd3\x82^\x0c\x89\xdb\xc5\x82\x8d\xb7\x0fv',
                's2ma\x00\x00CN\x92\xd8\x17D\xc1D\x1b\xf6(\xedj\xb7\xe9\xd1\x94\x85\xc8`\x91M\x8btZ\x91\xf65\x1f\xf9\xdc\xd4\xe6\xbb',
                's2ma\x00\x00CN\xa1\xe9\xab\xcd?\xd2PS\xc9\x03\xab\x13R\xa6\x85u7(K2\x9d\x08\xb8k+\xe2\xdeI\xc3\xab\x7fC',
                's2ma\x00\x00CNN\xa5\xe7\xaf\xa0\x84\xe5\xbc\xe9HX\xb93S*sj\xe3\xf8\xe7\x84`\xf1Ye\x15~\xb93\x1f\xc90',
                's2ma\x00\x00CN8\xc6\x13F\x19\x1f\x97AH\xfa\x81m\xac\xc9\xa6\xa8\x90s\xfdd\x06\rL]z\xbb\x15\xdcI\x93\xd3V'],
'm_campaignIndex': 0,
'm_defaultDifficulty': 7,
'm_description': '',
'm_difficulty': '',
'm_gameSpeed': 4,
'm_imageFilePath': '',
'm_isBlizzardMap': True,
'm_mapFileName': '',
'm_miniSave': False,
'm_modPaths': None,
'm_playerList': [{'m_color': {'m_a': 255, 'm_b': 255, 'm_g': 92,   'm_r': 36},
               'm_control': 2,
               'm_handicap': 0,
               'm_hero': '\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89',
</code></pre>
<p>All of the information before the 'm_hero': field is not utf-8.  So using ShadowRanger's solution works if the file is only made up of these fake utf-encodings, but it doesn't work when I have already parsed m_hero as a string and try to convert that.  Karin's solution does work for that.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming you're using Python 3. In Python 2, strings are bytes by default, so it would just work for you. But in Python 3, strings are unicode and interpretted as unicode, which is what makes this problem harder if you have a byte string being read as unicode.</p>
<p>This solution was inspired by mgilson's answer. We can literally evaluate your unicode string as a byte string by using <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>literal_eval</code></a>:</p>
<pre><code>from ast import literal_eval

with open('source.txt', 'r', encoding='utf-8') as f_open:
    source = f_open.read()
    string = literal_eval("b'{}'".format(source)).decode('utf-8')
    print(string)  # 扎加拉
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <a href="https://docs.python.org/3/library/codecs.html#python-specific-encodings" rel="noreferrer">the <code>unicode_escape</code> codec is implicitly decoding the result of the escape fixes by assuming the bytes are <code>latin-1</code>, not <code>utf-8</code></a>. You can fix this by:</p>
<pre><code># Read the file as bytes:
with open(myfile, 'rb') as f:
    data = f.read()

# Decode with unicode-escape to get Py2 unicode/Py3 str, but interpreted
# incorrectly as latin-1
badlatin = data.decode('unicode-escape')

# Encode back as latin-1 to get back the raw bytes (it's a 1-1 encoding),
# then decode them properly as utf-8
goodutf8 = badlatin.encode('latin-1').decode('utf-8')
</code></pre>
<p>Which (assuming the file contains the literal backslashes and codes, not the bytes they represent) leaves you with <code>'\u624e\u52a0\u62c9'</code> (Which should be correct, I'm just on a system without font support for those characters, so that's just the safe <code>repr</code> based on Unicode escapes). You could skip a step in Py2 by using the <code>string-escape</code> codec for the first stage <code>decode</code> (which I believe would allow you to omit the <code>.encode('latin-1')</code> step), but this solution should be portable, and the cost shouldn't be terrible.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do some silly things like <code>eval</code>uating the string:</p>
<pre><code>import ast
s = r'\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89'
print ast.literal_eval('"%s"' % s).decode('utf-8')
</code></pre>
<ul>
<li>note use <code>ast.literal_eval</code> if you don't want attackers to gain access to your system :-P</li>
</ul>
<p>Using this in your case would probably look something like:</p>
<pre><code>with open('file') as file_handle:
    data = ast.literal_eval('"%s"' % file.read()).decode('utf-8')
</code></pre>
<p>I think that the real issue here is <em>likely</em> that you have a file that contains strings representing bytes (rather than having a file that just stores the bytes themselves).  So, fixing whatever code generated that file in the first place is probably a better bet.  However, barring that, this is the next best thing that I could come up with ...</p>
</div>
<div class="post-text" itemprop="text">
<p>Solution in Python3 with only string manipulations and encoding conversions without evil <code>eval</code> :)
</p>
<pre><code>import binascii

str = '\\xe6\\x89\\x8e\\xe5\\x8a\\xa0\\xe6\\x8b\\x89'
str = str.replace('\\x', '')  # str == 'e6898ee58aa0e68b89'

# we can use any encoding as long as it translate ascii as is,
# for example we can do str.encode('ascii') here
str = str.encode('utf8')  # str == b'e6898ee58aa0e68b89'

str = binascii.a2b_hex(str)  # str == b'\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89'
str = str.decode('utf8')  # str == '扎加拉'
</code></pre>
<p>If you like an one-liner, then we can put it simply as:
</p>
<pre><code>binascii.a2b_hex(str.replace('\\x', '').encode()).decode('utf8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>at the end of day, what you get back is a string right? i would use string.replace method to convert double slash to single slash and add b prefix to make it work. </p>
</div>
<div class="post-text" itemprop="text">
<p>So there are several different ways to interpret having the data "in byte form." Let's assume you really do:</p>
<pre class="lang-py prettyprint-override"><code>s = b'\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89'
</code></pre>
<p>The <code>b</code> prefix indicates those are bytes. Without getting into the 
whole mess that is bytes vs codepoints/characters and the long differences
between Python 2 and 3, the <code>b</code>-prefixed string indicates those are intended 
to be bytes (e.g. raw UTF-8 bytes).</p>
<p>Then just decode it, which converts UTF-8 encoding (which you already
have in the bytes, into true Unicode characters. In Python 2.7, e.g.:</p>
<pre><code>print s.decode('utf-8')
</code></pre>
<p>yields:</p>
<pre><code>扎加拉
</code></pre>
<p>One of your examples did an encode followed by a decode, which can only lead to sorrow and pain. If your variable holds true UTF-8 bytes, you only need the decode.</p>
<p><strong>Update</strong> Based on discussion, it appears the data isn't really in UTF-8 bytes, but a string-serialized version of same. There are a lot of ways to get from string serial to bytes. Here's mine:</p>
<pre><code>from struct import pack

def byteize(s):
    """
    Given a backslash-escaped string serialization of bytes,
    decode it into a genuine byte string.
    """
    bvals = [int(s[i:i+2], 16) for i in range(2, len(s), 4)]
    return pack(str(len(bvals)) + 'B', *bvals)
</code></pre>
<p>Then:</p>
<pre><code>print byteize(s).decode('utf-8')
</code></pre>
<p>as before yields:</p>
<pre><code>扎加拉
</code></pre>
<p>This <code>byteize()</code> isn't as general as the <code>literal_eval()</code>-based <a href="https://stackoverflow.com/a/39283896/240490">accepted answer</a>, but <code>%timeit</code> benchmarking shows it to be about 33% faster on short strings. It could be further accelerated by swapping out <code>range</code> for <code>xrange</code> under Python 2. The <code>literal_eval</code> approach wins handily on long strings, however, given its lower-level nature.</p>
<pre><code>100000 loops, best of 3: 6.19 µs per loop
100000 loops, best of 3: 8.3 µs per loop
</code></pre>
</div>
<span class="comment-copy">Does <code>source.txt</code> actually contain the backslashes, or is that how it looks when you display it in Python? Also, how are you "importing" it into Python? Are you reading from a file? How is that file opened?</span>
<span class="comment-copy">Okay, this doesn't work for the source file because of other data in the source file, but it works on a string to string basis, like so:  from ast import literal_eval string = literal_eval("b'{}'".format(heroName)).decode('utf-8')</span>
<span class="comment-copy">This is... suboptimal. Faking out a string representing a bytes object to use the literal parsing instead of using <code>unicode-escape</code> (or <code>string-escape</code>) for <code>decode</code>-ing is extremely tricky to get right, and risks problems if, say, the incoming data happened to not use pure escapes; a literal single-quote in there, and this explodes, where using the correct codec has no such edge cases.</span>
<span class="comment-copy">@ShadowRanger - yes, this doesn't work for the whole file; it immediately throws the error bad syntax because there is other data in the file that IS NOT UTF-8 encoding that it tries to decode as UTF-8:     b'{'m_cacheHandles': ['s2ma\x00\x00CN\x1f\x1b"\x8d\xdb\x1fr \\\xbf\xd4D\x05R\x87\x10\x0b\x0f9\x95\x9b\xe8\x16T\x81b\xe4\x08\x1e\xa8U\x11',                      ^ SyntaxError: invalid syntax  But it does work on a string by string basis, which is good enough for what I need.</span>
<span class="comment-copy">@ShadowRanger Happy to upvote your answer. I have no idea how OP got to this state, so I made no assumptions about it. As others have pointed out, it's best to fix the actual writing of the file so that it can be easily read as utf-8 encoded. But, if we just have a string of byte representations as a string, and need it as bytes, this was the simplest generic thing I could think of. Clearly the problem could be a more specific one (and therefore have a more specific solution) as you deduced.</span>
<span class="comment-copy">Obviously, in Py3 (or Py2 with <code>io.open</code>) you can remove the explicit <code>decode</code> with <code>unicode-escape</code> by opening in text mode with <code>encoding='unicode-escape'</code>, assuming your file should be interpreted solely in that mode. The example above was split up to make the steps obvious, that's all.</span>
<span class="comment-copy">This doesn't work for my file, it throws an error because of other data in the file: 'utf-8' codec can't decode byte 0x8d in position 32: invalid start byte  It also doesn't work on a per string basis like Karin's suggestion does.</span>
<span class="comment-copy">@JeremySchutte Other data in the file that you didn't show?? Are the answers supposed to be mind readers?  This answer is correct for the question as asked.</span>
<span class="comment-copy">@MarkTolonen - You're right.  I updated the original question to reflect this.</span>
<span class="comment-copy">I can't convert the double slashes to single slashes without copying from the console, so this won't work</span>
<span class="comment-copy">@JeremySchutte: The <code>r</code> is confusing you, but you do have bytes similar to what is shown.</span>
<span class="comment-copy">I can't hardcode this: r'\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89' And obviously typing: rSTRINGVARIABLE Doesn't work</span>
<span class="comment-copy">@JeremySchutte -- I'm not suggesting that you do.  I'm saying that as I understand your problem, <code>s</code> <i>should</i> be analogous to a line in your file.  so <code>for line in your_file:  print ast.literal_eval('"%s"' % line)</code> seems like it should do the trick (unless I'm misunderstanding the issue)</span>
<span class="comment-copy">How can I do this without copy pasting every string?</span>
<span class="comment-copy">what is the output when you print source?</span>
<span class="comment-copy">I think that OP <i>doesn't</i> have it in "byte" form.  You've got a string of bytes there -- OP seems to have a file of strings that contain the byte representations.  I'm not completely sure how OP got in <i>that</i> mess, but assuming that fixing it at the source isn't an option, I don't think that this is going to help.</span>
<span class="comment-copy">Yes, I can't get a string represented like:     s = b'\xe6\x89\x8e\xe5\x8a\xa0\xe6\x8b\x89' At best, I can get:    s = "b'\\xe6\\x89\\x8e\\xe5\\x8a\\xa0\\xe6\\x8b\\x89'"</span>
<span class="comment-copy">It was unclear to me. OP claimed to have it "in byte form." If not in UTF-8 bytes yet, but a further serialization of UTF-8, clearly it has to be brought to true UTF-8 data first.</span>
