<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/14345941/what-are-the-differences-between-lazy-greedy-and-possessive-quantifiers">What are the differences between lazy, greedy and possessive quantifiers?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm trying to parse the output that looks like below.</p>
<pre><code>1  192.168.1.1         0.706 ms  0.654 ms  0.697 ms 
2  10.10.10.10         4.215 ms  4.199 ms  4.175 ms
3  123.123.123.123     4.000 ms * *
</code></pre>
<p>I have regular expression that works, which is as follows.</p>
<p><strong>This regex works:</strong></p>
<pre><code>re.compile(r'^\s*(\d+)\s+?([\s\S]+?(?=^\s*\d+\s+))', re.M)
</code></pre>
<p>This will  capture each line properly.</p>
<pre><code>('1', ' 192.168.7.1         0.706 ms  0.654 ms  0.697 ms\n')
('2', ' 10.10.10.10         4.215 ms  4.199 ms  4.175 ms\n')
('3', ' 123.123.123.123     4.000 ms  * *\n')
</code></pre>
<p>My question is what does the bold <strong>?</strong> do that is in front of (?=^\s*\d+\s+) </p>
<p>i.e.  Changing the regular expression to as follows.</p>
<p><strong>This regex does not work</strong>. The only difference is the ? mark removed.</p>
<pre><code>re.compile(r'^\s*(\d+)\s+?([\s\S]+(?=^\s*\d+\s+))', re.M)
</code></pre>
<p>I have tried this and it does not work. It will not parse each line separately. </p>
<p>Could anyone help me interpret this regular expression?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/library/re.html" rel="nofollow">re docs</a>:</p>
<blockquote>
<p><code>*?</code>, <code>+?</code>, <code>??</code></p>
<p>The <code>'\*'</code>, <code>'+'</code>, and <code>'?'</code> qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isnâ€™t desired; if the RE <code>&lt;.*&gt;</code> is matched against <code>&lt;a&gt; b &lt;c&gt;</code>, it will match the entire string, and not just <code>&lt;a&gt;</code>. Adding <code>?</code> after the qualifier makes it perform the match in <em>non-greedy or minimal fashion</em>; as few characters as possible will be matched. Using the RE <code>&lt;.*?&gt;</code> will match only <code>&lt;a&gt;</code>.</p>
</blockquote>
<p>So in your case, <code>[\s\S]+?</code> will match a space or non-space character minimally, whereas <code>[\s\S]+</code> would greedily match as many characters as it can.</p>
</div>
<div class="post-text" itemprop="text">
<p>That question mark has no meaning by itself - the specific sequence <code>(?=</code> starts a "positive lookahead assertion", which basically requires that the contents of the regexp up to the next close paren has to be present in the string being searched, but doesn't count as part of the regexp match.</p>
<p>There are several advanced regexp features that start with <code>(?</code> - see the documentation for the re module for full details.  That particular sequence is used for such extensions, because it is otherwise meaningless in a regexp - an open paren has to be followed by something, and a question mark has to be preceded by something.</p>
</div>
