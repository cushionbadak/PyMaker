<div class="post-text" itemprop="text">
<p>I have the following class:</p>
<pre><code>class Members(object):
    def __init__(self, variable=50):
        self.__myvariable = variable

    def getVariable(self):
        return self.__myvariable

    # attempt 1
    def __repr__(self):
        return """{self.__class__.__name__}({self.getVariable()})""".format(self=self)

    # attempt 2
    def __repr__(self):
        return """{self.__class__.__name__}({self.__myvariable})""".format(self=self)
</code></pre>
<p>I cannot find a way to print the __ variables in a format string by using the <strong>self</strong> as a key, why is that so?</p>
<p>The error I get is</p>
<pre><code>AttributeError: 'Members' object has no attribute 'getVariable()'
AttributeError: 'Members' object has no attribute '__myvariable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Attempt 1 fails because <a href="https://docs.python.org/2/library/string.html#format-examples" rel="nofollow">format function</a> does not call method at all </p>
<p>Attempt 2 fails because of name mangling behavior, see <a href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" rel="nofollow">PEP8</a></p>
<pre><code>- __double_leading_underscore: when naming a class attribute, invokes name
  mangling (inside class FooBar, __boo becomes _FooBar__boo; see below).
</code></pre>
<p>By reading <a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow">498</a>, which is released with 3.60a1, you can do this and you will get "Members(50)":</p>
<pre><code>class Members(object):

    # attempt 3
    def __repr__(self):
        return f'{self.__class__.__name__}({self.getVariable()})'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When an attribute is <a href="https://docs.python.org/3/tutorial/classes.html#tut-private" rel="nofollow">private</a> (starting with two underscores <code>__</code>), its real name when running is <code>_ClassName__attribute</code>. So, to get <code>__myvariable</code>, you should ask for <code>_Members__myvariable</code>:</p>
<pre><code>def __repr__(self):
    return '{self.__class__.__name__}({self._Members__myvariable})'.format(self=self)
</code></pre>
<p>Examples in console:</p>
<pre><code>&gt;&gt;&gt; m = Members()
&gt;&gt;&gt; m
Members(50)
&gt;&gt;&gt; m._myvariable
50
&gt;&gt;&gt; m.getVariable()
50
&gt;&gt;&gt; m.__myvariable
AttributeError: 'Members' object has no attribute '__myvariable'
&gt;&gt;&gt; m._Members__myvariable
50
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could format it like this instead:</p>
<pre><code>    def __repr__(self):
        return "{}({})".format(self.__class__.__name__,self.getVariable())
</code></pre>
<p>or like this:</p>
<pre><code>    def __repr__(self):
        return "{}({})".format(self.__class__.__name__,self.__myvariable)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't access <code>__myvariable</code> because names with two leading __ get mangled (see <a href="https://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes">Does Python have “private” variables in classes?</a>)</p>
<p>And python doesn't do variable interpolation so the other method is not going to work either (see <a href="https://stackoverflow.com/questions/19796123/python-string-format-calling-a-function">python string format calling a function</a>)</p>
<p>You could, instead, do</p>
<pre><code>return """{0}({1})""".format(self.__class__.__name__, self.getVariable())
</code></pre>
</div>
<span class="comment-copy">so string format function does not understand methods only attributes ?</span>
<span class="comment-copy">by reading format <a href="https://www.python.org/dev/peps/pep-3101/" rel="nofollow noreferrer">PEP-3101</a>, there isn't a line about calling method of a supplied object. You might be able to provide your own formatter, please see the custom formatter section.</span>
<span class="comment-copy">see my updates regarding calling method in a formatted string.</span>
<span class="comment-copy">The point which I am not understanding is that if it does get mangled then how come the getVariable() is able to access it? What is the difference between getVariable in the outer scope and in the string?</span>
<span class="comment-copy">The function <code>getVariable</code> is created in the context of the <code>Members</code> class, and so the python compiler can change the variable name being accessed to the mangled version during compilation. The same cannot be done for the string format as the compiler doesn't know it needs to inspect the string.</span>
