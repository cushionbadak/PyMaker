<div class="post-text" itemprop="text">
<p>I'm familiar with the <code>csv</code> Python module, and believe it's necessary in my case, as I have some fields that contain the delimiter (<code>|</code> rather than <code>,</code>, but that's irrelevant) within quotes.</p>
<p>However, I am also looking for the byte-count length of each original row, <em>prior</em> to splitting into columns. I can't count on the data to always quote a column, and I don't know if/when <code>csv</code> will strip off outer quotes, so I don't think (but might be wrong) that simply joining on my delimiter will reproduce the original line string (less CRLF characters). Meaning, I'm not positive the following works:</p>
<pre><code>with open(fname) as fh:
    reader = csv.reader(fh, delimiter="|")
    for row in reader:
        original = "|".join(row) ## maybe?
</code></pre>
<p>I've tried looking at <code>csv</code> to see if there was anything in there that I could use/monkey-patch for this purpose, but since <code>_csv.reader</code> is a <code>.so</code>, I don't know how to mess around with that.</p>
<p>In case I'm dealing with an XY problem, my ultimate goal is to read through a CSV file, extracting certain fields and their overall file offsets to create a sort of look-up index. That way, later, when I have a list of candidate values, I can check each one's file-offset and <code>seek()</code> there, instead of chugging through the whole file again. As an idea of scale, I might have 100k values to look up across a 10GB file, so re-reading the file 100k times doesn't feel efficient to me. I'm open to other suggestions than the CSV module, but will still need <code>csv</code>-like intelligent parsing behavior. </p>
<p>EDIT: Not sure how to make it more clear than the title and body already explains - simply <code>seek()</code>-ing on a file handle isn't sufficient because I <strong>also</strong> need to parse the lines as a <code>csv</code> in order to pull out additional information.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't subclass <code>_csv.reader</code>, but the <em><code>csvfile</code></em> argument to the <code>csv.reader()</code> <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow">constructor</a> only has to be a "file-like object". This means you could supply an instance of your own class that does some preprocessingâ€”such as remembering the length of the last line read and file offset. Here's an implementation showing exactly that. Note that the line length does <em>not</em> include the end-of-line character(s). It also shows how the offsets to each line/row could be stored and used after the file is read.</p>
<pre><code>import csv

class CSVInputFile(object):
    """ File-like object. """
    def __init__(self, file):
        self.file = file
        self.offset = None
        self.linelen = None
    def __iter__(self):
        return self
    def __next__(self):
        offset = self.file.tell()
        data = self.file.readline()
        if not data:
            raise StopIteration
        self.offset = offset
        self.linelen = len(data)
        return data
    next = __next__

offsets = []  # remember where each row starts
fname = 'unparsed.csv'
with open(fname) as fh:
    csvfile = CSVInputFile(fh)
    for row in csv.reader(csvfile, delimiter="|"):
        print('offset: {}, linelen: {}, row: {}'.format(
            csvfile.offset, csvfile.linelen, row))  # file offset and length of row
        offsets.append(csvfile.offset)  # remember where each row started
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Depending on performance requirements and the size of the data, the low tech solution is to simply read the file twice. Make a first pass where you get the length of each line, and then then you can run the data through the csv parser. On my somewhat outdated Mac I can read and count the length of 2-3 million lines in a second, which isn't a huge performance hit.</p>
</div>
<span class="comment-copy">CSV is not well suited to this task.  Do you control the code that produces .CSV?  Could it produces a different format instead?</span>
<span class="comment-copy">@JeffreyRennie I don't control the CSV, so can't control the format. Even if I could, I'd still be intrigued as to how that could simplify things - for example, I don't think fixed-width would be great because some columns are text columns, so forcing fixed-width would balloon the size into something even less manageable (there are already grumblings about 10GB files). Were you thinking something else?</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/19782392/how-to-populate-list-of-starting-positions-of-each-line-using-for-loop-and-tell">How to Populate List of Starting Positions of Each Line Using For-loop and Tell Function?</a></span>
<span class="comment-copy">@NoctisSkytower - how do I still use <code>csv</code>-style parsing with that? I know how to seek in a file, but I <i>also</i> need to have properly-parsed rows. I feel that my question contains more than is contained in any "use the <code>csv</code> module" answer, and contains more than "<code>use </code>seek()`" answer as you just said it's a duplicate. What am I missing?</span>
<span class="comment-copy">You can wrap a file object, and while reading over the lines, you can track how much data has been passed through the iterator. That will at least give you an approximate location of where you are reading from in the file. Otherwise, you might consider inheriting one of the classes in the <code>csv</code> module and overriding its reading behavior so that it supports what you want.</span>
<span class="comment-copy">I considered hacking on the more-complex <code>csv.reader</code> class, but missed a simpler solution hacking on the <code>file-like</code> class - thanks!</span>
<span class="comment-copy">You're welcome. This approach is good to keep in mind when processing CVS files because it allows you to extend can be done with the <code>csv</code> module and can be applied to either/both csv file reading and writing. Here's one <a href="http://stackoverflow.com/a/30226173/355230">example</a> and <a href="http://stackoverflow.com/a/38758467/355230">another</a>.</span>
<span class="comment-copy">This deserves more upvotes.  I'm using this in a custom Pytorch DataLoader class with some really tricky CSV files and it's working like a dream.  I tried several other approaches to this probelm of indexing CSV files in preparation for random access and this proved to be the most reliable.</span>
<span class="comment-copy">That's what I ended up doing in the temporary case - I thought my Mac was shiny and new and fast, but mine took maybe a minute :).</span>
