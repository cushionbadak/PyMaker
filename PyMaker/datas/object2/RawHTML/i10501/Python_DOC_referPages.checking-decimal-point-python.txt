<div class="post-text" itemprop="text">
<p>I'm trying to create a script that counts to 3 (step size 0.1) using while, and I'm trying to make it not display .0 for numbers without decimal number (1.0 should be displayed as 1, 2.0 should be 2...)
What I tried to do is convert the float to int and then check if they equal. the problem is that it works only with the first number (0) but it doesn't work when it gets to 1.0 and 2.0..</p>
<p>this is my code:</p>
<pre><code>i = 0
while i &lt; 3.1:
    if int(i) == i:
        print int(i)
    else:
        print i
    i = i + 0.1
</code></pre>
<p>that's the output I get:</p>
<pre><code>0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
1.1
1.2
1.3
1.4
1.5
1.6
1.7
1.8
1.9
2.0
2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
3.0
</code></pre>
<p>the output I should get:</p>
<pre><code>0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1.1
1.2
1.3
1.4
1.5
1.6
1.7
1.8
1.9
2
2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
3
</code></pre>
<p>thank you for your time.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can remove trailing zeros with '{0:g}'.format(1.00).</p>
<pre><code>i = 0
while i &lt; 3.1:
    if int(i) == i:
        print int(i)
    else:
        print '{0:g}'.format(i)
    i = i + 0.1
</code></pre>
<p>See: <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow">https://docs.python.org/3/library/string.html#format-specification-mini-language</a></p>
<p>Update: Too lazy while copy/pasting. Thanks @aganders3</p>
<pre><code>i = 0
while i &lt; 3.1:
    print '{0:g}'.format(i)
    i = i + 0.1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Due to lack of precision in floating point numbers, they will not have an exact integral representation. Therefore, you want to make sure the difference is smaller than some small <code>epsilon</code>.</p>
<pre><code>epsilon = 1e-10
i = 0
while i &lt; 3.1:
    if abs(round(i) - i) &lt; epsilon:
        print round(i)
    else:
        print i
    i = i + 0.1
</code></pre>
</div>
<span class="comment-copy">Floating point numbers are not exact.  There are many good tutorials on this.  For example, see <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="nofollow noreferrer">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.</span>
<span class="comment-copy">Floating point arithmetic is approximate. When you add <code>.1</code> 10 times, you don't get <code>1.0</code>.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a></span>
<span class="comment-copy">@John1024 and Barmar thank you!</span>
<span class="comment-copy">Good answer, but I think you should then skip the if/else conditions.</span>
<span class="comment-copy">Thank you! Can't accept the answer yet.. what does epsilon means? What is that 1e-10</span>
<span class="comment-copy">Python 3 has an <code>isclose</code> function that solves this problem. It just means that if the difference is really small, it must be an "integer"</span>
<span class="comment-copy"><code>epsilon</code> is just kind of a math-y term for a very small number. <code>1e-10</code> is equal to <code>1 * 10 ^ -10</code> which is <code>0.0000000001</code></span>
<span class="comment-copy">@aganders3 ok thank you! and what happens if I want to count to 10 instead of 3? When I tried using epsilon it worked just untill 4..</span>
<span class="comment-copy">@morha13 thanks, this causes issues because sometimes the floating point representation is smaller than the integer by a bit, and <code>int()</code> will simply truncate the decimals. I updated my answer to use <code>round</code> instead.</span>
