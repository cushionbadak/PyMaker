<div class="post-text" itemprop="text">
<p>Based on the explanation on <a href="https://stackoverflow.com/questions/1537202/variables-inside-and-outside-of-a-class-init-function">Shared Variables in Python Class</a> here , I expected the following code to give output as :</p>
<pre><code>123 123
200 200
300 300
</code></pre>
<p>But it is </p>
<pre><code>123 123
200 123
200 300
</code></pre>
<p>Code:</p>
<pre><code>class A:
    abc = 123
    def __init__(self, a,b,c):
        self._a = a
        self._b = b
        self._c = c


if __name__ == '__main__':
    a = A(2, 4, 6)
    b = A(3, 9, 27)

    print a.abc , b.abc
    a.abc = 200
    print a.abc , b.abc
    A.abc = 300
    print a.abc , b.abc
</code></pre>
<p>Can somebody please help understand this ? My impression is that shared variables are same as static variables in C++ classes. Any insights to bust that myth, if it is so, would be helpful too. </p>
</div>
<div class="post-text" itemprop="text">
<p>Initially, the class A has an <code>abc</code> defined to be 123, which each of <code>a</code> and <code>b</code> use since neither has an <code>abc</code> of their own.</p>
<p>Then you execute <code>a.abc = 200</code>, which creates an <code>abc</code> for <code>a</code>; <code>b</code> still uses the one from <code>A</code>.</p>
<p>Then you execute <code>A.abc = 300</code>, which updates the <code>abc</code> for <code>A</code>, which <code>b</code> still looks to, so it see the new value.  But <code>a</code> has its own <code>abc</code>, and so doesn't care.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are creating a new instance variable -&gt; <code>a.abc</code> and setting it to <code>200</code>. Access the shared static variable instead.</p>
<pre><code>a = A(2, 4, 6)
b = A(3, 9, 27)
print a.abc , b.abc
A.abc = 200  # Set static class variable, instead of creating new instance member
print a.abc , b.abc
A.abc = 300
print a.abc , b.abc
</code></pre>
<p>I recommend reading the very informative Python official docs on <a href="https://docs.python.org/3/tutorial/classes.html#classes" rel="nofollow">[9] Classes</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/39234412/2373278">@Scott Hunter's answer</a> explains the behavior of code in question best but I would like to add C++ perspective to it here. Unfortunately it couldn't be added as comment in that answer as it is too long. </p>
<p>As in C++, to access static members name needs to be qualified by class name (e.g. <code>A::abc</code> or <code>A::func_static()</code> ) , in Python also you have to access the shared variable outside the class using Class name as qualifier. </p>
<p>Within the class, C++ allows to use the static variable name as like other member variables (i.e. without any qualifier) and same is true with Python as well, as shared variables can be accessed using self such as <code>self.abc</code> here.</p>
<p>Only thing which is different here is Python allows you to create an instance variable with the same name as shared variable for that instance only. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your expected output would mean that you can't change the attribute of an object without changing the attribute of every instance of the objects class. That would obviously break the core of the object orientation idea. I think you can overwrite "shared" variables because this gives just more possibilities.</p>
</div>
<span class="comment-copy">They are different objects, changing one should not affect another.</span>
<span class="comment-copy"><code>a.abc = 200</code>, you create a new instance variable called <code>abc</code> for object a.</span>
<span class="comment-copy">@AhsanulHaque : but "abc" should be shared object per say. Isn't it ?</span>
<span class="comment-copy">when you do <code>a.abc = ...</code> you create an instance variable that is completely seperate from the class variable <code>A.abc</code>, so changing <code>A.abc</code> will reflect that change in all other instances where as <code>a.abc</code> will only change that one instance.</span>
<span class="comment-copy">Change <code>a.abc = 200</code> to `A.abc = 200'</span>
<span class="comment-copy">Thanks. It is helpful.</span>
<span class="comment-copy">I thought the question was <i>why</i> the output was what it was, not how to change the code to produce the expected output.</span>
<span class="comment-copy">It gives unexpected output because of the instance variable being created. I can go into an explanation of python's run-time dispatching, and how classes are objects. Which is why you can add members to at run-time. <code>self</code> and <code>a</code> are just instances, and behave the same. Initializers behave, and are implemented far differently in python then they are in static languages like c/c++. I kept the answer brief.</span>
