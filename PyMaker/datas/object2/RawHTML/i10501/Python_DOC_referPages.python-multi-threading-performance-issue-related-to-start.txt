<div class="post-text" itemprop="text">
<p>I had some performance issues with a multi-threading code to parallelize multiple telnet probes.</p>
<h2>Slow</h2>
<p>My first implementation was is really slow, same a if the tasks were run sequencially:</p>
<pre><code>for printer in printers:
    …
    thread = threading.Thread(target=collect, args=(task, printers_response), kwargs=kw)
    threads.append(thread)

for thread in threads:
    thread.start()
    thread.join()
</code></pre>
<h2>Blastlingly Fast</h2>
<pre><code>for printer in printers:
    …
    thread = threading.Thread(target=collect, args=(task, printers_response), kwargs=kw)
    threads.append(thread)
    thread.start()  # &lt;----- moved this

for thread in threads:
    thread.join()
</code></pre>
<h2>Question</h2>
<p>I don't get why moving the <code>start()</code> method change the performance so much.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your first implementation you are actually running the code sequentially because by <strong>calling <a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow"><code>join()</code></a> immediately after <a href="https://docs.python.org/3/library/threading.html#threading.Thread.start" rel="nofollow"><code>start()</code></a> the main thread is blocked</strong> until the started thread is finished.</p>
</div>
<div class="post-text" itemprop="text">
<p>thread.join() is blocking every thread as soon as they are created in your first implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow">threading.Thread.join()</a> documentation:</p>
<blockquote>
<p>Wait until the thread terminates.
  This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs".</p>
</blockquote>
<p>In your <em>slow</em> example you start the thread and wait till it is complete, then you iterate to the next thread. </p>
<h2>Example</h2>
<pre><code>from threading import Thread
from time import sleep


def foo(a, b):
    while True:
        print(a + ' ' + b)
        sleep(1)

ths = []

for i in range(3):
    th = Thread(target=foo, args=('hi', str(i)))
    ths.append(th)


for th in ths:
    th.start()
    th.join()
</code></pre>
<h3>Produces</h3>
<pre><code>hi 0
hi 0
hi 0
hi 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your slow solution you are basically not using multithreading at all. Id's running a thread, waiting to finish it and then running another - there is no difference in running everything in one thread and this solution - you are running them in series.</p>
<p>The second one on the other hand starts all threads and then joins them. This solution limits the execution time to the longest execution time of one single thread - you are running them in parallel.</p>
</div>
<span class="comment-copy">Damn, and I was wondering the impact of <code>join()</code>. Thanks!</span>
