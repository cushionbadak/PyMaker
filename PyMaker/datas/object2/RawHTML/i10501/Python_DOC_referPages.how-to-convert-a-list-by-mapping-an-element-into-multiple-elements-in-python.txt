<div class="post-text" itemprop="text">
<p>For example,
how to convert [1, 5, 7] into [1,2,5,6,7,8] into python?
[x, x+1 for x in [1,5,7]] can't work for sure...</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if this is the best way, but I would do:</p>
<pre><code>l = [1, 5, 7]
print([y for x in l for y in (x, x + 1)])
</code></pre>
<p>Another way using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>from itertools import chain
l = [1, 5, 7]
print(list(chain.from_iterable((x, x + 1) for x in l)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>And you can always overcomplicate the problem with <a href="https://docs.python.org/2/library/operator.html" rel="nofollow noreferrer"><code>operator</code></a>, <a href="https://docs.python.org/2/library/itertools.html#itertools.imap" rel="nofollow noreferrer"><code>imap()</code></a>, <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>partial()</code></a>, <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow noreferrer"><code>izip()</code></a> and <a href="https://docs.python.org/2/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>chain()</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, izip, imap
&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; 
&gt;&gt;&gt; l = [1, 5, 7]
&gt;&gt;&gt;
&gt;&gt;&gt; list(chain(*izip(l, imap(partial(add, 1), l))))
[1, 2, 5, 6, 7, 8]
</code></pre>
<p>What happens here:</p>
<ul>
<li>we make an iterator over <code>l</code> that applies an <a href="https://docs.python.org/2/library/operator.html#operator.add" rel="nofollow noreferrer"><code>add</code> function</a> with <code>1</code> as an argument</li>
<li>we zip the initial list with the iterator returned by <code>imap()</code> to produce pairs of x, x+1 values</li>
<li>we <a href="https://stackoverflow.com/a/953097/771848">flatten the list with <code>chain()</code></a> and convert it to the list to see the result</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>A simple way to think about the problem is to make a second list of incremented values and add it to the original list, then sort it:</p>
<pre><code>l = [1, 5, 7]
m = l + [i+1 for i in l]
m.sort()
print m  # [1, 2, 5, 6, 7, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make a generator function that iterates over the list and yields, in turn, each element and that element plus one.  Iterate over your generator.</p>
<pre><code>def foo(lyst):
    for element in lyst:
        yield element
        yield element + 1

&gt;&gt;&gt; print(list(foo([1, 5, 7])))
[1, 2, 5, 6, 7, 8]
&gt;&gt;&gt; 
&gt;&gt;&gt; print([element for element in foo([1, 5, 7])])
[1, 2, 5, 6, 7, 8]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can combine some ideas from alecxe's answer and what you already had:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; 
&gt;&gt;&gt; a = [1, 5, 7]
&gt;&gt;&gt; b = ((x, x+1) for x in a)
&gt;&gt;&gt; 
&gt;&gt;&gt; list(itertools.chain(*b))
[1, 2, 5, 6, 7, 8]
</code></pre>
<p>What I have done is :</p>
<ol>
<li><p>Define in <code>b</code> a <a href="https://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow">generator expression</a> which allows us to have (something that looks like) a tuple that would have looked like <code>((1, 2), (5, 6), (7, 8))</code> but without evaluating it right away. It would have also worked with a list comprehension.</p></li>
<li><p><a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow">Unpack <code>b</code> in the argument list</a> of itertools.chain(). It would be the equivalent of <code>itertools.chain((1, 2), (5, 6), (7, 8))</code>. That function concatenates its arguments.</p></li>
<li><p>Use list() to create a list from the return value of the <code>itertools.chain()</code> function since it's an iterator.</p></li>
</ol>
<p>This could also have worked without any intermediate step:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.chain(*((x, x+1) for x in [1, 5, 7])))
[1, 2, 5, 6, 7, 8]
</code></pre>
<p>But "Simple is better than complex"</p>
<p>I hope this helps.</p>
<p>I would have put more links if I had more reputation, sorry.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do your list comprehension logic with tuples and then flatten the resulting list:</p>
<p><code>[n for pair in [(x, x+1) for x in [1,5,7]] for n in pair]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>If you just want to fill the list with the numbers between the min and max+1 values you can use <code>[i for i in range (min(x),max(x)+2)]</code> assuming <code>x</code> is your list.</p>
</div>
<span class="comment-copy">Haha this is hideous ;)</span>
<span class="comment-copy">Yeah, I don't understand the downvote though. This is a working solution <i>with an explanation</i>, links to docs and it even says I understand this is an over-complication of a sort.</span>
<span class="comment-copy">Beats me, I upvoted it.</span>
<span class="comment-copy">Don't think that's what they're trying to achieve.</span>
