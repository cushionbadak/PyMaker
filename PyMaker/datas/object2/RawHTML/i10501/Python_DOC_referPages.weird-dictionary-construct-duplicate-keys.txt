<div class="post-text" itemprop="text">
<p>I needed to write a function that 'maps' -1 to just '-', 1 to '' (yes, nothing) and every other value to a string representation of itself. Instead of using <code>if</code> statements i though i would do it with a dictionary like so:</p>
<pre><code>def adj(my_value):
    return {-1: '-', 1: '', my_value: str(my_value)}[my_value]
</code></pre>
<p>And then it hit me, this dictionary allows duplicate keys and behaves as follows:</p>
<pre><code>for x in [-1, 1, 4]:
    print(adj(x))
# -&gt; -1
# -&gt; 1
# -&gt; 4
</code></pre>
<p>I did run it multiple times to make sure the <code>print()</code> was not "random" since dicts are not ordered but i consistently get this output.</p>
<hr/>
<p>Now this is definitely not the behavior i was going for and in no way can such a construct be trusted but does anyone know why such a thing is even allowed since duplicate keys aren't? How is the calculation performed?</p>
</div>
<div class="post-text" itemprop="text">
<p>The dictionary you made doesn't have duplicate keys.  The "duplicates" overwrote each other. It's just as if you had done this:</p>
<pre><code>d = {}
d[1] = ''
d[1] = 1
print(d[1])
</code></pre>
<p>To demonstrate:</p>
<pre><code>&gt;&gt;&gt; def adj(my_value):
...     d = {-1: '-', 1: '', my_value: str(my_value)}
...     print(d)
...     return d[my_value]
...
&gt;&gt;&gt; for x in [-1, 1, 4]:
...     print(adj(x))
...
{1: '', -1: '-1'}
-1
{1: '1', -1: '-'}
1
{1: '', 4: '4', -1: '-'}
4
</code></pre>
<p>BTW, you could write the function like this:</p>
<pre><code>def adj(my_value)
    d = {-1: '-', 1: ''}
    return d.get(my_value, str(my_value))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quoting the <a href="https://docs.python.org/3/reference/expressions.html#dictionary-displays" rel="nofollow">Python docs</a>:</p>
<blockquote>
<p>If a comma-separated sequence of key/datum pairs is given, they are evaluated from left to right to define the entries of the dictionary: each key object is used as a key into the dictionary to store the corresponding datum. <strong>This means that you can specify the same key multiple times in the key/datum list, and the final dictionaryâ€™s value for that key will be the last one given.</strong></p>
</blockquote>
<p>It's not undefined behavior, it's as if you created an empty dictionary and set each key, one by one. You can fix your code by just shuffling the order around:</p>
<pre><code>def adj(my_value):
    return {my_value: str(my_value), -1: '-', 1: ''}[my_value]
</code></pre>
<p>Other people might find this approach hard to read, though, so you may want to use <code>dict.get</code>'s default value, as the other answers have shown.</p>
<p>Your question was recently asked on the <a href="https://mail.python.org/pipermail/python-ideas/2016-May/040042.html" rel="nofollow">Python mailing list</a> (in an easier to read format <a href="https://code.activestate.com/lists/python-ideas/39826/" rel="nofollow">here</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>By doing <code>{-1: '-', 1: '', my_value: str(my_value)}</code>, you overwrite the <code>-1</code> or <code>1</code> entries if <code>my_value</code> is <code>-1</code> or <code>1</code> respectively. Instead, you can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow"><code>dict.get</code> with a default value</a>:</p>
<pre><code>def adj(my_value):
    return {-1: '-', 1: ''}.get(my_value, str(my_value))
</code></pre>
</div>
<span class="comment-copy">All answers were helpful. Thank you all! Just for the record, I will implement the <code>{}.get()</code> method.</span>
<span class="comment-copy">So the key, value pair is not created unless it doesn't already exist. Nice!</span>
<span class="comment-copy">No, the key-value pair is always created, and will overwrite an existing key if it is a duplicate.</span>
<span class="comment-copy">As can be clearly seen in the output.. I think I am too tired. Thanks man.</span>
<span class="comment-copy">That doesn't make a lot of sense though since it "forces" the interpreter to go through the whole dictionary just to make sure no keys are on the right that overwrite the previous ones. And duplicate keys in a mapping where each object is supposed to correspond to exactly one other is just asking for trouble</span>
<span class="comment-copy">@Ev.Kounis: I'm not sure what you mean by the "go through the whole dictionary" part. Can you elaborate? Dictionary literals are just convenient syntax to create dictionaries. The literal can have duplicate keys, but the dictionary never will.</span>
<span class="comment-copy">Let's say I request a value from a dictionary by providing the key for it. If duplicate keys exist, finding one match does nor mean I can directly get the value for it. The computer has to go through all the entries to make sure no other exists that overwrites the first "hit". Another option would be to start checking from right to left but the notion of direction makes sense only in ordered structures..</span>
<span class="comment-copy">@Ev.Kounis: Dictionary literals (<code>d = {'foo': 2, 'bar': 3}</code>) aren't the way dictionaries look internally. It's just convenient notation for <code>d = dict(); d['foo'] = 2; d['bar'] = 3</code>. If you do <code>d['foo'] = 2; d['foo'] = 3</code>, then <code>d['foo']</code> will be <code>3</code>. The literal notation works no differently. That's what I meant when I said "<i>it's as if you created an empty dictionary and set each key, one by one</i>".</span>
<span class="comment-copy">That means that if I reverse the order and do <code>{my_value: str(my_value), -1: '-', 1: ''}</code> instead I can get the behaviour I want in a way I can trust, right?</span>
<span class="comment-copy">@Ev.Kounis Seems like you could do that, see Blender's answer, but IMHO using <code>get</code> with default is more readable and clearer what is meant.</span>
