<div class="post-text" itemprop="text">
<p>I have a <code>multiprocessing</code> program where</p>
<ul>
<li>one process adds elements to a shared list (<code>multiprocessing.Manager().list()</code>)</li>
<li>several other processes consume these elements from that list (and remove them); they run until there is something to process in the list and the process above is still adding to the list.</li>
</ul>
<p>I implemented locking (via <code>multiprocessing.Lock()</code>) when adding to the list, or removing from it. Since there is one "feeder" process and several (10-40) "consumer" ones all competing for the lock, and that the consumer processes are fast, I end up with the "feeder" process having a hard time acquiring the lock.</p>
<p><strong>Is there a concept of "priority" when acquiring a lock?</strong> I would like the "feeder" process to acquire it with more priority than the others.</p>
<p>Right now I mitigated the issue by having the "consumer" processes wait a random time before trying to acquire the lock while the "feeder" process is there (when it ends it sets a flag). This is a workaround which works but it is ugly and  hardly effective (I have the processes wait <code>random.random()*n</code> seconds, where <code>n</code> is the number of processes. This is a completely made up number, probably wrong). </p>
</div>
<div class="post-text" itemprop="text">
<p>Make the Feeder's acquisition of the lock blocking, and the consumer's non-blocking.<br/>
So for the feeder:</p>
<pre><code>try:
    with my_lock.acquire(): #locks block by default
        do stuff
finally:
    my_lock.release()
</code></pre>
<p>And the consumers:</p>
<pre><code>while True:
   try:
      locked = my_lock.acquire(blocking=False)
      if locked:
         do stuff
   finally:
      if locked:
         my_lock.release()
   time.sleep(seconds=10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of trying to change the locking priority, try changing the process priority itself such that feeder has a higher priority than the consumer. The workaround you used basically simulates this but with less efficiency.</p>
<p>To change process priority,</p>
<blockquote>
<p>On Unix: use os.setpriority()</p>
</blockquote>
<p>Refer the <a href="https://docs.python.org/3/library/os.html#os.setpriority" rel="nofollow noreferrer">docs</a></p>
<blockquote>
<p>On windows, use a third party module psutil.</p>
</blockquote>
<p>Refer to <a href="https://stackoverflow.com/questions/23060383/lowering-process-priority-of-multiprocessing-pool-on-windows">this thread</a> and <a href="https://pythonhosted.org/psutil/" rel="nofollow noreferrer">Psutil Docs</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not perfect, but it must work:</p>
<p>In "feeder":</p>
<pre><code>feeder_lock_object.lock()
consumer_lock_object.lock()
try:
    ...
finally:
    feeder_lock_object.release()
    consumer_lock_object.release()
</code></pre>
<p>In "consumer":</p>
<pre><code>while True:
    with consumer_lock_object:
        if feeder_lock_object.is_locked:
            continue
        ...
</code></pre>
<p>But I think it will be better when you will be use Queue.</p>
<p>If you use this method, be careful about how you implement the lock object. You should initialize the pool with an initializer function that creates these lock objects as global params. Refer to <a href="https://stackoverflow.com/questions/25557686/python-sharing-a-lock-between-processes">this</a>.</p>
</div>
<span class="comment-copy">how is the concept of a "queue" realised? Do you just append processes in a list when they come for the lock?</span>
<span class="comment-copy">@Ev.Kounis: yes, this is a <code>multiprocessing.Manager().list()</code> as I mentioned in the question (this is not a <code>multiprocessing.Queue()</code>)</span>
<span class="comment-copy">Out of curiosity, did you try using <code>multiprocessing.Queue</code> instead of implementing it?</span>
<span class="comment-copy">There shouldn't be a race condition if you only have one feeder. Just <code>put</code> to a queue or <code>append</code> to a list. The consumers should <code>get</code> from the queue or <code>pop(0)</code> from the list. As per documentation, "Queues are thread and process safe." i.e. you don't need a lock on the feeder side, or from the consumer side either. You'd be better off using a <code>Queue</code>. If you want to keep using a <code>Manager().list</code> instead, because you are just popping from the list, not modifying values in it, I think you don't need locks either. Just let <code>multiprocessing</code> module do its job.</span>
<span class="comment-copy">You need a <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock" rel="nofollow noreferrer">"reader writer lock"</a>. You can implement it using two locks and a counter (read the link).</span>
