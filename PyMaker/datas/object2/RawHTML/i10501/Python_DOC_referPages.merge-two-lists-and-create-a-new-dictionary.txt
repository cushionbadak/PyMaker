<div class="post-text" itemprop="text">
<p>I could not find a good way to do this. Suppose I have two lists (the lists have objects with given attributes). I need to create a new dictionary/list with merged atttributes.</p>
<pre><code>listA = [
  {
    "alpha": "some value",
    "time": "datetime",
  },
  ...
]

listB = [
  {
    "beta": "some val",
    "gamma": "some val",
    "time": "datetime"
  },
  ...
]
</code></pre>
<p>The result should be as follows (it should be merged based on "time" attribute)</p>
<pre><code>result = {
  "datetime": {
    "alpha": "some value",
    "beta": "some val",
    "gamma": "some val"
  },
  ...
}
</code></pre>
<p>How do I do this in a python way?</p>
<p>For example,</p>
<pre><code>listA = [
  {
    "time": "Jan 1",
    "alpha": "one"
  },
  {
    "time": "Jan 3",
    "alpha": "three"
  }
]

listB = [
  {
    "beta": "one-one",
    "gamma": "one-two",
    "time": "Jan 1"
  },
  {
    "beta": "two-one",
    "gamma": "two-two",
    "time": "Jan 2"
  },
]

result = {
  "Jan 1": {
    "alpha": "one",
    "beta": "one-one",
    "gamma": "one-two",
  },
  "Jan 2": {
    "beta": "two-one",
    "gamma": "two-two",
  },
  "Jan 3": {
    "alpha": "three"
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Using a list comprehension</h1>
<p>Since you are searching for an alternative not using a for loop here is an implementation using <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehensions</a>, which results in a two liner. I am not sure though that this is more intuitive than a for loop:</p>
<pre><code>output = {}
[output.setdefault(item["time"],{}).update({key: value}) 
 for key, value in item.items()     
 if key != "time" 
 for item in (listA + listB)]
</code></pre>
<p>To me this is just a more convoluted way of for loops...
Documentation for <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow">setdefault</a>.</p>
<h1>Using classic for loops</h1>
<p>Use <code>listA</code> and <code>listB</code> as given in your example:</p>
<pre><code>combined = listA + listB

merged = {}
for item in combined:
    time = item["time"]
    # setdefault only acts if the key is not found, initiate a dict then
    merged.setdefault(time, {})
    for key, value in item.items():
        if key != "time":
            merged[time].update({key: value})

print merged
</code></pre>
<p>Output:</p>
<pre><code>{'Jan 2': {'beta': 'two-one', 'gamma': 'two-two'}, 'Jan 3': {'alpha': 'three'}, 'Jan 1': {'alpha': 'one', 'beta': 'one-one', 'gamma': 'one-two'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another answer, that's perhaps cleaner in that it avoids conditional tests in favour of dict methods and uses only one level of indentation:</p>
<pre><code>d={}

for e in listA:
    t = e["time"]
    d.setdefault(t, {}).update(**e)

for e in listB:
    t = e["time"]
    d.setdefault(t, {}).update(**e)

# get rid of "time" keys, if important to do so

for e in d.values():
    del e["time"]
</code></pre>
<p><code>d.setdefault(t, {})</code> creates <code>d[t]</code> as an empty dict if the key <code>t</code> is not yet present in <code>d</code>, and returns <code>d[t]</code>. Then<code>.update(**e)</code> updates the returned dict to contain all keys and values in <code>e</code> (replacing current values if they exist, which may be a bug or a feature - the example did not have any overlaps or say what should happen if there are overlaps)</p>
</div>
<div class="post-text" itemprop="text">
<p>This code might be a good start:</p>
<pre><code>listA = [
  {
    "time": "Jan 1",
    "alpha": "one"
  },
  {
    "time": "Jan 3",
    "alpha": "three"
  }
]

listB = [
  {
    "beta": "one-one",
    "gamma": "one-two",
    "time": "Jan 1"
  },
  {
    "beta": "two-one",
    "gamma": "two-two",
    "time": "Jan 2"
  },
]
result = {}

# We consider every element of A and B one by one
for elem in listA + listB:
    key = elem["time"]

    # If that is the first time we encounter that key, we create a new empty dict in result
    if not result.get(key, None):
        result[key] = {}

    # We copy the content of the elem in listA or listB into the right dictionnary in result.
    for dictKey in elem.keys():

        # We don't want to copy the time
        if dictKey == "time":
            continue
        result[key][dictKey] = elem[dictKey]
print(result)
</code></pre>
</div>
<span class="comment-copy">How are you <i>currently</i> doing it, and what precisely is the problem with that implementation (if the problem is that it doesn't exist, then fix that first...)</span>
<span class="comment-copy">I don't see much evidence that you've tried to solve this yourself.</span>
<span class="comment-copy">I have tried and gotten a solution using for loop. But I want to know if there is a more intuitive way of doing it</span>
<span class="comment-copy">I added another way to my answer that is using list comprehensions. I am not sure that is more intuitive. In my opinion for complex, nested loops, plain "for loops" are more intuitive because the resulting code is more readable. For single loops, however, I find the list comprehensions often cleaner.</span>
