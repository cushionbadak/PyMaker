<div class="post-text" itemprop="text">
<p>I was trying out a problem on hackerrank contest for fun, and there came this question.
I used itertools for this, here is the code:</p>
<pre><code>import itertools

l = []

for _ in range(int(input())):
    l.append(int(input()))


max = l[0] * l[len(l)-1]

for a,b in itertools.combinations(l,2):
    if max &lt; (a*b):
        max = (a*b)
print(max)
</code></pre>
<p>Is their any other efficient way than this? As I am getting time out error on some test cases which I cant access (as its a small contest).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an implementation following @User_Targaryen's logic. <a href="https://docs.python.org/3.0/library/heapq.html" rel="nofollow"><code>heapq</code></a> returns the 2 largest and 2 smallest numbers in the list, <a href="https://docs.python.org/3/library/operator.html" rel="nofollow"><code>mul operator</code></a> returns the products of these 2 pairs of numbers, and <code>max</code> returns the largest of these 2 products.</p>
<pre><code>&gt;&gt;&gt; import heapq
&gt;&gt;&gt; from operator import mul
&gt;&gt;&gt; l = [2,40,600,3,-89,-899]
&gt;&gt;&gt; max(mul(*heapq.nsmallest(2,l)),mul(*heapq.nlargest(2,l)))
80011
# -899*-89 = 80011
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Iterate over the list and find the following:</p>
<p>Largest Positive number(a)</p>
<p>Second Largest Positive number(b)</p>
<p>Largest Negative number(c)</p>
<p>Second Largest Negative number(d)</p>
<p>Now, you will be able to figure out the maximum value upon multiplication, either <code>a*b</code> or <code>c*d</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Just sort the list and select the largest of the products of the last 2 items in the list and the first 2 items in the list:</p>
<pre><code>from operator import mul

numbers = [10, 20, 1, -11, 100, -12]
l = sorted(numbers)    # or sort in place with numbers.sort() if you don't mind mutating the list
max_product = max(mul(*l[:2]), mul(*l[-2:]))
</code></pre>
<p>This is a O(n log n) solution due to the sort. Someone else suggested a <code>heapq</code> solution which I found to be faster for lists longer than a few thousand random integers.</p>
</div>
<span class="comment-copy">precompute <code>a*b</code> when max is not the max you'll save a few instructions.</span>
<span class="comment-copy">@Jean-FrançoisFabre didnt get you clearly, could you elaborate please?</span>
<span class="comment-copy">Don't you just need to find the two largest individual elements and multiply them? (and also the two lowest negative elements if you're allowing negative numbers)</span>
<span class="comment-copy">@khelwood I thought about it, but in the question it is clearly written not to rely on that 'Keep in mind the answer is not always the product of the two biggest numbers.' but my main problem is why is this timing out!</span>
<span class="comment-copy">@Maverick You can keep that in mind by checking for negative numbers as well. Otherwise you're writing an O(n^2) solution to an O(n) problem.</span>
<span class="comment-copy">This is a good one, no time out, but still failing at one test case and do not know why.  Here is the link if anyone wants to try <a href="https://www.hackerrank.com/contests/arraysloops/challenges/arraysloops-4" rel="nofollow noreferrer">hackerrank.com/contests/arraysloops/challenges/arraysloops-4</a></span>
<span class="comment-copy">@Maverick I've edited my answer slightly to use <code>mul</code> instead of the <code>lambda</code> syntax after reading this <a href="http://stackoverflow.com/questions/2104782/returning-the-product-of-a-list" title="returning the product of a list">stackoverflow.com/questions/2104782/…</a></span>
<span class="comment-copy">You don't need to use <code>reduce</code>, try tuple unpacking: <code>max(mul(*heapq.nsmallest(2, l)), mul(*heapq.nlargest(2, l)))</code>. This heapq solution is faster than my sort based one for long lists.</span>
<span class="comment-copy">@mhawke yes thanks, my mistake, already edited</span>
<span class="comment-copy">thinking outside the box, well done!</span>
<span class="comment-copy">Nice logic, I went with the answer which had heapq solution. Thanks for your answer.</span>
<span class="comment-copy">Thank you for the answer, but that heapq was appropriate for some test cases so had to tag it.  I liked your solution too, it was simpler.</span>
<span class="comment-copy">@Maverick: no problem. They are basically equivalent, but heapq is slightly faster in some cases.</span>
