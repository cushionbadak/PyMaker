<div class="post-text" itemprop="text">
<p>Is there a way that I can stop the thread after few seconds (INTERNALLY)</p>
<pre><code>t1 = Thread(target=call_script1, args=())
t2 = Thread(target=call_script2, args=())
t3 = Thread(target=call_script3, args=())

t1.start()
t2.start()
t3.start()

t1.join()
t2.join()
t3.join()
</code></pre>
<p>The Main program waits until thread returns. I would like to know if there is a way - when I spawn a thread - say t2, it targets a function - call_script2. Lets say that function takes like 5 seconds to run completely. I would like to know if I can return the thread say like after 3 seconds.</p>
<p>The ability of the thread to return after 3 seconds should be inside the call_script2 function. I believe having stop_event.wait(3) in the main thread does not work.</p>
<p>call_script2 function looks something like this.</p>
<pre><code>def InterfaceThread2():
    a = 1;
    d = 2
    i = 1
    while i ==1:
        #ser = serial.Serial(3, 115200)
        if ser.isOpen():
            ser.write('\x5A\x03\x02\x00\x02\x07')

            a = ser.read(7) #### THIS COMMAND WAITS UNTIL IT RECEIVES DATA FROM MCU
            ## This usually happens in 100ms in theory. If it is taking like more than 100ms -for safety say I will wait for three seconds and if it did not respond back
            ## I want to stop the thread and popup an error message.

        # Tell the GUI about the Information
        wx.CallAfter(pub.sendMessage, "APP_EVENT2", arg1 = a, arg2 = d)
        print "hello"

        time.sleep(1)
        i = i+1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you can get the behavior you want by using the <code>timeout</code> parameter available on the <code>serial.Serial()</code> constructor. Additionally, you'll need to protect your interactions with the <code>Serial</code> instance with a <code>threading.Lock()</code>, so that your threads don't step on each other as they read/write data:</p>
<pre><code>ser = serial.Serial(..., timeout=3, ...)
lock = Threading.Lock()

def call_script1():
    a = 1
    d = 2
    i = 1
    while i == 1:  # Lock is acquired here
        with lock:
            if ser.isOpen():
                ser.write('\x5A\x03\x02\x00\x02\x07')
                a = ser.read(7)
                if len(a) != 7:
                    # We didn't get all the bytes we wanted, a timeout
                    # must have occurred.
                    print("Only read {} bytes!".format(len(a)))
                    # Maybe exit or throw an exception?

        # Lock is released here.
        # Tell the GUI about the Information
        wx.CallAfter(pub.sendMessage, "APP_EVENT2", arg1 = a, arg2 = d)
        print "hello"

        time.sleep(1)
        i = i+1

def call_script2():
    while i == 1:
        with lock:
            if ser.isOpen():
                # Do whatever

def call_script3():
    while i == 1:
        with lock:
            if ser.isOpen():
                # Do whatever

t1 = Thread(target=call_script1, args=())
t2 = Thread(target=call_script2, args=())
t3 = Thread(target=call_script3, args=())

t1.start()
t2.start()
t3.start()

t1.join()
t2.join()
t3.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="nofollow"><code>Thread.join</code></a> method has an optional <code>timeout</code> parameter.</p>
<pre><code># block until thread ``t`` completes, or just wait 3 seconds
t.join(3)
</code></pre>
<p>If you want the target function to handle this logic of timing out, I suggest writing a wrapper to spawn a new thread, make the call, then join with a 3-second timeout.</p>
<pre><code>from threading import Thread
import time

def counter(limit):
    for i in range(limit):
        print(i)
        time.sleep(0.1)

timeout = 3
def wrapper(*args, **kwargs):
    t = Thread(target=counter, args=args, kwargs=kwargs)
    t.daemon = True
    t.start()
    t.join(timeout)

t = Thread(target=wrapper, args=(100,))
t.start()
t.join()
</code></pre>
<p>Note that this doesn't actually kill the subthread until the main process dies. Killing a thread without knowing what it's doing inside could cause all sorts of mess.</p>
<p>If you can change the code of the original functions, you can have them periodically poll to check if anyone wants them dead.</p>
<p>Edit: Looks like I somewhat misunderstood the question. It was more about how to use PySerial to share 1 open <code>Serial</code> object across 3 workers, with a timeout on reads from the serial port.</p>
</div>
<span class="comment-copy">On what condition do you decide whether to exit the thread after 3 seconds versus letting it finish?</span>
<span class="comment-copy">The target function  call_script2 - calls for serial communication with a MCU. The MCU takes like 100ms to reply back - when requested to read. So I would like to wait say 3 secs, if the MCU did not reply - stop the thread - pop up an error message</span>
<span class="comment-copy">And the response controls whether to continue or exit? What is supposed to happen from the time of the response until the 3 seconds? This may be easier if you post the <code>call_script2</code> code.</span>
<span class="comment-copy">The <code>serial.Serial</code> object support a <a href="https://pythonhosted.org/pyserial/pyserial_api.html#serial.Serial" rel="nofollow noreferrer"><code>timeout</code></a> parameter, which you can use to set a max waiting period for reads to complete.</span>
<span class="comment-copy">@JeshKundem Sure you can - just pass the <code>Lock</code> instance into both functions.</span>
<span class="comment-copy">One of those call_script functions in my program is an infinite while loop. If it acquires the lock, it wont release it</span>
<span class="comment-copy">@JeshKundem You can acquire/release it <i>inside</i> the loop. Imagine if <code>call_script1()</code> above used <code>while True:</code> instead of <code>while i == 1:</code>. It would still release the lock right after it finishes reading 7 bytes (or the read times out), update the GUI, sleep for one second, then try to acquire the lock again.</span>
<span class="comment-copy">Thank yoU DANO for educating me.</span>
<span class="comment-copy">That won't actually cancel the thread, it'll just stop the thread you called <code>join()</code> in from blocking until it completes.</span>
<span class="comment-copy">Good point. We can make it a <code>daemon</code> thread, but it'll still keep going until the main process dies.</span>
