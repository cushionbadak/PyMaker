<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>def func():
    output = 0
    while True:
        new = yield output
        output = new


genr = func()
print(next(genr))
print(next(genr))
print(next(genr))
</code></pre>
<p>output:</p>
<blockquote>
<p>0<br/>
  None<br/>
  None  </p>
</blockquote>
<p>What i thought is:</p>
<ol>
<li><code>genr=func()</code> return a generator, but does not actually run it.</li>
<li>First <code>print(next(genr))</code> run from the begining of func to <code>yield output</code>, but not yet assign back to <code>new</code>,so output <code>0</code> make sense.  </li>
<li>Second <code>print(next(genr))</code> start from assigning <code>output</code> back to <code>new</code>ï¼Œand next line <code>output = new</code> make both <code>output</code> and <code>new</code> to 0, next execute <code>yield output</code> should return 0, but why it return <code>None</code> actually?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="https://docs.python.org/3.5/reference/simple_stmts.html#the-yield-statement"><em>yield</em></a> statement is used like <em>return</em> to return a value but it doesn't destroy the stack frame (the part of a function that knows the current line, local variables, and pending try-statements).  This allows the function to be resumed after the yield.</p>
<p>When you call a function containing yield, it returns a <a href="https://docs.python.org/3.5/glossary.html#term-generator">"generator"</a> that allows you to run code up to a yield and then to resume it from where it left off.</p>
<pre><code>&gt;&gt;&gt; def squares(n):
        for i in range(n):
            yield i ** 2

&gt;&gt;&gt; g = squares(5)             # create the generator
&gt;&gt;&gt; g
&lt;generator object squares at 0x106beef10&gt;
&gt;&gt;&gt; next(g)                    # run until the first yield
0
&gt;&gt;&gt; next(g)                    # resume after the yield
1
&gt;&gt;&gt; next(g)                    # resume after the yield
4
&gt;&gt;&gt; next(g)                    # resume after the yield
9
&gt;&gt;&gt; next(g)                    # resume after the yield
16
&gt;&gt;&gt; next(g)                    # looping is terminated with a StopIteration
Traceback (most recent call last):
  File "&lt;pyshell#13&gt;", line 1, in &lt;module&gt;
    next(g)                    # looping is terminated with a StopIteration
StopIteration
</code></pre>
<p>Interestingly, a generator can accept values using the <em>send()</em> method.  To prime the pump for such a generator the first call should be <em>next()</em>.</p>
<pre><code>&gt;&gt;&gt; def capitalize():
        word = 'start'
        while word != 'quit':
            word = yield word.capitalize()

&gt;&gt;&gt; g = capitalize()
&gt;&gt;&gt; next(g)                      # run to the first yield
'Start'
&gt;&gt;&gt; g.send('three')              # send in a value to be assigned to word
'Three'
&gt;&gt;&gt; g.send('blind')              # send in a value to be assigned to word
'Blind'
&gt;&gt;&gt; g.send('mice')               # send in a value to be assigned to word
'Mice'
&gt;&gt;&gt; g.send('quit')               # send in a control value
Traceback (most recent call last):
  File "&lt;pyshell#28&gt;", line 1, in &lt;module&gt;
    g.send('quit')               # send in a control value
StopIteration
</code></pre>
<p>What you've figured-out in your example is that <code>next(g)</code> is really the same as <code>g.send(None)</code>.</p>
<p>Here's what <a href="https://docs.python.org/3.5/reference/expressions.html#yield-expressions">the docs</a> have to say:</p>
<blockquote>
<p>The value of the yield expression after resuming depends on the method
  which resumed the execution. If __next__() is used (typically via
  either a for or the <em>next()</em> builtin) then the result is <em>None</em>.
  Otherwise, if <em>send()</em> is used, then the result will be the value passed
  in to that method</p>
</blockquote>
<p>Here's a session that makes all of that visible:</p>
<pre><code>&gt;&gt;&gt; def show_expression():
        for i in range(5):
            word = yield 10
            print('The word is %r' % word)

&gt;&gt;&gt; g = show_expression()
&gt;&gt;&gt; next(g)
10
&gt;&gt;&gt; g.send('blue')
The word is 'blue'
10
&gt;&gt;&gt; g.send('no')
The word is 'no'
10
&gt;&gt;&gt; g.send('yellow')
The word is 'yellow'
10
&gt;&gt;&gt; next(g)
The word is None
10
&gt;&gt;&gt; g.send('done')
The word is 'done'
Traceback (most recent call last):
  File "&lt;pyshell#44&gt;", line 1, in &lt;module&gt;
    g.send('done')
StopIteration
</code></pre>
<p>Hope that explains all the mysteries from first principles :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>The result of a <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="nofollow">yield expression</a> is the value sent in by the <a href="https://docs.python.org/3/reference/expressions.html#generator.send" rel="nofollow">generator.send()</a> function, and <code>next(gen)</code> is equivalent to <code>gen.send(None)</code>. So <code>new</code> receives the value <code>None</code> each time you call <code>next()</code>. </p>
<p>If you do this instead:</p>
<pre><code>gen = func()
print(next(gen))     # gets the first value of 'output'
print(next(gen))     # send in None, get None back
print(gen.send(10))  # send in 10, get 10 back
print(gen.send(20))  # send in 20, get 20 back
</code></pre>
<p>you'll get this output:</p>
<pre><code>0
None
10
20
</code></pre>
</div>
<span class="comment-copy">Don't assign <code>new</code> to <code>yield output</code>. The result of that operation is <code>None</code></span>
<span class="comment-copy">You mean <code>yield output</code> won't be assign back to <code>new</code>? do you have any reference information, thank you.</span>
<span class="comment-copy">Have a search for coroutines</span>
<span class="comment-copy">So, in my problem code, the <code>new = yield output</code> statement does not execute completely? just <code>yield output</code> without assigning back the result to new?</span>
<span class="comment-copy">@user2706322 Yes, though I would say it a bit differently.  The <code>yield output</code> returns the output value and <i>suspends</i> the execution.  Later, when you write <code>g.next()</code> which is equivalent to <code>g.send(None)</code>, the execution completes, with the passed-in <i>None</i> value becoming result of the expression and being assigned to <i>new</i>.   In other words, it executes completely but is broken into two steps, one before the <i>next</i> and one after.</span>
<span class="comment-copy">I still have 1 quesion, why first g.next() let <code>yield output</code> produce <code>0</code> and second let produce <code>None</code>?    In the second <code>g.next()</code>, the output should still be <code>0</code> doesn't it?</span>
<span class="comment-copy">So, the <code>new = yield output</code> statement does not execute completely? just <code>yield output</code> without assigning back the result to <code>new</code>?</span>
