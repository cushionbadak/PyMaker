<div class="post-text" itemprop="text">
<p>I was reading <a href="http://www.aleax.it/Python/nylug05_om.pdf" rel="nofollow noreferrer">a presentation</a> on Pythons' Object model when, in one slide (number <code>9</code>), the author asserts that Pythons' functions are descriptors. The example he presents to illustrate is similar to this one I wrote:</p>
<pre><code>def mul(x, y):
    return x * y

mul2 = mul.__get__(2)
mul2(3) # 6
</code></pre>
<p>Now, I understand that the point is made, since the function defines a <code>__get__</code> it is a descriptor as I described in the description section of the Python documentation. </p>
<p>What I don't understand is how exactly the call results in the output provided.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's Python doing what it does in order to support dynamically adding functions to classes. </p>
<p>When <code>__get__</code> is invoked on a function object (usually done via dot access <code>.</code> on an instance of a class) Python will transform the function to a <em>method</em> and <em>implicitly</em> pass the instance (usually recognized as <code>self</code>) as the first argument. </p>
<p>In your case, you <em>explicitly</em> call <code>__get__</code> and <em>explicitly</em> pass the 'instance' <code>2</code> which is bound as the first argument of the function <code>x</code>, here <code>2</code> is considered the "instance" <code>self</code>:</p>
<pre><code>&gt;&gt;&gt; mul2
&lt;bound method mul of 2&gt; 
</code></pre>
<p>This results in a method bound on the instance 2, with one expected argument that yields the multiplication: calling it returns <code>2</code> (the bound argument assigned to <code>x</code>) multiplied with anything else you supply as the argument <code>y</code>.</p>
<p>Normally, <code>function()</code> invokes it's <code>__call__</code> with the appropriate arguments provided:</p>
<pre><code>mul.__call__(2, 3)  # 6
</code></pre>
<hr/>
<p>As a plus, a Python implementation of <code>__get__</code> for functions is provided in the <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="noreferrer">Descriptor HOWTO</a> document of the Python Docs.</p>
<p>Here you can see the transformation, with the usage of <a href="https://docs.python.org/3/library/types.html#types.MethodType" rel="noreferrer"><code>types.MethodType</code></a>, that takes place when <code>__get__</code> is invoked :</p>
<pre><code>class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c"
        return types.MethodType(self, obj, objtype)
</code></pre>
<p>And the source code for the intrigued visitor is located in <code>Objects/funcobject.c</code>.</p>
<p>As you can see if this descriptor did not exist you'd have to automatically wrap functions in <code>types.MethodType</code> any time you'd want to dynamically add a function to class which is an unnecessary hassle.</p>
</div>
