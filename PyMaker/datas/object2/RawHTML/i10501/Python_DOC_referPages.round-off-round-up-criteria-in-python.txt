<div class="post-text" itemprop="text">
<p>I'm porting a MATLAB code to Python 3.5.1 and I found a float round-off issue.</p>
<p>In MATLAB, the following number is rounded <strong>up</strong> to the 6th decimal place:</p>
<pre><code>fprintf(1,'%f', -67.6640625);
-67.664063
</code></pre>
<p>In Python, on the other hand, the following number is rounded <strong>off</strong> to the 6th decimal place:</p>
<pre><code>print('%f' % -67.6640625)
-67.664062
</code></pre>
<p>Interestingly enough, if the number is '-67.6000625', then it is rounded <strong>up</strong> even in Python:</p>
<pre><code>print('%f' % -67.6000625)
-67.600063
</code></pre>
<p>... Why does this happen?
What are the criteria to round-off/up in Python?
(I believe this has something to do with handling hexadecimal values.)</p>
<p>More importantly, how can I prevent this difference?
I'm supposed to create a python code which can reproduce exactly the same output as MATLAB produces.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason for the python behavior has to do with how floating point numbers are stored in a computer and the standardized rounding rules defined by IEEE, which defined the standard number formats and mathematical operations used on pretty much all modern computers.</p>
<p>The need to store numbers efficiently in binary on a computer has lead computers to use floating-point numbers.  These numbers are easy for processors to work with, but have the disadvantage that many decimal numbers <a href="https://docs.python.org/3/tutorial/floatingpoint.html#representation-error" rel="nofollow">cannot be exactly represented</a>.  This results in numbers sometimes being a little off from what we think they should be.</p>
<p>The situation becomes a bit clearer if we expand the values in Python, rather than truncating them:</p>
<pre><code>&gt;&gt;&gt; print('%.20f' % -67.6640625)
-67.66406250000000000000
&gt;&gt;&gt;  print('%.20f' % -67.6000625)
-67.60006250000000704858
</code></pre>
<p>So as you can see, <code>-67.6640625</code> is a number that can be exactly represented, but <code>-67.6000625</code> isn't, it is actually a little bigger.  The default rounding mode <a href="https://en.wikipedia.org/wiki/IEEE_floating_point#Rounding_rules" rel="nofollow">defined by the IEEE stanard</a> for floating-point numbers says that anything above <code>5</code> should be rounded up, anything below should be rounded down.  So for the case of <code>-67.6000625</code>, it is actualy <code>5</code> plus a small amount, so it is rounded up.  However, in the case of <code>-67.6640625</code>, it is exactly equal to five, so a tiebreak rule comes into play.  The default tiebreaker rule is round to the nearest even number.  Since <code>2</code> is the nearest event number, it rounds down to two.</p>
<p>So Python is following the approach recommended by the floating-point standard.  The question, then, is why your version of MATLAB <em>doesn't</em> do this.  I tried it on my computer with 64bit MATLAB R2016a, and I got the same result as in Python:</p>
<pre><code>&gt;&gt; fprintf(1,'%f', -67.6640625)
-67.664062&gt;&gt;
</code></pre>
<p>So it seems like MATLAB was, at some point, using a different rounding approach (perhaps a non-standard approach, perhaps one of the alternatives specified in the standard), and has since switched to follow the same rules as everyone else.</p>
</div>
<span class="comment-copy">I was curious so I looked up the behaviour of this in numpy as well. What I got was odd. <code>np.around(a,6)</code> (with a being your first value) yields  -67.664062000000001. The second value you tried yields: -67.600061999999994. <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">The official python documentation</a> explains this behaviour.</span>
<span class="comment-copy">I tried both C and Octave and they all print <code>-67.664062</code>, the same as Python.</span>
<span class="comment-copy">Considering how tricky float comparision have always been (like 3.0*2.2 != 2.0*3.3), I would start by questionning the feasability of the project. Best practice for comparing two floats is always to compare the difference to some tolerance.</span>
<span class="comment-copy">Also see <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#round</a> and see <a href="http://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior" title="python 3 x rounding behavior">stackoverflow.com/questions/10825926/â€¦</a> for some suggestions.</span>
<span class="comment-copy">I'd suggest not using an implicit form of rounding off. Instead, ensure that your code is doing what you <b>expect</b> it to.  <b><a href="http://stackoverflow.com/a/22155830/3833764">This</a> answer</b> is an excellent summary on what you want to do.</span>
<span class="comment-copy">Wow, well-explained. I'm completely convinced. Yes, I'm using MATLAB R2011b, so a bit older. I thought MATLAB was always right, but I was wrong. One good thing is that I don't have to fix my Python code for this issue. ;-) Thank you very much!</span>
