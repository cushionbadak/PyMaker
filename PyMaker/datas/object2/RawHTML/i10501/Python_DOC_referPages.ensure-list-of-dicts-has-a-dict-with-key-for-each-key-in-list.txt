<div class="post-text" itemprop="text">
<p>Context:
I'm using an Ajax call to return some complex JSON from a python module. I have to use a list of keys and confirm that a list of single-item dicts contains a dict with each key.</p>
<p>Example:</p>
<pre><code>mylist=['this', 'that', 'these', 'those']

mydictlist=[{'this':1},{'that':2},{'these':3}]
</code></pre>
<p>How do I know that mydictlist is missing the "those" key? Once I know that, I can append {'those':4} to mylist. Simply checking for "those" won't work since the list is dynamic. The data structure cannot change.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple code is to convert your search list to a set, then use differencing to determine what you're missing:</p>
<pre><code>missing = set(mylist).difference(*mydictlist)
</code></pre>
<p>which gets you <code>missing</code> of <code>{'those'}</code>.</p>
<p>Since the named <code>set</code> methods can take multiple arguments (and they need not be <code>set</code>s themselves), you can just unpack all the <code>dict</code>s as arguments to <code>difference</code> to subtract all of them from your <code>set</code> of desired keys at once.</p>
<p>If you do need to handle duplicates (to make sure you see each of the <code>keys</code> in <code>mylist</code> at least that many time in <code>mydictlist</code>'s keys, so <code>mylist</code> might contain a value twice which must occur twice in the <code>dict</code>s), you can use <code>collections</code> and <code>itertools</code> to get remaining counts:</p>
<pre><code>from collections import Counter
from itertools import chain

c = Counter(mylist)
c.subtract(chain.from_iterable(mydictlist))
# In 3.3+, easiest way to remove 0/negative counts
c = +c

# In pre-3.3 Python, change c = +c to get the same effect slightly less efficiently
c += Counter()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most straightforward way is to iterate over both the containers and check:</p>
<pre><code>for key in mylist:
    if not any(key in dic for dic in mydictlist):
        print key, "missing"
</code></pre>
<p>However, if you have a lot of keys and/or dictionaries, this is not going to be efficient: it iterates over <code>mydictlist</code> once for each element in <code>mylist</code>, which is O(n*m). Instead, consider a set operation:</p>
<pre><code>print set(mylist).difference(*mydictlist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The pandas package is a great way to handle list of dicts problems. It takes all the keys and makes them column headers, values with similar keys populate the same column.</p>
<p>Check this out:</p>
<pre><code>import pandas as pd

mydictlist=[{'this':1},{'that':2},{'these':3}]

# Convert data to a DataFrame
df = pd.DataFrame(mydictlist)

# List all the column header names and check if any of the key words are missing
df.columns
</code></pre>
</div>
<span class="comment-copy">Are you saying that you cannot simply check that each list item is <a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer"><code>in</code></a> the dictionary?</span>
<span class="comment-copy">Right, because the list changes in different cases</span>
<span class="comment-copy">@wwii: More than one <code>dict</code>; the naive approach would require iterating <code>mydictlist</code> once for every value in <code>mylist</code>, which is <code>O(n*m)</code> (where <code>n</code> and <code>m</code> are the lengths of the two <code>list</code>s), both worst and expected case. Better solutions can reduce the work to <code>O(n + m)</code>, which could make a difference if the <code>list</code>s are large.</span>
<span class="comment-copy">Is it possible for <code>mylist</code> to have duplicates?</span>
<span class="comment-copy">@wwii no, it will always have unique items</span>
<span class="comment-copy">This is great so far. I get: set(['those']), which I can iterate over to populate a "missing keys" list.</span>
<span class="comment-copy">@JacobIRR: Ah, I used the Py3 <code>repr</code> for <code>set</code> in my answer, but you'd see it as the equivalent non-literal syntax in Py2. You don't actually need to iterate the <code>missing</code> result explicitly; <code>missing = list(missing)</code> converts from <code>set</code> to <code>list</code>, or <code>missing = sorted(missing)</code> to get a sorted <code>list</code>.</span>
<span class="comment-copy">Why limit it to a single key from each <code>dict</code>? I mean, sure, the example code has one key per <code>dict</code>, but it's actually easier to just slurp them all.</span>
<span class="comment-copy">True dat, 'specially since I don't care in the first example.</span>
