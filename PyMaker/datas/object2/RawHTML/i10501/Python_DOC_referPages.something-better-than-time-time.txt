<div class="post-text" itemprop="text">
<p>My team and I are designing a project which requires the detection of rising edge of a square wave and then storing the time using time.time() in a variable.If a same square wave is given to 3 different pins of RPi,and event detection is applied on each pin,theoretically,they should occur at the same time,but they have a delay which causes a difference in phase too (we are calculating phase from time).
We concluded that time.time() is a slow function.
Can anyone please help me as to which function to use to get SOC more precise than time.time()?
Or please provide me with the programming behind the function time.time().
I'll be really thankful. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>time.time</code> uses <code>gettimeofday</code> on platforms that support it. That means its resolution is in microseconds.</p>
<p>You might try using <code>time.clock_gettime(time.CLOCK_REALTIME)</code> which provides nanosecond resolution (assuming the underlying hardware/OS provides that). The result still gets converted to floating point as with <code>time.time</code>.</p>
<p>It's also possible to load up the <code>libc</code> shared object and invoke the native <code>clock_gettime</code> using the <code>ctypes</code> module. In that way, you could obtain access to the actual nanosecond count provided by the OS. (Using <code>ctypes</code> has a fairly steep learning curve though.)</p>
</div>
<span class="comment-copy">I'm afraid the answer is very likely to be "you need to drop down to C", but I don't really know from RPi-specific programming.  Also it would help if you tell us what you mean by "SOC"; that is not a TLA I am familiar with.</span>
<span class="comment-copy">@zwol System on a Chip, I believe.</span>
<span class="comment-copy">@MorganThrapp That doesn't make sense in context.  "Get system on a chip more precise than time.time"???</span>
<span class="comment-copy">@zwol My assumption is that they mean that they need the timing on their SOC to be more precise. It's kinda hard to tell exactly what's needed here.</span>
<span class="comment-copy">SOC=seconds of century. sorry to write that in flow.</span>
<span class="comment-copy">Thanks.but I couldn't get the "libc" thing you mentioned.I was thinking if I could get access to the actual programming of time.time() function, I could mould it somehow.</span>
<span class="comment-copy">The source of cpython (the most common python implementation) is freely available for download (<a href="https://www.python.org/downloads/source/" rel="nofollow noreferrer">python.org/downloads/source</a>). You will find the <code>time.time</code> function in <code>Modules/timemodule.c</code>. Modifying it is certainly possible but the learning curve on that is arguably steeper than for <code>ctypes</code>.</span>
<span class="comment-copy">Just realized something. You should try this: <code>import time; time.get_clock_info("time")</code> which will give you information on the implementation of <code>time.time</code>. You may already be using <code>clock_gettime</code>, in which case you will not likely get better resolution (though you <i>could</i> avoid loss of precision due to the integer-to-float conversion with the <code>ctypes</code> access of <code>libc</code>).</span>
<span class="comment-copy">printing the import time; time.get_clock_info("time") gave some info about time.time like the resolution=0.015625.Thanks for that. "(though you could avoid loss of precision due to the integer-to-float conversion with the ctypes access of libc)" Sorry but I have no idea of what you are talking about here.I am an amateur in python programming and I dont know anything about ctypes and libc</span>
<span class="comment-copy">What I was thinking of is this: <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/floatingpoint.html</a> -- however, in retrospect, the scale of the issue is probably not significant for what you're doing. For the other, I was suggesting you could use <code>ctypes</code> to gain access to the raw <code>clock_gettime</code> API function in the standard C library on your system to avoid the conversion. It now seems likely to me though that your OS/hardware clock resolution is simply too low to provide the precision you need. Not sure what you can do about that.</span>
