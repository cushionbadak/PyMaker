<div class="post-text" itemprop="text">
<p>I have a very large number, both before and after the decimal, but for this I'll just call it 4.58.</p>
<p>I want to know the number, Y, that will yield me an integer if multiplied by X and not any sort of float number.</p>
<p>Here is my code:</p>
<pre><code>from decimal import *
setcontext(ExtendedContext)
getcontext().prec = 300
x=Decimal('4.58')
while True:
    i=1
    a=Decimal(i*x)
    if float(a).is_integer():
        print(i*x)
        break
    else:
        i=+1
</code></pre>
<p>However, this method is incredibly slow and inefficient. I was wondering how could I implement continued fractions or some other method to make it predict the value of Y?</p>
<p><em>Edit</em></p>
<p>The decimal module stores float numbers more accurately (As strings), so 0.5 <em>won't</em> become 0.499999999.</p>
<p><em>Edit 2</em></p>
<p>I've got X (4.58).</p>
<p>I want to know what number will multiply by X to make an integer; as efficiently as possible.</p>
<p><strong>Edit 3</strong></p>
<p>Okay, maybe not my best question yet.</p>
<p>Here's my dilemma.</p>
<p>I've got a number spat out from a trivial programme I made. That number is a decimal number, 1.5.</p>
<p>All I want to do is find what integer will multiply by my decimal to yield another integer.</p>
<p>For 1.5, the best answer will be 2. (1.5*2=3) (float*int=int)</p>
<p>My while-loop above will do that, eventually, but I just wanted to know whether there was a better way to do this, such as continued fractions; and if there was, how could I implement it.</p>
<p><em>Edit 4</em></p>
<p>Here's my code thanks to user6794072. It's lengthy but functional.</p>
<pre><code>from gmpy2 import mpz, isqrt
from fractions import Fraction
import operator
import functools
from decimal import *
setcontext(ExtendedContext)
getcontext().prec = 300

def factors(n):
    n = mpz(n)

    result = set()
    result |= {mpz(1), n}

    def all_multiples(result, n, factor):
        z = n
        f = mpz(factor)
        while z % f == 0:
            result |= {f, z // f}
            f += factor
        return result

    result = all_multiples(result, n, 2)
    result = all_multiples(result, n, 3)

    for i in range(1, isqrt(n) + 1, 6):
        i1 = i + 1
        i2 = i + 5
        if not n % i1:
            result |= {mpz(i1), n // i1}
        if not n % i2:
            result |= {mpz(i2), n // i2}
    return result

j=Decimal('4.58')

a=(Fraction(j).numerator)
b=(Fraction(j).denominator)

y=(factors(a))
x=(factors(b))

q=([item for item in x if item not in y])
w=([item for item in y if item not in x]) q.extend(w)

p=(functools.reduce(operator.mul, q, 1)) ans=(p*j)

print(ans)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your question correctly, you want to find the smallest integer (i) that can be multiplied to a non-integer number (n) so that:</p>
<p>i*n is an integer</p>
<p>I would do this by finding the factors of the numerator and denominator for n.  In your example, if n = 4.58, then you can extract 458 for the numerator and 100 for the denominator.</p>
<p>The multiples of 458 are 2 and 229
The multiples of 100 are 2, 2, 5, 5</p>
<p>You can cross off one instance of 2 for the numerator and denominator.  Then your solution is just multiplying the remaining factors in the denominator: in this case, 2*5*5 or 50. </p>
</div>
<div class="post-text" itemprop="text">
<p>Well think of what if you wanted to reach <code>z = 1</code> and then use the fact that <code>z == z * 1</code> to scale the answer. For any float <code>x != 0.0</code>, <code>y = 1/x</code> will yield <code>z = 1</code>, so for arbitrary integer <code>z</code>, just use <code>y = z/x</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not a Python programmer, but what about <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow">round</a> function?</p>
</div>
<span class="comment-copy">This is a can worms since most numbers don't have an exact <code>float</code> representation (for example, <code>0.3</code> becomes <code>0.299999999999999988897769753748434595763683319091796875</code>).</span>
<span class="comment-copy">"I want to know the other float number, Y, that will yield me an integer if multiplied by X and not any sort of float number." - <i>the</i> other float? Why do you assume that such a float exists, or that it's unique?</span>
<span class="comment-copy">BTW, no, the <code>decimal</code> module does <i>not</i> make <code>range</code> accept decimals, in any sense.</span>
<span class="comment-copy">You really need to slow down and post code that makes sense.  In the latest iteration, <code>Decimal('x')</code> is just an error - you <i>may</i> have meant <code>Decimal(x)</code> or <code>Decimal(str(x))</code>, but impossible to guess which, and they're not at all the same.</span>
<span class="comment-copy">What do you want this value for? What are you going to do with it? The thing you're asking for doesn't make much sense, but if we know what you're trying to achieve by using it, we can probably suggest better ways to achieve it.</span>
<span class="comment-copy">Thanks a lot. I've posted the code in the question.</span>
<span class="comment-copy">@Master-chip, in a comment to Mark Dickinson, you said you did <i>not</i> want 50, although you didn't explain why.  As @user6794072 said in this answer, if implemented correctly 50 is the answer you get from this approach too.  A much easier way to get it is just to do <code>fractions.Fraction(your_decimal_input).denominator</code>.  No factoring is necessary - the <code>Fraction()</code> constructor eliminates factors common to numerator and denominator all by itself (by using <code>gcd()</code>, much more efficient than by factoring).</span>
<span class="comment-copy">This doesn't actually work. For example, with <code>x=0.013</code>, we have <code>x*(1/x) != 1</code>. The <code>decimal</code> module might change what particular values of <code>x</code> are counterexamples, but it still won't work.</span>
<span class="comment-copy">Good one, but I don't want to lose accuracy.</span>
