<div class="post-text" itemprop="text">
<p>Since Python 3.4, the <code>Enum</code> class exists.</p>
<p>I am writing a program, where some constants have a specific order and I wonder which way is the most pythonic to compare them:</p>
<pre><code>class Information(Enum):
    ValueOnly = 0
    FirstDerivative = 1
    SecondDerivative = 2
</code></pre>
<p>Now there is a method, which needs to compare a given <code>information</code> of <code>Information</code> with the different enums:</p>
<pre><code>information = Information.FirstDerivative
print(value)
if information &gt;= Information.FirstDerivative:
    print(jacobian)
if information &gt;= Information.SecondDerivative:
    print(hessian)
</code></pre>
<p>The direct comparison does not work with Enums, so there are three approaches and I wonder which one is preferred:</p>
<p>Approach 1: Use values:</p>
<pre><code>if information.value &gt;= Information.FirstDerivative.value:
     ...
</code></pre>
<p>Approach 2: Use IntEnum:</p>
<pre><code>class Information(IntEnum):
    ...
</code></pre>
<p>Approach 3: Not using Enums at all:</p>
<pre><code>class Information:
    ValueOnly = 0
    FirstDerivative = 1
    SecondDerivative = 2
</code></pre>
<p>Each approach works, Approach 1 is a bit more verbose, while Approach 2 uses the not recommended IntEnum-class, while  and Approach 3 seems to be the way one did this before Enum was added. </p>
<p>I tend to use Approach 1, but I am not sure. </p>
<p>Thanks for any advise!</p>
</div>
<div class="post-text" itemprop="text">
<p>I hadn'r encountered Enum before so I scanned the doc (<a href="https://docs.python.org/3/library/enum.html" rel="noreferrer">https://docs.python.org/3/library/enum.html</a>) ... and found OrderedEnum (section 8.13.13.2)  Isn't this what you want? From the doc:</p>
<pre><code>&gt;&gt;&gt; class Grade(OrderedEnum):
...     A = 5
...     B = 4
...     C = 3
...     D = 2
...     F = 1
...
&gt;&gt;&gt; Grade.C &lt; Grade.A
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should always implement the rich comparison operaters if you want to use them with an <code>Enum</code>. Using the <code>functools.total_ordering</code> class decorator, you only need to implement an <code>__eq__</code> method along with a single ordering, e.g. <code>__lt__</code>. Since <code>enum.Enum</code> already implements <code>__eq__</code> this becomes even easier:</p>
<pre><code>&gt;&gt;&gt; import enum
&gt;&gt;&gt; from functools import total_ordering
&gt;&gt;&gt; @total_ordering
... class Grade(enum.Enum):
...   A = 5
...   B = 4
...   C = 3
...   D = 2
...   F = 1
...   def __lt__(self, other):
...     if self.__class__ is other.__class__:
...       return self.value &lt; other.value
...     return NotImplemented
... 
&gt;&gt;&gt; Grade.A &gt;= Grade.B
True
&gt;&gt;&gt; Grade.A &gt;= 3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: Grade() &gt;= int()
</code></pre>
<p>Terrible, horrible, ghastly things can happen with <code>IntEnum</code>. It was mostly included for backwards-compatibility sake, enums used to be implemented by subclassing <code>int</code>. From the <a href="https://docs.python.org/3/library/enum.html#intenum" rel="noreferrer">docs</a>:</p>
<blockquote>
<p>For the vast majority of code, Enum is strongly recommended, since
  IntEnum breaks some semantic promises of an enumeration (by being
  comparable to integers, and thus by transitivity to other unrelated
  enumerations). It should be used only in special cases where there’s
  no other choice; for example, when integer constants are replaced with
  enumerations and backwards compatibility is required with code that
  still expects integers.</p>
</blockquote>
<p>Here's an example of why you don't want to do this:</p>
<pre><code>&gt;&gt;&gt; class GradeNum(enum.IntEnum):
...   A = 5
...   B = 4
...   C = 3
...   D = 2
...   F = 1
... 
&gt;&gt;&gt; class Suit(enum.IntEnum):
...   spade = 4
...   heart = 3
...   diamond = 2
...   club = 1
... 
&gt;&gt;&gt; GradeNum.A &gt;= GradeNum.B
True
&gt;&gt;&gt; GradeNum.A &gt;= 3
True
&gt;&gt;&gt; GradeNum.B == Suit.spade
True
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">Could you quote that "<i>not recommended</i> IntEnum-class", please ? Docs for 3.7.1 are not deprecating it at all.</span>
<span class="comment-copy">Sure, from the Docs: “For the majority of new code, Enum and Flag are strongly recommended, since IntEnum and IntFlag break some semantic promises of an enumeration (by being comparable to integers, and thus by transitivity to other unrelated enumerations). IntEnum and IntFlag should be used only in cases where Enum and Flag will not do; for example, when integer constants are replaced with enumerations, or for interoperability with other systems.”</span>
<span class="comment-copy">Great description, thanks a lot. Just one question: You <code>return NotImplemented</code> instead of <code>raise NotImplemented</code>. Is there a general rule, when to use return and when raise?</span>
<span class="comment-copy">@SebastianWerk Well, you cannot <code>raise NotImplemented</code> because it is not an exception. It is a built-in singleton. See the <a href="https://docs.python.org/3.5/library/constants.html#NotImplemented" rel="nofollow noreferrer">docs</a>, it is there for the special case of the rich-comparison operators. The <code>NotImplementedError</code>, according to the <a href="https://docs.python.org/2/library/exceptions.html#exceptions.NotImplementedError" rel="nofollow noreferrer">docs</a>, is there for when "abstract methods should raise this exception when they require derived classes to override the method. ".</span>
<span class="comment-copy">@SebastianWerk Also, see this question: <a href="http://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror" title="why return notimplemented instead of raising notimplementederror">stackoverflow.com/questions/878943/…</a></span>
<span class="comment-copy"><b>Excellent answer,</b> good Sir. This approach is a succinct – albeit less efficient – alternative to the <code>OrderedEnum</code> class detailed in the <a href="https://docs.python.org/3/library/enum.html#orderedenum" rel="nofollow noreferrer">official Python documentation</a>. While the <code>OrderedEnum</code> solution of manually implementing all comparison operators <i>is</i> modestly faster, the <code>@total_ordering</code> solution given above has its merits. Brevity is a thankless virtue. Relatedly, does anyone know why <code>OrderedEnum</code> was merely documented rather than added to the <code>enum</code> module?</span>
