<div class="post-text" itemprop="text">
<p>I would like to get the first letter with the maximum occurence of a string.</p>
<p>For instance:</p>
<pre><code> "google" -&gt; g  
 "azerty" -&gt; a  
 "bbbaaa" -&gt; b
</code></pre>
<p>I already have a working code, using <a href="https://docs.python.org/3/library/collections.html#collections.Counter">OrdererDict()</a> to avoid automatic keys rearangement:</p>
<pre><code>from collections import OrderedDict

sentence = "google"

d = OrderedDict()

for letter in sentence:
    if letter not in d.keys():
        d[letter] = sentence.count(letter)

print(max(d, key=d.get)) # g
</code></pre>
<p>but I'm looking for a possible one-liner or more elegant solution (if it's possible).</p>
<p><strong>Note:</strong> 
I already tried to use <a href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter()</a> but it doesn't work, since dict in python don't remember the order that keys were inserted. </p>
<p>e.g</p>
<pre><code>from collections import Counter

sentence = "bbbaaa"

c = Counter(sentence)
print(c.most_common()[0][0]) # have 50% chances of printing 'a' rather than 'b'.
</code></pre>
<p>Bonus question: Can someone explains why OrderedDict() are not the default dictionary behavior in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation for <code>collections.OrderedDict</code> actually has <a href="https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes">a recipe for an <code>OrderedCounter</code></a>:</p>
<pre><code>In [5]: from collections import Counter, OrderedDict

In [6]: class OrderedCounter(Counter, OrderedDict):
   ...:     pass
   ...:

In [7]: OrderedCounter("google").most_common()[0][0]
Out[7]: 'g'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Probably not very fast, but one-liner!</p>
<pre><code>&gt;&gt;&gt; s = "aaabbbbc"
&gt;&gt;&gt; sorted(s, key=lambda c: (-s.count(c), s.index(c)))[0]
'b'
</code></pre>
<p><strong>Edit</strong></p>
<p>Even shorter, thanks to @Ohad Eytan's comment:</p>
<pre><code>&gt;&gt;&gt; min(s, key=lambda c: (-s.count(c), s.index(c)))
'b'
</code></pre>
<p><strong>Benchmark</strong></p>
<p>Feeling bored tonight, so I benchmarked (using <code>timeit</code>) test @Joohwan's <code>most_common_char()</code> solution (mostcc), @Blender's <code>OrderedCounter</code> solution (odict) and my own one liner solution (onelin, using the <code>min</code> variant). The fastest solution was consistently mostcc: up to ~10x faster than onelin for long strings containing few different characters, and up to ~4x faster than odict for very short strings. For short strings or strings with little repeated chars, onelin beats odict (otherwise, it's the reverse). Here are the details (Length=length of the string, #chars=number of different unicode chars to randomly pick from for each char, mostcc=time to execute 10,000 times mostcc, odict=how much longer odict was compared to mostcc, onelin=how much longer oneline was compared to mostcc).</p>
<pre><code>Length  #chars  mostcc odict  onelin
10      10:     0.08s  3.76x  1.61x
10      100:    0.10s  3.57x  1.27x
10      1000:   0.12s  3.12x  1.34x
100     10:     0.43s  1.96x  3.29x
100     100:    0.59s  2.16x  2.18x
100     1000:   0.80s  1.92x  1.72x
1000    10:     3.48s  1.56x  9.79x
1000    100:    3.44s  1.72x  6.43x
1000    1000:   6.55s  1.68x  3.30x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am aware that you want a one-liner, but what if you had to repeat this task many times or handle really long sentences? I don't know the exact use case here but it could be worth your time considering the space and time complexity of the algorithm.</p>
<p>In your solution, for example, you are iterating through the sentence many times more than necessary with <code>sentence.count()</code>, which takes <code>O(n * number of unique characters)</code>. After that you iterate through the ordereddict once more to find the max (another <code>O(number of unique characters)</code> operation).</p>
<p>In the accepted solution, we end up having to define a new class (which breaks your 1 liner requirement btw) and instantiate new objects with alot of boilerplate code and functionalities you probably won't need every time you want to execute your task.</p>
<p>If you don't mind having a few more lines of code (again, I know this is not what the question is asking), we can build a reusable function which only has to iterate through the string <strong>once</strong> and use constant and minimal space:</p>
<pre><code>from collections import defaultdict


def most_common_char(sentence):
    if not sentence:
        return ''

    max_count = 1
    max_char = sentence[-1]
    char_counts = defaultdict(int)
    char_counts[max_char] = 1

    for i in xrange(len(sentence) - 2, -1, -1):
        char = sentence[i]
        char_counts[char] += 1
        if char_counts[char] &gt;= max_count:
            max_count = char_counts[char]
            max_char = char

    return max_char
</code></pre>
<p>We keep track of the character with the max count <strong>as</strong> we go through the string and spit it out at the end of the iteration. Note that we iterate <em>backwards</em> since you want the letter that comes first (i.e. last updated wins).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>Counter()</code> together with <code>next()</code> to find the first letter that meets the condition:</p>
<pre><code>&gt;&gt;&gt; s = "google"
&gt;&gt;&gt; c = Counter(s)
&gt;&gt;&gt; next(x for x in s if c[x] == c.most_common(1)[0][1])
'g'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also fix the issue you describe at the end of your question about using Counter by having the resulting list sorted by various attributes: firstly count, secondly lexicographical order like this:</p>
<pre><code>from collections import Counter

sentence = "google"

c = Counter(sentence)
print(sorted(c.most_common(), key = lambda x: (-x[1], sentence.index(x[0]))))
</code></pre>
<p>Output:</p>
<pre><code>=&gt; [('g', 2), ('o', 2), ('l', 1), ('e', 1)]
</code></pre>
<p>Just for fun:</p>
<p><em>Golfed Version</em>:</p>
<pre><code># If your sentence is s:
print(sorted(collections.Counter(s).most_common(),key=lambda x:(-x[1],s.index(x[0]))))
</code></pre>
</div>
<span class="comment-copy">OrderedDict() is slower than dict.</span>
<span class="comment-copy">Why do you need an OrderedDict at all? if you want to make sure keys aren't over-written use <a href="http://stackoverflow.com/questions/3483520/use-cases-for-the-setdefault-dict-method">the setdefault method or a DefaultDict</a> and for a "one-liner" you could just reduce the loop into a comprehension</span>
<span class="comment-copy">See <a href="http://stackoverflow.com/a/19643045/298607">OrderedDict vs defaultdict vs dict</a></span>
<span class="comment-copy">What would <code>goooogle</code> and <code>aaabbbb</code> desired result be?</span>
<span class="comment-copy">@MaxChr√©tien Is the tie broken by the one that occurs first in the word or the first lexicographically.</span>
<span class="comment-copy">Damn I fell stupid for not reading the doc entierly. Thanks anyway it's exactly what I was looking for</span>
<span class="comment-copy">Why not <code>min(s, key=lambda c: (-s.count(c), s.index(c)))</code>?</span>
<span class="comment-copy">Nice!  I didn't even know <code>min()</code> had a <code>key</code> argument.  Updating my answer.</span>
<span class="comment-copy">Now you got my vote :)</span>
<span class="comment-copy">First of all, thanks for this benchmark! Since this topic is now a speed test,  could you pass the code you use to output those results, it could be nice for new chalengers to have it. Otherwise, well played to @Joohwan with the backwards iterations! My favorite answer remains OdererCounter since it's the easiest one to understand but still have good performances.</span>
<span class="comment-copy">Glad you like the benchmark. Unfortunately I just did this in a console, I did not save the code. Basically I created a function for each, then I ran <code>timeit.timeit()</code> on random strings of various lengths and #chars, for each function. Something like: <code>t = timeit.timeit("mostcc(s)", number=10000, globals={"mostcc":mostcc, "s": s})</code>. To generate random strings I did something like this: <code>"".join([random.randint(32, n_chars+32) for i in range(length)]</code>.</span>
<span class="comment-copy">Most of the time, I prefer using official library when possible. It makes the code clearer and less error-free. But I've got your point, my solution isn't the best in term of complexity. I'm not sure for the validate answer though. I will make a benchmark of all the answers tomorrow to compare which one is the best. Anyhow, thanks for your time.</span>
<span class="comment-copy">@Joohwan I benchmarked a few solutions, yours won by a large margin (see my answer for details). :)</span>
<span class="comment-copy">@Joohwan, after an attempt to minify your function (which I failed ^^') I still removed 4 lines. Explanation: using <code>for char in reverse(sentence)</code> instead of <code>for i in xrange(len(sentence) - 2, -1, -1):</code>. This allows you to remove <code>char = sentence[i]</code> because you already got the <code>char</code>. Because now you start with the last character of the string you can remove the first <code>char_counts[max_char] = 1</code> and replace <code>max_char = sentence[-1]</code>by <code>max_char = ''</code> , so that you can deletethe <code>if not sentence: return ''</code>.</span>
<span class="comment-copy">Since you have <code>c.most_common(1)</code> that will return one of the most common elements but not the rest with the same count. So the entire predicate of <code>next(x for x in s if c[x] == c.most_common(1)[0][1])</code> suffers from the same random return...</span>
<span class="comment-copy">@dawg no it's not. The <code>c.most_common(1)[0][1]</code> will give just the desired <b>value</b> and that isn't random at all</span>
<span class="comment-copy">OK -- I see now.</span>
