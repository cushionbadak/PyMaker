<div class="post-text" itemprop="text">
<p>Print <code>dict</code> and <code>defaultdict</code>:</p>
<pre><code>&gt;&gt;&gt; d = {'key': 'value'}
&gt;&gt;&gt; print(d)
{'key': 'value'}

&gt;&gt;&gt; dd = defaultdict(lambda: 'value')
&gt;&gt;&gt; dd['key']
'value'
&gt;&gt;&gt; print(dd)
defaultdict(&lt;function &lt;lambda&gt; at 0x7fbd44cb6b70&gt;, {'key': 'value'})
</code></pre>
<p>With nested structure it becomes ugly:</p>
<pre><code>&gt;&gt;&gt; nested_d = {'key1': {'key2': {'key3': 'value'}}}
&gt;&gt;&gt; print(nested_d)
{'key1': {'key2': {'key3': 'value'}}}

&gt;&gt;&gt; def factory():
...     return defaultdict(factory)
... 
&gt;&gt;&gt; nested_dd = defaultdict(factory)
&gt;&gt;&gt; nested_dd['key1']['key2']['key3'] = 'value'
&gt;&gt;&gt; print(nested_dd)
defaultdict(&lt;function factory at 0x7fbd44cd4ea0&gt;, {'key1': defaultdict(&lt;function factory at 0x7fbd44cd4ea0&gt;, {'key2': defaultdict(&lt;function factory at 0x7fbd44cd4ea0&gt;, {'key3': 'value'})})})
</code></pre>
<p>Were there any reasons for not making it human-readable by default? (UPD: I mean what are the reasons behind not having custom <code>__str__</code> defined for <code>defaultdict</code> by default?)</p>
</div>
<div class="post-text" itemprop="text">
<p><code>repr()</code> output (<code>defaultdict</code> has no <code>__str__</code>, only <code>__repr__</code>) is  <em>debugging output</em>. It is not meant to be pretty, it is meant to be <em>functional</em>. It tells you the type, the <code>repr()</code> of the callable that produces the default, and the contents.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow"><code>__repr__</code> documentation</a>:</p>
<blockquote>
<p>This is typically used for debugging, so it is important that the representation is information-rich and unambiguous.</p>
</blockquote>
<p>Like all datatypes in Python, (except for strings for obvious reasons), no informal (<code>__str__</code>) is defined because it is up to the programmer to decide what output is suitable for their use-cases. No default can be set for that, because use-cases vary so widely. Output for a file has different needs than output to a GUI or to a web-page for example.</p>
<p>In Python 2, convert the object to a plain dictionary first, then use <code>pprint()</code> if you want 'pretty' output:</p>
<pre><code>def todict(d):
    if not isinstance(d, dict):
        return d
    return {k: todict(v) for k, v in d.items()}

pprint(todict(nested_dd))
</code></pre>
<p>In Python 3, <code>pprint</code> supports <code>defaultdict</code> directly:</p>
<pre><code>&gt;&gt;&gt; pprint(nested_dd)
defaultdict(&lt;function factory at 0x105ed2f28&gt;,
            {'key1': defaultdict(&lt;function factory at 0x105ed2f28&gt;,
                                 {'key2': defaultdict(&lt;function factory at 0x105ed2f28&gt;,
                                                      {'key3': 'value'})})})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no way to know what, if anything, the author(s) were thinking or even whether they gave it much consideration at all.</p>
<p>For the specific case of nested <code>defaultdict</code>s, as shown your example code:</p>
<pre><code>def factory():
    return defaultdict(factory)
nested_dd = defaultdict(factory)
nested_dd['key1']['key2']['key3'] = 'value'
</code></pre>
<p>You can avoid the issue by subclassing <code>dict</code> like this instead:</p>
<pre><code>class Tree(dict):
    def __missing__(self, key):
        value = self[key] = type(self)()
        return value

nested_dd = Tree()
nested_dd['key1']['key2']['key3'] = 'value'
print(nested_dd) # -&gt; {'key1': {'key2': {'key3': 'value'}}}
</code></pre>
<p>Since the subclass doesn't define its own <code>__repr__()</code> or <code>__str__()</code> methods, instances of it will <code>print</code> (and <code>pprint</code>) just like regular <code>dict</code> instances do.</p>
</div>
<span class="comment-copy">@jonrsharpe. It's not only <code>repr</code> in this case, <code>str()</code> has the same output. Might be actually worth it to take this upstream.</span>
<span class="comment-copy">@DJV: there is no <code>__str__</code> method, only <code>__repr__</code>; it doesn't matter if <code>str()</code> is called here, as the fallback is used.</span>
<span class="comment-copy">@MartijnPieters I have <code>__str__</code> in e.g. <code>dir(defaultdict(list))</code> (on Python 2.7.12). Did I miss something?</span>
<span class="comment-copy">@MartijnPieters That's quite obvious, yes. But should it? ;)</span>
<span class="comment-copy">@MartijnPieters Let me formulate this differently: How far is it a POLA violation if a "builtin" type had a different <code>str()</code> and <code>repr()</code> outputs? <code>defaultdict</code> could <code>str()</code> to something more like <code>dict()</code> and <code>repr()</code> to what it has now. But we are far in opinion country, now.</span>
<span class="comment-copy">I understand there are workarounds. Question is about why doesnt it print human readable text by default? It wasn't difficult to add <code>__str__</code> function, right? Were there any reasons for not having <code>__str__</code>?</span>
<span class="comment-copy">@DJV: there is no human readable version of dictionaries, lists, sets or tuples either. Why would a <code>defaultdict</code> be different?</span>
<span class="comment-copy">@DJV: these are <i>basic data structures</i>. There is no "human-readable" version, because it is up to the program to decide what that means.</span>
<span class="comment-copy">nested dicts seem pretty readable to be, Nested defaultdicts dont. I was just wondering what benefits fo that, as it seemed to me that if <code>defaultdicts</code> were printed as <code>dicts</code> by default it would be cleaner.</span>
<span class="comment-copy">@DJV: we are going round in circles here. That would loose information, the factory is a crucial piece of data on a <code>defaultdict</code> instance so is included in the <code>repr()</code>, which is meant for debugging purposes and should uniquely identify the object. From the <code>__repr__</code> documentation: <i>This is typically used for debugging, so it is important that the representation is information-rich and unambiguous.</i></span>
<span class="comment-copy"><code># the benefits of defaultdict but still prints like a regular dict class mydict(dict):     def __init__(self, func):         self.func=func     def __missing__(self, key):         value = self[key] = self.func()         return value</code></span>
