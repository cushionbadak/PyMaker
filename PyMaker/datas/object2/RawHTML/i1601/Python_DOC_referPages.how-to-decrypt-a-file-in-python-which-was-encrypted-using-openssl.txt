<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/16761458/how-to-decrypt-openssl-aes-encrypted-files-in-python">How to decrypt OpenSSL AES-encrypted files in Python?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>I encrypted a file using <code>openssl</code> using the below command</p>
<pre><code>cat input.txt
hello world
openssl aes-256-cbc -pass pass:'00112233445566778899aabbccddeeff' -iv a2a8a78be66075c94ca5be53c8865251 -nosalt -base64 -in input.txt -out output.txt
cat output.txt
pt7DqtAwtTjPbTlzVApucQ==
</code></pre>
<p>How can i decrypt the file using python Crypto package. I tried the below and it didn't work. </p>
<pre><code>&gt;&gt;&gt; from Crypto.Cipher import AES
&gt;&gt;&gt; from base64 import b64decode
&gt;&gt;&gt; with open('output.txt') as f:
...     aes = AES.new('00112233445566778899aabbccddeeff', AES.MODE_CBC, IV='a2a8a78be66075c94ca5be53c8865251'.decode('hex'))
...     print(aes.decrypt(b64decode(f.read())))
...
L�|�L   ��O�*$&amp;9�
</code></pre>
<p>I need a way to encrypt a file using openssl aes-256-cbc cipher and decrypt in python</p>
</div>
<div class="post-text" itemprop="text">
<p>The password is not the key. Openssl uses <a href="https://www.openssl.org/docs/manmaster/man3/EVP_BytesToKey.html" rel="nofollow noreferrer"><code>EVP_BytesToKey</code></a> to create an appropriate key (&amp; IV, if necessary) from the password and the salt.</p>
<p>As James K Polk mentions in a comment, you can use the -P (or -p) option to tell Openssl to print the key (in hex ), which you can then pass to Crypto.Cipher. Alternatively, you can implement <code>EVP_BytesToKey</code> in Python, as shown below. This is a simplified version of <code>EVP_BytesToKey</code> that uses no salt, and the default value of 1 for the <code>count</code> arg.</p>
<p>As the <code>EVP_BytesToKey</code> docs state, this is a rather weak password derivation function. As the <a href="https://docs.python.org/3/library/hashlib.html#key-derivation" rel="nofollow noreferrer">hashlib docs</a> mention, modern password derivation normally performs hundreds of thousands of hashes to make password hashing attacks very slow.</p>
<p>We also need a function to remove the <a href="https://en.wikipedia.org/wiki/Padding_%28cryptography%29#PKCS#5_and_PKCS#7" rel="nofollow noreferrer">PKCS7 padding</a> from the decrypted data bytes. The <code>unpad</code> function below simply assumes that the padding data is valid. In real software the <code>unpad</code> function must verify that the padded data is valid to prevent padding-based attacks. My <code>unpad</code> function also assumes the data has been encoded as UTF-8 bytes and decodes the unpadded data to text.</p>
<pre><code>from __future__ import print_function
from Crypto.Cipher import AES
from base64 import b64decode
from hashlib import md5

def evp_simple(data):
    out = ''
    while len(out) &lt; 32:
        out += md5(out + data).digest()
    return out[:32]

def unpad(s):
    offset = ord(s[-1])
    return s[:-offset].decode('utf-8')

iv = 'a2a8a78be66075c94ca5be53c8865251'.decode('hex')
passwd = '00112233445566778899aabbccddeeff'
key = evp_simple(passwd)
print('key', key.encode('hex'))

aes = AES.new(key, AES.MODE_CBC, IV=iv)

data = b64decode('pt7DqtAwtTjPbTlzVApucQ==')

raw = aes.decrypt(data)
print(repr(raw), len(raw))
plain = unpad(raw)
print(repr(plain), len(plain))
</code></pre>
<p><strong>output</strong></p>
<pre><code>key b4377f7babf2991b7d6983c4d3e19cd4dd37e31af1c9c689ca22e90e365be18b
'hello world\n\x04\x04\x04\x04' 16
u'hello world\n' 12
</code></pre>
<hr/>
<p>That code will not run on Python 3, so here's a Python 3 version.  </p>
<pre><code>from Crypto.Cipher import AES
from base64 import b64decode
from hashlib import md5

def evp_simple(data):
    out = b''
    while len(out) &lt; 32:
        out += md5(out + data).digest()
    return out[:32]

def unpad(s):
    offset = s[-1]
    return s[:-offset].decode('utf-8')

iv = bytes.fromhex('a2a8a78be66075c94ca5be53c8865251')
passwd = b'00112233445566778899aabbccddeeff'
key = evp_simple(passwd)

aes = AES.new(key, AES.MODE_CBC, IV=iv)

data = b64decode('pt7DqtAwtTjPbTlzVApucQ==')

raw = aes.decrypt(data)
print(repr(raw), len(raw))
plain = unpad(raw)
print(repr(plain), len(plain))
</code></pre>
<p><strong>output</strong></p>
<pre><code>b'hello world\n\x04\x04\x04\x04' 16
'hello world\n' 12
</code></pre>
</div>
<span class="comment-copy">use the -P option to openssl to print out the key and IV, then supply those to your python code.</span>
