<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6260089/strange-result-when-removing-item-from-a-list">strange result when removing item from a list [duplicate]</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>For loops are mentioned in <a href="https://docs.python.org/3/tutorial/controlflow.html?highlight=loop#for-statements" rel="nofollow noreferrer">two</a> <a href="https://docs.python.org/3/tutorial/controlflow.html?highlight=loop#for-statements" rel="nofollow noreferrer">places</a> in the python docs (that I have found). I did try to find the source code for <code>for</code> loops in <a href="https://github.com/python/cpython" rel="nofollow noreferrer">cpython</a> but to no avail.</p>
<p>Here's what I'm trying to understand: I had assumed for loops were a sort of <code>while i &lt;= len(iterable) then loop</code> or <code>if i &lt;= len(iterable) then loop:</code>. I'm not sure that's the case, and <a href="https://repl.it/@NotAnAmbiTurner/WeightyNeglectedCallbacks" rel="nofollow noreferrer">here's</a> why:</p>
<pre><code>y = [1, 2, 3, 4]
for x in y:
  print(y)
  print(y.pop(0))

Output:
[1, 2, 3, 4]
1
[2, 3, 4]
2
</code></pre>
<p>I <em>know</em> you shouldn't modify an iterable while you're looping through it. I know that. But still, this isn't a random result - it happens every time this code is run: 2 loops. You also get 2 loops if you run <code>pop()</code> instead.</p>
<p>Maybe even curiouser, it seems like you reliably get <code>len(y)+1//2</code> loops (at least using <code>.pop()</code>, I haven't tried much other testing):</p>
<ul>
<li>if <code>y = [1, 2]</code> there is one loop</li>
<li>if <code>y = [1, 2, 3]</code> there are two loops</li>
<li>if <code>y = [1, 2, 3, 4]</code> there are <em>still</em> two loops</li>
<li>if <code>y = [1, 2, 3, 4, 5]</code> there are three loops</li>
<li>if <code>y = [1, 2, 3, 4, 5, 6]</code> there are <em>still</em> three loops</li>
<li>if <code>y = [1, 2, 3, 4, 5, 6, 7]</code> there are <em>four</em> loops</li>
</ul>
<p>According to the Python docs:</p>
<blockquote>
<p>Note</p>
<p>There is a subtlety when the sequence is being modified by the loop
  (this can only occur for mutable sequences, e.g. lists). An internal
  counter is used to keep track of which item is used next, and this is
  incremented on each iteration. When this counter has reached the
  length of the sequence the loop terminates. This means that if the
  suite deletes the current (or a previous) item from the sequence, the
  next item will be skipped (since it gets the index of the current item
  which has already been treated). Likewise, if the suite inserts an
  item in the sequence before the current item, the current item will be
  treated again the next time through the loop. This can lead to nasty
  bugs that can be avoided by making a temporary copy using a slice of
  the whole sequence, e.g.,</p>
</blockquote>
<pre><code>for x in a[:]:
    if x &lt; 0: a.remove(x)
</code></pre>
<p>Can anyone explain the logic Python uses when it is looping through an iterable that is modified during the loop? How do <code>iter</code> and <code>StopIteration</code>, and <code>__getitem__(i)</code> and <code>IndexError</code> factor in? What about iterators that aren't lists? And most importantly, is this / where is this in the docs?</p>
<p>As @Yang K suggested:</p>
<pre><code>y = [1, 2, 3, 4, 5, 6, 7]
for x in y:
  print("y: {}, y.pop(0): {}".format(y, y.pop(0)))
  print("x: {}".format(x))

# Output
y: [2, 3, 4, 5, 6, 7], y.pop(0): 1
x: 1
y: [3, 4, 5, 6, 7], y.pop(0): 2
x: 3
y: [4, 5, 6, 7], y.pop(0): 3
x: 5
y: [5, 6, 7], y.pop(0): 4
x: 7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The loop executes till iterable says it has no more elements. After two cycles, the iterable has gone through two elements, and has lost two elements, which means it is at its end, and the loop terminates.</p>
<p>Your code is equivalent to this:</p>
<pre><code>y = [1, 2, 3, 4]
i = iter(y)
while True:
    try:
        x=next(i)
    except StopIteration:
        break
    print(y)
    print(y.pop(0))
</code></pre>
<p>The list iterator holds the index that is up to be read next. In the third cycle, the list is <code>[3, 4]</code>, and <code>next(i)</code> would be needing to read <code>y[2]</code>, which is not possible, so <code>next</code> raises <code>StopIteration</code>, which ends the loop.</p>
<p><strong>EDIT</strong> As to your other questions:</p>
<blockquote>
<p>How do <code>iter</code> and <code>StopIteration</code>, and <code>__getitem__(i)</code> and <code>IndexError</code> factor in?</p>
</blockquote>
<p>The first two are as described above: it is what defines a <code>for</code> loop. Or, if you will, it is the contract of <code>iter</code>: it will yield stuff till it stops with <code>StopIteration</code>.</p>
<p>The latter two, I don't think participate at all, since the list iterator is <a href="https://github.com/python/cpython/blob/621cebe81b1e6c8de10425955bf532d31ee4df42/Objects/listobject.c#L3156" rel="nofollow noreferrer">implemented in C</a>; for example, the check for whether the iterator is exhausted directly compares the current index with <code>PyList_GET_SIZE</code>, which directly looks at <code>-&gt;ob_size</code> field; it doesn't pass through Python any more. Obviously, you could make a list iterator that would be fully in pure Python, and you'd likely be either using <code>len</code> to perform the check, or catching <code>IndexError</code> and again letting the underlying C code perform the check against <code>-&gt;ob_size</code>.</p>
<blockquote>
<p>What about iterators that aren't lists?</p>
</blockquote>
<p>You can define any object to be iterable. When you call <code>iter(obj)</code>, it is the same as calling <code>obj.__iter__()</code>. This is expected to return an iterator, which knows what to do with <code>i.__next__()</code> (which is what <code>next(i)</code> translates to). I believe dicts iterate (I think, haven't checked) by having an index into the list of its keys. You can make an iterator that will do anything you want, if you code it. For example:</p>
<pre><code>class AlwaysEmpty:
    def __iter__(self):
        return self
    def __next__(self):
        raise StopIteration

for x in AlwaysEmpty():
    print("there was something")
</code></pre>
<p>will, predictably, print nothing.</p>
<blockquote>
<p>And most importantly, is this / where is this in the docs?</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/stdtypes.html#typeiter" rel="nofollow noreferrer">Iterator Types</a></p>
</div>
<span class="comment-copy">Just print <code>x</code> in the <code>for</code> loop and you'll understand the logic behind it.  First iteration: It does everything normally.      Second Iteration : <code>y[0]</code> has been removed in the first iteration. normally it would go to <code>y[1]</code>, but since you just removed something it skips it and goes to <code>y[2]</code> instead.  Third iteration: You have removed what was originally <code>y[2]</code> and the link shrinks. Normally, it would go to <code>y[3]</code>, but since you shrinked it, it goes to <code>y[4]</code>. But since <code>y[4]</code> is the end of the list and doesn't exist, the loop stops running.</span>
<span class="comment-copy">Python uses iterator-based for-loops. A for loop will result in a call to <code>iter</code> on the value being looped over, and the resulting iterator will have <code>next</code> called on it until it raises <code>StopIteration</code>. Now, there is some baggage left over from before this was formalized, there is an alternative iterator protocol that calls <code>__getitem__(i)</code> (i.e. the indexing operator <code>[i]</code>) with <code>i</code> starting from 0 until the indexing operation throws an <code>IndexError</code></span>
<span class="comment-copy">Note, that <code>len</code> is never involved, python for-loops are not equivalent to C-like for-loops. See <a href="https://stackoverflow.com/a/47348171/5014455">this</a> answer I made a while back to another question where I go into some details about this</span>
<span class="comment-copy">Different iterators are implemented differently. List iterators go strictly by index, and are exhausted when the index is no longer a valid index.</span>
<span class="comment-copy">Note, <b>lists are not iterators</b>. Lists are <i>iterable</i> (because their <code>iter</code> method <i>returns an iterator</i>).</span>
<span class="comment-copy">Great, thank you! For reference: <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer">iter()</a> and <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">next()</a></span>
<span class="comment-copy">Well, I was mistaken, list's use the actual iterator protocol, not the "old style", legacy sequence iteration protocol (which I can't find a good reference for in the docs, although it is alluded to <a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow noreferrer">here</a>). Here is a <a href="https://stackoverflow.com/questions/20551042/whats-the-difference-between-iter-and-getitem">question that addresses it</a>. I think by now, all the built-in types use the "real" protocol, or at least wrap their other implementation, but I remember <code>str</code> and <code>list</code> used to use it, at one time</span>
