<div class="post-text" itemprop="text">
<p>I know that in Python, generators are invoked lazily. For example:</p>
<pre><code>&gt;&gt;&gt; def G():
...     print('this was evaluated now 1')
...     yield 1
...     print('this was evaluated now 2')
...     yield 2
...
&gt;&gt;&gt; g = G()
&gt;&gt;&gt; next(g)
this was evaluated now 1
1
&gt;&gt;&gt; next(g)
this was evaluated now 2
2
</code></pre>
<p>The line <code>print('this was evaluated now 1')</code> was evaluated only after the first <code>next(g)</code> was called.</p>
<p>I wonder whether there is a simple way to invoke the generator non-lazily. This means that when calling <code>g = G()</code>, the function would calculate everything up to and including the first <code>yield</code> result, without actually yielding. Then, on the first call to <code>next(g)</code>, the already-calculated result will be yielded, and also everything up to and including the second <code>yield</code> result would be calculated. And so on.</p>
<p>How can this be achieved? </p>
<hr/>
<p>Here is the expected behavior under this non-lazy scheme:</p>
<pre><code>&gt;&gt;&gt; g = G()
this was evaluated now 1
&gt;&gt;&gt; next(g)
1
this was evaluated now 2
&gt;&gt;&gt; next(g)
2
</code></pre>
<hr/>
<p>Here is a solution attempt, which does not work:</p>
<pre><code>&gt;&gt;&gt; class NonLazyGenerator():
...     def __init__(self,G):
...         self.g = G()
...         self.next_value = next(self.g)
...
...     def __next__(self):
...         current_value = self.next_value
...         try:
...             self.next_value = next(self.g)
...         except StopIteration:
...             pass
...         return current_value
...
&gt;&gt;&gt; g = NonLazyGenerator(G)
this was evaluated now 1
&gt;&gt;&gt; next(g)
this was evaluated now 2
1
&gt;&gt;&gt; next(g)
2
</code></pre>
<p>This fails since the value is yielded only after the <code>return</code> statement, while the calculation of everything up to the next <code>yield</code> happens before the <code>return</code> statement. This example made me realize that it may not be possible to perform what I am seeking for, since it would require doing steps after the function has returned (might require multi-threading).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could probably write some kind of decorator for it, such as:</p>
<pre><code>def eagergenerator(mygen):
    class GeneratorWrapper:
        def __init__(self, *args, **kwargs):
            self.g = mygen(*args, **kwargs)
            self.last = next(self.g)
        def __iter__(self):
            return self
        def __next__(self):
            if self.last is self:
                raise StopIteration
            fake_yield = self.last
            try:
                self.last = next(self.g)
                return fake_yield
            except StopIteration:
                self.last = self
                return fake_yield
    return GeneratorWrapper
</code></pre>
<p>Then you can simply decorate your normal generators:</p>
<pre><code>@eagergenerator
def G():
    print("one")
    yield 1
    print("two")
    yield 2
</code></pre>
<p>which will work as follows:</p>
<pre><code>&gt;&gt;&gt; g = G()                               
one                                       
&gt;&gt;&gt; next(g)                               
two                                       
1                                         
&gt;&gt;&gt; next(g)                               
2                                         
&gt;&gt;&gt; next(g)                               
Traceback (most recent call last):        
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;     
  File "eagergen.py", line 10, in __next__
    raise StopIteration                   
StopIteration                             
&gt;&gt;&gt;                                       
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>credit: this was inspired by @L3viathan answer</p>
<p>In this version, <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer">itertools.tee</a> is used to store the one yielded value the wrapper is behind the original generator.</p>
<pre><code>import itertools

def eagergenerator(mygen):
    class GeneratorWrapper:
        def __init__(self, *args, **kwargs):
            self.g0, self.g1 = itertools.tee(mygen(*args, **kwargs))
            self._next0()
        def _next0(self):
            try:
                next(self.g0)
            except StopIteration:
                pass
        def __iter__(self):
            return self
        def __next__(self):
            self._next0()
            return next(self.g1)
    return GeneratorWrapper
</code></pre>
</div>
<span class="comment-copy">Why would you want that? Yielding would still do calculation work for the next result, so you are not gaining anything.</span>
<span class="comment-copy">I can give an explanation for why I would want this, but the purpose of my question is not to find justifications for or against doing this, but rather to understand how to do this.</span>
<span class="comment-copy">The reason is that I have a function which has in its body the a <code>yield</code> statement, and this turns the function into a generator. However, this <code>yield</code> is only reachable conditioned on the value of an argument to the function. I want the function to behave as a regular function when this argument is <code>False</code>, and as a generator otherwise. If generators would be evaluated non-lazily. this would solve the problem. (Of course, there are other ways to solve this problem, and of course, this isn't necessary good programming, but as I said, I'm currently only interested in an answer to the question)</span>
<span class="comment-copy">A nice example (+1). I'd like to add few notes if somebody wants to base own code on it. I did not try, but I think an "empty" generator needs to be handled as a special case with <code>try/next/except StopIteration</code> in <code>__init__</code>. Also the value of StopIteration (i.e. the generator's return value) should be preserved by the wrapper.</span>
<span class="comment-copy">This was just a proof-of-concept, but feel free to edit my answer!</span>
