<div class="post-text" itemprop="text">
<p>It seems to me that <code>NamedTuple</code> and <code>TypedDict</code> are fairly similar and the Python developers themselves recognized that.</p>
<blockquote>
<p>Concerning the PEP, I would rather add a common section about NamedTuple and TypedDict, they are quite similar and the latter already behaves structurally. What do you think?
  <a href="https://github.com/python/mypy/issues/3521#issuecomment-307506463" rel="nofollow noreferrer">source</a></p>
</blockquote>
<p>But then Guido seems not so sure about that.</p>
<blockquote>
<p>I'm not so sure that NamedTuple and TypedDict are really all that similar (except they are both attempts to handle outdated patterns in a statically-typed world).</p>
</blockquote>
<p><a href="https://github.com/python/mypy/issues/3521#issuecomment-307509230" rel="nofollow noreferrer">source</a></p>
<p>So, this is my lazy attempt to get someone else come up with a crisp comparison where the official documentation seems lacking.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python and its community are wrestling with the "struct" problem: how to best group related values into composite data objects that allow logical/easy accessing of components (typically by name). There are <em>many</em> competing approaches:</p>
<ul>
<li><code>collections.namedtuple</code> instances</li>
<li>dictionaries (with a fixed/known set of keys)</li>
<li>attribute-accessible dictionaries (like <a href="https://pypi.org/project/stuf/" rel="nofollow noreferrer">stuf</a>)</li>
<li>the <a href="https://github.com/python-attrs/attrs" rel="nofollow noreferrer">attrs</a> library</li>
<li>PEP 557 <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a></li>
<li>plain old bespoke objects hand-crafted for every struct type</li>
<li>sequences like <code>tuple</code> and <code>list</code> with implied meanings for each position/slot (archaic but extremely common)</li>
<li>etc.</li>
</ul>
<p>So much for "There should be one—and preferably only one—obvious way to do it."</p>
<p>Both the <code>typing</code> library and Mypy, like the Python community at large, are simultaneously struggling with how to more effectively define types/schema, including for composite objects. The discussion you linked to is part of that wrestling and trying to find a way forward. </p>
<p><code>NamedTuple</code> is a typing superclass for structured objects resulting from the <code>collections.namedtuple</code> factory; <code>TypedDict</code> a Mypy attempt to define the keys and corresponding types of values that occur when using fixed-schema dictionaries. They are similar if you're just thinking about "I have a fixed set of keys that should map to a fixed set of typed values." But the resulting implementations and constraints are very different. Are a bag and a box similar? Maybe. Maybe not. Depends on your perspective and how you want to use them. Pour wine and let the discussion begin!</p>
<p><code>NamedTuple</code>, by the way, is now a formal part of Python. </p>
<pre class="lang-py prettyprint-override"><code>from typing import NamedTuple

class Employee(NamedTuple):
    name: str
    id: int
</code></pre>
<p><code>TypedDict</code> is <em>not</em> part of Python proper, but an experimental Mypy feature to wrangle typing onto the heterogeneous, structure-oriented use of dictionaries. </p>
<pre><code>from mypy_extensions import TypedDict

Movie = TypedDict('Movie', {'name': str, 'year': int})
</code></pre>
<p>Despite their differences, both <code>NamedTuple</code> and <code>TypedDict</code> lock down the specific keys to be used, and the types of values corresponding to each key. Therefore they are aiming at basically the same goal: Being useful typing mechanisms for composite/struct types.</p>
<p>Python's standard <code>typing.Dict</code> focuses on much more homogenous, parallel mappings, defining key/value types, not keys <em>per se</em>. Therefore it is not very useful in defining composite objects that happen to be stored in dictionaries.</p>
<pre><code>ConnectionOptions = Dict[str, str] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>NamedTuple</code> is a specific type. As the name suggests it is a tuple that is extended to have named entries.</p>
<p><code>TypedDict</code> is not a real object, you can't (or at least shouldn't) use it, it is instead used for adding type information (for mypy type checker) to annotate types in scenarios when dictionary has various keys with different types i.e. essentially all places when one should use <code>NamedTuple</code>. It's very helpful to annotate existing code that you don't want to refactor.</p>
</div>
<span class="comment-copy">do <code>namedtuple</code> &amp; <code>dict</code> look similar to you?</span>
<span class="comment-copy">Thank you for the writeup. Did you deliberately go for that <code>TypedDict</code> syntax? Because there's also the class based syntax which make them look exactly like a the <code>NamedTuple</code> (from a syntax point of view)</span>
<span class="comment-copy">I used the syntax used by <a href="https://mypy.readthedocs.io/en/stable/more_types.html#typeddict" rel="nofollow noreferrer">the Mypy documentation</a>. Docs usually best source for what's considered canonical / preferred.</span>
