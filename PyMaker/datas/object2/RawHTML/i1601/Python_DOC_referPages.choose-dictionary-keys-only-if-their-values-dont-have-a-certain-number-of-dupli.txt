<div class="post-text" itemprop="text">
<p>Given a dictionary and a limit for the number of keys in a new dictionary, I would like the new dictionary to contain the keys with the highest values.</p>
<p>The given dict is:</p>
<pre><code>dict = {'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1 }
</code></pre>
<p>I want to get a new dictionary that has the keys with the highest values of length limit.</p>
<p>For instance for limit=1 the new dict is</p>
<pre><code>{'apple':5} 
</code></pre>
<p>if the limit=2 </p>
<pre><code>{'apple':5, 'pears':4}
</code></pre>
<p>I tried this:</p>
<pre><code>return dict(sorted(dictation.items(),key=lambda x: -x[1])[:limit])
</code></pre>
<p>but when I try limit=3, I get</p>
<pre><code>{'apple':5, 'pears':4, 'orange':3}
</code></pre>
<p>But it shouldn't include orange:3 <strong>because orange and kiwi have same priority</strong> if we include kiwi and orange it will exceed the limit so it shouldn't include both. I should return </p>
<pre><code>{'apple':5, 'pears':4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The way to go would be to use a <code>collections.Counter</code> and <code>most_common(n)</code>. Then you can take one more as needed and keep popping until the last value changes:</p>
<pre><code>from collections import Counter

dct = {'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1}
n = 3

items = Counter(dictation).most_common(n+1)
last_val = items[-1][1]
if len(items) &gt; n:
    while items[-1][1] == last_val:
        items.pop()

new = dict(items)
# {'apple': 5, 'pears': 4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is computationally not very good, but it works. It creates a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> object to get the sorted output for your data and a inverted <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a> that holds list that match to a score - it creates the result using both and some math:</p>
<pre><code>from collections import defaultdict, Counter

def gimme(d,n):
    c = Counter(d)
    grpd = defaultdict(list)
    for key,value in c.items():
        grpd[value].append(key)


    result = {}
    for key,value in c.most_common():
        if len(grpd[value])+len(result) &lt;= n:
            result.update( {k:value for k in grpd[value] } )
        else:
            break
    return result
</code></pre>
<p>Test:</p>
<pre><code>data = {'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1 }

for k in range(10):
    print(k, gimme(data,k))
</code></pre>
<p>Output:</p>
<pre><code>0 {}
1 {'apple': 5}
2 {'apple': 5, 'pears': 4}
3 {'apple': 5, 'pears': 4}
4 {'apple': 5, 'pears': 4, 'orange': 3, 'kiwi': 3}
5 {'apple': 5, 'pears': 4, 'orange': 3, 'kiwi': 3}
6 {'apple': 5, 'pears': 4, 'orange': 3, 'kiwi': 3, 'banana': 1}
7 {'apple': 5, 'pears': 4, 'orange': 3, 'kiwi': 3, 'banana': 1}
8 {'apple': 5, 'pears': 4, 'orange': 3, 'kiwi': 3, 'banana': 1}
9 {'apple': 5, 'pears': 4, 'orange': 3, 'kiwi': 3, 'banana': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you note, filtering by the top <em>n</em> doesn't exclude by default all equal values which exceed the stated cap. This is by design.</p>
<p>The trick is to consider the <em>(n+1)</em> th highest value and ensure the values in your dictionary are all higher than this number:</p>
<pre><code>from heapq import nlargest

dictation = {'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1}

n = 3
largest_items = nlargest(n+1, dictation.items(), key=lambda x: x[1])
n_plus_one_value = largest_items[-1][1]

res = {k: v for k, v in largest_items if v &gt; n_plus_one_value}

print(res)

{'apple': 5, 'pears': 4}
</code></pre>
<p>We assume here <code>len(largest_items) &lt; n</code>, otherwise you can just take the input dictionary as the result.</p>
<hr/>
<p>The dictionary comprehension seems expensive. For larger inputs, you can use <code>bisect</code>, something like:</p>
<pre><code>from heapq import nlargest
from operator import itemgetter
from bisect import bisect

dictation = {'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1}

n = 3
largest_items = nlargest(n+1, dictation.items(), key=lambda x: x[1])
n_plus_one_value = largest_items[-1][1]

index = bisect(list(map(itemgetter(1), largest_items))[::-1], n_plus_one_value)

res = dict(largest_items[:len(largest_items) - index])

print(res)

{'apple': 5, 'pears': 4}
</code></pre>
</div>
<span class="comment-copy">I followed this question until you said "because I can't add orange. If I add it will be more than the limit.".</span>
<span class="comment-copy">So you're saying if there are multiple items with the same count, you should only take any if all of them fit within the limit? Have you looked into whether <code>Counter.most_common</code> does what you need? I'd recommend not trying to fit it into one line.</span>
<span class="comment-copy">But OP says for <code>limit=3</code> the dict should still have 2 keys, for reasons I don't unterstand.</span>
<span class="comment-copy">@timgeb I added the necessary bumpiness. Lost all of its appeal :(</span>
<span class="comment-copy">still shorter then mine</span>
