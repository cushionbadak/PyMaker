<div class="post-text" itemprop="text">
<p>I have a nested containing values of different lengths as so:</p>
<pre><code>[['cat', 123, 'yellow'],
['dog', 12345, 'green'],
[horse', 123456, 'red']]
</code></pre>
<p>I want to print them like this:</p>
<pre><code>cat,   123,    yellow
dog,   12345,  green
horse, 123456, red 
</code></pre>
<p>I have tried using pprint to achieve my aims with the following code:</p>
<pre><code>for sub in master_list:

    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(sub)
</code></pre>
<p>Where master is the nested list and sub the lists within it. This however gives me an output like so:</p>
<pre><code>[
    'cat', 
    123, 
    'yellow'
],

[
    'dog', 
    12345, 
    'green'
],

[
    horse', 
    123456, 
    'red'
]
</code></pre>
<p>Is there a python module that allows me to relatively easily achieving what I want, without some sort of convoluted hack?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Pandas can help.</p>
<pre><code>import pandas as pd
lst = [['cat', 123, 'yellow'], ['dog', 12345, 'green'], ['horse', 123456, 'red']]
df = pd.DataFrame(lst)
print(df)
</code></pre>
<p>Output:</p>
<pre><code>    0   1   2
0   cat     123     yellow
1   dog     12345   green
2   horse   123456  red
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use the following code:</p>
<pre><code>myLst = [['cat', 123, 'yellow'],
['dog', 12345, 'green'],
['horse', 123456, 'red']]

for subLst in myLst:
    print("\t".join([str(ele) for ele in subLst]))
</code></pre>
<p>Which is printing the output like so:</p>
<pre><code>cat    123      yellow
dog    12345    green
horse  123456   red
</code></pre>
<p>In case you want to have "," too, just change the line</p>
<pre><code>print("\t".join([str(ele) for ele in subLst]))
</code></pre>
<p>to</p>
<pre><code>print(",\t".join([str(ele) for ele in subLst]))
</code></pre>
<p>And the complete thing as a one-liner:</p>
<pre><code>print("\n".join([",\t".join([str(ele) for ele in subLst]) for subLst in myLst]))
</code></pre>
<p>Or in case you need a function:</p>
<pre><code>def printLst(myLst):
    print("\n".join([",\t".join([str(ele) for ele in subLst]) for subLst in myLst]))
</code></pre>
<p><strong>Edit</strong></p>
<p>As pointed out in the comments this is also a good use-case for the python <code>map</code> function. Which can be used in order to make everything shorter ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>Your concrete format wishescan be solved by printing with <code>ljust</code> to add the needed spaces:</p>
<pre><code>data = [['cat', 123, 'yellow'],
        ['dog', 12345, 'green'],
        ['horse', 123456, 'red']]

# get the overall widest string as base for right-aligning them 
max_len = max( len(str(x)) for k in data for x in k) 

for inner in data:
    first = True
    for elem in inner[:-1]: # all but the last
        text = "{},".format(elem).ljust(max_len+2)
        print(text,end="")

    print(inner[-1]) # print last
</code></pre>
<p>Output:</p>
<pre><code>cat,    123,    yellow
dog,    12345,  green
horse,  123456, red
</code></pre>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/library/stdtypes.html#str.ljust" rel="nofollow noreferrer">str.ljust(width[, fillchar])</a> for left-justify in width </li>
<li><a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer">print(*objects, sep=' ', end='\n', ...)</a></li>
</ul>
<hr/>
<p>Generally for formatting you can use the  <a href="https://docs.python.org/3/library/string.html#formatspec" rel="nofollow noreferrer">string format mini language</a> to format your output to your liking: </p>
<pre><code>for inner in data:
    first = True
    for elem in inner:
        if first:
            text = "{:&lt;{}} ".format(elem,max_len+2)
            first = False
        else:
            text = ", {:&lt;{}} ".format(elem,max_len+2)
        print(text, end="")
    print("")
</code></pre>
<p>Output:</p>
<pre><code>cat      , 123      , yellow   
dog      , 12345    , green    
horse    , 123456   , red      
</code></pre>
<p>The format string <code>"{:&lt;{}} ".format(elem,max_len+2)</code> formats <code>element</code> rightaligned into <code>max_len+2</code> characters. The <code>first</code> thing is just to make your <code>,</code> not appear on the start of the line.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this:</p>
<pre><code>a = [['cat', 123, 'yellow'], ['dog', 12345, 'green'], ['horse', 123456, 'red']]

# Get the max length of string in the list
m = max([len(str(x)) for y in a for x in y])

# Use the format specifier in Python print function:
# Example: print '{:10s} {:3d}  {:7.2f}'.format('xxx', 123, 98)
# This prints : xxx        123    98.00
# We will create the string as {:6s}, here 6 is the length in our case and will be generated dynamically using 'm'

list(map(lambda x: print('\t'.join(list(map(lambda y:   str('{' + ':{m}s'.format(m=m) +'}').format(str(y)), x)))), a))
</code></pre>
<p>Output:</p>
<pre><code>cat     123     yellow
dog     12345   green 
horse   123456  red
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this:</p>
<pre><code>spacing = [max(map(lambda x: len(str(x)), d)) for d in zip(*data)]
for row in data:
    for i, elem in enumerate(row):
        e = str(elem) + (',' if i &lt; len(row) -1 else '')
        print('{{:{}}} '.format(spacing[i]+1).format(e), end='')
    print()
</code></pre>
<h1>Results:</h1>
<pre><code>cat,      123,      orange  
elephant, 500000,   green   
horse,    123456.0, red  
</code></pre>
<h1>Explanations:</h1>
<p><code>spacing</code> is defined by first gathering the maximum lengths of each "column" in your data.  We can group the columns by using:</p>
<pre><code>zip(*data)
</code></pre>
<p>Which gives a transposed copy of your data like this:</p>
<pre><code>('cat', 'elephant', 'horse'), 
(123, 500000, 123456.0), 
('orange', 'green', 'red')
</code></pre>
<p>Then we use the <code>map</code> function to apply the <code>len(str(x))</code> function over these columns:</p>
<pre><code>(3, 8, 5),
(3, 6, 8), 
(6, 5, 3)
</code></pre>
<p>Then we just get the <code>max</code> of each column, combine everything in a list comprehension and return it as <code>spacing</code>:</p>
<pre><code>spacing = [max(map(lambda x: len(str(x)), d)) for d in zip(*data)]
</code></pre>
<p>Then, while we loop through your data, we want to also <code>enumerate(row)</code> so we know which "column" we're working with.  <code>i</code> will give you the index of the column in addition to the actual <code>elem</code>.</p>
<p>After that, we assign a temporary <code>str</code> to append the comma if it's not the last element:</p>
<pre><code>e = str(elem) + (',' if i &lt; len(row) -1 else '')
</code></pre>
<p>This makes it a bit more readable then adding it as part of the format params.</p>
<p>Afterwards we use string formatting (or <code>e.ljust(spacing[i] + 1)</code> if you wish) to add the predefined maximum <code>spacing</code> based on the column.  Note we format the string twice by first escaping the outer curly brackets (<code>{{</code> and <code>}}</code>), so it can be in sequence:</p>
<pre><code>'{{:{}}}.format(9).format(e)
# becomes
'{:9}'.format(e)
# becomes
'cat,     '
</code></pre>
<p>Note the use of <code>end=''</code> to make the print line continuous until the <code>row</code> has finished.  The <code>spacing[i] + 1</code> is to account for the added comma.</p>
<p>I must confess this might not be the most efficient way, but depending on what you're trying to achieve the solution can be markedly different.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way, given the nested list:</p>
<pre><code>table = [['cat', 123, 'yellow'],
          ['dog', 12345, 'green'],
          ['horse', 123456, 'red']]
</code></pre>
<p>Using string methods:</p>
<pre><code>for line in table:
  print("|", end='')
  for word in line:
    print (f" {word}".ljust(10) + "|", end='')
  print()
</code></pre>
<p>To get:</p>
<pre><code>| cat      | 123      | yellow   |
| dog      | 12345    | green    |
| horse    | 123456   | red      |
</code></pre>
</div>
<span class="comment-copy">hi, thanks for replying...this has been the closest answer to what I need so far...the print representation of my dataframe is being abbreviated both width and height wise, represented by '...' on the screen...is there are a dataframe option to print the entire table do you know?</span>
<span class="comment-copy">@gdogg371 See if this helps. <code>with pd.option_context('display.max_rows', None, 'display.max_columns', None):     print(df)</code></span>
<span class="comment-copy">yes that did it, thanks...i was using the options, but not as part of a with clause. the annoying/disappointing this is that could cannot left justify the column data from what i can see in the documentation, but otherwise this has been the best and easiest answer to implement.</span>
<span class="comment-copy">Maybe <code>",\t"</code> to get the comma.</span>
<span class="comment-copy">You have a nice chance to use <code>map()</code> here: <code>print("\t".join(map(str, sub_list)))</code></span>
<span class="comment-copy">OMG this is so convoluted. Try this: <code>print('\n'.join('\t'.join('{:{width}}'.format(y, width=m) for y in x) for x in a))</code></span>
<span class="comment-copy">This works as well. Nice one!</span>
