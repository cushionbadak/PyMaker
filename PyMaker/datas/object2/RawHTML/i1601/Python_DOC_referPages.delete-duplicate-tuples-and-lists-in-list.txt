<div class="post-text" itemprop="text">
<p>I have a list of tuples and lists in python:</p>
<pre><code>gammagammalambda = [[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]], [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]], [[('r', 'u'), ('p', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]], [[('r', 'w'), ('p', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]
</code></pre>
<p>Where</p>
<pre><code>[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]]
</code></pre>
<p>is the same as</p>
<pre><code>[[('r', 'w'), ('p', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]
</code></pre>
<p>So now, I want to remove these double elements, in order to have  </p>
<pre><code>[[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]], [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]
</code></pre>
<p>For that, I want to use List comprehension and I've tried with</p>
<pre><code>main_set = set(tuple(frozenset(innermost_list) for innermost_list in sublist) for sublist in gammagammalambda)
</code></pre>
<p>But I get the error:</p>
<pre><code>TypeError: unhashable type: 'list'
</code></pre>
<p>Hope, you can help me.</p>
</div>
<div class="post-text" itemprop="text">
<p>One alternative is the following:</p>
<pre><code>gammagammalambda = [[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]],
                    [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]],
                    [[('r', 'u'), ('p', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]],
                    [[('r', 'w'), ('p', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]

d = {frozenset(e[0]) : e for e in reversed(gammagammalambda)}
result = list(d.values())

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]], [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]
</code></pre>
<p>Create a dictionary where the keys represent the values that must be unique, for each key set as value the entire element of <code>gammagammalambda</code>, finally the unique values are the values of the dictionary <code>d</code>.</p>
<p>Or a more <em>straightforward</em> alternative:</p>
<pre><code>gammagammalambda = [[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]],
                    [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]],
                    [[('r', 'u'), ('p', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]],
                    [[('r', 'w'), ('p', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]


seen = set()
result = []
for e in gammagammalambda:
    key = frozenset(e[0])
    if key not in seen:
        result.append(e)
        seen.add(key)

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]], [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar to <a href="https://stackoverflow.com/a/53373141/9209546">this answer</a>, <code>list</code> is not hashable, <code>tuple</code> and <code>frozenset</code> <em>are</em> hashable.</p>
<p>You can accordingly define a "uniqueness key", and use the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>unique_everseen</code> recipe</a>, also available in 3rd party libraries as <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="nofollow noreferrer"><code>toolz.unique</code></a> or <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="nofollow noreferrer"><code>more_itertools.unique_everseen</code></a>:</p>
<pre><code>from more_itertools import unique_everseen

L = [[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]],
     [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]],
     [[('r', 'u'), ('p', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]],
     [[('r', 'w'), ('p', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]

def unique_everseen(x):
    return frozenset(x[0]), tuple(map(tuple, x[1][0]))

res = list(unique(L, key=unique_key))
</code></pre>
<pre>
[[[('p', 'u'), ('r', 'w')], [[[], ['q', 's'], ['t', 'v'], []]]],
 [[('p', 'w'), ('r', 'u')], [[[], ['q', 's'], ['t', 'v'], []]]]]
</pre>
</div>
<span class="comment-copy">How did you even end up with such a nested list structure?</span>
<span class="comment-copy">By using list.pop ;)</span>
<span class="comment-copy">Cool thank you very much. So where did you lern this stuff?</span>
<span class="comment-copy">@Armani42 Most of that stuff I learned from the questions and answers here on stackoverflow. Also many PyCon talks and tutorials can be helpful.</span>
<span class="comment-copy">It seems the assumption is the <code>['q', 's'], ['t' ,'v']</code> bits need <i>not</i> be the same to ensure uniqueness. I'm not sure if this is the case, it could be the input data is not representative.</span>
<span class="comment-copy">The thing is, I get these object by using a self written class. If you want to, I can send you the piece of the code somehow.</span>
