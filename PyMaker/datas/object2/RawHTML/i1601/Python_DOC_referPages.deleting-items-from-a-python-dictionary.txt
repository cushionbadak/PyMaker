<div class="post-text" itemprop="text">
<p>I'm trying to use a spam classification application in Python but i'm getting the errors below. I don't understand it though since i'm using the .keys method to delete items from the dictionary so that shouldn't be a problem?
I've tried removing all the functionars bar the dictionary function to try and find a cause but I can't seem to wrap my head around this</p>
<p>Python code</p>
<pre><code>    import os
    import numpy as np
    from collections import Counter
    from sklearn.naive_bayes import MultinomialNB
    from sklearn.svm import LinearSVC
    from sklearn.metrics import confusion_matrix

    def make_Dictionary(train_dir):
        emails = [os.path.join(train_dir,f) for f in os.listdir(train_dir)]    
        all_words = []       
        for mail in emails:    
            with open(mail) as m:
                for i,line in enumerate(m):
                    if i == 2:
                        words = line.split()
                        all_words += words

        dictionary = Counter(all_words)

        list_to_remove = dictionary.keys()
        for item in list_to_remove:
            if item.isalpha() == False: 
                del dictionary[item]
            elif len(item) == 1:
                del dictionary[item]
        dictionary = dictionary.most_common(3000)
        return dictionary

    def extract_features(mail_dir): 
        files = [os.path.join(mail_dir,fi) for fi in os.listdir(mail_dir)]
        features_matrix = np.zeros((len(files),3000))
        docID = 0;
        for fil in files:
          with open(fil) as fi:
            for i,line in enumerate(fi):
              if i == 2:
                words = line.split()
                for word in words:
                  wordID = 0
                  for i,d in enumerate(dictionary):
                    if d[0] == word:
                      wordID = i
                      features_matrix[docID,wordID] = words.count(word)
            docID = docID + 1     
        return features_matrix

    # Create a dictionary of words with its frequency

    train_dir = r'.\train-mails'
    dictionary = make_Dictionary(train_dir)

    # Prepare feature vectors per training mail and its labels

    train_labels = np.zeros(702)
    train_labels[351:701] = 1
    train_matrix = extract_features(train_dir)

    # Training SVM and Naive bayes classifier and its variants

    model1 = LinearSVC()


    model1.fit(train_matrix,train_labels)


    # Test the unseen mails for Spam

    test_dir = r'.\test-mails'
    test_matrix = extract_features(test_dir)
    test_labels = np.zeros(260)
    test_labels[130:260] = 1

    result1 = model1.predict(test_matrix)


    print (confusion_matrix(test_labels,result1))
    print (confusion_matrix(test_labels,result2))
</code></pre>
<p>Error</p>
<pre><code>RuntimeError: dictionary changed size during iteration
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't work in Python 3.x because <code>keys</code> returns an iterator instead of a list.</p>
<p>Another way is to use list to force a copy of the keys to be made. This one also works in Python 3.x:</p>
<pre><code>for i in list(list_to_remove):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dictionary.keys()</code> is actually returning a reference to the original dictionary keys.</p>
<p>You can check this by doing the following:</p>
<pre><code> a_dict = {'a': 1}
 keys = a_dict.keys() # keys is dict_keys(['a'])
 a_dict['b'] = 2 # keys is dict_keys(['a', 'b'])
</code></pre>
<p>That's why you are getting the error: with <code>del dictionary[item]</code> you are actually affecting <code>list_to_remove</code>, which is forbidden during a loop.</p>
<p>You can avoid this by creating a copy of the original keys before looping through them. The easiest way to achieve this is using the <code>list</code> constructor. So changing your line</p>
<pre><code>list_to_remove = dictionary.keys()
</code></pre>
<p>with:</p>
<pre><code>list_to_remove = list(dictionary.keys())
</code></pre>
<p>solves the issue.</p>
<p><strong>Edition after comment</strong></p>
<p>Note that this behaviour only happens in <code>python 3</code>, in <code>python 2</code>, the <code>.keys()</code> method returned a normal list, with no reference to the dictionary:</p>
<pre><code>a_dict = {'a': 1}
keys = a_dict.keys() # keys is ['a']
a_dict['b'] = 2 # keys is still ['a']
</code></pre>
<p>About this on the Python 3.0 <a href="https://docs.python.org/3.0/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="nofollow noreferrer">changelog</a>:</p>
<blockquote>
<p>Some well-known APIs no longer return lists:</p>
<ul>
<li>dict methods dict.keys(), dict.items() and dict.values() return “views” instead of lists. </li>
</ul>
</blockquote>
</div>
<span class="comment-copy">thankyou for the answer! that seems to solve it. Any reason why the whole thing just crashes, aka not working. It comes straight from a github page that should work.</span>
<span class="comment-copy">Oh, yes! I forgot that. You are using <code>python 3</code>, which returns this reference <code>dict_keys</code> and the code you copied is <code>python 2</code>, where the <code>keys()</code> method returned a list. I'll add it to my answer now.</span>
<span class="comment-copy">awesome, that makes sense. Apart from rolling back to python 2 what would you suggest?</span>
<span class="comment-copy">This is one of the largest changes from python 2 to 3 and if it's not too much code it may work directly or with some <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">fixes</a>. On the other hand, typically both <code>python3</code> and <code>python2.7</code> can coexist in a linux environment, so you can try to run this code with <code>python2.7</code> instead of <code>python</code> which is the default. If <code>python2.7</code> is not present probably you could install it on the side of python 3. I mean, there is no need to "rollback".</span>
