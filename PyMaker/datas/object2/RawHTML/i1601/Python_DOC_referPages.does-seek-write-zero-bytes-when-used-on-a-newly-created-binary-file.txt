<div class="post-text" itemprop="text">
<p>I noticed, that when I do something like this:</p>
<pre><code>with open('testfile', 'wb') as fl:
    fl.seek(2048*512)
    fl.write(b'aaaaa')
</code></pre>
<p>Regardless of my python version, the hexdump of the resulting file will have zero bytes in the first portion of the <code>testfile</code>:</p>
<pre class="lang-none prettyprint-override"><code>$ hexdump -C testfile
00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00100000  61 61 61 61 61                                    |aaaaa|
00100005
</code></pre>
<p>Is that guaranteed, intended behavior that can be counted on across operating systems? If so, where is that fact documented?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is [zeroed out areas] intended behavior that can be counted on across operating systems? If so, where is that fact documented?</p>
</blockquote>
<p><em>Across</em> operating systems?  Probably not: if Python is ported to some ancient OSes, those writes might either not produce a gap at all (ignoring the seek), or fail.  However, modern systems all support <a href="https://en.wikipedia.org/wiki/Sparse_file" rel="nofollow noreferrer">sparse files</a>, or at least fake them to the point of making the above work just fine and behave that way.  If someone doing such a backport cares, they could add a faking layer.</p>
<p>You're probably safe if you rely on this.  Just don't assume that the holes will stay holes: some systems may fill them in when restoring from backup or migrating files across a cluster or whatever.  If you seek a few terabytes in and write one byte, the file might take only a little space until the fill-in point, if and when it ever occurs.</p>
</div>
<div class="post-text" itemprop="text">
<p>A binary file has a pointer that indicates the file position at which the next read or write operation will take place. Position is counted in terms of bytes. Read and write operations always move the pointer so it's at the end of whatever was just read or written.</p>
<p>Seeking to a position past the end of the file results in the file size being increased as needed, with the new bytes filled with 0. In the code above, you're creating a new file and using <code>seek</code> incrementing filepointer's (In python, there are <strong>no pointers</strong>, so this is <code>stream position</code>) start position. This will add 0's.</p>
<p>In Binary files, the current <code>stream position</code> is the bytes offset from the start of the file. If you increase stream position, all previous positions will be filled with 0 in a binary file.</p>
<p>Is this across operating systems; probably YES for all latest or LTS OSes. Might not be promising in some legacy systems. </p>
<p>Stream Position Documentation -<a href="https://docs.python.org/3/library/io.html#binary-i-o" rel="nofollow noreferrer">https://docs.python.org/3/library/io.html#binary-i-o</a></p>
</div>
<span class="comment-copy">I can't find its behavior in this scenario documented anywhere, so wouldn't count on it.</span>
<span class="comment-copy">"A write operation increases the size of the file to the file pointer position plus the size of the buffer written, which results in the intervening bytes uninitialized." to quote MSDN for <code>SetFilePointer</code> (which is probably used on Windows to implement seek). <a href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfilepointer" rel="nofollow noreferrer">docs.microsoft.com/en-us/windows/desktop/api/fileapi/â€¦</a></span>
