<div class="post-text" itemprop="text">
<p>When using an <code>if/else</code> statement to verify data was found to return the proper status code, my code within the loop to parse the response becomes completely unreachable. </p>
<p><strong>The following works as intended.</strong></p>
<pre><code>class Circuit(Resource):
    def get(self, store):
        print('USAGE: Received a request at CIRCUIT for Store ' + store )
        conn = sqlite3.connect('store-db.db')
        cur = conn.cursor()
        res = cur.execute('SELECT * FROM Circuit WHERE StoreNumber like ' + store)     

        for r in res:
            column_names = ["StoreNumber", "MainLEC", "MainCircuitID","SprintNUA","LastMileCircuitID", "AnalogCarrier", "SignalingCluster"]
            data = [r[0], r[1], r[2], r[3], r[4], r[5], r[6]]            
            datadict = {column_names[itemindex]:item for itemindex, item in enumerate(data)}
            return(datadict, 200)
</code></pre>
<p><strong>200 Result:</strong></p>
<pre><code>HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 239
Access-Control-Allow-Origin: *
Server: Werkzeug/0.14.1 Python/3.7.0
Date: Thu, 15 Nov 2018 16:30:01 GMT

{
  "StoreNumber": "42",
  "MainLEC": "XO",
  "MainCircuitID": "xx/xxx/xxxxx/ /TQW /",
  "SprintNUA": "",
  "LastMileCircuitID": "xx/xxxx/xxxx//PA",
  "AnalogCarrier": "XO/BE",
  "SignalingCluster": "ipv4:xx.2.xx.x0x"
}
</code></pre>
<p><strong>404 Result (no data found but still returns 200)</strong></p>
<pre><code>HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 5
Access-Control-Allow-Origin: *
Server: Werkzeug/0.14.1 Python/3.7.0
Date: Thu, 15 Nov 2018 16:31:14 GMT

null
</code></pre>
<p>So that works, but I want to check for <code>no data found</code> so I wrote a conditional that gets the row count. Here are examples of its use.</p>
<p><strong>Code Sample</strong></p>
<pre><code>class Circuit(Resource):
    def get(self, store):
        print('USAGE: Received a request at CIRCUIT for Store ' + store )
        conn = sqlite3.connect('store-db.db')
        cur = conn.cursor()
        res = cur.execute('SELECT * FROM Circuit WHERE StoreNumber like ' + store)     

        if len(list(cur)) == 0:
            return('No data', 404)
        else:
            for r in res:
                column_names = ["StoreNumber", "MainLEC", "MainCircuitID","SprintNUA","LastMileCircuitID", "AnalogCarrier", "SignalingCluster"]
                data = [r[0], r[1], r[2], r[3], r[4], r[5], r[6]]            
                datadict = {column_names[itemindex]:item for itemindex, item in enumerate(data)}
                return(datadict, 200)
</code></pre>
<p><strong>200 Result:</strong></p>
<pre><code>HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 5
Access-Control-Allow-Origin: *
Server: Werkzeug/0.14.1 Python/3.7.0
Date: Thu, 15 Nov 2018 16:35:53 GMT

null
</code></pre>
<p>The data just comes back as <code>null</code> and after testing with prints I found that at <code>for r in res:</code> my code is becoming unreachable. I've verified all indents.</p>
<p><strong>404 Result:</strong></p>
<pre><code>HTTP/1.0 404 NOT FOUND
Content-Type: application/json
Content-Length: 10
Access-Control-Allow-Origin: *
Server: Werkzeug/0.14.1 Python/3.7.0
Date: Thu, 15 Nov 2018 16:37:17 GMT

"No data"
</code></pre>
<p>The count is <code>0</code> so we get our 404 return, so I know the count and conditional are working.</p>
<p>If I put a <code>print()</code> right after <code>else:</code> it will run, but the loop will not.</p>
</div>
<div class="post-text" itemprop="text">
<p>By calling <code>list()</code> on the cursor, you exhaust the iterator, leaving nothing else for your <code>else</code> branch to loop through. The toy code below demonstrates this, and I have made some alterations for better practice:</p>
<ol>
<li>I used the <code>with</code> <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer">context manager</a> which will handle closing the database for us even in the event of an error.</li>
<li>I've used parameterized queries to retrieve values; these will help protect against SQL Injection.</li>
<li>I've demonstrated using <code>.fetchall()</code> to retrieve results. Although iterating directly over the cursor is more efficient than generating the whole result list upfront, it allows you to iterate multiple times, in addition to assigning the results to a meaningful name.</li>
</ol>
<p>Example:</p>
<pre><code>import sqlite3

with sqlite3.connect(":memory:") as conn: # Using a context manager
    c = conn.cursor()

    c.execute("""
              CREATE TABLE IF NOT EXISTS testing(
                  some_code INTEGER,
                  data TEXT)
              """)

    c.executemany("""
                  INSERT INTO testing VALUES (?, ?)
                  """, [[1, 'hi'], [2, 'bye'], [1, 'something']])

    # Query the new database using a parameterized query
    c.execute("select * from testing where some_code = ?", (1,))

    if len(list(c)) &gt; 0: # Exhausts the iterator and then throws the result away 
        print("Printing result set 1")
        for row in c:
            print(row)
        print("End of result set 1")
        print()

    # Repeat the query
    c.execute("select * from testing where some_code = ?", (1,))
    print("Printing result set 2")
    for row in c: # iterate the cursor 
        print(row)
    print("End of result set 2")
    print()

    # And one more time but using fetchall()
    c.execute("select * from testing where some_code = ?", (1,))
    data = c.fetchall() # Exhaust the iterator but assign a list to a name
    print("Printing result set 3")
    for row in data:
        print(row)
    print("End of result set 3")
    print()

    # And we can keep on printing without re-querying
    print("Printing result set 4")
    for row in data: 
        print(row)
    print("End of result set 4")
    print()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like <code>cur</code> is an iterator, and that <code>res</code> is a reference that iterator. When you call <code>list(cur)</code> it exhausts the iterator, and then you throw that data away. Then you try to iterate through <code>res</code>, there's nothing left and so your for loop does nothing.</p>
<p>The obvious answer would be to do:</p>
<pre><code>    res = list(cur) 
    if len(res) == 0:
        return('No data', 404)
    else:
        for r in res:
            column_names = ["StoreNumber", "MainLEC", "MainCircuitID","SprintNUA","LastMileCircuitID", "AnalogCarrier", "SignalingCluster"]
            data = [r[0], r[1], r[2], r[3], r[4], r[5], r[6]]            
            datadict = {column_names[itemindex]:item for itemindex, item in enumerate(data)}
            return(datadict, 200)
</code></pre>
</div>
<span class="comment-copy">One thing that immediately stands out is that you have a <code>return</code> <i>inside</i> <code>for r in res:</code>. This will break out of the function immediately.</span>
<span class="comment-copy">Aside from that, <code>res = cur.execute('SELECT * FROM Circuit WHERE StoreNumber like ' + store)</code> will not work in SQLite because you're missing <code>%</code> on either side of the search string, not to mention the vulnerability to SQL injection from using string concatenation. I imagine, unless you pass a fully-formed and formatted string as an argument, you never get any results back. See <a href="https://stackoverflow.com/a/3105370/4799172">this</a></span>
<span class="comment-copy"><code>if len(list(cur)) == 0:</code> â†’ <code>if not res:</code></span>
<span class="comment-copy">The link I gave you shows you how to do it properly. I suggest that you get into the habit of always doing it the correct way; the amount of times where people think that string concatenation is making life easier for them, then end up dumping some abomination of escaped strings on here because it doesn't work...</span>
<span class="comment-copy">Think I've sussed it, hold on, testing</span>
<span class="comment-copy">This is the answer I implemented as its readable and straight forward. Before I accept it, though, being fundamentally inexperienced with python and sql, are there any discrepancies to be aware of with <code>fetchall()</code>?</span>
<span class="comment-copy">@CodeSpent I was rushing before the next shift came in and stole my desk :) I will clean up the code when I'm home and make a few changes for best practice</span>
<span class="comment-copy">That gives me enough terminology to head off into research, thanks. :)</span>
<span class="comment-copy">@CodeSpent there is one thing that is worth noting if you have a lot of data. The cursor is an iterator that you can iterate through <i>lazily</i> whereas <code>fetchall</code> will generate the full list up front. This is the same as <code>xrange</code> vs <code>range</code> in python 2. Basically, iterating the cursor is slightly more efficient which would make a difference if you had hundreds if thousands of rows in your results</span>
<span class="comment-copy">@CodeSpent edits made. Sorry it took longer than I hoped.</span>
<span class="comment-copy">This is a great explanation, thank you guys.</span>
<span class="comment-copy">I am trying to apply your advise here, but not really understanding the changes you've made. By making <code>res</code> <code>list(cur)</code> should I be applying my query within <code>cur</code> as <code>conn.cursor.execute('SLECT blah blah')</code>?</span>
<span class="comment-copy">Sorry, I've never used <code>sqlite</code>, I have no idea what the underlying structure is that would lead to this behavior. This converts your iterator to a list and then does stuff on that list instead.</span>
<span class="comment-copy">Ohhhhh I see. That in itself is helpful, thanks.</span>
