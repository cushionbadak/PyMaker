<div class="post-text" itemprop="text">
<p>I have this <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer"><code>subprocess.Popen()</code></a> context manager:</p>
<pre><code>with Popen(
    args=command, shell=False, stdout=PIPE, bufsize=1, universal_newlines=True
) as process:

    # TIMING
    start = timer()
    lines = list(process.stdout)
    end = timer()
    print('Time taken:', end - start) # 53.662078000000065 seconds -&gt; Linux

    for _ in tqdm(iterable=lines, total=len(lines)):
        sleep(0.1)

if process.returncode != 0:
    raise CalledProcessError(returncode=process.returncode, cmd=process.args)
</code></pre>
<p>And it seems to take 53 seconds to process <code>list(process.stdout)</code> when running in a WSL Linux enviorment. However, when I run it in a Windows enviorment, it only takes 0.6 seconds. I'm finding it strange to see why the timings are so different. </p>
<p>I've tried using <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run()</code></a> and <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>subprocess.check_output()</code></a> instead, but they still lead to the same long lag before processing the <code>tqdm()</code> loop. </p>
<p>Am I missing something here? I've tried looking at the docs to see what are the differences using <code>subprocess.Popen()</code> in a Windows vs WSL Linux enviorment, but I'm still unsure what the issue is. Perhaps <code>list(process.stdout)</code> is unnecessary here, and there is a better way to store the lines from stdout.</p>
<p>Any sort of guidance would be very helpful here. </p>
</div>
<div class="post-text" itemprop="text">
<p>Windows Subsystem for Linux is a bit rubbish. It's got many, many bugs and it's significantly slower than it needs to be. This is just another bug manifesting itself. Here are some possible bottlenecks:</p>
<ul>
<li>Slow context switching in WSL.</li>
<li>WSL not noticing that an entire process waiting for a pipe means that the other end of the pipe should be run now.</li>
<li>The child process being executed lazily.</li>
<li>Windows taking a while to figure out that it needs to use <code>wsl.exe</code> to launch the program (thanks RoadRunner!)</li>
<li>The usual overhead of Windows, plus the usual (comparatively small) overhead of Linux.</li>
<li>A poor choice of Ubuntu distro causing many unnecessary services to be running in <code>systemd</code>(?)</li>
<li>Windows deciding to run other stuff before the child process for some unknown reason.</li>
<li><del>Deliberate malice on the part of the Windows Subsystem for Linux developers, conspiring to "prove" that Windows is the superior operating system by setting up a strawman.</del> Too silly.</li>
</ul>
<p>There's nothing wrong with your Python code that would make this slow.</p>
</div>
<span class="comment-copy">WSL will be slower than running Ubuntu natively. Also, have you tried timing the time for the <code>with</code> line to execute? It's possible that Windows will be partially ignoring the <code>bufsize</code> parameter or something, or maybe that it gives newly-started processes much more time to execute before going back to the parent than WSL does... If the <code>with</code> line makes up for about half of the discrepancy, could you let me know so I can write up an answer?</span>
<span class="comment-copy">@wizzwizz4 The <code>with</code> line by itself is only 0.0077 seconds. The major holdup exists in <code>lines = list(process.stdout)</code>, this continuesly gives me around the 50 - 60 second range to compute. I would need to test this code in actual Linux to be sure, it's probably just a WSL bug. It also seems that the parent process takes alot more time than any child processes. Anyways, It would be great if you could make an answer.</span>
<span class="comment-copy">@wizzwizz4 If you put <code>wsl.exe</code> in front of <code>command</code>, this speeds it up to 6 seconds. I'm confused.</span>
<span class="comment-copy">Yeah these are good points. I've tested this on my ubuntu partition and it's fine. I guess WSL has a lot of work to do before it can be decent. This will be helpful for future readers, so they don't waste their time wondering why their subprocesses take forever to finish.</span>
