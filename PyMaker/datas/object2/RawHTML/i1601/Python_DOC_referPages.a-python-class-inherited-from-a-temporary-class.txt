<div class="post-text" itemprop="text">
<p>I got stuck when I try to figure out the following <code>codes</code>:</p>
<pre><code>def with_metaclass(meta, base=object):
    print("[2]")
    return meta("NewBase", (base,), {})

class BaseForm(object):
    def __init__(self, fields, prefix=''):
       print(self.__class__)

    def say(self):
        print("BaseForm")


class FormMeta(type):
    def __init__(cls, name, bases, attrs):
        print("[3]: {!r}, {!r}, {!r}, {!r}, {!r}".format(cls, name, type(cls), bases, attrs))
        type.__init__(cls, name, bases, attrs)

    def __call__(cls, *args, **kwargs):
        print("[4]: {!r}, {!r}".format(cls, type(cls)))
        return type.__call__(cls, *args, **kwargs)

print("[1]")
class Form(with_metaclass(FormMeta, BaseForm)):
    print("[5]")
    def __init__(self):
        NewBase.__init__(self)
        print("[6]: {!r}, {!r}".format(self, type(self)))


# confused position
print(Form.__bases__)

# Form is based on NewBase, however, there is no NewBase
print(dir())
</code></pre>
<p>here is the code output:</p>
<pre><code>[1]
[2]
[3]: &lt;class '__main__.NewBase'&gt;, 'NewBase', &lt;class '__main__.FormMeta'&gt;, (&lt;class '__main__.BaseForm'&gt;,), {}
[5]
[3]: &lt;class '__main__.Form'&gt;, 'Form', &lt;class '__main__.FormMeta'&gt;, (&lt;class '__main__.NewBase'&gt;,), {'__module__': '__main__', '__qualname__': 'Form', '__init__': &lt;function Form.__init__ at 0x7f6ad4d76f28&gt;}
(&lt;class '__main__.NewBase'&gt;,)
['BaseForm', 'Form', 'FormMeta', '__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'with_metaclass']
</code></pre>
<p>Just like what I commented out, <code>Form</code> is base on <code>NewBase</code>, however, there is not a <code>NewBase</code> class in the main module. A class its base class is not accessible, is an error? But interesting, <code>Form</code> can still call the method, which comes from the parent of its parent. </p>
</div>
<div class="post-text" itemprop="text">
<p>For the sake of the answer, we don't need the FormMeta class at first.
Imagine the definition of Form as follows:</p>
<pre><code>class Form(with_metaclass(meta=type, base=BaseForm)):
    # ...
</code></pre>
<p>the <code>with_metaclass</code> call just returns <code>meta("NewBase", (base,), {})</code>, which in this case is just <code>type("NewBase", (base,), {})</code>, which creates a new class called <code>NewBase</code>, which is derived from <code>base</code> (<code>BaseForm</code> in this case), with no additional methods.
You can read about it at the <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer">type documentation</a>.</p>
<p>The <code>FormMeta</code> metaclass in this case does  nothing. It inherits <code>type</code> (that's why it is a meta class), and then just passes the data it receives on to <code>type</code>, plus some print statements. So it is essentially the same as above.
You can read more about metaclasses <a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python?rq=1">here</a>.</p>
</div>
<span class="comment-copy">Maybe I did not make it clear,  my question is that <code>Form</code> class based on <code>NewBase</code> class, but <code>NewBase</code> class is not in the module namespace, i.e <code>dir()</code>. So, the parent of <code>Form</code> class cannot be accessed. But the instance of  <code>Form</code> can access the method of <code>BaseForm</code> (the parent class of <code>NewBase</code>).</span>
<span class="comment-copy">If you want it in the global name space, just use <code>NewForm = with_metaclass(FormMeta)</code>, and then <code>class Form(NewForm)</code>. Or just use <code>super():__init__</code> instead of <code>NewForm.__init__</code>. If that is not what you mean, I don't understand your problem</span>
