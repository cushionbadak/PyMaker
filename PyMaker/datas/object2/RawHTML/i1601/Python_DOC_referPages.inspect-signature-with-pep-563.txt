<div class="post-text" itemprop="text">
<p>The following code:</p>
<pre><code>import inspect
from typing import NamedTuple

class Example(NamedTuple):
    a: str

if __name__== "__main__":
    signature: inspect.Signature = inspect.signature(Example)
    print(signature)
</code></pre>
<p>outputs:</p>
<pre><code>(a: str)
</code></pre>
<p>However when enabling <a href="https://www.python.org/dev/peps/pep-0563/" rel="nofollow noreferrer">PEP 563 â€“ Postponed Evaluation of Annotations</a>:</p>
<pre><code>from __future__ import annotations
import inspect
from typing import NamedTuple

class Example(NamedTuple):
    a: str

if __name__== "__main__":
    signature: inspect.Signature = inspect.signature(Example)
    print(signature)
</code></pre>
<p>The output is:</p>
<pre><code>(a: 'str')
</code></pre>
<p>How can I get the exact same object of type <code>inspect.Signature</code> with PEP 563 like without it?</p>
</div>
<div class="post-text" itemprop="text">
<p>The point of using PEP 536 is to <em>not</em> evaluate the annotations unless needed. The signature merely reports on the annotations.</p>
<p>If for your purposes you need to have the annotations resolved, you have to do so yourself. PEP 536 tells <a href="https://www.python.org/dev/peps/pep-0563/#resolving-type-hints-at-runtime" rel="nofollow noreferrer">documents how you do this</a>:</p>
<blockquote>
<p>For code that uses type hints, the <code>typing.get_type_hints(obj, globalns=None, localns=None)</code> function correctly evaluates expressions back from its string form.</p>
<p>[...]</p>
<p>For code which uses annotations for other purposes, a regular eval(ann, globals, locals) call is enough to resolve the annotation.</p>
</blockquote>
<p>You could even use the <a href="https://docs.python.org/3/library/typing.html#typing.get_type_hints" rel="nofollow noreferrer"><code>typing.get_type_hints()</code> function</a> to assign back to <code>__annotations__</code> before getting the signature:</p>
<pre><code>import typing

Example.__new__.__annotations__ = typing.get_type_hints(Example.__new__)
signature: inspect.Signature = inspect.signature(Example)
</code></pre>
<p>Doing this is safe even if <code>from __future__ import annotations</code> had not been used.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, let's run a different example:</p>
<pre><code>signature: inspect.Signature = inspect.signature(Example)
print(signature)
print(Example.__annotations__)
</code></pre>
<p>This prints:</p>
<pre><code>(a: str)
OrderedDict([('a', &lt;class 'str'&gt;)])
</code></pre>
<p>So far so good, we have or <code>Signature</code> and our <code>__anotations__</code> as we expected.</p>
<p>Now let's do the same for the second example, it prints:</p>
<pre><code>(a: 'str')
OrderedDict([('a', ForwardRef('str'))])
</code></pre>
<p>So you're not getting <strong>the same</strong> <code>Signature</code> here. One gives you the actual class and the other a <code>typing.ForwardRef</code> to the class.</p>
</div>
<span class="comment-copy">The <b>whole point</b> of that PEP is to <i>not</i> get the same object... You'll have to <i>evaluate</i> the string using <code>exec</code> or the like.</span>
<span class="comment-copy">Perfect. Thanks. I'll award the bounty tomorrow, because for some reason stackoverflow does not allow me to do so right now without waiting 3 hours. :rolleyes:</span>
