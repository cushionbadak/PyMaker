<div class="post-text" itemprop="text">
<p>I created a program that spawn processes and run the provided algorithm. When I run the algorithm without multiprocessing it takes 1.7 sec, but when I spawn two processes that run the same algorithm it takes 18 sec.</p>
<p>Profiler result for one process without spawning:
<code>68050    0.084    0.000    0.084    0.000 {method 'timestamp' of 'datetime.datetime' objects}</code></p>
<p>With spawning two processes for one of spawned processes:
<code>34025   15.947    0.000   15.947    0.000 {method 'timestamp' of 'datetime.datetime' objects}</code></p>
<p>Why the date.timestamp takes 15.9 sec? Is this profiler error ?</p>
<p>Spawn:</p>
<pre><code># Start processes
for index, simulation in enumerate(self.simulations):
    proc = Process(target=simulation_runner, args=(simulation, queues[index]))
    jobs.append(proc)
    proc.start()
</code></pre>
<p>Timestamp:</p>
<pre><code>timestamp = math.floor(date.timestamp())
</code></pre>
<p>Also I wrote the program that do the same:</p>
<pre><code>import time
from multiprocessing import Pool
from datetime import datetime


def worker(file_name):
    with open(file_name, 'r+') as file:
        for line in file:
            date = datetime.now()
            date.timestamp()


if __name__ == "__main__":
    start = time.time()
    args = ['FLT-TEST', 'FLT-TEST']
    pool = Pool()
    pool.map(worker, args)
    # worker('FLT-TEST')
    print(f'Executing in {time.time() - start} s.')
</code></pre>
<p>Without spawning it prints <code>Executing in 0.16368794441223145 s.</code>
With spawning it prints <code>Executing in 66.31291604042053 s.</code>
<code>FLT-TEST</code> contains 91849 lines</p>
<p>Without file reading</p>
<pre><code>import time
from multiprocessing import Pool
from datetime import datetime


def worker(num):
    print(f'Process {num}')
    for _ in range(95000):
        date = datetime.now()
        date.timestamp()


if __name__ == "__main__":
    start = time.time()
    args = [1, 2]
    pool = Pool()
    pool.map(worker, args)
    # worker(1)
    print(f'Executing in {time.time() - start} s.')
</code></pre>
<p>I get the same results.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>timestamp = math.floor(date.replace(tzinfo=timezone.utc).timestamp())
</code></pre>
<p>Setting timezone fixed time duration. </p>
</div>
<span class="comment-copy">It's probably due to the processing involved of having the OS create and launch a separate task. <code>multiprocessing</code> can involve a lot of overhead.</span>
<span class="comment-copy">Comment: You should consider using a <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer"><code>time.perf_counter()</code></a> for timing stuff like this.</span>
