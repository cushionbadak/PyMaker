<div class="post-text" itemprop="text">
<p>How can I write a function, that would take a dictionary and return me a set that would consist of pairs of keys that have at least one common value?</p>
<p>Example:</p>
<p>I have the following dictionary:</p>
<pre><code>dict = {
'C': {'123'}, 
'A': {'123', '456'}, 
'D': {'123'}, 
'B': {'789', '456'}, 
'E': {'789'}}
</code></pre>
<p>MyFunction(dict) should return me:</p>
<pre><code>{("A", "B"), ("A", "C"), ("A", "D"), ("B", "E"), ("C", "D")}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A more efficient one-pass solution would be to use a <code>seen</code> dict that keeps track of a list of keys that have "seen" a given value so far:</p>
<pre><code>pairs = set()
seen = {}
for key, values in d.items():
    for value in values:
        if value in seen:
            for seen_key in seen[value]:
                pairs.add(frozenset((key, seen_key)))
        seen.setdefault(value, []).append(key)
</code></pre>
<p><code>pairs</code> would become:</p>
<pre><code>{frozenset({'D', 'A'}), frozenset({'B', 'E'}), frozenset({'B', 'A'}), frozenset({'C', 'D'}), frozenset({'C', 'A'})}
</code></pre>
<p>You can then easily transform it to a set of lexicographically sorted tuples if you want:</p>
<pre><code>{tuple(sorted(p)) for p in pairs}
</code></pre>
<p>which returns:</p>
<pre><code>{('A', 'C'), ('B', 'E'), ('C', 'D'), ('A', 'D'), ('A', 'B')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3.5/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">itertools.combinations</a>:</p>
<pre><code>from itertools import combinations

d = {
    'C': {'123'}, 
    'A': {'123', '456'}, 
    'D': {'123'}, 
    'B': {'789', '456'}, 
    'E': {'789'}
}

def MyFunction(d):
    out = set()
    for i, j in combinations(d, 2):
        if d[j].intersection(d[i]) and (i, j) not in out and (j, i) not in out:
            out.add((i, j))
    return set(tuple(sorted(i)) for i in out)

print(MyFunction(d))
print(MyFunction(d) == {("A", "B"), ("A", "C"), ("A", "D"), ("B", "E"), ("C", "D")})
</code></pre>
<p>Output is:</p>
<pre><code>{('A', 'D'), ('A', 'B'), ('B', 'E'), ('A', 'C'), ('C', 'D')}
True
</code></pre>
<p>If you consider <code>('A', 'C')</code> and <code>('C', 'A')</code> same, you can replace </p>
<pre><code>return set(tuple(sorted(i)) for i in out)
</code></pre>
<p>with just</p>
<pre><code>return out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3><a href="https://docs.python.org/3.6/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> + <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>combinations</code></a></h3>
<p>For a brute force solution, you can invert your dictionary of sets, then use a set comprehension:</p>
<pre><code>from collections import defaultdict
from itertools import combinations

d = {'C': {'123'}, 'A': {'123', '456'}, 
     'D': {'123'}, 'B': {'789', '456'}, 
     'E': {'789'}}

dd = defaultdict(set)

for k, v in d.items():
    for w in v:
        dd[w].add(k)

res = {frozenset(i) for v in dd.values() if len(v) &gt;= 2 for i in combinations(v, 2)}

print(res)

{frozenset({'A', 'D'}), frozenset({'C', 'D'}),
 frozenset({'B', 'E'}), frozenset({'B', 'A'}),
 frozenset({'C', 'A'})}
</code></pre>
<p>As you can see the items in <code>res</code> are <code>frozenset</code> objects, i.e. they aren't depending on sorting within tuples. <code>frozenset</code> is required instead of <code>set</code> since <code>set</code> is not hashable.</p>
</div>
<span class="comment-copy">Side note: <i>never</i> (even as an example) shadow built-ins, e.g. use <code>d</code> or <code>dct</code> or <code>dict_</code> instead of <code>dict</code>.</span>
