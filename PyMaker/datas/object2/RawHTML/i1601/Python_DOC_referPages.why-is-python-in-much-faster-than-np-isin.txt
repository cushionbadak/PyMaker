<div class="post-text" itemprop="text">
<p>I'm implementing some search algorithm using <code>numpy</code> where one step is to check weather a vector is in a matrix (as row). I used to use <code>np.isin</code> before, but I suddenly become curious will the python keyword <code>in</code> work. I therefore tested it and find it do works.</p>
<p>Since I didn't find any python interface for <code>in</code> (like <code>__add__</code> for <code>+</code> or <code>__abs__</code> for <code>abs</code>), I believe <code>in</code> is hard-wired in python by using standard iterator logic, therefore it should be slower compared to the <code>numpy</code>-provided <code>np.isin</code>. But after I did some testing, unbelievably:</p>
<pre><code>&gt;&gt;&gt; a = np.int8(1)
&gt;&gt;&gt; A = np.zeros(2**24, 'b')
&gt;&gt;&gt; %timeit a in A
&gt;&gt;&gt; %timeit np.isin(a, A)
21.7 ms ± 1.58 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
310 ms ± 20.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>which sais <code>np.isin</code> is 10+ times slower than python <code>in</code> for small data type. I also did a test for big data type</p>
<pre><code>&gt;&gt;&gt; a = np.ones(1, 'V256')
&gt;&gt;&gt; A = np.zeros(2**22, 'V256')
&gt;&gt;&gt; %timeit a in A
&gt;&gt;&gt; %timeit np.isin(a, A)
129 ms ± 12.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
10.5 s ± 184 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>which sais <code>np.isin</code> is ~100 times slower.</p>
<p>I'm wondering what could be the reason for this. Note since <code>a=1</code> while <code>A=[0,0,...]</code>, the match will have to be done on the whole array. There's no such thing as "early exit" on python side.</p>
<p><strong>EDIT</strong> Oh actually there is python interface for <code>in</code> called <code>__contains__</code>. But still why would <code>np.isin</code> be way slower than <code>np.ndarray.__contains__</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>numpy.ndarray.__contains__</code> is basically just <code>(elem == arr).any()</code> (even when that doesn't make sense). You can take a look at the <a href="https://github.com/numpy/numpy/blob/v1.15.4/numpy/core/src/multiarray/sequence.c#L28" rel="nofollow noreferrer">source</a>, which is very short and simple for a NumPy C routine.</p>
<p><code>numpy.isin</code> broadcasts over its left operand, and it's optimized for efficiency in the broadcasting case. For a small left operand, it will use <a href="https://github.com/numpy/numpy/blob/v1.15.1/numpy/lib/arraysetops.py#L525" rel="nofollow noreferrer">an approach based on sorting</a>, which is overkill for a scalar. It currently has no fast path for the left operand being a scalar, or for the left hand being an array small enough that sorting is more expensive than a naive approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>My answer is not as asked. May be give you some idea. Generally, the big idea behind getting good performance from numpy is to amortize the cost of the interpreter over many elements at a time. In other words, move the loops from python code (slow) into C/Fortran loops somewhere in the numpy/BLAS/LAPACK/etc. internals (fast). If you succeed in that operation (called vectorization) performance will usually be quite good.</p>
<p>Of course, you can obviously get even better performance by dumping the python interpreter and using, say, C++ instead. Whether this approach actually succeeds or not depends on how good you are at high performance programming with C++ vs. numpy, and what operation exactly you're trying to do.</p>
</div>
<span class="comment-copy">"I therefore tested it and find it do works." - <a href="https://stackoverflow.com/questions/18320624/how-does-contains-work-for-ndarrays">nope</a>.</span>
<span class="comment-copy">"Since I didn't find any python interface for <code>in</code>" - <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">you were probably looking in the wrong places</a>.</span>
<span class="comment-copy">@user2357112 I know it only works on scalar. You can make it work by viewing the rows as a scalar. Therefore it becomes identical to testing <code>in</code> on <code>VsomeNumber</code> data type</span>
<span class="comment-copy"><code>isin</code> is Python code which you can read.  Or read the whole <code>arraysetops.py</code>.  I think this code is written more for convenience than for performance.  Arrays aren't optimal for search tasks.</span>
<span class="comment-copy">"high performance programming" is a concept I have never heard before.</span>
<span class="comment-copy">The highers performance is machine code or assembly language (different representations of the same thing.)  You're not limited by any constraints other than the harware capabilities of the device.  (IOW, there's no "make toast" instruction.)  After that, which language has the best performance is like asking which hand tool has the best performance.  It's difficult to cut wood with a hammer or drive a nail with a saw.  Some languages have better performance doing some things, some have better performance doing other things.</span>
