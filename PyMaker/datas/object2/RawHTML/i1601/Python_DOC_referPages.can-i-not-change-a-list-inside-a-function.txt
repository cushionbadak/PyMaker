<div class="post-text" itemprop="text">
<pre><code># left rotate using slicing
def leftRotate(arr, k, n):
    arr = arr[k:] + arr[:k]
    print(arr)

arr = [1, 2, 3, 4, 5, 6, 7] 
leftRotate(arr, 2, 7) 
print(arr)
</code></pre>
<p>Result:</p>
<pre><code>[3, 4, 5, 6, 7, 1, 2]
[1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>When I print the array outside the function it is not rotated anymore and remains how it originally was. Can someone help me understand this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can change a list from within a function, but you need to use the correct syntax.  As you've seen already, this is not the correct way:</p>
<pre><code>def leftRotate(arr, k, n):
    arr = arr[k:] + arr[:k]
</code></pre>
<p>I will try to explain why this did not work, and hope to give you a better intuition about what really happens.  Inside the scope of the function shown above, there are 3 local variables: <code>arr</code>, <code>k</code>, and <code>n</code>.  The right-hand side operations <code>arr[k:] + arr[:k]</code> creates a new list object, without modifying the original list, and this resulting object is bound to the local variable name  <code>arr</code>.  This does not modify the original object, because such assignment statements in Python are <em>never</em> mutating objects. They will only bind a name in a namespace. <strong>Think of it as if you're taking the nametag "arr" off of the old list object</strong>, which was passed in as argument, <strong>and sticking it on the new list object</strong> which was just created. The old list object is not modified by such an operation, only the local namespace is modified - the old list object becomes "anonymous" and is no longer reachable in this scope.</p>
<p>The solution is to use a different kind of assignment statement, a <em>slice assignment</em>, which does mutate:</p>
<pre><code>def leftRotate(arr, k, n):
    arr[:] = arr[k:] + arr[:k]
</code></pre>
<p>As a final note, there is a list-like data structure in stdlib which provides more efficient rotation operations (at the cost of less-efficient indexing into the middle of the collection). If you're interested in this,  read the docs on the <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is list slicing is <em>not</em> being applied in place. Effectively a <em>new</em> list is created and assigned to a variable <code>arr</code> scoped to <code>leftRotate</code>, i.e. it can can be accessed within your function only. A method which does work in place <em>will</em> work as expected:</p>
<pre><code>def rev_sort(arr, k, n):
    arr.sort(reverse=True)
    print(arr)

arr = [1, 2, 3, 4, 5, 6, 7] 
rev_sort(arr, 2, 7) 

print(arr)

[7, 6, 5, 4, 3, 2, 1]
[7, 6, 5, 4, 3, 2, 1]
</code></pre>
<p>In your example, you can have your function return a list and assign it to <code>arr</code>:</p>
<pre><code>def leftRotate(arr, k, n):
    arr = arr[k:]+arr[:k]
    print(arr)
    return arr

arr = [1, 2, 3, 4, 5, 6, 7] 
arr = leftRotate(arr, 2, 7) 
print(arr)

[3, 4, 5, 6, 7, 1, 2]
[3, 4, 5, 6, 7, 1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is because you can't change a variable inside a python function because of the scope. <a href="https://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">Read this</a> for more info.</p>
<p>But resuming, you need to either return arr and assign it outside. Like this:</p>
<pre><code>#left rotate using slicing
def leftRotate(arr, k, n):
    arr=arr[k:]+arr[:k]
    return arr

arr = [1, 2, 3, 4, 5, 6, 7] 
arr = leftRotate(arr, 2, 7) 
print arr
</code></pre>
<p>Or if you would like, you could make arr a global. (Check <a href="https://stackoverflow.com/questions/423379/using-global-variables-in-a-function">this</a> for more info on that). (Don't recommend this last one, but exists)</p>
<pre><code>arr = [1, 2, 3, 4, 5, 6, 7]

#left rotate using slicing
def leftRotate( k, n):
    global arr
    arr=arr[k:]+arr[:k]

leftRotate( 2, 7) 
print arr
</code></pre>
<p>Hope it helped :)</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a lot of really complicated answers. Here's the "for dummies" version:</p>
<ul>
<li>You are passing <code>arr</code> into <code>leftRotate()</code></li>
<li>For nearly all purposes, you can think of this as creating <em>another variable</em>, also called <code>arr</code> which <code>leftRotate()</code> works on. <code>leftRotate()</code>'s <code>arr</code> is <strong>not the same</strong> as the <code>arr</code> you are passing in to <code>leftRotate()</code>. It <strong>is a copy</strong> (technically it's not a copy until you assign <code>arr</code> to something else, but close enough for these purposes).</li>
<li>You're not getting your modified <code>arr</code> back out of <code>leftRotate()</code> again.</li>
</ul>
<p>You can solve this in two ways:</p>
<ul>
<li>Define <code>arr</code> outside of <code>leftRotate()</code>, and don't pass <code>arr</code> in. I'll call this the "<code>global</code>" approach. Not recommended unless you have a <em>very</em> good reason.</li>
<li>Use <code>return arr</code> after your function completes. Essentially, <code>return 'x'</code> means <code>leftRotate() == 'x'</code>. In 99.99999% of cases, this is what you want.</li>
</ul>
<p>Therefore, in your example, what you really want is this:</p>
<pre><code>#left rotate using slicing
def leftRotate(arr, k, n):
    arr=arr[k:]+arr[:k] # not sure this is right, but once you get the return working, it should be easy to debug
    # print arr # changed
    return arr

arr = [1, 2, 3, 4, 5, 6, 7] 
# leftRotate(arr, 2, 7) # changed
arr = leftRotate(arr, 2, 7) 
print arr
</code></pre>
</div>
<span class="comment-copy">yes you can, but you aren't modifying the list in your function, you simply assign to a local variable <code>arr</code> and then the function terminates</span>
<span class="comment-copy">Thats is very helpful. Thank you</span>
<span class="comment-copy">Slice assignment will modify <code>arr</code> in place, without requiring the return+assignment.</span>
<span class="comment-copy">@PaulMcG, Indeed, that's true. As per wim's solution (which is a great alternative if OP doesn't want to return <code>arr</code>).</span>
<span class="comment-copy">That's helpful. Thank you for explaining.</span>
<span class="comment-copy">Helpful. Thank you!</span>
<span class="comment-copy">Are you sure that passing <code>arr</code> into <code>leftRotate</code> creates a copy?</span>
<span class="comment-copy">Your assumption that <code>arr</code> passed to the function is a copy is incorrect. The part that fails is that assignment to <code>arr</code> inside the function just assigns to a new, local name, not affecting the original <code>arr</code>. It <i>is</i> possible to update the original passed-in <code>arr</code> by using slice assignment, as shown in @wim 's answer.</span>
<span class="comment-copy">I said it was the &amp;quot;for dummies&amp;quot; version. That means it's meant to be more easily understandable, if not precisely correct. We're not all professional coders (and OP prob isn't). I can tell you it's not a pointer/assignment. "Copy" to most people is the same as "local variable outside of scope" or whatever.</span>
