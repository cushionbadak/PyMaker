<div class="post-text" itemprop="text">
<p><strong>Background</strong></p>
<p>Let there be a set of integers </p>
<pre><code>trialinteg = [231,355,112,1432,2434,5235,7896,7776,27421,42342]
</code></pre>
<p>Then it is possible to classify them into different equivalence classes modulo 6  </p>
<p><strong>Problem</strong></p>
<p>Could we create an algorithm to classify all these integers into their respective equivalence class and store the results in a dictionary in python? </p>
<p>For example </p>
<pre><code>d = {"class0": [112,1432,..], "class1": [231,...], ...}
</code></pre>
<p>More importantly, can we make d changes its size and names of the keys as the integer by which we define equivalence class (in this example, 6) changes? </p>
<p><strong>Progress</strong></p>
<p>It is possible to store all integers of equivalence class 0 modulo 6 in a list. But it is not clear how one can create a 'dynamic' dictionary that adjusts its size and names of the key when the integer in question changes (for example from 6 to 121). </p>
<pre><code>moduloclasszero=[]
for num in trialinteg:
    while num % 6 != 0:

        print(f"{num} is not of class 0")
        print(f"But {num} is of class {num % 6}")
        print("now proceed to restore it to 0")

        num = num + (6-(num % 6))
    else: 
        print(f"{num} is of class 0")
        moduloclasszero.append(num)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict

trialinteg = [231,355,112,1432,2434,5235,7896,7776,27421,42342]

d = defaultdict(list)

for x in trialinteg:
    d[f'class{x % 6}'].append(x)

print(d)
# defaultdict(&lt;class 'list'&gt;, {'class3': [231, 5235], 'class1': [355, 27421], 'class4': [112, 1432, 2434], 'class0': [7896, 7776, 42342]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the class value itself for your dictionary key.</p>
<pre><code>my_mod = 6
for num in trialinteg:
    d[num % my_mod].append(num)
</code></pre>
<p>I'll assume that you can already handle initializing the dict; if not, look at supporting questions on this site.</p>
<p>A dict comprehension can do this in a single assignment statement:</p>
<pre><code>trial = [231,355,112,1432,2434,5235,7896,7776,27421,42342]
d = {equi: [i for i in trial if i%my_mod == equi] 
     for equi in range(my_mod)}
</code></pre>
<p>Resulting value of d:</p>
<pre><code>{0: [7896, 7776, 42342],
 1: [355, 27421],
 2: [],
 3: [231, 5235],
 4: [112, 1432, 2434],
 5: [] }
</code></pre>
</div>
