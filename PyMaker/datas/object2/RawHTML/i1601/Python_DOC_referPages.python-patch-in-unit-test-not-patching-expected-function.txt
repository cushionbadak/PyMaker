<div class="post-text" itemprop="text">
<p>I've created a simplified project directory with the following structure:</p>
<pre><code>.
├── communications
│   ├── __init__.py
│   └── push.py
├── venmo
│   ├── __init__.py
│   └── communication
│       ├── __init__.py
│       └── services
│           ├── __init__.py
│           └── notification_service.py
└── venmo_tests
    ├── __init__.py
    └── communication
        ├── __init__.py
        └── services
            ├── __init__.py
            └── test_notification_service.py
</code></pre>
<p>where the <code>__init__.py</code> files are all empty. Basically, the <code>venmo_tests</code> directory follows the 'structure' of <code>venmo</code>.</p>
<p>The <code>communications/push.py</code> module contains</p>
<pre><code>def send_push_to_user(message):
    print(message)
</code></pre>
<p>The <code>send_push_to_user()</code> is, in turn, invoked in the <code>notify_user()</code> function in <code>venmo/communication/services/notification_service.py</code>:</p>
<pre><code>from communications.push import send_push_to_user


def notify_user(message, push=False):
    if push:
        send_push_to_user(message=message)
</code></pre>
<p>I am trying to test this with the following unit test in <code>venmo_tests/communication/services/test_notification_service.py</code>:</p>
<pre><code>import unittest
from mock import patch

from venmo.communication.services import notification_service


class TestNotifyUser(unittest.TestCase):
    @patch('communications.push.send_push_to_user')
    def test_custom_push_message(self, push_mock):
        notification_service.notify_user(
            message='Hello, world!',
            push=True)

        push_mock.assert_called()
</code></pre>
<p>However, if I run this test from the command line, I get an error because the patch was not called:</p>
<pre><code>$ python -m unittest venmo_tests.communication.services.test_notification_service
Hello, world!
F
======================================================================
FAIL: test_custom_push_message (venmo_tests.communication.services.test_notification_service.TestNotifyUser)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/kupeek/Documents/Scratch/venv/lib/python2.7/site-packages/mock/mock.py", line 1305, in patched
    return func(*args, **keywargs)
  File "venmo_tests/communication/services/test_notification_service.py", line 14, in test_custom_push_message
    push_mock.assert_called()
  File "/Users/kupeek/Documents/Scratch/venv/lib/python2.7/site-packages/mock/mock.py", line 906, in assert_called
    raise AssertionError(msg)
AssertionError: Expected 'send_push_to_user' to have been called.

----------------------------------------------------------------------
Ran 1 test in 0.002s

FAILED (failures=1)
</code></pre>
<p>Although I'm using Python 2.7 in which <code>mock</code> is a separate package, as far as I can tell from the current documentation (<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch</a>), this should be the correct way to use the <code>patch()</code> decorator.</p>
<p>Any ideas what is wrong with this example?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Any ideas what is wrong with this example?</p>
</blockquote>
<p>Hum...</p>
<p>a) Why do you duplicate the folder structure. You've made a package, just put a <code>tests</code> sub-package in it, then in your tests import the relevant parts of the outer package to exercise in tests, patch what you want, and that's it.</p>
<p>b) Having <code>communications</code> and <code>communication</code> names is asking for trouble.</p>
<p>c) Other modules (and yet using other modules) don't see the patch you've made in your module. You are patching a string that your module doesn't use.</p>
</div>
