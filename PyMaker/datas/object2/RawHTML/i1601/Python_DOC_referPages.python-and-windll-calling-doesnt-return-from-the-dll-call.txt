<div class="post-text" itemprop="text">
<p>My DLL has the following function:</p>
<pre><code>extern "C" __declspec(dllexport) bool __cdecl  PcapOpen(unsigned long inSize, void * inData, unsigned long *outSize, void * outData, Function_Modes eMode)
</code></pre>
<p>The function will write data out through <strong>outSize</strong> and <strong>outData</strong> (meaning these need to be passed to the function with the expectation that my function inside the DLL will modify them)</p>
<p>In addition, <strong>Function_Modes</strong> is:</p>
<pre><code>typedef enum Function_Modes { Mode_Unknown = -1, Mode_Preview = 0, Mode_Execute = 1, Mode_Query } Function_Modes;
</code></pre>
<p>For reference in Perl I referenced the function like so:</p>
<pre><code>my %Data;
$Data{Interface} = $interface;
my ($inData, $inSize) = buildData(\%Data);
$$outSize = pack("L", 65536);

$outData = "\x00"x65536;

my $pPcapOpen = Win32::API-&gt;new($dllName, "PcapOpen", "NPPPI", "I", "_cdecl");
my $return = $pPcapOpen-&gt;Call($inSize, $inData, $$outSize, $outData, $eMode);
</code></pre>
<p>I created a small Python code that should run the function and show the data it returns, but the call while "appears to access the DLL", does not return (the python code just after the call is never called)</p>
<pre><code>pPcapDLL = ctypes.WinDLL("Pcap Interface.dll")

LP_c_char = ctypes.POINTER(ctypes.create_string_buffer(65536).__class__)                                                                                                  
obuf = ctypes.create_string_buffer(65536)
obuflen = ctypes.c_ulong(65536)
optr = LP_c_char(obuf)

PcapOpen = pPcapDLL["PcapOpen"]
PcapOpen.restype = ctypes.c_bool
PcapOpen.argtypes = [ctypes.c_ulong, ctypes.c_void_p, ctypes.POINTER(LP_c_char), ctypes.POINTER(ctypes.c_size_t), ctypes.c_int]

outSize = ctypes.c_ulong(65536)

LP_c_char = ctypes.POINTER(ctypes.create_string_buffer(65536).__class__)                                                                                                  
outData = ctypes.create_string_buffer(65536)
outData_ptr = LP_c_char(outData)

print("Calling PcapClose")
returnValue = PcapClose(inSize, inData, ctypes.byref(outSize), ctypes.byref(outData_ptr), eMode)

print("returnValue: {}".format(returnValue)) # &lt;-- This doesn't get called
</code></pre>
<p>There appears to be very little documentation on how to handle DLL functions that return data - just that byref should be used, but its not 100% clear how to allocate the data for these function to use them - so that could be my issue</p>
<p>Thank you for assisting.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I see it there are two changes you need to make:</p>
<ol>
<li><p>The C function you are attempting to call uses the <code>cdecl</code> calling convention, so you must access the DLL using <code>ctypes.cdll</code>, not <code>ctypes.windll</code>.   <code>ctypes.windll</code> is used for the <code>stdcall</code> calling convention.  See also the <a href="https://docs.python.org/3/library/ctypes.html#loading-dynamic-link-libraries" rel="nofollow noreferrer">Python <code>ctypes</code> documentation</a>.</p></li>
<li><p>The fourth argument to your function is a pointer, but you appear to be passing it a pointer to a pointer.  Try replacing <code>ctypes.byref(outdata_ptr)</code> with <code>ctypes.byref(outdata)</code>.</p></li>
</ol>
</div>
<span class="comment-copy">A couple of (perhaps naive) comments: 1.  The function is declared as <code>__cdecl</code> but you mention WinDLL in your question title.  Can you please edit your code to include how you are loading your DLL (i.e. where <code>pPcapDLL</code> comes from)?  2.  Have you tried replacing <code>ctypes.byref(outdata_ptr)</code> with <code>ctypes.byref(outdata)</code>?  As it stands it looks like your code is passing a pointer to a pointer to your function, when it appears to take just a pointer.</span>
<span class="comment-copy">I fixed the question, I will try the outdata_ptr =&gt; outdata -&gt; just tried, I am getting "ValueError: Procedure probably called with too many arguments (20 bytes in excess)"</span>
<span class="comment-copy">I will try and let you know</span>
