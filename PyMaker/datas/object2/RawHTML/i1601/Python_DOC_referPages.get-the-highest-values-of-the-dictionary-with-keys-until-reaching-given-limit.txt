<div class="post-text" itemprop="text">
<p>given dictionary and limit for the number of keys for the new dictionary. In the new dictionary we should have the highest number of values from given dictionary.</p>
<p>the given is:</p>
<pre><code>dict = {'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1
</code></pre>
<p>I want to get a new dictionary with the highest value with key.</p>
<p>new is</p>
<pre><code>{'apple':5} 
</code></pre>
<p>because there should be only one</p>
<p>if the limit is 2. </p>
<pre><code>{'apple':5, 'pears':4}
</code></pre>
<p>because there are three values but the limit is 2 it we don't take anything. I tried</p>
<p>if the limit is 3. It's still</p>
<pre><code>{'apple':5, 'pears':4}
</code></pre>
<p>because I can't add orange. If I add it will be more than the limit.</p>
<pre><code>new = {}
while len(new) &lt; limit:
</code></pre>
<p>then I have to append the highest value with key in new until I reach 
    the limit. I should not add the key if it will more than the limit. </p>
</div>
<div class="post-text" itemprop="text">
<p>I believe your problem is that you have </p>
<pre><code>while len(new) &lt; limit: 
</code></pre>
<p>it needs to be <code>while len(new) &lt;= limit:</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>Whole code being a function:</p>
<pre><code>def f(d,limit):
   return dict(sorted(d.items(),key=lambda x: -x[1])[:limit])
</code></pre>
<p>And now:</p>
<pre><code>print(f(d,1))
</code></pre>
<p>Is:</p>
<pre><code>{'apple': 5}
</code></pre>
<p>And:</p>
<pre><code>print(f(d,2))
</code></pre>
<p>Is:</p>
<pre><code>{'apple': 5, 'pears': 4}
</code></pre>
<p>Note that if the dictionary is always sorted by values like the dictionary you have now, do:</p>
<pre><code>def f(d,limit):
    return dict(d.items()[:limit])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>most_common()</code></a> from <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a>:</p>
<pre><code>from collections import Counter

def largest(dct, n):
    return dict(Counter(dct).most_common(n))

print(largest(dct={'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1}, n=2))
# {'apple': 5, 'pears': 4}

print(largest(dct={'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1}, n=3))
# {'apple': 5, 'pears': 4, 'orange': 3}
</code></pre>
<p>Or even with <a href="https://docs.python.org/3.0/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer"><code>heapq.nlargest()</code></a>:</p>
<pre><code>from heapq import nlargest
from operator import itemgetter

def largest(dct, n):
    return dict(nlargest(n, dct.items(), key=itemgetter(1)))

print(largest(dct={'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1}, n=2))
# {'apple': 5, 'pears': 4}

print(largest(dct={'apple':5, 'pears':4, 'orange':3, 'kiwi':3, 'banana':1}, n=3))
# {'apple': 5, 'pears': 4, 'orange': 3}
</code></pre>
</div>
<span class="comment-copy">It shouldn't be {'apple': 5, 'pears': 4, 'orange': 3} when n=3 because you should also include kiwi if you include orange but if you include kiwi then it will exceed the limit so we shouldn't include both of them.</span>
