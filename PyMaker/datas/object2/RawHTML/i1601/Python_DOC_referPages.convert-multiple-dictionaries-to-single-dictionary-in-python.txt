<div class="post-text" itemprop="text">
<p>I have multiple dictionaries with its keys and values and I want to assign(transfer- all of them to a new-empty- dictionary with keeping all keys and values.
note: other question that i checked have dictionaries with same size</p>
<pre><code>n = {}
x = {'six':6,'thirteen':13,'fifty five':55}
y = {'two': 2, 'four': 4, 'three': 3, 'one': 1, 'zero': 0,'ten': 10}
z = {'nine': 9, 'four': 4, 'three': 3, 'eleven': 11, 'zero': 0, 'seven':7}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3><a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><code>ChainMap</code></a></h3>
<p>For many use cases, <code>collections.ChainMap</code> suffices and is efficient (assumes Python 3.x):</p>
<pre><code>from collections import ChainMap

n = ChainMap(x, y, z)

n['two']       # 2
n['thirteen']  # 13
</code></pre>
<p>If you need a dictionary, just call <code>dict</code> on the <code>ChainMap</code> object:</p>
<pre><code>d = dict(n)
</code></pre>
<h3>Dictionary unpacking</h3>
<p>With Python 3.x, (<a href="https://www.python.org/dev/peps/pep-0448/" rel="nofollow noreferrer">PEP448</a>), you can unpack your dictionaries as you define a new dictionary:</p>
<pre><code>d = {**x, **y, **z}
</code></pre>
<p>Related: <a href="https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression">How to merge two dictionaries in a single expression?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Use the dict own update method in a cycle like this:</p>
<pre><code>x = {'six':6,'thirteen':13,'fifty five':55}
y = {'two': 2, 'four': 4, 'three': 3, 'one': 1, 'zero': 0,'ten': 10}
z = {'nine': 9, 'four': 4, 'three': 3, 'eleven': 11, 'zero': 0, 'seven':7}

n = {}
for e in [x,y,z]:
    n.update(e)
</code></pre>
<p>It is fast if you have just a few dicts. But if you have several dicts (for example more than 20) better to use the locals().</p>
<pre><code>n = {}
for e in "xyz":
    n.update(locals()[e])
</code></pre>
<p>Or if you work with python3 there is an easier way:</p>
<pre><code>n = {**x, **y, **z}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I read yow want duplicated keys. The dict keys are unique, so in this case convert the data to another data structures, for example into tuples.</p>
<pre><code>your_first_dict = {"a":1, "b":2, "c":3}
your_second_dict = {"a":3, "b":4, "d":5}
list_of_tuples = [(key,your_first_dict[key]) for key in your_first_dict]
list_of_tuples += [(key,your_second_dict[key]) for key in your_second_dict]
</code></pre>
</div>
<span class="comment-copy">Could also use extended unpacking (which if you've got a Python version that has ChainMap you should have): <code>n = {**x, **y, **z}</code>...</span>
<span class="comment-copy">thank you for helping, but the solutions guys you provided till now will delete duplicate keys and values. However, I want to keep all of them even if dictionaries have duplicated (keys&amp;values)</span>
<span class="comment-copy">@Abo, A dictionary cannot have duplicate keys. This is a non-negotiable requirement and determined by the structure and use of a dictionary, which maps unique keys to values (although values may be common between multiple keys).</span>
<span class="comment-copy">@jpp thank u so much</span>
<span class="comment-copy">Why <code>locals</code> here... why not just make it <code>for e in [x, y, z]:</code> ?</span>
<span class="comment-copy">Because on that way you create a list. It uses less memory.</span>
<span class="comment-copy">It's a list of 3 elements that are just holding a reference to the dictionaries... you're calling <code>locals()</code> which returns a dictionary of the entire namespace 3 times, then looking up the name, so you've got far more expensive in getting that dictionary 3 times and then performing the lookup...</span>
<span class="comment-copy">That dictionary already exists!</span>
<span class="comment-copy">You are right, I have checked it. The list is faster.</span>
