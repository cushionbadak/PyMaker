<div class="post-text" itemprop="text">
<p>I recently moved from Matlab to Python and want to transfer some Matlab code to Python. However an obstacle popped up.</p>
<p>In Matlab you can define a class with its methods and create nd-arrays of instances. The nice thing is that you can apply the class methods to the array of instances as long as the method is written so it can deal with the arrays. Now in Python I found that this is not possible: when applying a class method to a list of instances it will not find the class method. Below an example of how I would write the code:</p>
<pre><code>class testclass(): 
   def __init__(self, data):
      self.data = data
   def times5(self):
      return testclass(self.data * 5)

classlist = [testclass(1), testclass(10), testclass(100)]
times5(classlist)
</code></pre>
<p>This will give an error on the times5(classlist) line. Now this is a simple example explaining what I want to do (the final class will have multiple numpy arrays as variables).</p>
<p>What is the best way to get this kind of functionality in Python? The reason I want to do this is because it allows batch operations and they make the class a lot more powerful. The only solution I can think of is to define a second class that has a list of instances of the first class as variables. The batch processing would need to be implemented in the second class then.</p>
<p>thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>UPDATE:</p>
<p>In your comment , I notice this sentence,</p>
<blockquote>
<p>For example a function that takes the data of the first class in the list and substracts the data of all following classe.</p>
</blockquote>
<p>This can be solved by <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer">reduce</a> function.</p>
<pre><code>class testclass():
   def __init__(self, data):
      self.data = data
   def times5(self):
      return testclass(self.data * 5)

from functools import reduce
classlist = [x.data for x in [testclass(1), testclass(10), testclass(100)]]
result = reduce(lambda x,y:x-y,classlist[1:],classlist[0])
print(result)
</code></pre>
<p>ORIGIN ANSWER:</p>
<p>In fact, what you need is <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">List Comprehensions</a>.</p>
<p>Please let me show you the code </p>
<pre><code>class testclass(): 
   def __init__(self, data):
      self.data = data
   def times5(self):
      return testclass(self.data * 5)

classlist = [testclass(1), testclass(10), testclass(100)]
results = [x.times5() for x in classlist]
print(results)
</code></pre>
</div>
<span class="comment-copy">You should consider learning Numpy, once you're comfortable with core Python. Numpy can efficiently do arithmetic on arrays of numbers, but it does not speed up the execution of methods on general Python objects.</span>
<span class="comment-copy">You can make that list using a list comprehension: <code>[u.times5() for u in classlist]</code>. And you can populate the input list like <code>classlist = [testclass(u) for u in (1, 10, 100)]</code>. And those can be combined if you don't actually need to keep <code>classlist</code>.</span>
<span class="comment-copy">You have to use the method on the class itself... so it's defined as a method of testclass(), so you would have to have to do:  instance = testclass(1)</span>
<span class="comment-copy">Thanks for this answer, however I want to keep the list comprehension part away from the class user. This batch functionality will not always be to execute a method on each instance in the list but will do more complex things. For example a function that takes the data of the first class in the list and substracts the data of  all following classes.</span>
<span class="comment-copy">@StefanVR I updated answer to solve your new problem.</span>
