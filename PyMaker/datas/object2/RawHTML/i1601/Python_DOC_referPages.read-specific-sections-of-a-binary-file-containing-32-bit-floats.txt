<div class="post-text" itemprop="text">
<p>I have a binary file that contains 32-bit floats. I need to be able to read certain sections of the file into a <code>list</code> or other array-like structure. In other words, I need to read a specific number of bytes (specific number of <code>float32</code>s) at a time into my data structure, then use <code>seek()</code> to seek to another point in the file and do the same thing again.</p>
<p>In pseudocode:</p>
<pre><code>new_list = []

with open('my_file.data', 'rb') as file_in:
    for idx, offset in enumerate(offset_values):
        # seek in the file by the offset
        # read n float32 values into new_list[idx][:]
</code></pre>
<p>What is the most efficient/least confusing way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert bytes to and from 32-bit <code>float</code> values using the <a href="https://docs.python.org/3/library/struct.html#module-struct" rel="nofollow noreferrer"><code>struct</code></a> module:</p>
<pre><code>import random
import struct

FLOAT_SIZE = 4
NUM_OFFSETS = 5
filename = 'my_file.data'

# Create some random offsets.
offset_values = [i*FLOAT_SIZE for i in range(NUM_OFFSETS)]
random.shuffle(offset_values)

# Create a test file
with open(filename, 'wb') as file:
    for offset in offset_values:
        file.seek(offset)
        value = random.random()
        print('writing value:', value, 'at offset', offset)
        file.write(struct.pack('f', value))

# Read sections of file back at offset locations.

new_list = []
with open(filename, 'rb') as file:
    for offset in offset_values:
        file.seek(offset)
        buf = file.read(FLOAT_SIZE)
        value = struct.unpack('f', buf)[0]
        print('read value:', value, 'at offset', offset)
        new_list.append(value)

print('new_list =', new_list)
</code></pre>
<p>Sample output:</p>
<pre class="lang-none prettyprint-override"><code>writing value: 0.0687244786128608 at offset 8
writing value: 0.34336034914481284 at offset 16
writing value: 0.03658244351244533 at offset 4
writing value: 0.9733690320097427 at offset 12
writing value: 0.31991994765615206 at offset 0
read value: 0.06872447580099106 at offset 8
read value: 0.3433603346347809 at offset 16
read value: 0.03658244386315346 at offset 4
read value: 0.9733690023422241 at offset 12
read value: 0.3199199438095093 at offset 0
new_list = [0.06872447580099106, 0.3433603346347809, 0.03658244386315346,
            0.9733690023422241, 0.3199199438095093]
</code></pre>
<p>Note the values read back are slightly different because internally Python uses 64-bit <code>float</code> values, so some precision got lost in the process of converting them to 32-bits and then back.</p>
</div>
<div class="post-text" itemprop="text">
<p>The binary information from your input file can readily be mapped to virtual memory <a href="https://docs.python.org/2/library/mmap.html" rel="nofollow noreferrer">using mmap.</a>  From there, you can import the buffer into a numpy array, if desired.  One note - the numpy dtype may change depending on whether your 32 bit floats are signed or unsigned (this example assumes signed).  The array that get populated will contain the numbers (as opposed to the raw bytes).</p>
<pre><code>import mmap
import numpy as np
import os

new_list = []

with open('my_file.data', 'rb') as file_in:
    size_bytes = os.fstat(file_in.fileno()).st_size
    m = mmap.mmap(file_in.fileno(), length=size_bytes, access=mmap.ACCESS_READ)
    arr = np.frombuffer(m, np.dtype('float32'), offset=0)
    for idx, offset in enumerate(offset_values):
        new_list.append(arr[offset//4])  #For unsigned 32bit floats, divide by 8
</code></pre>
<p>I tested this with an n=10000 array of random floats, converted to bytes:</p>
<pre><code>import random
import struct

a = ''
for i in range(10000):
    a += struct.pack('&lt;f', random.uniform(0, 1000))
</code></pre>
<p>Then I read this "a" variable into the numpy array, as you would with the binary information from file.</p>
<pre><code>&gt;&gt;&gt; arr = np.frombuffer(a, np.dtype('float32'), offset=0)
&gt;&gt;&gt; arr[500]
634.24408
</code></pre>
</div>
<span class="comment-copy">Use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.html" rel="nofollow noreferrer"><code>numpy.memmap</code></a> to memory-map the file as a numpy array with dtype <code>numpy.float32</code>.</span>
<span class="comment-copy">This looks very promising. What if I need to read multiple floats at a time (i.e. a whole line of values into a line of my list)? Would I use a <code>for</code> loop containing <code>struct.unpack('f', buf)[0]</code> to run the <code>struct.unpack</code> operation as many times as values I need from the line?</span>
<span class="comment-copy">@questionable_code: Yes, you could do it in a <code>for</code> loop, but it would be much more efficient to use the <a href="https://docs.python.org/3/library/struct.html#struct.unpack" rel="nofollow noreferrer"><code>struct.unpack()</code></a> function to do it since it's capable of unpacking multiple values each time it's called if you give it the proper format string (i.e. <code>'4f'</code> for four of them). Note that strictly-speaking  there are no "lines" in a binary file, so to use it that way after a <code>seek()</code> to the  beginning of the group, you would then need to read in the desired number of <code>FLOAT_SIZE</code> bytes into the <code>buf</code> buffer.</span>
<span class="comment-copy">What if the number of values I need is variable? How would I write the format string for that?</span>
<span class="comment-copy">@questionable_code: The required format string could easily be constructed on-the-fly if you know the number of 32-bit floats expected at each offset.</span>
