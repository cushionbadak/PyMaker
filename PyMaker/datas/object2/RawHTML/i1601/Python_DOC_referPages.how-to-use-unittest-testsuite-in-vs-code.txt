<div class="post-text" itemprop="text">
<p>In the future, I'll need to add many identical tests with different parameters. Now I am making a sample test suite:</p>
<pre><code>import unittest

class TestCase(unittest.TestCase):
    def __init__(self, methodName='runTest', param=None):
        super(TestCase, self).__init__(methodName)
        self.param = param

    def test_something(self):
        print '\n&gt;&gt;&gt;&gt;&gt;&gt; test_something: param =', self.param
        self.assertEqual(1, 1)

if __name__ == "__main__":
    suite = unittest.TestSuite()
    testloader = unittest.TestLoader()
    testnames = testloader.getTestCaseNames(TestCase)
    for name in testnames:
        suite.addTest(TestCase(name, param=42))
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>
<p>It gets discovered by VS Code:</p>
<pre><code>start
test.test_navigator.TestCase.test_something
</code></pre>
<p>When I run the tests, I don't receive the parameter:</p>
<pre><code>test_something (test.test_navigator.TestCase) ... 
&gt;&gt;&gt;&gt;&gt;&gt; test_something: param = None
ok

----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
</code></pre>
<p>If I run this file directly, everything works as expected (note <code>param = 42</code> part)</p>
<pre><code>test_something (__main__.TestCase) ...
&gt;&gt;&gt;&gt;&gt;&gt; test_something: param = 42
ok

----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
</code></pre>
<p>So it looks like VS Code is running the tests on its own just by using the discovered classes and ignoring TestSuite completely?</p>
<p>What am I doing wrong?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is your code is in a <code>if __name__ == "__main__"</code> block which is only executed when you point Python directly at the file. So when the extension asks <code>unittest</code> to get all the tests and then run them for us it doesn't run the code in your <code>if __name__ == "__main__"</code> block (which is why it can find it but it doesn't do anything magical).</p>
<p>If you can get it to work using <a href="https://docs.python.org/3/library/unittest.html#command-line-interface" rel="nofollow noreferrer"><code>unittest</code>'s command-line interface</a> then the extension should run it as you want it to.</p>
</div>
<div class="post-text" itemprop="text">
<p>The key is to implement the <code>load_tests</code> function:</p>
<pre><code>def load_tests(loader, tests, pattern):
    suite = unittest.TestSuite()
    testnames = loader.getTestCaseNames(TestCase)
    for name in testnames:
        suite.addTest(TestCase(name, param=42))
        suite.addTest(TestCase(name, param=84))
    return suite
</code></pre>
<p>The documentation says:</p>
<blockquote>
<p>If load_tests exists then discovery does not recurse into the package, load_tests is responsible for loading all tests in the package.</p>
</blockquote>
<p>Now my tests run as expected.</p>
<p>P.S. Thanks to Brett Cannon for pointing me to Unit testing framework documentation</p>
</div>
<span class="comment-copy">If I remove the <code>if __name__ == "__main__"</code> condition then the tests are executed two times: one time in a suite as expected and one time as individual tests. Also they are executed on discovery.</span>
<span class="comment-copy">So while playing with unittest's CLI I realized that it's not a VS Code problem but the unittest's itself. I am getting the same behavior from CLI. I can't get the tests executed in a suite without getting them executed as standalone.</span>
