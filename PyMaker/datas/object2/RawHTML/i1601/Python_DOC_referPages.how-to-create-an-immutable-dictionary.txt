<div class="post-text" itemprop="text">
<ul>
<li>A frozen set is a frozenset.  </li>
<li>A frozen list could be a tuple.  </li>
<li>What would a frozen dict be? An immutable, hashable dict.  </li>
</ul>
<p>I guess it could be something like <code>collections.namedtuple</code>, but that is more like a frozen-keys dict (a half-frozen dict). Isn't it?</p>
<p>A "frozendict" should be a frozen dictionary, it should have <code>keys</code>, <code>values</code>, <code>get</code>, etc., and support <code>in</code>, <code>for</code>, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't have a builtin frozendict type. It turns out this wouldn't be useful too often (though it would still probably be useful more often than <code>frozenset</code> is).</p>
<p>The most common reason to want such a type is when memoizing function calls for functions with unknown arguments. The most common solution to store a hashable equivalent of a dict (where the values are hashable) is something like <code>tuple(sorted(kwargs.iteritems()))</code>. </p>
<p>This depends on the sorting not being a bit insane. Python cannot positively promise sorting will result in something reasonable here. (But it can't promise much else, so don't sweat it too much.)</p>
<hr/>
<p>You could easily enough make some sort of wrapper that works much like a dict. It might look something like</p>
<pre><code>import collections

class FrozenDict(collections.Mapping):
    """Don't forget the docstrings!!"""

    def __init__(self, *args, **kwargs):
        self._d = dict(*args, **kwargs)
        self._hash = None

    def __iter__(self):
        return iter(self._d)

    def __len__(self):
        return len(self._d)

    def __getitem__(self, key):
        return self._d[key]

    def __hash__(self):
        # It would have been simpler and maybe more obvious to 
        # use hash(tuple(sorted(self._d.iteritems()))) from this discussion
        # so far, but this solution is O(n). I don't know what kind of 
        # n we are going to run into, but sometimes it's hard to resist the 
        # urge to optimize when it will gain improved algorithmic performance.
        if self._hash is None:
            self._hash = 0
            for pair in self.iteritems():
                self._hash ^= hash(pair)
        return self._hash
</code></pre>
<p>It should work great:</p>
<pre><code>&gt;&gt;&gt; x = FrozenDict(a=1, b=2)
&gt;&gt;&gt; y = FrozenDict(a=1, b=2)
&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x == {'a': 1, 'b': 2}
True
&gt;&gt;&gt; d = {x: 'foo'}
&gt;&gt;&gt; d[y]
'foo'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Curiously, although we have the seldom useful <code>frozenset</code> in python, there's still no frozen mapping.  The idea was rejected in <a href="http://www.python.org/dev/peps/pep-0416/">PEP 416</a>.  </p>
<p>So the python 2 solution to this:</p>
<pre><code>def foo(config={'a': 1}):
    ...
</code></pre>
<p>Still seems to be the somewhat lame:</p>
<pre><code>def foo(config=None):
    if config is None:
        config = default_config = {'a': 1}
    ...
</code></pre>
<p>In python3 you have the option of <a href="https://docs.python.org/3/library/types.html#types.MappingProxyType">this</a>:</p>
<pre><code>from types import MappingProxyType

default_config = {'a': 1}
DEFAULTS = MappingProxyType(default_config)

def foo(config=DEFAULTS):
    ...
</code></pre>
<p>Now the default config <em>can</em> be updated dynamically, but remain immutable where you want it to be immutable by passing around the proxy instead.  </p>
<p>So changes in the <code>default_config</code> will update <code>DEFAULTS</code> as expected, but you can't write to the mapping proxy object itself.  </p>
<p>Admittedly it's not quite the same thing as an "immutable, hashable dict" - but it's a decent substitute given the same kind of use cases for which we might want a frozendict.    </p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the keys and values of the dictionary are themselves immutable (e.g. strings) then:</p>
<pre><code>&gt;&gt;&gt; d
{'forever': 'atones', 'minks': 'cards', 'overhands': 'warranted', 
 'hardhearted': 'tartly', 'gradations': 'snorkeled'}
&gt;&gt;&gt; t = tuple((k, d[k]) for k in sorted(d.keys()))
&gt;&gt;&gt; hash(t)
1524953596
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is the code I've been using.  I subclassed frozenset.  The advantages of this are the following.</p>
<ol>
<li>This is a truly immutable object.  No relying on the good behavior of future users and developers.</li>
<li>It's easy to convert back and forth between a regular dictionary and a frozen dictionary.  FrozenDict(orig_dict) --&gt; frozen dictionary.  dict(frozen_dict) --&gt; regular dict.</li>
</ol>
<p>Update Jan 21 2015:  The original piece of code I posted in 2014 used a for-loop to find a key that matched.  That was incredibly slow.  Now I've put together an implementation which takes advantage of frozenset's hashing features.  Key-value pairs are stored in special containers where the <code>__hash__</code> and <code>__eq__</code> functions are based on the key only.  This code has also been formally unit-tested, unlike what I posted here in August 2014.</p>
<p>MIT-style license.</p>
<pre><code>if 3 / 2 == 1:
    version = 2
elif 3 / 2 == 1.5:
    version = 3

def col(i):
    ''' For binding named attributes to spots inside subclasses of tuple.'''
    g = tuple.__getitem__
    @property
    def _col(self):
        return g(self,i)
    return _col

class Item(tuple):
    ''' Designed for storing key-value pairs inside
        a FrozenDict, which itself is a subclass of frozenset.
        The __hash__ is overloaded to return the hash of only the key.
        __eq__ is overloaded so that normally it only checks whether the Item's
        key is equal to the other object, HOWEVER, if the other object itself
        is an instance of Item, it checks BOTH the key and value for equality.

        WARNING: Do not use this class for any purpose other than to contain
        key value pairs inside FrozenDict!!!!

        The __eq__ operator is overloaded in such a way that it violates a
        fundamental property of mathematics. That property, which says that
        a == b and b == c implies a == c, does not hold for this object.
        Here's a demonstration:
            [in]  &gt;&gt;&gt; x = Item(('a',4))
            [in]  &gt;&gt;&gt; y = Item(('a',5))
            [in]  &gt;&gt;&gt; hash('a')
            [out] &gt;&gt;&gt; 194817700
            [in]  &gt;&gt;&gt; hash(x)
            [out] &gt;&gt;&gt; 194817700
            [in]  &gt;&gt;&gt; hash(y)
            [out] &gt;&gt;&gt; 194817700
            [in]  &gt;&gt;&gt; 'a' == x
            [out] &gt;&gt;&gt; True
            [in]  &gt;&gt;&gt; 'a' == y
            [out] &gt;&gt;&gt; True
            [in]  &gt;&gt;&gt; x == y
            [out] &gt;&gt;&gt; False
    '''

    __slots__ = ()
    key, value = col(0), col(1)
    def __hash__(self):
        return hash(self.key)
    def __eq__(self, other):
        if isinstance(other, Item):
            return tuple.__eq__(self, other)
        return self.key == other
    def __ne__(self, other):
        return not self.__eq__(other)
    def __str__(self):
        return '%r: %r' % self
    def __repr__(self):
        return 'Item((%r, %r))' % self

class FrozenDict(frozenset):
    ''' Behaves in most ways like a regular dictionary, except that it's immutable.
        It differs from other implementations because it doesn't subclass "dict".
        Instead it subclasses "frozenset" which guarantees immutability.
        FrozenDict instances are created with the same arguments used to initialize
        regular dictionaries, and has all the same methods.
            [in]  &gt;&gt;&gt; f = FrozenDict(x=3,y=4,z=5)
            [in]  &gt;&gt;&gt; f['x']
            [out] &gt;&gt;&gt; 3
            [in]  &gt;&gt;&gt; f['a'] = 0
            [out] &gt;&gt;&gt; TypeError: 'FrozenDict' object does not support item assignment

        FrozenDict can accept un-hashable values, but FrozenDict is only hashable if its values are hashable.
            [in]  &gt;&gt;&gt; f = FrozenDict(x=3,y=4,z=5)
            [in]  &gt;&gt;&gt; hash(f)
            [out] &gt;&gt;&gt; 646626455
            [in]  &gt;&gt;&gt; g = FrozenDict(x=3,y=4,z=[])
            [in]  &gt;&gt;&gt; hash(g)
            [out] &gt;&gt;&gt; TypeError: unhashable type: 'list'

        FrozenDict interacts with dictionary objects as though it were a dict itself.
            [in]  &gt;&gt;&gt; original = dict(x=3,y=4,z=5)
            [in]  &gt;&gt;&gt; frozen = FrozenDict(x=3,y=4,z=5)
            [in]  &gt;&gt;&gt; original == frozen
            [out] &gt;&gt;&gt; True

        FrozenDict supports bi-directional conversions with regular dictionaries.
            [in]  &gt;&gt;&gt; original = {'x': 3, 'y': 4, 'z': 5}
            [in]  &gt;&gt;&gt; FrozenDict(original)
            [out] &gt;&gt;&gt; FrozenDict({'x': 3, 'y': 4, 'z': 5})
            [in]  &gt;&gt;&gt; dict(FrozenDict(original))
            [out] &gt;&gt;&gt; {'x': 3, 'y': 4, 'z': 5}   '''

    __slots__ = ()
    def __new__(cls, orig={}, **kw):
        if kw:
            d = dict(orig, **kw)
            items = map(Item, d.items())
        else:
            try:
                items = map(Item, orig.items())
            except AttributeError:
                items = map(Item, orig)
        return frozenset.__new__(cls, items)

    def __repr__(self):
        cls = self.__class__.__name__
        items = frozenset.__iter__(self)
        _repr = ', '.join(map(str,items))
        return '%s({%s})' % (cls, _repr)

    def __getitem__(self, key):
        if key not in self:
            raise KeyError(key)
        diff = self.difference
        item = diff(diff({key}))
        key, value = set(item).pop()
        return value

    def get(self, key, default=None):
        if key not in self:
            return default
        return self[key]

    def __iter__(self):
        items = frozenset.__iter__(self)
        return map(lambda i: i.key, items)

    def keys(self):
        items = frozenset.__iter__(self)
        return map(lambda i: i.key, items)

    def values(self):
        items = frozenset.__iter__(self)
        return map(lambda i: i.value, items)

    def items(self):
        items = frozenset.__iter__(self)
        return map(tuple, items)

    def copy(self):
        cls = self.__class__
        items = frozenset.copy(self)
        dupl = frozenset.__new__(cls, items)
        return dupl

    @classmethod
    def fromkeys(cls, keys, value):
        d = dict.fromkeys(keys,value)
        return cls(d)

    def __hash__(self):
        kv = tuple.__hash__
        items = frozenset.__iter__(self)
        return hash(frozenset(map(kv, items)))

    def __eq__(self, other):
        if not isinstance(other, FrozenDict):
            try:
                other = FrozenDict(other)
            except Exception:
                return False
        return frozenset.__eq__(self, other)

    def __ne__(self, other):
        return not self.__eq__(other)


if version == 2:
    #Here are the Python2 modifications
    class Python2(FrozenDict):
        def __iter__(self):
            items = frozenset.__iter__(self)
            for i in items:
                yield i.key

        def iterkeys(self):
            items = frozenset.__iter__(self)
            for i in items:
                yield i.key

        def itervalues(self):
            items = frozenset.__iter__(self)
            for i in items:
                yield i.value

        def iteritems(self):
            items = frozenset.__iter__(self)
            for i in items:
                yield (i.key, i.value)

        def has_key(self, key):
            return key in self

        def viewkeys(self):
            return dict(self).viewkeys()

        def viewvalues(self):
            return dict(self).viewvalues()

        def viewitems(self):
            return dict(self).viewitems()

    #If this is Python2, rebuild the class
    #from scratch rather than use a subclass
    py3 = FrozenDict.__dict__
    py3 = {k: py3[k] for k in py3}
    py2 = {}
    py2.update(py3)
    dct = Python2.__dict__
    py2.update({k: dct[k] for k in dct})

    FrozenDict = type('FrozenDict', (frozenset,), py2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think of frozendict everytime I write a function like this:</p>
<pre><code>def do_something(blah, optional_dict_parm=None):
    if optional_dict_parm is None:
        optional_dict_parm = {}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use <a href="http://utilspie.readthedocs.io/en/latest/#frozendict" rel="nofollow noreferrer"><code>frozendict</code></a> from <a href="https://pypi.python.org/pypi/utilspie" rel="nofollow noreferrer"><code>utilspie</code></a> package as:</p>
<pre><code>&gt;&gt;&gt; from utilspie.collectionsutils import frozendict

&gt;&gt;&gt; my_dict = frozendict({1: 3, 4: 5})
&gt;&gt;&gt; my_dict  # object of `frozendict` type
frozendict({1: 3, 4: 5})

# Hashable
&gt;&gt;&gt; {my_dict: 4}
{frozendict({1: 3, 4: 5}): 4}

# Immutable
&gt;&gt;&gt; my_dict[1] = 5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Users/mquadri/workspace/utilspie/utilspie/collectionsutils/collections_utils.py", line 44, in __setitem__
    self.__setitem__.__name__, type(self).__name__))
AttributeError: You can not call '__setitem__()' for 'frozendict' object
</code></pre>
<hr/>
<p>As per the <a href="http://utilspie.readthedocs.io/en/latest/#frozendict" rel="nofollow noreferrer">document</a>:</p>
<blockquote>
<p><strong>frozendict(dict_obj)</strong>: Accepts obj of dict type and returns a hashable and immutable dict</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>There is no <code>fronzedict</code> but you can use <code>MappingProxyType</code>:</p>
<pre><code>&gt;&gt;&gt; from types import MappingProxyType
&gt;&gt;&gt; foo = MappingProxyType({'a': 1})
&gt;&gt;&gt; foo
mappingproxy({'a': 1})
&gt;&gt;&gt; foo['a'] = 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'mappingproxy' object does not support item assignment
&gt;&gt;&gt; foo
mappingproxy({'a': 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, this is my second answer, but it is a completely different approach.  The first implementation was in pure python.  This one is in Cython.  If you know how to use and compile Cython modules, this is just as fast as a regular dictionary.  Roughly .04 to .06 micro-sec to retrieve a single value.</p>
<p>This is the file "frozen_dict.pyx"</p>
<pre><code>import cython
from collections import Mapping

cdef class dict_wrapper:
    cdef object d
    cdef int h

    def __init__(self, *args, **kw):
        self.d = dict(*args, **kw)
        self.h = -1

    def __len__(self):
        return len(self.d)

    def __iter__(self):
        return iter(self.d)

    def __getitem__(self, key):
        return self.d[key]

    def __hash__(self):
        if self.h == -1:
            self.h = hash(frozenset(self.d.iteritems()))
        return self.h

class FrozenDict(dict_wrapper, Mapping):
    def __repr__(self):
        c = type(self).__name__
        r = ', '.join('%r: %r' % (k,self[k]) for k in self)
        return '%s({%s})' % (c, r)

__all__ = ['FrozenDict']
</code></pre>
<p>Here's the file "setup.py"</p>
<pre><code>from distutils.core import setup
from Cython.Build import cythonize

setup(
    ext_modules = cythonize('frozen_dict.pyx')
)
</code></pre>
<p>If you have Cython installed, save the two files above into the same directory.  Move to that directory in the command line.</p>
<pre><code>python setup.py build_ext --inplace
python setup.py install
</code></pre>
<p>And you should be done.</p>
</div>
<div class="post-text" itemprop="text">
<p>The main disadvantage of <code>namedtuple</code> is that it needs to be specified before it is used, so it's less convenient for single-use cases.</p>
<p>However, there is a practical workaround that can be used to handle many such cases. Let's say that you want to have an immutable equivalent of the following dict:</p>
<pre><code>MY_CONSTANT = {
    'something': 123,
    'something_else': 456
}
</code></pre>
<p>This can be emulated like this:</p>
<pre><code>from collections import namedtuple

MY_CONSTANT = namedtuple('MyConstant', 'something something_else')(123, 456)
</code></pre>
<p>It's even possible to write an auxiliary function to automate this:</p>
<pre><code>def freeze_dict(data):
    from collections import namedtuple
    keys = sorted(data.keys())
    frozen_type = namedtuple(''.join(keys), keys)
    return frozen_type(**data)

a = {'foo':'bar', 'x':'y'}
fa = freeze_dict(data)
assert a['foo'] == fa.foo
</code></pre>
<p>Of course this works only for flat dicts, but it shouldn't be too difficult to implement a recursive version.</p>
</div>
<div class="post-text" itemprop="text">
<p>Install <a href="https://pypi.org/project/frozendict/" rel="nofollow noreferrer">frozendict</a></p>
<pre><code>pip install frozendict
</code></pre>
<p>Use it!</p>
<pre><code>from frozendict import frozendict

def smth(param = frozendict({})):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option is the <code>MultiDictProxy</code> class from the <a href="https://pypi.python.org/pypi/multidict/1.2.1" rel="nofollow"><code>multidict</code></a> package.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Subclassing <code>dict</code></h1>
<p>i see this pattern in the wild (github) and wanted to mention it:</p>
<pre><code>class FrozenDict(dict):
    def __init__(self, *args, **kwargs):
        self._hash = None
        super(FrozenDict, self).__init__(*args, **kwargs)

    def __hash__(self):
        if self._hash is None:
            self._hash = hash(tuple(sorted(self.items())))  # iteritems() on py2
        return self._hash

    def _immutable(self, *args, **kws):
        raise TypeError('cannot change object - object is immutable')

    __setitem__ = _immutable
    __delitem__ = _immutable
    pop = _immutable
    popitem = _immutable
    clear = _immutable
    update = _immutable
    setdefault = _immutable
</code></pre>
<p>example usage:</p>
<pre><code>d1 = FrozenDict({'a': 1, 'b': 2})
d2 = FrozenDict({'a': 1, 'b': 2})
d1.keys() 
assert isinstance(d1, dict)
assert len(set([d1, d2])) == 1  # hashable
</code></pre>
<p><strong>Pros</strong></p>
<ul>
<li>support for <code>get()</code>, <code>keys()</code>, <code>items()</code> (<code>iteritems()</code> on py2) and all the goodies from <code>dict</code> out of the box without explicitly implementing them</li>
<li>uses internally <code>dict</code> which means performance (<code>dict</code> is written in c in CPython)</li>
<li>elegant simple and no black magic</li>
<li><code>isinstance(my_frozen_dict, dict)</code> returns True - although python encourages <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">duck-typing</a> many packages uses <code>isinstance()</code>, this can save many tweaks and customizations</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>any subclass can override this or access it internally (you cant really 100% protect something in python, you should trust your users and provide good documentation).</li>
<li>if you care for speed, you might want to make <code>__hash__</code> a bit faster.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In the absence of native language support, you can either do it yourself or use an existing solution. Fortunately Python makes it dead simple to extend off of their base implementations.</p>
<pre><code>class frozen_dict(dict):
    def __setitem__(self, key, value):
        raise Exception('Frozen dictionaries cannot be mutated')

frozen_dict = frozen_dict({'foo': 'FOO' })
print(frozen['foo']) # FOO
frozen['foo'] = 'NEWFOO' # Exception: Frozen dictionaries cannot be mutated

# OR

from types import MappingProxyType

frozen_dict = MappingProxyType({'foo': 'FOO'})
print(frozen_dict['foo']) # FOO
frozen_dict['foo'] = 'NEWFOO' # TypeError: 'mappingproxy' object does not support item assignment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I needed to access fixed keys for something at one point for something that was a sort of globally-constanty kind of thing and I settled on something like this:</p>
<pre><code>class MyFrozenDict:
    def __getitem__(self, key):
        if key == 'mykey1':
            return 0
        if key == 'mykey2':
            return "another value"
        raise KeyError(key)
</code></pre>
<p>Use it like</p>
<pre><code>a = MyFrozenDict()
print(a['mykey1'])
</code></pre>
<p>WARNING: I don't recommend this for most use cases as it makes some pretty severe tradeoffs.</p>
</div>
<span class="comment-copy">I don't know what level of thread safety people worry about with this kind of thing, but in that respect your <code>__hash__</code> method could be slightly improved.  Simply use a temporary variable when calculating the hash, and only set <code>self._hash</code> once you have the final value.  That way another thread getting a hash while the first is calculating will simply do redundant calculation, rather than getting an incorrect value.</span>
<span class="comment-copy">@Jeff As a rule, all code everywhere is not thread-safe, and you should wrap it around some synchronization structures in order to safely use that code. Also, your particular notion of thread safety relies on the atomicity of object attribute assignment, which is far from guaranteed.</span>
<span class="comment-copy">@Anentropic, That's not true at all.</span>
<span class="comment-copy">Be warned: This "FrozenDict" is not necessarily frozen. There is nothing to stop you from putting a mutable list as a value, in which case hashing will throw an error. There's nothing necessarily wrong with that, but users should be aware. Another thing: This hashing algorithm is poorly chosen, very prone to hash collisions. For example {'a':'b'} hashes the same as {'b':'a'} and {'a':1, 'b':2} hashes the same as {'a':2, 'b':1}. Better choice would be self._hash ^= hash((key, value))</span>
<span class="comment-copy">If you add a mutable entry in an immutable object, the two possible behaviors are to throw an error on creating the object, or throw an error on hashing the object. Tuples do the latter, frozenset does the former. I definitely think you made a good decision to take the latter approach, all things considered. Nevertheless, I think that people might see that FrozenDict and frozenset have similar names, and jump to a conclusion that they should behave similarly. So I think it is worth warning people about this difference. :-)</span>
<span class="comment-copy">That being said, see my answer for a more direct solution than proxy mapping.</span>
<span class="comment-copy">Is there any particular reason to store the proxy in a module variable? Why not just <code>def foo(config=MappingProxyType({'a': 1})):</code>? Your example still allows global modification through <code>default_config</code>, too.</span>
<span class="comment-copy">Also, I suspect the double assignment in <code>config = default_config = {'a': 1}</code> is a typo.</span>
<span class="comment-copy">This is a good, canonical, immutable representation of a dict (barring insane comparison behavior messing up the sort).</span>
<span class="comment-copy">+1, but nit: <code>tuple(sorted(d.iteritems()))</code> is nicer.</span>
<span class="comment-copy">@devin: agreed in full, but I'll let my post stand as an example that there's often an even better way.</span>
<span class="comment-copy">Even better would be to put it in a frozenset, which does not require the keys or values to have a consistent ordering defined.</span>
<span class="comment-copy">Only one problem with this: you no longer have a mapping. That would be the whole point of having the frozen dict in the first place.</span>
<span class="comment-copy">Note that you have also licensed it under CC BY-SA 3.0, by posting it here. At least that's the <a href="http://meta.stackexchange.com/a/109787/247924">prevalent view</a>. I guess the legal basis for that is agreeing to some T&amp;Cs when you first signed up.</span>
<span class="comment-copy">I broke my brain trying to think of a way to look up the key hash without a dict. Redefining the hash of the <code>Item</code> to be the hash of the key is a neat hack!</span>
<span class="comment-copy">Unfortunately, the run time of <code>diff(diff({key}))</code> is still linear in the size of the FrozenDict, while regular dict access time is constant in the average case.</span>
<span class="comment-copy">Every time I see a comment like this I'm sure that I screwed up somewhere and put {} as a default, and go back and look at my recently written code.</span>
<span class="comment-copy">Yeah, it's a nasty gotcha that everyone runs into, sooner or later.</span>
<span class="comment-copy">Easier formulation: <code>optional_dict_parm = optional_dict_parm or {}</code></span>
<span class="comment-copy">In this case you can use <a href="https://docs.python.org/3/library/types.html#types.MappingProxyType" rel="nofollow noreferrer"><code>types.MappingProxyType</code></a><code>({})</code> as default value for argument.</span>
<span class="comment-copy">@GingerPlusPlus could you write that up as an answer?</span>
<span class="comment-copy">Same problem as with the other tuple answer: you have to do <code>getattr(fa, x)</code> instead of <code>fa[x]</code>, no <code>keys</code> method at your finger tips, and all the other reasons a mapping can be desirable.</span>
<span class="comment-copy">Upvoted for the neat generator though.</span>
