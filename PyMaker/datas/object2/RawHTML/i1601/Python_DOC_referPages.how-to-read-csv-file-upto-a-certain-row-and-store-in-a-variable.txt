<div class="post-text" itemprop="text">
<p>I want to read in a csv file and then store the data under the headers as specific variables.   </p>
<p>Mys csv file:  </p>
<pre><code>multiplicity  
4.123  
lattice parameters  
1,0,0  
0,1,0  
0,0,1  
atom sites  
0,0,0  
0.5,0.5,0.5  
occupancy  
1,0  
0,1  
</code></pre>
<p>I want to create a code than can automatically store the line under the multiplicity as data for the variable and so on for the rest of csv. I can't hard code values such as multiplicity is line[2] in the csv because the number of lines for each will change. I would like to create a loop that stores the data in between headers as a variable but I am not sure how. </p>
<p>Ideally I would want the code to search for the first header and the second header and then save the values in between as the multiplicity variable. Then I would want it to find the second header and the third header and save those values as lattice parameter. Find the third header and the fourth header and the values in between as atom sites. And finally find the fourth header and the end of the csv and save the values in between as occupancy. </p>
</div>
<div class="post-text" itemprop="text">
<p>My $0.02:</p>
<ul>
<li>Your approach listed in the question is unecessarily complex. You don't need to identify the first and second heading and append the data between. You need:

<ol>
<li>A way to identify if you have hit a header</li>
<li>Code that will deal appropriately with the values after the header</li>
</ol></li>
</ul>
<p>This isn't working code, but you probably need something from the <a href="https://docs.python.org/3.7/library/csv.html" rel="nofollow noreferrer">python csv module</a>, which <em>may</em> look something like this (RoadRunner's code is more complete, but I think we're both going along the same lines and would end up with pretty much identical output).</p>
<pre><code>data_dict = {}

import csv
with open('file_name.csv', newline='') as csvfile:
     csvreader = csv.reader(csvfile, delimiter=',')
     curr_header = "IF THIS IN DICT, SOMETHING IS WRONG"
     for row in csvreader:
         try: # look for header, if not header, append data
             float(row[0])
             data_dict[curr_header].append([float(x) for x in row])
         except ValueError: # found a header
             curr_header = row[0]
             data_dict[curr_header] = []

print(data_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try collecting your rows in a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a>. </p>
<p>As for grouping lines to their respective headers, it seems that you can just check if a line has all letters and spaces, and is one item read by <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer"><code>csv.reader()</code></a>. It's difficult to say since you've only shown a snapshot of your data. I've made these assumptions in the example below. After you have identified how you find the headers, you can simply add all the proceeding rows until another header is found. </p>
<p>I've also assumed that your normal rows contain integers and floats. You can convert them directly to their proper types with <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a>. </p>
<p><strong>Demo:</strong></p>
<pre><code>from csv import reader
from collections import defaultdict
from ast import literal_eval
from pprint import pprint

# Create a dictionary of lists
data = defaultdict(list)

# Open your file
with open('data.csv') as f:

    # Get the csv reader
    csv_reader = reader(f)

    # Initialise current header
    # If rows fall under this header, they don't have a header
    current_header = None

    # Go over each line in the csv file
    for line in csv_reader:

        # Found header
        if len(line) == 1 and all(item.isalpha() or item.isspace() for item in line[0]):
            current_header = line[0]
            continue

        #  If we get here, normal line with ints and floats
        data[current_header].append(list(map(literal_eval, line)))

pprint(data)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>defaultdict(&lt;class 'list'&gt;,
            {'atom sites': [[0, 0, 0], [0.5, 0.5, 0.5]],
             'lattice parameters': [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
             'multiplicity': [[4.123]],
             'occupancy': [[1, 0], [0, 1]]})
</code></pre>
<p>And now you have a dictionary that stores each header with its respective rows. This can be manipulated later, and added to if needed.</p>
<p>Here is an example of printing each header and their respective rows(nested list):</p>
<pre><code>for header, rows in data.items():
    print("Header: %s, Rows: [%s]" % (header, ",".join(map(str, rows))))

# Header: multiplicity, Rows: [[4.123]]
# Header: lattice parameters, Rows: [[1, 0, 0],[0, 1, 0],[0, 0, 1]]
# Header: atom sites, Rows: [[0, 0, 0],[0.5, 0.5, 0.5]]
# Header: occupancy, Rows: [[1, 0],[0, 1]]
</code></pre>
<p>You can also have a look at <a href="https://www.pythonforbeginners.com/dictionary/how-to-use-dictionaries-in-python" rel="nofollow noreferrer">How to use dictionaries in Python</a> to understand more about dictionaries and how to manipulate them. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

data = {}
lines = list(open("data.csv", 'r'))

for line in lines:
    check = line.split(",")[0].strip()
    if not re.match("^-?\d+\.?\d*$", check):
        key = check
    else:
        data[key] =  data.get(key, []) + [[float(x) for x in line.split(",")]]
</code></pre>
<p>and data dict looks like:</p>
<pre><code>{'atom sites': [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]],
 'lattice parameters': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]],
 'multiplicity': [[4.123]],
 'occupancy': [[1.0, 0.0], [0.0, 1.0]]}
</code></pre>
</div>
<span class="comment-copy">Could you elaborate about the csv file you want to use??</span>
<span class="comment-copy">will your csv contain data for each row??</span>
<span class="comment-copy">My csv will look just like the one shown in the question. The problem is the number of lines under each header will vary. Sometimes it will have 3 under atom sites or other times it will have 8, which is why I need a loop to automate the process.</span>
<span class="comment-copy">Ideally I would want the code to find the first string and the string after that and assign the lines in between (those with numbers) to a variable and do this for each  section of the csv. Therefore I would have data for multiplicity, lattice parameters, atom sites and occupancy each saved in a variable.</span>
<span class="comment-copy">Ideally I would want the code to search for the first header and the second header and then save the values in between as the multiplicity variable. Then I would want it to find the second header and the third header and save those values as lattice parameter. Find the third header and the fourth header and the values in between as atom sites. And finally find the fourth header and the end of the csv and save the values in between as occupancy.</span>
<span class="comment-copy">Does using <code>defaultdict</code> avoid the need to check if the list already exists? I <i>think</i> with a regular <code>dict</code> your code would throw an error when you try to append to a non-initialized header (normally you'd need <code>data[current_header] = []</code> in there somewhere before you could <code>append</code> to <code>data[current_header]</code>.</span>
<span class="comment-copy">@NotAnAmbiTurner Yes, a <code>defaultdict()</code> handles that for you. It initilizes a list beforehand, saving you from doing <code>data[current_header] = []</code>.</span>
<span class="comment-copy">That's pretty badass. I was just reading the docs on it.</span>
<span class="comment-copy">Sorry I am just get getting started with Python so I have a lot of questions. Would this save values for me in a variable that I can manipulate later and how can I print the individual variables.</span>
<span class="comment-copy">@Gabriela Yes. Look at the output in RoadRunner's solution - that's a dictionary which you can manipulate later.</span>
