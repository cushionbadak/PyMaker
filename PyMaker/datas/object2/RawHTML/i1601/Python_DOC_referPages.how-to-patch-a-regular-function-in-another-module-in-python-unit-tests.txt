<div class="post-text" itemprop="text">
<p>I'm trying to <code>patch</code> a function defined in a different module from the module containing the testing code. If the function and its test are defined in the same module, I've found that the following works:</p>
<pre><code>import unittest
from mock import patch


def foo():
    return 'bar'


class FooTest(unittest.TestCase):
    @patch('__main__.foo')
    def test_foo(self, mock_foo):
        mock_foo.return_value = 'baz'

        foo()

        mock_foo.assert_called()


if __name__ == "__main__":
    unittest.main()
</code></pre>
<p>Moreover, if I drop into the debugger in test function just before the <code>foo()</code> call, I see that <code>foo</code> is a <code>MagicMock</code> instance, and that if I call it, it returns <code>'baz'</code> (not <code>'bar'</code>) as expected.</p>
<p>I've tried to adapt this somewhat as follows. In the same directory, I've written a <code>foo_module.py</code> containing just the definition of <code>foo()</code>:</p>
<pre><code>def foo():
    return 'bar'
</code></pre>
<p>and I've imported this function in the testing module and changed the <code>patch()</code> argument from <code>__main__.foo</code> to <code>foo_module.foo</code>:</p>
<pre><code>import unittest
from mock import patch
from foo_module import foo


class FooTest(unittest.TestCase):
    @patch('foo_module.foo')
    def test_foo(self, mock_foo):
        mock_foo.return_value = 'baz'

        foo()

        mock_foo.assert_called()


if __name__ == "__main__":
    unittest.main()
</code></pre>
<p>However, if I try to run this, I get an <code>AssertionError</code> because the <code>mock_foo</code> was not called:</p>
<pre><code>$ python use_patch.py
F
======================================================================
FAIL: test_foo (__main__.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/kupeek/Documents/Scratch/venv/lib/python2.7/site-packages/mock/mock.py", line 1305, in patched
    return func(*args, **keywargs)
  File "use_patch.py", line 13, in test_foo
    mock_foo.assert_called()
  File "/Users/kupeek/Documents/Scratch/venv/lib/python2.7/site-packages/mock/mock.py", line 906, in assert_called
    raise AssertionError(msg)
AssertionError: Expected 'foo' to have been called.

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
</code></pre>
<p>Indeed now if I drop into the debugger, <code>foo</code> is an ordinary function and no longer a <code>MagicMock</code> instance, and it returns <code>'bar'</code> instead of <code>'baz'</code>:</p>
<pre><code>$ python use_patch.py
&gt; /Users/kupeek/Documents/Scratch/use_patch.py(11)test_foo()
     10         import ipdb; ipdb.set_trace()
---&gt; 11         foo()
     12 

ipdb&gt; foo
&lt;function foo at 0x107347410&gt;
ipdb&gt; mock_foo
&lt;MagicMock name='foo' id='4429017168'&gt;
ipdb&gt; foo()
'bar'
</code></pre>
<p>Any idea why this is not working? I've consulted the docs (<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch</a>) but to no avail so far...</p>
</div>
<div class="post-text" itemprop="text">
<p>I managed to get the example to work by, instead of <code>from foo_module import foo</code> and calling <code>foo()</code>, doing <code>import foo_module</code> followed by <code>foo_module.foo()</code>:</p>
<pre><code>import unittest
from mock import patch
import foo_module


class FooTest(unittest.TestCase):
    @patch('foo_module.foo')
    def test_foo(self, mock_foo):
        mock_foo.return_value = 'baz'

        foo_module.foo()

        mock_foo.assert_called()


if __name__ == "__main__":
    unittest.main()
</code></pre>
<p>Basically the <code>patch()</code> decorator determines a <code>target</code> and an <code>attribute</code>, and internally replaces that attribute by a mock instance, along the lines of</p>
<p><code>setattr(target, attribute, MagicMock())</code></p>
<p>In the original example, the <code>foo()</code> function was being imported directly and was not an 'attribute' of the <code>foo_module</code>, so the patcher was not patching the intended object.</p>
</div>
