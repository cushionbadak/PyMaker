<div class="post-text" itemprop="text">
<p>I have two lists and would like to create a dictionary to record the occurrence of tuples.</p>
<p>My current code:</p>
<pre><code>tup_to_find_test = [('good', 'pea'), ('leaf', 'sweet')] 
self_per_list_test = [('leaf', 'liquid'), ('leaf', 'sweet'), ('leaf', 'sweet'),('good', 'pea'),('good', 'pea'),('good', 'pea')]
from collections import defaultdict
tup_dict_test = defaultdict(int)
for tup_to_find_test in self_per_list_test:
   tup_dict_test[tup_to_find_test]+=1
</code></pre>
<p>My result is:</p>
<pre><code>defaultdict(int, {('leaf', 'liquid'): 1, ('leaf', 'sweet'): 1, ('good', 'pea'): 3})
</code></pre>
<p>My desired result is:</p>
<pre><code>('leaf', 'liquid'): 0, ('leaf', 'sweet'): 2, ('good', 'pea'): 3})
</code></pre>
<p>I do not know why the count of <code>('leaf', 'liquid')</code> is 1. Isn't the default integer of <code>defaultdict(int)</code> zero? Why I got 1 for the <code>('leaf', 'liquid')</code> tuple?</p>
</div>
<div class="post-text" itemprop="text">
<p>This line isn't doing what you think it is:</p>
<pre><code>for tup_to_find_test in self_per_list_test:
   # ...
</code></pre>
<p>Here you are <strong>iterating a list elementwise</strong>, in this case the elements of <code>self_per_list_test</code>. There's <em>no filtering</em> taking place. As your <code>for</code> loop iterates, <code>tup_to_find_test</code> successively represents <code>('leaf', 'liquid')</code>, <code>('leaf', 'sweet')</code>, etc. The fact the name is the same as a variable you've defined earlier only serves to confuse.</p>
<p>Instead, you can use a ternary statement to differentiate operations:</p>
<pre><code>for item in self_per_list_test:
    tup_dict_test[item] += 1 if item in tup_to_find_test else 0

print(tup_dict_test)

defaultdict(int, {('leaf', 'liquid'): 0, ('leaf', 'sweet'): 2, ('good', 'pea'): 3})
</code></pre>
<hr/>
<p><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> is more idiomatic with Python. It's good practice to use <code>set</code> for O(1) lookup within a dictionary comprehension.</p>
<pre><code>from collections import Counter

tup_to_find_set = set(tup_to_find_test)
counts = Counter(self_per_list_test)

tup_dict_test = {k: v if k in tup_to_find_set else 0 for k, v in counts.items()}

print(tup_dict_test)

{('leaf', 'liquid'): 0, ('leaf', 'sweet'): 2, ('good', 'pea'): 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Isn't the default integer of <code>defaultdict(int)</code> zero?</p>
</blockquote>
<p>Yes.</p>
<blockquote>
<p>Why I got 1 for the ('leaf', 'liquid') tuple?</p>
</blockquote>
<p>You wrote:</p>
<pre><code>tup_dict_test[tup_to_find_test]+=1
</code></pre>
<p>That is, find the current value—which creates a new one set to zero—then add one to it and store the result back.  The resulting value is 1.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without reinventing the wheel. You can use <code>counter</code> from the wonderful <code>collections</code> standard module library for this. </p>
<pre><code>from collections import Counter

tup_to_find_test = [('good', 'pea'), ('leaf', 'sweet')] 
self_per_list_test = [('leaf', 'liquid'), ('leaf', 'sweet'), ('leaf', 'sweet'),('good', 'pea'),('good', 'pea'),('good', 'pea')]

c = Counter(self_per_list_test)

for key in c:
    if key not in tup_to_find_test:
        c[key] = 0

print(c)

&gt;&gt;Counter({('good', 'pea'): 3, ('leaf', 'sweet'): 2, ('leaf', 'liquid'): 0})
</code></pre>
<p>Here we create a counter based on <code>self_per_list_test</code> and updates the counts to zero if it is not found in <code>tup_to_find_test</code>. Hope this is a more intuitive method in solving your problem.</p>
</div>
<span class="comment-copy">You have <code>('leaf', 'liquid')</code> in <code>self_per_list_test</code> once, so its count is 1</span>
<span class="comment-copy">This is one line fashion of @BernardL solution right? It is very neat and smart! Thanks!!!</span>
<span class="comment-copy">@Abbey, Yep, if you want to stick with <code>defaultdict</code>, it is indeed a one-liner. It's just advisable to use hashing via <code>set</code> to make it efficient.</span>
<span class="comment-copy">A quick question. Compared to <code>defaultdict</code>, is the <code>Counter</code> faster than using <code>defaultdict</code>?</span>
<span class="comment-copy">Well, you cannot compare <code>defaultdict</code> to a <code>Counter</code>, <code>defaultdict</code> calls a factory function to supply missing values. A <code>Counter</code> is optimized to count hashable values. In this use case, if your purpose is just to count, I would go with <code>Counter</code>.</span>
<span class="comment-copy">I tried both of them on my dataset. You are right. As my goal is to simply count the frequency of tuple, I should go for <code>Counter</code>. Thanks for your smart/straightforward solution! (I think I overthink about my question)</span>
<span class="comment-copy">Yeah hoped it helped. If you found any of the answers here useful and alas, please accept the best answer here that helped you solved your problem.</span>
