<div class="post-text" itemprop="text">
<p>I have the following function:</p>
<pre><code>def update_contacts(data):
    '''
    Update a user's contacts from Google: to be run as a background task.
    '''
    from users.google_oauth import GoogleOauthClient
    email = data['email']
    access_token = data['access_token']
    g = GoogleOauthClient()
    contacts = g.get_all_contacts(email=email, access_token=access_token, insert=True)
    log.info('Fetched and updated %s contacts' % (len(contacts)))
</code></pre>
<p>I am looking to create a generic function that will run other functions in the background, such as the above. Here is what I have so far:</p>
<pre><code>def run_in_background(function):
    '''
    I want this to be able to receive a normal function call,
    such as `update_contacts(data)` or get_first_name('tom')
    '''

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_in_executor(None, function, data)
</code></pre>
<p>And I would then call this passing :</p>
<pre><code>data={'email': email,'access_token': g.tokens['access_token']}
run_in_background (
    update_contacts(data)
)
</code></pre>
<p>The problem is, I think that it will <strong>first</strong> run the <code>update_contacts</code> function and not really do anything async. How would I properly write and call the <code>run_in_background</code> function?</p>
<p>Perhaps I would need to use something like <code>partial</code> to pass the function without actually calling it until it's executed?</p>
</div>
<div class="post-text" itemprop="text">
<p>As other pointed out, the expression <code>run_in_background(update_contacts(data))</code> will evaluate <code>update_contacts(data)</code> before even calling <code>run_in_background</code>. Regardless of how <code>run_in_background</code> is implemented, you have to pass it a <em>function</em>.</p>
<p>The <code>run_in_background</code> function you're looking for already exists, it's the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit" rel="nofollow noreferrer"><code>submit</code></a> method on the <code>ThreadPoolExecutor</code>:</p>
<pre><code>with ThreadPoolExecutor() as executor:
    data = { ... }
    future = executor.submit(update_contacts, data)
    # ... the function now runs in a background thread,
    # and you can do other things here ...
</code></pre>
<p>You can use methods such as <code>done()</code> or <code>result()</code> on the returned <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer"><code>Future</code></a> object to test whether the submitted task is done or to pick up the result of the function. This is preferable to starting a thread manually because the executor can support a large number of background tasks by maintaining a pool of threads. There is also an executor that uses <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow noreferrer">multiprocessing</a> to provide true parallelism.</p>
<p>All this is completely independent of the asyncio library and its <code>run_in_executor</code> method, which serves to connect blocking code with code written specifically for asyncio, which you don't appear to have.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure about asyncio. However, I believe you can use threading for the same, 
Your function can then be modified as follows: </p>
<pre><code>def background_function(func, params):
    t1 = threading.Thread(target=func, args = params)
    t1.start()
</code></pre>
<p>Sample call: </p>
<pre><code> def do_something(num):
   print('printing' + num + 'times')

def call_do_domething():
   background_function(do_something, args = [1000])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you call <code>run_in_background (update_contacts(data))</code>, it means you already called function <code>update_contacts(data)</code>. But you should only pass function and its arguments like this:</p>
<pre><code>run_in_background(update_contacts, args=(data,))
</code></pre>
<p>And change your <code>run_in_background</code> function accordingly</p>
<pre><code>def run_in_background(function, args=()):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_in_executor(None, function, *args)
</code></pre>
</div>
<span class="comment-copy">If you just want to run "functions in the background", you should probably look into the <a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html" rel="nofollow noreferrer">Celery</a> module and use it with a message broker like Redis or RabbitMQ. The setup can be a little daunting, but it's a better fit for your needs.</span>
<span class="comment-copy">@prithajnath what would be the advantage of that? I'm currently using Google pubsub, and am trying to 'downgrade' to using a background process, as it's easier to manage for something as simple as the above.</span>
<span class="comment-copy">I see. I'm not very familiar with Google Pub/Sub but looks like it offers similar functionality. I guess if you want to make things simpler, <code>asyncio</code> is indeed the way to go.</span>
<span class="comment-copy">There is <i>no point at all</i> using asyncio to run executors. You can directly use a Thread, Process or an Executor for <code>concurrent.futures</code>.</span>
<span class="comment-copy">@MisterMiyagi Seconded. This sounds like exactly the use case that <code>concurrent.futures</code> was created for.</span>
<span class="comment-copy">how to pass the data, like I have it above?</span>
<span class="comment-copy">missed that out, updated my answer for the same.</span>
<span class="comment-copy">This creates a new event loop and a new coroutine without returning either to the caller. That means the caller can neither await the coroutine, check that the function is done, pick up the return value, or even close the event loop.</span>
