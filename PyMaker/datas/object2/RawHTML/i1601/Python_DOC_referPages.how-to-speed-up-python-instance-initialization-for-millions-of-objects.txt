<div class="post-text" itemprop="text">
<p>I have defined a python <code>class</code> named <code>Edge</code> as follows:</p>
<pre><code>class Edge:
    def __init__(self):
        self.node1 = 0
        self.node2 = 0
        self.weight = 0
</code></pre>
<p>Now I have to create approximately 10^6 to 10^7 instances of Edge using:</p>
<pre><code>edges= []
for (i,j,w) in ijw:
    edge = Edge()
    edge.node1 = i
    edge.node2 = j
    edge.weight = w
    edges.append(edge)
</code></pre>
<p>I took me approximately 2 seconds in Desktop. Is there any faster way to do? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can't make it <em>much</em> faster, but I certainly would use <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a> to save on memory allocations. Also make it possible to pass in the attribute values when creating the instance:</p>
<pre><code>class Edge:
    __slots__ = ('node1', 'node2', 'weight')
    def __init__(self, node1=0, node2=0, weight=0):
        self.node1 = node1
        self.node2 = node2
        self.weight = weight
</code></pre>
<p>With the updated <code>__init__</code> you can use a list comprehension:</p>
<pre><code>edges = [Edge(*args) for args in ijw]
</code></pre>
<p>Together these can shave off a decent amount of time creating the objects, roughly halve the time needed. </p>
<p>Comparison creating 1 million objects; the setup:</p>
<pre><code>&gt;&gt;&gt; from random import randrange
&gt;&gt;&gt; ijw = [(randrange(100), randrange(100), randrange(1000)) for _ in range(10 ** 6)]
&gt;&gt;&gt; class OrigEdge:
...     def __init__(self):
...         self.node1 = 0
...         self.node2 = 0
...         self.weight = 0
...
&gt;&gt;&gt; origloop = '''\
... edges= []
... for (i,j,w) in ijw:
...     edge = Edge()
...     edge.node1 = i
...     edge.node2 = j
...     edge.weight = w
...     edges.append(edge)
... '''
&gt;&gt;&gt; class SlotsEdge:
...     __slots__ = ('node1', 'node2', 'weight')
...     def __init__(self, node1=0, node2=0, weight=0):
...         self.node1 = node1
...         self.node2 = node2
...         self.weight = weight
...
&gt;&gt;&gt; listcomploop = '''[Edge(*args) for args in ijw]'''
</code></pre>
<p>and the timings:</p>
<pre><code>&gt;&gt;&gt; from timeit import Timer
&gt;&gt;&gt; count, total = Timer(origloop, 'from __main__ import OrigEdge as Edge, ijw').autorange()
&gt;&gt;&gt; (total / count) * 1000 # milliseconds
722.1121070033405
&gt;&gt;&gt; count, total = Timer(listcomploop, 'from __main__ import SlotsEdge as Edge, ijw').autorange()
&gt;&gt;&gt; (total / count) * 1000 # milliseconds
386.6706900007557
</code></pre>
<p>That's nearly 2 times as fast.</p>
<p>Increasing the random input list to 10^7 items, and the timing difference holds:</p>
<pre><code>&gt;&gt;&gt; ijw = [(randrange(100), randrange(100), randrange(1000)) for _ in range(10 ** 7)]
&gt;&gt;&gt; count, total = Timer(origloop, 'from __main__ import OrigEdge as Edge, ijw').autorange()
&gt;&gt;&gt; (total / count)
7.183759553998243
&gt;&gt;&gt; count, total = Timer(listcomploop, 'from __main__ import SlotsEdge as Edge, ijw').autorange()
&gt;&gt;&gt; (total / count)
3.8709938440006226
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to skip the <code>Edge</code> class and implement the edges via a table, or adjacency matrix.</p>
<p>E.g.</p>
<pre><code>A = create_adjacency_graph(ijw)  # Implement to return a IxJ (sparse?) matrix of weights
edge_a_weight = A[3, 56]
edge_b_weight = A[670, 1023]
# etc...
</code></pre>
<p>This does remove some flexibility though, but should be quite fast both to create and use.</p>
</div>
<span class="comment-copy">Thanks, I will try and test how much it improves!</span>
<span class="comment-copy">Will <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a> do anything for instantiation speed?</span>
<span class="comment-copy">@Tomalak: your dataclass code confirms my timings. It's the same speed as the slots example (the timings are the same within a margin). I may have misunderstood what your 75% was relative to here; the non-slots dataclass speedup is purely due to the list comprehension, not due to you using a dataclass. If you used my class without <code>__slots__</code> but with the list comp, you'd get the same timings.</span>
<span class="comment-copy">Thanks for clearing that up!</span>
<span class="comment-copy">@martineau: See <a href="https://gist.github.com/mjpieters/a4d01024f50d56210dceefc1acdbd487" rel="nofollow noreferrer">gist.github.com/mjpieters/a4d01024f50d56210dceefc1acdbd487</a> for timings and memory footprint.</span>
<span class="comment-copy">In my case, I will pass them into other functions, in order to improve code readability, I prefer using class.</span>
<span class="comment-copy">@ted930511 : To run any algorithm on huge data, you must think at more efficient data structure/language, unless it is a prototype.</span>
