<div class="post-text" itemprop="text">
<p>I was asked to create an inverted index and save its binary in multiple ways (with and without compression). </p>
<p>Long story short, I noticed that using a <code>dict</code> representation takes much less disk space than transforming into a <code>list</code>.</p>
<p>Sample:</p>
<pre><code>dic = {
    'w1': [1,2,3,4,5,6],
    'w2': [2,3,4,5,6],
    'w3': [3,4,5,6],
    'w4': [4,5,6]
}

dic_list = list(dic.items())

import pickle

with open('dic.pickle', 'wb') as handle:
    pickle.dump(dic, handle, protocol=pickle.HIGHEST_PROTOCOL)

with open('dic_list.pickle', 'wb') as handle:
    pickle.dump(dic_list, handle, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
<p>If you check both files sizes, you will notice the difference. </p>
<p>So, I am willing to know how and why they are different. Any additional information would be much appreciated</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>dic_list</code> list consists of <em>more objects</em>. You have an outer list of tuples, each tuple a key-value pair. Each value is another list. Those tuples are the reason you need more space.</p>
<p>The dictionary pickle format doesn't have to use tuple objects to store key-value pairs; it is already known up front that a dictionary consists of a series of pairs, so you can serialise key and value per such pair directly without the overhead of a wrapping tuple object.</p>
<p>You can analyse pickle data with the <a href="https://docs.python.org/3/library/pickletools.html" rel="nofollow noreferrer"><code>pickletools</code> module</a>; using a simpler dictionary with just one key-value, you can see the difference already:</p>
<pre><code>&gt;&gt;&gt; import pickle, pickletools
&gt;&gt;&gt; pickletools.dis(pickle.dumps({'foo': 42}, protocol=pickle.HIGHEST_PROTOCOL))
    0: \x80 PROTO      4
    2: \x95 FRAME      12
   11: }    EMPTY_DICT
   12: \x94 MEMOIZE    (as 0)
   13: \x8c SHORT_BINUNICODE 'foo'
   18: \x94 MEMOIZE    (as 1)
   19: K    BININT1    42
   21: s    SETITEM
   22: .    STOP
highest protocol among opcodes = 4
&gt;&gt;&gt; pickletools.dis(pickle.dumps(list({'foo': 42}.items()), protocol=pickle.HIGHEST_PROTOCOL))
    0: \x80 PROTO      4
    2: \x95 FRAME      14
   11: ]    EMPTY_LIST
   12: \x94 MEMOIZE    (as 0)
   13: \x8c SHORT_BINUNICODE 'foo'
   18: \x94 MEMOIZE    (as 1)
   19: K    BININT1    42
   21: \x86 TUPLE2
   22: \x94 MEMOIZE    (as 2)
   23: a    APPEND
   24: .    STOP
</code></pre>
<p>If you consider <code>EMPTY_DICT</code> + <code>SETITEM</code> to be the equivalent of <code>EMPTY_LIST</code> + <code>APPEND</code>, then the only real difference in that stream in the addition of the <code>TUPLE2</code> / <code>MEMOIZE</code> pair of opcodes. It's those opcodes that take the extra space.</p>
</div>
<div class="post-text" itemprop="text">
<p>A <code>dict</code> can natively handle key-value pairs, while a <code>list</code> must use a separate container.</p>
<p>Your <code>dict</code> is a straightforward representation of <code>Dict[K, V]</code> - pairs plus some structure. Since the structure is runtime only, it can be ignored for storage.</p>
<pre><code>{'a': 1, 'b': 2}
</code></pre>
<p>Your <code>list</code> uses a helper for pairs, resulting in <code>List[Tuple[K,V]]</code> - pairs plus wrapper. Since the wrapper is needed to reconstruct the pairs, it cannot be ignored for storage.</p>
<pre><code>[('a', 1), ('b', 2)]
</code></pre>
<hr/>
<p>You can also inspect this in the pickle dump. The <code>list</code> dump contains markers for the additional tuples.</p>
<pre><code>pickle.dumps({'a': 1, 'b': 2}, protocol=0)
(dp0  # &lt;new dict&gt;
  Va  # string a
 p1
  I1  # integer 1
 sVb  # &lt;setitem key/value&gt;, string b
 p2
  I2  # integer 2
 s.   # &lt;setitem key/value&gt;

pickle.dumps(list({'a': 1, 'b': 2}.items()), protocol=0)
(lp0    # &lt;new list&gt;
  (Va   # &lt;marker&gt;, string a
  p1
   I1   # integer 1
  tp2   # &lt;make tuple&gt;
 a(Vb   # &lt;append&gt;, &lt;marker&gt;, string b
  p3
   I2   # integer 2
  tp4   # &lt;make tuple&gt;
 a.     # &lt;append&gt;
</code></pre>
<p>While the surrounding <code>dict</code> and <code>list</code> are both stored as a sequence of pairs, the pairs are stored differently. For the <code>dict</code>, only key, value and stop are stored flatly. For the <code>list</code>, an additional <code>tuple</code> is needed for each pair.</p>
</div>
<span class="comment-copy">Closely related: <a href="//stackoverflow.com/q/15641344">Python memory consumption: dict VS list of tuples</a></span>
<span class="comment-copy">protocol 0 differs in enough ways from the current protocol revision 4 that I'd recommend <i>against</i> using it to illustrate what might be going on. <code>pickletools.dis()</code> is far more readable, at any rate.</span>
<span class="comment-copy">@MartijnPieters Well, the nesting is present either way and ASCII is less intimidating for some people. The point is that there is an additional container, not how these are encoded. That, plus your answer already showed the nicer <code>dis</code> output anyways. ;)</span>
<span class="comment-copy">The nesting is <i>not</i> present, not in the <code>pickle.dumps()</code> string, nor is the explanation of the opcodes. You had to add those yourself, or you used an IDE that detected you were dumping a pickle.</span>
<span class="comment-copy">@MartijnPieters I mean the tuples <i>nested into</i> the list. The relevant part is that the tuples must be dumped as well. I don't think it really matters where the formatting comes from, a pickle dump is low-level gibberish even with formatting/annotations for most people.</span>
