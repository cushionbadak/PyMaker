<div class="post-text" itemprop="text">
<p>I have a class that is a base for my other non-qt classes. This class instantiates QObject class with Signal instance. Unfortunately, sometimes it raises Segmentation Fault error. Here is my code:  </p>
<pre><code>class PublisherSignal(QObject):
    notify = Signal(list)


class PublisherBase:
    def __init__(self, *args, **kwargs):
        super(PublisherBase, self).__init__(*args, **kwargs)
        self._signal = PublisherSignal()
</code></pre>
<p>The faulthandler shows, that the segmentation fault is happening on the <code>PublisherSignal()</code> class instantiation. It is not always. In most cases it is working fine. No threads are involved. Subclasses of <code>PublisherBase</code> are not subclassing <code>QObject</code>.<br/>
What could be the cause of the segfaults?</p>
</div>
<div class="post-text" itemprop="text">
<p>First: <code>Segmentation fault</code> is a complicated issue for developers. To effectively handle it use <a href="https://docs.python.org/3/library/faulthandler.html" rel="nofollow noreferrer">fault handler</a>. It is a part of Python v.3.x but you could install it in Python v.2.x using <strong>pip</strong>. But sometimes you'd better use event filter Register – for a widget to track signal events for. Here's an example for mouse (it's just to see how it looks like):</p>
<pre><code># IT IS JUST AN EXAMPLE (NOT A SOLUTION)

def eventFilter(self, source, event):
    if event.type() == QEvent.MouseButtonPress:
        if source == self.txtEditor :
            pos=event.pos()
            cursor=self.txtEditor.cursorForPosition(pos)
            cursor.select(QTextCursor.WordUnderCursor)
            txtClicked=cursor.selectedText()
            self.testCommand(str(txtClicked))
    return QMainWindow.eventFilter(self, source, event)
</code></pre>
<p>Second: You might use <a href="https://docs.python.org/2/library/pdb.html" rel="nofollow noreferrer">The Python Debugger</a> module:</p>
<pre><code>python -m pdb yourScript.py
</code></pre>
<p>Third: For threads involved (but you said that no threads are involved).</p>
<pre><code>shutdown (exit) can hang or segfault with daemon threads running
</code></pre>
</div>
<span class="comment-copy">provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">What's wrong with the one I provided? It crashes when instantiating the <code>PublisherBase</code> class (which instantiates <code>PublisherSignal</code>) which are in the example.</span>
<span class="comment-copy">Your example is not complete, you have only declared 2 classes but you have not used it and you should know that the problem may be caused by how you use it. So it's better that you provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> if you want help. :-)</span>
<span class="comment-copy">@Djent Well, that is what you get for relying on unsupported legacy software. Issues like this will <i>never</i> be fixed now. If you want to diagnose the problem properly, you will have to compile debug builds of at least qt4 and pyside so you can get a full stacktrace. That <i>might</i> be enough to reveal what the underlying cause of the issue is (but I wouldn't count on it).</span>
<span class="comment-copy">@Djent I suspect the problem lies in passing complex python types as signal parameters (as opposed to basic types like integers and strings). If so, one possible work-around might be to send the parameters as json strings - or perhaps just try to rewrite your code so there's never any need to send types like <code>list</code> and <code>dict</code>.</span>
<span class="comment-copy">I am using faulthandler, and it is telling me that the segmentation fault is caused by the instantiation of the <code>PublisherSignal</code> object. No idea why.</span>
