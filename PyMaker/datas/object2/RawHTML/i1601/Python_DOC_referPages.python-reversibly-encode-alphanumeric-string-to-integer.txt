<div class="post-text" itemprop="text">
<p>I want to convert a string (composed of alphanumeric characters) into an integer and then convert this integer back into a string:</p>
<p><code>string --&gt; int --&gt; string</code></p>
<p>In other words, I want to represent an alphanumeric string by an integer.</p>
<p>I found a working solution, which I included in the answer, but I do not think it is the best solution, and I am interested in other ideas/methods.</p>
<p>Please don't tag this as duplicate just because a lot of similar questions already exist, I specifically want an easy way of transforming a string into an integer and <strong>vice versa</strong>.</p>
<p>This should work for strings that contain alphanumeric characters, i.e. strings containing numbers and letters.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's what I have so far:</p>
<p>string --&gt; bytes</p>
<pre><code>mBytes = m.encode("utf-8")
</code></pre>
<p>bytes --&gt; int</p>
<pre><code>mInt = int.from_bytes(mBytes, byteorder="big")
</code></pre>
<p>int --&gt; bytes</p>
<pre><code>mBytes = mInt.to_bytes(((mInt.bit_length() + 7) // 8), byteorder="big")
</code></pre>
<p>bytes --&gt; string</p>
<pre><code>m = mBytes.decode("utf-8")
</code></pre>
<p>try it out:</p>
<pre><code>m = "test123"
mBytes = m.encode("utf-8")
mInt = int.from_bytes(mBytes, byteorder="big")
mBytes2 = mInt.to_bytes(((mInt.bit_length() + 7) // 8), byteorder="big")
m2 = mBytes2.decode("utf-8")
print(m == m2)
</code></pre>
<hr/>
<p>Here is an identical reusable version of the above:</p>
<pre><code>class BytesIntEncoder:

    @staticmethod
    def encode(b: bytes) -&gt; int:
        return int.from_bytes(b, byteorder='big')

    @staticmethod
    def decode(i: int) -&gt; bytes:
        return i.to_bytes(((i.bit_length() + 7) // 8), byteorder='big')
</code></pre>
<p>If you're using Python &lt;3.6, remove the optional type annotations.</p>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; s = 'Test123'
&gt;&gt;&gt; b = s.encode()
&gt;&gt;&gt; b
b'Test123'

&gt;&gt;&gt; BytesIntEncoder.encode(b)
23755444588720691
&gt;&gt;&gt; BytesIntEncoder.decode(_)
b'Test123'
&gt;&gt;&gt; _.decode()
'Test123'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the character set is merely alphanumeric, i.e. a-z A-Z 0-9, this requires 6 bits per character. As such, using an 8-bit byte-encoding is theoretically an inefficient use of memory.</p>
<p>This answer converts the input bytes into a sequence of 6-bit integers. It encodes these small integers into one large integer using bitwise operations. Whether this  actually translates into real-world storage efficiency is measured by <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer"><code>sys.getsizeof</code></a>, and is more likely for larger strings.</p>
<p>This implementation customizes the encoding for the choice of character set. If for example you were working with just <code>string.ascii_lowercase</code> (5 bits) rather than <code>string.ascii_uppercase + string.digits</code> (6 bits), the encoding would be correspondingly efficient.</p>
<p>Unit tests are also included.</p>
<pre><code>import string


class BytesIntEncoder:

    def __init__(self, chars: bytes = (string.ascii_letters + string.digits).encode()):
        num_chars = len(chars)
        translation = ''.join(chr(i) for i in range(1, num_chars + 1)).encode()
        self._translation_table = bytes.maketrans(chars, translation)
        self._reverse_translation_table = bytes.maketrans(translation, chars)
        self._num_bits_per_char = (num_chars + 1).bit_length()

    def encode(self, chars: bytes) -&gt; int:
        num_bits_per_char = self._num_bits_per_char
        output, bit_idx = 0, 0
        for chr_idx in chars.translate(self._translation_table):
            output |= (chr_idx &lt;&lt; bit_idx)
            bit_idx += num_bits_per_char
        return output

    def decode(self, i: int) -&gt; bytes:
        maxint = (2 ** self._num_bits_per_char) - 1
        output = bytes(((i &gt;&gt; offset) &amp; maxint) for offset in range(0, i.bit_length(), self._num_bits_per_char))
        return output.translate(self._reverse_translation_table)


# Test
import itertools
import random
import unittest


class TestBytesIntEncoder(unittest.TestCase):

    chars = string.ascii_letters + string.digits
    encoder = BytesIntEncoder(chars.encode())

    def _test_encoding(self, b_in: bytes):
        i = self.encoder.encode(b_in)
        self.assertIsInstance(i, int)
        b_out = self.encoder.decode(i)
        self.assertIsInstance(b_out, bytes)
        self.assertEqual(b_in, b_out)
        # print(b_in, i)

    def test_thoroughly_with_small_str(self):
        for s_len in range(4):
            for s in itertools.combinations_with_replacement(self.chars, s_len):
                s = ''.join(s)
                b_in = s.encode()
                self._test_encoding(b_in)

    def test_randomly_with_large_str(self):
        for s_len in range(256):
            num_samples = {s_len &lt;= 16: 2 ** s_len,
                           16 &lt; s_len &lt;= 32: s_len ** 2,
                           s_len &gt; 32: s_len * 2,
                           s_len &gt; 64: s_len,
                           s_len &gt; 128: 2}[True]
            # print(s_len, num_samples)
            for _ in range(num_samples):
                b_in = ''.join(random.choices(self.chars, k=s_len)).encode()
                self._test_encoding(b_in)


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>Usage example:</p>
<pre><code>&gt;&gt;&gt; encoder = BytesIntEncoder()
&gt;&gt;&gt; s = 'Test123'
&gt;&gt;&gt; b = s.encode()
&gt;&gt;&gt; b
b'Test123'

&gt;&gt;&gt; encoder.encode(b)
3908257788270
&gt;&gt;&gt; encoder.decode(_)
b'Test123'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Recall that a string can be encoded to bytes, which can then be encoded to an integer. The encodings can then be reversed to get the bytes followed by the original string.</p>
<p>This encoder uses <a href="https://docs.python.org/3/library/binascii.html" rel="nofollow noreferrer"><code>binascii</code></a> to produce an <strong>identical integer encoding</strong> to the one in the answer by charel-f. I know it's identical because I extensively tested it.</p>
<p>Credit: <a href="https://stackoverflow.com/a/12627915/832230">this answer</a>.</p>
<pre><code>from binascii import hexlify, unhexlify

class BytesIntEncoder:

    @staticmethod
    def encode(b: bytes) -&gt; int:
        return int(hexlify(b), 16) if b != b'' else 0

    @staticmethod
    def decode(i: int) -&gt; int:
        return unhexlify('%x' % i) if i != 0 else b''
</code></pre>
<p>If you're using Python &lt;3.6, remove the optional type annotations.</p>
<p>Quick test:</p>
<pre><code>&gt;&gt;&gt; s = 'Test123'
&gt;&gt;&gt; b = s.encode()
&gt;&gt;&gt; b
b'Test123'

&gt;&gt;&gt; BytesIntEncoder.encode(b)
23755444588720691
&gt;&gt;&gt; BytesIntEncoder.decode(_)
b'Test123'
&gt;&gt;&gt; _.decode()
'Test123'
</code></pre>
</div>
<span class="comment-copy">This is clear &amp;simple. And it's fast, because all the heavy arithmetic is performed by methods that run at C speed.</span>
<span class="comment-copy">BTW, you can use negation to perform ceiling division. Eg, <code>-(-n // 8)</code>.</span>
<span class="comment-copy">@A-B-B :) It's a nice benefit of Python's convention of handling signed operands of <code>//</code> &amp; <code>%</code>. But it is a bit mysterious if you don't know what's going on, so I normally add a brief comment like <code># Ceiling division</code> when I use it.</span>
<span class="comment-copy">Thank you very much for the answer and for the time you put into this. Have a nice day, and I hope someone can benefit from one of your answers!</span>
