<div class="post-text" itemprop="text">
<p>I wrote this code to continually ask for more input, if the input is not an integer. However, when I try to abort it in the python interactive session, it keeps asking for input.</p>
<p>Why does it do this, even though I'm pressing Ctrl+C, which means abort.</p>
<pre><code>def get_size(text):
    while True:
        try:
            i = int(input(text))
            if i &gt;= 0 and i&lt;24:
                break
        except:
            pass
    return i

a = get_size("Input: ")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you press <kbd>Ctrl</kbd> + <kbd>C</kbd> the Python interpreter catches the interrupt and throws a <code>KeyboardInterrupt</code> exception. Because your bare <code>except</code> is equivalent to <code>except BaseException</code> and <code>KeyboardInterrupt</code> is a subclass of <code>BaseException</code> your <code>except</code> will catch the <code>KeyboardInterrupt</code>. You have no exception handling (like re-raising) in the <code>except</code> block so the program will continue.</p>
<p>At the very least change the <code>except</code> to an <code>except Exception</code> because the exceptions that are subclasses of <code>BaseException</code> but don't subclass <code>Exception</code> (<code>KeyboardInterrupt</code>, <code>SystemExit</code>, and <code>GeneratorExit</code>) are not really meant to be swallowed. In some rare cases it makes sense to catch them and do some clean-up before you re-raise them. But there's almost never a use-case for catching them and not raising them again.</p>
<p>The <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="nofollow noreferrer">Python documentation actually contains a hierarchy visualization of built-in exceptions</a> that might be handy:</p>
<blockquote>
<pre><code>BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      ...
</code></pre>
</blockquote>
<p>You may notice that <code>except Exception</code> <em>could</em> also catch some exceptions that you probably cannot recover from. For example <code>MemoryError</code>, <code>SyntaxError</code>, or <code>SystemError</code> normally indicate that something went (really) wrong and these shouldn't be swallowed because these <em>may</em> not be "recoverable" (at least in most cases).</p>
<p>That means you should observe which Exceptions could be thrown by your code and under which circumstances and then decide which ones you can recover from.</p>
<p>In your case:</p>
<ul>
<li>the <code>input()</code> is not <em>supposed</em> to fail, so you might as well put it outside the <code>try</code>. </li>
<li>Similarly, you wouldn't expect the comparisons to fail, so these can also be put outside the <code>try</code> block. Because you only want that code to run if the <code>try</code> succeeded you need to guard it, for example in the <code>else</code> block of the <code>try</code>. </li>
<li>The <code>int()</code> can fail because of a <code>TypeError</code> in case it's an unsupported type,  however <code>input</code> always returns a string. String is an acceptable type for <code>int()</code> so one wouldn't expect that to happen.</li>
<li>So the only "expected" exception you'll likely encounter here is a <code>ValueError</code>. It is thrown if the string couldn't be interpreted as integer.</li>
</ul>
<p>So I would use:</p>
<pre><code>def get_size(text):
    while True:
        input_text = input(text)
        try:
            i = int(input_text)
        except ValueError:
            pass
        else:
            if 0 &lt;= i &lt; 24:
                return i
</code></pre>
<p>Or in case you don't want the <code>else</code> block, you could also <code>continue</code> in the <code>except</code> block:</p>
<pre><code>def get_size(text):
    while True:
        input_text = input(text)
        try:
            i = int(input_text)
        except ValueError:
            continue
        if 0 &lt;= i &lt; 24:
            return i
</code></pre>
<p>Which one you use is mostly a matter of preference. Both should work identical.</p>
<p>To summarize it:</p>
<ul>
<li>Identify the minimal amount of code that is allowed (from your point of view) to fail, don't put anything else inside the <code>try</code> block.</li>
<li>Make sure you only catch "recoverable" exceptions. In most cases the exception type is enough. But sometimes it could make sense to <strong>also</strong> check the exception message to make sure it's really the exception you want to catch.</li>
<li>Never use <code>except:</code> or <code>except BaseException:</code>. The only exception is if you really want to catch <code>SystemExit</code>, <code>KeyboardInterrupt</code> or <code>GeneratorExit</code> and know how to deal with them appropriately. You may get away with <code>except Exception</code>, but for any code that you want to use regularly (or in production code) you should invest the time to find the more appropriate exceptions.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Ctrl+C means <code>KeyboardInterrupt</code>, but your <code>except</code> block catches and ignores it (as well as all other exceptions). Even Ctrl+D doesn't stop the execution, so you should just kill the process, to my mind.</p>
</div>
<div class="post-text" itemprop="text">
<p>You made the <code>try:</code> <code>except:</code> block inside <code>while</code> loop. So whenever the script throwing an error the <code>except</code> is just passing and going back to <code>while</code> loop.</p>
</div>
<span class="comment-copy">Stop the practice of just ignoring exceptions of all types in your <code>except:</code>, and you won't have this sort of issue. Throwing away all exceptions is never a good idea - stop doing it.</span>
<span class="comment-copy">Yes good point, I just don't know all the except errors, but now I'll just test to see which error I would get in the interactive session first.</span>
<span class="comment-copy">Wow thanks for such a detailed answer!</span>
<span class="comment-copy">I think the first example (using the else: clause after the try: except: block looks like neater code, but both works.</span>
<span class="comment-copy">@Adrian You're welcome. I'm glad it helped. Regarding the two code snippets: That's a matter of preference, I also prefer the <code>else</code> approach, but <code>try / except / else</code> is used less frequently than <code>continue</code>, so it might be confusing (especially for other readers).</span>
<span class="comment-copy">Yes, they did that on purpose so the loop would continue. The problem is that they're just ignoring all exception types (throwing them away). It has nothing to do with where the except is located.</span>
