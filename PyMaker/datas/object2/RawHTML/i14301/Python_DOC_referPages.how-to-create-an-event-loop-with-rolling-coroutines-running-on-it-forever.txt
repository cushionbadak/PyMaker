<div class="post-text" itemprop="text">
<p>In order to prevent from context switching, I want to create a big loop to serve both the network connections and some routines.</p>
<p>Here's the implementation for normal functions:</p>
<pre><code>import asyncio
import time


def hello_world(loop):
    print('Hello World')
    loop.call_later(1, hello_world, loop)

def good_evening(loop):
    print('Good Evening')
    loop.call_later(1, good_evening, loop)

print('step: asyncio.get_event_loop()')
loop = asyncio.get_event_loop()

print('step: loop.call_soon(hello_world, loop)')
loop.call_soon(hello_world, loop)
print('step: loop.call_soon(good_evening, loop)')
loop.call_soon(good_evening, loop)

try:
    # Blocking call interrupted by loop.stop()
    print('step: loop.run_forever()')
    loop.run_forever()
except KeyboardInterrupt:
    pass
finally:
    print('step: loop.close()')
    loop.close()
</code></pre>
<p>Here's the implementation for coroutines:</p>
<pre><code>import asyncio


@asyncio.coroutine
def hello_world():
    while True:
        yield from asyncio.sleep(1)
        print('Hello World')

@asyncio.coroutine
def good_evening():
    while True:
        yield from asyncio.sleep(1)
        print('Good Evening')

print('step: asyncio.get_event_loop()')
loop = asyncio.get_event_loop()
try:
    print('step: loop.run_until_complete()')
    loop.run_until_complete(asyncio.wait([
        hello_world(),
        good_evening()
    ]))
except KeyboardInterrupt:
    pass
finally:
    print('step: loop.close()')
    loop.close()
</code></pre>
<p>And the mixed one:</p>
<pre><code>import asyncio
import time


def hello_world(loop):
    print('Hello World')
    loop.call_later(1, hello_world, loop)

def good_evening(loop):
    print('Good Evening')
    loop.call_later(1, good_evening, loop)

@asyncio.coroutine
def hello_world_coroutine():
    while True:
        yield from asyncio.sleep(1)
        print('Hello World Coroutine')

@asyncio.coroutine
def good_evening_coroutine():
    while True:
        yield from asyncio.sleep(1)
        print('Good Evening Coroutine')

print('step: asyncio.get_event_loop()')
loop = asyncio.get_event_loop()

print('step: loop.call_soon(hello_world, loop)')
loop.call_soon(hello_world, loop)
print('step: loop.call_soon(good_evening, loop)')
loop.call_soon(good_evening, loop)
print('step: asyncio.async(hello_world_coroutine)')
asyncio.async(hello_world_coroutine())
print('step: asyncio.async(good_evening_coroutine)')
asyncio.async(good_evening_coroutine())

try:
    loop.run_forever()
except KeyboardInterrupt:
    pass
finally:
    print('step: loop.close()')
    loop.close()
</code></pre>
<p>As you see, each coroutine function has a while loop surrounded. How can I make it like the normal one? I.e. when it is done, call itself after the given delay time, but not just put a loop there.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really want to eliminate the while-loop from the coroutines (I'm not sure why you feel that's necessary; it's the most natural way to do what you're trying to do), you can use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.async" rel="noreferrer"><code>asyncio.async</code></a> (or <code>asyncio.ensure_future</code> on Python 3.4.4+) to schedule the coroutine to run again on the next event loop iteration:</p>
<pre><code>import asyncio

@asyncio.coroutine
def hello_world():
    yield from asyncio.sleep(1)
    print('Hello World')
    asyncio.async(hello_world())

@asyncio.coroutine
def good_evening():
    yield from asyncio.sleep(1)
    print('Good Evening')
    asyncio.async(good_evening())

print('step: asyncio.get_event_loop()')
loop = asyncio.get_event_loop()
try:
    print('step: loop.run_until_complete()')
    asyncio.async(hello_world())
    asyncio.async(good_evening())
    loop.run_forever()
except KeyboardInterrupt:
    pass
finally:
    print('step: loop.close()')
    loop.close()
</code></pre>
<p>Note that you have to switch back to using <code>loop.run_forever()</code> if you do this, since <code>hello_world</code>/<code>good_evening</code> will exit immediately after printing now.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># asyncio_coroutine_forever.py

import asyncio

async def hello_world():

    await asyncio.sleep(1)
    print('Hello World')
    await good_evening()


async def good_evening():

    await asyncio.sleep(1)
    print('Good Evening')
    await hello_world()


loop = asyncio.get_event_loop()

try:

    loop.run_until_complete(hello_world())
    loop.run_until_complete(good_evening())
    loop.run_forever()

finally:

    print('closing event loop')
    loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import asyncio


@asyncio.coroutine
def hello_world_coroutine():
    yield from asyncio.sleep(1)
    print('Hello World Coroutine')
    yield from hello_world_coroutine()

@asyncio.coroutine
def good_evening_coroutine():
    yield from asyncio.sleep(1)
    print('Good Evening Coroutine')
    yield from good_evening_coroutine()

print('step: asyncio.get_event_loop()')
loop = asyncio.get_event_loop()
try:
    print('step: loop.run_until_complete()')
    loop.run_until_complete(asyncio.wait([
        hello_world_coroutine(),
        good_evening_coroutine()
    ]))
except KeyboardInterrupt:
    pass
finally:
    print('step: loop.close()')
    loop.close()
</code></pre>
<p><strong>UPD</strong></p>
<p>This code would reach the maximum recursion depth. Might because Python has no tail call optimization. Leave the code here as a wrong example.</p>
</div>
<div class="post-text" itemprop="text">
<p>Did you actually try to run the three examples you gave? The difference in behaviour is pretty obvious.</p>
<p>Since you never said what you expect, there’s not telling what is right and what is not. All three implementations could be right or wrong. I can tell you what behaviour each implementation has, and why it has such behaviour; only you know whether it is correct.</p>
<hr/>
<p>In the second example (<code>yield from asyncio.sleep(1)</code>), the two coroutines are run concurrently. This means that each will execute on their own; <code>hello_world</code> prints <code>Hello World</code> every second, and <code>good_evening</code> prints <code>Good Evening</code> every second.</p>
<p>The other two examples both use <code>time.sleep(1)</code>, which is blocking. This means that when the first function (whichever that is; let’s say it’s <code>hello_world</code>) reaches <code>time.sleep(1)</code>, <em>the whole program will hang for one second</em>. This means that when <code>hello_world</code> sleeps, <code>good_evening</code> cannot run either, and vice versa.</p>
<p>The program executes like this:</p>
<ol>
<li>The loop is entered.</li>
<li>The loop calls <code>hello_world</code>.</li>
<li><code>time.sleep(1)</code> in <code>hello_world</code> is reached. The program sleeps for one second.</li>
<li><code>Hello World</code> printed.</li>
<li><code>hello_world</code> yields.</li>
<li>The loop calls <code>good_evening</code>.</li>
<li><code>Good Evening</code> printed.</li>
<li><code>time.sleep(1)</code> in <code>good_evening</code> is reached. The program sleeps for one second.</li>
<li><code>good_evening</code> yields.</li>
<li>Go to 2.</li>
</ol>
<p>Therefore both <code>Hello World</code> and <code>Good Evening</code> appear every <em>two</em> seconds, because there are two <code>time.sleep(1)</code> calls between each <code>print</code>. You would easily notice that if you run the two examples.</p>
</div>
<span class="comment-copy">Why do you not like a loop? The code with loop is pretty obvious and easy to read.</span>
<span class="comment-copy">This is what I want. Thank you!</span>
<span class="comment-copy">That looks much better.  Thank you Morten.   Tested that code with Python 3.6.1.</span>
<span class="comment-copy">Althouh this will eventually run out of stack frames because of the await. It'd be better to <code>await asyncio.sleep(1.0)</code> add the coros as futures to the event loop.</span>
<span class="comment-copy">I won't mark this as the answer right away. Wait some time for better solution.</span>
<span class="comment-copy">This actually won't work - eventually you'll reach the maximum recursion depth and the program will crash.</span>
<span class="comment-copy">Thank you @uranusjr. I wrote the codes and also ran it. I know the flow of it and also know sleep would block the thread and yield from async. not. What I am not sure is the way is the correct or pythonic way. I know the concept of coroutine but haven't used it before. So far I didn't see other people write the same code for this purpose. They use one of normal function and coroutine but not both.</span>
<span class="comment-copy">Top-level coroutines do not make an async program; a program is async only if you use async APIs like <code>asyncio.sleep</code>. You can use blocking APIs inside coroutines (e.g. <code>time.sleep</code>), but blocking APIs block the whole program, including other coroutines. Whether it is acceptable depends on your use case.</span>
<span class="comment-copy">Thank you again. I've updated the question and the code. Replace call_soon with call_later and remove time.sleep().</span>
<span class="comment-copy">The updated examples make sense to me. Now example 1 and 2 should behave identically, and example 3 is also truly async.</span>
<span class="comment-copy">Thank you @uranusjr. But what I want to know is how to emit the while loop.</span>
