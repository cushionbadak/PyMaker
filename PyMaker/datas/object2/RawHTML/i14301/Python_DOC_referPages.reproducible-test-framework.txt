<div class="post-text" itemprop="text">
<p>I am looking for a test or integration framework that supports long, costly tests for correctness. The tests should only be rerun if the code affecting the test has changed.</p>
<p>Ideally the test framework would</p>
<ul>
<li>find the code of the test</li>
<li>produce a hash of it,</li>
<li>run the code and write to an output file with the hash as the name</li>
<li>or skip if that already exists.</li>
<li>provide a simple overview what tests succeeded and which failed.</li>
</ul>
<p>It would be OK if the test has to specify the modules and files it depends on.</p>
<p>Python would be ideal, but this problem may be high-level enough that other languages would work too.</p>
<p>Perhaps there exists already a test or build integration framework I can adapt to fit this behaviour?</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically you need to track what is the test doing so you can check whether it has changed.</p>
<p>Python code can be traced with <a href="https://docs.python.org/3/library/sys.html#sys.settrace" rel="nofollow"><code>sys.settrace(tracefunc)</code></a>. There is a module <a href="https://docs.python.org/3/library/trace.html" rel="nofollow"><code>trace</code></a> that can help with it.</p>
<p>But if it is not just Python code - if the tests execute other programs, test input files etc. and you need to watch it for changes too, then you would need tracing on operating system level, like <code>strace</code>, <code>dtrace</code>, <code>dtruss</code>.</p>
<p>I've created a small demo/prototype of simple testing framework that runs only tests that changed from last run: <a href="https://gist.github.com/messa/3825eba3ad3975840400" rel="nofollow">https://gist.github.com/messa/3825eba3ad3975840400</a> It uses the <code>trace</code> module. It works this way:</p>
<ol>
<li>collect tests, each test is identified by name</li>
<li>load test fingerprints from JSON file (if present)</li>
<li>for each test:
<ul>
<li>if the fingerprint matches the current bytecode of functions listed in the fingerprint, the test is skipped</li>
<li>run test otherwise
<ol>
<li>trace it while running, record all functions being called</li>
<li>create test fingerprint with function names and bytecode MD5 hashes of each recorded function</li>
</ol></li>
</ul></li>
<li>save updated test fingerprints to a JSON file</li>
</ol>
<p>But there is one problem: it's <strong>slow</strong>. Running code while tracing it with <code>trace.Trace</code> is about 40x slower than without tracing. So maybe you will be just better running all tests without tracing :) But if the tracer would be implemented in C like for example <a href="https://bitbucket.org/ned/coveragepy/src/1e8fce85b885eea43a1b52f30f78db5cff8abe78/coverage/tracer.c?at=default" rel="nofollow">it is in the <code>coverage</code> module</a> it should be faster. (Python <code>trace</code> module is not in C.)</p>
<p>Maybe some other tricks could help with speed. Maybe you are interested just in some top-level function whether they changed or not, so you don't need to trace all function calls.</p>
<p>Have you considered other ways how to speed up expensive tests? Like paralellization, ramdisk (tmpfs)... For example, if you test against a database, don't use the "system" or development one, but run a special instance of the database with lightweight configuration (no prealloc, no journal...) from tmpfs. If it is possible, of course - some tests need to be run on configuration similar to the production.</p>
<p>Some test frameworks (or their plugins) can run only the tests that failed last time - that's different, but kind of similar functinality.</p>
</div>
<div class="post-text" itemprop="text">
<p>This may not be the most efficient way to do this, but this can be done with Python's <code>pickle</code> module.</p>
<pre><code>import pickle
</code></pre>
<p>At the end of your file, have it save itself as a pickle.</p>
<pre><code>myfile = open('myfile.py', 'r') #Your script
savefile = open('savefile.pkl', 'w') #File the script will be saved to
#Any file extension can be used but I like .pkl for "pickle"
mytext = myfile.readlines()
pickle.dump(mytext, savefile) #Saves list from readlines() as a pickle
myfile.close()
savefile.close()
</code></pre>
<p>And then at the beginning of your script (after you have pickled it once already), add the code bit that checks it against the pickle.</p>
<pre><code>myfile = ('myfile.py', 'r')
savefile = ('savefile.pkl', 'r')
mytext = myfile.readlines
savetext = pickle.load(savefile)
myfile.close()
savefile.close()

if mytext == savetext:
    #Do whatever you want it to do
else:
    #more code
</code></pre>
<p>That should work.  It's a little long, but it's pure python and should do what you're looking for.</p>
</div>
<span class="comment-copy">Have you took a look at <code>nose</code>? It is popular to do tests.</span>
<span class="comment-copy">Possibly on topic at <a href="https://softwarerecs.stackexchange.com/">softwarerecs.stackexchange.com</a></span>
<span class="comment-copy">Maybe another option would be to create the fingerprint from a hash of the python file (i.e. without executing it)? In this case, e.g. a md5 hash of fib.py</span>
<span class="comment-copy">@j13r Yes, but you need to know somehow that given test uses given .py file. That's why I've used tracing, but if there is other way than tracing then it would be better.</span>
<span class="comment-copy">Of course you can hash at least the file in which is the test function, but I think you want also hash all other files that are executed by that test.</span>
<span class="comment-copy">Btw. I don't have to "execute" functions to get its hash, I just have to execute functions to know what other functions it uses. To get a function hash, I just need to import that file, which should be lightweight - it should not execute any "expensive" code.</span>
<span class="comment-copy">I have an idea - maybe it's not necessary to trace a function execution to get list of other functions it executes; maybe I can get that list from inspecting function bytecode...  <a href="http://en.wikipedia.org/wiki/Static_program_analysis" rel="nofollow noreferrer">"static analysis"</a> :)</span>
