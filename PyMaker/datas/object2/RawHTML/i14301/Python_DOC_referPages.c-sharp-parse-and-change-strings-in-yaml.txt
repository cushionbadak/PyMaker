<div class="post-text" itemprop="text">
<p>I am looking for a way to parse yaml file and change each string then save file without changing structure of original file. In my opinion I should not use Regex for this but some kind of yaml parser.
Sample yaml input bellow:</p>
<pre><code>receipt:     Oz-Ware Purchase Invoice
date:        2007-08-06
customer:
    given:   Dorothy

items:
    - part_no:   A4786
      descrip:   Water Bucket (Filled)

    - part_no:   E1628
      descrip:   High Heeled "Ruby" Slippers
      size:      8

bill-to:  &amp;id001
    street: |
            123 Tornado Alley
            Suite 16
    city:   East Centerville
    state:  KS

ship-to:  *id001

specialDelivery:  &gt;
    Follow the Yellow Brick
    Road to the Emerald City.
...
</code></pre>
<p>Desired output:</p>
<pre><code>receipt:     ###Oz-Ware Purchase Invoice###
date:        ###2007-08-06###
customer:
    given:   ###Dorothy###

items:
    - part_no:   ###A4786###
      descrip:   ###Water Bucket (Filled)###

    - part_no:   ###E1628###
      descrip:   ###High Heeled "Ruby" Slippers###
      size:      ###8###

bill-to:  ###&amp;id001###
    street: |
            ###123 Tornado Alley
            Suite 16###
    city:   ###East Centerville###
    state:  ###KS###

ship-to:  ###*id001###

specialDelivery:  &gt;
    ###Follow the Yellow Brick
    Road to the Emerald City.###
...
</code></pre>
<p>Is there a good yaml parser that could handle complicated yaml files, change strings and save that data back without affecting structure of document? Maybe you have other idea how to solve this problem. Basically i would like to iterate through each string from the top of the document and do some modification on the string. 
Any hints appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Most YAML parsers are build for reading YAML, either written by other programs or edited by humans, and for writing YAML to be read by other programs. What is notoriously lacking is the ability of parsers to write YAML that is still readable by humans:</p>
<ul>
<li>the order of mapping keys is undefined</li>
<li>comments get thrown away </li>
<li>the scalar literal block style, if any, is dropped</li>
<li>spacing around scalars is discarded</li>
<li>the scalar folding information, if any, is dropped</li>
</ul>
<p>The loading of a dump of a loaded  handcrafted YAML file will result in the same internal data structures as the intial load, but the intermediate dump doesn't normally look like the original (handcrafted) YAML.</p>
<p>If you have a Python program:</p>
<pre><code>import ruamel.yaml as yaml

yaml_str = """\
receipt:     Oz-Ware Purchase Invoice
date:        2007-08-06
customer:
    given:   Dorothy

items:
    - part_no:   A4786
      descrip:   Water Bucket (Filled)

    - part_no:   E1628
      descrip:   High Heeled "Ruby" Slippers
      size:      8

bill-to:  &amp;id001
    street: |
            123 Tornado Alley
            Suite 16
    city:   East Centerville
    state:  KS

ship-to:  *id001

specialDelivery:  &gt;
    Follow the Yellow Brick
    Road to the Emerald City.
"""

data1 = yaml.load(yaml_str, Loader=yaml.Loader)
dump_str = yaml.dump(data1, Dumper=yaml.Dumper)
data2 = yaml.load(dump_str, Loader=yaml.Loader)
</code></pre>
<p>Then the following assertions hold:</p>
<pre><code>assert data1 == data2
assert dump_str != yaml_str
</code></pre>
<p>The intermediate <code>dump_str</code> looks like:</p>
<pre class="lang-none prettyprint-override"><code>bill-to: &amp;id001 {city: East Centerville, state: KS, street: '123 Tornado Alley

    Suite 16

    '}
customer: {given: Dorothy}
date: 2007-08-06
items:
- {descrip: Water Bucket (Filled), part_no: A4786}
- {descrip: High Heeled "Ruby" Slippers, part_no: E1628, size: 8}
receipt: Oz-Ware Purchase Invoice
ship-to: *id001
specialDelivery: 'Follow the Yellow Brick Road to the Emerald City.

  '
</code></pre>
<p>The above is the default behaviour for <a href="https://pypi.python.org/pypi/ruamel.yaml" rel="nofollow">ruamel.yaml</a>, <a href="http://pyyaml.org/" rel="nofollow">PyYAML</a> and for many YAML parsers in other language and online YAML conversion services. For some parsers this is the only behaviour provided.</p>
<p>The reason for me to start ruamel.yaml as an enhancement of PyYAML was to make going from handcrafted YAML to internal data, to YAML, result in something that is better human readable (what I call <em>round-tripping</em>), and preserves more information (especially comments).</p>
<pre><code>data = yaml.load(yaml_str, Loader=yaml.RoundTripLoader)
print yaml.dump(data, Dumper=yaml.RoundTripDumper)
</code></pre>
<p>gives you:</p>
<pre class="lang-none prettyprint-override"><code>receipt: Oz-Ware Purchase Invoice
date: 2007-08-06
customer:
  given: Dorothy
items:
- part_no: A4786
  descrip: Water Bucket (Filled)
- part_no: E1628
  descrip: High Heeled "Ruby" Slippers
  size: 8
bill-to: &amp;id001
  street: |
    123 Tornado Alley
    Suite 16
  city: East Centerville
  state: KS
ship-to: *id001
specialDelivery: 'Follow the Yellow Brick Road to the Emerald City.

  '
</code></pre>
<p>My focus has been on comments, key, order and literal block style. Spacing around scalars and folded scalars are not (yet) special.</p>
<hr/>
<p>Starting from there (you could also do this in PyYAML, but you would not have the built-in enhancements of ruamel.yaml key order keeping) you can either provide special emitters, or hook into the system at a lower level, overriding some methods in <code>emitter.py</code> (and making sure you can call the 
originals for the cases you don't need to handle:</p>
<pre><code>def rewrite_write_plain(self, text, split=True):
    if self.state == self.expect_block_mapping_simple_value:
        text = '###' + text + '###'
        while self.column &lt; 20:
            text = ' ' + text
            self.column += 1
    self._org_write_plain(text, split)

def rewrite_write_literal(self, text):
    if self.state == self.expect_block_mapping_simple_value:
        last_nl = False
        if text and text[-1] == '\n':
            last_nl = True
            text = text[:-1]
        text = '###' + text + '###'
        if False:
            extra_indent = ''
            while self.column &lt; 15:
                text = ' ' + text
                extra_indent += ' '
                self.column += 1
            text = text.replace('\n', '\n' + extra_indent)
        if last_nl:
            text += '\n'
    self._org_write_literal(text)

def rewrite_write_single_quoted(self, text, split=True):
    if self.state == self.expect_block_mapping_simple_value:
        last_nl = False
        if text and text[-1] == u'\n':
            last_nl = True
            text = text[:-1]
        text = u'###' + text + u'###'
        if last_nl:
            text += u'\n'
    self.write_folded(text)

def rewrite_write_indicator(self, indicator, need_whitespace,
                    whitespace=False, indention=False):
    if indicator and indicator[0] in u"*&amp;":
        indicator = u'###' + indicator + u'###'
        while self.column &lt; 20:
            indicator = ' ' + indicator
            self.column += 1
    self._org_write_indicator(indicator, need_whitespace, whitespace,
                              indention)

dumper._org_write_plain = dumper.write_plain
dumper.write_plain = rewrite_write_plain
dumper._org_write_literal = dumper.write_literal
dumper.write_literal = rewrite_write_literal
dumper._org_write_single_quoted = dumper.write_single_quoted
dumper.write_single_quoted = rewrite_write_single_quoted
dumper._org_write_indicator = dumper.write_indicator
dumper.write_indicator = rewrite_write_indicator

print yaml.dump(data, Dumper=dumper, indent=4)
</code></pre>
<p>gives you:</p>
<pre class="lang-none prettyprint-override"><code>receipt:             ###Oz-Ware Purchase Invoice###
date:                ###2007-08-06###
customer:
    given:           ###Dorothy###
items:
-   part_no:         ###A4786###
    descrip:         ###Water Bucket (Filled)###
-   part_no:         ###E1628###
    descrip:         ###High Heeled "Ruby" Slippers###
    size:            ###8###
bill-to:             ###&amp;id001###
    street: |
        ###123 Tornado Alley
        Suite 16###
    city:            ###East Centerville###
    state:           ###KS###
ship-to:             ###*id001###
specialDelivery: &gt;
    ###Follow the Yellow Brick Road to the Emerald City.###
</code></pre>
<p>which hopefully is acceptable for further processing in C#</p>
</div>
<div class="post-text" itemprop="text">
<p>The YAML specification has <a href="http://www.yaml.org/spec/1.2/spec.html#id2765608" rel="nofollow noreferrer">this to say</a>:</p>
<blockquote>
<p>In the representation model, mapping keys do not have an order. To serialize a mapping, it is necessary to impose an ordering on its keys. This order is a serialization detail and should not be used when composing the representation graph (and hence for the preservation of application data). In every case where node order is significant, a sequence must be used. For example, an ordered mapping can be represented as a sequence of mappings, where each mapping is a single key: value pair. YAML provides convenient compact notation for this case.</p>
</blockquote>
<p>So you really shouldn’t expect YAML to maintain any order when loading and saving documents.</p>
<p>That being said, I totally understand where you are coming from. Since YAML documents are meant for humans, maintaining a certain order is definitely helpful. Unfortunately, because of the specification, most implementations will use unordered data structures to represent the key/value mappings. In C# and Python, this would be a dictionary; and dictionaries are by design without order.</p>
<p>But both C# and Python do have ordered dictionary types, <a href="https://msdn.microsoft.com/en-us/library/system.collections.specialized.ordereddictionary.aspx" rel="nofollow noreferrer"><code>OrderedDictionary</code></a> and <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a>, and at least for Python, there has been some effort in the past to maintain the key order using ordered dictionaries:</p>
<ul>
<li>The <a href="http://yaml.org/type/omap.html" rel="nofollow noreferrer"><code>!!omap</code> type</a> is a special ordered mapping. It’s supported in PyYAML.</li>
<li><a href="http://pyyaml.org/ticket/29" rel="nofollow noreferrer">PyYAML ticket 29</a> talks about possibly including an <code>OrderedLoader</code>. There is also a short workaround using YAML constructors <a href="http://pyyaml.org/ticket/29#comment:4" rel="nofollow noreferrer">in between</a>, and a possible implementation of a loader <a href="http://pyyaml.org/ticket/29#comment:11" rel="nofollow noreferrer">at the end</a>.</li>
<li><a href="http://pyyaml.org/ticket/161" rel="nofollow noreferrer">PyYAML ticket 161</a> has a <a href="http://pyyaml.org/attachment/ticket/161/use_ordered_dict.py" rel="nofollow noreferrer">recipe</a> which also provides this functionality.</li>
<li>Finally, there is <a href="https://stackoverflow.com/q/5121931/216074">this other Stack Overflow question</a> that covers loading YAML into <code>OrderedDict</code>s.</li>
</ul>
<p>That’s the Python side; I’m sure there are similar efforts for C# implementations too.</p>
</div>
<span class="comment-copy"><a href="http://www.codeproject.com/Articles/28720/YAML-Parser-in-C" rel="nofollow noreferrer">codeproject.com/Articles/28720/YAML-Parser-in-C</a></span>
<span class="comment-copy">Have you tried YamlDotNet? It seems to provide what you need. <a href="https://github.com/aaubry/YamlDotNet" rel="nofollow noreferrer">github.com/aaubry/YamlDotNet</a></span>
<span class="comment-copy">Most YAML parsers will discard the extra spaces before the values and loose all of the implicit alignment information.  The parser I know will also interpret the anchor and reference on reading in (and create references to the same data. I can show you how to do most of that in Python (the folded style scalars are a problem), if that is an option, but since this is marked C# I won't unless you confirm that is ok.</span>
<span class="comment-copy">@Dreamweaver Thanks a lot for suggestions but I couldn't find any sample how to iterate/change through each string.</span>
<span class="comment-copy">@Anthon Although I prefer to use a C#, I could use the python solution as an alternative. If there won't be any answer written in C# then I will accept your solution.</span>
<span class="comment-copy">Thanks for the solution, however with some more complicated files I am getting: ruamel.yaml.scanner.ScannerError: while scanning a double-quoted scalar   in "&lt;byte string&gt;", line 116, column 17:               hint: "For a more detailed explanation ...                      ^ found unknown escape character '&amp;'   in "&lt;byte string&gt;", line 116, column 72:      ... planation,\n &amp;lt;a data-toggle=\&amp;quot;modal\&amp;quot; data-target=\ ...</span>
<span class="comment-copy">the second error I am getting is: ruamel.yaml.scanner.ScannerError: mapping values are not allowed here   in "&lt;byte string&gt;", line 1, column 7:     --- en:</span>
<span class="comment-copy">@wariacik 1) Can I access the exact file that throws the error somewhere? 2) Which version of Python is this on (<code>python --version</code>)? That might be a problem with the Python3 series.</span>
<span class="comment-copy">Thanks a lot for response. Here you go - simplified yaml <a href="https://gist.github.com/anonymous/758c5fedd339ee061b59" rel="nofollow noreferrer">gist.github.com/anonymous/758c5fedd339ee061b59</a> version  Python 2.6 (r26:66714</span>
<span class="comment-copy">@wariacik normally, if you get something after '---' at all it has to be a driective indicator (i.e. what type the following data is).  'en:' is a mapping key and should be on a new line, unindented. What program generated that file? And what about the more complicated file you mentioned in your first comment?</span>
