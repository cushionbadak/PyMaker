<div class="post-text" itemprop="text">
<p>I wanted to implement a library I have written for python in C using the C-API of python. In python I can declare "constants" in my module by just stating:</p>
<pre><code>RED = "red"   # Not really a constant, I know
BLUE = "blue" # but suitable, nevertheless

def solve(img_h):
    # Awesome computations
    return (RED, BLUE)[some_flag]
</code></pre>
<p>Those constants are then later returned by the functions offered by the module. I have some trouble doing the same thing in C. Here is what I got so far:</p>
<pre><code>PyMODINIT_FUNC
PyInit_puzzler(void)
{
    PyObject* module = PyModule_Create(&amp;Module);
    (void) PyModule_AddStringConstant(module, "BLUE",   "blue");
    (void) PyModule_AddStringConstant(module, "RED",    "red");
    return module;
}

PyObject* solve(PyObject* module, PyObject* file_handle)
{
    // Do some awesome computations based on the file
    // Involves HUGE amounts of memory management, thus efficient in C
    // PROBLEM: How do I return the StringConstants from here?
    return some_flag ? BLUE : RED;
}
</code></pre>
<p>I have already marked the problematic part. After I add string constants to the module with <code>PyModule_AddStringConstant(module, "FOO", "foo");</code> how can I actually return them as a <code>PyObject*</code> from my methods? Do I need to increase the ref-counter when I return them?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <a href="https://docs.python.org/3/c-api/module.html#c.PyModule_AddStringConstant" rel="nofollow">PyModule_AddStringConstant(module, name, value)</a> adds the constant to the module, it should be available from the module's dictionary which can be acquired with <a href="https://docs.python.org/3/c-api/module.html#c.PyModule_GetDict" rel="nofollow">PyModule_GetDict(module)</a>. You can then access any attribute from the module via its dictionary using <a href="https://docs.python.org/3/c-api/dict.html#c.PyDict_GetItemString" rel="nofollow">PyDict_GetItemString(dict, key)</a> This is how you can access the constants from your module (after their definitions):</p>
<pre><code>// Get module dict. This is a borrowed reference.
PyObject* module_dict = PyModule_GetDict(module);

// Get BLUE constant. This is a borrowed reference.
PyObject* BLUE = PyDict_GetItemString(module_dict, "BLUE");

// Get RED constant. This is a borrowed reference.
PyObject* RED = PyDict_GetItemString(module_dict, "RED");
</code></pre>
<p>To put this into context with your <code>solve()</code> function, you want something similar to:</p>
<pre><code>PyObject* solve(PyObject* module, PyObject* file_handle)
{
    // Do some awesome computations based on the file
    // Involves HUGE amounts of memory management, thus efficient in C

    // Return string constant at the end.
    PyObject* module_dict = PyModule_GetDict(module);
    PyObject* constant = NULL;
    if (some_flag) {
        // Return BLUE constant. Since BLUE is a borrowed 
        // reference, increment its reference count before 
        // returning it.
        constant = PyDict_GetItemString(module_dict, "BLUE");
        Py_INCREF(constant);
    } else {
        // Return RED constant. Since RED is a borrowed 
        // reference, increment its reference count before 
        // returning it.
        constant = PyDict_GetItemString(module_dict, "RED");
        Py_INCREF(constant);
    }

    // NOTE: Before you return, make sure to release any owned
    // references that this function acquired. `module_dict` does
    // not need to be released because it is merely "borrowed".

    // Return the constant (either BLUE or RED) as an owned
    // reference. Whatever calls `solve()` must make sure to
    // release the returned reference with `Py_DECREF()`.
    return constant;
}
</code></pre>
</div>
