<div class="post-text" itemprop="text">
<p>Is it possible to have an enum of enums in Python? For example, I'd like to have </p>
<pre><code>enumA
    enumB
        elementA
        elementB
    enumC
        elementC
        elementD
</code></pre>
<p>And for me to be able to refer to <code>elementA</code> as <code>enumA.enumB.elementA</code>, or to refer to <code>elementD</code> as <code>enumA.enumC.elementD</code>.</p>
<p>Is this possible? If so, how?</p>
<p>EDIT: When implemented in the naive way:</p>
<pre><code>from enum import Enum

class EnumA(Enum):
    class EnumB(Enum):
        member = 0

print(EnumA)
print(EnumA.EnumB.member)
</code></pre>
<p>It gives:</p>
<pre><code>&lt;enum 'EnumA'&gt;
Traceback (most recent call last):
  File "Maps.py", line 15, in &lt;module&gt;
    print(EnumA.EnumB.member)
AttributeError: 'EnumA' object has no attribute 'member'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't do this with the <code>enum</code> stdlib module. If you try it:</p>
<pre><code>class A(Enum):
    class B(Enum):
        a = 1
        b = 2
    class C(Enum):
        c = 1
        d = 2

A.B.a
</code></pre>
<p>… you'll just get an exception like:</p>
<pre><code>AttributeError: 'A' object has no attribute 'a'
</code></pre>
<p>This is because the enumeration values of <code>A</code> act like instances of <code>A</code>, not like instances of their value type. Just like a normal enum holding <code>int</code> values doesn't have <code>int</code> methods on the values, the <code>B</code> won't have <code>Enum</code> methods. Compare:</p>
<pre><code>class D(Enum):
    a = 1
    b = 2

D.a.bit_length()
</code></pre>
<hr/>
<p>You can, of course, access the underlying value (the <code>int</code>, or the <code>B</code> class) explicitly:</p>
<pre><code>D.a.value.bit_length()
A.B.value.a
</code></pre>
<p>… but I doubt that's what you want here.</p>
<hr/>
<p>So, could you use the same trick that <code>IntEnum</code> uses, of subclassing both <code>Enum</code> and <code>int</code> so that its enumeration values <em>are</em> <code>int</code> values, as described in the <a href="https://docs.python.org/3/library/enum.html#others" rel="noreferrer">Others</a> section of the docs?</p>
<p>No, because what type would you subclass? Not <code>Enum</code>; that's already your type. You can't use <code>type</code> (the type of arbitrary classes). There's nothing that works.</p>
<p>So, you'd have to use a different Enum implementation with a different design to make this work. Fortunately, there are about 69105 different ones on PyPI and ActiveState to choose from.</p>
<hr/>
<p>For example, when I was looking at building something similar to Swift enumerations (which are closer to ML ADTs than Python/Java/etc. enumerations), someone recommended I look at <a href="https://pypi.python.org/pypi/makeobj/" rel="noreferrer"><code>makeobj</code></a>. I forgot to do so, but now I just did, and:</p>
<pre><code>class A(makeobj.Obj):
    class B(makeobj.Obj):
        a, b = makeobj.keys(2)
    class C(makeobj.Obj):
        c, d = makeobj.keys(2)

print(A.B, A.B.b, A.B.b.name, A.B.b.value)
</code></pre>
<p>This gives you:</p>
<pre><code>&lt;Object: B -&gt; [a:0, b:1]&gt; &lt;Value: B.b = 1&gt; b 1
</code></pre>
<p>It might be nice if it looked at its <code>__qualname__</code> instead of its <code>__name__</code> for creating the str/repr values, but otherwise it looks like it does everything you want. And it has some other cool features (not exactly what I was looking for, but interesting…).</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Note</strong>  The below is interesting, and may be useful, but as @abarnert noted the resulting <code>A</code> Enum doesn't have <code>Enum</code> members -- i.e. <code>list(A)</code> returns an empty list.</p>
<hr/>
<p>Without commenting on whether an Enum of Enums is a good idea (I haven't yet decided ;) , this can be done... and with only a small amount of magic.</p>
<p>You can either use the <code>Constant</code> class from <a href="https://stackoverflow.com/a/18035135/208880">this answer</a>:</p>
<pre><code>class Constant:
    def __init__(self, value):
        self.value = value
    def __get__(self, *args):
        return self.value
    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.value)
</code></pre>
<p>Or you can use the new <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">aenum</a> library and its built-in <code>skip</code> desriptor decorator (which is what I will show).</p>
<p>At any rate, by wrapping the subEnum classes in a descriptor they are sheltered from becoming members themselves.</p>
<p>Your example then looks like:</p>
<pre><code>from aenum import Enum, skip

class enumA(Enum):
    @skip
    class enumB(Enum):
        elementA = 'a'
        elementB = 'b'
    @skip
    class enumC(Enum):
        elementC = 'c'
        elementD = 'd'
</code></pre>
<p>and you can then access them as:</p>
<pre><code>print(enumA)
print(enumA.enumB)
print(enumA.enumC.elementD)
</code></pre>
<p>which gives you:</p>
<pre><code>&lt;enum 'enumA'&gt;
&lt;enum 'enumB'&gt;
enumC.elementD
</code></pre>
<p>The difference between using <code>Constant</code> and <code>skip</code> is esoteric:  in <code>enumA</code>'s <code>__dict__</code> <code>'enumB'</code> will return a <code>Constant</code> object (if <code>Constant</code> was used) or <code>&lt;enum 'enumB'&gt;</code> if <code>skip</code> was used; normal access will always return <code>&lt;enum 'enumB'&gt;</code>.</p>
<p>In Python 3.5+ you can even (un)pickle the nested Enums:</p>
<pre><code>print(pickle.loads(pickle.dumps(enumA.enumC.elementD)) is enumA.enumC.elementD)
# True
</code></pre>
<p>Do note that the subEnum doesn't include the parent Enum in it's display; if that's important I would suggest enhancing <code>EnumMeta</code> to recognize the <code>Constant</code> descriptor and modify its contained class' <code>__repr__</code> -- but I'll leave that as an exercise for the reader.  ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <strong>namedtuples</strong> to do something like this:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Foo = namedtuple('Foo', ['bar', 'barz'])
&gt;&gt;&gt; Bar = namedtuple('Bar', ['element_a', 'element_b'])
&gt;&gt;&gt; Barz = namedtuple('Barz', ['element_c', 'element_d'])
&gt;&gt;&gt; bar = Bar('a', 'b')
&gt;&gt;&gt; barz = Barz('c', 'd')
&gt;&gt;&gt; foo = Foo(bar, barz)
&gt;&gt;&gt; foo
Foo(bar=Bar(element_a='a', element_b='b'), barz=Barz(element_c='c', element_d='d'))
&gt;&gt;&gt; foo.bar.element_a
'a'
&gt;&gt;&gt; foo.barz.element_d
'd'
</code></pre>
<p>This is not a enum but, maybe solves your problem</p>
</div>
<div class="post-text" itemprop="text">
<p>I made an enum of enum implementing  de __ getattr __ in the base enum like this</p>
<pre><code>def __getattr__(self, item):
    if item != '_value_':
        return getattr(self.value, item).value
    raise AttributeError
</code></pre>
<p>In my case I have an enum of enum of enum</p>
<pre><code>class enumBase(Enum):
    class innerEnum(Enum):
        class innerInnerEnum(Enum):
           A
</code></pre>
<p>And </p>
<pre><code>enumBase.innerEnum.innerInnerEnum.A
</code></pre>
<p>works</p>
</div>
<div class="post-text" itemprop="text">
<p>Solution based on attrs. This also allows to implement attributes validators and other goodies of attrs:</p>
<pre><code>@attr.s(frozen=True, auto_attribs=True)
class Cntfl:
    upper: str = attr.ib(default="upper")
    bottom: str = attr.ib(default="bottom")

@attr.s(frozen=True, auto_attribs=True)
class Phex:
    cntfl: Cntfl = attr.ib(default=Cntfl())
    crsfl: Cntfl = attr.ib(default=Cntfl())

@attr.s(frozen=True, auto_attribs=True)
class Comp:
    phex: Phex = attr.ib(default=Phex())

Comp = Comp()

c = Comp.phex.cntfl.bottom
print(c)    # -&gt; bottom
</code></pre>
</div>
<span class="comment-copy">First, you'll have to actually write this in Python syntax, using the stdlib <code>enum</code> module or a third-party one. So… have you tried it? What happens?</span>
<span class="comment-copy">I'm curious - why do you need this functionality in the first place? What is the specific use case for this?</span>
<span class="comment-copy">@inspectorG4dget I want to provide a system for classifying objects in my RPG engine's generic object system. For example one might classify an object as terrain.rocks.smallRock or as weapons.melee.swords.shortSword. Is there a better way?</span>
<span class="comment-copy">That seems like it should be dynamic information, not static—in other words, something you store in a string or a tuple, not as part of the type. Unless this is meant to be used for an embedded Python console or something?</span>
<span class="comment-copy">Object types, in the object engine, are immutable - though I'm now reconsidering that.</span>
<span class="comment-copy">Thank you. That makes a lot more sense now. How would you suggest going about what I have in mind? See my comment on the OP.</span>
<span class="comment-copy">@SilverWingedSeraph: As I said at the end, I'd first look through PyPI and ActiveState at all of the other enum implementations and see if one of them has a design closer to what you want. What you're asking for seems <i>reasonable</i>, it's just not the design the stdlib went with, so there's a good chance someone else did.</span>
<span class="comment-copy">Thank you. I've decided to go with a different system for now, but I'll come back to this question at some point and take a look at those.</span>
<span class="comment-copy">Actually, it can be done.  Mind you, I'm not saying it's a good idea (yet).  Check my answer if your curious.</span>
<span class="comment-copy">@EthanFurman Well, your answer doesn't actually have <code>Enum</code> values, it has <code>Constant</code> values. Of course you are using <code>Enum</code> types to <i>define</i> those <code>Constant</code> instances, so it kind of looks like you're using Enums all the way down. I think that's likely to be more misleading than helpful, but it's worth having the answer--anyone who reads it and figured out how it works will learn some useful stuff, if nothing else.</span>
<span class="comment-copy">Thank you. While this doesn't solve my problem, it's very useful to know. +1</span>
<span class="comment-copy">This for me is the best answer, as someone who has a huge library and dependent on enum, its difficult to change to a whole new library. Also <code>return getattr(self.value, item).value</code> if changed to <code>return getattr(self.value, item)</code> would be great! Value is accessible through enum, so the design remains constant.</span>
