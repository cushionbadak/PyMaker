<div class="post-text" itemprop="text">
<h1>Background</h1>
<p>I want to test my code which depends on <code>random</code> module.</p>
<p>The problematic PR is <a href="https://github.com/Axelrod-Python/Axelrod/pull/202" rel="nofollow">https://github.com/Axelrod-Python/Axelrod/pull/202</a> and code is here <a href="https://github.com/Axelrod-Python/Axelrod/blob/master/axelrod/strategies/qlearner.py" rel="nofollow">https://github.com/Axelrod-Python/Axelrod/blob/master/axelrod/strategies/qlearner.py</a></p>
<h1>The problem</h1>
<p>Since <code>random</code> module produces pseudo-random numbers, I always set <code>random.seed(X)</code> to known value <code>X</code>. This works for consecutive test runs. However, Python 3 seems to give different numbers than Python 2 when using <code>random.choice([D, C])</code></p>
<p>Following snippet:</p>
<pre><code>import random
random.seed(1)

for i in range(10):
    print(random.choice(['C', 'D']), end=', ')
</code></pre>
<p>gives different result for Python 2 and 3</p>
<pre><code>$ python2 test.py                                                                                                                                                     
C, D, D, C, C, C, D, D, C, C

$ python3 test.py
C, C, D, C, D, D, D, D, C, C
</code></pre>
<p>However, <code>random.random</code> method works the same on 2.x and 3.x:</p>
<pre><code>import random
random.seed(1)

for i in range(10):
    print(random.random())

$ python3 test.py
0.13436424411240122
0.8474337369372327
0.763774618976614
0.2550690257394217
0.49543508709194095
0.4494910647887381
0.651592972722763
0.7887233511355132
0.0938595867742349
0.02834747652200631

$ python2 test.py
0.134364244112
0.847433736937
0.763774618977
0.255069025739
0.495435087092
0.449491064789
0.651592972723
0.788723351136
0.0938595867742
0.028347476522
</code></pre>
<h1>Workaround</h1>
<p>I can <code>mock</code> the output of <code>random.choice</code>, which works well for simple test cases. However, for fairly complicated test cases, I'm not able to mock output, because I simply don't know how it should look like.</p>
<h1>The question</h1>
<p>Have I done something wrong when calling <code>random.choice</code> method?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/2/library/random.html" rel="nofollow">https://docs.python.org/2/library/random.html</a>, the RNG was changed in Python 2.4 and may use operating system resources. Based on this and the other answer to this question, it's not reasonable to expect Random to give the same result on two different versions of Python, two different operating systems, or even two different computers. For all any of us knows, the next version of Python could implement a Random function that uses the system's microphone to generate a random sequence.</p>
<p>Short version: you should never depend on a RNG to give a deterministic result. If you need a known sequence to satisfy a unit test, you need to either redesign your method or your unit test.</p>
<p>One way you might do this is to split your method into two parts: one part generates the random number. The second part consumes the value and acts on it. You would then write two unit tests: one to test coverage of the generated values, and a separate one to test the output of your method based on specific inputs.</p>
<p>Another way might be to change your method to output not just the result but the random number that created that result. You can modify your unit test to compare the two and pass or fail the test based on the expected output of known pairs. </p>
<p>Or perhaps your unit test can be modified to simply run the test <em>n</em> number of times and look for a spread that confirms some sort of randomness.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a completely different implementation of <code>random.choice</code> in each version.</p>
<p>Python 2.7:</p>
<pre><code>def choice(self, seq):
    """Choose a random element from a non-empty sequence."""
    return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty
</code></pre>
<p><a href="https://hg.python.org/cpython/file/2.7/Lib/random.py" rel="noreferrer">https://hg.python.org/cpython/file/2.7/Lib/random.py</a></p>
<p>Python 3.4:</p>
<pre><code>def choice(self, seq):
    """Choose a random element from a non-empty sequence."""
    try:
        i = self._randbelow(len(seq))
    except ValueError:
        raise IndexError('Cannot choose from an empty sequence')
    return seq[i]
</code></pre>
<p><a href="https://hg.python.org/cpython/file/3.4/Lib/random.py" rel="noreferrer">https://hg.python.org/cpython/file/3.4/Lib/random.py</a></p>
<p>The <a href="https://hg.python.org/cpython/file/3.4/Lib/random.py#l220" rel="noreferrer">_randbelow</a> method may call random() more than once, or may call <code>getrandbits</code> which has a different underlying call to <code>_urandom</code>.</p>
</div>
<span class="comment-copy">I guess in the snippet it must be <code>for i in range(10):</code> and not <code>for i in random(10):</code></span>
<span class="comment-copy">Why do you expect the random module to produce the exact same results across versions of Python?</span>
<span class="comment-copy">Perhaps something with <code>random.seed()</code>?</span>
<span class="comment-copy">Maybe it would help if you provided a bit more context. What does the algorithm that uses random do? Maybe there is a better solution.</span>
<span class="comment-copy">Have you read <a href="https://docs.python.org/3/library/random.html#random.seed" rel="nofollow noreferrer">the docs</a>?</span>
<span class="comment-copy">While true that using random in tests is rarely a good idea, the docs clearly state that <code>random</code> uses a deterministic Mersenne Twister implementation.</span>
<span class="comment-copy">Alright, so probably the best solution is mock the function with known results and don't rely on <code>random.seed</code>, right?</span>
<span class="comment-copy">@UloPe relying on that is a bad idea, since the algorithm is not guaranteed to stay the same. Since OS resources are involved, we can't ever guarantee the same sequence in two different environments.</span>
<span class="comment-copy">@elvard Without knowing what you're trying to accomplish, it's hard to give a sound recommendation. But if you need a non-random list, then yes, you'd need to implement your own sequence generator. Random is supposed to be just that - random and unpredictable.</span>
<span class="comment-copy">Thank you, that might be the problem!</span>
