<div class="post-text" itemprop="text">
<p>I'm aware of creating a custom <code>__repr__</code> or <code>__add__</code> method (and so on), to modify the behavior of operators and functions. Is there a method override for <code>len</code>?</p>
<p>For example:</p>
<pre><code>class Foo:
    def __repr__(self):
        return "A wild Foo Class in its natural habitat."

foo = Foo()

print(foo)         # A wild Foo Class in its natural habitat.
print(repr(foo))   # A wild Foo Class in its natural habitat.
</code></pre>
<p>Could this be done for <code>len</code>, with a list? Normally, it would look like this:</p>
<pre><code>foo = []
print(len(foo))    # 0

foo = [1, 2, 3]
print(len(foo))    # 3
</code></pre>
<p>What if I want to leave search types out of the count? Like this:</p>
<pre><code>class Bar(list):
    pass

foo = [Bar(), 1, '']
print(len(foo))    # 3

count = 0
for item in foo:
    if not isinstance(item, Bar):
        count += 1

print(count)       # 2
</code></pre>
<p>Is there a way to do this from within a <code>list</code> subclass?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__"><code>__len__</code> method</a>:</p>
<pre><code>def __len__(self):
    return 42
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     def __len__(self):
...         return 42
... 
&gt;&gt;&gt; len(Foo())
42
</code></pre>
<p>From the documentation:</p>
<blockquote>
<p>Called to implement the built-in function <code>len()</code>. Should return the length of the object, an integer <code>&gt;=</code> 0. Also, an object that doesnâ€™t define a <code>__bool__()</code> method and whose <code>__len__()</code> method returns zero is considered to be false in a Boolean context.</p>
</blockquote>
<p>For your specific case:</p>
<pre><code>&gt;&gt;&gt; class Bar(list):
...     def __len__(self):
...         return sum(1 for ob in self if not isinstance(ob, Bar))
... 
&gt;&gt;&gt; len(Bar([1, 2, 3]))
3
&gt;&gt;&gt; len(Bar([1, 2, 3, Bar()]))
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, just as you have already discovered that you can override the behaviour of a <code>repr()</code> function call by implementing the <code>__repr__</code> magic method, you can specify the behaviour from a <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow"><code>len()</code></a> function call by implementing (surprise surprise) then <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="nofollow"><code>__len__</code></a> magic:</p>
<pre><code>&gt;&gt;&gt; class Thing:
...     def __len__(self):
...         return 123
...     
&gt;&gt;&gt; len(Thing())
123
</code></pre>
<p>A pedant might mention that you are not modifying the behaviour of <code>len()</code>, you are modifying the behaviour of your class.  <code>len</code> just does the same thing it always does, which includes checking for a <code>__len__</code> attribute on the argument.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Remember: <a href="https://www.python.org" rel="nofollow">Python</a> is a dynamically and <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="nofollow">Duck Typed</a> language.</p>
<p><em>If it acts like something that might have a length;</em></p>
<pre><code>class MyCollection(object):

    def __len__(self):
        return 1234
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; obj = MyCollection()
&gt;&gt;&gt; len(obj)
1234
</code></pre>
<p><em>if it doesn't act like it has a length;</em> <strong>KABOOM!</strong></p>
<pre><code>class Foo(object):

    def __repr___(self):
        return "&lt;Foo&gt;"
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; try:
...     obj = Foo()
...     len(obj)
... except:
...     raise
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 3, in &lt;module&gt;
TypeError: object of type 'Foo' has no len()
</code></pre>
<p>From <a href="http://en.wikipedia.org/wiki/Python_%28programming_language%29#Typing" rel="nofollow">Typing</a>:</p>
<blockquote>
<p>Python uses duck typing and has typed objects but untyped variable
  names. Type constraints are not checked at compile time; rather,
  operations on an object may fail, signifying that the given object is
  not of a suitable type. Despite being dynamically typed, Python is
  strongly typed, forbidding operations that are not well-defined (for
  example, adding a number to a string) rather than silently attempting
  to make sense of them.</p>
</blockquote>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; x = 1234
&gt;&gt;&gt; s = "1234"
&gt;&gt;&gt; x + s
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'str'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just add a <code>__len__</code> method to your class. </p>
<pre><code>class Test:
    def __len__(self):
        return 2

a=Test()
len(a) # --&gt; 2
</code></pre>
</div>
<span class="comment-copy">You already have good answers, but in case you want to find out more about magic methods I can suggest <a href="http://www.rafekettler.com/magicmethods.html" rel="nofollow noreferrer">A Guide to Python's Magic Methods</a> ;)</span>
<span class="comment-copy">This will come in handy quite a bit! Thanks for sharing. @swenzel</span>
<span class="comment-copy">You have a list subclass, not a list superclass.</span>
<span class="comment-copy">Thanks. Fixed that. @wim</span>
<span class="comment-copy">Would <code>sum(not isinstance(ob, Bar) for ob in self)</code> be a bit cleaner?</span>
<span class="comment-copy">@TigerhawkT3: at which point you have to explain that Python's boolean type is a subclass of int and that <code>True</code> has an integer value of 1 and <code>False</code> a value of 0. It's not always worth having a little bit less code when you have to explain that every single time.</span>
<span class="comment-copy">Very true; I hadn't thought of it that way.</span>
