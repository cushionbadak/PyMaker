<div class="post-text" itemprop="text">
<p>I need to pickle a Python3 object to a string which I want to unpickle from an environmental variable in a Travis CI build. The problem is that I can't seem to find a way to pickle to a portable string (unicode) in Python3:</p>
<pre class="lang-python prettyprint-override"><code>import os, pickle    

from my_module import MyPickleableClass


obj = {'cls': MyPickleableClass, 'other_stuf': '(...)'}

pickled = pickle.dumps(obj)

# raises TypeError: str expected, not bytes
os.environ['pickled'] = pickled

# raises UnicodeDecodeError: 'utf-8' codec can't decode byte 0xbb (...)
os.environ['pickled'] = pickled.decode('utf-8')

pickle.loads(os.environ['pickled'])
</code></pre>
<p>Is there a way to serialize complex objects like <code>datetime.datetime</code> to unicode or to some other string representation in Python3 which I can transfer to a different machine and deserialize?</p>
<h2>Update</h2>
<p>I have tested the solutions suggested by @kindall, but the <code>pickle.dumps(obj, 0).decode()</code> raises a <code>UnicodeDecodeError</code>. Nevertheless the <strong>base64</strong> approach works but it needed an <strong>extra decode/encode</strong> step. The solution works on both Python2.x and Python3.x.</p>
<pre class="lang-python prettyprint-override"><code># encode returns bytes so it needs to be decoded to string
pickled = pickle.loads(codecs.decode(pickled.encode(), 'base64')).decode()

type(pickled)  # &lt;class 'str'&gt;

unpickled = pickle.loads(codecs.decode(pickled.encode(), 'base64'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>pickle.dumps()</code> produces a <code>bytes</code> object. Expecting these arbitrary bytes to be valid UTF-8 text (the assumption you are making by trying to decode it to a string from UTF-8) is pretty optimistic. It'd be a coincidence if it worked!</p>
<p>One solution is to use the older pickling protocol that uses entirely ASCII characters. This still comes out as <code>bytes</code>, but since it is ASCII-only it can be decoded to a string without stress:</p>
<pre><code>pickled = pickled.dumps(obj, 0).decode()
</code></pre>
<p>You could also use some other encoding method to encode a binary-pickled object to text, such as base64:</p>
<pre><code>import codecs
pickled = codecs.encode(pickle.dumps(obj), "base64").decode()
</code></pre>
<p>Decoding would then be:</p>
<pre><code>unpickled = pickle.loads(codecs.decode(pickled.encode(), "base64"))
</code></pre>
<p>Using <code>pickle</code> with protocol 0 seems to result in shorter strings than base64-encoding binary pickles (and abarnert's suggestion of hex-encoding is going to be even larger than base64), but I haven't tested it rigorously or anything. Test it with your data and see.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to store bytes in the environment, instead of encoded text, that's what <a href="https://docs.python.org/3/library/os.html#os.environb" rel="nofollow"><code>environb</code></a> is for.</p>
<p>This doesn't work on Windows. (As the docs imply, you should check <a href="https://docs.python.org/3/library/os.html#os.supports_bytes_environ" rel="nofollow"><code>os.supports_bytes_environ</code></a> if you're on 3.2+ instead of just assuming that Unix does and Windows doesn'tâ€¦) So for that, you'll need to smuggle the bytes into something that can be encoded no matter what your system encoding is, e.g., using <code>backslash-escape</code>, or even <code>hex</code>. So, for example:</p>
<pre><code>if os.supports_bytes_environ:
    environb['pickled'] = pickled
else:
    environ['pickled'] = codecs.encode(pickled, 'hex')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the <em>simplest</em> answer, especially if you don't care about Windows, is to just store the bytes in the environment, as suggested in <a href="https://stackoverflow.com/a/30469741/908494">my other answer</a>.</p>
<p>But if you want something clean and debuggable, you might be happier using something designed as a text-based format.</p>
<p><code>pickle</code> does have a "plain text" protocol 0, as explained in <a href="https://stackoverflow.com/a/30469744/908494">kindall's answer</a>. It's certainly more readable than protocol 3 or 4, but it's still not something I'd actually <em>want</em> to read.</p>
<p><a href="http://json.org" rel="nofollow noreferrer">JSON</a> is much nicer, but it can't handle <code>datetime</code> out of the box. You can come up with your own encoding (the stdlib's <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code></a> module is extensible) for the handful of types you need to encode, or use something like <a href="https://pypi.python.org/pypi/jsonpickle" rel="nofollow noreferrer"><code>jsonpickle</code></a>. It's generally safer, more efficient, and more readable to come up with custom encodings for each type you care about than a general "pack arbitrary types in a turing-complete protocol" scheme like <code>pickle</code> or <code>jsonpickle</code>, but of course it's also more work, especially if you have a lot of extra types.</p>
<p><a href="http://json-schema.org/" rel="nofollow noreferrer">JSON Schema</a> lets you define languages in JSON, similar to what you'd do in XML. It comes with a built-in <code>date-time</code> <a href="http://spacetelescope.github.io/understanding-json-schema/reference/string.html" rel="nofollow noreferrer">String format</a>, and the <a href="https://pypi.python.org/pypi/jsonschema" rel="nofollow noreferrer"><code>jsonschema</code></a> library for Python knows how to use it. </p>
<p><a href="http://yaml.org/" rel="nofollow noreferrer">YAML</a> has a standard extension repository that includes many types JSON doesn't, including a <a href="http://yaml.org/type/timestamp.html" rel="nofollow noreferrer">timestamp</a>. Most of <a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=yaml&amp;submit=search" rel="nofollow noreferrer">the zillion 'yaml' modules for Python</a> already know how to encode <code>datetime</code> objects to and from this type. If you need additional types beyond what YAML includes, it was designed to be extensible declaratively. And there are libraries that do the equivalent of <code>jsonpickle</code>, defining new types on the fly, if you really need that.</p>
<p>And finally, you can always write an XML language.</p>
</div>
<span class="comment-copy">Something like JSON?</span>
<span class="comment-copy">Yes, I would prefer a safer format like JSON if possible. Pickles are as good as executable code and running arbitrary code out of an envvar seems pretty dirty to me even if due to the application it is not at present a security hole. Don't resort to pickle until you actually need that flexibility; you certainly don't for <code>datetime</code>.</span>
<span class="comment-copy">If space efficiency really matters, you <i>definitely</i> want to use pickle protocol 4 and <code>environb</code> when possible, or maybe even pickle protocol 4 plus bzip. For Windows, I'd test pickle protocol 4 plus bzip plus base64 vs. pickle protocol 0, but my guess would be that the former is smaller. But I was assuming a few hundred bytes of memory/bandwidth/etc. for each CI build isn't going to be worth worrying about either way.</span>
<span class="comment-copy">2nd suggestion is working. Thank you!</span>
<span class="comment-copy">That's a good trick with the <code>environb</code>. I didn't know about that one.</span>
<span class="comment-copy">Unfortunately you still can't get pure binary into <code>environb</code> because of the null byte.</span>
<span class="comment-copy">The assignment to <code>environ</code> item was just for the sake of the example. What I really need is to put the serialized string into a Travis CI environmental variable through a web form.</span>
<span class="comment-copy">@PeterHudec: Good thing it's just for the sake of example, because bobince is right; this wouldn't have worked in general.</span>
<span class="comment-copy">I know about JSON but I need the serialization just for configuration. I have a complex configuration dictionary consisting of classes and datetime instances containing sensitive data which I need to transfer to Travis CI environment. I don't care about performance in this case.</span>
<span class="comment-copy">@PeterHudec: "Just for configuration" is exactly the kind of thing JSON or YAML is good for. It's easy to debug, human-editable, and extensible enough without being infinitely extensible.</span>
