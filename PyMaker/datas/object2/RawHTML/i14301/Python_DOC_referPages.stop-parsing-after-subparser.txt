<div class="post-text" itemprop="text">
<p>In my CLI script I am using argparse to take in a few optional arguments and then a positional argument. The positional argument is used to determine a subparser to use which in turn runs a function that calls an external program that takes its own arguments. So, the command-line usage looks something like this:</p>
<pre><code>myscript [OPTIONS] subcommand [SUBCOMMAND_OPTIONS]
</code></pre>
<p>Now my problem is that there are conflicts between my OPTIONS I've declared and the SUBCOMMAND_OPTIONS declared in the external program. The easy fix is to ensure I rename all conflicts in myscript but I can't do this for all options - most notably the "-h" option for help. Ideally I'd like argparse to stop parsing immediately after it encounters the subcommand and simply pass on the rest of the args to the external program.</p>
<p>So, the following invocation should show the help text for myscript:</p>
<pre><code>myscript -h
</code></pre>
<p>While, in contrast the following should show the help text from the external program invoked by the "bar" subparser:</p>
<pre><code>myscript --foo bar -h
</code></pre>
<p>Some more code to make the above clearer:</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--foo', action='store_true')
&gt;&gt;&gt; subparsers = parser.add_subparsers()
&gt;&gt;&gt; subparsers.add_parser("bar")

&gt;&gt;&gt; parser.parse_known_args("--foo bar --test".split())
(Namespace(foo=True), ['--test'])
# cool - this is what I want, I'll just pass --test on to the external program

&gt;&gt;&gt; parser.parse_known_args("--foo bar -h".split())
usage:  bar [-h]

optional arguments:
  -h, --help  show this help message and exit

# unfortunately the above argparse help message is NOT what I wanted, instead I was looking for the result below:
(Namespace(foo=True), ['-h'])

&gt;&gt;&gt; parser.parse_known_args("bar --test -- -h".split())
# this works, sort of, it requires educating the end-user to use the '--' parameter and I'd like to avoid that if possible.
(Namespace(foo=False), ['--test', '--', '-h'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your initial description was sufficiently close to subparsers that it takes some careful reading to identify what's wrong (for you).</p>
<p>From comments it sounds like the biggest fault is that the subparser captures the <code>-h</code> give you a help message, rather than passing it through to the <code>extras</code>.  Subparsers, just like a main parser, takes a <code>add_help=False</code> parameter.</p>
<pre><code>p=argparse.ArgumentParser()
p.add_argument('foo')
p.add_argument('--bar')
sp=p.add_subparsers(dest='cmd')
sp1=sp.add_parser('cmd1')   # with a subparser help
sp2=sp.add_parser('cmd2', add_help=False)  # will ignore -h
</code></pre>
<p>producing</p>
<pre><code>p.parse_known_args('-h'.split())   # top level help

p.parse_known_args('--bar xxx foo cmd1 -h'.split())
# usage: ipython foo cmd1 [-h]
# exit msg

p.parse_known_args('--bar xxx foo cmd2 -h'.split())
# (Namespace(bar='xxx', cmd='cmd2', foo='foo'), ['-h'])

p.parse_known_args('foo cmd2 test -o --more --bar xxx'.split())
# (Namespace(bar=None, cmd='cmd2', foo='foo'),
# ['test', '-o', '--more', '--bar', 'xxx'])
</code></pre>
<p>In a comment I mentioned a couple of <code>nargs</code> values, <code>argparse.PARSER</code> and <code>argparse.REMAINDER</code>.  To the main parser, subparsers are just a positional with a <code>PARSER</code> nargs (and <code>choices).  It's a special</code>action` type, which goes on to invoke another parser based on the 1st value.</p>
<p><code>REMAINDER</code> is like the <code>*</code> nargs, except that it takes everything, even strings that look like flags.  <code>PARSER</code> is like <code>+</code>, requiring at least one string.  </p>
<pre><code>p=argparse.ArgumentParser()
p.add_argument('foo')
p.add_argument('--bar')
p.add_argument('rest', nargs=argparse.REMAINDER)
</code></pre>
<p>producing</p>
<pre><code>In [32]: p.parse_args('--bar yyy foo'.split())
Out[32]: Namespace(bar='yyy', foo='foo', rest=[])

In [33]: p.parse_args('--bar yyy foo -h'.split())
Out[33]: Namespace(bar='yyy', foo='foo', rest=['-h'])

In [34]: p.parse_args('--bar yyy foo cmd2 test -o --more --bar xxx'.split())Out[34]: Namespace(bar='yyy', foo='foo', rest=['cmd2', 'test', '-o', '--more', '--bar', 'xxx'])
</code></pre>
<p>The <code>REMAINDER</code> note in the argparse docs is:</p>
<blockquote>
<p>argparse.REMAINDER. All the remaining command-line arguments are gathered into a list. This is commonly useful for command line utilities that dispatch to other command line utilities:</p>
</blockquote>
<p>and has an example similar to my last one.</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG')
&gt;&gt;&gt; parser.add_argument('--foo')
&gt;&gt;&gt; parser.add_argument('command')
&gt;&gt;&gt; parser.add_argument('args', nargs=argparse.REMAINDER)
&gt;&gt;&gt; print(parser.parse_args('--foo B cmd --arg1 XX ZZ'.split()))
Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The normal <a href="https://docs.python.org/3/library/argparse.html#sub-commands" rel="nofollow">sub-commands support in <code>argparse</code></a> does this just fine. Just note that when reusing argument names, you should specify a custom <a href="https://docs.python.org/3/library/argparse.html#dest" rel="nofollow"><code>dest</code></a> to make sure that your main commandsâ€™ values are not overwritten:</p>
<pre><code>parser = argparse.ArgumentParser()
parser.add_argument('--foo', action='store_true')
subparsers = parser.add_subparsers()

parser_foo = subparsers.add_parser('foo')
parser_foo.add_argument('--foo', dest='foo_foo')
parser_foo.add_argument('--bar', dest='foo_bar')

parser_bar = subparsers.add_parser('bar')
parser_bar.add_argument('--foo', dest='bar_foo')
</code></pre>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; parser.parse_args('-h'.split())
usage: [-h] [--foo] {foo,bar} ...

positional arguments:
  {foo,bar}

optional arguments:
  -h, --help  show this help message and exit
  --foo

&gt;&gt;&gt; parser.parse_args('foo -h'.split())
usage:  foo [-h] [--foo FOO_FOO] [--bar FOO_BAR]

optional arguments:
  -h, --help     show this help message and exit
  --foo FOO_FOO
  --bar FOO_BAR

&gt;&gt;&gt; parser.parse_args('bar -h'.split())
usage:  bar [-h] [--foo BAR_FOO]

optional arguments:
  -h, --help     show this help message and exit
  --foo BAR_FOO

&gt;&gt;&gt; parser.parse_args('--foo foo --foo test --bar baz'.split())
Namespace(foo=True, foo_bar='baz', foo_foo='test')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>arpgarse</code> module has a subparser feature, which you can combine with <code>argparse.REMAINDER</code> to capture any arguments without declaring those explicitly.</p>
<p>Update:</p>
<p>If you want to have more control than <code>argparse</code> provides, it might be worthwile to look into the <code>click</code> package instead. It has special support for ignoring unknown options and preventing options like <code>--help</code> to be handled. Details at</p>
<p><a href="http://click.pocoo.org/4/api/#click.Context.ignore_unknown_options" rel="nofollow">http://click.pocoo.org/4/api/#click.Context.ignore_unknown_options</a></p>
</div>
<span class="comment-copy">Have you tried the subparser mechanism in <code>argparse</code>?  The fit might not be perfect, but it might be most productive for all of us if you read the docs, try it, and then come back with some more questions.</span>
<span class="comment-copy">actually I explicitly mention the use of subparsers in my question above, so clearly I already know about it. The problem is not the ability to subparse the command it's the ability to stop parsing options after encountering the subcommand. And before you ask me - yes, I already am using argparse.parser_known_args() to stop argparse failing on the external commands arguments that it knows nothing about, the problem lies in the conflicting args - specifically.</span>
<span class="comment-copy"><code>--</code> tells it to treat everything that follows as arguments to a positional, whether they look like flags or not.  <code>nargs=argparse.PARSER</code> and <code>REMAINDEr</code> can also be used to grab 'everything else' for a positional.  The subparser mechanism uses <code>PARSER</code> to allocate arguments.  Play with these and see if they suit your needs better than the full subparser mechanism.</span>
<span class="comment-copy">Unfortunately not quite what I was asking. In my case I don't explicitly know all the args for the subcommand I just pass them on to the external program to interpret. I'll edit my question to make this a bit more clear.</span>
<span class="comment-copy">Unfortunately, no that doesn't work either. While it captures undeclared args it doesn't capture declared args like "-h" - so argparse will show the scripts help message if passed "-h" after the subcommand instead of passing the "-h" on to the external program</span>
<span class="comment-copy">I've updated my answer to mention <code>click</code> instead.</span>
