<div class="post-text" itemprop="text">
<p>This may sound a bit weird, but is it possible that Tornado completes executing a future after wrapping it in a timeout?</p>
<p>So something like this:</p>
<pre><code>try:
    result = yield gen.with_timeout(time.time() + 1, future)
except gen.TimeoutError as e:
    print('Timed out!')
</code></pre>
<p>So in this scenario, <code>future</code> does not complete before timeout but I want it continue executing whatever callable it has.</p>
<p>To put it in a different way, I want to be able to use this along with <a href="https://tornado.readthedocs.org/en/latest/gen.html#tornado.gen.WaitIterator" rel="nofollow"><code>gen.WaitIterator</code></a> to get results of a set of futures, like described in the document:</p>
<blockquote>
<p>If you need to get the result of each future as soon as possible, or if you need the result of some futures even if others produce errors, you can use <code>WaitIterator</code>.</p>
</blockquote>
<p>This is exactly what I'm looking for, I want result of each future ASAP because I have some tasks that take longer than others, but with one exception: those slow tasks should continue producing results so I can access them later.</p>
<p>Is this even possible?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>with_timeout</code> does not cancel the underlying <code>Future</code>, so it can be reused:</p>
<pre><code>future = do_something_async()
while True:
    try:
        result = yield gen.with_timeout(timedelta(seconds=1), future)
        break
    except gen.TimeoutError:
        print('tick')
</code></pre>
<p>Combining this with <code>WaitIterator</code> is a little tricky since you must not call <code>WaitIterator.next</code> again until the previous one completes. </p>
<p>Also consider the Queue classes introduced in Tornado 4.2. These can often produce cleaner code than WaitIterator (and they have built-in timeout support instead of a <code>with_timeout</code> wrapper).</p>
</div>
<span class="comment-copy">I guess I can use <code>Queue</code> class to aggregate results from different web services... Typically, I want to be able to collect results from different web services (some slow, some faster) and wait for all the results for a particular time. Should I be looking into Queue example (web spider) in the docs?  Also, would it be possible to <code>concurrent.futures.ThreadPoolExecutor</code> instead? (since it also has <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.wait" rel="nofollow noreferrer"><code>concurrent.futures.wait</code></a>)</span>
<span class="comment-copy">Yeah, the webspider demo is the best example of queue usage we have. Just put the result of each fetch on a queue and read them off in the "main" task. You can't use AsyncHTTPClient with a ThreadPoolExecutor (you could use a synchronous HTTP client but that would be more expensive than the non-threaded way).</span>
