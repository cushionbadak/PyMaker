<div class="post-text" itemprop="text">
<p>I am doing some exercises with datasets like so:</p>
<p><strong>List with many dictionaries</strong></p>
<pre><code>users = [
    {"id": 0, "name": "Ashley"},
    {"id": 1, "name": "Ben"},
    {"id": 2, "name": "Conrad"},
    {"id": 3, "name": "Doug"},
    {"id": 4, "name": "Evin"},
    {"id": 5, "name": "Florian"},
    {"id": 6, "name": "Gerald"}
]
</code></pre>
<p><strong>Dictionary with few lists</strong></p>
<pre><code>users2 = {
    "id": [0, 1, 2, 3, 4, 5, 6],
    "name": ["Ashley", "Ben", "Conrad", "Doug","Evin", "Florian", "Gerald"]
}
</code></pre>
<p><strong>Pandas dataframes</strong></p>
<pre><code>import pandas as pd
pd_users = pd.DataFrame(users)
pd_users2 = pd.DataFrame(users2)
print pd_users == pd_users2
</code></pre>
<p>Questions: </p>
<ol>
<li>Should I structure the datasets like users or like users2?</li>
<li>Are there performance differences?</li>
<li>Is one more readable than the other?</li>
<li>Is there a standard I should follow? </li>
<li>I usually convert these to pandas dataframes. When I do that, both versions are identical... right? </li>
<li>The output is true for each element so it doesn't matter if I work with panda df's right?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>This relates to <a href="https://en.wikipedia.org/wiki/Column-oriented_DBMS">column oriented databases</a> versus row oriented. Your first example is a row oriented data structure, and the second is column oriented. In the particular case of Python, the first could be made notably more efficient using <a href="https://docs.python.org/3/reference/datamodel.html#slots">slots</a>, such that the dictionary of columns doesn't need to be duplicated for every row. </p>
<p>Which form works better depends a lot on what you do with the data; for instance, row oriented is natural if you only ever access all of any row. Column oriented meanwhile makes much better use of caches and such when you're searching by a particular field (in Python, this may be reduced by the heavy use of references; types like <a href="https://docs.python.org/3/library/array.html">array</a> can optimize that). Traditional row oriented databases frequently use column oriented sorted indices to speed up lookups, and knowing these techniques you can implement any combination using a key-value store. </p>
<p>Pandas does convert both your examples to the same format, but the conversion itself is more expensive for the row oriented structure, simply because every individual dictionary must be read. All of these costs may be marginal. </p>
<p>There's a third option not evident in your example: In this case, you only have two columns, one of which is an integer ID in a contiguous range from 0. This can be stored in the order of the entries itself, meaning the entire structure would be found in the list you've called <code>users2['name']</code>; but notably, the entries are incomplete without their position. The list translates into rows using enumerate(). It is common for databases to have this special case also (for instance, sqlite <a href="https://www.sqlite.org/lang_createtable.html#rowid">rowid</a>). </p>
<p>In general, start with a data structure that keeps your code sensible, and optimize only when you know your use cases and have a measurable performance issue. Tools like Pandas probably means most projects will function just fine without finetuning. </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Users</strong> </p>
<ol>
<li><p>When you need to append some new user just make a new <code>dict</code> of all user details and append it</p></li>
<li><p>Easily sortable as @StevenRumbalski suggested</p></li>
<li><p>Searching will be easy</p></li>
<li><p>This is more compact and easily manageable as record grows (for some very high number of records I think we will need something better than users too)</p></li>
</ol>
<p><strong>Users2</strong></p>
<ol>
<li>Personally I am seeing this for the first time and I wouldn't approach this if I have a high number of records.</li>
</ol>
<p>PS: But I would like to learn advantages of <code>users2</code> over <code>users</code>
    Again a nice question</p>
</div>
<div class="post-text" itemprop="text">
<p>Time complexity for the lookups in - </p>
<ul>
<li>List - O(n)</li>
<li>Dicts - O(1)</li>
</ul>
<p>But that wouldn't hurt much if your data isn't that big and also modern day processors are quite efficient.
<br/>
You should go with the one in which the lookup is syntactically cleaner and readable(readability matters).<br/>
The first option is quite appropriate as the variable is a collection of users(which have been assigned an id) while the second would be just a collection of usernames and ids.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>users</code> in general sense is actually a collection of <code>user</code> elements. So it's better to define the <code>user</code> element as a standalone entity. So your first option is the right one.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some answers regarding the pandas aspect:</p>
<ol>
<li>Both dataframes are indeed the same and are column oriented, which is good, because pandas works best when data in each column is homogeneous (i.e. numbers can be stored as ints and floats).  A key reason for using pandas in the first place is that you can do vectorized numerical operations that are orders of magnitude faster than pure python -- but this relies on columnar organization when data is of heterogeneous type.</li>
<li>You could do <code>pd_users.T</code> to transpose, if you wanted to, and would then see (via <code>info()</code> or <code>dtypes</code>) that everything is then stored as a general purpose object because the column contains both strings and numbers.</li>
<li>Once converted, you can do <code>pd_users.set_index('id')</code> so that your dataframe is essentially a dictionary with <code>id</code> as the keys.  Or vice versa with <code>name</code>.</li>
<li>It's pretty common (and generally pretty fast) to change indexes, then change them back, transpose, subset, etc. when working with pandas so it's usually not necessary to think too much about the structure at the beginning.  Just change it as you need to on the fly.</li>
<li>This may be getting off on a tangent, but the a simpler pandas analog of what you have above may be a <code>Series</code> rather than <code>DataFrame</code>.  A series is essentially a column of a dataframe though it really is just a one-dimensional data array with an index ("keys").</li>
</ol>
<p>Quick demo (using <code>df</code> as the dataframe name, the common convention):</p>
<pre><code>&gt;&gt;&gt; df.set_index('name')

         id
name       
Ashley    0
Ben       1
Conrad    2
Doug      3
Evin      4
Florian   5
Gerald    6

&gt;&gt;&gt; df.set_index('name').T

name  Ashley  Ben  Conrad  Doug  Evin  Florian  Gerald
id         0    1       2     3     4        5       6

&gt;&gt;&gt; df.set_index('name').loc['Doug']

id    3
Name: Doug, dtype: int64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First option of list of dictionaries will be much better for quite few reasons. List does provides methods such as EXTEND, APPENT, PUSH which are not readily available with dictionaries. </p>
</div>
<span class="comment-copy">Nice questions I will go with the first option because I recon searching and insertion will be less tedious as compared with the second one</span>
<span class="comment-copy">I would go with the first one as long as convenience of use is the most important aspect. Having the ID together with the NAME will be handy when moving things around.</span>
<span class="comment-copy">The first version is easily sortable where the second is not.</span>
<span class="comment-copy">An example of using <code>slots</code> to save memory: <a href="http://tech.oyster.com/save-ram-with-python-slots/" rel="nofollow noreferrer">tech.oyster.com/save-ram-with-python-slots</a></span>
<span class="comment-copy">"You should go with the one in which the lookup is syntactically cleaner and readable" +1. But I don't think time complexity matters as we don't know how he is accessing that data.</span>
<span class="comment-copy">Hey! You mentioned that both data frames are column oriented. The most upvoted answer right now suggest one is column and the other is row. Can you confirm?</span>
<span class="comment-copy">I believe @YannVernier is only referring to the case <i>before</i> converting to pandas.  You already proved they are the same yourself with <code>pd_users == pd_users2</code>.  But you could do <code>pd_users == pd_users2.T</code> (put a transpose on either one) to further verify.  It will raise an exception because the the two dataframes no longer conform.  Aside from checking for equality, just printing the dataframe shows how pandas is structuring data in terms of rows and columns.</span>
<span class="comment-copy">Ah ok that makes sense. Thanks for clarifying.</span>
