<div class="post-text" itemprop="text">
<p>I'm trying to write a program to look for a number, n, between 0 and 100 such that n! + 1 is a perfect square. I'm trying to do this because I know there are only three so it was meant as a test of my Python ability - I failed because I really can't do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>For very large numbers it's better to avoid using floating point square roots altogether because you will run into too many precision issues and you can't even guarantee that you will be within 1 integer value of the correct answer. Fortunately Python natively supports integers of arbitrary size, so you can write an integer square root checking function, like this:</p>
<pre><code>def isSquare(x):
    if x == 1:
        return True
    low = 0
    high = x // 2
    root = high
    while root * root != x:
       root = (low + high) // 2
       if low + 1 &gt;= high:
          return False
       if root * root &gt; x:
          high = root
       else:
          low = root
    return True
</code></pre>
<p>Then you can run through the integers from 0 to 100 like this:</p>
<pre><code>n = 0
while n &lt;= 100:
    x = math.factorial(n) + 1
    if isSquare(x):
        print n
    n = n + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/math.html#math.sqrt" rel="nofollow"><code>math.sqrt</code></a> always returns a <code>float</code>, even if that float happens to be, say, <code>4.0</code>. As the docs say, "Except when explicitly noted otherwise, all return values are floats."</p>
<p>So, your test for <code>type(math.sqrt(x)) == int</code> will never be true.</p>
<p>You could try to work around that by checking whether the float represents an integer, like this:</p>
<pre><code>sx = math.sqrt(x)
if round(sx) == sx:
</code></pre>
<p>There's even <a href="https://docs.python.org/3/library/stdtypes.html#float.is_integer" rel="nofollow">a built-in method</a> that does this as well as possible:</p>
<pre><code>if sx.is_integer():
</code></pre>
<p>But keep in mind that <code>float</code> values are not a perfect representation of real numbers, and there are always rounding issues. For example, for a too-large number, the <code>sqrt</code> might <em>round</em> to an integer, even though it really wasn't a perfect square. For example, if <code>math.sqrt(10000000000**2 + 1).is_integer()</code> is <code>True</code>, even though obviously the number is not a perfect square.</p>
<p>I could tell you whether this is safe within your range of values, but can you convince yourself? If not, you shouldn't just assume that it is.</p>
<p>So, is there a way we can check that isn't affected by <code>float</code> roading issues? Sure, we can use integer arithmetic to check:</p>
<pre><code>sx = int(round(math.sqrt(x)))
if sx*sx == x:
</code></pre>
<p>But, as Stefan Pochmann points out, even if this check is safe, does that mean the whole algorithm is? No; <code>sqrt</code> itself could have already been rounded to the point where you've lost integer precision.</p>
<p>So, you need an exact <code>sqrt</code>. You <em>could</em> do this by using <code>decimal.Decimal</code> with a huge configured precision. This will take a bit of work, and a lot of memory, but it's doable. Like this:</p>
<pre><code>decimal.getcontext().prec = ENOUGH_DIGITS
sx = decimal.Decimal(x).sqrt()
</code></pre>
<p>But how many digits is <code>ENOUGH_DIGITS</code>? Well, how many digits do you need to represent <code>100!+1</code> exactly?</p>
<p>So:</p>
<pre><code>decimal.getcontext().prec = 156
while n &lt;= 100:
    x = math.factorial(n) + 1
    sx = decimal.Decimal(x).sqrt()
    if int(sx) ** 2 == x:
        print(sx)
    n = n + 1
</code></pre>
<p>If you think about it, there's a way to reduce the needed precision to 79 digits, but I'll leave that as an exercise for the reader.</p>
<hr/>
<p>The way you're presumably <em>supposed</em> to solve this is by using purely integer math. For example, you can find out whether an integer is a square in logarithmic time just by using <a href="http://en.wikipedia.org/wiki/Newton%27s_method" rel="nofollow">Newton's method</a> until your approximation error is small enough to just check the two bordering integers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another version working only with integers, computing the square root by adding decreasing powers of 2, for example <code>intsqrt(24680)</code> will be computed as 128+16+8+4+1.</p>
<pre><code> def intsqrt(n):
    pow2 = 1
    while pow2 &lt; n:
        pow2 *= 2
    sqrt = 0
    while pow2:
        if (sqrt + pow2) ** 2 &lt;= n:
            sqrt += pow2
        pow2 //= 2
    return sqrt

factorial = 1
for n in range(1, 101):
    factorial *= n
    if intsqrt(factorial + 1) ** 2 == factorial + 1:
        print(n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The number math.sqrt returns is never an int, even if it's an integer.<a href="https://stackoverflow.com/questions/21583758/how-to-check-if-a-float-value-is-a-whole-number">How to check if a float value is a whole number</a></p>
</div>
<span class="comment-copy">Why have you failed? What error(s) or problem(s) have you encountered?</span>
<span class="comment-copy">This is a very interesting open problem in number theory: <a href="http://en.wikipedia.org/wiki/Brocard%27s_problem" rel="nofollow noreferrer">en.wikipedia.org/wiki/Brocard%27s_problem</a>    It doesn't look like there are any elegant shortcuts, so a brute force search for n in [0,100] is probably the best you can hope for.  But it's important to use arbitrary precision integer math, rather than floating point, as several of the answers point out.</span>
<span class="comment-copy">I'm playing with <code>decimal</code>'s <code>sqrt</code> and trying to solve your exercise, but have a problem. Why does it tell me that floor(sqrt(8)) is 3? <code>from decimal import *; getcontext().prec = 1; getcontext().rounding = ROUND_FLOOR; Decimal(8).sqrt()</code></span>
<span class="comment-copy">@StefanPochmann: Interesting. You'd have to look at how it's implemented (and/or run some other tests—does it give you the sqrt of <code>1.20</code> as <code>1.10</code> with <code>prec=3</code>?), and then look at how IEEE 854 actually defines <code>sqrt</code> to make sure it doesn't require using this method or something equivalent. But it definitely smells like a bug. (Of course that won't affect this case, because <code>int(3) ** 2 == 8</code> will be false.)</span>
<span class="comment-copy">@StefanPochmann: P.S., do you know where to find the last draft (free) standard of IEEE 854 since 754 and 854 were merged in 2008? (I can find a copy of the final standard, but that's presumably a copyright violation and I wouldn't want to link to it…)</span>
<span class="comment-copy">@StefanPochmann: Got it. <a href="http://bugs.python.org/issue1388949" rel="nofollow noreferrer">#1388949</a> was closed because <code>sqrt</code> is explicitly defined to round to half-even, as required by IBM's <a href="http://speleotrove.com/decimal/daops.html#refsqrt" rel="nofollow noreferrer">General Decimal Arithmetic Specification</a>. Apparently the <code>decimal</code> module follows this as its primary definition, not IEEE 854-1987 (which says in section 4 "… every operation specified in Section 5. shall be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded…").</span>
<span class="comment-copy">Yes, I just saw #1388949 and some others as well, thanks. I'm just still displeased that <a href="https://docs.python.org/3.4/library/decimal.html#decimal.Decimal.sqrt" rel="nofollow noreferrer">the documentation for sqrt</a> doesn't mention that it ignores the rounding setting (it just says "Return the square root of the argument to full precision.").</span>
<span class="comment-copy">Why doesn't it return as an integer type when it is an integer?</span>
<span class="comment-copy">@PythonNewbie, an int and an integer aren't the same thing. The former is just one way of representing the latter. Floats can also accurately represent integers, and it's simpler and more consistent for the square root function to always return the same type.</span>
