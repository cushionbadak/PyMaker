<div class="post-text" itemprop="text">
<p>Is there an option I can pass open() that will cause an IOerror when trying to write a nonexistent file? I am using python to read and write block devices via symlinks, and if the link is missing I want to raise an error rather than create a regular file. I know I could add a check to see if the file exists and manually raise the error, but would prefer to use something built-in if it exists.</p>
<p>Current code looks like this:</p>
<pre><code>device = open(device_path, 'wb', 0)
device.write(data)
device.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes.    </p>
<pre><code>open(path, 'r+b')
</code></pre>
<p>Specifying the "r" option means the file must exist and you can read.
Specifying "+" means you can write and that you will be positioned at the end.
<a href="https://docs.python.org/3/library/functions.html?#open" rel="nofollow">https://docs.python.org/3/library/functions.html?#open</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/2/library/os.path.html#os.path.islink" rel="nofollow"><code>os.path.islink()</code></a> or <a href="https://docs.python.org/2/library/os.path.html#os.path.isfile" rel="nofollow"><code>os.path.isfile()</code></a> to check if the file exists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Doing the check each time is a nuisance, but you can always wrap <code>open()</code>:</p>
<pre><code>import os

def open_if_exists(*args, **kwargs):
    if not os.path.exists(args[0]):
        raise IOError('{:s} does not exist.'.format(args[0]))
    f = open(*args, **kwargs)
    return f

f = open_if_exists(r'file_does_not_exist.txt', 'w+')
</code></pre>
<p>This is just quick and dirty, so it doesn't allow for usage as: <code>with open_if_exists(...)</code>.</p>
<h1>Update</h1>
<p>The lack of a context manager was bothering me, so here goes:</p>
<pre><code>import os
from contextlib import contextmanager

@contextmanager
def open_if_exists(*args, **kwargs):
    if not os.path.exists(args[0]):
        raise IOError('{:s} does not exist.'.format(args[0]))
    f = open(*args, **kwargs)
    try:
        yield f
    finally:
        f.close()

with open_if_exists(r'file_does_not_exist.txt', 'w+') as f:
    print('foo', file=f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am afraid  you can't perform the check of file existence and raise error using the <code>open()</code> function. </p>
<p>Below is the signature of <code>open()</code> in python where <code>name</code> is the file_name, <code>mode</code> is the access mode and <code>buffering</code> to indicate if buffering is to be performed while accessing a file. </p>
<blockquote>
<p>open(name[, mode[, buffering]])</p>
</blockquote>
<p>Instead, you can check if the file exists or not.</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.isfile(file_name)
</code></pre>
<p>This will return <code>True</code> or <code>False</code> depending on if the file exists. To test a file specifically, you can use this.</p>
<p>To test the existence of  both files and directories, you can use:</p>
<pre><code>&gt;&gt;&gt; os.path.exists(file_path)
</code></pre>
</div>
<span class="comment-copy">I'm not aware of any built-in method to do this in one step, no.</span>
<span class="comment-copy">You can use <code>os.path.isfile()</code> to check though</span>
<span class="comment-copy">What you could do is opening the file in <code>w+</code> mode and see if there's any data in the file already.</span>
<span class="comment-copy">well checking the return of open is pretty much a 'builtin' solution...</span>
<span class="comment-copy">The problem here is that a file is created, and the symlink can't be added back if udev is trying to do that in the background.</span>
<span class="comment-copy">This in combination with seek(0) got me what I wanted!</span>
<span class="comment-copy">Also, I ended up needing to be a symlink, so I now use the os.path.islink function before opening the file.</span>
<span class="comment-copy">Nice! I thought you missed my answer. The responses just repeating what you said in your question was frustrating.</span>
<span class="comment-copy">Yes, I was just hoping there was a one step command.</span>
