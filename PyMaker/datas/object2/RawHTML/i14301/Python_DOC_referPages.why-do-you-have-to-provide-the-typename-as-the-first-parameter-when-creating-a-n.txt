<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/30282137/python-syntax-for-namedtuple">Python syntax for namedtuple</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>In the collections.namedtuple() constructor, the first parameter is the name of the type that you want to create, but as far as I can tell, it's irrelevant aside from diagnostic messages.</p>
<pre><code>from collections import namedtuple
Point = namedtuple('Point', 'x y')
p = Point(1,2)   # works fine, creates Point(x=1, y=2)

Point = namedtuple('blah', 'x y')
p = Point(2,3)   # works fine, creates blah(x=1,y=2)
</code></pre>
<p>Is this just a necessary item that the programmer should keep consistent for diagnostic purposes because there'd be no way for Python to learn the name of the variable you're assigning the namedtuple to?  Seems error-prone, but I can see how it'd be necessary.  Just wondering if there are any other reasons or repercussions of mismatching these two names.</p>
</div>
<div class="post-text" itemprop="text">
<p>Named tuples are implemented in a kind-of dirty way. There is a template string that has a few placeholders, and when you call <code>namedtuple()</code> what happens is actually that those placeholders are replaced by the arguments and the template is <code>eval</code>’d. This implementation seems really dirty (since it uses eval) but is really simple and powerful.</p>
<p>The downside is that there is an actual need for a class name because one of the first lines is actually this: <code>class {typename}(tuple):</code>. So you do need to specify a type name for it to work.</p>
<p>As for the value of that name, it does not matter much but as you said yourself, for debugging purposes, it’s useful to choose the same name you also use for the variable that holds the type. Otherwise, the whole thing wouldn’t be much different to this:</p>
<pre><code>class CustomType:
    …

# assign a new name, and never talk about CustomType again
NewName = CustomType
</code></pre>
</div>
<span class="comment-copy">"never talk about CustomType again". Or, for that matter, <code>del CustomType</code>. It's easy to forget that <code>def</code> and <code>class</code> in Python don't create any inherent connection between the name of the object they create (i.e. the function or class), and the name of the attribute/variable they assign it to. They use the same name for both, which <code>collections.namedtuple</code> can't do because it's just a function call and not a language builtin, so it can't "see" the assignment. Indeed, there might not be an assignment, you can just write <code>namedtuple('Foo', 'x')(1)</code></span>
<span class="comment-copy">It's also worth comparing <code>namedtuple</code> to the 3-argument form of <code>type</code>, which also takes the name of the class it creates as its first argument. (<code>namedtuple</code> could probably be reimplemented to use <code>type</code>, in fact, instead of exec'ing a class statement.)</span>
<span class="comment-copy">One could argue that it would be worse to use <code>type</code> because of the inability to create a <a href="https://docs.python.org/3/library/collections.html#collections.somenamedtuple._source" rel="nofollow noreferrer"><code>_source</code></a> for the namedtuple.</span>
