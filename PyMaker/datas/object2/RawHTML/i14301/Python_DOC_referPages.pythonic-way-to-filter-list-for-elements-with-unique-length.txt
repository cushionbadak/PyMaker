<div class="post-text" itemprop="text">
<p>I want to filter a list, leaving only first elements with unique length.
I wrote a function for it, but I believe there should be a simpler way of doing it:</p>
<pre><code>def uniq_len(_list):
    from itertools import groupby
    uniq_lens = list(set([x for x, g in groupby(_list, len)]))
    all_goods = []
    for elem in _list:
        elem_len = len(elem)
        try:
            good = uniq_lens.pop([i for i, x in enumerate(uniq_lens) if x==elem_len][0])
            if good:
                all_goods.append(elem)
        except IndexError as _e:
            #print all_goods
            pass
    return all_goods

In [97]: jones
Out[97]: ['bob', 'james', 'jim', 'jon', 'bill', 'susie', 'jamie']

In [98]: uniq_len(jones)
Out[98]: ['bob', 'james', 'bill']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want any arbitrary string for each length, in arbitrary order, the easy way to do this is to first convert to a dict mapping lengths to strings, then just read off the values:</p>
<pre><code>&gt;&gt;&gt; {len(s): s for s in jones}.values()
dict_values(['jon', 'bill', 'jamie'])
</code></pre>
<p>If you want the <em>first</em> for each length, and you need to preserve the order, then that's just <code>unique_everseen</code> from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer"><code>itertools</code> recipes</a>, with <code>len</code> as the key:</p>
<pre><code>&gt;&gt;&gt; from more_itertools import unique_everseen
&gt;&gt;&gt; list(unique_everseen(lst, key=len))
['bob', 'james', 'bill']
</code></pre>
<p>(If you <a href="https://pypi.python.org/pypi/more-itertools" rel="noreferrer"><code>pip install more-itertools</code></a>, it includes all of the recipes from the <code>itertools</code> docs, plus a bunch of other helpful things.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Getting the first item of the list with unique length (not necessarily in the same order as they appear in the list).</p>
<pre><code>&gt;&gt;&gt; lst = ['bob', 'james', 'jim', 'jon', 'bill', 'susie', 'jamie']
&gt;&gt;&gt; list({len(x): x for x in reversed(lst)}.values())
['bob', 'bill', 'james']
</code></pre>
<p>Respecting the order of the original list, you can use an auxiliary set:</p>
<pre><code>&gt;&gt;&gt; seen = set()
&gt;&gt;&gt; [x for x in lst if len(x) not in seen and seen.add(len(x)) is None]
['bob', 'james', 'bill']
</code></pre>
<p>For the above expression to work properly in succession, you have to make sure you reset <code>seen</code> to an empty set each time.</p>
</div>
<div class="post-text" itemprop="text">
<p>A not very elegant way would be:</p>
<pre><code>&gt;&gt;&gt; mylist = ['bob', 'james', 'jim', 'jon', 'bill', 'susie', 'jamie']
&gt;&gt;&gt; filtered = []
&gt;&gt;&gt; [filtered.append(x) for x in mylist if len(x) not in [len(y) for y in filtered]]
[None, None, None]
&gt;&gt;&gt; print(filtered)
['bob', 'james', 'bill']
</code></pre>
<p>As you can see the, interpreter prints <code>[None, None, None]</code> because the line where we <code>append</code> to <code>filtered</code> actually produces a list of None values (the <code>append</code> method always returns None), which is then discarded. But that line has the side effect of populating <code>filtered</code> with the right values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple way, using just built-ins:</p>
<pre><code>reduce(
         lambda o1, o2: o1 if o1 and len(o1[-1]) == len(o2) else o1 + [o2], 
         sorted(
                  orig, 
                  key=lambda o: len(o)
         ), 
         []
)
</code></pre>
<p>This will give you <code>O(n * log(n))</code> complexity.</p>
<p>As the <code>sorted</code> is stable, the ordering between equal-length strings will be the same as it was before sorting. Then the <code>reduce</code> function will leave only the first occurrence from each length.</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions are a good way to make your code more pythonic. Here's a good explanation of how they work: <a href="http://www.secnetix.de/olli/Python/list_comprehensions.hawk" rel="nofollow"> List Comprehensions. </a></p>
<p>So an example for how to do the above might be something like:</p>
<pre><code>from itertools import groupby

def filterUniqueLenghts(myList):
    lengths = {k:len(list(v)) for k,v in groupby(myList, lambda a: len(a))}
    return [e for e in myList if lengths[len(e)] == 1]

a = ['hello', 'hello', 'goodbye']
print(filterUniqueLenghts(a))

# prints ['goodbye']
</code></pre>
</div>
<span class="comment-copy">Do you want the <i>first</i> string with each length, in original order? Or just any string for each length in any order?</span>
<span class="comment-copy">wow, thats exactly I was looking for! and the reason for loving python more and more each day</span>
<span class="comment-copy">@abarnert Damn that's some sexy Python...</span>
<span class="comment-copy">Do you have read another answers?</span>
<span class="comment-copy">@Kasra I have. Why?</span>
<span class="comment-copy">Because it's less efficient than accepted answer!</span>
<span class="comment-copy">@Kasra Perhaps it is, but I was aiming for correctness in my answer. OP asked <i>I want to filter a list, leaving only <b>first</b> elements with unique length.</i> So I iterate in reverse with my snippet while the accepted answer does not. I didn't read the accepted answer before finishing mine if that's what you're thinking. I also include a list comprehension with an auxiliary set, which I don't see in any other answer.</span>
<span class="comment-copy">@Shashank: I was saying it's worth having around, precisely <i>because</i> it does the same thing as the recipe, but more obviously. Someone who reads both and tries to compare the two will learn something useful. (I doubt efficiency matters here at all.)</span>
<span class="comment-copy">Quadratic time, overly complicated, and abuses a listcomp for side effects… you did say "not very elegant", but why even show this?</span>
<span class="comment-copy">That is correct, it has (unnecessary) quadratic time, and it is not good code. I thought the OP wanted to achieve the shortest possible solution.</span>
<span class="comment-copy">He asked for "pythonic way" in the title, and "simpler" in the description; nowhere did he say that this was code golf…</span>
<span class="comment-copy">Anyway the @abarnert's answer is <i>O(n)</i> (for loop in a dict comprehension ) and another operations are O(1) because dictionaries use hash table for storing their items.</span>
<span class="comment-copy">sure, agree! :)</span>
<span class="comment-copy">It's worth noting that my answer is only <i>really</i> <code>O(n)</code> if you can either trust the user not to give you malicious data, or trust Python 3.3+ hash randomization; otherwise, it's possible to craft input that will make it <code>O(n^2)</code>; when you're worried about that as a DoS and can't figure out how to solve it, falling back to a sorting-based (or skiplist-based, etc.) <code>O(nlogn)</code> solution is worth knowing how to do…</span>
<span class="comment-copy">well, your comment quite objective :)</span>
<span class="comment-copy">This doesn't answer the same question he asked. The title is ambiguous, but if you look at the description and expected output, it's clear that he wants one name for each length, not one name for each length that only appears once.</span>
<span class="comment-copy">You are correct, my bad - too much of a hasty read.</span>
