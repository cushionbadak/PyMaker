<div class="post-text" itemprop="text">
<p>I am building an application in python that uses a wrap to a library that performs hardware communication </p>
<p>I would like to create some test units and I am pretty new to unit tests, so I would like to mock the communications but I really don't know how to do it</p>
<p>quick example:</p>
<p>this is the application code using the comm lib</p>
<pre><code>def changeValue(id, val):
    current_value = comm.getval(id)
    if (current_value != val):
        comm.send(id, val)
</code></pre>
<p>I want to test this without performing communications, i.e. replacing the comm.getval return by some mocked value, and sending comm.send to a mocked comm class.</p>
<p>Can anyone give a hint on that?</p>
<hr/>
<p>The thing is that comm is a object inside a class</p>
<p>let's say the class is like this:</p>
<pre><code>class myClass:
    comm = Comm()
    ....
    def __init__():
        comm = comm.start()

    def changeValue(id, val):
        ....

    ....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock" rel="nofollow"><code>mock</code></a> framework to this kind of jobs. First of all you use 
<code>comm = Comm()</code> in <code>MyClass</code> and that means you have something like <code>from comm_module import Comm</code> in <code>MyClass</code>'s module. In these cases you need to patch <code>Comm</code> reference in <code>MyClass</code>'s module to make your patch active.</p>
<p>So an example of how you can test your code without do any connection could be:</p>
<pre><code>@patch("my_class.Comm", autospec=True)
def test_base(self, mock_comm_factory):
    mock_comm = mock_comm_factory.return_value
    MyClass()
    mock_comm.start.assert_called_with()

@patch("my_class.Comm", autospec=True)
def test_changeValue(self, mock_comm_factory):
    mock_comm = mock_comm_factory.return_value
    mock_comm.getval.return_value = 13
    MyClass().changeValue(33, 23)
    mock_comm.getval.assert_called_with(33)
    mock_comm.send.assert_called_with(33, 23)
    mock_comm.reset_mock()
    mock_comm.getval.return_value = 23
    MyClass().changeValue(33, 23)
    mock_comm.getval.assert_called_with(33)
    self.assertFalse(mock_comm.send.called)
</code></pre>
<p>Now I can start to explain all details of my answer like why use <a href="https://docs.python.org/3/library/unittest.mock.html#autospeccing" rel="nofollow"><code>autospec=True</code></a> or <a href="https://docs.python.org/3/library/unittest.mock.html#test-prefix" rel="nofollow">how to apply patch to all methods</a> but that means to rewrite a lot of <code>mock</code> documentations and a SO answers. So I hope that is enough as starting point.</p>
</div>
<div class="post-text" itemprop="text">
<p>The trick is not to use global objects like <code>comm</code>. If you can, make it so that <code>comm</code> gets injected to your class or method by the caller. Then what you do is pass a mocked <code>comm</code> when testing and then real one when in production. </p>
<p>So either you make a <code>comm</code> reference a field in your class (and inject it via a constructor or setter method) like so</p>
<pre><code>class myClass:

  ....
  def __init__(myComm):
    comm = myComm;
    comm = comm.start()

  def changeValue(id, val):
    current_value = comm.getval(id)
    if (current_value != val):
      comm.send(id, val)

....
</code></pre>
<p>or you make it a parameter in the method where it is used, like so</p>
<pre><code>def changeValue(id, val, myComm):
current_value = myComm.getval(id)
if (current_value != val):
    myComm.send(id, val)
</code></pre>
<p>Using global <em>anything</em> makes mocking a huge pain, try to use <a href="https://stackoverflow.com/questions/130794/what-is-dependency-injection">Dependency Injection</a> whenever you need to mock something.</p>
<p>This is another good post about DI. It is in java, but it should be the same in python <a href="http://googletesting.blogspot.ca/2008/07/how-to-think-about-new-operator-with.html" rel="nofollow noreferrer">http://googletesting.blogspot.ca/2008/07/how-to-think-about-new-operator-with.html</a></p>
</div>
<span class="comment-copy">what is <code>comm</code>? some static library or an object?</span>
<span class="comment-copy">comm is a python object from an external module and I don't want to cover that on tests.  What I wanted to do is mock that object but I don't know how it can be done, I never used mockups before</span>
<span class="comment-copy">check my answer (I added an answer so the code snipped could be formatted)!</span>
<span class="comment-copy">i think it's better if you put your code snippet in the question itself. it might be useful for others to see the full class. But anyway, my point still stands. Instead of initializing <code>comm = Comm()</code>, receive <code>comm</code> in the constructor ( i guess <code>__init__</code> in python). that way when testing you inject a mock comm</span>
<span class="comment-copy">I edited the answer to show the case of injecting  <code>comm</code> in the class rather than passing it as a param in <code>changeValue</code></span>
