<div class="post-text" itemprop="text">
<p>I've been trying to solve this problem for a while. A M x N grid is given and we've to find number to paths from top left corner to bottom right corner. </p>
<p>Simple problem though; there are many solutions as well. Here're the details.
<a href="http://www.interviewbit.com/courses/programming/topics/math/problems/paths/" rel="nofollow noreferrer">http://www.interviewbit.com/courses/programming/topics/math/problems/paths/</a>
<a href="http://articles.leetcode.com/2010/11/unique-paths.html" rel="nofollow noreferrer">http://articles.leetcode.com/2010/11/unique-paths.html</a></p>
<p>I solved this problem in Java, and wrote one more solution in Python. Now I want to modify the previous solution with Memoized table so that the final answer gets collected at the bottom right cell. Value of a cell is the sum of its right and left adjacent cells.</p>
<p><img alt="Value of a cell is sum of it's right and left cell" src="https://i.stack.imgur.com/0uRmI.png"/></p>
<p>Here's the code I can't debug:-</p>
<pre><code>class Solution:
    #Actual Recursive function
    def paths(self,row,col):
        if row == 0 or col == 0:
            self.Mat[row][col] = 1
            return 1
        self.Mat[row][col-1] = self.paths(row, col-1)
        self.Mat[row-1][col] = self.paths(row-1, col)
        self.Mat[row][col] = self.Mat[row][col-1] + self.Mat[row-1][col]
        return self.Mat[row][col] 

    # Driver Function. This will be called
    def uniquePaths(self, A, B): 
        self.Mat = [[-1]*B]*A
        ans = self.paths(A-1, B-1)
        return self.Mat[A-1][B-1]
</code></pre>
<p>And here is my previous solution that works - But doesn't use memoized table. </p>
<pre><code>class OldSolution:
    def paths(self,row,col):
        if row==0 or col==0:
            return 1
        elif row&lt;0 or col&lt;0:
            return 0
        elif row &gt;0 and col &gt; 0:
            return self.paths(row-1,col) + self.paths(row,col-1)            
    def uniquePaths(self, A, B):
        Mat = [ [-1] * B ] *A
        return self.paths(A-1, B-1)

sol = OldSolution()
print sol.uniquePaths(3,3) # Prints 6
</code></pre>
<p>Test Cases:-
3, 3 = 6</p>
<p>15, 9 = 319770</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue is with the initialization of the matrix. You essentially create the same row duplicated in every column so when you update a cell, all corresponding cells in all columns get updated.</p>
<p>Instead of:</p>
<pre><code>self.Mat = [[-1]*B]*A
</code></pre>
<p>Use:</p>
<pre><code>self.Mat = [[-1 for i in range(B)] for j in range(A)]
</code></pre>
</div>
<span class="comment-copy">"Value of a cell is the sum of its right and left adjacent cells."  It looks like it's actually the sum of the <i>above</i> and left cells.  (According to your leetcode.com link, paths can only ever move right or down.)</span>
<span class="comment-copy">Your first link to interviewbit.com produces a login page --- whatever you intended to show us appears to be members-only.  I think the second outlines the problem well enough, but you might want to mention the "downward or rightward moves only" rule in your text, because the first thing I thought was along the lines of, "there's a a lot more paths than <i>that</i>".</span>
<span class="comment-copy">An alternative approach:  Python's tuples are hashable, so they can be used as dictionary keys.  Your memoization cache could be a single <code>dict</code> mapping a <code>(row, col)</code> tuple to an <code>int</code>.  Or, if you feel it's not cheating (and you're using Python 3.2 or greater), use the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a> decorator.</span>
<span class="comment-copy">Wow! Thanks. Rather [[-1 for i in range(B)] for j in range(A)] in this particular case..</span>
