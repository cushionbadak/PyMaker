<div class="post-text" itemprop="text">
<p>I have a sorted list L and I have a binary search for determining where in the list to insert an element such that the resulting list will still be in order. </p>
<p>However L.insert(index,object) needs O(N) time complexity.</p>
<p>Is there another data structure for L that will serve the same purpose, but allows for a faster insertion?</p>
</div>
<div class="post-text" itemprop="text">
<p>Check out the blist module.</p>
<p><a href="https://pypi.python.org/pypi/blist/" rel="nofollow">https://pypi.python.org/pypi/blist/</a></p>
<p>It claims O(log n) insertion.</p>
<p>usage:</p>
<pre><code>x = #list contents
y = blist(x)
y.insert(index, object) #now works in O(log n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A shout out to <a href="http://www.grantjenks.com/docs/sortedcontainers/" rel="nofollow noreferrer"><code>sortedcontainers.SortedList</code></a>. This will keep your list in order automatically, with a fast insert time.</p>
<pre><code>from sortedcontainers import SortedList

mylist = SortedList([1, 2, 4, 5])
mylist.add(3)
mylist
#&gt;&gt;&gt; SortedList([1, 2, 3, 4, 5], load=1000)
</code></pre>
<p><code>SortedList</code> <a href="http://www.grantjenks.com/docs/sortedcontainers/performance-scale.html" rel="nofollow noreferrer">insertions are amortized <code>O(sqrt n)</code>, or <code>O(cbrt n)</code> with different choices of parameters,</a> but it scales better than <code>blist</code>, which is <code>O(log n)</code>, because the constants are much better. There is <a href="http://www.grantjenks.com/docs/sortedcontainers/performance-workload.html" rel="nofollow noreferrer">a very in-depth look at performance on their website</a>.</p>
<p>Alternatively, you might be wanting a <a href="http://en.wikipedia.org/wiki/Priority_queue" rel="nofollow noreferrer">priority queue</a> in which case you can get potentially-faster inserts with <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer">the <code>heapq</code> module</a>.</p>
</div>
<span class="comment-copy">Binary search tree? Looks like Python doesn't have one built in, but there's probably a package somewhere for one.</span>
<span class="comment-copy">Yeah Binary Search Tree is O(1) insertion.</span>
<span class="comment-copy">Ahh I was hoping you guys weren't going to say BST. :(</span>
<span class="comment-copy">@JamesMills Don't you mean O(log n)?</span>
<span class="comment-copy">Take a look at the <a href="https://docs.python.org/2/library/bisect.html" rel="nofollow noreferrer">bisect</a> library, <code>bisect.insort()</code></span>
<span class="comment-copy">This library is also very efficient for inserting/deleting at random locations in <i>unsorted</i> lists (where the order matters).</span>
<span class="comment-copy">The <code>O(log n)</code> part is <a href="http://www.grantjenks.com/docs/sortedcontainers/performance-scale.html" rel="nofollow noreferrer">not strictly true</a>. <code>sortedcontainers.SortedList</code> stores data in <a href="http://www.grantjenks.com/docs/sortedcontainers/implementation.html" rel="nofollow noreferrer">balanced lists of lists</a> and exploits data locality achieving faster amortized times. Big-O insert complexity is, strictly speaking, <code>O(n^2)</code>, but due to large "load factor", amortized insert complexity is ~ <code>n^(1/3)</code>.</span>
<span class="comment-copy">@randomir Thanks, this is actually something <a href="https://www.reddit.com/r/Python/comments/4ge9xs/python_sorted_collections/d2hkra5/" rel="nofollow noreferrer">I was aware of</a>, just not at the time I wrote this. My post is fixed now.</span>
<span class="comment-copy">Still a good answer, though (I wasn't aware of <code>sortedcontainers</code>, probably because I didn't need them until today :)).</span>
