<div class="post-text" itemprop="text">
<p>I'm trying to connect to more than one server at the same time. I am currently using <code>loop.create_connection</code> but it freezes up at the first non-responding server.</p>
<pre><code>gsock = loop.create_connection(lambda: opensock(sid), server, port)
transport, protocol = loop.run_until_complete(gsock)
</code></pre>
<p>I tried threading this but it created problems with the sid value being used as well as various errors such as <code>RuntimeError: Event loop is running</code> and <code>RuntimeError: Event loop stopped before Future completed</code>.  Also, according my variables (tho were getting mixed up) the protocol's <code>connection_made()</code> method gets executed when <code>transport, protocol = loop.run_until_complete(gsock)</code> throws an exception.</p>
<p>I don't understand much about the asyncio module so please be as thorough as possible.  I dont think I need reader/writer variables, as the reading should be done automatically and trigger <code>data_received()</code> method.</p>
<p>Thank You.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can connect to many servers at the same time by scheduling all the coroutines concurrently, rather than using <code>loop.run_until_complete</code> to make each connection individually. One way to do that is to use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow"><code>asyncio.gather</code></a> to schedule them all and wait for each to finish:</p>
<pre><code>import asyncio

# define opensock somewhere

@asyncio.coroutine
def connect_serv(server, port):
    try:
        transport, protocol = yield from loop.create_connection(lambda: opensock(sid), server, port)
    except Exception:
        print("Connection to {}:{} failed".format(server, port))

loop = asyncio.get_event_loop()
loop.run_until_complete(
    asyncio.gather(
      connect_serv('1.2.3.4', 3333),
      connect_serv('2.3.4.5', 5555),
      connect_serv('google.com', 80),
 ))
loop.run_forever()
</code></pre>
<p>This will kick off all three coroutines listed in the call to <code>gather</code> concurrently, so that if one of them hangs, the others won't be affected; they'll be able to carry on with their work while the other connection hangs. Then, if all of them complete, <code>loop.run_forever()</code> gets executed, which will allow you program to continue running until you stop the loop or kill the program.</p>
<p>The <code>reader</code>/<code>writer</code> variables you mentioned would only be relevant if you used <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection" rel="nofollow"><code>asyncio.open_connection</code></a> to connect to the servers, rather than <code>create_connection</code>. It uses the Stream API, which is a higher-level API than the protocol/transport-based API that <code>create_connection</code> uses. It's really up to you to decide which you prefer to use. There are <a href="https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-client-protocol" rel="nofollow">examples</a> of <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio-tcp-echo-client-streams" rel="nofollow">both</a> in the <code>asyncio</code> docs, if you want to see a comparison.</p>
</div>
<span class="comment-copy">Thank you very much, I'll try out your technique.</span>
<span class="comment-copy">Im still wondering if its okay to use run_until_complete() while run_forever() is going.  I guess I'll try that after I rewrite.</span>
<span class="comment-copy">Actually this is not a working solution because the sockets are not fully active (unless all the server connections succeed in a timely manner).  The program hangs waiting for one of the connections to a server.</span>
<span class="comment-copy">@baudsmoke I'm not sure what you mean. What sockets aren't fully active? What specifically is hanging? The program is designed to block in the <code>run_until_complete</code> call, possibly forever if one of the calls to <code>connect_serv</code> never returns. However, the <code>connect_serv</code> calls that don't hang should continue to work just fine.</span>
