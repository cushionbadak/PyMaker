<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/23006428/create-li-li1-tuple-list-from-list-l">Create (L[i], L[i+1]) tuple list from list L [duplicate]</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I have an array that looks like this</p>
<pre><code>   [1,2,3,4,5]
</code></pre>
<p>and I would like a list of tuples that looks like this:</p>
<pre><code>[(1,2),(2,3),(3,4),(4,5)]
</code></pre>
<p>What is the most convenient way to do this in python?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>zip( a[:-1], a[1:] )
</code></pre>
<p>see <code>help(zip)</code> or the website <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">documentation</a> of <code>zip</code>.</p>
<p>Since <code>zip</code> limits itself to the shorter sequence,</p>
<pre><code>zip(a, a[1:])
</code></pre>
<p>works too.</p>
<p>EDIT: </p>
<p>Steven brought up the interesting point that if <code>a</code> is very long, doing the implicit copy to get the separate pyObject that is <code>a[1:]</code> is problematic. In this case, you might want to use <code>numpy</code> and its options to get a view on the same data with but a offset.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done using list comprehension and list slicing, you iterate over the elements upto <code>len(a) - 1</code> and on each iteration slice the elements form <code>current_index</code> and the element next to it.</p>
<pre><code>a = [1,2,3,4,5]
b = [tuple(a[i:i+2]) for i in range(len(a)-1)]
print b

&gt;&gt;&gt; [(1, 2), (2, 3), (3, 4), (4, 5)]
</code></pre>
</div>
<span class="comment-copy">It should be <code>zip( a[:-1], a[1:] )</code></span>
<span class="comment-copy">agreed, I'll edit</span>
<span class="comment-copy">May as well reduce it to <code>zip(a, a[1:])</code> since it only zips up to the end of the shortest argument.</span>
<span class="comment-copy">nice! Will do that.</span>
<span class="comment-copy">Your answer is practical and pythonic.  However if the OP needs to generate the tuples on the fly, he can use the <a href="https://docs.python.org/2/library/itertools.html#recipes" rel="nofollow noreferrer">recipe</a> for <code>pairwise</code> from the <code>iterools</code> module docs.  This would be useful if the data were coming from a very large in-memory list or a large external file.</span>
<span class="comment-copy">this returns a list of lists, not a list of tuples.</span>
<span class="comment-copy">you've fixed that :)</span>
