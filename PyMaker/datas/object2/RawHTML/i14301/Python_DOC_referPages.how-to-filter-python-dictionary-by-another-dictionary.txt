<div class="post-text" itemprop="text">
<p>I want to create a method that, Looks through each value in the mainDict, returning an array of all the values that contain all of the key-value pairs listed in filterDict.</p>
<pre><code>def where(mainDicts, filterDict):
    pass

mydicts = [{'title': "title 1", 'author': "author 1", 'year': 1611},
           {'title': "title 2", 'author': "author 2", 'year': 1615},
           {'title': "title 3", 'author': "author 1", 'year': 1611}]

filterDict = {'year': 1611, 'author': "author 1"}

where(mydicts, filterDict)
</code></pre>
<p>i want to return this:</p>
<pre><code>[{'title': "title 1", 'author': "author 1", 'year': 1611},
 {'title': "title 3", 'author': "author 1", 'year': 1611}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you run Python 3:</p>
<pre><code>def where(mainDicts, filterDict):
    return [x for x in mainDicts if not filterDict.items() - x.items()]
</code></pre>
<p>Quoting the documentation:</p>
<blockquote>
<p>Keys views are set-like since their entries are unique and hashable.
  If all values are hashable, so that <code>(key, value)</code> pairs are unique and
  hashable, then the items view is also set-like. For set-like views, all of the operations defined for the abstract base class <em>collections.abc.Set</em> are available (for example, <code>==</code>, <code>&lt;</code>, or <code>^</code>).</p>
</blockquote>
<p>Refer to <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow">Dictionary view objects</a> for more information.
If you need this to work in Python 2, just replace <code>items()</code> with <a href="https://docs.python.org/2/library/stdtypes.html#dict.viewitems" rel="nofollow"><code>viewitems()</code></a>.</p>
<p>Example:</p>
<pre><code>In [8]: where(mydicts, {'year': 1611, 'author': "author 1"})
Out[8]: 
[{'author': 'author 1', 'year': 1611, 'title': 'title 1'},
 {'author': 'author 1', 'year': 1611, 'title': 'title 3'}]
</code></pre>
<p>Note that the above won't work if your values are not hashable (see the <a href="https://docs.python.org/3/glossary.html?highlight=hashable" rel="nofollow">Glossary</a>), but the following will</p>
<pre><code>def where(dicts, filt):
    return [x for x in dicts if all(k in x and x[k] == v for k, v in filt.items())]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use a list comprehension, for each item <code>d</code> checking whether all the keys <code>k</code> from the <code>filterDict</code> are in that item, and if so, whether the value <code>v</code> is the same.</p>
<pre><code>def where(mainDict, filterDict):
    return [d for d in mainDict if all(k in d and d[k] == v 
                                       for k, v in filterDict.items())]
</code></pre>
<p>This also works with Python 2. Example:</p>
<pre><code>&gt;&gt;&gt; where(mydict, {'year': 1611, 'author': "author 1"})
[{'author': 'author 1', 'year': 1611, 'title': 'title 1'}, 
 {'author': 'author 1', 'year': 1611, 'title': 'title 3'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a more pythonic way you can use <a href="https://docs.python.org/2/library/stdtypes.html#dict.viewitems" rel="nofollow"><code>dict.viewitems</code></a> to get the intersection between your dictionaries and the filter dictionary then if the intersection was equal with filter you can return it :</p>
<pre><code>&gt;&gt;&gt; filt={'author': 'author 1', 'year': 1611}
&gt;&gt;&gt; [d for d in mydict if dict(filt.viewitems()&amp;d.viewitems())==filt]
[{'author': 'author 1', 'year': 1611, 'title': 'title 1'}, {'author': 'author 1', 'year': 1611, 'title': 'title 3'}]
</code></pre>
<p>read more about dictionary-view-objects <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="nofollow">https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another way to do it, maybe it's more readable for you. It's python 2 and 3 compatible and pretty straight forward.</p>
<pre><code>def where(list_of_dicts, filterDict):

    result = [] # to be returned, a list of dicts

    for d in list_of_dicts:
        n = 0 # count how many key/value pairs matches with filterDict
        for key in filterDict:
            try: # in case key is missing
                if d[key] == filterDict[key]:
                    n += 1
            except:
                pass # change with a proper error message
        if n == len(filterDict): # if True then all the key/value pairs in filterDict are in d
            result.append(d)

    return result




mydicts = [{'title': "title 1", 'author': "author 1", 'year': 1611},
          {'title': "title 2", 'author': "author 2", 'year': 1615},
          {'title': "title 3", 'author': "author 1", 'year': 1611}]

filterDict = {'year': 1611, 'author': "author 1"}


a = where(mydicts, filterDict)
print(a)
</code></pre>
<p>It prints out:</p>
<pre><code>[{'author': 'author 1', 'year': 1611, 'title': 'title 1'}, {'author': 'author 1', 'year': 1611, 'title': 'title 3'}]
</code></pre>
</div>
<span class="comment-copy">Could you post your attempts at an implementation?</span>
<span class="comment-copy">SO is not a code writing service. Kindly make an attempt and post any errors that you might be facing.</span>
<span class="comment-copy">Nice! But IMHO <code>if filterDict.items() &lt;= x.items()</code> is easier to understand.</span>
<span class="comment-copy"><code>d[key]</code> will fail (raise an exception) if the key is not in the dictionary.</span>
<span class="comment-copy">Can be solved with a try/except block</span>
<span class="comment-copy">Done :) now should be ok. Thank you for the notification.</span>
