<div class="post-text" itemprop="text">
<p>Please forgive the noob question. I don't understand this "self" stuff in relation to this:</p>
<pre><code>from selenium.common.exceptions import NoSuchElementException

def is_element_present(self, how, what):
    try:
        self.driver.find_element(by=how, value=what)
    except NoSuchElementException:
        return False
    return True

#### navigate to the web page with a bunch of code here, then continue

text_present = self.assertTrue(self.is_element_present(By.LINK_TEXT, "Click Here"))
</code></pre>
<p>When I run this, here's the error I get:</p>
<pre><code>        test_link = self.assertTrue(self.is_element_present(By.LINK_TEXT, "Click Here"))
NameError: name 'self' is not defined
</code></pre>
<p>I understand "self" is used by convention as the first argument in a function but I don't understand the error.  How do I define self?</p>
<p>Edit 1: I stand corrected on where "self" is used by convention (see comments/answers below).  However, I still don't know what I should be doing to satisfy the Python interpreter.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self</code> is "used by convention as the first argument" in a <em>method</em>, which is associated with a class. <code>self</code> in this context represents the instance of the class that is calling the method. A function, however, is not associated with a class, and thus no initial <code>self</code> argument is required. This is one of the fundamental differences between functions and methods--methods are associated with a class, and are called as <code>instanceOfClass.methodName(args)</code>, where functions simply exist in the namespace and are called as <code>functionName(args)</code>. Also note that when <em>calling</em> a method, <code>self</code> is not passed to the call: it is only used when defining the method.</p>
</div>
<div class="post-text" itemprop="text">
<p>You might know about the <code>this</code> pointer in C++. In priciple, Python's <code>self</code> is quite similar (but is more a reference than a pointer). It is the current object you apply the function to.</p>
<pre><code>class MyClass:
    def my_method(self, arg):
        pass

my_object = MyClass()
my_object.my__method("whatever")
</code></pre>
<p>is actually like (not exactly identical to):</p>
<pre><code>def my_func(the_object, arg):
    pass

class MyClass:
    pass

my_object = MyClass()
my_func(my_object, "whatever")
</code></pre>
<p>As there is actually more involved, the other way round will not work:</p>
<pre><code>my_object.my_func("whatever")
</code></pre>
<p>Will raise an exception (an error), just try it. That is because <code>my_func</code> is an <em>unbound function</em> (not related to any object/class). <code>my_method</code> actually is <code>bound</code> (to <code>my_object</code>).</p>
<p>While <code>this</code> is passed implicitly (you do not have to specify it as an argument) to a method in C++, Python requires it to be listed explicitly as the first argument. The name <code>self</code> is actually just convention, a method will always get its object as the first argument, so it could also be named "thats_me". However, stick to `self', as many tools rely on this (syntax highlighting editors, debuggers, ...).</p>
<p>In the method itself, all members of the object are then accessed explicitly by <code>self.my_member</code> or <code>self</code>.my_func()<code>. While in C++ one would write</code>my_member<code>or</code>this-&gt;my_member`, etcetera. The latter is basically similar to Python's way.</p>
<p>Please read more <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow">here</a> and in the tutorial in general.</p>
<p><strong>Background:</strong> Passing the object expliticly as the first argument is due to one of Pythons major guidelines: "explicit is better than implicit".</p>
</div>
<span class="comment-copy">What do you intend <code>self</code> to be?  Your code never creates any objects at all.</span>
<span class="comment-copy"><code>self</code> is used as the first argument in instance methods not functions. There is a pretty significant difference between the two.</span>
<span class="comment-copy"><code>self</code> is not used by convention as the first argument in a function.  Consider spending some time with one of the various "learning python" tutorials available on the net (e.g., <a href="http://learnpythonthehardway.org/book/" rel="nofollow noreferrer">this</a> or <a href="http://www.codecademy.com/en/tracks/python" rel="nofollow noreferrer">this</a>).</span>
<span class="comment-copy">I'm not sure what I intend self to be. What I really want is a boolean, which I thought the function would provide. I've tried creating a variable, like "text = self.assertTrue(..." , but I get the same error.  Thanks for the clarification IanAuld and larsks</span>
<span class="comment-copy">Also please don't do this: <code>try: do_some_stuff()</code> all on one line. Hit return and properly indent it, spaces not tabs.</span>
<span class="comment-copy">Just the name <code>self</code> is convention. The first argument is actually given by the language itself.</span>
<span class="comment-copy">I thought I made that clear in the last sentence when I said that <code>self</code> is only used in the method definition, not when calling the method (since the instance you are referring to was provided before the dot).</span>
<span class="comment-copy">You might have thought, but you actually did not. These are different aspects: calling and being called. Also, this is wrong: Of course is the object (note the difference: I do not call it <code>self</code>) passed to the method: as the <b>first</b> argument; within the object, it can then be referenced by then first argument's name. And <i>that</i> (the name, not the argument as such) would be <code>self</code> - just by convention  I tried to detail this in my answer, welcome to leave a comment if that is still not clear.</span>
<span class="comment-copy">@Olaf So let me make sure I have this straight: A method's first argument is the object calling the method (which by convention is given the name <code>self</code>), which Python automatically passes when the method is called, along with any additional arguments specified between the parentheses. So <code>objectInstance.nameOfMethod(arg1, arg2)</code> really has three arguments: <code>objectInstance</code> (which is passed automatically by Python), <code>arg1</code> and <code>arg2</code>, and would be defined <code>def nameOfMethod(self, someArg, otherArg)</code>, with <code>objectInstance</code> being passed for <code>self</code>, <code>arg1</code> for <code>someArg</code> and <code>arg2</code> for <code>otherArg</code>.</span>
<span class="comment-copy">Wel,, yes. That's exactly what the method signature says. Remember: "explicit is better than implicit". Actually, in Java you have somethig similar, also in C++, if we ignore the additional pointer-syntax (historical reasons: no reference types). For the latter languages, it is only that <code>this</code> can be omitted, as the compiler uses object-scope within a method when resolving a symbol name first (method).</span>
