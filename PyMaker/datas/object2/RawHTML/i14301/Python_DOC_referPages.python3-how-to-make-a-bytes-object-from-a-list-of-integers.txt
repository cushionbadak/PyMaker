<div class="post-text" itemprop="text">
<p>I have an array of integers (all less than 255) that correspond to byte values  (i.e. <code>[55, 33, 22]</code>) how can I turn that into a bytes object that would look like </p>
<p><code>b'\x55\x33\x22</code>  etc.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Just call the <a href="https://docs.python.org/3/library/functions.html#bytes" rel="noreferrer"><code>bytes</code></a> constructor.</p>
<p>As the docs say:</p>
<blockquote>
<p>â€¦ constructor arguments are interpreted as for <code>bytearray()</code>.</p>
</blockquote>
<p>And if you follow that link:</p>
<blockquote>
<p>If it is an <em>iterable</em>, it must be an iterable of integers in the range <code>0 &lt;= x &lt; 256</code>, which are used as the initial contents of the array.</p>
</blockquote>
<p>So:</p>
<pre><code>&gt;&gt;&gt; list_of_values = [55, 33, 22]
&gt;&gt;&gt; bytes_of_values = bytes(list_of_values)
&gt;&gt;&gt; bytes_of_values
b'7!\x16'
&gt;&gt;&gt; bytes_of_values == '\x37\x21\x16'
True
</code></pre>
<p>Of course the values aren't going to be <code>\x55\x33\x22</code>, because <code>\x</code> means <em>hexadecimal</em>, and the decimal values <code>55, 33, 22</code> are the hexadecimal values <code>37, 21, 16</code>. But if you had the hexadecimal values <code>55, 33, 22</code>, you'd get exactly the output you want:</p>
<pre><code>&gt;&gt;&gt; list_of_values = [0x55, 0x33, 0x22]
&gt;&gt;&gt; bytes_of_values = bytes(list_of_values)
&gt;&gt;&gt; bytes_of_values == b'\x55\x33\x22'
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>bytes</code> constructor takes an iterable of integers, so just feed your list to that:</p>
<pre><code>l = list(range(0, 256, 23))
print(l)
b = bytes(l)
print(b)
</code></pre>
<p>Output:</p>
<pre><code>[0, 23, 46, 69, 92, 115, 138, 161, 184, 207, 230, 253]
b'\x00\x17.E\\s\x8a\xa1\xb8\xcf\xe6\xfd'
</code></pre>
<p>See also:  <a href="https://stackoverflow.com/questions/18640175/python-3-on-converting-from-ints-to-bytes-and-then-concatenating-them-for-s?rq=1">Python 3 - on converting from ints to 'bytes' and then concatenating them (for serial transmission)</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>struct.pack("b"*len(my_list),*my_list)
</code></pre>
<p>I think will work</p>
<pre><code>&gt;&gt;&gt; my_list = [55, 33, 22]
&gt;&gt;&gt; struct.pack("b"*len(my_list),*my_list)
b'7!\x16'
</code></pre>
<p>if you want hex you need to make it hex in the list</p>
<pre><code>&gt;&gt;&gt; my_list = [0x55, 0x33, 0x22]
&gt;&gt;&gt; struct.pack("b"*len(my_list),*my_list)
b'U3"'
</code></pre>
<p>in all cases if that value has an ascii representation it will display it when you try to print it or look at it ...</p>
</div>
<span class="comment-copy">Good catch on the mismatched decimal / hexadecimal input and output.</span>
<span class="comment-copy">And in Python 2, <code>bytes(bytearray(l))</code>, since <code>bytes is str</code> in Python 2.</span>
<span class="comment-copy">this is close I think, i do get this error <code>struct.error: byte format requires -128 &lt;= number &lt;= 127</code>  Can you help with that?</span>
<span class="comment-copy">@Startec The <code>'b'</code> format means signed bytes [-128, 127].  You want to use a capital <code>'B'</code> for _un_signed bytes [0,255].</span>
<span class="comment-copy">You don't need to use <code>struct</code> for this.</span>
<span class="comment-copy">heh yeah but you could :P ... (Im not in py3 yet I now see there are much better solutions :P , that also apply to py2 I think)</span>
