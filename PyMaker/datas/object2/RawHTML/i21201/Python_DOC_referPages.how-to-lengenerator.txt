<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/393053/length-of-generator-output">Length of generator output [duplicate]</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/5384570/whats-the-shortest-way-to-count-the-number-of-items-in-a-generator-iterator">What's the shortest way to count the number of items in a generator/iterator?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p><a href="http://docs.python.org/tutorial/classes.html#generators" rel="noreferrer">Python generators</a> are very useful. They have advantages over functions that return lists. However, you could <code>len(list_returning_function())</code>. Is there a way to <code>len(generator_function())</code>?</p>
<p><strong>UPDATE:</strong><br/>
Of course <code>len(list(generator_function()))</code> would work.....<br/>
I'm trying to use a generator I've created inside a new generator I'm creating. As part of the calculation in the new generator it needs to know the length of the old one. However I would like to keep both of them together with the same properties as a generator, specifically - not maintain the entire list in memory as it may be <strong>very</strong> long.</p>
<p><strong>UPDATE 2:</strong><br/>
Assume the generator <em>knows</em> it's target length even from the first step. Also, there's no reason to maintain the <code>len()</code> syntax. Example - if functions in Python are objects, couldn't I assign the length to a variable of this object that would be accessible to the new generator?</p>
</div>
<div class="post-text" itemprop="text">
<p>Generators have no length, they aren't collections after all.</p>
<p>Generators are <em>functions with a internal state</em> (and fancy syntax). You can repeatedly call them to get a sequence of values, so you can use them in loop. But they don't contain any elements, so asking for the length of a generator is like asking for the length of a function. </p>
<blockquote>
<p>if functions in Python are objects, couldn't I assign the length to a
  variable of this object that would be accessible to the new generator?</p>
</blockquote>
<p>Functions are objects, but you cannot assign new attributes to them. The reason is probably to keep such a basic object as efficient as possible.</p>
<p>You can however simply return <code>(generator, length)</code> pairs from your functions or wrap the generator in a simple object like this:</p>
<pre><code>class GeneratorLen(object):
    def __init__(self, gen, length):
        self.gen = gen
        self.length = length

    def __len__(self): 
        return self.length

    def __iter__(self):
        return self.gen

g = some_generator()
h = GeneratorLen(g, 1)
print len(h), list(h)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The conversion to <code>list</code> that's been suggested in the other answers is the best way if you still want to process the generator elements afterwards, but has one flaw: It uses O(n) memory. You can count the elements in a  generator without using that much memory with:</p>
<pre><code>sum(1 for x in generator)
</code></pre>
<p>Of course, be aware that this might be slower than <code>len(list(generator))</code> in common Python implementations, and if the generators are long enough for the memory complexity to matter, the operation would take quite some time. Still, I personally prefer this solution as it describes what I want to get, and it doesn't give me anything extra that's not required (such as a list of all the elements).</p>
<p>Also listen to delnan's advice: If you're discarding the output of the generator it is very likely that there is a way to calculate the number of elements without running it, or by counting them in another manner.</p>
</div>
<div class="post-text" itemprop="text">
<p>Suppose we have a generator:</p>
<pre><code>def gen():
    for i in range(10):
        yield i
</code></pre>
<p>We can wrap the generator, along with the known length, in an object:</p>
<pre><code>import itertools
class LenGen(object):
    def __init__(self,gen,length):
        self.gen=gen
        self.length=length
    def __call__(self):
        return itertools.islice(self.gen(),self.length)
    def __len__(self):
        return self.length

lgen=LenGen(gen,10)
</code></pre>
<p>Instances of <code>LenGen</code> are generators themselves, since calling them returns an iterator.</p>
<p>Now we can use the <code>lgen</code> generator in place of <code>gen</code>, and access <code>len(lgen)</code> as well:</p>
<pre><code>def new_gen():
    for i in lgen():
        yield float(i)/len(lgen)

for i in new_gen():
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>len(list(generator_function())</code>. However, this consumes the generator, but that's the only way you can find out how many elements are generated. So you may want to save the list somewhere if you also want to use the items.</p>
<pre><code>a = list(generator_function())
print(len(a))
print(a[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>len(list(generator))</code> but you could probably make something more efficient if you really intend to discard the results.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>send</code> as a hack:</p>
<pre><code>def counter():
    length = 10
    i = 0
    while i &lt; length:
        val = (yield i)
        if val == 'length':
            yield length
        i += 1

it = counter()
print(it.next())
#0
print(it.next())
#1
print(it.send('length'))
#10
print(it.next())
#2
print(it.next())
#3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can combine the benefits of generators with the certainty of <code>len()</code>, by creating your own iterable object:</p>
<pre><code>class MyIterable(object):
    def __init__(self, n):
        self.n = n

    def __len__(self):
        return self.n

    def __iter__(self):
        self._gen = self._generator()
        return self

    def _generator(self):
        # Put your generator code here
        i = 0
        while i &lt; self.n:
            yield i
            i += 1

    def next(self):
        return next(self._gen)

mi = MyIterable(100)
print len(mi)
for i in mi:
    print i,
</code></pre>
<p>This is basically a simple implementation of <code>xrange</code>, which returns an object you can take the len of, but doesn't create an explicit list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>reduce</code>.</p>
<p>For Python 3:</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; def gen():
...     yield 1
...     yield 2
...     yield 3
...
&gt;&gt;&gt; functools.reduce(lambda x,y: x + 1, gen(), 0)
</code></pre>
<p>In Python 2, <code>reduce</code> is in the global namespace so the import is unnecessary.</p>
</div>
<span class="comment-copy">You mean avoiding the obvious <code>len(list(generator_function()))</code> ?</span>
<span class="comment-copy">If you <i>really</i> need the length, generators are the wrong approach. But frequently, you don't need it. <code>itertools</code> can do wonders, and at other times the output length can be predicted (accurately) from the input.</span>
<span class="comment-copy">yes, I mean avoiding the obvious <code>len(list(generator_function()))</code></span>
<span class="comment-copy">Explain why <i>"as part of the calculation in the new generator it needs to know the length of the old one"</i>, that's evil and we can probably eliminate that. <a href="http://docs.python.org/library/itertools.html" rel="nofollow noreferrer">itertools</a> has a bunch of constructs for that.</span>
<span class="comment-copy">e.g. the old generator produces a certain random function and the new generator performs a calculation that depends on the current time and on the length of the vector. I don't see how this use would be evil. Trust me that I have a need for this and that it's architecturally sound in my system.</span>
<span class="comment-copy">No, it's pretty obvious that it <i>is</i> meaningful to talk about the length of many generators, since many generators return a finite number of elements. Your argument that it is meaningless proves too much; if we accept it, then by the same logic it's also meaningless to convert the output of a generator to a list... and yet <code>list(generator())</code> works and is built into the language.</span>
<span class="comment-copy">@MarkAmery  Part of what makes generators so flexible is that they <i>don't</i> have to provide a <code>__len__</code> method (or a Java-like <code>hasNext</code> and <code>remove</code>, or ...).  What would <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a> return?  There's no "infinity" integer in Python.  And what about generators that <i>don't know</i> when they'll be done?  To write an efficient <code>__len__</code> method for a <a href="https://en.wikipedia.org/wiki/Goldbach%27s_conjecture" rel="nofollow noreferrer">Goldbach's Conjecture</a> generator, you'd first have to answer one of the biggest open questions in mathematics.</span>
<span class="comment-copy">@KevinJ.Chase I could just as well ask <i>"What would <code>sum(itertools.count())</code> return?"</i>, yet <code>sum</code> can take generators. There's an obvious possible way to implement <code>len()</code> on arbitrary iterables: have it iterate and count how many elements there are. I'd argue that this would be an unhelpful feature to have (knowing the length of a consumed generator whose elements you've discarded isn't going to be useful in most cases), but the fact that it would loop forever on infinite generators plainly isn't the knock-down argument you think it is because <code>sum()</code> and <code>list()</code> have the same behaviour.</span>
<span class="comment-copy">...and to "return the length of a consumed generator whose elements youve discarded" <b>is</b> sometimes useful: As the outermost consumer of a generator chain, you just want to report the number of elements the inner generators operated on (e.g. how many database records were written).</span>
<span class="comment-copy">@Roch Oxymoron's answer is exactly what I was looking for.</span>
<span class="comment-copy">This is the best answer imo. However, it would be slightly more pythonic to write: sum(1 for _ in generator)</span>
<span class="comment-copy">As a Python noob I'm probably missing something obvious, but what's the point in using this approach if you cannot use the generator afterwards anymore to generate the actual values, as you already used it to count the values (and generators are fire-once AFAIU)?</span>
<span class="comment-copy">@sschuberth: You are right. If you need both the length and the values (and you don't control the origin of the generator), turning it into the list is the best option.</span>
<span class="comment-copy">Just beautiful. This is very pragmatic and clever!</span>
<span class="comment-copy">Found this in scikit-learn's source :) <a href="https://github.com/scikit-learn/scikit-learn/blob/a24c8b46/sklearn/preprocessing/data.py#L1314" rel="nofollow noreferrer">github.com/scikit-learn/scikit-learn/blob/a24c8b46/sklearn/…</a></span>
<span class="comment-copy">you solved it, but with a class. I... didn't expect that :) Is there any advantage in trying to keep the design as a function?</span>
<span class="comment-copy">@Jonathan: My first attempt was to attach an attribute to the generator object, <code>gen()</code>. Unlike with functions, however, Python does not allow you to attach additional attributes to generator objects. Because of this restriction, I went with a class.</span>
<span class="comment-copy">This code doesn't work for me (python 3.6). If I do <code>it.next()</code> I get <code>AttributeError: 'generator' object has no attribute 'next'</code>. <code>next(it)</code> works, though.</span>
<span class="comment-copy">you solved it, but with a <code>class</code>. I... didn't expect that :) Is there any advantage in trying to keep the design as a function?</span>
<span class="comment-copy">That suffers from a little bug: The iterator you create restarts every time you call <code>iter</code> on it <i>or</i> on the original iterable. It will have less surprising behaviour if you rename <code>_generator</code> to <code>__iter__</code> and remove <code>next</code>. Your iterator won't have a length, but that's not an issue since the iterable will be. (Another fix is to call <code>self._generator</code> during <code>__init__</code> and <i>not</i> during <code>__iter__</code>.)</span>
