<div class="post-text" itemprop="text">
<p>I was wondering how to implement a global logger that could be used everywhere with your own settings:</p>
<p>I currently have a custom logger class:</p>
<pre><code>class customLogger(logging.Logger):
   ...
</code></pre>
<p>The class is in a separate file with some formatters and other stuff.
The logger works perfectly on its own.</p>
<p>I import this module in my main python file and create an object like this:</p>
<pre><code>self.log = logModule.customLogger(arguments)
</code></pre>
<p>But obviously, I cannot access this object from other parts of my code.
Am i using a wrong approach? Is there a better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/logging.html#logging.getLogger" rel="noreferrer"><code>logging.getLogger(name)</code></a> to create a named global logger.</p>
<p><strong>main.py</strong>
</p>
<pre><code>import log
logger = log.setup_custom_logger('root')
logger.debug('main message')

import submodule
</code></pre>
<p><strong>log.py</strong>
</p>
<pre><code>import logging

def setup_custom_logger(name):
    formatter = logging.Formatter(fmt='%(asctime)s - %(levelname)s - %(module)s - %(message)s')

    handler = logging.StreamHandler()
    handler.setFormatter(formatter)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    return logger
</code></pre>
<p><strong>submodule.py</strong>
</p>
<pre><code>import logging

logger = logging.getLogger('root')
logger.debug('submodule message')
</code></pre>
<p><strong>Output</strong></p>
<pre><code>2011-10-01 20:08:40,049 - DEBUG - main - main message
2011-10-01 20:08:40,050 - DEBUG - submodule - submodule message
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since I haven't found a satisfactory answer, I would like to elaborate on the answer to the question a little bit in order to give some insight into the workings and intents of the <code>logging</code> library, that comes with Python's standard library. </p>
<p>In contrast to the approach of the OP (original poster) the library clearly separates the interface to the logger and configuration of the logger itself. </p>
<blockquote>
<p>The configuration of handlers is the prerogative of the application developer who uses your library.</p>
</blockquote>
<p>That means you should <em>not</em> create a custom logger class and configure the logger inside that class by adding any configuration or whatsoever.</p>
<p>The <code>logging</code> library introduces four components: <em>loggers</em>, <em>handlers</em>, <em>filters</em>, and <em>formatters</em>.</p>
<blockquote>
<ul>
<li>Loggers expose the interface that application code directly uses.</li>
<li>Handlers send the log records (created by loggers) to the appropriate destination.</li>
<li>Filters provide a finer grained facility for determining which log records to output.</li>
<li>Formatters specify the layout of log records in the final output.</li>
</ul>
</blockquote>
<p>A common project structure looks like this:</p>
<pre><code>Project/
|-- .../
|   |-- ...
|
|-- project/
|   |-- package/
|   |   |-- __init__.py
|   |   |-- module.py
|   |   
|   |-- __init__.py
|   |-- project.py
|
|-- ...
|-- ...
</code></pre>
<p>Inside your code (like in <strong>module.py</strong>) you refer to the logger instance of your module to log the events at their specific levels.</p>
<blockquote>
<p>A good convention to use when naming loggers is to use a module-level logger, in each module which uses logging, named as follows:</p>
</blockquote>
<pre><code>logger = logging.getLogger(__name__)
</code></pre>
<p>The special variable <code>__name__</code> refers to your module's name and looks something like <code>project.package.module</code> depending on your application's code structure.</p>
<p><strong>module.py</strong> (and any other class) could essentially look like this:</p>
<pre><code>import logging
...
log = logging.getLogger(__name__)

class ModuleClass:
    def do_something(self):
        log.debug('do_something() has been called!')
</code></pre>
<p>The logger in each module will propagate any event to the parent logger which in return passes the information to its attached <em>handler</em>! Analogously to the python package/module structure, the parent logger is determined by the namespace using "dotted module names". That's why it makes sense to initialize the logger with the special <code>__name__</code> variable (in the example above <strong>name</strong> matches the string <em>"project.package.module"</em>).</p>
<p>There are two options to configure the logger globally:</p>
<ul>
<li><p>Instantiate a logger in <strong>project.py</strong> with the name <code>__package__</code> which equals <em>"project"</em> in this example and is therefore the parent logger of the loggers of all submodules. It is only necessary to add an appropriate handler and formatter to <em>this</em> logger.</p></li>
<li><p>Set up a logger with a handler and formatter in the executing script (like <strong>main.py</strong>) with the name of the topmost package.</p></li>
</ul>
<blockquote>
<p>When developing a library which uses logging, you should take care to document how the library uses logging - for example, the names of loggers used.</p>
</blockquote>
<p>The executing script, like <strong>main.py</strong> for example, might finally look something like this:</p>
<pre><code>import logging
from project import App

def setup_logger():
    # create logger
    logger = logging.getLogger('project')
    logger.setLevel(logging.DEBUG)

    # create console handler and set level to debug
    ch = logging.StreamHandler()
    ch.setLevel(level)

    # create formatter
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(name)s: %(message)s')

    # add formatter to ch
    ch.setFormatter(formatter)

    # add ch to logger
    logger.addHandler(ch)

if __name__ == '__main__' and __package__ is None:
     setup_logger()
     app = App()
     app.do_some_funny_stuff()
</code></pre>
<p>The method call <code>log.setLevel(...)</code> specifies the lowest-severity log message a logger will <em>handle</em> but not necessarily output! It simply means the message is passed to the handler as long as the message's severity level is higher than (or equal to) the one that is set. But the <em>handler</em> is responsible for <em>handling</em> the log message (by printing or storing it for example).</p>
<p>Hence the <code>logging</code> library offers a structured and modular approach which just needs to be exploited according to one's needs.</p>
<p><a href="https://docs.python.org/2/howto/logging.html" rel="noreferrer">Logging documentation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Create an instance of <code>customLogger</code> in your log module and use it as a singleton - just use the imported instance, rather than the class.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just pass it a string with a common sub-string before the first period.  The parts of the string separated by the period (".") can be used for different classes / modules / files / etc.  Like so (specifically the <code>logger = logging.getLogger(loggerName)</code> part):</p>
<pre><code>def getLogger(name, logdir=LOGDIR_DEFAULT, level=logging.DEBUG, logformat=FORMAT):
    base = os.path.basename(__file__)
    loggerName = "%s.%s" % (base, name)
    logFileName = os.path.join(logdir, "%s.log" % loggerName)
    logger = logging.getLogger(loggerName)
    logger.setLevel(level)
    i = 0
    while os.path.exists(logFileName) and not os.access(logFileName, os.R_OK | os.W_OK):
        i += 1
        logFileName = "%s.%s.log" % (logFileName.replace(".log", ""), str(i).zfill((len(str(i)) + 1)))
    try:
        #fh = logging.FileHandler(logFileName)
        fh = RotatingFileHandler(filename=logFileName, mode="a", maxBytes=1310720, backupCount=50)
    except IOError, exc:
        errOut = "Unable to create/open log file \"%s\"." % logFileName
        if exc.errno is 13: # Permission denied exception
            errOut = "ERROR ** Permission Denied ** - %s" % errOut
        elif exc.errno is 2: # No such directory
            errOut = "ERROR ** No such directory \"%s\"** - %s" % (os.path.split(logFileName)[0], errOut)
        elif exc.errno is 24: # Too many open files
            errOut = "ERROR ** Too many open files ** - Check open file descriptors in /proc/&lt;PID&gt;/fd/ (PID: %s)" % os.getpid()
        else:
            errOut = "Unhandled Exception ** %s ** - %s" % (str(exc), errOut)
        raise LogException(errOut)
    else:
        formatter = logging.Formatter(logformat)
        fh.setLevel(level)
        fh.setFormatter(formatter)
        logger.addHandler(fh)
    return logger

class MainThread:
    def __init__(self, cfgdefaults, configdir, pidfile, logdir, test=False):
        self.logdir = logdir
        logLevel = logging.DEBUG
        logPrefix = "MainThread_TEST" if self.test else "MainThread"
        try:
            self.logger = getLogger(logPrefix, self.logdir, logLevel, FORMAT)
        except LogException, exc:
            sys.stderr.write("%s\n" % exc)
            sys.stderr.flush()
            os._exit(0)
        else:
            self.logger.debug("-------------------- MainThread created.  Starting __init__() --------------------")

    def run(self):
        self.logger.debug("Initializing ReportThreads..")
        for (group, cfg) in self.config.items():
            self.logger.debug(" ------------------------------ GROUP '%s' CONFIG ------------------------------     " % group)
            for k2, v2 in cfg.items():
                self.logger.debug("%s &lt;==&gt; %s: %s" % (group, k2, v2))
            try:
                rt = ReportThread(self, group, cfg, self.logdir, self.test)
            except LogException, exc:
                sys.stderr.write("%s\n" % exc)
                sys.stderr.flush()
                self.logger.exception("Exception when creating ReportThread (%s)" % group)
                logging.shutdown()
                os._exit(1)
            else:
                self.threads.append(rt)
        self.logger.debug("Threads initialized.. \"%s\"" % ", ".join([t.name for t in self.threads]))
        for t in self.threads:
            t.Start()
        if not self.test:
            self.loop()


class ReportThread:
    def __init__(self, mainThread, name, config, logdir, test):
        self.mainThread = mainThread
        self.name = name
        logLevel = logging.DEBUG
        self.logger = getLogger("MainThread%s.ReportThread_%s" % ("_TEST" if self.test else "", self.name), logdir, logLevel, FORMAT)
        self.logger.info("init database...")
        self.initDB()
        # etc....

if __name__ == "__main__":
    # .....
    MainThread(cfgdefaults=options.cfgdefaults, configdir=options.configdir, pidfile=options.pidfile, logdir=options.logdir, test=options.test)
</code></pre>
</div>
<span class="comment-copy">I am not sure I understand what's the "logging" limitation that you are trying to overcome</span>
<span class="comment-copy">The logger defined in every submodule is not a global parameter , Is there a way to make it one? I want that when I define  logger = logging.getLogger('root') in  submodule.py it will be the same logger defined in logger = logging.getLogger('root') in submodule2.py</span>
<span class="comment-copy">What do you do if you configure your "global" logger after you have imported the module? (e.g. when forking a process with the multiprocessing module)</span>
<span class="comment-copy">Since you have to re-define the logger in your <code>submodule.py</code>, then the global definition is not such. Likewise one could have just re-initialised the logger in every sub-module reading from a config file (actually requiring even fewer key strokes).</span>
