<div class="post-text" itemprop="text">
<p>If I want the function name I can simply include <code>%(funcName)s</code> in the Formatter. But how do I get the name of the class containing the logging call instead?</p>
<p>I've gone through the documentation for <code>logging</code>, but I can't find any mentioning of it.</p>
</div>
<div class="post-text" itemprop="text">
<p>For a rather easy, pythonic way to get the class name to output with your logger, simply use a logging class.</p>
<pre><code>import logging


# Create a base class
class LoggingHandler:
    def __init__(self, *args, **kwargs):
        self.log = logging.getLogger(self.__class__.__name__)


# Create test class A that inherits the base class
class testclassa(LoggingHandler):
    def testmethod1(self):
        # call self.log.&lt;log level&gt; instead of logging.log.&lt;log level&gt;
        self.log.error("error from test class A")


# Create test class B that inherits the base class
class testclassb(LoggingHandler):
    def testmethod2(self):
        # call self.log.&lt;log level&gt; instead of logging.log.&lt;log level&gt;
        self.log.error("error from test class B")


testclassa().testmethod1()
testclassb().testmethod2()
</code></pre>
<p>By naming the logger as above, the <code>%(name)s</code> will be the name of your class</p>
<h3>example output</h3>
<pre><code>$ python mymodule.py
[2016-02-03 07:12:25,624] ERROR [testclassa.testmethod1:29] error from test class A
[2016-02-03 07:12:25,624] ERROR [testclassb.testmethod2:36] error from test class B
</code></pre>
<h3>Alternative(s)</h3>
<p>Non-inheritance</p>
<pre><code>import logging


def log(className):
    return logging.getLogger(className)


class testclassa:
    def testmethod1(self):
        log(self.__class__.__name__).error("error from test class A")


class testclassb:
    def testmethod2(self):
        log(self.__class__.__name__).error("error from test class B")


testclassa().testmethod1()
testclassb().testmethod2()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is almost certainly a better way of doing this, but until someone points that out, this will work:</p>
<pre><code>import inspect

class testclass:
    def testmethod(self):
        log()

def log():
    stack = inspect.stack()
    try:
        print "Whole stack is:"
        print "\n".join([str(x[4]) for x in stack])
        print "-"*20
        print "Caller was %s" %(str(stack[2][4]))
    finally:
        del stack

testclass().testmethod()
</code></pre>
<p>The output of this is the following:</p>
<pre><code>Whole stack is:
['    stack = inspect.stack()\n']
['        f()\n']
['testclass().testmethod()\n']
['                exec code in self.locals\n']
['            ret = method(*args, **kwargs)\n']
None
--------------------
Caller was ['testclass().testmethod()\n']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I personally just tend to name my loggers after classes, as it makes it much easier to track down where a particular message came from. So you can have a root logger named "top", and for the module "a" and class "testclass", I name my logger "top.a.testclass". </p>
<p>I don't see the need to otherwise retrieve the classname, since the log message should give you all the information you need. </p>
<p>@ed's response above, it feels very unpythonic to me and it is not something I would be comfortable with using on production code.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a function to make an informative log message using the representation class method:</p>
<p><a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#repr</a></p>
<pre><code>def log_message(thing: object = None, message: str = '') -&gt; str:
    """:returns: detailed error message using reflection"""
    return '{} {}'.format(repr(thing), message)
</code></pre>
<p>This can be implemented to any class using a mix-in:</p>
<pre><code>class UtilMixin(object):
    def log(self, message: str = '') -&gt; str:
        """:returns: Log message formatting"""
        return log_message(thing=self, message=message)
</code></pre>
<p>You can than be associated with a class using multiple inheritance:</p>
<pre><code>class MyClass(object, UtilMixin):
    def __repr__(self) -&gt; str:
        return '&lt;{}&gt;'.format(self)
    pass
</code></pre>
<p><strong>Usage</strong></p>
<pre><code>logger.warning(self.log('error message goes here'))
</code></pre>
</div>
<span class="comment-copy">The reason the class name is not available by default is that while the function name is readily available from the frame object on the stack - <code>f.f_code.co_name</code> -  the class name is not. Getting the class name would impose a run-time penalty greater than the corresponding benefit - after all, you can already see exactly which file and line the call came from, which is more precise than just the class.</span>
<span class="comment-copy">Yea I've been toying around with <code>inspect</code> too. But it feels very unpythonic. Would be super if there is a way to do the same in <code>logging</code> instead. I can't really come to think of any reason why that functionality shouldn't be there.</span>
<span class="comment-copy">Yes, I agree :)</span>
<span class="comment-copy">I'm using local logging instances for libraries, but I've never used them as local in individual classes. I guess it's the most pythonic way of doing it. But I still don't really see a reason for why the class info shouldn't be there next to the function info.</span>
<span class="comment-copy">When logging to a single log file, the use of local loggers is tricky.</span>
