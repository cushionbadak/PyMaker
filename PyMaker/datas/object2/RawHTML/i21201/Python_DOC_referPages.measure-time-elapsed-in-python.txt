<div class="post-text" itemprop="text">
<p>What I want is to start counting time somewhere in my code and then get the passed time, to measure the time it took to execute few function. I think I'm using the timeit module wrong, but the docs are just confusing for me.</p>
<pre><code>import timeit

start = timeit.timeit()
print "hello"
end = timeit.timeit()
print end - start
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want to measure the elapsed wall-clock time between two points, you could use  <a href="http://docs.python.org/library/time.html#time.time" rel="noreferrer"><code>time.time()</code></a>:</p>
<pre><code>import time

start = time.time()
print("hello")
end = time.time()
print(end - start)
</code></pre>
<p>This gives the execution time in seconds.</p>
<p>Another option since 3.3 might be to use <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer"><code>perf_counter</code></a> or <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="noreferrer"><code>process_time</code></a>, depending on your requirements. Before 3.3 it was recommended to use <a href="http://docs.python.org/library/time.html#time.clock" rel="noreferrer"><code>time.clock</code></a> (thanks <a href="https://stackoverflow.com/users/148870/amber">Amber</a>). However, it is currently deprecated:</p>
<blockquote>
<p>On Unix, return the current processor time as a floating point number
  expressed in seconds. The precision, and in fact the very definition
  of the meaning of “processor time”, depends on that of the C function
  of the same name.</p>
<p>On Windows, this function returns wall-clock seconds elapsed since the
  first call to this function, as a floating point number, based on the
  Win32 function <code>QueryPerformanceCounter()</code>. The resolution is typically
  better than one microsecond.</p>
<p><em>Deprecated since version 3.3</em>: The behaviour of this function depends
  on the platform: <strong>use <code>perf_counter()</code> or <code>process_time()</code> instead</strong>,
  depending on your requirements, to have a well defined behaviour.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>timeit.default_timer</code> instead of <code>timeit.timeit</code>. The former provides the best clock available on your platform and version of Python automatically:</p>
<pre><code>from timeit import default_timer as timer

start = timer()
# ...
end = timer()
print(end - start) # Time in seconds, e.g. 5.38091952400282
</code></pre>
<p><a href="http://docs.python.org/2/library/timeit.html#timeit.default_timer" rel="noreferrer">timeit.default_timer</a> is assigned to time.time() or time.clock() depending on OS. On Python 3.3+ <a href="http://docs.python.org/3/library/timeit#timeit.default_timer" rel="noreferrer">default_timer</a> is <a href="http://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer">time.perf_counter()</a> on all platforms. See <a href="https://stackoverflow.com/q/85451/4279">Python - time.clock() vs. time.time() - accuracy?</a></p>
<p>See also:</p>
<ul>
<li><a href="http://scipy-lectures.github.io/advanced/optimizing/" rel="noreferrer">Optimizing code</a></li>
<li><a href="http://scikit-learn.org/stable/developers/performance.html" rel="noreferrer">How to optimize for speed</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<h1>Python 3 only:</h1>
<p>Since time.clock() <a href="https://docs.python.org/3.3/library/time.html#time.clock" rel="noreferrer">is deprecated as of Python 3.3</a>, you will want to use <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer"><code>time.perf_counter()</code></a> for system-wide timing, or <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="noreferrer"><code>time.process_time()</code></a> for process-wide timing, just the way you used to use <code>time.clock()</code>:</p>
<pre><code>import time

t = time.process_time()
#do some stuff
elapsed_time = time.process_time() - t
</code></pre>
<p>The new function <code>process_time</code> will not include time elapsed during sleep.</p>
</div>
<div class="post-text" itemprop="text">
<p>Given a function you'd like to time,</p>
<p>test.py:</p>
<pre><code>def foo(): 
    # print "hello"   
    return "hello"
</code></pre>
<p>the easiest way to use <code>timeit</code> is to call it from the command line:</p>
<pre><code>% python -mtimeit -s'import test' 'test.foo()'
1000000 loops, best of 3: 0.254 usec per loop
</code></pre>
<p>Do not try to use <code>time.time</code> or <code>time.clock</code> (naively) to compare the speed of functions. <a href="https://stackoverflow.com/questions/1622943/timeit-versus-timing-decorator">They can give misleading results</a>.</p>
<p>PS. Do not put print statements in a function you wish to time; otherwise the time measured will depend on the <a href="https://stackoverflow.com/questions/3857052/why-is-printing-to-stdout-so-slow-can-it-be-sped-up/3860319#3860319">speed of the terminal</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's fun to do this with a context-manager that automatically remembers the start time upon entry to a <code>with</code> block, then freezes the end time on block exit. With a little trickery, you can even get a running elapsed-time tally inside the block from the same context-manager function. </p>
<p>The core library doesn't have this (but probably ought to). Once in place, you can do things like:</p>
<pre><code>with elapsed_timer() as elapsed:
    # some lengthy code
    print( "midpoint at %.2f seconds" % elapsed() )  # time so far
    # other lengthy code

print( "all done at %.2f seconds" % elapsed() )
</code></pre>
<p>Here's <a href="https://docs.python.org/dev/library/contextlib.html#contextlib.contextmanager" rel="noreferrer">contextmanager</a> code sufficient to do the trick:</p>
<pre><code>from contextlib import contextmanager
from timeit import default_timer

@contextmanager
def elapsed_timer():
    start = default_timer()
    elapser = lambda: default_timer() - start
    yield lambda: elapser()
    end = default_timer()
    elapser = lambda: end-start
</code></pre>
<p>And some runnable demo code:</p>
<pre><code>import time

with elapsed_timer() as elapsed:
    time.sleep(1)
    print(elapsed())
    time.sleep(2)
    print(elapsed())
    time.sleep(3)
</code></pre>
<p>Note that by design of this function, the return value of <code>elapsed()</code> is frozen on block exit, and further calls return the same duration (of about 6 seconds in this toy example). </p>
</div>
<div class="post-text" itemprop="text">
<p>I prefer this. <code>timeit</code> doc is far too confusing. </p>
<pre><code>from datetime import datetime 

start_time = datetime.now() 

# INSERT YOUR CODE 

time_elapsed = datetime.now() - start_time 

print('Time elapsed (hh:mm:ss.ms) {}'.format(time_elapsed))
</code></pre>
<p>Note, that there isn't any formatting going on here, I just wrote <code>hh:mm:ss</code> into the printout so one can interpret <code>time_elapsed</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>time.time</code> to measure execution gives you the overall execution time of your commands including running time spent by other processes on your computer. It is the time the user notices, but is not good if you want to compare different code snippets / algorithms / functions / ...</p>
<p>More information on <code>timeit</code>:</p>
<ul>
<li><a href="http://www.diveintopython.net/performance_tuning/timeit.html" rel="noreferrer">Using the timeit Module</a></li>
<li><a href="http://www.doughellmann.com/PyMOTW/timeit/" rel="noreferrer">timeit – Time the execution of small bits of Python code</a></li>
</ul>
<p>If you want a deeper insight into profiling:</p>
<ul>
<li><a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Profiling_Code" rel="noreferrer">http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Profiling_Code</a></li>
<li><a href="https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script">How can you profile a python script?</a></li>
</ul>
<p><strong>Update</strong>: I used <a href="http://pythonhosted.org/line_profiler/" rel="noreferrer">http://pythonhosted.org/line_profiler/</a> a lot during the last year and find it very helpfull and recommend to use it instead of Pythons profile module.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a tiny timer class that returns "hh:mm:ss" string: </p>
<pre><code>class Timer:
  def __init__(self):
    self.start = time.time()

  def restart(self):
    self.start = time.time()

  def get_time_hhmmss(self):
    end = time.time()
    m, s = divmod(end - self.start, 60)
    h, m = divmod(m, 60)
    time_str = "%02d:%02d:%02d" % (h, m, s)
    return time_str
</code></pre>
<p>Usage: </p>
<pre><code># Start timer
my_timer = Timer()

# ... do something

# Get time string:
time_hhmmss = my_timer.get_time_hhmmss()
print("Time elapsed: %s" % time_hhmmss )

# ... use the timer again
my_timer.restart()

# ... do something

# Get time:
time_hhmmss = my_timer.get_time_hhmmss()

# ... etc
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The python cProfile and pstats modules offer great support for measuring time elapsed in certain functions without having to add any code around the existing functions.</p>
<p>For example if you have a python script timeFunctions.py:</p>
<pre><code>import time

def hello():
    print "Hello :)"
    time.sleep(0.1)

def thankyou():
    print "Thank you!"
    time.sleep(0.05)

for idx in range(10):
    hello()

for idx in range(100):
    thankyou()
</code></pre>
<p>To run the profiler and generate stats for the file you can just run:</p>
<pre><code>python -m cProfile -o timeStats.profile timeFunctions.py
</code></pre>
<p>What this is doing is using the cProfile module to profile all functions in timeFunctions.py and collecting the stats in the timeStats.profile file. Note that we did not have to add any code to existing module (timeFunctions.py) and this can be done with any module.</p>
<p>Once you have the stats file you can run the pstats module as follows:</p>
<pre><code>python -m pstats timeStats.profile
</code></pre>
<p>This runs the interactive statistics browser which gives you a lot of nice functionality. For your particular use case you can just check the stats for your function. In our example checking stats for both functions shows us the following:</p>
<pre><code>Welcome to the profile statistics browser.
timeStats.profile% stats hello
&lt;timestamp&gt;    timeStats.profile

         224 function calls in 6.014 seconds

   Random listing order was used
   List reduced from 6 to 1 due to restriction &lt;'hello'&gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
       10    0.000    0.000    1.001    0.100 timeFunctions.py:3(hello)

timeStats.profile% stats thankyou
&lt;timestamp&gt;    timeStats.profile

         224 function calls in 6.014 seconds

   Random listing order was used
   List reduced from 6 to 1 due to restriction &lt;'thankyou'&gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      100    0.002    0.000    5.012    0.050 timeFunctions.py:7(thankyou)
</code></pre>
<p>The dummy example does not do much but give you an idea of what can be done. The best part about this approach is that I dont have to edit any of my existing code to get these numbers and obviously help with profiling.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another context manager for timing code -</p>
<p>Usage: </p>
<pre><code>from benchmark import benchmark

with benchmark("Test 1+1"):
    1+1
=&gt;
Test 1+1 : 1.41e-06 seconds
</code></pre>
<p>or, if you need the time value</p>
<pre><code>with benchmark("Test 1+1") as b:
    1+1
print(b.time)
=&gt;
Test 1+1 : 7.05e-07 seconds
7.05233786763e-07
</code></pre>
<p><strong>benchmark.py</strong>:</p>
<pre><code>from timeit import default_timer as timer

class benchmark(object):

    def __init__(self, msg, fmt="%0.3g"):
        self.msg = msg
        self.fmt = fmt

    def __enter__(self):
        self.start = timer()
        return self

    def __exit__(self, *args):
        t = timer() - self.start
        print(("%s : " + self.fmt + " seconds") % (self.msg, t))
        self.time = t
</code></pre>
<p>Adapted from <a href="http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html" rel="noreferrer">http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Use profiler module. It gives a very detailed profile.</p>
<pre><code>import profile
profile.run('main()')
</code></pre>
<p>it outputs something like:</p>
<pre><code>          5 function calls in 0.047 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 :0(exec)
        1    0.047    0.047    0.047    0.047 :0(setprofile)
        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)
        0    0.000             0.000          profile:0(profiler)
        1    0.000    0.000    0.047    0.047 profile:0(main())
        1    0.000    0.000    0.000    0.000 two_sum.py:2(twoSum)
</code></pre>
<p>I've found it very informative.</p>
</div>
<div class="post-text" itemprop="text">
<p>(With Ipython only) you can use <a href="https://ipython.org/ipython-doc/3/interactive/magics.html#magic-timeit" rel="noreferrer">%timeit</a> to measure average processing time:</p>
<pre><code>def foo():
    print "hello"
</code></pre>
<p>and then:    </p>
<pre><code>%timeit foo()
</code></pre>
<p>the result is something like:</p>
<pre><code>10000 loops, best of 3: 27 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>on python3:</strong></p>
<pre><code>from time import sleep, perf_counter as pc
t0 = pc()
sleep(1)
print(pc()-t0)
</code></pre>
<p>elegant and short.</p>
</div>
<div class="post-text" itemprop="text">
<p>Kind of a super later response, but maybe it serves a purpose for someone. This is a way to do it which I think is super clean.</p>
<pre><code>import time

def timed(fun, *args):
    s = time.time()
    r = fun(*args)
    print('{} execution took {} seconds.'.format(fun.__name__, time.time()-s))
    return(r)

timed(print, "Hello")
</code></pre>
<p>Keep in mind that "print" is a function in Python 3 and not Python 2.7. However, it works with any other function. Cheers!</p>
</div>
<div class="post-text" itemprop="text">
<p>We can also convert time into human-readable time.</p>
<pre><code>import time, datetime

start = time.clock()

def num_multi1(max):
    result = 0
    for num in range(0, 1000):
        if (num % 3 == 0 or num % 5 == 0):
            result += num

    print "Sum is %d " % result

num_multi1(1000)

end = time.clock()
value = end - start
timestamp = datetime.datetime.fromtimestamp(value)
print timestamp.strftime('%Y-%m-%d %H:%M:%S')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here are my findings after going through many good answers here as well as few other articles.</p>
<p>First, you always want to use <code>timeit</code> and not <code>time.time</code> (and in many cases perf counter APIs) because </p>
<ol>
<li><code>timeit</code> selects the best timer available on your OS and Python version. </li>
<li><code>timeit</code> disables garbage collection however this is not something you may or may not want.</li>
</ol>
<p>Now the problem is that timeit is not that simple to use because it needs setup and things get ugly when you have bunch of imports. Ideally you just want  a decorator or use <code>with</code> block and measure time. Unfortunately there is nothing built-in available for this so I created below little utility module.</p>
<p><strong>Timing Utility Module</strong></p>
<pre><code># utils.py
from functools import wraps
import gc
import timeit

def MeasureTime(f):
    @wraps(f)
    def _wrapper(*args, **kwargs):
        gcold = gc.isenabled()
        gc.disable()
        start_time = timeit.default_timer()
        try:
            result = f(*args, **kwargs)
        finally:
            elapsed = timeit.default_timer() - start_time
            if gcold:
                gc.enable()
            print('Function "{}": {}s'.format(f.__name__, elapsed))
        return result
    return _wrapper

class MeasureBlockTime:
    def __init__(self,name="(block)", no_print = False, disable_gc = True):
        self.name = name
        self.no_print = no_print
        self.disable_gc = disable_gc
    def __enter__(self):
        if self.disable_gc:
            self.gcold = gc.isenabled()
            gc.disable()
        self.start_time = timeit.default_timer()
    def __exit__(self,ty,val,tb):
        self.elapsed = timeit.default_timer() - self.start_time
        if self.disable_gc and self.gcold:
            gc.enable()
        if not self.no_print:
            print('Function "{}": {}s'.format(self.name, self.elapsed))
        return False #re-raise any exceptions
</code></pre>
<p><strong>How to Time Functions</strong></p>
<p>Now you can time any function just by putting a decorator in front of it:</p>
<pre><code>import utils

@utils.MeasureTime
def MyBigFunc():
    #do something time consuming
    for i in range(10000):
        print(i)
</code></pre>
<p><strong>How to Time Code Blocks</strong></p>
<p>If you want to time portion of code then just put it inside <code>with</code> block:</p>
<pre><code>import utils

#somewhere in my code

with utils.MeasureBlockTime("MyBlock"):
    #do something time consuming
    for i in range(10000):
        print(i)

# rest of my code
</code></pre>
<p><strong>Advantages</strong></p>
<p>There are several half-backed versions floating around so I want to point out few highlights:</p>
<ol>
<li>Use timer from timeit instead of time.time for reasons described earlier.</li>
<li>Disable GC during timing.</li>
<li>Decorator accepts functions with named or unnamed params.</li>
<li>Ability to disable printing in block timing (use <code>with utils.MeasureBlockTime() as t</code> and then <code>t.elapsed</code>).</li>
<li>Ability to keep gc enabled for block timing.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>One more way to use <a href="https://docs.python.org/2/library/timeit.html" rel="noreferrer">timeit</a>:</p>
<pre class="lang-py prettyprint-override"><code>from timeit import timeit

def func():
    return 1 + 1

time = timeit(func, number=1)
print(time)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I made a library for this, if you want to measure a function you can just do it like this </p>
<pre><code>
from pythonbenchmark import compare, measure
import time

a,b,c,d,e = 10,10,10,10,10
something = [a,b,c,d,e]

@measure
def myFunction(something):
    time.sleep(0.4)

@measure
def myOptimizedFunction(something):
    time.sleep(0.2)

myFunction(input)
myOptimizedFunction(input)
</code></pre>
<p><a href="https://github.com/Karlheinzniebuhr/pythonbenchmark" rel="noreferrer">https://github.com/Karlheinzniebuhr/pythonbenchmark</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use timeit.</p>
<p>Here is an example on how to test naive_func that takes parameter using Python REPL:</p>
<pre><code>&gt;&gt;&gt; import timeit                                                                                         

&gt;&gt;&gt; def naive_func(x):                                                                                    
...     a = 0                                                                                             
...     for i in range(a):                                                                                
...         a += i                                                                                        
...     return a                                                                                          

&gt;&gt;&gt; def wrapper(func, *args, **kwargs):                                                                   
...     def wrapper():                                                                                    
...         return func(*args, **kwargs)                                                                  
...     return wrapper                                                                                    

&gt;&gt;&gt; wrapped = wrapper(naive_func, 1_000)                                                                  

&gt;&gt;&gt; timeit.timeit(wrapped, number=1_000_000)                                                              
0.4458435332577161  
</code></pre>
<p>You don't need wrapper function if function doesn't have any parameters.                                                                                      </p>
</div>
<div class="post-text" itemprop="text">
<p>The only way I can think of is using <code>time.time()</code>.</p>
<pre><code>import time
start = time.time()
sleep(5) #just to give it some delay to show it working
finish = time.time()
elapsed = finish - start
print(elapsed)
</code></pre>
<p>Hope that will help.</p>
</div>
<div class="post-text" itemprop="text">
<p>Measuring time <strong>in seconds:</strong></p>
<pre class="lang-py prettyprint-override"><code>from timeit import default_timer as timer
from datetime import timedelta

start = timer()
end = timer()
print(timedelta(seconds=end-start))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Better use timeit simply: (it run multiple runs for the same command and give you the results). </p>
<p>Example is given below:</p>
<pre><code>%timeit import pandas as pd
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to <code>%timeit</code> in <em>ipython</em> you can also use <strong><code>%%timeit</code></strong> for multi-line code snippets:</p>
<pre><code>In [1]: %%timeit
   ...: complex_func()
   ...: 2 + 2 == 5
   ...:
   ...:

1 s ± 1.93 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>Also it can be used in <strong>jupyter notebook</strong> the same way, just put <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit" rel="nofollow noreferrer">magic <code>%%timeit</code></a> at the beginning of cell.</p>
</div>
<span class="comment-copy">The correct way to use timeit is: &gt;&gt;&gt; <code>t = timeit.Timer('char in text', setup='text = "sample string"; char = "g"')</code> &gt;&gt;&gt; <code>t.timeit()</code></span>
<span class="comment-copy">and for microseconds, use datetime.time()</span>
<span class="comment-copy">(For performance measurement, <code>time.clock()</code> is actually preferred, since it can't be interfered with if the system clock gets messed with, but <code>.time()</code> does mostly accomplish the same purpose.)</span>
<span class="comment-copy">I think that python -mtimeit is way better as it runs more times and it is build as a native way to measure time in python</span>
<span class="comment-copy">Is there a nice way of converting resulting execturion time in seconds to something like HH:MM::SS?</span>
<span class="comment-copy">@Danijel: <code>print(timedelta(seconds=execution_time))</code>. Though it is a separate question.</span>
<span class="comment-copy">Excellent answer - using <b>timeit</b> will produce far more accurate results since it will automatically account for things like garbage collection and OS differences</span>
<span class="comment-copy">This gives time in ms or seconds?</span>
<span class="comment-copy">@KhushbooTiwari in fractional seconds.</span>
<span class="comment-copy">I think this note from the official documentation needs to be added <code>default_timer() measurations can be affected by other programs running on the same machine, so the best thing to do when accurate timing is necessary is to repeat the timing a few times and use the best time. The -r option is good for this; the default of 3 repetitions is probably enough in most cases. On Unix, you can use time.clock() to measure CPU time.</code></span>
<span class="comment-copy">@KGS: Performance measurement is very tricky in a subtle way (it is easy to mislead yourself). There are many other remarks that could be relevant here. Follow the links in the answer.  You might be also interested in the <a href="https://perf.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>perf</code> module (nonexistent at the time of the answer)</a> that provides the same interface but it sometimes makes different from the <code>timeit</code> module decisions about how to measure time performance.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/25823885/4279">Use <code>timeit.default_timer</code></a> instead of <code>time.perf_counter</code>. The former will choose the appropriate timer to measure the time performance tuned for your platform and Python version. <code>process_time()</code> does <i>not</i> include the time during sleep and therefore it is not appropriate to measure elapsed time.</span>
<span class="comment-copy">I'm using the implementation suggested by Pierre, are the values given in seconds?</span>
<span class="comment-copy">Other context manager example: <a href="http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html" rel="nofollow noreferrer">dabeaz.blogspot.fr/2010/02/…</a></span>
<span class="comment-copy">@Jérôme nice example - I adapted it as another answer - <a href="http://stackoverflow.com/a/41408510/243392">stackoverflow.com/a/41408510/243392</a></span>
<span class="comment-copy">I was told that timeit calculates the CPU time, does datetime also take into account CPU time used? Are these the same thing?</span>
<span class="comment-copy">All this is fine, but AFAICT this still measures CPU time, not wall clock time.</span>
<span class="comment-copy">Actually there is some confusion; it appears cProfile does look at wall-clock time by default. I've upvoted your answer.</span>
<span class="comment-copy">FYI: If you get <code>python -m pstats timeStats.profile ValueError: bad marshal data (unknown type code)</code> check your python version you are running.  I got this when i ran <code>python3 -m cProfile...</code> and <code>python -m pstats</code>. My mistake but got me for a second, so, I wanted to share <code>don't forget consistency</code>. =)</span>
<span class="comment-copy">What is <code>main()</code>? Would be more useful if you could provide a simple code example.</span>
<span class="comment-copy">It worth to mention it is possible to pass flags to %timeit, for example -n specifies how many times the code should be repeated.</span>
<span class="comment-copy">How can I print very small times? I kind of am getting 0.0sec always</span>
<span class="comment-copy">You can turn this into a decorator; this looks even better to me.</span>
<span class="comment-copy">This solution is perfect.</span>
<span class="comment-copy">A <code>lambda</code> would be more succinct: <code>print(timeit.timeit(lambda: naive_func(1_000), number=1_000_000))</code></span>
