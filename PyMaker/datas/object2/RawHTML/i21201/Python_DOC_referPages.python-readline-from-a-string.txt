<div class="post-text" itemprop="text">
<p>In python, is there a built-in way to do a readline() on string?  I have a large chunk of data and want to strip off just the first couple lines w/o doing split() on the whole string.</p>
<p>Hypothetical example:</p>
<pre><code>def handleMessage(msg):
   headerTo  = msg.readline()
   headerFrom= msg.readline()
   sendMessage(headerTo,headerFrom,msg)

msg = "Bob Smith\nJane Doe\nJane,\nPlease order more widgets\nThanks,\nBob\n"
handleMessage(msg)
</code></pre>
<p>I want this to result in:
 <code>sendMessage("Bob Smith", "Jane Doe", "Jane,\nPlease order...")</code></p>
<p>I know it would be fairly easy to write a class that does this, but I'm looking for something built-in if possible.</p>
<p>EDIT: Python v2.7</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 2</h2>
<p>You can use <a href="http://docs.python.org/library/stringio.html">StringIO</a>:</p>
<pre><code>&gt;&gt;&gt; msg = "Bob Smith\nJane Doe\nJane,\nPlease order more widgets\nThanks,\nBob\n"
&gt;&gt;&gt; msg
'Bob Smith\nJane Doe\nJane,\nPlease order more widgets\nThanks,\nBob\n'
&gt;&gt;&gt; import StringIO
&gt;&gt;&gt; buf = StringIO.StringIO(msg)
&gt;&gt;&gt; buf.readline()
'Bob Smith\n'
&gt;&gt;&gt; buf.readline()
'Jane Doe\n'
</code></pre>
<p>Be sure to use <a href="http://docs.python.org/2/library/stringio.html#module-cStringIO">cStringIO</a> if performance is important.</p>
<h2>Python 3</h2>
<p>You can use <a href="http://docs.python.org/3/library/io.html#io.StringIO">io.StringIO</a>:</p>
<pre><code>&gt;&gt;&gt; import io
&gt;&gt;&gt; buf = io.StringIO(msg)
&gt;&gt;&gt; buf.readline()
'Bob Smith\n'
&gt;&gt;&gt; buf.readline()
'Jane Doe\n'
&gt;&gt;&gt; len(buf.read())
44
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not just only do as many splits as you need? Since you're using all of the resulting parts (including the rest of the string), loading it into some other buffer object and then reading it back out again is probably going to be slower, not faster (plus the overhead of function calls).</p>
<p>If you want the first <code>N</code> lines separated out, just do <code>.split("\n", N)</code>.</p>
<pre><code>&gt;&gt;&gt; foo = "ABC\nDEF\nGHI\nJKL"
&gt;&gt;&gt; foo.split("\n", 1)
['ABC', 'DEF\nGHI\nJKL']
&gt;&gt;&gt; foo.split("\n", 2)
['ABC', 'DEF', 'GHI\nJKL']
</code></pre>
<p>So for your function:</p>
<pre><code>def handleMessage(msg):
   headerTo, headerFrom, msg = msg.split("\n", 2)
   sendMessage(headerTo,headerFrom,msg)
</code></pre>
<p>or if you really wanted to get fancy:</p>
<pre><code># either...
def handleMessage(msg):
   sendMessage(*msg.split("\n", 2))

# or just...
handleMessage = lambda msg: sendMessage(*msg.split("\n", 2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way for both python 2 and 3 is using string's method <a href="https://docs.python.org/3.6/library/stdtypes.html#str.splitlines" rel="noreferrer">splitlines</a>(). This returns a list of lines.</p>
<pre><code>&gt;&gt;&gt; "some\nmultilene\nstring\n".splitlines()
</code></pre>
<p>['some', 'multilene', 'string']</p>
</div>
<div class="post-text" itemprop="text">
<p>Do it like StringIO does it:</p>
<pre><code>i = self.buf.find('\n', self.pos)
</code></pre>
<p>So this means: </p>
<pre><code>pos = msg.find("\n")
first_line = msg[:pos]
...
</code></pre>
<p>Seems more elegant than using the whole StringIO...</p>
</div>
<div class="post-text" itemprop="text">
<p>in Python string have method splitlines</p>
<pre><code>msg = "Bob Smith\nJane Doe\nJane,\nPlease order more widgets\nThanks,\nBob\n"
msg_splitlines = msg.splitlines()
headerTo = msg_splitlines[0]
headerFrom= msg_splitlines[1]
sendMessage(headerTo,headerFrom,msg)
</code></pre>
</div>
<span class="comment-copy">+1. And if performance is an issue <code>cStringIO</code> may help.</span>
<span class="comment-copy">Perfect.  <code>buf.read()</code> what's left of the buffer after reading a certain number of lines.</span>
<span class="comment-copy">Just found out that <code>io.StringIO</code> is the class if using Python 3.3</span>
<span class="comment-copy">Why allocating extra memory for buf?</span>
<span class="comment-copy">This works if you don't mind dealing with exceptions and/or checking array lengths that come with split AND you know how many lines to read in advance.  I don't know how many header lines there are in advance.  Perhaps my example was excessively trivial.</span>
<span class="comment-copy">If you're inspecting things as you go, then yes, StringIO is probably your best bet. (No worries re: examples - constructing the appropriate example can often be a difficult balance between simplifying and not losing context.)</span>
<span class="comment-copy">Best answer IMO</span>
<span class="comment-copy">And str.splitlines() is cross-platform, regardless the style of line endings like \r\n or \n.</span>
<span class="comment-copy">For me best answer, built-in function.</span>
<span class="comment-copy">It would have been even nicer if splitlines would be a generator so gives you one line at a time. Sometimes you don't need to parse the whole buffer/string (which might be big).</span>
