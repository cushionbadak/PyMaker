<div class="post-text" itemprop="text">
<p>I am currently struggling with an assignment. The solution would input a txt file and run through counting the number of palindromes and their frequency. I need to use Map reduce to create to do so </p>
<p>For example: the string "bab bab bab cab cac dad" would output:</p>
<pre><code>bab 3
cab 1
dad 1
</code></pre>
<p>Here is what I have so far</p>
<pre><code>def palindrome(string):
    palindromes = []
    for word in string.split(" "):
        if (word == word[::-1]):
            palindromes.append(word)
    return palindromes 

string = "abc abd bab tab cab tat yay uaefdfdu"
print map(lambda x: palindrome(x), ["bab abc dab bab bab dad crap pap pap "])
</code></pre>
<p>Currently prints </p>
<pre><code>[['bab', 'bab', 'bab', 'dad', 'pap', 'pap', '']]
</code></pre>
<p>Here is my attempt so far at the reduce section</p>
<pre><code>def p(lists):
for list in lists:

set_h = set(list) 

return set_h
</code></pre>
<p>with the p function I want to create a set of all palindromes found. Then run a count of the palindromes on the list and make a dict out of this</p>
<pre><code>print reduce(p, [['bab', 'bab', 'bab', 'dad', 'pap', 'pap', '']])
</code></pre>
<p>Am I on the right track?</p>
</div>
<div class="post-text" itemprop="text">
<p>Split your string into a list <em>before</em> you map it.  <strong>map()</strong> is for lists, sets, and dicts, <em>not</em> strings.</p>
<pre><code>word_list = words_str.split(" ")
</code></pre>
<p>Avoid using <em>map-filter-reduce</em> unless your assignment dictates it; <a href="http://www.python.org/~guido/" rel="nofollow">GVR</a> <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow">says so</a>.  The proper solution uses Python's <a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> syntax.  In fact, you can do it with a pretty nasty one-liner:</p>
<pre><code>pal_count = {
    x: word_list.count(x)  # reduce-ish
    for x in word_list     # map-ish
    if x == x[::-1]        # filter-ish
    }
for x, y in pal_count.iteritems():
    print x, y             # print the results!
</code></pre>
<p>Breaking it down...</p>
<ol>
<li>Catch this in a dictionary object to print it later: <code>pal_count = {</code></li>
<li>Define the return objects: <code>x: word_list.count(x)</code>  We use key:value syntax to associate the palindrome, <em>x</em>, with its number of occurrences.  <strong><a href="http://docs.python.org/library/stdtypes.html#str.count" rel="nofollow">count()</a></strong> is like a built-in reduce function for lists.</li>
<li>Iterate through our list with a <strong>for loop</strong>, assigning the current value to 'x': <code>for x in word_list</code></li>
<li>We only want to return palindromes, so we add a comparison operator to <em>filter</em> out bad values: <code>if x == x[::-1] # cool logic, btw</code> </li>
<li>Hurray! <code>}</code></li>
</ol>
<p>By the way, I'm only doing your homework because I never did mine.</p>
<p>The slower, less flexible, less portable, less <em>awesome</em> equivalent uses nested for loops:</p>
<pre><code>pal_count = dict()
for x in word_list:                     # same loop
    if x == x[::-1]                     # is this a palindrome?
        if x in pal_count:              # have we seen before?
            pal_count[x] += 1
        else:                           # this one is new!
            pal_count.setdefault(x, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think it would be much easier for you if your <code>map()</code> and <code>reduce()</code> input was an actual list of words. To achieve that, <code>.split()</code> the string before passing it to <code>map()</code>. Then <code>map()</code> a word either to itself (if your mapper encounters a palindrome) or <code>None</code>. You can then <code>filter()</code> the results to discard <code>None</code> values, sort it and pass it to <code>reduce()</code>. <code>reduce()</code> would then reduce it to a <code>dict</code> mapping words to their total count.</p>
<p>I will not provide you with a working solution not to take away from the learning factor.</p>
</div>
<div class="post-text" itemprop="text">
<p>For your reduce function, you should start off with an empty dict and update/populate your counts. Reduce functions require 2 parameters, so one can be your dict, and the other, your palindrome. You can feed in an initial value in reduce like so:</p>
<pre><code>reduce(lambda x, y: x+y, some_list, initial_value_for_x)
</code></pre>
<p>Take a look at <a href="http://docs.python.org/library/stdtypes.html#dict.get" rel="nofollow">dict's get</a> for how to set default values, which should help you simplify your reduce function a lot.</p>
</div>
<div class="post-text" itemprop="text">
<p>It would be very simple if we decompose the problem into small challenges. In our case this could be:</p>
<ol>
<li>Filter out all the palindromes from the list of words.</li>
<li>Get unique words to find the count.</li>
<li>Map all the unique words to their appropriate count.</li>
</ol>
<h1>Code:</h1>
<pre><code>words =  "bab bab bab cab cac dad"
is_palindrome = lambda word : word == word[::-1]
palindromes = filter(is_palindrome,words.split(" "))
get_count = lambda word : (word , palindromes.count(word))
unique = set(palindromes)
dict(map(get_count,unique))
Out[1]: {'bab': 3, 'cac': 1, 'dad': 1}
</code></pre>
<p>Here is the short explanation:</p>
<pre><code>#Input:
    words =  "bab bab bab cab cac dad"

#Step 1: Filter out the palindromes.
    is_palindrome = lambda word : word == word[::-1]
    palindromes = filter(is_palindrome,words.split(" "))

#Step 2: Get the unique set of string to find their counts.
    unique = set(palindromes)

#Step 3: Map every unique palindrome to their respective count.
    get_count = lambda word : (word , palindromes.count(word))
    dict(map(get_count,unique))

#Output:
    Out[1]: {'bab': 3, 'cac': 1, 'dad': 1}
</code></pre>
<p><strong>NOTE:</strong> map in python can accept any sequence, not just list, set or dict. Strings in python are also sequence, hence not satisfied with Cody Hess's statement: map cannot accept strings. </p>
<p>To demonstrate here is the very simple demo:</p>
<pre><code>In [10]: map(echo, "python")
Out[10]: ['p', 'y', 't', 'h', 'o', 'n']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For map/reduce, using <code>Counter</code> object is pretty straight forward.</p>
<pre><code>from collections import Counter 
words = "bab bab bab cab cac dad"
words_list = words.split(" ") 
cont = Counter()
for word in words_list:
    cont[word] += 1
print(cont)
# or if you want dict
print(dict(cont))
</code></pre>
<p><a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html</a></p>
</div>
<span class="comment-copy">It's "palindrome"... I fixed the spelling and cleaned up the formatting.</span>
<span class="comment-copy">Should be tagged with <code>homework</code></span>
<span class="comment-copy">FYI, map(lambda x: palindrome(x), ...) is redundant. You can just as easily do map(palindrome, ...) and get the same results. However, you should probably also re-think your palindrome() function to operate on only a single item at a time, and split your input in advance. Also remember that you will need to have the results sorted between the map and reduce steps.</span>
<span class="comment-copy">It's not cool to provide complete working solutions to problems marked as homework or assignments. Not sure why you consider the second version to be slower. Calling <code>.count()</code> on large datasets is not the fastest thing on earth, especially if you call it for every occurence of the same word. For your second example, use <code>pal_count.setdefault(x, 0)</code> followed by <code>pal_count[x] += 1</code> or <code>pal_count[x] = pal_count.setdefault(x, 0) + 1</code>.</span>
<span class="comment-copy">@patrys Sorries... I was just excited that I was actually able to answer something; feel free to flag it.  And thanks for the tip at <code>pal_count[x] = pal_count.setdefault(x, 0) + 1</code> - very cool way to solve a common problem.</span>
<span class="comment-copy">if you're using a modern (2.5+) version of Python, you can also use: <code>pal_count = defaultdict(int)</code> and then just <code>pal_count[x] += 1</code>.</span>
<span class="comment-copy">Oooh <a href="http://docs.python.org/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a>!  I've ignored that many times while scanning the docs.  Now you can't flag my answer because there's so much learning going on in the comments :-p</span>
<span class="comment-copy">so basically, the map function will see if any of the words in the list are palindromes. if so then add them to a different list?      <code>palindrome = []     def palindromes(word):         if (word == word[::-1]):             palindrome.append(word)         return palindromes         map(palindromes, list_of_strings)</code></span>
<span class="comment-copy">The philosophy of <code>map()</code> is that it will only feed the mapping function with one token at a time and the mapping function should only return one mapped value at a time. Same applies to <code>reduce()</code>â€”it will only pass tokens to reductor one by one. You should not have to maintain your own lists in your mapper / reductor functions. In fact you don't need <code>filter()</code> either because reductor can just check for <code>None</code> and do ignore it.</span>
