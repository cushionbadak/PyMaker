<div class="post-text" itemprop="text">
<p>I have a set of values and would like to create list of all subsets containing 2 elements. </p>
<p>For example, a source set <code>([1,2,3])</code> has the following 2-element subsets: </p>
<pre><code>set([1,2]), set([1,3]), set([2,3])
</code></pre>
<p>Is there a way to do this in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems like you want <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>:</p>
<pre><code>&gt;&gt;&gt; list(itertools.combinations((1, 2, 3), 2))
[(1, 2), (1, 3), (2, 3)]
</code></pre>
<p>If you want sets you'll have to convert them explicitly. If you don't mind an iterable instead of a list, and you're using Python 3, you can use <code>map</code>:</p>
<pre><code>&gt;&gt;&gt; s = set((1, 2, 3))
&gt;&gt;&gt; map(set, itertools.combinations(s, 2))
&lt;map object at 0x10cdc26d8&gt;
</code></pre>
<p>To view all the results at once, you can pass the output of <code>map</code> to <code>list</code>. (In Python 2, the output of <code>map</code> is automatically a list.)</p>
<pre><code>&gt;&gt;&gt; list(map(set, itertools.combinations(s, 2)))
[{1, 2}, {1, 3}, {2, 3}]
</code></pre>
<p>However, if you know you'll need a list, a list comprehension is marginally better (h/t <a href="https://stackoverflow.com/questions/7378180/generate-all-subsets-of-size-k-containing-k-elements-in-python/7378313#comment8907520_7378313">Jacob Bowyer</a>):</p>
<pre><code>&gt;&gt;&gt; [set(i) for i in itertools.combinations(s, 2)]
[{1, 2}, {1, 3}, {2, 3}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a subset of the <a href="http://en.wikipedia.org/wiki/Power_set" rel="nofollow">power set</a> of <code>{1, 2, 3}</code> (or whatever set) containing all two-element sets. </p>
<p>See the  <a href="http://docs.python.org/library/itertools.html" rel="nofollow">Python <code>itertools</code> documentation</a> and search on the term "powerset" for a general answer to this problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to give another perspective, I looked for a way to iterate all subset of size 2 of <code>{1.....N}</code>, so I put <code>itertools.combinations</code> into test:</p>
<pre><code>import itertools
from time import time


N = 7000
lst = [i for i in xrange(N)]

st = time()
c1 = 0
for x in itertools.combinations(lst, 2):
    c1 += 1
print "combinations: %f" % (time()-st)

st = time()
c2=0
for x in xrange(N):
    for y in xrange(x):
        c2 += 1
print "double loop: %f" % (time()-st)
print "c1=%d,c2=%d" % (c1,c2)

# prints:
#combinations: 4.247000
#double loop: 3.479000
# c1=24496500,c2=24496500
</code></pre>
<p>So I guess you should not always turn into the general solution.... If you know in advance the size of the subset you want, it should be more efficient to iterate using for loops.</p>
<p>Also note that you should not iterate over <code>list(itertools.combinations(lst, 2))</code> since this move creates the list (and much slower than using the generator itself).</p>
</div>
<span class="comment-copy">Damn it!, by the way your map can be done with a list comp <code>[set(i) for i in itertools.combinations(s, 2))]</code></span>
<span class="comment-copy">These two tests don't do the same thing. <code>itertools.combinations</code> actually creates a tuple; your nested loop doesn't create a tuple.</span>
<span class="comment-copy">I did a quick test. If you actually need to create tuples inside the nested loop, it's slower by 50%. Furthermore, if you don't need to use a <code>for</code> loop to process the output of <code>itertools.combinations</code>, you can get a substantial speedup with this generator expression: <code>c3 = sum(1 for pair in itertools.combinations(lst, 2))</code>. That runs about 40% faster than the fastest nested loop. There are always many subtleties to consider when optimizing this kind of code!</span>
