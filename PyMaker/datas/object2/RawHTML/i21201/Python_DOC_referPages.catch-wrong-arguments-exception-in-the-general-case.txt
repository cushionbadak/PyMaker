<div class="post-text" itemprop="text">
<p>I want to catch an exception, but only if it comes from the very next level of logic.</p>
<p>The intent is to handle errors caused by the act of calling the function with the wrong number of arguments, without masking errors generated by the function implementation.</p>
<p>How can I implement the <code>wrong_arguments</code> function below?</p>
<p>Example:</p>
<pre><code>try:
    return myfunc(*args)
except TypeError, error:
    #possibly wrong number of arguments
    #we know how to proceed if the error occurred when calling myfunc(), 
    #but we shouldn't interfere with errors in the implementation of myfunc
    if wrong_arguments(error, myfunc):
        return fixit()
    else:
        raise
</code></pre>
<hr/>
<p>Addendum:</p>
<p>There are several solutions that work nicely in the simple case, but none of the current answers will work in the real-world case of decorated functions.</p>
<p>Consider that these are possible values of <code>myfunc</code> above:</p>
<pre><code>def decorator(func):
    "The most trivial (and common) decorator"
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)

def myfunc1(a, b, c='ok'):
    return (a, b, c)

myfunc2 = decorator(myfunc1)
myfunc3 = decorator(myfunc2)
</code></pre>
<p>Even the conservative look-before-you-leap method (inspecting the function argument spec) fails here, since most decorators will have an argspec of <code>*args, **kwargs</code> regardless of the decorated function. Exception inspection also seems unreliable, since <code>myfunc.__name__</code> will be simply "wrapper" for most decorators, regardless of the core function's name.</p>
<p>Is there any good solution if the function may or may not have decorators?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do:</p>
<pre><code>    try:
        myfunc()
    except IndexError:
        trace = sys.exc_info()[2]
        if trace.tb_next.tb_next is None:
            pass
        else:
            raise
</code></pre>
<p>Although it is kinda ugly and would seem to violate encapsulation.</p>
<p>Stylistically, wanting to catch having passed too many arguments seem strange. I suspect that a more general rethink of what you are doing may resolve the problem. But without more details I can't be sure. </p>
<p><strong>EDIT</strong></p>
<p>Possible approach: check if function you are calling has the arguments <code>*args,**kwargs</code>. If it does, assume its a decorator and adjust the code above to check if the exception was one further layer in. If not, check as above.</p>
<p>Still, I think you need to rethink your solution. </p>
</div>
<div class="post-text" itemprop="text">
<p>I am not a fan of doing magic this way. I suspect you have an underlying design problem rather.</p>
<p>--original answer and code which was too unspecific to the problem removed--</p>
<p>Edit after understanding specific problem:</p>
<pre><code>from inspect import getargspec

def can_call_effectively(f, args):
    (fargs, varargs, _kw, df) = getattr(myfunc, 'effective_argspec', \
        getargspec(myfunc))
    fargslen = len(fargs)
    argslen = len(args)
    minargslen = fargslen - len(df)
    return (varargs and argslen &gt;= minargslen) or minargslen &lt;= argslen &lt;= fargslen

if can_call_effectively(myfunc, args)
    myfunc(*args)
else:
    fixit()
</code></pre>
<p>All your decorators, or at least those you want to be transparent in regard to
calling via the above code, need to set 'effective_argspec' on the returned callable.
Very explicit, no magic. To achieve this, you could decorate your decorators with the appropriate code...</p>
<p>Edit: more code, the decorator for transparent decorators.</p>
<pre><code>def transparent_decorator(decorator):
    def wrapper(f):
        wrapped = decorator(f)
        wrapped.__doc__ = f.__doc__
        wrapped.effective_argspec = getattr(f, 'effective_argspec', getargspec(f))
        return wrapped
    return wrapper
</code></pre>
<p>Use this on your decorator:</p>
<pre><code>@transparent_decorator
def decorator(func):
"The most trivial (and common) decorator"
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper  # line missing in example above
</code></pre>
<p>Now if you create myfunc1 - myfunc3 as above, they work exactly as expected.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ugh unfortunately not really.  Your best bet is to introspect the error object that is returned and see if myfunc and the number of arguments is mentioned.</p>
<p>So you'd do something like:</p>
<pre><code>except TypeError, err:
    if err.has_some_property or 'myfunc' in str(err):
        fixit()
    raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can do it by doing something like</p>
<pre><code>&gt;&gt;&gt; def f(x,y,z):
    print (f(0))


&gt;&gt;&gt; try:
    f(0)
except TypeError as e:
    print (e.__traceback__.tb_next is None)


True
&gt;&gt;&gt; try:
    f(0,1,2)
except TypeError as e:
    print (e.__traceback__.tb_next is None)


False
</code></pre>
<p>but a better way should be to count the number of args of function and comparing with the number of args expected</p>
<pre><code>len(inspect.getargspec(f).args) != len (args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can retrieve the traceback and look at its length. Try:</p>
<pre><code>import traceback as tb
import sys

def a():
    1/0

def b():
    a()

def c():
    b()

try:
    a()
except:
    print len(tb.extract_tb(sys.exc_traceback))

try:
    b()
except:
    print len(tb.extract_tb(sys.exc_traceback))

try:
    c()
except:
    print len(tb.extract_tb(sys.exc_traceback))
</code></pre>
<p>This prints</p>
<pre><code>2
3
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well-written wrappers will preserve the function name, signature, etc, of the functions they wrap; however, if you have to support wrappers that don't, or if you have situations where you want to catch an error in a wrapper (not just the final wrapped function), then there is no general solution that will work.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is an old post, but I stumbled with this question and later with a better answer. This answer depends on a new feature in python 3, <a href="https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow">Signature objects</a></p>
<p>With that feature you can write:</p>
<pre class="lang-py prettyprint-override"><code>sig = inspect.signature(myfunc)
try:
    sig.bind(*args)
except TypeError:
    return fixit()
else:
    f(*args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems to me what you're trying to do is exactly the problem that exceptions are supposed to solve, ie where an exception will be caught somewhere in the call stack, so that there's no need to propagate errors upwards.</p>
<p>Instead, it sounds like you are trying to do error handling the C (non-exception handling) way, where the return value of a function indicates either no error (typically 0) or an error (non 0 value).  So, I'd try just writing your function to return a value, and have the caller check for the return value.</p>
</div>
<span class="comment-copy">The answer: don't do this. Why do you want to handle the case of a function having the wrong number of arguments? I think solving your underlying problem in a different way will lead to a better solution.</span>
<span class="comment-copy">When calling python functions through the C API, it would be nice to be able to catch the wrong arguments error.  That is, when invoking pValue = PyObject_CallObject(pFunc, pArgs); is there a way to detect when there is a mismatch between the arguments passed from C++ and what the Python function is expecting?  Right now, it just returns immediately with no hint as to what went wrong.</span>
<span class="comment-copy">@user2787699: That's a question, not a comment.</span>
<span class="comment-copy">Beat me to it, this is the most reliable way to deal with this.  See the library info on <a href="http://docs.python.org/reference/compound_stmts.html#the-try-statement" rel="nofollow noreferrer"><code>try</code>statements</a> and on the associated <a href="http://docs.python.org/reference/datamodel.html#types" rel="nofollow noreferrer">Traceback objects</a></span>
<span class="comment-copy">+1 for the answer AND the invitation to rethink the need.</span>
<span class="comment-copy">I have no clue what you're aiming at here. It seems you want me to annotate all pieces of code that may throw an error, but if I knew that, there would be no errors to begin with...</span>
<span class="comment-copy">No, I just wanted to use different exceptions for different errors, so you can easily distinguish them in error handlers. I may have misunderstood exception_level(1) though, is this supposed to be true for an exception inside myfunc, or for an exception outside myfunc but just calling it?</span>
<span class="comment-copy">I want to catch an exception caused by the act of calling the function with the wrong arguments, without masking errors generated by the function implementation.</span>
<span class="comment-copy">That's pretty hard and I doubt there's a fully correct solution without touching your other code, because code generated by the decorator now effectively is part of the function implementation. I'd try a variant of look-before-leap. Either it has to inspect and handle all used decorators by following their internal attributes to the original function (if it's in an anonymous closure you are out of luck), or all your (modified) decorators provide the result of inspect.getargspec(origfunc) as an additional wrapper attribute. I'll try to provide some code.</span>
<span class="comment-copy">Almost transparent. (Yep year old grave-robbing is fun.)  The transparent decorator implementation above is currently incompatible with doctests.  Might want <code>wrapped.__doc__ = f.__doc__</code> after <code>wrapped = ...</code>   And also, there is still an <code>File "filename.py", line XX, in wrapper return func(*args, **kwargs)</code> in the stacktrace for exceptions thrown from invocation of @decorator fn.</span>
<span class="comment-copy">myfunc is a variable, so I'd have to use myfunc.__name__</span>
<span class="comment-copy">it's not "better", it's just look-before-you-leap style. This piece of code will succeed 99% of the time, so it's better to not inspect. See: <a href="http://docs.python.org/glossary.html#term-lbyl" rel="nofollow noreferrer">docs.python.org/glossary.html#term-lbyl</a></span>
<span class="comment-copy">Note that <code>exception.__traceback__</code> is python3-specific.</span>
<span class="comment-copy">The return value is irrelevant in the case where calling the function fails with <code>ValueError("wrong number of arguments")</code></span>
