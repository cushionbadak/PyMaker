<div class="post-text" itemprop="text">
<p>Is it possible to change python source file while running an application and have this changes reflected immediately in the application?</p>
<p>Let say I have a foo.py file with a class Foo. In other module I'm calling functions on the Foo on user action. Now, I would like to change source of the Foo without restarting the application and on next user input see the results of the new code.</p>
<p>Would that be possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, but it ill advised — code which changes itself (although necessary in some cases) is notoriously hard to debug. You're looking for the <a href="https://docs.python.org/3/library/imp.html#imp.reload" rel="nofollow noreferrer"><code>reload</code></a> method. The way that you would get it to work would be to modify the source file and then call reload on the module, then repeat.</p>
<p>You do have the option of re-assigning and modifying the code within the application itself — something which does not risk race conditions and it will also allow for a more consistent and testable environment. For an example, I would recomment <a href="https://stackoverflow.com/questions/7573599/change-python-source-while-running/7573631#7573631"><code>Ignacio Vazquez-Abrams</code>'s answer</a>.</p>
<hr/>
<p>Have you tried to see what you could manage by merely changing a state (an external config file, database entry, etc)</p>
</div>
<div class="post-text" itemprop="text">
<p>The following module can probably change whatever you need, not that it's a good idea to use, other than to muck around : )</p>
<p>Note that it will not change your source, which would probably be a disaster, especially if you make a coding error.  The 'safer' option would be to play with byteplay</p>
<p><a href="http://wiki.python.org/moin/ByteplayDoc">http://wiki.python.org/moin/ByteplayDoc</a></p>
<blockquote>
<p>Ok, now let's play! Say we want to change the function, to print its arguments in reverse order. To do this, we will add a ROT_TWO opcode after the two arguments were loaded to the stack. See how simple it is:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from byteplay import *
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; def f(a, b):
...     print (a, b)
...
&gt;&gt;&gt; f(3, 5)
(3, 5)
&gt;&gt;&gt; c = Code.from_code(f.func_code)
&gt;&gt;&gt; c.code[3:3] = [(ROT_TWO, None)]
&gt;&gt;&gt; f.func_code = c.to_code()
&gt;&gt;&gt; f(3, 5)
(5, 3)
&gt;&gt;&gt; f(3, 5)
(5, 3)
</code></pre>
<p>If you are using a defined set of options but want to preserve the same function call, you can also do something like the following</p>
<pre><code>class Foo(object):
     def fn(self):
         pass
     def op1(self):
         print "HELLO"
     #etc

&gt;&gt;&gt; a = Foo()
&gt;&gt;&gt; a.fn()
&gt;&gt;&gt; a.fn = a.op1
&gt;&gt;&gt; a.fn()
HELLO
</code></pre>
</div>
<span class="comment-copy">What is your reason for wanting to do this? What is the use case?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/437589/how-do-i-unload-reload-a-python-module" title="how do i unload reload a python module">stackoverflow.com/questions/437589/…</a></span>
<span class="comment-copy">@jhocking: just testing something while being lazy to write proper tests</span>
<span class="comment-copy">@Miroslav, the lazy thing to do is to <i>write the tests</i>. Trying to do it some weird, crazy way will only serve to introduce bugs (silent and otherwise) which will make your testing harder or even wrong.</span>
<span class="comment-copy">@MikeGraham This is an excellent exercise to help learn how the language works. After one understands how it works, it stops being weird and crazy.</span>
<span class="comment-copy">"Hopelessly ill advised" is more like it. Using <code>reload</code> is fundamentally buggy, and not the right tool for OP's actual problem.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/a/437591/2415524">stackoverflow.com/a/437591/2415524</a></span>
