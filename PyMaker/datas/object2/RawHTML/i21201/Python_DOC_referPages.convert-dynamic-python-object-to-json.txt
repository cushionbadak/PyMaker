<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Possible Duplicate:</strong><br/>
<a href="https://stackoverflow.com/questions/1458450/python-serializable-objects-json">Python serializable objects json</a> </p>
</blockquote>
<p>I need to know how to convert a dynamic python object into JSON.  The object must be able to have multiple levels object child objects.  For example:</p>
<pre class="lang-py prettyprint-override"><code>class C(): pass
class D(): pass

c = C()
c.dynProperty1 = "something"
c.dynProperty2 = { 1, 3, 5, 7, 9 }
c.d = D()
c.d.dynProperty3 = "d.something"

# ... convert c to json ...
</code></pre>
<p>Using python 2.6 the following code:</p>
<pre class="lang-py prettyprint-override"><code>import json

class C(): pass
class D(): pass

c = C()
c.what = "now?"
c.now = "what?"
c.d = D()
c.d.what = "d.what"

json.dumps(c.__dict__)
</code></pre>
<p>yields the following error:</p>
<pre><code>TypeError: &lt;__main__.D instance at 0x99237ec&gt; is not JSON serializable
</code></pre>
<p>I don't know what types of subobjects a user might put into <code>c</code>.  Is there a solution that is smart enough to detect if an attribute is an object and parse it's <code>__dict__</code> automatically?</p>
<p><b>UPDATED</b> to include subobjects on <code>c</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Specify the <code>default=</code> parameter <sup>(<a href="http://docs.python.org/library/json.html#json.dump" rel="noreferrer">doc</a>)</sup>:</p>
<pre><code>json.dumps(c, default=lambda o: o.__dict__)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>json.dumps(c.__dict__)
</code></pre>
<p>That will give you a generic JSON object, if that's what you're going for.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using this package <a href="https://github.com/jsonpickle/jsonpickle">python-jsonpickle</a></p>
<blockquote>
<p>Python library for serializing any arbitrary object graph into JSON. It can take almost any Python object and turn the object into JSON. Additionally, it can reconstitute the object back into Python.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>json.dumps</code> expects a dictonary as a parameter. For an instance <code>c</code>, the attribute <code>c.__dict__</code> is a dictionary mapping  attribute  names to the corresponding objects.</p>
</div>
<span class="comment-copy">except for the dynamic element--I don't know what properties might be added to the object before it is serialized into json.</span>
<span class="comment-copy">You'll notice the solution of the duplicate works in your case, too.</span>
<span class="comment-copy">@phihag: thanks for pointing that out.  It helped me realize there was more to my question than I thought (see updated question).</span>
<span class="comment-copy">Then you should probably ask a new question. Pay special notice not to include invalid example code. For example, you want <code>class C(object): pass</code>. I added an answer that should solve your problem.</span>
<span class="comment-copy">Oops sorry, I was totally wrong. <code>class C(): pass</code> is of course <i>valid</i>, but it creates an old-style class (just like <code>class C: pass</code> would) in Python 2.x. old-style classes are strange beasts. By inheriting from <code>object</code>, you get the saner new-style behaviour.</span>
<span class="comment-copy">One of my object's attributes is a datetime and i'm having <code>'AttributeError' object has no attribute '__dict__'</code></span>
<span class="comment-copy">@arun For a set, you'd use a different method. If you expect both objects and set, use a helper function instead of a lambda, test for <code>isinstance(o, set)</code> and then return something like <code>list(o)</code>.</span>
<span class="comment-copy">This one workds better than <code>json.dumps(c.__dict__)</code>, why?</span>
<span class="comment-copy">@soulmachine your code just dumps a dictionary, whose values (and values of values, recursively) may still be Python objects that have no JSON representation. The code in this answer uses the object's <code>__dict__</code> for all those problematic objects, recursively.</span>
<span class="comment-copy">@soulmachine From the Python3 <a href="https://docs.python.org/3/library/json.html#json.dump" rel="nofollow noreferrer">documentation</a>: <i>If specified, default should be a function that gets called for objects that canâ€™t otherwise be serialized. It should return a JSON encodable version of the object or raise a TypeError. If not specified, TypeError is raised.</i></span>
<span class="comment-copy">After looking into phihag's comment, I did some further testing and realized that this solution does not work in all cases...updating question...</span>
<span class="comment-copy">That works for me as well.</span>
