<div class="post-text" itemprop="text">
<p>I have a Django model with a start and end date range. I want to enforce validation so that no two records have overlapping date ranges. What's the simplest way to implement this so that I don't have to repeat myself writing this logic?</p>
<p>e.g. I don't want to re-implement this logic in a Form <em>and</em> a <code>ModelForm</code> <em>and</em> an admin form <em>and</em> the model's overridden <code>save()</code>.</p>
<p>As far as I know, Django doesn't make it easy to globally enforce these types of criteria. </p>
<p>Googling hasn't been very helpful, since "model validation" typically refers to validating specific model fields, and not the entire model contents, or relations between fields.</p>
</div>
<div class="post-text" itemprop="text">
<p>The basic pattern I've found useful is to put all my custom validation in <code>clean()</code> and then simply call <a href="https://docs.djangoproject.com/en/dev/ref/models/instances/#django.db.models.Model.full_clean" rel="noreferrer"><code>full_clean()</code></a> (which calls <code>clean()</code> and a few other methods) from inside <code>save()</code>, e.g.:</p>
<pre><code>class BaseModel(models.Model):

    def clean(self, *args, **kwargs):
        # add custom validation here
        super(BaseModel, self).clean(*args, **kwargs)

    def save(self, *args, **kwargs):
        self.full_clean()
        super(BaseModel, self).save(*args, **kwargs)
</code></pre>
<p>This isn't done by default, as explained <a href="https://stackoverflow.com/questions/4441539/why-doesnt-djangos-model-save-call-full-clean">here</a>, because it interferes with certain features, but those aren't a problem for my application.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would override the <a href="https://docs.djangoproject.com/en/1.3/ref/models/instances/#django.db.models.Model.validate_unique" rel="noreferrer"><code>validate_unique</code></a> method on the model. To make sure you ignore the current object when validating, you can use the following:</p>
<pre><code>from django.db.models import Model, DateTimeField
from django.core.validators import NON_FIELD_ERRORS, ValidationError

class MyModel(Model):
    start_date = DateTimeField()
    end_date = DateTimeField()

    def validate_unique(self, *args, **kwargs):
        super(MyModel, self).validate_unique(*args, **kwargs)

        qs = self.__class__._default_manager.filter(
            start_date__lt=self.end_date,
            end_date__gt=self.start_date
        )

        if not self._state.adding and self.pk is not None:
            qs = qs.exclude(pk=self.pk)

        if qs.exists():
            raise ValidationError({
                NON_FIELD_ERRORS: ['overlapping date range',],
            })
</code></pre>
<p><code>ModelForm</code> will automatically call this for you through a <code>full_clean()</code>, which you can use manually too.</p>
<p>PPR has a nice discussion of a simple, correct <a href="http://c2.com/cgi/wiki?TestIfDateRangesOverlap" rel="noreferrer">range overlap condition</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you should use this:
<a href="https://docs.djangoproject.com/en/dev/ref/models/instances/#validating-objects" rel="noreferrer">https://docs.djangoproject.com/en/dev/ref/models/instances/#validating-objects</a></p>
<p>Just define clean() method in your model like this: (example from the docs link)</p>
<pre class="lang-py prettyprint-override"><code>def clean(self):
    from django.core.exceptions import ValidationError
    # Don't allow draft entries to have a pub_date.
    if self.status == 'draft' and self.pub_date is not None:
        raise ValidationError('Draft entries may not have a publication date.')
    # Set the pub_date for published items if it hasn't been set already.
    if self.status == 'published' and self.pub_date is None:
        self.pub_date = datetime.datetime.now()
</code></pre>
</div>
<span class="comment-copy">In Python 3, <code>super(BaseModel, self)</code> can be simplified to <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code></a>.</span>
<span class="comment-copy">On django 1.3.1 I'm running into a problem raising the ValidationError the way you describe it.  I was able to fix it by passing a {field: (error_msg,)} dict instead of a string error_msg when raising the exception.</span>
<span class="comment-copy"><code>from django.core.exceptions import ValidationError, NON_FIELD_ERRORS</code> <code>raise ValidationError({NON_FIELD_ERRORS: ('overlapping date range',)})</code></span>
<span class="comment-copy">Is there any interest in extending <code>validate_unique</code> instead of just defining <code>clean</code>? Just a question of organizing the code?</span>
<span class="comment-copy">validate_unique implies [in it's method name] that you're validating a unique constraint.  Django's "validating objects" documentation refers to the clean method.  In my opinion, it seems more logical to go with the accepted answer and do your validation there.</span>
<span class="comment-copy">This is close. I also had to override my model's save(), and call clean() from there.</span>
<span class="comment-copy">But what for? AdminSite (ModelForm) calls clean() automatically. But calling clean() from save() method could produce ValidationError in unexpected moment and it won't be cought as expected.</span>
<span class="comment-copy">Not everything calls clean. This needs to be validated regardless of where it's saved. A broken site page is preferable to corrupt data.</span>
<span class="comment-copy">@Cerin seems anyway not a good idea to call <code>clean</code> from <code>save</code>. Don't follow Django guidelines at half. If you want this to happen at each <code>save()</code>, then forget about <code>clean</code> and put the code in the <code>save</code> method.</span>
<span class="comment-copy">@lajarre, Duplicating error checking code is a horrible idea. You should always follow DRY.</span>
