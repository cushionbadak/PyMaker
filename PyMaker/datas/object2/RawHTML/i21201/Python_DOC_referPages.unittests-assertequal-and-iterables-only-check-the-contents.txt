<div class="post-text" itemprop="text">
<p>Is there a 'decent' way in unittest to check the equality of the contents of two iterable objects? 
I am using a lot of tuples, lists and numpy arrays and I usually only want to test for the contents and not for the type. Currently I am simply casting the type:</p>
<pre><code>self.assertEqual (tuple (self.numpy_data), tuple (self.reference_list))
</code></pre>
<p>I used this list comprehension a while ago:</p>
<pre><code>[self.assertEqual (*x) for x in zip(self.numpy_data, self.reference_list)]
</code></pre>
<p>But this solution seems a bit inferior to the typecast because it only prints single values if it fails and also it does not fail for different lengths of reference and data (due to the zip-function).</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 3</h2>
<ul>
<li>If you <strong>don't care</strong> about the order of the content, you have the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertCountEqual" rel="noreferrer">assertCountEqual(a,b)</a> method </li>
<li>If you <strong>care</strong> about the order of the content, you have the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertSequenceEqual" rel="noreferrer">assertSequenceEqual(a,b)</a> method </li>
</ul>
<h2>Python &gt;= 2.7</h2>
<ul>
<li>If you <strong>don't care</strong> about the order of the content, you have the <a href="http://docs.python.org/library/unittest.html?highlight=assertequal#unittest.TestCase.assertItemsEqual" rel="noreferrer">assertItemsEqual(a,b)</a> method </li>
<li>If you <strong>care</strong> about the order of the content, you have the <a href="http://docs.python.org/library/unittest.html?highlight=assertequal#unittest.TestCase.assertSequenceEqual" rel="noreferrer">assertSequenceEqual(a,b)</a> method </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can always add your own assertion methods to your TestCase class:</p>
<pre><code>def assertSequenceEqual(self, it1, it2):
    self.assertEqual(tuple(it1), tuple(it2))
</code></pre>
<p>or take a look at how 2.7 defined it: <a href="http://hg.python.org/cpython/file/14cafb8d1480/Lib/unittest/case.py#l621" rel="noreferrer">http://hg.python.org/cpython/file/14cafb8d1480/Lib/unittest/case.py#l621</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It looks to me you care about the order of items in the sequences. Therefore, <code>assertItemsEqual</code>/<code>assertCountEqual</code> is not for you.</p>
<p>In Python 2.7 and in Python 3, what you want is <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertSequenceEqual" rel="nofollow noreferrer"><code>self.assertSequenceEqual</code></a>. This is sensitive to the order of the items.</p>
</div>
<span class="comment-copy">This won't do what the OP requested, since it disregards the order of the items.</span>
<span class="comment-copy">@Sven Marnach : right, I added the assertSequenceEqual that is not order-free</span>
<span class="comment-copy">Slight clarification: 2.7 has the desired functionality, so I think you meant &gt;=2.7 instead of &gt;2.7. Also, those features are available in 2.4-2.6 via the <a href="http://pypi.python.org/pypi/unittest2" rel="nofollow noreferrer">unittest2</a> package.</span>
<span class="comment-copy">Also note that <code>assertSequenceEqual</code> cannot compare generators, as it seems try and call <code>len()</code> on the result.</span>
<span class="comment-copy">I have tried using <code>assertSequenceEqual</code> to compare two <code>numpy</code> arrays. However, the test returns a value error saying that "(...) truth value of an array with more than one element is ambiguous." If <code>A = numpy.array([0, 1, 2, 3, 4, 5])</code> and <code>B = numpy.array([0, 1, 2, 3, 4, 5])</code>, running <code>self.assertSequenceEqual(A, B)</code> raises the error.  But, if I use <code>self.assertSequenceEqual(list(A), list(B))</code> the test passes as expected. I just want to know if this the proper way of running the test?</span>
<span class="comment-copy">The definition in the linked code does something different than your implementation:  It compares up to differences in the order of elements.</span>
<span class="comment-copy">Oops: <code>assertItemsEqual</code> is unordered.  I've fixed it to point to a more appropriate exemplar.</span>
<span class="comment-copy">also assertItemsEqual uses collections.Counter method, which uses the hash of the objects in the sequence. With sequences of User created objects without a specific hash implementation, assertItemsEqual will always fail (since the hash is based on object Id), even if the objects are equal (i.e. == is true).</span>
