<div class="post-text" itemprop="text">
<p>It is well known that <code>json</code> converts integer keys of a dict to string:</p>
<pre><code>import json
print json.dumps({1: [2.5, 2.5, 2.5], 2: [3, 3, 3, 3]})
# {"1": [2.5, 2.5, 2.5], "2": [3, 3, 3, 3]}
</code></pre>
<p>What's the cleanest way to restore integer keys when loading it back?</p>
<pre><code>d = json.loads('{"1": [2.5, 2.5, 2.5], "2": [3, 3, 3, 3]}')
print d
# {u'1': [2.5, 2.5, 2.5], u'2': [3, 3, 3, 3]}
</code></pre>
<p>I was thinking about:</p>
<pre><code>d = {int(k): d[k] for k in d}
</code></pre>
<p>but is there a cleaner way to deal with dictionaries with integer keys with JSON / Python, not requiring keys conversion a posteriori?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>object_hook</code> to define a custom function and perform operations:</p>
<pre><code>import json

def keystoint(x):
    return {int(k): v for k, v in x.items()}

j = json.dumps({1: [2.5, 2.5, 2.5], 2: [3, 3, 3, 3]})
# {"1": [2.5, 2.5, 2.5], "2": [3, 3, 3, 3]}

print(json.loads(j, object_hook=keystoint))
# {1: [2.5, 2.5, 2.5], 2: [3, 3, 3, 3]}
</code></pre>
<p>From <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p><code>object_hook</code> is an optional function that will be called with the
  result of any object literal decoded (a dict). The return value
  of <code>object_hook</code> will be used instead of the dict.</p>
</blockquote>
<p><hr/>
Or, you could also use <code>object_pairs_hook</code> that lets you iterate through pairs and saves the <code>.items()</code> call (Thanks @chepner):</p>
<pre><code>import json

def keystoint(x):
    return {int(k): v for k, v in x}

j = json.dumps({1: [2.5, 2.5, 2.5], 2: [3, 3, 3, 3]})
# {"1": [2.5, 2.5, 2.5], "2": [3, 3, 3, 3]}

print(json.loads(j, object_pairs_hook=keystoint))
# {1: [2.5, 2.5, 2.5], 2: [3, 3, 3, 3]}
</code></pre>
<p>From docs:</p>
<blockquote>
<p><code>object_pairs_hook</code> is an optional function that will be called with the
  result of any object literal decoded with an ordered list of pairs.
  The return value of <code>object_pairs_hook</code> will be used instead of
  the dict.</p>
</blockquote>
</div>
<span class="comment-copy">Cleaner in what way? You could do <code>{int(k):v for k,v in d.items()}</code></span>
<span class="comment-copy">@juanpa.arrivillaga To avoid conversion, and have it directly loaded back as a dict with integer keys.</span>
<span class="comment-copy">Well, since JSON requires string keys, you'll either have to write your own decoder (which is straightforward with the <code>json</code> library) or just convert, or chose an alternative serialization format.</span>
<span class="comment-copy">@juanpa.arrivillaga Hum, ok, I think this is the answer (if you want to post it).</span>
<span class="comment-copy"><code>object_pairs_hook</code> is slightly simpler (saving a call to the <code>items</code> method), as it receives a list of key/value pairs instead of a dict. <code>loads(j, object_pairs_hook=lambda pairs: {int(k): v for k,v in pairs})</code>.</span>
<span class="comment-copy">@chepner, nice point. Of course, if the size is larger, saving <code>.items()</code> call should matter.</span>
<span class="comment-copy">The default decoder, at least, always builds a concrete list of key/value pairs in memory. <code>object_pairs_hook</code> short-circuits the normal process by operating directly on that list; otherwise, the list is first turned into a <code>dict</code>, which is either returned as-is or passed to <code>object_hook</code> (That is, given <code>pairs</code>, the decoder returns <code>object_pairs_hook(pairs)</code>, <code>dict(pairs)</code>, or <code>object_hook(dict(pairs))</code>.)</span>
