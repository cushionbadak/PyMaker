<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/55347581/why-does-the-is-operator-behave-differently-in-a-script-vs-the-repl">Why does the `is` operator behave differently in a script vs the REPL?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I want to preface this by saying that I know the difference between <code>==</code> and <code>is</code> one is for references and the other is for objects. I also know that python caches the integers in the range <code>(-5, 256)</code> at startup so they should work when comparing them with <code>is</code>. </p>
<p>However I have seen a strange behaviour.</p>
<pre><code>&gt;&gt;&gt; 2**7 is 2**7
True
&gt;&gt;&gt; 2**10 is 2**10
False
</code></pre>
<p>This is to be expected, <code>2**7</code> is <code>128</code> and <code>2**10</code> is <code>1024</code>, one is in the interval <code>(-5, 256)</code> and the other is not. </p>
<p>However...</p>
<pre><code>&gt;&gt;&gt; 10000000000000000000000000000000000000000 is 10000000000000000000000000000000000000000
True
</code></pre>
<p>Why does this return <code>True</code>? It is obviously a value WAY above any kind of caching interval and <code>2**10 is 2**10</code> clearly showed that <code>is</code> does actually not work on integers above <code>256</code>. So... why does this happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>CPython detects constant values in your code and re-uses them to save memory. These constants are stored on <a href="https://stackoverflow.com/questions/5768684/what-is-a-python-code-object">code objects</a>, and can even be accessed from within python:</p>
<pre><code>&gt;&gt;&gt; codeobj = compile('999 is 999', '&lt;stdin&gt;', 'exec')
&gt;&gt;&gt; codeobj
&lt;code object &lt;module&gt; at 0x7fec489ef420, file "&lt;stdin&gt;", line 1&gt;
&gt;&gt;&gt; codeobj.co_consts
(999, None)
</code></pre>
<p>Both operands of your <code>is</code> refer to this very same 999 integer. We can confirm this by dissecting the code with the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module:</p>
<pre><code>&gt;&gt;&gt; dis.dis(codeobj)
  1           0 LOAD_CONST               0 (999)
              2 LOAD_CONST               0 (999)
              4 COMPARE_OP               8 (is)
              6 POP_TOP
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
</code></pre>
<p>As you can see, the first two <code>LOAD_CONST</code> instructions both load the constant with index <code>0</code>, which is the 999 number.</p>
<p><strong>However</strong>, this only happens if the two numbers are compiled at the same time. If you create each number in a separate code object, they will no longer be identical:</p>
<pre><code>&gt;&gt;&gt; x = 999
&gt;&gt;&gt; x is 999
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Remember that Python <em>is</em> compiled.  The expression was compiled all at once and its literals are shared when possible.  Any <strong>operation</strong>, like your exponentiation, or adding and subtracting 1 from one side, will break the identity. (Python could in theory do constant folding and thereby extend the set of <code>is</code>-identical expressions, but it doesnâ€™t bother.)</p>
<p>Performing <strong>multiple compilations</strong> will also break this:</p>
<pre><code>&gt;&gt;&gt; x=300
&gt;&gt;&gt; x is 300
False
</code></pre>
</div>
<span class="comment-copy">After answering, I realize that this point <b>is</b> covered in an answer to <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">"is" operator behaves unexpectedly with integers</a> (though it might not stand out).</span>
<span class="comment-copy">Actually, due to peephole-optimization <code>2**10 is 2**10</code> is <code>True</code> with Python3.8 (and probably Python3.7)</span>
<span class="comment-copy">Can confirm the exponent version is also optimized on 3.7.2 (linux).</span>
