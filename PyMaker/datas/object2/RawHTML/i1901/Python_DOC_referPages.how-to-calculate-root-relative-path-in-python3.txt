<div class="post-text" itemprop="text">
<p>The task is to implement a function <code>root_relative_path(root : str, path : str) -&gt; str</code>, which calculates the relative path with respect to root, with no intermediate <code>..</code> go beyond <code>root</code>. e.g., <code>root_relative_path('/abc', '/../def') == '/abc/def'</code></p>
<p>This question is different from <a href="https://stackoverflow.com/questions/41941315/how-to-calculate-relative-path-in-python">How to calculate relative path in Python?</a> because in this case, <code>root_relative_path(root='/tmp/abc', path='/../def')</code> should return <code>/tmp/abc/def</code> instead of <code>/tmp/def</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was able to implement your root_relative_path function using a combination of the posixpath and the pathlib modules. The result is</p>
<ul>
<li>Platform independent (as long as the root path corresponds to the current platform)</li>
<li>The path can begin with <code>/</code>, <code>./</code>, or <code>../</code></li>
<li>And the path will be normalized using all of the techniques covered by the <a href="https://docs.python.org/3/library/os.path.html#os.path.normpath" rel="nofollow noreferrer">normpath</a> function which includes resolving <code>..</code>s.</li>
</ul>
<p>Â </p>
<pre><code>from pathlib import Path
import posixpath

def root_relative_path(root : str, path : str) -&gt; str:
    ''' Calculates the relative path with respect to the root. 
        Any ".."s in the relative path will be resolved, 
        but not in a way that would cause the relative path to go beyond the root. '''

    # posixpath.normpath doesn't work as expected if the path doesn't start with a slash, so we make sure it does
    if not path.startswith('/'):
        path = '/' + path

    # The normalization process includes resolving any ".."s
    # we're only using posixpath for the relative portion of the path, the outcome will still be platform independent
    path = posixpath.normpath(path)

    # Remove the beginning slash so that we're not trying to join two absolute paths
    path = path[1:]

    joined = Path(root) / path

    # Per the OPs requirements the result needed to be a string,
    # But if you're allowed to use Pathlib objects, you could just return joined without converting it to a string
    return str(joined)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os.path

def root_relative_path(root : str, path : str) -&gt; str:
    return (os.path.join(root,
        os.path.join(os.sep, os.path.normpath(path)).split(os.sep)[1:])))
</code></pre>
</div>
<span class="comment-copy">Instead of pointing out the difference to an other question, you should have asked a detailed question itself.</span>
<span class="comment-copy">@KlausD. Thank you. I've refined the description of problem.</span>
<span class="comment-copy">I understand why you would like to prevent going beyond root, but why silently dropping some '..' instead of throwing an exception?</span>
<span class="comment-copy">@FrancisColas This function is useful when implementing a HTTP server, where <code>GET /../../abc</code> with root=<code>/tmp/abc</code> should return files under <code>/tmp/abc/abc</code></span>
<span class="comment-copy">Please leave a comment when you down vote.</span>
<span class="comment-copy"><code>return os.path.join(root, *os.path.join(os.sep, os.path.normpath(path)).split(os.sep)[1:])</code>?</span>
<span class="comment-copy">Adding a <code>*</code> before <code>os.path.join</code> breaks it. What are you asking?</span>
