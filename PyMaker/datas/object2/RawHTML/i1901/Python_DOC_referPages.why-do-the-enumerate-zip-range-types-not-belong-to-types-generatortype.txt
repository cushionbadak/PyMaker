<div class="post-text" itemprop="text">
<p>Python 3 has introduced generator-like objects to be returned upon calling <code>range()</code> and <code>zip()</code>. The object returned acts like a generator and can be iterated through once but doesn't 'print' well, much like the <code>enumerate()</code> return argument. </p>
<p>I was perplexed to see, however, that they are distinct object types and do not belong to <code>types.GeneratorType</code>, or at least this is what the <code>types</code> module shows. A function that would run e.g. expecting a generator would not detect them. What is their inheritance? Do they belong to a main "generator" structure, so that they e.g. could be identified along with other generators?</p>
<pre><code>import types

a = [1,2,3]
b = [4,5,6]

# create some generator-type objects
obj_zip = zip(a,b)
obj_enu = enumerate(a)
obj_r = range(10)

print(type(obj_zip))
print(type(obj_enu))
print(type(obj_r))

# checking against types.GeneratorType returns False
print(isinstance(obj_zip,types.GeneratorType))
print(isinstance(obj_enu,types.GeneratorType))
print(isinstance(obj_r,types.GeneratorType))

# checking against their own distinct object types returns True
print(isinstance(obj_zip,zip))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="https://docs.python.org/3/library/types.html#types.GeneratorType" rel="nofollow noreferrer">the <code>GeneratorType</code> docs</a>:</p>
<blockquote>
<h3>types.GeneratorType</h3>
<blockquote>
<p>The type of generator-iterator objects, created by generator functions.</p>
</blockquote>
</blockquote>
<p>Generator functions are a specific thing in the language; it means functions that use <code>yield</code> or <code>yield from</code> (or generator expressions, which are just a shorthand for inline generator functions). It's a subset of the set of iterators (all things that you can call <code>next()</code> on to get a new value), which is in turn a subset of iterables (all things that you can call <code>iter()</code> on to get an iterator; iterators themselves are iterables, where <code>iter(iterator)</code> behaves as the identity function).</p>
<p>Basically, if you're testing for "can I loop over this?", test <code>isinstance(obj, collections.abc.Iterable)</code>. If you're checking "is this an exhaustible iterator?" (that is, will I exhaust it by looping over it?), test either <code>isinstance(obj, collections.abc.Iterator)</code> or for the duck-typing based approach, test <code>iter(obj) is obj</code> (the invariants on iterators <em>require</em> that <code>iter(iterator)</code> yield the original iterator object unchanged).</p>
<p>Note that <code>range</code> is <em>not</em> a generator or iterator. Per <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>Rather than being a function, range is actually an immutable sequence type, as documented in <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-range" rel="nofollow noreferrer">Ranges</a> and <a href="https://docs.python.org/3/library/stdtypes.html#typesseq" rel="nofollow noreferrer">Sequence Types â€” list, tuple, range</a>.</p>
</blockquote>
<p>Being an immutable sequence type means it <em>is</em> an iterable, but that's it. The fact that it is usually used as if it were an iterator is irrelevant; if it were an iterator, the second loop here would never execute:</p>
<pre><code>r = range(3)
for i in r:
    print("First", i)
for i in r:
    print("Second", i)
</code></pre>
<p>but it works just fine, because each (implicit) call to <code>iter(r)</code> returns a <em>new</em> itera<em>tor</em> based on the same underlying itera<em>ble</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation says that enumerate is <em>functionally</em> equivalent to a generator. Actually it is implemented in C and returns an iterator, not a generator as described in <a href="https://stackoverflow.com/a/23663453/246241">Does enumerate() produce a generator object</a>. 
Generators and iterables are almost the same. This is explained in detail in <a href="https://stackoverflow.com/a/2776865/246241">Difference between Python's Generators and Iterators</a>.</p>
<p>I'm assuming you're trying to solve a real problem, like finding out if you can iterate over something. To solve that you can test if something is  an instance of <code>collections.Iterable</code>.</p>
<pre><code>a = enumerate([1,2,3])
isinstance(a, collections.Iterable)
&gt;&gt;&gt; True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>not meant to be a full answer (<a href="https://stackoverflow.com/a/52970756/6451573">ShadowRanger answer</a> already explains everything) but just to state that <code>types.GeneratorType</code> is really a very limited type as shown in <code>types.py</code> source:</p>
<pre><code>def _g():
    yield 1
GeneratorType = type(_g())
</code></pre>
<p>it only scopes the type of generator functions. Other "generator-like" objects don't use <code>yield</code> so they're not a match.</p>
</div>
<span class="comment-copy"><code>range</code> objects aren't a generator, they're an immutable sequence type; you can iterate them repeatedly, so they definitely shouldn't be of <code>GeneratorType</code>.</span>
<span class="comment-copy">Perfect, this is what I wanted, a clarification between Iterable, Iterator and Generator. So <code>enumerate()</code> and <code>zip()</code> create <b>iterators</b> (i.e. that can be exhausted) but not <b>generators</b>.</span>
<span class="comment-copy">"iterable" as a category is a superset of "generator" (all generators are iterable, but not all iterables are generators), so that's not all that useful.</span>
<span class="comment-copy">Well I am trying to create a function that is running over iterables twice. So, in case the iterable is a generator, it tries to clone a generator (using <code>itertools.tee</code>), but I'm having a problem checking against generators if the object passed belongs to these generator-type objects that have a special type.</span>
