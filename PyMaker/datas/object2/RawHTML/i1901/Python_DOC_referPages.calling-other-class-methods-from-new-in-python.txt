<div class="post-text" itemprop="text">
<p>I have created a class <code>foo</code> as below:</p>
<pre><code>class foo():

    def __new__(cls, a, b, c, add=True):
        return cls.sum(a, b, c) if add else cls.subtract(a, b, c)

    def sum(a, b, c):
        return a + b + c

    def subtract(a, b, c):
        return c - b - a

print(foo(1, 2, 3, True))
</code></pre>
<p>This program returns the required result as <code>6</code>. However, I needed to get the clarity of a few concepts:</p>
<ol>
<li>Is using this methodology or design of OOP correct or is there a better way to do it? I want the class to return a value or any other object(not it's own class instance)</li>
<li>Regardless of the structure above, if <code>sum</code> and <code>subtract</code> are instance methods, how can they be called without instantiating an object as in the above example i.e., <code>print(...)</code>?</li>
</ol>
<p>I have observed many python APIs and frameworks returning an object or a value through class instantiation.</p>
<p>I am trying to understand the core concepts of OOPs in python please help.</p>
</div>
<div class="post-text" itemprop="text">
<p>The way you have it now, <code>sum</code> and <code>subtract</code> are indeed instance methods.</p>
<pre><code>&gt;&gt;&gt; foo_obj = object.__new__(foo)  # This will actually create a foo object to demonstrate
&gt;&gt;&gt; foo_obj.sum
&lt;bound method foo.sum of &lt;__main__.foo object at 0x0000000000000000&gt;&gt;
&gt;&gt;&gt; type(foo_obj.sum)
&lt;class 'method'&gt;
</code></pre>
<p>But that's just because when you access them through an instance, Python dynamically creates a method (Basically just binds the first argument to the object, usually <code>self</code>)</p>
<p>But, you can access the wrapped function through the class:</p>
<pre><code>&gt;&gt;&gt; foo_obj.sum.__func__
&lt;function foo.sum at 0x0000000000000001&gt;
&gt;&gt;&gt; foo.sum
&lt;function foo.sum at 0x0000000000000001&gt;
&gt;&gt;&gt; foo_obj.sum.__func__ is foo.sum
True
</code></pre>
<p>So in your <code>__new__</code> function, it won't bind the first argument, and they call the underlying function instead of making them an instance method.</p>
<p>To fix the warnings, you can make them <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a>s or <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer"><code>staticmethod</code></a>s. But it is generally bad practice to not return an object that is an instance of the class from the <code>__new__</code>. If you really wanted to use OOP, either subclass <code>int</code> or make a wrapper, so you can have:</p>
<pre><code>&gt;&gt;&gt; class Foo:
    __slots__ = 'value',
    def __init__(self, a, b, c, add=True):
        self.value = self.sum(a, b, c) if add else self.subtract(a, b, c)
    @staticmethod
    def sum(a, b, c):
        return a + b + c
    @staticmethod
    def subtract(a, b, c):
        return c - b - a
&gt;&gt;&gt; foo = Foo(1, 2, 3, True)
&gt;&gt;&gt; foo
&lt;__main__.foo object at 0x0000000000000002&gt;
&gt;&gt;&gt; foo.value
6
</code></pre>
<p>or</p>
<pre><code>&gt;&gt;&gt; class Foo(int):
    __slots__ = ()
    def __new__(cls, a, b, c, add=True):
        value = cls.sum(a, b, c) if add else cls.subtract(a, b, c)
        return super().__new__(cls, value)
    @staticmethod
    def sum(a, b, c):
        return a + b + c
    @staticmethod
    def subtract(a, b, c):
        return c - b - a
&gt;&gt;&gt; foo = Foo(1, 2, 3, True)
&gt;&gt;&gt; foo
6
&gt;&gt;&gt; type(foo)
&lt;class '__main__.Foo'&gt;
</code></pre>
</div>
<span class="comment-copy">With <code>foo(1, 2, 3, True)</code> you <i>are</i> instantiating the object</span>
<span class="comment-copy">however, while using PyCharm, it shows an error(during editing)... but it runs though. This made it confusing actually... Then I guess it's a faulty suggestion by PyCharm...</span>
<span class="comment-copy">What error? Remember, PyCharm is trying to guess what will happen when the code actually runs without actually running it. From everything I read here, it doesn't do a great job.</span>
<span class="comment-copy">Why is this a class? A function makes far more sense.</span>
<span class="comment-copy">I agree. The error/suggestion is that it asks you to add <code>self</code> to <code>add</code> and <code>subtract</code> methods but when I add them, the program throws a <code>Missing Argument</code> error. This made me wonder whether <code>add</code> and <code>subtract</code> are instance methods.</span>
