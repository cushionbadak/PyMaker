<div class="post-text" itemprop="text">
<p><strong>Out of a random list of integers, with integers being repeated in the list, what is  the way to print that integer out of the list which is not repeated at all?</strong></p>
<p>I have tried to solve the question by making the following program:</p>
<pre><code>K = int(input())

room_list = list(input().split())

room_set = set(room_list)

for i in room_set:

    count = room_list.count(i)

    if count == 1:
        i = int(i)
        print(i)
        break
</code></pre>
<p>K being the number of the elements in the list.</p>
<p>When I try to run the above program, it works well in the case of less elements however, when it is tested with a list having (say, 825) elements, the program times out.</p>
<p>Please help me in optimizing the above code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Elements whose repetition count in the list is one will be your answer.</p>
<pre><code>from collections import Counter
a = [1,1,1,2,2,3,4,5,5]
c = Counter(a) # O(n)
x = [key for key, val in c.items() if val == 1]
print(x)
</code></pre>
<p>Output:</p>
<pre><code>[3,4]
</code></pre>
<p><a href="https://docs.python.org/3.1/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter class</a> creates a dictionary of elements and repetitions by iterating through the list once that takes time O(n) and each element's access takes O(1) time.</p>
<p>The count function of the list iterates every time you call it on a list. In your case taking O(n^2) time.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will print the number that occured least often:</p>
<pre><code>data = [3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,93,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9]

from collections import Counter

# least often
print (Counter(data).most_common()[-1][0])

# all non-repeated onces
# non_repeat = [k[0] for k in Counter(data).most_common() if k[1] == 1] 
</code></pre>
<p>Output:</p>
<pre><code>93
</code></pre>
<p>It uses a specialized dictionary: <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collection.Counter</a> thats built for counting things in iterable you give it. </p>
<p>The method <code>.most_common()</code> returns a sorted list of tuples of (key, count) - by printing its last member you get the one thats least often.</p>
<p>The built-up dict looks like this:</p>
<pre><code>Counter({4: 4, 5: 4, 6: 4, 7: 4, 8: 4, 3: 3, 9: 3, 0: 2, 1: 2, 2: 2, 93: 1})
</code></pre>
<hr/>
<p>A similar approach is to use a <a href="https://docs.python.org/3/library/collections.html#defaultdict-objects" rel="nofollow noreferrer">collections.defaultdict</a> and count them yourself, then get the one with the minimal value:</p>
<pre><code>from collections import defaultdict

k = defaultdict(int)
for elem in data:
    k[elem] += 1

print( min(k.items(), key=lambda x:x[1]) ) 
</code></pre>
<hr/>
<p>The last solutions is similar in approach without the specialized Counter - the advantage of both of them is that you iterate once over the whole list and increment a value instead of iterating <em>n</em> times over the whole list and count each distinct elements occurences once.</p>
<ul>
<li>Using <code>count()</code> on a list of pure distinct elements would lead to <code>n</code> counting-runs through <code>n</code> elements = <code>n^2</code> actions needed.</li>
<li>The dictionary approach only needs one pass though the list so only <code>n</code> actions needed.</li>
</ul>
</div>
