<div class="post-text" itemprop="text">
<p>Let's say I want to open a text file for reading using the following syntax:</p>
<pre><code>with open(fname,'r') as f:
    # do something
    pass
</code></pre>
<p>But if I detect that it ends with .gz, I would call gzip.open(). </p>
<pre><code>if fname.endswith('.gz'):
    with gzip.open(fname,'rt') as f:
            # do something
            pass
else:
    with open(fname,'r') as f:
            # do something
            pass
</code></pre>
<p>If "do something" part is long and not convenient to write in a function (e.g. it would create a nested function, which cannot be serialized), what is the shortest way to call with either gzip.open or open based on the return of fname.endswith('.gz')?</p>
</div>
<div class="post-text" itemprop="text">
<p>The context manager helps <em>close</em> the object.</p>
<p>You don't have to create the object used as a context manager, at the same time you use <code>with</code> to enter the context, though. The <code>open()</code> and <code>gzip.open()</code> calls return a new object that happens to be a context manager, and you can create them before you enter the context:</p>
<pre><code>if fname.endswith('.gz'):
    f = gzip.open(fname,'rt')
else:
    f = open(fname, 'r')

with f:
    # do something
</code></pre>
<p>In both cases, the object returns <code>self</code> on entering the context, so there is no need to use <code>as f</code> here.</p>
<p>Also, functions are first-class citizens, so you can also use a variable to store the function and then call that in the <code>with</code> statement to create the context manager and file object:</p>
<pre><code>if fname.endswith('.gz'):
    opener = gzip.open
else:
    opener = open

with opener(fname, 'rt') as f:  # yes, both open and gzip.open support mode='rt'
    # do something
</code></pre>
<p>This doesn't really buy you anything over the other method here, but you could use a dictionary to map extensions to callables if you so desire.</p>
<p>The bottom line is that <code>with</code> <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="nofollow noreferrer">calls context-manager hook methods</a>, nothing less, nothing more. The expression after <code>with</code> is supposed to supply such a manager, but <em>creating</em> that object is not subject to the context management protocol.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can bind either context manager to the same name and choose early:</p>
<pre><code>if fname.endswith('.gz'):
    context = gzip.open(fname,'rt')
else:
    context = open(fname,'r')

with context as f:
    # do the same thing in either case
</code></pre>
<p>This allows for some nice patterns, for instance if the input is possibly an opened file handle then you could use <a href="https://docs.python.org/3/library/contextlib.html#contextlib.nullcontext" rel="noreferrer"><code>contextlib.nullcontext</code></a> to get a no-op in the <code>with</code> block for the given case.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>with gzip.open(fname, 'rt') if fname.endswith('.gz') else open(fname, 'r') as f:
    # do something
    pass
</code></pre>
</div>
<span class="comment-copy">related question: <a href="https://stackoverflow.com/questions/49224375/open-statement-according-to-a-file-extension" title="open statement according to a file extension">stackoverflow.com/questions/49224375/…</a> . but the answers here are slightly different therefore i think it should remain open and not be closed as a duplicate.</span>
<span class="comment-copy">Thanks! Can you just explain why "opener, mode = open"? How is it possible that "opener = open" wouldn't work?</span>
<span class="comment-copy">@CindyAlmighty: that was an editing error, sorry. I originally assigned both an opener and a mode (so <code>opener, mode = gzip.open, 'rt'</code>), but then realised that <code>open()</code> accepts <code>rt</code> to mean the same thing as <code>r</code> for the mode.</span>
<span class="comment-copy">ha, learned something new! thanks!</span>
<span class="comment-copy">It's one of the beautiful things about Python because everything is an object you can get away with lots of neat tricks like this.  Another favorite of mine is using <code>dict</code>s as a switch.</span>
<span class="comment-copy">1. can you explain the last sentence please? :) 2. @Idlehands What is this use of dict as a switch?</span>
<span class="comment-copy">@CindyAlmighty it isn't directly applicable to your use case. But imagine the scenario when you have "<i>My <code>fname</code> is either a file path that needs to be opened or it has already been opened elsewhere by <code>open(the_actual_file_name)</code></i>". In this case you could do, say <code>context = gzip.open(fname, 'rt') if isinstance(fname, str) else contextlib.nullcontext(fname)</code> and use a single <code>with context as f:</code> block which will work in both cases just fine. This is exactly the second example given <a href="https://docs.python.org/3/library/contextlib.html#contextlib.nullcontext" rel="nofollow noreferrer">in the docs</a>, actually.</span>
<span class="comment-copy">@Idlehands.  very true, and Python is usually pretty clear in its intent. but context managers <i>are</i> a bit unusual in their implicit enter/exit triggering.   It’s not all that obvious that the context creation can syntactically be separated from <b>as</b>, so this post is extra informative - despite using them for a while this is a new trick for me.</span>
<span class="comment-copy">Why the need to put everything on one line?</span>
<span class="comment-copy">No real need of course, which is your (valid) point. But arguably it answers the actual question better, as the question mentions: "[...] what is the shortest way [...]"</span>
<span class="comment-copy">'shortest' is not always the better or more readable way.</span>
<span class="comment-copy">I did not say that. It was the OP who asked that.</span>
<span class="comment-copy">I didn't say you said that.</span>
