<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/37444002/overriding-enum-call-method">Overriding Enum __call__ method</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>My end goal really is to create a helper method in my Enum class that always returns an Enum member and never raises an exception, given whatever possible value, e.g.</p>
<pre><code>Color.from_value('red')
</code></pre>
<p>In case the value is not part of the enum, the helper method will return a default one, say <code>Color.UNKNOWN</code>.</p>
<p>Based on this <a href="https://stackoverflow.com/a/43634746/404604">answer from another related question</a>, I can do checks on the values by listing them through some built-in members. However, what I want to do next is to keep track of all the values in an internal member so that I don't have to always iterate through the values every time the helper method is called. I tried doing something similar to the following:</p>
<pre><code>class Color(Enum):
    RED = 'red'
    BLUE = 'blue'
    GREEN = 'green'

    # this doesn't work
    _values = [item.value for item in Color]
</code></pre>
<p>and as expected, it doesn't work. Is this perhaps something that's already built-in in Python Enums?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create the method and check for the values in the class:</p>
<pre><code>import enum

class Color(enum.Enum):
    RED = 'red'
    BLUE = 'blue'
    GREEN = 'green'
    UNKNOWN = "unknown"

    @classmethod
    def from_value(cls, value):
      try:
        return {item.value: item for item in cls}[value]
      except KeyError:
        return cls.UNKNOWN

print(Color.from_value("hey"))
print(Color.from_value("red"))
</code></pre>
<p>Results:</p>
<pre><code>Color.UNKNOWN
Color.RED
</code></pre>
<p>Here you have a <a href="https://repl.it/repls/TastyHeartyBlog" rel="nofollow noreferrer">live example</a></p>
<p>In case you dont want to reiterate, you can always have an outside cache of the values:</p>
<pre><code>class Color(enum.Enum):
    RED = 'red'
    BLUE = 'blue'
    GREEN = 'green'
    UNKNOWN = "unknown"

    @classmethod
    def from_value(cls, value):
      try:
        return _COLORITEMS[value]
      except KeyError:
        return cls.UNKNOWN
_COLORITEMS = {item.value: item for item in Color}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have since accepted <a href="https://stackoverflow.com/a/53041398/404604">Netwave's answer</a> but I'm adding this as a bit of variation from the original. I wanted to preserve the answer as is for reference.</p>
<pre><code>import enum

class Color(enum.Enum):
    RED = 'red'
    BLUE = 'blue'
    GREEN = 'green'
    UNKNOWN = "unknown"

    @staticmethod
    def from_value(value):
      try:
        return Color(value)
      except ValueError:
        return cls.UNKNOWN
</code></pre>
<p>Notice that in this approach, I have changed <code>@classmethod</code> to <code>@staticmethod</code> as I have no more need for the <code>cls</code> argument. In addition, I'm handling <code>ValueError</code> here instead of <code>KeyError</code> because that's what the <code>Color()</code> raises in case the value couldn't be found. This also works for multi-valued/tuple valued enums.</p>
<p>As for the second approach:</p>
<pre><code>import enum

class Color(enum.Enum):
    RED = 'red'
    BLUE = 'blue'
    GREEN = 'green'
    UNKNOWN = "unknown"

    @staticmethod
    def from_value(value):
        return Color(value) if value in _COLORITEMS else Color.UNKNOWN

_COLORITEMS = [item.value for item in Color]
</code></pre>
<p>Here, I switched from dict to list to keep track of values. Instead of handling <code>KeyError</code>, I just simply checked if the value is in the list. I could have used a set but since it's an enum, values are guaranteed to be unique (if I understand correctly).</p>
</div>
<div class="post-text" itemprop="text">
<p>[excerpt from <a href="https://stackoverflow.com/a/37444678/208880">my answer here</a>]</p>
<p>With Python 3.6 (and <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>aenum 2.0</code></a><sup>1</sup>) you can specify a <code>_missing_</code> method that will be called to give your class one last chance before raising <code>ValueError</code>.  So now you can do:</p>
<pre><code>    @classmethod
    def _missing_(cls, name):
        return cls.never_heard_of
</code></pre>
<p><em>N.B.</em>: only enum members or <code>None</code> should be returned by <code>_missing_</code> -- later Python versions will raise <code>TypeError</code> if anything else is returned by <code>_missing_</code>.</p>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<span class="comment-copy">So what would happen if someone calls <code>Color.from_value('chucknorris')</code>? Would that create a new Enum value and return it?</span>
<span class="comment-copy">Nope. It will return a default enum, something like <code>Color.UNKNOWN</code>.</span>
<span class="comment-copy">ha! was about to suggest the second variant. but you were quicker!</span>
<span class="comment-copy">So, technically, there's no way to keep track of the values in the Enum class internally?</span>
<span class="comment-copy">@PsychoPunch, I don't see how to, since you can not access the class values till it is completely read (AFAIK)</span>
<span class="comment-copy">Thanks but I'm not sure why you marked this as duplicate, as my question is really about something else. While your solution can potentially apply to both, and that the problems intersect quite a bit, they're not exactly the same. See, I have one more requirement that the <code>from_value</code> is case insensitive so that <code>from_value('red')</code> or <code>from_value('Red')</code> returns <code>Color.RED</code>. How do I accomplish that by using <code>_missing_</code>?</span>
