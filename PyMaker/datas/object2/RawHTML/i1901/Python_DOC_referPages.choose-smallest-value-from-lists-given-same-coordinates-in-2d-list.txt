<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>a = [[9, 5], [9, 10000], [9, 10000], [5, 10000], [5, 10000], [10001, 10], [10001, 10]]
b = [19144.85, 8824.73, 26243.88, 23348.02, 40767.17, 55613.43, 40188.8]
</code></pre>
<p>I am trying to remove the repeated coordinates in a and remove the adjacent value in b but by leaving the smallest value. So for example coordinate [9,10000] is repeated twice with values in b of 8824.73 and 26243.88 the result should be two lists where there is only one [9,10000] with the smaller of b which is 8824.73.</p>
<p>So overall the result should look like:</p>
<pre><code>aa = [[9,5],[9,10000],[5,10000],[10001,10]]
bb = [19144.85, 8824.73, 23348.02, 40188.8]
</code></pre>
<p>I am finding it difficult to formulate the problem and iterate through the lists and I am not sure how I can use the zip function. Any help is appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an O(<em>n</em>) solution using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict

dd = defaultdict(list)

for (key1, key2), value in zip(a, b):
    dd[(key1, key2)].append(value)

aa = list(map(list, dd))
bb = list(map(min, dd.values()))

print(aa, bb, sep='\n'*2)

[[9, 5], [9, 10000], [5, 10000], [10001, 10]]

[19144.85, 8824.73, 23348.02, 40188.8]
</code></pre>
<h3>Explanation</h3>
<p>There are 3 steps:</p>
<ol>
<li>Create a dictionary mapping each pair of keys to a list of values. Be careful to use <code>tuple</code> as keys, which must be hashable.</li>
<li>For <em>unique</em> keys, just extract your <code>defaultdict</code> keys, mapping to <code>list</code> so that you have a list of lists instead of list of tuples.</li>
<li>For minimum values, use <code>map</code> with <code>min</code>.</li>
</ol>
<h3>Note on ordering</h3>
<p>Dictionaries are insertion ordered in Python 3.6+, and this can be relied upon in 3.7+. In earlier versions, you can rely on <em>consistency</em> of ordering between <code>dd.keys</code> and <code>dd.values</code> provided no operations have taken place in between access of keys and values.</p>
</div>
<span class="comment-copy">Are you open to using 3rd party libraries (e.g. Pandas, NumPy), or are you looking for a pure Python solution?</span>
<span class="comment-copy">Does the result need to have the same order as the original list?</span>
<span class="comment-copy">I had started writing a solution using <code>combination</code> and <code>enumerate</code> and all that jazz ... But this is so much more straightforward. A bit more explanation for novices is welcome though. Basically, create a dictionary with the unique values from <code>a</code> mapped to the values from <code>b</code> put in a list. Then you can just <code>list()</code> the keys of that dictionary and get their <code>min()</code> values.</span>
<span class="comment-copy">@BramVanroy, Sure, I've tried to add a bit more explanation.</span>
<span class="comment-copy">Great! Very helpful for everyone. +1</span>
