<div class="post-text" itemprop="text">
<p>I'm looking to differentiate between a number like
<code>2.0</code> or <code>2</code> and an actual fractional number such as <code>2.4</code>. What would be the best way to do this? Currently I'm doing:</p>
<pre><code>def is_fractional(num):
    if not str(num).replace('.','').isdigit(): return
    return float(num) != int(num)

&gt;&gt;&gt; is_fractional(2)
False
&gt;&gt;&gt; is_fractional(2.1)
True
&gt;&gt;&gt; is_fractional(2.0)
False
&gt;&gt;&gt; is_fractional('a')
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That operation is built-in:</p>
<pre><code>&gt;&gt;&gt; 5.0.is_integer()
True
&gt;&gt;&gt; 5.00000001.is_integer()
False
&gt;&gt;&gt; 4.9999999.is_integer()
False
</code></pre>
<p>Documentation is <a href="https://docs.python.org/3/library/stdtypes.html#additional-methods-on-float" rel="nofollow noreferrer">here</a>.</p>
<p><strong>ADDENDUM</strong></p>
<p>The initial solution only works for <code>float</code>. Here's a more complete answer, with tests:</p>
<pre><code>from decimal import Decimal

def is_integer(x):
    if isinstance(x, int):
        return True
    elif isinstance(x, float):
        return x.is_integer()
    elif isinstance(x, Decimal):
        return x.as_integer_ratio()[1] == 1
    return False

good = [
    0, 
    0.0, 
    3, 
    -9999999999999999999999, 
    -2.0000000000000,
    Decimal("3.000000"),
    Decimal("-9")
]
bad = [
    -9.99999999999999,
    "dogs",
    Decimal("-4.00000000000000000000000000000000001"),
    Decimal("0.99999999999999999999999999999999999")
]

for x in good:
    assert is_integer(x)
for x in bad:
    assert not is_integer(x)
print("All tests passed")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If some of your numbers are <code>decimal.Decimal</code>s, they might have range issues where conversion to float fails, or drops the fractional part that actually exists, depending on their precision:</p>
<pre><code>&gt;&gt;&gt; import decimal
&gt;&gt;&gt; x = decimal.Decimal('1.00000000000000000000000000000000000001')
&gt;&gt;&gt; str(x)
'1.00000000000000000000000000000000000001'
&gt;&gt;&gt; float(x).is_integer()
True

&gt;&gt;&gt; y = decimal.Decimal('1e5000')
&gt;&gt;&gt; str(y)
'1E+5000'
&gt;&gt;&gt; float(y)
inf
</code></pre>
<p>The <code>str</code> method will generally work (modulo problem cases like the one illustrated above), so you could stick with that, but it might be better to attempt to use <code>is_integer</code> and use a fallback if that fails:</p>
<pre><code>try:
   return x.is_integer()
except AttributeError:
   pass
</code></pre>
<p>(as others note, you'll need to check for <code>int</code> and <code>long</code> here as well, if those are allowed types, since they are integers by definition but lack an <code>is_integer</code> attribute).</p>
<p>At this point, it's worth considering all of the other answers, but here's a specific decimal.Decimal handler:</p>
<pre><code># optional: special case decimal.Decimal here
try:
    as_tuple = x.as_tuple()
    trailing0s = len(list(itertools.takewhile(lambda i: i == 0, reversed(as_tuple[1]))))
    return as_tuple[2] + trailing0s &lt; 0
except (AttributeError, IndexError): # no as_tuple, or not 3 elements long, etc
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why do not check if the difference between the truncation to integer and the exact value is not zero?</p>
<pre><code>is_frac = lambda x: int(x)-x != 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are dealing with <code>decimal</code> module or with a <code>float</code> object, you can do this easily:</p>
<pre><code>def is_factional(num):
    return isinstance(num, (float, Decimal))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way to do it (assuming e.g. 2/2 is not "fractional" in the sense you have in mind):</p>
<pre><code># could also extend to other numeric types numpy.float32 
from decimal import Decimal

def is_frac(n):
  numeric_types = (int, float, Decimal)
  assert isinstance(n, numeric_types), 'n must be numeric :/'
  # (ints are never fractions)
  if type(n) is int: return False
  return n != float(int(n))

# various sorts of numbers 
ns = [-1, -1.0, 0, 0.1, 1, 1.0, 1., 2.3, 1e0, 1e3, 1.1e3, 
      Decimal(3), Decimal(3.0), Decimal(3.1)]

# confirm that values are as expected 
dict(zip(ns, [is_frac(n) for n in ns]))
</code></pre>
<p>This will only work if <code>n</code> is an <code>int</code> or a <code>float</code> or <code>decimal.Decimal</code>. But you could extend it to handle other numeric types such as <code>numpy.float64</code> or <code>numpy.int32</code> by just including them in <code>numeric_types</code>.</p>
</div>
<span class="comment-copy">Maybe <code>abs(x - int(x)) &gt; 0</code>?</span>
<span class="comment-copy">The issue with this approach, is I'm often dealing with decimals so I'd need to first cast it. Otherwise, I get: <code>AttributeError: 'decimal.Decimal' object has no attribute 'is_integer'</code></span>
<span class="comment-copy">Good point. <code>is_integer</code> only exists on <code>float</code>s. For <code>Decimal</code> I would go with <code>d.as_integer_ratio()[1] == 1</code>.</span>
<span class="comment-copy">Updated the answer</span>
<span class="comment-copy">Ah, the <code>as_integer_ratio</code> is better than <code>as_tuple</code> and counting trailing zeros. +1</span>
<span class="comment-copy">I think so... I tried a few of  the <code>decimal.Decimal</code> methods and found this one to be particularly nice and to work for everything I threw at it. Unbounded integers in Python are so nice.</span>
