<div class="post-text" itemprop="text">
<p>In a parent class, I defined a class variable and a class method with which to modify the class variable value. I want each child class to use its own variable, not share with its parent. </p>
<p>But the result is not what I expected; in the following example I have two sets of parent class plus child classes, and some code to demonstrate what goes wrong:</p>
<pre><code>class P:
    _X = 0

    @classmethod
    def cm(cls):
        print("In p cm")
        cls._X += 1

class C1(P):
    pass

class C2(P):
    pass

class Image:
    _callbacks = {}

    @classmethod
    def registerDataFormat(cls, fmt, loader):
        if fmt in cls._callbacks.keys():
            print("The %s format has already been registered." % (fmt))
            return False

        cls._callbacks[fmt] = {}
        cls._callbacks[fmt]["loader"] = loader

class HSImage(Image):
    pass

class GT(Image):
    pass

if __name__ == '__main__':
    C1.cm()
    print(C1._X)
    print(P._X)
    C2.cm()
    print(C2._X)
    print(P._X)

    HSImage.registerDataFormat("mat", "loader 1")
    print(HSImage._callbacks)
    print(Image._callbacks)
    GT.registerDataFormat("mat", "loader 2")
    print(GT._callbacks)
    print(Image._callbacks)
</code></pre>
<p>Here are the results:</p>
<pre><code>In p cm
1
0
In p cm
1
0
{'mat': {'loader': 'loader 1'}}
{'mat': {'loader': 'loader 1'}}
The mat format has already been registered.
{'mat': {'loader': 'loader 1'}}
{'mat': {'loader': 'loader 1'}}
</code></pre>
<p>The first example has the expected result, but not the second, why is the class variable shared with the parent class when I called the class method on a child class in the second set of classes?</p>
<p>My expected results:</p>
<pre><code>In p cm
1
0
In p cm
1
0
{'mat': {'loader': 'loader 1'}}
{}
{'mat': {'loader': 'loader 2'}}
{}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The difference is that you <em>mutated a dictionary</em>. The first, simple example with integers works with immutable integer objects. <code>cls._X += 1</code> takes the value of <code>_X</code> (from a parent class if necessary), after which the <code>old + 1</code> operation produces a new integer object that is then assigned back to <code>cls._X</code>. The assignment matters here, as that will take place on the child class.</p>
<p>But you didn't assign anything back to a class with the second case:</p>
<pre><code>cls._callbacks[fmt] = {}
cls._callbacks[fmt]["loader"] = loader
</code></pre>
<p>You assigned to a key <em>in</em> the dictionary. The <code>cls._callbacks</code> attribute itself is not altered, it is the same dictionary shared between all the classes. The <code>cls._callbacks</code> reference is looked up, found on the <code>Image</code> base class, after which the dictionary itself is updated by adding the key-value pair. None of the subclasses (<code>HSImage</code> or <code>GT</code>) have the attribute themselves.</p>
<p>You would need to create a copy and assign back the altered copy:</p>
<pre><code>cls._callbacks = {k: dict(v) for k, v in cls._callbacks.items()}
cls._callbacks[fmt] = {'loader': loader}
</code></pre>
<p>This creates a copy not just of the outer dictionary but of all the values too, because those are all dictionaries too, before adding the new dictionary for <code>fmt</code>. The copy is then assigned to <code>cls._callbacks</code>, effectively creating a new attribute on a subclass if it wasn't there already.</p>
<p>That's not that efficient of course; the copy is created <em>each time you register a loader</em>. You'd be better of with creating a new <code>_callback</code> dictionary object on each subclass, but that gets tedious and can easily be forgotten. You can instead <em>automate</em> that with the <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer"><code>__init_subclass__</code> method</a>:</p>
<pre><code>class Image:
    def __init_subclass__(cls):
        cls._callbacks = {}

    @classmethod
    def registerDataFormat(cls, fmt, loader):
        if fmt in cls._callbacks:
            print("The {} format has already been registered.".format(fmt))
            return

        cls._callbacks[fmt] = {'loader': loader}
</code></pre>
<p>The <code>__init_subclass__</code> method is called for each subclass you create.</p>
</div>
<span class="comment-copy">Thank you, by the way, for providing a full MCVE, and thank you for cleaning it up a bit more to tighten it up. That's not seen all that often in new questions.</span>
