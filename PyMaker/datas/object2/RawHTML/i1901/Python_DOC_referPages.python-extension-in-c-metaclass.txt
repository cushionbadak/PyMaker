<div class="post-text" itemprop="text">
<p>I have the following python code:</p>
<pre class="lang-py prettyprint-override"><code>class Meta(type):
    def __call__(cls, *args, **kwargs):
        obj = type.__call__(cls, *args, **kwargs)
        # Only do checks for subclasses
        if cls.__name__ == 'Parent':
            return obj
        required_attrs = ['x']
        for ra in required_attrs:
            if ra not in dir(obj):
                fmt = 'Subclasses of Parent must define the %s attribute'
                raise NotImplementedError(fmt % ra)
        return obj

class Parent(metaclass=Meta):
    pass

class Child(Parent):
    def __init__(self):
        self.x = True
</code></pre>
<p><code>Meta</code> is used only to require that <code>Child</code> defines certain attributes. This class structure must remain as is because this is how my project is structured. <code>Parent</code> is actually called <code>DefaultConfig</code> and <code>Child</code> is actually a user-defined class derived from <code>DefaultConfig</code>.</p>
<p>I'm working on translating <code>Meta</code> and <code>Parent</code> into a C extension. This is the module:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;Python.h&gt;
#include &lt;structmember.h&gt;

#define ARRLEN(x) sizeof(x)/sizeof(x[0])


typedef struct {
    PyObject_HEAD
} MetaObject;

typedef struct {
    PyObject_HEAD
} ParentObject;


static PyObject *Meta_call(MetaObject *type, PyObject *args, PyObject *kwargs) {
    PyObject *obj = PyType_GenericNew((PyTypeObject *) type, args, kwargs);

    // Only do checks for subclasses of Parent
    if (strcmp(obj-&gt;ob_type-&gt;tp_name, "Parent") == 0)
        return obj;

    // Get obj's attributes
    PyObject *obj_dir = PyObject_Dir(obj);
    if (obj_dir == NULL)
        return NULL;

    char *required_attrs[] = {"x"};

    // Raise an exception of obj doesn't define all required_attrs
    PyObject *attr_obj;
    int has_attr;
    for (int i=0; i&lt;ARRLEN(required_attrs); i++) {
        attr_obj = PyUnicode_FromString(required_attrs[i]);
        has_attr = PySequence_Contains(obj_dir, attr_obj);
        if (has_attr == 0) {
            printf("Subclasses of Parent must define %s\n", required_attrs[i]);
            // raise NotImplementedError
            return NULL;
        } else if (has_attr == -1) {
            return NULL;
        }
    }

    return obj;
}


static PyTypeObject MetaType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom.Meta",
    .tp_basicsize = sizeof(MetaObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = PyType_GenericNew,
    .tp_call = (ternaryfunc) Meta_call,
};

static PyTypeObject ParentType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom.Parent",
    .tp_basicsize = sizeof(ParentObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = PyType_GenericNew,
};


static PyModuleDef custommodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "custom",
    .m_size = -1,
};


PyMODINIT_FUNC PyInit_custom(void) {
    PyObject *module = PyModule_Create(&amp;custommodule);
    if (module == NULL)
        return NULL;

    // Should Parent inherit from Meta?
    ParentType.tp_base = &amp;MetaType;

    if (PyType_Ready(&amp;MetaType) &lt; 0)
        return NULL;
    Py_INCREF(&amp;MetaType);
    PyModule_AddObject(module, "Meta", (PyObject *) &amp;MetaType);

    if (PyType_Ready(&amp;ParentType) &lt; 0)
        return NULL;
    Py_INCREF(&amp;ParentType);
    PyModule_AddObject(module, "Parent", (PyObject *) &amp;ParentType);

    return module;
}
</code></pre>
<p>This is the python code used to test module <code>custom</code>:</p>
<pre class="lang-py prettyprint-override"><code>import custom

class Child(custom.Parent):
    def __init__(self):
        self.x = True

if __name__ == '__main__':
    c = Child()
</code></pre>
<p>Unfortunately, there is no <code>.tp_meta</code> member in the <code>PyTypeObject</code> struct, so how do I specify <code>Meta</code> as the metaclass of <code>Parent</code>?</p>
<hr/>
<p><strong>EDIT</strong>:</p>
<p>Modified C code:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;Python.h&gt;
#include &lt;structmember.h&gt;

#define ARRLEN(x) sizeof(x)/sizeof(x[0])


typedef struct {
    PyObject_HEAD
    PyTypeObject base;
} MetaObject;

typedef struct {
    PyObject_HEAD
} ParentObject;


static PyObject *Meta_call(MetaObject *type, PyObject *args, PyObject *kwargs) {
    PyObject *obj = PyType_GenericNew((PyTypeObject *) type, args, kwargs);

    // Only do checks for subclasses of Parent
    if (strcmp(obj-&gt;ob_type-&gt;tp_name, "Parent") == 0)
        return obj;

    // Get obj's attributes
    PyObject *obj_dir = PyObject_Dir(obj);
    if (obj_dir == NULL)
        return NULL;

    char *required_attrs[] = {"x"};

    // Raise an exception of obj doesn't define all required_attrs
    PyObject *attr_obj;
    int has_attr;
    for (int i=0; i&lt;ARRLEN(required_attrs); i++) {
        attr_obj = PyUnicode_FromString(required_attrs[i]);
        has_attr = PySequence_Contains(obj_dir, attr_obj);
        if (has_attr == 0) {
            printf("Subclasses of Parent must define %s\n", required_attrs[i]);
            // raise NotImplementedError
            return NULL;
        } else if (has_attr == -1) {
            return NULL;
        }
    }

    return obj;
}


static PyTypeObject MetaType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom.Meta",
    .tp_basicsize = sizeof(MetaObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = PyType_GenericNew,
    .tp_call = (ternaryfunc) Meta_call,
};

static PyTypeObject ParentType = {
    PyVarObject_HEAD_INIT(&amp;MetaType, 0)
    .tp_name = "custom.Parent",
    .tp_basicsize = sizeof(ParentObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = PyType_GenericNew,
};


static PyModuleDef custommodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "custom",
    .m_size = -1,
};


PyMODINIT_FUNC PyInit_custom(void) {
    PyObject *module = PyModule_Create(&amp;custommodule);
    if (module == NULL)
        return NULL;

    MetaType.tp_base = &amp;PyType_Type;
    if (PyType_Ready(&amp;MetaType) &lt; 0)
        return NULL;
    Py_INCREF(&amp;MetaType);
    PyModule_AddObject(module, "Meta", (PyObject *) &amp;MetaType);

    if (PyType_Ready(&amp;ParentType) &lt; 0)
        return NULL;
    Py_INCREF(&amp;ParentType);
    PyModule_AddObject(module, "Parent", (PyObject *) &amp;ParentType);

    return module;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The metaclass is nothing but <em>a type</em> that is used as <em>the type</em> (<strong><code>ob_type</code></strong>!) of the class (type)... (clear, isn't it)... <code>ParentType</code> does not inherit from <code>MetaType</code> but is an instance of `MetaType.</p>
<p>Hence, the place where <code>&amp;MetaType</code> <em>should</em> go if it works as it should, is <code>ParentType.ob_type</code>:</p>
<pre><code>PyModule_AddObject(module, "Meta", (PyObject *) &amp;MetaType);

ParentType.ob_type = &amp;MetaType;

if (PyType_Ready(&amp;ParentType) &lt; 0)
</code></pre>
<p><code>PyType_Ready</code> checks the <code>ob_type</code> field - if it is <code>NULL</code>, it takes the <code>ob_type</code> of the <code>.tp_base</code>; but if <code>ob_type</code> is set already, it is left as is. </p>
<p>Actually you can set it in the <code>ParentType</code> initializer:</p>
<pre><code>PyVarObject_HEAD_INIT(&amp;MetaType, 0)
</code></pre>
<p>The first argument goes to the <code>ob_type</code> field.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no direct way to do this. According to the <a href="https://docs.python.org/3/c-api/typeobj.html" rel="nofollow noreferrer">py docs</a>, there is no members or flags to directly indicate a class is a meta class of another. The attribute responsible for indicating a meta class is <a href="https://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__" rel="nofollow noreferrer">inside the class dictionary</a>. You could implement something that modifies the <code>.tp_dict</code> member, but this is actually deemed <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_dict" rel="nofollow noreferrer">unsafe</a> if done through the dictionary C-API.</p>
<blockquote>
<p>Warning It is not safe to use PyDict_SetItem() on or otherwise modify tp_dict with the dictionary C-API.</p>
</blockquote>
<p>EDIT:</p>
<p>From the <a href="https://github.com/python/cpython/blob/9dfa0fe587eae3626ffc973680c6a17f35de3864/Python/bltinmodule.c#L151" rel="nofollow noreferrer">python source code</a>, it seems meta class is accessed as an <code>id</code> via the C dictionary API, but the methods to do so are prefixed with an <code>_</code>, and don't appear in any documentation.</p>
<pre><code>    meta = _PyDict_GetItemId(mkw, &amp;PyId_metaclass);
    if (meta != NULL) {
        Py_INCREF(meta);
        if (_PyDict_DelItemId(mkw, &amp;PyId_metaclass) &lt; 0) {
            Py_DECREF(meta);
            Py_DECREF(mkw);
            Py_DECREF(bases);
            return NULL;
        }
</code></pre>
<p>These methods are apart of the <a href="https://docs.python.org/3/c-api/stable.html" rel="nofollow noreferrer">"limited api"</a>, and can be used by defining the <code>Py_LIMITED_API</code> macro</p>
<pre><code>PyAPI_FUNC(PyObject *) _PyDict_GetItemId(PyObject *dp, struct _Py_Identifier *key);
#endif /* !Py_LIMITED_API */
PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
#ifndef Py_LIMITED_API
PyAPI_FUNC(int) _PyDict_SetItemId(PyObject *dp, struct _Py_Identifier *key, PyObject *item);
#endif /* !Py_LIMITED_API */
</code></pre>
</div>
<span class="comment-copy">It seems though the python source code has a special attribute called <code>PyId_metaclass</code> that it uses to determine the meta class .... <a href="https://github.com/python/cpython/blob/9dfa0fe587eae3626ffc973680c6a17f35de3864/Python/bltinmodule.c#L151" rel="nofollow noreferrer">github.com/python/cpython/blob/…</a></span>
<span class="comment-copy">@JoshWeinstein on the contrary, this is just the <i>string</i> <code>"metaclass"</code>, used to get the <code>metaclass=FooBar</code> from the kwargs.</span>
<span class="comment-copy">Setting <code>ob_type</code> isn't going to be enough, though, because there are other problems with the code in the question. For example, <code>MetaObject</code> doesn't include a <code>PyTypeObject</code> base member, and <code>MetaType</code>'s <code>tp_base</code> needs to be set to <code>PyType_Type</code>.</span>
<span class="comment-copy">Also, things like PyId_metaclass aren't <i>quite</i> just strings - they're wrappers used to manage interned, static strings. Python still ends up using it to fetch <code>metaclass</code> from the kwargs by string name, though. It's not any sort of special attribute, and it's not how the metaclass of an actual class object is stored.</span>
<span class="comment-copy">@Nelson: From a quick glance, you don't need the <code>PyObject_HEAD</code> in <code>MetaObject</code>; the <code>PyTypeObject</code>'s <code>PyObject_HEAD</code> takes care of that. There may be other problems. See the <a href="https://docs.python.org/3/extending/newtypes_tutorial.html#subclassing-other-types" rel="nofollow noreferrer">relevant section</a> of the C API tutorial, and <a href="https://github.com/python/cpython/blob/v3.7.0/Modules/xxsubtype.c" rel="nofollow noreferrer"><code>Modules/xxsubtype.c</code></a> for an example of implementing subclasses of built-in types in C.</span>
<span class="comment-copy">There is a member indicating a class's metaclass; it's part of PyObject_HEAD, and it's the same member used for any other object's class. The <code>__metaclass__</code> dict entry isn't used in Python 3, and it was only ever used in Python 2 during class creation, not to determine the metaclass of an already-created class.</span>
<span class="comment-copy">Setting <code>__metaclass__</code> in the dict of an existing class won't affect its metaclass. Also, messing with <code>tp_dict</code> after <code>PyType_Ready</code> is called is still unsafe.</span>
<span class="comment-copy">Can you link to where that part of PyObject_HEAD is? not documented here <a href="https://docs.python.org/3/c-api/structures.html#c.PyObject" rel="nofollow noreferrer">docs.python.org/3/c-api/structures.html#c.PyObject</a></span>
<span class="comment-copy">/usr/include/python3.6/object.h:83 <code>#define PyObject_HEAD   PyObject ob_base;</code>. I don't understand how a <code>PyObject</code> contains the information about a type's metaclass</span>
<span class="comment-copy">Updated my answer to include the place in the python source code that checks an objects meta class. It is <i>not</i> in <code>PyObject_HEAD</code></span>
