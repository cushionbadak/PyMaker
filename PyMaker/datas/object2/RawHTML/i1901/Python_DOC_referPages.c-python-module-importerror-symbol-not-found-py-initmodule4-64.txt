<div class="post-text" itemprop="text">
<p>I am beginning the process of writing Python 3 module in C.  The C I have written already compiles fine (code I compiled at bottom of post).  I compile with:</p>
<pre><code>python3 setup.py build_ext --inplace
</code></pre>
<p>The built .so file is placed in the current directory.  After launching python3, when I import my module I get this error (tripple dot used to truncate paths):</p>
<pre><code>&gt;&gt;&gt; import helloWorld
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: dlopen(..., 2): Symbol not found: _Py_InitModule4_64
  Referenced from: .../helloWorld.cpython-36m-darwin.so
  Expected in: flat namespace
 in .../helloWorld.cpython-36m-darwin.so
</code></pre>
<p>How do I got about getting symbol <strong>_Py_InitModule4_64</strong> implemented?</p>
<p>I am running macOS High Sierra if that means anything</p>
<hr/>
<p>Running <em>nm</em> for <em>helloWorld.cpython-36m-darwin.so</em> shows _Py_InitModule4_64 is undefined, so does that prove there is an issue in the compilation process?</p>
<pre><code>nm helloWorld.cpython-36m-darwin.so 
                 U _Py_BuildValue
                 U _Py_InitModule4_64
0000000000000eb0 t _helloWorld
0000000000001060 d _helloWorld_docs
0000000000001020 d _helloworld_funcs
0000000000000e80 T _inithelloWorld
                 U dyld_stub_binder
</code></pre>
<h2>Code</h2>
<p>test.c:</p>
<pre><code>#include &lt;Python/Python.h&gt;

static PyObject* helloWorld(PyObject* self) {
   return Py_BuildValue("s", "Hello, Python extensions!!");
}

static char helloWorld_docs[] =
   "helloWorld( ): Any message you want to put here!!\n";

static PyMethodDef helloworld_funcs[] = {
   {"helloWorld", (PyCFunction)helloWorld,
   METH_NOARGS, helloWorld_docs},
   {NULL}
};

void inithelloWorld(void) {
   Py_InitModule3("helloworld", helloworld_funcs, "Extension module example!");
}
</code></pre>
<p>setup.py:</p>
<pre><code>from distutils.core import setup, Extension

setup(name = 'helloWorld', version = '1.0', \
    ext_modules = [Extension('helloWorld', ['test.c'])])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You wrote your module against the Python 2 C API (<a href="https://docs.python.org/2/c-api/allocation.html#c.Py_InitModule" rel="nofollow noreferrer">the various <code>Py_InitModule</code> functions</a> are purely for Python 2), but you're trying to compile it and run it with Python 3. The C layer for CPython changed a <em>lot</em> between Python 2 and 3, and there is no <code>2to3</code> tool for the C code to my knowledge.</p>
<p>You need to write Python 3 API compatible code to work on Python 3; the simplest (and only approach supported on 3.0-3.4) translation is to <a href="https://docs.python.org/3/c-api/module.html#single-phase-initialization" rel="nofollow noreferrer">single-phase initialization</a> (with <code>PyModule_Create</code>), but <a href="https://docs.python.org/3/c-api/module.html#multi-phase-initialization" rel="nofollow noreferrer">multi-phase initialization</a> gets behavior more like modules defined in Python (e.g. it's possible to completely unload them in a way that isn't possible with single-phase modules). The structure of the entry point name changed as well, from <code>initMODULENAME</code> to <code>PyInit_MODULENAME</code>, so you'll need to update that as well.</p>
<p>I'd strongly recommend reading <a href="https://docs.python.org/3/extending/index.html" rel="nofollow noreferrer">the Python 3 extension module tutorial</a>.</p>
</div>
<span class="comment-copy">Side-note: I suspect your build environment is messed up (e.g. Python 2 include directories have been forcibly added to <code>CPATH</code> or otherwise added you the include path in <code>setup.py</code> or the like), because you used <code>Py_InitModule3</code> and it translated to a dependency on <code>_Py_InitModule4_64</code>, which implies a remapping from a header that knows what <code>Py_InitModule3</code> is, and no Python 3 header should recognize that API name. I'm guessing you tried to force your way through some compiler errors, with "success" just guaranteeing the result was unusable anyway. Don't do that.</span>
<span class="comment-copy">Ah!  Yes, the header is incorrect.  I was using the answer from <a href="https://stackoverflow.com/questions/16454129/python-h-header-file-missing-on-mac-os-x-10-6">this post</a>, where I use <code>#include &lt;Python/Python.h&gt;</code> instead of <code>#include &lt;Python.h&gt;</code> for when I was compiling with gcc.  'Py_InitModule3' is now unknown upon compilation, like you stated.</span>
<span class="comment-copy">After following the module tutorial explicitly, everything works like expected.  Thank you for all the resources!</span>
<span class="comment-copy">@TarasPalczynski: You're welcome. Glad it was enough to get you on the right track. I've had to write cross-version (as in, compiles for both Py2 and Py3) portable Python C extensions, so I'm <i>really</i> familiar with the discrepancies, and module initialization is one of the biggies (the changes are so extreme that the two APIs are best treated as completely unrelated).</span>
