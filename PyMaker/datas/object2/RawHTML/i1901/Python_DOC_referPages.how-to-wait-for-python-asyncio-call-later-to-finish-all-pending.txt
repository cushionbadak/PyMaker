<div class="post-text" itemprop="text">
<p>I want to write a program that utilizes <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_later" rel="nofollow noreferrer">call_later</a> to signal something (or things) to happen later, which themselves might add more routines to be invoked, and then signal to the program to run until there's nothing remaining to be run. For an example, I can do the following:</p>
<pre><code>import  asyncio
START_RATE = 1

async def say_hi(who):
    print(f'hello {who}')

async def call_later(t, func, *params):
    await asyncio.sleep(t)
    await func(*params)

def run():
    # Let's go!
    incr = START_RATE
    loop = asyncio.get_event_loop()
    tasks = []
    for x in range(5):
        wait_delta = 5 - x
        tasks.append(
            call_later(incr * wait_delta, say_hi, x)
        )

    loop.run_until_complete(asyncio.gather(*tasks))

run()
</code></pre>
<p>But you'll notice that <code>call_later</code> is a bespoke coroutine.</p>
<p>Is it possible to use the event loop's <code>call_later</code>, but somehow inspect the event loop or otherwise await the completion of all pending callbacks?</p>
</div>
<div class="post-text" itemprop="text">
<p>You may introspect using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.all_tasks" rel="nofollow noreferrer">asyncio.all_tasks()</a> but it's probably the wrong way to do it.</p>
<p>The right way would be to create futures and allow <code>call_later</code> to mark them as done:</p>
<pre><code>import asyncio
from functools import partial
START_RATE = 1


def say_hi(who):
    print(f'hello {who}')


def run_on_finish(callback):
    def wrapper(func, *args, **kwargs):
        try:
            return func(*args, **kwargs)
        finally:
            callback()
    return wrapper


def release_waiter(waiter, *args):
    """Taken from standard library"""
    if not waiter.done():
        waiter.set_result(None)


def run():
    # Let's go!
    incr = START_RATE
    loop = asyncio.get_event_loop()
    tasks = []
    for x in range(5):
        wait_delta = 5 - x

        # Create a waiter
        waiter = loop.create_future()
        release_cb = partial(release_waiter, waiter)

        # Schedule the function, making sure we release the waiter on finish
        handle = loop.call_later(incr * wait_delta, run_on_finish(release_cb),
                                 say_hi, x)

        # If waiter is cancelled, cancel the handle too.
        waiter.add_done_callback(lambda *args: handle.cancel)

        tasks.append(waiter)

    loop.run_until_complete(asyncio.gather(*tasks))


run()
</code></pre>
<p>Keep in mind <code>call_later</code> is used for normal functions and not coroutines. If <code>say_hi</code> needs to be a coroutine, you should add <code>ensure_future</code> or <code>loop.create_task</code> into the mix.</p>
<p>Adding them does come with more complications -  you'll need to add a few more functions to take <code>ensure_future</code>'s resulting future, and chain it with your waiter in a similar way to <code>futures._chain_future</code>.</p>
<p>I highly suggest using your own coroutine in that case, as you have already done.</p>
</div>
