<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks">How do you split a list into evenly sized chunks?</a>
<span class="question-originals-answer-count">
                    57 answers
                </span>
</li>
</ul>
</div>
<p>How can I print chunks of size 5 from a list and the remaining tail end that does not have chunk size of 5</p>
<p>For example</p>
<pre><code>a = list(range(23))
</code></pre>
<p>I want to produce print out </p>
<pre><code>[0,1,2,3,4], [5,6,7,8,9], [10,11,12,13,14], [15,16,17,18,19], [20,21,22]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer">itertools recipes</a>:</p>
<pre><code>from functools import partial
from itertools import islice

def take(n, iterable):
    return tuple(islice(iterable, n))

def chunked(iterable, n):
    return iter(partial(take, n, iter(iterable)), tuple())

a = list(range(23))
print(list(chunked(a, 5)))
# [(0, 1, 2, 3, 4), (5, 6, 7, 8, 9), (10, 11, 12, 13, 14), 
#  (15, 16, 17, 18, 19), (20, 21, 22)]
</code></pre>
<p>or simply:</p>
<pre><code>n = 5
[a[j:j+n] for j in range(0, len(a), n)]
</code></pre>
</div>
<span class="comment-copy">does <code>chunked</code> need the two <code>iter</code> calls? If yes, why?</span>
<span class="comment-copy">yes, you need to have a fresh iterator to pass to <code>take</code>.</span>
<span class="comment-copy">@Ev.Kounis I think the question relates to the inner <code>iter</code> in <code>iter(iterable)</code>. That one is necessary to turn e.g. sequences into <i>lazy</i> iterators that can be exhausted.</span>
