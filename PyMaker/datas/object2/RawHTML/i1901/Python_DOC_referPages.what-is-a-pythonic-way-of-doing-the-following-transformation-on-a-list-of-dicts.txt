<div class="post-text" itemprop="text">
<p>I have a list of dicts like this:</p>
<pre><code>l = [{'name': 'foo', 'values': [1,2,3,4]}, {'name': 'bar', 'values': [5,6,7,8]}]
</code></pre>
<p>and I would like to obtain an output of this form:</p>
<pre><code>&gt;&gt;&gt; [('foo', 'bar'), ([1,2,3,4], [5,6,7,8])]
</code></pre>
<p>But short of <code>for</code>-looping and <code>append</code>ing I don't see a solution. Is there a smarter way than doing this?</p>
<pre><code>names = []
values = []
for d in l:
    names.append(d['name'])
    values.append(d['values'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use generator expression:</p>
<pre><code>l = [{'name': 'foo', 'values': [1,2,3,4]}, {'name': 'bar', 'values': [5,6,7,8]}]
v = [tuple(k["name"] for k in l), tuple(k["values"] for k in l)]
print(v)
</code></pre>
<p>Output:</p>
<pre><code>[('foo', 'bar'), ([1, 2, 3, 4], [5, 6, 7, 8])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a list comprehension (much like eyllanesc's) if I was writing this code for public consumption. But just for fun, here's a one-liner that doesn't use any <code>for</code>s.</p>
<pre><code>&gt;&gt;&gt; l = [{'name': 'foo', 'values': [1,2,3,4]}, {'name': 'bar', 'values': [5,6,7,8]}]
&gt;&gt;&gt; list(zip(*map(dict.values, l)))
[('foo', 'bar'), ([1, 2, 3, 4], [5, 6, 7, 8])]
</code></pre>
<p>(Note that this only reliably works if dictionaries preserve insertion order, which is not the case in all versions of Python. CPython 3.6 does it as an implementation detail, but it is only guaranteed behavior as of 3.7.)</p>
<p>Quick breakdown of the process:</p>
<ul>
<li>dict.values returns a <code>dict_values</code> object, which is an iterable containing all the values of the dict.</li>
<li><code>map</code> takes each dictionary in <code>l</code> and calls dict.values on it, returning an iterable of dict_values objects.</li>
<li><code>zip(*thing)</code> is a classic "transposition" recipe, which takes an iterable-of-iterables and effectively flips it diagonally. E.g. [[a,b],[c,d]] becomes [[a,c], [b,d]]. This puts all the names into one tuple, and all the values into another.</li>
<li><code>list</code> converts the zip object into a list.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> to <em>guarantee</em> ordering of values:</p>
<pre><code>from operator import itemgetter

fields = ('name', 'values')
res = list(zip(*map(itemgetter(*fields), L)))

print(res)

[('foo', 'bar'), ([1, 2, 3, 4], [5, 6, 7, 8])]
</code></pre>
<p>If, assuming Python 3.6+, you cannot guarantee appropriate insertion-ordering of dictionaries within your input list, you will need to explicitly define an order as above.</p>
<p><strong>Performance</strong></p>
<p>While a list of "tuple comprehensions" works, it becomes unreadable <em>and</em> inefficient when querying more than a couple of fields:</p>
<pre><code>from operator import itemgetter

n = 10**6
L = [{'name': 'foo', 'values': [1,2,3,4], 'name2': 'zoo', 'name3': 'xyz',
      'name4': 'def'}, {'name': 'bar', 'values': [5,6,7,8], 'name2': 'bart',
      'name3': 'abc', 'name4': 'ghi'}] * n

%timeit [tuple(k["name"] for k in L), tuple(k["values"] for k in L),\
         tuple(k["name2"] for k in L), tuple(k["name3"] for k in L),
         tuple(k["name4"] for k in L)]

%timeit fields = ('name', 'values', 'name2', 'name3' ,'name4');\
        list(zip(*map(itemgetter(*fields), L)))

1 loop, best of 3: 1.25 s per loop
1 loop, best of 3: 1.04 s per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may not be exactly what you had in mind, but for tabular data like this I find that <code>pandas</code> is usually the best solution in the long run:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; l = [{'name': 'foo', 'values': [1,2,3,4]}, {'name': 'bar', 'values': [5,6,7,8]}]
&gt;&gt;&gt; df = pd.DataFrame(l)
  name        values
0  foo  [1, 2, 3, 4]
1  bar  [5, 6, 7, 8]
</code></pre>
<p>Usually you use the data frame directly for anything you would need to do, but you can also convert it to a list-based data structure:</p>
<pre><code>&gt;&gt;&gt; df['name'].tolist(), df['values'].tolist()
(['foo', 'bar'], [[1, 2, 3, 4], [5, 6, 7, 8]]) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure about performance, but here's another take using <code>zip()</code> and unpacking:</p>
<pre><code>list(zip(*[tuple(i.values()) for i in l]))

# [('foo', 'bar'), ([1, 2, 3, 4], [5, 6, 7, 8])]
</code></pre>
<p>Edit: As @DeepSpace pointed out, it can be further reduced down to:</p>
<pre><code>list(zip(*(i.values() for i in l)))
</code></pre>
<p>Here's a longer, but more explicit answer if you want to define the orders yourself:</p>
<pre><code>list(zip(*(tuple(map(lambda k: i.get(k), ('name', 'values'))) for i in l)))

# [('foo', 'bar'), ([1, 2, 3, 4], [5, 6, 7, 8])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use map for this</p>
<pre><code>names = tuple(map(lambda d: d['name'], l))
values = tuple(map(lambda d: d['values'], l))
result = [names, values]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First : your code is fine, readable and efficient, which sounds Pythonic to me.
Note that you probably don't want a list of tuples, though. <a href="https://stackoverflow.com/a/626871/6419007">Tuples are immutable</a>, so you wouldn't be able to append another name to <code>names</code>.</p>
<h1>With a single dict</h1>
<p>If <code>names</code> are unique, you could convert your list of dicts to a large dict:</p>
<pre><code>&gt;&gt;&gt; l = [{'name': 'foo', 'values': [1,2,3,4]}, {'name': 'bar', 'values': [5,6,7,8]}]
&gt;&gt;&gt; data = {d['name']:d['values'] for d in l}
&gt;&gt;&gt; data
{'foo': [1, 2, 3, 4], 'bar': [5, 6, 7, 8]}
</code></pre>
<p>You can get the desired information directly:</p>
<pre><code>&gt;&gt;&gt; data.keys()
dict_keys(['foo', 'bar'])
&gt;&gt;&gt; data.values()
dict_values([[1, 2, 3, 4], [5, 6, 7, 8]])
</code></pre>
<p>If you really want a list of lists:</p>
<pre><code>&gt;&gt;&gt; [list(data.keys()), list(data.values())]
[['foo', 'bar'], [[1, 2, 3, 4], [5, 6, 7, 8]]]
</code></pre>
<h1>With pandas</h1>
<p>If you're working with a large list of dicts, you might want to consider <a href="https://pandas.pydata.org/" rel="nofollow noreferrer"><code>pandas</code></a>.</p>
<p>You could initialize a <a href="http://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.DataFrame.html" rel="nofollow noreferrer"><code>DataFrame</code></a> directly:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; df = pd.DataFrame([{'name': 'foo', 'values': [1,2,3,4]}, {'name': 'bar', 'values': [5,6,7,8]}])
&gt;&gt;&gt; df
  name        values
0  foo  [1, 2, 3, 4]
1  bar  [5, 6, 7, 8]
</code></pre>
<p>If you need the names as an iterable, you can get the corresponding column:</p>
<pre><code>&gt;&gt;&gt; df['name']
0    foo
1    bar
Name: name, dtype: object
</code></pre>
<p>If you really need a list of names:</p>
<pre><code>&gt;&gt;&gt; list(df['name'])
['foo', 'bar']
</code></pre>
<p>To get the names and values together:</p>
<pre><code>&gt;&gt;&gt; df.values.T
array([['foo', 'bar'],
       [list([1, 2, 3, 4]), list([5, 6, 7, 8])]], dtype=object)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a recursive way of doing it:</p>
<pre><code>def trans(l):
  if l:
    res = trans(l[1:])
    res[0], res[1] = (l[0]['name'],) + res[0], (l[0]['values'],) + res[1]
    return res
  return [(),()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just like this:</p>
<pre><code>(lambda f:
    lambda l, r=[(), ()]: f(f, l, r)
)(lambda g, l, r:
    r if len(l) == 0  else g(g, l[1:], [r[0]+(l[0]['name'],), r[1]+(l[0]['values'],)])
)([
    {'name': 'foo', 'values': [1, 2, 3, 4]},
    {'name': 'bar', 'values': [5, 6, 7, 8]},
    {'name': 'baz', 'values': [9, 9, 9, 9]}
])
</code></pre>
<p>Result:</p>
<pre><code>[('foo', 'bar', 'baz'), ([1, 2, 3, 4], [5, 6, 7, 8], [9, 9, 9, 9])]
</code></pre>
</div>
<span class="comment-copy">Keep in mind that your solution is probably the best there is performance-wise. All single-line comprehensions will probably need 2 full iterations over the list. Your code does it with one. Shorter code is not always the most Pythonic.</span>
<span class="comment-copy">Your solution is better than all the other ones down there.</span>
<span class="comment-copy">@DeepSpace The list comprehension method actually seems to be the fastest (about 3 times faster than OP.) Here's a script for benchmarking three of the solutions presented below: <a href="https://repl.it/@cchudzicki/Looping-Efficiency" rel="nofollow noreferrer">repl.it/@cchudzicki/Looping-Efficiency</a> For loops, it matters not just "how many loops" but also how many operations you do during each iteration. BTW: As always, don't optimize for efficiency prematurely. But I wouldn't go out of my way to avoid a generator expression in the name of efficiency when it is ... more efficient.</span>
<span class="comment-copy">@ChrisChudzicki: While the list comprehension method <i>is</i> faster, it's not <i>that</i> much faster: You slowed down the original code considerably by adding the result list, and thus two extra lookups in the loop. (The original could be made faster by caching the <code>list.append</code> lookups, but the comprehensions would still be 20-30% faster) As for the <code>map(dict.values, l)</code> version, it shouldn't even be considered, since it relies on â‰¥Python3.7 for guaranteed dictionary ordering <i>and</i> all the input dictionaries having been created in the same order! Guaranteed dictionary order by default was a mistake.</span>
<span class="comment-copy">This is the easiest to read and understand (For me, anyway).</span>
<span class="comment-copy">It may be worth noting that this solution (and quite possibly every one-liner) requires 2 iterations over the entire list (it may not be obvious at a quick glance)</span>
<span class="comment-copy">@DeepSpace I think that visible to the naked eye, there are 2 for loop. :-)</span>
<span class="comment-copy">There is no list comprehension in this code though...</span>
<span class="comment-copy">That's a generator expression.</span>
<span class="comment-copy">@DeepSpace On a list with <code>5e6</code> entries, this method appears to be about twice as fast as a simple for loop.</span>
<span class="comment-copy">Nice! one-liner with a single iteration over the input list  + a constant-length iteration.</span>
<span class="comment-copy">This was about what I had in mind, but I wouldn't want to rely on the order of dict items.</span>
<span class="comment-copy">@oarfish From Python 3.7 dictionaries are ordered, so you shouldn't really have a problem.</span>
<span class="comment-copy"><code>map</code> tends to be <a href="https://www.python.org/dev/peps/pep-0279/" rel="nofollow noreferrer">considered</a> <a href="https://stackoverflow.com/a/10973817">un-pythonic</a>, which is what was asked for in the title.</span>
<span class="comment-copy">In addition to requiring at least Python 3.7, this requires one to make sure that all the dictionaries in the input list have been created in the correct order; in other words, this is extremely fragile code. (Guaranteed ordering of dictionaries by default was a mistake) In addition, this is slower than both the original code and dual list comprehensions.</span>
<span class="comment-copy">I had no idea <code>itemgetter</code> could fetch multiple values at once. Excellent answer! Assuming that the list of fields is not needed later, wouldn't <code>map(itemgetter('name', 'values'), L))</code> work just as well?</span>
<span class="comment-copy">@jpmc26, Yep, of course <code>itemgetter('names', 'values')</code> works just as well, <code>*</code> operator just unpacks. I just felt separating in 2 lines aids readability here.</span>
<span class="comment-copy">This would actually be the best tool for the job I think.</span>
<span class="comment-copy">Nice. This can be a little bit more memory friendly: <code>list(zip(*(i.values() for i in l)))</code></span>
<span class="comment-copy">It seems that this does basically the same as @Kevin's solution with a listcomp instead of a map, correct?</span>
<span class="comment-copy">@DeepSpace Great point, I had the comprehension wrapped as a <code>list</code> before and it returned the <code>dict_view</code> so I forced it into a tuple.  Nice catch! @oarfish, I just saw the other answer after I posted :( testing takes time.  I do concede a <code>zip/map</code> combo is more compact.</span>
<span class="comment-copy">@oarfish In response to your comment for Kevin's answer, I've updated my answer to include a variant where you can define an explicit order without relying on the dictionary's order (to make up for the fact that our answers are so similar).</span>
<span class="comment-copy">The single dict answer works only if dictionaries have a deterministic order of iteration, doesn't it?</span>
<span class="comment-copy">@oarfish: Hello! Thanks for the comment. The dict order will be the same as the original data in <a href="https://stackoverflow.com/a/39980744/6419007">Python 3.6 or higher</a>. In older Python version, the returned objects might not have the same order as the original dict but <code>keys</code> and <code>values</code> will have the corresponding elements in the same order.</span>
<span class="comment-copy">Ok interesting, but I fail to see how this is more pythonic, efficient, or concise.</span>
<span class="comment-copy">It doesn't look pythonic to me.</span>
