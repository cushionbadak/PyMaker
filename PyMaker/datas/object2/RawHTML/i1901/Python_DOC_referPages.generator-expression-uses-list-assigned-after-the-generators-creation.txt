<div class="post-text" itemprop="text">
<p>I found this example and I can't understand why it works unpredictably?
I supposed it must output <code>[1, 8, 15]</code> or <code>[2, 8, 22]</code>.</p>
<pre><code>array = [1, 8, 15]
g = (x for x in array if array.count(x) &gt; 0)
array = [2, 8, 22]
print(list(g))


&gt;&gt;&gt;[8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason is that, at creation time, the generator <code>(a for b in c if d)</code> only evaluates <code>c</code> (which <em>sometimes</em> makes <code>b</code> predictable as well). But <code>a</code>, <code>b</code>, <code>d</code> are evaluated at consumption time (at each iteration). Here, it uses the <em>current</em> binding of <code>array</code> from the enclosing scope when evaluating <code>d</code> (<code>array.count(x) &gt; 0</code>).</p>
<p>You can for instance do:</p>
<pre><code>g = (x for x in [] if a)
</code></pre>
<p>Without having declared <code>a</code> in advance. But, you have to make sure <code>a</code> exists when the generator is consumed.</p>
<p>But you cannot do similarly:</p>
<pre><code>g = (x for x in a if True)
</code></pre>
<p>Upon request:</p>
<p>You can observe similar (however not identical) patterns with a common generator function:</p>
<pre><code>def yielder():
    for x in array:
        if array.count(x) &gt; 0:
            yield x

array = [1, 8, 15]
y = yielder()
array = [2, 8, 22]
list(y)
# [2, 8, 22]
</code></pre>
<p>The generator function does not execute any of its body ahead of consumption. Hence, even the <code>array</code> in the for-loop header is bound late. An even more disturbing example occurs where we "switch out" <code>array</code> during iteration:</p>
<pre><code>array = [1, 8, 15]
y = yielder()
next(y)
# 1
array = [3, 7]
next(y)  # still iterating [1, 8, 15], but evaluating condition on [3, 7]
# StopIteration raised
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the docs on <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">Generator expressions</a>:</p>
<blockquote>
<p>Variables used in the generator expression are <strong>evaluated lazily</strong> when
  the <a href="https://docs.python.org/3/reference/expressions.html#generator.__next__" rel="nofollow noreferrer"><code>__next__()</code></a> method is called for the generator object (in the same
  fashion as normal generators). However, the iterable expression in the
  leftmost <a href="https://docs.python.org/3/reference/compound_stmts.html#for" rel="nofollow noreferrer"><code>for</code></a> clause is <strong>immediately evaluated</strong>, so that an error
  produced by it will be emitted at the point where the generator
  expression is defined, rather than at the point where the first value
  is retrieved.</p>
</blockquote>
<p>So when you run</p>
<pre><code>array = [1, 8, 15]
g = (x for x in array if array.count(x) &gt; 0)
</code></pre>
<p>only the first <code>array</code> in the generator expression is evaluated. <code>x</code> and <code>array.count(x)</code> will only be evaluated when you call <code>next(g)</code>. Since you make <code>array</code> point to another list <code>[2, 8, 22]</code> <em>before</em> consuming the generator you get the 'unexpected' result.</p>
<pre><code>array = [2, 8, 22]
print(list(g))  # [8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>when you first create the array and assign the elements in it, elements of the array points to some memory location and generator keeps that location (not the array's) for its execution.</p>
<p>but when you modify its elements of the array it gets changed but as '8' is common for both of them python does not reassign it and points to the same element after modification.</p>
<p>Look the below example for better understanding</p>
<pre><code>array = [1, 8, 15]
for i in array:
    print(id(i))

g = (x for x in array if array.count(x) &gt; 0)

print('&lt;======&gt;')

array = [2, 8, 22]
for i in array:
    print(id(i))

print(array)
print(list(g))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>140208067495680
140208067495904
140208067496128
&lt;======&gt;
140208067495712
140208067495904 # memory location is still same
140208067496352
[2, 8, 22]
[8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually, it is not really crazy if you look more carefully.
look at </p>
<pre><code>g = (x for x in array if array.count(x) &gt; 0)
</code></pre>
<p>it will create a generator that looks through the array and will search if the count of already existing values is more than zero. so your generator only looks for <code>1</code>, <code>8</code> and <code>15</code>, and when you change the values to another, the generator just looks for the previous values again not new ones. because it(generator) creates when array had them.</p>
<p>so if you put thousands of values in the array it only looks for those three only.</p>
</div>
<div class="post-text" itemprop="text">
<p>The confusion, and so is the answer, lies in the line:<code>g = (x for x in array if array.count(x) &gt; 0)</code><br/>
If we simplify this line then it will become: <code>g = (x for x in array1 if array2.count(x) &gt; 0)</code></p>
<p>Now, when <em>generator</em> is created then it keeps the reference of <code>array1</code> object. So even if I will change the value of <code>array1</code> to any other value (i.e. set it to a new array object), it will not affect the <em>generator</em>'s copy of <code>array1</code>. Because only <code>array1</code> is changing it's object reference. But <code>array2</code> is checked dynamically. So if we change its value it will be reflected.</p>
<p>You can see outputy from following code to understand it batter. See it <a href="https://ideone.com/rtZ8OC" rel="nofollow noreferrer">working online here</a>: </p>
<pre><code>array1 = [1, 8, 15] #Set value of `array1`
array2 = [2, 3, 4, 5, 8] #Set value of `array2`
print("Old `array1` object ID: " + repr(id(array1)))
print("Old `array2` object ID: " + repr(id(array2)))
g = (x for x in array1 if array2.count(x) &gt; 0)
array1 = [0, 9] #Changed value of `array1`
array2 = [2, 8, 22, 1] #Changed value of `array2`
print("New `array1` object ID: " + repr(id(array1)))
print("New `array2` object ID: " + repr(id(array2)))
print(list(g))
</code></pre>
<p><strong>Output:</strong> </p>
<pre><code>Old `array1` object ID: 47770072262024
Old `array2` object ID: 47770072263816
New `array1` object ID: 47770072263944
New `array2` object ID: 47770072264008
[1, 8]
</code></pre>
</div>
<span class="comment-copy">aside: <code>if array.count(x) &gt; 0</code> =&gt; <code>x in array</code> is smarter &amp; faster :)</span>
<span class="comment-copy">Can you explain why the generator <i>expression</i> seems to behave differently to the generator <i>function</i> <code>def yielder(): \ for x in array: \ if array.count(x) &gt; 0: \ yield x</code>. Using <code>list(yielder)</code> exhausts so you get <code>[1, 8, 15]</code>, while <code>list(g)</code> only gives <code>[8]</code>.</span>
<span class="comment-copy">@jpp You cannot call <code>list</code> on a function object. But nitpicking aside =) I added some explanation to that end.</span>
<span class="comment-copy">Thank you, very helpful. Of course <code>list(yielder())</code> is what I meant :)</span>
<span class="comment-copy">"And since a generator does not open its own namespace" - yes it does. That's why the loop variables don't leak into the outer scope. What it doesn't do is eagerly copy the bindings from the namespace where it was created; it looks up closure variables upon use.</span>
<span class="comment-copy">@user2357112 Thx for commenting. I updated that section. According to most of the documentation I found on closures in Python, I am not sure if the generator expression really contains closures in the tight sense as there is no nested function.</span>
<span class="comment-copy">It is not clear to me whether this answer says that the condition or the <code>array</code> is instantly evaluated</span>
<span class="comment-copy">The way you're using the word "copy" here is pretty misleading. The generator expression doesn't copy anything. It simply holds a reference to the original value of <code>array</code>.</span>
