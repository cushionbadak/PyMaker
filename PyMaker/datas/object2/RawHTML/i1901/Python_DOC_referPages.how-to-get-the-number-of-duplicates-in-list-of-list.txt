<div class="post-text" itemprop="text">
<pre><code>a=[[2, 5, 21,],
  [2, 9, 14,],
  [2, 22, 32],
  [3, 10, 13],
  [3, 10, 13]
  [3, 10, 13]]

for i in range(len(a)):
  cnt=1                  #count
for j in range(i, len(a)):

    if (i==j):
        continue
    elif (len(set(a[i])&amp;set(a[j]))==6):
        cnt+=1
        print('\t{:2} {:2} {:2} {:2} {:2} {:2}, number {:2} '.format(*a[i],cnt))
    else:
        pass
</code></pre>
<p>The code i want to create is below</p>
<blockquote>
<p>[3, 10, 13], num 3</p>
</blockquote>
<p>How to count the list of list?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a> for it if you convert the inner list into tuples (<code>list</code>s are not hashable - <code>dict</code>s need hashable keys - f.e <code>tuples</code>):</p>
<pre><code>from collections import Counter

a=[[2, 5, 21,],
  [2, 9, 14,],
  [2, 22, 32],
  [3, 10, 13],
  [3, 10, 13],
  [3, 10, 13]]

c = Counter( map(tuple,a) )   # shorter notation for: ( tuple(item) for item in a) )

# extract all (key,value) tuples with values &gt; 1
for what, how_much in  (x for x in c.most_common() if x[1] &gt; 1):  

    # 3.6 string interpol, use  "{} num {}".format(list(what),how_much) else
    print(f"{list(what)} num {how_much}") 
</code></pre>
<p>Output:</p>
<pre><code>[3, 10, 13] num 3
</code></pre>
<hr/>
<p>You could also use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby()</a> but you would have to sort the list first:</p>
<pre><code>import itertools
# to make groupby work
a.sort()

for key,items in itertools.groupby(a):
    how_much = len(list(items))
    if how_much &gt; 1:
        print(key, "num", how_much) 
</code></pre>
<p>Same result. The itertools usage was loosly inspired by <a href="https://stackoverflow.com/a/2213973/7505395">this answer</a> to "how to remove dupes from list of list" when looking for dupes to this OP)</p>
</div>
<span class="comment-copy">with  <code>itertools</code>  subsequent sorting really looks good..</span>
<span class="comment-copy">@pygo ty. For big lists the Counter - approach might be faster though - depends on if sort() and groupby() takes longer in total then creating the intermerdiate tuples needed as keys for Counter - both are valid approaches.</span>
<span class="comment-copy">@ Patrick, well said, i reproduced with itertool but i saw you already given that with 2 distinct approaches which looks nice, my +1.</span>
<span class="comment-copy"><code>Counter(map(tuple, a))</code> also works. You can also use a generator expression: <code>(x for x in c.most_common() if x[1] &gt; 1)</code>.</span>
<span class="comment-copy">@PatrickArtner, No, I don't think so. The generator expression is <i>lazy</i>, so a full list or tuple of values is never produced at any point. Only when you feed the gen expr to <code>list</code> or <code>tuple</code> etc does it get <i>exhausted</i> in one go.</span>
