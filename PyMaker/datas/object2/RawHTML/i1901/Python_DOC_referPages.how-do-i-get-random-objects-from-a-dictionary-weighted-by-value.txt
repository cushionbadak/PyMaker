<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3679694/a-weighted-version-of-random-choice">A weighted version of random.choice</a>
<span class="question-originals-answer-count">
                    20 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/10803135/weighted-choice-short-and-simple">Weighted choice short and simple [duplicate]</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>I have a large dictionary. The keys are objects and the values are how often the given object appears in my data.</p>
<p>I would like to randomly choose an object from the dictionary but have the choice be weighted towards objects with higher corresponding values.</p>
<p>So far, I have been able to achieve this by adding x number of objects to a list where x is the corresponding value in the dictionary. Then I call <code>random.choice()</code> on this list. Like so:</p>
<pre><code>import random

myDict = { 'foo' : 10,
           'boo' : 5,
           'moo' : 3,
           'roo' : 2,
           'goo' : 1,
           'oo' : 0}

selection = []
for obj in myDict.keys():
    for n in range(myDict[obj]):
        selection.append(obj)
</code></pre>
<p>To make sure that this is working I've run <code>random.choice()</code> on the list 10000 times and saved the results. Here are 4 of the results I've gotten.</p>
<pre><code>{'foo': 4841, 'boo': 2397, 'moo': 1391, 'roo': 907, 'goo': 464, 'oo': 0}
{'foo': 4771, 'boo': 2410, 'moo': 1435, 'roo': 917, 'goo': 467, 'oo': 0}
{'foo': 4815, 'boo': 2340, 'moo': 1431, 'roo': 953, 'goo': 461, 'oo': 0}
{'foo': 4718, 'boo': 2443, 'moo': 1404, 'roo': 947, 'goo': 488, 'oo': 0}
</code></pre>
<p>As you can see, the distribution fits the frequency described in the dictionary.</p>
<p>My problem is that in my production code I have thousands of dictionaries each containing thousands of objects. The dictionaries are of variable length. My current method is very inefficient and slow. Is there a better way? I don't mind using a different structure to store the data as it comes in.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>numpy</code> provides an optional probability parameter that should work for your problem:</p>
<pre><code>In [14]: s = sum(myDict.values())

In [15]: d2 = {k: v/float(s) for k, v in myDict.items()}

In [16]: res = np.random.choice(list(d2.keys()), 10000, p=list(d2.values()))

In [17]: from collections import Counter

In [18]: Counter(res)
Out[18]: Counter({'foo': 4723, 'moo': 1426, 'boo': 2411, 'roo': 945, 'goo': 495})
</code></pre>
</div>
<span class="comment-copy">Does this help: <a href="https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value" title="how do i sort a dictionary by value">stackoverflow.com/questions/613183/â€¦</a>?</span>
<span class="comment-copy">This is a dupe. Essentially you want to use <code>random.choices( your_keys, ..) </code> and provide weights to it: see <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer">random.choices(population, weights=None, *, cum_weights=None, k=1)</a> - the population are your keys and the weights are taken from your values....</span>
