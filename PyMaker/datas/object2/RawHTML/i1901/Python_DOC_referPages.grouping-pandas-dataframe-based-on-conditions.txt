<div class="post-text" itemprop="text">
<p>I am following the suggestions here <a href="https://stackoverflow.com/questions/26886653/pandas-create-new-column-based-on-values-from-other-columns">pandas create new column based on values from other columns</a> but still getting an error. Basically, my Pandas dataframe has many columns and I want to group the dataframe based on a new categorical column whose value depends on two existing columns (AMP, Time). </p>
<pre><code>df
df['Time'] = pd.to_datetime(df['Time']) 
#making sure Time column read from the csv file is time object

import datetime as dt
day_1 = dt.date.today()
day_2 = dt.date.today() - dt.timedelta(days = 1)

def f(row):

    if (row['AMP'] &gt; 100) &amp; (row['Time'] &gt; day_1):
        val = 'new_positives'

    elif (row['AMP'] &gt; 100) &amp; (day_2 &lt;= row['Time'] &lt;= day_1):
        val = 'rec_positives'

    elif (row['AMP'] &gt; 100 &amp; row['Time'] &lt; day_2):
        val = 'old_positives'

    else:
        val = 'old_negatives'

    return val

df['GRP'] = df.apply(f, axis=1) #this gives the following error:
TypeError: ("Cannot compare type 'Timestamp' with type 'date'", 'occurred at index 0')

df[(df['AMP'] &gt; 100) &amp; (df['Time'] &gt; day_1)]  #this works fine

df[(df['AMP'] &gt; 100) &amp; (day_2 &lt;= df['Time'] &lt;= day_1)]  #this works fine

df[(df['AMP'] &gt; 100) &amp; (df['Time'] &lt; day_2)]  #this works fine


#df = df.groupby('GRP')  
</code></pre>
<p>I am able to select the proper sub-dataframes based on the conditions specified above, but when I apply the above function on each row, I get the error. What is the correct approach to group the dataframe based on the conditions listed?</p>
<p>EDIT:</p>
<p>Unforunately, I cannot provide a sample of my dataframe. However, here is simple dataframe that gives an error of the same type:</p>
<pre><code>import numpy as np
import pandas as pd
mydf = pd.DataFrame({'a':np.arange(10),
   'b':np.random.rand(10)})

def f1(row):
    if row['a'] &lt; 5 &amp; row['b'] &lt; 0.5:
        value = 'less'
    elif row['a'] &lt; 5 &amp; row['b'] &gt; 0.5:
        value = 'more'
    else:
        value = 'same'
    return value

mydf['GRP'] = mydf.apply(f1, axis=1)

ypeError: ("unsupported operand type(s) for &amp;: 'int' and 'float'", 'occurred at index 0')
</code></pre>
<p>EDIT 2:
As suggested below, enclosing the comparison operator with parentheses did the trick for the cooked up example. This problem is solved.</p>
<p>However, I am still getting the same error in my my real example. By the way, if I were to use the column 'AMP' with perhaps another column in my table, then everything works and I am able to create df['GRP'] by applying the function f to each row. This shows the problem is related to using df['Time']. But then why am I able to select df[(df['AMP'] &gt; 100) &amp; (df['Time'] &gt; day_1)]? Why would this work in this context, but not when the condition appears in a function?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Based on your error message and example, there are two things to fix. One is to adjust parentheses for operator precedence in your final <code>elif</code> statement. The other is to avoid mixing <code>datetime.date</code> and <code>Timestamp</code> objects.</p>
<p><strong>Fix 1:</strong> change this:</p>
<pre><code>elif (row['AMP'] &gt; 100 &amp; row['Time'] &lt; day_2):
</code></pre>
<p>to this:</p>
<pre><code>elif (row['AMP'] &gt; 100) &amp; (row['Time'] &lt; day_2):
</code></pre>
<p>These two lines are different because the bitwise <code>&amp;</code> operator takes precedence over the <code>&lt;</code> and <code>&gt;</code> comparison operators, so python attempts to evaluate <code>100 &amp; row['Time']</code>. A full list of Python operator precedence is here: <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">https://docs.python.org/3/reference/expressions.html#operator-precedence</a></p>
<p><strong>Fix 2:</strong> Change these 3 lines:</p>
<pre><code>import datetime as dt
day_1 = dt.date.today()
day_2 = dt.date.today() - dt.timedelta(days = 1)
</code></pre>
<p>to these 2 lines:</p>
<pre><code>day1 = pd.to_datetime('today')
day_2 = day_1 - pd.DateOffset(days=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some parentheses need to be added in the if-statements:</p>
<pre><code>import numpy as np
import pandas as pd

mydf = pd.DataFrame({'a':np.arange(10),
   'b':np.random.rand(10)})

def f1(row):
    if (row['a'] &lt; 5) &amp; (row['b'] &lt; 0.5):
        value = 'less'
    elif (row['a'] &lt; 5) &amp; (row['b'] &gt; 0.5):
        value = 'more'
    else:
        value = 'same'
    return value

mydf['GRP'] = mydf.apply(f1, axis=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't need to use a custom function, then you can use multiple masks (<a href="https://stackoverflow.com/a/24330483/4057186">somewhat similar to this SO post</a>)</p>
<p>For the <code>Time column</code>, I used this code. It may be that you were trying to compare <code>Time</code> column values that did not have the required <code>dtype</code> (??? this is my guess)</p>
<pre><code>import datetime as dt
mydf['Time'] = pd.date_range(start='10/14/2018', end=dt.date.today())
day_1 = pd.to_datetime(dt.date.today())
day_2 = day_1 - pd.DateOffset(days = 1)
</code></pre>
<p>Here is the raw data</p>
<pre><code>mydf

   a         b       Time
0  0  0.550149 2018-10-14
1  1  0.889209 2018-10-15
2  2  0.845740 2018-10-16
3  3  0.340310 2018-10-17
4  4  0.613575 2018-10-18
5  5  0.229802 2018-10-19
6  6  0.013724 2018-10-20
7  7  0.810413 2018-10-21
8  8  0.897373 2018-10-22
9  9  0.175050 2018-10-23
</code></pre>
<p>One approach involves using masks for columns</p>
<pre><code># Append new column
mydf['GRP'] = 'same'
# Use masks to change values in new column
mydf.loc[(mydf['a'] &lt; 5) &amp; (mydf['b'] &lt; 0.5) &amp; (mydf['Time'] &lt; day_2), 'GRP'] = 'less'
mydf.loc[(mydf['a'] &lt; 5) &amp; (mydf['b'] &gt; 0.5) &amp; (mydf['Time'] &gt; day_1), 'GRP'] = 'more'
mydf

   a         b       Time   GRP
0  0  0.550149 2018-10-14  same
1  1  0.889209 2018-10-15  same
2  2  0.845740 2018-10-16  same
3  3  0.340310 2018-10-17  less
4  4  0.613575 2018-10-18  same
5  5  0.229802 2018-10-19  same
6  6  0.013724 2018-10-20  same
7  7  0.810413 2018-10-21  same
8  8  0.897373 2018-10-22  same
9  9  0.175050 2018-10-23  same
</code></pre>
<p>Another approach is to set <code>a</code>, <code>b</code> and <code>Time</code> as a multi-index and use <a href="https://stackoverflow.com/a/36607669/4057186">index-based masks to set values</a></p>
<pre><code>mydf.set_index(['a','b','Time'], inplace=True)

# Get Index level values
a = mydf.index.get_level_values('a')
b = mydf.index.get_level_values('b')
t = mydf.index.get_level_values('Time')

# Apply index-based masks
mydf['GRP'] = 'same'
mydf.loc[(a &lt; 5) &amp; (b &lt; 0.5) &amp; (t &lt; day_2), 'GRP'] = 'less'
mydf.loc[(a &lt; 5) &amp; (b &gt; 0.5) &amp; (t &gt; day_1), 'GRP'] = 'more'
mydf.reset_index(drop=False, inplace=True)
mydf

   a         b       Time   GRP
0  0  0.550149 2018-10-14  same
1  1  0.889209 2018-10-15  same
2  2  0.845740 2018-10-16  same
3  3  0.340310 2018-10-17  less
4  4  0.613575 2018-10-18  same
5  5  0.229802 2018-10-19  same
6  6  0.013724 2018-10-20  same
7  7  0.810413 2018-10-21  same
8  8  0.897373 2018-10-22  same
9  9  0.175050 2018-10-23  same
</code></pre>
<p>Source to <a href="https://stackoverflow.com/a/22898920/4057186">filter by datetime</a> and <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.date_range.html#pandas-date-range" rel="nofollow noreferrer">create a range of dates</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a excelent example here, it is very useful and you could apply filters after groupby. It is a way without using mask.</p>
<pre><code>def get_letter_type(letter):
   if letter.lower() in 'aeiou':
       return 'vowel'
   else:
       return 'consonant'


In [6]: grouped = df.groupby(get_letter_type, axis=1)
</code></pre>
<p><a href="https://pandas.pydata.org/pandas-docs/version/0.22/groupby.html" rel="nofollow noreferrer">https://pandas.pydata.org/pandas-docs/version/0.22/groupby.html</a></p>
</div>
<span class="comment-copy">It would help if you provided a sample of your dataframe</span>
<span class="comment-copy">My actual dataframe has company confidential information and I can't share it per company policy. However, I did cook up a quick example which illustrates the same error type. Please see the EDIT.</span>
<span class="comment-copy">Thanks! For the trivial example that I shown, adding the parentheses fixed the problem. However, the same didn't work for my actual example and I get the error: TypeError: ("Cannot compare type 'Timestamp' with type 'date'", 'occurred at index 0'). I am trying to understand what this error means. What does index 0 refer to? 1st row of data in the dataframe?</span>
<span class="comment-copy">Yes, index 0 refers to the first row in whatever Series or DataFrame is causing the error. What is your pandas version? (Check in python with <code>pd.__version__</code>)</span>
<span class="comment-copy">pd.__version__ = 0.20.3 (python 3x)</span>
<span class="comment-copy">Gotcha. I realized that no matter what your version (0.23 is out by the way!), the fastest fix is this: change <code>day_1 = dt.date.today()</code> to <code>day1 = pd.to_datetime('today')</code>, and change <code>day_2 = dt.date.today() - dt.timedelta(days = 1)</code> to <code>day_2 = day_1 - pd.DateOffset(days=1)</code>. I've edited this into my answer.</span>
<span class="comment-copy">If I were to pass day_1 as an argument to the function, e.g., f(row, day_1), instead of hard coding it, how would I modify df.apply(f, axis = 1) statement? Or maybe even f(row, day_1, day_2)...</span>
<span class="comment-copy">thanks. the df with columns 'a' and 'b' work just fine (with applying the function) now with the addition of parentheses as pointed out above. it is the real example that still gives the error.</span>
<span class="comment-copy">I have edited my answer to include the <code>Time</code> column that you are referring to in the OP. Note: I had to change your definitions of <code>date_1</code> and <code>date_2</code> - I made some guesses for both of these variables.</span>
