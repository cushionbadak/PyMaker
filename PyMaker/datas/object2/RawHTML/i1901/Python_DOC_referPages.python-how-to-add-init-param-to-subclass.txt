<div class="post-text" itemprop="text">
<p>I have a subclass sharing the __ init __ of it's base class:</p>
<pre><code>class SubClass(BaseClass)
    def __init__(self, param, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.thing = param
</code></pre>
<p>The problem I have been having is the subclass __ init __ parameter "param" is being passed into the <code>super().__init__(*args, **kwargs)</code> as an extra parameter. This usually gives me an error like:</p>
<pre><code>TypeError: __init__() takes from 1 to 2 positional arguments but 3 were given
</code></pre>
<p>I don't want that. I only want "param" to be used for these subclass instances. How do stop sending the extra param to the baseclass __ init __ while still being able to use it in the subclass __ init __? Example code to reproduce the issue:</p>
<pre><code>from unittest import TestCase


class TestCaseSubClass(TestCase):

    def __init__(self, param, *args, **kwargs):
        super().__init__(*args, **kwargs)  # Just use whatever is in TestCase's init + our stuff
        self.thing = param
        print(self.thing)


class TestClass(TestCaseSubClass(param='bdfbdfb')):

        def test_stuff(self):
            print('test stuff here')
</code></pre>
<p>Or with just raw python, no import, why cant I do this? (same error)</p>
<pre><code>class A(object):
    def __init__(self, athing='thing'):
        self.thing = athing
        print(self.thing)

class AB(A):
    def __init__(self, param, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.param= param
        print(self.param)


class ABC(AB(param='thh')):
    pass

ABCinstance = ABC()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm interpreting this question as "how can I provide a default parameter to a subclass without defining an <code>__init__</code> for it?". One possible way is to define the default value as a class attribute, which you access in the parent class' <code>__init__</code>:</p>
<pre><code>from unittest import TestCase

class TestCaseSubClass(TestCase):
    _default_param = None
    def __init__(self, *args, **kwargs):
        param = kwargs.pop("param", self._default_param)
        super().__init__(*args, **kwargs)  # Just use whatever is in TestCase's init + our stuff
        self.thing = param

class TestClass(TestCaseSubClass):
    _default_param = "bdfbdfb"
    def test_stuff(self):
        print('test stuff here')

x = TestClass()
print(x.thing) #"bdfbdfb"
y = TestClass(param="foo")
print(y.thing) #"foo"
</code></pre>
<p>This approach doesn't <em>quite</em> match the argument format in your question, since now <code>param</code> is a keyword-only argument, rather than a named positional argument. The principal practical difference is that you can't supply an argument for <code>param</code> unless you refer to it by name: <code>z = TestClass("foo")</code> won't do it, for example.</p>
<hr/>
<p>Based on the edits and comments to this question, another possible interpretation may be "How can I provide a parameter to a subclass that gets passed to the parent class, by any means necessary?", which has no requirement regarding default values. If you're willing to make <code>param</code> a <em>mandatory</em> parameter, then you simply need to pass the value in when creating a TestClass instance:</p>
<pre><code>from unittest import TestCase

class TestCaseSubClass(TestCase):
    def __init__(self, param, *args, **kwargs):
        super().__init__(*args, **kwargs)  # Just use whatever is in TestCase's init + our stuff
        self.thing = param

class TestClass(TestCaseSubClass):
    def test_stuff(self):
        print('test stuff here')

x = TestClass("bdfbdfb")
print(x.thing) #"bdfbdfb"
</code></pre>
</div>
<span class="comment-copy">I don't think that code should give that error. The way you wrote it (syntax error notwithstanding) should <i>not</i> pass <code>param</code> on to the parent's <code>__init__</code>. Please provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">Maybe it's because of what I am subclassing? unittest.TestCase in this case. Here is a working example: <a href="https://onlinegdb.com/rJfgN183X" rel="nofollow noreferrer">onlinegdb.com/rJfgN183X</a></span>
<span class="comment-copy">This is how you are supposed to use TestCase: <a href="https://docs.python.org/3/library/unittest.html#basic-example" rel="nofollow noreferrer">docs.python.org/3/library/unittest.html#basic-example</a> The only thing I am doing is expanding upon TestCase with my own SubClass</span>
<span class="comment-copy">What do you expect <code>AB(param='thh')</code>, a class instance, to do inside a class definition?</span>
<span class="comment-copy">OHHHHH that's it! I thought you had to specify required AB params when I defined ABC subclass. I guess you don't have to. You send AB params when instantiating an ABC class. Make an answer that was it.</span>
