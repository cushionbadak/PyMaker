<div class="post-text" itemprop="text">
<p>I was trying to understand how to create a Singleton class in Python. Below is how i attempted</p>
<pre><code>class Singleton(object):
    _instance = None

    def __new__(class_, *args, **kwargs):
        if not isinstance(class_._instance, class_):
            class_._instance = object.__new__(class_)
        return class_._instance

class MyClass(Singleton):
    num_of_instances = 0
    def __init__(self, real = 5, imaginary = 6):
        self.real = real
        self.imaginary = imaginary
        MyClass.num_of_instances += 1

a = MyClass(10, 20)
print(a.real)
print(a.imaginary)
b = MyClass()

print(MyClass.num_of_instances)  # 2
</code></pre>
<p>Ideally <code>__new__()</code> calls <code>__init__()</code> with the object instance, but in the above case when I am trying to create second object <code>b</code>, <code>__new__</code> won't be called because an instance of <code>MyClass</code> already exits then why does the print statement printing <code>num_of_instances</code> print <code>2</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__new__</code> is called <em>for every <code>MyClass(...)</code> call</em>. If it didn't get called, it would not be able to return the singleton instance.</p>
<p>And when the <code>__new__</code> method returns an object and that object is an instance of the <code>cls</code> argument passed to <code>__new__</code> (or a subclass), then the <code>__init__</code> method is also called.</p>
<p>So, for each <code>MyClass(...)</code> call, <code>__new__</code> is called. The <code>__new__</code> method always returns an instance of the current class, so <code>__init__</code> is called, every time. It doesn't matter here that it is the same instance each time.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code> method documentation</a>:</p>
<blockquote>
<p>If <code>__new__()</code> returns an instance of <code>cls</code>, then the new instanceâ€™s <code>__init__()</code> method will be invoked like <code>__init__(self[, ...])</code>, where <code>self</code> is the new instance and the remaining arguments are the same as were passed to <code>__new__()</code>.</p>
</blockquote>
<p>You can see this happen if you add some <code>print()</code> calls in the methods:</p>
<pre><code>&gt;&gt;&gt; class Singleton(object):
...     _instance = None
...     def __new__(class_, *args, **kwargs):
...         print(f'Calling {class_!r}(*{args!r}, **{kwargs!r})')
...         if not isinstance(class_._instance, class_):
...             print(f'Creating the singleton instance for {class_!r}')
...             class_._instance = object.__new__(class_)
...         return class_._instance
...
&gt;&gt;&gt; class MyClass(Singleton):
...     num_of_instances = 0
...     def __init__(self, real=5, imaginary=6):
...         print(f'Calling {type(self)!r}.__init__(self, real={real!r}, imaginary={imaginary!r})')
...         self.real = real
...         self.imaginary = imaginary
...         MyClass.num_of_instances += 1
...
&gt;&gt;&gt; a = MyClass(10, 20)
Calling &lt;class '__main__.MyClass'&gt;(*(10, 20), **{})
Creating the singleton instance for &lt;class '__main__.MyClass'&gt;
Calling &lt;class '__main__.MyClass'&gt;.__init__(self, real=10, imaginary=20)
&gt;&gt;&gt; b = MyClass()
Calling &lt;class '__main__.MyClass'&gt;(*(), **{})
Calling &lt;class '__main__.MyClass'&gt;.__init__(self, real=5, imaginary=6)
</code></pre>
<p>You can't prevent the automatic <code>__init__</code> call, at least not without overriding something else. If you want to avoid <code>__init__</code> being called each time, you have some options:</p>
<p>You don't have to use an <code>__init__</code> method on the subclass. You could invent your own mechanism, <code>__new__</code> could look for a <code>__singleton_init__</code> method and call that:</p>
<pre><code>class Singleton(object):
    _instance = None

    def __new__(class_, *args, **kwargs):
        if not isinstance(class_._instance, class_):
            class_._instance = object.__new__(class_)
            if hasattr(class_._instance, '__singleton_init__'):
                class_._instance.__singleton_init__(*args, **kwargs)`
        return class_._instance
</code></pre>
<p>or your <code>__init__</code> method could check if there are already attributes set in <code>vars(self)</code> (or <code>self.__dict__</code>) and just not set attributes again:</p>
<pre><code>class MyClass(Singleton):
    def __init__(self, real=5, imaginary=6):
        if vars(self):
            # we already set attributes on this instance before
            return
        self.real = real
        self.imaginary = imaginary
</code></pre>
<p>The <code>__new__</code> and <code>__init__</code> logic is implemented in <code>type.__call__</code>; you could create a <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer"><em>metaclass</em></a> that overrides that logic. While you could simply call <code>__new__</code> only (and leave everything as is), it makes sense to make the metaclass responsible for handling the Singleton pattern:</p>
<pre><code>class SingletonMeta(type):
    def __new__(mcls, *args, **kwargs):
        cls = super().__new__(mcls, *args, **kwargs)
        cls._instance = None
        return cls

    def __call__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__call__(*args, **kwargs)
        return cls._instance
</code></pre>
<p>then use this not as a base class but with <code>metaclass=...</code>. You can create an empty base class if that's easier:</p>
<pre><code>class Singleton(metaclass=SingletonMeta):
    pass

class MyClass(Singleton):
    # ...
</code></pre>
<p>The above will call <code>__new__</code> on the class, optionally followed by <code>__init__</code> on the resulting instance, just <em>once</em>. The <code>SingletonMeta.__call__</code> implementation then, forever after, returns the singleton instance without further calls:</p>
<pre><code>&gt;&gt;&gt; class SingletonMeta(type):
...     def __new__(mcls, *args, **kwargs):
...         cls = super().__new__(mcls, *args, **kwargs)
...         cls._instance = None
...         return cls
...     def __call__(cls, *args, **kwargs):
...         print(f'Calling {cls!r}(*{args!r}, **{kwargs!r})')
...         if cls._instance is None:
...             cls._instance = super().__call__(*args, **kwargs)
...         return cls._instance
...
&gt;&gt;&gt; class Singleton(metaclass=SingletonMeta):
...     pass
...
&gt;&gt;&gt; class MyClass(Singleton):
...     def __init__(self, real=5, imaginary=6):
...         print(f'Calling {type(self)!r}.__init__(self, real={real!r}, imaginary={imaginary!r})')
...         self.real = real
...         self.imaginary = imaginary
...
&gt;&gt;&gt; a = MyClass(10, 20)
Calling &lt;class '__main__.MyClass'&gt;(*(10, 20), **{})
Calling &lt;class '__main__.MyClass'&gt;.__init__(self, real=10, imaginary=20)
&gt;&gt;&gt; MyClass()
Calling &lt;class '__main__.MyClass'&gt;(*(), **{})
&lt;__main__.MyClass object at 0x10bf33a58&gt;
&gt;&gt;&gt; MyClass() is a
Calling &lt;class '__main__.MyClass'&gt;(*(), **{})
True
&gt;&gt;&gt; MyClass().real
Calling &lt;class '__main__.MyClass'&gt;(*(), **{})
10
</code></pre>
</div>
<span class="comment-copy">See <a href="https://stackoverflow.com/q/6760685/1222951">here</a> for a proper Singleton implementation.</span>
<span class="comment-copy">@Martjin In this scenario how can avoid reinitialization of the object ?</span>
<span class="comment-copy">@ankit: added that to the answer.</span>
<span class="comment-copy"><i>"You can't prevent the automatic <code>__init__</code> call."</i> Umm, that's pretty misleading. You can't avoid the automatic <code>__init__</code> call <b><i>if</i></b> you implement your singleton logic in <code>__new__</code>. There are other solutions that don't have this problem with <code>__init__</code> being called.</span>
<span class="comment-copy">@Aran-Fey: you can't prevent the <code>__init__</code> call being called when <code>__new__</code> returns an object for which <code>isinstance(cls, returnvalue)</code> is true. I never made claims about different singleton approaches. <i>pretty misleading</i> is a rather harsh tone there, buddy!</span>
<span class="comment-copy">@Aran-Fey: and I've now added an alternative.</span>
