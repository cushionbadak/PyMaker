<div class="post-text" itemprop="text">
<p>I was wondering what the best (most pythonic) solution is to pass a list or a variable number of arguments to a function/method.</p>
<p>For example I have to following class:</p>
<pre><code>class Dataset():
def __init__(self, *args):
    self.data_set = args
</code></pre>
<p>and this is a part of the setter property:</p>
<pre><code>@data_set.setter
def data_set(self, args):
    data = []
    for item in args:
        if type(item) is list:
            data = [k for k in item]
            break
        data.append(item)
    self._data_set = data
</code></pre>
<p>I searched the web, but coudn't find much on the topic. 
My goal here is to design the class constructor such that it works with either a list as given parameter:</p>
<blockquote>
<p>ds1 = Dataset([4,3,5])</p>
</blockquote>
<p>or variable number or arguments:</p>
<blockquote>
<p>ds1 = Dataset(4,3,5)</p>
</blockquote>
<p>So, what is the best implementation and am I on the right track?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this,</p>
<pre><code>class Dataset():
    def __init__(self, *args):
        if isinstance(args[0], list) and len(args) == 1:
            print('Received a list')
        else:
            print('Received:', args)

obj = Dataset(1,2,3)
obj = Dataset([1,2,3], 2)
obj = Dataset([1,2,3])
</code></pre>
<p>ouputs:</p>
<pre><code>Received: (1, 2, 3)                                                       
Received: ([1, 2, 3], 2)                                                  
Received a list 
</code></pre>
<h1>Edit:</h1>
<p>This code does what you want in a simple way. Nothing more. There are other ways,
they don't look simple to me.</p>
<p>Your comment is actually an excellent question.</p>
<p>The problem is not in this code, but in what you are asking and the Python language.
You want method overloading, and Python doesn't have it.</p>
<p>Testing argument types is unpythonic because Python is a dynamic typed language.You can do it, but you are restricting your functions usefulness to a specific type.</p>
<p>Testing the argument type also results in a typical <code>if..elif</code> chain.</p>
<p>If you are writing functions take a look at <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools.singledispatch</code></a> decorator.
That eliminates the <code>if..elif</code> chain from code. Using it you can define a base function and register specific implementations for each type. Simple and readable. But this routes to the function implementation based on first argument. Now, for instance methods, this won't work because of <code>self</code>. You can <a href="https://stackoverflow.com/questions/24601722/how-can-i-use-functools-singledispatch-with-instance-methods">change that</a>, but it doesn't look simple any more.</p>
<p>Because Python doesn't support method/function overloading directly, what you asked is not a common pattern to use.</p>
<p>Now Aran Fey gives you good advice. Coding behaviour like this is uncommon in Python and actually introduces ambiguity. Your API contract becomes unclear. Should I pass a list or varargs. And why the choice? Just because you already have tuples and dicts with *args and *kwargs and want lists too? What about building the "varargs" as the list elements?</p>
<p>You ask for a list or a variable number of arguments, but a list has also a "variable number of arguments" in itself.</p>
<p>So use one or the other. If you go ahead with the initial idea, at least keep it simple like in this answer.</p>
</div>
<span class="comment-copy">I don't think this is what you want but if you put a <code>*</code> before the list you are passing (i.e: <code>ds1 = Dataset(*[4,3,5])</code> ) the list will be unpacked, and it will be the same as if you had typed: <code>ds1 = Dataset(4,3,5)</code>. Since you already are accepting *args as a parameter that's about all you have to do. If this is what you want please tell me so I can put this up as an answer for other visitors to see.</span>
<span class="comment-copy">Accept <i>either</i> a list <i>or</i> varargs. Don't do both.</span>
<span class="comment-copy">@Aran-Fey can you explain why?</span>
<span class="comment-copy">@DennisPatterson great answer, but for this particular case I think progmatico's solution answers my question best ;3</span>
<span class="comment-copy">@KamenHristov Because it introduces ambiguity. If your function is called like <code>func([1, 2])</code>, how do you know if that means <code>func(1, 2)</code> or <code>func([[1, 2]])</code>?</span>
<span class="comment-copy">Exactly what I was looking for! But I'd be very grateful if you (or someone else) could tell more about if this the most common way to accomplish this task , for example, would this be considered a good approach in a professional environment or is it unlikely?</span>
<span class="comment-copy">I edited my answer @KamenHristov, maybe good to match the requirement, but the requirement isn't a good one in Python.</span>
<span class="comment-copy">Thank you for the response, you provided just the type of information I was looking for! Definitely will look into functools.singledispatch and try to make my code as unambiguous as I can.</span>
