<div class="post-text" itemprop="text">
<p>Given string "lion" is should get the following output of substrings,
["ion", "lin", "in", "io", "li", "on", "lion"]</p>
<p>This is what i have so far,</p>
<pre><code>def Substring(n):
   sub = [n]
   if len(n) &gt; 2:
       sub.extend(Substring(n[1:]))
       sub.extend(Substring(n[:-1]))
   return list(sub)
</code></pre>
<p>my current output is ['lion', 'ion', 'on', 'io', 'lio', 'io', 'li']</p>
<p>I'm missing substrings "lin" and "in" and I shouldn't have "lio".</p>
<p>I haven't been able to figure it if I need a different method or if I need additional statements?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> on each length of a possible substring:</p>
<pre><code>from itertools import combinations

def substring_combinations(s, min_length):
    result = []

    # Check that minimum length is valid
    if not min_length:
        return result

    # For each possible length append all substring combinations
    for i in range(min_length, len(s)+1):
        for combination in combinations(s, i):
            result.append(''.join(combination))

    return result

&gt;&gt;&gt; print(substring_combinations('lion', 2))
['li', 'lo', 'ln', 'io', 'in', 'on', 'lio', 'lin', 'lon', 'ion', 'lion']
</code></pre>
<p>By the way, in your example, I think you miss some valid options.<br/>
Every output in my function is a substring of <code>lion</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a one-liner for this that doesn't require <code>itertools</code>. Depending on what you're used to, it may be more or less legible.</p>
<pre><code>tuple(s[i:i+j+1] for i in range(len(s)) for j in range(len(s)-i))
# ('l', 'li', 'lio', 'lion', 'i', 'io', 'ion', 'o', 'on', 'n')
</code></pre>
<p>Note that the <code>tuple</code> cast is only for printing; without it, Python will give you a generator, which is much more efficient if you're iterating over it.</p>
<p>For substrings of length 2 or greater:</p>
<pre><code>tuple(s[i:i+j+1] for i in range(len(s)) for j in range(1, len(s)-i))
# ('li', 'lio', 'lion', 'io', 'ion', 'on')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution that doesn't involve using any special libraries.<br/>
Basic idea:<br/>
Look at the first char of your string. A possible sub-string can either contain it or miss it.</p>
<pre><code>def get_all_substrings_recursively(s):
    if len(s) == 0:
        return ['']
    # recursive call to get all substrings of s without first char
    substrings = get_all_substrings_recursively(s[1:])
    # return all substrings with and without the first char of s
    return [(s[0] + substr) for substr in substrings] + substrings
</code></pre>
</div>
<span class="comment-copy">Why is <code>lio</code> not valid?</span>
<span class="comment-copy">Why is there no "lon" in the output? And what about "lo" and "ln"?</span>
<span class="comment-copy">lion has no substring lin or in or lon. It is not a substring it is a combination</span>
<span class="comment-copy">I wrote an answer assuming this was just "all possible substrings" without reading carefully enough... is your assignment to figure out what the actual algorithm is, or have you just not given us the full text of the assignment?</span>
<span class="comment-copy">The assignment is to write a function the takes a string argument and returns substrings. "lo" is not counted since there is no path of subwords from lion to lo.</span>
<span class="comment-copy">The test cases fail if I run the program and there are any more than the 7 substrings "ion", "lin", "in", "io", "li", "on" and "lion". Also I am supposed to implement the function recursively.</span>
