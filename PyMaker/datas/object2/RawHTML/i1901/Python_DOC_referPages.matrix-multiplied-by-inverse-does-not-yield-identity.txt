<div class="post-text" itemprop="text">
<p>I am trying to find the inverse matrix of a given matrix using the <code>np.linalg.inv()</code> function. <code>inv</code> yields a matrix which looks alright, but then when trying to multiply the original matrix by inverse the output is not the identity as supposed by the inverse matrix definition.</p>
<pre><code>from numpy.linalg import inv

M = np.random.random((4, 4))
Mi = inv(M)
I = M @ Mi # using matrix multiplication operator
I.astype(int) #as the output looks like 2.77555756e-17

&gt;&gt;&gt; array([[0, 0, 0, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 1]])
</code></pre>
<p>Which is clearly not the identity (gives a slightly different answer when running multiple times)</p>
</div>
<div class="post-text" itemprop="text">
<p>Try rounding it first before converting to int.</p>
<pre><code>np.around(I).astype(int)
</code></pre>
<p>Creating a random matrix:</p>
<pre><code>&gt;&gt;&gt; M = np.random.random((4,4))
&gt;&gt;&gt; M
array([[0.51351957, 0.57864882, 0.0489495 , 0.85066216],
       [0.60052988, 0.93844708, 0.74651889, 0.17237584],
       [0.26191596, 0.46451226, 0.46514401, 0.81917544],
       [0.19247662, 0.82801899, 0.83839146, 0.08531949]])
</code></pre>
<p>Taking inverse:</p>
<pre><code>&gt;&gt;&gt; from numpy.linalg import inv
&gt;&gt;&gt; Mi = inv(M)
&gt;&gt;&gt; Mi
array([[-1.3515514 ,  3.53647196,  1.0391335 , -3.64654487],
       [ 2.76188122, -2.23981308, -2.74634579,  3.35680468],
       [-2.44320291,  1.47102487,  2.36135635, -1.28451339],
       [ 0.2533113 , -0.69591469,  1.10498293, -0.00818495]])
</code></pre>
<p>Now, multiplying <code>M</code> and <code>Mi</code> should produce identity.</p>
<pre><code>&gt;&gt;&gt; M @ Mi
array([[ 1.00000000e+00, -4.44089210e-16, -1.11022302e-16, -6.93889390e-18],
       [-4.16333634e-17,  1.00000000e+00, -8.32667268e-17, -8.60856525e-17],
       [ 5.55111512e-17, -2.22044605e-16,  1.00000000e+00, -1.57859836e-16],
       [ 6.24500451e-17, -8.32667268e-17, -2.35922393e-16, 1.00000000e+00]])
</code></pre>
<p>But this is clearly not identity. But if you look closely, the diagonal values are pretty close to 1, and all other values are really small numbers (almost zeros), like <code>-16</code> or <code>-17</code> in the exponent.</p>
<p>This error is, because float values are never the exact values, they always have some error in them. Have a look at the article <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">15. Floating Point Arithmetic: Issues and Limitations</a> and <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>.</p>
<p>Now, if we just convert it to int, the chances are, that it will still not be an identity. Because a value which is really close to 1, it can actually be a little smaller than 1, resulting in 0 when casted to <code>int</code>.</p>
<pre><code>&gt;&gt;&gt; (M @ Mi).astype(int)
array([[1, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 1, 0],
       [0, 0, 0, 0]])
</code></pre>
<p>But if you round it first before converting to <code>int</code>, you'll get an identity.</p>
<pre><code>&gt;&gt;&gt; np.around(M @ Mi).astype(int)
array([[1, 0, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 1, 0],
       [0, 0, 0, 1]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you print out <code>I</code>, it looks like this:</p>
<pre><code>array([[ 1.00000000e+00, -5.55111512e-17, -1.66533454e-16, 0.00000000e+00],
       [ 6.38378239e-16,  1.00000000e+00, -5.55111512e-17, 0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00, 0.00000000e+00],
       [-5.55111512e-17, -1.11022302e-16, -1.24900090e-16, 1.00000000e+00]])
</code></pre>
<p>However, the <code>1.00</code> entries are not exact. When you print <code>1 - I</code>, you can see this:</p>
<pre><code>array([[-2.22044605e-16,  1.00000000e+00,  1.00000000e+00, 1.00000000e+00],
       [ 1.00000000e+00,  2.22044605e-16,  1.00000000e+00, 1.00000000e+00],
       [ 1.00000000e+00,  1.00000000e+00,  0.00000000e+00, 1.00000000e+00],
       [ 1.00000000e+00,  1.00000000e+00,  1.00000000e+00, 0.00000000e+00]])
</code></pre>
<p>The positive diagonal entries represent values in <code>I</code> that are slightly less than one. When you do integer truncation (which is what <code>astype(int)</code> does), you will set those elements to zero. Instead, <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.around.html" rel="nofollow noreferrer">round</a> the values to the nearest integer instead of truncating:</p>
<pre><code>np.around(I).astype(int)
</code></pre>
<p>However, you will not always have integer inputs like this, in which case rounding will be misleading. Numpy provides the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html" rel="nofollow noreferrer"><code>allclose</code></a> funcion for comparing values within a tolerance:</p>
<pre><code>np.allclose(I, np.identity(I.shape[0]), rtol=0, atol=1e-15)
</code></pre>
<p>You can also do an element-wise check using <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.isclose.html" rel="nofollow noreferrer"><code>isclose</code></a>:</p>
<pre><code>np.isclose(I, np.identity(I.shape[0]), rtol=0, atol=1e-15)
</code></pre>
<p>I set the relative tolerance to zero since it is multiplied by the elements of the second matrix, making it useless in this situation.</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue is that the <code>astype</code> function does not round, it simply truncates. So, the reason you do not see the identity matrix is that the other values that should be <code>1</code> were somewhere around <code>0.99999</code>. You can use this:</p>
<pre><code>import numpy as np
a = np.random.random((4,4))
b = np.linalg.inv(a)
# 0.00001 is the tolerance about which you which to consider values to be == 1
c = np.array(a@b + 0.00001, dtype=int)
print(c)
</code></pre>
<p>If you want to simply round (high tolerance == 0.5) use this instead:</p>
<pre><code>import numpy as np
a = np.random.random((4,4))
b = np.linalg.inv(a)
c = np.array(np.round(a@b), dtype=int)
print(c)
</code></pre>
<p>Additionally, it is likely best practice to use the full <code>np.linalg.inv</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>The question is, is the matrix close to <code>np.eye(4)</code> or not.</p>
<p>This is how you should check:</p>
<pre><code>I = M@Mi
EPS = 1e-8
r = np.all(np.abs(I - np.eye(4)) &lt; EPS)
</code></pre>
<p><code>r</code> will indicate if the two matrices (<code>I</code> and the identity) are close up to 1e-8.</p>
</div>
<div class="post-text" itemprop="text">
<p>What is your goal here?</p>
<p>It seems like you just want to know how to get the identity matrix and compare if the results of your matrix multiplication are close to it.</p>
<p>If so, this is what you should do:</p>
<pre><code>import numpy as np

matrix1 = np.random.random((4,4))
matrix1_inv = np.linalg.inv(matrix1)

# get what may be identity matrix
ident_pred = matrix1 @ matrix1_inv

# get what is the identity matrix
ident_true = np.identity(matrix1.shape[0])

# check that they are the same
print(np.allclose(ident_pred, ident_true))
</code></pre>
</div>
<span class="comment-copy">Integer truncation works like that. Did you try rounding?</span>
<span class="comment-copy">Why the downvote?  Please comment, downvoter!</span>
<span class="comment-copy">This would still hide differences that are up to 50%.</span>
<span class="comment-copy">Yes, that was bugging me, so I'm adding in a paragraph for that.</span>
<span class="comment-copy">I think the <code>astype(int)</code> was just added to view the matrix.  The real usecase probably doesn't involve converting to <code>int</code>.</span>
<span class="comment-copy">@MatthieuBrucher. I've completed my edits. Thanks for being patient.</span>
<span class="comment-copy">No worries, nice solution.</span>
<span class="comment-copy">It's not the best solution, as a result that is 50% off would consider the result as good when it's not.</span>
<span class="comment-copy">I have updated it -- the first solution includes a tolerance threshold</span>
<span class="comment-copy">This is still far from correct and doesn't properly check that the result is close to the identity matrix. The proper way to do it is @MadPhysicist answer.</span>
<span class="comment-copy">"correct" is subjective -- and my solution is significantly more readable than the @MadPhysicist answer, which also matters.</span>
<span class="comment-copy">the author wanted to know how to get the identity, not check if it was the identity -- that is a different question</span>
<span class="comment-copy">Your epsilon should be much smaller than that. +1 for being the first to post a reasonable comparison method.</span>
<span class="comment-copy">Indeed, I just gave 1e-8 for reference, I would use the epsilon for a double or a small increment over it.</span>
<span class="comment-copy">This is a rehash of the answer I posted three hours ago.</span>
