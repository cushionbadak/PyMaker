<div class="post-text" itemprop="text">
<p>I'm trying to make a staticmethod, object-creation factory method for a bunch of classes via meta programming. Here's what I've tried so far:</p>
<pre><code>class PlayMeta(type):
    def __new__(cls, clsname, bases, dct):
        newclass = super(PlayMeta, cls).__new__(cls, clsname, bases, dct)

        @staticmethod
        def make():
            print('meta make')

        setattr(newclass, make.__name__, make)

        return newclass

class Fritz(PlayMeta):
    pass

Fritz.make()
</code></pre>
<p>but when I run it I get: </p>
<pre><code>AttributeError: type object 'Fritz' has no attribute 'make'
</code></pre>
<p>How do you do this? I have messages with a lot of fields and I want this to be a class that will create and generate different of these messages. This question is about the factory / creation part. I'm using Python 3.5. Thanks!</p>
<p>edit: 2nd, working version:</p>
<pre><code>class PlayMeta(type):
    def __new__(cls, clsname, bases, dct):
        newclass = super(PlayMeta, cls).__new__(cls, clsname, bases, dct)

        def instance_method(self, x, y, z):
            print('instance method', x, y, z)
        setattr(newclass, instance_method.__name__, instance_method)

        def static_make(x, y, z):
            print('static make', x, y, z)
        setattr(newclass, static_make.__name__, static_make)

        return newclass

class Fritz(metaclass=PlayMeta):
    pass

Fritz.static_make('a', [], 3)

f = Fritz()
f.instance_method('a', [], 3)
</code></pre>
<p>Successfully prints:</p>
<pre><code>static make a [] 3
instance method a [] 3
</code></pre>
<p>How does Python distinguish an instance method from a class / static method, when they're defined and attached the same way? The presence of the word 'self'? Because that would be convenient, but a bit hokey. </p>
<p>edit2: Ah, it's probably <strong>just in how it's called</strong> - call it with an instance, and all is well with an instance-expecting method. But you could call either method, with or without an instance, and they would behave correctly or not, accordingly. </p>
<p>edit3, final form :) :</p>
<pre><code>@staticmethod
def static_make(x, y, z):
    print('static make', x, y, z)
    setattr(newclass, 'static_make', static_make)
</code></pre>
<p>I don't know what (at)staticmethod adds -- version 2, above, worked -- but this is more self-documenting at least. </p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure I entirely understand your plan. But assuming that <code>Fritz</code> is <strong>not</strong> supposed to be a metaclass itself but rather a regular class, you need to construct it like:</p>
<pre><code>class Fritz(metaclass=PlayMeta):
    pass
</code></pre>
<p>As for the difference between static and instance methods, all regular functions behave like instance methods and if called on the instance will get it as the first positional argument (regardless of how it is named). You can try in your <em>2nd example</em> to call <code>f.static_method</code> or <code>Fritz.instance_method</code>, they behave identically. To find out more have a look at <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>.</p>
<p>The <code>staticmethod</code> decorator converts the regular function to a proper static method that will work the same way even when called on the instance (i.e. it won't get the instance as the first argument). But note that when applied the resulting object doesn't have the <code>__name__</code> attribute which you will need if you will generate these methods programmatically.</p>
<p>Also, the <code>dct</code> argument to <code>__new__</code> is the set of names and values that will be used to set the attributes of the new class, so it might be a good place to put the methods you create in your metaclass. This will also enable you to decide whether you want the <code>Fritz</code> class to be able to override the attributes from the metaclass or vice versa.</p>
<p>Example (with metaclass overriding the methods if they happen to be also defined on the class):</p>
<pre><code>class PlayMeta(type):
    def __new__(cls, clsname, bases, dct):

        def instance_method(self, x, y, z):
            print('instance method', x, y, z)

        def static_make(x, y, z):
            print('static make', x, y, z)

        return super(PlayMeta, cls).__new__(cls, clsname, bases, {**dct,
            instance_method.__name__: instance_method,
            static_make.__name__: staticmethod(static_make),
        })


class Fritz(metaclass=PlayMeta):
    ...


f = Fritz()
</code></pre>
<p>...</p>
<pre><code>In [2]: f.instance_method(1, 2, 3)
instance method 1 2 3

In [3]: f.static_make(1, 2, 3)
static make 1 2 3

In [4]: Fritz.static_make(1, 2, 3)
static make 1 2 3

In [5]: Fritz.instance_method(1, 2, 3, 4)
instance method 2 3 4
</code></pre>
</div>
<span class="comment-copy">Sorry man, apparently I have enough karma to edit other people's answers, and edited your answer instead of my own. I don't know how to undo it. I will, later, if I can. Your answer worked, and I've now edited my own, as I originally intended. Thanks very much!</span>
<span class="comment-copy">The <code>staticmethod</code> decorator should be there; adding <code>make</code> like this does not automatically make it behave like a staticmethod.</span>
<span class="comment-copy">@JDonner: Yeah, that's just because you were trying to access <code>__name__</code> on a <code>staticmethod</code>. You need to either hardcode <code>"make"</code> (or <code>"static_make"</code> or whatever name you pick) or get the <code>__name__</code> from the underlying function at that point. Once you actually put the staticmethod on the class, accessing it will perform normal staticmethod descriptor access.</span>
<span class="comment-copy">I was a bit hasty in my original answer, edited with proper use of <code>staticmethod</code></span>
<span class="comment-copy">The new revision is much better.</span>
