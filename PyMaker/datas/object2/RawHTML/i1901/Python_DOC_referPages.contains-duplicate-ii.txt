<div class="post-text" itemprop="text">
<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<pre><code>Input: nums = [1,2,3,1], k = 3
Output: true
</code></pre>
<p>Example 2:</p>
<pre><code>Input: nums = [1,0,1,1], k = 1
Output: true
</code></pre>
<p>Example 3:</p>
<pre><code>Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre>
<p>Here's my code:</p>
<pre><code>class Solution(object):
def containsNearbyDuplicate(self, nums, k):
    """
    :type nums: List[int]
    :type k: int
    :rtype: bool
    """
    def helper(lnums, n):
        if len(lnums) == 0 and n == 0:
            return False
        elif len(lnums) &gt; n:
            for i in lnums[1:n]:
                if i == lnums[0]:
                    return True
            lnums.pop(0)
            return helper(lnums, n)
        else:
            return False

    return helper(nums, k)
</code></pre>
<p>Can anyone point out why I'm doing this wrong??? I know there's something wrong in the elif. But I have no idea why this doesn't work. </p>
</div>
<div class="post-text" itemprop="text">
<p>Some little tweaks to make it work:</p>
<pre><code>def helper(lnums, n):
    if len(lnums) == 0 or n == 0:  # note: or, not and
        return False
    else:   # there do NOT have to be at least n elements, why would there?
        for i in lnums[1:n+1]:  # exclusive upper slice boundary -&gt; n+1
            if i == lnums[0]:
                return True
        lnums.pop(0)
        return helper(lnums, n)
</code></pre>
<p>Or without expensive popping and recursion, using some fine utils like <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a> and <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>:</p>
<pre><code>def helper(lnums, n):
    return any(x in lnums[i+1:i+1+n] for i, x in enumerate(lnums))
</code></pre>
</div>
<span class="comment-copy">What if lnums has 2 objects, however n = 3, then lnums[1:n+1] will be out of range??? I didn't get why it works.</span>
<span class="comment-copy">There is no out of bounds with Python slices: see e.g. <a href="https://stackoverflow.com/questions/22951107/why-pythons-list-slicing-doesnt-produce-index-out-of-bound-error" title="why pythons list slicing doesnt produce index out of bound error">stackoverflow.com/questions/22951107/â€¦</a>. And still <code>nums=[1,1], k=3</code> should return <code>True</code>, so these lengths have to be considered.</span>
<span class="comment-copy">WOW! I got it! Really Appreciated!!! Thx!</span>
