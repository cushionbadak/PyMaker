<div class="post-text" itemprop="text">
<p>What does a bare asterisk in the arguments of a function do?</p>
<p>When I looked at the pickle module, I see this: (http://docs.python.org/3.3/library/pickle.html#pickle.dump)</p>
<pre><code>pickle.dump(obj, file, protocol=None, *, fix_imports=True)
</code></pre>
<p>I know about a single and double asterisks preceding arguments (for variable number of arguments), but this precedes nothing. And I'm pretty sure this has nothing to do with pickle. That's probably just an example of this happening. I only learned its name when I sent this to the interpreter:</p>
<pre><code>&gt;&gt;&gt; def func(*):
...     pass
...
  File "&lt;stdin&gt;", line 1
SyntaxError: named arguments must follow bare *
</code></pre>
<p>If it matters, I'm on python 3.3.0.</p>
</div>
<div class="post-text" itemprop="text">
<p>Bare <code>*</code> is used to force the caller to use named arguments - so you cannot define a function with <code>*</code> as an argument when you have no following keyword arguments.</p>
<p>See <a href="https://stackoverflow.com/a/14298976/180174">this answer</a> or <a href="http://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="noreferrer">Python 3 documentation</a> for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>While the original answer answers the question completely, just adding a bit of related information. The behaviour for the single asterisk derives from <a href="https://www.python.org/dev/peps/pep-3102/" rel="noreferrer"><code>PEP-3102</code></a>. Quoting the related section:</p>
<pre class="lang-none prettyprint-override"><code>The second syntactical change is to allow the argument name to
be omitted for a varargs argument. The meaning of this is to
allow for keyword-only arguments for functions that would not
otherwise take a varargs argument:

    def compare(a, b, *, key=None):
        ...
</code></pre>
<p>In simple english, it means that to pass the value for key, you will need to explicitly pass it as <code>key="value"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def func(*, a, b):
    print(a)
    print(b)

func("gg") # TypeError: func() takes 0 positional arguments but 1 was given
func(a="gg") # TypeError: func() missing 1 required keyword-only argument: 'b'
func(a="aa", b="bb", c="cc") # TypeError: func() got an unexpected keyword argument 'c'
func(a="aa", b="bb", "cc") # SyntaxError: positional argument follows keyword argument
func(a="aa", b="bb") # aa, bb
</code></pre>
<p>the above example with **kwargs</p>
<pre><code>def func(*, a, b, **kwargs):
    print(a)
    print(b)
    print(kwargs)

func(a="aa",b="bb", c="cc") # aa, bb, {'c': 'cc'}
</code></pre>
</div>
<span class="comment-copy">Note that all positional (unnamed) arguments, including <code>*args</code>, must occur before the bare <code>*</code>.</span>
<span class="comment-copy">Also note that there's sort of a counterpart, /, which marks the end of positional-only arguments (<a href="https://stackoverflow.com/questions/28243832/what-is-the-meaning-of-a-forward-slash-in-a-python-method-signature-as-show" title="what is the meaning of a forward slash in a python method signature as show">stackoverflow.com/questions/28243832/â€¦</a>).</span>
<span class="comment-copy">Oh, that makes things much clearer. So actually having an argument * is just like having an argument args*, but since you haven't named it anything, its only effect is probably to quietly gobble up all the remaining positional arguments, in order to force the remaining arguments to be keyword-only.</span>
<span class="comment-copy">@Stephen I too originally thought, the effect of bare <code>*</code> is to gobble up remaining positional arguments, but that's not the case. Passing extra positional arguments than the function expects, gives an error of this kind: <code>foo() takes exactly 1 positional argument (2 given)</code></span>
