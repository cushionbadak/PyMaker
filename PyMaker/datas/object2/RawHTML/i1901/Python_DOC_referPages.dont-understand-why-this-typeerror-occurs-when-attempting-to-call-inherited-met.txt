<div class="post-text" itemprop="text">
<p>First, I am using python 3.6.</p>
<p>I am trying <code>import</code> and use my own .py file in my project. I <code>import</code> my <code>LinkedList.py</code> file and create a <code>Mylist</code> class, which extends the imported file's class.</p>
<p>When I try the construct an instance of the <code>Mylist</code> class, which involves creating an instance of my <code>inheritedLinkedList</code> derived class, I get the following error:</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "*/PycharmProjects/Veri Yapilari/lists.py", line 65, in &lt;module&gt;
    test = Mylist()
  File "*/PycharmProjects/Veri Yapilari/lists.py", line 38, in __init__
    self.linkedlist = inheritedLinkedList()
  File "*/PycharmProjects/Veri Yapilari/lists.py", line 8, in __init__
    super.__init__()
TypeError: descriptor '__init__' of 'super' object needs an argument
</code></pre>
<p>Here's the section of the code where the problem occurs:</p>
<pre><code>test = Mylist()
test.insertFirstM(incomingDataM=4)  # &lt;- Causes a TypeError.
</code></pre>
<p>Below is the main script in its entirety:</p>
<pre><code>import LinkedList as myLinkedList


class inheritedLinkedList(myLinkedList.DoublyLinkedList):
    def __init__(self):
        super.__init__()
    def raplaceElements(self, dataToBeChanged, incomingData):
        position = self.find(dataToBeChanged)
        position.data = incomingData
    def swapElements(self, swap1, swap2):
        position1 = self.find(swap1)
        prev1 = position1.previous
        next1 = position1.next
        position2 = self.find(swap2)
        prev2 = position2.previous
        next2 = position2.next

        prev1.next = position1
        position1.previous = prev1
        position1.next = next1
        next1.previous = position1

        prev2.next = position2
        position2.previous = prev2
        position2.next = next2
        next2.previous = position2
    def insertBefore(self, incomingData, previousNode=None):
        self.insert(incomingData, self.find(previousNode).previous.data)


class Mylist:
    def __init__(self):
#        self.linkedlist = inheritedLinkedList;
        self.linkedlist = inheritedLinkedList()  # Per martineau's suggestion.

    def replaceElements(self, dataToBeChanged, incomingData):
        self.linkedlist.raplaceElements(dataToBeChanged, incomingData)

    def swapElements(self, swap1, swap2):
        self.linkedlist.swapElements(swap1, swap2)

    def insertFirstM(self, incomingDataM):
        self.linkedlist.insertFirst(incomingDataM)

    def insertLast(self, incomingData):
        self.linkedlist.insert(incomingData)

    def insertAfter(self, incomingData, incomingNode):
        self.linkedlist.insert(incomingData, incomingNode)

    def insertBefore(self, incomingData, incomingNode):
        self.linkedlist.insert(incomingData, incomingNode)

    def remove(self, incomingData):
        self.linkedlist.remove(incomingData)

    def listprint(self):
        self.linkedlist.listprint()


test = Mylist()
test.insertFirstM(4)
</code></pre>
<p>The code for the imported <code>LinkedList</code> module (<code>LinkedList.py</code>) can be obtained—if needed—by downloading it from my <a href="https://github.com/EmreKARAgh/unCompleteList" rel="nofollow noreferrer">github repository</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I said in a comment, you're not using the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super</code></a> built-in correctly. Try do things this way instead (so it's like the example in the linked documentation):</p>
<pre><code>class inheritedLinkedList(myLinkedList.DoublyLinkedList):
    def __init__(self):
        super().__init__()  # Change line to this.
</code></pre>
<p>Actually, since the derived class' <code>__init__()</code> is currently doing nothing but that, it's not even necessary because that's what would occur automatically if the subclass didn't define its own. In other words, the following would accomplish the same thing:</p>
<pre><code>class inheritedLinkedList(myLinkedList.DoublyLinkedList):
#    ** NOT REALLY NEEDED AT ALL **
#    def __init__(self):
#        super().__init__()
</code></pre>
<p>P.S. You also ought to change the very end of the <strong><code>LinkedList.py</code></strong> script so the last few lines that are there don't execute when it's <code>import</code>ed as a module by <code>lists.py</code>:</p>
<pre><code>            ...
            nextNode.previous = previousNode
            dataToBeDeleted.next = dataToBeDeleted.previous = None

if __name__ == '__main__':  # Should add this, too.

    list1 = SinglyLinkedList()
    list2 = DoublyLinkedList()

    list2.insertFirst(6)
</code></pre>
</div>
<span class="comment-copy"><code>list</code> is a python builtin. Your initialization is wrong as well. You need to use <code>super().__init__()</code> assuming you are using python &gt;= 3.6.</span>
<span class="comment-copy">It would best if you just showed the code you're running along with a copy of the error traceback (in your question, not as an image) you're getting.</span>
<span class="comment-copy">Thank You. I rename my class like "list" to "MyList" and use super.__init__() in "inheritedlinkedlist"'s __init__() method. but it didnt done yet.</span>
<span class="comment-copy">Note that "ı" is not the English pronoun "I".</span>
<span class="comment-copy">The <code>TypeError</code> you're currently getting is because of not using <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super</code></a> properly—it's a function that needs to be called. Try changing the code in the <code>inheritedLinkedList.__init__():</code> method to <code>super().__init__()</code> (assuming you're using Python 3) similar to what is shown in the documentation. Also note that the title of your question no longer matches the problem.</span>
