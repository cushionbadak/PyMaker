<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/36616739/python-how-can-i-run-eval-in-the-local-scope-of-a-function">Python: How can I run eval() in the local scope of a function</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I get the below error when I try to run this code. I'm trying to initialize a list with function pointers. It appears the eval doesn't see the functions. I'm guessing there's some kind of scoping going on that I don't understand. It works when I create the table by hand as you can see. I'm trying to avoid having to maintain a list of functions. This also worked when I made the functions global.</p>
<pre><code> Traceback (most recent call last):
   File "/home/westgate/code/python/try/x.py", line 27, in &lt;module&gt;
     main()
   File "/home/westgate/code/python/try/x.py", line 23, in main
     fxns_eval = [eval(fxn_name) for fxn_name in dir() if fxn_name.startswith('fxn_')]
   File "/home/westgate/code/python/try/x.py", line 23, in &lt;listcomp&gt;
     fxns_eval = [eval(fxn_name) for fxn_name in dir() if fxn_name.startswith('fxn_')]
   File "&lt;string&gt;", line 1, in &lt;module&gt;
 NameError: name 'fxn_bar' is not defined
</code></pre>
<hr/>
<pre><code>import inspect

def main():

    def fxn_foo():
        print('in foo '+inspect.currentframe().f_code.co_name)

    def fxn_bar():
        print('in bar '+inspect.currentframe().f_code.co_name)

    for i in dir():
        if i.startswith('fxn_'):
            print(i)

    fxn_bar()

    fxns = [ fxn_foo, fxn_bar ]

    fxns[1]()

    fxns_eval = [eval(fxn_name) for fxn_name in dir() if fxn_name.startswith('fxn_')]

    fxns_eval[1]()

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is you are not passing <code>locals</code> explicitly, so . From the <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>If both dictionaries are omitted, the expression is executed in the
  environment where eval() is called.</p>
</blockquote>
<p>However, the environment is the list comprehension, which creates it's own scope, and neither of those functions are in the list-comprehension's local namespace, nor in the global namespace. You want <em><code>main</code>'s local namespace</em> So note, this works:</p>
<pre><code>&gt;&gt;&gt; def main():
...    def foo(): 'foo'
...    print(eval('foo'))
...
&gt;&gt;&gt; main()
&lt;function main.&lt;locals&gt;.foo at 0x10c3ba6a8&gt;
</code></pre>
<p>Pass <code>globals</code> and <code>locals()</code> explicitly! <strong>But</strong> you have to use them as free variables to the list-comprehension's scope, since it is essentially like another nested function scope, you can't just do this either:</p>
<pre><code>&gt;&gt;&gt; def main():
...    def foo(): 'foo'
...    def bar(): 'bar'
...    print([eval(x, globals(), locals()) for x in dir()])
...
&gt;&gt;&gt; main()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in main
  File "&lt;stdin&gt;", line 4, in &lt;listcomp&gt;
  File "&lt;string&gt;", line 1, in &lt;module&gt;
NameError: name 'bar' is not defined
</code></pre>
<p>Indeed, that is equivalent to <em>not passing the arguments at all</em>.</p>
<p>You could do:</p>
<pre><code>&gt;&gt;&gt; def main():
...    def foo(): 'foo'
...    def bar(): 'bar'
...    locs, globs = locals(), globals()
...    print([eval(x, globs, locs) for x in dir()])
...
&gt;&gt;&gt; main()
[&lt;function main.&lt;locals&gt;.bar at 0x10bded1e0&gt;, &lt;function main.&lt;locals&gt;.foo at 0x10c3ba6a8&gt;, {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'n1': 1014.308, 'n0': 961.06, 'p1': 18.59, 'p0': 19.65, 'q1': 1014.308, 'q0': 961.06, 'main': &lt;function main at 0x10c3ba620&gt;}, {'foo': &lt;function main.&lt;locals&gt;.foo at 0x10c3ba6a8&gt;, 'bar': &lt;function main.&lt;locals&gt;.bar at 0x10bded1e0&gt;, 'globs': {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'n1': 1014.308, 'n0': 961.06, 'p1': 18.59, 'p0': 19.65, 'q1': 1014.308, 'q0': 961.06, 'main': &lt;function main at 0x10c3ba620&gt;}, 'locs': {...}}]
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">Your functions are defined within <code>main()</code> so they are local. Put them out and they will be global.</span>
<span class="comment-copy">I don't want them to be global. is there a way to make it work as nested functions?</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/a/36617153/719547">stackoverflow.com/a/36617153/719547</a></span>
<span class="comment-copy">Yes: put them in a list or a tuple and iterate through it instead of <code>dir()</code></span>
<span class="comment-copy">This is because list comprehensions essentially create a function scope, note, <code>eval('fxn_bar')</code> outside the comprehension works</span>
