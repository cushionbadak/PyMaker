<div class="post-text" itemprop="text">
<p>I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The <code>update()</code> method would be what I need, if it returned its result instead of modifying a dict in-place.</p>
<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; z = x.update(y)
&gt;&gt;&gt; print(z)
None
&gt;&gt;&gt; x
{'a': 1, 'b': 10, 'c': 11}
</code></pre>
<p>How can I get that final merged dict in <code>z</code>, not <code>x</code>?</p>
<p>(To be extra-clear, the last-one-wins conflict-handling of <code>dict.update()</code> is what I'm looking for as well.)</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>How can I merge two Python dictionaries in a single expression?</h2>
</blockquote>
<p>For dictionaries <code>x</code> and <code>y</code>, <code>z</code> becomes a shallowly merged dictionary with values from <code>y</code> replacing those from <code>x</code>.</p>
<ul>
<li><p>In Python 3.5 or greater:</p>
<pre><code>z = {**x, **y}
</code></pre></li>
<li><p>In Python 2, (or 3.4 or lower) write a function:</p>
<pre><code>def merge_two_dicts(x, y):
    z = x.copy()   # start with x's keys and values
    z.update(y)    # modifies z with y's keys and values &amp; returns None
    return z
</code></pre>
<p>and now:</p>
<pre><code>z = merge_two_dicts(x, y)
</code></pre></li>
</ul>
<h3>Explanation</h3>
<p>Say you have two dicts and you want to merge them into a new dict without altering the original dicts:</p>
<pre><code>x = {'a': 1, 'b': 2}
y = {'b': 3, 'c': 4}
</code></pre>
<p>The desired result is to get a new dictionary (<code>z</code>) with the values merged, and the second dict's values overwriting those from the first.</p>
<pre><code>&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'c': 4}
</code></pre>
<p>A new syntax for this, proposed in <a href="https://www.python.org/dev/peps/pep-0448" rel="noreferrer">PEP 448</a> and <a href="https://mail.python.org/pipermail/python-dev/2015-February/138564.html" rel="noreferrer">available as of Python 3.5</a>, is </p>
<pre><code>z = {**x, **y}
</code></pre>
<p>And it is indeed a single expression. </p>
<p>Note that we can merge in with literal notation as well:</p>
<pre><code>z = {**x, 'foo': 1, 'bar': 2, **y}
</code></pre>
<p>and now: </p>
<pre><code>&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}
</code></pre>
<p>It is now showing as implemented in the <a href="https://www.python.org/dev/peps/pep-0478/#features-for-3-5" rel="noreferrer">release schedule for 3.5, PEP 478</a>, and it has now made its way into <a href="https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations" rel="noreferrer">What's New in Python 3.5</a> document.</p>
<p>However, since many organizations are still on Python 2, you may wish to do this in a backwards compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</p>
<pre><code>z = x.copy()
z.update(y) # which returns None since it mutates z
</code></pre>
<p>In both approaches, <code>y</code> will come second and its values will replace <code>x</code>'s values, thus <code>'b'</code> will point to <code>3</code> in our final result.</p>
<h2>Not yet on Python 3.5, but want a <em>single expression</em></h2>
<p>If you are not yet on Python 3.5, or need to write backward-compatible code, and you want this in a <em>single expression</em>, the most performant while correct approach is to put it in a function:</p>
<pre><code>def merge_two_dicts(x, y):
    """Given two dicts, merge them into a new dict as a shallow copy."""
    z = x.copy()
    z.update(y)
    return z
</code></pre>
<p>and then you have a single expression:</p>
<pre><code>z = merge_two_dicts(x, y)
</code></pre>
<p>You can also make a function to merge an undefined number of dicts, from zero to a very large number:</p>
<pre><code>def merge_dicts(*dict_args):
    """
    Given any number of dicts, shallow copy and merge into a new dict,
    precedence goes to key value pairs in latter dicts.
    """
    result = {}
    for dictionary in dict_args:
        result.update(dictionary)
    return result
</code></pre>
<p>This function will work in Python 2 and 3 for all dicts. e.g. given dicts <code>a</code> to <code>g</code>:</p>
<pre><code>z = merge_dicts(a, b, c, d, e, f, g) 
</code></pre>
<p>and key value pairs in <code>g</code> will take precedence over dicts <code>a</code> to <code>f</code>, and so on.</p>
<h2>Critiques of Other Answers</h2>
<p>Don't use what you see in the formerly accepted answer:</p>
<pre><code>z = dict(x.items() + y.items())
</code></pre>
<p>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. <strong>In Python 3, this will fail</strong> because you're adding two <code>dict_items</code> objects together, not two lists - </p>
<pre><code>&gt;&gt;&gt; c = dict(a.items() + b.items())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items'
</code></pre>
<p>and you would have to explicitly create them as lists, e.g. <code>z = dict(list(x.items()) + list(y.items()))</code>. This is a waste of resources and computation power. </p>
<p>Similarly, taking the union of <code>items()</code> in Python 3 (<code>viewitems()</code> in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, <strong>since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:</strong></p>
<pre><code>&gt;&gt;&gt; c = dict(a.items() | b.items())
</code></pre>
<p>This example demonstrates what happens when values are unhashable:</p>
<pre><code>&gt;&gt;&gt; x = {'a': []}
&gt;&gt;&gt; y = {'b': []}
&gt;&gt;&gt; dict(x.items() | y.items())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<p>Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:</p>
<pre><code>&gt;&gt;&gt; x = {'a': 2}
&gt;&gt;&gt; y = {'a': 1}
&gt;&gt;&gt; dict(x.items() | y.items())
{'a': 2}
</code></pre>
<p>Another hack you should not use:</p>
<pre><code>z = dict(x, **y)
</code></pre>
<p>This uses the <code>dict</code> constructor, and is very fast and memory efficient (even slightly more-so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic. </p>
<p>Here's an example of the usage being <a href="https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff" rel="noreferrer">remediated in django</a>.</p>
<p>Dicts are intended to take hashable keys (e.g. frozensets or tuples), but <strong>this method fails in Python 3 when keys are not strings.</strong></p>
<pre><code>&gt;&gt;&gt; c = dict(a, **b)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: keyword arguments must be strings
</code></pre>
<p>From the <a href="https://mail.python.org/pipermail/python-dev/2010-April/099459.html" rel="noreferrer">mailing list</a>, Guido van Rossum, the creator of the language, wrote:</p>
<blockquote>
<p>I am fine with
  declaring dict({}, **{1:3}) illegal, since after all it is abuse of
  the ** mechanism.</p>
</blockquote>
<p>and </p>
<blockquote>
<p>Apparently dict(x, **y) is going around as "cool hack" for "call
  x.update(y) and return x". Personally I find it more despicable than
  cool.</p>
</blockquote>
<p>It is my understanding (as well as the understanding of the <a href="https://mail.python.org/pipermail/python-dev/2010-April/099485.html" rel="noreferrer">creator of the language</a>) that the intended usage for <code>dict(**y)</code> is for creating dicts for readability purposes, e.g.:</p>
<pre><code>dict(a=1, b=10, c=11)
</code></pre>
<p>instead of </p>
<pre><code>{'a': 1, 'b': 10, 'c': 11}
</code></pre>
<h2>Response to comments</h2>
<blockquote>
<p>Despite what Guido says, <code>dict(x, **y)</code> is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-comming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact ** was designed precisely to pass dicts as keywords. </p>
</blockquote>
<p>Again, it doesn't work for 3 when keys are non-strings. The implicit calling contract is that namespaces take ordinary dicts, while users must only pass keyword arguments that are strings. All other callables enforced it. <code>dict</code> broke this consistency in Python 2:</p>
<pre><code>&gt;&gt;&gt; foo(**{('a', 'b'): None})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo() keywords must be strings
&gt;&gt;&gt; dict(**{('a', 'b'): None})
{('a', 'b'): None}
</code></pre>
<p>This inconsistency was bad given other implementations of Python (Pypy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</p>
<p>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</p>
<p>More comments:</p>
<blockquote>
<p><code>dict(x.items() + y.items())</code> is still the most readable solution for Python 2. Readability counts. </p>
</blockquote>
<p>My response: <code>merge_two_dicts(x, y)</code> actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</p>
<blockquote>
<p><code>{**x, **y}</code> does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word "merging" these answers describe "updating one dict with another", and not merging.</p>
</blockquote>
<p>Yes. I must refer you back to the question, which is asking for a <em>shallow</em> merge of <strong><em>two</em></strong> dictionaries, with the first's values being overwritten by the second's - in a single expression.</p>
<p>Assuming two dictionary of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dicts from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</p>
<pre><code>from copy import deepcopy

def dict_of_dicts_merge(x, y):
    z = {}
    overlapping_keys = x.keys() &amp; y.keys()
    for key in overlapping_keys:
        z[key] = dict_of_dicts_merge(x[key], y[key])
    for key in x.keys() - overlapping_keys:
        z[key] = deepcopy(x[key])
    for key in y.keys() - overlapping_keys:
        z[key] = deepcopy(y[key])
    return z
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; x = {'a':{1:{}}, 'b': {2:{}}}
&gt;&gt;&gt; y = {'b':{10:{}}, 'c': {11:{}}}
&gt;&gt;&gt; dict_of_dicts_merge(x, y)
{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}
</code></pre>
<p>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at <a href="https://stackoverflow.com/a/24088493/541136">my answer to the canonical question on a "Dictionaries of dictionaries merge"</a>.</p>
<h2>Less Performant But Correct Ad-hocs</h2>
<p>These approaches are less performant, but they will provide correct behavior.
They will be <em>much less</em> performant than <code>copy</code> and <code>update</code> or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they <em>do</em> respect the order of precedence (latter dicts have precedence)</p>
<p>You can also chain the dicts manually inside a dict comprehension:</p>
<pre><code>{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7
</code></pre>
<p>or in python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</p>
<pre><code>dict((k, v) for d in dicts for k, v in d.items())
</code></pre>
<p><code>itertools.chain</code> will chain the iterators over the key-value pairs in the correct order:</p>
<pre><code>import itertools
z = dict(itertools.chain(x.iteritems(), y.iteritems()))
</code></pre>
<h2>Performance Analysis</h2>
<p>I'm only going to do the performance analysis of the usages known to behave correctly. </p>
<pre><code>import timeit
</code></pre>
<p>The following is done on Ubuntu 14.04</p>
<p>In Python 2.7 (system Python):</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(lambda: merge_two_dicts(x, y)))
0.5726828575134277
&gt;&gt;&gt; min(timeit.repeat(lambda: {k: v for d in (x, y) for k, v in d.items()} ))
1.163769006729126
&gt;&gt;&gt; min(timeit.repeat(lambda: dict(itertools.chain(x.iteritems(), y.iteritems()))))
1.1614501476287842
&gt;&gt;&gt; min(timeit.repeat(lambda: dict((k, v) for d in (x, y) for k, v in d.items())))
2.2345519065856934
</code></pre>
<p>In Python 3.5 (deadsnakes PPA):</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(lambda: {**x, **y}))
0.4094954460160807
&gt;&gt;&gt; min(timeit.repeat(lambda: merge_two_dicts(x, y)))
0.7881555100320838
&gt;&gt;&gt; min(timeit.repeat(lambda: {k: v for d in (x, y) for k, v in d.items()} ))
1.4525277839857154
&gt;&gt;&gt; min(timeit.repeat(lambda: dict(itertools.chain(x.items(), y.items()))))
2.3143140770262107
&gt;&gt;&gt; min(timeit.repeat(lambda: dict((k, v) for d in (x, y) for k, v in d.items())))
3.2069112799945287
</code></pre>
<h2>Resources on Dictionaries</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302">My explanation of Python's <strong>dictionary implementation</strong>, updated for 3.6.</a></li>
<li><a href="https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535">Answer on how to add new keys to a dictionary</a></li>
<li><a href="https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067">Mapping two lists into a dictionary</a></li>
<li>The official Python <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="noreferrer">docs on dictionaries</a> </li>
<li><a href="https://www.youtube.com/watch?v=66P5FMkWoVU" rel="noreferrer">The Dictionary Even Mightier</a> - talk by Brandon Rhodes at Pycon 2017</li>
<li><a href="https://www.youtube.com/watch?v=npw4s1QTmPg" rel="noreferrer">Modern Python Dictionaries, A Confluence of Great Ideas</a> - talk by Raymond Hettinger at Pycon 2017</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In your case, what you can do is:</p>
<pre><code>z = dict(x.items() + y.items())
</code></pre>
<p>This will, as you want it, put the final dict in <code>z</code>, and make the value for key <code>b</code> be properly overridden by the second (<code>y</code>) dict's value:</p>
<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; z = dict(x.items() + y.items())
&gt;&gt;&gt; z
{'a': 1, 'c': 11, 'b': 10}
</code></pre>
<p>If you use Python 3, it is only a little more complicated.  To create <code>z</code>:</p>
<pre><code>&gt;&gt;&gt; z = dict(list(x.items()) + list(y.items()))
&gt;&gt;&gt; z
{'a': 1, 'c': 11, 'b': 10}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative:</p>
<pre><code>z = x.copy()
z.update(y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another, more concise, option:</p>
<pre><code>z = dict(x, **y)
</code></pre>
<p><strong>Note</strong>: this has become a popular answer, but it is important to point out that if <code>y</code> has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, <a href="http://mail.python.org/pipermail/python-dev/2010-April/099459.html" rel="noreferrer">Guido is not a fan</a>. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</p>
</div>
<div class="post-text" itemprop="text">
<p>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or <a href="https://docs.python.org/2/library/copy.html" rel="noreferrer">deepcopy</a>, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</p>
<p>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</p>
<p>In terms of <a href="https://docs.python.org/2/library/timeit.html" rel="noreferrer">time</a>:</p>
<pre><code>&gt;&gt;&gt; timeit.Timer("dict(x, **y)", "x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))").timeit(100000)
15.52571702003479
&gt;&gt;&gt; timeit.Timer("temp = x.copy()\ntemp.update(y)", "x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))").timeit(100000)
15.694622993469238
&gt;&gt;&gt; timeit.Timer("dict(x.items() + y.items())", "x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))").timeit(100000)
41.484580039978027
</code></pre>
<p>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</p>
</div>
<div class="post-text" itemprop="text">
<p>In a follow-up answer, you asked about the relative performance of these two alternatives:</p>
<pre><code>z1 = dict(x.items() + y.items())
z2 = dict(x, **y)
</code></pre>
<p>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative <code>z2</code> is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the <code>timeit</code> module that comes with Python.</p>
<p>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</p>
<pre><code>% python -m timeit -s 'x=y=dict((i,i) for i in range(20))' 'z1=dict(x.items() + y.items())'
100000 loops, best of 3: 5.67 usec per loop
% python -m timeit -s 'x=y=dict((i,i) for i in range(20))' 'z2=dict(x, **y)' 
100000 loops, best of 3: 1.53 usec per loop
</code></pre>
<p><code>z2</code> wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but <code>z2</code> always seems to come out ahead.  (If you get inconsistent results for the <em>same</em> test, try passing in <code>-r</code> with a number larger than the default 3.)</p>
<p>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</p>
<pre><code>% python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z1=dict(x.items() + y.items())'
1000 loops, best of 3: 260 usec per loop
% python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z2=dict(x, **y)'               
10000 loops, best of 3: 26.9 usec per loop
</code></pre>
<p><code>z2</code> wins by about a factor of 10.  That's a pretty big win in my book!</p>
<p>After comparing those two, I wondered if <code>z1</code>'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</p>
<pre><code>from itertools import chain
z3 = dict(chain(x.iteritems(), y.iteritems()))
</code></pre>
<p>A few quick tests, e.g.</p>
<pre><code>% python -m timeit -s 'from itertools import chain; from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z3=dict(chain(x.iteritems(), y.iteritems()))'
10000 loops, best of 3: 66 usec per loop
</code></pre>
<p>lead me to conclude that <code>z3</code> is somewhat faster than <code>z1</code>, but not nearly as fast as <code>z2</code>.  Definitely not worth all the extra typing.</p>
<p>This discussion is still missing something important, which is a performance comparison of these alternatives with the "obvious" way of merging two lists: using the <code>update</code> method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</p>
<pre><code>z0 = dict(x)
z0.update(y)
</code></pre>
<p>A typical result:</p>
<pre><code>% python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z0=dict(x); z0.update(y)'
10000 loops, best of 3: 26.9 usec per loop
</code></pre>
<p>In other words, <code>z0</code> and <code>z2</code> seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</p>
<p>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses <code>dict</code> in lots of places; optimizing its operations is a big deal.</p>
<p>You could also write this as</p>
<pre><code>z0 = x.copy()
z0.update(y)
</code></pre>
<p>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</p>
<pre><code>def merge(d1, d2, merge_fn=lambda x,y:y):
    """
    Merges two dictionaries, non-destructively, combining 
    values on duplicate keys as defined by the optional merge
    function.  The default behavior replaces the values in d1
    with corresponding values in d2.  (There is no other generally
    applicable merge strategy, but often you'll have homogeneous 
    types in your dicts, so specifying a merge technique can be 
    valuable.)

    Examples:

    &gt;&gt;&gt; d1
    {'a': 1, 'c': 3, 'b': 2}
    &gt;&gt;&gt; merge(d1, d1)
    {'a': 1, 'c': 3, 'b': 2}
    &gt;&gt;&gt; merge(d1, d1, lambda x,y: x+y)
    {'a': 2, 'c': 6, 'b': 4}

    """
    result = dict(d1)
    for k,v in d2.iteritems():
        if k in result:
            result[k] = merge_fn(result[k], v)
        else:
            result[k] = v
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, you can use <a href="http://docs.python.org/3/library/collections.html#collections.ChainMap"><em>collections.ChainMap</em></a> which groups multiple dicts or other mappings together to create a single, updateable view:</p>
<pre><code>&gt;&gt;&gt; from collections import ChainMap
&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; z = ChainMap({}, y, x)
&gt;&gt;&gt; for k, v in z.items():
        print(k, '--&gt;', v)

a --&gt; 1
b --&gt; 10
c --&gt; 11
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Recursively/deep update a dict</h1>
<pre><code>def deepupdate(original, update):
    """
    Recursively update a dict.
    Subdict's won't be overwritten but also updated.
    """
    for key, value in original.iteritems(): 
        if key not in update:
            update[key] = value
        elif isinstance(value, dict):
            deepupdate(value, update[key]) 
    return update</code></pre>
<p>Demonstration:</p>
<pre><code>pluto_original = {
    'name': 'Pluto',
    'details': {
        'tail': True,
        'color': 'orange'
    }
}

pluto_update = {
    'name': 'Pluutoo',
    'details': {
        'color': 'blue'
    }
}

print deepupdate(pluto_original, pluto_update)</code></pre>
<p>Outputs:</p>
<pre><code>{
    'name': 'Pluutoo',
    'details': {
        'color': 'blue',
        'tail': True
    }
}</code></pre>
<p>Thanks rednaw for edits.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best version I could think while not using copy would be:</p>
<pre><code>from itertools import chain
x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
dict(chain(x.iteritems(), y.iteritems()))
</code></pre>
<p>It's faster than <code>dict(x.items() + y.items())</code> but not as fast as <code>n = copy(a); n.update(b)</code>, at least on CPython. This version also works in Python 3 if you change <code>iteritems()</code> to <code>items()</code>, which is automatically done by the 2to3 tool.</p>
<p>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
z = dict(x.items() + y.items())
print z
</code></pre>
<p>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.5 (PEP 448) allows a nicer syntax option:</p>
<pre><code>x = {'a': 1, 'b': 1}
y = {'a': 2, 'c': 2}
final = {**x, **y} 
final
# {'a': 2, 'b': 1, 'c': 2}
</code></pre>
<p>Or even </p>
<pre><code>final = {'a': 1, 'b': 1, **x, **y}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While the question has already been answered several times,
this simple solution to the problem has not been listed yet.</p>
<pre><code>x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
z4 = {}
z4.update(x)
z4.update(y)
</code></pre>
<p>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def dict_merge(a, b):
  c = a.copy()
  c.update(b)
  return c

new = dict_merge(old, extras)
</code></pre>
<p>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life <em>Guido van Rossum</em> himself!  Someone else suggested half of this, but did not put it in a function.</p>
<pre><code>print dict_merge(
      {'color':'red', 'model':'Mini'},
      {'model':'Ferrari', 'owner':'Carl'})
</code></pre>
<p>gives:</p>
<pre><code>{'color': 'red', 'owner': 'Carl', 'model': 'Ferrari'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you think lambdas are evil then read no further.
As requested, you can write the fast and memory-efficient solution with one expression:</p>
<pre><code>x = {'a':1, 'b':2}
y = {'b':10, 'c':11}
z = (lambda a, b: (lambda a_copy: a_copy.update(b) or a_copy)(a.copy()))(x, y)
print z
{'a': 1, 'c': 11, 'b': 10}
print x
{'a': 1, 'b': 2}
</code></pre>
<p>As suggested above, using two lines or writing a function is probably a better way to go.</p>
</div>
<div class="post-text" itemprop="text">
<p>Be pythonic. Use a <a href="https://docs.python.org/2/tutorial/datastructures.html#dictionaries" rel="noreferrer">comprehension</a>:</p>
<pre><code>z={i:d[i] for d in [x,y] for i in d}

&gt;&gt;&gt; print z
{'a': 1, 'c': 11, 'b': 10}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python3, the <code>items</code> method <a href="http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="noreferrer">no longer returns a list</a>, but rather a <em>view</em>, which acts like a set. In this case you'll need to take the set union since concatenating with <code>+</code> won't work:</p>
<pre><code>dict(x.items() | y.items())
</code></pre>
<p>For python3-like behavior in version 2.7, the <code>viewitems</code> method should work in place of <code>items</code>:</p>
<pre><code>dict(x.viewitems() | y.viewitems())
</code></pre>
<p>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</p>
<p><strong>Edit:</strong></p>
<p>A couple more points for python 3. First, note that the <code>dict(x, **y)</code> trick won't work in python 3 unless the keys in <code>y</code> are strings.</p>
<p>Also, Raymond Hettinger's Chainmap <a href="https://stackoverflow.com/a/16259217/386279">answer</a> is pretty elegant, since it can take an arbitrary number of dicts as arguments, but <a href="http://docs.python.org/dev/library/collections" rel="noreferrer">from the docs</a> it looks like it sequentially looks through a list of all the dicts for each lookup:</p>
<blockquote>
<p>Lookups search the underlying mappings successively until a key is found.</p>
</blockquote>
<p>This can slow you down if you have a lot of lookups in your application:</p>
<pre><code>In [1]: from collections import ChainMap
In [2]: from string import ascii_uppercase as up, ascii_lowercase as lo; x = dict(zip(lo, up)); y = dict(zip(up, lo))
In [3]: chainmap_dict = ChainMap(y, x)
In [4]: union_dict = dict(x.items() | y.items())
In [5]: timeit for k in union_dict: union_dict[k]
100000 loops, best of 3: 2.15 µs per loop
In [6]: timeit for k in chainmap_dict: chainmap_dict[k]
10000 loops, best of 3: 27.1 µs per loop
</code></pre>
<p>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</p>
</div>
<div class="post-text" itemprop="text">
<p>Abuse leading to a one-expression solution for <a href="https://stackoverflow.com/a/39437/15055">Matthew's answer</a>:</p>
<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; z = (lambda f=x.copy(): (f.update(y), f)[1])()
&gt;&gt;&gt; z
{'a': 1, 'c': 11, 'b': 10}
</code></pre>
<p>You said you wanted one expression, so I abused <code>lambda</code> to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</p>
<p>You could also do this of course if you don't care about copying it:</p>
<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; z = (x.update(y), x)[1]
&gt;&gt;&gt; z
{'a': 1, 'b': 10, 'c': 11}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple solution using itertools that preserves order (latter dicts have precedence)</p>
<pre><code>import itertools as it
merge = lambda *args: dict(it.chain.from_iterable(it.imap(dict.iteritems, args)))
</code></pre>
<p>And it's usage:</p>
<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; merge(x, y)
{'a': 1, 'b': 10, 'c': 11}

&gt;&gt;&gt; z = {'c': 3, 'd': 4}
&gt;&gt;&gt; merge(x, y, z)
{'a': 1, 'b': 10, 'c': 3, 'd': 4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Two dictionaries</strong></p>
<pre><code>def union2(dict1, dict2):
    return dict(list(dict1.items()) + list(dict2.items()))
</code></pre>
<p><strong><em>n</em> dictionaries</strong></p>
<pre><code>def union(*dicts):
    return dict(itertools.chain.from_iterable(dct.items() for dct in dicts))
</code></pre>
<p><code>sum</code> has bad performance. See <a href="https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/" rel="noreferrer">https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In python 3:</p>
<pre><code>import collections
a = {1: 1, 2: 2}
b = {2: 3, 3: 4}
c = {3: 5}

r = dict(collections.ChainMap(a, b, c))
print(r)
</code></pre>
<p>Out:</p>
<pre><code>{1: 1, 2: 2, 3: 4}
</code></pre>
<p>Docs: <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="noreferrer">https://docs.python.org/3/library/collections.html#collections.ChainMap</a>:</p>
</div>
<div class="post-text" itemprop="text">
<p>Even though the answers were good for this <em>shallow</em> dictionary, none of the methods defined here actually do a deep dictionary merge.</p>
<p>Examples follow:</p>
<pre><code>a = { 'one': { 'depth_2': True }, 'two': True }
b = { 'one': { 'extra': False } }
print dict(a.items() + b.items())
</code></pre>
<p>One would expect a result of something like this:</p>
<pre><code>{ 'one': { 'extra': False', 'depth_2': True }, 'two': True }
</code></pre>
<p>Instead, we get this:</p>
<pre><code>{'two': True, 'one': {'extra': False}}
</code></pre>
<p>The 'one' entry should have had 'depth_2' and 'extra' as items inside its dictionary if it truly was a merge.</p>
<p>Using chain also, does not work:</p>
<pre><code>from itertools import chain
print dict(chain(a.iteritems(), b.iteritems()))
</code></pre>
<p>Results in:</p>
<pre><code>{'two': True, 'one': {'extra': False}}
</code></pre>
<p>The deep merge that rcwesick gave also creates the same result.</p>
<p>Yes, it will work to merge the sample dictionaries, but none of them are a generic mechanism to merge.  I'll update this later once I write a method that does a true merge.</p>
</div>
<div class="post-text" itemprop="text">
<p>For Python 2 :</p>
<pre><code>x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
z = dict(x.items()+y.items())
print(z)
</code></pre>
<p>For Python 3:</p>
<pre><code>x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
z = dict(x.items()|y.items())
print(z)
</code></pre>
<p>It gives output:<code>{'a': 1, 'c': 11, 'b': 10}</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Drawing on ideas here and elsewhere I've comprehended a function:</p>
<pre><code>def merge(*dicts, **kv): 
      return { k:v for d in list(dicts) + [kv] for k,v in d.items() }
</code></pre>
<p>Usage (tested in python 3):</p>
<pre><code>assert (merge({1:11,'a':'aaa'},{1:99, 'b':'bbb'},foo='bar')==\
    {1: 99, 'foo': 'bar', 'b': 'bbb', 'a': 'aaa'})

assert (merge(foo='bar')=={'foo': 'bar'})

assert (merge({1:11},{1:99},foo='bar',baz='quux')==\
    {1: 99, 'foo': 'bar', 'baz':'quux'})

assert (merge({1:11},{1:99})=={1: 99})
</code></pre>
<p>You could use a lambda instead.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; x, z = dict(x), x.update(y) or x
&gt;&gt;&gt; x
{'a': 1, 'b': 2}
&gt;&gt;&gt; y
{'c': 11, 'b': 10}
&gt;&gt;&gt; z
{'a': 1, 'c': 11, 'b': 10}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key "b" is 10 but, to my way of thinking, it should be 12.
In that light, I present the following:</p>
<pre><code>import timeit

n=100000
su = """
x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
"""

def timeMerge(f,su,niter):
    print "{:4f} sec for: {:30s}".format(timeit.Timer(f,setup=su).timeit(n),f)

timeMerge("dict(x, **y)",su,n)
timeMerge("x.update(y)",su,n)
timeMerge("dict(x.items() + y.items())",su,n)
timeMerge("for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] ",su,n)

#confirm for loop adds b entries together
x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k]
print "confirm b elements are added:",x
</code></pre>
<h1>Results:</h1>
<pre><code>0.049465 sec for: dict(x, **y)
0.033729 sec for: x.update(y)                   
0.150380 sec for: dict(x.items() + y.items())   
0.083120 sec for: for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k]

confirm b elements are added: {'a': 1, 'c': 11, 'b': 12}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with a single dict comprehension:</p>
<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; { key: y[key] if key in y else x[key]
      for key in set(x) + set(y)
    }
</code></pre>
<p>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter
dict1 = {'a':1, 'b': 2}
dict2 = {'b':10, 'c': 11}
result = dict(Counter(dict1) + Counter(dict2))
</code></pre>
<p>This should solve your problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.5 you can use unpack <code>**</code> in order to create new dictionary. 
This method has no been showed in past answers. Also, it's better to use <code>{}</code> instead of <code>dict()</code>. Because <code>{}</code> is a python literal and <code>dict()</code> involves a function call.</p>
<pre><code>dict1 = {'a':1}
dict2 = {'b':2}
new_dict = {**dict1, **dict2}
&gt;&gt;&gt;new_dict
{'a':1, 'a':2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(For Python2.7* only; there are simpler solutions for Python3*.)</p>
<p>If you're not averse to importing a standard library module, you can do</p>
<pre><code>from functools import reduce

def merge_dicts(*dicts):
    return reduce(lambda a, d: a.update(d) or a, dicts, {})
</code></pre>
<p>(The <code>or a</code> bit in the <code>lambda</code> is necessary because <code>dict.update</code> always returns <code>None</code> on success.)</p>
</div>
<span class="comment-copy">To clarify why this doesn't meet the critera provided by the question: it's not a single expression and it doesn't return z.</span>
<span class="comment-copy">@neuronet every oneliner is usually just moving code that has to happen into a different component and solves it there. this is definitely one of the cases. but other languages have nicer constructs than python for this. and having a referentially transparent variant that returns it's element is a nice to have thing.</span>
<span class="comment-copy">Put it this way: if you need to put two lines of comments explaining your one line of code to the people you hand your code off to...have you really done it in one line? :) I fully agree Python is not good for this: there should be a much easier way. While this answer is more pythonic, is it really all that explicit or clear? <code>Update</code> is not one of the "core" functions that people tend to use a lot.</span>
<span class="comment-copy">This does not work in Python 3; <code>items()</code> is not catenable, and <code>iteritems</code> does not exist.</span>
<span class="comment-copy">But one should be cautious while using ChainMap there's a catch that if you have duplicate keys the values from first mapping get used and when you call a <code>del</code> on say a ChainMap c will delete the first mapping of that key.</span>
<span class="comment-copy">@Prerit What else would you expect it to do?  That's the normal way chained namespaces work.  Consider how $PATH works in bash.  Deleting an executable on the path doesn't preclude another executable with the same name further upstream.</span>
<span class="comment-copy">@Raymond Hettinger I agree, just added a caution. Most people may not know about it. :D</span>
<span class="comment-copy">This does not answer the question. The question clearly asks for a new dictionary, z, from original dictionaries, x and y, with values from y replacing those of x - not an updated dictionary. This answer modifies y in-place by adding values from x. Worse, it does not copy these values, so one could further modify the modified dictionary, y, and modifications could be reflected in dictionary x. @Jérôme I hope this code is not causing any bugs for your application - at least consider using deepcopy to copy the values.</span>
<span class="comment-copy">@AaronHall agreed this does not answer the question. But it answers my need. I understand those limitations, but that's not an issue in my case. Thinking of it, maybe the name is misleading, as it might evoke a deepcopy, which it does not provide. But it addresses deep nesting. Here's another implementation from the Martellibot: <a href="https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth#3233356" title="update value of a nested dictionary of varying depth%233233356">stackoverflow.com/questions/3232943/…</a>.</span>
<span class="comment-copy">In what way is this solution better than the <code>dict(x, **y)</code>-solution? As you (@CarlMeyer) mentioned within the note of your own answer (<a href="http://stackoverflow.com/a/39858/2798610">stackoverflow.com/a/39858/2798610</a>) Guido considers that solution <i>illegal</i>.</span>
<span class="comment-copy">Guido dislikes <code>dict(x, **y)</code> for the (very good) reason that it relies on <code>y</code> only having keys which are valid keyword argument names (unless you are using CPython 2.7, where the dict constructor cheats). This objection/restriction does not apply to PEP 448, which generalizes the <code>**</code> unpacking syntax to dict literals. So this solution has the same concision as <code>dict(x, **y)</code>, without the downside.</span>
<span class="comment-copy">but it's three statements rather than one expression</span>
<span class="comment-copy">Yes! The mentioned one-expression-solutions are either slow or evil. Good code is readable and maintainable. So the problem is the question not the answer. We should ask for the best solution of a problem not for a one-line-solution.</span>
<span class="comment-copy">Lose the <code>z4 = {}</code> and change the next line to <code>z4 = x.copy()</code> -- better than just good code doesn't do unnecessary things (which makes it even more readable and maintainable).</span>
<span class="comment-copy">Your suggestion would change this to Matthews answer. While his answer is fine, I think mine is more readable and better maintainable. The extra line would only be bad if it would cost execution time.</span>
<span class="comment-copy">As a function: <code>def dictmerge(*args):   return {i:d[i] for d in args for i in d}</code></span>
<span class="comment-copy">Save a lookup by iterating the key/value pairs directly: <code>z={k: v for d in (x, y) for k, v in d.items()}</code></span>
<span class="comment-copy">This is a commentary on the existing answers, and does not provide an answer.</span>
<span class="comment-copy">For the record, on 2.7, <code>dict(x.viewitems()|y.viewitems())</code> would be directly equivalent to your Py3.x code. That said, this answer has ordering issues; if the same key appears in <code>x</code> and <code>y</code>, it's arbitrary which value survives in <code>z</code>; better solutions avoid this arbitrariness (usually by saying that the last appearance of the key, in this case, the value from <code>y</code>, is the one which survives).</span>
<span class="comment-copy">This method overwrites <code>x</code> with its copy. If <code>x</code> is a function argument this won't work (see <a href="https://pastebin.com/QXmyn9m8" rel="nofollow noreferrer">example</a>)</span>
<span class="comment-copy">You might be interested in <code>cytoolz.merge_with</code> (<a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.dicttoolz.merge_with" rel="nofollow noreferrer">toolz.readthedocs.io/en/latest/…</a>)</span>
<span class="comment-copy">I suspect performance will not be very good though; creating a set out of each dict then only iterating through the keys means another lookup for the value each time (though relatively fast, still increases the order of the function for scaling)</span>
<span class="comment-copy">it all depends on the version of the python we are using. In 3.5 and above {**x,**y} gives the concatenated dictionary</span>
<span class="comment-copy"><b>Duplicate answer posted earlier.</b> <a href="http://stackoverflow.com/a/28753078/764592">stackoverflow.com/a/28753078/764592</a></span>
