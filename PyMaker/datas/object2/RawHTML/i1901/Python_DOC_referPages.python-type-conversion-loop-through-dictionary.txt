<div class="post-text" itemprop="text">
<p>I have a dictionary filled with number strings and i want to convert every of those values into binary. Here is what i tried:</p>
<pre><code>    for k,v in ValueDict.items():
        ValueDict.update(k:bin(v))
</code></pre>
<p>However this does not work. PyCharm says "Illegal target for variable annotation", i dont understand what this means. As far as i know, variable annotation is a way of "commenting" on the types of a variable, but i dont understand how this is related to my issue...</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using dictionary comprehension:</p>
<pre><code>print({k:bin(v) for k,v in ValueDict.items()})
</code></pre>
<p>Or if version less then 2.5:</p>
<pre><code>print(dict((k:bin(v) for k,v in ValueDict.items())))
</code></pre>
<p>Your code doesn't work from <code>:</code> in <code>ValueDict.update(k:bin(v))</code></p>
<p>To use your style:</p>
<pre><code>for k,v in ValueDict.items():
    ValueDict.update({k:bin(v)})
</code></pre>
<p>Or:</p>
<pre><code>for k,v in ValueDict.items():
    ValueDict[k]=bin(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to provide a <code>dict</code> to <code>update</code> method.</p>
<pre><code>for k,v in ValueDict.items():
    ValueDict.update({k:bin(v)})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See the documentation at <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer">dict.update</a>:</p>
<blockquote>
<p>Update the dictionary with the key/value pairs from other, overwriting existing keys. Return <em>None</em>.</p>
<p><strong><code>update()</code></strong> accepts either <strong>another dictionary</strong> object or an <strong>iterable of key/value pairs</strong> (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: <code>d.update(red=1, blue=2)</code>.</p>
</blockquote>
<p>Examples:</p>
<pre><code># dict expression
d = {"a":1, "b":2, "c":3}
&gt;&gt;&gt; {'a': 1, 'c': 3, 'b': 2}

# multiple updates: no loop needed
d.update( {"a" : 11, "b" : 22} )
&gt;&gt;&gt; {'a': 11, 'c': 3, 'b': 22}

# multiple adds: no loop needed (also no '' around keys)
d.update( A = 111, B = 22 )
&gt;&gt;&gt; {'a': 11, 'A': 111, 'c': 3, 'b': 22, 'B': 22}

# updating all keys using loop
for k,v in d.items():
    d[k]=v*2
&gt;&gt;&gt; {'a': 22, 'A': 222, 'c': 6, 'b': 44, 'B': 44}


# add values to a list if same keys and not yet in
# providing an existing key here would overwrite that one
new_ones = ( ("X",42), ("X",4711) )
for k,v in new_ones:
    entry = d.setdefault(k,[])
    entry.append(v)
&gt;&gt;&gt; {'a': 22, 'A': 222, 'c': 6, 'b': 44, 'B': 44, 'X': [42, 4711]}

# no loop - update from iterable of key/value pairs
new_ones = ( ("i",42), ("j",4711) )
d.update(new_ones)
&gt;&gt;&gt; {'a': 22, 'A': 222, 'c': 6, 'b': 44, 'i': 42, 'j': 4711, 'B': 44, 'X': [42, 4711]}
</code></pre>
</div>
<span class="comment-copy">Oh, i didnt knew i had to use curly braces when i only want to change one entry, thanks!</span>
<span class="comment-copy">Can only accept in 9 minutes for some reason</span>
