<div class="post-text" itemprop="text">
<p>I want to print all the lines in which a string occurs in the input file, along with the line numbers . So far I wrote the code shown below. It is working, but not in the way I wanted:</p>
<pre><code>def index(filepath, keyword):

    with open(filepath) as f:
        for lineno, line in enumerate(f, start=1):
            matches = [k for k in keyword if k in line]
            if matches:
                result = "{:&lt;15} {}".format(','.join(matches), lineno)
                print(result)
                print (line)

index('deneme.txt', ['elma'])
</code></pre>
<p>Output is as follows: </p>
<pre><code>elma            15
Sogan+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elma+Noun ve+Conj turunçgil+Noun+A3pl ihracat+Noun+P3sg+Dat devlet+Noun destek+Noun+P3sg ver+Verb+Pass+Prog2+Cop .+Punc  
</code></pre>
<p>So far so good, But when I enter a keyword like <code>"Sog"</code> it also finds the <code>Sogan</code> but I don't want that, I only want to check tokens between whitespaces. I think I need to write regex for this and I got one but I couldn't now how can i add that regex to this code. </p>
<pre><code>r'[\w+]+'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You will probably want to use the word boundary marker <code>\b</code>. This is an empty match for transitions between <code>\w</code> and <code>\W</code>. If you want your keywords to be literal strings, you will have to <a href="https://docs.python.org/3/library/re.html#re.escape" rel="nofollow noreferrer">escape</a> them first. You can combine everything into one regular expression using <code>|</code>:</p>
<pre><code>pattern = re.compile(r'\b(' + '|'.join(map(re.escape, keyword)) + r')\b')
</code></pre>
<p>OR</p>
<pre><code>pattern = re.compile(r'\b(?' + '|'.join(re.escape(k) for k in keyword) + r')\b')
</code></pre>
<p>Computing the matches is a bit easier now, since you can use <a href="https://docs.python.org/3/library/re.html#re.Pattern.finditer" rel="nofollow noreferrer"><code>finditer</code></a> instead of making your own comprehension:</p>
<pre><code>matches = pattern.finditer(line)
</code></pre>
<p>Since each match is enclosed in a group, printing is not much more difficult:</p>
<pre><code>result = "{:&lt;15} {}".format(','.join(m.group() for m in matches), lineno)
</code></pre>
<p>OR</p>
<pre><code>result = "{:&lt;15} {}".format(','.join(map(re.Match.group(), matches)), lineno)
</code></pre>
<p>Of course, don't forget to</p>
<pre><code>import re
</code></pre>
<p><strong>Corner Case</strong></p>
<p>If you have keywords that are subsets of each other with the same prefix, make sure the longer ones come first. For example, if you have</p>
<pre><code>keyword = ['foo', 'foobar']
</code></pre>
<p>The regex will be</p>
<pre><code>\b(foo|foobar)\b
</code></pre>
<p>When you encounter a line with <code>foobar</code> in it, <code>foo</code> will match successfully against it and then fail against <code>\b'. This is documented behavior of</code>|`. The solution is to pre-sort all your keywords by decreasing length before constructing the expression:</p>
<pre><code>keywords.sort(key=len, reversed=True)
</code></pre>
<p>Or, if non-list inputs are possible:</p>
<pre><code>keywords = sorted(keywords, key=len, reversed=True)
</code></pre>
<p>If you don't like this order, you can always print them in some other order after you match.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the following regex:</p>
<pre><code>import re

lines = [
    'Sogan+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elma+Noun ve+Conj turunçgil+Noun+A3pl ihracat+Noun+P3sg+Dat devlet+Noun destek+Noun+P3sg ver+Verb+Pass+Prog2+Cop .+Punc',
    'Sog+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elma+Noun ve+Conj turunçgil+Noun+A3pl ihracat+Noun+P3sg+Dat devlet+Noun destek+Noun+P3sg ver+Verb+Pass+Prog2+Cop .+Punc',
]

keywords = ['Sog']
pattern = re.compile('(\w+)\+')

for lineno, line in enumerate(lines):
    words = set(m.group(1) for m in pattern.finditer(line))  # convert to set for efficiency
    matches = [keyword for keyword in keywords if keyword in words]
    if matches:
        result = "{:&lt;15} {}".format(','.join(matches), lineno)
        print(result)
        print(line)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>Sog             1
Sog+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elma+Noun ve+Conj turunçgil+Noun+A3pl ihracat+Noun+P3sg+Dat devlet+Noun destek+Noun+P3sg ver+Verb+Pass+Prog2+Cop .+Punc
</code></pre>
<p><strong>Explanation</strong></p>
<p>The pattern <code>'(\w+)\+'</code> any group of letters followed by a <code>+</code> character, <code>+</code> is special character so you need to escape it, in order to match. Then use group to extract the matching group, (i.e. the group of letters).</p>
<p><strong>Further</strong></p>
<ol>
<li>Regular expression <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">syntax</a></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Question</strong>:  a keyword like "Sog" it also finds the Sogan ... I only want tokens between whitespaces. ... how can i add that regex to this code. </p>
</blockquote>
<p>Build a <code>regex</code> with your <code>keywords</code>, use the <code>or |</code> separator for multiple <code>keywords</code>.</p>
<p>For example:  </p>
<pre><code>import re

def index(lines, keyword):
    rc = re.compile(".*?(({})\+.+?\s)".format(keyword))

    for i, line in enumerate(lines):
        match = rc.match(line)
        if match:
            print("lines[{}] match:{}\n{}".format(i, match.groups(), line))

if __name__ == "__main__":
    lines = [
    'Sogan+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elmaro+Noun ve+Conj ... (omitted for brevity)',
    'Sog+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elma+Noun ve+Conj ... (omitted for brevity)',
]
    index(lines, 'elma')
    index(lines, 'Sog|elma')
</code></pre>
<blockquote>
<p><strong>Output</strong>:</p>
<pre><code>lines[1] match:('elma+Noun ', 'elma')
Sog+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elma+Noun ve+Conj ... (omitted for brevity)
lines[1] match:('Sog+Noun ', 'Sog')
Sog+Noun ,+Punc domates+Noun ,+Punc patates+Noun ,+Punc elma+Noun ve+Conj ... (omitted for brevity)
</code></pre>
</blockquote>
<p><strong><em>Tested with Python: 3.5</em></strong></p>
</div>
<span class="comment-copy">Your pattern field is giving error, I think there is some error with the the regex.</span>
<span class="comment-copy">Fixed. Extra question mark</span>
