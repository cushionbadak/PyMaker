<div class="post-text" itemprop="text">
<p>In Python, if you call a method that doesn't exist it throws an AttributeError. Ex </p>
<pre><code>&gt;&gt;&gt; class A:
...     def yo(self):
...             print(1)
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.yo()
1
&gt;&gt;&gt; a.hello()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'A' object has no attribute 'hello'
</code></pre>
<p>In the below code, MagicMock class doesn't have a function named hello or no patch was created for a method hello. Still below code doesn't throw an AttributeError</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import MagicMock 
&gt;&gt;&gt; obj = MagicMock()
&gt;&gt;&gt; obj.hello()
&lt;MagicMock name='mock.hello()' id='4408758568'&gt;
</code></pre>
<p>How is MagicMock able to do this? How can I create a class that can perform an action when any method (which might not be defined) is called on it?</p>
</div>
<div class="post-text" itemprop="text">
<p>The Python datamodel documents a hook, <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a>, which shall be called when attribute access fails to resolve in the usual ways. Mocks use it to return a new mock instance - i.e. mocks define unknown attributes as <a href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)" rel="nofollow noreferrer"><em>factories</em></a>.</p>
<p>Reproducing mock's implementation in a simpler way, you would just turn <code>__getattr__</code> and <code>__call__</code> into factory functions:</p>
<pre><code>class M:
    def __call__(self):
        return M()
    def __getattr__(self, name):
        return M()
</code></pre>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; mock = M()
&gt;&gt;&gt; mock.potato
&lt;__main__.M at 0xdeadbeef&gt;
&gt;&gt;&gt; mock.potato()
&lt;__main__.M at 0xcafef00d&gt;
</code></pre>
<blockquote>
<p>How is MagicMock able to do this? </p>
</blockquote>
<p>This part is not specific to <code>MagicMock</code>, an ordinary <code>Mock</code> will do the same (the "magic" in the name is just referring to additional features allowing better mocking of <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">magic methods</a>).  <code>MagicMock</code> <a href="https://github.com/python/cpython/blob/e80e77a484983ffb527ef22d336ff9500589dce3/Lib/unittest/mock.py#L575" rel="nofollow noreferrer">inherits such behavior from one of the base classes</a>:</p>
<pre><code>&gt;&gt;&gt; MagicMock.mro()
[unittest.mock.MagicMock,
 unittest.mock.MagicMixin,
 unittest.mock.Mock,
 unittest.mock.CallableMixin,
 unittest.mock.NonCallableMock,  # &lt;--- this one overrides __getattr__!
 unittest.mock.Base,
 object]
</code></pre>
<blockquote>
<p>How can I create a class that can perform an action when any method (which might not be defined) is called on it?</p>
</blockquote>
<p>It depends if you want to be in front of, or behind, a normal attribute access.  If you want to get in front, you should define <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a>, it's called unconditionally to implement attribute accesses before searching the class/instance namespaces. However, if you want to take a lower precedence to normal attributes (i.e. those living in the object <code>__dict__</code>) and to <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="nofollow noreferrer">descriptors</a>, then you should define <code>__getattr__</code> as previously discussed.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't actually know how specifically <code>MagicMock</code> works (I've never used it, but I've Heard Good Things), but this part of the behaviour can be replicated (along with probably multiple other possible solutions) by hijacking <code>__getattr__</code> in a way that it returns a callable that creates a new mock instance when called:</p>
<pre><code>class MM:
    def __init__(self, name=None):
        # store a name, TODO: random id, etc.
        self.name = name

    def __repr__(self):
        # make it pretty
        if self.name:
            r = f'&lt;MM name={self.name}&gt;'
        else:
            r = f'&lt;MM&gt;'
        return r

    def __getattr__(self, attrname):
        # we want a factory for a mock instance with a name corresponding to attrname
        def magicattr():
            return MM(name=f"'mock.{attrname}()'")
        return magicattr
</code></pre>
<p>When executed, we see the following:</p>
<pre><code>&gt;&gt;&gt; MM()
&lt;MM&gt;
&gt;&gt;&gt; MM().hello()
&lt;MM name='mock.hello()'&gt;
</code></pre>
<p>I didn't go overboard with defining an <code>id</code> and whatnot, but the basic trick can be seen on the above stripped-down example.</p>
<p>The way the above works is that accessing <code>.hello</code> or any other attribute goes through our custom <code>__getattr__</code> which gives us a chance to generate a fake (mocked) method on the fly, with whatever properties we want to. As I understand one of the many benefits of <code>MagicMock</code> is exactly that we don't have to worry about <code>AttributeError</code>s being thrown by default, it <em>just works</em>.</p>
</div>
<span class="comment-copy"><a href="http://www.reactiongifs.com/r/mgc.gif" rel="nofollow noreferrer">It's magic</a>. ;)</span>
<span class="comment-copy">I thought there was a special method that got called every time a function is called. And MagicMock overrides that.</span>
<span class="comment-copy">The mock documentation refers to this repeatedly; you need to <i>spec</i> the mock if you want to see attribute errors.</span>
<span class="comment-copy">I understand that with autospec=True, it will throw AttributeError. My question is how is MagicMock able to return mock for any method that get's called open it's object.</span>
<span class="comment-copy">This is exactly what I was looking for, Thanks!</span>
<span class="comment-copy">@2ank3th I suggest changing the accept to wim's answer. I only posted one because people more familiar with the subject didn't seem to bite.</span>
