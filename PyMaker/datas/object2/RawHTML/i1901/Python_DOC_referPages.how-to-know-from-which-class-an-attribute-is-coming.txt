<div class="post-text" itemprop="text">
<p>Imagine an instance from a classes has an attribute attr. I want to know from where it got that attribute.</p>
<p>Let's consider those 2 cases in Python :</p>
<pre><code>class vehicle():
    speed = 5
class flying_machine(vehicle):
    density = 1
</code></pre>
<p>And </p>
<pre><code>class vehicle():
    def __init__(self):
        self.speed = 5
class flying_machine(vehicle):
    def __init__(self):
        super().__init__()
        self.density = 1
</code></pre>
<p>If you execute the following line of codes :</p>
<pre><code>b = flying_machine()
s = b.speed
</code></pre>
<p>s has the value 5. Both cases are different, in the first case, speed is an attribute of the class "vehicle" and in the other case, it's a attribute of an instance of the class "vehicle".</p>
<p>My problem is the same in both case, i want to know from where b got his attribute "speed", I would like to have a function that i could call on b and "speed" and would point me to the place where b.speed was defined. </p>
<p>In my example, it's easy to see where b got its attribute from, but you could imagine classes and subclasses being defined across multiple documents, and having a long inheritance chain. For example :</p>
<pre><code># doc1.py
class vehicle():
    speed = 5

# doc2.py
from doc1.py import *
class flying_machine(vehicle):
     density = 1

# doc3.py
from doc2.py import *
class space_machine(flying_machine):
     light_speed = 0.5

# main.py
from doc3.py import *
c = space_machine()
</code></pre>
<p>In this last case, my c has an attribute speed, and if I want to see where its coming from, i have to go through all previous import, and that's where it would be useful to have a function to show me that c.speed comes from doc1.py .</p>
</div>
<div class="post-text" itemprop="text">
<p>Generally, I would advise you to use a proper IDE like <a href="https://www.jetbrains.com/pycharm/" rel="nofollow noreferrer">PyCharm</a> that allows you to <kbd>Ctrl</kbd>+click on any attribute and that will navigate you to where that attribute is assigned.</p>
<p>That being said, you can use a class's <a href="https://docs.python.org/3/glossary.html#term-method-resolution-order" rel="nofollow noreferrer">mro</a> to dynamically extract <em>some</em> information about where attributes may originate by inspecting the instance's and its classes' <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer"><code>__dict__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a>:</p>
<pre><code>def lookup(obj, attr):
    if attr in obj.__dict__ or attr in obj.__slots__:
        print('{}: instance attribute'.format(attr))
        klass = next((k for k in obj.__class__.mro() 
                          if '__slots__' in k.__dict__ and attr in k.__slots__), 
                     None)
        if klass:
            print('but expected for class {}'.format(klass))
    else:
        for klass in obj.__class__.mro():
            if attr in klass.__dict__:
                print('{}: class attribute of {}'.format(attr, klass))
</code></pre>
<p>You can use this function for arbitrary objects and attributes:</p>
<pre><code>class Vehicle:
    speed = 5

class Ugly:
    __slots__ = ('look',)
    def __init__(self):
        self.look = 'terrible'

class Car(Ugly, Vehicle):
    def __init__(self):
        super().__init__()
        self.num_wheels = 4

&gt;&gt;&gt; c = Car()

&gt;&gt;&gt; lookup(c, 'speed')
speed: class attribute of &lt;class '__main__.Vehicle'&gt;

&gt;&gt;&gt; lookup(c, 'num_wheels')
num_wheels: instance attribute

&gt;&gt;&gt; lookup(c, 'look')
look: instance attribute
but expected for class &lt;class '__main__.Ugly'&gt;
</code></pre>
</div>
<span class="comment-copy">Your question isn't a duplicate of this one, but it might give you some ideas anyway: <a href="https://stackoverflow.com/questions/6575551/how-to-get-python-object-parent" title="how to get python object parent">stackoverflow.com/questions/6575551/â€¦</a></span>
<span class="comment-copy">I would suggest documenting this behavior and looking in there to "know" as well as you described, tracing it back in code. Either way the class has to be instantiated in order to have a value so both are technically instances.</span>
<span class="comment-copy">Don't use wildcard imports, or soon you'll be wondering where <i>anything</i> comes from.</span>
<span class="comment-copy">@mkrieger1 This is obviously not the point of this question. Even without wildcard imports, the issue would be exactly the same.</span>
<span class="comment-copy">I think this will do the trick nicely. Do you know if there exists an equivalent to Pycharm Ctrl Click in Jupyter Lab?</span>
<span class="comment-copy">@StatisticDean I am sorry. Have never used it, but there should be documentation, I guess.</span>
