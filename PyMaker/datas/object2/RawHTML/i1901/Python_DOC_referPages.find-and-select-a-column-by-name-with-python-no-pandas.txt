<div class="post-text" itemprop="text">
<p>I'm looking for a standard Python (no pandas, no numpy) solution to the following.</p>
<p>I have some large csv files. Let's say:</p>
<pre><code>ID | Name | Address | City | State | Zip | Phone | OPEID | IPEDS |Status  |
10 | C... | 130 W.. | Mo.. | AL... | 3.. | 334.. | 01023 | 10063 |COMPLETE| 
11 | D... | 132 W.. | Mo.. | AL... | 3.. | 334.. | 02023 | 10011 |WITHDRAWN| 
</code></pre>
<p>First, not all the files have the same headers and the columns are not necessarily in the same order. For example, the "Status" header may be "Status" or "Case_status" or "CASE", and the value of "Status" for an individual record may be "COMPLETE", "COMPLETE-WITHDRAWN", "INCOMPLETE", etc. What I'd like to do is filter the data by selecting only the data with a "Status" value of "COMPLETE" and THEN find (list) the top 10 States according to how many "COMPLETE" statuses each State has.</p>
<p>I'm able to do this when I know the column numbers, and I found some help for filtering rows with lambda, but I'm having trouble finding a simple Python solution to filter columns by name.</p>
<p>Simple solution for a .csv file when the names and order of columns are known:</p>
<pre><code>import csv
from collections import Counter

with open('input.csv') as f:
    next(f)  # skip header
    #selecting columns by number, but I want to get by name
    if row[9] == 'COMPLETE': 
    occurrence = Counter(row[4] for row in csv.reader(f, delimiter=';'))   
    print(occurrence)
total=sum(occurrence.values())
print(total)

#print the top 10 records
from __future__ import division

with open('output.txt', 'w') as f:
    writer = csv.writer(f,delimiter=";")
    writer.writerow(['Top 10 States','Number of complete cases','PERCENTAGE'])
    for (src), cnt in occurrence.items():
    percent = cnt / total
    writer.writerow([src, cnt, "{0:.1%}".format(percent)])
</code></pre>
<p>So the output looks like:</p>
<pre><code>Top 10 States;Number of certified cases;PERCENTAGE
Wisconsin;11;16.9%
California;10;15.4%
Arizona;9;13.8%
Texas;8;12.3%
Kentucky;7;10.8%
Maine;6;9.2%
Oklahoma;5;7.7%
Ohio;4;6.2%
New York;3;4.6%
Florida;2;3.08%
</code></pre>
<p>But this will not help, since I have to first filter the columns by name and then select based on Status. </p>
<p>Slightly more complete solution with attempt at filtering:</p>
<pre><code>from __future__ import division
import csv
import itertools
from collections import Counter
from collections import defaultdict

f = open('input.csv');
next(f)  # skip header
reader = csv.reader(f, delimiter=';')
    #if row[2] == 'COMPLETE': 
filtered_complete = itertools.ifilter(lambda x: 'COMPLETE' == x[2], reader)

occurrence = Counter(row[24] for row in filtered_complete)   
print(occurrence) #check totals
total=sum(occurrence.values())
print(total) #check totals

with open('output.txt', 'w') as f:
    writer = csv.writer(f,delimiter=";")
    writer.writerow(['Top 10 States','Number of complete cases','PERCENTAGE'])
    for (src), cnt in occurrence.items():
    percent = cnt / total
    writer.writerow([src, cnt, "{0:.1%}".format(percent)])
</code></pre>
<p>But this isn't helpful for filtering columns by name, and I get a KeyError when I attempt to use</p>
<pre><code>itertools.ifilter(lambda x: 'Complete' == 'Status', reader)
</code></pre>
<p>Thoughts? Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just use <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>csv.DictReader</code></a> to read in column names too. It'll read each row as a <code>dict</code>, keys would be column names, and values will be row values, so assuming that the column name is <code>Status</code>, your filter using column name would look like:</p>
<pre><code>f = open('input.csv');
reader = csv.DictReader(f, delimiter=';')
filtered_complete = itertools.ifilter(lambda x: x['Status'] == 'COMPLETE', reader)
</code></pre>
<p>For dealing with the multiple column names, if you know that your column name could include <code>case</code> or <code>status</code> etc, you can write a regex to find the column name.</p>
<pre><code>import re

f = open('input.csv')
reader = list(csv.DictReader(f, delimiter=';'))

# Assuming that there will be atleast one column having either case or status in it
col_names = reader[0].keys()
col_name_regex = re.compile(r'(case|status)')
status_col_name = list(filter(col_name_regex.search, col_names))[0]

filtered_complete = itertools.ifilter(lambda x: x[status_col_name] == 'COMPLETE', reader)
</code></pre>
<p>Disclaimer: This code isn't tested. I just wrote it in this editor.</p>
</div>
<span class="comment-copy">Why would you tag the question <code>pandas</code> if you don't want to use pandas...</span>
<span class="comment-copy">I think you need <code>x['Complete'] == 'Status'</code>.  You gave a comparison of two string constants, which is identically <code>False</code>.</span>
<span class="comment-copy">Also, you should justify you insistence on <i>not</i> using common data-handling packages.  You're happy enough to use <code>csv</code>, which is no more "standard Python" than <code>pandas</code> and <code>numpy</code>.</span>
<span class="comment-copy">@user3483203 Thank you! I will clarify. I tagged it so perhaps some pandas experts who are familiar with the lower-level code would like to weigh in.</span>
<span class="comment-copy">@Prune Thank you! By "standard", I meant anything that comes with a python distribution without an additional pip (or otherwise) install. I apologize if that's incorrect terminology. <a href="https://docs.python.org/3/library/" rel="nofollow noreferrer">docs.python.org/3/library</a></span>
<span class="comment-copy">Thank you! How do I deal with having multiple names for the same column?</span>
<span class="comment-copy">I've edited my answer for that part as well.</span>
<span class="comment-copy">This may work! But I seem to be ending up with one less record at the end that I should.</span>
<span class="comment-copy">edit: this seems to work perfectly!</span>
