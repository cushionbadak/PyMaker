<div class="post-text" itemprop="text">
<p>I'm running a python script that for some reason gets killed and because of it, the stdout is not printed. I know I can get the buffered stdout with <code>sys.stdout.flush()</code>. However, since I don't know when the script is killed, I can miss the time between the last flush and the actual process ending. For example, is the following code only "test 1" will be saved before the 60s sleep ends. If I kill the program before that my log file will contain only the "test 1" print. </p>
<pre><code>import sys,time

sys.stdout = open('log', 'w')
print("test 1")
sys.stdout.flush()
print("test 2")
time.sleep(60) 
</code></pre>
<p>How can I catch the last stdout before the script is killed? How can I get the "test 2" print even if I kill the script before the 60s sleep ends?</p>
</div>
<div class="post-text" itemprop="text">
<p>calling </p>
<pre><code>sys.stdout.flush()
</code></pre>
<p>Will write whatever is in the buffer to the file.
All print does is write objects to the output file stream that's
provided so when forcibly ended the buffer may not have been flushed.
should have a look at this for more info <a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer">print function</a>.</p>
<p>If you want it to flush the buffer with every print pass the flush param like this:</p>
<pre><code>import sys,time

sys.stdout = open('log', 'w')
print("test 1", flush=True)
print("test 2", flush=True)
time.sleep(60) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>flush=True</code> parameter of print() function. Write a decorator to flush all the prints made inside the decorated function.</p>
<pre><code>import functools

def flush_prints(f):
    @functools.wraps(f)
    def decorated(*args, **kwargs):
        global print
        # Flush calls made to print(...)
        print = functools.partial(print, flush=True)
        f_returns = f(*args, **kwargs)
        # Restore back
        print = functools.partial(print, flush=False)
        return f_returns
    return decorated
</code></pre>
<p>So decorating a function like this, will flush all the prints made inside the function:</p>
<pre><code>@flush_prints
def test():
    print("test 1")
    time.sleep(10)
    print("test 2")
    time.sleep(10)

test()
</code></pre>
</div>
<span class="comment-copy">Take a look here: <a href="https://stackoverflow.com/questions/881696/unbuffered-stdout-in-python-as-in-python-u-from-within-the-program" title="unbuffered stdout in python as in python u from within the program">stackoverflow.com/questions/881696/â€¦</a></span>
<span class="comment-copy">How is your program killed? By <code>KeyboardInterrupt</code>? By <code>SystemExit</code>? Or something else?</span>
<span class="comment-copy">I don't know. I left it running and for some reason, it got killed. And is not the first time.</span>
<span class="comment-copy">Maybe you could incorporate a wrapper that takes the arguments and adds <code>flush</code> implicitly. i.e. <code>flush = lambda *args: print(*args, flush=True)</code></span>
<span class="comment-copy">Thanks but this only works with the prints. If I have anything else in the buffer I will miss it.</span>
