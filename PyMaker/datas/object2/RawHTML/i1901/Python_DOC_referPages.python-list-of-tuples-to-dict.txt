<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/19189274/nested-defaultdict-of-defaultdict">Nested defaultdict of defaultdict</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>There is a python list</p>
<pre><code>[('schema1', 'table1', 'column_name1'), ('schema1', 'table1', 'column_name2'), ('schema1', 'table2', 'column_name3'), ('schema2', 'table3', 'column_name4')]
</code></pre>
<p>I need to convert it into python dict with the following structure</p>
<pre><code>schema1:
            table1:
                    (column_name1,
                    column_name2)
            table2:
                    (column_name3)
schema2:
            table3:
                    (column_name4)
</code></pre>
<p>Are there any efficient ways to convert?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd do this with a <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><strong><code>defaultdict</code></strong></a> that produces <code>defaultdict(list)</code> instances as default values.</p>
<p><strong>Demo</strong></p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; 
&gt;&gt;&gt; d = defaultdict(lambda: defaultdict(list))
&gt;&gt;&gt; data = [('schema1', 'table1', 'column_name1'), ('schema1', 'table1', 'column_name2'), ('schema1', 'table2', 'column_name3'), ('schema2', 'table3', 'column_name4')]
&gt;&gt;&gt; 
&gt;&gt;&gt; for k1, k2, v in data:
...:    d[k1][k2].append(v)
...:    
&gt;&gt;&gt; d
&gt;&gt;&gt; 
defaultdict(&lt;function __main__.&lt;lambda&gt;()&gt;,
            {'schema1': defaultdict(list,
                         {'table1': ['column_name1', 'column_name2'],
                          'table2': ['column_name3']}),
             'schema2': defaultdict(list, {'table3': ['column_name4']})})
</code></pre>
<p>To match your desired output exactly (although I don't see much reason), build a regular dictionary from <code>d</code> with <code>tuple</code> values.</p>
<pre><code>&gt;&gt;&gt; d = {k1:{k2:tuple(v2) for k2, v2 in v1.items()} for k1, v1 in d.items()}
&gt;&gt;&gt; d
&gt;&gt;&gt; 
{'schema1': {'table1': ('column_name1', 'column_name2'),
  'table2': ('column_name3',)},
 'schema2': {'table3': ('column_name4',)}}
</code></pre>
<p><strong>Explanation</strong></p>
<p>The <code>defaultdict</code> initializer accepts a callable (in this example an anonymous <code>lambda</code> function is used). Whenever a key is missing, that callable is called and the return value is used as a fallback-value.</p>
<p>The line</p>
<pre><code>d = defaultdict(lambda: defaultdict(list))
</code></pre>
<p>is creating a <code>defaultdict</code> which creates another <code>defaultdict</code> when a key is missing. The second defaultdict creates a <code>list</code> when a key is missing.</p>
<pre><code>&gt;&gt;&gt; d = defaultdict(lambda: defaultdict(list))
&gt;&gt;&gt; d['bogus']
&gt;&gt;&gt; defaultdict(list, {})
&gt;&gt;&gt; d['hokus']['pokus']
&gt;&gt;&gt; []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sure. Use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="noreferrer"><code>collections.defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict

dd = defaultdict(lambda: defaultdict(list))

for schema, table, colname in L:
    dd[schema][table].append(colname)
</code></pre>
<p>Result:</p>
<pre><code>defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
            {'schema1': defaultdict(list,
                         {'table1': ['column_name1', 'column_name2'],
                          'table2': ['column_name3']}),
             'schema2': defaultdict(list, {'table3': ['column_name4']})})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No need for any special things, simple dictionary methods work:</p>
<pre><code>d = [('schema1', 'table1', 'column_name1'), 
     ('schema1', 'table1', 'column_name2'), 
     ('schema1', 'table2', 'column_name3'), 
     ('schema2', 'table3', 'column_name4')]

k = {}

for schema,table,column in d:
    p =  k.setdefault(schema,{})
    p2 = p.setdefault(table,[])
    p2.append(column)

print(k)
</code></pre>
<p>Output:</p>
<pre><code>{'schema1': {'table2': ['column_name3'], 
             'table1': ['column_name1', 'column_name2']}, 
 'schema2': {'table3': ['column_name4']}}
</code></pre>
<hr/>
<p>Although more experienced ppl suggest not using this, because its slower. So it is better to work with the defaultdict-approach provided by the other answers.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [('schema1', 'table1', 'column_name1'), ('schema1', 'table1', 'column_name2'), 
 ('schema1', 'table2', 'column_name3'), ('schema2', 'table3', 'column_name4')]
d = {}

for s, t, c in l:
    d[s] = d.get(s, {})
    d[s][t] = d[s].get(t, tuple()) + (c,)
print(d)
</code></pre>
<p>Out put:</p>
<pre><code>{'schema1': {'table1': ('column_name1', 'column_name2'), 
             'table2': ('column_name3',)}, 
 'schema2': {'table3': ('column_name4',)}}
</code></pre>
</div>
<span class="comment-copy">Post some code showing what you have tried so far.</span>
<span class="comment-copy">this is rather elegant, i have not used this particular pattern before</span>
<span class="comment-copy">@Chris_Rands, I sense sarcasm :)</span>
<span class="comment-copy">No I don't think @Chris_Rands knew this was a duplicate ;-)</span>
<span class="comment-copy">what's wrong with an <code>import</code> of <code>defaultdict</code>? it will likely be more performant too</span>
<span class="comment-copy">@Chris_Rands nothing is wrong with defaultdicts - but 2 other answers already used those - and its not needed. As for performace - I dont know which would be faster/better. One would have to test that.</span>
<span class="comment-copy">Re:Performance, <code>setdefault</code> is slower because the default is <i>always</i> created, even if the key exists (even though it isn't used in that situation). In the case of a defaultdict, it's better.</span>
