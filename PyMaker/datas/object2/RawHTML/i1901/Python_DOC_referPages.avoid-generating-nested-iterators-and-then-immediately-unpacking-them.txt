<div class="post-text" itemprop="text">
<p>In my some code I'm working on, I'm handling generating a lot of one-level deep nested iterators that need to be combined. As a working solution, I've wrapped each of these parts in <code>chain(*(one_level_nested))</code> (where <code>chain</code> is from the well-loved <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> module). However, repeating this expression several times makes me feel this expression is ugly and possibly misguided; </p>
<p>As an example of the one level deep generation code, most of them are constructed the following way: <code>[j for j in something_needing_i(i)] for i in range(5)</code> Thus I end up with <code>chain(*([j for j in something_needing_i(i)] for i in range(5)))</code>.</p>
<p>Is there a better approach, specifically in terms of generating the iterator without unpacking and with comparable efficiency (or ideally, better efficiency)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just use the following nesting:</p>
<pre><code>(j for i in range(5) for j in something_needing_i(i))
</code></pre>
<p>in order to get a flat generator. This also avoids the spurious intermediate lists for better space efficiency. </p>
<p>The order of the two <code>for</code> constructs may seem counter-intuitive at first as you have to turn them around in comparison to the one creating nested generators/lists. Also, their scoping does not correspond to my natural language "feel", but that's the way they work.</p>
</div>
<span class="comment-copy">Use a generator expression instead of a list comprehension.</span>
<span class="comment-copy">@MadPhysicist Actually, while my examples shows a list comprehension instead of a generator expression, I was actually using generator expressions in the original code. Whoops. Thanks for pointing that out.</span>
<span class="comment-copy">It's the order you would use for nested loops if you were to write them out.</span>
<span class="comment-copy">@MadPhysicist I am well aware =) it is still not the order you use to create nested generators. And in nested loops, the thing happening in the innermost loop comes <i>after</i> (inside) the loops, whereas here, the expression being yielded comes <i>before</i> them, moving one <code>j</code> away from the other which in NLP, would correspond to moving a node from its original place in the syntax tree.</span>
<span class="comment-copy">The order is very counter-intuitive for me. I think the counter-intuitive part is that the left side is the result, where in an actual for-loop, the right side would be the result. But once you get past that, it makes a lot of sense. Also, for completeness, looking at <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">the docs</a> probably could have cleared things up for me, but it didn't occur to me before asking. Thanks for the great answer!</span>
<span class="comment-copy">ordering of operations is always right to left, not the other way around. if I want to asign 5 to a , i write a = 5. If I first want to multiply by 3 I write a = 5 * 3. If I first want to convert the string 3 to an int I write a =  5 * int('3')</span>
<span class="comment-copy">@MarcWagner What about <code>a = 5 - 3 + 2</code></span>
