<div class="post-text" itemprop="text">
<p>In Python 3, the following code does not produce an error:</p>
<pre><code>slice(10.0)
</code></pre>
<p>while the following does:</p>
<pre><code>range(10.0)
</code></pre>
<p>If I try to use the <code>slice(float)</code> object, it will also fail:</p>
<pre><code>list(range(20))[slice(10.0)]
</code></pre>
<p>with the following error:</p>
<blockquote>
<p><code>TypeError: slice indices must be integers or None or have an __index__ method</code></p>
</blockquote>
<p>indicating that <code>slice()</code> could be used with some other object implementing the <code>__index__</code> method.</p>
<p>When / how to use <code>slice(obj)</code> for non-<code>int</code>/<code>None</code> types?</p>
<p>Why are <code>float</code> numbers allowed to be used when instantiating the <code>slice()</code> object?
Could I rely on <code>slice(float)</code> (and <code>slice(float, float)</code> and <code>slice(float, float, float)</code>) never complaining upon instantiation in Python 3?</p>
<h1>EDIT:</h1>
<p>This seems to be related to <a href="https://docs.python.org/2.5/whatsnew/pep-357.html" rel="nofollow noreferrer">PEP357</a><a href="https://docs.python.org/2.5/whatsnew/pep-357.html" rel="nofollow noreferrer">https://docs.python.org/2.5/whatsnew/pep-357.html</a></p>
<p>However, it is unclear to me if this has other uses beyond the implementation of the advanced indexing in <code>NumPy</code>.</p>
<p>EDIT3: EDIT2 basically contained the second part of the accepted answer with some syntax error, so it was removed</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you may pass objects of any type to <code>slice</code>. The <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer">documentation</a> makes no mention about restrictions for the type of slice's arguments, and the <a href="https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L111" rel="nofollow noreferrer">source code for slice's constructor</a> only says that "start, stop, and step are python objects".</p>
<p><code>list(range(20))[slice(10.0)]</code> rejects a slice object that has float arguments, but this seems to be specific to the list type. The data model itself does not do implicit type checking before calling <code>__getitem__</code>. You could write your own custom class that accepts more unconventional slices. Example:</p>
<pre><code>&gt;&gt;&gt; class Fred:
...     def __getitem__(self, idx):
...         return "baz"
...
&gt;&gt;&gt; x = Fred()
&gt;&gt;&gt; print(x[slice("Foo", "Bar")])
baz
&gt;&gt;&gt; print(x[1.0: -10.5])
baz
</code></pre>
<p>As for whether there's a <em>practical</em> reason to allow non-integer slices, none come to mind... But the Python community has a cultural norm of "we're all adults here". Which is to say, something should not be forbidden just because there's no obvious practical application for it. If someone wants to do something that seems silly, then all other things being equal, we should let them.</p>
<hr/>
<p>We've established that user-defined types can accept whatever kinds of slices they want. But what if you want to be able to slice built-in types with unusual slices? You can't change the list type's implementation in order to remove the type checking it does. <code>__index__</code> comes in handy as a way to define new types that can be used to slice lists. For example,</p>
<pre><code>&gt;&gt;&gt; class Begin:
...     def __index__(self):
...         return 0
...
&gt;&gt;&gt; class End:
...     def __index__(self):
...         return -1
...
&gt;&gt;&gt; list(range(20))[slice(Begin(), End())]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
</code></pre>
</div>
