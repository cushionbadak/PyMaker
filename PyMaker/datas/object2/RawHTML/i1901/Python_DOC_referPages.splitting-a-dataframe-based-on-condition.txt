<div class="post-text" itemprop="text">
<p>I am trying to split my dataframe into two based of <code>medical_plan_id</code>. If it is empty, into <code>df1</code>. If not empty into <code>df2</code>.</p>
<pre><code>df1 = df_with_medicalplanid[df_with_medicalplanid['medical_plan_id'] == ""]
df2 = df_with_medicalplanid[df_with_medicalplanid['medical_plan_id'] is not ""]
</code></pre>
<p>The code below works, but if there are no empty fields, my code raises <code>TypeError("invalid type comparison")</code>.</p>
<pre><code>df1 = df_with_medicalplanid[df_with_medicalplanid['medical_plan_id'] == ""]
</code></pre>
<p>How to handle such situation?</p>
<p>My df_with_medicalplanid looks like below:</p>
<pre><code>wellthie_issuer_identifier       ...       medical_plan_id
0                   UHC99806       ...                  None
1                   UHC99806       ...                  None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Use <code>==</code>, not <code>is</code>, to test equality</h3>
<p>Likewise, use <code>!=</code> instead of <code>is not</code> for inequality.</p>
<p><code>is</code> has a special meaning in Python. It returns <code>True</code> if two variables point to the same object, while <code>==</code> checks if the objects referred to by the variables are equal. See also <a href="https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python">Is there a difference between <code>==</code> and <code>is</code> in Python?</a>.</p>
<h3>Don't repeat mask calculations</h3>
<p>The Boolean masks you are creating are the most expensive part of your logic. It's also logic you want to <em>avoid</em> repeating manually as your first and second masks are inverses of each other. You can therefore use the <a href="https://stackoverflow.com/questions/8305199/the-tilde-operator-in-python">bitwise inverse</a> <code>~</code> ("tilde"), also accessible via <a href="https://docs.python.org/3/library/operator.html#operator.inv" rel="nofollow noreferrer"><code>operator.invert</code></a>, to negate an existing mask.</p>
<h3>Empty strings are different to null values</h3>
<p>Equality versus empty strings can be tested via <code>== ''</code>, but equality versus null values requires a specialized method: <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isnull.html" rel="nofollow noreferrer"><code>pd.Series.isnull</code></a>. This is because null values are represented in NumPy arrays, which are used by Pandas, by <code>np.nan</code>, and <code>np.nan != np.nan</code> <a href="https://stackoverflow.com/a/1573715/9209546">by design</a>.</p>
<p>If you want to replace empty strings with null values, you can do so:</p>
<pre><code>df['medical_plan_id'] = df['medical_plan_id'].replace('', np.nan)
</code></pre>
<p>Conceptually, it makes sense for missing values to be null (<code>np.nan</code>) rather than empty strings. But the opposite of the above process, i.e. converting null values to empty strings, is also possible:</p>
<pre><code>df['medical_plan_id'] = df['medical_plan_id'].fillna('')
</code></pre>
<p>If the difference matters, you need to <em>know your data</em> and apply the appropriate logic.</p>
<h3>Semi-final solution</h3>
<p>Assuming you do indeed have null values, calculate a single Boolean mask and its inverse:</p>
<pre><code>mask = df['medical_plan_id'].isnull()

df1 = df[mask]
df2 = df[~mask]
</code></pre>
<h3>Final solution: avoid extra variables</h3>
<p>Creating additional variables is something, as a programmer, you should look to avoid. In this case, there's no need to create two new variables, you can use <code>GroupBy</code> with <code>dict</code> to give a dictionary of dataframes with <code>False</code> (<code>== 0</code>) and <code>True</code> (<code>== 1</code>) keys corresponding to your masks:</p>
<pre><code>dfs = dict(tuple(df.groupby(df['medical_plan_id'].isnull())))
</code></pre>
<p>Then <code>dfs[0]</code> represents <code>df2</code> and <code>dfs[1]</code> represents <code>df1</code> (see also <a href="https://stackoverflow.com/a/52947460/9209546">this related answer</a>). A variant of the above, you can forego dictionary construction and use Pandas <code>GroupBy</code> methods:</p>
<pre><code>dfs = df.groupby(df['medical_plan_id'].isnull())

dfs.get_group(0)  # equivalent to dfs[0] from dict solution
dfs.get_group(1)  # equivalent to dfs[1] from dict solution
</code></pre>
<h3>Example</h3>
<p>Putting all the above in action:</p>
<pre><code>df = pd.DataFrame({'medical_plan_id': [np.nan, '', 2134, 4325, 6543, '', np.nan],
                   'values': [1, 2, 3, 4, 5, 6, 7]})

df['medical_plan_id'] = df['medical_plan_id'].replace('', np.nan)
dfs = dict(tuple(df.groupby(df['medical_plan_id'].isnull())))

print(dfs[0], dfs[1], sep='\n'*2)

   medical_plan_id  values
2           2134.0       3
3           4325.0       4
4           6543.0       5

   medical_plan_id  values
0              NaN       1
1              NaN       2
5              NaN       6
6              NaN       7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another variant is to unpack <code>df.groupby</code>, which returns an iterator with tuples (first item being the element of groupby and the second being the dataframe).</p>
<p>Like this for instance:</p>
<pre><code>cond = df_with_medicalplanid['medical_plan_id'] == ''
(_, df1) , (_, df2) = df_with_medicalplanid.groupby(cond)
</code></pre>
<p><code>_</code> is in Python used to mark variables that are not interested to keep. I have separated the code to two lines for readability.</p>
<hr/>
<p><strong>Full example</strong></p>
<pre><code>import pandas as pd 

df_with_medicalplanid = pd.DataFrame({
    'medical_plan_id': ['214212','','12251','12421',''],
    'value': 1
})

cond = df_with_medicalplanid['medical_plan_id'] == ''
(_, df1) , (_, df2) = df_with_medicalplanid.groupby()

print(df1)
</code></pre>
<p>Returns:</p>
<pre><code>  medical_plan_id  value
0          214212      1
2           12251      1
3           12421      1
</code></pre>
</div>
<span class="comment-copy">change <code>is not</code> to <code>!=</code> ?</span>
<span class="comment-copy">What dtype is in column <code>'medical_plan_id'</code>? If it is an integer or float, then comparing with "" will cause a type error. You could try using <code>.isnull()</code> instead</span>
<span class="comment-copy">I was using something like this to <code>fillna("")</code> .which I guess I shouldn't be using. Without this , None is coming wherever empty and the semi final solution is woking</span>
<span class="comment-copy">@user1896796, In my opinion, it makes sense that null values are <code>np.nan</code>, not empty strings, so I prefer <code>df['medical_plan_id'] = df['medical_plan_id'].replace('', np.nan)</code>. So I wouldn't use <code>fillna('')</code>.</span>
<span class="comment-copy">I tried printing this way <code>print ("In df1", dfs[0])</code>. I am getting     <code>print ("In df1", dfs[0]) KeyError: 0</code></span>
<span class="comment-copy">Apologies. updated the question with the dataframe. This is after I have removed fillna("") as per your comments.</span>
<span class="comment-copy">@user1896796, So do the solutions I outlined still fail? If so, we still need a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> which <b>demonstrates the problem</b>. See <a href="https://stackoverflow.com/questions/20109391/how-to-make-good-reproducible-pandas-examples">How to make good reproducible pandas examples</a> if you need help with this.</span>
