<div class="post-text" itemprop="text">
<p>So after going through multiple questions regarding the alignment using format specifiers I still can't figure out why the numerical data gets printed to stdout in a wavy fashion.</p>
<pre><code>def create_data(soup_object,max_entry=None):
    max_=max_entry
    entry=dict()
    for a in range(1,int(max_)+1):

        entry[a]={'Key':a,
        'Title':soup_object[a].div.text.strip(),
        'Link':soup_object[a].div.a['href'],
        'Seeds':soup_object[a](attrs={'align':'right'})[0].text.strip(),
        'Leechers':soup_object[a](attrs={'align':'right'})[1].text.strip()}

        yield entry[a]

tpb_get_data=tuple(create_data(soup_object=tpb_soup.body.table.find_all("tr"),max_entry=5))
for data in tpb_get_data:
    print('{0} {1:&lt;11}  {2:&lt;25} {3:&lt;25} '.format(data['Key'], data['Title'], data['Seeds'],data['Leechers']))
</code></pre>
<p>I tried using f-strings with the formatting specifiers but still it prints the data in the following way, can someone please help me figure this out.</p>
<pre><code> 1 Salvation.S02E11.HDTV.x264-KILLERS  262         19 
 2 Salvation.S02E13.WEB.x264-TBS[ettv]  229         25 
 3 Salvation.S02E08.HDTV.x264-KILLERS  178         21 
 4 Salvation.S02E01.HDTV.x264-KILLERS  144          11 
 5 Salvation.S02E09.HDTV.x264-SVA[ettv]  129       14
</code></pre>
<p>I have read most of the questions regarding this, I would like to know if there is a raw method rather than using a library like tabulate which does an excellent job. But I also want to learn how to do this without any library.</p>
</div>
<div class="post-text" itemprop="text">
<p>As already mentioned, you calculated lengths of strings incorrectly.<br/>
Instead of hardcoding them, delegate this task to your program.  </p>
<p>Here is a general approach:  </p>
<pre><code>from operator import itemgetter
from typing import (Any,
                    Dict,
                    Iterable,
                    Iterator,
                    List,
                    Sequence)


def max_length(objects: Iterable[Any]) -&gt; int:
    """Returns maximum string length of a sequence of objects"""
    strings = map(str, objects)
    return max(map(len, strings))


def values_max_length(dicts: Sequence[Dict[str, Any]],
                      *,
                      key: str) -&gt; int:
    """Returns maximum string length of dicts values for specific key"""
    return max_length(map(itemgetter(key), dicts))


def to_aligned_data(dicts: Sequence[Dict[str, Any]],
                    *,
                    keys: List[str],
                    sep: str = ' ') -&gt; Iterator[str]:
    """Prints a sequence of dicts in a form of a left aligned table"""
    lengths = (values_max_length(dicts, key=key) 
               for key in keys)

    format_string = sep.join(map('{{:{}}}'.format, lengths))

    for row in map(itemgetter(*keys), dicts):
        yield format_string.format(*row)
</code></pre>
<p><strong>Examples:</strong> </p>
<pre><code>data = [{'Key': '1',
         'Title': 'Salvation.S02E11.HDTV.x264-KILLERS',
         'Seeds': '262',
         'Leechers': '19'},
        {'Key': '2',
         'Title': 'Salvation.S02E13.WEB.x264-TBS[ettv]',
         'Seeds': '229',
         'Leechers': '25'},
        {'Key': '3',
         'Title': 'Salvation.S02E08.HDTV.x264-KILLERS',
         'Seeds': '178',
         'Leechers': '21'},
        {'Key': '4',
         'Title': 'Salvation.S02E01.HDTV.x264-KILLERS',
         'Seeds': '144',
         'Leechers': '11'},
        {'Key': '5',
         'Title': 'Salvation.S02E09.HDTV.x264-SVA[ettv]',
         'Seeds': '129',
         'Leechers': '14'}]
keys = ['Key', 'Title', 'Seeds', 'Leechers']
print(*to_aligned_data(data, keys=keys),
      sep='\n')
# 1 Salvation.S02E11.HDTV.x264-KILLERS   262 19
# 2 Salvation.S02E13.WEB.x264-TBS[ettv]  229 25
# 3 Salvation.S02E08.HDTV.x264-KILLERS   178 21
# 4 Salvation.S02E01.HDTV.x264-KILLERS   144 11
# 5 Salvation.S02E09.HDTV.x264-SVA[ettv] 129 14
keys = ['Title', 'Leechers']
print(*to_aligned_data(data, keys=keys),
      sep='\n')
# Salvation.S02E11.HDTV.x264-KILLERS   19
# Salvation.S02E13.WEB.x264-TBS[ettv]  25
# Salvation.S02E08.HDTV.x264-KILLERS   21
# Salvation.S02E01.HDTV.x264-KILLERS   11
# Salvation.S02E09.HDTV.x264-SVA[ettv] 14
keys = ['Key', 'Title', 'Seeds', 'Leechers']
print(*to_aligned_data(data, keys=keys, sep=' ' * 5),
      sep='\n')
# 1     Salvation.S02E11.HDTV.x264-KILLERS       262     19
# 2     Salvation.S02E13.WEB.x264-TBS[ettv]      229     25
# 3     Salvation.S02E08.HDTV.x264-KILLERS       178     21
# 4     Salvation.S02E01.HDTV.x264-KILLERS       144     11
# 5     Salvation.S02E09.HDTV.x264-SVA[ettv]     129     14
</code></pre>
<hr/>
<p>See <a href="https://docs.python.org/3.7/library/string.html#format-string-syntax" rel="nofollow noreferrer">docs</a> for more. There are examples with alignment as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You get a misaligned result because you did not count the length of the titles correct. You only reserved 11 characters, where the first is already 34 characters long.</p>
<p>Easiest is to have your program count for you:</p>
<pre><code>key_len,title_len,seed_len,leech_len = ( max(len(item[itemname]) for item in tpb_get_data) for itemname in ['Key','Title','Seeds','Leechers'] )

fmtstring = '{{:{:d}}} {{:{:d}}} {{:{:d}}} {{:{:d}}}'.format(key_len,title_len,seed_len,leech_len)

for data in tpb_get_data:
    print(fmtstring.format(data['Key'], data['Title'], data['Seeds'],data['Leechers']))
</code></pre>
<p>with the much better result</p>
<pre class="lang-none prettyprint-override"><code>1 Salvation.S02E11.HDTV.x264-KILLERS   262 19
2 Salvation.S02E13.WEB.x264-TBS[ettv]  229 25
3 Salvation.S02E08.HDTV.x264-KILLERS   178 21
4 Salvation.S02E01.HDTV.x264-KILLERS   144 11
5 Salvation.S02E09.HDTV.x264-SVA[ettv] 129 14
</code></pre>
<hr/>
<p>(Additional only)</p>
<p>Here is a more generalized approach that uses a list of to-print key names and is able to generate all other required variables on the fly. It does not need hardcoding the names of the variables nor fixating their order – the order is taken from that list. Adjustments of the items to show all go in one place: that same list, <code>get_items</code>. The output separator can be changed in the <code>fmtstring</code> line, for example using a tab or more spaces between the items.</p>
<pre><code>get_items = ['Key','Title','Leechers','Seeds']
lengths = ( max(len(item[itemname]) for item in tpb_get_data) for itemname in get_items )
fmtstring = ' '.join(['{{:{:d}}}' for i in range(len(get_items))]).format(*lengths)

for data in tpb_get_data:
    print(fmtstring.format(*[data[key] for key in get_items]))
</code></pre>
<p>It works as follows:</p>
<ol>
<li>The <code>lengths</code> list is filled with the maximum length of each named key taken from the <code>get_items</code> list.</li>
<li>This returns a <code>list</code>; the <code>fmtstring</code> repeats the format instruction <code>{:d}</code> for each of these items and fills in the number. The outer <code>{{:</code> and <code>}}</code> gets translated by <code>format</code> into <code>{:</code> and <code>}</code> so the end result will be <code>{:<em>number</em>}</code> for each length. These separate format strings are joined into a single longer format string.</li>
<li>Finally, the loop over the actual data prints the items from <code>get_items</code>. The list comprehension looks them up; the <code>*</code> notation forces the list to be 'written out' as separate values, instead of returning the entire list as one.</li>
</ol>
<p><sup>Thanks to <a href="https://stackoverflow.com/users/7851470/georgy">@Georgy</a> for suggesting to look for a less hardcoded variety.</sup></p>
</div>
<span class="comment-copy">You chose strange numbers for alignment. Why is it <code>1:&lt;11</code> when the length of those strings are at least 34? Try something like <code>'{0} {1:&lt;40} {2:&lt;3} {3:&lt;2}'</code>.</span>
<span class="comment-copy">Also, these are not f-strings! With <a href="https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals" rel="nofollow noreferrer">f-strings</a> you would have <code>print(f'{data['Key']} {data['Title']:&lt;40} {data['Seeds']:&lt;3} {data['Leechers']:&lt;2}')</code></span>
<span class="comment-copy">@Georgy I'm quite new to the formatting hence I didn't know what those numbers do. I know those aren't f-strings, I used them too but didn't post them here. Thanks for your input.</span>
<span class="comment-copy">This looks amazing, and clean. Can I know what the single asterisk argument in the function "values_max_length(dicts: Sequence[Dict[str, Any]],*, key: str) -&gt; int" mean?</span>
<span class="comment-copy">Never mind I found it, <a href="https://stackoverflow.com/questions/2965271/forced-naming-of-parameters-in-python/14298976#14298976" title="forced naming of parameters in python">stackoverflow.com/questions/2965271/…</a> sorry.</span>
<span class="comment-copy">Thanks I now see my foolishness. I never counted the length. @Georgy  also gave me the right answer. Thanks a lot for your input .</span>
<span class="comment-copy">This violates DRY</span>
<span class="comment-copy">@usr2564301 <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">The Zen of Python</a> says "<i>Flat is better than nested</i>" but now you have nested loops. There are still repetitions of <code>{{:{:d}}}</code> that could be avoided. And also, if user will decide to add a new key for printing, he will have to edit this code in 5 places! Check out my attempt on this: <a href="https://gist.github.com/LostFan123/554cac3e3586a01db512f895eeaa4001" rel="nofollow noreferrer">link</a>. I'll post it here if the question gets reopened. In any case, I take the downvote back as OP asked for the reason behind that misalignment, not the most pythonic solution :)</span>
