<div class="post-text" itemprop="text">
<p>Whenever I run part of my program that has a <code>threading.Lock</code> in it, my program stops running altogether (It does not crash, just pauses).</p>
<p>I need this as it is a server and multiple clients may be connecting and trying to overwrite the data all at the same time. At the time of running this, only one thread was active with a client connecting to it. I use this for my Sqlite3 databases too. I have not noticed it causing a problem there, as it seems to run perfectly fine despite the global lock. All are done in the same format of</p>
<pre><code>with global_lock:
</code></pre>
<p>Here is where the thread starts alongside how I import the thread</p>
<pre><code>from threading import Thread, Lock
global_lock = Lock()
while True:
    conn, addr = s.accept()
    connThread = Thread(target=handler, args=(conn, addr))
    connThread.daemon = True
    connThread.start()
</code></pre>
<p>Here is the program</p>
<pre><code>def addUser_InHash(username, password):

    print("Adding user in hash")
    hashID = 0
    hashString = username + password
    added = False
    for i in hashString:
        hashID += ord(i)
    hashID = hashID % hashKey
    print(hashID, "hashID in addUser")

    file = open("LoginHashTable.pickle", "rb+")
    if os.path.getsize("LoginHashTable.pickle") &gt; 0:
        hashTable = pickle.load(file)
        print("File not empty,\nSaved Data:\n{}".format(hashTable))

    else:
        print("File empty")
        hashTable = {}
    count = 0

    while not added:
        print("while not count :", count)
        count += 1
        if hashID in hashTable:
            # If this index exists
            if hashID &gt; (hashKey - 1):
                hashID = 0
            else:
                hashID += 1
                if hashID &gt; (hashKey - 1):
                    hashID = 0

        else:
            print("User doesnt exist, adding to hash table")
            hashTable[hashID] = [username, password]
            print("New Added")
            print(hashTable)
            added = True

    print("Saving updated file addUser_InHash")

    if hashTable:
        with global_lock:
            file.seek(0)  # Move file pointer back to beginning of file
            file.truncate()  # Empty file by truncating to current file pointer position
            pickle.dump(hashTable, file)
            print(hashTable)
            print("Data saved")
            file.close()
    else:
        print("Hash table still empty, addUser_InHash")


def deleteUser_InHash(username, password):


    print("In deleteUser_InHash\nUsername: {}\nPassword: {}".format(username,password))
    dataFound = True
    hashID = 0
    count = 0
    hashString = username + password

    if os.path.getsize("LoginHashTable.pickle") &gt; 0:
        file = open("LoginHashTable.pickle", "rb+")
        hashTable = pickle.load(file)
        print("File not empty,\nSaved Data:\n{}".format(hashTable))

    else:
        print("File empty")
        dataFound = False

    if dataFound:
        print("datafound true")
        for i in hashString:
            hashID += ord(i)
        hashID = hashID % hashKey
        print("hashID:",hashID)
        try:
            print("In try")
            while dataFound:
                print("In while, count:",count)
                if count == hashKey:
                    dataFound = False
                if hashTable[hashID] == [username,password]:
                    del hashTable[hashID]
                    print("Outside global lock")
                    with global_lock:
                        print("Inside global lock")
                        file.seek(0)  # Move file pointer back to beginning of file
                        file.truncate()  # Empty file by truncating to current file pointer position
                        pickle.dump(hashTable, file)
                        print(hashTable)
                        print("Data saved")
                        file.close()
                    print("Outside global lock")
                    print("Data updated")
                    print("User :", username, "deleted")
                    break
                else:
                    hashID += 1
                count += 1

        except IndexError:
            print("username could not be found")
            return False

    else:
        return False
</code></pre>
<p>The two functions are called in this sequence:</p>
<pre><code>deleteUser_InHash(username1,password1)
addUser_InHash(username2,password2)
</code></pre>
<p>The with global lock works fine in <code>deleteUser_InHash()</code> function but stops the program in <code>addUser_InHash()</code>.</p>
<p>The program hangs here:</p>
<pre><code>{33: ['foo', 'bar'], 0: ['toni', 'tony'], 34: ['bar', 'foo'], 118: ['fo', 'la'], 8: ['Tom', 'Tom'], 262: ['Kam', 'Kam'], 258: ['yes', 'no']}
Saving updated file addUser_InHash
</code></pre>
<p>Hanging on the line the piece of code:</p>
<pre><code>if hashTable:
    with global_lock:
</code></pre>
<p>I know this is true as it never gets to the print statements:</p>
<pre><code>print(hashTable)
print("Data saved")
</code></pre>
<p>Inside "addUser_InHash()"</p>
</div>
<div class="post-text" itemprop="text">
<p>Note to all: I changed </p>
<pre><code>global_lock = Lock()
</code></pre>
<p>to</p>
<pre><code>global_lock = RLock()
</code></pre>
<p>and now my program is running fine, I believe it has something to do with the fact that RLock allows threads to re-acquire a lock more than once, whilst it seems that normal locks cannot?</p>
<p>Source: <a href="https://docs.python.org/3/library/threading.html#thread-objects" rel="nofollow noreferrer">https://docs.python.org/3/library/threading.html#thread-objects</a></p>
</div>
<span class="comment-copy">Do you know where it's hanging?</span>
<span class="comment-copy">I have edited it in</span>
<span class="comment-copy">That helps, but I meant on exactly what line. You also need to add the code that starts the two threads running. It's possible that they are deadlocking (both waiting for the <code>Lock</code> to be releasedâ€”but I can't for sure tell yet.</span>
<span class="comment-copy">Only one thread is running at the time of me testing this code</span>
<span class="comment-copy">Will try my best, thank you for the support</span>
