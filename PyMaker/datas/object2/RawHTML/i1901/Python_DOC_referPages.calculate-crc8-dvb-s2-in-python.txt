<div class="post-text" itemprop="text">
<p>I need to calculate the crc8 dvb s2 checksum in python but I can't find any useful information on how this checksum really works, so I tried to convert this working C code:</p>
<pre><code>uint8_t crc8_dvb_s2(uint8_t crc, unsigned char a)

    {
        crc ^= a;
        for (int ii = 0; ii &lt; 8; ++ii) {
            if (crc &amp; 0x80) {
                crc = (crc &lt;&lt; 1) ^ 0xD5;
            } else {
                crc = crc &lt;&lt; 1;
            }
        }
        return crc;
    }
</code></pre>
<p>in python code:</p>
<pre><code>import crc8
import operator 
def bxor(b1, b2): # use xor for bytes
    return bytes(map(operator.xor, b1, b2))
def blshift(b1, b2): # use shift left for bytes
    return (int.from_bytes( b1, byteorder='little') &lt;&lt; int.from_bytes( b2, byteorder='little')).to_bytes(1, byteorder='little')
def _checksum(message): 
    #calculate crc
    crc = crc8.crc8()
    crc.update(message)
    crc_result = crc.digest()
    #calculate dvb
    crc_result = bxor(crc_result , message)
    for i in range(0, 7):
        if (crc_result == b'\x80') :
            crc_result = bxor((blshift(crc_result, b'\x01')) , b'\xD5')
        else:
            crc_result = blshift(crc_result, b'\x01')
    #-------------
    return crc_result;
</code></pre>
<p>But there is something wrong with it that I can't seem to understand.
If I give the C function the bytes '\x00d\x00\x00\x00' it gives my as a result '\x8f' ( which is right), while the Python function gives me the OverflowError: int too big to convert.</p>
<p>There's clearly something wrong with my code that makes the numbers bigger and bigger but I wasn't able to figure out what exactly.</p>
<p>Full backtrace: </p>
<pre><code>---------------------------------------------------------------------------
OverflowError                             Traceback (most recent call last)
&lt;ipython-input-226-8288eada1ce9&gt; in &lt;module&gt;
----&gt; 1 _checksum(b'\x00d\x00\x00\x00')

&lt;ipython-input-225-2e5beaea293f&gt; in _checksum(message)
     18             crc_result = bxor((blshift(crc_result, b'\x01')) , b'\xD5')
     19         else:
---&gt; 20             crc_result = blshift(crc_result, b'\x01')
     21     #-------------
     22     return crc_result;

&lt;ipython-input-225-2e5beaea293f&gt; in blshift(b1, b2)
      6     return bytes(map(operator.and_, b1, b2))
      7 def blshift(b1, b2): # use shift left for bytes
----&gt; 8     return (int.from_bytes( b1, byteorder='little') &lt;&lt; int.from_bytes( b2, byteorder='little')).to_bytes(1, byteorder='little')
      9 def _checksum(message):
     10     #calculate crc

OverflowError: int too big to convert
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The documentation of <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer"><code>int.to_bytes</code></a> says:</p>
<blockquote>
<p>An <code>OverflowError</code> is raised if the integer is not representable with
  the given number of bytes.</p>
</blockquote>
<p>It seems as if the number on which you use <code>.to_bytes(1, byteorder='little')</code> is larger than 255 (the highest number representable by one byte).</p>
<p>This:</p>
<blockquote>
<pre><code>int.from_bytes( b2, byteorder='little')).to_bytes(1, byteorder='little')
</code></pre>
</blockquote>
<p>can only work if <code>b2</code> is between 0 and 255, and I don't understand what would be the point of converting the same value from integer to bytes and back.</p>
<p>Do you intend to calculate the lowest 8 bits of the binary representation of <code>b2</code>? Then you should use <code>b2 % 256</code>.</p>
<hr/>
<p>You should be able to translate this C function almost literally to Python, without the need for helper functions like <code>bxor</code> or <code>blshift</code>:</p>
<pre><code>def crc8_dvb_s2(crc, a):
    crc ^= a
    for _ in range(8):
        if crc &amp; 0x80:
            crc = ((crc &lt;&lt; 1) ^ 0xD5) % 256
        else:
            crc = (crc &lt;&lt; 1) % 256
    return crc
</code></pre>
</div>
<span class="comment-copy">Please show the full traceback of the error. Specifically, you have shown multiple Python functions, and didn't tell us <i>which one</i> gives this error message.</span>
<span class="comment-copy">Yes, That doesn't give an error but the output is not correct, I need a unit8 int not an unit16 int(just like the c code).I'm not just converting bytes to int and that back to bytes.I'm converting b1 and b2 to int, performing a left shift and than converting the result back to bytes.</span>
<span class="comment-copy">Thank you very much!That almost works but there is a small problem: The crc value keeps getting bigger than 1 byte. This doesn't happen in C because the C xor function "cuts off" the end of the XORd value to fit in the char.</span>
<span class="comment-copy">Ah, I missed that. Truncation to one byte happens by assigning to an <code>uint8_t</code> variable, not by using xor. You can emulate that in Python by using the modulo operator, as I suggested before. See updated answer.</span>
