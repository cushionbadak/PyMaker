<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/44258903/scope-of-caught-exception-instance-in-python-2-and-3">Scope of caught exception instance in Python 2 and 3</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>Given the following code:</p>
<pre><code>msg = "test"
try:
    "a"[1]
except IndexError as msg:
    print("Error happened")
print(msg)
</code></pre>
<p>Can somebody explain why this causes the following output in Python 3?</p>
<pre class="lang-none prettyprint-override"><code>Error happened
Traceback (most recent call last):
  File "test.py", line 6, in &lt;module&gt;
    print(msg)
NameError: name 'msg' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>msg</code> in the except clause is in the same scope as <code>msg</code> on the first line.</p>
<p>But <a href="https://docs.python.org/3/reference/compound_stmts.html#except" rel="noreferrer">in Python 3 we have this new behavior too</a>:</p>
<blockquote>
<p>When an exception has been assigned using <code>as target</code>, it is cleared at
  the end of the except clause. This is as if</p>
<pre><code>except E as N:
    foo
</code></pre>
<p>was translated to</p>
<pre><code>except E as N:
    try:
        foo
    finally:
        del N
</code></pre>
<p>This means the exception must be assigned to a different name to be
  able to refer to it after the except clause. Exceptions are cleared
  because with the traceback attached to them, they form a reference
  cycle with the stack frame, keeping all locals in that frame alive
  until the next garbage collection occurs.</p>
</blockquote>
<p>so, you "overwrite <code>msg</code>" in the exception handler, and exiting the handler will delete the variable to clear the traceback reference cycle.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, as soon as the exception is raised and <code>msg</code> is assigned with the new exception object, the original object has no more reference and is therefore deleted. The new exception object is also deleted as soon as it leaves the <code>except</code> block.</p>
<p>You can verify it by overriding the <code>__del__</code> method of the object and the exception assigned to <code>msg</code>:</p>
<pre><code>class A:
    def __del__(self):
        print('object deleted')
class E(Exception):
    def __del__(self):
        print('exception deleted')
msg = A()
try:
    raise E()
except E as msg:
    print("Error happened")
</code></pre>
<p>This outputs:</p>
<pre><code>object deleted
Error happened
exception deleted
NameError: name 'msg' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Exception blocks delete the caught variable at the end of the block, but they do not have their own scopes. So the sequence of events goes:</p>
<p>1) <code>msg</code> is set to some string in the local scope</p>
<p>2) <code>msg</code> is set to an IndexError object in the same local scope as 1</p>
<p>3) <code>msg</code> is deleted from the local scope when the Exception block ends</p>
<p>4) <code>msg</code> is no longer defined in the local scope, so the attempt to access it fails</p>
</div>
<span class="comment-copy">This answers specifically the question how and why the previous <code>msg</code> gets deleted after the <code>except:</code>, including reference to the docs, so IMHO it should be the accepted answer.</span>
<span class="comment-copy">@LightnessRacesinOrbit Yeah, this is definitely strange. I mean: if you want a new scope then create a new scope and don't kill the reference to the first <code>msg</code>. If you don't want a new scope, then why kill the exception reference?</span>
<span class="comment-copy">It's not wonky at all. By using <code>except ... as msg</code> you're binding <code>msg</code> to the exception, which removes all references to the original object. Conversely, if <code>except ... as m</code> was used, it wouldn't result in any issue since the original binding <code>msg</code> isn't modified in the except block.</span>
<span class="comment-copy">@Shamtam As Giacomo explains, it’s <i>definitely</i> wonky. The way Python works, it rebinds <code>msg</code> <i>in the existing scope</i>. But the scope of <code>msg</code> exists beyond the <code>try</code> block (and would continue to, if no exception were raised). The fact that a <i>runtime condition</i> determines the scope of a variable (which should be static) is a crass subversion of the type system. Since Python is dynamically typed this of course works but it’s nevertheless weird. What’s more, Python 2 handles this completely differently, and as expected.</span>
<span class="comment-copy">@Shamtam "it's the way Python works": that is surely true.  Nobody is denying that.  But it doesn't mean that people shouldn't consider Python to be wonky.  Scope rules in "other popular languages" allow programmers using those languages to avoid the mental burden of keeping track of the names they've used before they got to the except block (or analogous) so as to be able to avoid using existing names in the block; the interpreter or compiler does it for them.</span>
<span class="comment-copy">The reason <code>msg</code> is deleted at the end of the <code>except</code> block has nothing to do with scope. They wanted to clear a reference cycle created by the addition of the <code>__traceback__</code> attribute in Python 3. See <a href="https://www.python.org/dev/peps/pep-3110/#semantic-changes" rel="nofollow noreferrer">PEP 3110</a>. It's definitely confusing, and there's a strong argument to be made that Python should stop trying to support running with the GC off, but it's not a scope issue.</span>
