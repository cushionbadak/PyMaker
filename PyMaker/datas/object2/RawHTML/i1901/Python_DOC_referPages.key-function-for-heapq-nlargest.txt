<div class="post-text" itemprop="text">
<p>I have a dictionary with <code>{key: count}</code>, say
<code>status_count = {'MANAGEMENT ANALYSTS': 13859, 'COMPUTER PROGRAMMERS': 72112}</code>
and I am trying to write a key function for heapq.nlargest() that sorts based on count and if there are ties I have to sort based on alphabetical order(a-z) of keys. I have to use heapq.nlargest because of very large N and small k = 10. </p>
<p>This is what I got until now, </p>
<p><code>top_k_results = heapq.nlargest(args.top_k, status_count.items(), key=lambda item: (item[1], item[0]))
</code>
But, this would be incorrect in case of breaking ties with alphabetical order. Please help!</p>
</div>
<div class="post-text" itemprop="text">
<p>Simplest may be to switch to <code>heapq.nsmallest</code> and redefine your sort key:</p>
<pre><code>from heapq import nsmallest

def sort_key(x):
    return -x[1], x[0]

top_k_results = nsmallest(args.top_k, status_count.items(), key=sort_key)
</code></pre>
<p>Alternatively, you can use <a href="https://docs.python.org/3/library/functions.html#ord" rel="nofollow noreferrer"><code>ord</code></a> and take the negative for ascending order:</p>
<pre><code>from heapq import nlargest

def sort_key(x):
    return x[1], [-ord(i) for i in x[0]]

top_k_results = nlargest(args.top_k, status_count.items(), key=sort_key)
</code></pre>
<p>Remember to use <a href="https://docs.python.org/3/library/stdtypes.html#str.casefold" rel="nofollow noreferrer"><code>str.casefold</code></a> if you need to normalize the case of your string.</p>
</div>
<span class="comment-copy">Can you show a sample of the dictionary you are working on?</span>
<span class="comment-copy">@Austin I just updated the question with details.</span>
<span class="comment-copy">Thank you for the answer. I have strings with length &gt; 1 and <code>ord()</code> would accept only strings of length 1 I guess. Is there a way to overcome this?</span>
<span class="comment-copy">@Ram, Sure, see update.</span>
