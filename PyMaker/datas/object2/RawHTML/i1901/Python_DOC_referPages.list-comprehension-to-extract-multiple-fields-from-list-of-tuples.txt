<div class="post-text" itemprop="text">
<p>I have a list of tuples</p>
<pre><code>servers = [('server1', 80 , 1, 2), ('server2', 443, 3, 4)]
</code></pre>
<p>I want to create a new list that only has the first two fields   as in:</p>
<pre><code> [('server1', 80), ('server2', 443)]
</code></pre>
<p>but I cannot see how to craft a list comprehension for more than one element.</p>
<pre><code>hosts = [x[0] for x in servers]  # this works to give me ['server1', server2']

hostswithports = [x[0], x[1] for x in servers] # this does not work
</code></pre>
<p>I prefer to learn the pythonic way vs using a loop - what am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">extended iterable unpacking</a>.</p>
<pre><code>&gt;&gt;&gt; servers = [('server1', 80 , 1, 2), ('server2', 443, 3, 4)]
&gt;&gt;&gt; [(server, port) for server, port, *_ in servers]
[('server1', 80), ('server2', 443)]
</code></pre>
<p>Using <code>_</code> as a throwaway placeholder-name is a common convention.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you were doing was <em>almost</em> right. You were attempting to translate each tuple in your list into a new tuple. But you forgot to actually declare the tuple. That's what the parentheses are doing:</p>
<pre><code>hosts = [(x[0], x[1]) for x in servers]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using basic slicing, which has the benefit of not failing if any of your list elements don't have the expected number of sub-elements.</p>
<pre><code>[el[:2] for el in servers]
</code></pre>
<p></p>
<pre><code>[('server1', 80), ('server2', 443)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">itemgetter</a>:</p>
<pre><code>from operator import itemgetter


servers = [('server1', 80 , 1, 2), ('server2', 443, 3, 4)]

result = list(map(itemgetter(0, 1), servers))

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[('server1', 80), ('server2', 443)]
</code></pre>
<p>A more readable alternative is the following:</p>
<pre><code>from operator import itemgetter

get_server_and_port = itemgetter(0, 1)
servers = [('server1', 80, 1, 2), ('server2', 443, 3, 4)]
result = [get_server_and_port(e) for e in servers]

print(result)  # [('server1', 80), ('server2', 443)]
</code></pre>
</div>
<span class="comment-copy"><i>loops are pythonic</i></span>
<span class="comment-copy">This is the only one that, by only looking at the line in question, I have any idea what is happening. Readability matters: +1</span>
<span class="comment-copy">... and for older versions, <code>[(server, port) for server, port, _, _ in servers]</code> works just as well.</span>
<span class="comment-copy">@tobias_k it is worth noting it handles things differently: <code>a, b, *_</code> will accept elements with at least two sub-elements. <code>a, b, _, _</code> only accepts elements with 4 sub-elements. So they are different in how they handle data that doesn't conform to the example. But with conforming data, they are the same... and in Py2.7 you don't get the choice ;)</span>
<span class="comment-copy">I see I was just missing enclosing parentheses but I really like the readability of this approach</span>
<span class="comment-copy">@TemporalWolf Of course, I thought that was clear, but you are right: OP actually never says anything about the shape of the lists, just that the first two elements are needed, so it might indeed be irregular.</span>
<span class="comment-copy">Thanks - I could have sworn I tried that too but obviously I did not!</span>
<span class="comment-copy">@Bill If I had a nickel for every time I did that . . . I'd be able to buy a steak dinner at least</span>
<span class="comment-copy">Instead of a list generator based on “identity” transformation you could simply call the list constructor on the iterable <code>map</code> object:  <code>result = list(map(itemgetter(0, 1), servers))</code>. Otherwise +1 for the smart use of <code>itemgetter</code>.</span>
<span class="comment-copy">An minor alternative would be to pass a slice object to itemgetter: <code>itemgetter(slice(n))</code> is equivalent to <code>itemgetter(0, 1, 2, ..., n-1)</code> in case you want to select a non-trivially sized index range. You can call the slice constructor with 2 or 3 arguments for ranges starting after the first element or ranges that skip indices respectively like with subscript slice expressions (<code>foo[start : stop : step]</code>).</span>
