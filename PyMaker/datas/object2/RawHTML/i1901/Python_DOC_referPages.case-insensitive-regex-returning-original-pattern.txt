<div class="post-text" itemprop="text">
<p>If I am looking for a small list of words (these words change dynamically) in a paragraph and want a case insensitive search, I use a pattern like:</p>
<pre><code>words = ['Cat', 'Dog', 'Horse']
reg = re.compile(r"(?i)(\b)(?P&lt;word&gt;" + "|".join(words) + r")(\b)")
</code></pre>
<p>which turns into this pattern string:</p>
<pre><code>r"(?i)(\b)(?P&lt;word&gt;Cat|Dog|Horse)(\b)"
</code></pre>
<p>This works to find a match in text like the following using re.search():</p>
<pre><code>reg.search('I own a black cat named Sally.')
# Returns one match on 'cat'
</code></pre>
<p>How do I return the actual word in the original match pattern? In this case the word "Cat" with a capital C and not the word in the search text with a lowercase c. </p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

words = ['Cat', 'Dog', 'Horse']
reg = re.compile(r"\b(?:(" + ")|(".join(words) + r"))\b", flags=re.I)

match = reg.search('My grandma owned no cats, only a black doG named Morli.'
                   ' Oh, and no horse, of course.')
if match:
    print(words[match.lastindex - 1])
</code></pre>
<p>prints</p>
<pre><code>Dog
</code></pre>
<p>This builds a regex like <code>\b(?:(Cat)|(Dog)|(Horse))\b</code>, i.e., a non-capturing group (this is the meaning of <code>?:</code>) surrounded by word boundaries (the <code>\b</code>s), which is an alternation of capturing groups. The index of the last (and only, if any) matching capturing group is returned in <a href="https://docs.python.org/3/library/re.html#re.Match.lastindex" rel="nofollow noreferrer"><code>match.lastindex</code></a>, but this is also the index in the <code>words</code> list (because of how the regex was constructed), except it is offset by 1 because group 0 is the full match.</p>
<p>The set of words found in the text is easily constructed by</p>
<pre><code>words_found = {words[match.lastindex - 1] for match in reg.finditer(text)}
</code></pre>
<p><br/></p>
<hr/>
<p>The following is an edit by Patrick Artner, of which I don't think it's an improvement - but I'll leave it here because it is food for thought.</p>
<p>Edit - pls, incorporate:</p>
<pre><code>all_matches = reg.findall('My grandma owned no cat, only a black doG named Morli.A cat named tinker came by.'
                          ' Oh, and no horse, of course.')
found = [ words[idx] for k in all_matches for idx,m in enumerate(k) if m.strip()  ]

print(found) # ['Cat', 'Dog', 'Cat', 'Horse'] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Somewhat clumsy with a workaround-dict that maps back from the regex-group-match to your original keyword - but should help you out:</p>
<pre><code>import re

def getWordsFromText(text,keywords = ['Cat', 'Dog', 'Horse']):
    """Builds a dict for keywords, returns the original spelling if something is found
    case insensitivly in the given text.

    Returns a (potentially empty) generator with results."""
    d = {w.lower():w for w in keywords}

    # pattern inspired by  Wiktor Stribi≈ºew
    reg = re.compile(rf"\b(?:{'|'.join(d)}\b)", flags=re.I)
    for m in reg.finditer(text):
        yield d[m.group().lower()]

print(list(getWordsFromText('I own a black cat named Sally. And a dOg called Jack.')))
print(list(getWordsFromText('I own a blue whale named Sally.')))
</code></pre>
<p>Output:</p>
<pre><code>['Cat', 'Dog']
[]
</code></pre>
</div>
<span class="comment-copy">you look for <code>cat</code> with flag caseinsensivity and want to get <code>Cat</code> back regardless how it was spelled in the text you search trough?</span>
<span class="comment-copy">Yes, I am looking for keywords that are stored in a db table. However they are capitalized in text, I want to match on them and then increment a counter in the database. The keywords are the index key so I want the regex match to return the keyword exactly as it appears in the database.</span>
<span class="comment-copy">Have a look - with that it is about the same - w/o using a dict.</span>
<span class="comment-copy">somewhat clumsy is an understatement</span>
<span class="comment-copy">@WalterTross  ping me back when you posted your solution :)</span>
<span class="comment-copy">I was going to post it, then I realised that yours essentially did what I had in mind, but was definitely written <i>much</i> better</span>
<span class="comment-copy">uhm, now that I think of it, there <i>is</i> another solution... (although I don't think it's really better)</span>
<span class="comment-copy">(... or maybe it is?)</span>
