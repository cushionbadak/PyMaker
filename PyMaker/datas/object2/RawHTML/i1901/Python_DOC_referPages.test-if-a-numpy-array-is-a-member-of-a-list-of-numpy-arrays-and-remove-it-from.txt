<div class="post-text" itemprop="text">
<p>When testing if a numpy array <code>c</code> is member of a list of numpy arrays <code>CNTS</code>:</p>
<pre><code>import numpy as np

c = np.array([[[ 75, 763]],
              [[ 57, 763]],
              [[ 57, 749]],
              [[ 75, 749]]])

CNTS = [np.array([[[  78, 1202]],
                  [[  63, 1202]],
                  [[  63, 1187]],
                  [[  78, 1187]]]),
        np.array([[[ 75, 763]],
                  [[ 57, 763]],
                  [[ 57, 749]],
                  [[ 75, 749]]]),
        np.array([[[ 72, 742]],
                  [[ 58, 742]],
                  [[ 57, 741]],
                  [[ 57, 727]],
                  [[ 58, 726]],
                  [[ 72, 726]]]),
        np.array([[[ 66, 194]],
                  [[ 51, 194]],
                  [[ 51, 179]],
                  [[ 66, 179]]])]

print(c in CNTS)
</code></pre>
<p>I get:</p>
<blockquote>
<p>ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</p>
</blockquote>
<p>However, the answer is rather clear: <code>c</code> is exactly <code>CNTS[1]</code>, so <code>c in CNTS</code> should return True!</p>
<p><strong>How to correctly test if a numpy array is member of a list of numpy arrays?</strong></p>
<p>The same problem happens <strong>when removing</strong>:</p>
<pre><code>CNTS.remove(c)
</code></pre>
<blockquote>
<p>ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</p>
</blockquote>
<p>Application: test if an <code>opencv</code> contour (numpy array) is member of a list of contours, see for example <a href="https://stackoverflow.com/questions/53051275/remove-an-opencv-contour-from-a-list-of-contours">Remove an opencv contour from a list of contours</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are getting the error because <code>in</code> essentially invokes <code>bool(c == x)</code> on every element <code>x</code> of <code>CNTS</code>. It's the <code>__bool__</code> conversion that is raising the error:</p>
<pre><code>&gt;&gt;&gt; c == CNTS[1]
array([[[ True,  True]],
       [[ True,  True]],
       [[ True,  True]],
       [[ True,  True]]])

&gt;&gt;&gt; bool(_)
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<p>The same applies for removal, since it tests for equality with each element.</p>
<p><strong>Containment</strong></p>
<p>The solution is to use <code>np.array_equal</code> or apply the <code>all</code> method to each comparison:</p>
<pre><code>any(np.array_equal(c, x) for x in CNTS)
</code></pre>
<p>OR</p>
<pre><code>any((c == x).all() for x in CNTS)
</code></pre>
<p><strong>Removal</strong></p>
<p>To perform the removal, you are more interested in the index of the element than its existence. The fastest way I can think of is to iterate over the indices, using the elements of <code>CNTS</code> as comparison keys:</p>
<pre><code>index = next((i for i, x in enumerate(CNTS) if (c == x).all()), -1)
</code></pre>
<p>This option short circuits quite nicely, and returns <code>-1</code> as the default index rather than raising a <code>StopIteration</code>. You can remove the argument <code>-1</code> to <code>next</code> if you prefer the error. If you prefer, you can replace <code>(c == x).all()</code> with <code>np.array_equal(c, x)</code>.</p>
<p>Now you can remove as usual:</p>
<pre><code>del CNTS[index]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution could work for this case:</p>
<pre><code>def arrayisin(array, list_of_arrays):
    for a in list_of_arrays:
        if np.array_equal(array, a):
            return True
    return False
</code></pre>
<p>This function iterates over a list of arrays and tests the equality against some other array. So the usage would be:</p>
<pre><code>&gt;&gt;&gt; arrayisin(c, CNTS)
True
</code></pre>
<p>To remove the array from the list, you can get the index of the array and then use <code>list.pop</code>. In the function <code>get_index</code>, we enumerate the list of arrays, meaning we zip the indices of the list and the contents of the list. If there is a match, we return the index of the match.</p>
<pre><code>def get_index(array, list_of_arrays):
    for j, a in enumerate(list_of_arrays):
        if np.array_equal(array, a):
            return j
    return None

idx = get_index(c, CNTS)  # 1
CNTS.pop(idx)
</code></pre>
<p>Please see the python data structures tutorial for the documentation of <code>list.pop</code> <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>del</code> to delete the index of the list you want to remove.</p>
<pre><code>del CNTS[int(np.where(list(np.array_equal(row, c) for row in CNTS))[0])]

CNTS

[array([[[  78, 1202]],

        [[  63, 1202]],

        [[  63, 1187]],

        [[  78, 1187]]]), array([[[ 72, 742]],

        [[ 58, 742]],

        [[ 57, 741]],

        [[ 57, 727]],

        [[ 58, 726]],

        [[ 72, 726]]]), array([[[ 66, 194]],

        [[ 51, 194]],

        [[ 51, 179]],

        [[ 66, 179]]])]
</code></pre>
</div>
<span class="comment-copy">@DavidG the real problem (for the <a href="https://stackoverflow.com/questions/53051275/remove-an-opencv-contour-from-a-list-of-contours">application</a>) is not only test membership, but also remove a numpy array from a list of numpy arrays, I added more details to the question. It's not really a duplicate.</span>
<span class="comment-copy">I think you can use <code>bool(sum((map(lambda x: np.array_equal(x,c), CNTS))))</code></span>
<span class="comment-copy">@RudolfMorkovskyi. You could just use <code>any</code>, which would also do short-circuiting</span>
<span class="comment-copy">Are all the arrays going to be the same size?</span>
<span class="comment-copy">@MadPhysicist No, those arrays are <i>contours</i>, i.e. list of points, it can be a rectangle (4 points), pentagon (5 points), etc.</span>
<span class="comment-copy">Thank you @MadPhysicist. As I mentioned in the edited question, the goal is to test membership to finally remove it (if present in the list of numpy arrays). How would you do the latter?</span>
<span class="comment-copy">@Basj. Updated to include removal</span>
<span class="comment-copy">I'd love to know why I have a downvote.</span>
<span class="comment-copy">Weird indeed (I upvoted all the 3 answers) @MadPhysicist!</span>
<span class="comment-copy">Thank you @Jakub. As I mentioned in the question, the goal is to test membership to finally remove it (if present in the list of numpy arrays). How would you do that?</span>
<span class="comment-copy">@Basj - please see my edits</span>
<span class="comment-copy">@Basj - if you used this answer, can you please mark it as correct?</span>
<span class="comment-copy">This does not short circuit, and creates an extra numpy array, just to call np.where...</span>
<span class="comment-copy">Thanks @MadPhysicist, answer modified</span>
<span class="comment-copy">I tried running your updated code and it does not work as advertised. np.where will wrap any input in an array. Generators do not get expanded, so it gives you index 0 no matter what (since a generator object is truthy).</span>
<span class="comment-copy">I would recommend going back to your original answer with <code>list</code>. While not optimal, it worked perfectly.</span>
<span class="comment-copy"><code>int(np.where(list(np.array_equal(row, c) for row in CNTS))[0])</code> -&gt; 1, <code>int(np.where((np.array_equal(row, c) for row in CNTS))[0])</code> -&gt; 0. I'm using numpy 1.14.2. Perhaps in version 15, generators are expanded?</span>
