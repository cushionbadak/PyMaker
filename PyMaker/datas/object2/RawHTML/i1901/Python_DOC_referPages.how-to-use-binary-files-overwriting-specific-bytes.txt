<div class="post-text" itemprop="text">
<p>I'm writing a program in python, and would like to be able to write to specific bytes in a binary file. I tried to do this in the shell with a small binary file containing the numbers 0 through 15, but I can't figure out how to do so. Below is the code I just entered into the shell with comments to demonstrate what I am trying to do:</p>
<pre><code>&gt;&gt;&gt; File=open("TEST","wb") # Opens the file for writing.
&gt;&gt;&gt; File.write(bytes(range(16))) # Writes the numbers 0 through 15 to the file.
16
&gt;&gt;&gt; File.close() # Closes the file.
&gt;&gt;&gt; File=open("TEST","rb") # Opens the file for reading, so that we can test that its contents are correct.
&gt;&gt;&gt; tuple(File.read()) # Expected output: (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
&gt;&gt;&gt; File.close() # Closes the file.
&gt;&gt;&gt; File=open("TEST","wb") # Opens the file for writing.
&gt;&gt;&gt; File.seek(3) # Moves the pointer to position 3. (Fourth byte.)
3
&gt;&gt;&gt; File.write(b"\x01") # Writes 1 to the file in its current position.
1
&gt;&gt;&gt; File.close() # Closes the file.
&gt;&gt;&gt; File=open("TEST","rb") # Opens the file for reading, so that we can test that its contents are correct.
&gt;&gt;&gt; tuple(File.read()) # Expected output: (0, 1, 2, 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
(0, 0, 0, 1)
&gt;&gt;&gt; File.close()
&gt;&gt;&gt; File=open("TEST","wb") # I will try again using apend mode to overwrite.
&gt;&gt;&gt; File.write(bytes(range(16)))
16
&gt;&gt;&gt; File.close()
&gt;&gt;&gt; File=open("TEST","ab") # Append mode.
&gt;&gt;&gt; File.seek(3)
3
&gt;&gt;&gt; File.write(b"\x01")
1
&gt;&gt;&gt; File.close()
&gt;&gt;&gt; File=open("TEST","rb")
&gt;&gt;&gt; tuple(File.read()) # Expected output: (0, 1, 2, 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1)
&gt;&gt;&gt; File.close()
</code></pre>
<p>My desired output is as shown, but <code>"wb"</code> seems to erase all the data in the file, while <code>"ab"</code> can't seek backwards.</p>
<p>How would I achieve my desired output without rewriting the whole file?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you open a file for writing with <code>w</code>, the file is <em>truncated</em>, all contents removed. You need to open the file for reading and writing with <code>r+</code> instead. From the <code>open()</code> function documentation:</p>
<blockquote>
<p><code>'w'</code>     open for writing, <strong>truncating the file first</strong></p>
</blockquote>
<p>and</p>
<blockquote>
<p>For binary read-write access, the mode 'w+b' opens and truncates the file to 0 bytes. 'r+b' opens the file without truncation.</p>
</blockquote>
<p>Because the file was truncated first, seeking to position 3 then writing <code>\x01</code> has the first few bytes filled in with <code>\x00</code> for you.</p>
<p>Opening a file in append mode usually restricts access to the new portion of the file only, so anything past the first 16 bytes. Again, from the documentation:</p>
<blockquote>
<p>Other common values are [...] and <code>'a'</code> for appending (<strong>which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position</strong>).</p>
</blockquote>
<p>(<em>bold emphasis in quoted sections mine</em>). This is why your <code>\x01</code> byte ends up right at the end in spite of the <code>File.seek(3)</code> call.</p>
<p><code>r</code> does not truncate a file and gives you full range of the contents with <code>seek()</code>; <code>r+</code> adds write access to that mode. Demo with <code>'r+b'</code>:</p>
<pre><code>&gt;&gt;&gt; with open('demo.bin', 'wb') as f:
...     f.write(bytes(range(16)))
...
16
&gt;&gt;&gt; with open('demo.bin', 'rb') as f:
...     print(*f.read())
...
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
&gt;&gt;&gt; with open('demo.bin', 'r+b') as f:  # read and write mode
...     f.seek(3)
...     f.write(b'\x01')
...
3
1
&gt;&gt;&gt; with open('demo.bin', 'rb') as f:
...     print(*f.read())
...
0 1 2 1 4 5 6 7 8 9 10 11 12 13 14 15
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution is another mode: <code>"r+b"</code>. (as shown by other answers.)</p>
<p>Here is the solution in the shell from where the file left off:</p>
<pre><code>&gt;&gt;&gt; File=open("TEST","r+b") # Opens file for reading and writing.
&gt;&gt;&gt; File.seek(3)
3
&gt;&gt;&gt; File.write(b"\x01")
1
&gt;&gt;&gt; File.close()
&gt;&gt;&gt; File=open("TEST","rb")
&gt;&gt;&gt; tuple(File.read()) # Expected output: (0, 1, 2, 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1)
(0, 1, 2, 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1)
&gt;&gt;&gt; File.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I remember properly, you have to open the file in "Append mode" or it will simply erase everything and start from scratch, and then when you use <code>seek(3)</code> you just create those 3 0's and then you write the 1. I'll investigate further on how to write directly to a position but you may have to read the whole file, modify, write the whole file again.</p>
<p>You can actually read about this behaviour in <a href="https://docs.python.org/3/tutorial/inputoutput.html" rel="nofollow noreferrer">the documentation</a>: </p>
<blockquote>
<p>'w' for only writing (an existing file with the same name will be erased)</p>
</blockquote>
</div>
<span class="comment-copy">I have shown in my question that append mode doesn't work in this situation.</span>
<span class="comment-copy">Or rather, that append mode does work - it enforces that writes go to the end. It is specifically not meant for modifying existing contents.</span>
<span class="comment-copy">Yeah, maybe I wrote a bit too fast since I had to go toa meeting but wasn't intending that append mode was your solution here :) Martijin did a much better work at explaining how to solve your problem.</span>
