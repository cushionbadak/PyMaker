<div class="post-text" itemprop="text">
<p>If I had a list like this:</p>
<pre><code>L = [
           ['a', 'b'], 
           ['c', 'f'], 
           ['d', 'e']
       ]
</code></pre>
<p>I know that I could check if e.g. <code>'f'</code> was contained in any of the sub lists by using <code>any</code> in the following way:</p>
<pre><code>if any('f' in sublist for sublist in L) # True
</code></pre>
<p>But how would I go about searching through second sub lists, i.e. if the list was initialized the following way:</p>
<pre><code>L = [
           [
               ['a', 'b'], 
               ['c', 'f'], 
               ['d', 'e']
           ], 
           [
               ['z', 'i', 'l'],
               ['k']
           ]
       ]
</code></pre>
<p>I tried chaining the <code>for in</code> expressions like this:</p>
<pre><code>if any('f' in second_sublist for second_sublist in sublist for sublist in L)
</code></pre>
<p>However, this crashes because <code>name 'sublist' is not defined</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>First write your logic as a <em>regular</em> <code>for</code> loop:</p>
<pre><code>for first_sub in L:
    for second_sub in first_sub:
        if 'f' in second_sub:
            print('Match!')
            break
</code></pre>
<p>Then rewrite as a generator expression with the <code>for</code> statements in the same order:</p>
<pre><code>any('f' in second_sub for first_sub in L for second_sub in first_sub)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>any</code> twice, like this:</p>
<pre><code>if any(any('f' in secondsublist for secondsublist in sublist) for sublist in list) # True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't need to know where 'f' is located you can leverage <code>itertools</code> here as well.</p>
<pre><code>import itertools

any('f' in x for x in itertools.chain.from_iterable(l))
</code></pre>
<p>This will flatten your nested lists and evaluate each list separately.  The benefit here is if you have three nested lists this solution would still function without having to continue writing nest <code>for</code> loops.</p>
</div>
<span class="comment-copy">Side note: don't shadow built-in <code>list</code>.</span>
<span class="comment-copy">Don't call your variable <code>list</code>. Call it something else: like <code>L</code>, or <code>lst</code>. If you need to use the built-in <a href="https://docs.python.org/3/library/functions.html#func-list" rel="nofollow noreferrer"><code>list</code></a> later, you won't be able to.</span>
<span class="comment-copy">@jpp I did that only for the sake of making it easy to read (imo). I would also use tuples if I wanted to create a static "list" like that.</span>
<span class="comment-copy">No, it makes it harder to read / more prone to error. Anyone copying / pasting your code will find their session doesn't allow <code>list</code> later in their code. You can just use <code>L</code> (less characters too, if ease of reading is your objective).</span>
<span class="comment-copy">@jpp I believe that is up to the reader, but I also think that it is valid to not shadow the <code>list</code> function, which is why I adjusted it.</span>
<span class="comment-copy">I would choose <code>chain.from_iterable</code> instead.</span>
<span class="comment-copy">@Austin- good call.  That's a little cleaner.</span>
