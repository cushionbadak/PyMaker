<div class="post-text" itemprop="text">
<p>I find myself frequently creating sets of named objects where each object has a unique name.  I implement these as <code>dict</code>s whose keys are derived from <code>myObject.name</code>.  But this feels a bit clunky to keep the name in two places.</p>
<p>My typical approach looks like this:</p>
<pre><code>class NamedObject(object):
    ITEMS = {}

    def __init__(self, name, ...other arguments...):
        self.name = name
        ...more initialization...

    @classmethod
    def create_named_object(cls, name, ...other arguments...):
        obj = cls(name, ...other arguments...)
        cls.ITEMS[name] = obj

    @classmethod
    def find_object_by_name(cls, name):
        return cls.ITEMS.get(name, None)

    @classmethod
    def filter_objects(cls, predicate):
        return [e for e in cls.ITEMS.values() if predicate(e)]
</code></pre>
<p>I know I could create a generalized class to handle this, but is there a more naturally Pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no more generalised support in the standard library, no, nor is there any more 'Pythonic' way to achieve this than using a dictionary.</p>
<p>What you are doing is providing an <a href="https://en.wikipedia.org/wiki/Lookup_table" rel="nofollow noreferrer"><em>lookup table index</em></a>, and indices generally require some duplication of data. You are trading memory for access speed. But indices are <em>use-case specific</em> and either trivially implemented with a mapping, or too specific to the application to be generalisable to the level that adding that to the language library makes sense.</p>
<p>At least in Python, the string value for the name is not actually duplicated; you just add more references to it; once from the instance and another time from the <code>ITEMS</code> dictionary.</p>
</div>
<span class="comment-copy">Thanks - I wasn't so worried about using extra storage as much as the conceptual overhead of keeping two references to the same string.  What I'd find useful is a 'key' argument to the <code>set</code> (or <code>frozenset</code>) class that lets you use an accessor on an object rather than the object itself for determining keys for the <code>set</code> (or <code>frozenset</code>).</span>
<span class="comment-copy">You mean like <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow noreferrer"><code>__hash__</code> and <code>__eq__</code></a>? You can trivially create a wrapper object that implements hashing and equality testing based on an attribute you name (or a key function), or have the class implement these directly.  A wrapper adds a bit of overhead though (I'd make sure to use <code>__slots__</code> and cache the key function outcome and hash).</span>
