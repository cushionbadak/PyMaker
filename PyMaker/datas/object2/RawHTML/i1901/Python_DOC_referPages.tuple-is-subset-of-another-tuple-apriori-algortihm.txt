<div class="post-text" itemprop="text">
<p>I'm trying to implement the apriori algorithm. In one of the final steps I have two arrays of tuples generated from a list of products.</p>
<pre><code>&gt;&gt;&gt; arr1 = array([(2421,), (35682,), (30690,), ..., (18622,), (18285,), (31269,)],
  dtype=object)

&gt;&gt;&gt; arr2 = array([(2421, 35682), (2421, 30690), (2421, 24852), ..., (18622, 18285),
   (18622, 31269), (18285, 31269)], dtype=object))
</code></pre>
<p>The think is that I need to check which of <code>arr1</code> are subtuples of <code>arr2</code>, i.e. <code>(2421, )</code> is a subtuple of <code>(2421, 30690)</code>.</p>
<p>I tried </p>
<pre><code>&gt;&gt;&gt; if (2421,) in (2421, 1231):
...    print('Yes')
... else:
...    print('No')
</code></pre>
<p>and I get <code>No</code>. I also tried using <code>.issubset</code> but I get <code>AtributeError</code>.</p>
<p>I would like to know how can I do this without going the hardcore way, </p>
<pre><code>&gt;&gt;&gt; print(len(arr1), len(arr2))
(9258, 263616)
</code></pre>
<p>I'm using a Jupyter notebook with Python 2. Only using numpy, pandas and itertools. </p>
<p>The desired output should be of the form; if I have products <code>1,2,3</code> but I only consider the tuples <code>(1,)</code> and <code>(2,)</code> then I need <code>(1,2)</code> but not <code>(1,3)</code> from all the 2-combinations of products.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are implementing the Apriori algorithm, you want to uses <em>actual sets</em> instead of tuples. Python has two set types, <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer"><code>set</code> and <code>frozenset</code></a>, where the latter is immutable and thus can be stored in dictionaries or other sets. You probably want to use the latter so you can associate such sets with support scores.</p>
<p>That's certainly the approach that the <a href="https://github.com/ymoch/apyori/blob/master/apyori.py" rel="nofollow noreferrer"><code>apyori</code> project implementation</a> uses; <code>apyory</code> is a pure-Python library of the Apriori algorithm. </p>
<p>You can do subset tests with tuples, but this is a slow O(NM) operation for tuples of sizes N and M:</p>
<pre><code>def tuple_is_subset(ta, tb):
    return all(tav in tb for tav in ta)
</code></pre>
<p>That's a full loop over N items in <code>ta</code>, and each <code>tav in tb</code> test takes M = <code>len(tb)</code> steps. </p>
<p>You can convert the tuples to sets but that too takes O(N) + O(M) time, after which the subset test takes O(N) time. That makes the whole take linear time, but for small tuples, I suspect that the constant costs of creating new objects will outweigh the theoretical more costly O(NM) <code>all()</code> test above.</p>
<p>To use sets, you can use:</p>
<pre><code>set(ta).issubset(tb)
</code></pre>
<p>where <code>set.issubset()</code> accepts any non-set iterable, the code creates a temporary set object for the test.</p>
</div>
<div class="post-text" itemprop="text">
<p>Welcome <a href="https://stackoverflow.com/users/4468167/2pac">2pac</a>,</p>
<p>Initilization</p>
<pre><code>&gt;&gt;&gt; arr1 =  np.array([(2421,), (35682,), (30690,),(18622,), (18285,), (31269,)], dtype=object)
&gt;&gt;&gt; arr2 = np.array([(2421, 35682), (2421, 30690), (2421, 24852), (18622, 18285), (18622, 31269), (18285, 31269)], dtype=object)
</code></pre>
<p>So if you try to ask <code>(2421,)</code> is it a subset of <code>arr2</code>
will return <code>True</code> only if <code>arr2</code> contain a tuple of size 1 and contain the value <code>2421</code> . </p>
<p>As it is not your expected behaviour you have to iterate over each <code>i</code> items of <code>arr1</code> and check if all <code>i[j]</code>  items are part of <code>arr2[k]</code></p>
<p>Quick overview</p>
<pre><code>&gt;&gt;&gt; arr1[0]
array([2421], dtype=object)
&gt;&gt;&gt; arr1[0] in arr2
True
&gt;&gt;&gt; arr1[0] in arr2[0]
True
</code></pre>
<p>This could give this function</p>
<pre><code>def is_a_subset( tuple_i, primary_tuple ):
  return all( k in primary_tuple for k in tuple_i)

for tuple_i in arr1:
  is_a_subset( tuple_i , arr2)
</code></pre>
<p>But I will advice to use set if you build your collection step by step of frozenset if it is an immutable collection (i.e <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">set and frozenset</a>)</p>
<p>Edit:
<a href="https://stackoverflow.com/a/52988191/427887">Martijn Pieters</a> answer go in the same way</p>
</div>
<span class="comment-copy"><code>sourcetuple in othertuple</code> would only work if <i>the whole tuple</i> is contained in <code>othertuple</code>; <code>(42,) in ((81,), (42,))</code> is true because the second tuple contains nested tuples and one of them is equal to the sought tuple. For per-value tests, you can use <code>if any(v in othertuple for v in sourcetuple):</code> or use <i>sets</i>, where you can use actual subset tests; <code>seta &lt;= setb</code> is true when <code>seta</code> is a subset of <code>setb</code> <i>or</i> is equal.</span>
<span class="comment-copy">Now, I suspect that this a small part of a bigger problem, that you think you found a solution to. I suspect that there are better approaches possible, using actual sets, for example.</span>
<span class="comment-copy">Yes, @MartijnPieters I talked with some colleagues and they told me to use sets instead. Thank you for pointing it out!</span>
