<div class="post-text" itemprop="text">
<p>I'd like to execute a simple batch file using Python. But I'm getting some error back from the process saying the file, directory or disc name is not right. I guess the best way to start is to show the code:</p>
<pre><code>import subprocess as sp
from pathlib import Path

file = Path(r'C:\Program Files (x86)\test.bat')

p = sp.Popen(['"' + str(file) + '"'], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE,
             shell=True, universal_newlines=True)
outs, errs = p.communicate('', timeout=5)
print(outs, '\n-----\n', errs)
</code></pre>
<p>I extended this with appending to system path and changing the working directory:</p>
<pre><code>import os
import sys

sys.path.append(file.parent)
os.chdir(file.parent)
</code></pre>
<p>The batch file contains just a few echo commands for debugging. So I'd expect the code above to print the contents of the echoes. I've verified that I'm able to call it inside a command prompt from any folder. Previously I was getting some file permission error (<code>WinError 5</code>), so that might be related especially as the file is in Program Files. This error was not from the process, but Python itself.</p>
<p>I also tried it with an executable, and a similar error was raised: <code>WinError 2: the system cannot find the file specified</code>. Any idea where I'm stumbling?</p>
<hr/>
<h3>Attempts</h3>
<ul>
<li>When the <code>shell=True</code> keyword is removed, the <code>WinError 5</code> is back</li>
<li>When <code>Popen</code> is called with <code>['cmd']</code> and the batch file is run with <code>p.communicate('"' + str(file) + '"\n', timeout=5)</code>, no errors are thrown, and the output contains the echoes. However batch files should run without explicitly opening a command prompt, I presume.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Use a command-line string instead of an args list when passing <code>shell=True</code> or when running a batch script with the default <code>shell=False</code>. </p>
<p>On Windows, <code>Popen</code> processes an args list into a command line that's compatible with VC++ argument parsing. But cmd.exe don't use VC++ argument parsing rules, and even for an executable that does use VC++ rules (e.g. python.exe), the extra quotes you're adding (i.e. <code>'"' + str(file) + '"'</code>) get backslash-escaped as literal quotation marks in the command line.</p>
</div>
<span class="comment-copy">Just a suggestion . Maybe try os.path.normpath("path/foreslash/rather/than/backslash".</span>
<span class="comment-copy">@NihalSangeeth The sole purpose of <code>pathlib.Path</code> here is to avoid that very confusion. Should you print <code>file</code>, it has forward slashes. I only used backslashes because Windows uses them. And on Windows, <code>normpath</code> <a href="https://docs.python.org/3/library/os.path.html#os.path.normpath" rel="nofollow noreferrer">converts</a> forward slashes to backward ones. This makes <code>str(file)</code> and <code>os.path.normpath(file)</code> equivalent. (<code>str</code> around a path converts the slashes of a Windows path)</span>
<span class="comment-copy">can you verify you can open this file like open(file,"r") ?</span>
<span class="comment-copy">@NihalSangeeth I indeed can open it: <code>with open(file, 'r') as f:     print(f.read())</code></span>
