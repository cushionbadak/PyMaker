<div class="post-text" itemprop="text">
<p>I am trying to write a unit test (or call it integration test if you want) for my <em>main</em> module and <code>main()</code> method.</p>
<p>It looks like this:</p>
<pre class="lang-python prettyprint-override"><code># main.py in mymodule
# some imports...

def main() -&gt; None:
    # args is a result of argparse parsing
    try:
        if args.type == 'a':
            from mymodule import a
            a.run()
        elif args.type == 'b'
            from mymodule import b
            b.run()
        # elif ...
        else:
            raise RuntimeError('Unknown type ' + args.type)
    except (RuntimeError, FileNotFoundError, ...) as e:
        # some logging
        sys.exit(1)

    # some other logging
</code></pre>
<p>I have tried to mock/patch the modules in these ways:</p>
<pre><code>def dummy_run():
    # just do nothing here

def test_main_a(self):
    import mymodule.a
    mymodule.a.run = dummy_run
    os.system('python3 mymodule.main a')
</code></pre>
<p>and </p>
<pre><code>def test_main_a(self):
    # patch is imported as from unittest.mock import patch
    with patch('mymodule.a.run', return_value=None):
        os.system('python3 mymodule.main a')
</code></pre>
<p>and </p>
<pre><code>def test_main_a(self):
    # patch is imported as from unittest.mock import patch
    with patch('mymodule.a.run') as run_mocked:
        run_mocked.return_value = None
        os.system('python3 mymodule.main a')
</code></pre>
<p>and</p>
<pre><code>@patch('mymodule.a.run')
def test_main_a(self, a_mock):
    a_mock.return_value = None
    os.system('python3 mymodule.main a')
</code></pre>
<p>But all of these ways do not mock/patch the <code>mymodule.a.run</code> method ending up in the real method invoked.</p>
<p>When I tried to patch <code>mymodule.main.a.run</code> or <code>mymodule.main.mymodule.a.run</code> I only got <code>ModuleNotFoundError</code>s. I tried these targets after reading the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">Where to patch</a> part.</p>
<p>Honestly I do not really understand where is the problem with the patching, as I am patching before the module <code>mymodule.a</code> is imported and it's <code>run()</code> is called (as this happens only after <code>os.system('...')</code> part in the test). Any help is highly appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>Patching and mocking only works within the same interpreter, but your call to <code>os.system('python [...]')</code> runs the the <code>main</code> function in a new interpreter. Instead, you probably want to call the <code>main</code> function directly. That might involve patching some <code>sys</code> objects like <code>sys.exit</code> and <code>sys.argv</code>. </p>
<p>However, a common practice is to provide an optional <code>args</code> argument to the <code>main</code> function:</p>
<pre><code>def main(args=None):
    parser = argparse.ArgumentParser()
    parser.add_argument('type')
    namespace = parser.parse_args(args)
    if namespace.type == 'a':
        from mymodule import a
        a.run()
    sys.exit()
</code></pre>
<p>This way, one can easily inject and test command-line arguments:</p>
<pre><code>def test_main_a():
    with patch('mymodule.a.run') as run_mocked:
        main(['a'])
</code></pre>
<p>Also, the <a href="https://docs.pytest.org/en/latest/assert.html#assertions-about-expected-exceptions" rel="nofollow noreferrer">pytest.raises</a> context can be used to manage the call to <code>sys.exit</code>:</p>
<pre><code>def test_main_a():
    with patch('mymodule.a.run') as run_mocked:
        with pytest.raises(SystemExit):
            main(['a'])
</code></pre>
</div>
<span class="comment-copy">Do you mean <a href="https://docs.python.org/3.5/library/os.html#os.system" rel="nofollow noreferrer">os.system</a>?</span>
<span class="comment-copy">Of course, I am sorry...will fix</span>
<span class="comment-copy">Honestly I don't understand why you expect it will work as you are using <code>os.system</code> to launch another subprocess. So you patch method in current process and expect it will work in another process?</span>
<span class="comment-copy">@Sraw Obviously I was not aware of this behavior. My bad. Thanks for your neat comment :-)</span>
<span class="comment-copy">Do you suggest using the <code>pytest</code> library instead of the native <code>unittest</code>? What are the advantages? So far I have all my unittests written using the native library (with overall 87.8% coverage). Thanks!</span>
<span class="comment-copy">@shadyyx It's a different question, and quite a subjective one. But in my opinion, it is much nicer to write tests using pytest. Also note that the pytest runner <a href="https://docs.pytest.org/en/latest/unittest.html" rel="nofollow noreferrer">supports unittest.TestCase</a>, so you don't have to rewrite all your tests. You can simply start writing extra tests with pytest and see how you like it.</span>
<span class="comment-copy">I have one problem though. I have rewritten the <code>main()</code> method as you have suggested, and running selective tests from the suite works without a problem. However, if I run the whole suite at once, I get ~50% of the tests failed when trying to setup the logging, telling me that <code>log = logging.getLogger('mymodule')</code> followed by <code>handler = logging.StreamHandler(stderr)</code> and <code>log.addHandler(handler)</code> fails in <code>AttributeError: 'CustomAdapter' object has no attribute 'addHandler'</code>. This happens always when I have my test to run <code>main.main(args)</code> not commented out... Any idea what might be wrong?</span>
<span class="comment-copy">@shadyyx It really depends on how your logging system is set up, so I can't really help you with that.</span>
