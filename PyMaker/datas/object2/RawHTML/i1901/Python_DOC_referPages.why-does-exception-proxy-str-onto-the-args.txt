<div class="post-text" itemprop="text">
<p>Why does printing an exception instance print the value of <code>exc.args</code> instead of representing <code>exc</code> directly? The docs call it a <a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="noreferrer">convenience</a> but it's actually an <strong>inconvenience</strong> in practice.</p>
<p>Can't tell the difference between *args and a tuple:</p>
<pre><code>&gt;&gt;&gt; print(Exception(123, 456))
(123, 456)
&gt;&gt;&gt; print(Exception((123, 456)))
(123, 456)
</code></pre>
<p>Can't reliably discern type:</p>
<pre><code>&gt;&gt;&gt; print(Exception('123'))
123
&gt;&gt;&gt; print(Exception(123))
123
</code></pre>
<p>And the lovely "invisible" exception:</p>
<pre><code>&gt;&gt;&gt; print(Exception())

&gt;&gt;&gt; 
</code></pre>
<p>Which you'll inherit unless you specifically ask not to:</p>
<pre><code>&gt;&gt;&gt; class MyError(Exception):
...     """an error in MyLibrary"""
...     
&gt;&gt;&gt; print(MyError())

&gt;&gt;&gt; 
</code></pre>
<p>This can be a real problem if you forget to log error instances specifically with <code>repr</code> - a default string representation in a log file has irreversibly lost information.</p>
<p><strong>What's the rationale for such strange implementation of <code>Exception.__str__</code></strong>?  Presumably if a user wanted to print <code>exc.args</code> then they should just print <code>exc.args</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>BaseException.__str__</code> could have been fixed in a backwards-incompatible manner with Python 3 to include at least the type of the exception, but perhaps no one noticed that it is a thing that should be fixed. </p>
<p>The current implementation dates back to PEP 0352 which provides rationale:</p>
<blockquote>
<p>No restriction is placed upon what may be passed in for <code>args</code> for backwards-compatibility reasons. In practice, though, only a single string argument should be used. This keeps the string representation of the exception to be a useful message about the exception that is human-readable; this is why the <code>__str__</code> method special-cases on length-1 <code>args</code> value. Including programmatic information (e.g., an error code number) should be stored as a separate attribute in a subclass.</p>
</blockquote>
<p>Of course Python itself breaks this principle of useful human-readable messages in many cases - for example stringification of a <code>KeyError</code> is the key that was not found, which leads to debug messages like</p>
<pre><code>An error occurred: 42
</code></pre>
<hr/>
<p>The reason why <code>str(e)</code> is essentially <code>str(e.args)</code> or <code>str(e.args[0])</code> was originally backwards-compatibility with Python 1.0. In <strong>Python 1.0</strong>, the syntax for raising an exception, such as <code>ValueError</code> would have been:</p>
<pre><code>&gt;&gt;&gt; raise ValueError, 'x must be positive'
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1
ValueError: x must be positive
</code></pre>
<p>Python retained backwards-compatibility with 1.0 up to 2.7, so that you can run most Python 1.0 programs unchanged in <strong>Python 2.7</strong> (like you never would):</p>
<pre><code>&gt;&gt;&gt; raise ValueError, 'x must be positive'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: x must be positive
</code></pre>
<p>Likewise, in <strong>Python 1.0</strong> you would catch the <code>ValueError</code> with </p>
<pre><code>&gt;&gt;&gt; try:
...     raise ValueError, 'foo'
... except ValueError, e:
...     print 'Got ValueError', e
</code></pre>
<p>which worked unchanged in Python 2.7.</p>
<p>But the mechanism of how this worked internally had changed: In Python 1.0.1, <code>ValueError</code> was a <em>string</em> with value... <code>'ValueError'</code></p>
<pre><code>&gt;&gt;&gt; ValueError, type(ValueError)
('ValueError', &lt;type 'string'&gt;)
</code></pre>
<p>There were no exception classes at all, and you could only <code>raise</code> a single argument, or a tuple, with a string as a discriminator:</p>
<pre><code>&gt;&gt;&gt; class MyCustomException: 
...     pass
...   
&gt;&gt;&gt; raise MyCustomException, 'my custom exception'
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1
TypeError: exceptions must be strings
</code></pre>
<p>It would also be possible to give a tuple as an argument:</p>
<pre><code>&gt;&gt;&gt; raise ValueError, ('invalid value for x', 42)
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1
ValueError: ('invalid value for x', 42)
</code></pre>
<p>And if you catch this "exception" in <strong>Python 1.0</strong>, what you get in <code>e</code> is:</p>
<pre><code>&gt;&gt;&gt; try:
...     raise ValueError, ('invalid value for x', 42)
... except ValueError, e:
...     print e, type(e)
... 
('invalid value for x', 42) 42 &lt;type 'tuple'&gt;
</code></pre>
<p>A <em>tuple</em>!</p>
<p>Let's try the code in <strong>Python 2.7</strong>:</p>
<pre><code>&gt;&gt;&gt; try:
...     raise ValueError, ('invalid value for x', 42)
... except ValueError, e:
...     print e, e[1], type(e)
... 
('invalid value for x', 42) 42 &lt;type 'exceptions.ValueError'&gt;
</code></pre>
<p>The output looks identical, except for the type of the value; which was a <code>tuple</code> before and now an exception... Not only does the <code>Exception</code> delegate <code>__str__</code> to the <code>args</code> member, but it also supports indexing like a tuple does - and unpacking, iteration and so on:</p>
<p><strong>Python 2.7</strong></p>
<pre><code>&gt;&gt;&gt; a, b, c = ValueError(1, 2, 3)
&gt;&gt;&gt; print a, b, c
1 2 3
</code></pre>
<p>All these hacks for the purpose of keeping backwards-compatibility.</p>
<p>The Python 2.7 behaviour comes from the <code>BaseException</code> class that was introduced in <a href="https://www.python.org/dev/peps/pep-0352/" rel="nofollow noreferrer">PEP 0352</a>; PEP 0352 was originally implemented in Python 2.5.</p>
<hr/>
<p>In Python 3, the old syntax was removed - you could not raise exceptions with <code>raise discriminator, (arg, um, ents)</code>; and the <code>except</code> could only use the <code>Exception as e</code> syntax. </p>
<p>PEP 0352 discussed about dropping support for multiple arguments to <code>BaseException</code>:</p>
<blockquote>
<p>It was decided that it would be better to deprecate the <code>message</code> attribute in Python 2.6 (and remove it in Python 2.7 and Python 3.0) and consider a more long-term transition strategy in Python 3.0 to remove multiple-argument support in <code>BaseException</code> in preference of accepting only a single argument. Thus the introduction of message and the original deprecation of <code>args</code> has been retracted.</p>
</blockquote>
<p>Seemingly this deprecation of <code>args</code> was forgotten, as it still does exist in Python 3.7 and is the <em>only</em> way to access the arguments given to many built-in exceptions. Likewise <code>__str__</code> no longer needs to delegate to the args, and could actually alias the <code>BaseException.__repr__</code> which gives nicer, unambiguous representation:</p>
<pre><code>&gt;&gt;&gt; BaseException.__str__(ValueError('foo', 'bar', 'baz'))
"('foo', 'bar', 'baz')"
&gt;&gt;&gt; BaseException.__repr__(ValueError('foo', 'bar', 'baz'))
"ValueError('foo', 'bar', 'baz')"
</code></pre>
<p>but no one considered it.</p>
<hr/>
<p>P.S. The <code>repr</code> of an exception is useful - next time try printing your exception with <code>!r</code> format:</p>
<pre><code>print(f'Oops, I got a {e!r}')
</code></pre>
<p>which results in</p>
<pre><code>ZeroDivisionError('division by zero',)
</code></pre>
<p>being output.</p>
</div>
