<div class="post-text" itemprop="text">
<p>Python's docs say that there's an alternative to local imports to prevent loading the module on startup:</p>
<p><a href="https://docs.python.org/3/library/unittest.mock-examples.html#mocking-imports-with-patch-dict" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock-examples.html#mocking-imports-with-patch-dict</a></p>
<blockquote>
<p>...to prevent “up front costs” by delaying the import.
  This can also be solved in better ways than an unconditional local
  import (store the module as a class or module attribute and only do
  the import on first use).</p>
</blockquote>
<p>I don't understand the explanation in brackets. How do I do this? However I think about it, I seem to end up with local imports anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation likely refers to the use of <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer"><code>importlib.import_module</code></a>, which exposes Python's <code>import</code> functionality:</p>
<pre><code>import importlib

class Example():

    TO_IMPORT = "os"  # the name of the module to lazily import
    __module = None

    def __init__(self):
        if self.__module is None:
            self.__module = importlib.import_module(self.TO_IMPORT)
</code></pre>
<p>Note that this way the module is only imported once when the class is first instantiated and is not available in global namespace.</p>
<p>Further, it allows you to change which module is imported, which could be useful e.g. in cases where the same class is used as an interface to different backends:</p>
<pre><code>import importlib

class Example():

    def __init__(self, backend="some_module"):
        self.module = importlib.import_module(backend)
</code></pre>
</div>
<span class="comment-copy">It's not very clearly written. Maybe the sentence in parenthesis is an example of an "unconditional local import", and not an example of the opposite?</span>
<span class="comment-copy">@HåkenLid In the previous part of the paragraph, it states "They are sometimes done to prevent circular dependencies, for which there is usually a much better way to solve the problem (refactor the code)". So I'd assume the brackets mean the solution.</span>
<span class="comment-copy">What this likely refers to is the use of <code>import</code> through <code>importlib</code> as described in my answer below.</span>
<span class="comment-copy">Can you explain why this is better? This seems to be no different from a unconditional local import other than that it uses the <code>import_module</code> function e.g. why not <code>def __init__(self):    import os    self.module = os</code>? (sadly, I can't create line breaks in comments, but I hope you get my point)</span>
<span class="comment-copy">The difference is that <code>import os</code> imports into the global namespace and will import the module every time the class is instantiated. I edited the example so that the import only happens once.</span>
<span class="comment-copy">Sorry for taking awhile to respond, I think I can see what your first example does. However, I think the use of importlib is a red herring. Generally, delayed-import doesn't need dynamic-import behavior.</span>
<span class="comment-copy">What makes you believe that using <code>importlib</code> is a red herring?</span>
<span class="comment-copy">I can do the exact same thing with <code>import os</code> in the function. The only purpose of importlib is to allow dynamic import (the ability to change what you import in code). The purpose of lazy import is to delay the import so startup does not have the cost of importing. It's actually different purposes</span>
