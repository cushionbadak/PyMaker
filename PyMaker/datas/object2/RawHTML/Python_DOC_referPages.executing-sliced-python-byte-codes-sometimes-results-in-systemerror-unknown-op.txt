<div class="post-text" itemprop="text">
<p>Given a code object compiled from the following 3 lines of code:</p>
<pre><code>code = compile('''a = 1 / 0 # bad stuff. avoid running this!
b = 'good stuff'
c = True''', '', 'exec')
</code></pre>
<p>which calling <code>dis.dis(code)</code> would disassemble into:</p>
<pre><code>  1           0 LOAD_CONST               0 (1)
              2 LOAD_CONST               1 (0)
              4 BINARY_TRUE_DIVIDE
              6 STORE_NAME               0 (a)

  2           8 LOAD_CONST               2 ('good stuff')
             10 STORE_NAME               1 (b)

  3          12 LOAD_CONST               3 (True)
             14 STORE_NAME               2 (c)
             16 LOAD_CONST               4 (None)
             18 RETURN_VALUE
</code></pre>
<p>How do I extract and run just the byte codes for the second line, <code>b = 'good stuff'</code>?</p>
<p>For example, if I want to extract and run just the byte codes for the last line, <code>c = True</code>, which starts from the byte index <code>12</code>, I can slice the code object's <code>co_code</code> attribute, which contains the raw byte codes, from index <code>12</code>, to construct a <code>types.CodeType</code> object, and then call <code>exec</code> with it:</p>
<pre><code>import types
code3 = types.CodeType(
    code.co_argcount,
    code.co_kwonlyargcount,
    code.co_nlocals,
    code.co_stacksize,
    code.co_flags,
    code.co_code[12:],
    code.co_consts,
    code.co_names,
    code.co_varnames,
    code.co_filename,
    code.co_name,
    code.co_firstlineno,
    code.co_lnotab,
    code.co_freevars,
    code.co_cellvars)
exec(code3)
print(eval('c'))
</code></pre>
<p>so that it correctly outputs the value of <code>c</code> as assigned:</p>
<pre><code>True
</code></pre>
<p>However, if I attempt to extract and run just the byte codes for the second line, <code>b = 'good stuff'</code>, which ranges from index <code>8</code> to <code>12</code> (not including <code>12</code>):</p>
<pre><code>code2 = types.CodeType(
    code.co_argcount,
    code.co_kwonlyargcount,
    code.co_nlocals,
    code.co_stacksize,
    code.co_flags,
    code.co_code[8:12],
    code.co_consts,
    code.co_names,
    code.co_varnames,
    code.co_filename,
    code.co_name,
    code.co_firstlineno,
    code.co_lnotab,
    code.co_freevars,
    code.co_cellvars)
exec(code2)
print(eval('b'))
</code></pre>
<p>it produces:</p>
<pre><code>XXX lineno: 1, opcode: 0
Traceback (most recent call last):
  File "/path/file.py", line 21, in &lt;module&gt;
    exec(code2)
  File "", line 1, in &lt;module&gt;
SystemError: unknown opcode
</code></pre>
<p>Calling <code>dis.dis(code2)</code> would show that the new code object appears to contain the right byte codes for <code>b = 'good stuff'</code>:</p>
<pre><code>  1           0 LOAD_CONST               2 ('good stuff')
              2 STORE_NAME               1 (b)
</code></pre>
<p>So what am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm answering my own question because I could find no documentation on this topic and it took me a while to figure out what I was missing so it might benefit others who happen to encounter the same issue.</p>
<p>It turns out that every code block is <em>required</em> to return a value--it isn't an option not to return a value. If there's no explicit <code>return</code> statement, then <code>None</code> would be implicitly returned, as evident by the last two byte codes shown in the question:</p>
<pre><code>             16 LOAD_CONST               4 (None)
             18 RETURN_VALUE
</code></pre>
<p>So by slicing the byte codes from index <code>12</code> for the last line of <code>c = True</code>, I inadvertently included the trailing implicit return of <code>None</code>, luckily satisfying the requirement for the code block to return a value.</p>
<p>Such was not the case when I tried to slice the byte codes from index <code>8</code> to <code>12</code> for the second line of <code>b = 'good stuff'</code>, as it left out the last two byte codes to return <code>None</code>, thereby causing the <code>SystemError: unknown opcode</code> exception.</p>
<p>So to fix this, all that was needed was to append the last two byte codes (for a total of 4 bytes actually, since byte codes have actually become "word" codes in Python 3) to the slice:</p>
<pre><code>code2 = types.CodeType(
    code.co_argcount,
    code.co_kwonlyargcount,
    code.co_nlocals,
    code.co_stacksize,
    code.co_flags,
    code.co_code[8:12] + code.co_code[-4:],
    code.co_consts,
    code.co_names,
    code.co_varnames,
    code.co_filename,
    code.co_name,
    code.co_firstlineno,
    code.co_lnotab,
    code.co_freevars,
    code.co_cellvars)
exec(code2)
print(eval('b'))
</code></pre>
<p>This would then correctly output:</p>
<pre><code>good stuff
</code></pre>
</div>
