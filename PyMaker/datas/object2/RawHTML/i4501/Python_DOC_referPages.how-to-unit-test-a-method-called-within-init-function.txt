<div class="post-text" itemprop="text">
<p>I am trying to test a class method which is called within an<code>__init__</code> function. </p>
<pre><code>class abc:

    def __init__(path):
         list = []
         foo(path) 
         bar('hello') # test function bar

    def foo(self, path):
          # does a bunch of stuff and creates internal list 
          list =

    def bar(self):
         # does a bunch of stuff and uses list
</code></pre>
<p>I would like to write a test for method <code>bar</code> here which I guess must be called through an instance of class <code>abc</code>. I can mock <code>list</code> array for this test, but cannot understand how to avoid the call to <code>foo()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just mock <code>foo</code> method for the time of testing <code>bar</code>. You can use <a href="https://docs.python.org/3/library/unittest.mock.html#patch-object" rel="nofollow noreferrer"><code>patch.object</code></a>.</p>
<p>A full example below:</p>
<pre><code>import unittest
from unittest.mock import patch


class MyClass:

    def __init__(self, path):
        self.list = []
        self.foo(path)
        self.bar('/init')

    def foo(self, path):
        self.list.append(path)

    def bar(self, path):
        self.list.insert(0, path)


class MyTestClass(unittest.TestCase):

    @patch.object(MyClass, 'foo')
    def test_bar_decorated(self, mock):
        a = MyClass('/foo')
        a.bar('/bar')
        self.assertEqual(a.list, ['/bar', '/init'])  # .foo() wasn't invoked


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>Notice that, a mock is created for you and passed in as an extra argument to the decorated function (we don't use it in this test). To avoid that you can use context manager version of <code>patch.object</code>:</p>
<pre><code>    def test_bar_context_manager(self):
        with patch.object(MyClass, 'foo'):
            a = MyClass('/foo')
            a.bar('/bar')
            self.assertEqual(a.list, ['/bar', '/init'])  # same behaviour
</code></pre>
</div>
<span class="comment-copy">so when we use Mock() the object created is of type Mock(), but when we use patch.object it creates an object the type requested</span>
<span class="comment-copy">quick follow up... what does <code>foo</code> here <code>@patch.object(MyClass, 'foo')</code> signify?</span>
<span class="comment-copy">name of the <code>MyClass</code> method you want to mock</span>
<span class="comment-copy">So what are the arguments accepted by patch.object: class, method, returnval?</span>
<span class="comment-copy">You probably haven't noticed but I've included the link to the documentation of <code>patch.object</code> in my answer. It accepts a few more arguments, you can read about it <a href="https://docs.python.org/3/library/unittest.mock.html#patch-object" rel="nofollow noreferrer">here</a>.</span>
