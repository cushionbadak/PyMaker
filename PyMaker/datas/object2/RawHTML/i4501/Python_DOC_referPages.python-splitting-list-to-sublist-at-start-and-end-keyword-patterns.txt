<div class="post-text" itemprop="text">
<p>If I were to have a list, say:</p>
<pre><code>lst = ['foo', 'bar', '!test', 'hello', 'world!', 'word']
</code></pre>
<p>with a character of <code>!</code>, how would I return a list given:</p>
<pre><code>lst = ['foo', 'bar', ['test', 'hello', 'world'], 'word']
</code></pre>
<p>I'm having some difficulty finding a solution for this. Here's one approach I've tried:</p>
<pre><code>def define(lst):
    for index, item in enumerate(lst):
        if item[0] == '!' and lst[index+2][-1] == '!':
            temp = lst[index:index+3]
            del lst[index+1:index+2]
            lst[index] = temp
    return lst
</code></pre>
<p>Any help would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that there is no elements which starts &amp; ends with <code>!</code> like <code>'!foo!'</code>.</p>
<p>First of all we can write helper predicates like</p>
<pre><code>def is_starting_element(element):
    return element.startswith('!')


def is_ending_element(element):
    return element.endswith('!')
</code></pre>
<p>Then we can write <a href="https://docs.python.org/3/glossary.html#term-generator" rel="noreferrer">generator-function</a> (because they are awesome)</p>
<pre><code>def walk(elements):
    elements = iter(elements)  # making iterator from passed iterable
    for position, element in enumerate(elements):
        if is_starting_element(element):
            yield [element[1:], *walk(elements)]
        elif is_ending_element(element):
            yield element[:-1]
            return
        else:
            yield element
</code></pre>
<p>Tests:</p>
<pre><code>&gt;&gt;&gt; lst = ['foo', 'bar', '!test', 'hello', 'world!', 'word']
&gt;&gt;&gt; list(walk(lst))
['foo', 'bar', ['test', 'hello', 'world'], 'word']
&gt;&gt;&gt; lst = ['foo', 'bar', '!test', '!hello', 'world!', 'word!']
&gt;&gt;&gt; list(walk(lst))
['foo', 'bar', ['test', ['hello', 'world'], 'word']]
&gt;&gt;&gt; lst = ['hello!', 'world!']
&gt;&gt;&gt; list(walk(lst))
['hello']
</code></pre>
<p>as we can see from the last example if there are more closing elements than opening ones remaining closing elements will be ignored (this is because we're <code>return</code>ing from generator). So if <code>lst</code> has invalid signature (difference between opening and closing elements is not equal to zero) then we can have some unpredictable behavior. As a way out of this situation we can validate given data before processing and raise error if data is invalid.</p>
<p>We can write validator like</p>
<pre><code>def validate_elements(elements):
    def get_sign(element):
        if is_starting_element(element):
            return 1
        elif is_ending_element(element):
            return -1
        else:
            return 0

    signature = sum(map(get_sign, elements))
    are_elements_valid = signature == 0
    if not are_elements_valid:
        error_message = 'Data is invalid: '
        if signature &gt; 0:
            error_message += ('there are more opening elements '
                              'than closing ones.')
        else:
            error_message += ('there are more closing elements '
                              'than opening ones.')
        raise ValueError(error_message)
</code></pre>
<p>Tests</p>
<pre><code>&gt;&gt;&gt; lst = ['!hello', 'world!']
&gt;&gt;&gt; validate_elements(lst)  # no exception raised, data is valid
&gt;&gt;&gt; lst = ['!hello', '!world']
&gt;&gt;&gt; validate_elements(lst)
...
ValueError: Data is invalid: there are more opening elements than closing ones.
&gt;&gt;&gt; lst = ['hello!', 'world!']
&gt;&gt;&gt; validate_elements(lst)
...
ValueError: Data is invalid: there are more closing elements than opening ones.
</code></pre>
<p>Finally we can write function with validation like</p>
<pre><code>def to_sublists(elements):
    validate_elements(elements)
    return list(walk(elements))
</code></pre>
<p>Tests</p>
<pre><code>&gt;&gt;&gt; lst = ['foo', 'bar', '!test', 'hello', 'world!', 'word']
&gt;&gt;&gt; to_sublists(lst)
['foo', 'bar', ['test', 'hello', 'world'], 'word']
&gt;&gt;&gt; lst = ['foo', 'bar', '!test', '!hello', 'world!', 'word!']
&gt;&gt;&gt; to_sublists(lst)
['foo', 'bar', ['test', ['hello', 'world'], 'word']]
&gt;&gt;&gt; lst = ['hello!', 'world!']
&gt;&gt;&gt; to_sublists(lst)
...
ValueError: Data is invalid: there are more closing elements than opening ones.
</code></pre>
<h1>EDIT</h1>
<p>If we want to handle elements which starts &amp; ends with <code>!</code> like <code>'!bar!'</code> we can modify <code>walk</code> function using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a> like</p>
<pre><code>from itertools import chain


def walk(elements):
    elements = iter(elements)
    for position, element in enumerate(elements):
        if is_starting_element(element):
            yield list(walk(chain([element[1:]], elements)))
        elif is_ending_element(element):
            element = element[:-1]
            yield element
            return
        else:
            yield element
</code></pre>
<p>also we need to complete validation by just modifying <code>get_sign</code> function</p>
<pre><code>def get_sign(element):
    if is_starting_element(element):
        if is_ending_element(element):
            return 0
        return 1
    if is_ending_element(element):
        return -1
    return 0
</code></pre>
<p>Tests</p>
<pre><code>&gt;&gt;&gt; lst = ['foo', 'bar', '!test', '!baz!', 'hello', 'world!', 'word']
&gt;&gt;&gt; to_sublists(lst)
['foo', 'bar', ['test', ['baz'], 'hello', 'world'], 'word']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an iterative solution that can handle arbitrarily nested lists:</p>
<pre><code>def nest(lst, sep):
    current_list = []
    nested_lists = [current_list]  # stack of nested lists
    for item in lst:
        if item.startswith(sep):
            if item.endswith(sep):
                item = item[len(sep):-len(sep)]  # strip both separators
                current_list.append([item])
            else:
                # start a new nested list and push it onto the stack
                new_list = []
                current_list.append(new_list)
                current_list = new_list
                nested_lists.append(current_list)
                current_list.append(item[len(sep):])  # strip the separator
        elif item.endswith(sep):
            # finalize the deepest list and go up by one level
            current_list.append(item[:-len(sep)])  # strip the separator
            nested_lists.pop()
            current_list = nested_lists[-1]
        else:
            current_list.append(item)

    return current_list
</code></pre>
<p>Test run:</p>
<pre><code>&gt;&gt;&gt; nest(['foo', 'bar', '!test', '!baz!', 'hello', 'world!', 'word'], '!')
['foo', 'bar', ['test', ['baz'], 'hello', 'world'], 'word']
</code></pre>
<p>The way it works is to maintain a stack of nested lists. Every time a new nested list is created, it gets pushed onto the stack. Elements are always appended to the last list in the stack. When an element that ends with "!" is found, the topmost list is removed from the stack.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would first determine where the start and end points of your sublist are, then cut up the list accordingly, then remove the <code>!</code>s.</p>
<pre><code>def define(lst):
    # First find the start and end indexes
    for index, item in enumerate(lst):
        if item[0] == '!':
            start_index = index
        if item[-1] == "!":
            end_index = index+1

    # Now create the new list
    new_list = lst[:start_index] + [lst[start_index:end_index]] + lst[end_index:]

    # And remove the !s
    new_list[start_index][0] = new_list[start_index][0][1:]
    new_list[start_index][-1] = new_list[start_index][-1][:-1]

    return new_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a quite simple implementation:</p>
<pre><code>lst = ['foo', 'bar', '!test', 'hello', 'world!', 'word']

lst_tmp = [(tuple(el.split()) if ' ' in (el[0], el[-1]) else el.split()) for el in ' '.join(lst).split('!')]
lst = []
for el in lst_tmp:
    if isinstance(el, tuple):
        for word in el:
            lst.append(word)
    else:
        lst.append(el)
</code></pre>
<p>First we join <code>lst</code> into a single <code>str</code> and then split it on <code>'!'</code>. Now, this results in <code>['foo bar ', 'test hello world', ' word']</code>. We can now use the appearing whitespace characters in the beginning or end of the elements to signify where the embedded <code>list</code> should appear. The words that should appear individually are packed into <code>tuple</code>s, just to distinguish them from the <code>list</code>(s). All of this results in <code>lst_tmp</code>. The final thing to do is to unpack the <code>tuple</code>s into their single elements, which is what the loop is doing.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you should insert to array rather assign it. and you also need to delete up to index + 3</p>
<pre><code>def define(lst):
    for index, item in enumerate(lst):
        if item[0] == '!' and lst[index+2][-1] == '!':
            temp = lst[index:index+3]
            del lst[index:index+3]
            lst.insert(index, temp)
    return lst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Please Try below : </p>
<pre><code>lst = ['foo', 'bar', '!test', 'hello', 'world!', 'word']
temp =[]
isFound=False
for str in lst:
    if str.startswith("!"):
        temp.append(str,replace("!",""))
        isFound=True
    elif len(temp) and isFound and not str.endswith("!"):
        temp.append(str)
    elif str.endswith("!"):
        temp.append(str,replace("!",""))
        isFound=False
for item in temp:
    lst.remove(item)
lst.append(temp)
</code></pre>
</div>
<span class="comment-copy">Do you want your sublist to contain all elements between the two <code>!</code>s?</span>
<span class="comment-copy">can element start and end with <code>!</code> like <code>'!element!'</code>?</span>
<span class="comment-copy">what if there is more opening elements than closing ones? should we check?</span>
<span class="comment-copy">Checks for matching numbers of opening/closing brackets is not needed, nested sublists are also not needed. An element cannot start and end with <code>'!element!'</code></span>
<span class="comment-copy">This only works with a single nested list. Something like <code>['!foo', 'bar!', '!x', 'y!']</code> or <code>['!foo', '!x', 'y!', 'bar!']</code> gets incorrect output.</span>
<span class="comment-copy">Yes, I was assuming only one set of <code>!</code>s.</span>
<span class="comment-copy">This doesn't work correctly if any of the words in the list contain exclamation marks like <code>['f!o!o']</code>. It also doesn't handle arbitrary nesting like <code>['!foo', '!x', 'y!', 'bar!']</code>.</span>
<span class="comment-copy">Your indentation is messed up. When I fix it (well, I took a guess. I don't know what the intended indentation is), it throws an exception with the input <code>['!foo', 'bar!']</code>.</span>
<span class="comment-copy">@Aran-Fey I am just pointing out the problem with OP solutions. If OP needs dynamic solution OP should try first. And sorry for the bad indentation.</span>
<span class="comment-copy">I don't think it should be posted as an answer if you're not answering the question... pointing out problems can be done in the comments.</span>
<span class="comment-copy">Yes I am answering the question but not dynamically as OP did not ask for it. I just fixed OP algorithm and posted corrected version.</span>
<span class="comment-copy">But it isn't fixed, it throws an error with a lot of inputs...</span>
<span class="comment-copy">That puts the sublist at the end of the list, and doesn't remove the <code>!</code>s.</span>
<span class="comment-copy">Yes, agree, but this can be enhanced to achieve that as well. but solution from @Aran-Fey is much better.</span>
<span class="comment-copy">You have a bunch of typos in there (<code>str,replace</code>) and if I try on the input <code>['!foo', 'bar!']</code> it throws a ValueError. <code>str.replace</code> is also not the right tool for the job, because it will replace <i>all</i> occurences of the exclamation mark. If there's a word like <code>"!fo!o"</code> in the list, the result would contain <code>"foo"</code> instead of <code>"fo!o"</code>.</span>
