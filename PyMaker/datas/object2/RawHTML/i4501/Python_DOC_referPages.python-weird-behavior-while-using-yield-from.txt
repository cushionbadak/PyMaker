<div class="post-text" itemprop="text">
<p>In the following code, I have run into a <code>RecursionError: maximum recursion depth exceeded</code>.</p>
<pre><code>def unpack(given):
    for i in given:
        if hasattr(i, '__iter__'):
            yield from unpack(i)
        else:
            yield i

some_list = ['a', ['b', 'c'], 'd']

unpacked = list(unpack(some_list))
</code></pre>
<p>This works fine if I use <code>some_list = [1, [2, [3]]]</code>, but not when I try it with strings. </p>
<p>I suspect my lack of knowledge in python. Any guidance appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Strings are infinitely iterable.  Even a one-character string is iterable. </p>
<p>Therefore, you will always get a stack overflow unless you add special handling for strings:</p>
<pre><code>def flatten(x):
    try:
        it = iter(x)
    except TypeError:
        yield x
        return
    if isinstance(x, str):
        yield x
        return
    for elem in it:
        yield from flatten(elem)
</code></pre>
<p><em>Note:</em> using <code>hasattr(i, '__iter__')</code> is not sufficient to check if <code>i</code> is iterable, because there are other ways to satisfy the iterator protocol.  The <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow noreferrer">only</a> reliable way to determine whether an object is iterable is to call <code>iter(obj)</code>.  </p>
</div>
<span class="comment-copy">Strings are themselves iterable, and the things they iterate over are strings. <code>for x in 'a'</code> yields <code>'a'</code> itself.</span>
<span class="comment-copy">Try <code>some_list = []; some_list.append(some_list); unpacked = list(unpack(some_list))</code> to see that this can happen with anything with depth&gt;1000. So the remaining question is why every string has depth&gt;1000, which wim's answer (and BallpointBen's comment) explains.</span>
<span class="comment-copy">@abarnert For your case, is it that <code>__iter__</code> for <code>list</code> returns itself, and naturally it's unending recursion?</span>
<span class="comment-copy">@user7865286 Yesâ€”or, maybe more simply, that the list contains itself: <code>some_list[0] is some_list</code>. I thought this would be less surprising than the fact that if <code>s = 'a'</code>, <code>s[0] is s</code>, so it would help illuminate the problem, but now that I think about it, how many people actually know about recursive lists in Python? The only really obvious example would be a class that explicitly iterates itself, which is too big and distracting to be worth commenting about; better to just go straight to <code>s[0] is s</code> for strings as BallpointBen did.</span>
<span class="comment-copy">It could be just a comment.</span>
<span class="comment-copy">"using <code>hasattr(i, '__iter__')</code> is not sufficient to check if <code>i</code> is iterable" - true, but <code>isinstance(x, Iterable)</code> fails for many of the same cases. The most reliable check is to just call <code>iter</code>.</span>
<span class="comment-copy">@user2357112 is right. In particular, the "old-style sequence iteration protocol" (which is actually a pair of related incomplete protocols, but never mind that) isn't captured by either test. Just define a class with a <code>__len__</code> that returns an <code>int</code> (and make sure it's in <code>range(0, 1&lt;&lt;32)</code>), and a <code>__getitem__</code> that doesn't raise <code>IndexError</code> for any value in <code>range(0, __len__())</code> but does for <code>__len__()</code>, and you've got an iterable but not an <code>Iterable</code>.</span>
<span class="comment-copy">What do you think is a more Pythonic way to implement <code>flatten</code>?  I almost always prefer EAFP, but somehow I always come back to LBYL for this one.  For example - which exception(s) to catch, is just <code>TypeError</code> enough?  It's hard to say.</span>
<span class="comment-copy"><code>isinstance(x, Iterable)</code> is definitely an improvement over <code>hasattr(x, '__iter__')</code>, at least. It'll pick up "anti-registration" through <code>__iter__ = None</code>, and it'll detect <code>isinstance("asdf", Iterable)</code> in Python 2 (though only due to a <code>register</code> call).</span>
