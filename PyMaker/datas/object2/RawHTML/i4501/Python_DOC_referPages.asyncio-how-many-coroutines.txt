<div class="post-text" itemprop="text">
<p>I have been struggling for a few days now with a python application where I am expecting to look for a file or files in a folder and iterate through the each file and each record in it and create objects to be persisted on a Janusgraph database. The particular OGM that I am using, requires that the transactions with the database are done in an asynchronously using asyncio. I have read a lot of blogs, posts about asyncio and I think I understand the concept of async, await, tasks, etc... In my application I have defined several functions that handle different parts of the processing:</p>
<ul>
<li>Retrieves the list of all files available</li>
<li>Select one file for processing</li>
<li>Iterates through the selected file and reads a line/record for processing</li>
<li>Receives the record, determines parses the from in and calls several other functions that are responsible for creating the Model objects before they are persisted to the database. For instance, I different functions that creates: User, Session, Browser, DeviceUsed, Server, etc...</li>
</ul>
<p>I understand (and I may be wrong) that the big advantage of using asyncio is for situations where the call to a function will block usually for I/O, database transaction, network latency, etc...</p>
<p>So my question is if I need to convert <strong>all</strong> my functions into coroutines and schedule to run through the event loop, or just the ones that would block, like committing transaction to the database. I tried this approach to begin with and had all sorts of problems. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>So my question is if I need to convert <strong>all</strong> my functions into coroutines and schedule to run through the event loop, or just the ones that would block,</p>
</blockquote>
<p>You might need to convert most of them, but the conversion should be largely mechanical, boiling down to changing <code>def</code> to <code>async def</code>, and adding <code>await</code> when calling other coroutines.</p>
<p>Obviously, you cannot avoid converting the ones that actually block, either by switching to the appropriate asyncio API or by using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer"><code>loop.run_in_executor()</code></a> for those that don't have one. (DNS resolution used to be an outstanding example of the latter.)</p>
<p>But then you also need to convert their <em>callers</em>, because calling a coroutine from a blocking function is not useful unless the function implements event-loop-like functionality. On the other hand, when a coroutine is called from another coroutine, everything works because suspends are automatically propagated to the top of the chain. Once the whole call chain consists of coroutines, the top-level ones are fed to the event loop using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task" rel="nofollow noreferrer"><code>loop.create_task()</code></a> or <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_until_complete" rel="nofollow noreferrer"><code>loop.run_until_complete()</code></a>.</p>
<p>Of course, convenience functions that neither block nor call blocking functions can safely remain non-async, and are invoked by either sync or async code without any difference.</p>
<p><hr/>
The above applies to asyncio, which implements stackless coroutines. A different approach is used by <a href="https://greenlet.readthedocs.io/en/latest/" rel="nofollow noreferrer">greenlet</a>, whose tasks encapsulate the call stack, which allows them to be switched at arbitrary places in code that uses normal function calls. Greenlets are a bit more heavyweight and less portable than coroutines, though, so I'd first converting to asyncio.</p>
</div>
<span class="comment-copy">If you have an existing synchronous codebase, you can generally transform it by converting all functions that do blocking calls to async, then following the chain of callers up to the top so that every function that at least sometimes directly or indirectly calls something async is now async. But if you're working from scratch, it's usually better to think of those async chains before you write anything.</span>
<span class="comment-copy">A couple of follow-up questions your answer: (1) I have a main coroutine which will be at the top of the chain where I read records, I am assuming that this one needs to be fed to the event loop. That function will in its turn chain calls to others that are just doing in memory data manipulation or creating objects. If I understood your statement correctly, I don't need to call the subsequent ones using await ? Is it fine to call them as normal functions ? (2) I am also assuming that I can also feed the top coroutine using asyncio.ensure_future(), right ?</span>
<span class="comment-copy">@Cracoras (1) Exactly, if you are calling simple functions that do in-memory stuff, those don't need to be converted to coroutines and consequently don't need to be awaited - it is fine to call them as normal functions. (2) Yes; given a coroutine, <code>asyncio.ensure_future</code> and <code>loop.create_task</code> are equivalent, but the latter is <a href="https://github.com/python/asyncio/issues/477#issuecomment-268709555" rel="nofollow noreferrer">the intended API</a> when the argument is known to be a coroutine. You can think of <code>create_task</code> (and <code>ensure_future</code>) as starting a task "in the background". Also look at <code>asyncio.gather</code>.</span>
<span class="comment-copy">I finally finished refactoring my code, and changed all the inner function back to regular functions. However I an getting the following error:     file_stats, db_session = process_function(message_types.index(row[0]), row, file_stats, db_session) TypeError: 'coroutine' object is not iterable This line is inside the last of the coroutines that I call in my stack and triggers all the remaining memory bound functions that I mentioned about.</span>
<span class="comment-copy">@Cracoras You need to <code>await</code> the coroutine. If it's at the very top of the call chain, you need to call it using <code>loop.run_until_complete</code>.</span>
<span class="comment-copy">Hi @user4815162342 after your last comment I went back to the code again and realized what you meant by process_function calling coroutines. It turns out none of those were supposed to be coroutines, but regular functions. I reverted them back and were able to run the code without any issues/exceptions. I will still do some additional testing but it seems like it is working. Thank you so much for all your help and definitely your patience. I hope I don't have to bother you with this issue again ;-) --MD</span>
