<div class="post-text" itemprop="text">
<p>I am representing category hierarchy in flat manner.<br/>
Category Hierarchy is  </p>
<pre><code>category1  
    category4
        category6  
    category5  
        category7
category2
category3
</code></pre>
<p>I am storing this as list using dictionary  </p>
<pre><code>d = [{'id': 1, 'name': 'category1', 'parent_category_id': None, 'level': 1},
     {'id': 2, 'name': 'category2', 'parent_category_id': None, 'level': 1},
     {'id': 3, 'name': 'category3', 'parent_category_id': None, 'level': 1},
     {'id': 4, 'name': 'category4', 'parent_category_id': 1, 'level': 2},
     {'id': 5, 'name': 'category5', 'parent_category_id': 1, 'level': 2},
     {'id': 7, 'name': 'category6', 'parent_category_id': 4, 'level': 3},
     {'id': 7, 'name': 'category7', 'parent_category_id': 5, 'level': 3}]
</code></pre>
<p>What can be best approach to convert this category list to hierarchical list like</p>
<pre><code>[{'name': 'category1',
  'subcategory': [{'name': 'category4',
                   'subcategory': [{'name': 'category6', 'subcategory': []}]},
                  {'name': 'category5',
                   'subcategory': [{'name': 'category7', 'subcategory': []}]}]},
 {'name': 'category2', 'subcategory': []},
 {'name': 'category3', 'subcategory': []}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def flat_to_hierarchical(d, category_id=None):
    out = list()
    for item in filter(lambda item: item['parent_category_id']==category_id, d):
        out.append(dict(
            name = item['name'],
            subcategories = flat_to_hierarchical(d, item['id'])
        ))
    return out


print(flat_to_hierarchical(d))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We start with a way to <code>make_tree</code> given an <code>index</code> and a <code>root</code> node identity</p>
<pre><code>def make_tree (index, root):
  if not root in index:
    return []
  else:
    return [ make_node (index, child) for child in index[root] ]
</code></pre>
<p>Now we need a way to <code>make_node</code> - this is where we convert to an element in your input data to an element of our output tree</p>
<pre><code>def make_node (index, child):
  return \
    { 'name': child['name']
    , 'children': make_tree (index, child['id'])
    }
</code></pre>
<p>Now of course we need a way to <code>make_index</code> based on your input data. We use itertools <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> so that we can perform efficient lookup of all child nodes</p>
<pre><code>from itertools import groupby

def make_index (nodes):
  return \
    { k: list (v)
        for (k,v) in
          groupby (nodes, lambda n: n['parent_category_id']) }
</code></pre>
<p>Lastly we write <code>main</code> to tie it all together. Note the data is not re-indexed or filtered for each iteration</p>
<pre><code>def main (nodes, root = None):
  return make_tree (make_index (nodes), root)
</code></pre>
<p>Full program demonstration</p>
<pre><code>from itertools import groupby

def make_tree (index, root):
  if not root in index:
    return []
  else:
    return [ make_node (index, child) for child in index[root] ]

def make_node (index, child):
  return \
    { 'name': child['name']
    , 'children': make_tree (index, child['id'])
    }

def make_index (nodes):
  return \
    { k: list (v)
        for (k,v) in
          groupby (nodes, lambda n: n['parent_category_id']) }

def main (nodes, root = None):
  return make_tree (make_index (nodes), root)

d = \
  [ {'id': 1, 'name': 'category1', 'parent_category_id': None, 'level': 1}
  , {'id': 2, 'name': 'category2', 'parent_category_id': None, 'level': 1}
  , {'id': 3, 'name': 'category3', 'parent_category_id': None, 'level': 1}
  , {'id': 4, 'name': 'category4', 'parent_category_id': 1, 'level': 2}
  , {'id': 5, 'name': 'category5', 'parent_category_id': 1, 'level': 2}
  , {'id': 7, 'name': 'category6', 'parent_category_id': 4, 'level': 3}
  , {'id': 7, 'name': 'category7', 'parent_category_id': 5, 'level': 3}
  ]

# get sub-tree of [None] from dataset [d]
print (main (d, None))
</code></pre>
<p>Program output</p>
<pre><code>[ { 'name': 'category1'
  , 'children': [ { 'name': 'category4'
                  , 'children': [  { 'name': 'category6'
                                  , 'children': []
                                  }
                                ]
                  }
                  , { 'name': 'category5'
                    , 'children': [ { 'name': 'category7'
                                    , 'children': []
                                    }
                                  ]
                    }
                ]
  }
  , { 'name': 'category2', 'children': [] } 
  , { 'name': 'category3', 'children': [] }
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is very similar to that I answered at: <a href="https://stackoverflow.com/questions/47898630/python-calculating-the-path-from-parent-child-relationships/47919995#47919995">Calculating the Path from Parent Child Relationships
</a></p>
<p>I note that you seem to have a lot of superfluous fields in your data structures. Essentially you could represent the information in the post by:</p>
<pre><code>d = {1: {4: {6: None}, 5: {7: None}}, 2: None, 3: None}
</code></pre>
<p>Reworking the code for you. </p>
<pre><code>ds = [{'id': 1, 'name': 'category1', 'parent_category_id': None, 'level': 1},
     {'id': 2, 'name': 'category2', 'parent_category_id': None, 'level': 1},
     {'id': 3, 'name': 'category3', 'parent_category_id': None, 'level': 1},
     {'id': 4, 'name': 'category4', 'parent_category_id': 1, 'level': 2},
     {'id': 5, 'name': 'category5', 'parent_category_id': 1, 'level': 2},
     {'id': 6, 'name': 'category6', 'parent_category_id': 4, 'level': 3},
     {'id': 7, 'name': 'category7', 'parent_category_id': 5, 'level': 3}]

e = {1: {4: {6: None}, 5: {7: None}}, 2: None, 3: None}

parents = set()
children = {}
for d in ds:
    c = str(d['id'])
    p = str(d['parent_category_id'])
    if p is not None:
        parents.add(p)
        children[c] = p

# recursively determine parents until child has no parent
def ancestors(p):
    return (ancestors(children[p]) if p in children else []) + [p]

# for each child that has no children print the geneology
for k in (set(children.keys()) - parents):
    print ' '.join(ancestors(k)[1:])
</code></pre>
<p>outputs:</p>
<pre><code>3
2
1 5 7
1 4 6
</code></pre>
<p>To turn this into a nested dictionary I refer you to <a href="https://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries">What is the best way to implement nested dictionaries?</a></p>
</div>
<span class="comment-copy">this is inefficient for large <code>d</code> because it calls <code>filter</code> and iterates through <code>d</code> entirely <i>for each</i> element in <code>d</code>. This is exponential complexity <code>O(nÂ²)</code> when it can be done in in the much faster <code>O(log n)</code> when using a dict for child lookups. See my answer for details.</span>
<span class="comment-copy">@user633183 true, I did not optimize for runtime. Thanks for pointing that out.</span>
