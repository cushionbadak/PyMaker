<div class="post-text" itemprop="text">
<p>How do I type hint a parameter or <code>isinstance</code> check an object that must be iterable and works with <code>len</code>? I assume that pretty much all objects with a length are iterable, so this is really about what type, if any, represents objects that implement <code>__len__</code>.</p>
<pre><code>def n_and_list(x: ???):
    return len(x), [y for y in x]
</code></pre>
<p>It is not <code>typing.Iterable</code> or <code>collections.Iterable</code> because those are true for things that don't have length, like <code>zip</code>. </p>
<pre><code>In [1]: from typing import Iterable

In [2]: isinstance(zip([]), Iterable)
Out[3]: True

In [3]: from collections import Iterable

In [4]: isinstance(zip([]), Iterable)
Out[4]: True

In [5]: len(zip([]))
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-27-86d411a5426c&gt; in &lt;module&gt;()
----&gt; 1 len(zip([]))

TypeError: object of type 'zip' has no len()
</code></pre>
<p>It is not <code>typing.Sequence</code> or <code>collections.Sequence</code>, because those are false for things that have length, like dictionary keys and numpy arrays.</p>
<pre><code>In [6]: from typing import Sequence

In [7]: isinstance({}.keys(), Sequence)
Out[7]: False

In [8]: from numpy import asarray

In [9]: isinstance(asarray([]), Sequence)
Out[9]: False

In [10]: from collections import Sequence

In [11]: isinstance({}.keys(), Sequence)
Out[11]: False

In [12]: from numpy import asarray

In [13]: isinstance(asarray([]), Sequence)
Out[13]: False
</code></pre>
<p>It's not <code>iterable</code> or <code>iter</code> because those are not types. It is not <code>list</code> or <code>tuple</code> because those are much too narrow.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sized" rel="nofollow noreferrer"><code>collections.Sized</code></a> for that:</p>
<pre><code>def n_and_list(x: collections.Sized):
    return len(x), [y for y in x]
</code></pre>
<p>Or for your case, since you want it to have <code>__len__</code> and to be iterable: </p>
<pre><code>import typing
import collections

def n_and_list(x: typing.Union[collections.Sized, collections.Iterable]):
    return len(x), [y for y in x]
</code></pre>
<p>Sadly, as the comments bellow mentioned, there is no <code>typing.Intersection</code> as of yet to guarantee the presence of both.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>typing.Collection</code> if you don't including <code>__contains__</code> as a requirement:</p>
<pre><code>class Collection(Sized, Iterable, Container):

    __slots__ = ()

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Collection:
            return _check_methods(C,  "__len__", "__iter__", "__contains__")
        return NotImplemented
</code></pre>
<p>If you do, a <code>SizedIterable</code> would be trivial to implement yourself, by just removing the check for <code>__contains__</code></p>
<pre><code>class SizedIterable(Sized, Iterable):

    __slots__ = ()

    @classmethod
    def __subclasshook__(cls, C):
        if cls is SizedIterable:
            return _check_methods(C,  "__len__", "__iter__")
        return NotImplemented
</code></pre>
</div>
<span class="comment-copy">That only checks if <code>x</code> has a <code>__len__</code> method though. Technically there could be an <code>x</code> that has <code>__len__</code> but isn't iterable. Edit: <code>typing.Union</code> doesn't solve the problem; it just makes it worse. <code>Union[Sized, Iterable]</code> checks if <code>x</code> is <i>either</i> sized <i>or</i> an iterable; it doesn't require that <code>x</code> is <i>both</i>.</span>
<span class="comment-copy"><code>typing.Union</code> is "or", not "and".</span>
<span class="comment-copy"><code>Sized</code> was the main missing piece for me. In order to be both <code>Sized</code> and <code>Iterable</code>, I'd need an intersection type rather than a union type. I don't know if Python has that.</span>
<span class="comment-copy"><code>typing.Sized</code> is also an alias for <code>collections.abc.Sized</code>. <code>typing.Collection</code> in Python 3.6 inherits both <code>Sized</code> and <code>Iterable</code> (and <code>Container</code>, which asserts the existence of <code>__contains__</code>).</span>
<span class="comment-copy"><code>Intersection</code> is listed in the <a href="https://www.python.org/dev/peps/pep-0483/" rel="nofollow noreferrer">original PEP for type hints</a> under "We might add".</span>
