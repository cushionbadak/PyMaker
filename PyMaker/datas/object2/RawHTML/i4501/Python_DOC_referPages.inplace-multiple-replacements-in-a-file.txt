<div class="post-text" itemprop="text">
<p>I am trying to perform some replacements in a file:</p>
<pre><code>'\t' --&gt; '◊'
 '⁞' --&gt; '\t'
</code></pre>
<p><a href="https://stackoverflow.com/questions/17140886/how-to-search-and-replace-text-in-a-file-using-python">This question</a> recommends the following procedure:</p>
<pre><code>import fileinput

with fileinput.FileInput(filename, inplace=True, backup='.bak') as file:
    for line in file:
        line = line.replace('\t','◊')
        print(line.replace('⁞','\t'), end='')
</code></pre>
<p>I am not allowed to comment there, but when I run this piece of code I get an error saying:</p>
<pre><code>UnicodeDecodeError: 'charmap' codec can't decode byte 0x81 in position 10: character maps to &lt;undefined&gt;
</code></pre>
<p>This kind of error I have remedied previously by adding <code>encoding='utf-8'</code>.
The problem is that <code>fileinput.FileInput()</code> does not allow for an encoding argument.</p>
<p><strong>Question</strong>: How to get rid of this error?</p>
<hr/>
<p>The above solution, if it would work and provided that the speed is comparable to the following method, would please me most. It seems to be doing inplace replacements as it should be done.</p>
<p>I have tried also:</p>
<pre><code>replacements = {'\t':'◊', '⁞':'\t'}
with open(filename, encoding='utf-8') as inFile:
    contents = inFile.read()
with open(filename, mode='w', encoding='utf-8') as outFile:
    for i in replacements.keys():
        contents = contents.replace(i, replacements[i])
    outFile.write(contents)
</code></pre>
<p>which is relatively fast, but very greedy when it comes to memory.</p>
<hr/>
<p>For UNIX users, I need something which does the following thing:</p>
<pre><code>sed -i 's/\t/◊/g' 'file.csv'
sed -i 's/⁞/\t/g' 'file.csv'
</code></pre>
<p>This turns out to be rather slow.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generally, with <code>FileInput</code> you can specify the encoding that you want passing a <a href="https://docs.python.org/3/library/fileinput.html#fileinput.hook_encoded" rel="nofollow noreferrer"><code>fileinput.hook_encoded</code></a> as <code>openhook</code> parameter:</p>
<pre><code>import fileinput

with fileinput.FileInput(filename, openhook=fileinput.hook_encoded('utf-8')) as file:
    # ...
</code></pre>
<p>However, that does not work with <code>inplace=True</code>. In this case, you can treat the file as a binary and decode/encode the strings by yourself. For reading, this can be done just specifying <code>mode='rb'</code>, which will give you <code>bytes</code> instead of <code>str</code> lines. For writing it's a bit more complicated, because <code>print</code> always uses <code>str</code>, or converts the given input to <code>str</code>, so passing bytes will not work as expected. You can, however, <a href="https://stackoverflow.com/questions/908331/how-to-write-binary-data-in-stdout-in-python-3">write binary data to <code>sys.stdout</code></a> directly, and this will work:</p>
<pre><code>import sys
import fileinput

filename = '...'
with fileinput.FileInput(filename, mode='rb', inplace=True, backup='.bak') as file:
    for line in file:
        line = line.decode('utf-8')
        line = line.replace('\t', '◊')
        line = line.replace('⁞', '\t')
        sys.stdout.buffer.write(line.encode('utf-8'))
</code></pre>
</div>
<span class="comment-copy">And it is ~2 times faster (in my case) than the working method I have there in the post. Negligible amount of RAM used. This is fantastic @jdehesa! Thank you!</span>
