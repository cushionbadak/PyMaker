<div class="post-text" itemprop="text">
<p>I'm using a basler camera to take images and also using pypylon to interface camera software(pylon) with python</p>
<p>I want to create two parts </p>
<ol>
<li>grab images (i.e 1000 or 2000)with some specific exposure time and shutter speed.</li>
<li><p>and save it parallelly without disturbing fps.</p>
<p>Or is there any way to save them in a buffer and use it afterward which won't affect fps?</p></li>
</ol>
<p>Right now my concern is to save images without affecting fps 
Thanks</p>
<p>Following is my code</p>
<pre><code>import pypylon
pypylon.pylon_version.version
available_cameras = pypylon.factory.find_devices()
available_cameras
cam = pypylon.factory.create_device(available_cameras[0])
cam.opened
cam.open()

cam.properties['AcquisitionFrameRateEnable'] = True
cam.properties['AcquisitionFrameRate'] = 1000
cam.properties['ExposureTime']
cam.properties['ExposureTime'] = 1000
#import matplotlib.pyplot as plt
from scipy.misc import imsave 
count=0
for image in cam.grab_images(30):
    count +=1
    a=str(count)
    b=str('I:/'+ a+'.png')
    imsave(b,image)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First things first: <code>scipy</code>'s <code>imsave</code> has been deprecated, and is scheduled to be removed. Use <code>imageio</code>'s <a href="https://imageio.readthedocs.io/en/latest/userapi.html#imageio.imwrite" rel="nofollow noreferrer"><code>imwrite</code></a> instead.</p>
<p>Now for the code. There are a few ways of doing this. I'll move from fewest modifications to most modifications.</p>
<h2>Fix up code</h2>
<p>I'm just going to make some changes to your program, to make it easier to modify later and so that it won't break in the future:</p>
<pre><code>import pypylon
from imageio import imwrite

available_cameras = pypylon.factory.find_devices()
cam = pypylon.factory.create_device(available_cameras[0])
cam.open()

cam.properties['AcquisitionFrameRateEnable'] = True
cam.properties['AcquisitionFrameRate'] = 1000
cam.properties['ExposureTime'] = 1000

for count, image in enumerate(cam.grab_images(30)):
    filename = str('I:/{}.png'.format(count))
    imwrite(filename, image)
</code></pre>
<p>Future modifications will be based on this. I recommend looking up what some of these do, like <code>'ExposureTime'</code>, since it looks like you blindly copied these from the example.</p>
<h2>Buffer</h2>
<p>In order to store these images in a buffer, we can simply read them all straight away by converting the iterable into a <code>tuple</code> (a read-only list). Once we're done with the buffer we can <code>del</code>ete it to free up some memory.</p>
<pre><code>import pypylon
from imageio import imwrite

available_cameras = pypylon.factory.find_devices()
cam = pypylon.factory.create_device(available_cameras[0])
cam.open()

cam.properties['AcquisitionFrameRateEnable'] = True
cam.properties['AcquisitionFrameRate'] = 1000
cam.properties['ExposureTime'] = 1000

buffer = tuple(cam.grab_images(30))
for count, image in enumerate(buffer):
    filename = str('I:/{}.png'.format(count))
    imwrite(filename, image)
del buffer
</code></pre>
<h2>Asynchronous saving</h2>
<p>I need to do something with multiprocessing. Oh, look, there's a Python module called <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a>. I've never used this before, but by reading it I can create this:</p>
<pre><code>import pypylon
from imageio import imwrite
from multiprocessing import Pool

def save_image(pair):
    count, image = pair  # pair is actually two values
    filename = str('I:/{}.png'.format(count))
    imwrite(filename, image)

if __name__ == "__main__":
    available_cameras = pypylon.factory.find_devices()
    cam = pypylon.factory.create_device(available_cameras[0])
    cam.open()

    cam.properties['AcquisitionFrameRateEnable'] = True
    cam.properties['AcquisitionFrameRate'] = 1000
    cam.properties['ExposureTime'] = 1000

    with Pool(30) as p:  # One for each image
        p.map(save_image, enumerate(cam.grab_images(30)))
</code></pre>
<p>This solution is the one you asked for in the title. The most cryptic part of this is <code>pair</code>. This is there because each item generated by <code>enumerate</code> is a tuple of the form <code>(i, image)</code>. This is only one argument, so it's passed to <code>save_image</code> as one argument. We need to expand that into the two variables <code>count</code> and <code>image</code> so that the rest of the code will work, which is what the first line of the function achieves.</p>
<p>You might also have noticed <code>if __name__ == "__main__":</code>. This makes sure that the code only runs when the program is imported as a module, which is used internally by <code>multiprocess</code> to find the <code>save_image</code> function.</p>
<p>I hope this does what you wanted. If you want clarification, feel free to post a comment. If you have a separate question, please ask another question.</p>
</div>
<span class="comment-copy">How are you getting those images? Could you provide some sample code so that we can see roughly what you're doing?</span>
<span class="comment-copy">@wizzwizz4 I'm using a basler camera to take images and also using pypylon to interface camera software(pylon) with python. I updated my code in my question please check above.</span>
<span class="comment-copy">Thank you very much @wizzwizz4</span>
<span class="comment-copy">@Rishabhsharma You double-clicked the accept mark, which accepts and then unaccepts. Did you mean to do that?</span>
<span class="comment-copy">no, I did that accidentally. Really sorry for that. I'll try your code on my camera and let you know if it worked or not and then accept the answer.</span>
<span class="comment-copy">@Rishabhsharma Good! Some people accept answers before making sure that they're right; you're waiting until you know whether it's right before deciding to accept an answer which is what you're supposed to do.</span>
<span class="comment-copy">Thanks for your help. All three of codes are running well for capturing 30 images. But when I'm running third one 'Asynchronous saving' for 2000 images (30 is replaced with 2000 in "with Pool(30) as p" and "p.map(save_image, enumerate(cam.grab_images(30)))") it's giving some error which is: OSError: [WinError 1455] The paging file is too small for this operation to complete. I think it's a memory error. Is there any way to solve this?</span>
