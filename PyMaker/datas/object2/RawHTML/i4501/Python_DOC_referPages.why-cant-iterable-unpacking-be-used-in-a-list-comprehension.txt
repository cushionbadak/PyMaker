<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; LOL = [[1, 2], ['three']]
&gt;&gt;&gt; [*LOL[0], *LOL[1]]
[1, 2, 'three']
</code></pre>
<p>Alright!  Goodbye <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a>.  Never liked you much anyway.  </p>
<pre><code>&gt;&gt;&gt; [*L for L in LOL]
  File "&lt;ipython-input-21-e86d2c09c33f&gt;", line 1
    [*L for L in LOL]
    ^
SyntaxError: iterable unpacking cannot be used in comprehension
</code></pre>
<p><strong>Oh</strong>.  Why can't we have nice things?  </p>
<p>Unpacking in a comprehension seems to be obvious/pythonic, but since they've bothered to add that special error message there was a reason for disabling it.  So, what's the problem with that syntax?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Taking a quote from <a href="https://mail.python.org/pipermail/python-dev/2015-February/138564.html" rel="noreferrer">the Py-Dev mailing list thread in which this feature was accepted</a>:</p>
<blockquote>
<p>So that leaves comprehensions. IIRC, during the development of the patch we realized that <code>f(*x for x in xs)</code> is <strong><em>sufficiently ambiguous</em></strong> that we decided to disallow it -- note that <code>f(x for x in xs)</code> is already somewhat of a special case because an argument can only be a "bare" generator expression if it is the only argument. The same reasoning doesn't apply (in that form) to list, set and dict comprehensions -- while <code>f(x for x in xs)</code> is identical in meaning to <code>f((x for x in xs))</code>, <code>[x for x in xs]</code> is NOT the same as <code>[(x for x in xs)]</code> (that's a list of one element, and the element is a generator
  expression)</p>
</blockquote>
<p><sup>(Emphasis mine)</sup></p>
<p>I also took a peek at the Python issue tracker for this feature. I found an issue in which discussion took place while implementing it. The sequence of messages that helped them come to this realization starts <a href="http://bugs.python.org/issue2292#msg234754" rel="noreferrer">here</a> with a nice overview of the ambiguity introduced presented in <a href="http://bugs.python.org/issue2292#msg234766" rel="noreferrer">msg234766</a> by GvR.</p>
<p>In <em>fear</em> of link-rot, I'm attaching the (formatted) message here:</p>
<blockquote>
<p>So I think the test function here should be:</p>
<pre><code>def f(*a, **k): print(list(a), list(k))
</code></pre>
<p>Then we can try things like:</p>
<pre><code>f(x for x in ['ab', 'cd'])
</code></pre>
<p>which prints a generator object, because this is interpreted as an argument that's a generator expression.</p>
<p>But now let's consider:</p>
<pre><code>f(*x for x in ['ab', 'cd'])
</code></pre>
<p>I personally expected this to be equivalent to:</p>
<pre><code>f(*'ab', *'cd')
</code></pre>
<p>IOW:</p>
<pre><code> f('a', 'b', 'c', 'd')
</code></pre>
<p><em>The PEP doesn't give clarity on what to do here.  The question now is, should we interpret things like <code>*x for x in ...</code> as an extended form of generator expression, or as an extended form of <code>*arg</code>?  I somehow think the latter is more useful and also the more logical extension.</em></p>
<p>My reasoning is that the PEP supports things like <code>f(*a, *b)</code> and it would be fairly logical to interpret <code>f(*x for x in xs)</code> as doing the <code>*x</code> thing for each <code>x</code> in the list <code>xs</code>.</p>
</blockquote>
<p>Finally, as noted in <a href="https://www.python.org/dev/peps/pep-0448/#abstract" rel="noreferrer">the Abstract section of the corresponding PEP</a>, this feature isn't completely ruled out:</p>
<blockquote>
<p>This PEP does not include unpacking operators inside list, set and dictionary comprehensions although <em>this has not been ruled out for future proposals</em>.</p>
</blockquote>
<p>So, we might get to see it sometime soon (definitely not 3.6, though :-) and I hope we do, they look nice. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is <em>briefly</em> explained in the <a href="https://www.python.org/dev/peps/pep-0448/#variations" rel="noreferrer">PEP 448</a> which introduces unpacking generalizations:</p>
<blockquote>
<p>Earlier iterations of this PEP allowed unpacking operators inside
  list, set, and dictionary comprehensions as a flattening operator over
  iterables of containers:</p>
<pre><code>&gt;&gt;&gt; ranges = [range(i) for i in range(5)]
&gt;&gt;&gt; [*item for item in ranges]
[0, 0, 1, 0, 1, 2, 0, 1, 2, 3]

&gt;&gt;&gt; {*item for item in ranges}
{0, 1, 2, 3}
</code></pre>
<p>This was met with a mix of strong concerns about readability and mild
  support. In order not to disadvantage the less controversial aspects
  of the PEP, this was not accepted with the rest of the proposal.</p>
</blockquote>
<p>However, this may change in the future:</p>
<blockquote>
<p>This PEP does not include unpacking operators inside list, set and dictionary comprehensions although this has not been ruled out for future proposals. </p>
</blockquote>
</div>
<span class="comment-copy">you add a a second loop: <code>[item for L in LOL for item in L]</code> Possibly to remove ambiguity as to which one should be used.</span>
<span class="comment-copy">This hasn't been ruled out for the future (the initial implementation <i>had</i> it from what I know), looking for the reference on this.</span>
<span class="comment-copy">See the acceptance message <a href="https://mail.python.org/pipermail/python-dev/2015-February/138564.html" rel="nofollow noreferrer">on py-dev, there's a paragraph on comps.</a></span>
<span class="comment-copy">P.s your naming conventions are <i>horrible</i>!</span>
<span class="comment-copy">IOW = "in other words"  (had to google it)</span>
<span class="comment-copy">@wim Since we're being honest here, so did I.</span>
