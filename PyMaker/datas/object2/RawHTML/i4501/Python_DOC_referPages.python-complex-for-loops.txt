<div class="post-text" itemprop="text">
<p>I am working through some code trying to understand some Python mechanics, which I just do not get. I guess it is pretty simple and I also now, what it does, but i do not know how it works. I understand the normal use of <code>for</code>-loops but this here... I do not know. </p>
<p>Remark: I know some Python, but I am not an expert. </p>
<pre><code>np.array([[[S[i,j]] for i in range(order+1)] for j in range(order+1)])
</code></pre>
<p>The second piece of code, I have problems with is this one: </p>
<pre><code>for i in range(len(u)):
        for j in range(len(v)):
            tmp+=[rm[i,j][k]*someFuction(name,u[i],v[j])[k] for k in range(len(rm[i,j])) if rm[i,j][k]]
</code></pre>
<p>How does the innermost <code>for</code>-loop work? And also what does the <code>if</code> do here?</p>
<p>Thank you for your help. </p>
<p>EDIT: Sorry that the code is so unreadable, I just try to understand it myself. <code>S, rm</code> are numpy matrices, <code>someFunction</code> returns an array with scalar entries, and<code>tmp</code> is just a help variable</p>
</div>
<div class="post-text" itemprop="text">
<p>There are quite a few different concepts inside your code. Let's start with the most basic ones. Python <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">lists</a> and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html" rel="nofollow noreferrer">numpy arrays</a> have different methodologies for indexation. Also you can build a numpy array by providing it a list:</p>
<pre><code>S_list  = [[1,2,3], [4,5,6], [7,8,9]]
S_array = np.array(S_list)

print(S_list)
print(S_array)

print(S_list[0][2]) # indexing element 2 from list 0
print(S_array[0,2]) # indexing element at position 0,2 of 2-dimensional array
</code></pre>
<p>This results in:</p>
<pre><code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
3
3
</code></pre>
<p>So for your first line of code:</p>
<pre><code>np.array([[[S[i,j]] for i in range(order+1)] for j in range(order+1)])
</code></pre>
<p>You are building a numpy array by providing it a list. This list is being built with the concept of <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>. So the code inside the <code>np.array(...)</code> method:</p>
<pre><code>[[[S[i,j]] for i in range(order+1)] for j in range(order+1)]
</code></pre>
<p>... is equivalent to:</p>
<pre><code>order     = 2
full_list = []
for j in range(order+1):
    local_list = []
    for i in range(order+1):
        local_list.append(S_array[i, j])
    full_list.append(local_list)

print(full_list)
</code></pre>
<p>This results in:</p>
<pre><code>[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
</code></pre>
<p>As for your second snippet its important to notice that although typically numpy arrays have very specific and constant (for all the array) cell types you can actually give the data type object to a numpy array. So creating a 2-dimensional array of lists is possible. It is also possible to create a 3-dimensional array. Both are compatible with the indexation <code>rm[i,j][k]</code>. You can check this in the following example:</p>
<pre><code>rm = np.array(["A", 3, [1,2,3]], dtype="object")
print(rm, rm[2][0]) # Acessing element 0 of list at position 2 of the array

rm2 = np.zeros((3, 3, 3))
print(rm2[0, 1][2])  # This is also valid
</code></pre>
<p>The following code:</p>
<pre><code>[rm[i,j][k]*someFuction(name,u[i],v[j])[k] for k in range(len(rm[i,j])) if rm[i,j][k]]
</code></pre>
<p>... could be written as such:</p>
<pre><code>some_list = []
for k in range(len(rm[i,j])):
    if rm[i, j][k]: # Expecting a boolean value (or comparable)
        a_list = rm[i,j][k]*someFuction(name,u[i],v[j])
        some_list.append(a_list[k])
</code></pre>
<p>The final detail is the <code>tmp+=some_list</code>. When you sum two list they'll be concatenated as can been seen in this simple example:</p>
<pre><code>tmp = []
tmp += [1, 2, 3]
print(tmp)
tmp += [4, 5, 6]
print(tmp)
</code></pre>
<p>Which results in this:</p>
<pre><code>[1, 2, 3]
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>Also notice that multiplying a list by a number will effectively be the same as summing the list several times. So <code>2*[1,2]</code> will result in <code>[1,2,1,2]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Its a list comprehension, albeit a pretty unreadable one. That was someome doing something very 'pythonic' in spite of readablity. Just look up list comprehensions and try to rewrite it yourself as a traditional for loop. list comprehensions are very useful, not sure I would have gone that route here.</p>
<p>The syntax for a list comprehension is</p>
<pre><code>[var for var in iterable if optional condition]
</code></pre>
<p>So this bottom line can be rewritten like so:</p>
<pre><code>for k in range(len(rm[i,j]):
    if rm[i,j][k]:
        tmp+= rm[i,j][k]*someFunction(name,u[i],v[j])[k]
</code></pre>
</div>
<span class="comment-copy">this is not readable at all...</span>
<span class="comment-copy">Someone clearly wrote this as a joke. Possibly on his/herself. Why the DV? Seems like a legit question...</span>
<span class="comment-copy">If you intend for no one to ever fathom being able to read your code, then this thoroughly accomplishes it's task.</span>
<span class="comment-copy">Guys this is obviously a player of CodeGolf... Look how short and messy it iss!</span>
<span class="comment-copy">hi @peter, what about to <a href="https://en.wikipedia.org/wiki/RTFM" rel="nofollow noreferrer">RTFM</a>: Here it is: <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">5.1.3. List Comprehensions</a></span>
<span class="comment-copy">Hmmm... +1 this answers part of the question, -1 this has no explanation of the obsfucated line. EDIT: apparently other people are harsher than me.</span>
