<div class="post-text" itemprop="text">
<p>In the code snippet below, passing x and y values puts the dot in (y,x) coordinates while the drawing is done in (x,y). What is the correct way to set up the drawing buffer so it's placing pixels and drawing in the same coordinate system?</p>
<pre><code>from PIL import Image, ImageDraw

def visual_test(x, y):
    grid = np.zeros((100, 100, 3), dtype=np.uint8)
    grid[:] = [0, 0, 0]
    grid[x, y] = [255, 0, 0]
    img = Image.fromarray(grid, 'RGB')
    draw = ImageDraw.Draw(img)
    draw.line((x, y, x, y-5), fill=(255,255,255), width=1)
    img.show()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Note: with "axis" I refer to image coordinates, not to NumPy's array dimensions.</em></p>
<p>The issue is with the interpretation of <a href="https://docs.scipy.org/doc/numpy-dev/reference/arrays.ndarray.html" rel="nofollow noreferrer"><code>ndarray</code></a>'s dimensions ("The N-dimensional array"), or the definition of a <em>coordinate system</em> in that context.</p>
<p>For <a href="https://pypi.python.org/pypi/Pillow" rel="nofollow noreferrer">Pillow</a>, it's clear:</p>
<blockquote>
<p><a href="https://pillow.readthedocs.io/en/stable/handbook/concepts.html#coordinate-system" rel="nofollow noreferrer">Coordinate System</a></p>
<p>The Python Imaging Library uses a Cartesian pixel coordinate system,
  with (0,0) in the upper left corner. Note that the coordinates refer
  to the implied pixel corners; the centre of a pixel addressed as (0,
  0) actually lies at (0.5, 0.5).</p>
<p>Coordinates are usually passed to the library as 2-tuples (x, y).
  Rectangles are represented as 4-tuples, with the upper left corner
  given first. For example, a rectangle covering all of an 800x600 pixel
  image is written as (0, 0, 800, 600).</p>
</blockquote>
<p>That would look like this (image -&gt; public domain):  </p>
<p><a href="https://i.stack.imgur.com/t4AiI.png" rel="nofollow noreferrer"><img alt="Pillow's XY coordinate system" src="https://i.stack.imgur.com/t4AiI.png"/></a></p>
<p>Your code, modified to create a 2x2 pixel image:</p>
<pre><code>import numpy as np
from PIL import Image # Pillow

w, h, d = 2,2,3
x,y = 0,1

grid = np.zeros((w, h, d), dtype=np.uint8) # NumPyarray for image data
#test = np.zeros(w*h*d, dtype=np.uint8).reshape(w, h, d)
#print(np.array_equal(grid,test)) # =&gt; True

# red pixel with NumPy
grid[x, y] = [255, 0, 0]

print(grid[::])

# green pixel with Pillow
img = Image.fromarray(grid, 'RGB')
pixels = img.load()
pixels[x,y] = (0, 255, 0)

# display temporary image file with default application
scale = 100
img.resize((w*scale,h*scale)).show()
</code></pre>
<p>shows the issue (draw pixel at (0,1), green: Pillow, red: ndarray):</p>
<p><a href="https://i.stack.imgur.com/A4K2l.png" rel="nofollow noreferrer"><img alt="generated image" src="https://i.stack.imgur.com/A4K2l.png"/></a></p>
<p>X and Y indeed are swapped:</p>
<p><a href="https://i.stack.imgur.com/ULWE2.png" rel="nofollow noreferrer"><img alt="ndarrays YX axes" src="https://i.stack.imgur.com/ULWE2.png"/></a></p>
<p>Is it because of NumPy or Pillow?</p>
<p>The <code>ndarray</code> prints as</p>
<pre><code>[[[  0   0   0]
  [255   0   0]]

 [[  0   0   0]
  [  0   0   0]]]
</code></pre>
<p>which is easily reformatted to visually correspond to the image pixels </p>
<pre><code>[
 [ [  0   0   0] [255   0   0] ]
 [ [  0   0   0] [  0   0   0] ]
]
</code></pre>
<p>which shows that Pillow interprets the array as one would expect.</p>
<p>But why does NumPy's <code>ndarray</code> seem to swap the axes?</p>
<p>Let's take this apart a bit further </p>
<pre><code>[ # grid
 [ # grid[0]
   [  0   0   0]  #grid[0,0]
                  [255   0   0] #grid[0,1]
 ]
 [ #grid[1]
   [  0   0   0]  #grid[1,0]
                  [  0   0   0] #grid[1,1]
 ]
]
</code></pre>
<p>Let's test this (<code>-i</code> has Python run in interactive mode once the script is finished):</p>
<pre><code>&gt;py -i t.py
[[[  0   0   0]
  [255   0   0]]

 [[  0   0   0]
  [  0   0   0]]]
&gt;&gt;&gt; grid[0,1]
array([255,   0,   0], dtype=uint8)
&gt;&gt;&gt; grid[0]
array([[  0,   0,   0],
       [255,   0,   0]], dtype=uint8)
&gt;&gt;&gt; ^Z
</code></pre>
<p>which confirms the assumed indexes above.</p>
<p>It becomes obvious how the first dimension of the <code>ndarray</code> corresponds to the image lines or Y axis, the second to the image columns or X axis (and the third obviously to the RGB pixel values).</p>
<p>So, to match the "coordinate systems", either ...</p>
<ol>
<li>... the axes need to be "swapped"</li>
<li>... the data needs to be "swapped"</li>
<li>... the axis interpretation needs to "swapped"</li>
</ol>
<p>Let's see:</p>
<p><strong>1. Simply swapping the index variables</strong> when writing to the <code>ndarray</code>:</p>
<pre><code># red pixel with NumPy
grid[y, x] = [255, 0, 0]
</code></pre>
<p>expectedly results in </p>
<pre><code>[[[  0   0   0]
  [  0   0   0]]

 [[255   0   0]
  [  0   0   0]]]
</code></pre>
<p>and</p>
<p><a href="https://i.stack.imgur.com/682pt.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/682pt.png"/></a></p>
<p>Of course a wrapper function could do this.</p>
<p><strong>2.</strong> <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html" rel="nofollow noreferrer"><strong>Transposing</strong></a> the array, as <a href="https://stackoverflow.com/questions/49720605/pixel-coordinates-vs-drawing-coordinates#comment86455565_49720605">suggested by zch</a>, does not work <em>that</em> easily on a 3-dimensional array, since this function affects all dimensions by default:</p>
<pre><code>grid = np.transpose(grid)
print("transposed\n", grid)
print("shape:", grid.shape)
</code></pre>
<p>results in</p>
<pre><code>[[[  0   0]
  [255   0]]

 [[  0   0]
  [  0   0]]

 [[  0   0]
  [  0   0]]]
shape: (3, 2, 2)
</code></pre>
<p>and because of the Pillow <code>RGB</code> image mode specified, consequently an Exception is thrown:</p>
<pre><code>ValueError: not enough image data
</code></pre>
<p>But there is an additional argument to <code>np.transpose</code>, <code>axes</code>:</p>
<blockquote>
<p>...permute the axes according to the values given.</p>
</blockquote>
<p>We want to swap only <code>0</code> and <code>1</code>, but not <code>2</code>, so:</p>
<pre><code>grid = np.transpose(grid, (1,0,2))
</code></pre>
<p>There are other functions that operate similarly, e.g.</p>
<pre><code>grid = np.swapaxes(grid,0,1)
</code></pre>
<p><strong>3. Change the interpretation ?</strong></p>
<p>Can Pillow's <a href="https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.fromarray" rel="nofollow noreferrer"><code>PIL.Image.fromarray</code></a> be brought to interpret the <code>ndarray</code> with swapped axes? It does not have any other arguments than <code>mode</code> for color (really, see the <a href="https://github.com/python-pillow/Pillow/blob/master/src/PIL/Image.py#L2407" rel="nofollow noreferrer">source code</a>).</p>
<blockquote>
<p>Creates an image memory from an object exporting the array interface using the buffer protocol).
  If obj is not contiguous, then the tobytes method is called and frombuffer() is used.</p>
</blockquote>
<p>The function figures out how to call <a href="http://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.frombuffer" rel="nofollow noreferrer"><code>PIL.Image.frombuffer()</code></a> (<a href="https://github.com/python-pillow/Pillow/blob/master/src/PIL/Image.py#L2346" rel="nofollow noreferrer">source</a>), which has a few more options for the "decoder".</p>
<p><a href="https://docs.scipy.org/doc/numpy/reference/arrays.interface.html" rel="nofollow noreferrer">Array interface</a>? <a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow noreferrer">Buffer protocol</a>? That's both a little too low-level for now...</p>
<p><strong>TL;DR</strong><br/>
Just swap the index variables (either)!</p>
<p><hr/>
Further reading:
- <a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" rel="nofollow noreferrer">https://docs.scipy.org/doc/numpy-dev/user/quickstart.html</a></p>
</div>
<span class="comment-copy">I don't know much about it, but I guess you can do <code>Image.fromarray(np.transpose(grid), 'RGB')</code>.</span>
<span class="comment-copy">Thank you so much for the detailed explanation. I learned so much reading your answer.</span>
