<div class="post-text" itemprop="text">
<pre><code>def miniMaxSum(arr):
    #
    # Write your code here.
    #
    eArr = enumerate(arr)
    maxNum = 0
    indexMax = -1;
    for a,b in eArr:
        if b &gt; maxNum:
            maxNum = b
            indexMax = a

    for index,number in eArr:
        print("hello")
</code></pre>
<p>why does it not print anything? I put the print hello part to see if it iterates through the second for loop.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>enumerate</code> is an <a href="https://docs.python.org/3/tutorial/classes.html#iterators" rel="nofollow noreferrer">iterator</a>. Iterators can only be used once; after that, they're empty.</p>
<p>The easy (and idiomatic) solution is to just make a new <code>enumerate</code> iterator for each loop:</p>
<pre><code>def miniMaxSum(arr):
    maxNum = 0
    indexMax = -1;
    for a,b in enumerate(arr):
        if b &gt; maxNum:
            maxNum = b
            indexMax = a

    for index,number in enumerate(arr):
        print("hello")
</code></pre>
<hr/>
<p>If you need to use an iterator more than once, you can save it to a list, and then reuse the list. Just change this line</p>
<pre><code>eArr = enumerate(arr)
</code></pre>
<p>… to this:</p>
<pre><code>eArr = list(enumerate(arr))
</code></pre>
<p>In this case, there's no reason to do that. You'd just be wasting memory building the list. (As for speed, it's probably a little faster for very small lists, but slower for very big ones—but it probably doesn't matter either way for your code.) But there are cases where it's useful, so it's worth knowing how to do.</p>
</div>
<span class="comment-copy">What is the value of <code>arr</code>?</span>
<span class="comment-copy"><code>enumerate</code> is an iterator. Iterators can only be used once; after that, they're empty.</span>
<span class="comment-copy"><code>eArr</code> is an <code>enumerate object</code>: an iterator, not a list. You already consumed all generated data in the first loop. There is nothing left for the second loop. Solution: convert the iterator to a list <code>eArr = list(enumerate(arr))</code>.</span>
<span class="comment-copy">it's just a list of numbers 1 to 5. the first loop works but the second doesn't</span>
<span class="comment-copy">No, it is <i>not</i> a list. But you can make it a list.</span>
<span class="comment-copy">In the OP's example, the iterator in fact <i>is</i> used twice, so there may be a reason to convert it to a list. Constructing the list takes time, but calling the iterator's <code>next()</code> at each iteration also takes time.</span>
<span class="comment-copy">@DyZ I highly doubt that performance actually matters here unless the input list is huge—and if it is, the allocation costs are going to hurt a lot more than iterating twice. According to a quick <code>%timeit</code> test, two enumerates are significantly faster than a list and two iteration once you get into the millions, and they're never more than 2x as slow even for tiny lists. An optimization that saves less than 1us for some cases and wastes more than 1ms for others is not generally worth doing.</span>
<span class="comment-copy">What are the "<i>cases where it's useful</i>", then?</span>
<span class="comment-copy">@DyZ Needing to access the values in reversed or random-access order, needing to pass them to a function that demands a sequence for some reason, needing to use it tons of times instead of just twice, as a micro-optimization in the very rare cases where you've found a bottleneck doing it twice and tested both ways on your actual data… If you run into a case where it's useful, you'll generally know it.</span>
<span class="comment-copy">You are quite right.</span>
