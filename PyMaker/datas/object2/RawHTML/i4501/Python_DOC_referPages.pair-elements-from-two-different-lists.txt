<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>listA = ['a1', 'a2', 'a3', 'a4']
listB = ['b2', 'b4']
</code></pre>
<p>and I want to pair items in the format <em>any string same number</em>, like so:</p>
<pre><code>listC = [('a1', None),('a2', 'b2'),('a3', None),('a4', 'b4')]
</code></pre>
<p>I´ve tried <code>itertools.zip_longest</code> but I couldn´t get what I need:</p>
<pre><code>&gt;&gt;&gt;list(itertools.zip_longest(listA, listB)
[('a1', 'b2'), ('a2', 'b4'), ('a3', None), ('a4', None)]
</code></pre>
<p>Any suggestions how to get <code>listC</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>iter</code> with <code>next</code>:</p>
<pre><code>listA = ['a1', 'a2', 'a3', 'a4']
listB = ['b2', 'b4']
l = iter(listB)
listC = [(a, next(l) if i%2 != 0 else None) for i, a in enumerate(listA)] 
</code></pre>
<p>Output:</p>
<pre><code>[('a1', None), ('a2', 'b2'), ('a3', None), ('a4', 'b4')]
</code></pre>
<p>Edit: pairing by trailing number:</p>
<pre><code>import re
listA = ['a1', 'a2', 'a3', 'a4']
listB = ['b2', 'b4']
d = {re.findall('\d+$', b)[0]:b for b in listB}
listC = [(i, d.get(re.findall('\d+$', i)[0])) for i in listA]
</code></pre>
<p>Output:</p>
<pre><code>[('a1', None), ('a2', 'b2'), ('a3', None), ('a4', 'b4')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension with a ternary statement for this:</p>
<pre><code>listA = ['a1', 'a2', 'a3', 'a4']
listB = ['b2', 'b4']

listB_set = set(listB)
listC = [(i, 'b'+i[1:] if 'b'+i[1:] in listB_set else None) for i in listA]

# [('a1', None), ('a2', 'b2'), ('a3', None), ('a4', 'b4')]
</code></pre>
<p>However, for clarity and performance, I would consider separating numeric and string data.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try dict approach:</p>
<pre><code>listA = ['a1', 'a2', 'a3', 'a4']
listB = ['b2', 'b4']

final_list={}
import itertools

for i in itertools.product(listA,listB):
    data,data1=list(i[0]),list(i[1])
    if data[1]==data1[1]:
        final_list[i[0]]=i
    else:
        if i[0] not in final_list:
            final_list[i[0]]=(i[0],None)

print(final_list.values())
</code></pre>
<p>output:</p>
<pre><code>[('a2', 'b2'), ('a3', None), ('a4', 'b4'), ('a1', None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Given</strong></p>
<pre><code>import itertools as it


list_a = ["a1", "a2", "a3", "a4"]
list_b = ["b2", "b4"]
</code></pre>
<p><strong>Code</strong></p>
<pre><code>pred = lambda x: x[1:]
res = [tuple(g) for k, g in it.groupby(sorted(list_a + list_b, key=pred), pred)]
res
# [('a1',), ('a2', 'b2'), ('a3',), ('a4', 'b4')]

list(zip(*it.zip_longest(*res)))
# [('a1', None), ('a2', 'b2'), ('a3', None), ('a4', 'b4')]
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>A flat, sorted list is grouped by the numbers of each string and yields grouped <code>res</code>ults according to the predicate.  Note, if strings start with a <em>single</em> letter, the predicate should work for any digit, <code>"a1"</code>, <code>"b23"</code>, <code>"c132"</code>, etc.  If you are willing, you might also consider a trailing number regex as seen in <a href="https://stackoverflow.com/a/49703108/4531270">@Ajax1234's answer</a>.</p>
<p>As you discovered, <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> pads <code>None</code> to shorter sub-groups by default.</p>
<p><strong>See Also</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/3438756/some-built-in-to-pad-a-list-in-python">this post</a> for more ideas on padding iterables</li>
<li><a href="https://stackoverflow.com/questions/773/how-do-i-use-pythons-itertools-groupby/45873519#45873519">this post</a> on how to use <code>itertool.groupby</code></li>
<li><a href="https://stackoverflow.com/questions/5967500/how-to-correctly-sort-a-string-with-a-number-inside">this post</a> on natural sorting for a more robust predicate </li>
</ul>
</div>
<span class="comment-copy">This will only work if listB is always a subset of listA. Maybe that's what OP wants, but wasn't clear from the question.</span>
<span class="comment-copy">This was a valiant guess at what the OP wanted, but he's since posted a comment that makes it clear that you don't have the superhuman telepathy that would have been needed to answer it correctly as posted…</span>
<span class="comment-copy">@abarnert can you clarify?</span>
<span class="comment-copy">@Ajax1234 Read his comment on the question: He wants to pair up the strings with the same number, not skip over every other element of the shorter list.</span>
<span class="comment-copy">@abarnert Ah. Please see my recent edit.</span>
<span class="comment-copy">That <code>len(max(res))</code> is the length of the last tuple, not the length of the longest tuple; you need to add a <code>key=len</code> in there.</span>
<span class="comment-copy">Also, you don't need a <code>lambda</code> here; I think <code>itemgetter(1)</code> may be a little clearer to a novice (or at least give them something they can look up), as well as being a tiny bit faster.</span>
<span class="comment-copy">Thank you @abarnert.  The <code>len</code> keyword is subtle and insightful.  I am still working on parsing digits, so I'm thinking <code>lambda</code> might be more flexible for now.</span>
<span class="comment-copy">Yeah, there are definitely advantages to lambda for flexibility. If the OP comes back and says "It doesn't work for c27", you just need to change <code>x[1]</code> to <code>x[1:]</code>.</span>
<span class="comment-copy">I was just about to make that change.  Many thanks.</span>
