<div class="post-text" itemprop="text">
<p>I have spent a good while searching through this website so I hope this question hasn't been asked before - apologises if it has. I'm learning classes for the first time and I'm making a class with multiple users (could be 50+ but for now, I just have 2 in my example). What I'm trying to do is have certain information about users/employees and be able to print them all in one go... in a way that isn't a complete eyesore! This is what I have attempted:</p>
<pre><code>class User:

    def __init__(self, user_id, first, last, address):
        self.user_id = user_id
        self.first = first
        self.last = last
        self.address = address
        self.email = first + '.' + last + '@python.com'

    def all_users(self):
        print()
        print('User ID: {} First Name: {} {} {} {}'.format(self.user_id, self.first, self.last, self.address, self.email))
        print()


user_1 = User(123, 'Kim', 'N', 'London')

user_2 = User(312, 'Chris', 'E', 'Japan')

print(all_users(User))
</code></pre>
<p>This is the error message that I am receiving: </p>
<pre><code>print('User ID: {} First Name: {} {} {} {}'.format(self.user_id, self.first, self.last, self.address, self.email))
AttributeError: type object 'User' has no attribute 'user_id'
</code></pre>
<p>Thanks in advance for any help or guidance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sounds like you want the <code>User</code> class to contain a list of all users.</p>
<p>This is called a <em>class variable</em> because it is attached to the class itself, instead of being attached to a particular <em>instance</em> of the class.</p>
<p>Example code:</p>
<pre><code>class User(object):

    users = []

    def __init__(self, first, last):
        self.first = first
        self.last = last

        # now that this instance is fully initialized, add it
        # to the master list of users
        User.users.append(self)

    def __str__(self):
        return '{} {}'.format(self.first, self.last)

    @staticmethod
    def all_users():
        for user in User.users:
            print (user)

user_1 = User('Kim', 'Smith')
user_2 = User('Chris', 'Jones')

User.all_users()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should probably implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__</code> or <code>__repr__</code> special methods</a>, which are designed to print human readable and "official" representations of the class instances, respectively</p>
<pre><code>class User():
    ...

    def __str__(self):
        attrs = ['{}={}'.format(k, repr(v)) for k, v in self.__dict__.items()]
        return '{}({})'.format(self.__class__.__name__, ', '.join(attrs))
</code></pre>
<p>Then it would look like this</p>
<pre><code>&gt;&gt;&gt; user = User('123', 'John', 'Doe', 'USA')
&gt;&gt;&gt; print(user)
User(user_id='123', first='John', last='Doe', address='USA', email='John.Doe@python.com')
</code></pre>
</div>
<span class="comment-copy">Please post formatted code.</span>
<span class="comment-copy"><code>User</code> is a class, not an object.  You've confused the two in your program.  <code>user_1</code> and <code>user_2</code> have the attributes; <code>User</code> does not.</span>
<span class="comment-copy">@Prune well, classes are objects :) But I think fundamentally the OP is under the misapprehension that classes automatically act as containers for instances of themselves.</span>
<span class="comment-copy"><code>all_users()</code> is a very misleading method name, as it only prints information for <i>one</i> user.</span>
<span class="comment-copy">This is a good alternative to defining a container class or using a list. The class can keep a list of its own instances.</span>
<span class="comment-copy">Brilliant John Gordon - that makes sense. I'm still learning in my own time but it is great to have a place like this to come to get help when stuck.   Thanks to everyone for their assistance and time.</span>
