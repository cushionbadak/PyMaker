<div class="post-text" itemprop="text">
<p>With a boring class, object instance attribute shadow class attributes:</p>
<pre><code>class C(object):
    a="class_a"

    def __init__(self, a):
        self.a = a


c = C(a="obja")
print c.a  # obja
</code></pre>
<p>But if my class attributes are declared in a named_tuple base:</p>
<pre><code>class C(collections.namedtuple("CBase", ['a', ])):
    a="class_a"

c = C(a="obja")
print c.a  # class_a !!??!
</code></pre>
<p>... so, declaring my instance attribute through the name tuple causes that attribute to be shadowed by the class attribute ... which not what you'd expect. </p>
<p>Why is this?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>namedtuple</code> "attributes" are implemented as <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a> (<a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">specifically, <code>property</code>s</a>) on the class itself, not attributes in the traditional sense (all the actual data is stored in unnamed indices of the <code>tuple</code>). In this case, the <code>namedtuple</code> (roughly) defines:</p>
<pre><code>@property
def a(self):
    return self[0]
</code></pre>
<p>Since the property is a class level attribute, when you define <code>a</code> on the subclass, it shadows equivalent definitions in the parent class.</p>
</div>
<span class="comment-copy">For those who care, the actual implementation (as of 3.6) wraps <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">an <code>operator.itemgetter</code></a> using <code>property</code>; the code I wrote is more recognizable to beginners though, so I omitted the specific implementation details. Either way, the actual behavior is identical.</span>
