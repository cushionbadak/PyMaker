<div class="post-text" itemprop="text">
<p>Since some days ago I was unaware of the <code>__index__()</code> method until reading <a href="https://stackoverflow.com/questions/49633222/slicing-elements-from-a-python-list-using-boolean-indexing">this question</a>. After that, I have been reading about it in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" rel="nofollow noreferrer">documentation</a>, <a href="https://docs.python.org/2.5/whatsnew/pep-357.html" rel="nofollow noreferrer">PEP</a> and in <a href="https://stackoverflow.com/questions/27449310/python-index-special-method">other SO questions</a>.</p>
<p>I understood that whenever the <code>[]</code> operator was used in objects that could be sliced (in my case I'm interested in lists, numpy arrays and pandas), the value either for slicing or for indexing was obtained so that <code>lst[key]=lst[key.__index__()]</code> was fulfilled. </p>
<p>However, as in one of the questions, the result depended on whether PyPy or CPython was used, so I decided to check when was slicing actually done with <code>__index__</code> and when it was not. I have done the following (in CPython 2.7.14):</p>
<pre><code>lst = range(10)
array = np.arange(10)
series = pd.Series(lst)
</code></pre>
<p>And defined the following classes:</p>
<pre><code>class MyIndex:
    def __index__(self):
        return 2
class MyInt(int):
    def __index__(self):
        return 3
class MyStr(str):
    def __index__(self):
        return 4
</code></pre>
<p>Then I tried to acces the defined objects with this used defined objects, obtaining the following:</p>
<p>Note: I am not posting the complete error message for readability purposes. </p>
<p>For <code>MyIndex</code> class, expected output 2:</p>
<pre><code>print lst[MyIndex()]
print array[MyIndex()]
print series[MyIndex()]
# Output:
2
2
AttributeError: MyIndex instance has no attribute '__trunc__'
</code></pre>
<p>For <code>MyInt</code> class, expected output 3:</p>
<pre><code># Case 1
print lst[MyInt()]
print array[MyInt()]
print series[MyInt()]
# Output
0
0
0

# Case 2
print lst[MyInt(2)]
print array[MyInt(2)]
print series[MyInt(2)]
# Output
2
2
2
</code></pre>
<p>For <code>MyStr</code> class, expected output 4:</p>
<pre><code># Case 1
print lst[MyStr()]
print array[MyStr()]
print series[MyStr()]
# Output
4
4
KeyError: ''

# Case 2
print lst[MyStr('a')]
print array[MyStr('a')]
print series[MyStr('a')]
# Output
4
IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices
KeyError: 'a'
</code></pre>
<p>I'm really puzzled by this, mainly by the following points:</p>
<ul>
<li>With lists the <code>__index__</code> method is used but not for <code>int</code> and its childrens. </li>
<li>Numpy uses <code>__index__</code> like lists, but in the last case <code>MyStr('a')</code> raises an error. Am I missing something or in this case <code>__index__</code> is only used when <code>MyStr</code> is an empty string?</li>
<li>Pandas slicing is a whole world and even accepts slicing for ordered string index, so it is a relieve that <code>__index__</code> is not used. Thus, my only question about pandas is if the output of a code could be different depending on the python implementation.</li>
</ul>
<p>My question is basically the one in the title:</p>
<blockquote>
<p><strong>When is <code>__index__</code> called for lists and numpy arrays? Why are there some exceptions?</strong></p>
</blockquote>
<p>Having said that, I will be happy to recieve any extra information I may have missed about this method.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, quoting the <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" rel="nofollow noreferrer">docs</a> for <code>__index__</code>:</p>
<blockquote>
<p>Called to implement operator.index(), and whenever Python needs to
  losslessly convert the numeric object to an integer object (such as in
  slicing, or in the built-in bin(), hex() and oct() functions).
  Presence of this method indicates that the numeric object is an
  integer type. Must return an integer.</p>
<p><strong>Note:</strong> In order to have a coherent integer type class, when <code>__index__()</code>
  is defined <code>__int__()</code> should also be defined, and both should return
  the same value.</p>
</blockquote>
<p><code>__index__</code> usually isn't called if an object is already an int, since no conversion is needed. Also, you need an <code>__int__</code> method to go with <code>__index__</code>; some of your problems come from that. (Your <code>MyInt</code> inherits <code>int.__int__</code>, but its <code>__index__</code> behavior isn't consistent with what it inherits from <code>int</code>, so that's also a problem.)</p>
<hr/>
<p>In CPython, lists implement the C-level sequence protocol, and CPython automatically calls <code>__index__</code> for non-ints before invoking the sequence protocol. Ints just get their int value used, and your <code>MyInt()</code> has an int value of 0. You can trace the call chain for <code>__index__</code> through <a href="https://github.com/python/cpython/blob/v3.6.5/Objects/abstract.c#L156" rel="nofollow noreferrer"><code>PyObject_GetItem</code></a>, <a href="https://github.com/python/cpython/blob/v3.6.5/Objects/abstract.c#L1269" rel="nofollow noreferrer"><code>PyNumber_AsSsize_t</code></a>, and <a href="https://github.com/python/cpython/blob/v3.6.5/Objects/abstract.c#L1227" rel="nofollow noreferrer"><code>PyNumber_Index</code></a> if you want.</p>
<hr/>
<p>NumPy arrays don't use the sequence protocol for indexing. They implement it, but they also implement the mapping protocol, which takes priority. NumPy arrays handle index processing themselves.</p>
<p>One of the things they try is <code>PyNumber_Index</code>, which is why they behave like lists for most of your tests. However, NumPy arrays support a lot more complex indexing than lists, and one part of the NumPy array indexing implementation is a <a href="https://github.com/numpy/numpy/blob/v1.14.2/numpy/core/src/multiarray/mapping.c#L255" rel="nofollow noreferrer">weird special case</a> where certain non-tuple sequences get treated as index tuples.</p>
<p>Your <code>MyStr</code> objects are sequences, and <code>MyStr('a')</code> triggers the special case. It gets treated as <code>tuple(MyStr('a'))</code>, or <code>('a',)</code>, which isn't a valid indexing tuple.</p>
<hr/>
<p>As for Pandas, <code>pandas.Series</code> implements <code>__getitem__</code> at Python level. It also has to process indexes manually.</p>
<p>For <code>MyIndex()</code>, it looks like it tried to call <code>int</code> on your <code>MyIndex()</code> object, which failed because you don't have an <code>__int__</code> method. The error would normally have been a TypeError, which Pandas would probably handle differently, but you forgot to inherit from <code>object</code>, so you got a classic class, and those are weird.</p>
<p>Your <code>MyInt()</code> objects are ints and were used as ints, same as with the list and array tests.</p>
<p>Your <code>MyStr()</code> objects are strings, and Pandas treated them as strings instead of trying to interpret them as ints.</p>
</div>
<span class="comment-copy">It's instructive to define a class with a <code>__getitem__</code> method, and look at the <code>args</code> tuple that indexing gives it.  <code>numpy</code> <code>index_tricks.py</code> uses this to create a number of pseudo  indexing functions, such as <code>np.r_</code> and <code>np.mgrid</code>.</span>
<span class="comment-copy">It's only in recent releases that <code>numpy</code> rejects floats as indices.  It used to allow them, truncating as needed.</span>
<span class="comment-copy">Now my only doubt left is what should be expected for ints whose <b>index</b> returns a different value than <b>int</b>? In PyPy it looks like <b>index</b> takes preference (<a href="https://stackoverflow.com/questions/49633222/slicing-elements-from-a-python-list-using-boolean-indexing" title="slicing elements from a python list using boolean indexing">stackoverflow.com/questions/49633222/â€¦</a>)</span>
<span class="comment-copy">@xg.plt.py: If your <code>__int__</code> and your <code>__index__</code> don't match, your object is broken. Python does not specify which one wins, and anything you glean from examining the implementation is just implementation details, subject to change without notice.</span>
