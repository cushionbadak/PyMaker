<div class="post-text" itemprop="text">
<p>I'm trying to convert a long, complex, Windows batch file into Python.</p>
<p>Things work except for subtle problems, which I suspect have something to do with quoting, but can't quite figure out.</p>
<p>In a batch file, this works fine:</p>
<pre><code>Reg.exe add "HKCR\7-Zip.zip\shell\open\command" /ve /t REG_SZ /d "\"C:\Program Files\7-Zip\7zFM.exe\" \"%%1\"" /f
</code></pre>
<p>This Python code is meant to, but doesn't, do the same thing:</p>
<pre><code>import os, subprocess

cmd = r'Reg.exe add "HKCR\7-Zip.zip\shell\open\command" /ve /t REG_SZ /d "\"C:\Program Files\7-Zip\7zFM.exe\" \"%%1\"" /f'
#os.system(cmd)
subprocess.call(cmd, shell=True)
</code></pre>
<p>Note that the (raw) string <code>cmd</code> and the batch file are <em>exactly</em> identical.</p>
<p>Both the os.system() and subprocess.call() result in the same thing - no error (Reg.exe says everything is fine), but a different effect on the system.</p>
<p>In my testing, the batch file configures the archiver 7z to open the .ZIP file itself (correct result).</p>
<p>The Python code causes 7z to open the folder where the .ZIP is located (wrong). </p>
<p>How to get Python to do what the batch file does?</p>
</div>
<div class="post-text" itemprop="text">
<p>OK, shot in the dark:</p>
<p>I would drop <code>shell=True</code> and use a argument list to pass to <code>subprocess</code>. The quoting will be handled automatically:</p>
<pre><code>cmd = ['Reg.exe','add',r'HKCR\7-Zip.zip\shell\open\command','/ve','/t','REG_SZ','/d',r'"C:\Program Files\7-Zip\7zFM.exe" "%1"','/f']
rc = subprocess.call(cmd)
</code></pre>
<p>also check the return code of <code>subprocess.call</code></p>
<p>If you want to process several commands like this "automatically", I'd suggest to use <a href="https://docs.python.org/3/library/shlex.html#shlex.split" rel="nofollow noreferrer"><code>shlex.split</code></a>, I'm not saying that it will solve everything, but it does a fine job with the quotes (protecting the quoted arguments, with quote nesting):</p>
<pre><code>import shlex
text = r"""Reg.exe add "HKCR\7-Zip.zip\shell\open\command" /ve /t REG_SZ /d "\"C:\Program Files\7-Zip\7zFM.exe\" \"%%1\"" /f"""

print([x.replace("%%","%") for x in shlex.split(text)])  # %% =&gt; % in listcomp, add more filters if needed
</code></pre>
<p>result:</p>
<pre><code>['Reg.exe', 'add', 'HKCR\\7-Zip.zip\\shell\\open\\command', '/ve', '/t', 'REG_SZ', '/d', '"C:\\Program Files\\7-Zip\\7zFM.exe" "%1"', '/f']
</code></pre>
<p>same thing with raw prefix would be:</p>
<pre><code>['Reg.exe', 'add', r'HKCR\7-Zip.zip\shell\open\command', '/ve', '/t', 'REG_SZ', '/d', r'"C:\Program Files\7-Zip\7zFM.exe" "%1"', '/f']
</code></pre>
<p>pretty close right? :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Jean-François Fabre's answer is good, and probably the most Pythonic answer.</p>
<p>Unfortunately for me, I don't have the patience to analyze the batch file to figure out whatever other filters might be needed, so I came up with this solution, which works regardless of the syntax, quoting, and escape sequences in the batch file lines:</p>
<pre><code>def do(command):
    '''Executes command at Windows command line.'''

    import os, subprocess, uuid

    batchFile = open("temp_" + str(uuid.uuid4()) + ".bat", 'w')
    batchFile.write(command)
    batchFile.close()
    subprocess.call(batchFile.name, shell=True)
    os.remove(batchFile.name)
</code></pre>
<p>All it does is create a one-line batch file and then run it. Brute-force.</p>
<p>It's a bit slow because it has the overhead of creating, calling, and deleting the one-line batch file each time.</p>
<p>Here's a faster version that creates one big batch file with all the command lines. Whenever you call it with <code>defer=False</code>, it executes all the commands to date:</p>
<pre><code># thanks to https://stackoverflow.com/questions/279561/what-is-the-python-equivalent-of-static-variables-inside-a-function
def static_vars(**kwargs):
    def decorate(func):
        for k in kwargs:
            setattr(func, k, kwargs[k])
        return func
    return decorate

@static_vars(batchFile=None)
def do(command, defer=True):
    '''Executes command at Windows command line.
       Runs immediately, including all previously deferred commands, if defer is not True
    '''
    import os, subprocess, uuid

    if do.batchFile == None:
        do.batchFile = open("temp_" + str(uuid.uuid4()) + ".bat", 'w')

    do.batchFile.write(command + "\n") # append to file

    if not defer:
        do.batchFile.close()
        subprocess.call(do.batchFile.name, shell=True)
        os.remove(do.batchFile.name)
        do.batchFile = None
</code></pre>
</div>
<span class="comment-copy">can you try <code>cmd = ['Reg.exe','add',r'HKCR\7-Zip.zip\shell\open\command','/ve','/t','REG_SZ','/d',r'\"C:\Program Files\7-Zip\7zFM.exe\" \"%%1\"','/f']</code></span>
<span class="comment-copy">Is there a reason you need to use the shell here? You're not using any shell features, just executing a command with some arguments, so you're just trying to figure out how to fight with two layers of quoting instead of none this way…</span>
<span class="comment-copy">(Actually, make that three layers of quoting instead of one, because you've also got the unavoidable registry string quoting…)</span>
<span class="comment-copy">Doubling percent only escapes it in batch scripts, not in an interactive or <code>/c</code> command. However, escaping percent is not an issue here since it's not paired. Simply use a single percent. (CMD has no completely reliable way to escape multiple percents on the command line or <code>/c</code> commands. Its "^" escape character often works to disrupt variable-name matching, but not if the variable name starts with "^".)</span>
<span class="comment-copy">Also, don't set the value using HKCR. That's a dynamic view that's intended for reading. The result of writing to HKCR depends on what's already defined in "[HKLM|HKCU]\Software\Classes". When adding a setting, it should be defined explicitly in either the HKLM or HKCU registry hive.</span>
<span class="comment-copy">@eryksun thanks. BTW (unrelated) I've put a bounty on my other Popen/stdin question. You may be interested :)</span>
<span class="comment-copy">Yes, that works (upvoted the answer). However exactly what rule you used to transform the original command line into the the new one isn't clear to me. I've got thousands of lines of batch file (not all involving reg.exe) to process; I need an algorithm - hand tweaking each one isn't going to work here.</span>
<span class="comment-copy">For example, some of your strings are raw, some aren't. Why? Exactly why you dropped "\" before the path to 7zFM.exe isn't clear, nor is the quoting or change to single % around %1.</span>
<span class="comment-copy">raw is useful to avoid doubling the backslashes in string literals. If there are no backslashes, no need to. See my edit, should be a good start.</span>
<span class="comment-copy">That is indeed a good start. Unfortunately for me I don't have the patience to analyze the batch file to figure out whatever other filters might be needed. I found a solution - posting my own answer.</span>
<span class="comment-copy">yeah, whatever works :)</span>
