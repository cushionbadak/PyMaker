<div class="post-text" itemprop="text">
<p>I'm comparing Unicode strings between JSON objects.</p>
<p>They have the same value:</p>
<pre><code>a = '人口じんこうに膾炙かいしゃする'
b = '人口じんこうに膾炙かいしゃする'
</code></pre>
<p>But they have different Unicode representations:</p>
<pre><code>String a : u'\u4eba\u53e3\u3058\u3093\u3053\u3046\u306b\u81be\u7099\u304b\u3044\u3057\u3083\u3059\u308b'
String b : u'\u4eba\u53e3\u3058\u3093\u3053\u3046\u306b\u81be\uf9fb\u304b\u3044\u3057\u3083\u3059\u308b'
</code></pre>
<p>How can I compare between two Unicode strings on their value?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://unicode.org/faq/normalization.html" rel="noreferrer">Unicode normalization</a> will get you there for this one:</p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; unicodedata.normalize("NFC", "\uf9fb") == "\u7099"
True
</code></pre>
<p>Use <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize" rel="noreferrer"><code>unicodedata.normalize</code></a> on both of your strings before comparing them with <code>==</code> to check for canonical Unicode equivalence.</p>
<p>Character <a href="https://www.compart.com/en/unicode/U+F9FB" rel="noreferrer"><code>U+F9FB</code></a> is a "CJK Compatibility" character. These characters decompose into one or more regular CJK characters when normalized.</p>
</div>
<div class="post-text" itemprop="text">
<p>Character <a href="https://www.compart.com/en/unicode/U+F9FB" rel="noreferrer"><code>U+F9FB</code></a> (炙) is a <a href="https://en.wikipedia.org/wiki/CJK_Compatibility_Ideographs" rel="noreferrer">CJK Compatibility Ideograph</a>. These characters are distinct code points from the regular CJK characters, but they decompose into one or more regular CJK characters when normalized.</p>
<p>Unicode has an official string collation algorithm called <a href="http://unicode.org/reports/tr10/" rel="noreferrer">UCA</a> designed for exactly this purpose. Python does not come with UCA support as of 3.7,<sup>*</sup> but there are third-party libraries like <a href="https://pypi.python.org/pypi/pyuca/1.2" rel="noreferrer"><code>pyuca</code></a>:</p>
<pre><code>&gt;&gt;&gt; from pyuca import Collator
&gt;&gt;&gt; ck = Collator().sort_key
&gt;&gt;&gt; ck(a) == ck(b)
True
</code></pre>
<p>For this case—and many others, but definitely not all—picking the appropriate <a href="https://unicode.org/faq/normalization.html" rel="noreferrer">normalization</a> to apply to both strings before comparing will work, and it has the advantage of support built into the stdlib.</p>
<p><sub>* The idea has been accepted in principle since 3.4, but nobody has written an implementation—in part because most of the core devs who care are using <code>pyuca</code> or one of the two ICU bindings, which have the advantage of working in current and older versions of Python.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>I would have used PyICU and its Collator class. But first, you should think at what level of <a href="http://www.unicode.org/reports/tr10/#Multi_Level_Comparison" rel="nofollow noreferrer">Unicode collation algorithm</a> you want the equality to happen.</p>
<pre class="lang-python prettyprint-override"><code>#!/usr/bin/python
# -*- coding: utf-8 -*-

from icu import Collator

coll = Collator.createInstance()
coll.setStrength(Collator.IDENTICAL)

a = u'人口じんこうに膾炙かいしゃする'
b = u'人口じんこうに膾炙かいしゃする'
print repr(a)
print repr(b)
print ('%s == %s : %s' % (a, b, coll.equals(a,b)))

a = u'ｴﾚﾍﾞｰﾀｰ'
b = u'エレベーター'
print ('%s == %s : %s' % (a, b, coll.equals(a,b)))

coll.setStrength(Collator.PRIMARY)
print ('%s == %s : %s' % (a, b, coll.equals(a,b)))

a = u'hello'
b = u'HELLO'
coll.setStrength(Collator.PRIMARY)
print ('%s == %s : %s' % (a, b, coll.equals(a,b)))

coll.setStrength(Collator.TERTIARY)
print ('%s == %s : %s' % (a, b, coll.equals(a,b)))
</code></pre>
<p>This outputs:</p>
<pre class="lang-none prettyprint-override"><code>u'\u4eba\u53e3\u3058\u3093\u3053\u3046\u306b\u81be\u7099\u304b\u3044\u3057\u3083\u3059\u308b'
u'\u4eba\u53e3\u3058\u3093\u3053\u3046\u306b\u81be\uf9fb\u304b\u3044\u3057\u3083\u3059\u308b'
人口じんこうに膾炙かいしゃする == 人口じんこうに膾炙かいしゃする : True
ｴﾚﾍﾞｰﾀｰ == エレベーター : False
ｴﾚﾍﾞｰﾀｰ == エレベーター : True
hello == HELLO : True
hello == HELLO : False
</code></pre>
</div>
<span class="comment-copy">It would really help if you formatted this properly, including the closing quotes on your strings, etc., so we can just copy and paste and test it.</span>
<span class="comment-copy">But I'm going to guess the problem is Unicode normalization…</span>
<span class="comment-copy">Why is \u7099 the same as \uf9fb?</span>
<span class="comment-copy">@ThorbjørnRavnAndersen <a href="https://www.compart.com/en/unicode/U+F9FB" rel="nofollow noreferrer">U+F9FB</a> is a <a href="https://en.wikipedia.org/wiki/CJK_Compatibility_Ideographs" rel="nofollow noreferrer">CJK Compatibility Ideographs</a> which decomposes to U+7099</span>
<span class="comment-copy">I would say different "code points" instead of different "bytes".</span>
<span class="comment-copy">Ry, why did you roll back my revision? Suggesting that people convert to NFC and compare is "often good enough", but it's not really correct. The UCA exists for good reasons, and the fact that it's not in the stdlib doesn't mean there aren't easily available implementations.</span>
<span class="comment-copy">@abarnert: I don’t like to recommend libraries whose source I haven’t reviewed, and it’s not clear if it’s required here; feel free to write your own answer. (Plus it takes more instruction to use pyuca effectively.) (EDIT: Turns out it doesn’t and I was thinking of PyICU, which wilx’s answer now covers, so read that)</span>
<span class="comment-copy">It really should be stressed that this isn't going to solve all classes of problems like this, and <code>==</code> is a <i>hard</i> problem that you have to think about.  What <code>==</code> means <i>in each specific context</i> has to be thought about.  Rendered the same?  Mean the same to a speaker of a specific language?  All languages?  Is it an identifier?  Do you want to ignore purely rendering differences?  Is this an attack surface?</span>
<span class="comment-copy">A pair NFC considers different but a user might consider the same is 'µ' (MICRO SIGN) and 'μ' (GREEK SMALL LETTER MU). NFKC will collapse these two.</span>
<span class="comment-copy">thanks for knowing me what problem is on my testing. I solved unicode comparing test to normalize unicode string</span>
