<div class="post-text" itemprop="text">
<p>I have a list of item, where I want to remove the occurrence of any duplicates for one item, but keep any duplicates for the rest.
I.e. I start with the following list</p>
<pre><code>mylist = [4, 1, 2, 6, 1, 0, 9, 8, 0, 9]
</code></pre>
<p>I want to remove any duplicates of <code>0</code> but keep the duplicates of <code>1</code> and <code>9</code>.
My current solution is the following:</p>
<pre><code>mylist = [i for i in mylist if i != 0]
mylist.add(0)
</code></pre>
<p>Is there a nice way of keeping one occurrence of <code>0</code> besides the following?</p>
<pre><code>for i in mylist:
    if mylist.count(0) &gt; 1:
        mylist.remove(0)
</code></pre>
<p>The second approach takes more than double the time for this example.</p>
<p>Clarification:</p>
<ul>
<li><p>currently, I don't care about the order of items in the list, as I currently sort it after it has been created and cleaned, but that might change later.</p></li>
<li><p>currently, I only need to remove duplicates for one specific item (that is <code>0</code> in my example)</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The solution:</p>
<pre><code>[0] + [i for i in mylist if i]
</code></pre>
<p>looks good enough, except if <code>0</code> is not in <code>mylist</code>, in which case you're wrongly adding 0.</p>
<p>Besides, adding 2 lists like this isn't very good performance wise. I'd do:</p>
<pre><code>newlist = [i for i in mylist if i]
if len(newlist) != len(mylist):  # 0 was removed, add it back
   newlist.append(0)
</code></pre>
<p>(or using filter <code>newlist = list(filter(None,mylist))</code> which could be slightly faster because there are no native python loops)</p>
<p>Appending to a list at the last position is very efficient (<code>list</code> object uses pre-allocation and most of the time no memory is copied). The length test trick is <code>O(1)</code> and allows to avoid to test <code>0 in mylist</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like a better data structure for you to use would be <a href="https://docs.python.org/3.6/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> (which is in the standard library):</p>
<pre><code>import collections

counts = collections.Counter(mylist)
counts[0] = 1
mylist = list(counts.elements())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a generator-based approach with approximately O(n) complexity that also preserves the order of the original list:</p>
<pre><code>In [62]: def remove_dup(lst, item):
    ...:     temp = [item]
    ...:     for i in lst:
    ...:         if i != item:
    ...:             yield i
    ...:         elif i == item and temp:
    ...:             yield temp.pop()
    ...:             

In [63]: list(remove_dup(mylist, 0))
Out[63]: [4, 1, 2, 6, 1, 0, 9, 8, 9]
</code></pre>
<p>Also if you are dealing with larger lists you can use following vectorized and optimized approach using Numpy:</p>
<pre><code>In [80]: arr = np.array([4, 1, 2, 6, 1, 0, 9, 8, 0, 9])

In [81]: mask = arr == 0

In [82]: first_ind = np.where(mask)[0][0]

In [83]: mask[first_ind] = False

In [84]: arr[~mask]
Out[84]: array([4, 1, 2, 6, 1, 0, 9, 8, 9])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If performance is an issue and you are happy to use a 3rd party library, use <code>numpy</code>.</p>
<p>Python standard library is great for many things. Computations on numeric arrays is not one of them.</p>
<pre><code>import numpy as np

mylist = np.array([4, 1, 2, 6, 1, 0, 9, 8, 0, 9])

mylist = np.delete(mylist, np.where(mylist == 0)[0][1:])

# array([4, 1, 2, 6, 1, 0, 9, 8, 9])
</code></pre>
<p>Here the first argument of <code>np.delete</code> is the input array. The second argument extracts the indices of all occurrences of 0, then extracts the second instance onwards.</p>
<p><strong>Performance benchmarking</strong></p>
<p>Tested on Python 3.6.2 / Numpy 1.13.1. Performance will be system and array specific.</p>
<pre><code>%timeit jp(myarr.copy())         # 183 µs
%timeit vui(mylist.copy())       # 393 µs
%timeit original(mylist.copy())  # 1.85 s

import numpy as np
from collections import Counter

myarr = np.array([4, 1, 2, 6, 1, 0, 9, 8, 0, 9] * 1000)
mylist = [4, 1, 2, 6, 1, 0, 9, 8, 0, 9] * 1000

def jp(myarr):
    return np.delete(myarr, np.where(myarr == 0)[0][1:])

def vui(mylist):
    return [0] + list(filter(None, mylist))

def original(mylist):
    for i in mylist:
        if mylist.count(0) &gt; 1:
            mylist.remove(0)

    return mylist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Slicing should do</p>
<pre><code>a[start:end] # items start through end-1
a[start:]    # items start through the rest of the list
a[:end]      # items from the beginning through end-1
a[:]         # a copy of the whole list
</code></pre>
<p>Input:</p>
<pre><code>mylist = [4,1, 2, 6, 1, 0, 9, 8, 0, 9,0,0,9,2,2,]
pos=mylist.index(0)
nl=mylist[:pos+1]+[i  for i in mylist[pos+1:] if i!=0]

print(nl)
</code></pre>
<p>Output:<code>[4, 1, 2, 6, 1, 0, 9, 8, 9, 9, 2, 2]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this:</p>
<pre><code>desired_value = 0
mylist = [i for i in mylist if i!=desired_value] + [desired_value]
</code></pre>
<p>You can now change your desired value,
you can also make it as a list like this</p>
<pre><code>desired_value = [0, 6]
mylist = [i for i in mylist if i not in desired_value] + desired_value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you can use a <code>filter</code>.</p>
<pre><code>[0] + list(filter(lambda x: x != 0, mylist))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use an <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer">itertools.count</a> counter 
which will return 0, 1, ... each time it is iterated on:</p>
<pre><code>from itertools import count

mylist = [4, 1, 2, 6, 1, 0, 9, 8, 0, 9]

counter = count()

# next(counter) will be called each time i == 0
# it will return 0 the first time, so only the first time
# will 'not next(counter)' be True
out = [i for i in mylist if i != 0 or not next(counter)]
print(out)

# [4, 1, 2, 6, 1, 0, 9, 8, 9]
</code></pre>
<p>The order is kept, and it can be easily modified to deduplicate an arbitrary number of values:</p>
<pre><code>from itertools import count

mylist = [4, 1, 2, 6, 1, 0, 9, 8, 0, 9]

items_to_dedup = {1, 0}
counter = {item: count() for item in items_to_dedup}

out = [i for i in mylist if i not in items_to_dedup or not next(counter[i])]
print(out)

# [4, 1, 2, 6, 0, 9, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here's on line for it: where <code>m</code> is number to be occured once,and the order is kept</p>
<pre><code>[x for i,x in enumerate(mylist) if mylist.index(x)==i or x!=m]
</code></pre>
<p><strong>Result</strong></p>
<pre><code>[4, 1, 2, 6, 1, 0, 9, 8, 9]
</code></pre>
</div>
<span class="comment-copy">Does order matter in this list?</span>
<span class="comment-copy">what's wrong with your first solution? <code>[0] + [i for i in mylist if i != 0]</code></span>
<span class="comment-copy">I think you are most likely too concerned about  minor performance differences and should just go with one of your current solutions.</span>
<span class="comment-copy">Also, do you <i>only</i> need to remove duplicate zeroes specifically, or do you need a solution for arbitrary other values?</span>
<span class="comment-copy">What @DanielPryden is saying is that a different function might be written which expects a sorted list and is faster than any other solution, especially if the item to be removed is the smallest possible item in the list (which for 0 is likely)</span>
<span class="comment-copy">The <code>if 0 in mylist</code> check is also O(N) so I don't see how this would be better than the OP's second example which was already stated to be too slow.</span>
<span class="comment-copy">@DanielPryden you're right. Testing length is better. Edited.</span>
<span class="comment-copy">It might be better so set <code>counts[0] = min(1, counts[0])</code>, otherwise this code would insert a 0 into a list that doesn't have any.</span>
<span class="comment-copy">This is a very neat idea but (1) Almost certainly slower than OP's solutions and (2) Doesn't preserve order.</span>
<span class="comment-copy">if order doesn't matter, that's really nice. Order doesn't <i>seem</i> to matter though.</span>
<span class="comment-copy">@AlexHall: It's basically just a pidgeonhole sort, which is O(N). Why would that be substantially slower than the other approaches?</span>
<span class="comment-copy">@DanielPryden because it will execute much more code in Python space than in built in (probably C) space.</span>
<span class="comment-copy">Why <code>temp.pop()</code>? Why not just use a boolean local variable?</span>
<span class="comment-copy">@DanielPryden Because it's only one item and keeps the code neat. Also it doesn't make a noticeable difference in performance.</span>
<span class="comment-copy">What are the specifications of the computer, you did the benchmark on?</span>
<span class="comment-copy">@NikhilWagh, added Python + Numpy versions. I have provided code for you to test. Every machine will produce difference results.</span>
<span class="comment-copy">This is a slightly unfair comparison because you assume that the list is already a numpy array. If we're changing the input type then we should do the same for the Counter-based approach. Or else make building the array part of the timeit test.</span>
<span class="comment-copy">@DanielPryden, In your case, there are still assumptions. In <i>almost all</i> cases, upstream processes (reading from csv, retrieving from calculation, etc) can be further optimised by moving to <code>numpy</code>. The point is, <i>if performance is the problem</i>, consider a library which is specifically designed to improve performance. Or move to C.</span>
<span class="comment-copy">You should always prefer using a list comprehension rather than <code>filter</code> + <code>lambda</code>. The list comprehension will be shorter, clearer, and usually substantially faster.</span>
<span class="comment-copy"><code>filter(None,mylist)</code> is better</span>
<span class="comment-copy">@DanielPryden Thanks.</span>
<span class="comment-copy">@Jean-FrançoisFabre yes of course ! Here it was just for exemple, it's could be '42' ;-)</span>
<span class="comment-copy"><code>filter(None,x)</code> is the exact case where you don't need any lambda, or any function. It just keeps the "truthy" values.</span>
<span class="comment-copy">This approach is terribly inefficient. Calling <code>list.index</code> with O(n) complexity for all the items plus two condition checking!</span>
