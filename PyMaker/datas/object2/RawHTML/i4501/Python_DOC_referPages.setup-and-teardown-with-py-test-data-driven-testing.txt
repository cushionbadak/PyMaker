<div class="post-text" itemprop="text">
<p>I have a lot of tests that basically do the same actions but with different data, so I wanted to implement them using pytest, I managed to do it in a typical junit way like this:</p>
<pre><code>import pytest
import random

d = {1: 'Hi',2: 'How',3: 'Are',4:'You ?'}

def setup_function(function):
    print("setUp",flush=True)

def teardown_function(functions):
    print("tearDown",flush=True)

@pytest.mark.parametrize("test_input", [1,2,3,4])
def test_one(test_input):
    print("Test with data " + str(test_input))
    print(d[test_input])
    assert True
</code></pre>
<p>Which gives me the following output</p>
<p>C:\Temp&gt;pytest test_prueba.py -s</p>
<p>============================= test session starts =============================
platform win32 -- Python 3.6.5, pytest-3.5.0, py-1.5.3, pluggy-0.6.0
rootdir: C:\Temp, inifile:
collected 4 items</p>
<p>test_prueba.py </p>
<p>setUp</p>
<p>Test with data 1</p>
<p>Hi</p>
<p>.tearDown</p>
<p>setUp</p>
<p>Test with data 2</p>
<p>How</p>
<p>.tearDown</p>
<p>setUp</p>
<p>Test with data 3</p>
<p>Are</p>
<p>.tearDown</p>
<p>setUp</p>
<p>Test with data 4</p>
<p>You ?</p>
<p>.tearDown</p>
<p>========================== 4 passed in 0.03 seconds ===========================</p>
<p>The problem now is that I would perform some actions also in the setup and teardown that I need to access to the test_input value</p>
<p>Is there any elegant solution for this ?
Maybe to achieve this I should use the parametrization or the setup teardown in a different way ?
If that the case can someone put an example of data driven testing with setup and teardown parametrized ?</p>
<p>Thanks !!!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>parameterize</code> on a test is more for just specifying raw inputs and expected outputs. If you need access to the parameter in the setup, then it's more part of a fixture than a test.</p>
<p>So you might like to try:</p>
<pre><code>import pytest

d = {"good": "SUCCESS", "bad": "FAIL"}

def thing_that_uses_param(param):
    print("param is", repr(param))
    yield d.get(param)
    print("test done")

@pytest.fixture(params=["good", "bad", "error"])
def parameterized_fixture(request):
    param = request.param
    yield from thing_that_uses_param(param)

def test_one(parameterized_fixture):
    assert parameterized_fixture.lower() == "success"
</code></pre>
<p>Which outputs:</p>
<pre><code>============================= test session starts =============================
platform win32 -- Python 3.5.1, pytest-3.4.0, py-1.5.2, pluggy-0.6.0 -- c:\Users\User\AppData\Local\Programs\Python\Python35-32\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\User\Documents\python, inifile:

collecting ... collected 3 items

a.py::test_one[good] PASSED                                              [ 33%]
a.py::test_one[bad] FAILED                                               [ 66%]
a.py::test_one[error] FAILED                                             [100%]

================================== FAILURES ===================================
________________________________ test_one[bad] ________________________________

parameterized_fixture = 'FAIL'

    def test_one(parameterized_fixture):
&gt;       assert parameterized_fixture.lower() == "success"
E       AssertionError: assert 'fail' == 'success'
E         - fail
E         + success

a.py:28: AssertionError
---------------------------- Captured stdout setup ----------------------------
param is 'bad'
-------------------------- Captured stdout teardown ---------------------------
test done
_______________________________ test_one[error] _______________________________

parameterized_fixture = None

    def test_one(parameterized_fixture):
&gt;       assert parameterized_fixture.lower() == "success"
E       AttributeError: 'NoneType' object has no attribute 'lower'

a.py:28: AttributeError
---------------------------- Captured stdout setup ----------------------------
param is 'error'
-------------------------- Captured stdout teardown ---------------------------
test done
===================== 2 failed, 1 passed in 0.08 seconds ======================
</code></pre>
<p>However, that requires that you create a parameterized fixture for each set of parameters you might want to use with a fixture.</p>
<p>You could alternatively mix and match the parameterized mark and a fixture that reads those params, but that requires the test to uses specific names for the parameters. It will also need to make sure such names are unique so it won't conflict with any other fixtures trying to do the same thing. For instance:</p>
<pre><code>import pytest

d = {"good": "SUCCESS", "bad": "FAIL"}

def thing_that_uses_param(param):
    print("param is", repr(param))
    yield d.get(param)
    print("test done")

@pytest.fixture
def my_fixture(request):
    if "my_fixture_param" not in request.funcargnames:
        raise ValueError("could use a default instead here...")
    param = request.getfuncargvalue("my_fixture_param")
    yield from thing_that_uses_param(param)

@pytest.mark.parametrize("my_fixture_param", ["good", "bad", "error"])
def test_two(my_fixture, my_fixture_param):
    assert my_fixture.lower() == "success"
</code></pre>
<p>Which outputs:</p>
<pre><code>============================= test session starts =============================
platform win32 -- Python 3.5.1, pytest-3.4.0, py-1.5.2, pluggy-0.6.0 -- c:\Users\User\AppData\Local\Programs\Python\Python35-32\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\User\Documents\python, inifile:
collecting ... collected 3 items

a.py::test_two[good] PASSED                                              [ 33%]
a.py::test_two[bad] FAILED                                               [ 66%]
a.py::test_two[error] FAILED                                             [100%]

================================== FAILURES ===================================
________________________________ test_two[bad] ________________________________

my_fixture = 'FAIL', my_fixture_param = 'bad'

    @pytest.mark.parametrize("my_fixture_param", ["good", "bad", "error"])
    def test_two(my_fixture, my_fixture_param):
&gt;       assert my_fixture.lower() == "success"
E       AssertionError: assert 'fail' == 'success'
E         - fail
E         + success

a.py:25: AssertionError
---------------------------- Captured stdout setup ----------------------------
param is 'bad'
-------------------------- Captured stdout teardown ---------------------------
test done
_______________________________ test_two[error] _______________________________

my_fixture = None, my_fixture_param = 'error'

    @pytest.mark.parametrize("my_fixture_param", ["good", "bad", "error"])
    def test_two(my_fixture, my_fixture_param):
&gt;       assert my_fixture.lower() == "success"
E       AttributeError: 'NoneType' object has no attribute 'lower'

a.py:25: AttributeError
---------------------------- Captured stdout setup ----------------------------
param is 'error'
-------------------------- Captured stdout teardown ---------------------------
test done
===================== 2 failed, 1 passed in 0.08 seconds ======================
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think that what you are looking for is yield fixtures, 
you can make an auto_use fixture the run something before every test and after
and you can access all the test metadata (marks, parameters and etc)
you can read it 
<a href="https://pytest.readthedocs.io/en/reorganize-docs/yieldfixture.html" rel="nofollow noreferrer">here</a></p>
<p>and the access to parameters is via function argument called request </p>
</div>
<div class="post-text" itemprop="text">
<p>IMO, set_up and tear_down should not access test_input values. If you want it to be that way, then probably there is some problem in your test logic. </p>
<p>set_up and tear_down must be independent of values used by test. However, you may use another fixture to get the task done.</p>
</div>
<span class="comment-copy">Have a look at Python's <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code> statement</a>. Is this what you're looking for? You basically create a class with a standard setup/teardown template. See also <a href="http://preshing.com/20110920/the-python-with-statement-by-example/" rel="nofollow noreferrer">this</a> example</span>
<span class="comment-copy">Hi,thanks for the answer; I followed your second example and it works but would you mind explaining it a little better ? What is the meaning of the yield and yield from ? (I've just been working in Python for a few months, I come from a Jave/C#/Powershell background)  Thanks again for your answer</span>
<span class="comment-copy">That sounds kind of in the direction (Despite I was hoping that there still was a simple approach like JUnit setup teardown but with access to the current test of the data driven parameters)  How you combine those fixtures with data driven ?</span>
<span class="comment-copy">Note that the <i>yield_fixture</i> decorator is considered deprecated, use <i>yield</i>: <a href="https://pytest.readthedocs.io/en/latest/historical-notes.html#pytest-yield-fixture-decorator" rel="nofollow noreferrer">pytest.readthedocs.io/en/latest/â€¦</a></span>
<span class="comment-copy">I agree with your first point, but if you elaborate on "another fixture" with examples that would help a lot.</span>
