<div class="post-text" itemprop="text">
<p>Is there some function which can converts a context manager to a decorator?</p>
<p>i.e. I can quickly write the following, but I hope don't miss the common wheel..</p>
<p>Thanks!</p>
<pre><code>def context_manager_to_decorator(context_manager: ContextManager):
  def decorator(func):
    if context_manager is None:
      return func

    @functools.wraps(func)
    def decorated(*args, **kwargs):
      with context_manager:
        return func(*args, **kwargs)
    return decorated
  return decorator
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is very similar functionality already in the stdlib as <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ContextDecorator" rel="nofollow noreferrer"><code>contextlib.ContextDecorator</code></a>.</p>
<p>However, <code>ContextDecorator</code> is a class, and the way it's usually used is to inheriting from <code>ContextDecorator</code> (it works fine as a mixin if you have some other primary base class that has to come first). So all of your context manager class's instances are automatically usable as decorators, rather than passing specific instances to a decorator factory. It also has some nice bells &amp; whistles, which you can find by reading the docs.</p>
<p>It's worth noting that most context managers defined in that library, and all context managers that you create with the <code>@contextlib.contextmanager</code> decorator, are already <code>ContextDecorator</code>s. And for many of the other context managers in builtins and the stdlib (like files, or locks), usefulness a decorator is a little questionable—but there are some examples I could see wanting to wrap up this way, like <code>decimal</code> context context managers.</p>
</div>
<span class="comment-copy">I doubt it'd be useful for most use cases - you usually don't want to use the same context manager every time. It's hard to convert <code>with self._lock</code> or <code>with open(whatever)</code> into something that makes sense as a decorator, and the contortions involved would probably be messier than using a context manager the normal way.</span>
<span class="comment-copy">@user2357112 I could see this being useful for things like <code>decimal</code> context context managers, especially if you're hoping to be able to upgrade them all to PEP 567 contextvars context context managers as soon as you migrate to 3.7 (and come up with a better way to phrase it that doesn't say "context" three times in a row…). But I think you'd still probably want to write a couple of special-case decorators rather than abstracting it like this.</span>
<span class="comment-copy">By the way, what's the point of <code>if context_manager is None:</code>? Why would you ever use <code>@context_manager_to_decorator(None)</code> in your code?</span>
<span class="comment-copy">What I <i>can't</i> think of is a good use case for where you'd want some particular instance of a context manager class to be usable as a decorator, but not want all instances to be usable. If you <i>do</i> have such a use case, you should edit it into your question, possibly write your own answer (explaining why <code>ContextDecorator</code> doesn't handle your use case and your implementation does), talk to Nick Coghlan about adding it to <a href="http://contextlib2.readthedocs.io/" rel="nofollow noreferrer"><code>contextlib2</code></a>, and then see if it gets any uptake and propose it to be added to 3.8 or 3.9 if it does.</span>
<span class="comment-copy">I think the <code>refresh_cm</code> you're thinking of is <code>_recreate_cm</code>, which is intended only as support for <code>@contextmanager</code>. The default implementation in <code>ContextDecorator</code> just does <code>return self</code>.</span>
<span class="comment-copy">@user2357112 Or maybe I'm thinking of something that was public in <code>contextlib2</code> but ended up being an implementation detail of <code>@contextmanager</code> when it went into the stdlib. Probably better to read the docs than to rely on my memory (both for me and for the OP and others who seek the same answer)…</span>
