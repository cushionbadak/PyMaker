<div class="post-text" itemprop="text">
<p>I have a list of characters</p>
<pre><code>a = ["s", "a"]
</code></pre>
<p>I have some words.</p>
<pre><code>b = "asp"

c= "lat"

d = "kasst"
</code></pre>
<p>I know that the characters in the list can appear only once or in linear order(or at most on small set can appear in the bigger one).</p>
<p>I would like to split my words by putting the elements in a in the middle, an the rest on the left or on the right (and put a "=" if there is nothing) </p>
<p>so <code>b = ["*", "as", "p"]</code></p>
<p>If a bigger set of characters which contains </p>
<pre><code>d = ["k", "ass", "t"]
</code></pre>
<p>I know that the combinations can be at most of length 4.</p>
<p>So I have divided the possible combinations depending on the length:</p>
<pre><code>import itertools

c4 = [''.join(i) for i in itertools.product(a, repeat = 4)]
c3 = [''.join(i) for i in itertools.product(a, repeat = 3)]
c2 = [''.join(i) for i in itertools.product(a, repeat = 2)]
c1 = [''.join(i) for i in itertools.product(a, repeat = 1)]
</code></pre>
<p>For each c, starting with the greater 
For simplicity, let's say I start with c3 in this case and not with length 4. </p>
<p>I have to do this with a lot of data.</p>
<p>Is there a way to simplify the code ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do something similar using a regular expression:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile(r'([sa]{1,4})')
</code></pre>
<p><code>p</code> matches the characters 's' or 'a' repeated between 1 and 4 times.</p>
<p>To split a given string at this pattern, use <code>p.split</code>. The use of capturing parentheses in the pattern leads to the pattern itself being included in the result.</p>
<pre><code>&gt;&gt;&gt; p.split('asp')
['', 'as', 'p']
&gt;&gt;&gt; p.split('lat')
['l', 'a', 't']
&gt;&gt;&gt; p.split('kasst')
['k', 'ass', 't']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use regex ?</p>
<pre><code>import re
a = ["s", "a"]
text = "kasst"
pattern = re.compile("[" + "".join(a) + "]{1,4}")
match = pattern.search(text)
parts = [text[:match.start()], text[match.start():match.end()], text[match.end():]]
parts = [part if part else "*" for part in parts]
</code></pre>
<p>However, note that this won't handle the case when there is no match on the elements in a</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do a regular expression to simplify the matching.</p>
<pre><code>import re

splitters = ''.join(a)
pattern = re.compile("([^%s]*)([%s]+)([^%s]*)" % (splitters, splitters, splitters))
words = [v if v else '=' for v in pattern.match(s).groups() ]
</code></pre>
<p>This doesn't allow the characters in the first or last group, so not all string will match correctly (and throw an exception). You can allow them if you want. Feel free to modify the regular expression to better match what you want it to do.</p>
<p>Also you only need to run the <code>re.compile</code> once, not for every string you are trying to match.</p>
</div>
<span class="comment-copy">Have you considered <code>itertools.groupby</code>? key would be <code>a.__contains__</code>.</span>
<span class="comment-copy">What should be the result for <code>c = 'lat'</code>?</span>
<span class="comment-copy">You can have <code>p.split()</code> include the pattern itself by enclosing the pattern in grouping parentheses: e.g. <code>re.split(r'([sa]{1,4})', 'kasst')</code> -&gt; <code>['k', 'ass', 't']</code>.</span>
<span class="comment-copy">@KarlKnechtel Thanks!</span>
<span class="comment-copy">is this correct : ""]{1,4}"" I obtain: invalid syntax</span>
<span class="comment-copy"><code>re.split</code> as shown in @mkrieger1's answer is more robust and gets the matching parts more easily. This answer shows how to construct the <code>pattern</code> dynamically given the original list of characters, which is also useful for OP.</span>
<span class="comment-copy">The <code>]</code> matches the <code>[</code> at the beginning of the assembled string, and <code>{1,4}</code> specifies the minimum and maximum number of matches for the character class. See regex documentation e.g. <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">docs.python.org/3/library/re.html#regular-expression-syntax</a> for more info. There was a missing <code>+</code> in the code which I have edited in. It is perhaps more elegant to build this string using string formatting, however.</span>
<span class="comment-copy">I obtain an invalid syntax with else</span>
<span class="comment-copy">@Jack sorry, I've placed it in the wrong place. I've fixed it now, please try it.</span>
