<div class="post-text" itemprop="text">
<p>Given is a list containing lists of arbitrary lengths. Each list contains the keys of one level for the dictionary. </p>
<p>Example:</p>
<p>Given the list "DL"</p>
<pre><code>DL = [['A1'],['A11','A12'],['B1'],['B11','B12']] # &lt;- All entries are strings
</code></pre>
<p>I would like to create a nested dictionary with four levels of the following structure:
<a href="https://i.stack.imgur.com/6Q9Ro.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/6Q9Ro.png"/></a></p>
<p>In Python notation:</p>
<pre><code>D = {'A1': {'A11': {'B1': {'B11': [], 'B12': []}},
            'A12': {'B1': {'B11': [], 'B12': []}}}}
</code></pre>
<p>The values of the last level dictionaries (B11, B12) should be empty lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple recursive function. Since all the nested dicts are the same, the function simply recurses once to build the sub-dict, and then copies it for each value with <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>copy.deepcopy</code></a>.</p>
<pre><code>import copy

def dictify(lst):
    if not lst:
        return []

    sub_dict = dictify(lst[1:])
    return {value: copy.deepcopy(sub_dict) for value in lst[0]}
</code></pre>
<p>Pretty-printed output of <code>dictify(DL)</code>:</p>
<pre><code>{'A1': {'A11': {'B1': {'B11': [], 'B12': []}},
        'A12': {'B1': {'B11': [], 'B12': []}}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution iterates through each depth, starting at the "end" of the list, then iterates through each element, assigning it to the previous depth's dictionary.</p>
<pre><code>DL = [['A1'],['A11','A12'],['B1'],['B11','B12']]
DL_rev = DL[::-1] #reverse list - we want to create the smallest dicionaries first

# Initialise dictionary where solution will be stored
my_dictionary = {}

# Calculate depth of dictionaries
depth = len(DL)

# Temporary dictionary
temp = {}

# First initialise the dictionary of empty arrays, into temp
for k in DL_rev[0]:
    temp[k] = []

# For each depth, create a new dictionary
for i in range(1, depth):
    my_dictionary = {}
    # For each element, create an entry for it in the dictionary
    for j in DL_rev[i]:
        my_dictionary[j] = temp.copy()
    temp = my_dictionary.copy() #make a copy of the dictionary, for the next level up

D = {'A1': {'A11': {'B1': {'B11': [], 'B12': []}},
        'A12': {'B1': {'B11': [], 'B12': []}}}}
print(D)
print(my_dictionary)
print(D == my_dictionary)
</code></pre>
<p>Output:</p>
<pre><code>{'A1': {'A12': {'B1': {'B12': [], 'B11': []}}, 'A11': {'B1': {'B12': [], 'B11': []}}}}
{'A1': {'A12': {'B1': {'B12': [], 'B11': []}}, 'A11': {'B1': {'B12': [], 'B11': []}}}}
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution can be reduced to creating a dictionary tree structure from a Cartesian product.</p>
<p>This is a solution based on <code>collections.defaultdict</code> and <code>itertools.product</code>.</p>
<pre><code>from collections import defaultdict
from itertools import product

DL = [['A1'],['A11','A12'],['B1'],['B11','B12']]

rec_dd = lambda: defaultdict(rec_dd)
d = rec_dd()

for route in product(*DL):
    i = d[route[0]]
    for j in route[1:-1]:
        i = i[j]
    i[route[-1]] = []
</code></pre>
<p>Result:</p>
<pre><code>defaultdict({'A1': defaultdict({'A11': defaultdict({'B1': defaultdict({'B11': [],
                                                                       'B12': []})}),
                                'A12': defaultdict({'B1': defaultdict({'B11': [],
                                                                       'B12': []})})})})
</code></pre>
</div>
<span class="comment-copy">Could you show us the output as an actual dictionary instead of an image of ascii art, please?</span>
<span class="comment-copy">What have you tried so far? Some code, please.</span>
<span class="comment-copy">If they're strings, why not make them strings? First thing I have to do when I try to come up with an answer to your question is inserting a bunch of quotation marks just so the input doesn't throw an exception. That's not a great start.</span>
<span class="comment-copy">Your code isn't copying the dicts properly. Some of those dicts are the same dict object; you have to use <code>copy.deepcopy(my_dictionary)</code> instead of <code>my_dictionary.copy()</code>. (You can see this if you try <code>my_dictionary['A1']['A11']['B1']['B11'] = 5</code> - the 5 will show up in <code>my_dictionary</code> twice.)</span>
