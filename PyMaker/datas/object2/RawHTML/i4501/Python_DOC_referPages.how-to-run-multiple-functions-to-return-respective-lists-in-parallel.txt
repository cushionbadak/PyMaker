<div class="post-text" itemprop="text">
<p>In the example code, I would like to run 4 functions in parallel and return list values for each. Is the multiprocessing package appropriate for this task? If so how do I implement it?</p>
<p>Example Code:</p>
<pre><code>from multiprocessing import Pool

def func_a(num):
    return([1+num,2+num,3+num])

def func_b(num):
    return([10+num,11+num,12+num])

def func_c(num):
    return([20+num,21+num,22+num])

def func_d(num):
    return([30+num,31+num,32+num])

if __name__ == '__main__':
    pool = Pool(processes=2)

    list_a = ???
    list_b = ???
    list_c = ???
    list_d = ???

    full_list = []
    for item in list_a:
        full_list.append(item)
    for item in list_b:
        full_list.append(item)
    for item in list_c:
        full_list.append(item)
    for item in list_d:
        full_list.append(item)
</code></pre>
<p>Any information much appreciated. Thanks in advance. </p>
</div>
<div class="post-text" itemprop="text">
<p>As explained in <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="nofollow noreferrer">Process Pools</a>, you need to submit all of the jobs to the pool, and then wait for all of the results.</p>
<p>I'm not sure what arguments you want to pass to these functions, since it isn't in your question or your code, but I'll just make up something arbitrary.</p>
<pre><code>if __name__ == '__main__':
    pool = Pool(processes=2)

    result_a = pool.apply_async(func_a, (23,))
    result_b = pool.apply_async(func_b, (42,))
    result_c = pool.apply_async(func_c, (fractions.Fraction(1, 2),))
    result_d = pool.apply_async(func_a, (1j * math.pi,))

    full_list = []
    for item in result_a.get():
        full_list.append(item)
    for item in result_b.get():
        full_list.append(item)
    for item in result_c.get():
        full_list.append(item)
    for item in result_d.get():
        full_list.append(item)
</code></pre>
<p>You can dramatically simplify this in multiple ways (e.g., each of those <code>for</code> loops can be replaced by a single call to <code>extend</code>, or you can just write <code>full_list = result_a.get() + result_b.get() + result_c.get() + result_d.get())</code>, but this is the smallest change to your existing code that works. (And if you really want to simplify this code, I think you'd be happier with <code>concurrent.futures.ProcessPoolExecutor</code> in the first place.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming (since my question was never answered) that each function receives the same number:</p>
<pre><code>def apply_func(f):
    return f(3)

full_list = sum(pool.map(apply_func, [func_a, func_b, func_c, func_d]), [])
</code></pre>
</div>
<span class="comment-copy">Do you pass a different number to each function?</span>
<span class="comment-copy">The args for apply_async need to be wrapped in an iterable, e.g. <code>pool.apply_async(func_a, [23])</code>.</span>
<span class="comment-copy">@AlexHall Oops, I always forget which methods in <code>multiprocessing</code> take <code>args</code> and which take <code>*args</code>â€¦ thanks; fixed.</span>
