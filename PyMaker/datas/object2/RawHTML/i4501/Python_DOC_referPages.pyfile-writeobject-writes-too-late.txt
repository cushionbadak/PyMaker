<div class="post-text" itemprop="text">
<p>I have more or less this code:</p>
<pre class="lang-c prettyprint-override"><code>PyObject* py_list(PyObject* obj) {
    printf("py_list: %p, ", obj);
    PyObject* pystdout = PySys_GetObject("stdout");
    PyFile_WriteObject(obj, pystdout, Py_PRINT_RAW);
    printf("\n");
    printf("py_list: %p\n", pystdout);
    if (obj == NULL) {
        return PyList_New(0);
    }
    PyObject* result = PyList_New(1);
    PyList_SetItem(result, 0, obj);
    printf("py_list returns: %p, ", result);
    PyFile_WriteObject(result, pystdout, Py_PRINT_RAW);
    printf("\n");
    return result;
}
</code></pre>
<p>What I really would like is to replicate <code>str(obj)</code> (the Python 2 version of), and then use the result in <code>printf</code> call.  I cannot find a sane API for calling something like this.  So, <code>PyFile_WriteObject</code> was the closest I could find...  However, instead of writing to <code>stdout</code>, it waits until every possible interaction with <code>stdout</code> finishes in C, and only then it prints whatever it was supposed to...</p>
<p>I've looked at what Cython generates for code like <code>print(obj)</code> or <code>str(obj)</code>, and I want to pull my hair out, it's so complex.  All I need, really, is to be able to print out the Python objects for debugging purposes.  I also tried the GDB way, but Python objects are such a mess when you look at them from GDB perspective, it's not really workable either.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>However, instead of writing to <code>stdout</code>, [<code>PyFile_WriteObject</code>] waits until every possible interaction with <code>stdout</code></p>
</blockquote>
<p>You are likely getting bitten by Python-level buffering. A call to <code>PyObject_CallMethod(pystdout, "flush", "")</code> would probably fix the issue.</p>
<blockquote>
<p>What I really would like is to replicate <code>str(obj)</code> (the Python 2 version of), and then use the result in <code>printf</code> call.</p>
</blockquote>
<p>The API you're looking for is <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_Str" rel="nofollow noreferrer"><code>PyObject_Str</code></a> in combination with <a href="https://docs.python.org/3/c-api/unicode.html?highlight=pyunicode_asutf8#c.PyUnicode_AsUTF8" rel="nofollow noreferrer"><code>PyUnicode_AsUTF8</code></a>. This allows things like:</p>
<pre><code>printf("py_list returns: %s\n", PyUnicode_AsUTF8(PyObject_Str(result)));
</code></pre>
<p>That will leak the string returned by <code>__str__</code> and crash if <code>PyObject_Str</code> raises; the correct version could look like this:</p>
<pre><code>void print_obj(PyObject *o) {
    PyObject *o_str = PyObject_Str(o);
    if (!o_str) {
        PyErr_Print();
        return;
    }
    printf("%s\n", PyUnicode_AsUTF8(o_str));
    Py_DECREF(o_str);
}
</code></pre>
</div>
<span class="comment-copy">Even more complications appear to be necessary to do this in Python 3... since nothing is really convertible to strings, only to Unicode arrays. So, I need to first convert to Unicode, then to string, and only then printing.</span>
<span class="comment-copy">@wvxvw No complications whatsoever, <code>PyUnicode_AsUTF8</code> gives you UTF-8 which you can pass to <code>printf</code> just fine.</span>
