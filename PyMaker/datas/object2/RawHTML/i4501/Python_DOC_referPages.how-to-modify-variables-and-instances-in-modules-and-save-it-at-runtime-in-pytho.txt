<div class="post-text" itemprop="text">
<p>I have <code>main.py</code>,<code>header.py</code> and <code>var.py</code></p>
<blockquote>
<p><strong>header.py</strong></p>
</blockquote>
<pre><code>import var
class table():
    def __init__(self, name):
        self.name = name
</code></pre>
<blockquote>
<p><strong>var.py</strong></p>
</blockquote>
<pre><code>month = "jen"
table = "" # tried to make empty container which can save table instance but don't know how
</code></pre>
<blockquote>
<p><strong>main.py</strong></p>
</blockquote>
<pre><code>import header
import var

var.table = header.table(var.month)
var.month = "feb"
</code></pre>
<p>And after all this, I mean after this program ended. I want that <code>var.table</code> and <code>var.month</code> is modified and saved in <code>var.py</code>. </p>
<p>It's so confusing to deal with references in python.</p>
<p>I miss C &amp; pointer.</p>
</div>
<div class="post-text" itemprop="text">
<p>When your program ends, all your values are lost—unless you save them first, and load them on the next run. There are a variety of different ways to do this; which one you want depends on what kind of data you have and what you're doing with it.</p>
<p>The one thing you never, ever want to do is print arbitrary objects to a file and then try to figure out how to parse them later. If the answer to any of your questions is <code>ast.literal_eval</code>, you're saving things wrong.</p>
<p>One important thing to consider is when you save. If someone quits your program with ^C, and you only save during clean shutdowns, all your changes are gone.</p>
<h1>Numpy/Pandas</h1>
<p>Numpy and Pandas have their own built-in functions for saving data. See the <a href="https://docs.scipy.org/doc/numpy/reference/routines.io.html" rel="nofollow noreferrer">Numpy docs</a> and <a href="https://docs.scipy.org/doc/numpy/reference/routines.io.html" rel="nofollow noreferrer">Pandas docs</a> for all of the options, but the basic choices are:</p>
<ul>
<li>Text (e.g., <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html#numpy.savetxt" rel="nofollow noreferrer"><code>np.savetxt</code></a>): Portable formats, editable in a spreadsheet.</li>
<li>Binary (e.g., <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.save.html#numpy.save" rel="nofollow noreferrer"><code>np.save</code></a>): Small files, fast saving and loading.</li>
<li>Pickle (see below, but also builtin functions): Can save arrays with arbitrary Python objects.</li>
<li><a href="https://support.hdfgroup.org/HDF5/" rel="nofollow noreferrer">HDF5</a>. If you need HDF5 or NetCDF, you probably already know that you need it.</li>
</ul>
<h1>List of strings</h1>
<p>If all you have is a list of single-line strings, you just write them to a file and read them back line by line. It's hard to get simpler, and it's obviously human-readable.</p>
<p>If you need a short name for each value, or need separate sections, but your values are still all simple strings, you may want to look at <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer"><code>configparser</code></a> for CFG/INI files. But as soon as you get more complicated than that, look for a different format.</p>
<h1>Python source</h1>
<p>If you don't need to save anything, only load data (that your users might want to edit), you can use Python itself as a format—either a module that you <code>import</code>, or a script file that you <code>exec</code>. This can of course be very dangerous, but for a config file that's only being edited by people who already have your entire source code on their computer, that may not be a problem.</p>
<h1>JSON and friends</h1>
<p><a href="http://www.json.org/" rel="nofollow noreferrer">JSON</a> can save a single dict or list to a file and load it back. JSON is <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">built into the Python standard library</a>, and most other languages can also load and save it. JSON files are human-editable, although not beautiful.</p>
<p>JSON dicts and lists can be nested structure with other dicts and lists inside, and can also contain strings, floats, bools, and None, but nothing else. You can extend the <code>json</code> library with converters for other types, but it's a bit of work.</p>
<p><a href="http://yaml.org/" rel="nofollow noreferrer">YAML</a> is (almost) a superset of JSON that's easier to extend, and allows for prettier human-editable files. It doesn't have builtin support in the standard library, but there are a number of solid libraries on PyPI, like <a href="https://pypi.python.org/pypi/ruamel.yaml" rel="nofollow noreferrer"><code>ruamel.yaml</code></a>.</p>
<p>Both JSON and YAML can only save one dict or list per file. (The library will let you save multiple objects, but you won't be able to load them back, so be careful.) The simplest way around this is to create one big dict or list with all of you data packed into it. But <a href="http://jsonlines.org/" rel="nofollow noreferrer">JSON Lines</a> allows you save multiple JSON dicts in a single file, at the cost of human readability. You can load it just by <code>for line in file: obj = json.loads(obj)</code>, and you can save it with just the standard library if you know what you're doing, but you can also find third-party libraries like <a href="https://pypi.python.org/pypi/json-lines" rel="nofollow noreferrer"><code>json-lines</code></a> to do it for you.</p>
<h1>Key-value stores</h1>
<p>If what you want to store fits into a dict, but you want to have it on disk all the time instead of explicitly saving and loading, you want a key-value store.</p>
<p><a href="https://docs.python.org/3/library/dbm.html" rel="nofollow noreferrer"><code>dbm</code></a> is an old but still functional format, as long as your keys and values are all small-ish strings and you don't have tons of them. Python makes a <code>dbm</code> look like a <code>dict</code>, so you don't need to change most of your code at all.</p>
<p><a href="https://docs.python.org/3/library/shelve.html" rel="nofollow noreferrer"><code>shelve</code></a> extends <code>dbm</code> to let you save arbitrary values instead of just strings. It does this by using Pickle (see below), meaning it has the same safety issues, and it can also be slow.</p>
<p>More powerful key-value stores (and related things) are generally called NoSQL databases. There are lots of them nowadays; <a href="https://redis.io/" rel="nofollow noreferrer">Redis</a> is one of the popular choices. There's more to learn, but it can be worth it.</p>
<h1>CSV</h1>
<p><a href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="nofollow noreferrer">CSV</a> stands for "comma-separated values", although there are variations that use whitespace or other characters. CSV is <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">built into the standard library</a>.</p>
<p>It's a great format when you have a list of objects all with the same fields, as long as all of the members are strings or numbers. But don't try to stretch it beyond that.</p>
<p>CSV files are just barely human-editable as text—but they can be edited very easily in spreadsheet programs like Excel or Google Sheets.</p>
<h1>Pickle</h1>
<p><a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">Pickle</a> is designed to save and load just about anything. This can be dangerous if you're reading arbitrary pickle files supplied by users, but it can also be very convenient. Pickle actually can't quite save and load everything unless you do a lot of work to add support to some of your types, but there's a third-party library named <a href="https://pypi.python.org/pypi/dill" rel="nofollow noreferrer"><code>dill</code></a> that extends support a lot further.</p>
<p>Pickle files are not at all human-readable, and are only compatible with Python, and sometimes not even with older versions of Python.</p>
<h1>SQL</h1>
<p>Finally, you can always build a full relational database. This it's quite as scary as it sounds.</p>
<p>Python has a database called <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer"><code>sqlite3</code></a> built into the standard library.</p>
<p>If that looks too complicated, you may want to consider <a href="https://docs.sqlalchemy.org/en/latest/" rel="nofollow noreferrer">SQLAlchemy</a>, which lets you store and query data without having to learn the SQL language. Or, if you search around, there are a number of fancier ORMs, and libraries that let you run custom list comprehensions directly against databases, and so on.</p>
<h1>Other formats</h1>
<p>There are ziklions of other standards out there for data files; <a href="https://docs.python.org/3/library/fileformats.html" rel="nofollow noreferrer">a few even come with support in the standard library</a>. They can be useful for special cases—plist files match what Apple uses for preferences on macOS and iOS; netrc files are a long-established way to store a list of server logins; XML is perfect if you have a time machine that can only travel to the year 2000; etc. But usually, you're better off using one of the common formats mentioned above.</p>
</div>
<span class="comment-copy">If you want to save <b>data</b> after the program has ended, use data files.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/28661860/how-could-i-save-data-after-closing-my-program">Possible duplicate</a>.</span>
<span class="comment-copy">Why do you miss C and pointers? Modifying C source files from C is not only even harder, but also even more useless, than doing the same from Python…</span>
<span class="comment-copy">@user202729 It's definitely a dup, but there surely must be a question with better answers than repr/literal_eval and "don't use pickle, but here's how to use pickle"…</span>
<span class="comment-copy">There's also <a href="https://stackoverflow.com/questions/4529815/saving-an-object-data-persistence">this one</a>, but it's basically a pickle vs. dill fight with no mention of JSON, YAML, CSV, cfg/ini/rc, …</span>
