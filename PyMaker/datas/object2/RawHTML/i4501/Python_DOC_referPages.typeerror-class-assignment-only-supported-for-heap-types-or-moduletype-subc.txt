<div class="post-text" itemprop="text">
<p>I'm trying to copy functions from an arbitrary 'base' class into my new object.  However, I'm getting the following error with this sample code. </p>
<pre><code>class my_base:
    def print_hey():
        print("HEY")

    def get_one():
        print(1)

class my_ext:
    def __init__(self, base):
        methods = [method for method in dir(base) if callable(getattr(base, method))]
        for method in methods:
            setattr(self, method, getattr(base, method))


me = my_ext(my_base)
me.get_one()
</code></pre>
<p>The above gets this error on the call to <code>setattr</code>.</p>
<pre><code> TypeError: __class__ assignment only supported for heap types or ModuleType subclasses
</code></pre>
<p>The statement works if I type it into the prompt after defining the above.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that all objects in python have a <code>__class__</code> attribute that stores the type of the object:</p>
<pre><code>&gt;&gt;&gt; my_base.__class__
&lt;class 'type'&gt;
&gt;&gt;&gt; type(my_base)
&lt;class 'type'&gt;
</code></pre>
<p>Since calling a class is how you create an instance of that class, they're considered callables and pass the <a href="https://docs.python.org/3/library/functions.html#callable" rel="nofollow noreferrer"><code>callable</code></a> test:</p>
<pre><code>&gt;&gt;&gt; callable(my_base)
True
&gt;&gt;&gt; my_base()
&lt;__main__.my_base object at 0x7f2ea5304208&gt;
</code></pre>
<p>And when your code tries to assign something to the <code>__class__</code> attribute the TypeError you've observed is thrown:</p>
<pre><code>&gt;&gt;&gt; object().__class__ = int
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: __class__ assignment only supported for heap types or ModuleType subclasses
</code></pre>
<hr/>
<p>So you need to be more specific about which attributes should be copied.</p>
<p>You could filter out attributes with double underscores:</p>
<pre><code>methods = [method for method in dir(base) if not method.startswith('__')
                                             and callable(getattr(base, method))]
</code></pre>
<p>Or you could filter out classes:</p>
<pre><code>methods = [method for method in dir(base) if callable(getattr(base, method)) and
                                     not isinstance(getattr(base, method), type)]
</code></pre>
<p>Or you could only allow functions by comparing to <a href="https://docs.python.org/3/library/types.html#types.FunctionType" rel="nofollow noreferrer"><code>types.FunctionType</code></a>:</p>
<pre><code>methods = [method for method in dir(base) if callable(getattr(base, method)) and
                           isinstance(getattr(base, method), types.FunctionType)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your instance object has many attributes that shouldn't be reassigned, and most of them pass the <code>callable</code> test:</p>
<pre><code>&gt;&gt;&gt; [item for item in dir(my_base) if callable(getattr(my_base, item))]
['__class__', '__delattr__', '__dir__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'get_one', 'print_hey']
</code></pre>
<p>You should restrict most of them. You could simply check for <code>item.startswith('__')</code> but I'm not sure what you want to do with <code>__repr__</code> and friends. Perhaps check for underbars after a whitelist?</p>
</div>
<div class="post-text" itemprop="text">
<p>Turns out that <code>__class__</code> is callable and that there are many other callables as well. </p>
<p>I just want the functions so the following does the job:</p>
<pre><code> import types
 . . . 
  methods = [method for method in dir(base) if isinstance(getattr(base, method), types.FunctionType)]
 . . .
</code></pre>
</div>
<span class="comment-copy">It appears that all the attributes returned by getattr() are considered callable.  So the first one <code>__class__</code> is what's causing this error.  Maybe there is some other way to tell if an attribute is a function?</span>
<span class="comment-copy">Why are you doing this? Why don't you subclass my_base?</span>
<span class="comment-copy">Even if we fixed that TypeError, the code still wouldn't work because you're adding unbound methods to an instance. Really, why are you doing this? This doesn't look like clean code.</span>
<span class="comment-copy">There are good reasons in this design to be doing this. That's not really the question.</span>
<span class="comment-copy">@Aran-Fey Its perfectly fine and okay to add methods to an instance like this. This is a dynamic language and dynamic happens.</span>
<span class="comment-copy">Yup!  And <code>__class__</code> turned out to be the real problem.</span>
<span class="comment-copy">It turns out the functions in my actual solution all start with the same prefix. So <code>startswith</code> was the right solution.</span>
<span class="comment-copy">great! I was going to make that very suggestion.</span>
<span class="comment-copy">That's going to catch other things you don't want like <code>__repl__</code>.</span>
