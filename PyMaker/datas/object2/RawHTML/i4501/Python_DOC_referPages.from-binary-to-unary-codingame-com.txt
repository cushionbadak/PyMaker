<div class="post-text" itemprop="text">
<p>This is part of codingame chucknorris game, when we want to start for a string, and then convert it to "unary", a code with only 0 and spaces. 
Here is my code, my problem is that nothing gets out my print. 
Ex : 
CC =&gt; 10000111000011 :</p>
<pre><code>0 0 (one 1)
00 0000 (four 0)
0 000 (three 1)
00 0000 (four 0)
0 00 (two 1)
</code></pre>
<p>CC gives : 0 0 00 0000 0 000 00 0000 0 00</p>
<pre><code>import sys
import math
# Auto-generated code below aims at helping you parse
# the standard input according to the problem statement.*

message = input()
# message to binary (01001)
bimsg = str([ bin(ord(ch))[2:].zfill(8) for ch in message ])[2:-2]

# function
to_chuck = ''
for n in bimsg:
    index = bimsg.index(n)
    if index &gt;= 1 and bimsg[index] == bimsg[index-1]:
        to_chuck+='0'
    else: 
        if n == 1:
            to_chuck+='0 0'
        elif n == 0:
            to_chuck+='00 0'

print(to_chuck)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are 4 mistakes in your code.</p>
<ol>
<li><p>The way you convert the input string to binary is incorrect. You're padding each character to 8 bits instead of 7, and since you're calling <code>str</code> on a list, strings with more than a single character will get commas between characters. The correct transformation is</p>
<pre><code>bimsg = ''.join(format(ord(x), 'b').zfill(7) for x in message)
</code></pre></li>
<li><p><code>index = bimsg.index(n)</code> will always give you the index of the <em>first</em> occurence of <code>n</code> in the input. If your input is <code>1010</code>, <code>bimsg.index('1')</code> will always return 0 and <code>bimsg.index('0')</code> will always return 1. This is not what you want.</p>
<p>To get the correct index, use the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> function:</p>
<pre><code>to_chuck = ''
for index, n in enumerate(bimsg):
    if index &gt;= 1 and bimsg[index] == bimsg[index-1]:
        to_chuck+='0'
    else: 
        if n == 1:
            to_chuck+='0 0'
        elif n == 0:
            to_chuck+='00 0'
</code></pre></li>
<li><p>Since <code>bimsg</code> is a string, <code>n</code> will also be a string. When you do <code>if n == 1</code> or <code>if n == 0</code>, you're comparing a string to a number - that will always evaluate to <code>False</code>. You have to compare <code>n</code> to strings instead:</p>
<pre><code>to_chuck = ''
for index, n in enumerate(bimsg):  # use enumerate here
    if index &gt;= 1 and bimsg[index] == bimsg[index-1]:
        to_chuck+='0'
    else: 
        if n == '1':
            to_chuck+='0 0'
        elif n == '0':
            to_chuck+='00 0'
</code></pre></li>
<li><p>Your code doesn't put any spaces between chunks of zeros and ones here:</p>
<pre><code>if n == '1':  # changed 1 to '1' here
    to_chuck+='0 0'
elif n == '0':  # changed 0 to '0' here
    to_chuck+='00 0'
</code></pre>
<p>The zeros you're adding there just melt together with the zeros at the end of <code>to_chuck</code>, giving you incorrect output. To fix this, just add a space:</p>
<pre><code>to_chuck = ''
for index, n in enumerate(bimsg):
    if index &gt;= 1 and bimsg[index] == bimsg[index-1]:
        to_chuck+='0'
    else: 
        if n == '1':
            to_chuck+=' 0 0'  # added leading space here
        elif n == '0':
            to_chuck+=' 00 0'  # added leading space here
to_chuck = to_chuck[1:]  # get rid of the leading space
</code></pre></li>
</ol>
<p>Now we get the correct output:</p>
<pre><code>print(to_chuck)
# 0 0 00 0000 0 000 00 0000 0 00
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def firstBlock(x):
    if x == "1":
        return "0"
    return "00"

def getBlock(x, counter):
    return firstBlock(x) + " " + ("0" * counter)

message = input()
result = ""

binaryString = ""
for x in message:
    binaryChar = format(ord(x), 'b')
    paddedChar = binaryChar.zfill(7)
    binaryString += paddedChar

counter = 1
currentChar = binaryString[0]

for x in binaryString[1:]:
    if x == currentChar:
        counter += 1
        continue

    result += getBlock(currentChar, counter) + " "
    counter = 1
    currentChar = x

result += getBlock(currentChar, counter)
print(result)
</code></pre>
</div>
<span class="comment-copy">"unary" and "0 and spaces" doesn't go together. Unary means there's only a single type of character, not two different ones. But more importantly, you should probably try to explain the conversation algorithm in a bit more detail. It's not exactly easy to figure out at the moment. Also, what's wrong with your code? Is the output incorrect? Does it throw an error?</span>
<span class="comment-copy">I deleted my answer though it was correct for the question in the post, addressing to the nothing out in print problem. However, test you code and it doesn't pass the requirements of the exercise as well: <a href="https://www.codingame.com/ide/puzzle/chuck-norris" rel="nofollow noreferrer">codingame chuck norris</a></span>
<span class="comment-copy">b.t.w you should also use a more straight-forward transformation of dtypes: <code>bimsg = ''.join(format(ord(x), 'b') for x in message)</code></span>
<span class="comment-copy">@mr_mo I didn't think the input transformation was part of the question. I fixed it, all the test cases pass now.</span>
