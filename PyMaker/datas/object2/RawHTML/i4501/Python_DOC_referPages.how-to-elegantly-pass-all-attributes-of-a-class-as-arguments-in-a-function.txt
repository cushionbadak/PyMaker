<div class="post-text" itemprop="text">
<p>I have a somewhat complex class <code>Thing</code>, and an associated mixin <code>IterMixin</code> (to make the class iterable)...and a <code>funky</code> method elsewhere in the codebase which receives an instance of my class as an argument.</p>
<p>In fact, I'm attempting to bundle up a bunch of parameters as single object to be passed to <em>multiple</em> external functions beyond the <code>funky</code> function below. A parameter object design pattern of sorts...</p>
<pre><code>class IterMixin():
    def __iter__(self):
        for attr, value in self.__dict__.items():
            yield attr, value

class Thing(IterMixin):
    def __iter__(self, foo=None, bar=None, baz=999):

        if foo is None:
            self.foo = {}
        else:
            self.foo = foo

        if bar is None:
            self.foo = {}
        else:
            self.bar = bar

        self.baz = baz

    @property
    def foo(self):
        return self._foo

    @foo.setter
    def foo(self, data)
        self._foo = self.parser(data)

    @property
    def bar(self):
        return self._bar

    @bar.setter
    def bar(self, more_data)
        self._bar, self.baz = self.another_parser(more_data)

    def parser(self, data):
        ...do stuff...
        return foo

    def another_parser(self, more_data):
        ...do add'l stuff...
        return bar, baz
</code></pre>
<p>With regard to the <code>funky</code> function, in a completely different module, via the <code>Thing</code> class, I want to pass <code>Thing</code>'s attributes (<code>foo</code>, <code>bar</code>, and <code>baz</code>) to the <code>funky</code> function as <em>one argument</em>...like so:</p>
<pre><code>    thing_args = Thing()

    def funky(*thing_args):
        ...do stuff...
        ...expecting to manipulate keys from things_arg
        ...
        return whatever
</code></pre>
<p>PROBLEM:</p>
<p>If I do not make the <em>setters</em> for the attributes <code>foo</code> and <code>bar</code> <em>private</em> (for example, via <code>self._foo</code>)--i.e., by way of an underscore--then I evoke  infinite recursion during class initialization ...as the <code>__init__</code> and setters for these attributes loop over and over and repeatedly call themselves. To avoid that, I used the<code>@property</code> decorator and "privatized" the foo and bar while setting them.</p>
<p>However, when I pass an instance of the <code>Thing</code> class, and unpack its attributes as args in the <code>funky</code> function via a splat or asterick, if I introspect the resultant keys for those attributes, I still get <code>_foo</code> and <code>_bar</code>. I can't seem to get rid of the underscores. (In other words, I get the "privatized" attribute names of <code>Thing</code>.)</p>
<p>The biz logic of <code>funky</code> needs the unpacked values to not have any underscores.</p>
<p>Why is this happening (the underscores upon unpacking)? How can I fix this? Is there a more elegant way to either initialize the foo and bar attributes without privatizing anything? Or perhaps a more Pythonic way to pass all the attributes in the <code>Thing</code> class to my <code>funky</code> function?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you've got a major problem that will prevent you from even seeing the problem you've asked for help with: Your <code>Thing</code> class defines an <code>__iter__</code> method that doesn't <code>super</code>, and doesn't <code>yield</code> or <code>return</code> anything. Hopefully that part is just some typo and you know how to fix it to do whatever you actually wanted there.</p>
<p>No, onto the problem you're asking about:</p>
<pre><code>class IterMixin():
    def __iter__(self):
        for attr, value in self.__dict__.items():
            yield attr, value
</code></pre>
<p>Try printing out the <code>__dict__</code> of your instances. Or, better, instances of a minimal example like this:</p>
<pre><code>class Thing:
    @property
    def foo(self):
        return self._foo
    @foo.setter
    def foo(self, data):
        self._foo = data

t = Thing()
t.foo = 2
print(t.__dict__)
</code></pre>
<p>The output is <code>{'_foo': 2}</code>.</p>
<p>You've tried to hide the attributes by giving them private names and putting them behind properties, but then you've gone around behind the properties' backs and looked directly into the <code>__dict__</code> where the real attributes are.</p>
<p>And what else <em>could</em> be there? Your actual <code>_foo</code> has to be stored <em>somewhere</em> on each instance. That <code>foo</code>, on the other hand, isn't really a value, it's a getter/setter that uses that private attribute, so it isn't stored anywhere.</p>
<p>If you really want to use reflection to find all of the "public values" on an instance, you can do something like this:</p>
<pre><code>for attr, value in inspect.getmembers(self):
    if not attr.startswith('_') and not callable(value):
        yield attr, value
</code></pre>
<p>However, I think it would be much better to <em>not</em> do this reflectively. Simpler and cleaner options include:</p>
<ul>
<li>Add a <code>_fields = 'foo', 'bar', 'baz'</code> and have the base class iterate <code>_fields_</code>.</li>
<li>Write a decorator that registers a property, and have the base class iterate that registry.</li>
<li>Build something that lets you specify the attributes more declaratively and writes the boilerplate for you. See <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>, <a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer"><code>dataclass</code></a>, and <a href="https://pypi.python.org/pypi/attrs" rel="nofollow noreferrer"><code>attrs</code></a> for some inspiration.</li>
<li>Just use <code>attrs</code> (or, if you're not the OP but someone reading this from the future who can rely on 3.7+, <code>dataclass</code>) to do that work for you.</li>
<li>Rethink your design. A class whose instances iterate name-value pairs of their public attributes is weird in the first place. A "parameter object" that acted like a mapping to be used for keyword-splatting could be useful; one that acted like a normal iterable could be useful; one that acts as an iterable of name-value pairs is useless for anything except for passing to a <code>dict</code> construct (at which point it's, again, simpler to be a mapping). Plus, a mixin is really not helping you with the hard part of doing it. <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">Whatever you actually need to do, ask for help on how to do that, instead of how to make this code that shouldn't work work anyway.</a></li>
</ul>
</div>
<span class="comment-copy">I think you are really overthinking this whole thing... But it looks like you are having fun, so I won't complain.</span>
<span class="comment-copy">why dont you just pass "thing" ? and use its attributes?</span>
<span class="comment-copy">If you want to be able to pass an instance as if it were a sequence of its attributes, why not just make it a sequence, or at least an iterable? See <code>namedtuple</code> in the stdlib for an example (although you don’t need to build anything that complicated).</span>
<span class="comment-copy">Meanwhile, if you’re looking for how to hide private attributes from even determined introspection, you’re just using the wrong language. Python “private” just means “private by convention”.</span>
<span class="comment-copy">You mean the attributes of <b>instances</b> of class <code>Thing</code>, right?</span>
<span class="comment-copy">Thank you! Super helpful. Was unfamiliar with both the dataclass in v3.7+ and unfamiliar with attrs. The latter did the trick via the <i>attrs_post_init</i> method. Also...thanks for turning me onto the X, Y Problem. Glad to have the vocab to know identify a widespread problem...of which, occasionally, I myself manifest.</span>
