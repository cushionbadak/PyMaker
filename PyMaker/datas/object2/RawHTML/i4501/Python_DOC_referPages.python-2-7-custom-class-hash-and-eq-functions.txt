<div class="post-text" itemprop="text">
<p>I'm having an issue which I believe is related to improper implementation of custom class <code>__eq__</code>/<code>__hash__</code> functions. </p>
<p>I created a custom <code>Line</code> class, where a line holds a slope and y intercept which are calculated from 2 Points. I'm running a test on equality between 2 lines, which is producing unexpected results as shown below. </p>
<p>I'm looking for an explanation of why the first 2 lines in the test code I've included below are not equal, but the 2nd set of 2 lines are equal, despite both sets of lines having matching values for slope and y intercept?</p>
<pre><code>class Point:
    def __init__(self, x1, y1):
        self.x = x1
        self.y = y1

    def to_string(self):
        return '{},{}'.format(self.x, self.y)

class Line:
    def __init__(self, pt1, pt2):
        self.m = (pt1.y - pt2.y)/(pt1.x - pt2.x)
        self.b = pt1.y - self.m * pt1.x

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.m == other.m and self.b == other.b
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash((self.m, self.b))

    def print_line(self):
        print('y = {} x + {}'.format(self.m, self.b))
</code></pre>
<p>test code:</p>
<pre><code>pt_a = Point(0.1, 1.0)
pt_b = Point(1.1, 1.1)
pt_c = Point(2.1, 1.2)
line1 = Line(pt_a, pt_b)
print('line1:')
line1.print_line()
line2 = Line(pt_b, pt_c)
print('line2:')
line2.print_line()
if line1 == line2:
    print('lines equal')
else:
    print('lines not equal')

pt_x = Point(0.5, 1)
pt_y = Point(1.5, 2)
pt_z = Point(2.5, 3)
line1 = Line(pt_x, pt_y)
print('line1:')
line1.print_line()
line2 = Line(pt_y, pt_z)
print('line2:')
line2.print_line()
if line1 == line2:
    print('lines equal')
else:
    print('lines not equal')
</code></pre>
<p>This test produces output:</p>
<pre><code>line1:
y = 0.1 x + 0.99
line2:
y = 0.1 x + 0.99
lines not equal
line1:
y = 1.0 x + 0.5
line2:
y = 1.0 x + 0.5
lines equal
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your original <code>line1</code> and <code>line2</code> are <em>not</em> equal, because of rounding errors.</p>
<p>They're <em>close</em>, close enough that your output is hiding the difference, but if you try printing the <code>repr</code> of the numbers (e.g., replacing each <code>{}</code> with <code>{!r}</code>), or just specifying a whole mess of digits in your format, you will see that they're the y-intercept values are actually <code>0.10000000000000009</code> and <code>0.09999999999999987</code>.</p>
<p>There's a famous paper called <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="nofollow noreferrer">What Every Computer Scientist Should Know About Floating Point</a> that's so important it's been incorporated by reference into various standards documents. (I've seen a few answer link to a similarly-named site, <a href="http://floating-point-gui.de/" rel="nofollow noreferrer">What Every Programmer Should Know About Floating Point</a>, which looks like it might be friendlier, but I can't vouch for its accuracy.)</p>
<p>Anyway, in general, the right way to deal with this is to use <code>math.isclose</code>. Of course if you want to learn Python 2.7 even though it's 2018, you can't do that, because it doesn't have such a thing. <a href="https://www.python.org/dev/peps/pep-0485/" rel="nofollow noreferrer">PEP 485</a> includes a pseudocode description of the algorithm, and links to a pure-Python implementation.</p>
<p>But in this specific case, there's an issue you have to think through: the values aren't actually equal, so they shouldn't hash the same. Does that break your intended design? Usually, the answer is that your design shouldn't be using lines, or anything else with <code>float</code> values, as dict keys, or whatever you were intending. But occasionally, it's worth building a wrapper that handles both equality and hashing by rounding things off to a fixed number of bits or digitsâ€”although that doesn't actually make rounding errors impossible; it just makes it possible to deal with them for some sets of input, so it only works if you know your input set.</p>
</div>
<div class="post-text" itemprop="text">
<p>Computing the same logical result in different ways with floating point numbers doesn't get consistent results. For highly precise values like this, you likely want to use an infinite precision numeric type, like <a href="https://docs.python.org/3/library/fractions.html#fractions.Fraction" rel="nofollow noreferrer"><code>fractions.Fraction</code></a>.</p>
<p>If you create your <code>Point</code>s with <code>Fraction</code> with equivalent but (unlike <code>float</code>) 100% precise values:</p>
<pre><code>from fractions import Fraction
pt_a = Point(Fraction(1, 10), Fraction(1))
pt_b = Point(Fraction(11, 10), Fraction(11, 10))
pt_c = Point(Fraction(21, 10), Fraction(12, 10))
</code></pre>
<p>then your code works as expected:</p>
<pre><code>line1 = Line(pt_a, pt_b)
print('line1:')
line1.print_line()
line2 = Line(pt_b, pt_c)
print('line2:')
line2.print_line()
if line1 == line2:
    print('lines equal')
else:
    print('lines not equal')
</code></pre>
<p>which prints:</p>
<pre><code>line1:
y = 1/10 x + 99/100
line2:
y = 1/10 x + 99/100
lines equal
</code></pre>
<p><code>fractions.Fraction</code> uses a normalized form of the <code>Fraction</code> too (as you can see, it's always <code>1/10 x + 99/100</code>, even with distinct <code>Point</code>s as input), so your hashing code will "just work".</p>
</div>
<span class="comment-copy">I'm not comparing Points, and Lines don't store the Points that they were created with.</span>
<span class="comment-copy">You're relying on floating-point rounding error being consistent or just not happening.</span>
<span class="comment-copy">See <a href="https://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow noreferrer">Floating Point Arithmetic: Issues and Limitations</a> for more information</span>
<span class="comment-copy">This problem is more than just the usual "floats aren't exact" problem, because the OP is writing <code>__hash__</code> methods, which means that he can't just use <code>isclose</code> or an equivalent.</span>
<span class="comment-copy">Side-note: If you want to allow other classes to work with your <code>Line</code>s, you should <code>return NotImplemented</code>, not <code>return False</code> when you don't recognize <code>other</code>'s type in <code>__eq__</code>. And your <code>__ne__</code> should be <code>ret = self.__eq__(other)</code>, <code>return ret if ret is NotImplemented else not ret</code> (the canonical body of <code>__ne__</code> on Python 2 to implement it correctly in terms of <code>__eq__</code>; Python 3 does this correctly automatically).</span>
