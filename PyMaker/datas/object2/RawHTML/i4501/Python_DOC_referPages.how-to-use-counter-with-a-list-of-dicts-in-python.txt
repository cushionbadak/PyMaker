<div class="post-text" itemprop="text">
<p>Having a list like this, I can get groups of the same values by:</p>
<pre><code>N = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]
C = Counter(N)
print([[k, ] * v for k, v in C.items()])
</code></pre>
<p>getting the following result.</p>
<pre><code>[[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5]]
</code></pre>
<p>However if I have the following list </p>
<pre><code>N = [{'doc':'A','value':300,'W':1},{'doc':'B','value':301,'W':0.5},{'doc':'C','value':301,'W':0.45},{'doc':'D','value':301,'W':0.3},{'doc':'E','value':300,'W':1},]
</code></pre>
<p>I want to group in the same way that the previous one, using the key 'value' to group them, namely:</p>
<pre><code>[[{'doc':A,'value':300,'W':1}, {'doc':'E','value':300,'W':1}],[{'doc':'B','value':301,'W':0.5},{'doc':'C','value':301,'W':0.45},{'doc':'D','value':301,'W':0.3}]]
</code></pre>
<p>Can somebody help?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collections.defaultdict</code> for this problem.</p>
<p><code>collections.Counter</code> is only useful for incrementing integer counters, and even then <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">only with hashable objects</a>. This isn't what you are looking to do here.</p>
<pre><code>from collections import defaultdict

N = [{'doc':'A','value':300,'W':1}, {'doc':'B','value':301,'W':0.5},
     {'doc':'C','value':301,'W':0.45}, {'doc':'D','value':301,'W':0.3},
     {'doc':'E','value':300,'W':1},]

d = defaultdict(list)

for i in N:
    d[i['value']].append(i)

res = list(d.values())

# [[{'W': 1, 'doc': 'A', 'value': 300}, {'W': 1, 'doc': 'E', 'value': 300}],
#  [{'W': 0.5, 'doc': 'B', 'value': 301},
#   {'W': 0.45, 'doc': 'C', 'value': 301},
#   {'W': 0.3, 'doc': 'D', 'value': 301}]]
</code></pre>
<hr/>
<p>As an aside, this also presents a more direct solution to your first problem:</p>
<pre><code>N = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]

d = defaultdict(list)

for i in N:
    d[i].append(i)

res = list(d.values())

# [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4], [5, 5, 5, 5, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That cannot be done with a Counter, for multiple reasons:</p>
<ol>
<li>Integers are hashable, dicts are not. <code>Counter</code> only works with hashable values.</li>
<li>All the grouped integers are the same, but the dicts are not. Only the "value" key of the dicts you're grouping is the same. Even if <code>Counter</code> worked with dicts, it would only keep 1 dict per group and discard the rest.</li>
</ol>
<hr/>
<p>The solution here is to use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> instead of a <code>Counter</code>:</p>
<pre><code>from collections import defaultdict

N = [{'doc':'A','value':300,'W':1},{'doc':'B','value':301,'W':0.5},
     {'doc':'C','value':301,'W':0.45},{'doc':'D','value':301,'W':0.3},
     {'doc':'E','value':300,'W':1}]

groups = defaultdict(list)
for dic in N:
    groups[dic['value']].append(dic)

result = list(groups.values())
# [[{'W': 1, 'doc': 'A', 'value': 300}, {'W': 1, 'doc': 'E', 'value': 300}],
#  [{'W': 0.5, 'doc': 'B', 'value': 301},
#   {'W': 0.45, 'doc': 'C', 'value': 301},
#   {'W': 0.3, 'doc': 'D', 'value': 301}]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about simple manual approach without any import :</p>
<pre><code>N = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]

d={}

for i,j in enumerate(N):
    if j not in d:
        d[j]=[j]
    else:
        d[j].append(j)

print(d)
</code></pre>
<p>output:</p>
<pre><code>{1: [1], 2: [2, 2], 3: [3, 3, 3], 4: [4, 4, 4, 4], 5: [5, 5, 5, 5, 5]}
</code></pre>
<p>or:</p>
<pre><code>print(d.values())
</code></pre>
<p>output:</p>
<pre><code>[[1], [2, 2], [3, 3, 3], [4, 4, 4, 4], [5, 5, 5, 5, 5]]
</code></pre>
</div>
<span class="comment-copy">Great! it work perfectly! thanks</span>
