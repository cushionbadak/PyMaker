<div class="post-text" itemprop="text">
<p>I have the following folder structure:</p>
<pre><code>/main
    main.py
    /io
        __init__.py
        foo.py
</code></pre>
<p>In Python 2.7 I would write the following in <code>main.py</code>:</p>
<pre><code>import io.foo
</code></pre>
<p>or</p>
<pre><code>from io.foo import *
</code></pre>
<p>wheareas in Python 3.5 I get an import error:</p>
<pre><code>Traceback (most recent call last):
  File "./main.py", line 6, in &lt;module&gt;
    import io.foo
ImportError: No module named 'io.foo'; 'io' is not a package
</code></pre>
<p>I couldn't find any help so far.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>io</code> is a <a href="https://docs.python.org/3/tutorial/inputoutput.html" rel="noreferrer">built-in module</a>. Don't name your local packages the same as a built-in module.</p>
</div>
<div class="post-text" itemprop="text">
<p>While @ErikCederstrand's answer is correct and probably sufficient for you, I was curious as to why it failed so I went digging through cpython's source. So for any future visitors, here's what I found.</p>
<p>The function where it's failing is here: <a href="https://github.com/python/cpython/blob/3.4/Lib/importlib/_bootstrap.py#L2207" rel="nofollow noreferrer">https://github.com/python/cpython/blob/3.4/Lib/importlib/_bootstrap.py#L2207</a></p>
<p>On line 2209, it checks to see if the parent module has been loaded:</p>
<pre><code>parent = name.rpartition('.')[0]  #  Value of 'io'
</code></pre>
<p>Since it has loaded the <em>builtin</em> <code>io</code> module, it continues on like normal. After the <code>if</code> returns false, it goes on to assign parent module which again is set to "io":</p>
<pre><code>if name in sys.modules:
    return sys.modules[name]
parent_module = sys.modules[parent]
</code></pre>
<p>The next lines are what cause the failure, and it's because builtin modules (<code>io</code> anyway) don't have a __path__ instance variable. The exception you see raised here are ultimately what you're seeing when you run it:</p>
<pre><code>try:
    path = parent_module.__path__
except AttributeError:
    msg = (_ERR_MSG + '; {!r} is not a package').format(name, parent)
    raise ImportError(msg, name=name)
</code></pre>
<p>If you change your module name like Erik says, then step through this whole process, you can see the call to get parent_module.__path__ works like it's supposed to and everything's happy.</p>
<p>So, tldr: you've tricked the import system into thinking it's already loaded your custom module, but when it goes to try and use it like a custom module it fails because it's actually the builtin <code>io</code>.</p>
<p>EDIT: It looks like <code>__path__</code> is set here after it goes through a normal import process in <code>init_module_attrs</code>:</p>
<pre><code> if _override or getattr(module, '__path__', None) is None:
     if spec.submodule_search_locations is not None:
         try:
             module.__path__ = spec.submodule_search_locations
         except AttributeError:
             pass
</code></pre>
</div>
<span class="comment-copy">+1, I went down a rabbithole down below to figure out why it behaves like that though. OP feel free to accept this one since he was first.</span>
