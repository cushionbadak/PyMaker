<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/9884132/what-exactly-are-iterator-iterable-and-iteration">What exactly are iterator, iterable, and iteration?</a>
<span class="question-originals-answer-count">
                    12 answers
                </span>
</li>
</ul>
</div>
<p>First of all i have to say i read lot of SO posts before coming to this one because I could not find what I was looking for or maybe I didn't understood.
So here it goes</p>
<p>I kind of understand what Iterables and Iterators are. So any container object like Lists/Tuples/Sets which contains items, which you can iterate over are called Iterables. Now to iterate over the Iterables you need Iterators and the way it happens is because of <code>__iter__</code> method which gives you the Iterator object for the type and then calling the <code>__next__</code> on the Iterator object to extract the values.</p>
<p>So to make any object iterable you need to define <strong>iter</strong> and <strong>next</strong> methods, and i suppose that is true for Lists as well. But here comes the weird part which I discovered recently.</p>
<pre><code>l1 = [1,2,3]
hasattr(l1, "__next__")
Out[42]: False
g = (x for x in range(3))
hasattr(g, "__next__")
Out[44]: True
</code></pre>
<p>Now because the lists do support Iterator protocol why the <code>__next__</code> method is missing from their implementation, and if it indeed is missing then how does iteration for a list work ?</p>
<pre><code>list_iterator = iter(l1)
next(list_iterator)
Out[46]: 1
next(list_iterator)
Out[47]: 2
next(list_iterator)
Out[48]: 3
next(list_iterator)
Traceback (most recent call last):
  File "C:\Users\RJ\Anaconda3\lib\site-packages\IPython\core\interactiveshell.py", line 2910, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File "&lt;ipython-input-49-56e733bbb896&gt;", line 1, in &lt;module&gt;
    next(list_iterator)
StopIteration

gen0_iterator = iter(g)
gen_iterator = iter(g)
next(gen_iterator)
Out[57]: 0
next(gen_iterator)
Out[58]: 1
next(gen_iterator)
Out[59]: 2
next(gen_iterator)
Traceback (most recent call last):
  File "C:\Users\RJ\Anaconda3\lib\site-packages\IPython\core\interactiveshell.py", line 2910, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File "&lt;ipython-input-60-83622dd5d1b9&gt;", line 1, in &lt;module&gt;
    next(gen_iterator)
StopIteration
gen_iterator1 = iter(g)
next(gen_iterator1)
Traceback (most recent call last):
  File "C:\Users\RJ\Anaconda3\lib\site-packages\IPython\core\interactiveshell.py", line 2910, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File "&lt;ipython-input-62-86f9b3cc341f&gt;", line 1, in &lt;module&gt;
    next(gen_iterator1)
StopIteration
</code></pre>
<p>I created an iterator for a list and then called next method on it to get the elements and it works. </p>
<ol>
<li><p>Now if the previous <code>hasattr(a, "__next__")</code> returns a <code>False</code> then how we are able to call next method on the iterator object for a list.</p></li>
<li><p>Now the original question which made me think all this, no matter how many times i iterate over the list, it doesn't exhaust and calling the <code>iter()</code> gives back a new iterator object everytime, but in case of generator this does not happen, and once the generator has exhausted, no matter how many times you call <code>iter()</code> it will always gives you back the same object which already has raised the <code>StopIteration</code> exception and again this is true because an iterator once raised a <code>StopIteration</code>, it always will, but why it does not happen with lists.</p></li>
</ol>
<p>Further this is in sync with what python docs says for <a href="https://docs.python.org/3/library/stdtypes.html#container.__iter__" rel="nofollow noreferrer">conatiner.__ iter__</a> that <code>container.__iter__</code> gives you the iterator object for the type and <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__iter__" rel="nofollow noreferrer">iterator.__ iter__</a> and <code>iterator.__iter__</code> gives you the iterator object itself, which is precisely the reason that calling the <code>iter()</code> on generator returns the same object over and over again. But why and more importantly how ?</p>
<p>One more thing to observe here is</p>
<pre><code>isinstance(l1 , collections.Iterator)
Out[65]: False
isinstance(g , collections.Iterator)
Out[66]: True
</code></pre>
<p>So this suggests that there is some implementation difference b/w Iterables and Iterators, but i could not find any such details, because both have <code>__iter__</code> and <code>__next__</code> methods implemented, so from where does this variation in behavior comes. So is it that <code>__iter__</code> for iterables returns something different from what is returned by <code>__iter__</code> of iterables(generators). If some can explain with some examples of <code>__iter__</code> for Iterables and Iterataors that would be really helpful. Finally some puzzle about <code>yield</code>, since that is the magic word which makes a normal function a generator (so a type of iterator), so what does <code>__iter__</code> and <code>__next__</code> of `yield looks like.</p>
<p>I have tried my level best to explain the question, but if still something is missing, please do let me know i will try to clarify my question.</p>
</div>
<div class="post-text" itemprop="text">
<p>Its a bit different than that. <em>iterables</em> have an <code>__iter__</code> method that returns an iterator. <em>iterators</em> have a <code>__next__</code> method (and usually also have <code>__iter__</code> so that <code>iter()</code> works on them - but that's not required).</p>
<p>Lists are iterable:</p>
<pre><code>&gt;&gt;&gt; l = [1,2,3]
&gt;&gt;&gt; hasattr(l, "__iter__")
True
&gt;&gt;&gt; hasattr(l, "__next__")
False
&gt;&gt;&gt; l_iter = iter(l)
&gt;&gt;&gt; hasattr(l_iter, "__next__")
True
&gt;&gt;&gt; hasattr(l_iter, "__iter__")
True
&gt;&gt;&gt; l_iter == iter(l_iter)
True
</code></pre>
<p>And give you new iterators that run through the e each time you use them</p>
<pre><code>&gt;&gt;&gt; list(l)
[1, 2, 3]
&gt;&gt;&gt; list(l)
[1, 2, 3]
&gt;&gt;&gt; l_iter = iter(l)
&gt;&gt;&gt; list(l_iter)
[1, 2, 3]
&gt;&gt;&gt; list(l_iter)
[]
 each time you use them

&gt;&gt;&gt; list(l)
[1, 2, 3]
&gt;&gt;&gt; list(l)
[1, 2, 3]
&gt;&gt;&gt; iter(l) == iter(l)
False
</code></pre>
<p>But the list iterator itself is one shot</p>
<pre><code>&gt;&gt;&gt; l_iter = iter(l)
&gt;&gt;&gt; list(l_iter)
[1, 2, 3]
&gt;&gt;&gt; list(l_iter)
[]
</code></pre>
<p>The generator is an iterator, not an iterable and is also one shot.</p>
<pre><code>&gt;&gt;&gt; g = (x for x in range(3))
&gt;&gt;&gt; hasattr(g, "__iter__")
True
&gt;&gt;&gt; hasattr(g, "__next__")
True
&gt;&gt;&gt; g == iter(g)
True
&gt;&gt;&gt; 
&gt;&gt;&gt; list(g)
[0, 1, 2]
&gt;&gt;&gt; list(g)
[]
</code></pre>
</div>
<span class="comment-copy">Because tuples and lists are <b>sequences</b>, so can be indexed at random. Iterators are not sequences, and you can create iterators for many more things than just sequences. Like an <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer">infinite counter</a>. Sequences are <i>iterable</i>, meaning that you can create (new) iterators for them.</span>
<span class="comment-copy">As to why <code>list</code> doesn't have a <code>__next__()</code>, iterable objects aren't required to have <code>__next__()</code>; they just need <code>__iter__()</code>. The object <i>returned by <code>__iter__()</code></i> has to have a <code>__next__()</code> method.</span>
<span class="comment-copy"><i>to make any object iterable you need to define <code>__iter__</code> and <code>__next__</code> methods</i>: no, you only need the <code>__iter__</code> method. <b>Iterators</b> need <code>__next__</code>, <i>iterables</i> do not.</span>
<span class="comment-copy">In other words: you have the iterable and iterator types confused. <i>Iterable</i> --&gt; can <b>potentially</b> be iterated over, you can produce an iterator for this object. <i>Iterator</i> --&gt; the object doing the iterating.</span>
<span class="comment-copy"><i>Iterable</i> -&gt; you use the <code>__iter__</code> method to produce the iterator. <i>iterator</i> -&gt; you use the <code>__next__</code> method to do the iterating. Iterators also have a <code>__iter__</code> method, because that makes it so much easier to handle both types (just call <code>iter()</code> on either and you know you have something with a <code>__next__</code> method returned).</span>
<span class="comment-copy">So if i understand correctly, the <code>__iter__</code> of an iterartor returns itself that's why <code>l_iter == iter(l_iter)</code> returns <code>True</code>, but <code>__iter__</code> of an iterables returns a fresh iterator every time correct ? So can you give example of how <code>__iter__</code> of list class looks like maybe ?</span>
<span class="comment-copy">Yes. Its python so people can do crazy things but the advantage of an iterator returning itself is that something like an inner <code>for</code> keeps consuming the data. Iterables tend to pass unique iterators so that different <code>for</code> 's don't interfere with each other. I'll see what I can work up.</span>
