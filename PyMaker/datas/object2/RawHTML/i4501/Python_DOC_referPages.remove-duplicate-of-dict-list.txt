<div class="post-text" itemprop="text">
<p>How can I remove duplicates from the dict list below, while summing up the corresponding values thanks</p>
<pre><code>{'VIC': [['City West ', 10.0], ['City West ', 30.0], ['Thornbury ',
         0.0]], 'NSW': [['Queanbeyan ', 5.0],['Queanbeyan ', 20.0]], 
         'ACT': [['Civic ', 8.0], ['Civic ', 60.0], ['Civic ', 1.0]]}
</code></pre>
<p>Desired output</p>
<pre><code>{'VIC': [['City West ', 40.0], ['Thornbury ', 0.0]], 'NSW':
        [['Queanbeyan ', 25.0]], 'ACT': [['Civic ', 69.0]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get your desired output by using the following</p>
<pre><code>dictionary = {'VIC': [['City West ', 10.0], ['City West ', 30.0], ['Thornbury ', 0.0]], 'NSW': [['Queanbeyan ', 5.0],['Queanbeyan ', 20.0]], 'ACT': [['Civic ', 8.0], ['Civic ', 60.0], ['Civic ', 1.0]]}

dic = {}
for i in dictionary:
    temp = {}
    for j in dictionary[i]:
        if not j[0] in temp: temp.update({j[0]: j[1]})
        else: temp[j[0]] += j[1]
    dic.update({i: [[j, temp[j]] for j in temp]})
dic
</code></pre>
<blockquote>
<p>{'ACT': [['Civic ', 69.0]], <br/> 'NSW': [['Queanbeyan ', 25.0]], <br/> 'VIC':
  [['City West ', 40.0], ['Thornbury ', 0.0]]}</p>
</blockquote>
<hr/>
<p>I would however suggest sing a dictionary of dictionaries for simplicity you can do the following</p>
<pre><code>dictionary = {'VIC': [['City West ', 10.0], ['City West ', 30.0], ['Thornbury ', 0.0]], 'NSW': [['Queanbeyan ', 5.0],['Queanbeyan ', 20.0]], 'ACT': [['Civic ', 8.0], ['Civic ', 60.0], ['Civic ', 1.0]]}

dic = {}
for i in dictionary:
    temp = {}
    for j in dictionary[i]:
        if not j[0] in temp: temp.update({j[0]: j[1]})
        else: temp[j[0]] += j[1]
    dic.update({i: temp})

print(dic)
</code></pre>
<blockquote>
<p>{'ACT': {'Civic ': 69.0}, <br/> 'NSW': {'Queanbeyan ': 25.0}, <br/> 'VIC':
  {'City West ': 40.0, 'Thornbury ': 0.0}}</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can rebuilt the <code>dict</code> using dict-comprehension. During rebuilding, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to group the nested lists on first value of each sublist and sum the second value using a list comprehension:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby

&gt;&gt;&gt; d = {'VIC': [['City West ', 10.0], ['City West ', 30.0], ['Thornbury ', 0.0]], 'NSW': [['Queanbeyan ', 5.0],['Queanbeyan ', 20.0]], 'ACT': [['Civic ', 8.0], ['Civic ', 60.0], ['Civic ', 1.0]]}
&gt;&gt;&gt; {k:[[ke,sum([i[1] for i in list(g)])] for ke,g in groupby(sorted(v), key= lambda x: x[0])] for k,v in d.items()}
&gt;&gt;&gt; {'NSW': [['Queanbeyan ', 25.0]], 'VIC': [['City West ', 40.0], ['Thornbury ', 0.0]], 'ACT': [['Civic ', 69.0]]}
</code></pre>
<p>The above expression can also be rewritten using <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> instead of <code>lambda</code> to get some performance</p>
<pre><code>&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; {k:[[ke,sum([i[1] for i in list(g)])] for ke,g in groupby(sorted(v), key=itemgetter(0))] for k,v in d.items()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Throwing my hat into the ring with defaultdict</p>
<pre><code>In [6]: from collections import defaultdict

In [7]: tree = lambda: defaultdict(tree)

In [8]: a
Out[8]:  
{'ACT': [['Civic ', 8.0], ['Civic ', 60.0], ['Civic ', 1.0]],
 'NSW': [['Queanbeyan ', 5.0], ['Queanbeyan ', 20.0]],       
 'VIC': [['City West ', 10.0], ['City West ', 30.0], ['Thornbury ', 0.0]]}

In [9]: b = tree()

In [10]: for key in a:
    ...:     for entry in a[key]:
    ...:         if b[key][entry[0]]:
    ...:             b[key][entry[0]] += entry[1]
    ...:         else:                           
    ...:             b[key][entry[0]] = entry[1] 
    ...:                                         

In [11]: b
Out[11]:  
defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
            {'ACT': defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
                         {'Civic ': 69.0}),                  
             'NSW': defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
                         {'Queanbeyan ': 25.0}),             
             'VIC': defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
                         {'City West ': 40.0, 'Thornbury ': 0.0})})

In [12]: c = {}

In [14]: for key in b:
    ...:     for entry in b[key]:
    ...:         if key in c:
    ...:             c[key].append([entry, b[key][entry]])
    ...:         else:
    ...:             c[key] = [[entry, b[key][entry]]]
    ...:

In [15]: c
Out[15]:
{'ACT': [['Civic ', 69.0]],
 'NSW': [['Queanbeyan ', 25.0]],
 'VIC': [['City West ', 40.0], ['Thornbury ', 0.0]]}
</code></pre>
<p>I've used a vivified hash map to do this, which in turns uses <code>defaultdict</code>. I like the automatic grouping feature it creates.</p>
</div>
<span class="comment-copy">What is your desired output?</span>
<span class="comment-copy">See <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> and its examples in the docs. You just need to write a loop that creates a <code>Counter</code> for each list, and then loop over the name-value-pair sublists and does <code>my_counter[name] += value</code>. You should be able to write the rest yourself, but if you get stuck anywhere, you can ask for specific help.</span>
<span class="comment-copy">please see revision</span>
