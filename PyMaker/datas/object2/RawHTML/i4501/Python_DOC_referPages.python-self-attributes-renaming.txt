<div class="post-text" itemprop="text">
<p>If within an instance, I have <code>self.foo = 1</code>, what is the difference between these (or other more complicated examples):</p>
<pre><code># 1
for i in range(10):
    print(self.foo)

# 2
foo = self.foo
for i in range(10):
    print(foo)
</code></pre>
<p>I'm currently looking at a code base where all the <code>self</code> variables are reassigned to something else. Just wondering if there is any reason to do so and would like to hear both from an efficiency standpoint and a code clarity standpoint.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider these possibilities:</p>
<ul>
<li>The local variable <code>self</code> gets rebound in the middle of the loop. (That's not possible with the specific code you've given, but a different loop could conceivably do it.) In that case, #1 will see the new <code>self</code>'s <code>foo</code> attribute, while #2 will not. Although, of course, you could just as easily rebind the local variable <code>foo</code> as the local variable <code>self</code>…</li>
<li><code>self</code> is mutable, and <code>self.foo</code> is rebound to a different value in the middle of the loop. (That could happen more easily with, e.g., another thread operating on the same object.) Again, #1 will see the new value of the <code>foo</code> attribute, but #2 will not.</li>
<li><code>self.foo</code> is itself mutable, and its value is mutated in the middle of the loop (e.g., it's a list, and some other thread calls <code>append(2)</code> on it). Now both #1 and #2 will see the new value.</li>
<li>Everything is immutable, or there's just no code (including on other threads) to mutate anything. Now both #1 and #2 are going to see the original value, because there is no other value to see.</li>
</ul>
<p>If any of those semantic differences are relevant, then of course you want to use whichever one gives you the right answer.</p>
<hr/>
<p>Meanwhile, every time you access <code>self.foo</code>, that requires doing an attribute lookup. In the most common case, this means looking up <code>'foo'</code> in <code>self.__dict__</code>, which is pretty quick, but not free. And you can easily create pathological cases where it goes through 23 base classes in MRO order before calling a <code>__getattr__</code> that creates the value on the fly and returns a descriptor whose <code>__get__</code> method does some non-trivial transformation.</p>
<p>Accessing <code>foo</code>, on the other hand, is going to be compiled into just loading a value out of an array on the frame using a compiled-in index. So it will almost always be faster, and in some cases it can be a lot faster.</p>
<p>In most real-life cases, this doesn't matter at all. But occasionally, it does. In which case copying the value to a local outside the loop is a worthwhile micro-optimization. This is a little more common with bound methods than with normal values (because they always have a descriptor call in the way); see <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">the <code>unique_everseen</code> recipe in the <code>itertools</code> docs</a> for an example.</p>
<p>Of course you could contrive a case where this optimization actually made things slower—e.g., make that loop really tiny, but put the whole thing inside an outer loop. Now the extra <code>self.foo</code> copy each time through the outer loop (and the fact that the bytecode involved in the loop is longer and may spill onto another cache line) could cost a lot more than it saves.</p>
<hr/>
<p>If there's no semantic difference that matters, and the performance difference doesn't matter, then it's just a matter of clarify.</p>
<p>If the expression is a lot more complicated than <code>self.foo</code>, it may well be clearer to pull out the value and give it a name.</p>
<p>But for a trivial case like this, it's probably clearer to just use <code>self.foo</code>. By taking the extra step of copying it to a local variable, you're signaling that you had some reason to do so. So a reader will wonder whether maybe <code>self.foo</code> can get rebound in a different thread, or maybe this loop is a major bottleneck in your code and the <code>self.foo</code> access is a performance issue, etc., and waste time dealing with all of those irrelevancies instead of just reading your code as intended.</p>
</div>
<span class="comment-copy">Show some real example code that demonstrates why you think this is a problem.</span>
<span class="comment-copy">The first one evaluates <code>self.foo</code> each loop, if <code>self.foo</code> is immutable and changes its value in the middle of the loop the change will be reflected. That wouldn't be the case with the second loop. On the other hand, the second loop doesn't have to evaluate <code>self.foo</code> each time improving the performance a bit (a tiny bit, usually not worth the trouble - remember the first rule of programming: do not optimize!).</span>
<span class="comment-copy">@ekhumoro I didn't say it's a problem? I'm wondering if there are benefits or drawbacks to either approach.</span>
<span class="comment-copy">@zwer I think you meant "if self.foo is <i>mutable</i>", not immutable. But that still isn't quite right. If the value is mutable, <i>both</i> versions will see the change. The way to see the difference is if <code>self</code> is mutable, not <code>self.foo</code> is: if <code>self</code> rebinds <code>self.foo</code> to a different value, then the first one will show the new version and the second will not.</span>
<span class="comment-copy">@Justin. It certainly could be a problem: but that depends on the specifics of the code itself. For example, <code>self.foo</code> might be a calculated property. In which case, caching (or not caching) its current value could change the behaviour of the program.</span>
<span class="comment-copy">Thanks for this thorough explanation. My guess is also that someone just renamed it to be a little clearer. Not even to micro-optimize. I'll have to look into which ones actually matter though.</span>
<span class="comment-copy">@Justin I've occasionally written code that does this just to give it a different name, just because it was clearer than a comment. I can't think of a good example, but… something like <code>emptynodes = self.children</code> and then using <code>emptynodes</code> says as much as <code># self.children is guaranteed to be a tuple of nodes that are all empty here</code> and then using <code>self.children</code>.</span>
