<div class="post-text" itemprop="text">
<p>I am developing a program that will email me when new music from my artists on Spotify. It does this by getting the number of albums every artist has when the script is run and comparing the results to a previous day saved as a CSV file. </p>
<p>This involves API calls to verify the artist is on Spotify (I was getting errors that certain albums were not on Spotify) and then getting the number of albums for that artist. These calls are very time consuming especially when I have close to a thousand individual artists. </p>
<p>I was wondering how I would parallelize these API calls or any other suggestions to speed up the overall program. Linked below is the portion of code that has the API calls. Thank you for your time in advance. </p>
<pre><code># given artist name returns all info related to artist 
def get_artist_info(spotipy_instance, name):
    results = spotipy_instance.search(q='artist:' + name, type='artist')
    items = results['artists']['items']
    if len(items) &gt; 0:
        return items[0]
    else:
        return None

# returns list of all albums given artist name 
def get_artist_albums(spotipy_instance, artist):
    albums = []
    results = spotipy_instance.artist_albums(artist['id'], album_type='album')
    albums.extend(results['items'])
    while results['next']:
        results = spotipy_instance.next(results)
        albums.extend(results['items'])
    seen = set() # to avoid dups
    for album in albums:
        name = album['name']
        # print(album['name'] + ": " + album['id'])
        if name not in seen:
            seen.add(name.encode('utf-8'))
    return list(seen)

def get_all_artists_info(spotipy_instance, list_of_all_artists):
    all_artist_info = []
    print("Getting number of albums for all artists")
    # bar = Bar('Loading...', max=len(list_of_all_artists), suffix='%(index)d/%(max)d - %(percent).1f%% - %(eta)ds')
    for artist_name in list_of_all_artists:
        # increment_progress_bar(bar)
        # print(artist_name)
        artist_info = get_artist_info(spotipy_instance, artist_name)
        if artist_info is not None:  
            albums = get_artist_albums(spotipy_instance, artist_info)
            # print(albums)
            artist = Artist(artist_name, len(albums), albums)
            all_artist_info.append(artist)
        else:
            print("\nCan't find " + artist_name)
            artist = Artist(artist_name, -1, [])
            all_artist_info.append(artist)
        # print(" ")
    # bar.finish()
    print("Done!\n")

    all_artist_info.sort(key=lambda artist: artist.name)

    return all_artist_info
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So basically you have 3 options here.</p>
<ol>
<li>Using Threading</li>
<li>Multiprocessing</li>
<li>Async code ( if you are using python 3.5 or above )</li>
</ol>
<p><strong>Threading</strong> will spawn multiple threads in your process making it run in parallel but the downside is that it introduces big overhead in memory usage and is not the most efficient way of parallelism because the context switching is happening on processor level. Example with threading_toolbelt: <a href="https://toolbelt.readthedocs.io/en/latest/threading.html" rel="nofollow noreferrer">https://toolbelt.readthedocs.io/en/latest/threading.html</a></p>
<p><strong>Multiprocessing</strong> will spawn multiple processes of python introduction even more overhead in resources consumption as it has hold whole stack of python process in memory for each one. And communicating between processes is not the most trivial thing in the world.</p>
<p><strong>Async</strong> is definitely the best solution here if you are using python3.5 or above. You might think of it as somehow similar to threading but with context switching on event loop level and without memory overhead from coping python stack. You would need to use async request library in order to do that. (here is one: <a href="https://aiohttp.readthedocs.io/en/stable/" rel="nofollow noreferrer">asyncio</a>). And example usage: <a href="https://pawelmhm.github.io/asyncio/python/aiohttp/2016/04/22/asyncio-aiohttp.html" rel="nofollow noreferrer">https://pawelmhm.github.io/asyncio/python/aiohttp/2016/04/22/asyncio-aiohttp.html</a></p>
<p>So in summary sorting from the best option to worst is:</p>
<ul>
<li>Async</li>
<li>Threading</li>
<li>Multiprocessing</li>
</ul>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example" rel="nofollow noreferrer"><code>ThreadPoolExecutor</code> Example from the docs</a></span>
