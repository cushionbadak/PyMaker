<div class="post-text" itemprop="text">
<p>I've got the following classes:</p>
<p>model.py</p>
<pre><code>from priceChecker.priceChecker import db

class Model():

    def __init__(self, tableName):
        self.__tablename__ = tableName

    def getAll(self): #, conditions=[]
        try:
            print('Executing query for table: ' + self.__tablename__)
            result = db.execute("SELECT * FROM " + self.__tablename__)
            return result
        except ValueError:
            print("Oops, something went wrong sucker!...")
</code></pre>
<p>and item.py</p>
<pre><code>from priceChecker.core.models.model import Model

class Item(Model):

    def __init__(self):
        print('\n\nInitializing Item model...')
        super().__init__('orders')

    def getAllItems(self):
       items = Model.getAll()
       return items
</code></pre>
<p>my controller ItemController.py</p>
<pre><code>from priceChecker.core.models.item import Item

class ItemController:

    def __init__(self):
        self.item = Item()

    def retrieveItems(self):
        #allItms = 'a'
        allItms = self.item.getAllItems()
        return allItms
</code></pre>
<p>when running this, I'm getting the following error:</p>
<blockquote>
<p>builtins.TypeError TypeError: getAll() missing 1 required positional
  argument: 'self'</p>
</blockquote>
<p>I can solve it by adding self to this call in item.py:</p>
<pre><code>items = Model.getAll(self)
</code></pre>
<p>but my question is: why do I have to pass self as parameter? Since it's extending from model, is there a way to call getAll without passing self?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you access a function directly from the class object, then it is not actually a method, it is merely a function and you have to pass the arguments you specified in the signature of your function definition, or else, like any other function, it will raise an error. Only if you access the function through the instance will the <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">descriptor protocol</a> be initiated, binding the instance to the method, essentially returning a new partially applied function, a bound-method-object. So, you need to do:</p>
<pre><code>items = self.getAll()
</code></pre>
</div>
<span class="comment-copy">change <code>items = Model.getAll()</code> to  <code>items = self.getAll()</code>. Your <i>solution</i> is not adequate</span>
<span class="comment-copy">Calling methods on a base class is the same as calling your own methods—a <code>Item</code> is a <code>Model</code>, so ti can just do <code>self.getAll()</code> to call its inherited <code>getAll</code> method.</span>
<span class="comment-copy">Under the covers, <code>self.getAll()</code> and <code>type(self).getAll(self)</code> do almost the same thing—but the first one is obviously shorter, and clearer, and in the minor ways they do differ, it's almost always the right one.</span>
