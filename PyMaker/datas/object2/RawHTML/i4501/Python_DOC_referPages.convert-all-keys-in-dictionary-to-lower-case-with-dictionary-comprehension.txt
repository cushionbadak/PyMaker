<div class="post-text" itemprop="text">
<p>I wrote a function to convert all keys in a dictionary to lowercase:</p>
<pre><code>def lower_dict_keys(some_dict):
    """Convert all keys to lowercase"""
    result = {}
    for key, value in some_dict.items():
        if type(key) == str:
            result[key.lower()] = value
        else:
            result[key] = value
    return result
</code></pre>
<p>So far so good. Then I thought, hm, this would be more elegant in a dictionary comprehension, so this is what I came up with:</p>
<pre><code>def lower_dict_keys2(some_dict):
    return {key.lower(): value for key, value in some_dict.items() if type(key) == str}
</code></pre>
<p>This only works if all keys are strings. I there are numeric keys, they get dropped:</p>
<pre><code>d1 = {'A':'foo', 'b':'bar', 1:'zip'}

print(lower_dict_keys(d1))

&gt;&gt;&gt;{'a': 'foo', 'b': 'bar', 1: 'zip'}

print(lower_dict_keys2(d1))

&gt;&gt;&gt;{'a': 'foo', 'b': 'bar'}
</code></pre>
<p>So my question is: is it possible to write this function as a dictionary comprehension?</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct translation of your code to a comprehension is:</p>
<pre><code>{key.lower() if type(key) == str else key: value for key, value in some_dict.items()}
</code></pre>
<p>using a <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow noreferrer">conditional expression</a> to determine the key for each key-value pair.</p>
<p>Using <code>if</code> <em>after</em> the <code>for</code> loop <strong>filters</strong> on elements; those elements that don't pass the <code>if</code> test are not included in the output.</p>
<p>You also want to avoid using <code>type(...) is</code>, use <code>isinstance()</code> instead; subclasses of <code>str</code> will support the <code>lower()</code> method too:</p>
<pre><code>{key.lower() if isinstance(key, str) else key: value for key, value in some_dict.items()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you <em>expect</em> your keys to ordinarily be strings, a more appropriate solution would be to use a <code>try</code> / <code>except</code> clause.</p>
<p>Here we catch <code>AttributeError</code>, which will occur only for non-string elements.</p>
<pre><code>def lower_dict_keys(some_dict):
    """Convert all keys to lowercase"""
    result = {}
    for key, value in some_dict.items():
        try:
            result[key.lower()] = value
        except AttributeError:
            result[key] = value
    return result

d1 = {'A':'foo', 'b':'bar', 1:'zip'}

lower_dict_keys(d1)

# {'a': 'foo', 'b': 'bar', 1: 'zip'}
</code></pre>
<p>Unfortunately, this will not work with a dictionary comprehension, since <a href="https://stackoverflow.com/questions/1528237/how-can-i-handle-exceptions-in-a-list-comprehension-in-python">statements are not permitted in comprehensions</a> and <a href="https://www.python.org/dev/peps/pep-0463/" rel="nofollow noreferrer">PEP-463 was rejected</a>.</p>
</div>
<span class="comment-copy">What do you want to happen if the key is not a string?</span>
<span class="comment-copy">Like in the original function, it should just be added to the dict unaltered.</span>
<span class="comment-copy">late 2s :)... +1</span>
