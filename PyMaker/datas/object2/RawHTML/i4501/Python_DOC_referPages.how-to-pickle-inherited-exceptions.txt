<div class="post-text" itemprop="text">
<p>This code</p>
<pre><code>import pickle
class Error(Exception):
    def __init__(self):
        super().__init__("Some error message")   

c = Error()    
a = pickle.dumps(c)
b = pickle.loads(a)
</code></pre>
<p>raises error:</p>
<pre><code>...
    b = pickle.loads(a)
TypeError: __init__() takes 1 positional argument but 2 were given
</code></pre>
<p>However this code:</p>
<pre><code>import pickle
class MyBaseException:
    def __init__(self, msg):
        self.msg = msg

class Error(MyBaseException):
    def __init__(self):
        super().__init__("Some error message")

c = Error()
a = pickle.dumps(c)
b = pickle.loads(a)
</code></pre>
<p>works fine.</p>
<p><strong>Question:</strong> How do I pickle objects inherited from Python base Exception object?</p>
<p>Python version: 3.6.3</p>
</div>
<div class="post-text" itemprop="text">
<p><code>BaseException</code> implements a <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer"><code>__reduce__</code> method</a> that returns a tuple with the type and the value of <code>self.args</code> (a third value is included if there are more attributes besides <code>.args</code>):</p>
<pre><code>&gt;&gt;&gt; Error().__reduce__()
(&lt;class '__main__.Error'&gt;, ('Some error message',))
</code></pre>
<p>This tuple is pickled and when unpickling, used to re-create the instance. The class also implements <a href="https://docs.python.org/3/library/pickle.html#object.__setstate__" rel="nofollow noreferrer"><code>__setstate__</code></a>, which would be called if there was a third element in the <code>__reduce__</code> return tuple, but that's not relevant here.</p>
<p>You'd have to provide a different implementation of <code>__reduce__</code>:</p>
<pre><code>class Error(Exception):
    def __init__(self):
        super().__init__("Some error message")
    def __reduce__(self):
        return type(self), ()
</code></pre>
</div>
<span class="comment-copy">Since you are dumping an object, have you tried <code>pickle.dump()</code> (not <code>pickle.dumps()</code>)</span>
<span class="comment-copy">@VivekKalyanarangan: that makes zero difference here. <code>dump()</code> writes the pickled data to a file, while <code>dumps()</code> returns the produced data to the caller.</span>
<span class="comment-copy">@VivekKalyanarangan: and <b>everything</b> in Python is an object, so I'm not sure what you even mean by <i>since you are dumping an object</i>. How would you <i>not</i> dump an object?</span>
<span class="comment-copy">@VivekKalyanarangan Why should I use <code>pickle.dump()</code>? I'm not writing anything to file. I send pickled information through socket to other machine and then unpickle it.</span>
<span class="comment-copy">@SergeyDylda: you can safely ignore that comment, it makes zero sense.</span>
<span class="comment-copy">This works. Thanks!</span>
