<div class="post-text" itemprop="text">
<p>I'm reading several articles to understand how class types are created in Python (<a href="https://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions" rel="nofollow noreferrer">1</a>, <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/" rel="nofollow noreferrer">2</a>, <a href="https://leanpub.com/insidethepythonvirtualmachine/read" rel="nofollow noreferrer">3</a>), and following along Python's source code (<a href="https://github.com/python/cpython/blob/c3d9508ff22ece9a96892b628dd5813e2fb0cd80/Objects/typeobject.c" rel="nofollow noreferrer">typeobject.c</a>).</p>
<p>My Question: When a new user-defined type is created, where does its metaclass' <code>__new__</code> and <code>__init__</code> get invoked? </p>
<p>I'll explain:</p>
<p>say we have a simple user-defined type:</p>
<pre><code>class A(object): pass
</code></pre>
<p>To create the type <code>A</code>, <code>type_call</code> is eventually invoked, with <code>type</code> as its first parameter. In this case, <code>type</code> is actually <code>PyType_Type</code>. </p>
<p>Inside <code>type_call</code>, <code>tp_new</code> is called, which in this case means a call to <code>type_new</code>. </p>
<p>Now, Inside <code>type_new</code>, the new type is eventually allocated with:</p>
<pre><code>/* Allocate the type object */
type = (PyTypeObject *)metatype-&gt;tp_alloc(metatype, nslots);
</code></pre>
<p>And when <code>type_new</code> finishes, it returns <code>type</code> to <code>type_call</code>. Then, <code>type_call</code> calls <code>tp_init</code> - which means a call to <code>type_init</code>, which invokes <code>object_init</code>, that doesn't really do anything.</p>
<p>Somewhere, <code>type</code>'s <code>__new__</code> and <code>__init__</code> should be called. Did I miss these calls along the way, or are they called outside <code>type_call</code>? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>tp_new</code> and <code>tp_init</code> are the C-level counterparts of <code>__new__</code> and <code>__init__</code>. The calls to <code>tp_new</code> and <code>tp_init</code> <em>are</em> the <code>__new__</code> and <code>__init__</code> calls.</p>
<p>If you override <code>type.__new__</code> or <code>type.__init__</code> in a metaclass you define, the corresponding <code>tp_new</code> or <code>tp_init</code> slots in your metaclass will be set to C-level <a href="https://github.com/python/cpython/blob/v3.6.5/Objects/typeobject.c#L6398" rel="nofollow noreferrer">functions</a> that search for and invoke your Python-level overrides.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/a/49661509/908494">user2357112's answer</a> explains, <code>tp_new</code> is the type slot method, and the default version of it for Python-defined classes looks up and calls the <code>__new__</code> method.</p>
<p>The idea of type slot methods isn't really explained all in a single place, but see <a href="https://docs.python.org/3/c-api/typeobj.html" rel="nofollow noreferrer">Type Objects</a> in the C API and <a href="https://docs.python.org/3/extending/newtypes.html" rel="nofollow noreferrer">New Types</a> in the Extending and Embedding docs.</p>
<p>You'll also want to read the specific entries on <code>tp_new</code> in both of those chapters, because it's a particularly special function.</p>
<p>If you want to see the source, most of the relevant stuff is in <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c" rel="nofollow noreferrer"><code>typeobject.c</code></a>. Notice that the <code>__new__</code> wrapper is different from other Python method wrappers, and the name lookup doesn't call the generic special method lookup code, but the basics are still pretty similar.</p>
</div>
<span class="comment-copy">Huh. I never really thought about how the lookup for <code>__new__</code> would need different handling from other special methods, and now that I'm looking at it, I'm surprised it almost (but not quite) boils down to "just do a normal attribute lookup". That interacts <a href="https://ideone.com/lK5ugm" rel="nofollow noreferrer">pretty strangely</a> with a metaclass <code>__getattribute__</code>.</span>
<span class="comment-copy">@user2357112 Well, Python doesn't guarantee that special method lookup will be different from normal method lookup, it just refuses to guarantee that it <i>won't</i> be different. And the <code>__hash__</code> rationale doesn't apply to <code>__new__</code>, soâ€¦</span>
