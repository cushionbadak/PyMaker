<div class="post-text" itemprop="text">
<p>Are the python <a href="http://docs.python.org/library/functions.html#built-in-functions" rel="noreferrer">built-in</a> methods available to reference in a package somewhere?</p>
<p>Let me explain.  In my early(ier) days of python I made a django model similar to this:</p>
<pre><code>class MyModel(models.Model):
    first_name = models.CharField(max_length=100, null=True, blank=True)
    last_name = models.CharField(max_length=100, null=True, blank=True)
    property = models.ForeignKey("Property")
</code></pre>
<p>I have since needed to add a property to it.  This leaves me with this model:</p>
<pre><code>class MyModel(models.Model):
    first_name = models.CharField(max_length=100, null=True, blank=True)
    last_name = models.CharField(max_length=100, null=True, blank=True)
    property = models.ForeignKey("Property")

    @property
    def name(self):
        return "{} {}".format(first_name, last_name)
</code></pre>
<p>So now at runtime I get the error: <code>TypeError: 'ForeignKey' object is not callable</code>.  This is happening because the ForeignKey for property has replaced the built-in identifier property.  What I would like to be able to do is, instead of <code>@property</code> use <code>@sys.property</code> (or something similar).</p>
<p><em><strong>Note:</strong> I already know about the workaround of moving the name property above the declaration of the property field.  I am not so concerned about this particular case as I am the main question of alternative locations for referencing the python built-ins.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer"><code>builtins</code></a>, or <a href="https://docs.python.org/2.7/library/__builtin__.html" rel="nofollow noreferrer"><code>__builtin__</code></a> if you're on Python 2.</p>
<pre><code>def open():
    pass

import __builtin__

print open
print __builtin__.open
</code></pre>
<p>This gives you:</p>
<pre><code>&lt;function open at 0x011E8670&gt;
&lt;built-in function open&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python has a <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer"><code>builtins</code></a> module where "truly global" things—normally just <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">the standard builtin functions and types</a>—are stored. In Python 2, it was named <code>__builtin__</code>, but worked mostly the same.</p>
<p>This module can be imported just like any other module—but it also magically supplies the builtin names for every other module (that doesn't hide them).</p>
<hr/>
<p>If you're wondering how that works, the <code>builtins</code> docs say:</p>
<blockquote>
<p>As an implementation detail, most modules have the name <code>__builtins__</code> made available as part of their globals. The value of <code>__builtins__</code> is normally either this module or the value of this module’s <code>__dict__</code> attribute. Since this is an implementation detail, it may not be used by alternate implementations of Python.</p>
</blockquote>
<p>And <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a> says:</p>
<blockquote>
<p>If the <em>globals</em> dictionary does not contain a value for the key <code>__builtins__</code>, a reference to the dictionary of the built-in module <code>builtins</code> is inserted under that key. That way you can control what builtins are available to the executed code by inserting your own <code>__builtins__</code> dictionary into globals before passing it to <code>exec()</code>.</p>
</blockquote>
<p>So, at least in CPython, when you evaluate <code>abs</code>, it's looked up in <code>globals()['abs']</code>, not found there, and then looked up in <code>globals()['__builtins__'].__dict__['abs']</code>.</p>
<p>And whenever Python (or at least CPython) creates a new module object, its code is executed against a <code>globals</code> with an <code>empty</code> <code>__builtins__</code>, which means the default <code>builtins</code> module value gets filled in, so that works. And this <code>globals</code> is the one that gets copied for very function and class defined in the module (and anything you do explicitly with <code>globals</code> without explicitly replacing <code>__builtins__</code>), so it works inside functions and classes as well.</p>
</div>
<span class="comment-copy">Perhaps I don't understand, but can't you just rename your <code>MyModel</code> class' <code>property</code> something else, like <code>_property</code> or what-have-you?</span>
<span class="comment-copy">That wasn't the question.</span>
<span class="comment-copy">No, but that doesn't make mine irrelevant.</span>
<span class="comment-copy">Ok then.  The class I was looking at represents a database table that is in production.  Changing the <code>property</code> field name to something else is impractical right now.  There are other work arounds in django, but I was mainly curious if the built-ins lived in a namespace somewhere and my (admittedly halfhearted) googleing didn't turn up anything.</span>
<span class="comment-copy">OK, I see, too bad. Python's keywords and built-ins frequently conflict with names one would like to make use of, like <code>file</code> and <code>list</code>. All you can do is try to remember them all and avoid these sorts of problems from the get go. namespaces help, but just about any language is going to have a global one (so it's best to stay out of it). Even if you do everything right, language changes can still bite you (like when they added <code>property()</code> in version 2.2).</span>
<span class="comment-copy">If typing all those underscores gets to you, you could also do <code>import __builtin__ as builtin</code> or the like.</span>
<span class="comment-copy">what a life saver :-)</span>
