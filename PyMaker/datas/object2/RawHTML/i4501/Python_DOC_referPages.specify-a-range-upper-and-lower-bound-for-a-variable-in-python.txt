<div class="post-text" itemprop="text">
<p>Is there a way to specify bounds for a float variable in Python? For example, when I import data, I would like to either check if it within certain range such that <code>min &lt;= variable &lt;=max</code>. Further, if possible, I would like assign a specific value to such variable if the imported value is outside of these bounds (or even missing). </p>
<p>I can perhaps do the first part if the variable was a float.</p>
<pre><code>def var_check(x,lower_bound=3,upper_bound=30):
    rng = range(lower_bound,upper_bound+1)
    if x not in rng:
        return (upper_bound-lower_bound)/2
    else:
        return x
</code></pre>
<p><code>x = var_check(5)</code> returns 5, while <code>x = var_check(50)</code> returns 13.</p>
<p>Any ideas on how to do this for a float variable?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do almost exactly what you wrote in your question:</p>
<pre><code>def var_check(x, lower_bound=3, upper_bound=30):
    if lower_bound &lt;= x &lt;= upper_bound:
        return x
    else:
        return (upper_bound - lower_bound) / 2
</code></pre>
<p>You should do the same with integers, by the way, at least in Python 2. In Python 3 (or with <code>xrange</code> in Python 2), it doesn't matter so much.</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution could look like this:</p>
<pre><code>def var_check(x, lower_bound=3, upper_bound=30):
    if x &gt;= lower_bound and x &lt;= upper_bound:
        return x
    return (upper_bound-lower_bound)/2

print(var_check(2.5))
print(var_check(15.5))
print(var_check(33.5))
</code></pre>
<p>Output</p>
<pre><code>13.5
15.5
13.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can define a class and override its <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer"><code>__float__</code></a></p>
<pre><code>class MyFloat:
   def __init__(self, num, upper=20, lower=10):
       self.num = num
       self.upper = upper
       self.lower = lower

   def __float__(self):
       if self.lower &lt;= self.num &lt;= self.upper:
           return float(self.num)
       else:
           return (self.upper - self.lower) / 2
</code></pre>
<p>Then while importing your data you can do</p>
<pre><code>&gt;&gt;&gt; data = [1,2,3,10,11,12,21,22,23]
&gt;&gt;&gt; [float(MyFloat(d)) for d in data]
&gt;&gt;&gt; [5.0, 5.0, 5.0, 10.0, 11.0, 12.0, 5.0, 5.0, 5.0]
</code></pre>
</div>
<span class="comment-copy">This seems like an interesting but a bit complicated solution. Nonetheless, I get the <code>TypeError: __float__ returned non-float (type int)</code> message.</span>
<span class="comment-copy">Can you provide some sample data which throws this error?</span>
<span class="comment-copy">I just ran the example that you included, and I was getting that TypeError, which I mentioned earlier. After the edit that you provided, the example works now, thanks!</span>
