<div class="post-text" itemprop="text">
<p>I'd like to use <strong>future</strong> module in exec function. But it looks like it only take effect in the current exec function, but not the following exec calls. The following code shows the issues. The second <strong>future</strong> module take affect as you can see the output <code>hello world</code> is what I expect. Is there anything that I miss here ? Thanks</p>
<pre><code>&gt;&gt;&gt; ns = {}
&gt;&gt;&gt; exec("from __future__ import print_function", ns)
&gt;&gt;&gt; exec("print('hello', 'world')", ns)
('hello', 'world')
&gt;&gt;&gt; exec("from __future__ import print_function\nprint('hello', 'world')", ns)
hello world
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>from __future__</code> imports are really compiler switches, and only apply to <em>single units</em> being compiled. You have two separate <code>exec()</code> calls, future statements do not carry across. Compilation flags are not stored in the global or local namespace you execute code in.</p>
<p>So yes, you'd need to prepend the line for <em>each call to <code>exec()</code></em>.</p>
<p>You could also use the <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow noreferrer"><code>compile()</code> function</a> to first produce a code object, that you then pass to <code>exec()</code>; <code>compile()</code> lets you set <em>flags</em> instead of having to spell out the switches as <code>from __future__ import</code> lines:</p>
<pre><code>import __future__

flags = __future__.print_function.compiler_flag
exec(compile("print('hello', 'world')", '', 'exec', flags=flags))
</code></pre>
</div>
<span class="comment-copy">What I want is to use exec to implement a python interpreter, if I have to pass this statement each time, this is inconvenient for me. Do you how does the native python interpreter handle this situation ?</span>
<span class="comment-copy">@zjffdu: Python compiles whole <code>.py</code> files in one go, so there is a single <code>compile()</code> call for such files, with the <code>from __future__ import</code> statements at the top to set the flags (<code>exec()</code> just calls <code>compile()</code>).</span>
<span class="comment-copy">Don't you mean <code>__future__.CO_FUTURE_PRINT_FUNCTION</code>, not <code>__future__.print_function</code>?</span>
<span class="comment-copy">@user2357112: no, I forgot the <code>.compiler_flag</code> attribute dereference.</span>
<span class="comment-copy">@user2357112: the <code>CO_*</code> names are only there to help code searches, they are not part of the module API.</span>
