<div class="post-text" itemprop="text">
<p>I am working on a transpiler and want to replace my language's tokens with those of Python. The substitution is done like so:</p>
<pre><code>for rep in reps:
    pattern, translated = rep;

    # Replaces every [pattern] with [translated] in [transpiled]
    transpiled = re.sub(pattern, translated, transpiled, flags=re.UNICODE)
</code></pre>
<p>Where <code>reps</code> is a list of <code>(regex to be replaced, string to replace it with)</code> ordered pairs and <code>transpiled</code> is the text to be transpiled.</p>
<p>However, I can't seem to find a way to exclude text between quotes from the substitution process. Please note that this is for a language, so it should work for escaped quotes and single quotes as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>This may depend on how you define your patterns, but in general you can always surround your <code>pattern</code> with a lookahead and a lookbehind group to ensure that text between quotes is not matched:</p>
<pre><code>import re

transpiled = "A foo with \"foo\" and single quoted 'foo'. It even has an escaped \\'foo\\'!"

reps = [("foo", "bar"), ("and", "or")]

print(transpiled)  # before the changes

for rep in reps:
    pattern, translated = rep
    transpiled = re.sub("(?&lt;=[^\"']){}(?=\\\\?[^\"'])".format(pattern),
                        translated, transpiled, flags=re.UNICODE)
    print(transpiled)  # after each change
</code></pre>
<p>Which will yield:</p>
<pre>A foo with "foo" and single quoted 'foo'. It even has an escaped \'foo\'!
A bar with "foo" and single quoted 'foo'. It even has an escaped \'foo\'!
A bar with "foo" or single quoted 'foo'. It even has an escaped \'foo\'!</pre>
<p><strong>UPDATE</strong>: If you want to ignore whole quoted swaths of text, not just a quoted word, you'll have to do a bit more work. While you could do it by looking for repeated quotations the whole lookahead/lookbehind mechanism would get really messy and probably far from optimal - it's just easier to separate the quoted from non-quoted text and do replacements only in the former, something like:</p>
<pre><code>import re

QUOTED_STRING = re.compile("(\\\\?[\"']).*?\\1")  # a pattern to match strings between quotes

def replace_multiple(source, replacements, flags=0):  # a convenience replacement function
    if not source:  # no need to process empty strings
        return ""
    for r in replacements:
        source = re.sub(r[0], r[1], source, flags=flags)
    return source

def replace_non_quoted(source, replacements, flags=0):
    result = []  # a store for the result pieces
    head = 0  # a search head reference
    for match in QUOTED_STRING.finditer(source):
        # process everything until the current quoted match and add it to the result
        result.append(replace_multiple(source[head:match.start()], replacements, flags))
        result.append(match[0])  # add the quoted match verbatim to the result
        head = match.end()  # move the search head to the end of the quoted match
    if head &lt; len(source):  # if the search head is not at the end of the string
        # process the rest of the string and add it to the result
        result.append(replace_multiple(source[head:], replacements, flags))
    return "".join(result)  # join back the result pieces and return them
</code></pre>
<p>You can test it as:</p>
<pre><code>print(replace_non_quoted("A foo with \"foo\" and 'foo', says: 'I have a foo'!", reps))
# A bar with "foo" or 'foo', says: 'I have a foo'!
print(replace_non_quoted("A foo with \"foo\" and foo, says: \\'I have a foo\\'!", reps))
# A bar with "foo" or bar, says: \'I have a foo\'!
print(replace_non_quoted("A foo with '\"foo\" and foo', says - I have a foo!", reps))
# A bar with '"foo" and foo', says - I have a bar!
</code></pre>
<p>As an added bonus, this also allows you to define fully qualified regex patterns as your replacements:</p>
<pre><code>print(replace_non_quoted("My foo and \"bar\" are like 'moo' and star!",
                        (("(\w+)oo", "oo\\1"), ("(\w+)ar", "ra\\1"))))
# My oof and "bar" are like 'moo' and rast!
</code></pre>
<p>But if your replacements do not involve patterns and need just a simple substitution you can replace the <code>re.sub()</code> in the <code>replace_multiple()</code> helper function with the significantly faster <em>native</em> <code>str.replace()</code>.</p>
<p>Finally, you can get rid of regex completely if you don't need complex patterns:</p>
<pre><code>QUOTE_STRINGS = ("'", "\\'", '"', '\\"')  # a list of substring considered a 'quote'

def replace_multiple(source, replacements):  # a convenience multi-replacement function
    if not source:  # no need to process empty strings
        return ""
    for r in replacements:
        source = source.replace(r[0], r[1])
    return source

def replace_non_quoted(source, replacements):
    result = []  # a store for the result pieces
    head = 0  # a search head reference
    eos = len(source)  # a convenience string length reference
    quote = None  # last quote match literal
    quote_len = 0  # a convenience reference to the current quote substring length
    while True:
        if quote:  # we already have a matching quote stored
            index = source.find(quote, head + quote_len)  # find the closing quote
            if index == -1:  # EOS reached
                break
            result.append(source[head:index + quote_len])  # add the quoted string verbatim
            head = index + quote_len  # move the search head after the quoted match
            quote = None  # blank out the quote literal
        else:  # the current position is not in a quoted substring
            index = eos
            # find the first quoted substring from the current head position
            for entry in QUOTE_STRINGS:  # loop through all quote substrings
                candidate = source.find(entry, head)
                if head &lt; candidate &lt; index:
                    index = candidate
                    quote = entry
                    quote_len = len(entry)
            if not quote:  # EOS reached, no quote found
                break
            result.append(replace_multiple(source[head:index], replacements))
            head = index  # move the search head to the start of the quoted match
    if head &lt; eos:  # if the search head is not at the end of the string
        result.append(replace_multiple(source[head:], replacements))
    return "".join(result)  # join back the result pieces and return them
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than just using regexes, you probably want to use Python's built in <a href="https://docs.python.org/3.6/library/shlex.html#module-shlex" rel="nofollow noreferrer">shlex</a> module. It's designed for handling quoted strings like you find in a shell, including nested examples.</p>
<pre><code>import shlex
shlex.split("""look "nested \\"quotes\\"" here""")
# ['look', 'nested "quotes"', 'here']
</code></pre>
</div>
<span class="comment-copy">I think I know what you mean, but just to be sure, could you provide an example input with the current and expected outputs? This usually makes it much more likely that someone will answer the question.</span>
<span class="comment-copy">Why don't you surround your regex pattern with lookahead/lookbehind groups of <code>['"]</code>?</span>
<span class="comment-copy">^ This is probably what you want ^ Some info here: <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">docs.python.org/3/library/re.html</a></span>
<span class="comment-copy">Thanks, but it doesn't seem to work...   Example: \n import re\n \n transpiled = ('hey " foo and foo!"')\n \n reps = [("foo", "bar"), ("and", "or")]\n \n print(transpiled)  # before the changes\n \n for rep in reps:\n     pattern, translated = rep\n     transpiled = re.sub("(?&lt;=[^\"']){}(?=\\\\?[^\"'])".format(pattern),\n                         translated, transpiled, flags=re.UNICODE)\n print "\n"\n print transpiled\n</span>
<span class="comment-copy">@Lucca - Check the update.</span>
<span class="comment-copy">again, thanks a lot for the time and effort. Unfortunately, however, it appears that this solution still doesn't work... the (slightly modified) code at <a href="https://pastebin.com/ggzjQCY0" rel="nofollow noreferrer">pastebin.com/ggzjQCY0</a> procudes <code>TypeError: sequence item 0: expected string, NoneType found</code>. I've been trying to get this to work for quite some time, so your help really means a lot. Thanks in advance!</span>
<span class="comment-copy">@Lucca - you never <code>return source</code> from the <code>replace_multiple()</code> function. Also, keep <code>QUOTED_STRING</code> outside of your function so you don't have to re-compile the pattern each time you run it.</span>
<span class="comment-copy">YES! Thanks a million!</span>
