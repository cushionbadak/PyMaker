<div class="post-text" itemprop="text">
<p>Let's say I have a list like this:</p>
<pre><code>[(9600002, 42, 3),
(9600001, 17, 3),
(9600003, 11, 1),
(9600002, 14, 5),
(9600001, 17, 1),
(9600003, 11, 4),
(9600001, 17, 4),
(9600001, 14, 3),
(9600002, 42, 6),
(9600002, 42, 1)] 
</code></pre>
<p>The first number is the <strong><em>user_id</em></strong>, the second is the <strong><em>tv_program_code</em></strong>, and the third is the <strong><em>season_id</em></strong>. </p>
<h2>My question</h2>
<p>How can I find out the <strong>program_code</strong> with more than <strong><em>1 season</em></strong> subscribed, and then print the <strong>user_id</strong> and the <strong>tv_program_code</strong>?  For example:</p>
<pre><code>9600001 17
</code></pre>
<p>Or do you have any suggestion of which data structure I should apply?</p>
</div>
<div class="post-text" itemprop="text">
<p>One method is to use <code>collections.Counter</code>.</p>
<p>The idea is to count the number of series per (user, program) combination using a dictionary.</p>
<p>Then filter for count greater than 1 via a dictionary comprehension.</p>
<pre><code>from collections import Counter

lst = [(9600002, 42, 3), (9600001, 17, 3), (9600003, 11, 1),
       (9600002, 14, 5), (9600001, 17, 1), (9600003, 11, 4),
       (9600001, 17, 4), (9600001, 14, 3), (9600002, 42, 6),
       (9600002, 42, 1)] 

c = Counter()

for user, program, season in lst:
    c[(user, program)] += 1

print(c)

# Counter({(9600002, 42): 3, (9600001, 17): 3, (9600003, 11): 2,
#          (9600002, 14): 1, (9600001, 14): 1})

res = {k: v for k, v in c.items() if v &gt; 1}

print(res)

# {(9600002, 42): 3, (9600001, 17): 3, (9600003, 11): 2}

print(res.keys())

# dict_keys([(9600002, 42), (9600001, 17), (9600003, 11)])
</code></pre>
<hr/>
<p><strong>Note on Counter versus defaultdict(int)</strong></p>
<p><code>Counter</code> is twice as slow as <code>defaultdict(int)</code>, see benchmarking below. You can switch easily to <code>defaultdict(int)</code> if performance matters and none of these features are relevant to you:</p>
<ol>
<li>Missing <code>Counter</code> keys <a href="https://stackoverflow.com/a/19883180/9209546">don't get added automatically</a> when querying.</li>
<li>You can add / subtract <code>Counter</code> objects.</li>
<li><code>Counter</code> offers <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">additional methods</a>, e.g. <code>elements</code>, <code>most_common</code>.</li>
</ol>
<p>Benchmarking on Python 3.6.2.</p>
<pre><code>from collections import defaultdict, Counter

lst = lst * 100000

def counter(lst):
    c = Counter()
    for user, program, season in lst:
        c[(user, program)] += 1
    return c

def dd(lst):
    d = defaultdict(int)
    for user, program, season in lst:
        d[(user, program)] += 1
    return d

%timeit counter(lst)  # 900 ms
%timeit dd(lst)       # 450 ms
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many ways to do this task </p>
<blockquote>
<p>first using detaultdict :</p>
</blockquote>
<pre><code>import collections
data=[(9600002, 42, 3),
(9600001, 17, 3),
(9600003, 11, 1),
(9600002, 14, 5),
(9600001, 17, 1),
(9600003, 11, 4),
(9600001, 17, 4),
(9600001, 14, 3),
(9600002, 42, 6),
(9600002, 42, 1)]

d=collections.defaultdict(list)

for i in data:
    d[(i[0],i[1])].append(i)

print(list(filter(lambda x:len(x)&gt;1,d.values())))
</code></pre>
<p>output:</p>
<pre><code>[[(9600003, 11, 1), (9600003, 11, 4)], [(9600001, 17, 3), (9600001, 17, 1), (9600001, 17, 4)], [(9600002, 42, 3), (9600002, 42, 6), (9600002, 42, 1)]]
</code></pre>
<blockquote>
<p>Second using itertools groupby :</p>
</blockquote>
<pre><code>import itertools

print(list(filter(lambda x:len(x)&gt;1,[list(j) for i,j in itertools.groupby(sorted(data),key=lambda x:(x[0],x[1]))])))
</code></pre>
<p>output:</p>
<pre><code>[[(9600001, 17, 1), (9600001, 17, 3), (9600001, 17, 4)], [(9600002, 42, 1), (9600002, 42, 3), (9600002, 42, 6)], [(9600003, 11, 1), (9600003, 11, 4)]]
</code></pre>
<blockquote>
<p>Third approach</p>
</blockquote>
<p>At last you can also try manual approach instead of using any import :</p>
<pre><code>d={}

for i in data:
    if (i[0],i[1]) not in d:
        d[(i[0],i[1])]=[i]
    else:
        d[(i[0],i[1])].append(i)

print(list(filter(lambda x:len(x)&gt;1,d.values())))
</code></pre>
<p>output:</p>
<pre><code>[[(9600003, 11, 1), (9600003, 11, 4)], [(9600001, 17, 3), (9600001, 17, 1), (9600001, 17, 4)], [(9600002, 42, 3), (9600002, 42, 6), (9600002, 42, 1)]]
</code></pre>
</div>
<span class="comment-copy">This looks good, but you aren't actually using the <code>Counter</code> interface at all, really. Might as well be a defaultdict.</span>
<span class="comment-copy">@miradulo, I have this discussion every time :). I don't see why one should, by default, prefer <code>defaultdict(int)</code> over <code>Counter</code>. Can you please explain further? <a href="https://stackoverflow.com/questions/19883015/python-collections-counter-vs-defaultdictint">Relevant question</a></span>
<span class="comment-copy">Thx,bro,and there is only one thing i don't understand res = {k: v for k, v in c.items() if v &gt; 1}  k: v for k     what is the k doing here?</span>
<span class="comment-copy"><code>c.items()</code> iterates through keys and values of your <code>Counter</code> dictionary. <code>k</code> is the tuple key (i.e. combination of user and program), while <code>v</code> is the count. You don't want to modify or filter by the key in this case.</span>
<span class="comment-copy">@jpp The defaultdict class is written in C, whereas a <code>collections.Counter</code> is written in Python. But beyond that, just on principle, why use a class giving you a far larger interface that you don't actually need?</span>
<span class="comment-copy">thx bro, i really appreciate</span>
<span class="comment-copy">Ayodhyankit Paul, one more thing, every sublist belongs to another class, so every sublist is an object when i try these methods i always end up getting the error [ object is not iterable ] , how can i fix this problem?</span>
<span class="comment-copy">@ShaneFAN show me example , I am not able to get your issue.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/49720361/object-is-not-iterable-in-python?noredirect=1#comment86453979_49720361">link</a>@Ayodhyankit Paul</span>
