<div class="post-text" itemprop="text">
<p>When I do socket programming with python,<br/>
I notice that some operations didn't stop by interrupt. Ex: <code>accept()</code> or <code>recv()</code><br/>
So I solve this problem using small timeout, that every 1 second, program stop the operation and recall that. For example,</p>
<pre><code>socket.settimeout(1)    
while True:
    try:
        socket.recv()
    except timeout:
        # back to socket.recv()
        continue
    except KeyboardInterrupt:
        break
</code></pre>
<p>Is there some potential problem like losing some messages during timeout exception or heavy load to OS, etc?</p>
<p>And, do you have any better idea to stop socket not using the timeout? Please tell me then I appreciate your answer.</p>
<p>There is one more thing need to consider. I test this program in Windows, and KeyboardInterrupt actually raise after recv() is done even if I press <kbd>ctrl</kbd>+<kbd>C</kbd>. But in MacOS or Linux, KeyboardInterrupt raise just after pressing <kbd>ctrl</kbd>+<kbd>C</kbd>. Is there difference between Windows and Linux/Unix?</p>
</div>
<div class="post-text" itemprop="text">
<p>With sockets, the risk of losing data depends on the socket type.  </p>
<p>With <code>SOCK_DGRAM</code> sockets, there is no promise that the protocol is <em>reliable</em>.  This means that in general you should expect that some messages will be lost no matter how you program <code>recv()</code> calls.  </p>
<p>With <code>SOCK_STREAM</code>, there is a promise that the incoming stream of data will be reliable and in the same order it was sent.</p>
<p>If you call <code>socket.settimeout(0)</code> or <code>socket.setblocking(False)</code>, then <code>recv()</code> checks the socket's receive buffer for incoming data, and if there is none, it <a href="https://docs.python.org/3/library/socket.html#socket-timeouts" rel="nofollow noreferrer">fails with an error that depends on the operating system</a>.  This could be used to <em>poll</em> periodically for data while also doing other things.  However, it can also introduce operating system-specific behavior to your program.</p>
<p>Another common technique is to create a thread whose sole purpose is to send and receive a socket that is set to blocking mode [<code>socket.setblocking(True)</code>].  In this case the thread can call <code>recv()</code> and wait as long as necessary until data actually comes in.  This setup lets you program a protocol as a conversation between <code>send()</code> and <code>recv()</code> calls. </p>
<p>For applications that handle messages from several sockets at a time, <a href="https://docs.python.org/3/library/select.html#select.select" rel="nofollow noreferrer"><code>select()</code></a> can be used to figure out which sockets in a set have pending data to <code>recv()</code>.  One caution is that <code>select()</code> can be inefficient in situations that demand high performance.</p>
</div>
<span class="comment-copy">A zero timeout value means infinity, not zero. It is not a mechanism for polling the socket.</span>
<span class="comment-copy">@EJP According to documentation for <a href="https://docs.python.org/3/library/socket.html#socket.socket.settimeout" rel="nofollow noreferrer"><code>socket.settimeout()</code></a>, zero puts the socket in non-blocking mode, while None, puts it in blocking mode (infinite timeout).</span>
