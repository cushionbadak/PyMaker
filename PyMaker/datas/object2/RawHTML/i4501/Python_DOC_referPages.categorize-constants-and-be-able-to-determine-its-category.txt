<div class="post-text" itemprop="text">
<p>I have some constants (they are something like Error codes).</p>
<pre><code>#errors
ERR_ROW_NUM = 1
ERR_COL_NUM = 2
ERR_NUM = 3

#incorrect
INCOR_ROW = 4
INCOR_COL = 5
INCOR_BOX = 6

#warning
WAR_HEAT = 7
WAR_PROCESS = 8
</code></pre>
<p>The numbers are 'randomly' assign and don't matter (what matter is that it is unique). I then have a dictionary that associates the constant with an error message (see below)</p>
<pre><code>MSG = {
    ERR_ROW_NUM:"incorrect number of row",
    ERR_COL_NUM:"incorrect number of column",
    ERR_NUM:"an incorrect number in tile detected",

    INCOR_ROW:"repeated number in a row",
    INCOR_COL:"repeated number in a column",
    INCOR_BOX:"repeated number in a small box",

    WAR_HEAT:"some kind of warning message",
    WAR_HARD:"the computer might not be able to handle this",
}
</code></pre>
<p>As you see, the constants can be put into categories: <em>error</em>, <em>incorrect</em> and <em>warning</em>.
Lets say a function <code>generate()</code> one of the constant. How can I determine the 'category' of the constant just from the unique constant number?</p>
<p>My aim is to be able to do something like this:</p>
<pre><code>output = generate()
category = #somehow get the category from the constant number
print "[ %s ] %s" % (category.upper(), MSG[output].capitalize())
</code></pre>
<p>So if the output from function <code>generate()</code> was <em>3</em>, then it would print out:</p>
<pre><code>[ ERROR ] An incorrect number in tile detected
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a mapping for the category:</p>
<pre><code>def catMapper(cat):
    if cat in [1,2,3]:
        return "Error"  # or "ERROR" to save the .upper() below
    elif cat in [4,5,6]:
        return "..."    # Incorrect? ValidationError? pick one.
    elif cat in [7,8]:
        return "Warning"

    raise ValueError('No mapping for {}'.format(cat)) # or return a default of your liking
</code></pre>
<p>And use it when creating your error message. </p>
<pre><code>print "[ %s ] %s" % (catMapper(output).upper(), MSG[output].capitalize())
</code></pre>
<p>You could also mapp each Errorcode to another Constant "CategoryType" in a dict - similar to what you do with your error messages, but I would probably do it inside a function, not a dict-lookup.</p>
<hr/>
<p>Advantage for dicts (Dict-Code taken from comment by @BlackJack) using <a href="https://docs.python.org/3/library/timeit.html#timeit.timeit" rel="nofollow noreferrer">timeit</a>:</p>
<pre><code>setupDict = """
CAT_TO_NAME = {cat: name for name, cats in [('Error', [1, 2, 3]), ('Incorrect', [4, 5, 6]), ('Warning', [7,8])] for cat in cats}
"""     

testDict = """
for c in range(1,9):
    getIt = CAT_TO_NAME[c]
"""

setupFunc = """
def catMapper(cat):
    if cat in [1,2,3]:
        return "Error"  # or "ERROR" to save the .upper() below
    elif cat in [4,5,6]:
        return "..."    # Incorrect? ValidationError? pick one.
    elif cat in [7,8]:
        return "Warning"

    raise ValueError('No mapping for {}'.format(cat)) # or return a default of your liking
"""

testFunc = """ 
for c in range(1,9):
    getIt = catMapper(c)
"""

import timeit

print(timeit.timeit(testDict,setup = setupDict))
print(timeit.timeit(testFunc,setup = setupFunc))
</code></pre>
<p>Output:</p>
<pre><code>0.974066972733   # dictionary lookup
3.08595490456    # functional lookup
</code></pre>
<p><strong>Result:</strong> </p>
<p>Dict-Lookup is 3 times as performant .... looking up <em>all</em> codes, once each, 1 million times takes not quite <code>1s</code> for dict and <code>3s</code> for functional lookup.</p>
<p>So if your main task is looking up this string 9 million times as fast as possible, you shave off 2s doing so by using a dictionary ...</p>
</div>
<span class="comment-copy">I would look into the <code>enum</code> module. This is not available in python2.7 but there are backports available.</span>
<span class="comment-copy">Any reason why a slow and ”complicated” function instead of a lookup dictionary? Also I cringe looking at the <code>else</code> branch. Supplying a <code>cat</code> value that is neither error, incorrect, or warning but returning warning is an error waiting to happen. :-)</span>
<span class="comment-copy">@BlackJack a dictionary would need multiple int-&gt;string mappings - lots of strings the same. Thats why I mentioned the possibility but I prefer to do otherwise. The "slowness" due to function call is not that important in this case (IMHO) - unless all the application does is formatting this kind of format strings. I concede a point for the <code>else</code> though - I was lazy - I fixed it up a bit and made it  better :) One should probably put all the message creation into one function so you just call <code>msg = GetErrorMessage(code)</code> and be good with it - abstracting the message building.</span>
<span class="comment-copy">It's not lots of strings the same but the same string as value for different keys. <code>CAT_TO_NAME = {cat:name for name, cat in [('Error', [1, 2, 3]), ('Incorrect', [4, 5, 6]), ('Warning', [7,8])]}</code></span>
<span class="comment-copy">@BlackJack does not work, lists are not hashable. you cant use them as key. You could use tuples instead but then you are sacrificing the fast lookup of your key inside the dict. You only have 1 or 2 or 3 not (1,2,3) as key - so you need to iterate the dictionary over all keys and check each key-tuple if it contains the given code - also not a speedy approach. You get speed if you create each single code and map it to the string but then you get lots of duplicate texts ... hence I prefer the function.</span>
<span class="comment-copy">Sorry, I meant: <code>CAT_TO_NAME = {cat: name  for name, cats in [('Error', [1, 2, 3]), ('Incorrect', [4, 5, 6]), ('Warning', [7,8])] for cat in cats}</code>.</span>
