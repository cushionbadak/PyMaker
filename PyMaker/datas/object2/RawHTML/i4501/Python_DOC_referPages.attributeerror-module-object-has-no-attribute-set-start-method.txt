<div class="post-text" itemprop="text">
<p>That code below starts fine in pycharm. </p>
<p>But by starting with the command line:</p>
<pre><code> "python field_basket_design_uwr.py" 
</code></pre>
<p>it gives error:</p>
<pre><code>Traceback (most recent call last):
  File "field_basket_design_uwr.py", line 677, in &lt;module&gt;
    mp.set_start_method('spawn')
AttributeError: 'module' object has no attribute 'set_start_method'
</code></pre>
<p>Has somebody an idea how to make the script starting without error?</p>
<pre><code>#!/usr/bin/python3.5

import math
import sys
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk as gtk, Gdk as gdk, GLib, GObject as gobject
import string
import os
import subprocess
import glob
from datetime import datetime, timedelta
import time
import numpy as np
import matplotlib; matplotlib.use('Gtk3Agg')
import matplotlib.animation as animation
from mpl_toolkits.mplot3d.proj3d import proj_transform
from matplotlib.text import Annotation
from matplotlib.backends.backend_gtk3cairo import FigureCanvasGTK3Cairo as FigureCanvas 
import matplotlib.pyplot as plt
import multiprocessing as mp
class Annotation3D(Annotation):
    '''Annotate the point xyz with text s'''
    def __init__(self, s, xyz, *args, **kwargs):
        Annotation.__init__(self,s, xy=(0,0), *args, **kwargs)
        self._verts3d = xyz

    def draw(self, renderer):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj_transform(xs3d, ys3d, zs3d, renderer.M)
        self.xy=(xs,ys)
        Annotation.draw(self, renderer)
#
def annotate3D(ax, s, *args, **kwargs):
    '''add anotation text s to to Axes3d ax'''
    tag = Annotation3D(s, *args, **kwargs)
    ax.add_artist(tag)
#
def draw_basket(ax1, x, y, z, h, color='black'):
    '''add basket to the ax1 figure'''
    t = np.linspace(0, np.pi * 2, 16)
    ax1.plot(x+0.24*np.cos(t), y+0.24*np.sin(t), z,  linewidth=1, color=color)
    ax1.plot(x+0.16*np.cos(t), y+0.16*np.sin(t), z,  linewidth=1, color=color)
    ax1.plot(x+0.24*np.cos(t), y+0.24*np.sin(t), z+h,  linewidth=1, color=color)
    A=0
    while A &lt; 16:
        xBar = [x+ 0.16 * math.sin(A*22.5*np.pi/180),x+ 0.24 * math.sin(A*22.5*np.pi/180)]
        yBar = [y+ 0.16 * math.cos(A*22.5*np.pi/180),y+ 0.24 * math.cos(A*22.5*np.pi/180)]
        zBar = [0,h]
        ax1.plot(xBar, yBar, zBar, color=color)
        A = A+1

def draw_halfsphere (ax1, x, y, z, sph_radius, color=(0,0,1,1)):
    ''' add free distance surface to Axes3d ax1 '''
    u, v = np.mgrid[0:2 * np.pi:20j, 0:np.pi/2:10j]
    xP1 = x + sph_radius * np.cos(u) * np.sin(v)
    yP1 = y + sph_radius * np.sin(u) * np.sin(v)
    zP1 = z - sph_radius * np.cos(v)
    halffreesphere = ax1.plot_wireframe(xP1, yP1, zP1, color=color, alpha=0.3)
    return halffreesphere

def OnClick(event):
    global selected_coord
    global clicked_coord
    clicked_coord [0, 0] = clicked_coord [1, 0]
    clicked_coord [0, 1] = clicked_coord [1, 1]
    clicked_coord [0, 2] = clicked_coord [1, 2]
    clicked_coord [1, 0] = selected_coord[0]
    clicked_coord [1, 1] = selected_coord[1]
    clicked_coord [1, 2] = selected_coord[2]
    print ("selected position X: %5.2f   Y: %5.2f   Z: %5.2f" % (selected_coord[0], selected_coord[1],selected_coord[2]))
    print ("distance between selected points:  %5.2f", np.sqrt ((clicked_coord [0, 0] - clicked_coord [1, 0])**2
                    + (clicked_coord [0, 1]- clicked_coord [1, 1])**2
                    + (clicked_coord [0, 2] - clicked_coord [1, 2])**2))

def distance(point, event):
    """Return distance between mouse position and given data point

    Args:
        point (np.array): np.array of shape (3,), with x,y,z in data coords
        event (MouseEvent): mouse event (which contains mouse position in .x and .xdata)
    Returns:
        distance (np.float64): distance (in screen coords) between mouse pos and data point
    """
    x2, y2, _ = proj_transform(point[0], point[1], point[2], plt.gca().get_proj())
    x3, y3 = ax1.transData.transform((x2, y2))

    return np.sqrt ((x3 - event.x)**2 + (y3 - event.y)**2)


def calcClosestDatapoint(X, event):
    """"Calculate which data point is closest to the mouse position.

    Args:
        X (np.array) - array of points, of shape (numPoints, 3)
        event (MouseEvent) - mouse event (containing mouse position)
    returns:
        smallestIndex (int) - the index (into the array of points X) of the element closest to the mouse position
    """
    distances = [distance (X[i, 0:3], event) for i in range(X.shape[0])]
    return np.argmin(distances),np.amin(distances)


def annotatePlot(X, index):
    global selected_coord
    """Create popover label in 3d chart

    Args:
        X (np.array) - array of points, of shape (numPoints, 3)
        index (int) - index (into points array X) of item which should be printed
    Returns:
        None
    """
    # If we have previously displayed another label, remove it first
    if hasattr(annotatePlot, 'label'):
        annotatePlot.label.remove()
    # Get data point from array of points X, at position index
    x2, y2, _ = proj_transform(X[index, 0], X[index, 1], X[index, 2], ax1.get_proj())
    annotatePlot.label = plt.annotate( "Select %d" % (index+1),
        xy = (x2, y2), xytext = (-20, 20), textcoords = 'offset points', ha = 'right', va = 'bottom',
        bbox = dict(boxstyle = 'round,pad=0.5', fc = 'yellow', alpha = 0.5),
        arrowprops = dict(arrowstyle = '-&gt;', connectionstyle = 'arc3,rad=0'))
    # make coord from label available global for other function like distance measurement  between points
    selected_coord[0]=X[index, 0]
    selected_coord[1]=X[index, 1]
    selected_coord[2]=X[index, 2]
    #
    fig.canvas.draw()

def onMouseMotion(event):
    global pos_pb_now, pos_pw_now
    """Event that is triggered when mouse is moved. Shows text annotation over data point closest to mouse."""
    closestIndexW,LowestDistanceW = calcClosestDatapoint(pos_pw_now, event)
    closestIndexB,LowestDistanceB = calcClosestDatapoint(pos_pb_now, event)
    if LowestDistanceW &lt; LowestDistanceB:
        annotatePlot (pos_pw_now, closestIndexW)
    else:
        annotatePlot (pos_pb_now, closestIndexB)

#
def OneWindow(s_w_shared,s_d_shared,s_l_shared,el_w_shared,elevation_shared, azimut_shared, pb,
              pw, ball):
    import numpy as np
    import matplotlib.pyplot as plt

    ''' Sub-processed Plot viewer of the main windows; copy/paste in one; it helps for PC with 2 monitors
     The main windows remain the control window of the trainer. This window is the view windows of the trained player'''
    #

    def animate_one(i):
        p_b_one._offsets3d = pos_pb_now_one[:, 0], pos_pb_now_one[:, 1], pos_pb_now_one[:, 2]
        p_w_one._offsets3d = pos_pw_now_one[:, 0], pos_pw_now_one[:, 1], pos_pw_now_one[:, 2]
        p_ball_one._offsets3d = pos_ball_now_one[:, 0], pos_ball_now_one[:, 1], pos_ball_now_one[:, 2]
        ax1_one.view_init(elev=elevation_shared.value, azim=azimut_shared.value)
    fig_one = plt.figure()
    ax1_one = fig_one.add_subplot(111,projection='3d')
    #
    arrpb = np.frombuffer(pb.get_obj(), dtype='f')
    pos_pb_now_one = np.reshape(arrpb, (6, 3))
    #
    arrpw = np.frombuffer(pw.get_obj(), dtype='f')
    pos_pw_now_one = np.reshape(arrpw, (6, 3))
    #
    arrball = np.frombuffer(ball.get_obj(), dtype='f')
    pos_ball_now_one = np.reshape(arrball, (1, 3))

    xG = [0,s_w_shared.value,s_w_shared.value,0,0, 0,s_w_shared.value,s_w_shared.value,s_w_shared.value,
          s_w_shared.value,s_w_shared.value, 0, 0,0, 0,s_w_shared.value]
    yG = [0, 0, 0,0,0,s_l_shared.value,s_l_shared.value, 0, 0,s_l_shared.value,s_l_shared.value,s_l_shared.value,
          s_l_shared.value,0,s_l_shared.value,s_l_shared.value]
    zG = [0, 0, s_d_shared.value,s_d_shared.value,0, 0, 0, 0, s_d_shared.value, s_d_shared.value, 0, 0,
          s_d_shared.value,s_d_shared.value, s_d_shared.value, s_d_shared.value]
    ax1_one.plot_wireframe (xG,yG,zG,colors= (0,0,1,1))  # blue line game area
    xW = [s_w_shared.value,s_w_shared.value+el_w_shared.value,s_w_shared.value+el_w_shared.value,s_w_shared.value,
          s_w_shared.value,s_w_shared.value,s_w_shared.value+el_w_shared.value,s_w_shared.value+el_w_shared.value,
          s_w_shared.value+el_w_shared.value,s_w_shared.value+el_w_shared.value,s_w_shared.value+el_w_shared.value,
          s_w_shared.value,s_w_shared.value,s_w_shared.value,s_w_shared.value,s_w_shared.value+el_w_shared.value]
    yW = [0,  0, 0, 0, 0,s_l_shared.value,s_l_shared.value, 0, 0,s_l_shared.value,s_l_shared.value,s_l_shared.value,
          s_l_shared.value, 0,s_l_shared.value,s_l_shared.value]
    zW = [0,  0, s_d_shared.value, s_d_shared.value, 0, 0, 0, 0, s_d_shared.value, s_d_shared.value, 0, 0,
          s_d_shared.value, s_d_shared.value, s_d_shared.value, s_d_shared.value]
    ax1_one.plot_wireframe (xW,yW,zW,colors= (0,1,1,1))  # light blue line exchange area
    #
    ax1_one.set_xlabel('Wide')
    ax1_one.set_ylabel('Length')
    ax1_one.set_zlabel('Water')
    #
    # draw the 2 lines which show the depth
    xG1 = [0, s_w_shared.value]
    yG1 = [s_d_shared.value, s_d_shared.value]
    zG1 = [0, 0]
    ax1_one.plot_wireframe(xG1, yG1, zG1, colors=(0, 0, 1, 1),linestyle=':')  # blue line
    xG2 = [0, s_w_shared.value]
    yG2 = [s_l_shared.value-s_d_shared.value, s_l_shared.value-s_d_shared.value]
    zG2 = [0, 0]
    ax1_one.plot_wireframe(xG2, yG2, zG2, colors=(0, 0, 1, 1),linestyle=':')  # blue line
    #
    # put the axis fix
    ax1_one.set_xlim3d(0, s_w_shared.value+el_w_shared.value)
    ax1_one.set_ylim3d(0, s_l_shared.value)
    ax1_one.set_zlim3d(0, s_d_shared.value)
    ax1_one.set_aspect(aspect=0.222)
    draw_basket(ax1_one, s_w_shared.value / 2, 0.24, 0., 0.45)
    draw_basket(ax1_one, s_w_shared.value / 2, s_l_shared.value - 0.24, 0., 0.45)
    #
    p_b_one = ax1_one.scatter(pos_pb_now_one[:, 0], pos_pb_now_one[:, 1], pos_pb_now_one[:, 2],
                          s=400, alpha = 0.5, c=(0, 0, 1, 1))
    p_w_one = ax1_one.scatter(pos_pw_now_one[:, 0], pos_pw_now_one[:, 1],
                      pos_pw_now_one[:, 2], s=400, alpha = 0.5, c="darkgrey")
    p_ball_one = ax1_one.scatter(pos_ball_now_one[:,0], pos_ball_now_one[:,1],
                      pos_ball_now_one[:,2], s=100, alpha = 0.5, c="red")

    for j, xyz_ in enumerate(pos_pb_now_one):
        annotate3D(ax1_one, s=str(j+1), xyz=xyz_, fontsize=10, xytext=(-3,3),
                   textcoords='offset points', ha='right',va='bottom')
    for j, xyz_ in enumerate(pos_pw_now_one):
        annotate3D(ax1_one, s=str(j+1), xyz=xyz_, fontsize=10, xytext=(-3,3),
                   textcoords='offset points', ha='right', va='bottom')

    Frame = 10

    ani1_one = animation.FuncAnimation(fig_one, animate_one, frames=Frame, interval=600, blit=False, repeat=True,
                                       repeat_delay=500)
    #
    plt.pause(0.001)
    plt.show()


def animate(i):

    global pos_pb_now, pos_pb_now_shared, pos_pb_target, p_b, pos_pb_deltamove
    global pos_pw_now, pos_pw_now_shared, pos_pw_target, p_w, pos_pw_deltamove
    global pos_ball_now, pos_ball_now_shared, pos_ball_target, p_ball, pos_ball_deltamove
    global Frame
    global count_iter
    global video_page_iter
    global azimut_shared
    global elevation_shared
    global video_file_name
#    global EmitPosOneWin
#    global EmitPosFourWin
    global ax1
    global free_sphere
    #
    azimut, elevation = ax1.azim, ax1.elev
#    print ("azimut from main",azimut)
    azimut_shared.value = azimut
#    print ("azimut_shared value from main",azimut_shared.value)
    elevation_shared.value = elevation

    pos_ball_now[0,0] += (1. / Frame) * pos_ball_deltamove[0,0]
    pos_ball_now[0,1] += (1. / Frame) * pos_ball_deltamove[0,1]
    pos_ball_now[0,2] += (1. / Frame) * pos_ball_deltamove[0,2]
    #
#    EmitPosOneWin.put(['bp', 0, pos_ball_now[0,0], pos_ball_now[0,1], pos_ball_now[0,2]])
#    EmitPosFourWin.put(['bp', 0, pos_ball_now[0,0], pos_ball_now[0,1], pos_ball_now[0,2]])
    pos_ball_now_shared[0] = pos_ball_now[0, 0]
    pos_ball_now_shared[1] = pos_ball_now[0, 1]
    pos_ball_now_shared[2] = pos_ball_now[0, 2]

    for j in range(6):
        pos_pb_now[j, 0] += (1. / Frame) * pos_pb_deltamove[j, 0]
        pos_pb_now[j, 1] += (1. / Frame) * pos_pb_deltamove[j, 1]
        pos_pb_now[j, 2] += (1. / Frame) * pos_pb_deltamove[j, 2]

        pos_pw_now[j, 0] += (1. / Frame) * pos_pw_deltamove[j, 0]
        pos_pw_now[j, 1] += (1. / Frame) * pos_pw_deltamove[j, 1]
        pos_pw_now[j, 2] += (1. / Frame) * pos_pw_deltamove[j, 2]

        #
        # feed the queue; queue because that animation could be paused
#        EmitPosOneWin.put(['pb', j, pos_pb_now[j, 0], pos_pb_now[j, 1], pos_pb_now[j, 2]])
#        EmitPosOneWin.put(['pw', j, pos_pw_now[j, 0], pos_pw_now[j, 1], pos_pw_now[j, 2]])
#        EmitPosFourWin.put(['pb', j, pos_pb_now[j, 0], pos_pb_now[j, 1], pos_pb_now[j, 2]])
#        EmitPosFourWin.put(['pw', j, pos_pw_now[j, 0], pos_pw_now[j, 1], pos_pw_now[j, 2]])
        pos_pb_now_shared[j*3] = pos_pb_now[j,0]
        pos_pb_now_shared[j*3+1] = pos_pb_now[j,1]
        pos_pb_now_shared[j*3+2] = pos_pb_now[j,2]
        pos_pw_now_shared[j*3] = pos_pw_now[j,0]
        pos_pw_now_shared[j*3+1] = pos_pw_now[j,1]
        pos_pw_now_shared[j*3+2] = pos_pw_now[j,2]
        #

    p_b._offsets3d = pos_pb_now[:, 0], pos_pb_now[:, 1], pos_pb_now[:, 2]
    p_w._offsets3d = pos_pw_now[:, 0], pos_pw_now[:, 1], pos_pw_now[:, 2]
    p_ball._offsets3d = pos_ball_now[:,0],pos_ball_now[:,1],pos_ball_now[:,2]

    #
    video_page_iter = video_page_iter+1 # if video is on
    plt.savefig("/home/family/Bilder" + "/file%03d.png" % video_page_iter)  # if video is on
    #
    if video_page_iter==100:   # or if command store video
        os.chdir("/home/family/Bilder")
        subprocess.call([
            'ffmpeg', '-framerate', '8', '-i', 'file%03d.png', '-r', '30', '-pix_fmt', 'yuv420p',
#            'video_name.mp4'
            video_file_name
        ])   # add -y to overwrite  test this
        for file_name in glob.glob("*.png"):
            os.remove(file_name)
        video_page_iter = 0
        # simulate the deletion of the free domain. Will be activated later by a GUI
        free_sphere.remove()
#        fig.canvas.draw()

    if i == (Frame - 1):
        # reset the deltamove to a clean zero for last position in case of rounding elements
        # or set to next step of dynamic move
        count_iter = count_iter+1
        m, s = divmod(count_iter, 2)
        if s == 1:
            free_sphere.remove()
            fig.canvas.draw()
            pos_ball_deltamove[0,0] = -1.
            pos_ball_deltamove[0,1] = -1.
            pos_ball_deltamove[0,2] = -1.
            for k in range(6):
                pos_pb_deltamove[k, 0] = -1.
                pos_pb_deltamove[k, 1] = -1.
                pos_pb_deltamove[k, 2] = -1.
                pos_pw_deltamove[k, 0] = -1.
                pos_pw_deltamove[k, 1] = -1.
                pos_pw_deltamove[k, 2] = -1.
        else:
            free_sphere = draw_halfsphere(ax1, 5., 9., 4., 2.)
            pos_ball_deltamove[0,0] = 1.
            pos_ball_deltamove[0,1] = 1.
            pos_ball_deltamove[0,2] = 1.
            for k in range(6):
                pos_pb_deltamove[k, 0] = 1.
                pos_pb_deltamove[k, 1] = 1.
                pos_pb_deltamove[k, 2] = 1.
                pos_pw_deltamove[k, 0] = 1.
                pos_pw_deltamove[k, 1] = 1.
                pos_pw_deltamove[k, 2] = 1.

        pos_ball_now[0,0] = pos_ball_target[0,0]
        pos_ball_now[0,1] = pos_ball_target[0,1]
        pos_ball_now[0,2] = pos_ball_target[0,2]
        pos_ball_now_shared[0] = pos_ball_now[0, 0]
        pos_ball_now_shared[1] = pos_ball_now[0, 1]
        pos_ball_now_shared[2] = pos_ball_now[0, 2]

        for k in range(6):
            pos_pb_now[k, 0] = pos_pb_target[k, 0]
            pos_pb_now[k, 1] = pos_pb_target[k, 1]
            pos_pb_now[k, 2] = pos_pb_target[k, 2]
            pos_pw_now[k, 0] = pos_pw_target[k, 0]
            pos_pw_now[k, 1] = pos_pw_target[k, 1]
            pos_pw_now[k, 2] = pos_pw_target[k, 2]
            pos_pb_now_shared[k * 3] = pos_pb_now[k, 0]
            pos_pb_now_shared[k * 3 + 1] = pos_pb_now[k, 1]
            pos_pb_now_shared[k * 3 + 2] = pos_pb_now[k, 2]
            pos_pw_now_shared[k * 3] = pos_pw_now[k, 0]
            pos_pw_now_shared[k * 3 + 1] = pos_pw_now[k, 1]
            pos_pw_now_shared[k * 3 + 2] = pos_pw_now[k, 2]

        #
if __name__=="__main__":
    #
    ######## define the queues for the 2 detached plot processes
    mp.set_start_method('spawn')
    #
    s_w = 10.0
#    s_w_shared = Value('d', 10.0)
    s_w_shared = mp.Value('f', 10.0)
    #
    s_d = 4.0
    s_d_shared = mp.Value('f', 4.0)
    #
    s_l = 18.0
    s_l_shared = mp.Value('f', 18.0)
    # exchange lane width
    el_w = 1.0  # normally 3
    el_w_shared = mp.Value('f', 1.0)  # just 1m in order to show the side
    # ball radius
#    b_r = 0.53 / (2 * math.pi)
#    b_r_shared = Value('d', 0.53 / (2 * math.pi))
    #
    elevation_shared = mp.Value('f', 10.)
    azimut_shared = mp.Value('f', 30.)
    #
    # define/initiate teams blue and white; array

    pos_pb_now = []
    pos_pb_now_shared = mp.Array('f',3*6)

    pos_pb_target = []

    pos_pw_now = []
    pos_pw_now_shared = mp.Array('f',3*6)

    pos_pw_target = []
    pos_pb_deltamove = []
    pos_pw_deltamove = []
    #
    pos_ball_now = []
    pos_ball_now_shared = mp.Array('f',3)

    pos_ball_target = []
    pos_ball_deltamove = []
    #
    clicked_coord = []    # matrix 2x3 for storing coord of clicked points for distance calculation
    clicked_coord.append([0., 0., 0.])
    clicked_coord.append([0., 0., 0.])
    #
    selected_coord = [0., 0., 0.]
    #
    numb_seq = 0
    video_page_iter = 0
    video_file_name = "test_video_name.mp4"
    #
    pos_ball_now.append([5.,9.,0.2]) # ball in the middle
    pos_ball_target.append([5.,9.,0.2])
    pos_ball_deltamove.append([0., 0., 0.])
    #
    for i in range(6):
        # distribute the players at the side with the same distance
        # at game start
        pos_pb_now.append([((s_w/6)/2)+i*(s_w/6),1.0, s_d])
        pos_pb_target.append([((s_w/6)/2)+i*(s_w/6),1.0, s_d])
        pos_pw_now.append([s_w - ((s_w / 6) / 2) - i * (s_w / 6), s_l - 1.0, s_d])
        pos_pw_target.append([s_w - ((s_w / 6) / 2) - i * (s_w / 6), s_l - 1.0, s_d])
        pos_pb_deltamove.append([0., 0., 0.])
        pos_pw_deltamove.append([0., 0., 0.])
    #
    # Define numpy array which is faster to work with
    pos_pb_now = np.array(pos_pb_now, dtype='f')
    pos_pb_target = np.array(pos_pb_target, dtype='f')
    pos_pw_now = np.array(pos_pw_now, dtype='f')
    pos_pw_target = np.array(pos_pw_target, dtype='f')
    pos_pb_deltamove = np.array(pos_pb_deltamove, dtype='f')
    pos_pw_deltamove = np.array(pos_pw_deltamove, dtype='f')
    #
    pos_ball_now = np.array(pos_ball_now, dtype='f')
    pos_ball_target = np.array(pos_ball_target, dtype='f')
    pos_ball_deltamove = np.array(pos_ball_deltamove, dtype='f')
    #
    clicked_coord = np.array(clicked_coord, dtype='f')
    selected_coord = np.array(selected_coord, dtype='f')
    #
    fig = plt.figure()
    ax1 = fig.add_subplot(111,projection='3d')
    # field
    xG = [0,s_w,s_w,0,0, 0,s_w,s_w,s_w,s_w,s_w, 0, 0,0, 0,s_w]
    yG = [0, 0, 0,0,0,s_l,s_l, 0, 0,s_l,s_l,s_l,s_l,0,s_l,s_l]
    zG = [0, 0, s_d,s_d,0, 0, 0, 0, s_d, s_d, 0, 0, s_d,s_d, s_d, s_d]
    ax1.plot_wireframe (xG,yG,zG,colors= (0,0,1,1))  # blue line game area
    # exchange area
    xW = [s_w,s_w+el_w,s_w+el_w,s_w,s_w,s_w,s_w+el_w,s_w+el_w,s_w+el_w,s_w+el_w,s_w+el_w,s_w,s_w,s_w,s_w,s_w+el_w]
    yW = [0,  0, 0, 0, 0,s_l,s_l, 0, 0,s_l,s_l,s_l,s_l, 0,s_l,s_l]
    zW = [0,  0, s_d, s_d, 0, 0, 0, 0, s_d, s_d, 0, 0, s_d, s_d, s_d, s_d]
    ax1.plot_wireframe (xW,yW,zW,colors= (0,1,1,1))  # light blue line exchange area
    #
    ax1.set_xlabel('Wide')
    ax1.set_ylabel('Length')
    ax1.set_zlabel('Water')
    #
    # draw the 2 lines which show the depth
    xG1 = [0, s_w]
    yG1 = [s_d, s_d]
    zG1 = [0, 0]
    ax1.plot_wireframe(xG1, yG1, zG1, colors=(0, 0, 1, 1),linestyle=':')  # blue line
    xG2 = [0, s_w]
    yG2 = [s_l-s_d, s_l-s_d]
    zG2 = [0, 0]
    ax1.plot_wireframe(xG2, yG2, zG2, colors=(0, 0, 1, 1),linestyle=':')  # blue line
    #
    # put the axis fix
    ax1.set_xlim3d(0, s_w+el_w)
    ax1.set_ylim3d(0, s_l)
    ax1.set_zlim3d(0, s_d)
    ax1.set_aspect(aspect=0.15)  # the best
    draw_basket(ax1, s_w / 2, 0.24, 0., 0.45)
    draw_basket(ax1, s_w / 2, s_l - 0.24, 0., 0.45)
    free_sphere = draw_halfsphere(ax1, 5., 9., 4., 2.)
    p_b = ax1.scatter(pos_pb_now[:, 0], pos_pb_now[:, 1], pos_pb_now[:, 2],
                          s=400, alpha = 0.5, c=(0, 0, 1, 1))
    p_w = ax1.scatter(pos_pw_now[:, 0], pos_pw_now[:, 1],
                      pos_pw_now[:, 2], s=400, alpha = 0.5, c="darkgrey")

    p_ball = ax1.scatter(pos_ball_now[:,0], pos_ball_now[:,1],
                      pos_ball_now[:,2], s=100, alpha = 0.5, c="red")
    for j, xyz_ in enumerate(pos_pb_now):
        annotate3D(ax1, s=str(j+1), xyz=xyz_, fontsize=10, xytext=(-3,3),
                   textcoords='offset points', ha='right',va='bottom')
    for j, xyz_ in enumerate(pos_pw_now):
        annotate3D(ax1, s=str(j+1), xyz=xyz_, fontsize=10, xytext=(-3,3),
                   textcoords='offset points', ha='right', va='bottom')

    Frame = 5   
    for j in range(6):
        pos_pb_deltamove[j, 0] = 1.
        pos_pb_deltamove[j, 1] = 1.
        pos_pb_deltamove[j, 2] = 1.

        pos_pw_deltamove[j, 0] = 1.
        pos_pw_deltamove[j, 1] = 1.
        pos_pw_deltamove[j, 2] = 1.

    pos_ball_deltamove[0,0] = 1.
    pos_ball_deltamove[0,1] = 1.
    pos_ball_deltamove[0,2] = 1.

    count_iter = 0

    ani1 = animation.FuncAnimation(fig, animate, frames=Frame, interval=1000, blit=False, repeat=True, repeat_delay=1000)

    plt.pause(0.001)

    p1 = mp.Process(target=OneWindow, args=(s_w_shared, s_d_shared, s_l_shared, el_w_shared,elevation_shared,
                                         azimut_shared, pos_pb_now_shared, pos_pw_now_shared, pos_ball_now_shared))
    p1.start()

    fig.canvas.mpl_connect('motion_notify_event', onMouseMotion)
    fig.canvas.mpl_connect('button_press_event', OnClick)

    plt.show()
</code></pre>
<p>EDIT1:</p>
<p>"python3 field_basket_design_uwr.py" works.</p>
<p>error which is still coming; perhaps subject to a new thread (not disturbing for the moment); anyway, any comment ho to take this away is welcome. Thanks.   </p>
<pre><code>/usr/lib/python3/dist-packages/matplotlib/backend_bases.py:2445: MatplotlibDeprecationWarning: Using default event loop until function specific to this GUI is implemented
  warnings.warn(str, mplDeprecation)
/usr/lib/python3/dist-packages/cairocffi/surfaces.py:651: UserWarning: implicit cast from 'char *' to a different pointer type: will be forbidden in the future (check that the types are as you expect; use an explicit ffi.cast() if they are correct)
  ffi.cast('char*', address), format, width, height, stride)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>set_start_method</code> in <code>multiprocessing</code> was introduced in Python version 3.4</p>
<p>The error you are facing is due to the fact that you are using an older version of Python. Upgrading to Python 3.4 and above will fix the error.</p>
<p>For more information, refer to -
<a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.set_start_method" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html#multiprocessing.set_start_method</a></p>
</div>
<span class="comment-copy">What version of <code>Python</code> are you using?</span>
<span class="comment-copy">uname -a  gives Linux 4.9.0-6-amd64 #1 SMP Debian 4.9.82-1+deb9u3 (2018-03-02) x86_64 GNU/Linux   and  apt-get install python3  show the version python3 is already the newest version (3.5.3-1).</span>
<span class="comment-copy">mistake.. "python -V" show Python 2.7.13 ...  "python3 field_basket_design_uwr.py" works. topic closed. Thanks.</span>
<span class="comment-copy">Glad that helps. I've posted an answer to the question below so that it would be useful for others if they face the same issue. Kindly upvote or mark the answer as accepted if this has solved your problem.</span>
<span class="comment-copy">Any work around for 2.7 users? Thank you.</span>
