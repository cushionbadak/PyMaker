<div class="post-text" itemprop="text">
<p>Disclaimer: This is not homework or anything related to a school assignment. This is purely me trying to better understand how programming with classes (and making shallow/ deep copies of class instances) works. </p>
<p>So I wrote two classes: <code>Point</code> and <code>Rectangle</code>. Here I'm creating two Rectangle objects: <code>box</code> and <code>new_box</code>.</p>
<p>When I invoke the <code>move_rectangle(rect, dx, dy)</code> method and run my code (which I will attempt to post here), it's supposed to return a deep copy of <code>box</code> (the returned value of which is assigned to <code>new_box</code>). </p>
<p>When I check if: <code>box is new_box</code>, it returns <code>False</code> (which I expected), but when I check the x-coordinates of both <code>box</code> and <code>new_box</code>, <strong>both</strong> of their x-values were changed. </p>
<p>This is what I expected:</p>
<pre><code>box.corner.x = 3
new_box.corner.x = 6
</code></pre>
<p>Instead, I got: </p>
<pre><code>box.corner.x = 6    
new_box.corner.x = 6
</code></pre>
<p>How can that be if box is supposed to be a separate object from <code>new_box</code>? </p>
<p>Any help/ tips/ advice is greatly appreciated!</p>
<p>Here's my code: </p>
<pre><code>import math
import copy

class Point (object):
    """ Represent a point in a 2-D space """
    x = 0.0
    y = 0.0

    def distance(p1, p2):
        return math.sqrt((p2.x-p1.x)**2 + (p2.y-p1.y)**2)

    def print_point(p):
        print('(%g, %g)' % (p.x, p.y))

class Rectangle(object):
    """represent a rectangle.
    attributes: width, height, corner."""

    width = 0.0
    height = 0.0
    corner = Point()

    def grow_rectangle(rect, dwidth, dheight):
        rect.width += dwidth
        rect.height += dheight

    def move_rectangle(rect, dx, dy):
        new_rect = copy.deepcopy(rect)
        new_rect.corner.x += dx
        new_rect.corner.y += dy
        return new_rect

    def findCenter(box):
        p = Point()
        p.x = box.corner.x + box.width/2.0
        p.y = box.corner.y + box.height/2.0
        return p

box = Rectangle()
box.corner.x = 3
box.corner.y = 8

new_box = Rectangle.move_rectangle(box, 3, 5)
print(new_box is box.corner)
print(box.corner.x)
print(new_box.corner.x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer"><code>copy.deepcopy</code></a> function only knows how to deep-copy types that implement the copying protocol (or the pickling protocol). Built-in containers like lists and dicts of course implement it, but your <code>Rectangle</code> does not.</p>
<p>Often, the "default" behavior just works. But it won't work for you, because you're not actually using an instance attribute for <code>Point</code>; instead, you're relying on the class attribute providing a default value. Which works great for immutable values like <code>0.0</code>, but not so much for mutable values like <code>Point()</code>.</p>
<p>So that <code>copy.deepcopy(self)</code> returns a new <code>Rectangle</code> with the same <code>corner</code>:</p>
<pre><code>&gt;&gt;&gt; box1 = Rectangle
&gt;&gt;&gt; box1
&lt;__main__.Rectangle at 0x155c9e5c0&gt;
&gt;&gt;&gt; box1.corner
&lt;__main__.Point at 0x155c9e5f8&gt;
&gt;&gt;&gt; box2 = copy.deepcopy(box1)
&gt;&gt;&gt; box2
&lt;__main__.Rectangle at 0x155c670f0&gt;
&gt;&gt;&gt; box2.corner
&lt;__main__.Point at 0x155c9e5f8&gt;
&gt;&gt;&gt; box2 is box1
False
&gt;&gt;&gt; box2.corner is box1.corner
True
</code></pre>
<p>So, you have two choices:</p>
<ul>
<li>Implement the copy or pickle protocol, as described in the <code>copy</code> docs.</li>
<li>Don't use <code>deepcopy</code>, just do it manually.</li>
</ul>
<p>The second one is simpler:</p>
<pre><code>def move_rectangle(rect, dx, dy):
    new_rect = Rectangle()
    new_rect.corner = Point()
    new_rect.corner.x = rect.corner.x + dx
    new_rect.corner.y = rect.corner.y + dy
    return new_rect
</code></pre>
<hr/>
<p>While we're at it, you're doing some odd things with classes here.</p>
<p>First, naming the <code>self</code> parameter something other than <code>self</code>, like <code>rect</code>, violates a pretty major idiom. Anyone familiar with Python will do a double-take, start reading the code, and then do another double-take before they even get to parsing out what your code does.</p>
<p>Second, for types like this, you usually want to be able to pass values in to the constructor, like this:</p>
<pre><code>class Point:
    def __init__(self, x=0.0, y=0.0):
        self.x, self.y = x, y
</code></pre>
<p>If you design things that way, your <code>move_rectangle</code> method becomes a lot simpler:</p>
<pre><code>def move_rectangle(self, dx, dy):
    return Rectangle(Point(self.corner.x+dx, self.corner.y+dy))
</code></pre>
<p>Finally, you have a method named <code>grow_rectangle</code> that grows <code>self</code> in-place, but another one named <code>move_rectangle</code> that leaves <code>self</code> alone and instead returns a different rectangle. That's confusing; there's no obvious reason to anyone reading those names that one should mutate and the other copy.</p>
<p>In Python 3.7, it might be even nicer to use the new <code>dataclass</code> feature. 3.7 is still in beta right now, but you can get similar functionality with the third-party <code>attrs</code> library, or, if you want these objects to be immutable after construction, by just using <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>.</p>
</div>
<span class="comment-copy">What do you mean when you say "You don't even use the same variable name between methods"?</span>
<span class="comment-copy">@PaulRooney: (1) No matter how you call the first parameter of a method, it is set to the instance; <code>self</code> is but a convention. (2) <code>@staticmethod</code> is an antipattern.</span>
<span class="comment-copy">Also, I tried what you suggested with using "self" (I don't know how to "code up" text like you did when you edited my question) and it totally messed up my "move_rectangle(...)" method --&gt; TypeError: move_rectangle() missing 1 required positional argument: 'dy'</span>
<span class="comment-copy">@9000 of course its a convention and a overwhelmingly common one. <code>@staticmethod</code> an anti pattern. I haven't heard that before and would be interested to know the justification for such a claim.</span>
<span class="comment-copy">@PaulRooney Most uses of <code>@staticmethod</code> (especially in code by novices, and even more especially in code by people coming from languages like Java) should just be plain functions in the module. There are some good uses for it (e.g., the default value for a <code>callback</code> instance attribute), but if you know what those uses are, you don't need to worry about what's an antipattern in the general case anymore.</span>
<span class="comment-copy">I see your point about using self. But I was referring directly to what I was instructed to type from a textbook called "Think Python: How to think like a computer scientist" (page 150)</span>
<span class="comment-copy">Full disclosure: beginner programmer. I am still new to all of the programming jargon/ nomenclature.</span>
<span class="comment-copy">@BrandonDusch Seriously, the textbook encourages you to use names like <code>rect</code> instead of <code>self</code> for the self parameter? That's already a good enough reason not to recommend this book to anyone. And if it's also encouraging you to use mutable class attributes as default values and then teaching you to use <code>copy</code> (unless that's very late in the course and it's time to learn the pickle protocol), that's an even <i>better</i> reason.</span>
<span class="comment-copy">This was from a class I took called "Programming Fundamentals". That might not help my case, but I think the point of the class was to just get the student to dip their toe in the world of programming through the Python language. I'm sure that as I progress through subsequent courses, I and other students will be taught best practices such as the point you were making.</span>
