<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/48688494/python-string-search-regardless-of-character-sequence">Python String Search Regardless Of Character Sequence</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I'm aware of subsets and how they can find if a list matches with another list but I've realised that my code doesn't account for repeating letters.</p>
<pre><code>word = ["b", "e", "e"]
given_letters = ["b", "e", "p", "w"]

if set(word).issubset(given_letters): 
    print("Within the given letters' limits.")
</code></pre>
<p>This would print out the sentence I placed but I don't want it to because it's not an exact match.</p>
<p>Basically, I want it to accept ['b', 'e'] because it matches the number of times 'e' appeared but reject ['b', 'e', 'e'] because that list contains one more 'e' than there is in 'given_letters'.</p>
<p>Anyone have any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest approach with <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a></p>
<pre><code>from collections import Counter

def is_sublist(check_list, base_list):
    base_list_counter = Counter(base_list)
    check_list_counter = Counter(check_list)
    for letter, occurances in check_list_counter.items():
        if occurances &gt; base_list_counter[letter]:
            return False
    return True

assert not is_sublist(["b", "e", "e"], ["b", "e", "p", "w"])
assert is_sublist(["b", "e", "e"], ["b", "e", "e", "p", "w"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should help.</p>
<pre><code>word = ["b", "e", "e"]
given_letters = ["b", "e", "p", "w"]

def check(given_letters, word):
    for i in set(given_letters):
        if i in word:
            if given_letters.count(i) != word.count(i):      #Check if element count is greater than 1. 
                return False
    return True

print(check(given_letters, word))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I get your question right and you are looking for one-liner :</p>
<pre><code>word = ["b", "e", "e"]
given_letters = ["b", "e", "p", "e","w"]
if(all(True if word.count(item) &lt;= given_letters.count(item) else False for item in word)):
    print("Within the given letters' limits.")
else:
    print ("Whatever you want")
</code></pre>
</div>
<span class="comment-copy">When you turn a <b>list</b> into a <b>set</b>, you lose any duplicates.</span>
<span class="comment-copy">And sure it fails when <code>given_letters = ["b", "e", "e", "p", "w"]</code></span>
<span class="comment-copy">@vishes_shell. Thanks updated snippet.</span>
<span class="comment-copy">Why <code>if i in word:</code>? This will result in false positives</span>
<span class="comment-copy">Yuck, an O(n^2) solution. Should be using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> instead of <code>.count()</code>.</span>
<span class="comment-copy"><code>True if word.count(item) &lt;= given_letters.count(item) else False</code> is the same thing as just <code>word.count(item) &lt;= given_letters.count(item)</code> :/</span>
