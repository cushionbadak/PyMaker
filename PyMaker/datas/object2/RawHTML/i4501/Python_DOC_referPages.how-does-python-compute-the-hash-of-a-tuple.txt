<div class="post-text" itemprop="text">
<p>In python, if I have a tuple with many elements, is its hash calculated from its elements' <code>id</code>s or its elements' content? </p>
<p>In this example,</p>
<pre><code>a = (1, [1,2])
hash(a)
</code></pre>
<p>It errors out saying list is unhashable. So I guess it's not computed by id, or probably there is a check on whether the element is mutable.</p>
<p>Now see this example</p>
<pre><code>class A: pass
a0 = A()
ta = (1, a0)
hash(ta)  # -1122968024
a0.x = 20
hash(ta)  # -1122968024
</code></pre>
<p>Here it turns out the hash of <code>ta</code> does not change with the modification of its element, i.e., <code>a0</code>. So maybe <code>a0</code>'s id is used for the hash calculation? Is <code>a0</code> somehow considered as immutable? How does python know if a type is mutable?</p>
<p>Now consider this case</p>
<pre><code>b = (1, 2)
id(b)  # 3980742764
c = (1, 2)
id(c)  # 3980732588
tb = (1, b)
tc = (1, c) 
hash(tb)  # -1383040070
hash(tc)  # -1383040070
</code></pre>
<p>It seems the content of <code>b</code> and <code>c</code> are used for the hash calculation.</p>
<p>How should I understand these examples?</p>
</div>
<div class="post-text" itemprop="text">
<p>Neither. It is calculated on the basis of the hashes of these elements, not their "contents" (values/attributes).</p>
<p>Take a look at this paragraph in <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow noreferrer">python's documentation glossary</a>. </p>
<p>Whether something <em>is</em> hashable or not, and <em>how</em> it is hashed, depends on the implementation of its <code>.__hash__()</code> method. Python itself has no idea about mutability of an object.</p>
<p>In your first example, <code>tuple</code> happens to hash itself on the basis of its elements, while a <code>list</code> doesn't have a hash at all - the <code>.__hash__()</code> method is not implemented for it (and for a good reason). That's why a <code>tuple</code> with a <code>list</code> object inside of it is not hashable.</p>
<p>Now, having that in mind, let's have a look at <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">python data model documentation</a>, and what it has to say on the topic:</p>
<blockquote>
<p>User-defined classes have <code>__eq__()</code> and <code>__hash__()</code> methods by default; with them, all objects compare unequal (except with themselves) and <code>x.__hash__()</code> returns an appropriate value such that <code>x == y</code> implies both that <code>x is y</code> and <code>hash(x) == hash(y)</code>.</p>
</blockquote>
<p>That's why you don't have to define <code>.__hash__()</code> for your classes - python does it for you in this case. The default implementation doesn't take instance fields into account though. That's why you can change the values inside your object without changing its hash.</p>
<p>In this regard you're right - the default (<em>CPython's</em>) implementation of the hashing function for custom classes relies on the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id()</code></a> of an object, and not on the values inside of it. It is an implementation detail, and it differs between Python versions though. In more recent versions of Python the relation between <code>hash()</code> and <code>id()</code> involves some randomization.</p>
<hr/>
<h2>But how does it actually hash itself?</h2>
<p>While the details are quite complicated and probably involve some advanced math, the implementation of the hash function for tuple objects is written in C, and can be seen <a href="https://github.com/python/cpython/blob/master/Objects/tupleobject.c#L348" rel="nofollow noreferrer">here</a> (see <code>static Py_hash_t tuplehash(PyTupleObject *v)</code>.</p>
<p>The calculation involves XORing a constant with the hashes of each of the tuple's elements. The line responsible for hashing of the elements is this one:</p>
<pre><code>y = PyObject_Hash(*p++);
</code></pre>
<hr/>
<p>So, to answer your original question: it does a bunch of XOR hokus-pocus with the <strong>hashes of each of its elements</strong>. Whether or not the contents of these elements are used depends on their specific hash functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>The core contract of hashing is that <strong>equal objects have equal hashes</strong>. In particular, hashing does not directly care about mutability or mutation; it only cares about <strong>mutation that affects equality comparisons</strong>.</p>
<hr/>
<p>Your first tuple is unhashable because mutating the nested list would change how the tuple behaves in equality comparisons.</p>
<p>Mutating <code>a0</code> in your second example doesn't affect the hash of the tuple because it doesn't affect equality comparisons. <code>a0</code> is still only equal to itself, and its hash is unchanged.</p>
<p><code>tb</code> and <code>tc</code> in your third example have equal hashes because they are equal tuples, regardless of whether their elements are the same objects.</p>
<hr/>
<p>This all means that tuples cannot (directly) use <code>id</code> for hashes. If they did, equal tuples with distinct but equal elements could hash differently, violating the contract of hashing. Without special-casing element types, the only things tuples can use to compute their own hashes are their elements' hashes, so tuples base their hashes on their elements' hashes.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer to the question "Is the tuple's hash calculated based on the identity or the value?" is: Neither.</p>
<p>The correct answer is that the tuple's hash is calculated from the elements' hashes. How <em>those</em> hashes are calculated is (more or less) irrelevant.</p>
<p>An easy way to prove this is to see what happens when you put a list into a tuple:</p>
<pre><code>&gt;&gt;&gt; hash( (1, 2) )
3713081631934410656
&gt;&gt;&gt; hash( (1, []) )
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<p>Because lists aren't hashable, a tuple containing a list isn't hashable either.</p>
<hr/>
<p>Let's take a closer look at this example you brought:</p>
<pre><code>class A: pass
a0 = A()
ta = (1, a0)
hash(ta)  # -1122968024
a0.x = 20
hash(ta)  # -1122968024
</code></pre>
<p>Why doesn't setting <code>a0.x = 20</code> affect the tuple's hash? Well, if we modify this code to output the hash of <code>a0</code>, you'll see that setting <code>a0.x = 20</code> has no effect on <code>a0</code>'s hash value:</p>
<pre><code>a0 = A()
print(hash(a0))  # -9223363274645980307
a0.x = 20
print(hash(a0))  # -9223363274645980307
</code></pre>
<p>The reason for this is that python implements a default hash function for you. From <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>User-defined classes have <code>__eq__()</code> and <code>__hash__()</code> methods by default;
  with them, all objects compare unequal (except with themselves) and
  <code>x.__hash__()</code> returns an appropriate value such that <code>x == y</code> implies
  both that <code>x is y</code> and <code>hash(x) == hash(y)</code>.</p>
</blockquote>
<p>The default hash function ignores the object's attributes and calculates the hash based on the object's id. No matter what changes you make to <code>a0</code>, its hash will always stay the same. (Though it is possible to define a custom hash function for instances of your <code>A</code> class by implementing a custom <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code></a> method.)</p>
<hr/>
<p>Addendum: The reason why lists aren't hashable is because they're mutable. From <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>If a class defines mutable objects and implements an <code>__eq__()</code> method,
  it should not implement <code>__hash__()</code>, since the implementation of
  hashable collections requires that a key’s hash value is immutable (if
  the object’s hash value changes, it will be in the wrong hash bucket).</p>
</blockquote>
<p>Lists fall into this category.</p>
</div>
<div class="post-text" itemprop="text">
<p>the hash of a <code>tuple</code> is based on the <em>contents</em>, not on the _id_s of the tuples. And the hashes are computed recursively: if one element isn't hashable (like a <code>list</code> element), then the tuple itself isn't hashable.</p>
<p>That's perfectly normal that if <code>a</code> and <code>b</code> are tuples and <code>a == b</code>, then <code>hash(a) == hash(b)</code> (if hashes can be computed of course), even if <code>a is not b</code>.</p>
<p>(on the contrary <code>hash(a) == hash(b)</code> doesn't mean that <code>a == b</code>)</p>
<p>The information conveyed by <code>is</code> is often not very useful, because of python object interning for example.</p>
</div>
