<div class="post-text" itemprop="text">
<p>There is a list:</p>
<pre><code>a = [("ax", 1), ("ec", 3), ("bk", 5)]
</code></pre>
<p>another list: </p>
<pre><code>b = ["ec", "ax", "bk"]
</code></pre>
<p>I want to sort <code>a</code> according to <code>b</code>:</p>
<pre><code>sort_it(a, b)

a = [("ec", 3), ("ax", 1), ("bk", 5)]
</code></pre>
<p>How to do this?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a.sort(key=lambda x: b.index(x[0]))
</code></pre>
<p>This sorts <code>a</code> in-place using the the index in <code>b</code> of the first element of each tuple from <code>a</code> as the values it sorts on.</p>
<p>Another, possibly cleaner, way of writing it would be:</p>
<pre><code>a.sort(key=lambda (x,y): b.index(x))
</code></pre>
<hr/>
<p>If you had large numbers of items, it might be more efficient to do things a bit differently, because <code>.index()</code> can be an expensive operation on a long list, and you don't actually need to do a full sorting since you already know the order:</p>
<pre><code>mapping = dict(a)
a[:] = [(x,mapping[x]) for x in b]
</code></pre>
<p>Note that this will only work for a list of 2-tuples. If you want it to work for arbitrary-length tuples, you'd need to modify it slightly:</p>
<pre><code>mapping = dict((x[0], x[1:]) for x in a)
a[:] = [(x,) + mapping[x] for x in b]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another posibility is to sort <code>a</code>, sort the indices of <code>b</code> according to <code>b</code> and than sort the <code>a</code> according to the indices</p>
<pre><code>a.sort(key=lambda x: x[0])
ind = [i[0] for i in sorted(enumerate(b),key=lambda x: x[1])]
a = [i[0] for i in sorted(zip(a,ind),key=lambda x: x[1])]
</code></pre>
<p>since every sorting takes n*log(n) this is still scalable for bigger lists</p>
</div>
<div class="post-text" itemprop="text">
<p>Traditional sorting may not be needed.</p>
<pre><code>[tup for lbl in b for tup in a if tup[0] == lbl]
# [('ec', 3), ('ax', 1), ('bk', 5)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's actually a way to do this in linear O(n) time, because this isn't really a sorting operation. The existence of the list <code>b</code> means that the sorting is already done; all we really need to do is to rearrange the elements of <code>a</code> to be in the same order. This can be done efficiently thanks to dictionaries.</p>
<pre><code>from collections import defaultdict

def sorted_by(seq_to_sort, desired_order, key=None):
    if key is None:
        key = lambda x: x

    # group the elements by their key
    grouped_items = defaultdict(list)
    for item in seq_to_sort:
        k = key(item)
        grouped_items[k].append(item)

    # flatten the dict of groups to a list
    return [item for key in desired_order for item in grouped_items[key]]
</code></pre>
<p>Usage:</p>
<pre><code>a = [("ax", 1), ("ec", 3), ("bk", 5)]
b = ["ec", "ax", "bk"]
result = sorted_by(a, b, lambda tup: tup[0])
print(result)  # output: [("ec", 3), ("ax", 1), ("bk", 5)]
</code></pre>
<p>Notes:</p>
<ul>
<li><p>This is a stable sort; if two list items have the same key, their order will be preserved. Example:</p>
<pre><code>&gt;&gt;&gt; sorted_by([1, 2, 3], [5], key=lambda x: 5)
[1, 2, 3]
</code></pre></li>
<li><p>If any list elements are mapped to keys that don't exist in <code>desired_order</code>, those elements are silently discarded. For example:</p>
<pre><code>&gt;&gt;&gt; sorted_by([1, 2, 3], [1, 2, 3], key=lambda x: 5)
[]
</code></pre></li>
</ul>
<p>See also:</p>
<ul>
<li><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a></li>
</ul>
</div>
<span class="comment-copy">@jpp this is in fact <i>not</i> a duplicate of <a href="https://stackoverflow.com/q/6618515/519015">stackoverflow.com/q/6618515/519015</a>.  This question is about aligning the ordering of one list with that of another, whereas the other question is about using the values of the second list as the sort key for the first.  Try the solution given there and you will see that it does not produce the desired result.  Likewise if you try to apply the accepted solution here to the case there you will get a <code>ValueError</code>.</span>
<span class="comment-copy">@AryehLeibTaurog, I appreciate the sentiment, so I have opened it up again. In my mind, they are both adaptations of each other. If one solution is understood, the other is obvious. What we don't want to go down is the road we have a separate solution for len-2 tuples, len-3 tuples, len-4 tuples, etc.</span>
<span class="comment-copy">I get this :( <code>TypeError: unhashable type: 'list'</code></span>
<span class="comment-copy">I don't like this answer because it's very specialized for the purpose of sorting tuples by their first element, and it's not at all obvious how to generalize this solution to work in other scenarios. The arbitrary-length tuple sorting code also makes an assumption that each tuple has a unique first element; if any 2 tuples have the same 1st element, one of the tuples is silently discarded.</span>
<span class="comment-copy">Python's for loop is a bad way to sort things</span>
<span class="comment-copy">This is bad due to 2 for loops. For loops are bad in Python. It's better to use lambda functions</span>
<span class="comment-copy">"Bad" may not be true.  In general, nested loops <i>may</i> have O(n^2) time complexity, but list comprehensions are efficient in Python, especially with such small inputs as with the OP.  In this case, "<a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Explicit is better than implicit</a>."  Also, I think the creator of Python would disagree with your opinion on lambdas, as he has claimed <a href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">"... the lambda is slower than the list comprehension"</a>.</span>
