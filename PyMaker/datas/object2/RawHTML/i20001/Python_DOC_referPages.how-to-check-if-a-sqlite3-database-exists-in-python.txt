<div class="post-text" itemprop="text">
<p>I am trying to create a function in Python 2.7.3 to open a SQLite database.<br/> </p>
<p>This is my code at the moment:</p>
<pre><code>import sqlite3 as lite
import sys

db = r'someDb.sqlite'

def opendb(db):
    try:
        conn = lite.connect(db)
    except sqlite3.Error:
        print "Error open db.\n"
        return False
    cur = conn.cursor()
    return [conn, cur]
</code></pre>
<p>I have tried the code above and I have observed that the <code>sqlite3</code> library opens the database declared if exists, or creates a new database if this one doesn't exist. </p>
<p>Is there a way to check if the database exists with <code>sqlite3</code> methods or I have to use file operation like <code>os.path.isfile(path)</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, you'll have to explicitly test for the existence using <a href="http://docs.python.org/library/os.path.html#os.path.isfile" rel="noreferrer"><code>os.path.isfile</code></a>:</p>
<pre><code>if os.path.isfile(db):
</code></pre>
<p>There is no way to force the <code>sqlite3.connect</code> function to not create the file for you.</p>
<hr/>
<p>For those that are using Python 3.4 or newer, you can use the newer URI path feature to set a different mode when opening a database. The <code>sqlite3.connect()</code> function by default will open databases in <code>rwc</code>, that is <em>Read, Write &amp; Create</em> mode, so connecting to a non-existing database will cause it to be created.</p>
<p>Using a URI, you can specify a different mode instead; if you set it to <code>rw</code>, so <em>Read &amp; Write</em> mode, an exception is raised when trying to connect to a non-existing database. You can set different modes when you set the <code>uri=True</code> flag when connecting and pass in a <code>file:</code> URI, and add a <code>mode=rw</code> query parameter to the path:</p>
<pre><code>from urllib.request import pathname2url

try:
    dburi = 'file:{}?mode=rw'.format(pathname2url(db))
    conn = lite.connect(dburi, uri=True)
except sqlite3.OperationalError:
    # handle missing database case
</code></pre>
<p>See the <a href="https://www.sqlite.org/uri.html#recognized_query_parameters" rel="noreferrer">SQLite URI <em>Recognized Query Parameters</em> documentation</a> for more details on what parameters are accepted.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>os.path.isfile()</code> is just telling you if a file exists, not if it exists AND is a SQLite3 database! Knowing <a href="http://www.sqlite.org/fileformat.html" rel="noreferrer">http://www.sqlite.org/fileformat.html</a>, you could do this :</p>
<pre><code>def isSQLite3(filename):
    from os.path import isfile, getsize

    if not isfile(filename):
        return False
    if getsize(filename) &lt; 100: # SQLite database file header is 100 bytes
        return False

    with open(filename, 'rb') as fd:
        header = fd.read(100)

    return header[:16] == 'SQLite format 3\x00'
</code></pre>
<p>and subsequently use it like :</p>
<pre><code>for file in files:
    if isSQLite3(file):
        print "'%s' is a SQLite3 database file" % file
    else:
        print "'%s' is not a SQLite3 database file" % file
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there is a way to do what you want with Python 3.4+.</p>
<p>Use the <code>sqlite3.connect()</code> function to connect, but pass it a URI instead of a file path, and add <code>mode=rw</code> to its query string.</p>
<p>Here is a complete working code example:</p>
<pre class="lang-py prettyprint-override"><code>import sqlite3
con = sqlite3.connect('file:aaa.db?mode=rw', uri=True)
</code></pre>
<p>This will open an existing database from a file named <code>aaa.db</code> in the current folder, but will raise an error in case that file can not be opened or does not exist:</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "aaa.py", line 2, in &lt;module&gt;
    con = sqlite3.connect('file:aaa.db?mode=rw', uri=True)
sqlite3.OperationalError: unable to open database file
</code></pre>
<p>Python <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.connect" rel="nofollow noreferrer">sqlite.connect() docs</a> state that:</p>
<blockquote>
<p>If uri is true, database is interpreted as a URI. This allows you to specify options. For example, to open a database in read-only mode you can use:</p>
<p>db = sqlite3.connect('file:path/to/database?mode=ro', uri=True)</p>
<p>More information about this feature, including a list of recognized options, can be found in the <a href="https://www.sqlite.org/uri.html" rel="nofollow noreferrer">SQLite URI documentation</a>.</p>
</blockquote>
<p>Here's an excerpt of all the relevant URI option information collected from <a href="http://www.sqlite.org/c3ref/open.html" rel="nofollow noreferrer">http://www.sqlite.org/c3ref/open.html</a>:</p>
<blockquote>
<p><strong>mode</strong>: The mode parameter may be set to either "ro", "rw", "rwc", or "memory". Attempting to set it to any other value is an error. If "ro" is specified, then the database is opened for read-only access, just as if the SQLITE_OPEN_READONLY flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to "rw", then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value "rwc" is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to "memory" then a pure in-memory database that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().</p>
<p>The <strong>sqlite3_open_v2()</strong> interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the SQLITE_OPEN_NOMUTEX, SQLITE_OPEN_FULLMUTEX, SQLITE_OPEN_SHAREDCACHE, SQLITE_OPEN_PRIVATECACHE, and/or SQLITE_OPEN_URI flags:</p>
<p>SQLITE_OPEN_READONLY
     The database is opened in read-only mode. If the database does not already exist, an error is returned.</p>
<p>SQLITE_OPEN_READWRITE
     The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</p>
<p>SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
     The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().</p>
</blockquote>
<p>For convenience, here's also a Python 3.4+ function for converting a regular path to an URI usable by sqlite.connect():</p>
<pre class="lang-py prettyprint-override"><code>import pathlib
import urllib.parse

def _path_to_uri(path):
    path = pathlib.Path(path)
    if path.is_absolute():
        return path.as_uri()
    return 'file:' + urllib.parse.quote(path.as_posix(), safe=':/')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a fork (using Python 3) based on <strong>Tom Horen's answer</strong>, which presents a solution more complete and reliable that the elected answer. </p>
<p>The elected answer, does not evaluate any content, header, etc., in order to determine whether the file actually contains any data related to a SQLite3 database or not.</p>
<p>I tried to present something more pragmatic here:</p>
<pre><code>#!/usr/bin/python3

import os
import sys

if os.path.isfile('test.sqlite3'):
    if os.path.getsize('test.sqlite3') &gt; 100:
        with open('test.sqlite3','r', encoding = "ISO-8859-1") as f:
            header = f.read(100)
            if header.startswith('SQLite format 3'):
                print("SQLite3 database has been detected.")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am using a function like the following at the beginning of my script so that I can try and figure out why a sqlite3 db script might not be working. Like the comments say, it uses 3 phases, checks if a path exist, checks if the path is a file, checks if that file's header is a sqlite3 header. </p>
<pre><code>def checkdbFileforErrors():

    #check if path exists
    try:
        with open('/path/to/your.db'): pass
    except IOError:
        return 1

    #check if path if a file
    if not isfile('/path/to/your.db'):
        return 2

    #check if first 100 bytes of path identifies itself as sqlite3 in header
    f = open('/path/to/your.db', "rx")
    ima = f.read(16).encode('hex')
    f.close()
    #see http://www.sqlite.org/fileformat.html#database_header magic header string
    if ima != "53514c69746520666f726d6174203300": 
        return 3

    return 0
</code></pre>
</div>
<span class="comment-copy">There is apparently a way to test the file to check whether it is a SQLite file prior to using <code>sqlite3.connect</code>.  See @Tom-Horen's response.</span>
<span class="comment-copy">@Nate: sure; testing for the file content with a header check is a fine approach. :-) I was focusing on the original question: <i>Is there a way to check if the database exists with sqlite3 methods</i>, which there is not.</span>
<span class="comment-copy">@JurkoGospodnetiÄ‡: I must note that the question is tagged with <code>python-2.7</code>, so the URI option is <i>not available there</i>.</span>
<span class="comment-copy">@MartijnPieters - true, I did not notice that when I originally ran into this question</span>
<span class="comment-copy">For Python 3, make sure you compare against bytes: <code>Header[0:16] == b'SQLite format 3\000'</code> (note the leading <code>b</code> for the format string</span>
<span class="comment-copy">Not sure what's the added value here. The only case which cannot be tested against is whether the file exists prior to the connect. If the file exists <i>and</i> an exception is thrown from the connect, I also know if the DB is valid. The existence of the magic string still doesn't say that connect will succeed. So what's the purpose of this?</span>
<span class="comment-copy">This one should be the answer, for sure. Filename or extension means nothing (specially on SQLite). Validation of database header is the most safety technique that you can apply for this case.</span>
<span class="comment-copy">OP: Python 2.7.3 not Python 3.x</span>
<span class="comment-copy">@Nick - true, as mentioned in some earlier comments above, I did not notice that when I originally ran into this question  Still, the information I posted here I did find very good use for several times since then :-)</span>
<span class="comment-copy">That should read  if ima == '53514c69746520666f726d6174203300':          return 3</span>
<span class="comment-copy">This design of returning numbers for each error or 0 for success is more C style than Python. Python is more about throwing exceptions.</span>
