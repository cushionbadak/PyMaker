<div class="post-text" itemprop="text">
<p>The following works beautifully in Python:</p>
<pre><code>def f(x,y,z): return [x,y,z]

a=[1,2]

f(3,*a)
</code></pre>
<p>The elements of <code>a</code> get unpacked as if you had called it like <code>f(3,1,2)</code> and it returns <code>[3,1,2]</code>. Wonderful!</p>
<p>But I can't unpack the elements of <code>a</code> into the <em>first</em> two arguments:</p>
<pre><code>f(*a,3)
</code></pre>
<p>Instead of calling that like <code>f(1,2,3)</code>, I get "SyntaxError: only named arguments may follow *expression".</p>
<p>I'm just wondering why it has to be that way and if there's any clever trick I might not be aware of for unpacking arrays into arbitrary parts of argument lists without resorting to temporary variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Raymond Hettinger's answer points out, this <s>may change</s> has changed in Python 3 and <a href="http://www.python.org/dev/peps/pep-3132/" rel="noreferrer">here is a related proposal</a>, which has been accepted.
Especially related to the current question, here's one of the possible changes to that proposal that was discussed:</p>
<blockquote>
<p>Only allow a starred expression as the last item in the exprlist. This would simplify the 
  unpacking code a bit and allow for the starred expression to be assigned an iterator. This 
  behavior was rejected because it would be too surprising.</p>
</blockquote>
<p>So there are implementation reasons for the restriction with unpacking function arguments but it is indeed a little surprising!</p>
<p>In the meantime, here's the workaround I was looking for, kind of obvious in retrospect:</p>
<pre><code>f(*(a+[3]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't <em>have to</em> be that way.  It was just rule that Guido found to be sensible.</p>
<p>In Python 3, the rules for unpacking have been liberalized somewhat:</p>
<pre><code>&gt;&gt;&gt; a, *b, c = range(10)
&gt;&gt;&gt; a
0
&gt;&gt;&gt; b
[1, 2, 3, 4, 5, 6, 7, 8]
&gt;&gt;&gt; c
9
</code></pre>
<p>Depending on whether Guido feels it would improve the language, that liberalization could also be extended to function arguments. </p>
<p>See the discussion on <a href="http://www.python.org/dev/peps/pep-3132/" rel="noreferrer">extended iterable unpacking</a> for some thoughts on why Python 3 changed the rules.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to the <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP 448 - Additional Unpacking Generalizations</a>,</p>
<pre><code>f(*a, 3)
</code></pre>
<p>is <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations" rel="noreferrer">now accepted syntax starting from Python 3.5</a>. Likewise you can use the double-star <code>**</code> for keyword argument unpacking anywhere and either one can be used multiple times.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>f</code> is expecting 3 arguments (<code>x</code>, <code>y</code>, <code>z</code>, in that order).</p>
<p>Suppose <code>L = [1,2]</code>. When you call <code>f(3, *L)</code>, what python does behind the scenes, is to call <code>f(3, 1, 2)</code>, without really knowing the length of <code>L</code>.</p>
<p>So what happens if <code>L</code> was instead <code>[1,2,3]</code>?</p>
<p>Then, when  you call <code>f(3, *L)</code>, you'll end up calling <code>f(3,1,2,3)</code>, which will be an error because <code>f</code> is expecting exactly 3 arguments and you gave it 4.</p>
<p>Now, suppose <code>L=[1,2]1. Look at what happens when you call</code>f`:</p>
<pre><code>&gt;&gt;&gt; f(3,*L) # works fine
&gt;&gt;&gt; f(*L) # will give you an error when f(1,2) is called; insufficient arguments
</code></pre>
<p>Now, you implicitly know when you call <code>f(*L, 3)</code> that 3 will be assigned to <code>z</code>, but python doesn't know that. It only knows that the last <code>j</code> many elements of the input to <code>f</code> will be defined by the contents of <code>L</code>. But since it doesn't know the value of <code>len(L)</code>, it can't make assumptions about whether <code>f(*L,3)</code> would have the correct number of arguments.</p>
<p>This however, is not the case with <code>f(3,*L)</code>. In this case, python knows that all the arguments EXCEPT the first one will be defined by the contents of <code>L</code>.</p>
<p>But if you have named arguments <code>f(x=1, y=2, z=3)</code>, then the arguments being assigned to by name will be bound first. Only then are the positional arguments bound. So you do <code>f(*L, z=3)</code>. In that case, <code>z</code> is bound to <code>3</code> first, and then, the other values get bound. </p>
<p>Now interestingly, if you did <code>f(*L, y=3)</code>, that would give you an error for trying to assign to <code>y</code> twice (once with the keyword, once again with the positional)</p>
<p>Hope this helps</p>
</div>
<div class="post-text" itemprop="text">
<p>Nice. This also works for tuples. Don't forget the comma:</p>
<pre><code>a = (1,2)
f(*(a+(3,)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>f(*a, z=3)</code> if you use <code>f(*a, 3)</code>, it do not know how to unpack the parameter for you provided 2 parameters and 2 is the second.</p>
</div>
<span class="comment-copy"><code>f(*a, 3)</code> now works in Python 3.5</span>
<span class="comment-copy">And if <code>a</code> is tuple: <code>f(*(a+(3,)))</code></span>
<span class="comment-copy">Interesting! Thanks! I didn't mean to phrase it as "have to" but was curious about the rationale. Sounds like it may have been rather arbitrary. As for a workaround, looks like <code>apply(f, a+[3])</code> would do it, though I see that apply() is deprecated.</span>
<span class="comment-copy">Thanks again for the elucidating answer. See also my answer for more about this, and the workaround I was looking for.</span>
<span class="comment-copy">I think I may disagree with this, in particular the "python doesn't know that" part. As Raymond Hettinger says, it seems to be an arbitrary restriction. I could imagine an efficiency argument against the liberalization though.</span>
<span class="comment-copy">Possible. I've shared this question on G+, tagged to Guido. Let's see if he says something</span>
<span class="comment-copy">That's a dirty trick!</span>
<span class="comment-copy">I don't understand why this was downvoted, it's a very good answer for python 2. More readable than the *(a+(b,)) trick</span>
