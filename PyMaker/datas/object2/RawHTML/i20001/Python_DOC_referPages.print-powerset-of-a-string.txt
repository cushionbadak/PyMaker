<div class="post-text" itemprop="text">
<p>I'm trying to write python code to print the <a href="/tags/powerset/info">powerset</a> of a string, but am running into some bugs. Here's what I've got:</p>
<pre><code>def getperm (string):
    perm = []
    if len(string) == 0:
        perm.append("")
        return perm
    #if len(string) == 1:
    #   perm.append(string)
    #   perm.append("")
    first = string[0]
    print "first = " + str(first)
    rem = string[1:len(string)]
    print "rem = " + str(rem)
    words = getperm(rem)
    for word in words:
        for i in range(len(word)):
            temp = string[0:i] + first + string[i:len(string)]
            print "temp = " + str(temp)
            perm.append(temp)

    return perm

if __name__=="__main__":
    a = "ab"
    mag  = getperm(a)
    print mag
</code></pre>
<p>My expected output would be:</p>
<pre><code>['', 'a', 'b', 'ab']
</code></pre>
<p>My actual output is:</p>
<pre><code>[]
</code></pre>
<p>Can anyone help me figure out what's going on? Is this some nuance of python, or is there a bug in my code? I think my code should be ok -- I'm going off the fifth edition of Cracking the coding interview</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You're overthinking it</p>
<p>This part is trying to do too much</p>
<pre><code>for word in words:
    for i in range(len(word)):
        temp = string[0:i] + first + string[i:len(string)]
        print "temp = " + str(temp)
        perm.append(temp)
</code></pre>
<p>See how simple it really should be</p>
<pre><code>def get_powerset (string):
    perm = []
    if len(string) == 0:
        perm.append("")
        return perm
    #if len(string) == 1:
    #   perm.append(string)
    #   perm.append("")
    first = string[0]
    print "first = " + str(first)
    rem = string[1:len(string)]
    print "rem = " + str(rem)
    words = get_powerset(rem)
    perm.extend(words)
    for word in words:
        perm.append(first+word)

    return perm

if __name__=="__main__":
    a = "ab"
    mag  = get_powerset(a)
    print mag
</code></pre>
<p>Now you should be able to make the code look a lot nicer with a little refactoring</p>
</div>
<div class="post-text" itemprop="text">
<p>Is this what you want?</p>
<pre><code>import itertools as it

def func(s):
    for i in range(len(s)+1):
        for combo in it.combinations(s,i):
            yield "".join(combo)

print list(func("abc"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a method for permutations:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; chars = "ABCD"
&gt;&gt;&gt; perms = list(itertools.permutations(chars))
&gt;&gt;&gt; print(perms)
[('A', 'B', 'C'),
 ('A', 'C', 'B'),
 ('B', 'A', 'C'),
 ('B', 'C', 'A'),
 ('C', 'A', 'B'),
 ('C', 'B', 'A')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a refactored iterative solution <strong>without</strong> the <code>itertools</code> module:</p>
<pre><code>def powerset(s):
    a = ['']
    for i,c in enumerate(s):
        for k in range(2**i):
            a.append(a[k]+c)
    return a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried tracing through what your algorithm actually does?</p>
<pre><code>getperm('ab'):
  first, rem = 'a', 'b'
  words = getperm('b')
    first, rem = 'b', ''
    words = getperm('')
    words = ['']
    for word in words:
      for i in range(len(word)):
        pass # only called on '', so doesn't matter
    return []
  words = []
  for word in words:
    pass # only called on [], so doesn't matter
</code></pre>
<p>So, there's no nuance of Python here; your algorithm returns the empty list in O(N) steps, and you've coded that algorithm properly in Python.</p>
<p>(Instead of tracing it by hand, of course, you can add some more useful print statements and see what each step is actually doing.)</p>
<p>It probably wasn't the algorithm you wanted, but you'll need to tell us what you were <em>trying</em> to do. Are you, e.g., porting some pseudocode from Hoare into Python? If so, what's the pseudocode?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.powerset" rel="nofollow noreferrer"><code>powerset</code></a> from <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a>:</p>
<pre><code>&gt;&gt;&gt; import more_itertools

&gt;&gt;&gt; ["".join(p) for p in list(more_itertools.powerset("ab"))]
['', 'a', 'b', 'ab']
</code></pre>
<p>This <code>powerset</code> is a convenience function directly implemented from the <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipes</a>.</p>
</div>
<span class="comment-copy">You're looking to generate the power set, not permutations. The only permutations of the string <code>'ab'</code> are <code>'ab'</code> and <code>'ba'</code>.</span>
<span class="comment-copy">Also, you really shouldn't name a string <code>string</code> (that's the name of a built-in module), and I'm not sure what you're trying to accomplish by calling <code>str</code> on objects that are already strings (<code>first</code>, <code>rem</code>, etc.).</span>
<span class="comment-copy">@Matt Ball Yes -- good call. Even so, I'm not generating 'ab' or 'ba'. Do you know why?</span>
<span class="comment-copy">@abarnert Very true -- I renamed string to something different, and removed the redundant str() but am still receiving the errors. Any idea why?</span>
<span class="comment-copy">Well, obviously those weren't causing your problems; they were just making it harder to readâ€¦ Meanwhile, you should update the question with the edited version of the code.</span>
<span class="comment-copy">That did it! Thank you. What does extend do that my code wasn't doing?</span>
<span class="comment-copy">@mythander889, <code>.extend</code> just loads the result of the previous level into the current result.</span>
<span class="comment-copy">I tried running this code, it does not print the powers, it just prints all the alphabets of a string.</span>
<span class="comment-copy">@nakulchawla09, I'm not sure what you mean by "powers", but it is probably different to a powerset</span>
<span class="comment-copy">I am sorry for the typing mistake, I meant power set only. For this program I was somehow getting the output <code>[" ", "a", "b"]</code> , I was thinking on the terms of getting an output like <code>[" ", "a", "b", "ab", "ba"]</code></span>
<span class="comment-copy">I believe that would do it, but I'm looking to implement the solution using recursion. Thank you!</span>
<span class="comment-copy">was searching for combinations with replacement. Saw this, went to docs.. <code>combinations_with_replacement()</code> -- actually a method there! :')</span>
<span class="comment-copy">Is there a way to do what you do without using the package itertools?</span>
<span class="comment-copy">but he doesnt actually want permutations he wants the power set...</span>
<span class="comment-copy">How he can encode the algorithm with the wrong name in mind? Suspicious...</span>
