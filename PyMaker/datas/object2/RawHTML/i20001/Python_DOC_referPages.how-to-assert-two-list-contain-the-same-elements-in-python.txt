<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/7828867/how-to-efficiently-compare-two-unordered-lists-not-sets-in-python">How to efficiently compare two unordered lists (not sets) in Python?</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>When writing test cases, I often need to assert that two list contain the same elements without regard to their order.</p>
<p>I have been doing this by converting the lists to sets.</p>
<p>Is there any simpler way to do this?</p>
<p><strong>EDIT</strong>:</p>
<p>As @MarkDickinson pointed out, I can just use <a href="http://docs.python.org/library/unittest.html#unittest.TestCase.assertItemsEqual" rel="noreferrer">TestCase.assertItemsEqual</a>.</p>
<p>Notes that <code>TestCase.assertItemsEqual</code> is new in Python2.7.
If you are using an older version of Python, you can use <a href="http://pypi.python.org/pypi/unittest2" rel="noreferrer">unittest2</a> - a backport of new features of Python 2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Slightly faster version of the implementation (If you know that most couples lists will have different lengths):</p>
<pre><code>def checkEqual(L1, L2):
    return len(L1) == len(L2) and sorted(L1) == sorted(L2)
</code></pre>
<p>Comparing: </p>
<pre><code>&gt;&gt;&gt; timeit(lambda: sorting([1,2,3], [3,2,1]))
2.42745304107666
&gt;&gt;&gt; timeit(lambda: lensorting([1,2,3], [3,2,1]))
2.5644469261169434 # speed down not much (for large lists the difference tends to 0)

&gt;&gt;&gt; timeit(lambda: sorting([1,2,3], [3,2,1,0]))
2.4570400714874268
&gt;&gt;&gt; timeit(lambda: lensorting([1,2,3], [3,2,1,0]))
0.9596951007843018 # speed up
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.2 <code>unittest.TestCase.assertItemsEqual</code>(<a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertItemsEqual" rel="noreferrer">doc</a>) has been replaced by <code>unittest.TestCase.assertCountEqual</code>(<a href="https://docs.python.org/3.2/library/unittest.html#unittest.TestCase.assertCountEqual" rel="noreferrer">doc</a>) which does exactly what you are looking for, as you can read from the python <a href="https://docs.python.org/3.2/library/unittest.html" rel="noreferrer">standard library documentation</a>. The method is somewhat misleadingly named but it does exactly what you are looking for.</p>
<blockquote>
<p>a and b have the same elements in the same number, regardless of their order</p>
</blockquote>
<p>Here a simple example which compares two lists having the same elements but in a different order.</p>
<ul>
<li>using <code>assertCountEqual</code> the test will succeed</li>
<li>using <code>assertListEqual</code> the test will fail due to the order difference of the two lists</li>
</ul>
<p>Here a little example script.</p>
<pre><code>import unittest


class TestListElements(unittest.TestCase):
    def setUp(self):
        self.expected = ['foo', 'bar', 'baz']
        self.result = ['baz', 'foo', 'bar']

    def test_count_eq(self):
        """Will succeed"""
        self.assertCountEqual(self.result, self.expected)

    def test_list_eq(self):
        """Will fail"""
        self.assertListEqual(self.result, self.expected)

if __name__ == "__main__":
    unittest.main()
</code></pre>
<p><strong>Side Note :</strong> Please make sure that the elements in the lists you are comparing are sortable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Given</p>
<pre><code>l1 = [a,b]
l2 = [b,a]
</code></pre>
<p><a href="http://docs.python.org/3/library/unittest.html?highlight=assertcountequal#unittest.TestCase.assertCountEqual" rel="noreferrer">In Python <em>&gt;= 3.0</em></a></p>
<pre><code>assertCountEqual(l1, l2) # True
</code></pre>
<p><a href="http://docs.python.org/library/unittest.html?highlight=assertequal#unittest.TestCase.assertItemsEqual" rel="noreferrer">In Python <em>&gt;= 2.7</em></a>, the above function was named:</p>
<pre><code>assertItemsEqual(l1, l2) # True
</code></pre>
<p><a href="https://pypi.python.org/pypi/unittest2" rel="noreferrer">In Python <em>&lt; 2.7</em></a></p>
<pre><code>import unittest2
assertItemsEqual(l1, l2) # True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Converting your lists to sets will tell you that they contain the same elements. But this method cannot confirm that they contain the same number of all elements. For example, your method will fail in this case:</p>
<pre><code>L1 = [1,2,2,3]
L2 = [1,2,3,3]
</code></pre>
<p>You are likely better off sorting the two lists and comparing them:</p>
<pre><code>def checkEqual(L1, L2):
    if sorted(L1) == sorted(L2):
        print "the two lists are the same"
        return True
    else:
        print "the two lists are not the same"
        return False
</code></pre>
<p>Note that this does not alter the structure/contents of the two lists. Rather, the sorting creates two new lists</p>
</div>
<div class="post-text" itemprop="text">
<p>Needs <strong>ensure</strong> library but you can compare list by:</p>
<blockquote>
<p>ensure([1, 2]).contains_only([2, 1])</p>
</blockquote>
<p>This will not raise assert exception. Documentation of thin is really thin so i would recommend to look at <a href="https://github.com/kislyuk/ensure/blob/master/ensure/__init__.py" rel="nofollow">ensure's codes on github</a> </p>
</div>
<span class="comment-copy">Simpler than <code>set(x) == set(y)</code>?  How much simpler can you get?</span>
<span class="comment-copy">@cdhowie: This will fail when there are redundant elements in the lists.</span>
<span class="comment-copy">@inspectorG4dget It's not clear from the original question whether that should be a failure case or not.</span>
<span class="comment-copy">If you're unit testing, what's wrong with <code>TestCase.assertItemsEqual</code>?</span>
<span class="comment-copy">@MarkDickinson "without regard to their order".</span>
<span class="comment-copy">Your speedup comes from (1) no branching (valid), (2) a <code>len</code> check before sorting. The <code>len</code> check is O(n) and only helps in cases when it returns <code>False</code>. Else, it hurts the actual runtime (not complexity) by adding two linear passes (one on each of <code>L1</code> and <code>L2</code>). Thus while the runtime complexity is still O(nlogn) (from sorting), the O(n) will hurt the number of seconds it takes for this function to <code>return</code></span>
<span class="comment-copy">@inspectorG4dget, add comparison (without branching difference)</span>
<span class="comment-copy">This is exactly what I meant. Yours is actually a better solution if OP knows a priori that most of the pairs of lists that he compares will be of unequal length</span>
<span class="comment-copy">@inspectorG4dget: <code>len()</code> has O(1) complexity (constant time). There is no pass to get the value.</span>
<span class="comment-copy">This doesnâ€™t work if your list contains unorderable types like <code>dict</code>.</span>
<span class="comment-copy">Thanks. The original name was so much clearer, I had seen that method, but assumed it checked the count.</span>
<span class="comment-copy">Is there a way to compare to lists that are "almost equal"? In the sense that given an error, i want to assert the equal if the  difference btw the elements in the lists are within the error?</span>
<span class="comment-copy">Thanks. But <i>downright</i> misleading, I would have called it!</span>
<span class="comment-copy"><b>If there are only unique values in list</b> Converting them to set using set(l1)&amp; set(2) &amp; asserting using assertSetEqual(l1, l2) also helps.</span>
<span class="comment-copy">What is a proper name for this if I'm going to encapsulate it in a function?</span>
<span class="comment-copy">"abstract/encapsulate into a function". Answer edited to abstract my code into a function</span>
<span class="comment-copy">In my shop we use 'assertElementsEqual', makes sense to us.</span>
