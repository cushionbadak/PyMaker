<div class="post-text" itemprop="text">
<p>What is the specific code, in order, being executed when I ask for something like</p>
<pre><code>&gt;&gt;&gt; 1 &lt;= 3 &gt;= 2
True
</code></pre>
<p>If both have equal precedence and it's just the order of their evaluation, why does the second inequality function as <code>(3 &gt;= 2)</code> instead of <code>(True &gt;= 2)</code></p>
<p>Consider for example the difference between these</p>
<pre><code>&gt;&gt;&gt; (1 &lt; 3) &lt; 2
True

&gt;&gt;&gt; 1 &lt; 3 &lt; 2
False
</code></pre>
<p>Is it just a pure syntactical short-cut hard-coded into Python to expand the second as the <code>and</code> of the two statements?</p>
<p>Could I change this behavior for a class, such that <code>a &lt;= b &lt;= c</code> gets expanded to something different? It's looking like the following is the case</p>
<pre><code>a (logical operator) b (logical operator) c 
    --&gt; (a logical operator b) and (b logical operator c)
</code></pre>
<p>but the real question is how this gets implemented in code.</p>
<p>I'm curious so that I can replicate this kind of <code>__lt__</code> and <code>__gt__</code> behavior in some of my own classes, but I am confused about how this is accomplished holding the middle argument constant.</p>
<p>Here's a specific example:</p>
<pre><code>&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; tst = np.asarray([1,2,3,4,5,6])

&gt;&gt;&gt; 3 &lt;= tst
array([False, False,  True,  True,  True,  True], dtype=bool)

&gt;&gt;&gt; 3 &lt;= tst &lt;= 5
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
/home/ely/&lt;ipython-input-135-ac909818f2b1&gt; in &lt;module&gt;()
----&gt; 1 3 &lt;= tst &lt;= 5

ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<p>It would be nice to override this so that it "just works" with arrays too, like this:</p>
<pre><code>&gt;&gt;&gt; np.logical_and(3 &lt;= tst, tst &lt;= 5)
array([False, False,  True,  True,  True,  False], dtype=bool)
</code></pre>
<p><strong>Added for clarification</strong></p>
<p>In the comments it is indicated that I did a poor job of explaining the question. Here's some clarifying remarks:</p>
<p>1) I am <em>not</em> looking for a simple explanation of the fact that the interpreter pops an <code>and</code> in between the two chained inequalities. I already knew that and said so above.</p>
<p>2) For an analogy to what I want to do, consider the <code>with</code> statement (<a href="http://www.python.org/dev/peps/pep-0343/" rel="noreferrer">link</a>). The following:</p>
<pre><code>with MyClass(some_obj) as foo:
    do_stuff()
</code></pre>
<p>unpacks into </p>
<pre><code>foo = MyClass(some_obj)
foo.__enter__()
try:
    do_stuff()
finally:
    foo.__exit__()
</code></pre>
<p>So by writing <code>MyClass</code> appropriately, I can do many special things inside of the <code>with</code> statement.</p>
<p>I am asking whether there is a similar code unpacking of the chained inequality by which I can intercept what it's doing and redirect it to use array-style logical operators instead <em>just for the classes I care about</em>.</p>
<p>I feel this is very clear from my question, especially the example, but hopefully this makes it more clear.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not totally sure what you're looking for, but a quick disassembly shows that <code>a &lt; b &lt; c</code> is not compiled to the same bytecode as <code>a &lt; b and b &lt; c</code></p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt;
&gt;&gt;&gt; def f(a, b, c):
...     return a &lt; b &lt; c
...
&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_FAST                0 (a)
              3 LOAD_FAST                1 (b)
              6 DUP_TOP
              7 ROT_THREE
              8 COMPARE_OP               0 (&lt;)
             11 JUMP_IF_FALSE_OR_POP    21
             14 LOAD_FAST                2 (c)
             17 COMPARE_OP               0 (&lt;)
             20 RETURN_VALUE
        &gt;&gt;   21 ROT_TWO
             22 POP_TOP
             23 RETURN_VALUE
&gt;&gt;&gt;
&gt;&gt;&gt; def f(a, b, c):
...     return a &lt; b and b &lt; c
...
&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_FAST                0 (a)
              3 LOAD_FAST                1 (b)
              6 COMPARE_OP               0 (&lt;)
              9 JUMP_IF_FALSE_OR_POP    21
             12 LOAD_FAST                1 (b)
             15 LOAD_FAST                2 (c)
             18 COMPARE_OP               0 (&lt;)
        &gt;&gt;   21 RETURN_VALUE
</code></pre>
<p><strong>Edit 1:</strong> Digging further, I think this is something weird or wrong with numpy. Consider this example code, I think it works as you would expect.</p>
<pre><code>class Object(object):
    def __init__(self, values):
        self.values = values
    def __lt__(self, other):
        return [x &lt; other for x in self.values]
    def __gt__(self, other):
        return [x &gt; other for x in self.values]

x = Object([1, 2, 3])
print x &lt; 5 # [True, True, True]
print x &gt; 5 # [False, False, False]
print 0 &lt; x &lt; 5 # [True, True, True]
</code></pre>
<p><strong>Edit 2:</strong> Actually this doesn't work "properly"...</p>
<pre><code>print 1 &lt; x # [False, True, True]
print x &lt; 3 # [True, True, False]
print 1 &lt; x &lt; 3 # [True, True, False]
</code></pre>
<p>I think it's comparing boolean values to numbers in the second comparison of <code>1 &lt; x &lt; 3</code>.</p>
<p><strong>Edit 3:</strong> I don't like the idea of returning non-boolean values from the gt, lt, gte, lte special methods, but it's actually not restricted according to the Python documentation.</p>
<p><a href="http://docs.python.org/reference/datamodel.html#object.__lt__" rel="noreferrer">http://docs.python.org/reference/datamodel.html#object.<strong>lt</strong></a></p>
<blockquote>
<p>By convention, False and True are returned for a successful
  comparison. However, these methods can return any value...</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Both have the same precedence, but are evaluated from left-to-right according to the <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="nofollow">documentation</a>. An expression of the form <code>a &lt;= b &lt;= c</code> gets expanded to <code>a &lt;= b and b &lt;= c</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>but the real question is how this gets implemented in code.</p>
</blockquote>
<p>Do you mean <em>how the interpreter transforms it</em>, or what? You already said</p>
<pre><code>a (logical operator) b (logical operator) c 
    --&gt; (a logical operator b) and (b logical operator c)
</code></pre>
<p><strike>so I'm not sure what you're asking here</strike>
OK, I figured it out: no, you cannot override the expansion from <code>a &lt; b &lt; c</code> into <code>(a &lt; b) and (b &lt; c)</code> IIUC.</p>
<hr/>
<blockquote>
<p>I'm curious so that I can replicate this kind of <code>__lt__</code> and <code>__gt__</code> behavior in some of my own classes, but I am confused about how this is accomplished holding the middle argument constant.</p>
</blockquote>
<p>It depends which of <code>a</code>, <code>b</code> and <code>c</code> in the expression <code>a &lt; b &lt; c</code> are instances of your own class. Implementing your <code>__lt__</code> and <code>__gt__</code> and methods gets some of the way, but the <a href="http://docs.python.org/reference/datamodel.html#object.__lt__" rel="nofollow">documentation</a> points out that:</p>
<blockquote>
<p>There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does)</p>
</blockquote>
<p>So, if you want <code>Int &lt; MyClass &lt; Int</code>, you're out of luck. You need, at a minimum, <code>MyClass &lt; MyClass &lt; Something</code> (so an instance of your class is on the LHS of each comparison in the expanded expression).</p>
</div>
<span class="comment-copy">This is not quite what I am looking for, but it is helpful and closer to the right track than the other answers so far. Since it doesn't yield the same byte code, the question is what Python functions are being inserted to make up the call in the first case, and how I can override them.</span>
<span class="comment-copy">@EMS: See my edits...</span>
<span class="comment-copy">Yes, you appear to be correct. This is a NumPy bug. For example, if I do the following: <code>list((-1 &lt; vect)[:,0]) and list((vect &lt; 5)[:,0])</code> then it works. So the <code>and</code> is choking on the fact that it's two arguments are <code>numpy.ndarray</code> instead of <code>list</code>. This is very odd; it means that <code>__gt__</code> and <code>__lt__</code> must have some extra <code>ndarray</code> cruft in them.</span>
<span class="comment-copy">It does appear to have issues with getting the right True/False value though, but at least it's not choking on the array types. Lots more digging to do. I wonder if this has anything to do with <code>__and__</code>.</span>
<span class="comment-copy">@EMS, what you want is simply impossible. You should use the binary operators instead which work fine (thats what <code>__and__</code> is). The <code>and</code> operator cannot do any element wise logic, it is simply not possible in Python, the result is what you find in <b>Edit 2</b>. Only the last comparison/object can be returned, and that will not do what you expect.</span>
<span class="comment-copy">Why doesn't it result in (1 &lt;= 3) --&gt; True --&gt; (True &gt;= 2) --&gt; type error?</span>
<span class="comment-copy">The expression <code>a &lt;= b &lt;= c</code> gets expanded to <code>a &lt;= b and b &lt;= c</code></span>
<span class="comment-copy">In code, how does the expansion happen. Or is this just a one-off hard-coded Python idiom?</span>
<span class="comment-copy">I really don't think removing this answer it going to get you better responses. Firstly, that's what voting is for, and secondly, continuing to improve your question will have more impact.</span>
<span class="comment-copy">The generalization that <code>a &lt;= b &lt;= c</code> gets expanded to <code>a &lt;= b and b &lt;= c</code> is incorrect.</span>
<span class="comment-copy">So you are saying that the expansion of <code>a &lt; b &lt; c</code> into <code>a &lt; b and b &lt; c</code> is just <i>hard-coded</i> into the code for this part of the interpreter? There's no way to (aside from branching Python source ), for some classes, expand using <code>numpy.logical_and</code> instead, so that logical arrays are handled correctly?</span>
<span class="comment-copy">I don't understand why the answers are so dismissive of this. Can you give some advice for how I can improve my question? I feel it is a very valid point that we should be able to get things to combine with <code>and</code> however it makes the most sense for our classes. This is a very very common kind of operation in Python Pandas and in NumPy, so it's not like I'm asking for some very arcane array support. For example, immediately getting back an array of bools indicating where a date variable falls between a valid start and end date would be much better expressed as one chained inequality.</span>
<span class="comment-copy">Your question starts asking how a chained inequality works, and later says you <i>already know</i> that, and say the real question is something else. So, by about 5 paragraphs in, I'm no longer sure what you're asking, and feel you wasted my time on something you already knew. Now, in the eighth comment to the first answer, and the second comment to the second answer, you've actually made it clear what you wanted to ask. If you feel the answers are dismissive of the question you <i>wanted</i> to ask it's because they're based on the question you <i>actually</i> asked.</span>
<span class="comment-copy">... if I have time, I'll try hacking your question into something more answerable. Otherwise, I'd recommend you ask a new question which is clearer.</span>
<span class="comment-copy">Sorry if it was not clear. I wanted to ask how does it work one layer below just the interpreter's replacement of one syntax with another. I already knew that it popped the <code>and</code> in between. But think of the <code>with</code> statement. This is implemented with an <code>__enter__</code> then a <code>try</code> block, and then a <code>finally</code> with the <code>__exit__</code> call. You can do a lot of syntax manipulation by knowing how <code>with</code> works. I was hoping that chained inequalities similarly reduced down to a sequence of calls to some <code>__</code> type functions, with the handling of the chaining explicitly given in one of those functions.</span>
