<div class="post-text" itemprop="text">
<p>I would like to understand how to use <a href="http://docs.python.org/library/dis.html" rel="noreferrer">dis (the dissembler of Python bytecode)</a>. Specifically, how should one interpret the output of <a href="http://docs.python.org/library/dis.html#dis.dis" rel="noreferrer"><code>dis.dis</code></a> (or <a href="http://docs.python.org/library/dis.html#dis.disassemble" rel="noreferrer"><code>dis.disassemble</code></a>)?</p>
<p>.</p>
<p><em>Here is a very specific example (in Python 2.7.3):</em></p>
<pre class="lang-py prettyprint-override"><code>dis.dis("heapq.nsmallest(d,3)")

      0 BUILD_SET             24933
      3 JUMP_IF_TRUE_OR_POP   11889
      6 JUMP_FORWARD          28019 (to 28028)
      9 STORE_GLOBAL          27756 (27756)
     12 LOAD_NAME             29811 (29811)
     15 STORE_SLICE+0  
     16 LOAD_CONST            13100 (13100)
     19 STORE_SLICE+1
</code></pre>
<p>I see that <a href="http://docs.python.org/library/dis.html#opcode-JUMP_IF_TRUE_OR_POP" rel="noreferrer"><code>JUMP_IF_TRUE_OR_POP</code></a> etc. are bytecode instructions <em>(although interestingly, <code>BUILD_SET</code> does not appear in this list, though I expect it works as <a href="http://docs.python.org/library/dis.html#opcode-BUILD_TUPLE" rel="noreferrer"><code>BUILD_TUPLE</code></a>)</em>. I think the numbers on the right-hand-side are memory allocations, and the numbers on the left are <a href="http://en.wikipedia.org/wiki/GOTO" rel="noreferrer">goto</a> numbers... I notice they <em>almost</em> increment by 3 each time (but not quite).</p>
<p>If I wrap <code>dis.dis("heapq.nsmallest(d,3)")</code> inside a function:</p>
<pre class="lang-py prettyprint-override"><code>def f_heapq_nsmallest(d,n):
    return heapq.nsmallest(d,n)

dis.dis("f_heapq(d,3)")

      0 BUILD_TUPLE            26719
      3 LOAD_NAME              28769 (28769)
      6 JUMP_ABSOLUTE          25640
      9 &lt;44&gt;                                      # what is &lt;44&gt; ?  
     10 DELETE_SLICE+1 
     11 STORE_SLICE+1 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to disassemble a string containing source code, but that's not supported by <code>dis.dis</code> in Python 2. With a string argument, it treats the string as if it contained byte code (see the function <a href="http://hg.python.org/cpython/file/ed76eac4491e/Lib/dis.py#l110" rel="noreferrer"><code>disassemble_string</code> in <code>dis.py</code></a>). So you are seeing nonsensical output based on misinterpreting source code as byte code.</p>
<p>Things are different in Python 3, where <a href="http://docs.python.org/dev/library/dis.html#dis.dis" rel="noreferrer"><code>dis.dis</code> compiles a string argument</a> before disassembling it:</p>
<pre><code>Python 3.2.3 (default, Aug 13 2012, 22:28:10) 
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis('heapq.nlargest(d,3)')
  1           0 LOAD_NAME                0 (heapq) 
              3 LOAD_ATTR                1 (nlargest) 
              6 LOAD_NAME                2 (d) 
              9 LOAD_CONST               0 (3) 
             12 CALL_FUNCTION            2 
             15 RETURN_VALUE         
</code></pre>
<p>In Python 2 you need to compile the code yourself before passing it to <code>dis.dis</code>:</p>
<pre><code>Python 2.7.3 (default, Aug 13 2012, 18:25:43) 
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(compile('heapq.nlargest(d,3)', '&lt;none&gt;', 'eval'))
  1           0 LOAD_NAME                0 (heapq)
              3 LOAD_ATTR                1 (nlargest)
              6 LOAD_NAME                2 (d)
              9 LOAD_CONST               0 (3)
             12 CALL_FUNCTION            2
             15 RETURN_VALUE        
</code></pre>
<p>What do the numbers mean? The number <code>1</code> on the far left is the line number in the source code from which this byte code was compiled. The numbers in the column on the left are the offset of the instruction within the bytecode, and the numbers on the right are the <em>opargs</em>. Let's look at the actual byte code:</p>
<pre><code>&gt;&gt;&gt; co = compile('heapq.nlargest(d,3)', '&lt;none&gt;', 'eval')
&gt;&gt;&gt; co.co_code.encode('hex')
'6500006a010065020064000083020053'
</code></pre>
<p>At offset 0 in the byte code we find <code>65</code>, the opcode for <code>LOAD_NAME</code>, with the oparg <code>0000</code>; then (at offset 3) <code>6a</code> is the opcode <code>LOAD_ATTR</code>, with <code>0100</code> the oparg, and so on. Note that the opargs are in little-endian order, so that <code>0100</code> is the number 1. The undocumented <code>opcode</code> module contains tables <code>opname</code> giving you the name for each opcode, and <code>opmap</code> giving you the opcode for each name:</p>
<pre><code>&gt;&gt;&gt; opcode.opname[0x65]
'LOAD_NAME'
</code></pre>
<p>The meaning of the oparg depends on the opcode, and for the full story you need to read the implementation of the CPython virtual machine <a href="http://hg.python.org/cpython/file/ed76eac4491e/Python/ceval.c" rel="noreferrer">in <code>ceval.c</code></a>. For <code>LOAD_NAME</code> and <code>LOAD_ATTR</code> the oparg is an index into the <code>co_names</code> property of the code object:</p>
<pre><code>&gt;&gt;&gt; co.co_names
('heapq', 'nlargest', 'd')
</code></pre>
<p>For <code>LOAD_CONST</code> it is an index into the <code>co_consts</code> property of the code object:</p>
<pre><code>&gt;&gt;&gt; co.co_consts
(3,)
</code></pre>
<p>For <code>CALL_FUNCTION</code>, it is the number of arguments to pass to the function, encoded in 16 bits with the number of ordinary arguments in the low byte, and the number of keyword arguments in the high byte.</p>
</div>
<div class="post-text" itemprop="text">
<p><sub><em>I am reposting my answer to <a href="https://stackoverflow.com/questions/3299648/python-compilation-interpretation-process">another question</a>, in order to be sure to find it while Googling <code>dis.dis()</code>.</em></sub></p>
<hr/>
<p>To complete the great <a href="https://stackoverflow.com/a/12673195/2291710">Gareth Rees's answer</a>, here is just a small column-by-column summary to explain the output of disassembled bytecode.</p>
<p>For example, given this function:</p>
<pre><code>def f(num):
    if num == 42:
        return True
    return False
</code></pre>
<p>This may be disassembled into (Python 3.6):</p>
<pre class="lang-erlang prettyprint-override"><code>(1)|(2)|(3)|(4)|          (5)         |(6)|  (7)
---|---|---|---|----------------------|---|-------
  2|   |   |  0|LOAD_FAST             |  0|(num)
   |--&gt;|   |  2|LOAD_CONST            |  1|(42)
   |   |   |  4|COMPARE_OP            |  2|(==)
   |   |   |  6|POP_JUMP_IF_FALSE     | 12|
   |   |   |   |                      |   |
  3|   |   |  8|LOAD_CONST            |  2|(True)
   |   |   | 10|RETURN_VALUE          |   |
   |   |   |   |                      |   |
  4|   |&gt;&gt; | 12|LOAD_CONST            |  3|(False)
   |   |   | 14|RETURN_VALUE          |   |
</code></pre>
<p>Each column has a specific purpose:</p>
<ol>
<li>The corresponding <strong>line number</strong> in the source code</li>
<li>Optionally indicates the <strong>current instruction</strong> executed (when the bytecode comes from a <a href="https://docs.python.org/3/library/inspect.html#the-interpreter-stack" rel="noreferrer">frame object</a> for example)</li>
<li>A label which denotes a possible <strong><code>JUMP</code> from an earlier instruction</strong> to this one</li>
<li>The <strong>address</strong> in the bytecode which corresponds to the byte index (those are multiples of 2 because Python 3.6 use 2 bytes for each instruction, while it could vary in previous versions)</li>
<li>The instruction name (also called <strong>opname</strong>), each one is briefly explained in <a href="https://docs.python.org/3.6/library/dis.html#python-bytecode-instructions" rel="noreferrer">the <code>dis</code> module</a> and their implementation can be found in <a href="https://github.com/python/cpython/blob/master/Python/ceval.c" rel="noreferrer"><code>ceval.c</code></a> (the core loop of CPython)</li>
<li>The <strong>argument</strong> (if any) of the instruction which is used internally by Python to fetch some constants or variables, manage the stack, jump to a specific instruction, etc.</li>
<li>The <strong>human-friendly interpretation</strong> of the instruction argument</li>
</ol>
</div>
<span class="comment-copy">see also: <a href="http://stackoverflow.com/questions/3299648/python-compilation-interpretation-process" title="python compilation interpretation process">stackoverflow.com/questions/3299648/…</a></span>
<span class="comment-copy">amazing, is there any reference/tutorial/book which has all this low level details. I want to dig more</span>
<span class="comment-copy">@DevC: Code objects are documented with the <a href="http://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module. Byte code instructions are documented with the <a href="http://docs.python.org/3/library/dis.html#bytecodes" rel="nofollow noreferrer"><code>dis</code></a> module. For the implementation details of the CPython virtual machine, you have to read the source code in <a href="http://hg.python.org/cpython/file/47618b00405b/Python/ceval.c" rel="nofollow noreferrer"><code>ceval.c</code></a>.</span>
<span class="comment-copy">So <a href="http://hg.python.org/cpython/file/default/Lib/dis.py#l291" rel="nofollow noreferrer">this</a> show it is little-endian and two bytes long for <code>oparg</code>?</span>
<span class="comment-copy">Yes; also the <a href="http://hg.python.org/cpython/file/47618b00405b/Python/ceval.c#l992" rel="nofollow noreferrer"><code>NEXTARG</code> and <code>PEEKARG</code> macros in <code>ceval.c</code></a>.</span>
<span class="comment-copy">@GarethRees for documentation on <code>ceval.c</code> you can refer to the Execution Model <a href="https://docs.python.org/3.3/reference/executionmodel.html" rel="nofollow noreferrer">docs.python.org/3.3/reference/executionmodel.html</a></span>
<span class="comment-copy">this is what i am looking for!But I don't find in official doc, thx</span>
