<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Possible Duplicate:</strong><br/>
<a href="https://stackoverflow.com/questions/19339/a-transpose-unzip-function-in-python">A Transpose/Unzip Function in Python</a> </p>
</blockquote>
<p>I have a list of tuples, where I want to unzip this list into two independent lists. I'm looking for some standardized operation in Python. </p>
<pre><code>&gt;&gt;&gt; l = [(1,2), (3,4), (8,9)]
&gt;&gt;&gt; f_xxx (l)
[ [1, 3, 8], [2, 4, 9] ] 
</code></pre>
<p>I'm looking for a succinct and pythonic way to achieve this. </p>
<p>Basically, I'm hunting for inverse operation of <a href="http://docs.python.org/library/functions.html?highlight=zip#zip" rel="noreferrer"><code>zip()</code></a> function. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>zip(*list)</code>:</p>
<pre><code>&gt;&gt;&gt; l = [(1,2), (3,4), (8,9)]
&gt;&gt;&gt; list(zip(*l))
[(1, 3, 8), (2, 4, 9)]
</code></pre>
<p>The <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip()</code> function</a> pairs up the elements from all inputs, starting with the first values, then the second, etc. By using <code>*l</code> you <a href="https://stackoverflow.com/questions/36901">apply all tuples in <code>l</code> as <em>separate arguments</em> to the <code>zip()</code> function</a>, so <code>zip()</code> pairs up <code>1</code> with <code>3</code> with <code>8</code> first, then <code>2</code> with <code>4</code> and <code>9</code>. Those happen to correspond nicely with the columns, or the <em>transposition</em> of <code>l</code>.</p>
<p><code>zip()</code> produces tuples; if you must have mutable list objects, just <code>map()</code> the tuples to lists or use a list comprehension to produce a list of lists:</p>
<pre><code>map(list, zip(*l))          # keep it a generator
[list(t) for t in zip(*l)]  # consume the zip generator into a list of lists
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want a list of lists:</p>
<pre><code>&gt;&gt;&gt; [list(t) for t in zip(*l)]
[[1, 3, 8], [2, 4, 9]]
</code></pre>
<p>If a list of tuples is OK:</p>
<pre><code>&gt;&gt;&gt; zip(*l)
[(1, 3, 8), (2, 4, 9)]
</code></pre>
</div>
<span class="comment-copy"><code>zip</code> is basically it's own inverse.  It's pretty cute like that. :)</span>
<span class="comment-copy"><code>zip</code> is <i>not</i> it's own inverse. It is close though. A function that is its own inverse is called an <i>involution</i>. <a href="https://stackoverflow.com/a/19343/1959808">This answer</a> uses <code>zip</code> to define an involution.</span>
<span class="comment-copy">anyone with the actual implementation?</span>
<span class="comment-copy">If you want to sort the values of X by the values of Y and return two separate lists after , you can do : <code>y,x= map(list,zip(*sorted(zip(y, x))))</code></span>
<span class="comment-copy">Clever.... perhaps too clever. Anyone reading this without surrounding comments will scratch their head for some time.</span>
<span class="comment-copy">In Python3, this creates a zip object.    <code>&gt;&gt;&gt; l = [(1,2), (3,4), (8,9)]</code> <code>&gt;&gt;&gt; zip(*l)</code> <code>&lt;zip at 0x1042d8c48&gt;</code> which can be viewed with a list comprehension <code>&gt;&gt;&gt; [ii for ii in zip(*l)]</code> <code>[(1, 3, 8), (2, 4, 9)]</code>.</span>
<span class="comment-copy">@amath: There is no need for a list comprehension. Just use <code>list()</code>: <code>list(zip(*l))</code>, much faster.</span>
<span class="comment-copy"><b>Beware</b>: <code>a, b = zip(*list)</code> will fail if <code>list</code> is empty so you'll have to treat empty as a special case. You won't get back two empty tuples - of course how could you? If this case can occur then it's much better to use a list comprehension instead.</span>
<span class="comment-copy">@Kapocsi: that's trivially addressed; if lists are needed just map the tuples to lists with a list comprehension. For the majority of use cases, producing sequences or even just iterables is enough.</span>
<span class="comment-copy">I think <code>map(list, zip(*l))</code> is quite nice in Python 2.x. Anyway, +1 for option of list of lists :)</span>
<span class="comment-copy">I prefer list comprehension above <code>map</code> :)</span>
<span class="comment-copy"><code>map</code> is slower than a <code>LC</code>.</span>
<span class="comment-copy">@dav1d -- That's not true.  The speed of map vs. list-comp is entirely problem dependent (You'll see different timings from different people for different problems on SO relatively frequently).  <code>map</code> + <code>lambda</code> is usually slower though ...  The nice thing about a list-comp is that it's the same in py2k and py3k.</span>
<span class="comment-copy">@dav1d -- Here's an older, but classic <a href="http://stackoverflow.com/questions/1247486/python-list-comprehension-vs-map">post</a> which shows the opposite (and the results still hold for me using python2.7 on OS-X)</span>
