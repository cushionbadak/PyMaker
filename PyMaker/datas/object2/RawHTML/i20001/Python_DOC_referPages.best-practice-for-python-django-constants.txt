<div class="post-text" itemprop="text">
<p>I have a Django model that relies on a tuple. I'm wondering what the best practice is for refering to constants within that tuple for my Django program. Here, for example, I'd like to specify "<code>default=0</code>" as something that is more readable and does not require commenting. Any suggestions?</p>
<pre><code>Status = (
    (-1, 'Cancelled'),
    (0, 'Requires attention'),
    (1, 'Work in progress'),
    (2, 'Complete'),
)

class Task(models.Model):
    status = models.IntegerField(choices=Status, default=0) # Status is 'Requires attention' (0) by default.
</code></pre>
<p>EDIT:</p>
<p>If possible I'd like to avoid using a number altogether. Somehow using the string 'Requires attention' instead would be more readable.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is quite common to define constants for the integer values as follows:</p>
<pre><code>class Task(models.Model):
    CANCELLED = -1
    REQUIRES_ATTENTION = 0
    WORK_IN_PROGRESS = 1
    COMPLETE = 2

    Status = (
        (CANCELLED, 'Cancelled'),
        (REQUIRES_ATTENTION, 'Requires attention'),
        (WORK_IN_PROGRESS, 'Work in progress'),
        (COMPLETE, 'Complete'),
    )

    status = models.IntegerField(choices=Status, default=REQUIRES_ATTENTION)
</code></pre>
<p>By moving the constants and <code>Status</code> inside the class, you keep the module's namespace cleaner, and as a bonus you can refer to <code>Tasks.COMPLETE</code> wherever you import the <code>Tasks</code> model.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>CANCELED, ATTENTION, WIP, COMPLETE = range(-1, 3)
Status = (
    (CANCELED, 'Cancelled'),
    (ATTENTION, 'Requires attention'),
    (WIP, 'Work in progress'),
    (COMPLETE, 'Complete'),
)

class Task(models.Model):
    status = models.IntegerField(choices=Status, default=CANCELED)
</code></pre>
<p><hr/>
Keep in mind that as others noted, the proper way is to put these variables
inside your Model class. That's also how the official django <a href="https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.Field.choices">example</a> does it.</p>
<p>There is only one reason where you'd want to put it outside the class namespace
and that is only if these semantics are equally shared by other models of your app. i.e.
you can't decide in which <em>specific</em> model they belong.</p>
<p>Though it doesn't seem like this is the case in your particular example.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Python 3.4+: <code>Enum</code></h1>
<p>You write <em>"If possible I'd like to avoid using a number altogether."</em>
and indeed a named representation is clearly more pythonic.
A bare string, however, is susceptible to typos.</p>
<p>Python 3.4 introduces a module called 
<a href="https://docs.python.org/3/library/enum.html" rel="noreferrer"><code>enum</code></a> providing <code>Enum</code> and <code>IntEnum</code> pseudoclasses
that help with this situation.
With it, your example could work as follows:</p>
<pre><code># in Python 3.4 or later:
import enum  

class Status(enum.IntEnum):
    Cancelled = -1,
    Requires_attention = 0,
    Work_in_progress = 1,
    Complete = 2

def choiceadapter(enumtype):
    return ((item.value, item.name.replace('_', ' ')) for item in enumtype)

class Task(models.Model):
    status = models.IntegerField(choices=choiceadapter(Status), 
                                 default=Status.Requires_attention.value)
</code></pre>
<p>and once the Django team picks up <code>Enum</code>, the
<code>choiceadapter</code> will even be built into Django.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <code>namedtuple</code>, using an Immutable for a constant seems fitting. ;-)</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Status = namedtuple('Status', ['CANCELLED', 'REQUIRES_ATTENTION', 'WORK_IN_PROGRESS', 'COMPLETE'])(*range(-1, 3))
&gt;&gt;&gt; Status
Status(CANCELLED=-1, REQUIRES_ATTENTION=0, WORK_IN_PROGRESS=1, COMPLETE=2)
&gt;&gt;&gt; Status.CANCELLED
-1
&gt;&gt;&gt; Status[0]
-1
</code></pre>
<p>Using attributes on <code>Task</code> as constants like in <a href="https://stackoverflow.com/a/12823272/383793">Alasdair's answer</a> makes more sense in this case, but namedtuples are very cheap substitutes for dicts and objects that don't change. Especially very handy if you want to have <em>lots</em> of them in memory. They are like regular tuples with a bonus of a descriptive <code>__repr__</code> and attribute access.</p>
</div>
<div class="post-text" itemprop="text">
<p>One possible approach could be to use python <strong>range</strong> function with the combination of <strong>tuple</strong>.</p>
<pre><code>class Task(models.Model):
    CANCELED, ATTENTION, WIP, COMPLETE = range(-1, 3)
    Status = (
        (CANCELLED, 'Cancelled'),
        (REQUIRES_ATTENTION, 'Requires attention'),
        (WORK_IN_PROGRESS, 'Work in progress'),
        (COMPLETE, 'Complete'),
    )

    status = models.IntegerField(choices=Status, default=REQUIRES_ATTENTION)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My approach:</p>
<pre><code>class Task(models.Model):
    STATUSES = { 'cancelled': 'Cancelled',
                 'requires attention': 'Requires attention',
                 'work in progress': 'Work in progress',
                 'complete': 'Complete' }

    status = models.CharField(choices=STATUSES.items(), default='cancelled')
</code></pre>
<p>This allows you to write convenient expressions:</p>
<pre><code>tasks = Task.objects.filter(status='complete')
</code></pre>
<p>Also, it allows you to not create unnecessary global variables.</p>
<p>If you really want to use integer field:</p>
<pre><code>class Task(models.Model):

   class STATUS:
      CANCELED, ATTENTION, WIP, COMPLETE = range(-1, 3)
      choices = {
        CANCELED: 'Cancelled',
        ATTENTION: 'Requires attention',
        WIP: 'Work in progress',
        COMPLETE: 'Complete'
      }


   status = models.CharField(choices=STATUSES.choices.items(), default=STATUSES.CANCELED)
</code></pre>
<p>And:</p>
<pre><code>tasks = Task.objects.filter(status=Task.STATUSES.COMPLETE)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary for a small improvement in clarity:</p>
<pre><code>Status = {
    -1: 'Cancelled',
    0: 'Requires attention',
    1: 'Work in progress',
    2: 'Complete',
}

class Task(models.Model):
    status = models.IntegerField(choices=Status.items(), default=Status[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't use Django, but I do something like the following quite a bit under Pyramid and Twisted ...</p>
<pre><code>def setup_mapping( pairs ):
    mapping = {'id':{},'name':{}}
    for (k,v) in pairs:
        mapping['id'][k]= v
        mapping['name'][v]= k
    return mapping

class ConstantsObject(object):
    _pairs= None
    mapping= None

    @classmethod
    def lookup_id( cls , id ):
       pass

    @classmethod
    def lookup_name( cls , name ):
       pass

class StatusConstants(ConstantsObject):
    CANCELLED = -1
    REQUIRES_ATTENTION = 0
    WORK_IN_PROGRESS = 1
    COMPLETE = 2

    _pairs= (
        (-1, 'Cancelled'),
        (0, 'Requires attention'),
        (1, 'Work in progress'),
        (2, 'Complete'),
    )
    mapping= setup_mapping(_pairs)
</code></pre>
<p>So the essence is this:</p>
<ul>
<li>There is a base "constants" class , and another class for each type.  the class defines the keywords to a value in ALLCAPS</li>
<li>I toss in the plaintext <code>_pairs</code> into the class too.  why? because i might need to build out some DB tables with them, or I might want them for error/status messages.  I use the numbers and not the ALLCAPS variable name as a personal preference.  </li>
<li>i initialize a <code>mapping</code> class variable which basically monkeypatches the class by precompiling a bunch of variables within a dict because...</li>
<li>the class is derived from that base class, which offers classmethod functionality to search for a value or do other standard things you often need to do with constants.</li>
</ul>
<p>It's not a one-size-fits-all approach, but I've generally come to really like this.  You can easily use a dict to define the pairs , have the 'mapping' function setup some other attributes, such as giving you tuples of the pair values as k,v or v,k or any weird format you might need.</p>
<p>my code can then looks like this:</p>
<pre><code>status_id = sa.Column(sa.Integer, sa.ForeignKey("_status.id") , nullable=False , default=constants.StatusConstants.CANCELLED )

status_name = constants.StatusConstants.lookup_id(status_id)    
status_name = constants.StatusConstants.mapping['id'][status_id]
</code></pre>
<p>whenever you need to use the constants in another way, you just add or alter the classmethods of the base.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes I have to create some huge choice list. I do not like to type like a monkey, so I rather to create a funcion like this:</p>
<pre><code>def choices(labels):
    labels = labels.strip().split('\n')
    ids = range(1, len(labels)+1)
    return zip(ids, labels)
</code></pre>
<p>And use like this:</p>
<pre><code>my_choices = """
choice1
choice2
choice3
"""
MY_CHOICES = choices(my_choices)
print(MY_CHOICES) # ((1, choice1), (2, choice2), (3, choice3))
</code></pre>
</div>
<span class="comment-copy">Have you read this interesting approach that uses <code>__metaclass__</code>? <a href="http://tomforb.es/using-python-metaclasses-to-make-awesome-django-model-field-choices" rel="nofollow noreferrer">tomforb.es/â€¦</a></span>
<span class="comment-copy">Also give access to the string representations with: <code>def status_str(self):         return self.Status[self.status][1]</code></span>
<span class="comment-copy">@Alveoli django's base model supplies a 'get_fieldname_display()' function for each field within a model. Thus, get_status_display() is already available</span>
<span class="comment-copy">Don't you think it will require extra memory for the objects of that class? A better idea would be to keep them separate and if you want to access them from object, then you can define a function which can return this.</span>
<span class="comment-copy">@AnujnI You might be able to do it in a more memory efficient way, but I think that's a premature optimisation for most readers of this answer.</span>
<span class="comment-copy">Upvoted, but I like it better when the constants are moved into the class like in Alasdair's answer.</span>
<span class="comment-copy">@ChrisWesseling Totally agree, just didn't want to deviate from the OP's example code.</span>
<span class="comment-copy">Even though it is used in only in model, sometimes it is useful to put them outside the class. Maybe in a constants file. I had to do it to avoid circular imports. To call Task.CANCELED i have to import it. Since it is called in many places and the models are changing very fast there is chance for circular imports if we import Task in all the needed files.</span>
<span class="comment-copy">If you need further <a href="http://pyvideo.org/video/367/pycon-2011--fun-with-python--39-s-newer-tools" rel="nofollow noreferrer">convincing</a><code>[11:35 - 26:00]</code></span>
<span class="comment-copy">I think this is very similar to simply having the numeric constant. Is there a way to add human-readable contextual information to what the meaning of '1' is in this case? How can someone tell that 1 means 'Work in progress'?</span>
<span class="comment-copy">I think this is very similar to simply having the numeric constant. Is there a way to add human-readable contextual information to what the meaning of '1' is in this case? How can someone tell that 1 means 'Work in progress'?</span>
