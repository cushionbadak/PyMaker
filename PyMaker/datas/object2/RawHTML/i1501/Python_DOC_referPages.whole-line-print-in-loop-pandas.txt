<div class="post-text" itemprop="text">
<p>I have a <code>DataFrame</code> from pandas:</p>
<pre><code>import pandas as pd
inp = [{'c1':10, 'c2':100}, {'c1':11,'c2':110}, {'c1':12,'c2':120}]
df = pd.DataFrame(inp)
print df
</code></pre>
<p>Output:</p>
<pre><code>   c1   c2
0  10  100
1  11  110
2  12  120
</code></pre>
<p>Now I want to iterate over the rows of this frame. For every row I want to be able to access its elements (values in cells) by the name of the columns. For example:</p>
<pre><code>for row in df.rows:
   print row['c1'], row['c2']
</code></pre>
<p>Is it possible to do that in pandas?</p>
<p>I found this <a href="https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas">similar question</a>. But it does not give me the answer I need. For example, it is suggested there to use:</p>
<pre><code>for date, row in df.T.iteritems():
</code></pre>
<p>or</p>
<pre><code>for row in df.iterrows():
</code></pre>
<p>But I do not understand what the <code>row</code> object is and how I can work with it.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows" rel="noreferrer">DataFrame.iterrows</a> is a generator which yield both index and row</p>
<pre><code>for index, row in df.iterrows():
    print(row['c1'], row['c2'])

Output: 
   10 100
   11 110
   12 120
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To iterate through DataFrame's row in pandas one can use:</p>
<ul>
<li><p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noreferrer">DataFrame.iterrows()</a></p>
<pre><code>for index, row in df.iterrows():
    print row["c1"], row["c2"]
</code></pre></li>
<li><p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html" rel="noreferrer">DataFrame.itertuples()</a></p>
<pre><code>for row in df.itertuples(index=True, name='Pandas'):
    print getattr(row, "c1"), getattr(row, "c2")
</code></pre></li>
</ul>
<p><code>itertuples()</code> is supposed to be faster than <code>iterrows()</code></p>
<p>But be aware, according to the docs (pandas 0.21.1 at the moment):</p>
<ul>
<li><p>iterrows: <code>dtype</code> might not match from row to row</p>
<blockquote>
<p>Because iterrows returns a Series for each row, it <strong>does not preserve</strong> dtypes across the rows (dtypes are preserved across columns for DataFrames).</p>
</blockquote></li>
<li><p>iterrows: Do not modify rows</p>
<blockquote>
<p>You should <strong>never modify</strong> something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.</p>
</blockquote>
<p>Use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="noreferrer">DataFrame.apply()</a> instead:</p>
<pre><code>new_df = df.apply(lambda x: x * 2)
</code></pre></li>
<li><p>itertuples: </p>
<blockquote>
<p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.</p>
</blockquote></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>While <code>iterrows()</code> is a good option, sometimes <code>itertuples()</code> can be much faster:</p>
<pre><code>df = pd.DataFrame({'a': randn(1000), 'b': randn(1000),'N': randint(100, 1000, (1000)), 'x': 'x'})

%timeit [row.a * 2 for idx, row in df.iterrows()]
# =&gt; 10 loops, best of 3: 50.3 ms per loop

%timeit [row[1] * 2 for row in df.itertuples()]
# =&gt; 1000 loops, best of 3: 541 Âµs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <code>df.apply()</code> to iterate over rows and access multiple columns for a function.</p>
<p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html">docs: DataFrame.apply()</a></p>
<pre><code>def valuation_formula(x, y):
    return x * y * 0.5

df['price'] = df.apply(lambda row: valuation_formula(row['x'], row['y']), axis=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the df.iloc function as follows:</p>
<pre><code>for i in range(0, len(df)):
    print df.iloc[i]['c1'], df.iloc[i]['c2']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was looking for <strong>How to iterate on rows AND columns and ended here so :</strong></p>
<pre><code>for i, row in df.iterrows():
    for j, column in row.iteritems():
        print(column)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <em>itertuples()</em>. It is faster than <em>iterrows()</em>:</p>
<pre><code>for row in df.itertuples():
    print "c1 :",row.c1,"c2 :",row.c2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can write your own iterator that implements <code>namedtuple</code></p>
<pre><code>from collections import namedtuple

def myiter(d, cols=None):
    if cols is None:
        v = d.values.tolist()
        cols = d.columns.values.tolist()
    else:
        j = [d.columns.get_loc(c) for c in cols]
        v = d.values[:, j].tolist()

    n = namedtuple('MyTuple', cols)

    for line in iter(v):
        yield n(*line)
</code></pre>
<p>This is directly comparable to <code>pd.DataFrame.itertuples</code>.  I'm aiming at performing the same task with more efficiency.</p>
<hr/>
<p>For the given dataframe with my function:</p>
<pre><code>list(myiter(df))

[MyTuple(c1=10, c2=100), MyTuple(c1=11, c2=110), MyTuple(c1=12, c2=120)]
</code></pre>
<p>Or with <code>pd.DataFrame.itertuples</code>:</p>
<pre><code>list(df.itertuples(index=False))

[Pandas(c1=10, c2=100), Pandas(c1=11, c2=110), Pandas(c1=12, c2=120)]
</code></pre>
<hr/>
<p><strong>A comprehensive test</strong><br/>
We test making all columns available and subsetting the columns.  </p>
<pre><code>def iterfullA(d):
    return list(myiter(d))

def iterfullB(d):
    return list(d.itertuples(index=False))

def itersubA(d):
    return list(myiter(d, ['col3', 'col4', 'col5', 'col6', 'col7']))

def itersubB(d):
    return list(d[['col3', 'col4', 'col5', 'col6', 'col7']].itertuples(index=False))

res = pd.DataFrame(
    index=[10, 30, 100, 300, 1000, 3000, 10000, 30000],
    columns='iterfullA iterfullB itersubA itersubB'.split(),
    dtype=float
)

for i in res.index:
    d = pd.DataFrame(np.random.randint(10, size=(i, 10))).add_prefix('col')
    for j in res.columns:
        stmt = '{}(d)'.format(j)
        setp = 'from __main__ import d, {}'.format(j)
        res.at[i, j] = timeit(stmt, setp, number=100)

res.groupby(res.columns.str[4:-1], axis=1).plot(loglog=True);
</code></pre>
<p><a href="https://i.stack.imgur.com/rt88e.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/rt88e.png"/></a></p>
<p><a href="https://i.stack.imgur.com/azbOF.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/azbOF.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>To loop all rows in a <code>dataframe</code> you can use:</p>
<pre><code>for x in range(len(date_example.index)):
    print date_example['Date'].iloc[x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>IMHO, the simplest decision</p>
<pre><code> for ind in df.index:
     print df['c1'][ind], df['c2'][ind]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To loop all rows in a <code>dataframe</code> and <strong>use</strong> values of each row <strong>conveniently</strong>, <code>namedtuples</code> can be converted to <code>ndarray</code>s. For example:</p>
<pre><code>df = pd.DataFrame({'col1': [1, 2], 'col2': [0.1, 0.2]}, index=['a', 'b'])
</code></pre>
<p>Iterating over the rows:</p>
<pre><code>for row in df.itertuples(index=False, name='Pandas'):
    print np.asarray(row)
</code></pre>
<p>results in:</p>
<pre><code>[ 1.   0.1]
[ 2.   0.2]
</code></pre>
<p>Please note that if <code>index=True</code>, <strong>the index is added as the first element of the tuple</strong>, which may be undesirable for some applications.</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding to the answers above, sometimes a useful pattern is:</p>
<pre><code># Borrowing @KutalmisB df example
df = pd.DataFrame({'col1': [1, 2], 'col2': [0.1, 0.2]}, index=['a', 'b'])
# The to_dict call results in a list of dicts
# where each row_dict is a dictionary with k:v pairs of columns:value for that row
for row_dict in df.to_dict(orient='records'):
    print(row_dict)
</code></pre>
<p>Which results in:</p>
<pre><code>{'col1':1.0, 'col2':0.1}
{'col1':2.0, 'col2':0.2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why complicate things?  </p>
<p>Simple.</p>
<pre><code>import pandas as pd
import numpy as np

# Here is an example dataframe
df_existing = pd.DataFrame(np.random.randint(0,100,size=(100, 4)), columns=list('ABCD'))

for idx,row in df_existing.iterrows():
    print row['A'],row['B'],row['C'],row['D']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>Q: How to iterate over rows in a DataFrame in Pandas?</h2>
</blockquote>
<h1>Don't!</h1>
<p>Iteration in pandas is an anti-pattern, and is something you should only want to do when you have exhausted every other option possible. You should not consider using any function with "<code>iter</code>" in its name for anything more than a few thousand rows or you will have to get used to a <strong>lot</strong> of waiting.</p>
<p>Do you want to print a DataFrame? Use <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_string.html" rel="nofollow noreferrer"><code>DataFrame.to_string()</code></a>.</p>
<p>Do you want to compute something? In that case, search for methods in this order (list modified from <a href="https://stackoverflow.com/questions/24870953/does-iterrows-have-performance-issues">here</a>):</p>
<ol>
<li>vectorization</li>
<li>cython routines</li>
<li>pure python list comprehension (for loop)</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="nofollow noreferrer"><code>apply</code></a><br/>
a. reductions that can be performed in cython<br/>
b. iteration in python space</li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html" rel="nofollow noreferrer"><code>itertuples</code></a>, <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iteritems.html#pandas.DataFrame.iteritems" rel="nofollow noreferrer"><code>iteritems</code></a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows" rel="nofollow noreferrer"><code>iterrows</code></a></li>
</ol>
<p><code>iterrows</code> and <code>itertuples</code> (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which these functions are good at. </p>
<p><strong>Appeal to Authority</strong><br/>
<a href="https://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#iteration" rel="nofollow noreferrer">The docs page</a> on iteration has a huge red warning box that says:</p>
<blockquote>
<p>Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].</p>
</blockquote>
<hr/>
<h2>Next Best Thing: <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">List Comprehensions</a></h2>
<p>If you are iterating because there is no vectorized solution available, use a list comprehension. To iterate over rows using a single column, use</p>
<pre><code>result = [f(x) for x in df['col']]
</code></pre>
<p>To iterate over rows using multiple columns, you can use </p>
<pre><code># two column format
result = [f(x, y) for x, y in zip(df['col1'], df['col2'])]

# many column format
result = [f(row[0], ..., row[n]) for row in df[['col1', ...,'coln']].values]
</code></pre>
<p>If you need an integer row index while iterating, use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>:</p>
<pre><code>result = [f(...) for i, row in enumerate(df[...].values)]
</code></pre>
<p>(where <code>df.index[i]</code> gets you the index label.)</p>
<p>If you can turn it into a function, you can use list comprehension. You can make arbitrarily complex things work through the simplicity and speed of raw  python.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also do <code>numpy</code> indexing for even greater speed ups. It's not really iterating but works much better than iteration for certain applications.</p>
<pre><code>subset = row['c1'][0:5]
all = row['c1'][:]
</code></pre>
<p>You may also want to cast it to an array. These indexes/selections are supposed to act like Numpy arrays already but I ran into issues and needed to cast</p>
<pre><code>np.asarray(all)
imgs[:] = cv2.resize(imgs[:], (224,224) ) #resize every image in an hdf5 file
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are so many ways to iterate over the rows in pandas dataframe. One very simple and intuitive way is :</p>
<pre><code>df=pd.DataFrame({'A':[1,2,3], 'B':[4,5,6],'C':[7,8,9]})
print(df)
for i in range(df.shape[0]):
    # For printing the second column
    print(df.iloc[i,1])
    # For printing more than one columns
    print(df.iloc[i,[0,2]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This example uses iloc to isolate each digit in the data frame. </p>
<pre><code>import pandas as pd

 a = [1, 2, 3, 4]
 b = [5, 6, 7, 8]

 mjr = pd.DataFrame({'a':a, 'b':b})

 size = mjr.shape

 for i in range(size[0]):
     for j in range(size[1]):
         print(mjr.iloc[i, j])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For both viewing and modifying values, I would use <code>iterrows()</code>. In a for loop and by using tuple unpacking (see the example: <code>i, row</code>), I use the <code>row</code> for only viewing the value and use <code>i</code> with the <code>loc</code> method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.</p>
<pre><code>for i, row in df.iterrows():
    if row['A'] == 'Old_Value':
        df.loc[i,'A'] = 'New_value'  
</code></pre>
<p>Here the <code>row</code> in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like <code>row['A'] = 'New_Value'</code>, it will not modify the DataFrame. However, you can use <code>i</code> and <code>loc</code> and specify the DataFrame to do the work.</p>
</div>
<span class="comment-copy">The df.iteritems() iterates over columns and not rows. Thus, to make it iterate over rows, you have to transpose (the "T"), which means you change rows and columns into each other (reflect over diagonal). As a result, you effectively iterate the original dataframe over its rows when you use df.T.iteritems()</span>
<span class="comment-copy">DON'T use <code>iterrows()</code>!. Depending on what you're trying to do, <a href="https://stackoverflow.com/a/55557758/4909087">there are possibly much better alternatives.</a>. <code>iter*</code> functions should be used in very rare circumstances. Also <a href="https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care">related.</a></span>
<span class="comment-copy">Note: "Because iterrows returns a Series for each row, it <b>does not</b> preserve dtypes across the rows." Also, "You <b>should never modify</b> something you are iterating over." According to <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="nofollow noreferrer">pandas 0.19.1 docs</a></span>
<span class="comment-copy">@viddik13 that's a great note thanks. Because of that I ran into a case where numerical values like <code>431341610650</code> where read as <code>4.31E+11</code>. Is there a way around preserving the dtypes?</span>
<span class="comment-copy">@AzizAlto use <code>itertuples</code>, as explained below. See also <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html" rel="nofollow noreferrer">pandas.pydata.org/pandas-docs/stable/generated/â¦</a></span>
<span class="comment-copy">Do not use iterrows. Itertuples is faster and preserves data type. <a href="https://stackoverflow.com/a/41022840/4180797">More info</a></span>
<span class="comment-copy">if you don't need to preserve the datatype, iterrows is fine. @waitingkuo's tip to separate the index makes it much easier to parse.</span>
<span class="comment-copy">Just a small question from someone reading this thread so long after its completion: how df.apply() compares to itertuples in terms of efficiency?</span>
<span class="comment-copy">Note: you can also say something like <code>for row in df[['c1','c2']].itertuples(index=True, name=None):</code> to include only certain columns in the row iterator.</span>
<span class="comment-copy">Instead of <code>getattr(row, "c1")</code>, you can use just <code>row.c1</code>.</span>
<span class="comment-copy">I am about 90% sure that if you use <code>getattr(row, "c1")</code> instead of <code>row.c1</code>, you lose any performance advantage of <code>itertuples</code>, and if you actually need to get to the property via a string, you should use iterrows instead.</span>
<span class="comment-copy">When I tried this it only printed the column values but not the headers.  Are the column headers excluded from the row attributes?</span>
<span class="comment-copy">Much of the time difference in your two examples seems like it is due to the fact that you appear to be using label-based indexing for the .iterrows() command and integer-based indexing for the .itertuples() command.</span>
<span class="comment-copy">For a finance data based dataframe(timestamp, and 4x float), itertuples is 19,57 times faster then iterrows on my machine. Only <code>for a,b,c in izip(df["a"],df["b"],df["c"]:</code> is almost equally fast.</span>
<span class="comment-copy">Can you explain why it's faster?</span>
<span class="comment-copy">@AbeMiessler <code>iterrows()</code> boxes each row of data into a Series, whereas <code>itertuples()</code>does not.</span>
<span class="comment-copy">Note that the order of the columns is actually indeterminate, because <code>df</code> is created from a dictionary, so <code>row[1]</code> could refer to any of the columns. As it turns out though the times are roughly the same for the integer vs the float columns.</span>
<span class="comment-copy">Is the df['price'] refers to a column name in the data frame? I am trying to create a dictionary with unique values from several columns in a csv file. I used your logic to create a dictionary with unique keys and values and got an error stating <b>TypeError: ("'Series' objects are mutable, thus they cannot be hashed", u'occurred at index 0')</b></span>
<span class="comment-copy"><b>Code:</b>  df['Workclass'] = df.apply(lambda row: dic_update(row), axis=1) <b>end of line</b>  id = 0 <b>end of line</b> def dic_update(row):     if row not in dic:         dic[row] = id         id = id + 1</span>
<span class="comment-copy">Never mind, I got it. Changed the function call line to <b>df_new = df['Workclass'].apply(same thing)</b></span>
<span class="comment-copy">Having the axis default to 0 is the worst</span>
<span class="comment-copy">Notice that <code>apply</code> doesn't "iteratite" over rows, rather it applies a function row-wise. The above code wouldn't work if you really <i>do</i> need iterations and indeces, for instance when comparing values across different rows (in that case you can do nothing but iterating).</span>
<span class="comment-copy">Using <code>0</code> in <code>range</code> is pointless, you can omit it.</span>
<span class="comment-copy">I know that one should avoid this in favor of iterrows or itertuples, but it would be interesting to know why. Any thoughts?</span>
<span class="comment-copy">This is the only valid technique I know of if you want to preserve the data types, and also refer to columns by name.  <code>itertuples</code> preserves data types, but gets rid of any name it doesn't like.  <code>iterrows</code> does the opposite.</span>
<span class="comment-copy">Spent hours trying to wade through the idiosyncrasies of pandas data structures to do something simple AND expressive.  This results in readable code.</span>
<span class="comment-copy">While <code>for i in range(df.shape[0])</code> might speed this approach up a bit, it's still about 3.5x slower than the iterrows() approach above for my application.</span>
<span class="comment-copy">I don't see how this answer adds anything that was not in the previous answers</span>
<span class="comment-copy">For people who don't want to read the code: blue line is <code>intertuples</code>, orange line is a list of an iterator thru a yield block. <code>interrows</code> is not compared.</span>
<span class="comment-copy">An <a href="https://stackoverflow.com/a/55557758/4909087">alternate perspective</a>... do take a look :)</span>
<span class="comment-copy">how is the performance of this option when used on a large dataframe (millions of rows for example)?</span>
<span class="comment-copy">Honestly, I donât know exactly, I think that in comparison with the best answer, the elapsed time will be about the same, because both cases use "for"-construction.  But the memory may be different in some cases.</span>
<span class="comment-copy">How is this different than the accepted answer??</span>
<span class="comment-copy">I guess I prefer when coder can quickly just snip the entire code block run it, and it parses fine.  Accepted answer requires piecing together blocks.  Timesaver</span>
<span class="comment-copy">I agree with @coldspeed.  Don't unless you absolutely must.</span>
