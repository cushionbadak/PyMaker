<div class="post-text" itemprop="text">
<p>The following code outputs as follows:</p>
<pre><code>1 sec delay, print "1", 
1 sec delay, print "2", 
1 sec delay, print "1", 
1 sec delay, print "2"
</code></pre>
<p>How can it be modified to run like this:</p>
<pre><code>1 sec delay, print "1", print "1",
1 sec delay, print "2", print "2"
</code></pre>
<p>I would like it to run so that both instances of the for loop begin executing at the same time. As each instance executes, they will encounter the first() function at the same time, then the second() function at the same time, thus printing in the order mentioned above.</p>
<p>Code:</p>
<pre><code>import asyncio

async def first():
    await asyncio.sleep(1)
    return "1"

async def second():
    await asyncio.sleep(1)
    return "2"

async def main():     
    for i in range(2):
      result = await first()
      print(result)
      result2 = await second()
      print(result2)


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Looking at the desired output, it seems that the goal is to leave the individual iteration as it is - i.e. run <code>first</code> and <code>second</code> sequentially - but execute both loop iterations in parallel.</p>
<p>Assuming you only want to modify <code>main()</code>, it could be achieved like this:</p>
<pre><code>async def main():
    async def one_iteration():
        result = await first()
        print(result)
        result2 = await second()
        print(result2)
    coros = [one_iteration() for _ in range(2)]
    await asyncio.gather(*coros)
</code></pre>
<p>Instead of iterating in sequence, the above creates a coroutine for each iteration task, and uses <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow noreferrer"><code>asyncio.gather</code></a> to execute all the iterations in parallel.</p>
<p>Note that simply creating a coroutine doesn't start executing it, so a large number of <code>coros</code> won't block the event loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>With the aysncio library you can use aysncio.gather()</p>
<pre><code>loop.run_until_complete(asyncio.gather(
  first(),
  second()
))
</code></pre>
<p>This can come in handy if you are also sending HTTP requests in parallel:</p>
<pre><code>loop.run_until_complete(asyncio.gather(
  request1(),
  request2()
))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To run the two functions simultaneously you can use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow noreferrer"><code>gather</code></a>. However, the results will be provided to you in the order you provide them. So for example if you do </p>
<pre><code>results = await asyncio.gather(first(), second())
</code></pre>
<p>Then you will get <code>[the result of first(), the result of second()]</code> back. If you want to do something whenever each one returns then you should use <code>Tasks</code> explicitly and <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.add_done_callback" rel="nofollow noreferrer">add callbacks</a>.</p>
</div>
<span class="comment-copy">There are several ways you could do what you're asking - are we assuming there are any constraints here, like that you can't edit the <code>main</code> function? For instance, you could put two loops in <code>main</code> that print the result of each function call twice, and it would produce the exact behavior you're asking for. However, again, if you're working under any constraints, we need to know them in order to help.</span>
<span class="comment-copy">This has no guarantee of printing out <code>1, 1, 2, 2</code>. Though it may happen that way while the system waits for the I/O for printing and the sleep it is entirely possible that this prints <code>1, 2, 1, 2</code>.</span>
<span class="comment-copy">@NickChapman I don't see how it could print <code>1, 2, 1, 2</code> on a non-broken system. It basically executes <code>asyncio.gather(one_iteration(), one_iteration())</code>, and <code>one_iteration</code> <i>sleeps for a second</i> between the different prints executed sequentially. Since they are executed in parallel, one would expect <code>1, 1, 2, 2</code>, with pauses between the 1s and the 2s.</span>
<span class="comment-copy">It will most likely happen that way, but there is no guarantee depending on how constrained the system resources are. For whatever this person is doing it's probably fine for them, but people should be aware that this isn't bulletproof.</span>
<span class="comment-copy">@NickChapman The order of output specified by the question clearly assumes a non-broken system, otherwise it wouldn't use <i>sleeps</i> to begin with. The answer shows how to execute loop iterations in parallel, which was the actual point.</span>
<span class="comment-copy">@user4815162342 sure, though it won't solve the problem of getting the results back in the order you provided the functions rather than the order they actually execute in.</span>
<span class="comment-copy">Looking more closely, this will result in <code>1 sec delay, print "1", print "2"</code>, repeated twice. The OP seems to want something different.</span>
<span class="comment-copy">@user4815162342 ah yeah, ok it looks like they don't need asyncio at all in that case?</span>
<span class="comment-copy">I believe the OP wants to leave the contents of the individual iteration as it is (i.e. run <code>first</code> and <code>second</code> in sequence), but execute all iterations in parallel. See my answer.</span>
