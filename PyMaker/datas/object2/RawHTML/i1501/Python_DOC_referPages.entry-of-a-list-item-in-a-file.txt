<div class="post-text" itemprop="text">
<p>Good afternoon, I have a multiple list of IP and MAC, list of arbitrary length</p>
<pre><code>A = [['10.0.0.1','00:4C:3S:**:**:**', 0], ['10.0.0.2', '00:5C:4S:**:**:**', 0], [....], [....]]
</code></pre>
<p>I want to check if this MAC is in the oui file:</p>
<pre><code>E043DB   (base 16)   Shenzhen
2405f5   (base 16)   Integrated
3CD92B   (base 16) Hewlett Packard
...
</code></pre>
<p>If the MAC from the list is in the file, write the name of the manufacturer as 3 list items. I'm trying to do so and it turns out to check only the first element, the remaining ones are not checked, how can I do this please tell me?</p>
<pre><code>f = open('oui.txt', 'r')
for values in A:
    for line in f.readlines():
        if values[1][0:8].replace(':','') in line:
            values[2]=(line.split('(base 16)')[1].strip())
f.close()
print (A)
</code></pre>
<p>And get an answer:</p>
<pre><code>A = [['10.0.0.1','00:4C:3S:**:**:**', 'Firm Name'], ['10.0.0.2', '00:5C:4S:**:**:**', 0], [....], [....]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>The Problem</strong></p>
<p>Consider the "shape" of your code:</p>
<pre><code>f = open('a file')
for values in [ 'some list' ]:
    for line in f.readlines():
</code></pre>
<p>Your two loops are doing this:</p>
<pre><code>Start with first value in list
Read all lines remaining in file object f
Move to next value in list
Read all lines remaining in file object f
</code></pre>
<p>Except that the first time you told it to "read all lines remaining" it would do so. </p>
<p>So, unless you have some way to put more lines into f (which can happen with async files like stdin!) you are going to get one "good" pass through the file, and then every subsequent pass the file object will point to the end of the file, so you'll get nothing.</p>
<p><strong>A Solution</strong></p>
<p>When you are dealing with a file, you want to only process it one time. File I/O is expensive compared to other operations. So you can choose to either (a) read the entire file into memory, and do whatever you want since it's not a file any more; or (b) scan through it only one time.</p>
<p>If you choose to scan through it only once, the easy solution is just to invert the two for loops. Instead of doing this:</p>
<pre><code>for item in list:
    for line in file:
</code></pre>
<p>Do this instead:</p>
<pre><code>for line in file:
    for item in list:
</code></pre>
<p>And presto! You are now only reading the file one time.</p>
<p><strong>Other Considerations</strong></p>
<p>If I look at your code, and your examples, it seems like you are trying for an <em>exact match</em> on a particular key. You trim down the MAC addresses in your list to check them against the manufacturer ids. </p>
<p>This suggests to me that you might well have <em>many, many more</em> list values (source MAC addresses) than you have manufacturers. So perhaps you should consider reading the contents of the tile into memory, rather than processing it one line at a time.</p>
<p>Once you have the file in memory, consider building a proper dictionary. You have a key (MAC prefix) and a value (manufacturer). So build something like:</p>
<pre><code>for line in f:
    mac = line.split('(base 16)')[0].strip()
    mfg = line.split('(base 16)')[1].strip()
    mac_to_mfg[mac] = mfg
</code></pre>
<p>Then you can make one pass through the source addresses and use the dict's O(1) lookup to your advantage:</p>
<pre><code>for src in A:
    prefix = src[1][:8].replace(':', '')
    if prefix in mac_to_mfg:
        # etc...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is you got the order of the loops reversed.  Usually this isn't that big of a problem, but when working objects that are consumed (like the IO file object) the contents will no longer produce once it's been iterated over.</p>
<p>You'll need to iterate the <code>lines</code> first, and then within each <code>lines</code> iterate through <code>A</code> to check the values:</p>
<pre><code>with open('oui.txt', 'r') as f:
    for line in f.readlines():
        for values in A:
            if values[1][0:8].replace(':','') in line:
                values[2]=(line.split('(base 16)')[1].strip())

print (A)
</code></pre>
<p>Notice I changed your file opening to use the <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code> context manager</a> instead, where once your code exists the <code>with</code> block it will automatically <code>close()</code> the file for you.  It is recommended over manually <code>open</code>ing the file as you might forget to <code>close()</code> it after.</p>
</div>
<span class="comment-copy">I did it, it works, thanks!</span>
