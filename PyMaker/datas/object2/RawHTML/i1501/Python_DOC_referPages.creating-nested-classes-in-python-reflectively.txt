<div class="post-text" itemprop="text">
<p>I am trying to create nested Python classes using the 3 argument <code>type</code> function. I want to construct an analogue of this:</p>
<pre><code>In [15]: class CC: 
    ...:     class DD: 
    ...:         pass 
    ...:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
</code></pre>
<p>The naive attempt is</p>
<pre><code>In [17]: AA = type('AA', (), {'BB': type('BB', (), {})})                                                                                                                                                                                                                                                                                                                                                                                                                                       
</code></pre>
<p>but that is not quite right, since <code>BB</code> is actually created outside
and before <code>AA</code> and is only put inside `AA later.</p>
<p>The difference isdemonstrated by:</p>
<pre><code>In [18]: AA.BB                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
Out[18]: __main__.BB

In [16]: CC.DD                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
Out[16]: __main__.CC.DD
</code></pre>
<p>How can I create nested classes reflectively/dynamically that are completely equivalent to nested definitions?</p>
<hr/>
<p>I want to use this to reflectively generate a <code>graphene-sqlalchemy</code> api. The idiom there is to create an outer Graphene class with an inner Meta class pointing to the correponding SQLAchemy model class (<a href="http://docs.graphene-python.org/projects/sqlalchemy/en/latest/tutorial/#schema" rel="nofollow noreferrer">http://docs.graphene-python.org/projects/sqlalchemy/en/latest/tutorial/#schema</a>) eg:</p>
<pre><code>from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import relationship

from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class UserModel(Base):
    __tablename__ = 'department'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    last_name = Column(String)

from graphene_sqlalchemy import SQLAlchemyObjectType

class User(SQLAlchemyObjectType):
    class Meta:
        model = UserModel
        # only return specified fields
        only_fields = ("name",)
        # exclude specified fields
        exclude_fields = ("last_name",)
</code></pre>
<p>The <code>User</code> class above is pretty cookie cutter and should be constructable programmatically from the <code>UserModel</code> class. This should then be doable for an entire schema.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the Python 3.7 <a href="https://docs.python.org/3.7/library/functions.html#type" rel="nofollow noreferrer"><code>type</code></a> documentation, it says:</p>
<blockquote>
<p>The [1st argument] is the class name and becomes the <code>__name__</code> attribute.</p>
</blockquote>
<p>So, I think the only difference between your 2 examples is that <code>AA.BB.__name__</code> is <code>AA.BB</code> in the 1st example, and <code>BB</code> in the 2nd. If you want the <code>__name__</code> to be the same, you can do this:</p>
<pre><code>AA = type('AA', (), {'BB': type('AA.BB', (), {})})
</code></pre>
<p>Otherwise, as far as I can tell, both examples are functionally equivalent.</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, the only difference you get there is the <code>__qualname__</code> class attribute.
The <code>__qualname__</code> is created by the code object running the class body, and passed as an ordinary attribute to the metaclass <code>__new__</code> method (usually <code>type</code>) .</p>
<p>Therefore all you need to get this level of equivalence is to explicitly pass a proper <code>__qualname__</code>  when creating the class:</p>
<pre><code>In [9]: AA = type('AA', (), {'BB': type('BB', (), {'__qualname__': 'AA.BB'})})  

In [10]: AA
Out[10]: __main__.AA

In [11]: AA.BB
Out[11]: __main__.AA.BB
</code></pre>
<p>This will likely be enough for you, but beware that there are more subtle differences between classes created dynamically. One of the last metaclass questions I answered is exactly about that, but with the opposite approach: the challenge was to actually be able to distinguish classes created with both styles.</p>
<p><a href="https://stackoverflow.com/questions/53158324/detect-if-class-was-defined-declarative-or-functional-possible">Detect if class was defined declarative or functional - possible?</a></p>
<p>(warning: that contains what likely is the "deepest black magic" Python code I ever put in an answer here)</p>
</div>
<span class="comment-copy">Why do you want to do this? Are you sure this is the solution to your problem?</span>
<span class="comment-copy">@roganjosh Fairly sure. I am trying to reflectively generate a <code>graphene-sqlalchemy</code> api. The idiom is to create an outet Graphene class with an inner <code>Meta</code> class pointing to the correponding SQLAchemy model class. <a href="http://docs.graphene-python.org/projects/sqlalchemy/en/latest/tutorial/#schema" rel="nofollow noreferrer">docs.graphene-python.org/projects/sqlalchemy/en/latest/tutorial/â€¦</a></span>
<span class="comment-copy">@roganjosh i added a fuller explanation to the of the use case to the question.</span>
<span class="comment-copy">"but that is not quite right, since BB is actually created outside and before AA and is only put inside AA later" - nearly the same thing happens with CC and DD. DD is created before CC and inserted into the namespace before the creation of CC.</span>
<span class="comment-copy">If you're working with SQLAlchemy, you're going to need to handle weird metaclass stuff, which may necessitate using something like <a href="https://docs.python.org/3/library/types.html#types.new_class" rel="nofollow noreferrer"><code>types.new_class</code></a>, depending on exactly what kind of weird metaclass stuff is involved.</span>
