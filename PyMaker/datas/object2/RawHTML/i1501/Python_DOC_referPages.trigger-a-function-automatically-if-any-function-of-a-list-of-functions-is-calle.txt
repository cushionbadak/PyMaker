<div class="post-text" itemprop="text">
<p>Is there a way to trigger a function automatically if any of a list of functions is called in python? </p>
<p>Like say function a is attached to a list of functions [b, c, d, e] and if either of [b, c, d, e] is called (for example say b()) then a() is called automatically before it? </p>
<p>I want to use function a to set up some values before b is called so that b can use it.</p>
<p>Like for example:</p>
<pre><code># function b is some inbuilt, library function
attach(a, b) #attach function b to function a
b()
# If function b is called first function a gets called, it changes up some 
# global variables for the use of function b, then function b gets executed 
</code></pre>
<p>I have some global variables and some class methods, The global variables are somethings like CLASSIFIER(e.g. LogisticRegression or XGBClassifier), CLASSIFIER_TYPE(e.g. 'linear' or Tree) which I need to change everytime I call fit and predict methods on their respective pipelines (e.g. pipeline_linear or pipeline_tree).fit/predict. This is because I have written code like:</p>
<pre><code>CLASSIFIER = LogisticRegression
CLASSIFIER_TYPE = 'linear'
pipeline_linear = make_pipeline(preprocessing_pipe, CLASSIFIER())
pipeline_linear.fit(X, y)
CLASSIFIER = XGBClassifier
CLASSIFIER_TYPE = 'tree'
pipeline_tree = make_pipeline(preprocessing_pipe, CLASSIFIER())
pipeline_tree.fit(X, y)
linear_preds = pipeline_linear.predict(X) # This statement throws an error
# because CLASSIFIER and CLASSIFIER_TYPE are not changed
# preprocessing_pipe uses CLASSIFIER_TYPE internally to take care of  
# handling both types of classifiers differently.
</code></pre>
<p>So based on the pipeline I am using, the global variables need to be modified accordingly in order for the fit and predict methods to work on the pipelines(pipeline_linear and pipeline_tree).</p>
<p>Any other good approach to take care of these situations will be really helpful!</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you can still use something like a decorator/wrapper. See if something like this could work for you:</p>
<pre><code>MY_GLOBAL = 123

def wrap_with_global_value(func, global_val):
    def wrap(*args, **kwargs):
        global MY_GLOBAL
        prev_global_val = MY_GLOBAL
        MY_GLOBAL = global_val
        result = func(*args, **kwargs)
        MY_GLOBAL = prev_global_val
        return result
    return wrap

class MyClass(object):
    def my_func(self):
        global MY_GLOBAL
        print('from my_func: MY_GLOBAL is {}.'.format(MY_GLOBAL))

my_obj = MyClass()
my_obj.my_func = wrap_with_global_value(my_obj.my_func, 456)

print('Before calling my_func: MY_GLOBAL is {}.'.format(MY_GLOBAL))
my_obj.my_func()
print('After calling my_func: MY_GLOBAL is {}.'.format(MY_GLOBAL))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Before calling my_func: MY_GLOBAL is 123.
from my_func: MY_GLOBAL is 456.
After calling my_func: MY_GLOBAL is 123.
</code></pre>
<p>You can add <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a> if that is important for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a wrapper.</p>
<p>If your function is <code>my_function</code> and your list is <code>list_of_functions</code>:</p>
<pre><code>def func_wrapper(query):
    for additional_function in list_of_functions:
        # Do whatever you need to do with your list of functions
        additional_function()

    my_function(query)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Surely it would be easier to just call the function at the top of each other function?</p>
<pre><code>def setup():
    # Set some variables
    pass

def target1():
    setup()
    pass

def target2():
    setup()
    pass
</code></pre>
</div>
<span class="comment-copy">This is the type of question I want to upvote and vote close as too broad at the same time. There is some <i>meat</i> in here. Can you provide a minimal example?</span>
<span class="comment-copy">You can call <code>a()</code> in <code>b()</code>? If that's not it, then at-least share some code here?</span>
<span class="comment-copy">Are these all your functions? In that case you can probably use a <a href="https://www.thecodeship.com/patterns/guide-to-python-function-decorators/" rel="nofollow noreferrer">decorator</a>. If these functions are already defined (e.g. in a different module), you can use a wrapper (which is what a decorator is, in the end), but that will change its behavior locally only. If you want to modify the behavior of an existing function for anyone using it anywhere, now that is more complicated. As suggested, an example of what you want would be best, or a description of why you need something like this.</span>
<span class="comment-copy">Assume b, c, d, e are all predefined functions. So I can't call a in b. Also I dont want to use decorators to decorate b, c, d, e and call something like decorate(b)() because I will be calling function b several times in my code and I dont want to miss any call of b without a decorator. It would be better to attach b to a function a which will automatically get called if b is called.</span>
<span class="comment-copy">What about something like <code>b = decorate(b)</code>, right after you import <code>b</code>? Then you don't need to remember every time. Or, otherwise, maybe you could give an example of what would be an "ideal" syntax for you?</span>
