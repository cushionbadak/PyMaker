<div class="post-text" itemprop="text">
<p>I want to find the shortest unique combination of characters for each element in a list of strings. Each combination should consist of the string's first character and its two rarest characters at least (more if necessary) and order matters. If a character appears more than once in one string, it should get more weight.</p>
<p>Consider the following example:</p>
<pre><code>liste = ["apple", "pear", "banana", "xylophone", "bear", "banunu"]
combinations = ["apl", "per", "ban", "xyh", "ber", "bnu"
</code></pre>
<p>for <code>apple</code>, both <code>p</code> and <code>e</code> appear 4 times overall, but since <code>p</code> appears twice in <code>apple</code>, it should be used in the combination.</p>
<p>What is the most efficient way to write this logic in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like this:</p>
<pre><code>import heapq

from collections import Counter
from operator import itemgetter


def combination(word, n, counts):
    word_count = Counter(word)
    elements = []
    seen = set()
    for i, c in enumerate(word[1:]):
        if c not in seen:
            elements.append((-1 * counts[c], word_count[c], i, c))
            seen.add(c)
    top = heapq.nlargest(n, elements)
    characters = map(itemgetter(3), top)

    return word[0] + ''.join(sorted(characters, key=lambda x: word.index(x)))


lst = ["apple", "pear", "banana", "xylophone", "bear", "banunu"]

counts = Counter(''.join(lst))

result = [combination(w, 2, counts) for w in lst]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['apl', 'per', 'ban', 'xyh', 'ber', 'bnu']
</code></pre>
<p>The idea is to create a tuple of the priority criterias representing each <em>unique</em> letter. So <code>elements</code> is a list containing tuples represeting:</p>
<ol>
<li><code>counts[c]</code>: The overall count (as you want the rarest multiply by -1)</li>
<li><code>word_count[c]</code>: The specific count of the letter in the word</li>
<li><code>i</code>: represents the firs position of the letter</li>
<li><code>c</code>: the letter itself.</li>
</ol>
<p>Once you create the list <code>elements</code> with:</p>
<pre><code>elements = []
seen = set()
for i, c in enumerate(word[1:]):
    if c not in seen:
        elements.append((-1 * counts[c], word_count[c], i, c))
        seen.add(c)
</code></pre>
<p>Note that as the characters must be unique we use a set (<code>seen</code>) to guarantee uniqueness. Finally you use <a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer">heapq.nlargest</a> to get the top <code>n</code> elements according to the above criterias.</p>
</div>
<span class="comment-copy"><i>"for apple, both p and e appear 4 times overall,..."</i> I didn't get it. How do they appear 4 times?</span>
<span class="comment-copy">In all strings together, both <code>p</code> and <code>e</code> occur 4 times in total. The total number of occurrences of a character is what determines its rarity and whether it should be included in the combination. In case of a tie, like here, preference should be given to the character that appears more than once in the string (if any).</span>
<span class="comment-copy">Why <code>'l'</code> instead of <code>'h'</code> in xylophone?</span>
<span class="comment-copy">My mistake, thanks. Edited the question.</span>
<span class="comment-copy">Zero explanation on how this works, or what heapq is</span>
<span class="comment-copy">That seems like exactly what I was looking for! Could you elaborate a bit on <code>elements.append((-1 * counts[c], word_count[c], i, c))</code> and what <code>heapq.nlargest(n, elements)</code> does?</span>
<span class="comment-copy">@iuvbio Updated the answer!</span>
