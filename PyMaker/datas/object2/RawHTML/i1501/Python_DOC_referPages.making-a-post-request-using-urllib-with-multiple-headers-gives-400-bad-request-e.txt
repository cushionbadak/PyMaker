<div class="post-text" itemprop="text">
<p>I have used <code>requests</code> library and I know how to work with it, but I need to work with standard library only, so I would appreciate if you don't encourage me to use <code>requests</code> instead.   </p>
<p>I made a flask server that handles POST requests and then from a different script I call <em>urllib</em> to make POST calls to the flask server. <strong>I need to send a raw json in body just like we do in Postman.</strong> </p>
<p><strong>Flask Server</strong> </p>
<pre><code>from flask import Flask, request

app = Flask(__name__)
@app.route('/random', methods=['POST'])
def random():
    if request.method == 'POST':
        if request.headers.get('Authorization') and request.headers.get('Content-Type') == 'application/json':
            print(request.get_json())
            return "Success"
        else:
            print(request.get_json())
            return "Bad request"

app.run(host='0.0.0.0', port=5000, debug=True)
</code></pre>
<p><strong>Urllib Client</strong> (saved as test.py) -</p>
<pre><code>import urllib.request
import urllib.parse
d = {"spam": 1, "eggs": 2, "bacon": 0}
data = urllib.parse.urlencode(d)
data = data.encode()
req = urllib.request.Request("http://localhost:5000/random", data)
req.add_header('Content-Type', 'application/json')
req.add_header('Authorization', 12345)
with urllib.request.urlopen(req) as f:
    print(f.read().decode('utf-8'))
</code></pre>
<p>With only <strong>Authorization</strong> header I get <code>Bad Request</code> as output and the json is <code>None</code> on the flask server side <strong>as expected</strong>.  </p>
<p>With ONLY Content-Type header OR both the headers I get this error -</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 9, in &lt;module&gt;
    with urllib.request.urlopen(req) as f:
  File "C:\ProgramData\Anaconda3\lib\urllib\request.py", line 223, in urlopen
    return opener.open(url, data, timeout)
  File "C:\ProgramData\Anaconda3\lib\urllib\request.py", line 532, in open
    response = meth(req, response)
  File "C:\ProgramData\Anaconda3\lib\urllib\request.py", line 642, in http_response
    'http', request, response, code, msg, hdrs)
  File "C:\ProgramData\Anaconda3\lib\urllib\request.py", line 570, in error
    return self._call_chain(*args)
  File "C:\ProgramData\Anaconda3\lib\urllib\request.py", line 504, in _call_chain
    result = func(*args)
  File "C:\ProgramData\Anaconda3\lib\urllib\request.py", line 650, in http_error_default
    raise HTTPError(req.full_url, code, msg, hdrs, fp)
urllib.error.HTTPError: HTTP Error 400: BAD REQUEST
</code></pre>
<p>The whole thing is simple enough, but I am not able to understand why is this happening and the error message doesn't help much either.</p>
</div>
<div class="post-text" itemprop="text">
<p>The server is failing in <code>request.get_json()</code>. It's only happening when the client sends both headers because that's when it reaches this line.</p>
<p>To fix it, change the client to send the data as JSON:</p>
<pre><code>import json            # &lt;-- Import json
import urllib.request
import urllib.parse

d = {"spam": 1, "eggs": 2, "bacon": 0}
data = json.dumps(d)   # &lt;-- Dump the dictionary as JSON
data = data.encode()
req = urllib.request.Request("http://localhost:5000/random", data)
req.add_header('Content-Type', 'application/json')
req.add_header('Authorization', 12345)
with urllib.request.urlopen(req) as f:
    print(f.read().decode('utf-8'))
</code></pre>
<p>I hope this helps</p>
</div>
<span class="comment-copy">This does solve the issue, however I am not able to understand why do i need to use <code>json.dumps</code> as the <a href="https://docs.python.org/3/library/urllib.request.html" rel="nofollow noreferrer">docs</a> (third from last example before <b>Legacy interface</b>) and a few other SO posts suggest to use <code>urlencode</code> like i have <code>d = {"spam": 1, "eggs": 2, "bacon": 0} data = urllib.parse.urlencode(d) data = data.encode()</code></span>
<span class="comment-copy">The SO posts I am talking about are, <a href="https://stackoverflow.com/a/41917763/3647970">this</a> and <a href="https://stackoverflow.com/questions/36484184/python-make-a-post-request-using-python-3-urllib">this</a></span>
<span class="comment-copy">The first link in your comment did not solve the problem. The <a href="https://stackoverflow.com/a/41918479/6118299">accepted answer</a> uses the <code>requests</code> library, which would work for you, too and I recommend it. The second link in your comment works with <code>urlencode</code> because it's simulating POSTing a form. The data in a POST request is just a big string. The encoding tells the server how to interpret that data. Try printing the raw request (<code>print request.data</code>) instead of using <code>get_json()</code> to see the difference between URL-encoded data and JSON.</span>
<span class="comment-copy">I finally understand it now. Thanks a lot for the time and effort. However I was playing around with what you suggested and I found this peculiar thing, if i don't pass any of the headers from the urllib script but i do pass the json then the server receives an empty byte like <code>b''</code> . However when I do the same via POSTMAN, i.e manually disable the headers by un-ticking them but keep the json body as it is, I still somehow get the whole json byte as <code>b'{"spam": 1, "eggs": 2, "bacon": 0}'</code>. Any idea why is this happening?</span>
