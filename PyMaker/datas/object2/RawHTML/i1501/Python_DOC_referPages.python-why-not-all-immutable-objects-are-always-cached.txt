<div class="post-text" itemprop="text">
<p>I am not sure what is happening under the hood with regards to the Python object model for the code below.</p>
<p>You can download the data for the ctabus.csv file from this <a href="http://www.dabeaz.com/datadeepdive/" rel="nofollow noreferrer">link</a> </p>
<pre><code>import csv

def read_as_dicts(filename):
    records = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)

        for row in rows:
            route = row[0]
            date = row[1]
            daytype = row[2]
            rides = int(row[3])
            records.append({
                    'route': route,
                    'date': date,
                    'daytype': daytype,
                    'rides': rides})

    return records

# read data from csv
rows = read_as_dicts('ctabus.csv')
print(len(rows)) #736461

# record route ids (object ids)
route_ids = set()
for row in rows:
    route_ids.add(id(row['route']))

print(len(route_ids)) #690072

# unique_routes
unique_routes = set()
for row in rows:
    unique_routes.add(row['route'])

print(len(unique_routes)) #185
</code></pre>
<p>When I call <code>print(len(route_ids))</code> it prints <code>"690072"</code>. Why did Python end up creating these many objects? </p>
<p>I expect this count to be either 185 or 736461. 185 because, when I count the unique routes in set the length of that set comes out to be 185. 736461 because, this is the total number of records in csv file.</p>
<p>What is this weird number "690072"?</p>
<p>I am trying to understand why this partial caching? Why python can't perform a full caching something like below. </p>
<pre><code>import csv

route_cache = {}

#some hack to cache
def cached_route(routename):
    if routename not in route_cache:
        route_cache[routename] = routename
    return route_cache[routename]

def read_as_dicts(filename):
    records = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)

        for row in rows:
            row[0] = cached_route(row[0]) #cache trick
            route = row[0]
            date = row[1]
            daytype = row[2]
            rides = int(row[3])
            records.append({
                    'route': route,
                    'date': date,
                    'daytype': daytype,
                    'rides': rides})

    return records

# read data from csv
rows = read_as_dicts('ctabus.csv')
print(len(rows)) #736461

# unique_routes
unique_routes = set()
for row in rows:
    unique_routes.add(row['route'])

print(len(unique_routes)) #185

# record route ids (object ids)
route_ids = set()
for row in rows:
    route_ids.add(id(row['route']))

print(len(route_ids)) #185
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A typical record from the file looks like following:</p>
<pre><code>rows[0]
{'route': '3', 'date': '01/01/2001', 'daytype': 'U', 'rides': 7354}
</code></pre>
<p>That means most of your immutable objects are strings and only the <code>'rides'</code>-value is an integer. </p>
<p>For small integers (<code>-5...255</code>), Python3 keeps <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="nofollow noreferrer">an integer pool</a> - so these small integers feels like being cached (as long as <code>PyLong_FromLong</code> and Co. are used).</p>
<p>The rules are more complicated for strings - they are, as pointed out by @timgeb, interned. There is <a href="http://guilload.com/python-string-interning/" rel="nofollow noreferrer">a greate article about interning</a>, even if it is about Python2.7 - but not much changed since then. In a nutshell, the most important rules are:</p>
<ol>
<li>all strings of length <code>0</code> and <code>1</code> are interned.</li>
<li>stings with more than one character are interned if they constist of characters that can be used in identifiers and are created at compile time either directly or through peephole optimization (but in the second case only if the result is no longer than 20 characters).</li>
</ol>
<p>All of the above are implementation details, but taking them into account we get the following for the <code>row[0]</code> above:</p>
<ol>
<li><code>'route', 'date', 'daytype', 'rides'</code> are all interned because they created at compile time of the function <code>read_as_dicts</code> and don't have "strange" characters.</li>
<li><code>'3'</code> and <code>'W'</code> are interned because their length is only <code>1</code>.</li>
<li><code>01/01/2001</code> isn't interned because it is longer than <code>1</code>, created at runtime and whouldn't qualify anyway because it has character <code>/</code> in it.</li>
<li><code>7354</code> isn't from the small integer pool, because too large. But other entries might be from this pool.</li>
</ol>
<p>This was an explanation for the current behavior, with only some objects being "cached". </p>
<p>But why doesn't Python cache all created strings/integer? </p>
<p>Let's start with integers. In order to be able to look-up fast if an integer-number is already created (much faster than <code>O(n)</code>), one has to keep an additional look-up data-structure, which needs additional memory. However, there are so many integers, that the probability to hit one already existing integer again is not very high, so the memory overhead for the look-up-data-structure will not be repaid in the most cases.</p>
<p>Because strings need more memory, the relative (memory) cost of the look-up data-structure isn't that high. But it doesn't make any sense to intern a 1000-character-string, because the probability for a randomly created string to have the very same characters is almost <code>0</code>! </p>
<p>On the other hand, if for example a hash-dictionary is used as the look-up structure, the calculation of the hash will take <code>O(n)</code> (<code>n</code>-number of characters), which probably won't pay off for large strings.</p>
<p>Thus, Python makes a trade off, which works pretty well in most scenarios - but it cannot be perfect in some special cases. Yet for those special scenarios you can optimize per hand using <a href="https://docs.python.org/3/library/sys.html#sys.intern" rel="nofollow noreferrer"><code>sys.intern()</code></a>.</p>
<hr/>
<p>Note: Having the same id doesn't mean to be the same object, if the live time of two objects don't overlapp, - so your reasoning in the question isn't entrirely watherproof - but this is of no consequence in this special case.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are 736461 elements in <code>rows</code>.</p>
<p>Thus, you are adding <code>id(row['route'])</code> to the set <code>route_ids</code> 736461 times.</p>
<p>Since whatever <code>id</code> returns is guaranteed to be <strong>unique</strong> among simultaneously existing objects, we would expect <code>route_ids</code> to end up with 736461 items minus whatever the amount of strings that are small enough to be cached for two <code>'route'</code> keys of two rows in <code>rows</code>. </p>
<p>Turns out that in your specific case,  that number is 736461 - 690072 == 46389.</p>
<p>Caching of small immutable objects (strings, integers) is an implementation detail you should not rely on - but here's a demo:</p>
<pre><code>&gt;&gt;&gt; s1 = 'test' # small string
&gt;&gt;&gt; s2 = 'test'
&gt;&gt;&gt; 
&gt;&gt;&gt; s1 is s2 # id(s1) == id(s2)
True
&gt;&gt;&gt; s1 = 'test'*100 # 'large' string
&gt;&gt;&gt; s2 = 'test'*100
&gt;&gt;&gt; 
&gt;&gt;&gt; s1 is s2
False
</code></pre>
<p>In the end, there's probably a semantic error in your program. What do you want to do with the unique <code>id</code>s of the Python objects?</p>
</div>
<span class="comment-copy">id returns the memory location of the object. Some memory might be recycled in your loop and addresses reused, so you get a lower number. What are you trying to achieve?</span>
<span class="comment-copy">I have too many pending edits but can I suggest changing the title of this question to something others are more likely to find? Perhaps, 'Python - Less Unique IDs than Objects', or something like that.</span>
<span class="comment-copy">Regarding your edit: so in the end you are asking why not <i>all</i> immutable objects are always cached?</span>
<span class="comment-copy">@timgeb Yes. I mean whats the thought process behind caching short bits but not the large ones.</span>
<span class="comment-copy">Well it was just a guess. I added the python-internals tag, maybe it attracts somebody who can answer authoritatively.</span>
<span class="comment-copy">Also, I'd assume hashing in order to find out if a string already has been cached would come with some performance cost.</span>
<span class="comment-copy">Thanks for the answer. I am just trying to understand how python caches the memory under the hood. I have updated the question accordingly.</span>
