<div class="post-text" itemprop="text">
<p><code>argparse</code> replaces dashes in optional arguments by underscores to determine their destination:</p>
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--use-unicorns', action='store_true')
args = parser.parse_args(['--use-unicorns'])
print(args)  # returns: Namespace(use_unicorns=True)
</code></pre>
<p>However the user has to remember whether the option is <code>--use-unicorns</code> or <code>--use_unicorns</code>; using the wrong variant raises an error.</p>
<p>This can cause some frustration as the variable <code>args.use_unicorns</code> in the code does not make it clear which variant was defined.</p>
<p>How can I make <code>argparse</code> accept both <code>--use-unicorns</code> and <code>--use_unicorns</code> as valid ways to define this optional argument?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>parser.add_argument('--use-unicorns', action='store_true')
args = parser.parse_args(['--use-unicorns'])
print(args)  # returns: Namespace(use_unicorns=True)
</code></pre>
<p><code>argparse</code> translates the '-' to '_' because the use of '-' in flags is well established POSIX practice.  But <code>args.use-unicones</code> is not acceptable Python.  In other words, it does the translation so the <code>dest</code> will be a valid Python variable or attribute name.</p>
<p>Note that <code>argparse</code> does not perform this translation with <code>positionals</code>.  In that case the programmer has full control over the <code>dest</code> parameter, and can choose anything that's convenient.  Since the <code>argparse</code> only uses <code>getattr</code> and <code>setattr</code> when accessing the <code>Namespace</code>, the constraints on a valid <code>dest</code> are minimal.</p>
<p>There are two users.  There's you, the programmer, and there's your end user.  What's convenient for you might not be optimal for the other.</p>
<p>You can also specify a <code>dest</code> with defining an <code>optional</code>.  And <code>metavar</code> gives you further control over the <code>help</code> display.</p>
<hr/>
<p>It's <code>parser._get_optional_kwargs</code> that performs the '-' replace:</p>
<pre><code>    if dest is None:
        ....
        dest = dest.replace('-', '_')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>parser.add_argument</code> accepts more than one flag for an argument (<a href="https://docs.python.org/3/library/argparse.html#name-or-flags" rel="nofollow noreferrer">link to documentation</a>). One easy way to make the parser accept both variants is to declare the argument as</p>
<pre><code>parser.add_argument('--use-unicorns', '--use_unicorns', action='store_true')
</code></pre>
<p>However both options will show up in the help, and it is not very elegant as it forces one to write the variants manually.</p>
<p>An alternative is to subclass <code>argparse.ArgumentParser</code> to make the matching invariant to replacing dashes by underscore. This requires a little bit of fiddling, as both <code>argparse_ActionsContainer._parse_optional</code> and <code>argparse_ActionsContainer._get_option_tuples</code> have to be modified to handle this matching and abbrevations, e.g. <code>--use_unic</code>.</p>
<p>I ended up with the following subclassed method, where the matching to abbrevations is delegated from <code>_parse_optional</code> to <code>_get_option_tuples</code>:</p>
<pre><code>from gettext import gettext as _
import argparse


class ArgumentParser(argparse.ArgumentParser):

    def _parse_optional(self, arg_string):
        # if it's an empty string, it was meant to be a positional
        if not arg_string:
            return None

        # if it doesn't start with a prefix, it was meant to be positional
        if not arg_string[0] in self.prefix_chars:
            return None

        # if it's just a single character, it was meant to be positional
        if len(arg_string) == 1:
            return None

        option_tuples = self._get_option_tuples(arg_string)

        # if multiple actions match, the option string was ambiguous
        if len(option_tuples) &gt; 1:
            options = ', '.join([option_string
                for action, option_string, explicit_arg in option_tuples])
            args = {'option': arg_string, 'matches': options}
            msg = _('ambiguous option: %(option)s could match %(matches)s')
            self.error(msg % args)

        # if exactly one action matched, this segmentation is good,
        # so return the parsed action
        elif len(option_tuples) == 1:
            option_tuple, = option_tuples
            return option_tuple

        # if it was not found as an option, but it looks like a negative
        # number, it was meant to be positional
        # unless there are negative-number-like options
        if self._negative_number_matcher.match(arg_string):
            if not self._has_negative_number_optionals:
                return None

        # if it contains a space, it was meant to be a positional
        if ' ' in arg_string:
            return None

        # it was meant to be an optional but there is no such option
        # in this parser (though it might be a valid option in a subparser)
        return None, arg_string, None

    def _get_option_tuples(self, option_string):
        result = []

        if '=' in option_string:
            option_prefix, explicit_arg = option_string.split('=', 1)
        else:
            option_prefix = option_string
            explicit_arg = None
        if option_prefix in self._option_string_actions:
            action = self._option_string_actions[option_prefix]
            tup = action, option_prefix, explicit_arg
            result.append(tup)
        else:  # imperfect match
            chars = self.prefix_chars
            if option_string[0] in chars and option_string[1] not in chars:
                # short option: if single character, can be concatenated with arguments
                short_option_prefix = option_string[:2]
                short_explicit_arg = option_string[2:]
                if short_option_prefix in self._option_string_actions:
                    action = self._option_string_actions[short_option_prefix]
                    tup = action, short_option_prefix, short_explicit_arg
                    result.append(tup)

            underscored = {k.replace('-', '_'): k for k in self._option_string_actions}
            option_prefix = option_prefix.replace('-', '_')
            if option_prefix in underscored:
                action = self._option_string_actions[underscored[option_prefix]]
                tup = action, underscored[option_prefix], explicit_arg
                result.append(tup)
            elif self.allow_abbrev:
                    for option_string in underscored:
                        if option_string.startswith(option_prefix):
                            action = self._option_string_actions[underscored[option_string]]
                            tup = action, underscored[option_string], explicit_arg
                            result.append(tup)

        # return the collected option tuples
        return result
</code></pre>
<p>A lot of this code is directly derived from the corresponding methods in <code>argparse</code> (<a href="https://github.com/python/cpython/blob/master/Lib/argparse.py" rel="nofollow noreferrer">from the CPython implementation here</a>). Using this subclass should make the matching of optional arguments invariant to using dashes <code>-</code> or underscores <code>_</code>.</p>
</div>
<span class="comment-copy">I think you're overstating the potential for confusion. <code>use_unicorn</code> is an internal attribute name that isn't exposed to the user <i>at all</i>. If you want to support <code>--use_unicorn</code>, go for it, but don't feel compelled to just because <code>-</code> is not a valid character in a Python identifier.</span>
<span class="comment-copy">Did you consider rewriting the args it the <code>sys.argv</code>?</span>
<span class="comment-copy">@chepner here I consider the user to be more of a developer; I myself made this confusion multiple times when working on some code. Since <code>argparse</code> converts the <code>-</code> into <code>_</code> for the <code>dest</code> it does not harm to support both when parsing (same as supporting <code>arg=value</code> interchangeably with arg value).  When working on other people's code I tend to change <code>use_unicorns</code> into <code>use-unicorns</code> for standard POSIX but would like to be able to do so in a backward-compatible way easily.</span>
<span class="comment-copy">Strictly speaking, POSIX only allows single letter/number option names like <code>-a</code> and <code>-1</code>.</span>
<span class="comment-copy">@VPfB indeed that could be a simpler option, e.g. when only using <code>-</code> instead of <code>_</code> in the arguments</span>
<span class="comment-copy">Hi, I understood these aspects; my question was about letting the parser parse <code>--use-unicorns</code> and <code>--use_unicorns</code> interchangeably, in the same way one can use <code>option=1</code> or <code>option 1</code> interchangeably with argparse.</span>
<span class="comment-copy">Who needs to know about  '--use_unicorns'?  You or your end user?</span>
<span class="comment-copy">Well my wish was for the option specified in the code to be reflected in the help for consistency (so visible to the end user), but for the parser to deal with both variants interchangeably.</span>
