<div class="post-text" itemprop="text">
<p>I have a long string with me like this</p>
<p><code>s = 'abcdabcdabcdabcdabcdefghi'</code></p>
<p>I want to split it to K substrings, where each substring must be at least of length  1 ie non-empty. I want all such possible combinations.</p>
<p>The output I am expecting must be like following if <code>K</code> is 3</p>
<pre><code>[['abcda', 'bcdabcdabcda', 'bcdefghi'], [.....], [....], ... ]
</code></pre>
<p>I wanted to do this with list comprehension but I am stuck. Is it possible to implement.? Are there any other faster alternatives.?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>, you can get separation index pairs:</p>
<pre><code>&gt;&gt;&gt; s = 'abcdef'
&gt;&gt;&gt; k = 3
&gt;&gt;&gt; list(combinations(range(1, len(s)), k-1))
[(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]
</code></pre>
<p>using that index pair to get string slices</p>
<ul>
<li><code>(1, 2)</code> -&gt; (<code>s[:1]</code>, <code>s[1:2]</code>, <code>s[2:]</code>)</li>
<li><code>(1, 3)</code> -&gt; (<code>s[:1]</code>, <code>s[1:3]</code>, <code>s[3:]</code>)</li>
<li>...</li>
<li><code>(4, 5)</code> -&gt; (<code>s[:4]</code>, <code>s[4:5]</code>, <code>s[5:]</code>)</li>
</ul>
<hr/>
<pre><code>&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt; s = 'abcdef'

&gt;&gt;&gt; k = 3
&gt;&gt;&gt; [[s[i:j] for i, j in zip((None,) + idxs, idxs + (None,))]
...  for idxs in combinations(range(1, len(s)), k-1)]
[['a', 'b', 'cdef'], ['a', 'bc', 'def'], ..., ['abcd', 'e', 'f']]


&gt;&gt;&gt; k = 4
&gt;&gt;&gt; [[s[i:j] for i, j in zip((None,) + idxs, idxs + (None,))]
...  for idxs in combinations(range(1, len(s)), k-1)]
[['a', 'b', 'c', 'def'], ['a', 'b', 'cd', 'ef'], ..., ['abc', 'd', 'e', 'f']]
</code></pre>
<ul>
<li><code>s[:1] == s[0:1] == s[None:1]</code></li>
<li><code>s[2:] == s[2:len(s)] == s[2:None]</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could find all slices of your list so that none of sliced parts will be empty without any extended libraries like so:</p>
<pre><code>s = 'abcd'
substrings = []

# find slice of first part - from a|bcd to ab|cd
for first_slice in range(len(s)-2):
    # find slice of second and last part, for bcd - from b|cd to bc|d
    #                                     for cd -  just c|d
    for second_slice in range(first_slice+1, len(s)-1):
        substrings.append([s[:first_slice+1], s[first_slice+1: second_slice+1], s[second_slice+1:]])

print(substrings) # -&gt; [['a', 'b', 'cd'], ['a', 'bc', 'd'], ['ab', 'c', 'd']]

s = 'abcdabcdabcdabcdabcdefghi'
print(len(substrings)) # -&gt; 276
</code></pre>
</div>
<span class="comment-copy">Why does your expected output with K=3 not start with <code>['a','b','cdabcdabcdabcdabcdefghi']</code>?</span>
<span class="comment-copy">I just gave a random sample. The order doesn't matter</span>
<span class="comment-copy">Do you want every possible combination of <code>K</code> sublists?</span>
<span class="comment-copy">I want to get every possible combination of K sublists. I am looking for some faster method. List comprehension most preferably.</span>
<span class="comment-copy">Seems cool. Will this be faster than the other solution.?</span>
<span class="comment-copy">@SreeramTP, Time complexity is same as far as I know. But other solution (Filip MÅ‚ynarski) works only for k=3 case. To go future you need to add another <code>for</code> loop(s).</span>
