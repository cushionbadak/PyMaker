<div class="post-text" itemprop="text">
<p>Say I have a python class which may set a dictionary upon instantiating:</p>
<pre><code>class myClass():
    def __init__(self, some_dict=None):
        self.some_dict = some_dict
</code></pre>
<p>and then in another place in my code, I want to look up a key in that dict - but of course only if it exists. Is the best Python style then to 1) make a "checking method" in the class, even if it's only one line, or 2) directly reference the class' dictionary attribute? Let's say the class was instantiated as <code>myClassInstance</code> the options are then</p>
<p>1) Class method:</p>
<pre><code>    def is_key_in_dict(self, query_key):
        return self.some_dict and query_key in self.some_dict
</code></pre>
<p>which is then used as</p>
<pre><code>if myClassInstance.is_key_in_dict(query_key):
    do_something()
</code></pre>
<p>or, 2) directly reference in the code where its used. </p>
<pre><code>if myClassInstance.some_dict and query_key in myClassInstance.some_dict:
    do_something()
</code></pre>
<p>Is it okay (style-wise) to reference class attributes directly or is it considered bad/unsafe practice? I am somewhat familiar with the <code>@property</code> decorator, as discussed in this post: <a href="https://stackoverflow.com/questions/2627002/whats-the-pythonic-way-to-use-getters-and-setters">What's the pythonic way to use getters and setters?</a>, but not sure if that answers my question.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://stackoverflow.com/questions/11360858/what-is-the-eafp-principle-in-python">EAFP-Principle</a>, using exceptions for control flow is pythonic. Currently, you are looking before you leap.</p>
<p>I would code (either as a function or method):</p>
<pre><code>def do_something(myClassInstance, query_key): # additional arguments omitted
    try:
        query_value = myClassInstance.some_dict[query_key]
    except TypeError, KeyError: # could also consider AttributeError
        pass # or whatever logic you need
    else: # no exception
        # code that does something
</code></pre>
<p>If you have multiple functions/methods that need the same exception handling, for reusability it would make sense to write an additional wrapper around the exception handling which returns <code>query_value</code> if no exception occured and a appropriate sentinel value (e.g. <code>None</code>) if an exception occured. </p>
<p>You could also consider to use the line</p>
<pre><code>self.some_dict = some_dict or {}
</code></pre>
<p>in <code>__init__</code>, then you don't have to think about <code>TypeError</code>s any longer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you need
<a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">object.__contains__</a> method</p>
<pre><code>class SomeClass:
    def __init__(self, some_dict):
        self.some_dict = some_dict or {}

    def __contains__(self, item):

        if item in self.some_dict:
            return True

        return False
</code></pre>
<p>And in your code</p>
<pre><code>c = SomeClass({'a': 1})

if 'a' in c:
    print('c contains key "a"')
</code></pre>
</div>
<span class="comment-copy">I wouldn't do either of these. I'd set the attribute to an empty dict if the parameter is none, then just do the <code>if...in</code>.</span>
