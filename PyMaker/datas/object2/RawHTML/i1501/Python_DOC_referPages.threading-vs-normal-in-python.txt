<div class="post-text" itemprop="text">
<pre><code>import time
import threading
import multiprocessing

def fn():
    '''since all 3 functions were identical you can just use one ...'''
    x = 0
    while  x &lt; 100000000:
        x += 1




def TEST_THREADS():
    new_thread1  = threading.Thread(target = fn , args = ())
    new_thread2  = threading.Thread(target = fn, args = ())
    new_thread1.start()
    new_thread2.start()
    new_thread1.join()
    new_thread2.join()

def TEST_NORMAL():
    fn()
    fn()

def TEST_MULTIPROCESSING():
    new_thread1  = multiprocessing.Process(target = fn , args = ())
    new_thread2  = multiprocessing.Process(target = fn, args = ())
    new_thread1.start()
    new_thread2.start()
    new_thread1.join()
    new_thread2.join()
if __name__ == "__main__":  
    '''It is very important to use name == __main__ guard code with threads         and multiprocessing'''
    import timeit
    print ("Time to Run 1x: %0.2fs"%(timeit.timeit(fn,number=1),))
    print ("NORMAL:%0.2fs"%(timeit.timeit(TEST_NORMAL,number=1),))
    print ("Threaded: %0.2fs"%(timeit.timeit(TEST_THREADS,number=1),))
    print ("Multiprocessing: %0.2fs"%    (timeit.timeit(TEST_MULTIPROCESSING,number=1),))
</code></pre>
<p>I found interesting presentetion about GIL and Threading:
<a href="http://www.dabeaz.com/python/NewGIL.pdf" rel="nofollow noreferrer">http://www.dabeaz.com/python/NewGIL.pdf</a>
So I wrote similar code, but get strange results:</p>
<pre><code>Time to Run 1x: 11.60s
NORMAL:23.15s
Threaded: 23.43s
Multiprocessing: 1.19s
</code></pre>
<p>As you can see, threading method ran faster than normal one or equally (0.28s not too much).
I found some articles and similar questions, but everywhere results were like in presentetion- threading is slower.</p>
<p>Am I doing something wrong or new Python version improved GIL?</p>
<p>However, Multiprocessing also went crazy and work 20x faster than others! Is it ok? </p>
</div>
<div class="post-text" itemprop="text">
<p>In modern Python, the GIL isn't as bad as it used to be (previously, you could expect CPU bound threaded code to run meaningfully slower), so your observation is roughly what you'd expect.</p>
<p>From personal experience, a bunch of CPU bound threads on CPython 2.7 could use close to two cores of CPU, and accomplish less than 75% of a core's worth of work. Since they <a href="https://docs.python.org/3/whatsnew/3.2.html#multi-threading" rel="nofollow noreferrer">rewrote the GIL in CPython 3.2</a>, that overhead largely disappeared; you still don't <em>gain</em> anything from the threading, but you end up using 1-1.1 cores' worth of compute and accomplish 95-100% of a core's worth of work. Basically, the GIL doesn't meaningfully slow code anymore, but it still prevents you from reaping a benefit from threading with CPU bound code that isn't based on third party GIL-releasing extensions like <code>numpy</code>.</p>
</div>
<span class="comment-copy">it's the same time plus the overhead of creating &amp; managing the thread. If you know the GIL why does the result surprise you?</span>
<span class="comment-copy">multiprocessing runs 20x faster than the non-threaded version. Doesn't that surprise you more?</span>
<span class="comment-copy">Everywhere threads are much slower. Sequential    : 24.6s Threaded     : 45.5s or something like that</span>
<span class="comment-copy">the timings in your question are different. You state 0.28s difference, and your comment states 200% increase. Which one is it?</span>
<span class="comment-copy">The GIL doesn't apply when you create a whole new process in multiprocessing, which is why you see the 20x increase. Even this is a bit surprising, because I'm guessing  you'd expect only a 2x increase at most. As for the slight difference in time between MT and ST, that seems too insignificant to draw any meaningful conclusions from.</span>
<span class="comment-copy">Thank you so much. However, can you explain 20x increase in multiprocessing? I'm puzzled about such gain.</span>
<span class="comment-copy">@V.k.n.s: The number seems unbelievable at first glance. I can't explain it from the code you posted. Running it myself (on CPython x64 3.7.1 on Ubuntu on Windows), I get ~4.5 s for single run, ~9 s each for NORMAL and Threaded, and ~6 s for Multiprocessing, which all seems reasonable. You'd have to give a lot more details on Python version and OS to even have a chance of guessing. My assumption would be that you're using a non-default timer that measures CPU time, not wall clock time, so the CPU time in the worker processes wouldn't be counted, but that's a guess not supported by your code.</span>
