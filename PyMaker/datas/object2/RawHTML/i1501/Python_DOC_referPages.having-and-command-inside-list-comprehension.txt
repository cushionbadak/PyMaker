<div class="post-text" itemprop="text">
<p>I do not understand what this source code does on line 3, <code>res = [...];</code> I tried to understand by testing out in python console with dummy variables and in the same syntax format like <code>res = ['raj' / 'esh'];</code> it gives error; if tested with <code>res = ['raj' and 'esh'];</code> I always return the second string <code>'esh'</code>, so I'm confused why use 'and' in the line. The syntax p/o also confuses me.</p>
<pre><code>def _get_files(parent, p, f, extensions):
    p = Path(p)  #.relative_to(parent)
    res = [p/o for o in f if not o.startswith('.')
           and (extensions is None or f'.{o.split(".")[-1].lower()}' in extensions)]
    return res
</code></pre>
<p>Argument <code>p</code> parsed is file path (string), argument f parsed is <code>f = [o.name for o in os.scandir(path) if o.is_file()]</code>; where path in this syntax line is file path. Could I get any help in understanding line 3?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>['raj' and 'esh']</code> is a one-element array, whose sole element is the result of <code>'raj'</code> and <code>'esh'</code>; <code>and</code> will evaluate to the first operand if falsy, and second operand otherwise. Since the first operand is not falsy, you get <code>'esh'</code>.</p>
<p>The line in the code is not a simple array, it is a <em>comprehension</em> - basically a short way to write a loop that constructs an array. The general syntax of a comprehension is</p>
<pre><code>[x for y in z if p]
</code></pre>
<p>where <code>y</code> will loop over all elements of the iterable <code>z</code>, check if <code>p</code> is true, and if it is, add <code>x</code> to the result. In your case, the condition (<code>p</code>) is</p>
<pre><code>not o.startswith('.')
and
(extensions is None or f'.{o.split(".")[-1].lower()}' in extensions)
</code></pre>
<p>For each element <code>o</code> of <code>f</code> (presumably an iterable of filenames), if this criterion is true, the result list will gain an element which consists of the concatenation of the path <code>p</code> with the filename <code>o</code> (<code>/</code> being a natural, if surprising at first sight, concatenation operator for paths.)</p>
<p>The problem is compounded by bad naming exhibited in the snippet. Consider this rewrite:</p>
<pre><code>def _hidden(filename):
    return filename.startswith('.')

def _extension(filename):
    return '.' + filename.split(".")[-1].lower()

def _extension_ok(filename, allowed_extensions=None):
    return allowed_extensions is None
           or _extension(filename) in allowed_extensions

def _get_files(parent, path, filenames, allowed_extensions=None):
    path = Path(path)
    good_paths = [path/filename for filename in filenames
                  if not _hidden(filename)
                     and _extension_ok(filename, allowed_extensions)]
    return good_paths
</code></pre>
<p>Now this reads almost like English, and is very clear about what it's doing (the only dodgy bit being <code>path/filename</code>, and almost anyone could guess what that might be just by analogy to UNIX paths).</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>.</p>
<pre><code>res = [p/o for o in f if not o.startswith('.')
       and (extensions is None or f'.{o.split(".")[-1].lower()}' in extensions)]
</code></pre>
<p>Is a syntactic shorthand for</p>
<pre><code>res = []
for o in f:
    if not o.startswith('.') and (extensions is None or f'.{o.split(".")[-1].lower()}' in extensions):
        res.append(p/o)
</code></pre>
</div>
<span class="comment-copy">Thank you!! I wasn't able to figure out it's an concatenation operator.</span>
<span class="comment-copy">Yeah, but let me reiterate, it is <i>just</i> for <code>Path</code> objects. Reading about <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer">pathlib</a> should clarify.</span>
<span class="comment-copy">Why one earth though someone thought that <code>in</code> check needed to be put in an f-string though... <i>sighs</i></span>
