<div class="post-text" itemprop="text">
<p>Is there any way to assign multiple values to a variable?
I am coding a solitaire game and using the values of ACE through KING for the cards. Is there any way to assign a variable the value of "ACE" and the value of "1" and so on, KING being "13"? This is not necessary, but would make the code a lot simpler and easier to create.</p>
<hr/>
<p>Thank you all, I currently have this:</p>
<pre><code>from collections import namedtuple
Card = namedtuple('Card', 'name value')
ace = Card(name="ACE", value=1)
</code></pre>
<p>When I do:  <code>print(ace)</code> I end up with:<code>Card(name="ACE", value=1)</code> and when I do ace.name or ace.value, I get the right outcome as well.</p>
<p>Is there any way to have the "ace" value in a list, and withdraw just the name?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a class or <a href="https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer"><code>namedtuple</code></a> to wrap both pieces of data</p>
<pre><code>from collections import namedtuple

Card = namedtuple('Card', 'name value')
ace = Card(name="ACE", value=1)
king = Card(name="King", value=13)
</code></pre>
<p>A custom class might be better because then you can implement logic like <code>card1 &lt; card2</code></p>
<blockquote>
<p>could I make the statement stackA + 1 == stackB true?</p>
</blockquote>
<p>Yes, if you implement an <code>__radd__</code> and <code>__eq__</code> methods on the Card type that accept adding other Cards to int types and comparing the results to other Card types </p>
</div>
<div class="post-text" itemprop="text">
<p>Use a dictionary.</p>
<pre><code>{'ace' :1, 'two' :2', ...etc}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a custom class:</p>
<pre><code>class Card(object):
    # fancier output
    s = {0:"hearts", 1:"diamonds", 2:"clubs", 3:"spades"}
    r = {i:v for i,v in enumerate( [ "Ace","2","3","4","5","6","7","8",
                                     "9","10","Jack","Queen","King"],1)}
    def __init__(self, suit,rank):
        self.suit = suit
        self.rank = rank

    def __str__(self):
        return "{} of {}".format(Card.r[self.rank],Card.s[self.suit])

    def __repr__(self):
        return str(self)

    def __lt__(self,other):
        return (self.suit,self.rank) &lt; (other.suit, other.rank)


    @classmethod
    def summ_hand(cls,hand):
        return sum ( 10 if card.rank &gt; 10 else card.rank for card in hand)


class Deck(object): 
    def __init__(self):
        self.cards = [Card(suit,rank) for suit in range(4) for rank in range(1,14)]


deck = Deck()

print( deck.cards )
</code></pre>
<p>Output:</p>
<pre><code>[Ace of hearts, 2 of hearts, 3 of hearts, 4 of hearts, 5 of hearts, 6 of hearts, 
 7 of hearts, 8 of hearts, 9 of hearts, 10 of hearts, Jack of hearts, Queen of hearts, 
 King of hearts, 
 Ace of diamonds, 2 of diamonds, 3 of diamonds,4 of diamonds,5 of diamonds, 6 of diamonds, 
 7 of diamonds, 8 of diamonds, 9 of diamonds, 10 of diamonds, Jack of diamonds, 
 Queen of diamonds, King of diamonds, 
 Ace of clubs, 2 of clubs, 3 of clubs, 4 of clubs, 5 of clubs, 6 of clubs, 7 of clubs, 
 8 of clubs, 9 of clubs, 10 of clubs, Jack of clubs, Queen of clubs, King of clubs, 
 Ace of spades, 2 of spades, 3 of spades, 4 of spades, 5 of spades, 6 of spades, 
 7 of spades, 8 of spades, 9 of spades, 10 of spades, Jack of spades, Queen of spades, 
 King of spades]
</code></pre>
<p>Providing <code>__lq__(self)</code> allows you to sort:</p>
<pre><code>hand = random.choices(deck.cards, k=7)
print(hand)
print(sorted(hand))

print( Card.summ_hand([Card(0,9),Card(0,11),Card(0,13)]))
</code></pre>
<p>Output:</p>
<pre><code># as given by choices
[Ace of hearts, Ace of spades, Queen of diamonds, 9 of spades, 
 King of hearts, Ace of spades, 3 of diamonds]

 # sorted
[Ace of hearts, King of hearts, 3 of diamonds, Queen of diamonds,
 Ace of spades, Ace of spades, 9 of spades]

29  # summ_hand for 9,Queen,King, 
</code></pre>
</div>
<span class="comment-copy">I believe you're looking for the <code>dictionary</code> data type: <a href="https://docs.python.org/3/library/stdtypes.html#typesmapping" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#typesmapping</a></span>
<span class="comment-copy">cricket_007 if i did this would i be able to use the value "ACE" and the value "1" seperately?</span>
<span class="comment-copy">Yes. <code>ace.name</code> or <code>ace[0]</code>, as mentioned in the link to the docs will produce <code>"ACE"</code></span>
<span class="comment-copy">how would i recall the value idea from the namedtuple?</span>
<span class="comment-copy">Same way, different field/index.</span>
<span class="comment-copy">If i had a list: listA = [ace, "fake", "fake"] ... When I do "print(listA[0])", I get "Card(name="ACE", value=1)"...   Is there anyway to just recall the name or just the value?</span>
