<div class="post-text" itemprop="text">
<p>I am trying to randomly iterate over a deck of cards with no repetition.</p>
<p>Following is the code:</p>
<pre><code>import random

class Cards:

    # Where prefix d is Diamonds, h is Hearts, s is Spades and c is Clubs
    total_cards = [{2: 'd2', 3: 'd3', 4: 'd4', 5: 'd5', 6: 'd6', 7: 'd7', 8: 'd8', 9: 'd9', 10: 'd10', 11: 'dJack',
              12: 'dQueen', 13: 'dKing', 14: 'dAce'},
             {2: 'h2', 3: 'h3', 4: 'h4', 5: 'h5', 6: 'h6', 7: 'h7', 8: 'h8', 9: 'h9', 10: 'h10', 11: 'hJack',
              12: 'hQueen', 13: 'hKing', 14: 'hAce'},
             {2: 's2', 3: 's3', 4: 's4', 5: 's5', 6: 's6', 7: 's7', 8: 's8', 9: 's9', 10: 's10', 11: 'sJack',
              12: 'sQueen', 13: 'sKing', 14: 'sAce'},
             {2: 'c2', 3: 'c3', 4: 'c4', 5: 'c5', 6: 'c6', 7: 'c7', 8: 'c8', 9: 'c9', 10: 'c10', 11: 'cJack',
              12: 'cQueen', 13: 'cKing', 14: 'cAce'}]

    def random_pick(self): # Method to randomly pick a card from the deck

        choice = random.choice(random.choice(self.total_cards))

        for v in self.total_cards:    # to retrieve the corresponding `key` for `choice` 
            for i in v.values():
                if choice == i:
                    k = v[i]
                    v.pop(k)

        print(choice)    # To print the random card picked from the deck
        print(self.total_cards)    # To print the updated Deck after picking the card


c = Cards()
c.random_pick()
</code></pre>
<p>The idea that I am trying to work with is, as soon as the card is picked, it should be removed from the deck.</p>
<p>This is the error :</p>
<pre><code>Traceback (most recent call last):
  File "F:/Blackjack/Base/Cards.py", line 30, in &lt;module&gt;
    c.random_pick()
  File "F:/Blackjack/Base/Cards.py", line 17, in random_pick
    choice = random.choice(random.choice(self.total_cards))
  File "C:\Users\Python\Python37-32\lib\random.py", line 262, in choice
    return seq[i]
KeyError: 0
</code></pre>
<p>From my understanding, <code>KeyError</code> is an exception raised when a mapping (dictionary) key is not found in the set of existing keys. But my <strong>IF LOOP</strong> is <strong>TRUE</strong> only when the condition <code>choice == i</code> and only then should the pop() be initiated.</p>
<p>I have tried the above code without the pop() method in the code and the code works just fine, generating random cards after every run.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you try your code several times, you'll notice that you won't get this error every time. Sometimes it'll get past the line</p>
<pre><code>        choice = random.choice(random.choice(self.total_cards))
</code></pre>
<p>and hit another error later in the code.</p>
<p>So what's going on? I assume that <code>random.choice(self.total_cards)</code> works fine and returns one of the four decks from the <code>total_cards</code> list. You represent that deck as a dictionary.</p>
<p>Let's see what <code>random.choice</code> does with dictionaries on a simpler example:</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt;
&gt;&gt;&gt; random.seed(0)  # for reproducability
&gt;&gt;&gt; random.choice({1:2, 3:4})
2
</code></pre>
<p>Huh, strange, it returned one of the values. I'd have expected one of the keys, like when iterating over a dictionary without calling <code>.items()</code> nor <code>.values()</code>.</p>
<pre><code>&gt;&gt;&gt; [i for i in {1:2, 3:4}]
[1, 3]
</code></pre>
<p>Let's try again:</p>
<pre><code>&gt;&gt;&gt; random.seed(42)  # for reproducability
&gt;&gt;&gt; random.choice({1:2, 3:4})
KeyError: 0
</code></pre>
<p>Strange, isn't it? <code>0</code> is neither among the values nor among the keys here. Where did it come from?</p>
<p>Let's see how <code>random.choice</code> is implemented. In IPython I can get its source code like this:</p>
<pre><code>In [1]: import random

In [2]: random.choice??
</code></pre>
<p>To get the code on your system, you can also look at the file mentioned in the error message you got: <code>C:\Users\Python\Python37-32\lib\random.py</code> around line 262.</p>
<p>On Python 3.6.6 (the version on my system) the source code is:</p>
<pre><code>    def choice(self, seq):
        """Choose a random element from a non-empty sequence."""
        try:
            i = self._randbelow(len(seq))
        except ValueError:
            raise IndexError('Cannot choose from an empty sequence') from None
        return seq[i]
</code></pre>
<p>private method <code>random._randbelow</code> has the description</p>
<blockquote>
<p>Return a random int in the range [0,n).  Raises ValueError if n==0.</p>
</blockquote>
<p>While this works fine for sequences (like lists, sets or tuples), I guess you can see why it won't do the right thing at all when <code>seq</code> happens to be a dictionary (or any other mapping):</p>
<p>It takes</p>
<blockquote class="spoiler">
<p> the length of the sequence (<code>len(seq)</code>)</p>
</blockquote>
<p>(which works fine for dictionaries, too) and then</p>
<blockquote class="spoiler">
<p> generates a random integer between 0 (inclusive) and that length (exclusive) (that's what <code>self._randbelow</code> does)</p>
</blockquote>
<p>so this will be the</p>
<blockquote class="spoiler">
<p> 0-indexed position of a random element of the sequence</p>
</blockquote>
<p>and then it</p>
<blockquote class="spoiler">
<p> uses that random integer to index the sequence (<code>seq[i]</code>) and returns that value (<code>return</code>)</p>
</blockquote>
<p>which doesn't work on dictionaries as intended because they are</p>
<blockquote class="spoiler">
<p> indexed by their keys.</p>
</blockquote>
<p>That's also why we sometimes didn't get the error and instead one of the dictionary values was returned by <code>random.choice</code>: When the integer intended as a</p>
<blockquote class="spoiler">
<p> random position</p>
</blockquote>
<p>also happened to be one of the keys of the dictionary, it would just return the corresponding value. If it happens to be none of our keys (which b.t.w. would always be the case, if all the keys were non-integers, e.g. strings) then a <code>KeyError</code> occurs.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quick answer: <a href="https://docs.python.org/3/library/random.html?highlight=random#random.choice" rel="nofollow noreferrer">random.choice()</a> is meant for sequences i.e. lists, as it says in documentation. </p>
<p>Long answer: See <a href="https://stackoverflow.com/a/53457518/674064">das-g's answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think a list would be better, here is how I would do it:</p>
<pre><code>from random import shuffle

class Cards:

def __init__(self): #example deck with just some cards
    self.total_cards = ['c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'c10']
    shuffle(self.total_cards)  #shuffle the deck of cards

def random_pick(self): #Method to randomly pick a card from the deck

    print(self.total_cards[len(self.total_cards)-1])    #To print the last card from your deck, which will be removed by pop() command
    self.total_cards.pop()
    print(self.total_cards)    #To print the updated Deck after pop() the last card


c = Cards()
for _ in range(3): # picking 3 random cards for demostration
    c.random_pick()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try my solution:</p>
<pre><code>import random
import numpy as np

class Cards:

    # Where prefix d is Diamonds, h is Hearts, s is Spades and c is Clubs
    total_cards = [{2: 'd2', 3: 'd3', 4: 'd4', 5: 'd5', 6: 'd6', 7: 'd7', 8: 'd8', 9: 'd9', 10: 'd10', 11: 'dJack',
          12: 'dQueen', 13: 'dKing', 14: 'dAce'},
         {2: 'h2', 3: 'h3', 4: 'h4', 5: 'h5', 6: 'h6', 7: 'h7', 8: 'h8', 9: 'h9', 10: 'h10', 11: 'hJack',
          12: 'hQueen', 13: 'hKing', 14: 'hAce'},
         {2: 's2', 3: 's3', 4: 's4', 5: 's5', 6: 's6', 7: 's7', 8: 's8', 9: 's9', 10: 's10', 11: 'sJack',
          12: 'sQueen', 13: 'sKing', 14: 'sAce'},
         {2: 'c2', 3: 'c3', 4: 'c4', 5: 'c5', 6: 'c6', 7: 'c7', 8: 'c8', 9: 'c9', 10: 'c10', 11: 'cJack',
          12: 'cQueen', 13: 'cKing', 14: 'cAce'}]
    _showed = 0

    def __init__(self):
        self._shuffle_cards()
        self.pointers = [0 for _ in range(len(self.total_cards))]

    def _shuffle_cards(self):
        for i, v in enumerate(self.total_cards):
            temp = list(v.items())
            self._showed += 1
            np.random.shuffle(temp)
            self.total_cards[i] = temp

    def random_pick(self):
        choice = random.choice(range(len(self.total_cards)))
        while self.pointers[choice] &gt;= len(self.total_cards[choice]) and self._showed &gt; 0: 
            choice = random.choice(self.total_cards)
            self.pointers[choice] += 1
        if self._showed == 0:
            print('Nothing cards to show')
        else:
            self._showed -= 1
            print(self.total_cards[choice][self.pointers[choice]][1])


c = Cards()
c.random_pick()
</code></pre>
</div>
<span class="comment-copy">It's way easier to <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow noreferrer">shuffle</a> the deck instead, like you do in a real card game.</span>
<span class="comment-copy">Why don't you store all the cards in an array and then simply shuffle the array using <code>random.shuffle(array)</code>? Traversal over the shuffled array will be same as randomly iterating over array. Is there any specific reason you want to go for this data-structure?</span>
<span class="comment-copy">@LavishKothari hi, i know that arrays would do the trick but i am trying to teach myself OOP with DS with an example. Its not mandatory to use DS but that's the goal i started with.</span>
<span class="comment-copy">@user2357112 but that still presents a possibility that an already used card might still reappear. I have to be able to remove the card once it is used</span>
<span class="comment-copy">@404BrainNotFound: Shuffle a list, then draw cards off the end with <code>pop()</code>, or iterate with <code>for</code>. No repetition.</span>
<span class="comment-copy">I would add also a sentence like "Look in File "C:\Users\Python\Python37-32\lib\random.py", line 262, as python itself is implicitly suggesting you, to see source code of python 3.7"</span>
<span class="comment-copy">Good idea @myfirstAnswer. Done.</span>
<span class="comment-copy">I also looked at source code and tried to write some answer like yours, but you were faster! so I abandoned my answer :) Good answer!</span>
<span class="comment-copy">Well, for a novice, it might not be obvious that dictionaries aren't sequences. But +1 for referring to the documentation!</span>
<span class="comment-copy">haha :D, thanks!</span>
<span class="comment-copy">You don't need to shuffle the deck every time. Shuffling it once up front is enough.</span>
<span class="comment-copy">True, maybe i could put it in the constructor, thanks for the tip</span>
