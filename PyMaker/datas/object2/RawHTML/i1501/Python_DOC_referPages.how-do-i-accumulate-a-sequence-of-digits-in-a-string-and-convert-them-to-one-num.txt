<div class="post-text" itemprop="text">
<p>I need to decode a string 'a3b2' into 'aaabb'. The problem is when the numbers are double,triple digits. E.g. 'a10b3' should detect that the number is <strong>not</strong> 1 but 10.</p>
<p>I need to start accumulating digits.</p>
<pre><code>a = "a12345t5i6o2r43e2"
for i in range(0, len(a)-1):
  if a[i].isdigit() is False: 
   #once i see a letter, i launch a while loop to check how long a digit streak

   #after it can be - it's 2,3,4,5 digit number etc
    print(a[i])
    current_digit_streak = ''
    counter = i+1
    while a[counter].isdigit():  #this gives index out of range error!
      current_digit_streak += a[counter]
      counter+=1
</code></pre>
<p>If I change the while loop to this:</p>
<pre><code>while a[counter].isdigit() and counter &lt; ( len(a)-1)
</code></pre>
<p>it does work but omits the last letter.
I should not use regex, only loops.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>for</code> loop and <code>while</code> loop use different indices for obtaining tokens, which is why the characters consumed by the <code>while</code> loop are processed once again by the <code>for</code> loop. You should instead use a <code>while</code> loop with a single index to parse the tokens:</p>
<pre><code>a = "a12t5i6o2r11e2"
i = 0
char = repeat = output = ''
while i &lt; len(a):
    token = a[i]
    if token.isdigit():
        repeat += token
    if char and repeat and (not token.isdigit() or i == len(a) - 1):
        output += char * int(repeat)
        char = repeat = ''
    if not token.isdigit():
        char += token
    i += 1
print(output)
</code></pre>
<p>This outputs:</p>
<pre><code>aaaaaaaaaaaatttttiiiiiioorrrrrrrrrrree
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Regex is a good fit here.</p>
<pre><code>import re
pat = re.compile(r"""
(\w)       # a word character, followed by...
(\d+)      # one or more digits""", flags=re.X)

s = "a12345t5i6o2r43e2"
groups = pat.findall(s)
# [('a', '12345'), ('t', '5'), ('i', '6'), ('o', '2'), ('r', '43'), ('e', '2')]

result = ''.join([lett*int(count) for lett, count in groups])
</code></pre>
<hr/>
<p>Since you can't use regex for some unbeknownst reason, I recommend a recursive function to split the string into parts.</p>
<pre><code>import itertools

def split_into_groups(s):
    if not s:
        return []
    lett, *rest = s
    count, rest = int(itertools.takewhile(str.isdigit, rest)), itertools.dropwhile(str.isdigit, rest)
    return [(lett, count)] + split_into_groups(rest)

s = "a12345t5i6o2r43e2"
groups = split_into_groups(s)

result = ''.join([lett*count for lett, count in groups])
</code></pre>
<p>or, using a more generic (and Functional-derived) pattern:</p>
<pre><code>def unfold(f, x):
    while True:
        v, x = f(x)
        yield v

def get_group(s):
    if not s:
        raise StopIteration()
    lett, *rest = s
    count, rest = int(itertools.takewhile(str.isdigit, rest)), itertools.dropwhile(str.isdigit, rest)
    return lett*count, rest

s = "a12345t5i6o2r43e2"
result = ''.join(unfold(get_group, s))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a>:</p>
<pre><code>from itertools import groupby

text = 'a12345t5i6o2r43e2'

groups = [''.join(group) for _, group in groupby(text, key=str.isdigit)]
result = list(zip(groups[::2], groups[1::2]))

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[('a', '12345'), ('t', '5'), ('i', '6'), ('o', '2'), ('r', '43'), ('e', '2')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One of possible variant</p>
<pre><code>import re


def main():
    a = "a10t5i6o2r43e2"
    items = re.findall(r'(\w)(\d+)', a)
    return ''.join([letter*int(count) for letter, count in items])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a functional solution using the <code>itertools</code> module. You can use the <code>grouper</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe from the <code>itertools</code> docs</a> or import via 3rd party <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper" rel="nofollow noreferrer"><code>more_itertools.grouper</code></a>:</p>
<pre><code>from itertools import groupby
from more_itertools import grouper
from operator import itemgetter

a = "a12t5i6o2r11e2"

it = map(''.join, map(itemgetter(1), groupby(a, key=str.isdigit)))

res = ''.join(char*int(count) for char, count in grouper(it, 2))

'aaaaaaaaaaaatttttiiiiiioorrrrrrrrrrree'
</code></pre>
<p>For reference, the <code>grouper</code> recipe:</p>
<pre><code>def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is kind of lengthy, but it works and uses loops as you requested:</p>
<pre><code>def parse_segment(string, index):
    for i, letter in enumerate(string[index+1:]):
        if letter.isalpha():
            return string[index+1:i+index+1]
        if i + index + 1 &gt;= len(string) - 1:
            return string[index+1:]

def segment_string(string):
    num_list = []
    for index, letter in enumerate(string):
        if letter.isalpha():
            num_list.append({'letter': letter, 'number': int(parse_segment(string,  index))})
    return num_list

def list_2_string(list):
    ret_string = ''
    for row in list:
        ret_string += row['letter'] * row['number']
    return ret_string

a = "a12345t5i6o2r43e2"
segmented_string = segment_string(a)
result_string = list_2_string(segmented_string)
print(result_string)
</code></pre>
</div>
<span class="comment-copy">You say you should only use loops, but in your code example you also use conditionals, arithmetic, and assignment! /s</span>
<span class="comment-copy">@AdamSmith, sorry :) I mean i should use loops and other BASIC structures as you mentioned, just not those itertools, groupby etc.</span>
<span class="comment-copy">regex is a very basic structure. I think it's necessary to actually see the problem statement of your homework.</span>
<span class="comment-copy">hmmm this 2nd condition is what I did not know... if chars are empty -&gt;false? if chars are not empty , simply evaluating them as-is makes them True?!</span>
<span class="comment-copy">Yes, in Python an empty string is considered <code>False</code>, while a non-empty string is considered <code>True</code>.</span>
<span class="comment-copy">i can't use regex, it should be loops used here</span>
<span class="comment-copy">@ERJAN Regex is the correct tool for the job. Using a loop is incorrect here.</span>
<span class="comment-copy">@ERJAN if you have any kind of restrictions on the thing you're asking a question about, you have to include what those restrictions are. Otherwise people are going to answer the question the correct way, not the "homework" way.</span>
<span class="comment-copy">@RandomDavis, sorry you are right, i will include it now...</span>
<span class="comment-copy">thx u for showing advanced python, but i should use loops here</span>
<span class="comment-copy">thx u , but i should find a way to use loops</span>
<span class="comment-copy">The <code>+?</code> quantifier doesn't make much sense after <code>\w</code>, because by specification every word character must be followed by digits.</span>
<span class="comment-copy">Good point! Thanks, I updated the answer</span>
