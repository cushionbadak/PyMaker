<div class="post-text" itemprop="text">
<p>I have an app written in Electron/Typescript and I need to validate that a user input is a valid Python expression.</p>
<p>For example: </p>
<ol>
<li><code>cos(PARAMPOLY.engineeringValue1) + cos(PARAMPOLY.engineeringValue2)</code></li>
<li><code>x + y + z</code></li>
</ol>
<p>I have no way of producing the correct type and value of the operands for these expressions. I need something which parses the expression and tells me if there is an expression error.</p>
<p>The Python <code>eval()</code> function parses and evaluates the expression. I need only a parsing.</p>
<p>Is there something for that need?</p>
</div>
<div class="post-text" itemprop="text">
<p>You may want <em>full compilation</em> into a full Python code object, or you can just parse into an abstract syntax tree. You can use the <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow noreferrer"><code>compile()</code> function</a> to achieve either, or just use <a href="https://docs.python.org/3/library/ast.html#ast.parse" rel="nofollow noreferrer"><code>ast.parse()</code></a> to produce the tree.</p>
<p>Parsing into an AST tokenizes the input and outputs a tree of syntax objects that you can then further analyse or transform. Compiling into bytecode goes one step further, using that AST to create a Python code object that you can optionally execute with either <code>eval()</code> or the <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec()</code> function</a>; note that the latter always returns <code>None</code> and is probably not the best choice to evaluate an expression code object.</p>
<p><code>eval(string)</code> uses <code>eval(compile(string, "&lt;stdin&gt;", "eval"))</code> to compile a string argument to a code object, then execute it, so <code>compile(string, "&lt;stdin&gt;", "eval")</code> would give you the same result without execution.</p>
<p>Use <code>"eval"</code> as the mode if only an <em>expression</em> is valid, or <code>"exec"</code> if full Python <em>statements</em> are to be accepted. <code>compile()</code> (and <code>ast.parse()</code>) raises a  <code>SyntaxError</code> exception if the input is not a valid Python expression (<code>"eval"</code>) or not valid statements (<code>"exec"</code>).</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; example1 = "cos(PARAMPOLY.engineeringValue1) + cos(PARAMPOLY.engineeringValue2)"
&gt;&gt;&gt; example2 = "x + y + z"
&gt;&gt;&gt; compile(example1, "&lt;stdin&gt;", "eval")
&lt;code object &lt;module&gt; at 0x111c2eae0, file "&lt;stdin&gt;", line 1&gt;
&gt;&gt;&gt; compile(example2, "&lt;stdin&gt;", "eval")
&lt;code object &lt;module&gt; at 0x111c2e540, file "&lt;stdin&gt;", line 1&gt;
&gt;&gt;&gt; result2 = _
&gt;&gt;&gt; eval(result2, {"x": 42, "y": 81, "z": 117})
240
&gt;&gt;&gt; compile("not a valid expression", "&lt;stdin&gt;", "eval")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1
    not a valid expression
              ^
SyntaxError: invalid syntax
</code></pre>
<p>Parsing to an AST would let you discover what names the code expects to be able to access; you can collect names by looking for <code>Name</code> nodes:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; tree1 = ast.parse(example1)
&gt;&gt;&gt; tree2 = ast.parse(example2)
&gt;&gt;&gt; ast.dump(tree2.body[0])
"Expr(value=BinOp(left=Call(func=Name(id='cos', ctx=Load()), args=[Attribute(value=Name(id='PARAMPOLY', ctx=Load()), attr='engineeringValue1', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='cos', ctx=Load()), args=[Attribute(value=Name(id='PARAMPOLY', ctx=Load()), attr='engineeringValue2', ctx=Load())], keywords=[])))"
&gt;&gt;&gt; ast.dump(tree2.body[0])
"Expr(value=BinOp(left=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Name(id='y', ctx=Load())), op=Add(), right=Name(id='z', ctx=Load())))"
&gt;&gt;&gt; {node.id for node in ast.walk(tree1) if isinstance(node, ast.Name)}
{'cos', 'PARAMPOLY'}
&gt;&gt;&gt; {node.id for node in ast.walk(tree2) if isinstance(node, ast.Name)}
{'x', 'z', 'y'}
</code></pre>
<p>Note that the above ignored context, so the <code>PARAMPONLY</code> attribute name is listed too. Write a <a href="https://docs.python.org/3/library/ast.html#ast.NodeVisitor" rel="nofollow noreferrer"><code>ast.NodeVisitor</code> subclass</a> if you need to process a syntax tree with more context.</p>
</div>
<span class="comment-copy">Thanks a lot for your explanation.  To go further, imagine I expect math vocabulary items like "cos" and "sin" in the expression provided by the user and I want to check it.  ex :  1 - IN : cos(a) + sin(b) OUT : OK 2 - IN : cos(a,b) OUT NOK 3 - IN fake(a) OUT NOK 4 - IN tan(a) OUT NOK   As I undertand, parsing is not enough, I need to use eval expression but I don't  know how to manage operand.  <code>from math import * print(eval('cos(a) + sin(b)', {'cos': cos, 'sin': sin}))	</code>     Do you have any idea ?</span>
<span class="comment-copy">@Julieng31: if you need to evaluate mathematical expressions, then see <a href="//stackoverflow.com/q/2371436">Evaluating a mathematical expression in a string</a>, where one of the answers led to <a href="https://github.com/danthedeckie/simpleeval" rel="nofollow noreferrer">github.com/danthedeckie/simpleeval</a>, which is, at the very least, a starting point for what you want to do. The latter uses the AST to then drive expression execution in a safe and controlled way.</span>
<span class="comment-copy">@Julieng31: at any rate, something like <code>cos(a b)</code> would be parsed into a <code>Call()</code> expression, with <code>cos</code> as the name of the callable, with two arguments. You can then use something like the <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer">function signature</a> or information you stored up front to see if that call could work at all (<code>len(inspect.signature(math.cos).parameters)</code> is <code>1</code>, so no, that call would fail).</span>
