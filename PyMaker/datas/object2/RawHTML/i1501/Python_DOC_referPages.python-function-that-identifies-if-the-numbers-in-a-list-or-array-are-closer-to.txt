<div class="post-text" itemprop="text">
<p>I have a <code>numpy</code> array of numbers. Below is an example:</p>
<pre><code>[[-2.10044520e-04  1.72314372e-04  1.77235336e-04 -1.06613465e-04
6.76617611e-07  2.71623057e-03 -3.32789944e-05  1.44899758e-05
5.79249863e-05  4.06502549e-04 -1.35823707e-05 -4.13955189e-04
5.29862793e-05 -1.98286005e-04 -2.22829175e-04 -8.88758230e-04
5.62228710e-05  1.36249752e-05 -2.00474996e-05 -2.10090068e-05
1.00007518e+00  1.00007569e+00 -4.44597417e-05 -2.93724453e-04
1.00007513e+00  1.00007496e+00  1.00007532e+00 -1.22357142e-03
3.27903892e-06  1.00007592e+00  1.00007468e+00  1.00007558e+00
2.09869172e-05 -1.97610235e-05  1.00007529e+00  1.00007530e+00
1.00007503e+00 -2.68725642e-05 -3.00372853e-03  1.00007386e+00
1.00007443e+00  1.00007388e+00  5.86993822e-05 -8.69989983e-06
1.00007590e+00  1.00007488e+00  1.00007515e+00  8.81850779e-04
2.03875532e-05  1.00007480e+00  1.00007425e+00  1.00007517e+00
-2.44678912e-05 -4.36556267e-08  1.00007436e+00  1.00007558e+00
1.00007571e+00 -5.42990711e-04  1.45517859e-04  1.00007522e+00
1.00007469e+00  1.00007575e+00 -2.52271817e-05 -7.46339417e-05
1.00007427e+00]]
</code></pre>
<p>I want to know if each of the numbers is closer to 0 or 1. Is there a function in Python that could do it or do I have to do it manually?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.rint.html" rel="noreferrer"><code>numpy.rint</code></a> is a ufunc that will round the elements of an array to the <em>nearest</em> integer.</p>
<pre><code>&gt;&gt;&gt; a = np.arange(0, 1.1, 0.1)
&gt;&gt;&gt; a
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])
&gt;&gt;&gt; np.rint(a)
array([0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 1.])
</code></pre>
<blockquote>
<p>What if the numbers don't have to be between 0 and 1?</p>
</blockquote>
<p>In that case, I'd use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" rel="noreferrer"><code>numpy.where</code></a>.</p>
<pre><code>&gt;&gt;&gt; a = np.arange(-2, 2.1, 0.1)
&gt;&gt;&gt; a
array([-2.00000000e+00, -1.90000000e+00, -1.80000000e+00, -1.70000000e+00,
       -1.60000000e+00, -1.50000000e+00, -1.40000000e+00, -1.30000000e+00,
       -1.20000000e+00, -1.10000000e+00, -1.00000000e+00, -9.00000000e-01,
       -8.00000000e-01, -7.00000000e-01, -6.00000000e-01, -5.00000000e-01,
       -4.00000000e-01, -3.00000000e-01, -2.00000000e-01, -1.00000000e-01,
        1.77635684e-15,  1.00000000e-01,  2.00000000e-01,  3.00000000e-01,
        4.00000000e-01,  5.00000000e-01,  6.00000000e-01,  7.00000000e-01,
        8.00000000e-01,  9.00000000e-01,  1.00000000e+00,  1.10000000e+00,
        1.20000000e+00,  1.30000000e+00,  1.40000000e+00,  1.50000000e+00,
        1.60000000e+00,  1.70000000e+00,  1.80000000e+00,  1.90000000e+00,
        2.00000000e+00])
&gt;&gt;&gt; np.where(a &lt;= 0.5, 0, 1)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A straightforward way:</p>
<pre><code>lst=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]

closerTo1 = [x &gt;= 0.5 for x in lst]
</code></pre>
<p>Or you can use np:</p>
<pre><code>import numpy as np
lst=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]

arr = np.array(lst)
closerTo1 = arr &gt;= 0.5
</code></pre>
<p>Note that <code>&gt;= 0.5</code> can be changed to <code>&gt; 0.5</code>, however you choose to treat it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one simple way to do this:</p>
<pre><code>&gt;&gt;&gt; a = np.arange(-2, 2.1, 0.1)
&gt;&gt;&gt; (a &gt;= .5).astype(np.float)
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
        0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,
        1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,
        1.,  1.])
</code></pre>
<p>(Change <code>np.float</code> to <code>np.int</code> if you want integers.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.where.html" rel="noreferrer">numpy.where</a>:</p>
<pre><code>import numpy as np

arr = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 2.0])
result = np.where(arr &gt;= 0.5, 1, 0)
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[0 0 0 0 1 1 1 1 1 1]
</code></pre>
<p>Note that this will return 1 for numbers above 1 (for instance 2).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functions.html#abs" rel="nofollow noreferrer"><code>abs()</code></a> to measure distances between your number and <code>0</code> and <code>1</code> and check which on is shorter.</p>
<pre><code>x = [[-2.10044520e-04,  1.72314372e-04,  1.77235336e-04, -1.06613465e-04,
6.76617611e-07,  2.71623057e-03, -3.32789944e-05,  1.44899758e-05,
5.79249863e-05,  4.06502549e-04, -1.35823707e-05, -4.13955189e-04,
5.29862793e-05, -1.98286005e-04, -2.22829175e-04, -8.88758230e-04,
5.62228710e-05,  1.36249752e-05, -2.00474996e-05, -2.10090068e-05,
1.00007518e+00,  1.00007569e+00, -4.44597417e-05, -2.93724453e-04,
1.00007513e+00,  1.00007496e+00,  1.00007532e+00, -1.22357142e-03,
3.27903892e-06,  1.00007592e+00,  1.00007468e+00,  1.00007558e+00,
2.09869172e-05, -1.97610235e-05,  1.00007529e+00,  1.00007530e+00,
1.00007503e+00, -2.68725642e-05, -3.00372853e-03,  1.00007386e+00,
1.00007443e+00,  1.00007388e+00,  5.86993822e-05, -8.69989983e-06,
1.00007590e+00,  1.00007488e+00,  1.00007515e+00,  8.81850779e-04,
2.03875532e-05,  1.00007480e+00,  1.00007425e+00,  1.00007517e+00,
-2.44678912e-05, -4.36556267e-08,  1.00007436e+00,  1.00007558e+00,
1.00007571e+00, -5.42990711e-04,  1.45517859e-04,  1.00007522e+00,
1.00007469e+00,  1.00007575e+00, -2.52271817e-05, -7.46339417e-05,
1.00007427e+00]]

rounded_x = [0 if abs(i) &lt; abs(1-i) else 1 for i in x[0]]
print(rounded_x)
</code></pre>
<p>Output:</p>
<pre><code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple generalization for any arbitrary numbers <code>a</code> and <code>b</code>, instead of just <code>0</code> and <code>1</code>:</p>
<pre><code>def closerab(l, a=0, b=1):
    l = np.asarray(l)
    boolarr = (np.abs(l - b) &gt; np.abs(l - a))

    # returns two lists of indices, one for numbers closer to a and one for numbers closer to b
    return boolarr.nonzero()[0], (boolarr==0).nonzero()[0]
</code></pre>
<p>This'll return two lists, one with the indices of the numbers closer to <code>a</code>, and one with the indices of the numbers closer to <code>b</code>.</p>
<p>Testing it out:</p>
<pre><code>l = [
-2.10044520e-04, 1.72314372e-04, 1.77235336e-04, 1.06613465e-04,
6.76617611e-07, 2.71623057e-03, 3.32789944e-05, 1.44899758e-05,
5.79249863e-05, 4.06502549e-04, 1.35823707e-05, 4.13955189e-04,
5.29862793e-05, 1.98286005e-04, 2.22829175e-04, 8.88758230e-04,
5.62228710e-05, 1.36249752e-05, 2.00474996e-05, 2.10090068e-05,
1.00007518e+00, 1.00007569e+00, 4.44597417e-05, 2.93724453e-04,
1.00007513e+00, 1.00007496e+00, 1.00007532e+00, 1.22357142e-03,
3.27903892e-06, 1.00007592e+00, 1.00007468e+00, 1.00007558e+00,
2.09869172e-05, 1.97610235e-05, 1.00007529e+00, 1.00007530e+00,
1.00007503e+00, 2.68725642e-05, 3.00372853e-03, 1.00007386e+00,
1.00007443e+00, 1.00007388e+00, 5.86993822e-05, 8.69989983e-06,
1.00007590e+00, 1.00007488e+00, 1.00007515e+00, 8.81850779e-04,
2.03875532e-05, 1.00007480e+00, 1.00007425e+00, 1.00007517e+00,
-2.44678912e-05, 4.36556267e-08, 1.00007436e+00, 1.00007558e+00,
1.00007571e+00, 5.42990711e-04, 1.45517859e-04, 1.00007522e+00,
1.00007469e+00, 1.00007575e+00, 2.52271817e-05, 7.46339417e-05,
1.00007427e+00
]

print(closerab(l, 0, 1))
</code></pre>
<p>This outputs:</p>
<pre><code>(array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 22, 23, 27, 28, 32, 33, 37, 38, 42, 43, 47, 48, 52, 53,
        57, 58, 62, 63]),
 array([20, 21, 24, 25, 26, 29, 30, 31, 34, 35, 36, 39, 40, 41, 44, 45, 46,
        49, 50, 51, 54, 55, 56, 59, 60, 61, 64]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively, you can use a ternary operator.</p>
<pre><code>x = [-0.2, 0.1, 1.1, 0.75, 0.4, 0.2, 1.5, 0.9]

a = 0
b = 1

[a if i &lt;= (a+b)/2 else b for i in x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the Python built-in function docs <a href="https://docs.python.org/2/library/functions.html#round" rel="nofollow noreferrer"><code>round(number[, ndigits])</code></a>:</p>
<blockquote>
<p>Return the floating point value <em>number</em> rounded to <em>ndigits</em> digits after the decimal point. If <em>ndigits</em> is omitted, it defaults to zero. The result is a floating point number. Values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done away from 0 (so, for example, <code>round(0.5)</code> is <code>1.0</code> and <code>round(-0.5)</code> is <code>-1.0</code>).</p>
</blockquote>
<p>For numpy arrays in particular, you can use the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.round_.html" rel="nofollow noreferrer"><code>numpy.round_</code></a> function.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>your_list=[[-2.10044520e-04, 1.72314372e-04, 1.77235336e-04, 1.06613465e-04,
6.76617611e-07, 2.71623057e-03, 3.32789944e-05, 1.44899758e-05,
5.79249863e-05, 4.06502549e-04, 1.35823707e-05, 4.13955189e-04,
5.29862793e-05, 1.98286005e-04, 2.22829175e-04, 8.88758230e-04,
5.62228710e-05, 1.36249752e-05, 2.00474996e-05, 2.10090068e-05,
1.00007518e+00, 1.00007569e+00, 4.44597417e-05, 2.93724453e-04,
1.00007513e+00, 1.00007496e+00, 1.00007532e+00, 1.22357142e-03,
3.27903892e-06, 1.00007592e+00, 1.00007468e+00, 1.00007558e+00,
2.09869172e-05, 1.97610235e-05, 1.00007529e+00, 1.00007530e+00,
1.00007503e+00, 2.68725642e-05, 3.00372853e-03, 1.00007386e+00,
1.00007443e+00, 1.00007388e+00, 5.86993822e-05, 8.69989983e-06,
1.00007590e+00, 1.00007488e+00, 1.00007515e+00, 8.81850779e-04,
2.03875532e-05, 1.00007480e+00, 1.00007425e+00, 1.00007517e+00,
-2.44678912e-05, 4.36556267e-08, 1.00007436e+00, 1.00007558e+00,
1.00007571e+00, 5.42990711e-04, 1.45517859e-04, 1.00007522e+00,
1.00007469e+00, 1.00007575e+00, 2.52271817e-05, 7.46339417e-05,
1.00007427e+00]]

close_to_one_or_zero=[1 if x &gt; 0.5 else 0 for x in your_list[0]]
close_to_one_or_zero
    [0, 0, 0, 0, 0,....... 1, 1, 1, 0, 0, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>round</code>:    </p>
<pre><code>[round(i) for i in [0.1,0.2,0.3,0.8,0.9]]
</code></pre>
</div>
<span class="comment-copy">You may want to take a look at <code>numpy.rint</code>. Although it returns floats and not ints, for whatever reason, but you can cast the result to int after applying this function.</span>
<span class="comment-copy">@ForceBru: It returns floats because float to int conversion can overflow.</span>
<span class="comment-copy">What behaviour do you want for <code>0.5</code>?</span>
<span class="comment-copy">@ForceBru or even just (x &gt;= 0.5).</span>
<span class="comment-copy">What if my numbers is  above 2?</span>
<span class="comment-copy">@Eliyah then <code>np.where</code>!</span>
<span class="comment-copy">np.minimum(np.rint(a),1) returns 0 for a&lt;0.5 and 1 for a&gt;=0.5.</span>
<span class="comment-copy">@TlsChris On my machine: <code>np.minimum(np.rint(0.5),1)</code> -&gt; <code>0</code> because <code>np.rint(0.5)</code> -&gt; <code>0</code>.</span>
<span class="comment-copy">@timgeb. np.rint(0.5) rounds down on my machine too. I shouldn't make assumptions :-).</span>
<span class="comment-copy">Best to use NumPy for NumPy arrays, +1. Also worth mentioning <a href="https://stackoverflow.com/questions/27252209/numpy-around-rint-slow-compared-to-astypeint">other options</a> if performance is an issue.</span>
<span class="comment-copy">Did not mention rounding solutions, as no range was defined.</span>
<span class="comment-copy">Cleanest and probably fastest solution. Pity it did not attract many votes so far.</span>
<span class="comment-copy">You don't have to use <code>np.float</code> or <code>np.int</code> in <code>.astype</code>, a regular <code>float</code> or <code>int</code> will do just fine. Numpy will interpret it as the equivalent numpy variant.</span>
<span class="comment-copy">What about numbers that are not in range of 0 and 1?</span>
<span class="comment-copy">Round works outside of the <code>[0, 1]</code> range. So <code>round(2.2)</code> would be <code>2.0</code>, <code>round(-1.2)</code> would be <code>-1.0</code>, and <code>round(3.141, 2)</code> would be <code>3.14</code>.</span>
<span class="comment-copy">@AndrewFiorillo But I just wanted an output 0 and 1 :)</span>
<span class="comment-copy">Then @FilipMÅ‚ynarski 's answer above is probably the most robust.</span>
