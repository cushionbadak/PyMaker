<div class="post-text" itemprop="text">
<p>I am trying to filter a list where there are words line by line, by the length of the word(between 4 and 8 characters). So that if the input file has:</p>
<ul>
<li>hello</li>
<li>communication</li>
<li>be</li>
<li>dog</li>
<li>test</li>
</ul>
<p>The output file is:</p>
<ul>
<li>hello</li>
<li>test</li>
</ul>
<p>So I have this code: </p>
<pre><code>dir = "lower.lst"
dict = open(dir, 'r').readlines()
f=open('dictionary','w')
for word in dict:
  if len(word)&gt;=4 &amp; len(word)&lt;=8:
    f.write(word)
f.close()
print(len(dict))

print(f)
</code></pre>
<p>But the output file keeps all the words.
By the way is there any more efficient way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>Use the with-statement to automatically close files (even with exceptions are encountered).</li>
<li><code>&amp;</code> in Python is really for bit twiddling only, use <code>and</code>.</li>
<li>You don't actually need <code>and</code>, because comparisons can be chained. (<code>len(word)&gt;=4 and len(word)&lt;=8</code> is equivalent to <code>4 &lt;= len(word) &lt;= 8</code>).</li>
<li>In your question you use <code>.readlines()</code> and here I use <code>for line in fin:</code>.  Either way the resulting strings will end in newline characters, so your length measurements will be off by one.  I correct for this by stripping the line before taking the length (<code>len(line.strip())</code>).  (Your code as written should have omitted <code>'be'</code>, but kept <code>'dog'</code>, because it's really <code>'dog\n'</code> which has a length of 4).</li>
<li>You said your code kept all of the words.  To my eye your code should have worked to omit <code>'communication\n'</code> and <code>'be\n'</code>.  I could imagine that <code>'be\n'</code> might be kept if there were extra spaces after it in the file (<code>'be  \n</code>' has a length of 5 because of the two spaces).  But there seems to be no logical way that <code>'communication\n'</code> would be kept in your output file.  You may want to double check that it really was there.  </li>
</ul>
<hr/>
<pre><code>with open('lower.lst', 'r') as fin, open('dictionary', 'w') as fout:
    for line in fin:
        if 4 &lt;= len(line.strip()) &lt;= 8:
            fout.write(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are more than one choice to do this.</p>
<ol>
<li>With <strong>filter()</strong> built-in function</li>
</ol>
<p>Check the docs <a href="https://stackoverflow.com/questions/53438554/cleaning-up-a-string-without-split-strip-built-in-functions">here</a>.</p>
<p>Let's suppose you have  list of strings called <code>data</code>, then:</p>
<pre><code>data = ['hello', 'communication', 'be', 'dog', 'test']
filtered_list = filter(lambda x: len(x) &gt; 4 and len(x) &lt; 8, data)
print(filtered_list)
</code></pre>
<p>Will return: </p>
<pre><code>Python 3.6.1 (default, Dec 2015, 13:05:11)
[GCC 4.8.2] on linux
&gt;   
['hello']
</code></pre>
<p>You can change the lambda function to filter different conditions. Filter will "catch" every element that returns <code>True</code>.</p>
<ol start="2">
<li>With <strong>list-comprehension</strong></li>
</ol>
<p>This is probably the shortest way to achieve this. Just need to do:</p>
<pre><code>filtered_list = [x for x in data if len(x) &gt; 4 and len(x) &lt; 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">List comprehension</a> does let you choose which elements you want to construct your list from. Here's an example implementation:</p>
<pre><code>s = """
hello
communication
be
dog
test
"""

lst = [elm for elm in s.split() if (len(elm) &gt;= 4 and len(elm) &lt;= 8)]

print(lst)
</code></pre>
<p>Output:</p>
<pre><code>['hello', 'test']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this what you're looking for? Here I use file context managers with the <code>with</code> reserved word, and I use <code>and</code> instead of <code>&amp;</code> as noted in the comments.</p>
<pre><code>with open("lower.lst", "r") as f:
   o = [word for word in f if (len(word) &gt;= 4 and len(word) &lt;= 8)]

with open("outfile.lst", "w") as f:
   f.write(o)
</code></pre>
<p>It's a bit tough to know if this will format exactly to your intentions in the outfile.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code should work if you replace <code>&amp;</code> for <code>and</code>, i.e:</p>
<hr/>
<pre><code>dict = open("lower.lst", 'r').readlines()
with open('dictionary','w') as f:
    for word in dict:
        if len(word)&gt;=4 and len(word)&lt;=8:
            f.write(word)
</code></pre>
</div>
<span class="comment-copy"><code>&amp;</code> is a C-ism (or Java, or JavaScript). Python uses <code>and</code>.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1075652/using-the-and-and-not-operator-in-python">Using the AND and NOT Operator in Python</a></span>
<span class="comment-copy">Don't use <code>dict</code> as variable name.</span>
<span class="comment-copy">Nifty way of opening the 2 files at once, but  shouldn't you use <code>readlines()</code> before <code>for line in fin:</code>?</span>
<span class="comment-copy">@PedroLobito: Files iterate by line.  <code>readlines()</code> buffers all the lines into a list first, but if all you're going to do is iterate over that list you should just cutout the middleman and iterate directly. This is especially important if the file is larger than working memory. (Both methods will give lines that include the newline at the end.  That impacts this problem.)</span>
<span class="comment-copy">When the OP wrote "between 4 and 8 characters" I believe he meant that as having inclusive endpoints so that word lengths of 4 and 8 would also be preserved.  If so, your <code>&gt;</code> and <code>&lt;</code> should be <code>&gt;=</code> and <code>&lt;=</code>.  Also a clearer way to write that is <code>4 &lt;= len(x) &lt;= 8</code> without the <code>and</code>.  Finally, it would be worth mentioning in your answer that the OP has an additional bug because he's reading from file.  His words have newlines at the end, so his length measurements are off by one.</span>
<span class="comment-copy"><code>readlines()</code> preserves the newlines, so the length test will need to account for that: <code>if 4 &lt;= len(word.strip()) &lt;= 8:</code>.  This also impacts the write: <code>f.write(word)</code>.</span>
<span class="comment-copy">I used a <code>list</code> as example... thank you for pointing that.</span>
