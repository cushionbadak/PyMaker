<div class="post-text" itemprop="text">
<p>I have this code here:</p>
<pre><code>def most_popular_book(book_loans):
    vBL = book_loans.values()
    kBL = book_loans.keys()
    items = book_loans.items()
    print items
    kBL = sorted(kBL, key=str.lower)
    mvBL = max(vBL)
    for key,vaule in items:
        if vaule == mvBL:
            return key
</code></pre>
<p>my goal with this code is to get the key with the biggest value, and if 2 keys have the same values then choose the one that comes first in a lexicography order.</p>
<p>now the first part of the code works fine! however I am having trouble with the second part. 
I read some code on the subject but I haven't been able to find a way to make it work.</p>
<p><em>example for how the code should work:</em> </p>
<pre><code>print most_popular_book({'harry potter':['yossi','adam'], 
'lilo and stich':['yossi', "adam"], 'catch-22':['adam'] })

'harry potter'
</code></pre>
<p>(it should print harry potter)
but my code prints <strong>'lilo and stich'</strong> </p>
<p><em>another example:</em></p>
<pre><code>{'the little prince': ['yossi'], 'harry potter': ['yossi', 'assaf'], 
 'catch-22': ['yossi', 'dana']}

'catch-22'
</code></pre>
<p>(this output is working correctly)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get the fully sorted list by:</p>
<pre><code>fancy = sorted( book_loans.items(), key = lambda x:(-len(x[1]), x[0]))
</code></pre>
<p>and takte the first one. </p>
<p>It works by defining a <code>tuple</code> as sort-criteria - <code>tuples</code> are sorted by 1st value, then 2nd value if 1st value draws etc.</p>
<p>Sorting by <code>-len()</code> "inverts" it (you could also specify the <code>reverse=True</code> param to sorting - either one works.</p>
<pre><code>fancy = sorted( {'harry potter':['yossi','adam'], 'lilo and stich':['yossi', "adam"],
                 'catch-22':['adam'] }.items(), key = lambda x:(-len(x[1]), x[0])) 

print(fancy)
print(fancy[0][0])
</code></pre>
<p>Output:</p>
<pre><code>[('harry potter', ['yossi', 'adam']), ('lilo and stich', ['yossi', 'adam']),
 ('catch-22', ['adam'])]

harry potter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer">min</a> if you only want the <em>most popular book</em>:</p>
<pre><code>def most_popular_book(books):
    result, _ = min(books.items(), key=lambda x: (-len(x[1]), x[0]))
    return result


print(most_popular_book({'harry potter': ['yossi', 'adam'],
                         'lilo and stich': ['yossi', "adam"], 'catch-22': ['adam']}))
print(most_popular_book({'the little prince': ['yossi'], 'harry potter': ['yossi', 'assaf'],
                         'catch-22': ['yossi', 'dana']}))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>harry potter
catch-22
</code></pre>
<p>The idea is the same as in the answer of @PatrickArtner, the only difference being the sorted is <em>O(nlogn)</em> and min is <em>O(n)</em>. No need to sort the list, only to find the minimum.</p>
</div>
<span class="comment-copy">You said you want lexicographic order as a criteria, in case two keys have the same amount of values, then <code>'catch-22'</code> is correct, because in lexicographic order it comes before than harry potter.</span>
<span class="comment-copy">@CtrlS then why should harry potter be the answer, if the length of the corresponding value is equal to the length of 'catch-22'?</span>
<span class="comment-copy">yeah i noticed that catch is the correct one sorry about that!</span>
<span class="comment-copy">thank you so much!!!!!</span>
