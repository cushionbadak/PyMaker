<div class="post-text" itemprop="text">
<p>Let's say I have a class which implements an <code>__iter__()</code> function, is it preferred to use <code>iter(obj)</code> or calling <code>obj.__iter__()</code> directly? Are there any real differences besides having to type 5 characters less with the magic function?</p>
<p>In contrast: For <code>next()</code> and <code>__next__()</code> I can see an advantage for having a default value with the magic function. </p>
</div>
<div class="post-text" itemprop="text">
<p>The difference is mostly just convenience. It's less typing and less symbols to read, and so faster to read. However, the various builtin functions (eg. <code>iter</code>, <code>len</code> et al.) usually do a little type checking to catch errors early. If you wrote a customer <code>__iter__</code> method and it <em>returned</em> <code>2</code>, then invoking <code>obj.__iter__()</code> wouldn't catch that, but <code>iter(obj)</code> throws a type error. eg.</p>
<pre><code>&gt;&gt;&gt; class X:
    def __iter__(self):
        return 2

&gt;&gt;&gt; x = X()
&gt;&gt;&gt; x.__iter__()
2
&gt;&gt;&gt; iter(x)
Traceback (most recent call last):
  File "&lt;pyshell#37&gt;", line 1, in &lt;module&gt;
    iter(x)
TypeError: iter() returned non-iterator of type 'int'
</code></pre>
<p><code>iter</code> also implements the iterator protocol for objects that have no <code>__iter__</code>, but do implement the sequence protocol. That is, they have a <code>__getitem__</code> method which implements a sequence starting at index 0 and raises an IndexError for indexes not in bounds. This is an older feature of python and not really something new code should be using. eg.</p>
<pre><code>&gt;&gt;&gt; class Y:
    def __getitem__(self, index):
        if 0 &lt;= index &lt; 5:
            return index ** 2
        else:
            raise IndexError(index)

&gt;&gt;&gt; list(iter(Y()))  # iter not strictly needed here
[0, 1, 4, 9, 16]
</code></pre>
<p>When should you use <code>__iter__</code>? This might not be so relevant to <code>__iter__</code>, but if you need access to the implementation of method that the parent class uses then it is best to invoke such methods in the style <code>super().__&lt;dunder_method&gt;__()</code> (using Python 3 style super usage). eg.</p>
<pre><code>&gt;&gt;&gt; class BizzareList(list):
    def __iter__(self):
        for item in super().__iter__():
            yield item * 10

&gt;&gt;&gt; l = BizzareList(range(5))
&gt;&gt;&gt; l  # normal access
[0, 1, 2, 3, 4]
&gt;&gt;&gt; l[0]  # also normal access
0
&gt;&gt;&gt; tuple(iter(l))  # iter not strictly needed here
(0, 10, 20, 30, 40)
</code></pre>
</div>
<span class="comment-copy"><code>iter()</code> is not magic - it is, what you are supposed to be using ...</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/33709805/how-does-the-python-iter-function-work">reading this and the linked maybe-dupe</a> might help</span>
<span class="comment-copy">In general, <code>__dunder__</code> methods implement the behaviour, but you trigger it with functions like <code>iter()</code> or <code>next()</code> or <code>len()</code>. Those functions often add a little extra behaviour.</span>
<span class="comment-copy">It's largely about duck typing too. You implement <code>__iter__</code> on a custom object to make it iterable. But code that wants to iterate something should not necessarily know or care <i>how</i> that object is iterable, it should use <code>iter()</code> to leave the details to it.</span>
<span class="comment-copy">If I read up on <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer">iter()</a> it also says it will work with either <code>__iter__()</code> or <code>__getitem()__</code> implementing classes - from a consumer perspective it abstracts of either one.</span>
<span class="comment-copy">Great answer, thanks a lot!</span>
