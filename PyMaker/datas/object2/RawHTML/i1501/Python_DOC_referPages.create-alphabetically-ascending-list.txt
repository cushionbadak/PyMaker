<div class="post-text" itemprop="text">
<p>I want to create alphabetically ascending names like the column names in excel. That is I want to have smth. like a,b,c,...,z,aa,ab,...az,...zz,aaa,aab,....</p>
<p>I have tried:</p>
<pre><code>for i in range(1000):
    mod = int(i%26)
    div = int(i/26)
    print(string.ascii_lowercase[div]+string.ascii_lowercase[mod])
</code></pre>
<p>Which works until <strong>zz</strong> but than fails because it runs out of index</p>
<pre><code>aa
ab
ac
ad
ae
af
ag
ah
ai
aj
ak
al
.
.
.
zz
</code></pre>
<blockquote>
<p>IndexError</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You could make use of <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a>:</p>
<pre><code>from itertools import product
from string import ascii_lowercase

for i in range(1, 4):
    for x in product(ascii_lowercase, repeat=i):
        print(''.join(x))
</code></pre>
<p>First, you want all letters, then all pairs, then all triplets, etc. This is why we first need to iterate through all the string lengths you want (<code>for i in range(...)</code>).</p>
<p>Then, we need all possible associations with the <code>i</code> letters, so we can use <code>product(ascii_lowercase)</code> which is equivalent to a nested <code>for</code> loop repeated <code>i</code> times.</p>
<p>This will generate the tuples of size <code>i</code> required, finally just <code>join()</code> them to obtain a string.</p>
<p>To continuously generate names without limit, replace the <code>for</code> loop with <code>while</code>:</p>
<pre><code>def generate():
    i = 0
    while True:
        i += 1
        for x in product(ascii_lowercase, repeat=i):
            yield ''.join(x)

generator = generate()
next(generator)  # 'a'
next(generator)  # 'b'
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a general solution we can use a generator and <code>islice</code> from <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">itertools</a>:</p>
<pre><code>import string
from itertools import islice
def generate():
    base = ['']
    while True:
        next_base = []
        for b in base:
            for i in range(26):
                next_base.append(b + string.ascii_lowercase[i])
                yield next_base[-1]
        base = next_base

print('\n'.join(islice(generate(), 1000)))
</code></pre>
<p>And the output:</p>
<pre><code>a
b
c
...
z
aa
ab
...
zz
aaa
aab
...
</code></pre>
<p>And you can use <code>islice</code> to take as many strings as you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>&gt;&gt;import string
&gt;&gt;string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'
&gt;&gt;len(string.ascii_lowercase)
26
</code></pre>
<p>When your index in below line exceed 26 it raise exception</p>
<pre><code>div = int(i/26)
</code></pre>
<p>, becouse of ascii_lowercase length:</p>
<p>But you can:</p>
<pre><code>for i in range(26*26):  # &lt;--- 26 is string.ascii_lowercase
    mod = int(i%26)
    div = int(i/26)
    print(string.ascii_lowercase[div]+string.ascii_lowercase[mod])
</code></pre>
<h2>EDIT:</h2>
<p>or you can use:</p>
<pre><code>import string

n = 4  # number of chars
small_limit = len(string.ascii_lowercase)
limit = small_limit ** n
i = 0
while i &lt; limit:
    s = ''
    for c in range(n):
        index = int(i/(small_limit**c))%small_limit
        s += string.ascii_lowercase[index]
    print(s)
    i += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code>from string import ascii_lowercase
l = list(ascii_lowercase) + [letter1+letter2 for letter1 in ascii_lowercase for letter2 in ascii_lowercase]+ [letter1+letter2+letter3 for letter1 in ascii_lowercase for letter2 in ascii_lowercase for letter3 in ascii_lowercase]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's an answer to this question provided on <a href="https://codereview.stackexchange.com/questions/100865/increment-a-string-of-uppercase-characters">Code Review SE</a></p>
<p>A slight modification to the answer in the link gives the following which works for an arbitrary number of iterations.</p>
<pre><code>def increment_char(c):
    return chr(ord(c) + 1) if c != 'z' else 'a' 

def increment_str(s):
    lpart = s.rstrip('z')
    num_replacements = len(s) - len(lpart)
    new_s = lpart[:-1] + increment_char(lpart[-1]) if lpart else 'a' 
    new_s += 'a' * num_replacements
    return new_s

s = ''
for _ in range(1000):
    s = increment_str(s)
    print(s)
</code></pre>
</div>
<span class="comment-copy">how many characters up do you want to go? Does it stop with <code>'zzz'</code>? Or are you after an <code>iterator</code>?</span>
<span class="comment-copy">do you mean <code>for i in range(1, 4):</code>? because the way it is right now creates them up to <code>'zz'</code>.</span>
<span class="comment-copy">@Ev.Kounis Sure, I edited it, thanks. In the end, this generic solution let the author choose the maximum length he needs.</span>
<span class="comment-copy">use 4 space indentations.</span>
