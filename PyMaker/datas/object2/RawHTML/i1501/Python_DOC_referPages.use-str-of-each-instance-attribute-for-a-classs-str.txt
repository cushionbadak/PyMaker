<div class="post-text" itemprop="text">
<p>Is there a way in Python 3 to recursively call private member variables unique <code>__str__</code> functions programmatically? Something like:</p>
<pre><code>class A:
  def __str__(self):
    return "A"

class B:
  def __str__(self):
    return "B"

class C:
  def __init__(self):
    self._A = A()
    self._B = B()

  def __str__(self):
    for var in vars(self):
      return str(var)
</code></pre>
<p>When calling the individual private members, it works fine. Would like a method to do it dynamically however.</p>
<p>Thanks so much.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer"><code>vars</code></a> function returns a dictionary where the keys are the variable names (as strings) and the values are the values of the variable. So iterating over the values should work.</p>
<pre><code>class A:
  def __str__(self):
    return "A"

class B:
  def __str__(self):
    return "B"

class C:
  def __init__(self):
    self._A = A()
    self._B = B()

  def __str__(self):
    output = ""
    for _,var in vars(self).items(): #Iterate over the values
      output += str(var) #Use the str() function here to make the object return its string form
    return output #Need to return instead of print since that is what the __str__() function should do
</code></pre>
<p>You can add some kind of separator (like a <code>\n</code>) between the values if you want. Just replace <code>str(var)</code> with <code>str(var) + "\n"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the dictionary keys; <code>vars()</code> is <code>self.__dict__</code>:</p>
<pre><code>&gt;&gt;&gt; class A:
...     def __str__(self):
...         return self.__class__.__name__
... 
&gt;&gt;&gt; class B:
...     def __str__(self):
...         return self.__class__.__name__
... 
&gt;&gt;&gt; str(A())
'A'
&gt;&gt;&gt; repr(A())  # "long-form" the hex-string is id()
'&lt;__main__.A object at 0x10f65a908&gt;'

&gt;&gt;&gt; class C:
...     def __init__(self):
...        self.A = A()
...        self.B = B()
...     def __str__(self):
...         return '\n'.join(self.__dict__)
... 
&gt;&gt;&gt; C()
&lt;__main__.C object at 0x10f65aa58&gt;
&gt;&gt;&gt; print(C())  # Uses str(C())
A
B
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer"><code>vars(self)</code></a> is effectively <code>self</code>.  In turn, <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer"><code>self.__dict__</code></a> is a <code>dict</code> used to store an objectâ€™s (writable) attributes.</p>
<pre><code>&gt;&gt;&gt; C().__dict__
{'A': &lt;__main__.A object at 0x10f65aa90&gt;, 'B': &lt;__main__.B object at 0x10f65aac8&gt;}
</code></pre>
<p>The signature is <code>'\n'.join(iterable)</code>, and when you iterate over a dictionary, you iterate over its keys, which suffices in this case.</p>
<h3>Note on Dataclasses</h3>
<p>I'm not totally sure if (Python 3.7+) dataclasses are an easier solution here.  That's because they automatically implement a <code>__repr__()</code> but not a <code>__str__()</code> as far as I can tell:</p>
<pre><code>&gt;&gt;&gt; from dataclasses import dataclass
&gt;&gt;&gt;
&gt;&gt;&gt; @dataclass
... class C:
...     _A: object = A()
...     _B: object = B()
... 
&gt;&gt;&gt; c = C()  # still uses repr() for each field
&gt;&gt;&gt; str(c)
'C(_A=&lt;__main__.A object at 0x10f373828&gt;, _B=&lt;__main__.B object at 0x10f373940&gt;)'
</code></pre>
<p>In other words, you'd need to replace <code>A.__str__</code> with <code>A.__repr__</code> (same for <code>B</code>, which is maybe not something you want to do in the first place with regards to those two classes.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure you shouldn't be using <code>__repr__</code>?</p>
<p>Anyway, here's an example using <code>attrs</code>, beacuse I'm stuck on Python 3.5. With <code>dataclasses</code> it will work in a similar manner.</p>
<pre><code>import attr


class A:
    def __str__(self):
        return 'A'

class B:
    def __str__(self):
        return 'B'

@attr.s
class C:
    a = attr.ib(default=attr.Factory(A))
    b = attr.ib(default=attr.Factory(B))


if __name__ == '__main__':
    c = C()
    print(c) # __str__ defaults to __repr__

    def __str__(self):
        bits = ['&lt;C']
        for a in self.__attrs_attrs__:
            bits.append(' %s=%s' % (a.name, getattr(self, a.name)))
        bits.append('&gt;')
        return ''.join(bits)
    C.__str__ = __str__
    print(c) # custom __str__
</code></pre>
</div>
<span class="comment-copy"><code>__str__</code> should return a string.  You don't do the print in <code>__str__</code></span>
<span class="comment-copy">Ah yes, typo. Thanks for that.</span>
<span class="comment-copy">The standard way is to use <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">PEP 557 dataclasses</a>. Prior to that, the <a href="https://attrs.readthedocs.io/en/stable/" rel="nofollow noreferrer">attrs project</a> was most popular, and is still most flexible.</span>
<span class="comment-copy">I'm happy to listen to how to do this with a dataclass. Anyone have an example?</span>
<span class="comment-copy">@BradSolomon Right, but once you have the metadata, you can define your own functions however you want if you really need to.</span>
<span class="comment-copy">This works, which is excellent and thank you so much. If anyone else has opinions on this approach, I'm all ears. Thanks again! What exactly is the _,var doing here though? Grabbing the semi-privates?</span>
<span class="comment-copy">@BradSolomon Just checked it. The keys are the variable names, written as strings. So in this case, they are <code>"_A"</code> and <code>"_B"</code>.</span>
<span class="comment-copy">@BradSolomon the keys are the string corresponding to the <i>attribute name</i>, nothing to do with the <code>__str__</code> or <code>__repr__</code> of the objects in the namespace</span>
<span class="comment-copy">@BradSolomon the representation will be used if you print the dict, however</span>
<span class="comment-copy">@troy_s The <code>_,var</code> is what is used to iterate through a dictionary. The underscore would be the key, while <code>var</code> is the value. I use an underscore whenever I'm not actually using that particular variable, like in this case.</span>
<span class="comment-copy">Yeah this just happens to work because your attribute name just happens to be the same as what <code>str</code> would return by the objects being referenced by those attributes</span>
<span class="comment-copy">From what I can tell, this doesn't work. The reason it is working in this example is because the names of the members (<code>A</code> and <code>B</code>) are the same as their string representation. If you change the names to <code>_A</code> and <code>_B</code>, like in the original question, this outputs <code>"_A"</code> and <code>"_B"</code>, which are not the correct string representations.</span>
<span class="comment-copy">That's because of <code>self.__class__.__name__</code> though, no?  @kungfushark.  If you want to manually alter that, just would need to use a <code>str</code> literal in place</span>
<span class="comment-copy">@BradSolomon What I mean is that, if classes <code>A</code> and <code>B</code> had actual <code>__str__()</code> functions, this solution would not work. If, say, <code>str(A("x"))</code> was supposed to be <code>"x"</code> (would be defined in <code>A().__str__()</code>), this solution would not work, and would instead just output whatever the member name in <code>C()</code> was.</span>
<span class="comment-copy">This is for prettied output, so string seems the most logical choice here. Not certain however.</span>
