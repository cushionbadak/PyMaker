<div class="post-text" itemprop="text">
<pre><code>def check_classes(cls):
    if len(cls.__bases__) == 0:
        return []
    else:
        test_list = []
        for x in range(len(cls.__bases__)):
            test_list += [cls] + check_classes(cls.__bases__[x])
        for x in cls.__bases__:
            return test_list + [x]
</code></pre>
<p>I currently have a recursive function that takes a class as its parameter and returns a list of all base classes.  This works fine, but it has many duplicate classes in the list.  I want to return a set instead of a list and was wondering how I could go about changing the code to do so.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has a builtin <code>set</code> type that eliminates duplicates:</p>
<pre><code>def get_bases(obj):
   bases = {obj}  # new set including only obj
   if not(obj.__bases__):  # technically redundant - iter is a noop on empty collections
      return bases
   else:
      for x in obj.__bases__:
          bases.update(get_bases(x))  # update set - automatically eliminates duplicates
      return bases
</code></pre>
<p>This code already avoids adding many duplicates in the first place. However, the <code>set</code> still eliminates duplicates in case of multiple inheritance.</p>
<pre><code>class A: ...
class B1(A): ...
class B2(A): ...
class C(B1, B2): ...
print(get_bases(C))
# {&lt;class '__main__.C'&gt;, &lt;class '__main__.B1'&gt;, &lt;class 'object'&gt;, &lt;class '__main__.B2'&gt;, &lt;class '__main__.A'&gt;}
</code></pre>
<hr/>
<p>Python being Python, there is already something that does this:</p>
<pre><code>&gt;&gt;&gt; C.__mro__
(__main__.C, __main__.B1, __main__.B2, __main__.A, object)
</code></pre>
<p>If you just care about the bases, use <code>__mro__</code>. Its order also expresses how lookup is performed with multiple bases.</p>
<hr/>
<p>A slightly different approach for such searches is to use a <code>set</code> to <em>track</em> duplicates, but a <code>list</code> to <em>store</em> elements:</p>
<pre><code>def get_bases(obj, _dupes=None):
   _dupes = _dupes if _dupes is not None else set()
   bases = [obj]  # new list including only obj
   _dupes.add(obj)
   for x in obj.__bases__:
       if x not in _dupes:
           bases.extend(get_bases(x, _dupes))  # update set - automatically eliminates duplicates
   return bases
</code></pre>
<p>This uses a <code>_dupes: set</code> to check whether you already visited a class. Instead of eliminating classes you added twice, it only adds them once in the first place. A <code>set</code> is faster for this check than a <code>list</code>, given many elements. However, you need the <code>list</code> to preserve order.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your function is redundant in that it can be replaced with <a href="https://docs.python.org/3/library/stdtypes.html#class.__mro__" rel="nofollow noreferrer"><code>cls.__mro__</code></a>:</p>
<pre><code>&gt;&gt;&gt; class Base: pass
...
&gt;&gt;&gt; class Foo(Base): pass
...
&gt;&gt;&gt; class Bar(Base): pass
...
&gt;&gt;&gt; class Baz(Foo, Bar): pass
...

&gt;&gt;&gt; Baz.__mro__
(&lt;class '__main__.Baz'&gt;, &lt;class '__main__.Foo'&gt;, &lt;class '__main__.Bar'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>Your biggest issue is that your implementation adds classes to the list <em>twice</em>, once in the recursive call, then again in the current call. Only add the <em>current</em> class to the list. Checking for the <code>__bases__</code> list as empty is redundant too, as the <code>for</code> loop already not do anything if the sequence is empty.</p>
<p>So this is enough:</p>
<pre><code>def check_classes(cls):
    result = [cls]
    for base in cls.__bases__:
        result += check_classes(base)
    return result
</code></pre>
<p>But this will still repeat base classes that have been included in the hierarchy more than once:</p>
<pre><code>&gt;&gt;&gt; check_classes(Baz)
[&lt;class '__main__.Baz'&gt;, &lt;class '__main__.Foo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;, &lt;class '__main__.Bar'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]
</code></pre>
<p>Note that <code>Base</code> and <code>object</code> appear twice, due to multiple inheritance. You could use a set to avoid this:</p>
<pre><code>def check_classes(cls):
    result = set([cls])
    for base in cls.__bases__:
        result.update(check_classes(base))
    return result
</code></pre>
<p>at which point we lose ordering, but that may be sufficient for your needs:</p>
<pre><code>&gt;&gt;&gt; check_classes(Baz)
{&lt;class '__main__.Bar'&gt;, &lt;class '__main__.Foo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;, &lt;class '__main__.Baz'&gt;}
</code></pre>
<p>However, then you could just use <code>set(cls.__mro__)</code> and be done with it:</p>
<pre><code>&gt;&gt;&gt; check_classes(Baz) == set(Baz.__mro__)
True
</code></pre>
</div>
<span class="comment-copy">If you want to return a <code>set</code>, why don't you just use a <code>set</code>?</span>
<span class="comment-copy">use 'return set(test_list + [x])'</span>
<span class="comment-copy">Why use this <b>at all</b> and not <code>class.__mro__</code>?</span>
<span class="comment-copy">Don't vanadalize your posts. I have rollbacked to previous sane version.</span>
