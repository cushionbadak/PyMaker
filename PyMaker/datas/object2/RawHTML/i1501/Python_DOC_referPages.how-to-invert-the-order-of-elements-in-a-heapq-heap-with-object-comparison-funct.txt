<div class="post-text" itemprop="text">
<p>First of all, I read this <a href="https://stackoverflow.com/questions/44792566/descending-order-using-heapq">SO question</a> but it actually doesn't include my desired approach. In addition, negating the actual values is not applicable for my use case.</p>
<p>Heapq Docs: <a href="https://docs.python.org/3.6/library/heapq.html" rel="nofollow noreferrer">https://docs.python.org/3.6/library/heapq.html</a></p>
<p>Assume I have a list of dataclass objects in my heap. Only the <code>a</code> property determines the order of objects.</p>
<pre><code>import heapq
from dataclasses import dataclass

@dataclass
class C:
    a: int
    b: int
    def __lt__(self, other):
        return self.a &lt; other.a

l=[C(2,1),C(9,109),C(2,4),C(9,4)]

print(heapq.heappop(l)) # C(a=2, b=1)
print(heapq.heappop(l)) # C(a=2, b=4)
print(heapq.heappop(l)) # C(a=9, b=109)
print(heapq.heappop(l)) # C(a=9, b=4)
</code></pre>
<p>Now I want to have an inverted order. Therefore, I changed the line <code>return self.a &lt; other.a</code> to <code>return self.a &gt; other.a</code>. The result:</p>
<pre><code>import heapq
from dataclasses import dataclass

@dataclass
class C:
    a: int
    b: int
    def __lt__(self, other):
        return self.a &gt; other.a

l=[C(2,1),C(9,109),C(2,4),C(9,4)]

print(heapq.heappop(l)) # C(a=2, b=1)
print(heapq.heappop(l)) # C(a=9, b=109)
print(heapq.heappop(l)) # C(a=9, b=4)
print(heapq.heappop(l)) # C(a=2, b=4)
</code></pre>
<p>The desired result should be one of the four solutions: </p>
<pre><code>C(a=9, b=109)   C(a=9, b=4)      C(a=9, b=109)  C(a=9, b=4)    
 C(a=9, b=4)    C(a=9, b=109)    C(a=9, b=4)    C(a=9, b=109) 
 C(a=2, b=1)    C(a=2, b=1)      C(a=2, b=4)    C(a=2, b=4)  
 C(a=2, b=4)    C(a=2, b=4)      C(a=2, b=1)    C(a=2, b=1) 
</code></pre>
<p>Probably, not all pairs of objects are compared by <code>heapq</code> that would explain the strange order. However, is it still possible to get an inverted order?</p>
<p>Do I have to provide more object comparison methods?        </p>
<pre><code>object.__lt__(self, other)
object.__le__(self, other)
object.__eq__(self, other)
object.__ne__(self, other)
object.__gt__(self, other)
object.__ge__(self, other)
</code></pre>
<p>If you have an completely other approach, do not hesitate!</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to make <code>l</code> into a heap using <a href="https://docs.python.org/3.0/library/heapq.html#heapq.heapify" rel="nofollow noreferrer"><code>heapify</code></a></p>
<pre><code>from heapq import heapify, heappop
from dataclasses import dataclass

@dataclass
class C:
    a: int
    b: int
    def __lt__(self, other):
        return self.a &gt; other.a

l=[C(2,1),C(9,109),C(2,4),C(9,4)]

heapify(l)    

while l:
    print(heappop(l))
</code></pre>
<p>prints</p>
<pre><code>C(a=9, b=4)
C(a=9, b=109)
C(a=2, b=1)
C(a=2, b=4)
</code></pre>
</div>
<span class="comment-copy">But why is it working in the first case (in my question)? The list isn't ordered.</span>
<span class="comment-copy">Because your example list happens to satisfy the heap invariant when <code>&lt;</code> isn't reversed, but isn't a valid heap when <code>&lt;</code> is reversed.  The <a href="https://docs.python.org/3/library/heapq.html#theory" rel="nofollow noreferrer">Theory section of the <code>heapq</code> documentation</a> would be a good place to start reading, though I also recommend you actually try implementing all of the functions to understand how they work.</span>
