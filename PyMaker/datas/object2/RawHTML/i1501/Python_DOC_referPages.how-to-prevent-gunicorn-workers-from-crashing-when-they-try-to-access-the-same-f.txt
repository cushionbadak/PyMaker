<div class="post-text" itemprop="text">
<p>My Flask app logs requests in separate json files because they are fairly big and would just clutter the usual text logs (e.g. <code>app.logger.info("..")</code>). It keeps the last <em>n</em> requests in some folder.</p>
<p>More precisely a function globs all json files and while there are more than <em>n</em> it removes one at a time and then adds the new request:</p>
<pre><code>logfiles = sorted(glob.glob("*.json"))

while len(logfiles) &gt;= n:
    os.remove(logfiles.pop(0))
</code></pre>
<p>I employ the app with a gunicorn server and noticed that, for an identical request, it sometimes crashes and sometimes succeeds. A crash is followed by the info:</p>
<pre><code>[18935] [INFO] Handling signal: int
[18935] [INFO] Shutting down: Master
</code></pre>
<p>I am guessing that two gunicorn workers are simultaneously accessing the log folder and try to delete the same file. So one of the two will crash because the file is already gone. I am aware of (=heard of) this type of problem when programming with multiple threads but I have so far never had to solve it myself.</p>
<p>I guess I will have to lock the folder and create a queue of workers that are trying to add / remove files to the folder? Whats the best way to go about it? Should I use one of the available modules like <code>threading</code> or
<code>Queue</code>? Will they run smoothly with Flask and gunicorn? Or should I implement my own queue?</p>
<p>PS: This is a follow up question to <a href="https://stackoverflow.com/questions/53499362/how-to-log-large-requests-as-files">How to log large requests as files?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>When the python run-time attempts to access a file that doesn't exist, it throws an exception. Your code does not have a way to handle that exception and as a result, the gunicorn thread throws an interrupt signal and crashes. The most basic way of handling this is to use a <a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">try block</a> to encapsulate the code that attempts to access/delete the file:</p>
<pre><code>try:
    # Code that tries to access the file
    while len(logfiles) &gt;= n:
        os.remove(logfiles.pop(0))
except:
    # Code that you want to execute after the operation fails 
</code></pre>
<p>This works for removing pages, but you might want to also use something like <a href="https://pypi.org/project/filelock/" rel="nofollow noreferrer">filelock</a> if you run into other errors while trying to write to files.</p>
</div>
