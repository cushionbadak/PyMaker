<div class="post-text" itemprop="text">
<p>I am wondering why this function:
</p>
<pre class="lang-py prettyprint-override"><code>def digit(k):
    return len(str(k))
</code></pre>
<p>is faster than this one ? :</p>
<pre class="lang-py prettyprint-override"><code>def digit(k):
    i = 0
    while k != 0:
        k = k // 10
        i += 1
    return i
</code></pre>
<p>And why it's the opposite for example in C?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's look at what happens if we take your Python code and translate it as literally as possible to C.  We can do that very easily with <a href="https://cython.org/" rel="nofollow noreferrer">Cython</a>:</p>
<pre><code># save this in a file named "testmod.pyx" and compile it with Cython and a
# C compiler - details vary depending on OS and Python installation

from libc.stdio cimport snprintf
from libc.string cimport strlen

def c_digit_loop(k_):
    cdef unsigned int k = k_
    cdef int i = 0
    while k != 0:
        k = k // 10
        i += 1
    return i

def c_digit_str(k_):
    cdef unsigned int k = k_
    cdef char strbuf[32] # more than enough for any 'unsigned int'
    snprintf(strbuf, sizeof(strbuf), "%u", k);
    return strlen(strbuf);
</code></pre>
<p>The machine code you get from this is not as optimal as it could be, but it's close enough for a quick test.  This allows us to compare performance directly using <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a>, like this:</p>
<pre><code># save this in a file named 'test.py' and run it using the
# same CPython you compiled testmod.pyx against

import timeit
from testmod import c_digit_loop, c_digit_str

def py_digit_loop(k):
    i = 0
    while k != 0:
        k = k // 10
        i += 1
    return i

def py_digit_str(k):
    return len(str(k))

def test1(name):
    print(name, timeit.timeit(name+"(1234567)", "from __main__ import "+name,
                              number=10000))

test1("py_digit_loop")
test1("py_digit_str")
test1("c_digit_str")
test1("c_digit_loop")
</code></pre>
<p>When I run this program, this is the output I get on the computer where I'm typing this. I've manually lined up the numbers to make them easier to compare by eye.</p>
<pre><code>py_digit_loop 0.004024484000183293
py_digit_str  0.0020454510013223626
c_digit_str   0.0009924650003085844
c_digit_loop  0.00025072999960684683
</code></pre>
<p>So that confirms your original assertion: the loop is slower than converting to a string in Python, but in C it's the other way around.  But notice that converting to a string in C is still faster than converting to a string in Python.</p>
<p>To know <em>precisely</em> why this is happening we would need to dig deeper into the guts of the Python interpreter than I feel like doing this morning, but I know enough about its guts already to tell you in outline.  The CPython interpreter is not very efficient.  Even operations on small integers involve reference counting and construction of scratch objects on the heap.  Your loop that does basic arithmetic in Python requires one or two scratch objects per iteration (depending on whether 0, 1, 2, ... are "interned").  Doing the calculation by converting to a string and taking its length involves creating only <em>one</em> temporary object, the string, for the whole calculation.  The bookkeeping involved with these scratch objects dwarfs the cost of the actual calculation, <em>for both of the Python implementations</em>.</p>
<p>The C string-based implementation performs almost exactly the same steps that the Python string-based implementation performs, but its scratch object is a <code>char</code> array on the stack, not a full-fledged Python string object, and that all by itself is apparently good for a 40-50% speedup.</p>
<p>The C loop-based implementation compiles down to <em>eight machine instructions</em> for the actual loop.  No memory accesses.  Not even a hardware divide instruction (that's the magic of <a href="https://stackoverflow.com/questions/30790184/perform-integer-division-using-multiplication">strength reduction</a>).  And then hundreds more instructions dealing with the Python object model.  Most of those 0.00025 seconds are <em>still overhead</em>.</p>
</div>
<span class="comment-copy">FWIW, <code>len</code> already returns an <code>int</code>, no need to convert it again. And why it's faster: because <code>str</code> and <code>len</code> are implemented in C and highly optimised, while a loop in userland code requires a lot more steps to complete.</span>
<span class="comment-copy">@deceze It's claimed, that the loop is faster in C. I'm not sure about this, but, like stated, in Python the loop is slower - which maybe is because of what you said...</span>
<span class="comment-copy">@Kai A C compiler could highly optimise such a loop. I don't know C well enough to support or refute the claim that it'll actually be faster. But Python most certainly doesn't do that level of optimisation and will actually execute all those steps in the loop, which should quite obviously be slower.</span>
<span class="comment-copy">Why don't you provide the C code that you claim is different?</span>
<span class="comment-copy">‚Ä¶?! ü§∑‚Äç‚ôÇÔ∏è You already know that a whole lot of userland code will be slower than two function calls to C code‚Ä¶ <i>and it's not the answer?!</i> How does that work?</span>
