<div class="post-text" itemprop="text">
<p>I am trying to create a custom logger as in the code below. However, no matter what level I pass to the function, logger only prints warning messages. For example even if I set the argument <strong>level = logging.DEBUG</strong> by default my code fails to log the debug or info messages. Can someone point out the problem here. </p>
<pre><code>import boto3
import logging


def get_logger(name=__name__, level=logging.DEBUG):
    # Create log handler
    logHandler = logging.StreamHandler()
    logHandler.setLevel(level)

    # Set handler format
    logFormat = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s", datefmt="%d-%b-%y")
    logHandler.setFormatter(logFormat)

    # Create logger
    logger = logging.getLogger(name)
    # Add handler to logger
    logger.addHandler(logHandler)

    # Stop propagating the log messages to root logger
    # logger.propagate = False

    return logger


def listBuckets():

    logThis = get_logger(level=logging.DEBUG)

    s3 = boto3.resource('s3')
    for bucket in s3.buckets.all():
        logThis.debug(msg='This message is from logger')
        print(bucket.name)


listBuckets()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A couple of points to know (Read these <a href="https://docs.python.org/2/library/logging.html#logger-objects" rel="nofollow noreferrer">logging docs</a> for details)</p>
<ul>
<li>A parent's / ancestor's log level takes precedence while evaluating the effective log level</li>
<li>A root logger, for example that created with <em>getLogger</em>, has <em>WARNING</em> as it default log level</li>
</ul>
<p>You have set the log level of the handler (<em>logHandler</em>) but not the root (<em>logger</em>). At this point, no handler can have a log level less than the root's, ie, <em>WARNING</em></p>
<pre><code>logHandler.setLevel(level)
logger.addHandler(logHandler)
logThis.debug(msg='This message is from logger')  # Does not log
logThis.warn(msg='This message is from logger')  # Logs
</code></pre>
<p>So, set the root level to something reasonable and you should be good to go</p>
<pre><code>logHandler.setLevel('WARNING')  # or NOTSET
logThis.debug(msg='This message is from logger') # Logs!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are missing the fact that a) every logger's ultimate ancestor is the <em>root</em> logger (which has level <code>WARNING</code> by default) and b) that both, loggers and handlers have levels. </p>
<p><a href="https://docs.python.org/3/library/logging.html#logging.Logger.setLevel" rel="nofollow noreferrer">The docs</a> state:</p>
<blockquote>
<p>When a logger is created, the level is set to NOTSET (<strong>which causes</strong> all
  messages to be processed when the logger is the root logger, or
  <strong>delegation to the parent when the logger is a non-root logger</strong>).</p>
</blockquote>
<p>So, you create a logger and a StreamHandler with their default level <code>NOTSET</code>. Your logger is an implicit descendant of the <em>root</em> logger. You set the <em>handler</em> to level <code>DEBUG</code>, but not the <em>logger</em> using that handler. 
Since the level on your logger still is <code>NOTSET</code>, when a log event occurs, its chain of ancestors is traversed ... </p>
<blockquote>
<p>... until either an ancestor with a level other than NOTSET is found, or
  the root is reached.</p>
<p>[...]</p>
<p><strong>If the root is reached</strong>, and it has a level of NOTSET, then all
  messages will be processed. Otherwise, <strong>the rootâ€™s level will be used
  as the effective level</strong>.</p>
</blockquote>
<p>Which means, you immediately end up at the <em>root</em> logger to determine the effective log level; it is set to <code>WARNING</code> as per the <em>root</em> logger's default.
You can check this with the <code>parent</code> and <code>level</code> properties and the <code>getEffectiveLevel</code> method on the <code>logger</code> object:</p>
<pre><code>logThis = get_logger()
print(logThis.parent)               # &lt;RootLogger root (WARNING)&gt;
print(logThis.level)                # 0 (= NOTSET)
print(logThis.getEffectiveLevel())  # 30 (= WARNING) from root logger
</code></pre>
<p>To have your logger handle the messages on and above the desired level itself, simply set it on the logger via <code>logger.setLevel(level)</code> in your <code>get_logger</code> function.</p>
</div>
<span class="comment-copy">First, you are not using <code>logThis</code> variable for logging which is returned by your get_logger function, second DO NOT use type as a name of a variable as <code>type</code> is a keyword in Python.</span>
<span class="comment-copy">The default root level logger is set to <code>WARNING</code> level.</span>
<span class="comment-copy">I am of the view that if I am creating a custom logger then I should be able to see the messages from that logger. Irrespective of what settings root logger has. Am I right or missing something?</span>
<span class="comment-copy">you have edited your question, are you still not able to get the desired output? In your previous code, you did create your custom logger but you were not using that. Instead you were using the default logger settings from root logger.</span>
<span class="comment-copy">@AnkitJaiswal: Thanks for the pointing out the typos. I edited the post to match my code, however problem is somewhere else and not because of the typos.</span>
