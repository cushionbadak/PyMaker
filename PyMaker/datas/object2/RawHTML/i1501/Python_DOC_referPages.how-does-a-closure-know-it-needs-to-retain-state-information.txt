<div class="post-text" itemprop="text">
<p>I understand the basics of closures. The common example I have seen on some questions here from learning python is:</p>
<pre><code>def maker(N):
    def action(X):
        return X ** N
    return action
</code></pre>
<p>I understand the outcomes of running maker, and I understand that action retains some state information, N, even once the enclosing scope of maker is gone. I also understand that different values of N are stored in different calls to action. What I don't understand however is how the interpreter 'knows' that N is referenced in action.</p>
<p>If a function's body is only run upon a call to that function, then how is it possible that the interpreter even knows to associate the data of N to the nested action function? I thought perhaps when there is a nested structure like this exists, python maybe looks inside to check if there are any references. I tried this:</p>
<pre><code>def f1():
    def f2():
        print(undefined_variable)
</code></pre>
<p>If it's the case that python looks into nested functions to determine if they reference variables in enclosing scopes, then wouldn't it also throw an error when it comes across an undefined variable in f2? My guess is that it doesn't (since it doesn't spit out an error here, even when f1 is called).</p>
<p>So my question is then how can python know to associate names from enclosing scopes to nested functions, if the bodies of those nested functions are never executed until they are called?</p>
</div>
<div class="post-text" itemprop="text">
<p>to add some more detail to @DYZ's answer, try the difference between:</p>
<pre><code>def foo(a):
    return lambda b: a * b

def foo2(a):
    return lambda b: locals()['a'] * b

def foo3(a):
    def bar(b):
        return locals()['a'] * b
        print('not executed', a)
    return bar
</code></pre>
<ul>
<li><code>foo(3)(5)</code> successfully evaluates to 15</li>
<li><code>foo2(3)(5)</code> fails to evaluate, because the parser didn't "know" that <code>a</code> would be needed later</li>
<li><code>foo3(3)(5)</code> succeeds because it knows it will need <code>a</code> later and hence builds a closure that binds it.  if byte code generation was smarter it might realise that the <code>print</code> was unreachable and hence not build the closure, but it doesn't do that for me in Python 3.7</li>
</ul>
<p>the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code> module</a> might make it more obvious what Python is doing behind the scenes, for example:</p>
<pre><code>from dis import dis
dis(foo)
</code></pre>
<p>prints out the bytecode associated with <code>foo</code> try comparing with the other functions</p>
</div>
<span class="comment-copy">The inner function is not executed until the function is called, but it is parsed and converted into an intermediate representation. N is bound at the parsing stage.</span>
<span class="comment-copy">@DYZ Does this mean it is converted to bytecode but not executed?</span>
<span class="comment-copy">Correct. Just like all other user-defined functions.</span>
<span class="comment-copy">Thank you, that is very helpful!</span>
<span class="comment-copy">Thanks very much for this. I think I understand the foo and foo(2) examples. If possible could you expand on what you mean by 'if the byte code was smarter'? Do you mean that the print statement, even though not executed, is what tells the parser to maintain a reference to a? So if it knew it was unreachable and didn't create a closure then foo3 would also fail?</span>
<span class="comment-copy">@masiewpao yes just that.  i.e. without the <code>print</code> <code>foo2</code> and <code>foo3</code> have the same semantics (I just used a <code>lambda</code> so it's shorter)</span>
<span class="comment-copy">Thank you, your answer and @DYZ's comment have made it very clear!</span>
