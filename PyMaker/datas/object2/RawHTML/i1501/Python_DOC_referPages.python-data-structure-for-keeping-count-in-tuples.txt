<div class="post-text" itemprop="text">
<p>I have a list of people objects like this...</p>
<pre><code>class person:
    monthlyTaskCount = [] 
    def __init__(self, name):
        self.name = name

bob = person("Bob Smith")
sam = person("Sam Jones")
amy = person("Amy Owen")

people = [bob,sam,amy]
</code></pre>
<p>And I'm comparing to a list of tasks to count and keep track of how many tasks they performed a month...</p>
<pre><code>for x in taskList: #contains x.personName, x.taskName, x.monthPerformed
    for p in people:
         if x.personName == p.name:
            #append to p.monthlyTaskCount in some way
</code></pre>
<p>I'm stuck because I can't visualise an appropriate way to keep track of month-by-month data and end up with something like this for p.amy.monthlyTaskCount...</p>
<pre><code>[11/2018:23, 12/2018:12, 1/2019:19, 2/2019:34]
</code></pre>
<p>(showing 23 tasks completed for Nov 2018 etc)</p>
<p>I'm just lost in terms of finding an elegant way to store data in this format - e.g. simply appending values to a list would result in duplicate entries per month which I'd then have to clean-up afterwards so I'm hoping there's a data structure someone could recommend that would solve the problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suspect this problem would be a lot easier to solve if you were using dictionaries to store more of your data. For instance, rather than putting the <code>people</code> in a list, but them in a dictionary keyed by their name, and you can immediately look up the appropriate <code>person</code> instance rather than needing to iterate through the list each time.</p>
<p>Similarly, the per-month count should probably be another dictionary, or maybe a dictionary subtype like <code>collections.Counter</code> (which is specifically designed for counting things).</p>
<p>There's another issue with how you're setting <code>monthlyTaskCount</code> in your class: All the instances will share the same list, since it's being created as a class variable. You should probably move its creation into the <code>__init__</code> method so each <code>person</code> gets their own copy.</p>
<p>Anyway, here's my suggestion:</p>
<pre><code>import collections

class person:
    def __init__(self, name):
        self.name = name
        monthlyTaskCount = collections.Counter()

bob = person("Bob Smith")
sam = person("Sam Jones")
amy = person("Amy Owen")

people = {p.name: p for p in [bob, sam, amy]}
</code></pre>
<p>With the improved data structures, your bookkeeping becomes easy:</p>
<pre><code>for x in taskList: #contains x.personName, x.taskName, x.monthPerformed
    people[x.personName].monthlyTaskCount[x.monthPerformed] += 1
</code></pre>
</div>
<span class="comment-copy">Do you just want <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">a <code>set</code></a>? Maybe a <code>collections.defaultdict(set)</code> if you want a mapping from keys to sets of values? Or <code>collections.Counter</code> if you're just counting things?</span>
<span class="comment-copy">Without the input and any explanation we can not assert what is wrong with your output.</span>
<span class="comment-copy">Also just to add, you might want to instantiate the list within <code>__init__</code> as shared data involving mutable objects might have surprising effects. You can read more <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" rel="nofollow noreferrer">here</a></span>
