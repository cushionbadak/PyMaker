<div class="post-text" itemprop="text">
<p>This is not my actual program but it illustrates my issue. This is the code:</p>
<pre><code>import multiprocessing as mp
import subprocess
import random
O = open("test.txt","w")
for i in range(10000000):
    O.write("%s\n" % (random.randint(0,9)))
O.close()

def worker(number):
    subprocess.call("awk \'$1==%s\' test.txt&gt; test.%s.txt" % (number,number),shell=True)
    return number

pool = mp.Pool(processes=3)
results = [pool.apply(worker, args=(x,)) for x in range(10)]
print(results)
</code></pre>
<p>This code is working fine however I noticed that the awk commannds are executing sequentially instead of 3 at a time. Is there anything that I am missing?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply" rel="nofollow noreferrer"><code>multiprocessing.Pool.apply</code></a>...</p>
<blockquote>
<p>blocks until the result is ready. Given this blocks, <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async" rel="nofollow noreferrer"><code>apply_async()</code></a> is better suited for performing work in parallel.</p>
</blockquote>
<p>If your core work really involves launching subprocesses rather than doing work natively in Python, you also might consider just outright launching a bunch of <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer"><code>subprocess.Popen</code></a> objects in a single Python process, then <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.poll" rel="nofollow noreferrer"><code>poll()</code></a> and <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait" rel="nofollow noreferrer"><code>wait()</code></a> on each of them.  This saves a layer of process, but it can be much trickier to collect outputs of the subprocesses if they're writing things to their own stdout.</p>
</div>
<span class="comment-copy">If the inputs and outputs can be treated as sequence, then <code>Pool.map</code> or Pool.imap_unordered` are probably a better choice and <code>apply_async</code>. Also, using <code>multiprocessing.dummy</code> might be better than rolling your own subprocess launcher.</span>
