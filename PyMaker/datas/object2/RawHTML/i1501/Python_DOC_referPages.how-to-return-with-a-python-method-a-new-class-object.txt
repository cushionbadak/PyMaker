<div class="post-text" itemprop="text">
<p>I have some questions with respect to the not working code below:</p>
<ol>
<li>How to make a method search return a New Database object? </li>
<li>Can <code>__init__</code> take as an argument a schema and a <code>list</code> (which is a <code>list</code> of dictionaries - where I do my search)?</li>
<li>How to avoid writing similar function in search method again and again, cause there are a lot of field names in the database.</li>
</ol>
<p>Thanks in advance for your help. </p>
<pre><code>class DataBase():  
# Searches Movies by title and gives its entire info :( (stupid)
def __init__(self, movies, schema):
    pass


def search(self, field_name, field_value1, field_value2=None):
    if field_name=='title':
        mov=[]
        for movie in movies:
            if field_value1 == movie['movie_title']:
                mov.append(movie)
        return mov

    if field_name=='year':
        for movie in movies:
            if field_value2:
                if movie['title_year'] in range (field_value1, field_value2+1):
                     return movie['movie_title'],movie['title_year']

            else:
                if movie['title_year']==field_value1:
                     return movie['movie_title'],movie['title_year']

    if field_name=='actor_1_name':
        mov=[]
        for movie in movies:
            if field_value1 == movie['actor_1_name']:
                mov.append(movie)
        return mov
        **strong text**
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It isn't really clear what you are trying to do, and it is hard to interpret without an example of the <em>inputs</em> and the desired result but this might be close.</p>
<pre><code>class DataBase():  
    def __init__(self, movies, schema):
        self.movies = movies
        self.schema = schema

    def search(self, field_name, field_value1, field_value2=None):
        search_result = []
        for movie in self.movies:
            if field_value2:
                if movie[field_name] in range((field_value1, field_value2+1)):
                    search_results.append(movie)
            else:
                if movie[field_name] == field_value1:
                    search_results.append(movie)

        return DataBase(search_results, self.schema)
</code></pre>
<hr/>
<p>You might even want to simplify the comparisons in the search. you could define helper functions for the (two) different types of comparisons; choose which comparison to use based on the arguments; then use the <em>chosen</em> function in the search.</p>
<pre><code>...

    def search(self, field_name, field_value1, field_value2=None):

        # comparison types    
        def range_comparison(movie, start=field_value1, end=field_value2):
            return movie[field_name] in range(start, end+1)
        def equality_comparison(movie, name=field_value1):
            return movie[field_name] == name

        # which comparison to use    
        comparison = range_comparison if field_value2 else equality_comparison

        search_result = []
        for movie in self.movies:
            if comparison(movie):
                search_results.append(movie)
        # or
        # search_results = [movie for movie in movies if comparison(movie)]
        return DataBase(search_results, self.schema)
</code></pre>
<p>For some reason that appeals to me because it separates the logic of the type  of comparison from the actual search.</p>
<hr/>
<p>It doesn't account for <code>search_results</code> being empty - no movies found.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>To return a <code>DataBase</code> object call <code>DataBase(movies, schema)</code>, where <code>movies</code> and <code>schema</code> are the parameters of the <code>__init__()</code> method of the class.</li>
<li><code>__init__()</code> can take as many positional parameters as you want, but remember to assign their object to appropriate names inside the <code>__init__()</code> body, so that you can use them later (see the <code>__init__()</code> method on my class).</li>
<li>To avoid repeating the search pattern all over the <code>search()</code> method, just use the <code>field</code> parameter as a key for matching each record on the database, and split the problem in two cases: one for the range search, the other for the plain search (see <code>search()</code> method below). Remember to address the no-match case: in my implementation I just return an empty <code>DataBase</code> object. You should also address the case of invalid search key: in my implementation I return <code>None</code>.</li>
</ol>
<p>The <code>test()</code> function below provides a database and three searches, both simple and within a range.</p>
<p>You should consider <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a> as an alternative representation for database records.</p>
<pre class="lang-py prettyprint-override"><code>class DataBase():

    def __init__(self, movies, schema):
        self.movies, self.schema = movies, schema

    def __str__(self):
        return str(self.movies)

    def search(self, field, from_value, to_value=None):
        if field in self.schema:
            matches = []
            if to_value:
                for movie in self.movies:
                    if movie[field] in range(from_value, to_value):
                        matches.append(movie)
            else:
                for movie in self.movies:
                    if movie[field] == from_value:
                        matches.append(movie)
            return DataBase(matches, self.schema)
        else:
            return None

def test():
    schema = [ "title", "year", "rating" ]
    movies = [
        { "title":"Star Wars: The Empire Strikes Back",       "year":1980, "rating":3 },
        { "title":"Serenity",                                 "year":2005, "rating":5 },
        { "title":"Scarface",                                 "year":1983, "rating":4 },
        { "title":"Harry Potter and the Philosopher's Stone", "year":2001, "rating":2 },
        ]

    db = DataBase(movies, schema)
    print(db.search("title", "Scarface"))
    print(db.search("year", 2000, 2008))
    print(db.search("rating", 4, 6))
    print(db.search("title", "The Last Emperor"))
    print(db.search("invalid", "value"))
</code></pre>
</div>
<span class="comment-copy">Have you read through the <a href="https://docs.python.org/3/tutorial/classes.html#classes" rel="nofollow noreferrer">Tutorial for Classes</a>?</span>
<span class="comment-copy">Will <code>field_value1</code> always be compared to <code>movie[field_name]</code>? And if <code>field_value2</code> is present does it imply a search for a range of values?</span>
<span class="comment-copy">Looks like searches on some fields return a list and other fields return a single thing.  You probably need to make two sets of fieldnames, to help distinguish the two.</span>
<span class="comment-copy">Yes, if <code>field_value2</code> is present, it should search for a range of values only.  And, search function should return a NEW DataBase objects, which only contains the movies found by the search. I returned list and other stuff, cause I did not know how to do it.</span>
