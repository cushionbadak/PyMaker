<div class="post-text" itemprop="text">
<p>I was trying to figure out exactly how Python 3 (using CPython as an interpreter) executes its program. I found out that the steps are:</p>
<ol>
<li><p>Compilation of Python source code (.py file) by CPython compilator to Python bytecode (.pyc) file. In the case of importing any modules the .pyc files are saved, in the case of one main.py Python script running they are not saved.</p></li>
<li><p>Python Virtual Machine interpretation of the bytecode into the hardware specific Machine Code.</p></li>
</ol>
<p>A great answer found here <a href="https://stackoverflow.com/a/1732383/8640077">https://stackoverflow.com/a/1732383/8640077</a> says that Python Virtual Machine takes longer to run its bytecode comparing to JVM because the java bytecode contains the information about data types, while Python Virtual Machine interprets lines one by one and has to determine the data types. </p>
<p>My question is how does Python Virtual Machine determine the data type and does it happen during the interpretation to Machine code or during a separate process (which e.g. would produce another intermediate code)?</p>
</div>
<div class="post-text" itemprop="text">
<p>The dynamic, run-time dispatch of CPython (compared to static, compile-time dispatch of Java) is only one of the reasons, why Java is faster than pure CPython: there are jit-compilation in Java, different garbage collection strategies, presence of native types like <code>int</code>, <code>double</code> vs. immutable data structures in CPython and so on.</p>
<p>My earlier <a href="https://stackoverflow.com/a/46723823/5769463">superficial experiments</a> have shown, that the dynamical dispatch is only responsible for about 30% of running - you cannot explain speed differences of some factors of magnitude with that.</p>
<p>To make this answer less abstract, let's take a look at an example:</p>
<pre><code>def add(x,y):
   return x+y
</code></pre>
<p>Looking at the bytecode:</p>
<pre><code>import dis
dis.dis(add)
</code></pre>
<p>which gives:</p>
<pre><code>2         0 LOAD_FAST                0 (x)
          2 LOAD_FAST                1 (y)
          4 BINARY_ADD
          6 RETURN_VALUE
</code></pre>
<p>We can see on the level of bytecode there is no difference whether <code>x</code> and <code>y</code> are integers or floats or something else - the interpreter doesn't care.</p>
<p>The situation is completely different in Java:</p>
<pre><code>int add(int x, int y) {return x+y;}
</code></pre>
<p>and </p>
<pre><code>float add(float x, float y) {return x+y;}
</code></pre>
<p>would result in completely different opcodes and the call-dispatch would happen at compile time - the right version is picked depending on the static types which are known at the compile time.</p>
<p>Pretty often CPython-interpreter doesn't have to know the exact type of arguments: Internally there is a base "class/interface" (obviously there are no classes in C, so it is called "protocol", but for somebody who knows C++/Java "interface" is probably the right mental model), from which all other "classes" are derived. This base "class" is called <code>PyObject</code> and <a href="https://docs.python.org/3/c-api/object.html" rel="nofollow noreferrer">here is the description of its protocol.</a>. So as long as the function is a part of this protocol/interface CPython interpreter can call it, without knowing the exact type and the call will be dispatched to the right implementation (a lot like "virtual" functions in C++).</p>
<p>On the pure Python side, it seems as if variables don't have types:</p>
<pre><code>a=1
a="1"
</code></pre>
<p>however, internally <code>a</code> has a type - it is <code>PyObject*</code> and this reference can be bound to an integer (<code>1</code>)  and to an unicode-string (<code>"1"</code>) - because they both "inherit" from <code>PyObject</code>.</p>
<p>From time to time the CPython interpreter tries to find out the right type of the reference, also for the above example - when it sees <code>BINARY_ADD</code>-opcode, the <a href="https://github.com/python/cpython/blob/bcda8f1d42a98d9022736dd52d855be8e220fe15/Python/ceval.c#L1276" rel="nofollow noreferrer">following C-code</a> is executed:</p>
<pre><code>    case TARGET(BINARY_ADD): {
        PyObject *right = POP();
        PyObject *left = TOP();
        PyObject *sum;
        ...
        if (PyUnicode_CheckExact(left) &amp;&amp;
                 PyUnicode_CheckExact(right)) {
            sum = unicode_concatenate(left, right, f, next_instr);
            /* unicode_concatenate consumed the ref to left */
        }
        else {
            sum = PyNumber_Add(left, right);
            Py_DECREF(left);
        }
        Py_DECREF(right);
        SET_TOP(sum);
        if (sum == NULL)
            goto error;
        DISPATCH();
    }
</code></pre>
<p>Here the interpreter queries, whether both objects are unicode strings and if this is the case a special method (maybe more efficient, as matter of fact it tries to change the immutable unicode-object in-place, see this <a href="https://stackoverflow.com/a/54030412/5769463">SO-answer</a>) is used, otherwise the work is dispatched to <code>PyNumber</code>-protocol.</p>
<p>Obviously, the interpreter also has to know the exact type when an object is created, for example for  <code>a="1"</code> or <code>a=1</code> different "classes" are used - but as we have seen it is not the only one place.</p>
<p>So the interpreter interfers the types during the run-time, but most of the time it doesn't have to do it - the goal can be reached via dynamic dispatch.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is built around the philosophy of duck typing. No explicit type checking takes place, not even during runtime. For example, </p>
<pre><code>&gt;&gt;&gt; x = 5
&gt;&gt;&gt; y = "5"
&gt;&gt;&gt; '__mul__' in dir(x)
&gt;&gt;&gt; True
&gt;&gt;&gt; '__mul__' in dir(y)
&gt;&gt;&gt; True
&gt;&gt;&gt; type(x)
&gt;&gt;&gt; &lt;class 'int'&gt;
&gt;&gt;&gt; type(y)
&gt;&gt;&gt; &lt;class 'str'&gt;
&gt;&gt;&gt; type(x*y)
&gt;&gt;&gt; &lt;class 'str'&gt;
</code></pre>
<p>The CPython interpreter checks if <code>x</code> and <code>y</code> have the <code>__mul__</code> method defined, and tries to "make it work" and return a result. Also, Python bytecode never gets translated to machine code. It gets executed inside the CPython interpreter. One major difference between the JVM and the CPython virtual machine is that the JVM can compile Java bytecode to machine code for performance gains whenever it wants to (JIT compilation), whereas the CPython VM only runs bytecode just as it is.</p>
</div>
<div class="post-text" itemprop="text">
<p>It could be useful for your understanding to avoid thinking of "variables" in Python. Compared to statically typed languages that have to associate a type with a variable, a class member, or a function argument, Python only deals with "labels" or names for objects.</p>
<p>So in the snippet,</p>
<pre><code>a = "a string"
a = 5 # a number
a = MyClass() # an object of type MyClass
</code></pre>
<p>the label <code>a</code> never has a type. It is just a name that points to different objects at different times (very similarly, in fact, to "pointers" in other languages). The objects on the other hand (the string, the number) always have a type. This nature of this type could change, as you can dynamically change the definition of a class, but it will always be determined, i.e. known by the language interpreter.</p>
<p>So to answer the question: Python never determines the type of a variable (label/name), it only uses it to refer to an object and that object has a type.</p>
</div>
<span class="comment-copy">Why do you think Python ever needs to "determine the data type"? Python is a dynamically-typed language; a type will only be checked when you ask specifically, and can very continually over the life of a variable. And I highly doubt the difference in execution time between Python and Java is due to runtime type checking.</span>
<span class="comment-copy">So even during the translation from Bytecode to Machine Code Python does not know the type of a variable? AD 2: What then makes the biggest difference in execution time between Python and Java?</span>
<span class="comment-copy">No, how can it? The program itself can change the type of a variable at any time, that is what dynamic typing means. This code is perfectly legal: <code>a = 'mystring'; a = MyClassThatIsNotAString()</code>. What is the type of <code>a</code>?</span>
<span class="comment-copy">I found <a href="https://leanpub.com/insidethepythonvirtualmachine/read" rel="nofollow noreferrer">this resource</a> while searching for an answer to your question. Maybe you will find it useful.</span>
<span class="comment-copy">I have yet to thoroughly understand <a href="https://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions" rel="nofollow noreferrer">this article</a>, but it is much shorter, and I think it answers your question.</span>
<span class="comment-copy">What do you mean "Python bytecode never gets translated to machine code. It gets executed inside the CPython interpreter.". Could you please elaborate on that?</span>
<span class="comment-copy">Machine code usually refers to code that can be executed by your computer. For instance, when you compile a C++ program in your computer, it gets compiled to machine code specific to YOUR computer's CPU architecture. Your CPU understands these instructions and can run them. So in a way, your CPU is the interpreter here. Just think of Python bytecode as machine code for the CPython virtual machine. They are just instructions for the CPython virtual machine. The CPython virtual machine can run these instructions without having to translate them to something else</span>
