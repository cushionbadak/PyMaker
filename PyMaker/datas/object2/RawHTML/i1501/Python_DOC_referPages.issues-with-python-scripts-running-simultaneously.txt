<div class="post-text" itemprop="text">
<p>I have two python scripts that use two different cameras for a project I am working on and I am trying to run them both inside a different script or within each other, either way is fine.</p>
<pre><code>import os

os.system('python 1.py')

os.system('python 2.py')
</code></pre>
<p>My problem however is that they don't run at the same time, I have to quit the first one for the next to open. I also tried doing it with bash as well with the &amp; shell operator </p>
<pre><code>python 1.py &amp;
python 2.py &amp;
</code></pre>
<p>And this does in fact make them both run however the issue is that they both run endlessly in the background and I need to close them rather easily. Any suggestion what I can do to avoid the issues with these implementations</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it with <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing</a></p>
<pre><code>import os
import time
import psutil
from multiprocessing import Process

def run_program(cmd):
    # Function that processes will run
    os.system(cmd)

# Initiating Processes with desired arguments
program1 = Process(target=run_program, args=('python 1.py',))
program2 = Process(target=run_program, args=('python 2.py',))

# Start our processes simultaneously
program1.start()
program2.start()

def kill(proc_pid):
    process = psutil.Process(proc_pid)
    for proc in process.children(recursive=True):
        proc.kill()
    process.kill()

# Wait 5 seconds and kill first program
time.sleep(5)
kill(program1.pid)
program1.join()

# Wait another 1 second and kill second program
time.sleep(1)
kill(program2.pid)
program2.join()

# Print current status of our programs
print('1.py alive status: {}'.format(program1.is_alive()))
print('2.py alive status: {}'.format(program2.is_alive()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One possible method is to use <code>systemd</code> to control your process (i.e. treat them as daemons).</p>
<p>This is how I control my Python servers since they need to run in the background and be completely detached from the current <code>tty</code> so I can exit my connection to the machine and the continue processes continue. You can then also stop the server later using <code>systemctl</code>, as explained below.</p>
<p><strong>Instructions:</strong></p>
<p>Create a <code>.service</code> file and save it in <code>/etc/systemd/system</code>, with contents along the lines of:</p>
<pre><code>[Unit]
Description=daemon one

[Service]
ExecStart=/path/to/1.py
</code></pre>
<p>and repeat with one going to <code>2.py</code>.</p>
<p>Then you can use <code>systemctl</code> to control your daemons.</p>
<p>First reload all config files with:</p>
<pre><code>systemctl daemon-reload
</code></pre>
<p>then start either of your daemons (where <code>my_daemon.service</code> is one of your unit files):</p>
<pre><code>systemctl start my_daemon
</code></pre>
<p>it should now be running and you should find it in:</p>
<pre><code>systemctl list-units
</code></pre>
<p>You can also check its status with:</p>
<pre><code>systemctl status my_daemon
</code></pre>
<p>and <code>stop</code>/<code>restart</code> them with:</p>
<pre><code>systemctl stop|restart my_daemon
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">subprocess.Popen</a>. This will create a child process and return its pid.</p>
<pre><code>pid = Popen("python 1.py").pid
</code></pre>
<p>And then check out <a href="https://docs.python.org/3/library/subprocess.html#popen-objects" rel="nofollow noreferrer">these functions</a> for communicating with the child process and checking if it is still running.</p>
</div>
<span class="comment-copy">Because your python scripts are programs that never ends until user doesn't decide to close them or error raises your first statement blocks your calling program. So until you don't close <code>python1.py</code> obviously python will never go to execute the next statement that in your case is another endless program <code>python2.py</code>. For solving this you need to create two new process like when forking a child (Look on processes concepts) and communicate with the in some way.</span>
<span class="comment-copy">I don't think he wants to terminate the called scripts after some fixed time. It's more like execute this two scripts and wait for when they're closed so check last conditions and exit. So you need to wait for both of them tho terminate independently in which order the scripts are closed.</span>
<span class="comment-copy">He said that they run forever and he needs to be able to close them <i>they both run endlessly in the background and I need to close them rather easily</i>, so that's what my code do. If however you'd like to wait for them to finish just remove lines with <code>terminate()</code> function and keep <code>join()</code> that will wait for processes to finish.</span>
<span class="comment-copy">I edited this error while ago, try current code.</span>
<span class="comment-copy">I tried the current code and it launches both programs but its actually not terminating them with the timer</span>
<span class="comment-copy">I tested it with python programs that run infinite loop and had same problem. I fixed it using <a href="https://pypi.org/project/psutil/" rel="nofollow noreferrer">psutil library</a>, you can try code now.</span>
