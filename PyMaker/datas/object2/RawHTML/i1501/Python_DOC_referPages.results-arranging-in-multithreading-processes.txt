<div class="post-text" itemprop="text">
<p>Assuming I have a code that using multiprocessing returns me a list of 200000 items that are a list of their own (in the code marked as point 1). In case i need one list with the internal items only, I iterate the received list again (in the code marked as point 2).</p>
<p>Problem: the line marked as point 2 does not work in parallel and therefore takes valuable time. Is there a way to write all the data in directly from the function cu to the doc?</p>
<pre><code>def cu(num):
   return range(num)

pool = mp.Pool(processes=384)
results = [pool.apply_async(cu, args=(20, )) for ind in range(200000)]
docs = [p.get() for p in results] # point 1
docs = [point for item in docs for point in item] # point 2
pool.close()
pool.join()
</code></pre>
<p>I suspect that replacing multithreading by multiprocessing will solve this problem but I am afraid that it will not saves time.</p>
<p>Note: this is a minimal example.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you are running a pool for only one operation but 200k times, but you want the pool to run over 200k operations. You need to use, <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map_async" rel="nofollow noreferrer"><code>map_async</code></a>, with generators and <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>docs = itertools.chain.from_iterable(
    pool.map_async(cu, args=(20 for _ in range(200000)))
)
</code></pre>
<p>This solution is lazy, that means that you need to consume the iterator for taking the values (iterating over it), you can easyly use:</p>
<pre><code>docs = list(docs)
</code></pre>
<p>or if you dont want the results stored:</p>
<pre><code>for doc in docs:
    ... #Do your stuff here
</code></pre>
</div>
<span class="comment-copy">BTW, I wouldnt suggest to use <code>384</code> processes, just the number of CPU cores your computer have (but maybe you are running this in a super server)</span>
<span class="comment-copy">I have attached a minimal example which does not represent the complete problem. Do you have a solution assuming that the computation is more complex and can not be modified?</span>
<span class="comment-copy">Well, the problem is that your approach is not the correct one. If you can not change then there is nothing to solve here. This is the way for doing it lazyly and get the results as the come from the pool computations.</span>
<span class="comment-copy">I am processing files that provide list of outputs. What do you mean by "This is the way for doing it lazyly and get the results as the come from the pool computations" What way?</span>
<span class="comment-copy">@GideonKogan, ok, i understand what is the problem. Check the upcoming edit</span>
