<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/9922283/filter-out-reversed-duplicated-tuples-from-a-list-in-python">filter out “reversed” duplicated tuples from a list in Python</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>For example, let's say I have a list:</p>
<pre><code>list_ = [(4,5),(5,4),(5,4),(8,10),(10,8),(9,3),(5,4),(10,8),(8,8)]
</code></pre>
<p>How do I get rid of all reversed tuples, so what's left is:</p>
<pre><code>list_ = [(4,5),(8,10),(9,3),(8,8)] 
</code></pre>
<p>?</p>
<p>this is for a personal project I'm doing it, and I wrote something that detects reversed tuples and deletes them, but only deletes one of the reversed tuples (rather than all of them). I think a dictionary would be useful here, but not sure how to go about implementing it</p>
</div>
<div class="post-text" itemprop="text">
<p>I would write a good old fashioned <code>for</code> loop. This solution guarantees the following: the first of any reversed tuples is kept, the output list is the same order as the input, makes no assumptions about the input tuple lengths.</p>
<pre><code>list_ = [(4,5),(5,4),(5,4),(8,10),(10,8),(9,3),(5,4),(10,8),(8,8)]

output, seen = [], set()
for item in list_:
    t1 = tuple(item)
    if t1 not in seen and tuple(reversed(item)) not in seen:
        seen.add(t1)
        output.append(item)

print(output)
# [(4, 5), (8, 10), (9, 3), (8, 8)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Tuples of length 2</h3>
<p>For tuples all of length 2, you can use <code>frozenset</code> with the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>unique_everseen</code> recipe</a> available in the docs, also featured in <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="nofollow noreferrer"><code>more_itertools</code></a> and <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="nofollow noreferrer"><code>toolz</code></a> 3rd party libraries:</p>
<pre><code>from more_itertools import unique_everseen

list_ = [(4,5),(5,4),(5,4),(8,10),(10,8),(9,3),(5,4),(10,8),(8,8)]

res = list(unique_everseen(list_, key=frozenset))

[(4, 5), (8, 10), (9, 3), (8, 8)]
</code></pre>
<p><a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer"><code>frozenset</code></a> is an unordered but hashable collection of unique items. The solution assumes your inputs all have length 2. So it won't differentiate between <code>(8,)</code> and <code>(8, 8)</code>.</p>
<h3>Tuples of variable length</h3>
<p>For tuples of different lengths, you can make a small adjustment to the recipe:</p>
<pre><code>def unique_everseen_custom(it):
    seen = set()
    seen_add = seen.add
    for tup in it:
        if (tup not in seen) and (tup[::-1] not in seen):
            seen_add(tup)
            seen_add(tup[::-1])
            yield tup

res = list(unique_everseen_custom(list_))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If we consider that all your tuples are duplets and that you want to keep unique values:</p>
<pre><code>list_ = [(4,5),(5,4),(5,4),(8,10),(10,8),(3,9),(5,4)]
</code></pre>
<p>We then sort the tuples:</p>
<pre><code>list_ = [tuple(sorted(t)) for t in list_]
</code></pre>
<p>And then use a set to remove the duplicates:</p>
<pre><code>list_ = list(set(list_))
</code></pre>
</div>
<span class="comment-copy">How is decided whether (4,5) or (5,4) is kept?</span>
<span class="comment-copy">Well, that depends. So you would want to keep the tuple with the low value in the first slot? What about tuples like <code>(4,4)</code>?</span>
<span class="comment-copy">Loop-based approaches like this one that properly display the algorithm at hand are underrepresented at SO and often get lost among the fancy one-liners despite being very useful to the learner. Have a rec!</span>
<span class="comment-copy">@Chris_Rands, Thanks, I've added a disclaimer. It's not clear whether the singleton tuple case is relevant (it may well be, and in this case <code>tuple</code> + <code>sorted</code> works).</span>
<span class="comment-copy">i mislead you, sorry, sorting is also wrong for &gt;2 element tuples, e.g. (1,2,3) and (1,3,2) are not palindrones</span>
<span class="comment-copy">@Chris_Rands, Yup, reread the question and you're right, you can just adjust the recipe trivially I believe, have updated accordingly. Your solution is also fine.</span>
<span class="comment-copy">You're missing <code>[</code> when you're sorting <code>list_</code></span>
<span class="comment-copy">What if you have another tuple, say for eg <code>(6,5)</code>, in the list?</span>
<span class="comment-copy">Thanks for the typo notice ([) and the sorted, forgot that one.</span>
<span class="comment-copy">Now you will find <code>TypeError: unhashable type: 'list'</code>.</span>
<span class="comment-copy">The possibly larger issue is is that you don't preserve the order of either the tuples or the list as a whole</span>
