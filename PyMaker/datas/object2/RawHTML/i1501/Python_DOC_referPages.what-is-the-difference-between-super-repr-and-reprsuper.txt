<div class="post-text" itemprop="text">
<p>In python (3.5.2), I was expecting the <code>repr(obj)</code> function to call the magic method <code>__repr__()</code> of <code>obj</code>'s class. 
However calling both of them do not seem to yield the same result. Can anyone explain why ?</p>
<p>Sample code : </p>
<pre><code>class parent:

    def __init__(self):
        self.a = "haha"

    def __repr__(self):
        return repr(self.a)

class child(parent):
    def __init__(self):
        super().__init__()
        self.b="bebe"

    def __repr__(self):
        return "("+super().__repr__()+", "+repr(super())+", "+self.b+")"

    def print1(self):
        print("super().__repr__() returns:", super().__repr__())
        print("repr(super()) returns:", repr(super()))
        print("plom(super()).__repr__() returns:", plom(super()).__repr__())
        print("repr(plom(super())) returns:", repr(plom(super())))

def plom(var):
    return var

t=child()
print(t.__repr__())
print(repr(t))
print('-----')
t.print1()
print('-----')
print(plom(t).__repr__())
print(repr(plom(t)))
</code></pre>
<p>result : </p>
<pre><code>&gt;&gt;&gt; 
 RESTART: test super.py 
('haha', &lt;super: &lt;class 'child'&gt;, &lt;child object&gt;&gt;, bebe)
('haha', &lt;super: &lt;class 'child'&gt;, &lt;child object&gt;&gt;, bebe)
-----
super().__repr__() returns: 'haha'
repr(super()) returns: &lt;super: &lt;class 'child'&gt;, &lt;child object&gt;&gt;
plom(super()).__repr__() returns: 'haha'
repr(plom(super())) returns: &lt;super: &lt;class 'child'&gt;, &lt;child object&gt;&gt;
-----
('haha', &lt;super: &lt;class 'child'&gt;, &lt;child object&gt;&gt;, bebe)
('haha', &lt;super: &lt;class 'child'&gt;, &lt;child object&gt;&gt;, bebe)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Calling <code>repr(super())</code> directly accesses the <code>__repr__</code> on the <code>super</code> <em>class</em> (technically, the <code>tp_repr</code> of the C <code>PyTypeObject</code> struct defining the <code>super</code> type). Most special dunder methods behave this way when called implicitly (as opposed to explicitly calling them as methods). <code>repr(x)</code> isn't equivalent to <code>x.__repr__()</code>. You can think of <code>repr</code> as being defined as:</p>
<pre><code>def repr(obj):
    return type(obj).__repr__(obj)  # Call unbound function of class with instance as arg
</code></pre>
<p>while you were expecting it to be:</p>
<pre><code>def repr(obj):
    return obj.__repr__()  # Call bound method of instance
</code></pre>
<p>This behavior is intentional; one, customizing dunder methods per-instance makes little sense, and two, prohibiting it allows for much more efficient code at the C level (it has much faster ways of doing what the illustrative methods above do).</p>
<p>By contrast, <code>super().__repr__()</code> looks up the method on the <code>super</code> <em>instance</em>, and <code>super</code> defines a custom <code>tp_getattro</code> (roughly equivalent to defining a custom <code>__getattribute__</code> method), which means lookups on the instance are intercepted before they find the <code>tp_repr</code>/<code>__repr__</code> of the class, and instead are dispatched through the custom attribute getter (which performs the superclass delegation).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you consult<a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"> the docs</a>, you'll see that <code>super</code> returns a proxy object which delegates method calls to the appropriate class according to method resolution order.</p>
<p>So <code>repr(super())</code> gets you the representation of the proxy object. Whereas the method call <code>super().__repr__()</code> gives you the representation defined by the next class in the method resolution order.</p>
<p>If you want the superclass itself, try</p>
<pre><code>my_object.__mro__[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In <code>super().__repr__()</code> you're calling the repr class of the super object so you get <code>'haha'</code></p>
<p>In the second, you're calling repr of the <code>super()</code>. what does <code>super()</code> output? <code>&lt;super: &lt;class 'child'&gt;, &lt;child object&gt;&gt;</code> so you're effectively calling repr on some class hierarchy</p>
</div>
<span class="comment-copy">Because <code>super</code> returns a proxy object, not the class itself.</span>
<span class="comment-copy">How can I get the superclass from my object itself from it, then ? and why does it work with <code>__repr__()</code> ? In what way is <code>repr</code> different from <code>__repr__</code> ?</span>
<span class="comment-copy">This doesn't make any sense to me : Why would super() output something different between super().__repr__() and repr(super()) ?</span>
<span class="comment-copy">I added some cases and I don't understand why <code>super()</code> would make that difference when my <code>plom(t)</code> function doesn't. Isn't super a regular function ?</span>
