<div class="post-text" itemprop="text">
<p>Are there any existing libraries to parse a string as an ipv4 or ipv6 address, or at least identify whether a string is an IP address (of either sort)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there is <code>ipaddr</code> module, that can you help to check if a string is a IPv4/IPv6 address, and to detect its version.</p>
<pre><code>import ipaddr
import sys

try:
   ip = ipaddr.IPAddress(sys.argv[1])
   print '%s is a correct IP%s address.' % (ip, ip.version)
except ValueError:
   print 'address/netmask is invalid: %s' % sys.argv[1]
except:
   print 'Usage : %s  ip' % sys.argv[0]
</code></pre>
<p>But this is not a standard module, so it is not always possible to use it.
You also try using the standard <code>socket</code> module:</p>
<pre><code>import socket

try:
    socket.inet_aton(addr)
    print "ipv4 address"
except socket.error:
    print "not ipv4 address"
</code></pre>
<p>For IPv6 addresses you must use <code>socket.inet_pton(socket.AF_INET6, address)</code>.</p>
<p>I also want to note, that <code>inet_aton</code> will try to convert (and really convert it) addresses like <code>10</code>, <code>127</code> and so on, which do not look like IP addresses.</p>
</div>
<div class="post-text" itemprop="text">
<p>For IPv4, you can use</p>
<pre><code>socket.inet_aton(some_string)
</code></pre>
<p>If it throws an exception, <code>some_string</code> is not a valid ip address</p>
<p>For IPv6, you can use:</p>
<pre><code>socket.inet_pton(socket.AF_INET6, some_string)
</code></pre>
<p>Again, it throws an exception, if <code>some_string</code> is not a valid address.</p>
</div>
<div class="post-text" itemprop="text">
<p>IPv4 + IPv6 solution relying only on standard library. Returns <code>4</code> or <code>6</code> or raises <code>ValueError</code>.</p>
<pre><code>try:
    # Python 3.3+
    import ipaddress

    def ip_kind(addr):
        return ipaddress.ip_address(addr).version

except ImportError:
    # Fallback
    import socket

    def ip_kind(addr):
        try:
            socket.inet_aton(addr)
            return 4
        except socket.error: pass
        try:
            socket.inet_pton(socket.AF_INET6, addr)
            return 6
        except socket.error: pass
        raise ValueError(addr)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>netaddr</code> library. It has valid_ipv4/valid_ipv6 methods:</p>
<pre><code>import netaddr
if netaddr.valid_ipv4(str_ip) is True:
    print("IP is IPv4")
else:
    if netaddr.valid_ipv6(str_ip) is True:
        print("IP is IPv6")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://pypi.python.org/pypi/ipaddr/2.0.0" rel="nofollow">ipaddr</a> -- Google's IP address manipulation package.</p>
<p>Note that a proposal to include a revised version of the package in the Python standard library has recently been accepted (see <a href="http://www.python.org/dev/peps/pep-3144/" rel="nofollow">PEP 3144</a>). </p>
</div>
<div class="post-text" itemprop="text">
<p>Try </p>
<pre><code>apt-get install python-ipaddr
</code></pre>
<p>or get the source code from  <a href="http://code.google.com/p/ipaddr-py/" rel="nofollow">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you know for sure that the address is valid and only trying to decide whether it is ipv4 or ipv6, wouldn't it be sufficient to do just:</p>
<pre><code>if ":" in address:
    print("Ipv6")
else:
    print("Ipv4")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer ip_interface because it handles situations both with and without prefix mask, for example, both "10.1.1.1/24" as well as simply "10.1.1.1".  Needless to say, works for both v4 as well as v6</p>
<pre><code>from ipaddress import ip_interface
ip_interface("10.1.1.1/24").ip
ip_interface("10.1.1.1/24").ip.version
ip_interface("10.1.1.1").ip
ip_interface("10.1.1.1").ip.version
</code></pre>
</div>
<span class="comment-copy">AttributeError: 'module' object has no attribute 'ip_address'</span>
<span class="comment-copy">@Blazemore: in new versions of the module use <code>IPAddress</code>; fixed my answer; thank you for the suggestion!</span>
<span class="comment-copy">Just to add little bit background the socket impl is way faster.</span>
<span class="comment-copy">socket implementation is way faster, i have a function that tests either ipv4, or ipv6 with ports. So it must invoke a call to ipaddress or socket to check. In case of mixed IPs and a lot of calls it's worth to use socket:      ipaddres:     127.0.0.1:5000 100000 runs     0.700674057007          ::1 100000 runs     0.607309103012          [::1]:5000 100000 runs     0.051575899124          socket     127.0.0.1:5000 100000 runns     0.172153949738          ::1 100000 runns     0.0361239910126          [::1]:5000 100000 runns     0.0545198917389</span>
<span class="comment-copy">Note that since this was posted, ipaddr is now ipaddress and part of the standard the Python 3 library along with a Python 2 backport: <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer">docs.python.org/3/library/ipaddress.html</a></span>
<span class="comment-copy">This only works vor IPv4 adresses, though.</span>
<span class="comment-copy">@Sven, I added a way for v6, it's just a little more complicated</span>
<span class="comment-copy">These are Unix only solutions. If you're looking for a cross-platform solution, they won't work.</span>
<span class="comment-copy">Note that while this library indeed has been accepted for inclusion in the standard library, it is not included in any stable Python release yet.  (Of course you can still install the PyPI version.)</span>
<span class="comment-copy">@Sven Marnach -- good point, have edited to reflect this.</span>
<span class="comment-copy">I didn't know it was an IP. I needed to check if it was an IP. I updated the question for clarity.</span>
