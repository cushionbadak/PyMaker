<div class="post-text" itemprop="text">
<p>I have some legacy code with a legacy function that takes a filename as an argument and processes the file contents.  A working facsimile of the code is below.</p>
<p>What I want to do is not have to write to disk with some content that I generate in order to use this legacy function, so I though I could use <code>StringIO</code> to create an object in place of the physical filename.  However, this does not work, as you can see below.</p>
<p>I thought <code>StringIO</code> was the way to go with this.  Can anyone tell me if there is a way to use this legacy function and pass it something in the argument that isn't a file on disk but can be treated as such by the legacy function?  The legacy function does have the <code>with</code> context manager doing work on the <code>filename</code> parameter value.</p>
<p>The one thing I came across in google was: <a href="http://bugs.python.org/issue1286" rel="noreferrer">http://bugs.python.org/issue1286</a>, but that didn't help me...</p>
<p><strong>Code</strong></p>
<pre><code>from pprint import pprint
import StringIO

    # Legacy Function
def processFile(filename):
    with open(filename, 'r') as fh:
        return fh.readlines()

    # This works
print 'This is the output of FileOnDisk.txt'
pprint(processFile('c:/temp/FileOnDisk.txt'))
print

    # This fails
plink_data = StringIO.StringIO('StringIO data.')
print 'This is the error.'
pprint(processFile(plink_data))
</code></pre>
<p><strong>Output</strong></p>
<p>This is the output in <code>FileOnDisk.txt</code>:</p>
<pre><code>['This file is on disk.\n']
</code></pre>
<p>This is the error:</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "C:\temp\test.py", line 20, in &lt;module&gt;
    pprint(processFile(plink_data))
  File "C:\temp\test.py", line 6, in processFile
    with open(filename, 'r') as fh:
TypeError: coercing to Unicode: need string or buffer, instance found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <code>StringIO</code> instance <em>is</em> an open file already. The <code>open</code> command, on the other hand, only takes filenames, to return an open file. A <code>StringIO</code> instance is not suitable as a filename.</p>
<p>Also, you don't need to close a <code>StringIO</code> instance, so there is no need to use it as a context manager either.</p>
<p>If all your legacy code can take is a filename, then a <code>StringIO</code> instance is not the way to go. Use the <a href="http://docs.python.org/library/tempfile.html" rel="nofollow noreferrer"><code>tempfile</code> module</a> to generate a temporary filename instead.</p>
<p>Here is an example using a contextmanager to ensure the temp file is cleaned up afterwards:</p>
<pre><code>import os
import tempfile
from contextlib import contextmanager

@contextmanager
def tempinput(data):
    temp = tempfile.NamedTemporaryFile(delete=False)
    temp.write(data)
    temp.close()
    try:
        yield temp.name
    finally:
        os.unlink(temp.name)

with tempinput('Some data.\nSome more data.') as tempfilename:
    processFile(tempfilename)
</code></pre>
<p>You can also switch to the newer Python 3 infrastructure offered by the <code>io</code> module (available in Python 2 and 3), where <a href="https://docs.python.org/3/library/io.html#io.BytesIO" rel="nofollow noreferrer"><code>io.BytesIO</code></a> is the more robust replacement for <code>StringIO.StringIO</code> / <code>cStringIO.StringIO</code>. This object does support being used as a context manager (but still can't be passed to <code>open()</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>you could define your own open function</p>
<pre><code>fopen = open
def open(fname,mode):
    if hasattr(fname,"readlines"): return fname
    else: return fopen(fname,mode)
</code></pre>
<p>however with wants to call __exit__ after its done and StringIO does not have an exit method... </p>
<p>you could define a custom class to use with this open</p>
<pre><code>class MyStringIO:
     def __init__(self,txt):
         self.text = txt
     def readlines(self):
          return self.text.splitlines()
     def __exit__(self):
          pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one is based on the python doc of <a href="https://docs.python.org/2/library/contextlib.html" rel="nofollow noreferrer">contextmanager</a></p>
<p>It's just wrapping StringIO with simple context, and when <strong>exit</strong> is called, it will return to the yield point, and properly close the StringIO. This avoids the need of making tempfile, but with large string, this will still eat up the memory, since StringIO buffer that string.
It works well on most cases where you know the string data is not going to be long</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def buildStringIO(strData):
    from cStringIO import StringIO
    try:
        fi = StringIO(strData)
        yield fi
    finally:
        fi.close()
</code></pre>
<p>Then you can do:</p>
<pre><code>with buildStringIO('foobar') as f:
    print(f.read()) # will print 'foobar'
</code></pre>
</div>
<span class="comment-copy">you cant "Open" a stringIO instance</span>
<span class="comment-copy">I'm using this solution.  Here is a link to sample code that implements this directly: <a href="http://pastie.org/4450354" rel="nofollow noreferrer">pastie.org/4450354</a> .  Thank you to everyone that contributed here!</span>
<span class="comment-copy">@mpettis: I've updated my answer to give an example using a context manager that will create the temporary file and clean it up for you in one go.</span>
<span class="comment-copy">That is really an elegant way tho handle this... Thanks!</span>
<span class="comment-copy">@MartijnPieters: is there a reason you rather unlink the file after the yield statement, instread of just closing it, or is it just for the sake of providing an example usage?</span>
<span class="comment-copy">@mike: Because of the <code>delete=False</code> argument when it was created, the named temporary file will <i>not</i> be deleted as soon as it is closed â€” read the <a href="https://docs.python.org/2/library/tempfile.html#tempfile.NamedTemporaryFile" rel="nofollow noreferrer">docs</a>. Seems like that would have been fairly obvious from the <code>temp.close()</code> just before the <code>yield temp.name</code> statement...</span>
<span class="comment-copy">Unfortunately that does not solve the problem since it would have to be inside of the legacy function</span>
<span class="comment-copy">wouldnt this open override it as long as it was in the same file?</span>
<span class="comment-copy">@jdi I think it might work if it was defined before the legacy function, i.e. when the legacy module is imported.</span>
<span class="comment-copy">Actually the only way to make the legacy module pick up the custom open is to define the new <code>open</code> first, then import the legacy module, and do:  <code>legacy.open = open</code>. Because the legacy module is using its own scope.</span>
<span class="comment-copy">I started to make another answer but quickly realized it was only half the problem, which your second example covers. You could suggest using <a href="http://docs.python.org/library/tempfile.html#tempfile.SpooledTemporaryFile" rel="nofollow noreferrer">tempfile.SpooledTenporaryFile</a> with a <code>max_size=10e8</code> or something high. This will be a file-like object, using StringIO under the hood, and already has a context manager.</span>
<span class="comment-copy">This can be done with the standard library: "with closing(StringIO(.... data ....)) as f:"</span>
