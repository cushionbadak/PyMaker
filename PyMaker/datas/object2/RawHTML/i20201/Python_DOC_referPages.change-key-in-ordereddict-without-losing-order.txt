<div class="post-text" itemprop="text">
<p>Starting with</p>
<pre><code>OrderedDict([('a', 1), ('c', 3), ('b', 2)])
</code></pre>
<p>is it possible to end up with</p>
<pre><code>OrderedDict([('a', 1), ('__C__', 3), ('b', 2)])
</code></pre>
<p>making sure that the <code>'__C__'</code> item is before <code>'b'</code> and after <code>'a'</code> i.e. keeping order?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try:</p>
<pre><code>&gt;&gt;&gt; d = OrderedDict([('a', 1), ('c', 3), ('b', 2)])
&gt;&gt;&gt; d
OrderedDict([('a', 1), ('c', 3), ('b', 2)])
&gt;&gt;&gt; d2 = OrderedDict([('__C__', v) if k == 'c' else (k, v) for k, v in d.items()])
&gt;&gt;&gt; d2
OrderedDict([('a', 1), ('__C__', 3), ('b', 2)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you wish to mutate the current dictionary object:</p>
<pre><code>def change_key(self, old, new):
    for _ in range(len(self)):
        k, v = self.popitem(False)
        self[new if old == k else k] = v
</code></pre>
<p>This works by iterating over the whole <code>OrderedDict</code> (using its length), and <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">pop'ing its first item</a> (by passing <code>False</code> to <code>.popitem()</code>: the default of this method is to pop the last item) into <code>k</code> and <code>v</code> (respectively standing for <em>key</em> and <em>value</em>); and then inserting this key/value pair, or the new key with its original value, at the end of the <code>OrderedDict</code>.</p>
<p>By repeating this logic for the entire size of the dict, it effectively rotates the dict completely, thus recreating the original order.</p>
</div>
<span class="comment-copy">You need to either create a new OrderedDict or use <code>move_to_end</code> method on each item after <code>c</code></span>
<span class="comment-copy">You can't do it efficiently like you could for a <code>list</code>. If the dictionarys are big and you need to be doing this, possibly <code>OrderedDict</code> is not the best choice of datastructure</span>
<span class="comment-copy">Bruteforce FTW :)</span>
<span class="comment-copy">Why not: <code>d2 = OrdededDict([('__C__' if k == 'c' else k, v) for k, v in d.items()])</code> ?</span>
<span class="comment-copy">Same as above, but longer</span>
<span class="comment-copy">@TahaJahangir not exactly, this answer does not create a new dict. This can sometimes be desired and sometimes undesired.</span>
