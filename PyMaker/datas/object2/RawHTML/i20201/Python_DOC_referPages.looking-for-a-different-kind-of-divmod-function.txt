<div class="post-text" itemprop="text">
<p>Python's <code>divmod</code> function works properly, and it is almost what I want. However, its behavior with non-integer numbers needs to be slightly different for an operation that needs to be performed. When running the following code, you might see what it is that is trying to be done.</p>
<pre><code>&gt;&gt;&gt; function = divmod
&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; function(pi * pi, pi) == (pi, 0)
False
&gt;&gt;&gt; 
</code></pre>
<p><em>How can <code>function</code> be defined above such that the final expression evaluates to <code>True</code>, not <code>False</code>?</em> If anyone can figure out how to get <code>(pi, 0)</code> instead of <code>(3.0, 0.4448...)</code>, that would be the answer.</p>
<p><strong>Edit 1:</strong> Now for a more complicated example, the following code should yield <code>[3, 2, 1, 3, 2, 1]</code>.</p>
<pre><code>&gt;&gt;&gt; x = 1 * pi ** 5 + \
        2 * pi ** 4 + \
        3 * pi ** 3 + \
        1 * pi ** 2 + \
        2 * pi ** 1 + \
        3 * pi ** 0
&gt;&gt;&gt; digits = []
&gt;&gt;&gt; while x:
        x, y = function(x, pi)
        digits.append(y)


&gt;&gt;&gt; digits
[0.3989191524449005, 0.2212554774328268, 2.309739581793931, 0.1504440784612413,
2.858407346410207, 1.0]
&gt;&gt;&gt; 
</code></pre>
<p><strong>Edit 2:</strong> The following shows code that works fine except that it has unexpected but valid output.</p>
<pre><code>import math

def convert_dec_to_pi(number):
    digits = get_pi_digits(number)
    digits, remainder = correct_pi_digits(digits)
    return make_pi_string(digits, remainder)

def get_pi_digits(number):
    digits = []
    while number:
        number, digit = divmod(number, math.pi)
        digits.append(digit)
    digits.reverse()
    return digits

def correct_pi_digits(digits):
    last = len(digits) - 1
    for index, digit in enumerate(digits):
        if index &lt; last and digit % 1 != 0:
            a, b = get_digit_options(digit, digits[index + 1])
            digits[index:index+2] = a if 0 &lt;= a[1] &lt; math.pi else b
    digit, remainder = divmod(digits[-1], 1)
    digits[-1] = digit
    return digits, remainder

def get_digit_options(digit, next_digit):
    a, b = math.floor(digit), math.ceil(digit)
    if a not in range(4):
        return (b, (digit - b) * math.pi + next_digit), None
    if b not in range(4):
        return (a, (digit - a) * math.pi + next_digit), None
    c, d = ((a, (digit - a) * math.pi + next_digit),
            (b, (digit - b) * math.pi + next_digit))
    return (c, d) if digit - a &lt; 0.5 else (d, c)

def make_pi_string(digits, remainder):
    return '{} base \u03C0 + {} base 10'.format(
        ''.join(str(int(d)) for d in digits), remainder)
</code></pre>
<p>The following function can be used to reverse the operation and check the results.</p>
<pre><code>import re

def convert_pi_to_dec(string):
    match = re.search('^(\\d+) base \u03C0 \\+ (0\\.\\d+) base 10$', string)
    if not match:
        raise ValueError()
    digits, remainder = match.groups()
    return sum(int(x) * math.pi ** y for y, x in enumerate(reversed(digits))) \
           + float(remainder)
</code></pre>
<p>The following code does not raise an <code>AssertionError</code>, so it is evident that everything is working fine.</p>
<pre><code>for n in range(1, 36):
    value = convert_dec_to_pi(n)
    print(value)
    assert convert_pi_to_dec(value) == n
</code></pre>
<p>So then this brings me to the following example. The output can be converted back without a problem, but one would expect something slightly different.</p>
<pre><code>&gt;&gt;&gt; convert_dec_to_pi(math.pi * math.pi)
'30 base π + 0.44482644031997864 base 10'
&gt;&gt;&gt; convert_pi_to_dec(_) == math.pi * math.pi
True
&gt;&gt;&gt; 
</code></pre>
<p>The string should have been <code>100 base π + 0.0 base 10</code>. The output is accurate but not "proper" at this point.</p>
<p><strong>Edit 3:</strong> The following example may provide some extra insight into what I am after. After running a loop with different powers of π, I would expect all outputs to be <code>10... base π + 0.0 base 10</code> in their form. The results are different from this as shown below.</p>
<pre><code>&gt;&gt;&gt; for power in range(20):
    print(convert_dec_to_pi(math.pi ** power))


1 base π + 0.0 base 10
10 base π + 0.0 base 10
30 base π + 0.44482644031997864 base 10
231 base π + 0.8422899173517213 base 10
2312 base π + 0.6461318165449161 base 10
23122 base π + 0.029882968108176033 base 10
231220 base π + 0.0938801130760924 base 10
2312130 base π + 0.7397595138779653 base 10
23121302 base π + 0.3240230542211062 base 10
231213021 base π + 0.017948446735832846 base 10
2312130210 base π + 0.05638670840988885 base 10
23121302100 base π + 0.17714406890720072 base 10
231213021000 base π + 0.5565145054551264 base 10
2312130133130 base π + 0.6366321966964654 base 10
23121301331302 base π + 3.9032618162071486e-05 base 10
231213013313020 base π + 0.00012262302157861615 base 10
2312130133123211 base π + 0.24905356925301847 base 10
23121301331232110 base π + 0.7824248909895828 base 10
231213013312321102 base π + 0.4580601707952492 base 10
2312130133123211021 base π + 0.4390387422112354 base 10
&gt;&gt;&gt; convert_pi_to_dec('2312130133123211021 base π + 0.4390387422112354 base 10')
2791563949.5978436
&gt;&gt;&gt; convert_pi_to_dec('10000000000000000000 base π + 0.0 base 10')
2791563949.5978436
&gt;&gt;&gt; 
</code></pre>
<p>Also shown is how the last two strings are equivalent, yet the output should have been in the form of the second string. I find it fascinating that the difference between <code>10000000000000000000 base π</code> and <code>2312130133123211021 base π</code> is <code>0.4390387422112354 base 10</code>, but that difference has a large influence over the representation. The output should have been as shown below.</p>
<pre><code>1 base π + 0.0 base 10
10 base π + 0.0 base 10
100 base π + 0.0 base 10
1000 base π + 0.0 base 10
10000 base π + 0.0 base 10
100000 base π + 0.0 base 10
1000000 base π + 0.0 base 10
10000000 base π + 0.0 base 10
100000000 base π + 0.0 base 10
1000000000 base π + 0.0 base 10
10000000000 base π + 0.0 base 10
100000000000 base π + 0.0 base 10
1000000000000 base π + 0.0 base 10
10000000000000 base π + 0.0 base 10
100000000000000 base π + 0.0 base 10
1000000000000000 base π + 0.0 base 10
10000000000000000 base π + 0.0 base 10
100000000000000000 base π + 0.0 base 10
1000000000000000000 base π + 0.0 base 10
10000000000000000000 base π + 0.0 base 10
</code></pre>
<p><em>Is there something that I am missing, is there a solution to this problem, or should this be considered a fool's errand?</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for an algorithm to determine a <a href="http://en.wikipedia.org/wiki/Non-integer_representation" rel="nofollow">non-integer base</a> representation of a floating-point number.</p>
<p>Wikipedia describes a greedy algorithm due to Rényi and Frougny; here's an attempt at an implementation:</p>
<pre><code>from math import log, floor
def expansion(x, b):
    k = int(floor(log(x) / log(b)))
    d, r = divmod(x / float(b ** k), 1)
    digits = [int(d)]
    for _ in range(k):
        d, r = divmod(b * r, 1)
        digits.append(int(d))
    def rest(b, d, r):
        while r:
            d, r = divmod(b * r, 1)
            yield int(d)
    return digits, rest(b, d, r)
</code></pre>
<p>This gives the lexicographically initial expansion; you can get the lexicographically terminal expansion with a little fiddling:</p>
<pre><code>def expansion(x, b, greedy=True):
    if not greedy:
        m = (floor(b) / (b - 1)) - 1
    k = int(floor(log(x) / log(b)))
    d, r = divmod(x / float(b ** k), 1)
    if not greedy and r &lt; m:
        d, r = d - 1, r + 1
    digits = [int(d)]
    for _ in range(k):
        d, r = divmod(b * r, 1)
        if not greedy and r &lt; m:
            d, r = d - 1, r + 1
        digits.append(int(d))
    def rest(d, r):
        while r:
            d, r = divmod(b * r, 1)
            if not greedy and r &lt; m:
                d, r = d - 1, r + 1
            yield int(d)
    return digits, rest(d, r)
</code></pre>
<p>Unfortunately this still won't quite work, as OP's expansion is non-greedy in the first digit but greedy in the last digit.</p>
</div>
<div class="post-text" itemprop="text">
<p>Recognize that floating point arithmetic is by definition imprecise.  Operations like <code>pi*pi</code> are not guaranteed to equal the mathematical constant <code>π^2</code> (for that matter <a href="http://docs.python.org/library/math.html#math.pi" rel="nofollow"><code>math.pi</code></a> is only as accurate as "available precision" - meaning it's not the right value either).  Therefore it's not actually possible to do operations on floating point numbers that treat them like real numbers.</p>
<p>The general solution is to check for a distance from some epsilon value, but this has obvious limitations.  You'll do better to re-examine your underlying requirements (why do you need real-number precision?) and try to solve the problem from a different direction.</p>
<p>For the example you describe, why do you need to actually use a value for π?  Could you just leave the actual calculation of π off til the very end, and do your operations only on the coefficients?</p>
<p>For instance, store the list <code>[3, 2, 1, 3, 2, 1]</code> directly, and do your operations and transformations with the implicit contract that they are coefficients, then define something like:</p>
<pre><code>toFloat(ls,mult):
  pow = 0
  ret = 0
  for coef in ls:
    ret += coef * mult**pow
    pow += 1
  return ret
</code></pre>
<p>as the very last step before printing.  Even better, you could wrap this behavior up in a class (and I'd be willing to bet someone has done this before) and make <code>__str__()</code> do <code>toFloat()</code>'s behavior, so that displaying your object gives you the most precise value you can get.</p>
</div>
<div class="post-text" itemprop="text">
<p>This one is pretty simple and seems to work better than OPs. I think the flaws in the results are precision related:</p>
<pre><code>import math
import struct
import os
from decimal import Decimal, getcontext

getcontext().prec = 1000

def digits_base_b(n, b):
    n = Decimal(n)
    b = Decimal(b)
    digits = {}
    while n &gt;= b:
        exp = int(math.log(n, b))
        digit = int(n/b**exp)
        digits[exp] = digit
        n -= digit*b**exp
    return digits, n # n is less than b**1, idk how you want to handle those

def digits_2_str(digits, base):
    exps = sorted(digits, reverse=True)
    result = []
    format_spec = '%d*'+base+'^%d'
    for exp in exps:
        result.append(format_spec % (digits[exp], exp))
    return ' + '.join(result)

pi = Decimal(
'3.14159265358979323846264338327950288419716939937510'
'58209749445923078164062862089986280348253421170679'
'82148086513282306647093844609550582231725359408128'
'48111745028410270193852110555964462294895493038196'
'44288109756659334461284756482337867831652712019091'
'45648566923460348610454326648213393607260249141273'
'72458700660631558817488152092096282925409171536436'
'78925903600113305305488204665213841469519415116094'
'33057270365759591953092186117381932611793105118548'
'07446237996274956735188575272489122793818301194912'
'98336733624406566430860213949463952247371907021798'
'60943702770539217176293176752384674818467669405132'
'00056812714526356082778577134275778960917363717872'
'14684409012249534301465495853710507922796892589235'
'42019956112129021960864034418159813629774771309960'
'51870721134999999837297804995105973173281609631859'
'50244594553469083026425223082533446850352619311881'
'71010003137838752886587533208381420617177669147303'
'59825349042875546873115956286388235378759375195778'
'18577805321712268066130019278766111959092164201989'
)

if __name__ == '__main__':
    random_float = lambda: struct.unpack('d', os.urandom(8))[0]
    x = random_float()
    while x &lt; pi: # some floats are no good, i've only tested with positives
        x = random_float()

    digits, leftover = digits_base_b(x, pi)
    print x, '='
    print digits_2_str(digits, u'\u03C0')

    for i in range(20):
        digits, leftover = digits_base_b(pi**i, pi)
        print float(pi**i), '=', digits_2_str(digits, u'\u03C0'), '+', float(leftover)
</code></pre>
<p><strong>UPDATE</strong>
I got the first thousand digits of pi off the internet, and used that and decimal.Decimal and got a few less errors, but there was still a couple. Therefore, I'm confident difference is related to precision. Also,  amount of time the computation takes increases dramatically as the precision increases.</p>
</div>
<span class="comment-copy">So basically, you want the remainder to always be 0? Then why use <code>divmod</code>? Just use division!</span>
<span class="comment-copy">Semi serious answer: use the piecewise function <code>func = lambda x,y: (pi,0) if x== pi*pi and y == pi else divmod(x,y)</code>. If that's not sufficient, please show some more sample input/output. It's difficult to derive an equation from one data point.</span>
<span class="comment-copy">Please see the edit. Your function would work well with the first example. However, it is the second application that I am after.</span>
<span class="comment-copy">I'm not sure that the greedy algorithm will give the OP the desired results, though.  ISTM the first greedy digit would be 2, and the rep wouldn't terminate.</span>
<span class="comment-copy">It's complicated due to the fact that non-integer base representations are often not unique. Just like <code>1</code> in base 10 can also be representaed as <code>.9999...</code>, the example number, the number represented as <code>123123</code> in base pi is almost the same as <code>2000000</code> (though the latter has some fractional bits left off). The greedy algorithm prefers the latter form, and I'm not sure there's a way to get the alternative version.</span>
<span class="comment-copy">The example number was fine. Executing <code>convert_dec_to_pi(1 * pi ** 5 + 2 * pi ** 4 + 3 * pi ** 3 + 1 * pi ** 2 + 2 * pi ** 1 + 3 * pi ** 0 + 0.0000000000001)</code> returns <code>'123123 base π + 3.597122599785507e-14 base 10'</code>, and that is close enough. However, it was disappointing that running <code>convert_dec_to_pi(pi * pi)</code> does not return <code>'100 base π + 0.0 base 10'</code>.</span>
<span class="comment-copy">I don't think the questioner's issue has with floating point precision (though that might come up later, if the conceptual issues get solved first).</span>
<span class="comment-copy">Hmm, I interpreted expecting <code>divmod(pi * pi, pi) == (pi, 0)</code> to be True to be a misunderstanding of floating point operations.  The second example similarly wants to apply and then strip off powers of π as if they were exact values that could be added and removed at will.  To OP - if this isn't a helpful answer, please add more backstory to your question.</span>
<span class="comment-copy">The problem is, I do not have the coefficients. My desire is to extract the coefficients. The second edit should help to explain the situation better.</span>
<span class="comment-copy"><code>divmod(pi * pi, pi)</code> is <code>(3.0, 0.44482644031997864)</code> on my Pythons 2 and 3. Not a matter of precision. <a href="https://docs.python.org/3/library/functions.html#divmod" rel="nofollow noreferrer">"For floating point numbers the result is (q, a % b), where q is usually math.floor(a / b) ..."</a></span>
