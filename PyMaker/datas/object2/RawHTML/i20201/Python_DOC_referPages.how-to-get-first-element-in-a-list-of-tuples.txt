<div class="post-text" itemprop="text">
<p>I have a list like below where the first element is the id and the other is a string:</p>
<pre><code>[(1, u'abc'), (2, u'def')]
</code></pre>
<p>I want to create a list of ids only from this list of tuples as below:</p>
<pre><code>[1,2]
</code></pre>
<p>I'll use this list in <code>__in</code> so it needs to be a list of integer values.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; a = [(1, u'abc'), (2, u'def')]
&gt;&gt;&gt; [i[0] for i in a]
[1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the zip function to decouple elements:</p>
<pre><code>&gt;&gt;&gt; inpt = [(1, u'abc'), (2, u'def')]
&gt;&gt;&gt; unzipped = zip(*inpt)
&gt;&gt;&gt; print unzipped
[(1, 2), (u'abc', u'def')]
&gt;&gt;&gt; print list(unzipped[0])
[1, 2]
</code></pre>
<p><strong>Edit</strong> (@BradSolomon):
The above works for Python 2.x, where <code>zip</code> returns a list.</p>
<p>In Python 3.x, <code>zip</code> returns an iterator and the following is equivalent to the above:</p>
<pre><code>&gt;&gt;&gt; print(list(list(zip(*inpt))[0]))
[1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>do you mean something like this?</p>
<pre><code>new_list = [ seq[0] for seq in yourlist ]
</code></pre>
<p>What you actually have is a list of <code>tuple</code> objects, not a list of sets (as your original question implied).  If it is actually a list of sets, then <em>there is no first element</em> because sets have no order.</p>
<p>Here I've created a flat list because generally that seems more useful than creating a list of 1 element tuples.  However, you can easily create a list of 1 element tuples by just replacing <code>seq[0]</code> with <code>(seq[0],)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use "tuple unpacking":</p>
<pre><code>&gt;&gt;&gt; my_list = [(1, u'abc'), (2, u'def')]
&gt;&gt;&gt; my_ids = [idx for idx, val in my_list]
&gt;&gt;&gt; my_ids
[1, 2]
</code></pre>
<p>At iteration time each tuple is unpacked and its values are set to the variables <code>idx</code> and <code>val</code>. </p>
<pre><code>&gt;&gt;&gt; x = (1, u'abc')
&gt;&gt;&gt; idx, val = x
&gt;&gt;&gt; idx
1
&gt;&gt;&gt; val
u'abc'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="noreferrer"><code>operator.itemgetter</code></a> is for. </p>
<pre><code>&gt;&gt;&gt; a = [(1, u'abc'), (2, u'def')]
&gt;&gt;&gt; import operator
&gt;&gt;&gt; b = map(operator.itemgetter(0), a)
&gt;&gt;&gt; b
[1, 2]
</code></pre>
<p>The <code>itemgetter</code> statement <em>returns a function</em> that returns the index of the element you specify. It's exactly the same as writing</p>
<pre><code>&gt;&gt;&gt; b = map(lambda x: x[0], a)
</code></pre>
<p>But I find that <code>itemgetter</code> is a clearer and <a href="https://www.python.org/dev/peps/pep-0020/#id3" rel="noreferrer">more explicit</a>. </p>
<p>This is handy for making compact sort statements. For example,</p>
<pre><code>&gt;&gt;&gt; c = sorted(a, key=operator.itemgetter(0), reverse=True)
&gt;&gt;&gt; c
[(2, u'def'), (1, u'abc')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From a performance point of view, in python3.X</p>
<ul>
<li><code>[i[0] for i in a]</code> and <code>list(zip(*a))[0]</code> are equivalent</li>
<li>they are faster than <code>list(map(operator.itemgetter(0), a))</code></li>
</ul>
<p><strong>Code</strong></p>
<pre><code>import timeit


iterations = 100000
init_time = timeit.timeit('''a = [(i, u'abc') for i in range(1000)]''', number=iterations)/iterations
print(timeit.timeit('''a = [(i, u'abc') for i in range(1000)]\nb = [i[0] for i in a]''', number=iterations)/iterations - init_time)
print(timeit.timeit('''a = [(i, u'abc') for i in range(1000)]\nb = list(zip(*a))[0]''', number=iterations)/iterations - init_time)
</code></pre>
<p><strong>output</strong></p>
<p>3.491014136001468e-05</p>
<p>3.422205176000717e-05</p>
</div>
<div class="post-text" itemprop="text">
<p>if the tuples are unique then this can work</p>
<pre><code>&gt;&gt;&gt; a = [(1, u'abc'), (2, u'def')]
&gt;&gt;&gt; a
[(1, u'abc'), (2, u'def')]
&gt;&gt;&gt; dict(a).keys()
[1, 2]
&gt;&gt;&gt; dict(a).values()
[u'abc', u'def']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>when I ran (as suggested above):</p>
<pre><code>&gt;&gt;&gt; a = [(1, u'abc'), (2, u'def')]
&gt;&gt;&gt; import operator
&gt;&gt;&gt; b = map(operator.itemgetter(0), a)
&gt;&gt;&gt; b
</code></pre>
<p>instead of returning:</p>
<pre><code>[1, 2]
</code></pre>
<p>I received this as the return:</p>
<pre><code>&lt;map at 0xb387eb8&gt;
</code></pre>
<p>I found I had to use list():</p>
<pre><code>&gt;&gt;&gt; b = list(map(operator.itemgetter(0), a))
</code></pre>
<p>to successfully return a list using this suggestion. That said, I'm happy with this solution, thanks. (tested/run using Spyder, iPython console, Python v3.6)</p>
</div>
<div class="post-text" itemprop="text">
<p>Those are tuples, not sets. You can do this:</p>
<pre><code>l1 = [(1, u'abc'), (2, u'def')]
l2 = [(tup[0],) for tup in l1]
l2
&gt;&gt;&gt; [(1,), (2,)]
</code></pre>
</div>
<span class="comment-copy">is the int conversion needed?</span>
<span class="comment-copy">No, not really. Even if you need to force typing to pass a typecheck, it would be better to type <code>a</code> as <code>List[Tuple[int, str]]</code> than to convert to int.  The conversion would only be necessary if you couldn't guarantee that the first element of each tuple is int, in which case you could use it as a form of validation.</span>
<span class="comment-copy">does this need a separate import?</span>
<span class="comment-copy">@JuliandotNut No, it's a built-in function. (in Python 2.x)</span>
<span class="comment-copy">I tried it. It gives this error: <code>int() argument must be a string or a number, not 'QuerySet'</code></span>
<span class="comment-copy">@wasimbhalli -- <code>int()</code> is nowhere in my solution, so the exception you're seeing must come later on in the code.</span>
<span class="comment-copy">I've updated the question, I need to use this list later in <code>__in</code> for filtering data</span>
<span class="comment-copy">what is <code>__in</code>? -- Based on the example input you've given, this will create a list of integers.  However, if your list of tuples doesn't start with integers, then you won't get integers and you'll need to make them integers via <code>int</code>, or try to figure out why your first element can't be converted to an integer.</span>
<span class="comment-copy">Does <code>new_list = [ seq[0] for seq in yourlist if type(seq[0]) == int]</code> work?</span>
<span class="comment-copy">This will lose the order.  It may work with <code>ordereddict</code>, though.</span>
<span class="comment-copy">Not really what is being asked</span>
