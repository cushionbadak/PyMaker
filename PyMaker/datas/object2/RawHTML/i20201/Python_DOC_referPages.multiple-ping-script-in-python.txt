<div class="post-text" itemprop="text">
<p>I'm unable to find any good easy to learn documentation on python and networking.  In this instance, I'm just trying to make a easy script which I can ping a number of remote machines.</p>
<pre><code>for ping in range(1,10):
   ip="127.0.0."+str(ping)
   os.system("ping -c 3 %s" % ip)
</code></pre>
<p>A simple script like that will ping the machines fine, but I'd like to get the script to returns 'active' 'no response'  Which makes me think I'll have to look up the time module as well, I think <code>time.sleep(5)</code> and after that, there would be a break statement. Which makes me think there should be a while loop inside for. I'm not 100% sure, I could be going in the wrong direction completely :/ if anyone could help or point me in the direction of some documentation that'd be great.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try <code>subprocess.call</code>. It saves the return value of the program that was used.</p>
<p>According to my ping manual, it returns 0 on success, 2 when pings were sent but no reply was received and any other value indicates an error.</p>
<pre><code># typo error in import
import subprocess

for ping in range(1,10):
    address = "127.0.0." + str(ping)
    res = subprocess.call(['ping', '-c', '3', address])
    if res == 0:
        print "ping to", address, "OK"
    elif res == 2:
        print "no response from", address
    else:
        print "ping to", address, "failed!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This script:</p>
<pre><code>import subprocess
import os
with open(os.devnull, "wb") as limbo:
        for n in xrange(1, 10):
                ip="192.168.0.{0}".format(n)
                result=subprocess.Popen(["ping", "-c", "1", "-n", "-W", "2", ip],
                        stdout=limbo, stderr=limbo).wait()
                if result:
                        print ip, "inactive"
                else:
                        print ip, "active"
</code></pre>
<p>will produce something like this output:</p>
<pre><code>192.168.0.1 active
192.168.0.2 active
192.168.0.3 inactive
192.168.0.4 inactive
192.168.0.5 inactive
192.168.0.6 inactive
192.168.0.7 active
192.168.0.8 inactive
192.168.0.9 inactive
</code></pre>
<p>You can capture the output if you replace <code>limbo</code> with <code>subprocess.PIPE</code> and use <code>communicate()</code> on the <code>Popen</code> object:</p>
<pre><code>p=Popen( ... )
output=p.communicate()
result=p.wait()
</code></pre>
<p>This way you get the return value of the command and can capture the text. Following the <a href="http://docs.python.org/library/subprocess.html" rel="noreferrer">manual</a> this is the preferred way to operate a subprocess if you need flexibility:</p>
<blockquote>
<p>The underlying process creation and management in this module is
  handled by the Popen class. It offers a lot of flexibility so that
  developers are able to handle the less common cases not covered by the
  convenience functions.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Thank you so much for this.  I have modified it to work with Windows.  I have also put a low timeout so, the IP's that have no return will not sit and wait for 5 seconds each.  This is from hochl source code.</p>
<pre><code>import subprocess
import os
with open(os.devnull, "wb") as limbo:
        for n in xrange(200, 240):
                ip="10.2.7.{0}".format(n)
                result=subprocess.Popen(["ping", "-n", "1", "-w", "200", ip],
                        stdout=limbo, stderr=limbo).wait()
                if result:
                        print ip, "inactive"
                else:
                        print ip, "active"
</code></pre>
<p>Just change the ip= for your scheme and the xrange for the hosts.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm a beginner and wrote a script to ping multiple hosts.To ping multiple host you can use ipaddress module. </p>
<pre><code>import ipaddress
from subprocess import Popen, PIPE

net4 = ipaddress.ip_network('192.168.2.0/24')
for x in net4.hosts():
    x = str(x)
    hostup = Popen(["ping", "-c1", x], stdout=PIPE)
    output = hostup.communicate()[0]
    val1 = hostup.returncode
 if val1 == 0:
    print(x, "is pinging")
 else:
    print(x, "is not responding")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To ping several hosts at once you could use <code>subprocess.Popen()</code>:</p>
<pre><code>#!/usr/bin/env python3
import os
import time
from subprocess import Popen, DEVNULL

p = {} # ip -&gt; process
for n in range(1, 100): # start ping processes
    ip = "127.0.0.%d" % n
    p[ip] = Popen(['ping', '-n', '-w5', '-c3', ip], stdout=DEVNULL)
    #NOTE: you could set stderr=subprocess.STDOUT to ignore stderr also

while p:
    for ip, proc in p.items():
        if proc.poll() is not None: # ping finished
            del p[ip] # remove from the process list
            if proc.returncode == 0:
                print('%s active' % ip)
            elif proc.returncode == 1:
                print('%s no response' % ip)
            else:
                print('%s error' % ip)
            break
</code></pre>
<p>If you can run as a root you could use a <a href="https://stackoverflow.com/a/317206/4279">pure Python ping script</a> or <a href="http://www.secdev.org/projects/scapy/doc/usage.html#icmp-ping" rel="nofollow noreferrer"><code>scapy</code></a>:</p>
<pre><code>from scapy.all import sr, ICMP, IP, L3RawSocket, conf

conf.L3socket = L3RawSocket # for loopback interface
ans, unans = sr(IP(dst="127.0.0.1-99")/ICMP(), verbose=0) # make requests
ans.summary(lambda (s,r): r.sprintf("%IP.src% is alive"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import subprocess
import os
'''
servers.txt contains ip address in following format
192.168.1.1
192.168.1.2
'''
    with open('servers.txt', 'r') as f:
        for ip in f:
            result=subprocess.Popen(["ping", "-c", "1", "-n", "-W", "2",    ip],stdout=f, stderr=f).wait()
            if result:
                print(ip, "inactive")
            else:
                print(ip, "active")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python actually has a really sweet <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow">method</a> that will 'return an iterator over the usable hosts in the network'. (setting strict to false iterates over all IPs)</p>
<p>For example:</p>
<pre><code>import subprocess
import ipaddress

subnet = ipaddress.ip_network('192.168.1.0/24', strict=False)
for i in subnet.hosts():
    i = str(i)
    subprocess.call(["ping", "-c1", "-n", "-i0.1", "-W1", i])
</code></pre>
<p>The wait interval (-i0.1) may be important for automations, even a one second timeout (-t1) can take forever over a .0/24</p>
<p><strong>EDIT</strong>:
So, in order to track ICMP (ping) requests, we can do something like this:</p>
<pre><code>#!/usr/bin/env python

import subprocess
import ipaddress

alive = []
subnet = ipaddress.ip_network('192.168.1.0/23', strict=False)
for i in subnet.hosts():
    i = str(i)
    retval = subprocess.call(["ping", "-c1", "-n", "-i0.1", "-W1", i])
    if retval == 0:
        alive.append(i)
for ip in alive:
    print(ip + " is alive") 
</code></pre>
<p>Which will return something like:</p>
<pre><code>192.168.0.1 is alive
192.168.0.2 is alive
192.168.1.1 is alive
192.168.1.246 is alive
</code></pre>
<p>i.e. all of the IPs responding to ICMP ranging over an entire /23-- Pretty cool!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import subprocess,os,threading,time
from queue import Queue
lock=threading.Lock()
_start=time.time()
def check(n):
    with open(os.devnull, "wb") as limbo:
                ip="192.168.21.{0}".format(n)
                result=subprocess.Popen(["ping", "-n", "1", "-w", "300", ip],stdout=limbo, stderr=limbo).wait()
                with lock:                    
                    if not result:
                        print (ip, "active")                    
                    else:
                        pass                        

def threader():
    while True:
        worker=q.get()
        check(worker)
        q.task_done()
q=Queue()

for x in range(255):
    t=threading.Thread(target=threader)
    t.daemon=True
    t.start()
for worker in range(1,255):
    q.put(worker)
q.join()
print("Process completed in: ",time.time()-_start)
</code></pre>
<p>I think this will be better one.</p>
</div>
<span class="comment-copy">I'm not sure why you think you need the time module?  I'd suggest researching how to parse the STDOUT from a <a href="http://docs.python.org/library/subprocess.html#module-subprocess" rel="nofollow noreferrer">subprocess</a> (which is what you should be using instead of <code>os.system()</code>)</span>
<span class="comment-copy">Try <a href="http://www.secdev.org/projects/scapy/" rel="nofollow noreferrer">Scapy</a>.</span>
<span class="comment-copy">Here is an example  <a href="https://github.com/lbaby/javalearn/blob/master/shell/ppe.py" rel="nofollow noreferrer">github.com/lbaby/javalearn/blob/master/shell/ppe.py</a></span>
<span class="comment-copy">No do not use scapy, scapy is terrible for anything requiring either throughput or reliability... Both are required for monitoring applications.</span>
<span class="comment-copy">wow.... thanks guys, i really do appreciate all of your help.  peace :)</span>
<span class="comment-copy">You'rw welcome. Remember to mark answers that helped you as accepted (click the green tickmark below the question vote tally), it signals to other visitors the answer was helpful. :-)</span>
<span class="comment-copy"><code>subprocess.call()</code> pings only one ip at a time. To ping multiple ips simultaneously <a href="http://stackoverflow.com/a/12102040/4279"><code>subprocess.Popen()</code> could be used</a></span>
<span class="comment-copy">Please leave a comment with an explanation why you voted down, so the answer can be improved.</span>
<span class="comment-copy">FYI, I threw errors on this until specifying the IP address as being unicode:  subnet = ipaddress.ip_network(u'192.168.1.0/23', strict=False)</span>
