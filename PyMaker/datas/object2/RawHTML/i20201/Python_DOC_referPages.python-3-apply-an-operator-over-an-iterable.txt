<div class="post-text" itemprop="text">
<p><code>sum(iterable)</code> is effectively:</p>
<pre><code>def sum(iterable):
    s = 0
    for x in iterable:
        s = s.__add__(x)
    return s
</code></pre>
<p>Does Python have a built-in function that accomplishes this without setting the initial value?</p>
<pre><code># add is interchangeable with sub, mul, etc.
def chain_add(iterable):
    iterator = iter(iterable)
    s = next(iterator)
    while True:
        try:
            s = s.__add__(next(iterator))
        except StopIteration:
            return s
</code></pre>
<p>The problem I have with <code>sum</code> is that it does not work for other types that support the <code>+</code> operator, e.g. <code>Counter</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try looking into the python <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce()</code> function</a>: You pass in a function, an iterable, and an optional initializer and it would apply the function cumulatively to all the values.</p>
<p>For example:</p>
<pre><code>import functools
def f(x,y):
    return x+y

print functools.reduce(f, [1, 2, 3, 4]) # prints 10
print functools.reduce(f, [1, 2, 3, 4], 10) # prints 20, because it initializes at 10, not 0.
</code></pre>
<p>You can change the function based on your iterable, so it's very customizable.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the case of addition:</p>
<pre><code>import operator
reduce(operator.add, iterable)
</code></pre>
<p>This will work on iterables that can't be added together using <code>sum</code>. Similarly, you could perform multiplication using</p>
<pre><code>reduce(operator.mul, iterable)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a pretty good use for <code>reduce()</code>, which was moved to <a href="http://docs.python.org/py3k/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce()</code></a> in Python 3.</p>
<p>Here is an example for chaining multiplication:</p>
<pre><code>import functools
import operator

def chain_mul(iterable):
    return functools.reduce(operator.mul, iterable)
</code></pre>
<p>You can replace <code>operator.mul</code> there with one of the other functions from the <a href="http://docs.python.org/py3k/library/operator.html" rel="nofollow">operator</a> module, or just define your own two-argument function that operates on its arguments.</p>
</div>
<span class="comment-copy">This is good assistance, though isn't reduce often used with its third "initial" argument?  EG, for addition, it is 0, for multiplication, it is 1, for strings it would be '' (but strings don't add that well).</span>
<span class="comment-copy">It can be, but it doesn't have to be. If nothing is given based on adding each value from 2 onward to the original. (If there is nothing in the iterable, it throws an exception for <code>TypeError: reduce() of empty sequence with no initial value</code>)</span>
