<div class="post-text" itemprop="text">
<p>I am running a function for several sets of iterables, returning a list of all results as soon as all processes are finished.</p>
<pre><code>def fct(variable1, variable2):

   # do an operation that does not necessarily take the same amount of
   # time for different input variables and yields result1 and result2

   return result1, result2

variables1 = [1,2,3,4]
variables2 = [7,8,9,0]

with ThreadPoolExecutor(max_workers = 8) as executor:
    future = executor.map(fct,variables1,variables2)
    print '[%s]' % ', '.join(map(str, future))
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; [ (12,3) , (13,4) , (14,5) , (15,6) ]
</code></pre>
<p>How can I print intermediary results e.g. for variable1 = 1, variable2 = 7 as soon as their results are calculated?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>map</code> already does this, but <code>join</code> needs to consume the entire iterable in order to create the joined string. Changing this to a <code>for</code> loop will let you print it incrementally:</p>
<pre><code>for i in executor.map(fct, v1, v2):
    print(str(i))
</code></pre>
<p>Keeping the same output as the <code>join</code> code is a bit more work, but doable regardless:</p>
<pre><code>first = True
print("[ ", end="")
for i in executor.map(fct, v1, v2):
    if first:
        first = False
    else:
        print(" , ", end="")

    print(str(i), end="")
print("]", end="")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to consume the results as they finish <em>without preserving the order of the original iterable</em>, you can use <code>executor.submit</code> along with <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed" rel="nofollow"><code>concurrent.futures.as_completed</code></a>:</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import random

def fct(variable1, variable2):
   time.sleep(random.randint(1,5))
   return variable1+1, variable2+1

variables1 = [1,2,3,4]
variables2 = [7,8,9,0]

with ThreadPoolExecutor(max_workers = 8) as executor:
    for out in as_completed([executor.submit(fct,*vars) 
                                for vars in zip(variables1, variables2)]):
        print(out.result())
</code></pre>
<p>Output (though any order is possible on any given run, due to <code>random.randint</code>):</p>
<pre><code>(4, 10)
(5, 1)
(2, 8)
(3, 9)
</code></pre>
<p><code>as_completed</code> will yield a <code>Future</code> from its input list as soon as that <code>Future</code> is marked as done, regardless of where it actually falls in the input list. This way, if the second item is done after 2 seconds, but the first takes fifteen, you'll see the result of the second items after two seconds, rather than needing to wait fifteen. This may or may not be desirable behavior, depending on your specific use-case.</p>
<p><strong>Edit:</strong></p>
<p>Note that you can still get the output in the original order this way. You just need to save the list you give to <code>as_completed</code>:</p>
<pre><code>with ThreadPoolExecutor(max_workers = 8) as executor:
    jobs = [executor.submit(fct, *vars) 
               for vars in zip(variables1, variables2)]

    for out in as_completed(jobs):
        print(out.result())
    results = [r.result() for r in jobs]
    print(results)
</code></pre>
<p>Output:</p>
<pre><code>(5, 1)
(2, 8)
(3, 9)
(4, 10)
[(2, 8), (3, 9), (4, 10), (5, 1)]
</code></pre>
</div>
<span class="comment-copy">Thank you. Perfect would be, if I see the progress of the whole process but retrieve the results in the same order as the input.</span>
<span class="comment-copy">@user3540181 I've edited my answer to show you how you can do that, too.</span>
<span class="comment-copy">Great answer bro! StackOverlow is for sure the best invention from recent years. :-)</span>
