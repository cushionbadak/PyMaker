<div class="post-text" itemprop="text">
<p>I am trying to print the Fibonacci sequence and it always returns an Overflow error after about the 600th term.</p>
<pre><code>def fib():

    import math
    from math import sqrt
    print "\nFibonacci Sequence up to the term of what?"
    n=raw_input(prompt)
    if n.isdigit():
        if int(n)==0:
            return 0
        elif int(n)==1:
            return 1
        else:
            n_count=2
            print "\n0\n1"
            while n_count&lt;int(n):
                fib=int(((1+sqrt(5))**n_count-(1-sqrt(5))**n_count)/(2**n_count*sqrt(5)))
                print fib
                n_count+=1
            fib()
    else:
        print "\nPlease enter a number."
        fib()
fib()
</code></pre>
<p>When I run this:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;pyshell#21&gt;", line 1, in &lt;module&gt;
    fib()
  File "&lt;pyshell#20&gt;", line 15, in fib
    fib=int(((1+sqrt(5))**n_count-(1-sqrt(5))**n_count)/(2**n_count*sqrt(5)))
OverflowError: (34, 'Result too large')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, first, let's split that big expression up into smaller ones, so we can see where it's going wrong. And use a debugger or some <code>print</code> statements to see what values are making it go wrong. That way, we're not just taking a stab in the dark.</p>
<p>If you do that, you can tell that <code>(1+sqrt(5)**n_count)</code> is raising this exception when <code>n_count</code> hits <code>605</code>. Which you can verify pretty easily:</p>
<pre><code>&gt;&gt;&gt; (1+sqrt(5))**604
1.1237044275099689e+308
&gt;&gt;&gt; (1+sqrt(5))**605
OverflowError: (34, 'Result too large')
</code></pre>
<p>So, why is that a problem?</p>
<p>Well, Python <a href="https://docs.python.org/3/library/stdtypes.html#typesnumeric" rel="nofollow"><code>float</code></a> values, unlike its integers, aren't arbitrary-sized, they can only hold what an <a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow">IEEE double</a> can hold:*</p>
<pre><code>&gt;&gt;&gt; 1e308
1e308
&gt;&gt;&gt; 1e309
inf
</code></pre>
<p>So, the problem is that one of the terms in your equation is greater than the largest possible IEEE double.</p>
<p>That means you either need to pick a different algorithm,** or get a "big-float" library.</p>
<p>As it happens, Python has a built-in big-float library, in the <a href="https://docs.python.org/3/library/decimal.html#module-decimal" rel="nofollow"><code>decimal</code></a> module. Of course as the name implies, it handles <em>decimal</em> floats, not <em>binary</em> floats, so you'll get different rounding errors if you use it. But you presumably don't care much about rounding errors, given your code.</p>
<p>So:</p>
<pre><code>import decimal
s5 = decimal.Decimal(5).sqrt()
</code></pre>
<p>… then …</p>
<pre><code>fib=int(((1+s5)**n_count-(1-s5)**n_count)/(2**n_count*s5))
</code></pre>
<hr/>
<p><sub>* In fact, the limits are platform-specific; implementations aren't <em>required</em> to use IEEE doubles for <code>float</code>. So, use <code>sys.float_info</code> to see the max value for your platform. But it's almost always going to be <code>1.7976931348623157e+308</code>.</sub></p>
<p><sub>** Note that the only advantage of the algorithm you're using over the naive one is that it allows you to approximate the Nth Fibonacci number directly, without calculating the preceding N-1. But since you want to print them all out anyway, you're not getting any advantage. You're just getting the disadvantages—it's an approximation; it's more complicated; it requires floating-point math, which is subject to rounding error; it's slower; it takes more memory; the built-in floating-point types in most languages on most platforms can't hold F(605), … All that for no benefit doesn't seem worth it.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>As abarnert pointed out, floats are limited in python. You can see the limit by</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.float_info
sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)
</code></pre>
<p>You will reach some more terms if you divide by 2 before raising to the power:</p>
<pre><code>int(( ((1+sqrt(5))/2)**n_count - ((1-sqrt(5))/2)**n_count)/sqrt(5))
</code></pre>
<p>But since Fibonacci sequence grows exponentially, you will soon hit the same wall. Try computing Fibonacci by holding the last two terms and adding them. That way you will use ints.</p>
</div>
<span class="comment-copy">Note that this won't actually print the Fibonacci sequence, it'll print a rough approximation of the Fibonacci sequence—and it'll do so in a way that's less efficient then printing the actual sequence. Is that really what you want?</span>
<span class="comment-copy">Also, because you're faking a loop with recursion instead of just using a loop, once you solve this problem, you're just going to have a <code>RecursionError</code> the 1000th time you try to print a Fibonacci number.</span>
