<div class="post-text" itemprop="text">
<p>In python, there are a number of ways to reverse a sequence:</p>
<pre><code>l = [1,2,3]
reversed(l) #returns a reverse iterator
l[::-1] #returns a reverse sequence
</code></pre>
<p>Although there is a builtin specifically for reversing a sequence, it is more concise to use list slicing. Additionally, list slicing returns a full <code>Sequence</code>, which supports <code>__getitem__</code> and <code>__len__</code>, while <code>reversed</code> is only an iterator. Finally, <code>reversed</code> requires a <code>Sequence</code>, which means that list slicing will almost always work. </p>
<p>What are the advantages of using the <code>reversed</code> builtin over list slicing?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list[::-1]</code> returns a new reversed copy of the list. It will consume more memory according to the size of the list: sizeof the list object + sizeof(pointer) * len(list)</p>
<p>If you don't need the whole list items at once, using <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow"><code>reversed</code></a> is more preferable in terms of memory. (For example, iterating the list reversed order, processing items one by one does not require all items at once.)</p>
</div>
<div class="post-text" itemprop="text">
<p>It isn't quite correct to say "<code>reversed</code> requires a sequence". in Python 2.6+ <code>reversed</code> works on any object that defines a <code>__reversed__</code> method. Thus it can work on objects that do not support integer indexing, while slicing can't. </p>
<p>So, use slicing when reversing only a segment of a sequence, need more than one element at a time, or perhaps need to control the step size. Use <code>reversed</code> if you only need to iterate through every element (as per the memory considerations of @falsetru's answer), or if you have an object with custom-defined reversing behavior. </p>
</div>
<div class="post-text" itemprop="text">
<p>Oh darn, a commenter pointed out that rev_func wasn't returning a list, it was returning the list iterator.  oops</p>
<p>When I corrected it, the results are essentially the same.</p>
<blockquote>
<p>Using [::-1]: 1.6161760782445813 
  Using reversed(): 1.7324838771408098</p>
</blockquote>
<pre><code>import timeit
import random

def rev_slice(big_list):
    return big_list[::-1]


def rev_func(big_list):

    #return reversed(big_list)
    return list(reversed(big_list))


big_list = [random.random() for i in range(10000000)]

slice_t = timeit.Timer("foo = rev_slice(big_list)", "from __main__ import big_list, rev_slice")
slice_time = slice_t.timeit(10)
print ("Using [::-1]: {0}".format(slice_time))

func_t = timeit.Timer("foo = rev_func(big_list)", "from __main__ import big_list, rev_func")
func_time = func_t.timeit(10)
print ("Using reversed(): {0}".format(func_time))
</code></pre>
</div>
<span class="comment-copy">It won't consume as much as memory as the original list because the pointers in the new list still point to the same objects in memory(shallow copy). The extra memory will be <b>size of list object + 4 * len(lst)</b>.(4 for each pointer, an empty list's size is around 36 Bytes on my system)</span>
<span class="comment-copy">@AshwiniChaudhary, Thank you for pointing that. I updated the answer accordingly.</span>
<span class="comment-copy">It's because reversed returns an iterator, no list creation or loop is happening in that process. So that doesn't depends on list size at all, hence constant time.</span>
<span class="comment-copy">Oh darn, yeah, you're right.  And once-fixed, the results are essentially the same, perhaps even tiny slower for reversed().</span>
