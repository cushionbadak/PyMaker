<div class="post-text" itemprop="text">
<p>Can I create a HTTP server without using </p>
<pre><code>python -m http.server [port number]
</code></pre>
<p>Using an old school style with sockets and such.</p>
<p>Latest code and errors...</p>
<pre><code>import socketserver

response = """HTTP/1.0 500 Internal Server Error
Content-type: text/html

Invalid Server Error"""

class MyTCPHandler(socketserver.BaseRequestHandler):
    """
    The RequestHandler class for our server.

    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """


    def handle(self):
        # self.request is the TCP socket connected to the client
        self.data = self.request.recv(1024).strip()
        self.request.sendall(response)

if __name__ == "__main__":
    HOST, PORT = "localhost", 8000
    server = socketserver.TCPServer((HOST, PORT), MyTCPHandler)
    server.serve_forever()
</code></pre>
<p>TypeError: 'str' does not support the buffer interface</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can, but it's a terrible idea -- in fact, even <code>http.server</code> is at best a toy implementation.</p>
<p>You're better off writing whatever webapp you want as a standard WSGI application (most Python web frameworks do that -- Django, Pyramid, Flask...), and serving it with one of the dozens of production-grade HTTP servers that exist for Python.</p>
<p>uWSGI (<a href="https://uwsgi-docs.readthedocs.org/en/latest/" rel="nofollow">https://uwsgi-docs.readthedocs.org/en/latest/</a>) is my personal favorite, with Gevent a close second.</p>
<p>If you want more info about how it's done, I recommend that you read the source code to the CherryPy server (<a href="http://www.cherrypy.org/" rel="nofollow">http://www.cherrypy.org/</a>). While not as powerful as the aforementioned uWSGI, it's a good reference implementation written in pure Python, that serves WSGI apps through a thread pool.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sure you can, and servers like <a href="http://tornadoweb.org" rel="nofollow">Tornado</a> already do it this way.
For simple test servers which can do only HTTP/1.0 GET requests and handle only a single request at a time it should not be that hard once you understood the basics of the HTTP protocol. But if you care even a bit about performance it gets complex fast.</p>
</div>
<span class="comment-copy">You probably could. Give it a try and if you run into a problem, ask a question. We aren't going to do it for you.</span>
<span class="comment-copy">You could, but why? If you want build a bicycle, you don't start by making the wheel - you get a wheel and you work on the bicycle. You only start making the wheel if you are going to make a better wheel.</span>
<span class="comment-copy">not sure where to start I guess. Impossible to find any help that doesn't reference a way, so a starting point would be nice</span>
<span class="comment-copy">Or are you asking how to create a simple HTTP server just without using the <code>python -m</code> CLI helper? Then look at the example at the bottom of the <a href="https://docs.python.org/3/library/http.server.html" rel="nofollow noreferrer"><code>http.server</code> module docs</a>.</span>
<span class="comment-copy">basically trying to reinvent the wheel... a simple HTTP server without any use of http.server module</span>
<span class="comment-copy">Just looking to create a simple test server...</span>
<span class="comment-copy">In that case create a simple TCP server and then create a minimal HTTP/1.0 stack on top, that is read the request from the accepted connection until you get <code>\r\n\r\n</code> and send the response back. Then close the connection. It is not fast, but simple.</span>
<span class="comment-copy">@CaseyJames22 then use the <code>http</code> module. Or do you really want to implement all of <a href="http://www.isi.edu/in-notes/rfc1945.txt" rel="nofollow noreferrer">RFC1945</a> and <a href="https://www.ietf.org/rfc/rfc2616.txt" rel="nofollow noreferrer">RFC2616</a> yourself?</span>
<span class="comment-copy">It's actually a good exercise to get familiar with the protocol. After a while you will probably understand enough to realize, why a comprehensive and performant server is much more complex, but you've learned a lot to debug HTTP problems in the future :)  Of course, the real details on how to do write the server you have to figure out yourself, otherwise you would not have the learning experience.</span>
<span class="comment-copy"><a href="http://pastebin.com/5Ys0RcYR" rel="nofollow noreferrer">pastebin.com/5Ys0RcYR</a> - Here is a small server written in Perl. Please don't expect us to write the Python server for you, but you might learn some basics from this minimal Perl server. And you should definitely make yourself familiar with the HTTP protocol.</span>
