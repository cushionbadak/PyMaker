<div class="post-text" itemprop="text">
<p>this is the first time I am trying to code in python and I am implementing the Apriori algorithm. I have generated till 2-itemsets and below is the function I have to generate 2-Itemsets by combining the keys of the 1-itemset. </p>
<p>How do I go about making this function generic? I mean, by passing the keys of a dictionary and the number of elements required in the tuple, the algorithm should generate all possible n-number(k+1) subsets using the keys. I know that Union on sets is a possibility, but is there a way to do union of tuples which is essentially the keys of a dictionary?</p>
<pre><code># generate 2-itemset candidates by joining the 1-itemset candidates
def candidate_gen(keys):
    adict={}
    for i in keys:
        for j in keys:
            #if i != j and (j,i) not in adict:
            if j&gt;i:
        #call join procedure which will generate f(k+1) keys
        #call has_infrequent_subset --&gt; generates all possible k+1 itemsets and checks if k itemsets are present in f(k) keys
                adict[tuple([min(i,j),max(i,j)])] = 0
    return adict
</code></pre>
<p>For example, if my initial dictionary looks like: {key, value} --&gt; value is the frequency</p>
<pre><code>{'382': 1163, '298': 560, '248': 1087, '458': 720, 
 '118': 509,  '723': 528, '390': 1288}
</code></pre>
<p>I take the keys of this dictionary and pass it to the candidate_gen function mentioned above
it will generate the subsets of 2-itemsets and give the output of keys. I will then pass the keys to a function to find the frequency by comparing against the original database to get this output:</p>
<pre><code>{('390', '723'): 65, ('118', '298'): 20, ('298', '390'): 70, ('298', '458'): 35, 
 ('248', '382'): 88, ('248', '458'): 76, ('248', '723'): 26, ('382', '723'): 203,
 ('390', '458'): 33, ('118', '458'): 26, ('458', '723'): 26, ('248', '390'): 87,
 ('118', '248'): 54, ('298', '382'): 47, ('118', '723'): 41, ('382', '390'): 413,
 ('382', '458'): 57, ('248', '298'): 64, ('118', '382'): 40, ('298', '723'): 36, 
 ('118', '390'): 52}
</code></pre>
<p>How do I generated 3-itemset subsets from the above keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>I assume that, given your field, you can benefit very much from the study of python's <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow">itertools</a> library.</p>
<p>In your use case you can directly use the itertools <code>combinations</code>
or wrap it in a helper function</p>
<pre><code>from itertools import combinations
def ord_comb(l,n):
    return list(combinations(l,n))

#### TESTING ####
a = [1,2,3,4,5]
print(ord_comb(a,1))
print(ord_comb(a,5))
print(ord_comb(a,6))
print(ord_comb([],2))
print(ord_comb(a,3))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[(1,), (2,), (3,), (4,), (5,)]
[(1, 2, 3, 4, 5)]
[]
[]
[(1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)]
</code></pre>
<p>Please note that the order of the elements in the <code>n</code>-uples depends on the order that you used in the iterable that you pass to <code>combinations</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This?</p>
<pre><code>In [12]: [(x, y) for x in keys for y in keys if y&gt;x]
Out[12]: 
[('382', '723'),
 ('382', '458'),
 ('382', '390'),
 ('458', '723'),
 ('298', '382'),
 ('298', '723'),
 ('298', '458'),
 ('298', '390'),
 ('390', '723'),
 ('390', '458'),
 ('248', '382'),
 ('248', '723'),
 ('248', '458'),
 ('248', '298'),
 ('248', '390'),
 ('118', '382'),
 ('118', '723'),
 ('118', '458'),
 ('118', '298'),
 ('118', '390'),
 ('118', '248')]
</code></pre>
</div>
<span class="comment-copy">Can you give some example input and the expected output? This will make your problem much clearer for everyone.</span>
<span class="comment-copy">Your code has  <code>if j&gt;i: adict[tuple([min(i,j),max(i,j)])] = 0</code> but it's equivalent to the simpler <code>if j&gt;i: adict[i,j]=0</code></span>
<span class="comment-copy">In your code, <code>keys</code> are strings and the comparison <code>j&gt;i</code> works if the strings are of the same length. Please try <code>print('oh!' if '99'&gt;'100' else 'ok.')</code> at the interpreter prompt...</span>
<span class="comment-copy">Thank you for the reply. This will give n-number combinations over a list containing a = [1,2,3,4,5] --&gt; single elements. say if my input was a = [(1,2),(3,4),(1,5)] and so on. How to generate n-number combinations over that? like, output --&gt; a= [(1,2,3),(1,2,4)...,(1,2,5)] an so on.</span>
<span class="comment-copy">@prakyathj, the last case in my <code>TESTING</code> code, isn't it what you're looking for? In your example the level 2 tuples were in number of 21, that is ((7x8)/2-7) all the non repeating combinations of the original 7 items taken 2 by 2, so I deduced (no expertise in apriori algorithms) that you need all the distinct, ordered combinations of 3 items from the original seven... If for level 3 you need something different from these combinations, please tell me because I can't understand.</span>
<span class="comment-copy">@prakyathj I'd like to stress that the last line in the box labeled <b>Output</b> up there in my answer is <i>exactly</i> what <i>you</i> wrote, in terms of an unsatisfied requirement, in the end of your previous comment.</span>
<span class="comment-copy">OP requires a 3rd level combination, as in <code>[ (x, y, z) for x in l for y in l for z in l if x &lt; y &lt; z]</code> so you're close.  If he needs deeper levels <code>(4, ..., n)</code> imho it's better a function like <code>itertools.combinations</code></span>
<span class="comment-copy">if he need deeper level and flexibility then yes.   the code he pasted generates 2-itemsets</span>
