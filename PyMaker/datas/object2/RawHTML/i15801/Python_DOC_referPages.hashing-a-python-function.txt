<div class="post-text" itemprop="text">
<pre><code>def funcA(x):
    return x
</code></pre>
<p><strong>Is <code>funcA.__code__.__hash__()</code> a suitable way to check whether <code>funcA</code> has changed?</strong></p>
<p>I know that <code>funcA.__hash__()</code> won't work as it the same as <code>id(funcA) / 16</code>. I checked and this isn't true for <code>__code__.__hash__()</code>. I also tested the behaviour in a ipython terminal and it seemed to hold. But is this guaranteed to work?</p>
<h1>Why</h1>
<p>I would like to have a way of comparing an old version of function to a new version of the same function.</p>
<p>I'm trying to create a <em>decorator</em> for disk-based/long-term caching. Thus I need a way to identify if a function has changed. I also need to look at the call graph to check that none of the called functions have changed but that is not part of this question.</p>
<p>Requirements:</p>
<ul>
<li>Needs to be stable over multiple calls and machines. <a href="https://mail.python.org/pipermail/python-announce-list/2012-March/009394.html" rel="nofollow">1</a> says that in Python 3.3 <code>hash()</code> is randomized on each start of a new instance. Although it also says that "HASH RANDOMIZATION IS DISABLED BY DEFAULT". Ideally, I'd like a function that does is stable even with randomization enabled.</li>
<li>Ideally, it would yield the same hash for <code>def funcA: pass</code> and <code>def funcB: pass</code>, i.e. when only the name of the function changes. Probably not necessary.</li>
<li>I only care about Python 3.</li>
</ul>
<p>One alternative would be to hash the text inside the file that contains the given function.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Yes, it seems that <code>func_a.__code__.__hash__()</code> is unique to the specific functionality of the code. I could not find where this is implemented, or where it is <code>__code__.__hash__()</code>  defined.</p></li>
<li><p>The perfect way would be to use <code>func_a.__code__.co_code.__hash__()</code> because <code>co_code</code> has the byte code as a string. Note that in this case, the function name is not part of the hash and two functions with the same code but names <code>func_a</code> and <code>func_b</code> will have the same hash.</p>
<pre><code>hash(func_a.__code__.co_code)
</code></pre></li>
</ol>
<p><a href="https://docs.python.org/3/library/inspect.html#module-inspect" rel="nofollow">Source</a>.</p>
</div>
<span class="comment-copy">Maybe something like <code>pickle</code> would be more useful?</span>
<span class="comment-copy">How could pickle be more useful? Should I pickle the function?</span>
<span class="comment-copy">"Note that functions (built-in and user-defined) are pickled by “fully qualified” name reference, not by value. This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function’s code, nor any of its function attributes are pickled." From the Python docs on pickle.</span>
