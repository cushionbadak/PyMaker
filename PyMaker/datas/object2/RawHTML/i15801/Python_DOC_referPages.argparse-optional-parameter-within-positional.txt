<div class="post-text" itemprop="text">
<p>With <code>argparse</code> I would like to be able to mix optional parameters with multiple positional parameters, e.g., like <code>svn</code> allows:</p>
<pre><code>svn ls first/path -r 1000 second/path
</code></pre>
<p>At the moment, this is not officially supported by Python (c.f. <a href="http://bugs.python.org/issue14191" rel="nofollow">http://bugs.python.org/issue14191</a>). I wrote this workaround and I am now wondering, if a) there is a better/easier/more elegant way to do it, and b) if someone can see something in the code that might break it under certain cirumstances:</p>
<pre><code>#!/usr/bin/env python3                                                          

import argparse as ap                                                           

p = ap.ArgumentParser()                                                         
p.add_argument('-v', action='store_true')                                       
p.add_argument('-l', action='store_true')                                       
p.add_argument('files', nargs='*', action='append')                             
p.add_argument('remainder', nargs=ap.REMAINDER, help=ap.SUPPRESS)                  

args = p.parse_args()                                                              
while args.remainder != []:                                                        
    args = p.parse_args(args.remainder, args)                                      

print(args)  
</code></pre>
<p>Usage example:</p>
<pre><code>./test.py a b -v c d 
</code></pre>
<p>Output:</p>
<pre><code>Namespace(files=[['a', 'b'], ['c', 'd']], l=False, remainder=[], v=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_known_args" rel="nofollow">parse_known_args</a> instead of including a <code>remainder</code>:</p>
<pre><code>import argparse as ap                                                           

p = ap.ArgumentParser()                                                         
p.add_argument('-v', action='store_true')                                       
p.add_argument('-l', action='store_true')                                       
p.add_argument('files', nargs='*', action='append')                             

args, unknown = p.parse_known_args()
while unknown:
    args, unknown = p.parse_known_args(unknown, args) 

print(args)
</code></pre>
<p>yields</p>
<pre><code>Namespace(files=[['a', 'b'], ['c', 'd']], l=False, v=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you want <code>files=[['a', 'b'], ['c', 'd']]</code> or <code>files=['a', 'b', 'c', 'd']</code>?  In other words should</p>
<pre><code>./test.py a b -v c d 
./test.py a b -v c -l d 
./test.py -l a b -v c d 
</code></pre>
<p>give different <code>files</code> lists of lists.</p>
<p><code>append</code> with a <code>*</code> positional usually doesn't make sense, since you can't repeat a positional argument.  But with this recursive application, it does work.  But if the sublists are important, why not use multiple positional arguments.</p>
<p>On the other hand, to get a flat list of 'files', you could do several things:</p>
<p>You could flatten the list after parsing (e.g. <code>args.files=list(itertools.chain(*args.files))</code>)</p>
<p>You could use <code>p.add_argument('files', nargs='?', action='append')</code>.  This iterates over each <code>file</code> string.</p>
<pre><code>./test.py a b -l c d -v e f
Namespace(files=['a', 'b', 'c', 'd', 'e', 'f'], l=True, remainder=[], v=True)
</code></pre>
<hr/>
<p>You could replicate the <a href="http://bugs.python.org/issue14191" rel="nofollow">http://bugs.python.org/issue14191</a> patch by removing the positional from the initial parse.  In this case the <code>extras</code> can be simply inserted into <code>args</code>.</p>
<p>A disadvantage of this is that the <code>usage</code> and <code>help</code> known nothing about the positional, requiring a custom <code>usage</code> and/or <code>description</code> parameter.</p>
<pre><code>usage = usage: %(prog)s [-h] [-v] [-l] [files [files ...]]
description = 'files: may be given in any order'
p = ap.ArgumentParser(usage=usage, description=description)                            
p.add_argument('-v', action='store_true')                                       
p.add_argument('-l', action='store_true')                                       
args, extras = p.parse_known_args() 
args.files = extras
</code></pre>
<hr/>
<p>unutbu's answer does not preserve the groupings.  They are lost the first time through:</p>
<p>    Namespace(files=[['a', 'b'], ['c', 'd', 'e', 'f']], l=True, v=True)</p>
<p>It could be changed to give a flat list:</p>
<pre><code>p = ap.ArgumentParser()
p.add_argument('-v', action='store_true')
p.add_argument('-l', action='store_true')
p.add_argument('files', nargs='*')

args, unknown = p.parse_known_args()
args.files.extend(unknown)
</code></pre>
<p>The iteration isn't needed, since <code>optionals</code> are handled the first time through.  All that is left in <code>unknown</code> are <code>files</code>.</p>
<p>In sum - to preserve the groupings, your solution appears to be the best.</p>
</div>
<span class="comment-copy">There's a version of the workaround in 14191 that you can download and add to your code - without modifying your <code>argparse</code>.  You may need it if you need to define more <code>positionals</code>.</span>
