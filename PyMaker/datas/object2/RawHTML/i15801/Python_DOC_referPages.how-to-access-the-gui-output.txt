<div class="post-text" itemprop="text">
<p>I'm developing one test bench which runs multiple tests via python gui and prints the output as below.</p>
<pre><code>A Passed
B Passed
C Passed
D Passed
E Passed
</code></pre>
<p>Button from gui should be changed to 'Passed' only when A,B,C,D,E all are Passed. If any of these tests fails, it should say failed. What is the way to access this output from gui which is printed on screen.</p>
<p>My code for tests is:</p>
<pre><code>from PyQt4.QtCore import *
from PyQt4.QtGui import *
import sys, os, time
from PyQt4 import QtGui, QtCore
from progress.bar import Bar
import datetime 
import thread

class MyTestBench(QDialog, QtGui.QWidget):
    def __init__(self):
        super(QDialog, self).__init__()
        self.setWindowTitle("Implementation")

        self.progressbar = QtGui.QProgressBar()
        self.progressbar.setMinimum(0)
        self.progressbar.setMaximum(100)
        self.run_test_button = QtGui.QPushButton('Run Your Tests')
        self.run_test_button.clicked.connect(self.run_test_event)

    def run_test_event(self):
        thread.start_new_thread(self.run_the_test, ("Thread-1", 0.5))
        thread.start_new_thread(self.run_the_progress, ("Thread-2", 0.5))


    def run_the_test(self, tname, delay):        
        os.system("python nxptest.py my_testlist.txt")
        self.progressbar.setValue(100)
        if self.progressbar.value() == self.progressbar.maximum(): 
            time.sleep(3)
            self.run_test_button.setText('Run Your Tests')


    def run_the_progress(self, tname, delay):
        count = 0
        while count &lt; 5:
            self.run_test_button.setText('Running.')
            time.sleep(0.5)
            self.run_test_button.setText('Running..')
            time.sleep(0.5)
            self.run_test_button.setText('Running...')
            value = self.progressbar.value() + 10
            self.progressbar.setValue(value)
            time.sleep(0.5)
            if self.progressbar.value() == self.progressbar.maximum():
                self.progressbar.reset()
            count = count + 1

app = QApplication(sys.argv)
dialog = MyTestBench()
dialog.setGeometry(100, 100, 200, 50)
dialog.show()
app.exec_()
</code></pre>
<p>The main challenge I'm facing here is I'm new to gui programming and I don't know how to access the output that is printed on screen.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're trying to get the text output of a program, you can't run that program using <code>os.system</code>. As <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow">the docs for that function</a> say:</p>
<blockquote>
<p>The <code>subprocess</code> module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the <a href="https://docs.python.org/3/library/subprocess.html#subprocess-replacements" rel="nofollow">Replacing Older Functions with the <code>subprocess</code> Module</a> section in the <a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" rel="nofollow"><code>subprocess</code></a> documentation for some helpful recipes.</p>
</blockquote>
<p>If you follow those links, they'll show how to do what you want. But basically, it's something like this:</p>
<pre><code>output = subprocess.check_output(["python", "nxptest.py", "my_testlist.txt"])
</code></pre>
<p>If you're using 2.6 or earlier, you won't have <code>check_output</code>; you can read the docs to see how to build it yourself on top of, e.g., <code>communicate</code>, or you can just install the <a href="https://pypi.python.org/pypi/subprocess32/" rel="nofollow"><code>subprocess32</code></a> backport from PyPI and use that.</p>
<hr/>
<p>From a comment:</p>
<blockquote>
<p>This works but my only concern is there are lot of results for the tests which are printed before it actually prints A Passed B Passed etc.. Im looking for a way to get just this part of string and not the whole output. </p>
</blockquote>
<p>That isn't possible. How could your program have any idea which part of the output is "this part of the string" and which part is "a lot of results … which are printed before"?</p>
<p>If you can edit the programs being tested in some way—e.g., make them print their "real" output to stdout, but their "extra" output to stderr, or provide a command-line argument that makes them skip all the extra stuff—that's great. But assuming you can't, there is no alternative but to filter the results.</p>
<p>But this doesn't look very hard. If each line of "real" output is either <code>"X Passed"</code> or <code>"X Failed"</code> and nothing else starts with <code>"X "</code> (where <code>X</code> is any uppercase ASCII letter), that's just:</p>
<pre><code>test_results = {}
for line in output.splitlines():
    if line[0] in string.ascii_uppercase and line[1] == ' ':
        test_results[line[0]] = line[2:]
</code></pre>
<p>Now, at the end, you've got:</p>
<pre><code>{'A': 'Passed', 'B': 'Passed', 'C': 'Passed', 'D': 'Passed', 'E': 'Passed'}
</code></pre>
<p>If you want to verify that all of A-E were covered and they all passed:</p>
<pre><code>passed = (set(test_results) == set('ABCDE') and
          all(value == 'Passed' for value in test_results.values()))
</code></pre>
<p>Of course you could build something nicer that shows which ones were skipped or didn't pass or whatever. But honestly, if you want something more powerful, you should probably be using an existing unit testing framework instead of building one from scratch anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can mask the printing output through a queue like so:</p>
<pre><code>class FileQ(Queue.Queue):
    def __init__(self):
        Queue.Queue.__init__(self)

    def write(self,data):
        self.put(data)

class MyTestBench(QtGui.QWidget):
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.incoming = FileQ()
        self.setWindowTitle("Implementation")
        sys.stdout = self.incoming
        self.time = QtCore.QTimer()
        self.time.timeout.connect(self.refresh)
        self.time.start(10)
        self.t = QtGui.QTextEdit(self)
        self.t.setObjectName('TextOut')
        self.box = QtGui.QHBoxLayout(self)
        self.setLayout(self.box)
        self.box.addWidget(self.t)
        self.run_test_event()
        self.progressbar = QtGui.QProgressBar(self)
        self.progressbar.setObjectName('BarOut')
        self.box.addWidget(self.progressbar)

    def run_test_event(self):
        thread.start_new_thread(self.run_the_test, ("Thread-1", 0.5))

    def run_the_test(self,*args):
        for i in range(10):
            print i
            time.sleep(1)

    def refresh(self):        
        try:
            data = self.incoming.get_nowait()
        except:
            return
        if data:
            self.t.insertPlainText(str(data))
            self.progressbar.setValue(int(data)*10)
</code></pre>
</div>
<span class="comment-copy">The tests produce output only by print statements?</span>
<span class="comment-copy">@mdurant yes, that job is done via nxptest.py module</span>
<span class="comment-copy">@abarnet Thanks This works but my only concern is there are lot of results for the tests which are printed before it actually prints A Passed B Passed etc.. Im looking for a way to get just this part of string and not the whole output.</span>
<span class="comment-copy">@tryPy: Then you have to parse the output. Unless you can change the program you're testing so it doesn't mix together real output with irrelevant stuff, there's no possible way around this.</span>
<span class="comment-copy">@abarnert1 yup.. did the same and got it working.. thanks :)</span>
