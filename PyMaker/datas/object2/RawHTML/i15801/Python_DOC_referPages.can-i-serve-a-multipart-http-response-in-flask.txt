<div class="post-text" itemprop="text">
<p>I want to do a multipart http response similar to the multipart http requests that forms can produce for file uploads.  It would contain multiple data segments, each with its own content type.  When I google this, all I find is <a href="http://flask.pocoo.org/docs/0.10/patterns/streaming/" rel="nofollow">information on streaming</a>.</p>
<p>I don't care if browsers support this, since it's for a client that is using libcurl.  However, I'm not sure if libcurl supports multipart responses either.  Does it?  Are multipart responses a thing you can do?</p>
</div>
<div class="post-text" itemprop="text">
<p>Building on the other answers, and using the <a href="https://github.com/sigmavirus24/requests-toolbelt/" rel="nofollow noreferrer">requests toolbelt</a> library, the code would look something like the following:</p>
<pre><code>from flask import Flask, Response
from requests_toolbelt import MultipartEncoder

app = Flask(__name__)

@app.route('/downloads')
def downloads():
    m = MultipartEncoder(
           fields={'field0': 'value', 'field1': 'value',
                   'field2': ('filename', open('file.py', 'rb'), 'text/plain')}
        )
    return Response(m.to_string(), mimetype=m.content_type)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be asking at least two different things here. I'm going to answer the one that's in your title: Can Flask send multipart responses? (If you need to know whether/how libcurl supports multipart responses, either try it and see, or ask a separate question.)</p>
<p>Of course it can. Even if there's no Flask extension to automate it (I haven't searched to see whether there is), there's nothing stopping you from, e.g., using the <a href="https://docs.python.org/3/library/email.html" rel="nofollow"><code>email</code></a> package in the stdlib to generate the MIME envelope manually, and then serving it up with the appropriate Content-Type.</p>
</div>
<div class="post-text" itemprop="text">
<p>So, I was looking into something similar today. This is an old question. But so that you dont have search - simple answer is create a Multipart mime entity from email package. And return that. Flask will handle the output correctly.</p>
<blockquote>
<p>responseBody = MIMEMultipart() ...</p>
<p>Response(responseBody.as_string())</p>
</blockquote>
</div>
<span class="comment-copy">I guess I'd have to set the boundary header manually then?</span>
<span class="comment-copy">@NickRetallack: You can if you want to, but the <code>email</code> package can do that for you. For example, if you construct a <a href="https://docs.python.org/3/library/email.mime.html#email.mime.multipart.MIMEMultipart" rel="nofollow noreferrer"><code>MIMEMultipart</code></a> then call <code>attach</code> for each file's part, it'll generate the boundaries automatically.</span>
<span class="comment-copy">I'm wondering how I can return that from Flask, since it will wrap anything in a Response that will already have headers on it.  I guess I'd have to merge the headers in?  Or does it work in some other way?</span>
<span class="comment-copy">@NickRetallack: If you return a <code>Response</code>, it doesn't wrap it in a <code>Response</code>. That's shown by the very example you linked to. And that example <i>also</i> shows how you can specify the <code>mimetype</code> keyword argument to the <code>Response</code> constructor to modify the headers it generates, so you don't have to replace everything it does.</span>
<span class="comment-copy">If it's not clear <i>what</i> to pass to <code>Response</code>: You can pass it any iterable of strings. A file, a list of strings, a list of one string, a generator that yields complete MIME parts one by one, a generator that alternates yielding MIME headers and boundaries with yielding line by line from a field or chunk by chunk from a gzipped file, â€¦</span>
