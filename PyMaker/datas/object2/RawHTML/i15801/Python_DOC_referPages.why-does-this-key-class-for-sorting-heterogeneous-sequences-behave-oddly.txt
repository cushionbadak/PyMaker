<div class="post-text" itemprop="text">
<p>Python 3.x's <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted()</code></a> function cannot be relied on to sort heterogeneous sequences, because most pairs of distinct types are unorderable (numeric types like <code>int</code>, <code>float</code>, <code>decimal.Decimal</code> etc. being an exception):</p>
<pre><code>Python 3.4.2 (default, Oct  8 2014, 08:07:42) 
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; sorted(["one", 2.3, "four", -5])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: float() &lt; str()
</code></pre>
<p>In contrast, comparisons between objects that have no natural order are arbitrary but consistent in Python 2.x, so <code>sorted()</code> works:</p>
<pre><code>Python 2.7.8 (default, Aug  8 2014, 14:55:30) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; sorted(["one", 2.3, "four", -5])
[-5, 2.3, 'four', 'one']
</code></pre>
<p>In order to replicate Python 2.x's behaviour in Python 3.x, I wrote a class to use as the <code>key</code> parameter to <code>sorted()</code>, which relies on the fact that <code>sorted()</code> is <a href="https://docs.python.org/3/howto/sorting.html#odd-and-ends" rel="nofollow noreferrer">guaranteed</a> to use only less-than comparisons:</p>
<pre><code>class motley:

    def __init__(self, value):
        self.value = value

    def __lt__(self, other):
        try:
            return self.value &lt; other.value
        except TypeError:
            return repr(type(self.value)) &lt; repr(type(other.value))
</code></pre>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; sorted(["one", 2.3, "four", -5], key=motley)
[-5, 2.3, 'four', 'one']
</code></pre>
<p>So far, so good.</p>
<p><strong>However</strong>, I've noticed a surprising behaviour when <code>sorted(s, key=motley)</code> is called with certain sequences containing complex numbers:</p>
<pre><code>&gt;&gt;&gt; sorted([0.0, 1, (1+0j), False, (2+3j)], key=motley)
[(1+0j), 0.0, False, (2+3j), 1]
</code></pre>
<p>I would have expected <code>0.0</code>, <code>False</code> and <code>1</code> to be in one group (because they are mutually orderable), and <code>(1+0j)</code> and <code>(2+3j)</code> in another (because they are of the same type). The fact that the complex numbers in this result are not only separated from each other, but one of them is sitting in the middle of a group of objects that are comparable with each other but not with it, is somewhat perplexing.</p>
<p>What's going on here?</p>
</div>
<div class="post-text" itemprop="text">
<p>You do not know what order the comparisons are done in, or even which items are compared, which means you can't really know what effect your <code>__lt__</code> will have.  Your defined <code>__lt__</code> sometimes depends on the actual values, and sometimes on the string representations of the types, but both versions may be used for the same object in the course of the sort.  This means that your ordering is not determined solely by the objects in the list, but also may depend on their initial order.  This in turn means that just because objects are mutually comparable does not mean they will be sorted together; they may be "blocked" by an incomparable object between them.</p>
<p>You can get an inkling of what is going on by putting some debugging prints in to see what it's comparing:</p>
<pre><code>class motley:

    def __init__(self, value):
        self.value = value

    def __lt__(self, other):
        fallback = False
        try:
            result = self.value &lt; other.value
        except TypeError:
            fallback = True
            result = repr(type(self.value)) &lt; repr(type(other.value))
        symbol = "&lt;" if result else "&gt;"
        print(self.value, symbol, other.value, end="")
        if fallback:
            print(" -- because", repr(type(self.value)), symbol, repr(type(other.value)))
        else:
            print()
        return result
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; sorted([0.0, 1, (1+0j), False, (2+3j)], key=motley)
1 &gt; 0.0
(1+0j) &lt; 1 -- because &lt;class 'complex'&gt; &lt; &lt;class 'int'&gt;
(1+0j) &lt; 1 -- because &lt;class 'complex'&gt; &lt; &lt;class 'int'&gt;
(1+0j) &lt; 0.0 -- because &lt;class 'complex'&gt; &lt; &lt;class 'float'&gt;
False &gt; 0.0
False &lt; 1
(2+3j) &gt; False -- because &lt;class 'complex'&gt; &gt; &lt;class 'bool'&gt;
(2+3j) &lt; 1 -- because &lt;class 'complex'&gt; &lt; &lt;class 'int'&gt;
[(1+0j), 0.0, False, (2+3j), 1]
</code></pre>
<p>You can see, for instance, that the type-based ordering is used for comparing the complex number to 1, but not for comparing 1 and 0.  Likewise <code>0.0 &lt; False</code> for "normal" reasons, but <code>2+3j &gt; False</code> for type-name-based reasons.</p>
<p>The result is that it sorts <code>1+0j</code> to the beginning, and then leaves <code>2+3j</code> where it is above False.  It never even attempts to compare the two complex numbers to each other, and the only item they are both compared to is 1.</p>
<p>More generally, your approach can lead to an intransitive ordering with appropriate choices for the names of the types involved.  For instance, if you define classes A, B, and C, such that A and C can be compared, but they raise exceptions when comparing to B, then by creating objects <code>a</code>, <code>b</code> and <code>c</code> (from the respective classes) such that <code>c &lt; a</code>, you can create a cycle <code>a &lt; b &lt; c &lt; a</code>.  <code>a &lt; b &lt; c</code> will be true because the classes will be compared based on their names, but <code>c &lt; a</code> since these types can be directly compared.  With an intransitive ordering, there is no hope of a "correct" sorted order.</p>
<p>You can even do this with builtin types, although it requires getting a little creative to think of objects whose type names are in the right alphabetical sequence:</p>
<pre><code>&gt;&gt;&gt; motley(1.0) &lt; motley(lambda: 1) &lt; motley(0) &lt; motley(1.0)
True
</code></pre>
<p>(Because <code>'float' &lt; 'function'</code> :-)</p>
</div>
<span class="comment-copy">I'm not sure, but what you describe might also be an effect of the fact that Python's sorting algorithm is supposed to be stable, in that it doesn't reorder a sequence that is already sorted. See <a href="http://en.wikipedia.org/wiki/Timsort" rel="nofollow noreferrer">Timsort</a>.</span>
<span class="comment-copy">Heh ... yeah, the <code>a &lt; b &lt; c &lt; a</code> cycle does kind of kill the whole approach, doesn't it? Thanks for the thorough answer :-)</span>
<span class="comment-copy">Thought you might be interested to know I've posted a <a href="http://stackoverflow.com/questions/26575183/how-can-i-get-2-x-like-sorting-behaviour-in-python-3-x">followup question</a> ...</span>
