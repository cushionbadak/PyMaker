<div class="post-text" itemprop="text">
<p>I thought Python Processes call their atexit functions when they terminate. Note that I'm using Python 2.7. Here is a simple example:</p>
<pre><code>from __future__ import print_function
import atexit
from multiprocessing import Process


def test():
    atexit.register(lambda: print("atexit function ran"))

process = Process(target=test)
process.start()
process.join()
</code></pre>
<p>I'd expect this to print "atexit function ran" but it does not.</p>
<p>Note that this question:
<a href="https://stackoverflow.com/questions/2546276/python-process-wont-call-atexit">Python process won't call atexit </a>
is similar, but it involves Processes that are terminated with a signal, and the answer involves intercepting that signal. The Processes in this question are exiting gracefully, so (as far as I can tell anyway) that question &amp; answer do not apply (unless these Processes are exiting due to a signal somehow?).</p>
</div>
<div class="post-text" itemprop="text">
<p>I did some research by looking at how this is implemented in CPython. This is assumes you are running on Unix. If you are running on Windows the following might not be valid as the implementation of processes in <code>multiprocessing</code> differs.</p>
<p>It turns out that <code>os._exit()</code> is always called at the end of the process. That, together with the following note from the documentation for <a href="https://docs.python.org/2/library/atexit.html" rel="nofollow">atexit</a>, should explain why your lambda isn't running.</p>
<blockquote>
<p>Note: The functions registered via this module are not called when the
  program is killed by a signal not handled by Python, when a Python
  fatal internal error is detected, or when os._exit() is called.</p>
</blockquote>
<hr/>
<p>Here's an excerpt from the <code>Popen</code> class for CPython 2.7, used for forking processes. Note that the last statement of the forked process is a call to <code>os._exit()</code>.</p>
<pre><code># Lib/multiprocessing/forking.py

class Popen(object):

    def __init__(self, process_obj):
        sys.stdout.flush()
        sys.stderr.flush()
        self.returncode = None

        self.pid = os.fork()
        if self.pid == 0:
            if 'random' in sys.modules:
                import random
                random.seed()
            code = process_obj._bootstrap()
            sys.stdout.flush()
            sys.stderr.flush()
            os._exit(code)
</code></pre>
<p>In Python 3.4, the <code>os._exit()</code> is still there if you are starting a forking process, which is the default. But it seems like you can change it, see <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow">Contexts and start methods</a> for more information. I haven't tried it, but perhaps using a start method of <em>spawn</em> would work? Not available for Python 2.7 though.</p>
</div>
<span class="comment-copy">@MichaelBrennan that question involves Processes which are terminated with a signal. My Processes are simply exiting gracefully, so this isn't a duplicate (the fix posted there doesn't apply here as far as I can tell, unless mine are getting killed by a signal too somehow?)</span>
<span class="comment-copy">You're right, somehow I draw the conclusion that a signal is used even without <code>terminate()</code>. I've deleted the duplication comment. Perhaps you can set up a signal handler and try to find out if there are any signals sent?</span>
<span class="comment-copy">The exit code (i.e. process.exitcode, evaluated after join executes) is zero so as far as I can tell. If I terminate the process I get a negative exit code as expected from the docs. So I'm pretty confused! I can't imagine something this fundamental is broken, but I can't find evidence anywhere that this shouldn't work as I expect.</span>
<span class="comment-copy">That is great, thank you for figuring this out! It seems like the multiprocessing.Process docs should mention this limitation explicitly. Anyway I'll come up with another mechanism to solve this in my case.</span>
