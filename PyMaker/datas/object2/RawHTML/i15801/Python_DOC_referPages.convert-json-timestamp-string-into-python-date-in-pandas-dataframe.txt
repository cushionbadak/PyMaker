<div class="post-text" itemprop="text">
<p>I have a pandas dataframe which I have read from JSON, one date column is a strange timestamp format like follows </p>
<blockquote>
<p>"/Date(1405961743000+0100)/"</p>
</blockquote>
<p>. How can I convert the entire column into a python date?</p>
<p>I have been able to manually convert that date into a python date by using the datetime <code>fromtimestamp</code> function on the first 10 digits i.e. <code>datetime.datetime.fromtimestamp(1405961743)</code> but am struggling to convert the whole column.</p>
<p>I am guessing I need to select the appropriate digits from each entry, convert to integer, then use the fromtimestamp function, but I am new to python (and pandas) so am struggling to do this.</p>
<p>Any help would be appreciated.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Obviously it would be better if you know where the JSON comes from, and can look in the docs/ask the author/etc. to know what the actual intention is behind that date format. (It might even be generated by Python code, using a library you can just use yourself…)</p>
<p>But looking at the numbers, I can make a pretty good guess what this means: the <code>1405961743000</code> is milliseconds since the Unix epoch (which explains why you can use the first 10 digits of it as seconds since the Unix epoch, at least within a pretty wide range around 2014), and the <code>+0100</code> is a timezone offset from GMT, in <code>+HHMM</code> format.</p>
<p>So, instead of extracting the first 10 digits, converting to int, and calling <code>fromtimestamp</code>, you'd want to extract everything up to the <code>+</code> or <code>-</code>, convert to int, divide by 1000, and call <code>fromtimestamp</code>. Although the fact that the only example you've given us happens to have 0 milliseconds implies that there's a good chance they all will, in which case this difference won't matter…</p>
<p>Anyway, it's then up to you what to do with the timezone offset. Do you want to store aware local datetimes? GMT datetimes? naive local datetimes? They're all pretty easy to get to from a timestamp and an offset (although "aware" is going to mean using a fake timezone like GMT-05:00, which doesn't have any historical or DST information, of course), but you have to decide which one you want.</p>
<hr/>
<p>Whatever you end up doing, you may want to consider extending your JSON decoder to automate it, as shown in the examples in <a href="https://docs.python.org/3/library/json.html" rel="nofollow">the docs</a>. (Any string that matches the regex <code>r'/Date\((\d+)([+-]\d{4})\)/'</code>, the first group is the timestamp and the second the offset.)</p>
<p>But maybe not. Especially since <code>parse_string</code> doesn't seem to be overridable, at least as of 3.4, so it looks like you'd have to monkeypatch it. See <a href="http://pastebin.com/a4XszBhE" rel="nofollow">this code</a> I slapped together as a proof of concept; you might be able to make it a little nicer, but there's a limit to how clean you can make it if they didn't provide a hook for it…</p>
<hr/>
<p>PS, if you're ever extending JSON yourself, you may want to consider a more standardized and self-documenting way of doing this. The dict format shown in the <code>json</code> module docs, where you effectively specify a constructor to call and the arguments to pass it, is a lot easier for people to figure out (and to add a hook for). Or, alternatively, there's a quasi-standard way of encoding YAML formats as JSON formats, and YAML is extensible (and already has a standard timestamp extension).</p>
</div>
<div class="post-text" itemprop="text">
<p>The time string is <a href="http://www.odata.org/documentation/odata-version-2-0/json-format" rel="nofollow noreferrer">OData version 2 JSON verbose format for Datetime</a>:</p>
<blockquote>
<p><code>“/Date(&lt;ticks&gt;[“+” | “-” &lt;offset&gt;])/”</code><br/>
<code>&lt;ticks&gt;</code> = number of milliseconds
  since midnight Jan 1, 1970<br/>
<code>&lt;offset&gt;</code> = number of minutes to add or
  subtract</p>
</blockquote>
<p>As <a href="https://stackoverflow.com/questions/26513586/convert-json-timestamp-string-into-python-date-in-pandas-dataframe/26541769#comment41669181_26513834">@Matt Johnson mentions</a> the format may be seen in ASP.NET or WCF applications.</p>
<pre><code>#!/usr/bin/env python3
import re
from datetime import datetime, timedelta, timezone

time_string = "/Date(1405961743000+0100)/"
epoch = datetime(1970, 1, 1, tzinfo=timezone.utc)
ticks, offset = re.match(r'/Date\((\d+)([+-]\d{4})?\)/$', time_string).groups()
utc_dt = epoch + timedelta(milliseconds=int(ticks))
print(utc_dt, utc_dt.strftime('%Z'))
if offset:
   offset = int(offset)
   # http://www.odata.org/documentation/odata-version-2-0/json-format
   # says offset is minutes (an error?)
   dt = utc_dt.astimezone(timezone(timedelta(minutes=offset)))
   print(dt, dt.strftime('%Z'))
   # but it looks like it could be HHMM
   hours, minutes = divmod(abs(offset), 100)
   if offset &lt; 0:
      hours, minutes = -hours, -minutes
   dt = utc_dt.astimezone(timezone(timedelta(hours=hours, minutes=minutes)))
   print(dt, dt.strftime('%Z'))
</code></pre>
<h3><a href="http://ideone.com/qbSnaJ" rel="nofollow noreferrer">Output</a></h3>
<pre><code>2014-07-21 16:55:43+00:00 UTC+00:00
2014-07-21 18:35:43+01:40 UTC+01:40
2014-07-21 17:55:43+01:00 UTC+01:00
</code></pre>
<p>It looks like the odata.org docs should be ignored and the offset should be treated as HHMM format.</p>
</div>
<span class="comment-copy">The format is from older versions of ASP.NET or from WCF applications.  It isn't the best format, but it is well known.  It has been replaced with ISO8601 in most contexts, but it still used by a lot of code.</span>
<span class="comment-copy">@MattJohnson: Thanks! Handy information. Knowing that should make it easier to search for existing code that parses these things, instead of having to guess at it and reinvent the wheel…</span>
<span class="comment-copy"><code>fromtimestamp()</code> without specifying timezone may be wrong if the local UTC offset doesn't correspond to the one in the time string. Here's <a href="http://ideone.com/4n33fj" rel="nofollow noreferrer">how to get an aware datetime object given this time format</a>. It looks like my code is also wrong, the offset is number of minutes (i.e., it is <i>not</i> HHMM).</span>
<span class="comment-copy">on the other hand <a href="http://www.odata.org/documentation/odata-version-2-0/json-format" rel="nofollow noreferrer">the docs</a> can lie, all examples I see use HHMM format instead of "minutes".</span>
<span class="comment-copy">@J.F.Sebastian: Are those the right docs for this format? If not, it's not particularly surprising that two different standards for extending JSON to new types via special string formats would come up with very similar but not quite identical ways of doing it. For example, the dict format used by jsonpickle and by YAML-in-JSON are often identical, but sometimes not. (Which is exactly why having docs or a person to talk to or code is always better than trying to guess from a small sample of the format…)</span>
