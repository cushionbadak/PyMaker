<div class="post-text" itemprop="text">
<p>I am learning about namedtuple. I would like to find a way, using the <code>._replace</code> method, to update all the appearances of a <code>namedtuple</code> wherever they are. </p>
<p>Say I have a list of nodes, and lists of elements (two-node beams, four-node quads) and boundaries ("one node" elements) defined by these nodes. </p>
<p>I am playing around with doing this:</p>
<pre><code>from collections import namedtuple as nt
Node = nt('Node', 'x y')
Beam = nt('Beam', 'i j')
Quad = nt('Quad', 'i j k l')
Boundary = nt('Boundary', 'b')
#Define some nodes:
n1 = Node(0,0)
n2 = Node(0,1)
n3 = Node(1,1)
n4 = Node(1,0)
#And some other things using those nodes:
q1 = Quad(n1,n2,n3,n4)
b1 = Boundary(n1)
be1 = Beam(n1,n4)
</code></pre>
<p>Now, if I replace <code>n1</code> with a new <code>Node</code>:</p>
<pre><code>n1 = n1._replace(x=0.5,y=0.5)
print(n1)  # Node(x=0.5,y=0.5)
</code></pre>
<p>None of the other items are updated:</p>
<pre><code>print(b1)  # Boundary(b=Node(x=0, y=0))
</code></pre>
<p>I understand the Python naming and object model and the <em>why</em> behind this: <code>b1.b</code> has been set to the <em>object</em> <code>Node(0,0)</code>, <em>not</em> the name <code>n1</code>. So when <code>n1</code> is changed, the other namedtuples still contain the same object as before, while <code>n1</code> gets a new object. </p>
<p>What I would like to do is change this behavior so that when I change <code>n1</code>, the changes are "felt" in <code>b1</code>, <code>be1</code>, <code>q1</code>, etc. How can I do this? </p>
</div>
<div class="post-text" itemprop="text">
<p>All instances of <code>namedtuple</code>-produced classes are <em>immutable</em>. <code>._replace()</code> creates a <em>new</em> instance, it doesn't even update the one instance you call this on.</p>
<p>Because the instances are immutable you cannot do what you want with a <code>namedtuple</code>. You'll have to provide such functionality in a subclass, effectively breaking the immutability. Or just provide your own <code>Node</code> custom class that allows the attributes to be mutated directly:</p>
<pre><code>class Node(object):
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return '{0.__class__.__name__}({0.x!r}, {0.y!r})'.format(self)
</code></pre>
<p>Like a <code>namedtuple</code>, this class uses <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow"><code>__slots__</code></a> to cut back on memory use. You can set the <code>x</code> and <code>y</code> attributes directly on instances, and any other references to the instance will see the change:</p>
<pre><code>&gt;&gt;&gt; class Node(object):
...     __slots__ = ('x', 'y')
...     def __init__(self, x, y):
...         self.x = x
...         self.y = y
...     def __repr__(self):
...         return '{0.__class__.__name__}({0.x!r}, {0.y!r})'.format(self)
... 
&gt;&gt;&gt; n1 = Node(10, 20)
&gt;&gt;&gt; n2 = n1
&gt;&gt;&gt; n2
Node(10, 20)
&gt;&gt;&gt; n1.x = 42
&gt;&gt;&gt; n1.y = 81
&gt;&gt;&gt; n2
Node(42, 81)
</code></pre>
</div>
<span class="comment-copy">This is bad news! Do you think I should subclass namedtuple, or do something else entirely?</span>
<span class="comment-copy">@RickTeachey: creating your own class is easy enough.</span>
<span class="comment-copy">@RickTeachey: it is a <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">formatted string</a>; the <code>str.format()</code> method drives it.</span>
<span class="comment-copy">@RickTeachey: you'll need to define <code>__slots__</code> at the class level; this is what the <code>namedtuple()</code> class factory does too. You could write your own, generating a class on the fly is not that hard (just produce a <code>class</code> statement in a function).</span>
<span class="comment-copy">@RickTeachey: this one is very comprehensive: <a href="http://stackoverflow.com/a/6581949">What is a metaclass in Python?</a></span>
