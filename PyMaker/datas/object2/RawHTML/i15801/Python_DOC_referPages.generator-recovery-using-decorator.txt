<div class="post-text" itemprop="text">
<p>Let's have a class that has function that fails from time to time but after some actions it just works perfectly.</p>
<p>Real life example would be Mysql Query that raises <code>_mysql_exceptions.OperationalError: (2006, 'MySQL server has gone away')</code> but after client reconnection it works fine.</p>
<p>I've tried to write decorator for this:</p>
<pre><code>def _auto_reconnect_wrapper(func):
    ''' Tries to reconnects dead connection
    '''

    def inner(self, *args, _retry=True, **kwargs):
        try:
            return func(self, *args, **kwargs)

        except Mysql.My.OperationalError as e:
            # No retry? Rethrow
            if not _retry:
                raise

            # Handle server connection errors only
            # http://dev.mysql.com/doc/refman/5.0/en/error-messages-client.html
            if (e.code &lt; 2000) or (e.code &gt; 2055):
                raise

            # Reconnect
            self.connection.reconnect()

        # Retry
        return inner(self, *args, _retry=False, **kwargs)
    return inner

class A(object):
    ...

    @_auto_reconnect_wrapper
    def get_data(self):
        sql = '...'
        return self.connection.fetch_rows(sql)
</code></pre>
<p>And if client loses connection it just silently reconnect and everybody is happy.</p>
<p>But what if I want to transform <code>get_data()</code> to generator (and use <code>yield</code> statement):</p>
<pre><code>    @_auto_reconnect_wrapper
    def get_data(self):
        sql = '...'
        cursor = self.connection.execute(sql)
        for row in cursor:
            yield row

        cursor.close()
</code></pre>
<p>Well, previous example won't work because inner function already returned generator and it will break after calling first <code>next()</code>.</p>
<p>As I understand it if python sees <code>yield</code> inside method it just yields control immediately (<em>without executing one single statement</em>) and waits for first <code>next()</code>.</p>
<p>I've managed to make it work by replacing:</p>
<pre><code>return func(self, *args, **kwargs)
</code></pre>
<p>With:</p>
<pre><code>for row in func(self, *args, **kwargs):
    yield row
</code></pre>
<p>But I'm curious whether there is more elegant (more pythonic) way to do this. <strong>Is there a way to make python run all the code up to first <code>yield</code> and <em>then</em> wait?</strong></p>
<p>I'm aware of possibility of just calling <code>return tuple(func(self, *args, **kwargs))</code> but I want to avoid loading all records at once.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, I think the solution you're currently using is fine. When you decorate a generator, the decorator is going to need to at least behave like an iterator over that generator. Doing that by making the decorator a generator, too, is perfectly ok. As x3al pointed out, using <code>yield from func(...)</code> instead of <code>for row in func(...): yield row</code> is a possible optimization.</p>
<p>If you want to avoid actually making the decorator a generator, too, you can do that by using <code>next</code>, which will run until the first <code>yield</code>, and return the first yielded value. You'll need to make the decorator somehow capture and return that first value, in addition to the rest of the values to be yielded by the generator. You could do that with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>itertools.chain</code></a>:</p>
<pre><code>def _auto_reconnect_wrapper(func):
    ''' Tries to reconnects dead connection
    '''

    def inner(self, *args, _retry=True, **kwargs):
        gen = func(self, *args, **kwargs)
        try:
            value = next(gen)
            return itertools.chain([value], gen)
        except StopIteration:
            return gen
        except Mysql.My.OperationalError as e:
            ...
            # Retry
            return inner(self, *args, _retry=False, **kwargs)
    return inner
</code></pre>
<p>You could also make the decorator work with both generator and non-generator functions, using <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow"><code>inspect</code></a> to determine if you're decorating a generator:</p>
<pre><code>def _auto_reconnect_wrapper(func):
    ''' Tries to reconnects dead connection
    '''

    def inner(self, *args, _retry=True, **kwargs):
        try:
            gen = func(self, *args, **kwargs)
            if inspect.isgenerator(gen):
                value = next(gen)
                return itertools.chain([value], gen)
            else: # Normal function
                return gen
        except StopIteration:
            return gen
        except Mysql.My.OperationalError as e:
            ...
            # Retry
            return inner(self, *args, _retry=False, **kwargs)
    return inner
</code></pre>
<p>I would favor the <code>yield</code>/<code>yield from</code>-based solution, unless you have a requirement to decorate regular functions in addition to generators.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a way to make python run all the code up to first yield and then wait?</p>
</blockquote>
<p>Yes and it's called <code>next(your_generator)</code>. Call <code>next()</code> once and the code will wait exactly after first <code>yield</code>. You can place another <code>yield</code> right before the loop if you don't want to lose first value.</p>
<p>If you're using python 3.3+, you can also replace</p>
<pre><code>for row in func(self, *args, **kwargs):
    yield row
</code></pre>
<p>with <code>yield from func(self, *args, **kwargs)</code>.</p>
</div>
<span class="comment-copy">I like this answer (+1-ed), but how about case when <code>next(gen)</code> raises <code>StopIteration</code>?</span>
<span class="comment-copy">@Vyktor I've edited my answer to handle that case. You can just catch that exception and return the generator object, which will no-op if an attempt to iterate over it is made (or raise <code>StopIteration</code> again if <code>next</code> is called on it).</span>
<span class="comment-copy">Honestly, that's the reason I suggested to add another <code>yield</code> before the loop in <code>get_data</code>. The dano's sollution is much more clear though.</span>
<span class="comment-copy">@x3al I really don't like the idea of editing the decorated function to make it work properly with the decorator. Because then if you remove the decorator for some reason, <code>get_data</code> is now broken. It also just looks bizarre to someone reading <code>get_data</code> without also reading the decorator.</span>
<span class="comment-copy">You should use <code>next(your_generator)</code>, <code>obj.next()</code> has been removed in Python 3.x</span>
