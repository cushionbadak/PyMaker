<div class="post-text" itemprop="text">
<p>I want to create an int type with boundaries like:</p>
<p><code>&gt; a = BoundInt(2,4)</code></p>
<p><code>a</code> will only hold values 2, 3 or 4 and raise an error if a different value is assigned to it.</p>
<p>But since Python doesn't let me override assignment and using setters is no Pythonic I'm kind of lost. </p>
<p>How could I work this out in my class and what specific syntax would this require when assigning new values to my vars?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you're trying to attach this as an attribute to a class</p>
<p>You can do this via a property:</p>
<pre><code>class Foo(object):
    def __init__(self, a):
        self._a = a

    @property
    def a(self):
        return self._a

    @a.setter
    def a(self, value):
        if not (2 &lt;= value &lt;= 4):
            raise ValueError
        self._a = value 
</code></pre>
<p>Note that I <em>am</em> using a setter.  Python style generally discourages using a function when attribute access will do.  However, if you <em>need</em> to take some action when you set a variable, then a traditional setter or property is fine (depending on the API you want to expose).</p>
<p>If you actually want to do this using a syntax similar to what you've already written, maybe using a descriptor:</p>
<pre><code>class BoundInt(object):
  def __init__(self, lower, upper, name):
      self.lower = lower
      self.upper = upper
      self.name = '_' + name

  def __get__(self, inst, cls):
      return getattr(inst, self.name)

  def __set__(self, inst, val):
      if self.lower &lt;= val &lt;= self.upper:
          setattr(inst, self.name, val)
      else:
          raise ValueError('must be in bounds!')

class Foo(object):
    a = BoundInt(2, 4, 'a')

f = Foo()
f.a = 2
print(f.a)
f.a = 3
print(f.a)
f.a = 4
print(f.a)
f.a = 5
</code></pre>
<p>results in:</p>
<pre><code>2
3
4
Traceback (most recent call last):
  File "/usr/home/mgilson/sandbox/test.py", line 28, in &lt;module&gt;
    f.a = 5
  File "/usr/home/mgilson/sandbox/test.py", line 15, in __set__
    raise ValueError('must be in bounds!')
ValueError: must be in bounds!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a property:</p>
<pre><code>class BoundInt(object):

    def __init__(self, bottom, top):
       self.bounds = range(bottom, top)   # xrange for Python 2.x
       self._value = bottom

     @property
     def value():
         return self._value

     @value.setter
     def value(x):
          if x in self.bounds:
             self._value = x
          else:
              raise ValueError("%s is not in %r" % (x, self.bounds))
</code></pre>
<p>Problem here is that you have to hold your value as an attribute of your object, and then implement all the methods of <code>int</code> that allow you to use it as a number.  In Python, this is basically unavoidable.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can subclass <code>int</code>:</p>
<pre><code>class BoundInt(int):
    def __init__(self, x, allowed=(2, 3, 4), *args, **kwargs):
        value = int(x, *args, **kwargs)
        if value not in allowed:
            raise ValueError("Not in allowed values: " + repr(allowed))
        else:
            self = value

a = BoundInt(2)
print a + 3
b = BoundInt('11', base=2)
print b - a
c = BoundInt(7)
</code></pre>
<p>Please note, that you cannot prevent in Python <code>assigment</code> or value to name. Operator <code>=</code> only binds existing object (value of right hand expression) to a variable name. In Python it is value, that has type, not variable name.</p>
</div>
<span class="comment-copy">your best bet is probably to write an object with a <code>set</code> method that checks for validity. setters aren't Pythonic, no - but when all else fails there isn't really a better option. also, properties and decorators are encouraged syntax in this kind of situation</span>
<span class="comment-copy">A bit unclear. You can't "override" assignment, because it won't modify your object, it will just rebind <code>a</code> to another object. You can even do <code>a = "string"</code>. Doesn't matter what was <code>a</code>'s type before.</span>
<span class="comment-copy">Thanks for the explanation and examples</span>
<span class="comment-copy">to use a syntax like this I should write a class factory or something that returns BoundInt, right? like  <code>bIntClass = BoundIntFactory(min=2, max=4); val = bIntClass(3)</code></span>
<span class="comment-copy">Note that writing <code>self = int(value)</code> does nothing here.  The integer is already created -- it's value set until reaped by the garbage collector.  Yours works because it raises the exception in <code>__init__</code> after the integer is created, but before it can be assigned to anything.</span>
<span class="comment-copy">@mgilson indeed, that was my quirky way to write invariant ;) I edited it out and added support for different bases.</span>
<span class="comment-copy">@dnuske you can write a decorator that validates arguments (maybe better to pass validation as function in this case). And in Python 3.4+ you can use <a href="https://docs.python.org/3/tutorial/controlflow.html#function-annotations" rel="nofollow noreferrer">annotations</a> to pack validation right into signature (you can later verify with decorator or inside the function).</span>
