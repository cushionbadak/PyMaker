<div class="post-text" itemprop="text">
<p>I am trying to parse the output of the linux <a href="http://en.wikipedia.org/wiki/Dig_(command)" rel="nofollow">dig</a> command and do several things on one shot with regular expressions.</p>
<p>Let's say I dig the host <code>mail.yahoo.com</code>:</p>
<pre><code>/usr/bin/dig +nocomments +noquestion \
    +noauthority +noadditional +nostats +nocmd \
    mail.yahoo.com A
</code></pre>
<p>This command outputs:</p>
<pre><code>mail.yahoo.com.                   0  IN  CNAME  login.yahoo.com.
login.yahoo.com.                  0  IN  CNAME  ats.login.lgg1.b.yahoo.com.
ats.login.lgg1.b.yahoo.com.       0  IN  CNAME  ats.member.g02.yahoodns.net.
ats.member.g02.yahoodns.net.      0  IN  CNAME  any-ats.member.a02.yahoodns.net.
any-ats.member.a02.yahoodns.net. 12  IN  A      98.139.21.169
</code></pre>
<p>What I'd like to is finding all the <code>&lt;host&gt;</code>, <code>&lt;record_type&gt;</code> and <code>&lt;resolved_name&gt;</code> parts without the final period using only one regular expression</p>
<p>For this particular example with <code>mail.yahoo.com</code>, it'd be:</p>
<pre><code>[
    ('mail.yahoo.com', 'CNAME', 'login.yahoo.com'),
    ('login.yahoo.com', 'CNAME', 'ats.login.lgg1.b.yahoo.com'),
    ('ats.login.lgg1.b.yahoo.com', 'CNAME', 'ats.member.g02.yahoodns.net'),
    ('ats.member.g02.yahoodns.net', 'CNAME', 'any-ats.member.a02.yahoodns.net'),
    ('any-ats.member.a02.yahoodns.net', 'A', '98.139.21.169'),
]
</code></pre>
<p>But it turns out that the <code>dig</code> command might be showing a period at the end of the name: </p>
<pre><code>    mail.yahoo.com. 
        ^     ^   ^
        |     |   |
  Good dot    |   |
              |   |
        Good dot  |
                  |
           (!) Baaaad dot
</code></pre>
<p>Doing a regular expression that splits <code>dig</code>'s output and returns the name with the final period is fairly straightforward:</p>
<pre><code>regex = re.compile("^(\S+).+IN\s+([A-Z]+)\s+(\S+)\.*\s*$",re.MULTILINE)
</code></pre>
<p>But calling <code>.findall</code> with that regex does return the final period in the host, because <code>\S+</code> will match the last period as well:</p>
<pre><code>[
    ('mail.yahoo.com.', 'CNAME', 'login.yahoo.com.'),
    ('login.yahoo.com.', 'CNAME', 'ats.login.lgg1.b.yahoo.com.'),
    ('ats.login.lgg1.b.yahoo.com.', 'CNAME', 'ats.member.g02.yahoodns.net.'),
    ('ats.member.g02.yahoodns.net.', 'CNAME', 'any-ats.member.a02.yahoodns.net.'),
    ('any-ats.member.a02.yahoodns.net.', 'A', '98.139.21.169'),
]
</code></pre>
<p>So I'd need <em>something</em> that matches all non-spaces <code>\S</code> except if it's a period followed by a whitespace.</p>
<p>I've done endless tries, and I haven't been able to come up with a decent solution.</p>
<p>Thank you in advance!</p>
<p><strong>PS:</strong>
I know I can always use the "easy" regular expression and (on a second pass) remove the last dot of the found string, but I'm curious about whether this can be done with a regular expression in one shot.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this pattern with multiline modifier:</p>
<pre><code>^([^ ]+)(?&lt;!\.)\.?[ ]+[0-9]+[ ]+IN[ ]+([^ ]+)[ ]+(.+(?&lt;!\.))\.?$
</code></pre>
<p>Groups stored in $1 $2 and $3</p>
<p><a href="http://rubular.com/r/JisUlMLAL0" rel="nofollow">DEMO</a></p>
<p>Edit:  Try this:</p>
<pre><code>^([^ \t]+)(?&lt;!\.)\.?[ \t]+[0-9]+[ \t]+IN[ \t]+([^ \t]+)[ \t]+(.+(?&lt;!\.))\.?$
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But calling <code>.findall</code> with that regex does return the final period in the host, because <code>\S+</code> will match the last period as well…</p>
</blockquote>
<p>There are two problems here.</p>
<p>First, once you're escaping things with backslashes, you need to use raw string literals (<code>r"…"</code>), or you have to escape the backslashes too. I'm not actually sure whether any of your backslash-prefixed characters happen to match Python backslash-escape sequences, but that in itself is enough reason to use a raw-string literal, so your readers don't have to look up the exact rules.</p>
<p>Second, the general case of this problem is that regex repeats are <a href="https://docs.python.org/3/howto/regex.html#greedy-versus-non-greedy" rel="nofollow">greedy</a> by default: they will match as much as possible while still allowing the rest of the pattern to match; when you want them to match as <em>little</em> as possible while still allowing the rest of the pattern to match, you need to add a <code>?</code> after the <code>+</code> or <code>*</code>.</p>
<p>In your particular case, the <code>\S+</code> can match everything up to and including the final <code>.</code>, and the <code>\.*\s*</code> will successfully match 0 <code>.</code>s and 0 spaces. but <code>\S+?</code> will leave the final <code>.</code> for the next part of the pattern. You can also force the period out of the first group by appending a period after it. Like so:</p>
<pre><code>^(\S+)\..+IN\s+([A-Z]+)\s+(\S+?)\.*\s*$
</code></pre>
<p><img alt="Regular expression visualization" src="https://www.debuggex.com/i/2b1_JafSMDlU--4_.png"/></p>
<p><a href="https://www.debuggex.com/r/2b1_JafSMDlU--4_" rel="nofollow">Debuggex Demo</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply force that there is no period at the end of your group (and that it contains no space) :</p>
<pre><code>npg = '([^\.\s]+(?:.[^\.\s]+)*)' #not_period_ending_group
regex = re.compile("^" + npg + ".+IN\s+([A-Z]+)\s+" + npg +".+$",re.MULTILINE)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative answer i suggest to use <code>str.split()</code>,
if you have your string lines in a list like <code>L</code> you need this :</p>
<pre><code>[(line[0][:-1],line[3],line[4][:-1]) for line in L]
</code></pre>
<p>Note that <code>[:-1]</code> remove the last <code>.</code> from host address !</p>
</div>
<span class="comment-copy">A simple change to your regex gets you the desired result <code>regex = re.compile("^(\S+)\..+IN\s+([A-Z]+)\s+(\S+)\.\s*$",re.MULTILINE)</code> Note that I'm explicitly matching the dot character at the beginning and the end.</span>
<span class="comment-copy">This doesn't work because sometimees there is no period at the end of the resolved name (for instance 98.139.21.169). But I believe abarnert and I proposed some working solutions ;)</span>
<span class="comment-copy">This is pretty close, but it seems to have problems dealing with tabs.</span>
<span class="comment-copy">Message updated</span>
<span class="comment-copy">Sorry I'm not sleeping so I end up doing the same questions as you. I hope you don't mind ;(</span>
<span class="comment-copy">@abarnert makes a good point about using raw string (in this case it is not needed but it's good practice, I don't put them because I'm lazy to add 4 r, but do it on production code.)</span>
<span class="comment-copy">I'm a bit torn about what answer should I choose... This is closer to my initial regexp idea, but abarnet's explanation might be useful for other OPs...</span>
<span class="comment-copy">I really have the impression that there is also an unwanted period at the end of first group (therefore line[0][:-1]), am I wrong here ?</span>
<span class="comment-copy">@Ara oh yes ...thanks for reminding !</span>
