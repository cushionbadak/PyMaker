<div class="post-text" itemprop="text">
<p>I have a path which looks like</p>
<pre><code>/First/Second/Third/Fourth/Fifth
</code></pre>
<p>and I would like to remove the <code>First</code> from it, thus obtaining</p>
<pre><code>Second/Third/Fourth/Fifth
</code></pre>
<p>The only idea I could come up with is to use recursively <code>os.path.split</code> but this does not seem optimal. Is there a better solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>There really is nothing in the <code>os.path</code> module to do this. Every so often, someone suggests creating a <code>splitall</code> function that returns a list (or iterator) of all of the components, but it never gained enough traction.</p>
<p>Partly this is because every time anyone ever suggested adding new functionality to <code>os.path</code>, it re-ignited the long-standing dissatisfaction with the general design of the library, leading to someone proposing a new, more OO-like, API for paths to deprecated the os, clunky API. In 3.4, that finally happened, with <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a>. And it's already got functionality that wasn't in <code>os.path</code>. So:</p>
<pre><code>&gt;&gt;&gt; p = pathlib.Path('/First/Second/Third/Fourth/Fifth')
&gt;&gt;&gt; p.parts[2:]
('Second', 'Third', 'Fourth', 'Fifth')
&gt;&gt;&gt; pathlib.Path(*p.parts[2:])
PosixPath('Second/Third/Fourth/Fifth')
</code></pre>
<p>Or… are you sure you really want to remove the first component, rather than do this?</p>
<pre><code>&gt;&gt;&gt; p.relative_to(*p.parts[:2])
PosixPath('Second/Third/Fourth/Fifth')
</code></pre>
<p>If you need to do this in 2.6-2.7 or 3.2-3.3, there's a <a href="https://pypi.python.org/pypi/pathlib/" rel="noreferrer">backport of <code>pathlib</code></a>.</p>
<p>Of course, you can use string manipulation, as long as you're careful to normalize the path and use <code>os.path.sep</code>, and to make sure you handle the fiddly details with non-absolute paths or with systems with drive letters, and…</p>
<p>Or you can just wrap up your recursive <code>os.path.split</code>. What exactly is "non-optimal" about it, once you wrap it up? It may be a bit slower, but we're talking nanoseconds here, many orders of magnitude faster than even calling <code>stat</code> on a file. It will have recursion-depth problems if you have a filesystem that's 1000 directories deep, but have you ever seen one? (If so, you can always turn it into a loop…) It takes a few minutes to wrap it up and write good unit tests, but that's something you just do once and never worry about again. So, honestly, if you don't want to use <code>pathlib</code>, that's what I'd do.</p>
</div>
<div class="post-text" itemprop="text">
<p>A bit like another answer, taking advantage of os.path :</p>
<pre><code>os.path.join(*(x.split(os.path.sep)[2:]))
</code></pre>
<p>... assuming your string starts with a separator.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple approach</p>
<pre><code>a = '/First/Second/Third/Fourth/Fifth'
"/".join(a.strip("/").split('/')[1:])
</code></pre>
<p>output:</p>
<pre><code>Second/Third/Fourth/Fifth
</code></pre>
<p>In this above code i have split the string. then joined leaving 1st element</p>
<p>Using <code>itertools.dropwhile</code>:</p>
<pre><code>&gt;&gt;&gt; a = '/First/Second/Third/Fourth/Fifth'
&gt;&gt;&gt; "".join(list(itertools.dropwhile(str.isalnum, a.strip("/"))[1:])
'Second/Third/Fourth/Fifth'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was looking if there was a native way to do it, but it seems it doesn't. </p>
<p>I know this topic is old, but this is what I did to get me to the best solution:
There was two basically two approaches: using split() and using len(). Both had to use slicing.</p>
<p>1) Using split()</p>
<pre><code>import time

start_time = time.time()

path = "/folder1/folder2/folder3/file.zip"
for i in xrange(500000):
    new_path = "/" + "/".join(path.split("/")[2:])

print("--- %s seconds ---" % (time.time() - start_time))
</code></pre>
<p><strong>Result: --- 0.420122861862 seconds ---</strong></p>
<p>*Removing the char "/" in the line new_path = "/" + "/".... didn't improve the performance too much.</p>
<p>2) Using len(). <strong>This method will only work if you provide the folder if you would like to remove</strong></p>
<pre><code>import time

start_time = time.time()

path = "/folder1/folder2/folder3/file.zip"
folder = "/folder1"
for i in xrange(500000):
    if path.startswith(folder):
        a = path[len(folder):]

print("--- %s seconds ---" % (time.time() - start_time))
</code></pre>
<p><strong>Result: --- 0.199596166611 seconds ---</strong></p>
<p>*Even with that "if" to check if the path starts with the file name, it was twice as fast as the first method. </p>
<p>In summary: each method has a pro and con. If you are absolutely sure about the folder you want to remove use method two, otherwise I recommend to use method 1 which people here have mentioned previously.  </p>
</div>
<span class="comment-copy"><code>pathlib</code> dosent come with python, need to install it</span>
<span class="comment-copy">performance-wise you are totally right: we are talking about nanoseconds; it is more me trying to learn the best way / other ways of doing it</span>
<span class="comment-copy">@Hackaholic: As the answer explains in detail, <code>pathlib</code> comes with Python 3.4+, and you can install the backport for 2.6-2.7 or 3.2-3.3.</span>
<span class="comment-copy">@meto: Yeah, that's perfectly reasonable. It's just that often when people say "optimize" or "efficient" they really are asking about (time) performance, in cases where it doesn't actually matter, so it's better to be sure of what people are asking for…</span>
<span class="comment-copy">@abarnert as a serious question: what would be the best way of asking stuff like this, in your opinion?</span>
<span class="comment-copy">Can you explain a bit about the use of the "*" here?</span>
<span class="comment-copy">@Luke The * is used in order to treat the set generated by <code>(x.split(os.path.sep)[2:])</code> as the <code>*args</code> keyword. However, this will not work is the path is too short since the argument list will be completely empty</span>
<span class="comment-copy">At first I thought this wouldn't work on paths which start with the path seperator because you seem to wantonly strip the first character from the string, but upon further review, what does the first character matter if you are just removing the first segment. +1, but maybe something in the answer which says this (or maybe a comment by someone you helped)</span>
<span class="comment-copy">@iLoveTux made it more efficient</span>
<span class="comment-copy">Amazinf, Thanks</span>
