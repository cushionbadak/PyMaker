<div class="post-text" itemprop="text">
<p>I have a method that take a list and return an object</p>
<pre><code># input a list, returns an object
def map_to_obj(lst):
    a_list = f(lst)
    return a_list[0] if a_list else None
</code></pre>
<p>I want to get a list that contains all the mapped elements that isn't <code>None</code>.</p>
<p>Like this:</p>
<pre><code>v_list = [v1, v2, v3, v4]

[map_to_obj(v) for v in v_list if map_to_obj(v)]
</code></pre>
<p>But it seems not good to call the <code>map_to_obj</code> method twice in the list comprehension. </p>
<p>Is there a way to have local variables in list comprehension so that it can have better performance? </p>
<p>Or does the compiler optimize it automatically?</p>
<p>Here is what I want:</p>
<pre><code>(sml like)
[let mapped = map_to_obj(v) in for v in v_list if mapped end] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use nested list comprehension:</p>
<p><code>[x for x in [map_to_obj(v) for v in v_list] if x]</code></p>
<p>or better still, a list comprehension around a generator expression:</p>
<p><code>[x for x in (map_to_obj(v) for v in v_list) if x]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid re-calculation by using python built-in <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a>:</p>
<pre><code>list(filter(lambda t: t is not None, map(map_to_obj, v_list)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A variable assignment is just a singular binding: </p>
<pre><code>[x   for v in l   for x in [v]]
</code></pre>
<p>This is a more general answer and also closer to what you proposed. 
So for your problem you can write:</p>
<pre><code>[x   for v in v_list   for x in [map_to_obj(v)]   if x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A local variable can be set within a comprehension by cheating a bit and using an extra 'for' which "iterates" through a 1-element tuple containing the desired value for the local variable. Here's a solution to the OP's problem using this approach:</p>
<pre><code>[o for v in v_list for o in (map_to_obj(v),) if o]
</code></pre>
<p>Here, <code>o</code> is the local variable being set equal to <code>map_to_obj(v)</code> for each <code>v</code>.</p>
<p>In my tests this is slightly faster than Lying Dog's nested generator expression (and also faster than the OP's double-call to <code>map_to_obj(v)</code>, which, surprisingly, can be faster than the nested generator expression if the <code>map_to_obj</code> function isn't too slow).</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions are fine for the simple cases, but sometimes a plain old <code>for</code> loop is the simplest solution:</p>
<pre><code>other_list = []
for v in v_list:
    obj = map_to_obj(v)
    if obj:
        other_list.append(obj)
</code></pre>
<p>Now if you really want a list comp and dont want to build an tmp list, you can use the iterator versions of <code>filter</code> and <code>map</code>:</p>
<pre><code>import itertools as it
result = list(it.ifilter(None, it.imap(map_to_obj, v_list)))
</code></pre>
<p>or more simply :</p>
<pre><code>import itertools as it
result = filter(None, it.imap(map_to_obj, v_list)))
</code></pre>
<p>The iterator versions don't build a temporary list, they use lazy evaluation.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have figured out a way of using <code>reduce</code>:</p>
<pre><code>def map_and_append(lst, v):
    mapped = map_to_obj(v)
    if mapped is not None:
        lst.append(mapped)
    return lst

reduce(map_and_append, v_list, [])
</code></pre>
<p>How about the performance of this?</p>
</div>
<span class="comment-copy">It is a fine answer, and of course it is the same as <a href="http://stackoverflow.com/users/625914/behzad-nouri">behzad</a>'s one, with list comprehensions in place of <code>map</code> and <code>filter</code>... I' going to upvote as I liked how <a href="http://stackoverflow.com/users/4134826/lying-dog">Lying Dog</a> translated <code>filter</code> in terms of l-c, but the OP may approve either one of those answers as both are fine, useful answers.</span>
<span class="comment-copy">The inner comprehension should be a generator expression. No need to build the entire list and only then throw away the empty items to build yet another list.</span>
<span class="comment-copy">@Lying Imho Tim's advice is sound and meaningful, please consider editing your answer to reflect his suggestion.</span>
<span class="comment-copy">@cowbert: If a <code>lambda</code> (actually any Python implemented function that the comprehension could inline to avoid the call overhead) is involved, yes, the listcomp wins. <code>map</code>/<code>filter</code> can win if the callback function is a C built-in though, as they can push all the work to the C layer, bypassing bytecode interpreter overhead, which listcomps cannot avoid, as they're Python level functions, just with direct bytecode support for the append-to-list step.</span>
<span class="comment-copy">Silly example: Changing behzad's answer to replace <code>lambda t: t is not None</code> with <code>None.__ne__</code>, while ever-so-slightly weird in how it works (it returns <code>False</code> for other <code>None</code>s, and <code>NotImplemented</code>, which happens to be truthy, for everything else), would improve the speed of that solution (in local tests, the <code>filter</code> work drops by nearly a factor of 2), though at the expense of comprehensibility.</span>
<span class="comment-copy">But that also iterates the list twice...</span>
<span class="comment-copy">Is there a one-iteration solution?</span>
<span class="comment-copy">@HaoTan not in python 3; in python 3, <code>map</code> returns a map object not a list, and <code>filter</code> returns a filter object; so, this will <i>chain</i> the functions without making intermediate lists.</span>
<span class="comment-copy">Is it possible to use <code>reduce</code> to do the job?</span>
<span class="comment-copy">@HaoTan: Why would you? <code>reduce</code> is for combining many things down to one thing, not for changing many things to many things. The work done by a paired <code>map</code> and <code>filter</code> (that is then <code>list</code>ified) is equivalent to that done by a listcomp that performs both filtering and mapping operations.</span>
<span class="comment-copy">This differs from my answer only by using a 1-element list instead of a 1-element tuple, and I think tuple beats list when it doesn't need to be mutable. :-)</span>
<span class="comment-copy">You can use the <code>timeit</code> module to time the different solutions, but your above snippet is an arbitrarily overcomplexificated way to do a very simple thing - and I doubt it will be either faster or more space-efficient than the plain old for loop or the filter/imap solutions...</span>
<span class="comment-copy">@Bruno I like your «overcomplexificated» !</span>
<span class="comment-copy">If I look at the no itertools answers, performance notwithstanding, I dare say <a href="http://stackoverflow.com/a/26672589/2749397">Lying Dog's one</a> is the most expressive of the intent, and hence the most readable. And what about performance? well, I don't know how much cpu you spend in your <code>f(lst)</code> calls but removing the <code>None</code>s one way or another is unlikely to change the whole picture.</span>
<span class="comment-copy"><code>reduce</code> really isn't called for here. It's use is for reducing a list of values to a single value (typically, a list of scalars to a single scalar), not transforming one list into another list.</span>
