<div class="post-text" itemprop="text">
<p>I'm working on a KNN Classifier using Python but I have some problems.
The following piece of code takes 7.5s-9.0s to be completed and i'll have to run it for 60.000 times.</p>
<pre><code>        for fold in folds:  
            for dot2 in fold:
                """
                distances[x][0] = Class of the dot2
                distances[x][1] = distance between dot1 and dot2
                """
                distances.append([dot2[0], calc_distance(dot1[1:], dot2[1:], method)])
</code></pre>
<p>The "folds" variable is a list with 10 folds that summed contain 60.000 inputs of images in the .csv format. The first value of each dot is the class it belongs to. All the values are in integer.
Is there a way to make this line run any faster ?</p>
<p>Here it is the <code>calc_distance</code> function</p>
<pre><code>def calc_distancia(dot1, dot2, distance):

if distance == "manhanttan":
    total = 0
    #for each coord, take the absolute difference
    for x in range(0, len(dot1)):
        total = total + abs(dot1[x] - dot2[x])
    return total

elif distance == "euclidiana":
    total = 0
    for x in range(0, len(dot1)):
        total = total + (dot1[x] - dot2[x])**2
    return math.sqrt(total)

elif distance == "supremum":
    total = 0
    for x in range(0, len(dot1)):
        if abs(dot1[x] - dot2[x]) &gt; total:
            total = abs(dot1[x] - dot2[x])
    return total

elif distance == "cosseno":
    dist = 0
    p1_p2_mul = 0
    p1_sum = 0
    p2_sum = 0
    for x in range(0, len(dot1)):
        p1_p2_mul = p1_p2_mul + dot1[x]*dot2[x]
        p1_sum = p1_sum + dot1[x]**2
        p2_sum = p2_sum + dot2[x]**2
    p1_sum = math.sqrt(p1_sum)
    p2_sum = math.sqrt(p2_sum)
    quociente = p1_sum*p2_sum
    dist = p1_p2_mul/quociente

    return dist
</code></pre>
<p>EDIT:
Found a way to make it faster at least for the "manhanttan" method. Instead of:</p>
<pre><code>    if distance == "manhanttan":
    total = 0
    #for each coord, take the absolute difference
    for x in range(0, len(dot1)):
        total = total + abs(dot1[x] - dot2[x])
    return total
</code></pre>
<p>i put</p>
<pre><code>    if distance == "manhanttan":
    totalp1 = 0
    totalp2 = 0
    #for each coord, take the absolute difference
    for x in range(0, len(dot1)):
        totalp1 += dot1[x]
        totalp2 += dot2[x]

    return abs(totalp1-totalp2)
</code></pre>
<p>The <code>abs()</code> call is very heavy</p>
</div>
<div class="post-text" itemprop="text">
<p>There are many guides to "profiling python"; you should search for some, read them, and walk through the profiling process to ensure you know what parts of your work are taking the most time.</p>
<p>But if this is really the core of your work, it's a fair bet that that <code>calc_distance</code> is where the majority of the running time is being consumed.</p>
<p>Optimizing that deeply will probably require using <a href="http://www.numpy.org" rel="nofollow">NumPy</a> accelerated math or a similar, lower-level approach.</p>
<p>As a quick and dirty approach requiring less invasive profiling and rewriting, try installing the <a href="http://pypy.org" rel="nofollow">PyPy</a> implementation of Python and running under it. I have seen easy 2x or more accelerations compared to the standard (CPython) implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm confused. Did you try the profiler?</p>
<pre><code> python -m cProfile myscript.py
</code></pre>
<p>It will show you where the bulk of the time is being consumed and provide hard data to work with. eg. refactor to reduce the number of calls, restructure the input data, substitute this function for that, etc.</p>
<p><a href="https://docs.python.org/3/library/profile.html" rel="nofollow">https://docs.python.org/3/library/profile.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In the first place, you should avoid using a single <code>calc_distance</code> function that performs a linear search in a list of strings on every call. Define independent distance functions and call the right one. As  Lee Daniel Crocker suggested, don't use the slicing, just start your loop ranges at 1.</p>
<p>For the cosine distance, I would recommend to normalize all the dot vectors once for all. This way the distance computation reduces to a dot product.</p>
<p>These micro-optimization can give you some speedup. But a better gain should be possible by switching to a better algorithm: the kNN classifier calls for a <a href="http://en.wikipedia.org/wiki/K-d_tree" rel="nofollow">kD-tree</a>, that will allow you to quickly remove a significant fraction of the points from consideration.</p>
<p>This is harder to implement (you'll have to slightly adapt for the different distances; the cosine distance will make it tricky.)</p>
</div>
<span class="comment-copy">Here are a couple of links that may help: <a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" rel="nofollow noreferrer">wiki.python.org/moin/PythonSpeed/PerformanceTips</a> <a href="http://nbviewer.ipython.org/github/rasbt/python_reference/blob/master/benchmarks/timeit_tests.ipynb?create=1#string_operations" rel="nofollow noreferrer">nbviewer.ipython.org/github/rasbt/python_reference/blob/master/â€¦</a></span>
<span class="comment-copy">Please edit your answer to include the whole code. Also include the input (or at least some of it).</span>
<span class="comment-copy"><i>"some help to optimize a python code"</i> is not an on-topic question here.</span>
<span class="comment-copy">Okay. Just a second</span>
<span class="comment-copy">Meanwhile, have you considered either (a) using NumPy and restructuring your program so it can broadcast the operation element-wise over the array instead of looping, (b) running under PyPy or some other JIT-based implementation instead of CPython, or (c) compiling the inner loop with Cython?</span>
<span class="comment-copy">I talked to my teacher and he said that the time is right. It takes a lot of time.  I used these arguments and they'll help me a lot. The function "calc_distance" takes a lot of time to process. I'll try to make it faster.</span>
<span class="comment-copy">You can improve that a lot with numpy array/s.</span>
