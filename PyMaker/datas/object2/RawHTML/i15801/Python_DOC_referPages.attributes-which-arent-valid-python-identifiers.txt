<div class="post-text" itemprop="text">
<p>The usual method of attribute access requires attribute names to be <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers">valid python identifiers</a>.  </p>
<p>But attributes don't have to be valid python identifiers:</p>
<pre><code>&gt;&gt;&gt; class Thing:
...     def __init__(self):
...         setattr(self, '0potato', 123)
...         
&gt;&gt;&gt; t = Thing()
&gt;&gt;&gt; Thing.__getattribute__(t, '0potato')
123
&gt;&gt;&gt; getattr(t, '0potato')
123
</code></pre>
<p>Of course, <code>t.0potato</code> remains a <code>SyntaxError</code>, but the attribute is there nonetheless:</p>
<pre><code>&gt;&gt;&gt; vars(t)
{'0potato': 123}
</code></pre>
<p>What is the reason for this being permissable?  Is there really any valid use-case for attributes with spaces, empty string, python reserved keywords etc?  I thought the reason was that attributes were just keys in the object/namespace dict, but this makes no sense because other objects which are valid dict keys are not allowed: </p>
<pre><code>&gt;&gt;&gt; setattr(t, ('tuple',), 321)
TypeError: attribute name must be string, not 'tuple'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, to answer the use case question, looking at the reasoning behind how Python works in the references from the comments above, we can infer some of the situations that might make this Pythonic quirk useful.</p>
<ol>
<li>You want an object to have an attribute that cannot be accessed with dot notation, say, to protect it from the naive user. (Quoting Guido: "some people might use this to hide state they don't want accessible using regular attribute notation (x.foo)". Of course, he goes on to say, "but that feels like abuse of the namespace to me, and there are plenty of other
ways to manage such state.")</li>
<li>You want an object's attribute names to correspond to external data over which you have no control. Thus, you have to be able to use whatever strings appear in the external data as an attribute name even if it matches a Python reserved word or contains embedded spaces or dashes, etc.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The details from a <a href="https://stackoverflow.com/questions/26534634/attributes-which-arent-valid-python-identifiers#comment41696226_26534634">comment</a> on the post fully answer this question, so I'm posting it as an answer:  </p>
<p><a href="https://mail.python.org/pipermail/python-dev/2012-March/117441.html" rel="nofollow noreferrer">Guido</a> says:</p>
<blockquote>
<p>...it is a <em>feature</em> that you can use any arbitrary string
  with getattr() and setattr(). However these functions should (and do!)
  reject non-strings.</p>
</blockquote>
<p>Possible use-cases include hiding attributes from regular dotted access, and making attributes in correspondence with external data sources (which may clash with Python keywords).  So, the argument seems to be there's simply no good reason to forbid it.  </p>
<p>As for a reason to disallow non-strings, this seems to be a sensible restriction which is ensuring greater performance of the implementation:</p>
<blockquote>
<p>Although Python's dicts already have some string-only optimizations -- they just dynamically adapt to a more generic and slightly slower approach once the first non-key string shows up.  </p>
</blockquote>
</div>
<span class="comment-copy">The answer for why this is allowed can be found in @poke's answer <a href="http://stackoverflow.com/a/25477703/2555451">here</a>.  I don't think that your question should be dupe-hammered however because it asks for legitimate use-cases where as the other only asks why this is allowed.</span>
<span class="comment-copy">For a start see Martin v. LÃ¶wis's response in <a href="http://bugs.python.org/issue14029" rel="nofollow noreferrer">Python Issue 14029</a>.  So it mostly depends on the underlying implementation of <code>__setattr__</code> which may accept non-identifiers.  Still, though it is possible to create a <code>__setattr__</code> that accepts tuples, but still fails when called via <code>setattr</code>.  So it seems that the builtin method doesn't just blindly hand off its arguments to the object's <code>__setattr__</code> method.</span>
<span class="comment-copy">Here is <a href="https://mail.python.org/pipermail/python-dev/2012-March/117441.html" rel="nofollow noreferrer">Guido van Rossum considering</a> your question.</span>
