<div class="post-text" itemprop="text">
<p>Is there a way to tell the python unittest execute all assertion in a method and show all cases it fails, instead of stop at the first failed.</p>
<pre><code>class MyTestCase(TestCase):
    def test_a(self):
        with open('testcase.txt') as ifile: 
            for iline in ifile:
                self.assertEqual(iline, 'it is a test!')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.4 introduced the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.subTest" rel="noreferrer"><code>subTest</code></a> context manager. Your code will look like</p>
<pre><code>class MyTestCase(TestCase):
    def test_a(self):
        with open('testcase.txt') as ifile: 
            for iline in ifile:
                with self.subTest(line=iline):
                    self.assertEqual(iline, 'it is a test!')
</code></pre>
<p>The ugly way to achieve this without <code>subTest</code> is to make <code>self.assert*</code> calls within a <code>try</code> block, print the errors caught, and raise the <code>AssertionError</code> explicitly after the loop if at least one test failed. </p>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively, you can make a <em>data-driven-test</em> with the help of <a href="http://ddt.readthedocs.org/en/latest/example.html" rel="nofollow"><code>ddt</code> package</a>:</p>
<blockquote>
<p>DDT (Data-Driven Tests) allows you to multiply one test case by
  running it with different test data, and make it appear as multiple
  test cases.</p>
</blockquote>
<pre><code>import unittest
from ddt import ddt, data

@ddt
class FooTestCase(unittest.TestCase):
    @data('it is a test!', 'it is a test!', 'something else')
    def test_lines(self, value):
        self.assertEqual(value, 'it is a test!')
</code></pre>
<p><code>ddt</code> can also have the <a href="http://ddt.readthedocs.org/en/latest/api.html#ddt.file_data" rel="nofollow">data coming from a file</a>, but it has to be a JSON file.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generally no. Unit tests stop at first fail. If you want to compare all lines you need to have a local list and then put the different lines into the list. Then assert that list length is zero. Or a local boolean variable.</p>
</div>
<span class="comment-copy">I have yet to see a unit test framework that accumulates errors and reports them all. It seems that the standard is to fail on first failure.</span>
<span class="comment-copy">@TGH: I have; <a href="https://code.google.com/p/googletest/wiki/Primer" rel="nofollow noreferrer">googletest</a> has <code>EXPECT</code> macros that continue on failure and <code>ASSERT</code> macros that abort immediately.</span>
<span class="comment-copy">@user2357112 Ok interesting. I guess it makes sense since it's just a design choice made by the creator of the framework. I guess a common pattern is to throw exceptions when asserts fail, leaving it to the caller to implement their own tally of exceptions if desirable.</span>
<span class="comment-copy">I guess I need to find a subtest backport for python 2.7...</span>
<span class="comment-copy">@lucemia subTest is unarguably the easiest way to achieve what you want, but you can also use <code>try..except</code> in a loop to print exceptions.</span>
<span class="comment-copy">The problem with subtests is that <code>setUp</code> is not automatically called for each subtest, as can sometimes be necessary. It can however certainly be called manually as <code>self.setUp()</code> within the subtest.</span>
