<div class="post-text" itemprop="text">
<p>I have to write a code that somehow works for both python versions and I can't understand the behavior of the code:</p>
<pre><code>from __future__ import print_function
import sys
sys.stdout.flush()
print("input: ", end="")
f = sys.stdin.readline()
print(f)
</code></pre>
<p>When I run the code with python2 it behaves like I expect:</p>
<pre><code>$ python2 test_input.py 
input: foo bar
foo bar
</code></pre>
<p>When I run the code with python3 it behaves strange. It first reads the input
and then prints the prompt:</p>
<pre><code>$ python3 test_input.py 
foo bar
input: foo bar
</code></pre>
<p>Can you explain this and suggest a fix?</p>
</div>
<div class="post-text" itemprop="text">
<p>You got your <code>flush()</code> and <code>print()</code> backwards.  Here is the correct order:</p>
<pre><code># First, write to stdout
print("input: ", end="")
# Then, flush all data in the stdout buffer
sys.stdout.flush()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The difference is that CPython 2  uses C stdio to implement standard streams such as <code>sys.stdin</code>, <code>sys.stdout</code> (used by <code>print()</code>) while Python 3 reimplements IO on top of system API e.g., open, read, write on POSIX.</p>
<p>To avoid thinking about how <code>print()</code> is implemented, the same issue occurs if <code>sys.stdout</code> is used directly:</p>
<pre><code># __main__.py
import sys

sys.stdout.write("input: ")
f = sys.stdin.readline()
sys.stdout.write("*" + f)
</code></pre>
<p>On Python 3 <code>"input: "</code> is not printed before the <code>readline()</code> call:</p>
<pre><code>$ python2 .
input: foo bar
*foo bar
$ python3 .
foo bar
input: *foo bar
</code></pre>
<p>In C, <code>stdout</code> is flushed before reading any input in the interactive case (it is undefined behavior if an output operation is followed by an input operation on the same update stream without <code>fflush()</code> in between). This C program prints <code>"input: "</code> before asking for input as expected:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;

#define MAXLEN 100

int main(void) {
  char buf[MAXLEN] = {0};

  fputs("input: ", stdout);
  if (!fgets(buf, MAXLEN, stdin))
    return 1;

  fputs(buf, stdout);
  return 0;
}
</code></pre>
<p>That is why the workaround: calling <code>sys.stdout.flush()</code> before <code>sys.stdin.readline()</code> <a href="https://stackoverflow.com/a/26449390/4279">suggested by @Dietrich Epp</a> works.</p>
<p>It is a deficiency in Python 3 implementation. stdout shall be flushed by default before reading from stdin if both point to the same place (<code>os.path.samefile(sys.stdout.fileno(), sys.stdin.fileno())</code> e.g., if both tty). You could <a href="http://bugs.python.org/" rel="nofollow noreferrer">report the issue at Python bug tracker</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3 the <code>flush</code> keyword was added to the <a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow"><code>print()</code> function</a>:</p>
<blockquote>
<p><em>Changed in version 3.3</em>: Added the flush keyword argument.</p>
</blockquote>
<p>In versions before 3.3, the <code>print()</code> function would <em>always</em> flush, even when using <code>end=''</code>. Your exact behaviour also reproduced using Python 3.2:</p>
<pre><code>$ python3.2 test.py 
foo bar
input: foo bar
</code></pre>
<p>To get the same behaviour, flush in Python 3.3:</p>
<pre><code>try:
    print("input: ", end="", flush=True)
except TypeError:
    print("input: ", end="")
</code></pre>
<p>or use <code>sys.stdout.flush()</code> after <code>print()</code> calls on Python 3.3 or up.</p>
</div>
<span class="comment-copy">The I/O subsystem in Python 3 is a complete overhaul (see the <code>io</code> module, available in Python 2 as well), so it is no suprise that flushing behaviour may have changed.</span>
<span class="comment-copy">@MartijnPieters, actually, the solution by Dietrich Epp works.</span>
<span class="comment-copy">@MartijnPieters, how would you do it?</span>
<span class="comment-copy">have you tried <code>from six.moves import input; print("*" + input("input: "))</code>? `</span>
<span class="comment-copy">If you are using sys.stdin.readline to avoid the <code>rawinput</code> to <code>input</code> change, put <code>try: input=rawinput\nexcept NameError: pass</code>. at the top of the file.</span>
<span class="comment-copy">I think that that was the <i>point</i>. The OP shows that <code>stdout</code> has been flushed manually first, after which the difference in behaviour is unexpected.</span>
<span class="comment-copy">@MartijnPieters: What would the point be of calling <code>flush()</code> with nothing in the buffer?</span>
<span class="comment-copy">To produce a minimal, verifiable test case that demonstrates the behaviour?</span>
<span class="comment-copy">@MartijnPieters: For what?  For demonstrating that flushing an empty buffer is pointless?</span>
<span class="comment-copy">It is already known that the buffer is empty, because the program is reproduced in its entirety, and the buffer is empty at program startup.</span>
<span class="comment-copy">"Or use <code>sys.stdout.flush()</code> after <code>print()</code> calls"... weren't you <i>complaining</i> about that advice in my answer?</span>
<span class="comment-copy">@DietrichEpp: I am complaining about your <i>diagnosis</i>. I'm saying the flush was put first <b>deliberately</b>. I never said it wouldn't solve the problem. The OP is asking for us to explain <b>why</b> there is a difference between Py 2 and Py 3.</span>
