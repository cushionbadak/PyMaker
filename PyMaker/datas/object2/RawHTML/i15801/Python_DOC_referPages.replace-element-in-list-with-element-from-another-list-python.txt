<div class="post-text" itemprop="text">
<p>I have a list named <code>rule.start.</code> In this list, all elements are equal to an element from another list called <code>com.empty</code>. I want the element from <code>rule.start</code> to be replaced by the element that comes AFTER the same element from <code>com.empty</code>. How would I do this?</p>
<p><code>rule.start</code> looks like this:</p>
<p><code>['F', 'L', 'G', 'L', 'F', 'R', 'F', 'R', 'F', 'L', 'G', 'L', 'F', 'L', 'F', 'L', 'G', 'L', 'F', 'L',........]</code></p>
<p><code>com.empty</code> looks like this:</p>
<p><code>['F', ['fd'], 'G', ['fd'], 'L', ['lt', '60'], 'R', ['rt', '60']]</code></p>
<p>I have tried this:</p>
<pre><code>wut = 0    
for elem in rule.start:
    v = 1
    for mel in com.empty[::2]:
        if elem == mel:
            rule.start[wut] = com.empty[v]
            print elem
            print mel
            wut +=1
            v += 2
</code></pre>
<p>But it just replaces all element of rule.start with <code>['fd']</code></p>
<p>In the end, I want to evaluate all elements as commands, that looks like this: <code>fd(var, scale)</code></p>
<p>and this: <code>rt(var, 60)   # 60 is from the list.</code></p>
</div>
<div class="post-text" itemprop="text">
<p>First, this would be much easier to write, and a lot more efficient, if you had a dictionary, mapping keys to values, instead of a list of alternating keys and values. You can do that as a one-liner:</p>
<pre><code>mapping = dict(zip(com.empty[::2], com.empty[1::2]))
</code></pre>
<p>But if you don't understand how that works, you can do this, which you should be able to understand (based on your code).</p>
<pre><code>mapping = {}
key = None
for mel in com.empty:
    if key is None:
        key = mel
    else:
        mapping[key] = mel
        key = None
</code></pre>
<p>Or, even better, if possible, change your code to build a dict instead of a list of alternating values in the first place.</p>
<hr/>
<p>Now, once you have this, your loop becomes dead simple, and very hard to get wrong:</p>
<pre><code>for wut, elem in enumerate(rule.start):
    rule.start[wut] = mapping.get(elem, elem)
</code></pre>
<p>I'm using <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> so you don't have to keep track of <code>wut</code> manually, and I'm using the <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow"><code>dict.get</code></a> method instead of looping over all the keys and values, which is the tricky part that you got lost in.</p>
<p>Or, even more simply:</p>
<pre><code>rule.start = [mapping.get(elem, elem) for elem in rule.start]
</code></pre>
<hr/>
<p>But, if you want to know what's wrong with your attempt:</p>
<p>You start off <code>v = 1</code>. For each <code>mel</code>, you increment <code>v</code> by 2 <code>if elem == mel</code>. Otherwise, it stays at 1. So, the first time <code>elem == mel</code>, you're going to have <code>v = 1</code>, so you're going to assign <code>com.empty[1]</code> to <code>rule.start[wut]</code>. If you move the <code>v + 2</code> outside the loop, that will fix this problem.</p>
<p>You also have a similar problem with <code>wut += 1</code> being in the wrong place. It should be updated for every <code>elem</code>; instead, it's updated for every <code>elem</code> and <code>mel</code> that match, which could be 0 times or (theoretically) 3 times.</p>
<p>Getting this stuff right is a big source of errors, which is exactly why <code>enumerate</code> exists.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would be tempted to start by rewriting com.empty as a dict, which is what you really want here. </p>
<pre><code>c2 = {key:val for (key, val) in zip (com.empty[0::2], com.empty[1::2])}
</code></pre>
<p>Then it's pretty easy:</p>
<pre><code>rule.start.new = [c2[key] for key in rule.start]
</code></pre>
<p>of course, this fails if you have a key in rule.start which is not in com.empty - I'll let you dot the i's and cross the t's to make it safe for your use</p>
</div>
<span class="comment-copy">What about using a dict <code>{'F': ['fd'], 'G': ['fd'], 'L': ['lt', '60'], 'R': ['rt', '60']}</code> ?</span>
<span class="comment-copy">Aha, thank you. I already made a dictionary, but couldn't make it work either. I see what you mean about the values now, I'll read up on enumerate, never heard of it.</span>
