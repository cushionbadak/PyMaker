<div class="post-text" itemprop="text">
<p>I have been trying to understand better the decorators and closures.</p>
<p>I am trying to decorate the function to achieve: </p>
<ul>
<li>remembering previously passed values, </li>
<li>counting how many times the function was called.</li>
</ul>
<p>I want to make it using two separate decorators - for science :)</p>
<p>So I managed to create this <strong>working</strong> code (I used some snippet for the counting - I admit)</p>
<pre><code>class countcalls(object):
    "Decorator that keeps track of the number of times a function is called."

    __instances = {}

    def __init__(self, f):
        self.__f = f
        self.__numcalls = 0
        countcalls.__instances[f] = self

    def __call__(self, *args, **kwargs):
        self.__numcalls += 1
        return self.__f(*args, **kwargs)

    def count(self):
        "Return the number of times the function f was called."
        return countcalls.__instances[self.__f].__numcalls

    @staticmethod
    def counts():
        "Return a dict of {function: # of calls} for all registered functions."
        return dict([(f.__name__, countcalls.__instances[f].__numcalls) for f in countcalls.__instances])

def wrapper(x):
    past=[]
    @countcalls
    def inner(y):
        print x 
        print inner.count()
        past.append(y)
        print past

    return inner

def main():
    foo = wrapper("some constant")

    foo(5)
    foo("something")


if __name__ == '__main__':
    main()
</code></pre>
<p>output:</p>
<pre><code>some constant
1
[5]
some constant
2
[5, 'something']  
</code></pre>
<p>Now I want to change the memoize function to a neat pythonic decorator. Here is what I came out with so far:</p>
<pre><code>class countcalls(object):
    "Decorator that keeps track of the number of times a function is called."

    __instances = {}

    def __init__(self, f):
        self.__f = f
        self.__numcalls = 0
        countcalls.__instances[f] = self

    def __call__(self, *args, **kwargs):
        self.__numcalls += 1
        return self.__f(*args, **kwargs)

    def count(self):
        "Return the number of times the function f was called."
        return countcalls.__instances[self.__f].__numcalls

    @staticmethod
    def counts():
        "Return a dict of {function: # of calls} for all registered functions."
        return dict([(f.__name__, countcalls.__instances[f].__numcalls) for f in countcalls.__instances])


class memoize(object):
    past=[]

    def __init__(self, f):
        past = []
        self.__f = f

    def __call__(self, *args, **kwargs):
        self.past.append(*args)

        return self.__f(*args, **kwargs)

    def showPast(self):
        print self.past


@memoize
@countcalls
def dosth(url):
    print dosth._memoize__f.count()  ## &lt;-- this is so UGLY
    dosth.showPast()

def main():
    dosth("one")
    dosth("two")

if __name__ == '__main__':
    main()
</code></pre>
<p>And here is the output:</p>
<pre><code>1
['one']
2
['one', 'two']
</code></pre>
<p>How to get rid of the "ugly" line ( <code>print dosth._memoize__f.count()</code> ) ? In other words - how can I directly call the methods of the stacked decorators? (without adding a method to the decorators to call the methods of other decorators - that is not my point)</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll still have to unwrap the decorators if you want to access specific decorator results, but the 'default' attribute for this is <code>__wrapped__</code>. The Python 3 version of the <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow"><code>@functools.wraps()</code> decorator</a> sets this attribute for you (via the <a href="https://docs.python.org/3/library/functools.html#functools.update_wrapper" rel="nofollow"><code>functools.update_wrapper()</code> utility function</a>, starting with Python 3.4), but you can do the same manually in your own decorators:</p>
<pre><code>class memoize(object):
    past=[]

    def __init__(self, f):
        past = []
        self.__wrapped__ = self.__f = f
</code></pre>
<p>Now you can access the wrapped callable with:</p>
<pre><code>dosth.__wrapper__.count()
</code></pre>
<p>wich is the <em>standard</em> Pythonic way of unwrapping decorators.</p>
</div>
<span class="comment-copy">Why are you accessing the decorators from within the function <i>at all</i>?</span>
<span class="comment-copy">i figured in this case its a good way to count how many times the function was called and modify the behavior of the function depending on it it doesnt matter anyway - if i want to access the count property outside of the function - i still need to use  dosth._memoize__f.count()</span>
<span class="comment-copy">Not if you put the counter <i>outside</i> the memoizer.</span>
