<div class="post-text" itemprop="text">
<p>I'm getting a strange error in my Django testing code.</p>
<p>Full code:</p>
<pre><code>from .models                    import MIN_BIRTH_YEAR
from .models                    import UserProfile
from django.contrib.auth.models import User
from django.test                import TestCase
import factory

TEST_USERS = []
TEST_PASSWORD = 'password123abc'

class UserProfileFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = UserProfile
    birth_year = factory.Sequence(lambda n: n + MIN_BIRTH_YEAR - 1)

class UserFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = User
    profile = factory.RelatedFactory(UserProfileFactory, 'user')

    username = factory.Sequence(lambda n: 'test_username{}'.format(n))
    first_name = factory.Sequence(lambda n: 'test_first_name{}'.format(n))
    last_name = factory.Sequence(lambda n: 'test_last_name{}'.format(n))
    email = factory.Sequence(lambda n: 'test_email{}@example.com'.format(n))
    password = factory.PostGenerationMethodCall('set_password', TEST_PASSWORD)

def create_insert_test_users():
    for i in range(5):
        TEST_USERS.append(UserFactory.create())

def _test_one_logged_in_user(test_instance, test_user_index):
    """
    In addition to public information, private content for a single
    logged-in user should be somewhere on the page.
    """
    test_instance.client.logout()

    test_user = TEST_USERS[test_user_index]

    print('Attempting to login:')
    profile = test_user.profile
    print('test_user.id=' + str(test_user.id))
    print('   username=' + test_user.username + ', password=' + TEST_PASSWORD)
    print('   first_name=' + test_user.first_name + ', last_name=' + test_user.last_name)
    print('   email=' + test_user.email)
    print('   profile=' + str(profile))
    print('      profile.birth_year=' + str(profile.birth_year))
</code></pre>
<p>Continued. This is the login line I'm talking about. This <code>_test_one_logged_in_user</code> function is called by the second to last line (<code>_test_one_logged_in_user(self, 0)</code>) below:</p>
<pre><code>    did_login_succeed = test_instance.client.login(
        username=test_user.username,
        password=TEST_PASSWORD)
    test_instance.assertTrue(did_login_succeed)

    ##########################################
    # GET PAGE AND TEST ITS CONTENTS HERE...
    ##########################################

class MainPageTestCase(TestCase):
    """Tests for the main page."""
    def setUp(self_ignored):
        """Insert test users."""
        create_insert_test_users()

    def test_true_is_true(self):
        """Public information should be somewhere on the page."""
        self.assertTrue(True)

    def test_logged_in_users(self):
        """
        In addition to public information, private content for logged in
        users should also be somewhere on the page.
        """
        _test_one_logged_in_user(self, 0)
        _test_one_logged_in_user(self, 1)
</code></pre>
<p>This works fine. Everything passes. But change the name of <code>test_true_is_true</code> to <code>test_content_not_logged_in</code></p>
<pre><code>def test_content_not_logged_in(self):
    """Public information should be somewhere on the page."""
    self.assertTrue(True)
</code></pre>
<p>and <code>test_instance.client.login</code> now returns <code>False</code>...which results in the assertion below it</p>
<pre><code>test_instance.assertTrue(did_login_succeed)
</code></pre>
<p>to fail: <code>AssertionError: False is not true</code>. If you comment out the entire function, though, it succeeds (login returns <code>True</code>).</p>
<pre><code># def test_content_not_logged_in(self):
#     """Public information should be somewhere on the page."""
#     self.assertTrue(True)
</code></pre>
<p>If you uncomment it and rename it to any of the following, it works:</p>
<ul>
<li><code>test_xcontent_not_logged_in</code></li>
<li><code>test__content_not_logged_in</code></li>
<li><code>test_not_logged_in</code></li>
</ul>
<p>Any of these, and it fails:</p>
<ul>
<li><code>test_ctrue_is_true</code></li>
<li><code>test_cxontent_not_logged_in</code></li>
<li><code>test_contentnot_logged_in</code></li>
<li><code>test_contennot_logged_in</code></li>
<li><code>test_contenot_logged_in</code></li>
<li><code>test_contnot_logged_in</code></li>
<li><code>test_connot_logged_in</code></li>
<li><code>test_cnot_logged_in</code></li>
<li><code>test_c</code></li>
</ul>
<p>(I've <a href="https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#qscrl=1&amp;q=%22test_c%22+python" rel="nofollow">searched for <code>test_c</code></a> and found <em>something</em> but nothing that indicates anything particularly special.)</p>
<p>This seems to imply that the <code>setUp</code> function runs once for <code>test_content_not_logged_in</code> (the trivial function), and then again for <code>test_logged_in_users</code>. And this running twice is causing problems. So I changed it so the users are only created if the <code>TEST_USER</code> array is empty:</p>
<pre><code>def create_insert_test_users():
    if  len(TEST_USERS) == 0:
        for i in range(5):
            TEST_USERS.append(UserFactory.create())
</code></pre>
<p>But it's still failing, and I can confirm it's failing with the user having an id of 1:</p>
<pre><code>$ python -Wall manage.py test auth_lifecycle.test__view_main2
/home/jeffy/django_files/django_auth_lifecycle_venv/lib/python3.4/site.py:165: DeprecationWarning: 'U' mode is deprecated
  f = open(fullname, "rU")
/home/jeffy/django_files/django_auth_lifecycle_venv/lib/python3.4/imp.py:32: PendingDeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
  PendingDeprecationWarning)
Creating test database for alias 'default'...
.Attempting to login:
test_user.id=1
   username=test_username1, password=password123abc
   first_name=test_first_name1, last_name=test_last_name1
   email=test_email1@example.com
   profile=test_username1
      profile.birth_year=1887
F
======================================================================
FAIL: test_logged_in_users (auth_lifecycle.test__view_main2.MainPageTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/jeffy/django_files/django_auth_lifecycle/auth_lifecycle/test__view_main2.py", line 74, in test_logged_in_users
    _test_one_logged_in_user(self, 0)
  File "/home/jeffy/django_files/django_auth_lifecycle/auth_lifecycle/test__view_main2.py", line 53, in _test_one_logged_in_user
    test_instance.assertTrue(did_login_succeed)
AssertionError: False is not true

----------------------------------------------------------------------
Ran 2 tests in 0.385s

FAILED (failures=1)
Destroying test database for alias 'default'...
</code></pre>
<hr/>
<p>models.py:</p>
<pre><code>"""Defines a single extra user-profile field for the user-authentication
    lifecycle demo project:

    - Birth year, which must be between &lt;link to MIN_BIRTH_YEAR&gt; and
    &lt;link to MAX_BIRTH_YEAR&gt;, inclusive.
"""
from datetime                   import datetime
from django.contrib.auth.models import User
from django.core.exceptions     import ValidationError
from django.db                  import models

OLDEST_EVER_AGE     = 127  #:Equal to `127`
YOUNGEST_ALLOWED_IN_SYSTEM_AGE = 13   #:Equal to `13`
MAX_BIRTH_YEAR      = datetime.now().year - YOUNGEST_ALLOWED_IN_SYSTEM_AGE
"""Most recent allowed birth year for (youngest) users."""
MIN_BIRTH_YEAR      = datetime.now().year - OLDEST_EVER_AGE
"""Most distant allowed birth year for (oldest) users."""

def _validate_birth_year(birth_year_str):
    """Validator for &lt;link to UserProfile.birth_year&gt;, ensuring the
        selected year is between &lt;link to OLDEST_EVER_AGE&gt; and
        &lt;link to MAX_BIRTH_YEAR&gt;, inclusive.
        Raises:
            ValidationError: When the selected year is invalid.

        https://docs.djangoproject.com/en/1.7/ref/validators/

        I am a recovered Hungarian Notation junkie (I come from Java). I
        stopped using it long before I started with Python. In this
        particular function, however, because of the necessary cast, it's
        appropriate.
    """
    birth_year_int = -1
    try:
        birth_year_int = int(str(birth_year_str).strip())
    except TypeError:
        raise ValidationError(u'"{0}" is not an integer'.format(birth_year_str))

    if  not (MIN_BIRTH_YEAR &lt;= birth_year_int &lt;= MAX_BIRTH_YEAR):
        message = (u'{0} is an invalid birth year.'
                   u'Must be between {1} and {2}, inclusive')
        raise ValidationError(message.format(
            birth_year_str, MIN_BIRTH_YEAR, MAX_BIRTH_YEAR))
    #It's all good.

class UserProfile(models.Model):
    """Extra information about a user: Birth year.

        ---NOTES---

        Useful related SQL:
            - `select id from auth_user where username &lt;&gt; 'admin';`
            - `select * from auth_lifecycle_userprofile where user_id=(x,x,...);`
    """
    # This line is required. Links UserProfile to a User model instance.
    user = models.OneToOneField(User, related_name="profile")

    # The additional attributes we wish to include.
    birth_year = models.IntegerField(
        blank=True,
        verbose_name="Year you were born",
        validators=[_validate_birth_year])

    # Override the __str__() method to return out something meaningful
    def __str__(self):
        return self.user.username
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you change the name of the test, you change the order in which the tests run. The test_logged_in_users method runs BEFORE test_true_is_true but runs AFTER test_c_whatever (presumably because it's running them in alpha or some sort of order). This is why you're seeing the weirdness with the name changes.</p>
<p>As you figured out, your setUp method runs for each test case.  When your setUp runs the first time, Users are created and saved to both the DB and TEST_USERS. When your second test runs, your DB is refreshed, and all your users are deleted. The users represented by TEST_USERS (which are still in your list, because your globals persist across test cases) no longer exist in the DB.</p>
<p>You can make your test pass in your original code by resetting TEST_USERS, like this:</p>
<pre><code>def create_insert_test_users():
    # global tells python to use the TEST_USERS above, not create a new one
    global TEST_USERS
    TEST_USERS = []
    # Your code here...
</code></pre>
<p>Now, TEST_USERS represents new, real users that match users in the DB. Generally speaking, though, globals are a bad idea (<a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil">for several reasons</a>, the confusion you're experiencing being among them). Creating them on-the-fly (as you're working toward in your latest update) is a much better solution.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" rel="nofollow">TestCase</a> will recognize all the tests by looking for methods that start with <code>test</code></p>
<p>From documentation:</p>
<blockquote>
<p>The individual tests are defined with methods whose names start
  with the letters test. This naming convention informs the test runner
  about which methods represent tests.</p>
</blockquote>
<p>So when you rename <code>a_trivial_function</code> it changes whether it is considered a test or not.</p>
</div>
<div class="post-text" itemprop="text">
<p>The original code stores <code>TEST_USERS</code> locally, and it seems that statically-held object was causing problems when shared among the tests. I naively thought it was important to store the objects locally, in order to compare the database values against it. That implies I don't trust Django or Factory Boy to correctly insert them into the database, and they can handle that just fine.</p>
<p>Here's the updated code, which only stores the objects in the database. I also moved the contents sub-function containing <code>login</code> directly into the bottom function.</p>
<pre><code>from .models                    import MIN_BIRTH_YEAR
from .models                    import UserProfile
from django.contrib.auth.models import User
from django.test                import TestCase
import factory

TEST_PASSWORD = 'password123abc'
TEST_USER_COUNT = 5

class UserProfileFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = UserProfile
    birth_year = factory.Sequence(lambda n: n + MIN_BIRTH_YEAR - 1)

class UserFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = User
    profile = factory.RelatedFactory(UserProfileFactory, 'user')

    username = factory.Sequence(lambda n: 'test_username{}'.format(n))
    #print('username=' + username)
    first_name = factory.Sequence(lambda n: 'test_first_name{}'.format(n))
    last_name = factory.Sequence(lambda n: 'test_last_name{}'.format(n))
    email = factory.Sequence(lambda n: 'test_email{}@example.com'.format(n))
    password = factory.PostGenerationMethodCall('set_password', TEST_PASSWORD)

class MainPageTestCase(TestCase):
    """Tests for the main page."""
    def setUp(self_ignored):
        """Insert test users."""
        #print('a User.objects.count()=' + str(User.objects.count()))

        #http://factoryboy.readthedocs.org/en/latest/reference.html?highlight=create#factory.create_batch
        UserFactory.create_batch(TEST_USER_COUNT)

        #print('b User.objects.count()=' + str(User.objects.count()))
</code></pre>
<p>Continued:</p>
<pre><code>    def test_ctrue_is_true(self):
        """Public information should be somewhere on the page."""
        self.assertTrue(True)

    def test_some_logged_in_users(self):
        """
        In addition to public information, private content for logged in
        users should also be somewhere on the page.
        """
        for  n in range(2):
            self.client.logout()

            test_user = UserFactory()

            print('Attempting to login:')
            profile = test_user.profile
            print('test_user.id=' + str(test_user.id))
            print('   username=' + test_user.username + ', password=' + TEST_PASSWORD)
            print('   first_name=' + test_user.first_name + ', last_name=' + test_user.last_name)
            print('   email=' + test_user.email)
            print('   profile=' + str(profile))
            print('      profile.birth_year=' + str(profile.birth_year))

            did_login_succeed = self.client.login(
                username=test_user.username,
                password=TEST_PASSWORD)
            self.assertTrue(did_login_succeed)

            ##########################################
            # GET PAGE AND TEST ITS CONTENTS HERE...
            ##########################################
</code></pre>
</div>
<span class="comment-copy">Oops. Of course. I'm updating the question. The problem is still happening with <code>test...</code>. Thanks.</span>
