<div class="post-text" itemprop="text">
<p>The problem lies somewhere in how I'm parsing and or reassembling urls.  I'm losing the <code>?id=1</code> and <code>getting ?d=1</code>.</p>
<p>What I am trying to do is have the ability to manipulate and query parameter and reassemble it before sending back out modified. Meaning the dictionaries would be modified than using <code>urlencode(modified_dict)</code> I would reassemble url + query.</p>
<p>Can someone give me a pointer on what I'm doing wrong here. </p>
<pre><code>from urlparse import parse_qs, urlparse , urlsplit
from urllib import urlencode
import os
import sys
import mechanize
from collections import OrderedDict
import urllib2
scrape_post_urls = []
get_inj_tests = []

#check multiple values to  strip out duplicate and useless checks
def parse_url(url):
    parsed = urlparse(url,allow_fragments=False)

    if parsed.query:


        if url not in get_inj_tests:
           get_inj_tests.append(url)
           #print url
           '''get_inj_tests.append(url)
           print url
           #print 'scheme  :', parsed.scheme
           #print 'netloc  :', parsed.netloc
           print 'path    :', parsed.path
           print 'params  :', parsed.params
           print 'query   :', parsed.query
           print 'fragment:', parsed.fragment
           #print 'hostname:', parsed.hostname, '(netloc in lower case)'
           #print 'port    :', parsed.port
           '''
else:
    if url not in scrape_post_urls:
       scrape_post_urls.append(url)
       #print url




def main():
    unparsed_urls = open('in.txt','r')
    for urls in unparsed_urls:
        try:
           parse_url(urls)
        except:
            pass

    print(len(scrape_post_urls))
    print(len(get_inj_tests))
    clean_list = list(OrderedDict.fromkeys(get_inj_tests))
    reaasembled_url = ""
    #print clean_list
    for query_test in clean_list:
        url_object = urlparse(query_test,allow_fragments=False)
        #parse query paramaters
        url = query_test.split("?")[1]
        dicty = {x[0] : x[1] for x in [x.split("=") for x in url[1:].split("&amp;") ]}
        query_pairs = [(k,v) for k,vlist in dicty.iteritems() for v in vlist]
        reaasembled_url = "http://" + str(url_object.netloc) + str(url_object.path) +  '?'
        reaasembled_query = urlencode(query_pairs)
        full_url = reaasembled_url + reaasembled_query
        print dicty




main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Can someone give me a pointer on what I'm doing wrong here.</p>
</blockquote>
<p>Well quite simply you're not using the existing tools:</p>
<p>1/ to parse a query string, <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.parse_qsl" rel="nofollow noreferrer">use <code>urllib.parse.parse_qsl()</code></a>. </p>
<p>2/ to reassemble the querystring, <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlencode" rel="nofollow noreferrer">use <code>urllib.parse.urlencode()</code></a>. </p>
<p>And forget about dicts, querystrings can have multiple values for the same key, ie <code>?foo=1&amp;foo=2</code> is perfectly valid.</p>
</div>
<div class="post-text" itemprop="text">
<p>first of all, your variable <code>url</code> is a bad name for the params variable and this could create confusion.</p>
<pre><code>&gt;&gt;&gt; url = "https://url.domian.com?id=22&amp;param1=1&amp;param2=2".split("?")[1]
'id=22&amp;param1=1&amp;param2=2'

&gt;&gt;&gt; "https://url.domian.com?id=22&amp;param1=1&amp;param2=2".split("?")[1].split("&amp;")
['id=22', 'param1=1', 'param2=2']
</code></pre>
<p>The error is in the <code>url[1:].split("&amp;")</code></p>
<p><strong>Solution:</strong></p>
<pre><code>&gt;&gt;&gt; dicty = {x[0] : x[1] for x in [x.split("=") for x in url.split("&amp;") ]}
{'id': '22', 'param1': '1', 'param2': '2'}
</code></pre>
</div>
<span class="comment-copy">can you share your input, output and expected output</span>
<span class="comment-copy">Yes, but even so they would all still be broken up and than modified. Than reassembled with injection parameters Ill display updated version when I'm done, could You explain what You meant further?</span>
<span class="comment-copy">Typical SquaredWheel solution - Python has all you need to properly parse querystrings in it's stdlib, and dicts are the wrong tool here since a querystring can have multiple occurrences of the same key (with different values).</span>
<span class="comment-copy">Thank you, the point on avoiding a parsing library like parse_qs is to learn the inner workings etc.I gave up on parse_qs last night let me try this answer see where I get.  I'll also make sure to avoid confusing var names.</span>
<span class="comment-copy">{'id': '1\n'} {'id': '1\n'} {'id': '1'}  Thanks bro!</span>
<span class="comment-copy">Also note when I use the query_pairs over dicty on urlencode it doubles the params as its a list and I think urlencode expects a dict. So I passed dicty, perfect now I just need to strip the trailing %0A</span>
<span class="comment-copy">All set guys, I was able to do what I wanted and manipulate it This can be closed.</span>
