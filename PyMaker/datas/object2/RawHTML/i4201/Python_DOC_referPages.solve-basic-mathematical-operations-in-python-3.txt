<div class="post-text" itemprop="text">
<p>I'm trying to develop a simple python method that will allow me to compute basic mathematical operations. The point here is that I can't use eval(), exec() or any other functions that evaluate python statemets, so I have to do it manually. Up to now, I've came across with this piece of code:</p>
<pre><code>solutionlist = list(basicoperationslist)
for i in range(0, len(solutionlist)):
    if '+' in solutionlist[i]:
        y = solutionlist[i].split('+')
        solutionlist[i] = str(int(y[0]) + int(y[1]))
    elif '*' in solutionlist[i]:
        y = solutionlist[i].split('*')
        solutionlist[i] = str(int(y[0]) * int(y[1]))
    elif '/' in solutionlist[i]:
        y = solutionlist[i].split('/')
        solutionlist[i] = str(int(y[0]) // int(y[1]))
    elif '-' in solutionlist[i]:
        y = solutionlist[i].split('-')
        solutionlist[i] = str(int(y[0]) - int(y[1]))
print("The solutions are: " + ', '.join(solutionlist))
</code></pre>
<p>So we have two lists of Strings, the basicoperationlist has operations of the following format: 2940-81, 101-16, 46/3, 10*9, 145/24, -34-40.
They will always have two numbers, and one operand in the middle. The problem with my solution is that when I have an operation like the last one, the .split() method splits my list into an empty list and a list with the complete operation. In summary, this solution does not work well when we mix negative numbers an the minus operation. I don't know if it fails in any other case because I've only managed to notice the error I previously described. 
The idea is that at the end of the method, I have the solutionlist as a list of Strings that are going to be the ordered answers to the basic mathematical operations.
This is the error that prompts out whenever my code encounters an operation like the last one: <strong>ValueError: invalid literal for int() with base 10: ''</strong></p>
<p>The basicoperationslist is defined here:</p>
<pre><code>basicoperationslist = re.findall('[-]*\d+[+/*-]+\d+', step2processedoperation)
</code></pre>
<p>As you see, I use a regex to extract the basicoperations from a larger operation. The step2processedoperation is an String that a server sends to my machine. But as example it may contain:</p>
<pre><code>((87/(64*(98-94)))+((3-(97-27))-(89/69)))
</code></pre>
<p>It contains complete and balanced mathematical operations.</p>
<p>Maybe someone could help me to solve this problem or maybe I should change this method completely. </p>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd ditch the whole splitting approach as it is way too complex and may fail in certain cases as you noticed. </p>
<p>Instead I'd use a regex and the <code>operator</code> module to simplify things.</p>
<pre><code>import re
import operator

operators = {'+': operator.add,
             '-': operator.sub,
             '*': operator.mul,
             '/': operator.truediv}

regex = re.compile(r'(-?\d+)'       # 1 or more digits with an optional leading '-'
                   r'(\+|-|\*|/)'   # one of +, - , *, / 
                   r'(\d+)',        # 1 or more digits
                   re.VERBOSE)

exprssions = ['2940-81', '101-16', '46/3', '10*9', '145/24', '-34-40']

for expr in exprssions:
    a, op,  b = regex.search(expr).groups()
    print(operators[op](int(a), int(b)))

# 2859
# 85
# 15.333333333333334
#  90
# 6.041666666666667
# -74
</code></pre>
<p>This approach is easier to adapt to new cases (new operators for example)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily use <code>operator</code> and a <code>dict</code> to store the operations instead of a long list of <code>if-else</code> </p>
<p>This solution can also calculate more complicated expressions through recursion.</p>
<h1>Define the operations and their order</h1>
<pre><code>from operator import add, sub, mul, floordiv, truediv
from functools import reduce

OPERATIONS = {
    '+': add,
    '-': sub,
    '*': mul,
    '/': floordiv, # or '/': truediv,
    '//': floordiv,
}
OPERATION_ORDER = (('+', '-'), ('//', '/', '*'))
</code></pre>
<h1>The simple case of a single number</h1>
<pre><code>def calculate(expression):
    # expression = expression.strip()
    try:
        return int(expression)
    except ValueError:
        pass
</code></pre>
<h1>The calculation</h1>
<pre><code>    for operations in OPERATION_ORDER:
        for operation in operations:
            if operation not in expression:
                continue
            parts = expression.split(operation)

            parts = map(calculate, parts) # recursion
            value = reduce(OPERATIONS[operation], parts)
#             print(expression, value)
            return value
</code></pre>
<h1>Negative first number</h1>
<p>before the calculation:</p>
<pre><code>negative = False
if expression[0] == '-':
    negative = True
    expression = expression[1:]
</code></pre>
<p>in the calculation, after the splitting of the string:</p>
<pre><code>        if negative:
            parts[0] = '-' + parts[0]
</code></pre>
<p>So in total this becomes:</p>
<pre><code>def calculate(expression):
    try:
        return int(expression)
    except ValueError:
        pass

    negative = False
    if expression[0] == '-':
        negative = True
        expression = expression[1:]

    for operations in OPERATION_ORDER:
        for operation in operations:
            if operation not in expression:
                continue
            parts = expression.split(operation)
            if negative:
                parts[0] = '-' + parts[0]

            parts = map(calculate, parts) # recursion
            return reduce(OPERATIONS[operation], parts)
</code></pre>
<h1>Parentheses</h1>
<p>Checking whether there are parentheses can be done easily with <code>re</code>. First we need to make sure it doesn't recognise the 'simple' parenthised intermediary results (like <code>(-1)</code>)</p>
<pre><code>PATTERN_PAREN_SIMPLE= re.compile('\((-?\d+)\)')
PAREN_OPEN = '|'
PAREN_CLOSE = '#'
def _encode(expression):
    return PATTERN_PAREN_SIMPLE.sub(rf'{PAREN_OPEN}\1{PAREN_CLOSE}', expression)

def _decode(expression):
    return expression.replace(PAREN_OPEN, '(').replace(PAREN_CLOSE, ')')

def contains_parens(expression):
    return '(' in _encode(expression)
</code></pre>
<p>Then to calculate the leftmost outermost parentheses, you can use this function</p>
<pre><code>def _extract_parens(expression, func=calculate):
#     print('paren: ', expression)
    expression = _encode(expression)
    begin, expression = expression.split('(', 1)
    characters = iter(expression)

    middle = _search_closing_paren(characters)

    middle = _decode(''.join(middle))
    middle = func(middle)

    end = ''.join(characters)
    result = f'{begin}({middle}){end}' if( begin or end) else str(middle)
    return _decode(result)


def _search_closing_paren(characters, close_char=')', open_char='('):
    count = 1
    for char in characters:
        if char == open_char:
            count += 1
        if char == close_char:
            count -= 1
        if not count:
            return
        else:
            yield char
</code></pre>
<p>The reason for the <code>()</code> around <code>calculate(middle)</code> is because an intermediate result can be negative, and this might pose problems later on if the parentheses are left out here.</p>
<p>The beginning of the algorithm then changes to:</p>
<pre><code>def calculate(expression):
    expression = expression.replace(' ', '')
    while contains_parens(expression):
        expression = _extract_parens(expression)
    if PATTERN_PAREN_SIMPLE.fullmatch(expression):
        expression = expression[1:-1]
    try:
        return int(expression)
    except ValueError:
        pass
</code></pre>
<p>Since intermediary results can be negative, we need regular expressions to split on the <code>-</code> to prevent <code>5 * (-1)</code> from being split on the <code>-</code></p>
<p>So I reordered the possible operations like this:</p>
<pre><code>OPERATIONS = (
    (re.compile('\+'), add),
    (re.compile('(?&lt;=[\d\)])-'), sub), # not match the - in `(-1)`
    (re.compile('\*'), mul),
    (re.compile('//'), floordiv),
    (re.compile('/'), floordiv), # or '/': truediv,
)
</code></pre>
<p>The pattern for the <code>-</code> only matches if it is preceded by a <code>)</code> or a digit. This way we can drop the <code>negative</code> flag and handling</p>
<p>The rest of the algorithms changes then to:</p>
<pre><code>    operation, parts = split_expression(expression)
    parts = map(calculate, parts) # recursion
    return reduce(operation, parts)

def split_expression(expression):
    for pattern, operation in OPERATIONS:
        parts = pattern.split(expression)
        if len(parts) &gt; 1:
            return operation, parts
</code></pre>
<h1>complete algorithm</h1>
<p>The complete code can be found <a href="https://gist.github.com/vadella/b20dcd82c1bf175da9e6420366e82d52" rel="nofollow noreferrer">here</a></p>
<h1>testing:</h1>
<pre><code>def test_expression(expression):
    return calculate(expression) == eval(expression.replace('/','//'))  # the replace to get floor division

def test_calculate():
    assert test_expression('1')
    assert test_expression(' 1 ')
    assert test_expression('(1)')
    assert test_expression('(-1)')
    assert test_expression('(-1) - (-1)')
    assert test_expression('((-1) - (-1))')
    assert test_expression('4 * 3 - 4 * 4')
    assert test_expression('4 * 3 - 4 / 4')
    assert test_expression('((87/(64*(98-94)))+((3-(97-27))-(89/69)))')

test_calculate()
</code></pre>
<h1>power:</h1>
<p>Adding power becomes as simple as adding </p>
<pre><code>(re.compile('\*\*'), pow),
(re.compile('\^'), pow),
</code></pre>
<p>to <code>OPERATIONS</code></p>
<pre><code>calculate('2 + 4 * 10^5')
</code></pre>
<blockquote>
<pre><code>400002
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Welcome to StackOverflow! Your code snippet is not complete since you do not define <code>basicoperationslist</code>. Please show a complete, self-contained snippet that shows your error as well as the traceback of the error for that snippet. Please read and follow <a href="http://stackoverflow.com/help/mcve">How to create a Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">Your solution is pretty simple, if you are sure that you will have 2 operands, then after the split check if you got 3 values in the list. If there are three then one of them is a negative no.</span>
<span class="comment-copy">also how are you dealing with -34-(-10)</span>
<span class="comment-copy">That error you mention also says on which line it occurs.</span>
<span class="comment-copy">Have a look at: <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str.split</a>, you can specify the add number of splits you wan to</span>
<span class="comment-copy">Your solution is very interesting. I did not manage to came up with this approach. The problem here is that I need to do int operations. And the division is not '/', it's the '//' python operator (entire division)</span>
<span class="comment-copy">@enon97 I'm not sure what you mean. If you want to use "integer division" you can use <code>operator.floordiv</code> instead of <code>operator.truediv</code> that  I used in the <code>operators</code> dictionary.</span>
<span class="comment-copy">Yes, you are right, I've just search for it :operator.floordiv(a, b)¶ operator.__floordiv__(a, b) Return a // b.</span>
<span class="comment-copy">By the way, does this works if we have for example 34--10?</span>
<span class="comment-copy">@enon97 not as it is, but it can be fixed by a very simple change to the regex (the second <code>(\d+)</code> should be changed to <code>(-?\d+)</code>).</span>
<span class="comment-copy">Thank you so much for your idea. But I think that this is a too much complex solution for my needs. If I want to solve an operation recursively, it would be one like this: ((87/(64*(98-94)))+((3-(97-27))-(89/69)))</span>
