<div class="post-text" itemprop="text">
<p>Is there a way to duplicate the unicode category matching capability of <code>regex</code> using just <code>re</code>?  I have an <code>re</code> match string which identifies words (<code>r'\b[^\W\d_]+\b'</code>) which I would like to amend so that punctuation which is attached to the word (i.e. has no non-punctuation characters intervening between the word and the character) is included in the match.  Using <code>regex</code> I would do <code>r'\b[^\W\d_]+\b\p{P}*'</code> but I cannot be sure that <code>regex</code> will be installed on all the systems to which the final script will be deployed and thus would like to rework the match condition to be entirely <code>re</code> compatible.  Is that possible, and if so how would I do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>To replicate the <code>\p{P}</code> functionality, you'd have to manually build the set, using the <a href="https://docs.python.org/3/library/unicodedata.html" rel="nofollow noreferrer"><code>unicodedata</code> module</a>; you still need to manually filter all codepoints:</p>
<pre><code>import re
import sys
from unicodedata import category

p_class = re.escape(''.join([
    c for c in map(chr, range(sys.maxunicode))
    if category(c)[0] == 'P']))

pattern = re.compile(rf'\b[^\W\d_]+\b[{p_class}]*')
</code></pre>
<p>Personally, I'd just install <code>regex</code> at this point, and not try to manually build huge character sets.</p>
<p>You may want to do some statistical analysis on what kinds of characters you actually <em>need</em> to match, rather than <em>all punctuation</em>, to narrow down that set, or express it in terms of 'not a word character or whitespace', with <code>[^\w\s]*</code>, which is broader but faster to match.</p>
</div>
<span class="comment-copy">In my testing there is a clear performance hit here (the above code takes about 6 times longer to run than the equivalent using <code>regex</code>) but we're still talking about less than half-a-second (~0.3 vs. ~0.05).  I'll check with my colleagues, but I think that might be an acceptable hit.</span>
<span class="comment-copy">After consultation, we've decided that our use case is such that rebuilding the <code>\p{P}</code> class is overkill and that we're better off approximating it (something more akin to the now deleted other answer) in a way that does not incur the performance hit associated with this answer.  It's a trade-off decision, though, so I'm not sure if I should mark this as the accepted answer or not.  This answer solved my problem as stated, but it was the other (now deleted) answer which actually turned out to be the most helpful for the project.</span>
<span class="comment-copy">Sure, that's fine; I tried to answer the question you asked, 'how do I match what the <code>\p{P}</code> syntax matches, with <code>re</code>', Wiktor tried to address the problem they assumed you were trying to solve with your question. It's tricky to know what to include in a question sometimes, for it to be complete enough for answerers to give you the best information you actually need (which is not always what you perhaps thought you needed).</span>
