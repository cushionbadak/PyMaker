<div class="post-text" itemprop="text">
<p>Mark Lutz in his book "Learning Python" gives an example:</p>
<pre><code>&gt;&gt;&gt; [(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2==1]
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
&gt;&gt;&gt;
</code></pre>
<p>a bit later he remarks that 'a map and filter equivalent' of this is possible though complex and nested.</p>
<p>The closest one I ended up with is the following:</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x:list(map(lambda y:(y,x),filter(lambda x:x%2==0,range(5)))), filter(lambda x:x%2==1,range(5))))
[[(0, 1), (2, 1), (4, 1)], [(0, 3), (2, 3), (4, 3)]]
&gt;&gt;&gt; 
</code></pre>
<p>The order of tuples is different and nested list had to be introduced. I'm curious what would be the equivalent.</p>
</div>
<div class="post-text" itemprop="text">
<p>One important point that you have to notice is that your nested list comprehension is of O(n<sup>2</sup>) order. Meaning that it's looping over a product of two ranges. If you want to use <code>map</code> and <code>filter</code> you have to create all the combinations. You can do that after or before filtering but what ever you do you can't have all those combinations with those two functions, unless you change the ranges and/or modify something else.</p>
<p>One completely functional approach is to use <code>itertools.product()</code> and <code>filter</code> as following:</p>
<pre><code>In [16]: from itertools import product

In [17]: list(filter(lambda x: x[0]%2==0 and x[1]%2==1, product(range(5), range(5))))
Out[17]: [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
</code></pre>
<p>Also note that using a nested list comprehension with two iterations is basically more readable than multiple <code>map</code>/<code>filter</code> functions. And regarding the performance using built-in funcitons is faster than list comprehension when your function are merely built-in so that you can assure all of them are performing at C level. When you break teh chain with something like a <code>lambda</code> function which is Python/higher lever operation your code won't be faster than a list comprehension.</p>
</div>
<div class="post-text" itemprop="text">
<p>A note to append to <a href="https://stackoverflow.com/a/50074832/9209546">@Kasramvd's explanation</a>.</p>
<p><strong>Readability is important in Python</strong>. It's one of the features of the language. Many will consider the list comprehension the <em>only</em> readable way.</p>
<p>Sometimes, however, especially when you are working with multiple iterations of conditions, it is clearer to separate your <em>criteria</em> from <em>logic</em>. In this case, using the functional method may be preferable.</p>
<pre><code>from itertools import product

def even_and_odd(vals):
    return (vals[0] % 2 == 0) and (vals[1] %2 == 1)

n = range(5)

res = list(filter(even_and_odd, product(n, n)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the only confusing part in the expression <code>[(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]</code> is that there an implicit <code>flatten</code> operation is hidden.</p>
<p>Let's consider the simplified version of the expression first:</p>
<pre><code>def even(x):
    return x % 2 == 0

def odd(x):
    return not even(x)

c = map(lambda x: map(lambda y: [x, y], 
                      filter(odd, range(5))), 
        filter(even, range(5)))

print(c)
# i.e. for each even X we have a list of odd Ys:
# [
#   [[0, 1], [0, 3]],
#   [[2, 1], [2, 3]],
#   [[4, 1], [4, 3]]
# ]
</code></pre>
<p>However, we need pretty the same but flattened list <code>[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]</code>. </p>
<p>From the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">official python docs</a> we can grab the example of <code>flatten</code> function:</p>
<pre><code>from itertools import chain
flattened = list(chain.from_iterable(c))  # we need list() here to unroll an iterator
print(flattened)
</code></pre>
<p>Which is basically an equivalent for the following list comprehension expression:</p>
<pre><code>flattened = [x for sublist in c for x in sublist]
print(flattened)

# ... which is basically an equivalent to:
# result = []
# for sublist in c:
#   for x in sublist:
#     result.append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Range support <code>step</code> argument, so I come up with this solution using itertools.chain.from_iterable to flatten inner list:</p>
<pre><code>from itertools import chain
list(chain.from_iterable(
    map(
        lambda x:           
            list(map(lambda y: (x, y), range(1, 5, 2))),
        range(0, 5, 2)
        )
))    
</code></pre>
<p>Output:    </p>
<pre><code>Out[415]: [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
</code></pre>
</div>
<span class="comment-copy">Depends on your definition of "equivalent". Does <code>list(filter(lambda i:i[0]%2==0 and i[1]%2==1, map(lambda x:(x//5, x%5), range(25))))</code> count?</span>
<span class="comment-copy">I understand 'equivalent' as identical input and output. Input is the two identical ranges [0,1,2,3,4]</span>
<span class="comment-copy">`from_iterable' is good to remember</span>
