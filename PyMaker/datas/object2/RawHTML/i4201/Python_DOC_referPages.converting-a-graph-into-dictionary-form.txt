<div class="post-text" itemprop="text">
<p>I am currently writing a program to model Dijkstra's algorithm, however I am having some trouble the graph in its current form below:</p>
<pre><code>G = [['a', 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h', 'i', 'j'],
     [({'a', 'b'}, 4), ({'a', 'c'}, 6), ({'a', 'd'}, 8), ({'b', 'e'}, 1) ,
      ({'b', 'f'}, 9), ({'c', 'f'}, 2), ({'d', 'g'}, 7), ({'d', 'h'}, 1) ,
      ({'e', 'i'}, 2), ({'e', 'j'}, 7), ({'g', 'h'}, 2), ({'i', 'j'}, 4)]]
</code></pre>
<p>I want to get the graph in the form such as the one below</p>
<pre><code>{ 'a': {'b': 4, 'c': 6, 'd': 8},
    'b': {'a': 4, 'e': 1, 'f': 9}, etc
</code></pre>
<p>Would this be possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><strong><code>collections.defaultdict</code></strong></a> for this.</p>
<p><strong>Code:</strong></p>
<pre><code>from collections import defaultdict

G = [['a', 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h', 'i', 'j'],
     [({'a', 'b'}, 4), ({'a', 'c'}, 6), ({'a', 'd'}, 8), ({'b', 'e'}, 1) ,
      ({'b', 'f'}, 9), ({'c', 'f'}, 2), ({'d', 'g'}, 7), ({'d', 'h'}, 1) ,
      ({'e', 'i'}, 2), ({'e', 'j'}, 7), ({'g', 'h'}, 2), ({'i', 'j'}, 4)]]

result = defaultdict(dict)
for edge in G[1]:
    v1, v2 = edge[0]
    result[v1][v2] = edge[1]
    result[v2][v1] = edge[1]

print(result)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>defaultdict(&lt;class 'dict'&gt;,
            {'a': {'b': 4, 'c': 6, 'd': 8},
             'b': {'a': 4, 'e': 1, 'f': 9},
             'c': {'a': 6, 'f': 2},
             'd': {'a': 8, 'g': 7, 'h': 1},
             'e': {'b': 1, 'i': 2, 'j': 7},
             'f': {'b': 9, 'c': 2},
             'g': {'d': 7, 'h': 2},
             'h': {'d': 1, 'g': 2},
             'i': {'e': 2, 'j': 4},
             'j': {'e': 7, 'i': 4}})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a compact way using list comprehension:</p>
<pre><code>d = {k: dict((list(v[0] ^ {k})[0], v[1]) for v in G[1] if k in v[0]) for k in G[0]}
print(d)
#{'a': {'b': 4, 'c': 6, 'd': 8},
# 'b': {'a': 4, 'e': 1, 'f': 9},
# 'c': {'a': 6, 'f': 2},
# 'd': {'a': 8, 'g': 7, 'h': 1},
# 'e': {'b': 1, 'i': 2, 'j': 7},
# 'f': {'b': 9, 'c': 2},
# 'g': {'d': 7, 'h': 2},
# 'h': {'d': 1, 'g': 2},
# 'i': {'e': 2, 'j': 4},
# 'j': {'e': 7, 'i': 4}}
</code></pre>
<p>Breaking this down:</p>
<ul>
<li><code>{k: ... for k in G[0]}</code> is iterating over the first element of <code>G</code> to get the keys of the output dictionary.</li>
<li><code>{k: (... for v in G[1] if k in v[0]) ... }</code> is a generator expression over the second element in <code>G</code>, which will yield a value if the key <code>k</code> is contained in the set.</li>
<li><code>v[0] ^ {k}</code> is the symmetric difference of the set with the key- this removes the key from the set.</li>
<li><code>list(v[0] ^ {k})[0]</code> converts the set to a list and gets the first element. This assumes there will always be only 2 elements in the set, one of which is the key.</li>
<li><code>(list(v[0] ^ {k})[0], v[1])</code> makes a tuple where the second value is the number.</li>
<li><code>dict([(list(v[0] ^ {k})[0], v[1]) ...</code> calls the dict constructor on this list of tuples.</li>
</ul>
<hr/>
<p>Perhaps a slightly friendlier version, using more sensible variable names instead of tuple indexing and <code>set.pop()</code> instead of list indexing:</p>
<pre><code>d = {edge: dict(((pair ^ {edge}).pop(), value) for pair, value in G[1] if edge in pair) 
     for edge in G[0]}
</code></pre>
</div>
