<div class="post-text" itemprop="text">
<p>I am trying to understand python's class inheritance methods and I have some troubles figuring out how to do the following:</p>
<p>How can I inherit a method from a class <strong>conditional</strong> on the child's input?</p>
<p>I have tried the following code below without much success.</p>
<pre><code>class A(object):
    def __init__(self, path):
        self.path = path

    def something(self):
        print("Function %s" % self.path)   


class B(object):
    def __init__(self, path):
        self.path = path
        self.c = 'something'

    def something(self):
        print('%s function with %s' % (self.path, self.c))


class C(A, B):
    def __init__(self, path):
        # super(C, self).__init__(path)

        if path=='A':
            A.__init__(self, path)
        if path=='B':
            B.__init__(self, path)
        print('class: %s' % self.path)


if __name__ == '__main__':
    C('A')
    out = C('B')
    out.something()
</code></pre>
<p>I get the following output:</p>
<pre><code>class: A
class: B
Function B
</code></pre>
<p>While I would like to see:</p>
<pre><code>class: A
class: B
B function with something
</code></pre>
<p>I guess the reason why <code>A.something()</code> is used (instead of <code>B.something()</code>) has to do with the python's MRO.</p>
</div>
<div class="post-text" itemprop="text">
<p>Calling <code>__init__</code> on either parent class does not change the inheritance structure of your classes, no. You are only changing what initialiser method is run in addition to <code>C.__init__</code> when an instance is created. <code>C</code> inherits from both <code>A</code> and <code>B</code>, and all methods of <code>B</code> are shadowed by those on <code>A</code> due to the order of inheritance.</p>
<p>If you need to alter class inheritance based on a value in the constructor, create <strong>two separate classes</strong>, with different structures. Then provide a different callable as the API to create an instance:</p>
<pre><code>class CA(A):
    # just inherit __init__, no need to override

class CB(B):
    # just inherit __init__, no need to override

def C(path):
    # create an instance of a class based on the value of path
    class_map = {'A': CA, 'B': CB}
    return class_map[path](path)
</code></pre>
<p>The user of your API still has name <code>C()</code> to call; <code>C('A')</code> produces an instance of a different class from <code>C('B')</code>, but they both implement the same interface so this doesn't matter to the caller.</p>
<p>If you <em>have</em> to have a common 'C' class to use in <code>isinstance()</code> or <code>issubclass()</code> tests, you could mix one in, and use the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code> method</a> to override what subclass is returned:</p>
<pre><code>class C:
    def __new__(cls, path):
        if cls is not C:
            # for inherited classes, not C itself
            return super().__new__(cls)
        class_map = {'A': CA, 'B': CB}
        cls = class_map[path]
        # this is a subclass of C, so __init__ will be called on it
        return cls.__new__(cls, path)

class CA(C, A):
    # just inherit __init__, no need to override
    pass

class CB(C, B):
    # just inherit __init__, no need to override
    pass
</code></pre>
<p><code>__new__</code> is called to construct the new instance object; if the <code>__new__</code> method returns an instance of the class (or a subclass thereof) then <code>__init__</code> will automatically be called on that new instance object. This is why <code>C.__new__()</code> returns the result of <code>CA.__new__()</code> or <code>CB.__new__()</code>; <code>__init__</code> is going to be called for you.</p>
<p>Demo of the latter:</p>
<pre><code>&gt;&gt;&gt; C('A').something()
Function A
&gt;&gt;&gt; C('B').something()
B function with something
&gt;&gt;&gt; isinstance(C('A'), C)
True
&gt;&gt;&gt; isinstance(C('B'), C)
True
&gt;&gt;&gt; isinstance(C('A'), A)
True
&gt;&gt;&gt; isinstance(C('A'), B)
False
</code></pre>
<p>If neither of these options are workable for your specific usecase, you'd have to add more routing in a new <code>somemethod()</code> implementation on <code>C</code>, which then calls either <code>A.something(self)</code> or <code>B.something(self)</code> based on <code>self.path</code>. This becomes cumbersome really quickly when you have to do this for <em>every single method</em>, but a decorator could help there:</p>
<pre><code>from functools import wraps

def pathrouted(f):
    @wraps
    def wrapped(self, *args, **kwargs):
        # call the wrapped version first, ignore return value, in case this
        # sets self.path or has other side effects
        f(self, *args, **kwargs)
        # then pick the class from the MRO as named by path, and call the
        # original version
        cls = next(c for c in type(self).__mro__ if c.__name__ == self.path)
        return getattr(cls, f.__name__)(self, *args, **kwargs)
    return wrapped
</code></pre>
<p>then use that on empty methods on your class:</p>
<pre><code>class C(A, B):
    @pathrouted
    def __init__(self, path):
        self.path = path
        # either A.__init__ or B.__init__ will be called next

    @pathrouted
    def something(self):
        pass  # doesn't matter, A.something or B.something is called too
</code></pre>
<p>This is, however, becoming very unpythonic and ugly.</p>
</div>
<div class="post-text" itemprop="text">
<p>While Martijn's answer is (as usual) close to perfect, I'd just like to point out that from a design POV, inheritance is the wrong tool here. </p>
<p>Remember that implementation inheritance is actually a static and somehow restricted kind of composition/delegation, so as soon as you want something more dynamic the proper design is to eschew inheritance and go for full composition/delegation, canonical examples being the State and the Strategy patterns. Applied to your example, this might look something like:</p>
<pre><code>class C(object):
    def __init__(self, strategy):
        self.strategy = strategy

    def something(self):
        return self.strategy.something(self)

class AStrategy(object):
    def something(self, owner):
        print("Function A")

class BStrategy(object):
    def __init__(self):
        self.c = "something"

    def something(self, owner):
        print("B function with %s" % self.c)


if __name__ == '__main__':
    a = C(AStrategy())
    a.something()
    b = C(BStrategy())
    b.something()
</code></pre>
<p>Then if you need to allow the user to specify the strategy by name (as string), you can add the factory pattern to the solution</p>
<pre><code>STRATEGIES = {
    "A": AStrategy,
    "B": BStrategy, 
    }

def cfactory(strategy_name):
  try:
      strategy_class = STRATEGIES[strategy_name]
  except KeyError:
      raise ValueError("'%s' is not a valid strategy" % strategy_name)
  return C(strategy_class())

if __name__ == '__main__':
    a = cfactory("A")
    a.something()
    b = cfactory("B")
    b.something()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Martijn's answer explained how to choose an object inheriting from one of two classes. Python also allows to easily forward a method to a different class:</p>
<pre><code>&gt;&gt;&gt; class C:
    parents = { 'A': A, 'B': B }
    def __init__(self, path):
        self.parent = C.parents[path]
        self.parent.__init__(self, path)                 # forward object initialization
    def something(self):
        self.parent.something(self)                      # forward something method


&gt;&gt;&gt; ca = C('A')
&gt;&gt;&gt; cb = C('B')
&gt;&gt;&gt; ca.something()
Function A
&gt;&gt;&gt; cb.something()
B function with something
&gt;&gt;&gt; ca.path
'A'
&gt;&gt;&gt; cb.path
'B'
&gt;&gt;&gt; cb.c
'something'
&gt;&gt;&gt; ca.c
Traceback (most recent call last):
  File "&lt;pyshell#46&gt;", line 1, in &lt;module&gt;
    ca.c
AttributeError: 'C' object has no attribute 'c'
&gt;&gt;&gt; 
</code></pre>
<p>But here class C does not inherit from A or B:</p>
<pre><code>&gt;&gt;&gt; C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class 'object'&gt;)
</code></pre>
<hr/>
<p>Below is my original solution using <em>monkey patching</em>:</p>
<pre><code>&gt;&gt;&gt; class C:
    parents = { 'A': A, 'B': B }
    def __init__(self, path):
        parent = C.parents[path]
        parent.__init__(self, path)                      # forward object initialization
        self.something = lambda : parent.something(self) # "borrow" something method
</code></pre>
<p>it avoids the <code>parent</code> attribute in C class, but is less readable...</p>
</div>
<span class="comment-copy">Why would you do this? Why not just make two separate classes, <code>CA</code> and <code>CB</code>, that inherit from either base, then pick from those classes when creating an instance?</span>
<span class="comment-copy">While monkeypatching is a handy workaround sometimes, I would definitly not advise using it as part of a proper design. What you're doing here is mostly a non standard and rather brittle implemention of the strategy pattern, so better to go for a more canonical (and robust) strategy implementation.</span>
<span class="comment-copy">@brunodesthuilliers: I must admit that monkey patching is rather rough... This one now dynamically forwards a method to a different class</span>
