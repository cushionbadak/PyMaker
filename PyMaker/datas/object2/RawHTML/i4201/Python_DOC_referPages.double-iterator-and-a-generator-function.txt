<div class="post-text" itemprop="text">
<p>I want to get "next asset" with an iterator-like object, but (instead of <code>__next__()</code> method) there are two algorithms loading next asset (<code>next1</code> and <code>next2</code> below), which can be implemented as a "quasi-iterator" like:</p>
<pre><code>class AssetLoader(object):
    def __init___(self):
        pass

    def next1(self):
        # ...

    def next2(self):
        # ...
</code></pre>
<p>To be clear, what is the next retrieved object may depends on the "history" of calling <code>next1</code> and <code>next2</code>, like:</p>
<p><code>next1()</code>; <code>next1()</code>; <code>next2()</code>; <code>next1()</code>; <code>next2()</code></p>
<p>My question: May this (two kinds of "next" step in an iterator) be implemented as a generator function?</p>
<p>I guess this can be done with a global variable to which the function refers. But can it be done without using global variables, but with some local variable?</p>
<p>If it is hard or impossible with current Python, can we discuss how to add new semantics to Python to make it possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple example of using <code>send</code> to switch a generator between two different iteration modes: it either increments its current value or multiplies it. The same principle can be applied to your graph traversal task.</p>
<p>The <code>send</code> method allows you to send an object into the generator. Annoyingly, the result of <code>send</code> is the current value that you would have obtained by calling <code>next</code>; it would be nice if you could send without having the generator yield a value, but that's just something we have to live with.</p>
<pre><code>def add_or_mul(current, step, scale, mode='add'):
    ''' A generator that either adds step to the current value,
        or multiplies it by scale
    '''
    while True:
        newmode = yield current
        if newmode is not None:
            if newmode not in ('add', 'mul'):
                raise ValueError('Bad mode: ' + newmode)
            mode = newmode
        if mode == 'add':
            current += step
        else:
            current *= scale

# Test

    gen = add_or_mul(1, 1, 2)
    for i in range(5):
        print(next(gen))
    print(gen.send('mul'))
    for i in range(4):
        print(next(gen))
    print(gen.send('add'))
    for i in range(4):
        print(next(gen))       
</code></pre>
<p><strong>output</strong></p>
<pre><code>    1
    2
    3
    4
    5
    10
    20
    40
    80
    160
    161
    162
    163
    164
    165
</code></pre>
<hr/>
<p>If you have trouble applying this technique to your graph traversal task please ask a fresh question (possibly linking to this one) that includes some relevant graph code, so that answerers don't have to write that stuff from scratch in order to test and demonstrate their code.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>class AssetLoader(object):
    def __init___(self):
        self.current_next = self.next1

    def next1(self):
        if condition:
            self.current_next = self.next2
        elif conition:
            return x
        else:
            raise StopIteration

    def next2(self):
        if condition:
            self.current_next = self.next1
        elif conition:
            return y
        else:
            raise StopIteration

    def __next__(self):
        return self.current_next()

    def __iter__(self):
        return self
</code></pre>
</div>
<span class="comment-copy">Can you give a little more of context as to the logic behind the choosing of next1 or next2 to get the next element? Why a simple condition in __next__ would not be sufficient?</span>
<span class="comment-copy">This sounds interesting... OTOH, it might be an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>. ;) If you can give us a simple "fake" example of how you'd use this with the output it would produce it would make it a lot easier for us to understand what you want to do.</span>
<span class="comment-copy">@porton If you can't add more context, you won't get any useful answers.</span>
<span class="comment-copy">We aren't asking for your real example. Just a <i>simple</i> example that exhibits the kind of behaviour that you want to achieve. And then we can either a) show you code that does that, or b) tell you why it's not possible to do that using normal Python syntax. Python is very powerful &amp; versatile, so my hopes are high for a). But without a clear problem statement I'm afraid your question won't be answerable.</span>
<span class="comment-copy">Ok. Does the code that calls the generator make the choice of red or blue? If so, that sounds like a job for <a href="https://docs.python.org/3/reference/expressions.html#generator.send" rel="nofollow noreferrer"><code>send</code></a>.</span>
<span class="comment-copy">@porton Your question is rather unclear.  Why do you need a generator function rather than a different kind of iterator?  And for what it's worth, it's quite simple to turn this implementation into a generator function.  Please show your attempts, then we may be able to understand your actual problem.</span>
<span class="comment-copy">If the first <code>condition</code> in <code>next[12]</code> is met, the iterator will yield a <code>None</code> element, which seems wrong.</span>
<span class="comment-copy">@porton I don't understand your problem at all.  Why not simply store the current state in a local variable?</span>
<span class="comment-copy">I don't get this answer at all. Why are there two <code>next1</code> and <code>next2</code> functions that sometimes set an attribute, othertimes return something, and sometimes throw an exception? What's the point of those? What do they do? How would I use this <code>AssetLoader</code> class?</span>
<span class="comment-copy">don't blame the answer. The question is unclear for starters</span>
