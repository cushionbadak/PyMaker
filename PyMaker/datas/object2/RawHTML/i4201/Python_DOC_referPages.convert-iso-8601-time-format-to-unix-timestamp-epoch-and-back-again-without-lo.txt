<div class="post-text" itemprop="text">
<p>Python methods to convert ISO 8601 time format to UNIX timestamp (epoch) and back again without losing fractional seconds?</p>
<p>I found several examples, but all the examples seem to drop the fractional seconds at some point in the conversion.  Example below...</p>
<p>The issue seems to be the initial conversion to UNIX timestamp (epoch).  Code below.</p>
<pre><code>def ISO8601ToEpoch(theString):

    from datetime import datetime
    import calendar

    return calendar.timegm(datetime.strptime(theString, "%Y-%m-%dT%H:%M:%S.%f").timetuple())

def EpochToISO8601(theEpoch):

    from datetime import datetime

    return datetime.fromtimestamp(theEpoch).isoformat()

#

print 'Original Time {0}'.format('2018-04-27T04:19:51.050937')

theTime=ISO8601ToEpoch('2018-04-27T04:19:51.050937')
print 'Time {0}'.format(theTime)

print 'Original Time {0}'.format(EpochToISO8601(theTime)
</code></pre>
<p>This results as...</p>
<p>Original Time 2018-04-27T04:19:51.050937
Time 1524802791
Original Time 2018-04-27T04:19:51</p>
<p>Is there a way to get timetuple to not hack the fractional seconds?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that you're converting a <code>datetime</code>—which understands microseconds—into a <code>timetuple</code>—which doesn't.<sup>1</sup></p>
<p>The obvious fix is just to not do that.</p>
<p>If you want to convert a <code>datetime</code> object to a timestamp, just use the <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp" rel="nofollow noreferrer"><code>timestamp</code></a> method, the same way you already use the <code>fromtimestamp</code> classmethod to go the other way.</p>
<hr/>
<p><sub>1. You <em>might</em> be able to trick a <code>timetuple</code> into holding a <code>float</code> instead of an <code>int</code> for seconds. But then you'd be breaking the invariants of the type. And, more importantly, defeating the entire purpose of the type, which is to be identical to a 1980s-style C <code>struct tm</code>. And likely also breaking the <code>timegm</code> function, which probably just calls the C function of the same name. (Most of the <code>time</code> module is a thin wrapper around C's <code>&lt;time.h&gt;</code>, as opposed to <code>datetime</code>, which is a friendly module designed for Python.) And then <code>timegm</code> is documented to return an integral type, so even if you got that far, it would all be for nothing.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is correct... but if not I am sure someone will point out what I missed.</p>
<pre><code>&gt;&gt;&gt; import datetime as datetime
&gt;&gt;&gt; import dateutil.parser
&gt;&gt;&gt; import time

# Create a sample UNIX timestamp...
&gt;&gt;&gt; t=time.time()
&gt;&gt;&gt; t
1478266530.573583

# Convert the time stamp sample to ISO format...
&gt;&gt;&gt; i=datetime.datetime.utcfromtimestamp(t).isoformat()
&gt;&gt;&gt; i
'2016-11-04T13:35:30.573583'

# Convert ISO format to UNIX time stamp...
&gt;&gt;&gt; d=dateutil.parser.parse(i)
&gt;&gt;&gt; d
datetime.datetime(2016, 11, 4, 13, 35, 30, 573583)
&gt;&gt;&gt; s=(time.mktime(d.timetuple())*1e3+d.microsecond/1e3)/1e3
&gt;&gt;&gt; s
1478266530.5735831
</code></pre>
<p>It is not a perfect conversion given the number of fractional digits of the resulting timestamp but close enough for my need.  I am sure the ISO format is a point of debate, but the format matches the typical format I expect to encounter, this is of course the lack of the 'Z' qualifier.</p>
</div>
<span class="comment-copy">Why are you going through <code>timetuple</code> (and <code>calendar.timegm</code>) instead of just using the <code>datetime</code> object in the first place?</span>
<span class="comment-copy">The Unix timestamp is defined in integral seconds, you can't convert to it without losing the fractional seconds. Unless you create your own equivalent definition using real numbers.</span>
<span class="comment-copy">@MarkRansom No, "Unix timestamp" isn't actually defined as integral. <code>time_t</code> is, but POSIX defines at least two other timestamp types that have sub-second fields, that are used as more precise timestamps all over the place in Linux and macOS. That's why Python's <code>datetime.timestamp()</code> and <code>datetime.fromtimestamp</code> deal with floats whenever possible. (Of course the lower-level functions in <code>time</code> and <code>calendar</code> do not, because they're specifically wrapping <code>time_t</code> and <code>struct tm</code>.) The OP's code already makes use of that fact in one direction, and he works; he just didn't do it the other way.</span>
<span class="comment-copy">I got these routines from google sources, trying to avoid some effort, but that obvious did not work great.  Can someone provide a code example of converting ISO to timestamp and back again?  Not a python guru, still learning.  Examples would be appreciated.</span>
<span class="comment-copy">@Schorschi You already wrote one direction. For the opposite direction, just take the result of <code>strptime</code> and call <code>timetuple</code> on it. Also, if you look at the docs for the module instead of searching for random code and then trying to figure out what it does, you’ll find the answer a lot faster. Some modules aren’t documented that completely or that clearly, but most of the stdlib is. (Until you try to write a tkinter GUI…)</span>
<span class="comment-copy">So, tinkering around with the timetuple, and time.mktime, I think I got what I need:  &gt;&gt;&gt; import datetime as datetime &gt;&gt;&gt; import dateutil.parser &gt;&gt;&gt; import time  &gt;&gt;&gt; t=time.time() &gt;&gt;&gt; t 1478266530.573583  &gt;&gt;&gt; i=datetime.datetime.utcfromtimestamp(t).isoformat() &gt;&gt;&gt; i '2016-11-04T13:35:30.573583'  &gt;&gt;&gt; d=dateutil.parser.parse(i) &gt;&gt;&gt; d datetime.datetime(2016, 11, 4, 13, 35, 30, 573583) &gt;&gt;&gt; s=(time.mktime(d.timetuple())*1e3+d.microsecond/1e3)/1e3 &gt;&gt;&gt; s 1478266530.5735831</span>
<span class="comment-copy">@Schorschi Why are you doing all that work instead of just calling <code>timestamp</code>?</span>
<span class="comment-copy">Illustrate?  which what where?</span>
<span class="comment-copy">The <code>Z</code> means it's in the GMT timezone. Without either that <code>Z</code>, an offset, or a timezone ID, what you have is a "naive" datetime that's ambiguous (meaning it doesn't specify a timezone), but can be useful as a local time if only used locally.</span>
<span class="comment-copy">Actually given the environment and coding standard, everything is UTC.  Which would 'mask' the issue, sure.  I have made a note regardless, when I get a bit of time, will swing back and address the Z issue, so it is explicitly qualified.</span>
