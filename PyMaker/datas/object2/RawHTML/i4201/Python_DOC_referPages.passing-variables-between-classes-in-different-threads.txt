<div class="post-text" itemprop="text">
<p>Assume I have two classes that use threads</p>
<pre><code>class foo(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self,name="foo=&gt;bar")
        self.var1 = {}

    def run(self):
        while True
            value, name = getvalue()  // name is an string
            self.var1[name] = value
            bar(self)


class bar(threading.Thread):
    def __init__(self,fooInstance):
        threading.Thread.__init__(self,name="bar")

    def run(self):
        while True
            arg = myfunction()  // somefunction (not shown for simplicity)
            val = myOtherfunction(fooInstance.var1[arg])  //other function
            print(val)


f = foo()
f.start()
</code></pre>
<p>The variable <code>var1</code> in <code>foo</code> will change over time and <code>bar</code> needs to be aware of these changes. It makes sense to me, but I wonder if there is something fundamental here that could fail eventually. is this correct in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>The actual sharing part is the same question as "how do I share a value with another object?" without threads, and all the same solutions will work. </p>
<p>For example. you're already passing the <code>foo</code> instance into the <code>bar</code> initializer, so just get it from there:</p>
<pre><code>class bar(threading.Thread):
    def __init__(self,fooInstance):
        threading.Thread.__init__(self,name="bar")
        self.var1 = fooInstance.var1
</code></pre>
<hr/>
<p>But is this thread-safe?</p>
<p>Well, yes, but only because you never actually start the background thread. But I assume in your real code, you're going to have two threads running at the same time, both accessing that <code>var1</code> value. In which case it's not thread-safe without some kind of synchronization. For example:</p>
<pre><code>class foo(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self,name="foo=&gt;bar")
        self.var1 = {}
        self.var1lock = threading.Lock()

class bar(threading.Thread):
    def __init__(self,fooInstance):
        threading.Thread.__init__(self,name="bar")
        self.var1 = fooInstance.var1
        self.var1lock = fooInstance.var1lock
</code></pre>
<p>And now, instead of this:</p>
<pre><code>self.var1[name] = value
</code></pre>
<p>… you do this:</p>
<pre><code>with self.var1lock:
    self.var1[name] = value
</code></pre>
<p>And likewise, instead of this:</p>
<pre><code>val = myOtherfunction(fooInstance.var1[arg])  //other function
</code></pre>
<p>… you do this:</p>
<pre><code>with self.var1lock:
    var1arg = var1[arg]
val = myOtherfunction(var1arg)
</code></pre>
<p>Or… as it turns out, in CPython, updating a value for a single key in a dict (only a builtin <code>dict</code>, not a subclass or custom mapping class!) has always been atomic, and probably always will be. If you want to rely on that fact, you can. But I'd only do that if the lock turned out to be a significant performance issue. And I'd comment every use of it to make it clear, too.</p>
<hr/>
<p>If you'd rather <em>pass</em> values instead of <em>share</em> them, the usual answer is <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer"><code>queue.Queue</code></a> or one of its relatives.</p>
<p>But this requires a redesign of your program. For example, maybe you want to pass each new/changed key-value pair over the queue. That would go something like this:</p>
<pre><code>class foo(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self,name="foo=&gt;bar")
        self.var1 = {}
        self.q = queue.Queue()
    def run(self):
        b = bar(self)
        b.start()
        while True:
            value, name = getvalue()  // name is an string
            self.var1[name] = value
            self.q.put((name, value))
class bar(threading.Thread):
    def __init__(self,fooInstance):
        threading.Thread.__init__(self,name="bar")
        self.var1 = copy.deepcopy(fooInstance.var1)
        self.q = fooInstance.q
    def _checkq(self):
        while True:
            try:
                key, val = self.q.get_nowait()
            except queue.Empty:
                break
            else:
                self.var1[key] = val
    def run(self):
        while True:
            self._checkq()
            arg = myfunction()  // somefunction (not shown for simplicity)
            val = myOtherfunction(fooInstance.var1[arg])  //other function
            print(val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although it is highly inefficient and certainly not the most common way you could use files to transfer the data. One thread writes the data into the file e.g. as a json string and the other thread reads it. </p>
</div>
<span class="comment-copy">Your code is over-simplified and wouldn't work. There are (too) many things wrong with it. Please <a href="https://stackoverflow.com/posts/50108831/edit">edit</a> your question and provide a minimal runnable example—or something much closer to one.</span>
<span class="comment-copy">Generally speaking, in concurrent programming you often need use something like  <code>Lock</code> or <code>Semaphore</code> to unsure only one thread/process has access to a shared resource at any given time. In this case it looks like <code>fooInstance</code> might need that.</span>
<span class="comment-copy">If you want to explicitly pass data instead of sharing it, the usual answer is a <code>queue.Queue</code> (or one of its variants).</span>
<span class="comment-copy">Maybe make <code>var1</code> a module level dictionary and use a lock when foo changes it. Does it need to be unique to the instance?</span>
<span class="comment-copy">If you want to share data: there are a set of specific operations that have always been atomic in CPython, and probably always will be, even though they aren't guaranteed—and that includes updating a single key's value for a builtin <code>dict</code>. But I'd use a lock anyway, unless it causes a performance problem.</span>
<span class="comment-copy">Constantly writing and reading from the hard drive is not an option. Is much more efficient to just read from memory.</span>
