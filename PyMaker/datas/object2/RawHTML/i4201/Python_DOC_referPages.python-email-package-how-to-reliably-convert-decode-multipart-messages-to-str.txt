<div class="post-text" itemprop="text">
<p>I was trying to process old, potentially non-compliant emails with Python. I could read in the message without problem:</p>
<pre><code>In [1]: m=email.message_from_binary_file(open('/path/to/problematic:2,S',mode='rb'))
</code></pre>
<p>But subsequently converting it to string gave a UnicodeEncodeError: 'gb2312' codec can't encode character '\ufffd' in position 1238: illegal multibyte sequence. The (multi-)part of this problematic message has "Content-Type: text/plain; charset="gb2312" and "Content-Transfer-Encoding: 8bit".</p>
<pre><code>In [2]: m.as_string()
---------------------------------------------------------------------------
UnicodeEncodeError                        Traceback (most recent call last)
&lt;ipython-input-26-919a3a20e7d8&gt; in &lt;module&gt;()
----&gt; 1 m.as_string()

~/tools/conda/envs/conda3.6/lib/python3.6/email/message.py in as_string(self, unixfrom, maxheaderlen, policy)
    156                       maxheaderlen=maxheaderlen,
    157                       policy=policy)
--&gt; 158         g.flatten(self, unixfrom=unixfrom)
    159         return fp.getvalue()
    160

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in flatten(self, msg, unixfrom, linesep)
    114                     ufrom = 'From nobody ' + time.ctime(time.time())
    115                 self.write(ufrom + self._NL)
--&gt; 116             self._write(msg)
    117         finally:
    118             self.policy = old_gen_policy

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in _write(self, msg)
    179             self._munge_cte = None
    180             self._fp = sfp = self._new_buffer()
--&gt; 181             self._dispatch(msg)
    182         finally:
    183             self._fp = oldfp

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in _dispatch(self, msg)
    212             if meth is None:
    213                 meth = self._writeBody
--&gt; 214         meth(msg)
    215
    216     #

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in _handle_multipart(self, msg)
    270             s = self._new_buffer()
    271             g = self.clone(s)
--&gt; 272             g.flatten(part, unixfrom=False, linesep=self._NL)
    273             msgtexts.append(s.getvalue())
    274         # BAW: What about boundaries that are wrapped in double-quotes?

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in flatten(self, msg, unixfrom, linesep)
    114                     ufrom = 'From nobody ' + time.ctime(time.time())
    115                 self.write(ufrom + self._NL)
--&gt; 116             self._write(msg)
    117         finally:
    118             self.policy = old_gen_policy

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in _write(self, msg)
    179             self._munge_cte = None
    180             self._fp = sfp = self._new_buffer()
--&gt; 181             self._dispatch(msg)
    182         finally:
    183             self._fp = oldfp

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in _dispatch(self, msg)
    212             if meth is None:
    213                 meth = self._writeBody
--&gt; 214         meth(msg)
    215
    216     #

~/tools/conda/envs/conda3.6/lib/python3.6/email/generator.py in _handle_text(self, msg)
    241                 msg = deepcopy(msg)
    242                 del msg['content-transfer-encoding']
--&gt; 243                 msg.set_payload(payload, charset)
    244                 payload = msg.get_payload()
    245                 self._munge_cte = (msg['content-transfer-encoding'],

~/tools/conda/envs/conda3.6/lib/python3.6/email/message.py in set_payload(self, payload, charset)
    313             if not isinstance(charset, Charset):
    314                 charset = Charset(charset)
--&gt; 315             payload = payload.encode(charset.output_charset)
    316         if hasattr(payload, 'decode'):
    317             self._payload = payload.decode('ascii', 'surrogateescape')

UnicodeEncodeError: 'gb2312' codec can't encode character '\ufffd' in position 1238: illegal multibyte sequence
</code></pre>
<p>I'm not really familiar with the idiosyncrasies of email internals, and searching online for this type of errors turned up mostly problems while scraping the web, and basically suggested somewhat the obvious: the raw bytes read in contains Unicode characters that are not possible to encode with the target codec.</p>
<p>My question is: what's the correct way to reliably handle (potentially non-compliant) emails?</p>
<p><strong>EDIT</strong></p>
<p>It is interesting that <code>m.get_payload(i=0).as_string()</code> would trigger the same exception, but <code>m.get_payload(i=0).get_payload(decode=False)</code> gave a <code>str</code> that displayed correctly on my terminal, while <code>m.get_payload(i=0).get_payload(decode=True)</code> gave a <code>bytes</code> (<code>b'\xd7\xaa...'</code>) that I can't decode. However, the error happens on a <em>different character</em>:</p>
<pre><code>----&gt; 1 m.get_payload(i=0).get_payload(decode=True).decode('gb2312')
UnicodeDecodeError: 'gb2312' codec can't decode byte 0xac in position 1995: illegal multibyte sequence
</code></pre>
<p>or</p>
<pre><code>----&gt; 1 m.get_payload(i=0).get_payload(decode=True).decode('gb18030')
UnicodeDecodeError: 'gb18030' codec can't decode byte 0xa3 in position 2033: illegal multibyte sequence
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is usually <a href="https://docs.python.org/3/library/codecs.html#error-handlers" rel="nofollow noreferrer">error handlers</a> in your <code>bytes.decode</code> calls. But the details depend on a lot of things.</p>
<p>First, what are you trying to do with the data? Often you need something that is absolutely reversible, so you can guarantee that worst-case you can re-generate what you took in, in which case you probably want <code>surrogate-escape</code>. In other cases, you want to generate something human-readable, and it's better to just skip over impossible mojibake than try to present it, so <code>ignore</code> may be the right answer. And so on.</p>
<p>Second, is this a case of the vast majority of messages being fine, but a few being wrong, or of many messages being mostly fine but having a few errors?</p>
<p>Finally, in some cases (and this is particularly true with legacy Chinese encodings), the actual problem is just that someone specified a closely-related charset instead of the one they actually used. If that's what you're seeing, you may want to try writing explicit fallback code: if you get an exception, look up the encoding in a dict of common mistakes and try the alternative encoding(s). If none of them work, then go back to using the specific encoding with an error handler.</p>
</div>
<div class="post-text" itemprop="text">
<p>Apparently, if <code>Content-Transfer-Encoding</code> is <code>8bit</code>, <code>message.get_payload(decode=False)</code> will still try to decode it to recover the original bytes. On the other hand, <code>message.get_payload(decode=True)</code> always produces <code>bytes</code>, although actual decoding happens only if <code>Content-Transfer-Encoding</code> exists and is <code>quoted-printable</code> or <code>base64</code>.</p>
<p>I ended up with the following code. Not sure if this is the correct way of handling emails.</p>
<pre><code>body = []
if m.preamble is not None:
    body.extend(m.preamble.splitlines(keepends=True))

for part in m.walk():
    if part.is_multipart():
        continue

    ctype = part.get_content_type()
    cte = part.get_params(header='Content-Transfer-Encoding')
    if (ctype is not None and not ctype.startswith('text')) or \
       (cte is not None and cte[0][0].lower() == '8bit'):
        part_body = part.get_payload(decode=False)
    else:
        charset = part.get_content_charset()
        if charset is None or len(charset) == 0:
            charsets = ['ascii', 'utf-8']
        else:
            charsets = [charset]

        part_body = part.get_payload(decode=True)
        for enc in charsets:
            try:
                part_body = part_body.decode(enc)
                break
            except UnicodeDecodeError as ex:
                continue
            except LookupError as ex:
                continue
        else:
            part_body = part.get_payload(decode=False)

    body.extend(part_body.splitlines(keepends=True))

if m.epilogue is not None:
    body.extend(m.epilogue.splitlines(keepends=True))
</code></pre>
</div>
<span class="comment-copy">The fraction of the problematic messages is small, but their absolute quantity is large enough to be handled programmatically. However, in this particular case, I want to compare two messages to detect duplicates and the originals are never directly written back. So reversibility isn't an issue. Could you give some code samples to show how to set <code>surrogateescape</code> vs. <code>ignore</code> when serializing the message? From the documentation, it wasn't clear how to attach custom codec error handlers.</span>
<span class="comment-copy">I added a little more information to my question about <code>get_payload</code> and decoding with a different codec. Unicode is hard...</span>
