<div class="post-text" itemprop="text">
<p>Basically, I knew that abstract base classes are used as skeleton classes just like regular classes, but enforces that abstract methods should be overridden by the child/inherited classes if it has one like below</p>
<pre><code>Class AbstractClass(object):
    __metaclass__ = abc.ABCMeta

    @abstractmethod
    def absmethod(self):
        pass

class ChildClass(AbstractClass):
    def absmethod(self):
        print "Yeah!"

obj = ChildClass()
</code></pre>
<p>So we can create an object of <code>ChildClass</code> as above</p>
<p>We know we can't instantiate an abstract class as it meant to be just skeleton and we will get an error if we try to instantiate it as below</p>
<pre><code>obj = AbstractClass()

*** TypeError: Can't instantiate abstract class AbstractClass with abstract methods absmethod
</code></pre>
<p>But what my actual query about posting this <code>StackOverflow</code> is if we create an abstract class by using <code>abc.ABCMeta</code>, without abstract methods, I can able to create an instance of the abstract class which should not be the case(correct me if I am wrong)</p>
<pre><code>Class AbstractClass(object):
    __metaclass__ = abc.ABCMeta

obj = AbstractClass()
</code></pre>
<p><strong>OOOPPPSS</strong> it worked, we can actually create an object of abstract classes without abstract methods? So please let me know the key points behind this</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>A class that has a metaclass derived from <code>ABCMeta</code> cannot be
  instantiated unless all of its abstract methods and properties are
  overridden.</p>
</blockquote>
<p>Conversely, this means that any class with no abstract methods or properties like your <code>AbstractClass</code> <em>can</em> be instantiated.</p>
<hr/>
<p>If you want to disallow instantiation of the topmost parent class, you can write a custom class that performs a type check in its <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> method:</p>
<pre><code>class SubclassOnlyABC(object):
    __metaclass__ = abc.ABCMeta

    def __new__(cls, *args, **kwargs):
        if cls.__bases__ == (SubclassOnlyABC,):
            msg = 'Abstract class {} cannot be instantiated'.format(cls.__name__)
            raise TypeError(msg)

        return super(SubclassOnlyABC, cls).__new__(cls, *args, **kwargs)
</code></pre>
<pre><code>class AbstractClass(SubclassOnlyABC):
    pass

class ChildClass(AbstractClass):
    pass

ChildClass()  # works because it's a child class of an abstract class
AbstractClass()  # throws TypeError because its parent class is "object"
</code></pre>
<hr/>
<p>You can also write a <code>__new__</code> method that prevents instantiation of classes with no abstract methods:</p>
<pre><code>class NonEmptyABC(object):
    __metaclass__ = abc.ABCMeta

    def __new__(cls, *args, **kwargs):
        # check if ANY abstractmethod exists
        for parentcls in cls.__mro__:
            if any(getattr(attr, '__isabstractmethod__', False)
                               for attr in vars(parentcls).values()):
                break
        else:
            msg = 'Abstract class {} cannot be instantiated'.format(cls.__name__)
            raise TypeError(msg)

        return super(NonEmptyABC, cls).__new__(cls, *args, **kwargs)
</code></pre>
<pre><code>class EmptyAbstractClass(NonEmptyABC):
    pass

class NonemptyAbstractClass(NonEmptyABC):
    @abc.abstractmethod
    def foo(self):
        pass

class NonemptyChild(NonemptyAbstractClass):
    def foo(self):
        pass

NonemptyChild()  # works because "foo" is an abstractmethod
EmptyAbstractClass()  # throws TypeError because there are no abstractmethods
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since Python is a dynamic languages, the very idea of enforcing classes to inherit from a particular class goes against duck typing. Hence, the use case of Abstract classes in Python is pretty limited and provided more for a conventional reason. Still if you want to block the instantiation of a class without declaring virtual methods, you can,  however,</p>
<pre><code>class AbstractClass(object):

    __metaclass__ = abc.ABCMeta

    def __new__(cls, *args, **kwargs):
        if cls is AbstractClass:
            raise Exception('Abstract class cannot be instantiatied')

        return object.__new__(*args, **kwargs)
</code></pre>
</div>
<span class="comment-copy">Why it is downvoting guys, is it wrong to ask a doubt?</span>
