<div class="post-text" itemprop="text">
<p>How can I convert nested dictionary to nested defaultdict?</p>
<pre><code>dic = {"a": {"aa": "xxx"}}
default = defaultdict(lambda: None, dic)
print(default["dummy_key"])  # return None
print(default["a"]["dummy_key"])  # KeyError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to either loop or recurse over the nested dictionary, through all of its levels.</p>
<p>Unless it's potentially ridiculously deep (as in hundreds of levels), or so wide that small performance factors make a difference, recursion is probably simplest here:</p>
<pre><code>def defaultify(d):
    if not isinstance(d, dict):
        return d
    return defaultdict(lambda: None, {k: defaultify(v) for k, v in d.items()})
</code></pre>
<hr/>
<p>Or if you want it to work with all mappings, not just dicts, you could use <code>collections.abc.Mapping</code> instead of <code>dict</code> in your <code>isinstance</code> check.</p>
<hr/>
<p>Of course this is assuming you have a pure nested dict. If you've got, say, something you parsed from a typical JSON response, where there might be dicts with list values with dict elements, you have to handle the other possibilities too:</p>
<pre><code>def defaultify(d):
    if isinstance(d, dict):
        return defaultdict(lambda: None, {k: defaultify(v) for k, v in d.items()})
    elif isinstance(d, list):
        return [defaultify(e) for e in d]
    else:
        return d
</code></pre>
<p>But if this actually <em>is</em> coming from JSON, it's probably better to just use your <code>defaultdict</code> as an <a href="https://docs.python.org/3/library/json.html#json.load" rel="nofollow noreferrer"><code>object_pairs_hook</code></a> while the JSON is being parsed, rather than parsing it to a dict and then converting it to a defaultdict later.</p>
<p>There's an example in the docs of using an <code>OrderedDict</code> in place of <code>dict</code>, but that won't quite work for us—unlike <code>OrderedDict</code> and <code>dict</code>, <code>defaultdict</code> can't just take an iterable of pairs as its only argument; it needs the default value factory first. So we can bind that in, using <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>:</p>
<pre><code>d = json.loads(jsonstring, object_hook_pairs=partial(defaultdict, lambda: None))
</code></pre>
<hr/>
<p>And so on.</p>
</div>
<span class="comment-copy">Thank you, It worked very well. Yes, I have list too, your advice is greatly helpful for me.  Thank you very much.</span>
<span class="comment-copy">@MaikoOhkawa If you actually <i>are</i> getting this from <code>json.loads</code> or similar, you might want to consider building it a <code>defaultdict</code> in the first place, instead of first building a <code>dict</code> and then converting it. For example, the <a href="https://docs.python.org/3/library/json.html#encoders-and-decoders" rel="nofollow noreferrer"><code>json</code> docs</a> explain how to make a decoder use <code>OrderedDict</code> instead of <code>dict</code> for every JSON object—you can do the same thing to make it use a <code>defaultdict</code>.</span>
<span class="comment-copy">Oh, thank you very much. I tried it but an error occured.      json.loads('{"a": {"aa": "xxx"}}', object_pairs_hook=collections.defaultdict)  # TypeError: first argument must be callable or None  Maybe I'm wrong.</span>
<span class="comment-copy">@MaikoOhkawa You can't just use <code>defaultdict</code>, because it needs an extra first argument—but you can use, e.g., <code>functools.partial(defaultdict, lambda: None)</code>, or <code>lambda *args, **kw: defaultdict(lambda: None, *args, **kw)</code>. I'll edit this into the answer.</span>
<span class="comment-copy">Thank you very much, It worked very well!! Thanks!</span>
