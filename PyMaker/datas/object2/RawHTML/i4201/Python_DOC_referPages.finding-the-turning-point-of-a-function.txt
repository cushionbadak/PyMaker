<div class="post-text" itemprop="text">
<p>I'd like to the first value that outputs <code>True</code> for my function. I currently have a search that works fine, but I think is still a bit inefficient. Could anyone suggest a better binary search? My code is below, simplified.</p>
<pre><code>guess = 2
limits = [2, 2**35] #The search area

while True:
    if myFunction(guess) == False:
        limits[0] = max(limits[0], guess) #Limit the search area
        guess *= 2
    else:
        limits[1] = min(limits[1], guess) #Limit the search area
        guess = int((limits[0] + limits[1])/2) #The guess is the midpoint of the search area
        if myFunction(guess) == True and myFunction(guess-1) == False:
            return guess
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the classical problem of finding a level-crossing of a monotonically increasing or decreasing function. As you guessed, it is solvable by <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="nofollow noreferrer">binary search</a>. Your code has some bugs, which is not surprising:</p>
<blockquote>
<p>Although the idea is simple, implementing binary search correctly requires attention to some subtleties about its exit conditions and midpoint calculation.</p>
</blockquote>
<p>So, you should avoid writing your own binary search when possible. Fortunately, Python offers a library module <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> which can do the job for you. </p>
<pre><code>from bisect import bisect_left

MIN = 2
MAX = 2**35

def search(f):
   # Finds the first position of `True` in `f`
   return bisect_left(f, True, lo=MIN, hi=MAX + 1)
</code></pre>
<p>Don't be confused by the fact that <code>bisect</code> only works with indexable objects: there is no need to create a list with <code>2**35</code> elements. You can use a generator object instead using the <code>__getitem__</code> syntax. To do that, encapsulate your function in a class and define the getter method that would return <code>False</code> for all argument values on the left side of the point of interest and <code>True</code> otherwise.</p>
<pre><code>def myFunction1(index):
   return index &gt;= 1456
def myFunction2(index):
   return index &gt;= 2
def myFunction3(index):
   return index &gt;= MAX - 1

class F:
   def __init__(self, f):
      self.f = f
   def __getitem__(self, index):
      return self.f(index)

# testing code
print(search(F(myFunction1))) # prints 1456
print(search(F(myFunction2))) # prints 2
print(search(F(myFunction3))) # prints MAX - 1
</code></pre>
</div>
<span class="comment-copy">What do you mean by "first"? <i>Any</i> element in the range that meets your criteria? Or the <i>smallest</i>?</span>
<span class="comment-copy">Yes, the smallest.</span>
<span class="comment-copy">So there is no reason to make a guess in the middle of the range then, correct? If you want the first value in the range that meets your criteria, then you just have to write <code>next((x for x in my_range if myFunction(x)), None)</code>. Let us know if that's not what you need.</span>
<span class="comment-copy">@RayToal My interpretation of the question (which I admit could be wrong) is that <code>myFunction</code> returns False for values of <code>x</code> less than some number <code>N</code>, and returns True for all values of <code>x</code> greater than or equal to <code>N</code>. And the goal is to find <code>N</code>. So a binary search can be used to find <code>N</code> while calling <code>myFunction</code> no more than 35 times. But <code>next</code> will do a linear search, and could call <code>myFunction</code> up to 34 billion times.</span>
<span class="comment-copy">No worries, I didn't spend enough time reading it. It's fine. I don't think you can do much better than binary search though. Start right in the middle and go one way or the other. Even knowledge of whether the turning point is closer to the beginning or the end won't give that much benefit over the simplest binary search, since a search space of 2**35 will require only 35 probes.</span>
<span class="comment-copy">I've never used a Python class. Is this possible to do without a class? If not, how do I define my function inside the class? How do I call the function - let's say its name is myFunction? Sorry, I'm a total noob in this.</span>
<span class="comment-copy">I changed the example so that the examples of <code>myFunction</code> are defined separately - hope this makes it clearer. For this to work I suspect you might have to use a class: it is just a way how to trick the interpreter to accept it.</span>
<span class="comment-copy">If you don't want to use this, you can search for Python implementations of binary search and copypaste one of them: there are plenty around, even on Stack Overflow.</span>
<span class="comment-copy">I got it working. Thanks mate! The only problem I encountered was the system's max int size when trying values such as 2^35, but otherwise that was very convenient!</span>
