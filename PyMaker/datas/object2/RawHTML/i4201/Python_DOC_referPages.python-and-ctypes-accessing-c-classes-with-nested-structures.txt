<div class="post-text" itemprop="text">
<p>I have a shared library and two header files. I was able to use the library by creating bindings using <code>swig</code>. However, the <code>swig</code> version is quite slow and I didn't manage to include support for <code>numpy</code> arrays. I am now trying to call functions of the library from Python using <code>ctypes</code>. </p>
<p>First header contains an <code>extern "C"</code> block which exports 3 functions through macros (which are not available to me). The simplified version of the header looks like this:</p>
<pre><code>...

class Foo;
typedef Foo* FOO_HANDLE;

#if !defined(__cplusplus)
#   error "C++ Compiler only"
#endif

extern "C"
{
    APIPROTOTYPE_EXT( MakeAlgo, FOO_HANDLE, (void) );

    APIPROTOTYPE_EXT( DestroyAlgo, void, ( FOO_HANDLE ) );

    APIPROTOTYPE_EXT( AlgoProcess, void, ( FOO_HANDLE, StructOne *, StructTwo *) );
}
</code></pre>
<p>Normally, the first function <code>MakeAlgo</code> returns a pointer to an instance of the <code>Foo</code> class, the second function <code>DestroyAlgo</code> destroys the instance, and the third function <code>AlgoProcess</code> takes two structures as an input and modifies some of their values in-place.</p>
<p>The second header contains definitions of <code>StructOne</code> and <code>StructTwo</code> and some constants. <code>StructTwo</code> contains several nested structures.</p>
<p>In Python, I rewrote all the structures contained in the second header using <code>ctypes.Structure</code>. I don't post all the code here but here's an example how I defined a nested structure:</p>
<pre><code>class StructTwo(Structure):
    _fields_ = [("foo", StructFoo),
                ("dummy8", c_short)]

class StructFoo(Structure):
    _fields_ = [("bar", c_uint),
                ("reserv1", c_uint),
                ("reserv2", c_uint)]
</code></pre>
<p>Then my Python code looks like this (assuming the structures are in a <code>structures.py</code> file):</p>
<pre><code>from ctypes import *
from structures import StructOne, StructTwo

libfoo = ct.cdll.LoadLibrary(path/to/so/library)

makeAlgo = libfoo.MakeAlgo
makeAlgo.restype = c_void_p
makeAlgo.argtypes = []

destroyAlgo = libfoo.DestroyAlgo
destroyAlgo.restype = None
destroyAlgo.argtypes = [c_void_p]

submit = libfoo.AlgoProcess
submit.restype = None
submit.argtypes = [c_void_p, POINTER(StructOne), POINTER(StructTwo)]

handle = makeAlgo()

one = bar.StructOne()
two = bar.StructTwo()

submit(handle, byref(one), byref(two))
print(two.foo.bar)  # unsigned int, should output 1, got 196611000 instead

destroyAlgo(handle)
</code></pre>
<p>After creating a pointer to the <code>Foo</code> class, submitting the inputs, I check some of the values in one of the structures and it doesn't match the expected result. For instance, I know that one of the fields are set only to 0 or 1 by the library, but I get some weird results, like 196611000.</p>
<p>Does anybody knows what is wrong (maybe someone had similar problem)? Can it be the way I defined the structures? Or maybe it is a pointer to the C++ class which is not handled correctly?</p>
<p><s><strong>EDIT</strong></s></p>
<p>I managed to solve the initial problem. It appears that the way I define the structures was not correct. Instead of the above code, the nested structures should be passed by reference:</p>
<pre><code>class StructTwo(Structure):
    _fields_ = [("foo", POINTER(StructFoo)),
                ("dummy8", c_short)]

class StructFoo(Structure):
    _fields_ = [("bar", c_uint),
                ("reserv1", c_uint),
                ("reserv2", c_uint)]

# Then to initialize the nested structure
foo = StructFoo()
two = StructTwo(pointer(foo))  # has to be pointer() not byref()
</code></pre>
<p>However, now to access the <code>StructFoo</code>'s fields, I have to do:</p>
<pre><code>print(two.foo.contents.bar)
</code></pre>
<p>In actual code I might have up to 4 nested levels. Is there a more elegant way to access their fields then:</p>
<pre><code>two.foo.contents.baz.contents.qux.contents.field_value
</code></pre>
<p></p></div>
<div class="post-text" itemprop="text">
<p>My edit was incorrect.</p>
<p>The problem was that some of the structure were bit-field structures, specifying the width of each field solved it:</p>
<pre><code>class StructTwo(Structure):
    _fields_ = [("foo", StructFoo),
                ("dummy8", c_short)]

class StructFoo(Structure):
    _fields_ = [("bar", c_uint, 1),
                ("reserv1", c_uint, 8),
                ("reserv2", c_uint, 16)]
</code></pre>
<p><a href="https://docs.python.org/3/library/ctypes.html#bit-fields-in-structures-and-unions" rel="nofollow noreferrer">Bit-field structures in ctypes</a>.</p>
</div>
<span class="comment-copy">Does it work if called from a <i>C</i> (<i>C++</i>) app?</span>
<span class="comment-copy">In general, it looks right, but the structure definitions could be wrong and the C definitions weren't provided.</span>
<span class="comment-copy">@CristiFati, yes, the C++ version works as expected, so does the swig wrapper.</span>
