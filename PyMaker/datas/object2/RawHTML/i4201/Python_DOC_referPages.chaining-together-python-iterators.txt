<div class="post-text" itemprop="text">
<p>Trying to see if I can recursively generate an iterator of file paths. Essentially for a list of base paths and an ordered list of subdirs, I want to generate all child paths as a combination of the two inputs.</p>
<p>i.e </p>
<pre><code>base_path = ["/a", "/b"], subdir_lists = [ ["1", "2"], ["c", "d"] ] 
</code></pre>
<p>then the output should be </p>
<pre><code>[ "/a", "/a/1", "/a/1/c", "/a/1/d", "a/2", "/a/2/c", "/a/2/d", "/b", "/b/1", ... "/b/2/d" ]
</code></pre>
<p>My python code looks something like this. I'm calling appendpaths() recursively.</p>
<pre><code>def appendpaths(subdir_lists, base_path):
        if not subdir_lists or len(subdir_lists) == 0:
                return base_path
        if len(subdir_lists) == 1:
                return starmap(os.path.join, product(base_path, subdir_lists[0]))
        right = subdir_lists[1:]
        iter_list = [base_path, appendpaths(right, starmap(os.path.join, product(base_path, subdir_lists[0])))]
        return chain(*iter_list)


def main():
        subdir_lists = [["1", "2"], ["c", "d"]]
        it = appendpaths(subdir_lists, ["/a", "/b"])
        for x in it:
                print(x)
main()
</code></pre>
<p>My output is missing a few permutations:</p>
<pre><code>/a
/b
/a/1/c
/a/1/d
/a/2/c
/a/2/d
/b/1/c
/b/1/d
/b/2/c
/b/2/d
</code></pre>
<p>You can see that I'm missing /a/1, /a/2, /b/1 and /b/2. I'm guessing it's because somewhere in my code I've already exhausted the generators that iterate through those permutations? </p>
</div>
<div class="post-text" itemprop="text">
<p>You're complicating this a bit too much - if you just want a consecutive list product a simple recursion to merge together previously joined paths (or the base), moving one level deeper in each recursion all you need:</p>
<pre><code>import os

def append_paths(base, children):
    paths = []
    for e in base:
        paths.append(e)
        if children:  # dig deeper
            paths += append_paths([os.path.join(e, c) for c in children[0]], children[1:])
    return paths
</code></pre>
<p>And to test it:</p>
<pre><code>base_path = ["/a", "/b"]  # you might want to prepend with os.path.sep for cross-platform use
subdir_lists = [["1", "2"], ["c", "d"]]

print(append_paths(base_path, subdir_lists))
# ['/a', '/a/1', '/a/1/c', '/a/1/d', '/a/2', '/a/2/c', '/a/2/d',
#  '/b', '/b/1', '/b/1/c', '/b/1/d', '/b/2', '/b/2/c', '/b/2/d']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Given</strong></p>
<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; import itertools as it

&gt;&gt;&gt; base = ["/a", "/b"]
&gt;&gt;&gt; subdirs = [["1", "2"], ["c", "d"]] 
</code></pre>
<p>A helper itertools recipe:</p>
<pre><code>&gt;&gt;&gt; def powerset(iterable):
...     "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
...     s = list(iterable)
...     return it.chain.from_iterable(it.combinations(s, r) for r in range(len(s)+1))
</code></pre>
<p><strong>Code</strong></p>
<pre><code>&gt;&gt;&gt; def subsequence(iterable, pred=None):
...     """Return a non-contiguous subsequence."""
...     if pred is None: pred = lambda x: x
...     return (x for x in powerset(iterable) if x and pred(x))


&gt;&gt;&gt; prods = list(it.product(base, subdirs[0], subdirs[1]))
&gt;&gt;&gt; pred = lambda x: x[0].startswith("/")
&gt;&gt;&gt; result = sorted(set(it.chain.from_iterable(subsequence(p, pred) for p in prods)))
&gt;&gt;&gt; result
[('/a',),
 ('/a', '1'),
 ('/a', '1', 'c'),
 ('/a', '1', 'd'),
 ('/a', '2'),
 ('/a', '2', 'c'),
 ('/a', '2', 'd'),
 ('/a', 'c'),
 ('/a', 'd'),
 ('/b',),
 ('/b', '1'),
 ('/b', '1', 'c'),
 ('/b', '1', 'd'),
 ('/b', '2'),
 ('/b', '2', 'c'),
 ('/b', '2', 'd'),
 ('/b', 'c'),
 ('/b', 'd')]
</code></pre>
<p><em>Applications</em></p>
<p>Join paths as strings or <code>pathlib</code> objects.</p>
<pre><code>&gt;&gt;&gt; ["/".join(x) for x in result];
['/a', '/a/1', '/a/1/c', ...]

&gt;&gt;&gt; [pathlib.Path(*x) for x in result];
[WindowsPath('/a'), WindowsPath('/a/1'), WindowsPath('/a/1/c'), ...]
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p><em>Steps</em></p>
<ol>
<li><code>prods</code> are all <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code>s</a>, which accept iterables and create unique combinations (or Cartesian products) in a manner analogous to a <a href="https://developer.android.com/images/ui/pickers.png" rel="nofollow noreferrer">date picker dialog application</a>. See examples below.</li>
<li><code>subsequence</code> is simply a wrapper of the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>powerset</code> itertools recipe</a>.  It allows a <code>pred</code>icate, which is used to filter resuts that start with slashes like those from <code>base</code>.</li>
<li><code>result</code> sorts a flattened set of subsequences generated for each product.  You can optionally join each element as desired.  See Code - Applications.</li>
</ol>
<p><em>Examples</em></p>
<p>Here are the Cartesian products:</p>
<pre><code>&gt;&gt;&gt; prods
[('/a', '1', 'c'),
 ('/a', '1', 'd'),
 ('/a', '2', 'c'),
 ('/a', '2', 'd'),
 ('/b', '1', 'c'),
 ('/b', '1', 'd'),
 ('/b', '2', 'c'),
 ('/b', '2', 'd')]
</code></pre>
<p>Without a predicate, undesired subsequences are permitted:</p>
<pre><code>&gt;&gt;&gt; list(subsequence(prods[0]))
[('/a',),
 ('1',),                                                 # bad
 ('c',),
 ('/a', '1'),                           
 ('/a', 'c'),
 ('1', 'c'                                               # bad
 ('/a', '1', 'c')]
</code></pre>
<p>Thus, we filter unwanted elements with the predicate, <code>pred</code>.</p>
<pre><code>&gt;&gt;&gt; list(subsequence(prods[0], pred=pred))
[('/a',), ('/a', '1'), ('/a', 'c'), ('/a', '1', 'c')]
</code></pre>
</div>
<span class="comment-copy">No, it's because you forgot to recurse with a shorter sequence.</span>
<span class="comment-copy">Or look at the itertools builtin package. I think itertools.combinations should get you where you want to go.</span>
<span class="comment-copy">Yea, I agree. This was more of an exercise to familiarize myself with Python's generators</span>
