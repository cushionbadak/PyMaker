<div class="post-text" itemprop="text">
<p>So when I have objects</p>
<pre><code>[*range(4)]
[*zip([1, 2, 3], [4, 5, 6])]
</code></pre>
<p>and use tuple-unpacking, is there a way to subscript the tuple-unpacking notation which could look like this:</p>
<pre><code>[*range(4)[2]]
[*[2]zip([1, 2, 3], [4, 5, 6])]
</code></pre>
<p>Without using subscript on the whole comprehension?</p>
<pre><code>[[*range(4)][2]]
[[*zip([1, 2, 3], [4, 5, 6])][2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, you cannot slice an unpacking operation.</p>
<p>There are various possible workarounds though:</p>
<ul>
<li><p>If the iterable you're unpacking can be sliced, just slice it directly. For example, to get the 3rd element of a <code>range</code>:</p>
<pre><code>&gt;&gt;&gt; [*range(4)[2:3]]
[2]
</code></pre>
<p>So why are we using <code>[2:3]</code> here? It's simple: <code>range(4)[2]</code> would return a single integer, and integers can't be unpacked:</p>
<pre><code>&gt;&gt;&gt; [*range(4)[2]]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'int' object is not iterable
</code></pre>
<p>But <code>range(4)[2:3]</code> returns a single-element list, so the unpacking succeeds.</p></li>
<li><p>If the iterable can't be sliced, slice it anyway by using <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>:</p>
<pre><code>&gt;&gt;&gt; [*itertools.islice(zip([1, 2, 3], [4, 5, 6]), 2, 3)]
[(3, 6)]
</code></pre></li>
<li><p>If you only want a single element of a slice-able iterable, just don't unpack the iterable at all:</p>
<pre><code>&gt;&gt;&gt; [range(4)[2]]
[2]
</code></pre></li>
</ul>
</div>
<span class="comment-copy">The short answer is no. The longer answer is: How would you define what <code>[*range(4)[2]]</code> is supposed to mean? You obviously can't splat <code>range(4)[2]</code>, because that's the number <code>2</code>, not any kind of iterable. And if you changed the precedence so it meant <code>[(*range(4))[2]]</code>… I can <i>maybe</i> see how that could give you <code>[[2]]</code>, but not <code>[2]</code>.</span>
<span class="comment-copy">Meanwhile, why are you even trying to use splatting here? Why not just <code>[range(4)[2]]</code>, or <code>[list(zip([1,2,3], [4,5,6]))[2]]</code>, which already do what you seem to want? For that matter, why are you building single-element lists instead of just building the elements themselves?</span>
<span class="comment-copy">One last thing: there's no comprehension in any of your examples. These are just normal list displays. A comprehension is when you put a <code>for</code> clause (or rather 1 or more <code>for</code> clauses and 0 or more <code>if</code> clauses) inside the brackets to build a list by looping over another iterable.</span>
<span class="comment-copy">@abarnert thanks for the clarification. Both of the snippets were merly ment as examples for the underlying principle.</span>
<span class="comment-copy">If you’re interested, you should read the two accepted PEPs that expanded on unpacking between Python 2.3 and today, and the linked threads on the python-ideas and -dev lists. And then, if you can come up with well-defined syntax and semantics (and useful real-life examples) for a further extension that would make the language even better, you can even suggest it yourself on -ideas. The worst-case scenario is that Guido or another core dev tells you why it doesn’t fit well with Python (which, for me, has been a very useful learning experience a couple times…).</span>
<span class="comment-copy">Using an unpacking at all just to select one element seems pointless, though.</span>
<span class="comment-copy">True. I guess I'll add another bullet point.</span>
