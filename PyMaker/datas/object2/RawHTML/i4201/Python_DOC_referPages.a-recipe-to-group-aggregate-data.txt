<div class="post-text" itemprop="text">
<p>I have some data stored in a list that I would like to group based on a value.</p>
<p>For example, if my data is</p>
<pre><code>data = [(1, 'a'), (2, 'x'), (1, 'b')]
</code></pre>
<p>and I want to group it by the first value in each tuple to get</p>
<pre><code>result = [(1, 'ab'), (2, 'x')]
</code></pre>
<p>how would I go about it?</p>
<p>More generally, what's the recommended way to group data in python? Is there a recipe that can help me?</p>
</div>
<div class="post-text" itemprop="text">
<p>The go-to data structure to use for all kinds of grouping is the <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow noreferrer">dict</a>. The idea is to use something that uniquely identifies a group as the dict's keys, and store all values that belong to the same group under the same key.</p>
<p>As an example, your data could be stored in a dict like this:</p>
<pre><code>{1: ['a', 'b'],
 2: ['x']}
</code></pre>
<p>The integer that you're using to group the values is used as the dict key, and the values are aggregated in a list.</p>
<p>The reason why we're using a dict is because it can map keys to values in constant O(1) time. This makes the grouping process very efficient and also very easy. The general structure of the code will always be the same for all kinds of grouping tasks: You iterate over your data and gradually fill a dict with grouped values. Using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> instead of a regular dict makes the whole process even easier, because we don't have to worry about initializing the dict with empty lists.</p>
<pre><code>import collections

groupdict = collections.defaultdict(list)
for value in data:
    group = value[0]
    value = value[1]
    groupdict[group].append(value)

# result:
# {1: ['a', 'b'],
#  2: ['x']}
</code></pre>
<p>Once the data is grouped, all that's left is to convert the dict to your desired output format:</p>
<pre><code>result = [(key, ''.join(values)) for key, values in groupdict.items()]
# result: [(1, 'ab'), (2, 'x')]
</code></pre>
<hr/>
<h1><strong>The Grouping Recipe</strong></h1>
<p>The following section will provide recipes for different kinds of inputs and outputs, and show how to group by various things. The basis for everything is the following snippet:</p>
<pre><code>import collections

groupdict = collections.defaultdict(list)
for value in data:  # input
    group = ???  # group identifier
    value = ???  # value to add to the group
    groupdict[group].append(value)

result = groupdict  # output
</code></pre>
<p>Each of the commented lines can/has to be customized depending on your use case.</p>
<h1>Input</h1>
<p>The format of your input data dictates how you iterate over it.</p>
<p>In this section, we're customizing the <code>for value in data:</code> line of the recipe.</p>
<ul>
<li><h2>A list of values</h2>
<p>More often than not, all the values are stored in a flat list:</p>
<pre><code>data = [value1, value2, value3, ...]
</code></pre>
<p>In this case we simply iterate over the list with a <code>for</code> loop:</p>
<pre><code>for value in data:
</code></pre></li>
<li><h2>Multiple lists</h2>
<p>If you have multiple lists with each list holding the value of a different attribute like</p>
<pre><code>firstnames = [firstname1, firstname2, ...]
middlenames = [middlename1, middlename2, ...]
lastnames = [lastname1, lastname2, ...]
</code></pre>
<p>use the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> function to iterate over all lists simultaneously:</p>
<pre><code>for value in zip(firstnames, middlenames, lastnames):
</code></pre>
<p>This will make <code>value</code> a tuple of <code>(firstname, middlename, lastname)</code>.</p></li>
<li><h2>Multiple dicts or a list of dicts</h2>
<p>If you want to combine multiple dicts like</p>
<pre><code>dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 5}
</code></pre>
<p>First put them all in a list:</p>
<pre><code>dicts = [dict1, dict2]
</code></pre>
<p>And then use two nested loops to iterate over all <code>(key, value)</code> pairs:</p>
<pre><code>for dict_ in dicts:
    for value in dict_.items():
</code></pre>
<p>In this case, the <code>value</code> variable will take the form of a 2-element tuple like <code>('a', 1)</code> or <code>('b', 2)</code>.</p></li>
</ul>
<h1>Grouping</h1>
<p>Here we'll cover various ways to extract group identifiers from your data.</p>
<p>In this section, we're customizing the <code>group = ???</code> line of the recipe.</p>
<ul>
<li><h2>Grouping by a list/tuple/dict element</h2>
<p>If your values are lists or tuples like <code>(attr1, attr2, attr3, ...)</code> and you want to group them by the nth element:</p>
<pre><code>group = value[n]
</code></pre>
<p>The syntax is the same for dicts, so if you have values like <code>{'firstname': 'foo', 'lastname': 'bar'}</code> and you want to group by the first name:</p>
<pre><code>group = value['firstname']
</code></pre></li>
<li><h2>Grouping by an attribute</h2>
<p>If your values are objects like <code>datetime.date(2018, 5, 27)</code> and you want to group them by an attribute, like <code>year</code>:</p>
<pre><code>group = value.year
</code></pre></li>
<li><h2>Grouping by a key function</h2>
<p>Sometimes you have a function that returns a value's group when it's called. For example, you could use the <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow noreferrer"><code>len</code></a> function to group values by their length:</p>
<pre><code>group = len(value)
</code></pre></li>
<li><h2>Grouping by multiple values</h2>
<p>If you wish to group your data by more than a single value, you can use a <a href="https://docs.python.org/3/library/functions.html#func-tuple" rel="nofollow noreferrer">tuple</a> as the group identifier. For example, to group strings by their first letter <em>and</em> their length:</p>
<pre><code>group = (value[0], len(value))
</code></pre></li>
<li><h2>Grouping by something unhashable</h2>
<p>Because dict keys must be <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer">hashable</a>, you will run into problems if you try to group by something that can't be hashed. In such a case, you have to find a way to convert the unhashable value to a hashable representation.</p>
<ol>
<li><p><strong><a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow noreferrer">sets</a></strong>: Convert sets to <a href="https://docs.python.org/3/library/functions.html#func-frozenset" rel="nofollow noreferrer">frozensets</a>, which are hashable:</p>
<pre><code>group = frozenset(group)
</code></pre></li>
<li><p><strong><a href="https://docs.python.org/3/library/functions.html#func-dict" rel="nofollow noreferrer">dicts</a></strong>: Dicts can be represented as sorted <code>(key, value)</code> tuples:</p>
<pre><code>group = tuple(sorted(group.items()))
</code></pre></li>
</ol></li>
</ul>
<h1>Modifying the aggregated values</h1>
<p>Sometimes you will want to modify the values you're grouping. For example, if you're grouping tuples like <code>(1, 'a')</code> and <code>(1, 'b')</code> by the first element, you might want to remove the first element from each tuple to get a result like <code>{1: ['a', 'b']}</code> rather than <code>{1: [(1, 'a'), (1, 'b')]}</code>.</p>
<p>In this section, we're customizing the <code>value = ???</code> line of the recipe.</p>
<ul>
<li><h2>No change</h2>
<p>If you don't want to change the value in any way, simple delete the <code>value = ???</code> line from your code.</p></li>
<li><h2>Keeping only a single list/tuple/dict element</h2>
<p>If your values are lists like <code>[1, 'a']</code> and you only want to keep the <code>'a'</code>:</p>
<pre><code>value = value[1]
</code></pre>
<p>Or if they're dicts like <code>{'firstname': 'foo', 'lastname': 'bar'}</code> and you only want to keep the first name:    </p>
<pre><code>value = value['firstname']
</code></pre></li>
<li><h2>Removing the first list/tuple element</h2>
<p>If your values are lists like <code>[1, 'a', 'foo']</code> and <code>[1, 'b', 'bar']</code> and you want to discard the first element of each tuple to get a group like <code>[['a', 'foo], ['b', 'bar']]</code>, use the slicing syntax:</p>
<pre><code>value = value[1:]
</code></pre></li>
<li><h2>Removing/Keeping arbitrary list/tuple/dict elements</h2>
<p>If your values are lists like <code>['foo', 'bar', 'baz']</code> or dicts like <code>{'firstname': 'foo', 'middlename': 'bar', 'lastname': 'baz'}</code> and you want delete or keep only some of these elements, start by creating a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a> of elements you want to keep or delete. For example:</p>
<pre><code>indices_to_keep = {0, 2}
keys_to_delete = {'firstname', 'middlename'}
</code></pre>
<p>Then choose the appropriate snippet from this list:</p>
<ol>
<li><strong>To keep list elements:</strong> <code>value = [val for i, val in enumerate(value) if i in indices_to_keep]</code></li>
<li><strong>To delete list elements:</strong> <code>value = [val for i, val in enumerate(value) if i not in indices_to_delete]</code></li>
<li><strong>To keep dict elements:</strong> <code>value = {key: val for key, val in value.items() if key in keys_to_keep]</code></li>
<li><strong>To delete dict elements:</strong> <code>value = {key: val for key, val in value.items() if key not in keys_to_delete]</code></li>
</ol></li>
</ul>
<h1>Output</h1>
<p>Once the grouping is complete, we have a <code>defaultdict</code> filled with lists. But the desired result isn't always a (default)dict.</p>
<p>In this section, we're customizing the <code>result = groupdict</code> line of the recipe.</p>
<ul>
<li><h2>A regular dict</h2>
<p>To convert the defaultdict to a regular dict, simply call the <a href="https://docs.python.org/3/library/functions.html#func-dict" rel="nofollow noreferrer"><code>dict</code></a> constructor on it:</p>
<pre><code>result = dict(groupdict)
</code></pre></li>
<li><h2>A list of <code>(group, value)</code> pairs</h2>
<p>To get a result like <code>[(group1, value1), (group1, value2), (group2, value3)]</code> from the dict <code>{group1: [value1, value2], group2: [value3]}</code>, use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>result = [(group, value) for group, values in groupdict.items()
                           for value in values]
</code></pre></li>
<li><h2>A nested list of just values</h2>
<p>To get a result like <code>[[value1, value2], [value3]]</code> from the dict <code>{group1: [value1, value2], group2: [value3]}</code>, use <a href="https://docs.python.org/3/library/stdtypes.html#dict.values" rel="nofollow noreferrer"><code>dict.values</code></a>:</p>
<pre><code>result = list(groupdict.values())
</code></pre></li>
<li><h2>A flat list of just values</h2>
<p>To get a result like <code>[value1, value2, value3]</code> from the dict <code>{group1: [value1, value2], group2: [value3]}</code>, flatten the dict with a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>result = [value for values in groupdict.values() for value in values]
</code></pre></li>
<li><h2>Flattening iterable values</h2>
<p>If your values are lists or other iterables like</p>
<pre><code>groupdict = {group1: [[list1_value1, list1_value2], [list2_value1]]}
</code></pre>
<p>and you want a flattened result like</p>
<pre><code>result = {group1: [list1_value1, list1_value2, list2_value1]}
</code></pre>
<p>you have two options:</p>
<ol>
<li><p>Flatten the lists with a <a href="https://www.python.org/dev/peps/pep-0274/" rel="nofollow noreferrer">dict comprehension</a>:</p>
<pre><code>result = {group: [x for iterable in values for x in iterable]
                          for group, values in groupdict.items()}
</code></pre></li>
<li><p>Avoid creating a list of iterables in the first place, by using <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer"><code>list.extend</code></a> instead of <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer"><code>list.append</code></a>. In other words, change</p>
<pre><code>groupdict[group].append(value)
</code></pre>
<p>to</p>
<pre><code>groupdict[group].extend(value)
</code></pre>
<p>And then just set <code>result = groupdict</code>.</p></li>
</ol></li>
<li><h2>A sorted list</h2>
<p>Dicts are unordered data structures. If you iterate over a dict, you never know in which order its elements will be listed. If you don't care about the order, you can use the recipes shown above. But if you <em>do</em> care about the order, you have to sort the output accordingly.</p>
<p>I'll use the following dict to demonstrate how to sort your output in various ways:</p>
<pre><code>groupdict = {'abc': [1], 'xy': [2, 5]}
</code></pre>
<p>Keep in mind that this is a bit of a meta-recipe that may need to be combined with other parts of this answer to get exactly the output you want. The general idea is to sort the dictionary keys before using them to extract the values from the dict:</p>
<pre><code>groups = sorted(groupdict.keys())
# groups = ['abc', 'xy']
</code></pre>
<p>Keep in mind that <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted</code></a> accepts a key function in case you want to customize the sort order. For example, if the dict keys are strings and you want to sort them by length:</p>
<pre><code>groups = sorted(groupdict.keys(), key=len)
# groups = ['xy', 'abc']
</code></pre>
<p>Once you've sorted the keys, use them to extract the values from the dict in the correct order:</p>
<pre><code># groups = ['abc', 'xy']
result = [groupdict[group] for group in groups]
# result = [[1], [2, 5]]
</code></pre>
<p>Remember that this can be combined with other parts of this answer to get different kinds of output. For example, if you want to keep the group identifiers:</p>
<pre><code># groups = ['abc', 'xy']
result = [(group, groupdict[group]) for group in groups]
# result = [('abc', [1]), ('xy', [2, 5])]
</code></pre>
<p>For your convenience, here are some commonly used sort orders:</p>
<ol>
<li><p><strong>Sort by number of values per group:</strong> </p>
<pre><code> groups = sorted(groudict.keys(), key=lambda group: len(groupdict[group]))
 result = [groupdict[group] for group in groups]
 # result = [[2, 5], [1]]
</code></pre></li>
</ol></li>
<li><h2>Counting the number of values in each group</h2>
<p>To count the number of elements associated with each group, use the <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow noreferrer"><code>len</code></a> function:</p>
<pre><code>result = {group: len(values) for group, values in groupdict.items()}
</code></pre>
<p>If you want to count the number of <strong>distinct</strong> elements, use <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow noreferrer"><code>set</code></a> to eliminate duplicates:</p>
<pre><code>result = {group: len(set(values)) for group, values in groupdict.items()}
</code></pre></li>
</ul>
<hr/>
<h1><strong>An example</strong></h1>
<p>To demonstrate how to piece together a working solution from this recipe, let's try to turn an input of</p>
<pre><code>data = [["A",0], ["B",1], ["C",0], ["D",2], ["E",2]]
</code></pre>
<p>into</p>
<pre><code>result = [["A", "C"], ["B"], ["D", "E"]]
</code></pre>
<p>In other words, we're grouping lists by their 2nd element.</p>
<p>The first two lines of the recipe are always the same, so let's start by copying those:</p>
<pre><code>import collections

groupdict = collections.defaultdict(list)
</code></pre>
<p>Now we have to find out how to loop over the input. Since our input is a simple list of values, a normal <code>for</code> loop will suffice:</p>
<pre><code>for value in data:
</code></pre>
<p>Next we have to extract the group identifier from the value. We're grouping by the 2nd list element, so we use indexing:</p>
<pre><code>    group = value[1]
</code></pre>
<p>The next step is to transform the value. Since we only want to keep the first element of each list, we once again use list indexing:</p>
<pre><code>    value = value[0]
</code></pre>
<p>Finally, we have to figure out how to turn the dict we generated into a list. What we want is a list of values, without the groups. We consult the <strong>Output</strong> section of the recipe to find the appropriate dict flattening snippet:</p>
<pre><code>result = list(groupdict.values())
</code></pre>
<p>Et voilà:</p>
<pre><code>data = [["A",0], ["B",1], ["C",0], ["D",2], ["E",2]]

import collections

groupdict = collections.defaultdict(list)
for value in data:
    group = value[1]
    value = value[0]
    groupdict[group].append(value)

result = list(groupdict.values())
# result: [["A", "C"], ["B"], ["D", "E"]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>itertools.groupby</h1>
<p>There is a general purpose recipe in <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> and it's <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby()</code></a>.</p>
<p>A schema of this recipe can be given in this form:</p>
<pre><code>[(k, aggregate(g)) for k, g in groupby(sorted(data, key=extractKey), extractKey)]
</code></pre>
<p>The two relevant parts to change in the recipe are:</p>
<ul>
<li><p>define the grouping key (<strong>extractKey</strong>): in this case getting the first item of the tuple:</p>
<p><code>lambda x: x[0]</code></p></li>
<li><p>aggregate grouped results (if needed) (<strong>aggregate</strong>): <code>g</code> contains all the matching tuples for each key <code>k</code> (e.g. <code>(1, 'a')</code>, <code>(1, 'b')</code> for key <code>1</code>, and <code>(2, 'x')</code> for key <code>2</code>), we want to take only the second item of the tuple and concatenate all of those in one string:</p>
<p><code>''.join(x[1] for x in g)</code></p></li>
</ul>
<p>Example:</p>
<pre><code>from itertools import groupby

extractKey = lambda x: x[0]
aggregate = lambda g: ''.join(x[1] for x in g)

[(k, aggregate(g)) for k, g in groupby(sorted(data, key=extractKey), extractKey)]
# [(1, 'ab'), (2, 'x')]
</code></pre>
<p>Sometimes, <code>extractKey</code>, <code>aggregate</code>, or both can be inlined into a one-liner (we omit sort key too, as that's redundant for <em>this</em> example):</p>
<pre><code>[(k, ''.join(x[1] for x in g)) for k, g in groupby(sorted(data), lambda x: x[0])]
# [(1, 'ab'), (2, 'x')]
</code></pre>
<h1>Pros and cons</h1>
<p>Comparing this recipe with the recipe using <code>defaultdict</code> there are pros and cons in both cases.</p>
<p><code>groupby()</code> tends to be slower (about twice as slower in my tests) than the <code>defaultdict</code> recipe.</p>
<p>On the other hand, <code>groupby()</code> has advantages in the memory constrained case where the values are being produced on the fly; you can process the groups in a streaming fashion, without storing them; <code>defaultdict</code> will require the memory to store <em>all</em> of them.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Pandas groupby</h2>
<p>This isn't a recipe as such, but an intuitive and flexible way to group data using a function. In this case, the function is <code>str.join</code>.</p>
<pre><code>import pandas as pd

data = [(1, 'a'), (2, 'x'), (1, 'b')]

# create dataframe from list of tuples
df = pd.DataFrame(data)

# group by first item and apply str.join
grp = df.groupby(0)[1].apply(''.join)

# create list of tuples from index and value
res = list(zip(grp.index, grp))

print(res)

[(1, 'ab'), (2, 'x')]
</code></pre>
<p><strong>Advantages</strong></p>
<ul>
<li>Fits nicely into workflows that only require <code>list</code> output at the end of a sequence of vectorisable steps.</li>
<li>Easily adaptable by changing <code>''.join</code> to <code>list</code> or other reducing function.</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
<li>Overkill for an isolated task: requires <code>list</code> -&gt; <code>pd.DataFrame</code> -&gt; <code>list</code> conversion.</li>
<li>Introduces dependency on a 3rd party library.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<h2>Multiple-parse list comprehension</h2>
<p>This is inefficient compared to the <a href="https://stackoverflow.com/a/50086453/9209546"><code>dict</code></a> and <a href="https://stackoverflow.com/a/50086821/9209546"><code>groupby</code></a> solutions.</p>
<p>However, for <em>small lists where performance is not a concern</em>, you can perform a list comprehension which parses the list for each unique identifier.</p>
<pre><code>res = [(i, ''.join([j[1] for j in data if j[0] == i]))
       for i in set(list(zip(*data))[0])]

[(1, 'ab'), (2, 'x')]
</code></pre>
<p>The solution can be split into 2 parts:</p>
<ol>
<li><code>set(list(zip(*data))[0])</code> extracts the unique set of identifiers which we iterate via a <code>for</code> loop within the list comprehension.</li>
<li><code>(i, ''.join([j[1] for j in data if j[0] == i]))</code> applies the logic we require for the desired output.</li>
</ol>
</div>
<span class="comment-copy">Thats great effort consolidation a-lot of possible grouping use cases. +1.  Also it would be really nice if you can provide a brief comparison of using <code>itertools.groupby</code> vs the recipe you proposed.</span>
<span class="comment-copy">@bro-grammer Thanks for the feedback! I'm not sure if I want to make the answer even longer than it already is by getting into a "defaultdict vs groupby" discussion. I'll think about it.</span>
<span class="comment-copy">Surprised not to see a pandas option here as well, you should add one in just for completeness.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ I'll let a pandas expert handle that. I don't know pandas nearly well enough to write an answer as comprehensive as this one - and the point of the self-answered question was to cover as many common use cases as possible, after all.</span>
