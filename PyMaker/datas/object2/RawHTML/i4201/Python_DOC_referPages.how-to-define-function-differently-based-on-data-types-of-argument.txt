<div class="post-text" itemprop="text">
<p>I am trying to define a function that works differently based on given argument. </p>
<p>Below is a predicate filter, which is for given <strong>string</strong>
 type argument, it tags part-of-speeches of each word then returns that is adjective, adverb or verb. </p>
<p>But sometimes, the given argument could be a <strong>list</strong> in my entire system pipelines, of course, I could define another one, however I don't want to define another function which exactly works the same.</p>
<p>I could do :</p>
<blockquote>
<p>if type(sentence) == list -&gt; blahblahblah and </p>
<p>if type(sentence) == string -&gt; blahblahblah.</p>
</blockquote>
<p>This is good, but I just wonder there would be another better way to do this.</p>
<p>Any advice?     </p>
<pre><code>#defines predicate filter 

def pred_fl(sentence): 
    import nltk 

    ## Predicate Tags : 12 tags 
    tag_pred = ['JJ', 'JJR', 'JJS','RB','RBR', 'RBS', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ']

    ## Noun Tags : 4 tags 
    tag_noun = ['NN','NNS','NNP','NNPS']

    # Pos tagging the input from the User_reply 
    tagged = nltk.pos_tag(sentence.split())

    reply_pred = []

    for i in range(len(tagged)):
        if tagged[i][1] in tag_pred:
            reply_pred.append(tagged[i][0])

    return reply_pred
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is exactly the kind of thing that both overloaded methods and generic functions are made for.</p>
<p>Here's how to use <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>singledispatch</code></a> to implement it with generic functions:</p>
<pre><code>@functools.singledispatch
def helper(arg):
    raise TypeError("I expected a type I know about, not some kind of Spanish Inquisition")

@helper.register(list)
def _(arg):
    # do listy stuff here

@helper.register(str)
def _(arg):
    # do stringy stuff here

def pred_fl(sentence): 
    # do setup that applies to all types here
    stuff = helper(sentence)
    # do stuff with stuff here
</code></pre>
<hr/>
<p>Of course I'm assuming that a bunch of your "stuff" is the same for the two cases, and it's a small, refactorable part of your "stuff" that has to differ. </p>
<p>If the whole thing ends up being different, then you really should have two functions. </p>
<p>If, on the other hand, the small part that's different is trivial—or if it's nearly impossible to factor out because it's closely coupled to everything else you're doing—you probably do want type-switching. But by checking <code>isinstance(sentence, str)</code>, not checking <code>type(sentence)</code>:</p>
<pre><code>def pred_fl(sentence):
    # do setup that applies to all types here
    if isinstance(sentence, list):
        # do listy stuff that mutates a whole slew of local variables
    elif isinstance(sentence, str):
        # do stringy stuff that depends on a bunch of local state
    # do final stuff here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a matter of style in my opinion, but what I would suggest is assessing the input at the top of the function, and then the rest of the function should be able to assume the same type. Something like..</p>
<pre><code>def pred_fl(sentence): 
    import nltk

    if isinstance(sentence, str):
        word_list = sentence.split()
    elif isinstance(sentence, list):
        word_list = sentence
    else:
        raise Exception("unexpected input: %s", sentence)

    ## Predicate Tags : 12 tags 
    tag_pred = ['JJ', 'JJR', 'JJS','RB','RBR', 'RBS', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ']

    ## Noun Tags : 4 tags 
    tag_noun = ['NN','NNS','NNP','NNPS']

    # Pos tagging the input from the User_reply 
    tagged = nltk.pos_tag(word_list)

    reply_pred = []

    for i in range(len(tagged)):
        if tagged[i][1] in tag_pred:
            reply_pred.append(tagged[i][0])

    return reply_pred
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I assume your filer function just process <code>String</code> type so far. and you have some sentence like:</p>
<blockquote>
<p>"hello girl! How do you do?"</p>
</blockquote>
<p>But there are also another data input with list like:</p>
<blockquote>
<p>["hello", "girl", "how", "do", "you", "do?"]</p>
</blockquote>
<p>and if I assume right. how about this, just simple covert the list to string which you have already implement the function can process this.</p>
<pre><code>sentence = sentence if isinstance(sentence, str) else ' '.join(sentence)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want your function to behave differently based on the type of the sentence argument, one way to accomplish this is as follows:</p>
<p><code>
def pred_fl(sentence):
    if isinstance(sentence, str):
         ...
    elif isinstance(sentence, list):
         ...
    else:
         ...
</code></p>
</div>
<span class="comment-copy">Can you show what exactly you want to do differently for each case?</span>
<span class="comment-copy">Is your <code>pred_fl</code> equal your <code>blahblahblah</code>?</span>
<span class="comment-copy">I would argue this isn't very pythonic. It's neat, but not simpler than an if-else.</span>
<span class="comment-copy">@PeterKirby Whether it's more or less Pythonic than if-else  ultimately comes down to how decoupled the generic "stuff" is from everything else. Which is impossible to guess from the OP's toy example. But there are definitely uses for both designs (not to mention for a subclass-based design)—if not, PEP 443 would never have been accepted (and then used in the stdlib).</span>
<span class="comment-copy">I'm with @PeterKirby on this one, pulling in <code>singledispatch</code> here seems overkill, a bit like using <code>reduce</code> to add three numbers.</span>
<span class="comment-copy">@PaulPanzer It looks like overkill because with the OP's toy example—where he doesn't actually do <i>anything at all</i> except "blahlablahblah", of course it <i>is</i> overkill. But with his real program? I have no idea. That's why I suggested two different ways to do it, and tried to explain how to choose between them. (As for which one to explain first—well, this is the one that directly answers the question as asked, so I figured when there's not enough information to go on, err on the side of assuming the OP knows what he's asking…)</span>
