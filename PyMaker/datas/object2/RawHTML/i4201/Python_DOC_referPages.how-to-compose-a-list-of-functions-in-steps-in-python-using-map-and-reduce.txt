<div class="post-text" itemprop="text">
<p>Given a list of functions (functions) and an integer n, I'm trying to figure out a way to compose them stepwise, and return a list of each stepwise result as follows:</p>
<pre><code>compose_step([lambda x: x+3, lambda x: x+5, lambda x: x+1], 8) --&gt; [8, 11, 16, 17]
</code></pre>
<p>So, as of now I have figured out how to compose a list of functions and return the result as follows:</p>
<pre><code>def compose(functions, n):
    def compose2(f,g):
        return lambda x: f(g(x))
    composedFunction = functools.reduce(compose2, functions, lambda x: x)
    return composedFunction(n)
</code></pre>
<p>However, I'm extremely confused how to keep track of each step and return it as a list. I'm assuming that I need to use map somehow in order to map each stepwise piece to the list. I have also come up with a method to apply all functions in the list to n as such:</p>
<pre><code>def apply_all_functions(functions, n):
    answerList = list(map(methodcaller('__call__', n), functions)))
    return answerList
</code></pre>
<p>I was thinking of somehow using the composeFunction function to compose a new list of stepwise functions, all the way up until the fully composed function, and then using this as my new list for the apply_all_functions in order to achieve the desired result. But currently, I'm pretty stumped. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a> with a composition function</p>
<pre><code>from itertools import accumulate

def compose(f, g):
    return lambda x: f(g(x))

funcs = [lambda x: x, lambda x: x+3, lambda x: x+5, lambda x: x+1]

print([f(8) for f in accumulate(funcs, compose)])
# [8, 11, 16, 17]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools.accumulate</code> is the way to go, but if you're wondering how you could do it on your own, here's one way</p>
<pre><code>def apply_all (x, f = None, *fs):
  if f is None:
    return []
  else:
    next = f (x)
    return [ next ] + apply_all(next, *fs)

funcs = \
  [ lambda x: x
  , lambda x: x+3
  , lambda x: x+5
  , lambda x: x+1
  ]

print(apply_all(8, *funcs))
# [ 8, 11, 16, 17 ]
</code></pre>
<p>If you need the form in your original question</p>
<pre><code>def apply_all (fs, x):
  if not fs:
    return []
  else:
    next = fs[0](x)
    return [ next ] + apply_all(fs[1:], next)

funcs = \
  [ lambda x: x
  , lambda x: x+3
  , lambda x: x+5
  , lambda x: x+1
  ]

print(apply_all(funcs, 8))
# [ 8, 11, 16, 17 ]
</code></pre>
<p>The above form operates on <code>fs[0]</code> and <code>fs[1:]</code> which shows this can be expressed as a vanilla <code>reduce</code></p>
<pre><code>from functools import reduce

def apply_all (fs, x):
  def reducer (acc, f):
    (seq, x) = acc
    next = f (x)
    return (seq + [next], next)
  return reduce(reducer, fs, ([], x)) [0]

funcs = \
  [ lambda x: x
  , lambda x: x+3
  , lambda x: x+5
  , lambda x: x+1
  ]

print(apply_all(funcs, 8))
# [ 8, 11, 16, 17 ]
</code></pre>
</div>
<span class="comment-copy">Can you explain more what is your aim here? I don't understand what is your input and expected output.</span>
