<div class="post-text" itemprop="text">
<p>I have 2 coroutines (<code>co_A</code>, <code>co_B</code>) in different classes (<code>class_A</code>, <code>class_B</code>) that are called regularly by a scheduler.
At some time during the execution <code>co_B</code> needs a result that <code>co_A</code> is calculating during its run.</p>
<p>What I would like to do is something like this:</p>
<pre><code>class class_A:
    async def co_A(self):

        # execute time consuming code

        # set result that co_B needs
        self.set_result(result)

        # execute more time consuming code

class class_B:
    async def co_B(self):

        # execute time consuming code

        # wait for result from co_A
        result = await class_A_instance.get_result()

        # execute more time consuming code
</code></pre>
<p>My approach is to have an empty Future in class_A that gets filled during co_A and in co_B wait in a loop until the Future is set:</p>
<pre><code>class class_A:
    async def prepare(self):
        self.fut = asyncio.Future()

    async def co_A(self):

        # execute time consuming code

        # set result that co_B needs
        self.fut.set_result(result)

        # execute more time consuming code

class class_B:   
    async def co_B(self):

        # execute time consuming code

        # wait for result from co_A
        while not class_A_instance.fut.done():
            await asyncio.sleep(0)

        result = class_A_instance.fut.result()

        # execute more time consuming code
</code></pre>
<p>Is there a better way to do this without having to sleep in a loop until <code>co_A</code> has calculated the result?</p>
</div>
<div class="post-text" itemprop="text">
<p>Whole idea of futures is that you can await for it just like for coroutines, tasks, etc.</p>
<pre><code>class class_B:   
    async def co_B(self):

        # execute time consuming code

        # wait for result from co_A
        result = await class_A_instance.fut

        # execute more time consuming code
</code></pre>
<p>See section "Things a coroutine can do" <a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use <a href="https://docs.python.org/3/library/asyncio-sync.html#event" rel="nofollow noreferrer"><code>Event</code></a> class to synchronize coroutines. @Mikhail approach is 100% correct but doesn't address that you would like to get notified in the middle of <code>co_A</code>.</p>
<pre><code>class A:
    def __init__(self):
        self.partially_ready = asyncio.Event()

    async def prepare(self):
        self.partially_ready.clear()

    async def co_A(self):   
        # execute time consuming code

        # set result that co_B needs
        self.partially_ready.set()
        # execute more time consuming code


class class_B:   
    async def co_B(self):

        # execute time consuming code

        # wait for result from co_A
        await A_instance.partially_ready.wait()
        # here A_instance finished some part you would like to wait
</code></pre>
</div>
<span class="comment-copy">This approach is correct, but it assumes that co_A is already scheduled.</span>
<span class="comment-copy">@kwarunek The same assumption is present in the OP's code (the version with the <code>while</code> loop). The nice thing about this solution is that it's more lightweight than an <code>asyncio.Event</code>, and also that it allows transmitting a payload object (whereas an <code>Event</code> only carries a Boolean flag).</span>
