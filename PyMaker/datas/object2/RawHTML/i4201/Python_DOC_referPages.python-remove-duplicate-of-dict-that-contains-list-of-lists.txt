<div class="post-text" itemprop="text">
<p>suppose <code>training_data</code> is a dict that contains a list of lists
such as <code>{1: [[1, 2], [1, 3], [1, 2, 5]], 2: [[1], [5], [1, 6]], 3: [[7], [5]]}</code></p>
<p>I want to merge each value in <code>training_data</code> and then flatten it once to a list so that it will become <code>[[1,2,3,5],[1,5,6],[7,5]]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you only need <strong>unique elements from the list without maintaining the order of elements in initial list</strong>, then you may use <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow noreferrer"><code>set</code></a> here with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a>. You may use these with <em>list comprehension</em> to achieve your desired list as:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; my_dict = {1: [[1, 2], [1, 3], [1, 2, 5]], 2: [[1], [5], [1, 6]], 3: [[7], [5]]}

&gt;&gt;&gt; [list(set(chain.from_iterable(v))) for v in my_dict.values()]
[[1, 2, 3, 5], [1, 5, 6], [5, 7]]
</code></pre>
<p><strong>Note:</strong> since dictionaries are unordered in Python &lt;3.6, the order of sub-lists in the resultant lists might differ.</p>
<p>For preserving the order of elements in the sublist while merging, take a look at: <em><a href="https://stackoverflow.com/q/30055830/2063361">Pythonic way to merge two overlapping lists, preserving order</a></em></p>
</div>
<div class="post-text" itemprop="text">
<p>you can achieve the same result with a one-line comprehension, chaining and using a set + sort</p>
<pre><code>import itertools

d = {1: [[1, 2], [1, 3], [1, 2, 5]], 2: [[1], [5], [1, 6]], 3: [[7], [5]]}

result = [sorted(set(itertools.chain.from_iterable(v))) for v in d.values()]

print(result)
</code></pre>
<p>outputs:</p>
<pre><code>[[1, 2, 3, 5], [1, 5, 6], [5, 7]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found a possible solution, but could anyone tell me if there's a simpler way?</p>
<pre><code>training_data = list(chain.from_iterable([transaction for _, transaction in training_data.items()]))

new_training_data = []
for transaction in training_data:
    t = set()
    for i in transaction:
        t = t.union(i)
    new_training_data.append(list(t))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>set</code> with list comprehension:</p>
<pre><code>training_data = {1: [[1, 2], [1, 3], [1, 2, 5]], 2: [[1], [5], [1, 6]], 3: [[7], [5]]}

resultList = [sorted(set(elem for subList in training_data[key] for elem in subList)) for key in training_data.keys()]
print(resultList)
</code></pre>
<p>Output:</p>
<pre><code>[[1, 2, 3, 5], [1, 5, 6], [5, 7]]
</code></pre>
</div>
<span class="comment-copy">You can replace <code>[transaction for _, transaction in training_data.items()]</code> with <code>training_data.values()</code>.</span>
<span class="comment-copy">You don't need to convert the chain call to a list. The union code can be shortened to <code>set().union(*transaction)</code>. Then the whole thing can be turned into one list comprehension.</span>
