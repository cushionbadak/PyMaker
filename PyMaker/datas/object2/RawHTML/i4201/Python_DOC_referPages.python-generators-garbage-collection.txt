<div class="post-text" itemprop="text">
<p>I think my question is related to <a href="https://stackoverflow.com/questions/15490127/will-a-python-generator-be-garbage-collected-if-it-will-not-be-used-any-more-but">this</a>, but not exactly similar. Consider this code:</p>
<pre><code>def countdown(n):
    try:
        while n &gt; 0:
            yield n
            n -= 1
    finally:
        print('In the finally block')

def main():
    for n in countdown(10):
        if n == 5:
            break
        print('Counting... ', n)
    print('Finished counting')

main()
</code></pre>
<p>The output of this code is:</p>
<pre><code>Counting...  10      
Counting...  9       
Counting...  8       
Counting...  7       
Counting...  6       
In the finally block 
Finished counting  
</code></pre>
<p>Is it guaranteed that the line "In the finally block" is going to be printed before "Finished counting"? Or is this because of cPython implementation detail that an object will be garbage collected when the reference count reaches 0.</p>
<p>Also I am curious on how <code>finally</code> block of the <code>countdown</code> generator is executed? e.g. if I change the code of <code>main</code> to</p>
<pre><code>def main():
    c = countdown(10)
    for n in c:
        if n == 5:
            break
        print('Counting... ', n)
    print('Finished counting')
</code></pre>
<p>then I do see <code>Finished counting</code> printed before <code>In the finally block</code>. How does the garbage collector directly go to the <code>finally</code> block? I think I have always taken <code>try/except/finally</code> on its face value, but thinking in the context of generators is making me think twice about it. </p>
</div>
<div class="post-text" itemprop="text">
<p>You are, as you expected, relying on implementation-specific behavior of CPython reference counting.<sup>1</sup></p>
<p>In fact, if you run this code in, say, PyPy, the output will usually be:</p>
<pre><code>Counting...  10
Counting...  9
Counting...  8
Counting...  7
Counting...  6
Finished counting
In the finally block
</code></pre>
<p>And if you run it in an interactive PyPy session, that last line may come many lines later, or even only when you finally exit.</p>
<hr/>
<p>If you look at how generators are implemented, they have methods roughly like this:</p>
<pre><code>def __del__(self):
    self.close()
def close(self):
    try:
        self.raise(GeneratorExit)
    except GeneratorExit:
        pass
</code></pre>
<p>CPython deletes objects immediately when the reference count becomes zero (it also has a garbage collector to break up cyclic references, but that isn't relevant here). As soon as the generator goes out of scope, it gets deleted, so it gets closed, so it raises a <code>GeneratorExit</code> into the generator frame and resumes it. And of course there's no handler for the <code>GeneratorExit</code>, so the <code>finally</code> clause gets executed and control passes up the stack, where the exception is swallowed.</p>
<p>In PyPy, which uses a hybrid garbage collector, the generator doesn't get deleted until the next time the GC decides to scan. And in an interactive session, with low memory pressure, that could be as late as exit time. But once it does, the same thing happens.</p>
<p>You can see this by handling the <code>GeneratorExit</code> explicitly:</p>
<pre><code>def countdown(n):
    try:
        while n &gt; 0:
            yield n
            n -= 1
    except GeneratorExit:
        print('Exit!')
        raise
    finally:
        print('In the finally block')
</code></pre>
<p>(If you leave the <code>raise</code> off, you'll get the same results for only slightly different reasons.)</p>
<hr/>
<p>You can explicitly <code>close</code> a generator—and, unlike the stuff above, this is part of the public interface of the generator type:</p>
<pre><code>def main():
    c = countdown(10)
    for n in c:
        if n == 5:
            break
        print('Counting... ', n)
    c.close()
    print('Finished counting')
</code></pre>
<p>Or, of course, you can use a <code>with</code> statement:</p>
<pre><code>def main():
    with contextlib.closing(countdown(10)) as c:
        for n in c:
            if n == 5:
                break
            print('Counting... ', n)
    print('Finished counting')
</code></pre>
<hr/>
<p><sub>1. As <a href="https://stackoverflow.com/a/50091650/908494">Tim Peters' answer</a> points out, you're <em>also</em> relying of implementation-specific behavior of the CPython compiler in the second test.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>I endorse @abarnert's answer, but since I already typed this ...</p>
<p>Yes, the behavior in your first example is an artifact of <code>CPython</code>'s referencing counting.  When you break out of the loop, the anonymous generator-iterator object <code>countdown(10)</code> returned loses its last reference, and so is garbage-collected at once.  That in turn triggers the generator's <code>finally:</code> suite.</p>
<p>In your second example, the generator-iterator remains bound to <code>c</code> until your <code>main()</code> exits, so as far as <code>CPython</code> knows you <em>may</em> resume <code>c</code> at any time.   It's not "garbage" until <code>main()</code> exits.  A fancier compiler <em>could</em> notice that <code>c</code> is never referenced after the loop ends, and decide to effectively <code>del c</code> before then, but <code>CPython</code> makes no attempt to predict the future.  All local names remain bound until you explicitly unbind them yourself, or the scope in which they're local ends.</p>
</div>
<span class="comment-copy">The garbage collector does not gurantee the collection of references at a specific time.</span>
<span class="comment-copy">@Jean-FrançoisFabre It's always easier to answer an interesting and well-written question…</span>
<span class="comment-copy">No, it's easier to answer <i>easy</i> questions. It's <i>better</i> to answer <i>good</i> questions. keep it up.</span>
<span class="comment-copy">Probably worth mentioning: this is not <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer">garbage collector</a>, it's just plain old ref-counting.  You will still see the object get deleted in CPython even if you call <code>gc.disable()</code> beforehand.</span>
<span class="comment-copy">@wim The answer says "In CPython, which uses reference counting (plus a cycle collector, but that isn't relevant here)…" Does that need to be elaborated on further?</span>
<span class="comment-copy">I've just edited directly to remove the part I thought was troublesome ("relying on implementation-specific behavior of garbage collector").  Feel free to rollback if you don't like it.  My comments <a href="https://www.youtube.com/watch?v=Y2BcEIRIw3o" rel="nofollow noreferrer">here will self-destruct</a> in 24 hours.</span>
<span class="comment-copy">Right. @abarnert also answered my second query about how control flow reaches finally part of the generator, so I have marked his answer as accepted.</span>
<span class="comment-copy">Good point about the fact that a compiler could <code>del</code> dead objects. In fact, even CPython with a plugin optimizer a la Victor Stinner's proposals (or something hacky built around <code>byteplay</code>) could do that.</span>
<span class="comment-copy">@abarnert: The compiler would have to know that no observable differences resulted from the early destruction of the object.  And that the user didn’t care about introspection (<code>f_locals</code> and the like).</span>
<span class="comment-copy">@DavisHerring: Eh, the "no observable differences" bit is a language design decision. I'm pretty sure Java and C# are willing to finalize an object in situations like this, even when such early finalization has a major impact on the program's semantics. It comes down to what the language's concept of "garbage" is.</span>
<span class="comment-copy">@DavisHerring Plenty of compilers do that—although it's obviously harder for a language as dynamic as Python, consider that Python 2.x did (attempt to) detect <code>exec</code> and other uses of introspection to deal with fast-locals properly, which isn't that much different. But I was really envisioning an optimizer as an opt-in decorator or import hook or the like, which would mean the optimizer knows you don't care about introspection because that's part of its documentation…</span>
