<div class="post-text" itemprop="text">
<p>For example, the digits of <code>123431</code> and <code>4577852</code> increase and then decrease. I wrote a code that breaks the numbers into a list and is able to tell if all of the digits increase or if all of the digits decrease, but I don't know how to check for digits increasing <em>then</em> decreasing. How do I extend this?</p>
<pre><code>x = int(input("Please enter a number: "))
y = [int(d) for d in str(x)]
def isDecreasing(y):
    for i in range(len(y) - 1):
        if y[i] &lt; y[i + 1]:
            return False
        return True
if isDecreasing(y) == True or sorted(y) == y:
    print("Yes")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems like a good opportunity to learn about using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> and generator pipelines. First we make a few simple, decoupled, and reusable components:</p>
<pre><code>from itertools import tee, groupby

def digits(n):
    """420 -&gt; 4, 2, 0"""
    for char in str(n):
        yield int(char)

def pairwise(iterable):
    """s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."""
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

def deltas(pairs):
    """2 5 3 4 -&gt; 3, -2, 1"""
    for left, right in pairs:
        yield right - left

def directions(deltas):
    """3 2 2 5 6 -&gt; -1, 0, 1, 1"""
    for delta in deltas:
        yield -1 if delta &lt; 0 else +1 if delta &gt; 0 else 0

def deduper(directions):
    """3 2 2 5 6 2 2 2 -&gt; 3, 2, 5, 6, 2"""
    for key, group in groupby(directions):
        yield key
</code></pre>
<p>Then we put the pieces together to solve the wider problem of detecting an "increasing then decreasing number":</p>
<pre><code>from itertools import zip_longest

def is_inc_dec(stream, expected=(+1, -1)):
    stream = pairwise(stream)
    stream = deltas(stream)
    stream = directions(stream)
    stream = deduper(stream)
    for actual, expected in zip_longest(stream, expected):
        if actual != expected or actual is None or expected is None:
            return False
    else:
        return True
</code></pre>
<p>Usage is like this:</p>
<pre><code>&gt;&gt;&gt; stream = digits(123431)
&gt;&gt;&gt; is_inc_dec(stream)
True
</code></pre>
<p>This solution will short-circuit correctly for a number like:</p>
<p>121111111111111111111111111111111111111111111111111...2</p>
<p>I've addressed only the "strictly increasing, and then strictly decreasing" number case.  Since this sounds like it might be your homework, I'll leave it as an exercise for you to adapt the code for the "non-decreasing and then non-increasing" case which is mentioned in the question title.</p>
</div>
<div class="post-text" itemprop="text">
<p>Find the maximum element.
Break the list into two pieces at that location.
Check that the first piece is increasing, the second decreasing.</p>
<ul>
<li>For your second example, <code>4577852</code>, you find the largest element, <code>8</code>.</li>
<li>Break the list in two: <code>4577</code> and <code>852</code> (the 8 can go in either list, both, or neither).</li>
<li>Check that <code>4577</code> is increasing (okay) and <code>852</code> is decreasing (also okay).</li>
</ul>
<p>Is that enough to get you to a solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>Split the list at the maximum value, then take the min/ max of the diff of each side: </p>
<pre><code>import numpy as np

test1 = [1, 2, 3, 4, 5, 8, 7, 3, 1, 0]
test2 = [1, 2, 3, 4, 5, 8, 7, 3, 1, 0, 2, 5]
test3 = [7, 1, 2, 3, 4, 5, 8, 7, 3, 1, 0]
test4 = [1, 2, 3, 4, 5, 8, 8, 7, 3, 1, 0]

def incdec_test(x):
    i = np.array(x).argmax()
    return (np.diff(x[0:i]).min() &gt;= 0) and (np.diff(x[i:-1]).max() &lt;= 0)

for test in [test1, test2, test3, test4]:
    print 'increase then decrease = {}'.format(incdec_test(test))
</code></pre>
<p>Results:</p>
<pre><code>increase then decrease = True
increase then decrease = False
increase then decrease = False
increase then decrease = False
</code></pre>
</div>
<span class="comment-copy">Do you allow increasing or decreasing runs of length 0?</span>
<span class="comment-copy">Count the zero-crossings of the derivative</span>
<span class="comment-copy">@wim I assume you mean finite difference?</span>
<span class="comment-copy">Nice. Total overkill but very nice, especially the groupby.</span>
<span class="comment-copy">This can be implemented in one pass but without writing a C extension, I suspect it would be faster to do a separate pass for <code>max</code>.</span>
<span class="comment-copy">You should probably compare the diffs with <code>&lt;=</code>, <code>&gt;=</code> instead of <code>&lt;</code>, <code>&gt;</code></span>
<span class="comment-copy">Based on OP's description of <code>4577852</code></span>
<span class="comment-copy">Yeah, fair point. Edited.</span>
