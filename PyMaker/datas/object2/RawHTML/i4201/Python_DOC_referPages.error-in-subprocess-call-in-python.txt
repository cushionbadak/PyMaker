<div class="post-text" itemprop="text">
<p>What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:</p>
<pre><code>import os

file_path = "/my/directory/filename.txt"
directory = os.path.dirname(file_path)

try:
    os.stat(directory)
except:
    os.mkdir(directory)       

f = file(filename)
</code></pre>
<p>Somehow, I missed <code>os.path.exists</code> (thanks kanja, Blair, and Douglas). This is what I have now:</p>
<pre><code>def ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if not os.path.exists(directory):
        os.makedirs(directory)
</code></pre>
<p>Is there a flag for "open", that makes this happen automatically?</p>
</div>
<div class="post-text" itemprop="text">
<p>I see two answers with good qualities, each with a small flaw, so I will give my take on it:</p>
<p>Try <a href="https://docs.python.org/2/library/os.path.html#os.path.exists" rel="noreferrer"><code>os.path.exists</code></a>, and consider <a href="https://docs.python.org/2/library/os.html#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a> for the creation.</p>
<pre><code>import os
if not os.path.exists(directory):
    os.makedirs(directory)
</code></pre>
<p>As noted in comments and elsewhere, there's a race condition – if the directory is created between the <code>os.path.exists</code> and the <code>os.makedirs</code> calls, the <code>os.makedirs</code> will fail with an <code>OSError</code>. Unfortunately, blanket-catching <code>OSError</code> and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.</p>
<p>One option would be to trap the <code>OSError</code> and examine the embedded error code (see <a href="https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror">Is there a cross-platform way of getting information from Python’s OSError</a>):</p>
<pre><code>import os, errno

try:
    os.makedirs(directory)
except OSError as e:
    if e.errno != errno.EEXIST:
        raise
</code></pre>
<p>Alternatively, there could be a second <code>os.path.exists</code>, but suppose another created the directory after the first check, then removed it before the second one – we could still be fooled. </p>
<p>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.</p>
<p>Modern versions of Python improve this code quite a bit, both by exposing <a href="https://docs.python.org/3.3/library/exceptions.html?#FileExistsError" rel="noreferrer"><code>FileExistsError</code></a> (in 3.3+)...</p>
<pre><code>try:
    os.makedirs("path/to/directory")
except FileExistsError:
    # directory already exists
    pass
</code></pre>
<p>...and by allowing <a href="https://docs.python.org/3.2/library/os.html#os.makedirs" rel="noreferrer">a keyword argument to <code>os.makedirs</code> called <code>exist_ok</code></a> (in 3.2+).</p>
<pre><code>os.makedirs("path/to/directory", exist_ok=True)  # succeeds even if directory exists.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Python 3.5+:</h2>
<pre><code>import pathlib
pathlib.Path('/my/directory').mkdir(parents=True, exist_ok=True) 
</code></pre>
<p><a href="https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer"><code>pathlib.Path.mkdir</code></a> as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the <code>parents</code> argument.</p>
<h2>Python 3.2+:</h2>
<p><strong>Using <code>pathlib</code>:</strong></p>
<p>If you can, install the current <code>pathlib</code> backport named <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer"><code>pathlib2</code></a>. Do not install the older unmaintained backport named <a href="https://pypi.python.org/pypi/pathlib/" rel="noreferrer"><code>pathlib</code></a>. Next, refer to the Python 3.5+ section above and use it the same.</p>
<p>If using Python 3.4, even though it comes with <code>pathlib</code>, it is missing the useful <code>exist_ok</code> option. The backport is intended to offer a newer and superior implementation of <code>mkdir</code> which includes this missing option.</p>
<p><strong>Using <code>os</code>:</strong></p>
<pre><code>import os
os.makedirs(path, exist_ok=True)
</code></pre>
<p><a href="https://docs.python.org/library/os.html#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a> as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional <code>exist_ok</code> argument only if using Python 3.2+, with a default value of <code>False</code>. This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7.</p>
<h2>Python 2.7+:</h2>
<p><strong>Using <code>pathlib</code>:</strong></p>
<p>If you can, install the current <code>pathlib</code> backport named <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer"><code>pathlib2</code></a>. Do not install the older unmaintained backport named <a href="https://pypi.python.org/pypi/pathlib/" rel="noreferrer"><code>pathlib</code></a>. Next, refer to the Python 3.5+ section above and use it the same.</p>
<p><strong>Using <code>os</code>:</strong></p>
<pre><code>import os
try: 
    os.makedirs(path)
except OSError:
    if not os.path.isdir(path):
        raise
</code></pre>
<p>While a naive solution may first use <a href="https://docs.python.org/2/library/os.path.html#os.path.isdir" rel="noreferrer" title="os.path.isdir"><code>os.path.isdir</code></a> followed by <a href="https://docs.python.org/2/library/os.html#os.makedirs" rel="noreferrer" title="os.makedirs"><code>os.makedirs</code></a>, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.</p>
<p>Note that capturing the exception and using <code>errno</code> is of limited usefulness because <code>OSError: [Errno 17] File exists</code>, i.e. <code>errno.EEXIST</code>, is raised for both files and directories. It is more reliable simply to check if the directory exists.</p>
<h2>Alternative:</h2>
<p><a href="https://docs.python.org/distutils/apiref.html#distutils.dir_util.mkpath" rel="noreferrer"><code>mkpath</code></a> creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3.</p>
<pre><code>import distutils.dir_util
distutils.dir_util.mkpath(path)
</code></pre>
<p>Per <a href="http://bugs.python.org/issue10948" rel="noreferrer">Bug 10948</a>, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use <code>mkpath</code> again to recreate the same directory, <code>mkpath</code> will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, <code>os.makedirs</code> doesn't rely on any such cache. This limitation may be okay for some applications.</p>
<hr/>
<p>With regard to the directory's <em>mode</em>, please refer to the documentation if you care about it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:</p>
<pre><code>import os
import errno

def make_sure_path_exists(path):
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
</code></pre>
<p>In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an <code>OSError</code> raised with <code>errno.EACCES</code> (Permission denied, error 13).</p>
</div>
<div class="post-text" itemprop="text">
<p>I would personally recommend that you use <code>os.path.isdir()</code> to test instead of <code>os.path.exists()</code>.</p>
<pre><code>&gt;&gt;&gt; os.path.exists('/tmp/dirname')
True
&gt;&gt;&gt; os.path.exists('/tmp/dirname/filename.etc')
True
&gt;&gt;&gt; os.path.isdir('/tmp/dirname/filename.etc')
False
&gt;&gt;&gt; os.path.isdir('/tmp/fakedirname')
False
</code></pre>
<p>If you have:</p>
<pre><code>&gt;&gt;&gt; dir = raw_input(":: ")
</code></pre>
<p>And a foolish user input:</p>
<pre><code>:: /tmp/dirname/filename.etc
</code></pre>
<p>... You're going to end up with a directory named <code>filename.etc</code> when you pass that argument to <code>os.makedirs()</code> if you test with <code>os.path.exists()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Check <a href="https://docs.python.org/3/library/os.html#os.makedirs" rel="noreferrer">os.makedirs</a>:  (It makes sure the complete path exists.)<br/>
 To handle the fact the directory might exist, catch OSError.
(If exist_ok is False (the default), an OSError is raised if the target directory already exists.)</p>
<pre><code>import os
try:
    os.makedirs('./path/to/somewhere')
except OSError:
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Starting from Python 3.5, <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer"><code>pathlib.Path.mkdir</code></a> has an <code>exist_ok</code> flag:</p>
<pre><code>from pathlib import Path
path = Path('/my/directory/filename.txt')
path.parent.mkdir(parents=True, exist_ok=True) 
# path.parent ~ os.path.dirname(path)
</code></pre>
<p>This recursively creates the directory and does not raise an exception if the directory already exists.</p>
<p>(just as <a href="https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs" rel="noreferrer"><code>os.makedirs</code></a> got an <code>exist_ok</code> flag starting from python 3.2 e.g <code>os.makedirs(path, exist_ok=True)</code>)</p>
</div>
<div class="post-text" itemprop="text">
<h1>Insights on the specifics of this situation</h1>
<p>You give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code:</p>
<blockquote>
<pre><code>filename = "/my/directory/filename.txt"
dir = os.path.dirname(filename)
</code></pre>
</blockquote>
<p>We want to avoid overwriting the builtin function, <code>dir</code>. Also, <code>filepath</code> or perhaps <code>fullfilepath</code> is probably a better semantic name than <code>filename</code> so this would be better written:</p>
<pre><code>import os
filepath = '/my/directory/filename.txt'
directory = os.path.dirname(filepath)
</code></pre>
<p>Your end goal is to open this file, you initially state, for writing, but you're essentially approaching this goal (based on your code) like this, which opens the file for <strong>reading</strong>:</p>
<blockquote>
<pre><code>if not os.path.exists(directory):
    os.makedirs(directory)
f = file(filename)
</code></pre>
</blockquote>
<h2>Assuming opening for reading</h2>
<p>Why would you make a directory for a file that you expect to be there and be able to read? </p>
<p>Just attempt to open the file.</p>
<pre><code>with open(filepath) as my_file:
    do_stuff(my_file)
</code></pre>
<p>If the directory or file isn't there, you'll get an <code>IOError</code> with an associated error number: <code>errno.ENOENT</code> will point to the correct error number regardless of your platform. You can catch it if you want, for example:</p>
<pre><code>import errno
try:
    with open(filepath) as my_file:
        do_stuff(my_file)
except IOError as error:
    if error.errno == errno.ENOENT:
        print 'ignoring error because directory or file is not there'
    else:
        raise
</code></pre>
<h2>Assuming we're opening for writing</h2>
<p>This is <em>probably</em> what you're wanting.</p>
<p>In this case, we probably aren't facing any race conditions. So just do as you were, but note that for writing, you need to open with the <code>w</code> mode (or <code>a</code> to append). It's also a Python best practice to use the context manager for opening files.</p>
<pre><code>import os
if not os.path.exists(directory):
    os.makedirs(directory)
with open(filepath, 'w') as my_file:
    do_stuff(my_file)
</code></pre>
<p>However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it's best to wrap the <code>makedirs</code> call in a try-except block.</p>
<pre><code>import os
import errno
if not os.path.exists(directory):
    try:
        os.makedirs(directory)
    except OSError as error:
        if error.errno != errno.EEXIST:
            raise
with open(filepath, 'w') as my_file:
    do_stuff(my_file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try the <a href="https://docs.python.org/2/library/os.path.html#os.path.exists" rel="noreferrer" title="os.path.exists"><code>os.path.exists</code></a> function</p>
<pre><code>if not os.path.exists(dir):
    os.mkdir(dir)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have put the following down. It's not totally foolproof though.</p>
<pre><code>import os

dirname = 'create/me'

try:
    os.makedirs(dirname)
except OSError:
    if os.path.exists(dirname):
        # We are nearly safe
        pass
    else:
        # There was an error on creation, so make sure we know about it
        raise
</code></pre>
<p>Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Check if a directory exists and create it if necessary?</strong></p>
</blockquote>
<p>The direct answer to this is, assuming a simple situation where you don't expect other users or processes to be messing with your directory:</p>
<pre><code>if not os.path.exists(d):
    os.makedirs(d)
</code></pre>
<p><strong>or</strong> if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this:</p>
<pre><code>import errno
try:
    os.makedirs(d)
except OSError as exception:
    if exception.errno != errno.EEXIST:
        raise
</code></pre>
<p>But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via <a href="https://docs.python.org/library/tempfile.html#tempfile.mkdtemp" rel="noreferrer" title="tempfile.mkdtemp"><code>tempfile</code></a>:</p>
<pre><code>import tempfile

d = tempfile.mkdtemp()
</code></pre>
<p>Here's the essentials from the online doc:</p>
<blockquote>
<pre><code>mkdtemp(suffix='', prefix='tmp', dir=None)
    User-callable function to create and return a unique temporary
    directory.  The return value is the pathname of the directory.

    The directory is readable, writable, and searchable only by the
    creating user.

    Caller is responsible for deleting the directory when done with it.
</code></pre>
</blockquote>
<h2>New in Python 3.5: <code>pathlib.Path</code> with <code>exist_ok</code></h2>
<p>There's a new <code>Path</code> object (as of 3.4) with lots of methods one would want to use with paths - one of which is <code>mkdir</code>.</p>
<p>(For context, I'm tracking my weekly rep with a script. Here's the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.)</p>
<p>First the relevant imports:</p>
<pre><code>from pathlib import Path
import tempfile
</code></pre>
<p>We don't have to deal with <code>os.path.join</code> now - just join path parts with a <code>/</code>:</p>
<pre><code>directory = Path(tempfile.gettempdir()) / 'sodata'
</code></pre>
<p>Then I idempotently ensure the directory exists - the <code>exist_ok</code> argument shows up in Python 3.5:</p>
<pre><code>directory.mkdir(exist_ok=True)
</code></pre>
<p>Here's the relevant part of the <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" rel="noreferrer">documentation</a>:</p>
<blockquote>
<p>If <code>exist_ok</code> is true, <code>FileExistsError</code> exceptions will be ignored (same behavior as the <code>POSIX mkdir -p</code> command), but only if the last path component is not an existing non-directory file.</p>
</blockquote>
<p>Here's a little more of the script - in my case, I'm not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don't have anything trying to remove the directory. </p>
<pre><code>todays_file = directory / str(datetime.datetime.utcnow().date())
if todays_file.exists():
    logger.info("todays_file exists: " + str(todays_file))
    df = pd.read_json(str(todays_file))
</code></pre>
<p><code>Path</code> objects have to be coerced to <code>str</code> before other APIs that expect <code>str</code> paths can use them.</p>
<p>Perhaps Pandas should be updated to accept instances of the abstract base class, <code>os.PathLike</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.4 you can also use the <a href="https://docs.python.org/3/library/pathlib.html">brand new <code>pathlib</code> module</a>:</p>
<pre><code>from pathlib import Path
path = Path("/my/directory/filename.txt")
try:
    if not path.parent.exists():
        path.parent.mkdir(parents=True)
except OSError:
    # handle error; you can also catch specific errors like
    # FileExistsError and so on.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/2/library/os.html#files-and-directories" rel="noreferrer">relevant Python documentation</a> suggests the use of the <a href="https://docs.python.org/2/library/os.html#files-and-directories" rel="noreferrer">EAFP coding style (Easier to Ask for Forgiveness than Permission)</a>. This means that the code</p>
<pre><code>try:
    os.makedirs(path)
except OSError as exception:
    if exception.errno != errno.EEXIST:
        raise
    else:
        print "\nBE CAREFUL! Directory %s already exists." % path
</code></pre>
<p>is better than the alternative</p>
<pre><code>if not os.path.exists(path):
    os.makedirs(path)
else:
    print "\nBE CAREFUL! Directory %s already exists." % path
</code></pre>
<p>The documentation suggests this exactly because of the race condition discussed in this question. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program).</p>
<p>Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment.</p>
</div>
<div class="post-text" itemprop="text">
<p>In <strong>Python3</strong>, <code>os.makedirs</code> supports setting <code>exist_ok</code>. The default setting is <code>False</code>, which means an <code>OSError</code> will be raised if the target directory already exists. By setting <code>exist_ok</code> to <code>True</code>, <code>OSError</code> (directory exists) will be ignored and the directory will not be created.</p>
<pre><code>os.makedirs(path,exist_ok=True)
</code></pre>
<p>In <strong>Python2</strong>, <code>os.makedirs</code> doesn't support setting <code>exist_ok</code>. You can use the approach in <a href="https://stackoverflow.com/a/5032238/3109254">heikki-toivonen's answer</a>:</p>
<pre><code>import os
import errno

def make_sure_path_exists(path):
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/distutils/apiref.html#distutils.dir_util.mkpath" rel="noreferrer"><code>mkpath</code></a></p>
<pre><code># Create a directory and any missing ancestor directories. 
# If the directory already exists, do nothing.

from distutils.dir_util import mkpath
mkpath("test")    
</code></pre>
<p>Note that it will create the ancestor directories as well. </p>
<p>It works for Python 2 and 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>For a one-liner solution, you can use <code>IPython.utils.path.ensure_dir_exists()</code>:</p>
<pre><code>from IPython.utils.path import ensure_dir_exists
ensure_dir_exists(dir)
</code></pre>
<p>From the <a href="https://ipython.org/ipython-doc/3/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists" rel="noreferrer">documentation</a>: <em>Ensure that a directory exists. If it doesn’t exist, try to create it and protect against a race condition if another process is doing the same.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I use <code>os.path.exists()</code>, <a href="http://pastebin.com/vnVk2rY5" rel="noreferrer">here</a> is a Python 3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (if desired).</p>
<p>It prompts users for input of the directory and can be easily modified.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>os.listdir</code> for this:</p>
<pre><code>import os
if 'dirName' in os.listdir('parentFolderPath')
    print('Directory Exists')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this Q/A and I was initially puzzled by some of the failures and errors I was getting. I am working in Python 3 (v.3.5 in an Anaconda virtual environment on an Arch Linux x86_64 system).</p>
<p>Consider this directory structure:</p>
<pre><code>└── output/         ## dir
   ├── corpus       ## file
   ├── corpus2/     ## dir
   └── subdir/      ## dir
</code></pre>
<p>Here are my experiments/notes, which clarifies things:</p>
<pre><code># ----------------------------------------------------------------------------
# [1] https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist

import pathlib

""" Notes:
        1.  Include a trailing slash at the end of the directory path
            ("Method 1," below).
        2.  If a subdirectory in your intended path matches an existing file
            with same name, you will get the following error:
            "NotADirectoryError: [Errno 20] Not a directory:" ...
"""
# Uncomment and try each of these "out_dir" paths, singly:

# ----------------------------------------------------------------------------
# METHOD 1:
# Re-running does not overwrite existing directories and files; no errors.

# out_dir = 'output/corpus3'                ## no error but no dir created (missing tailing /)
# out_dir = 'output/corpus3/'               ## works
# out_dir = 'output/corpus3/doc1'           ## no error but no dir created (missing tailing /)
# out_dir = 'output/corpus3/doc1/'          ## works
# out_dir = 'output/corpus3/doc1/doc.txt'   ## no error but no file created (os.makedirs creates dir, not files!  ;-)
# out_dir = 'output/corpus2/tfidf/'         ## fails with "Errno 20" (existing file named "corpus2")
# out_dir = 'output/corpus3/tfidf/'         ## works
# out_dir = 'output/corpus3/a/b/c/d/'       ## works

# [2] https://docs.python.org/3/library/os.html#os.makedirs

# Uncomment these to run "Method 1":

#directory = os.path.dirname(out_dir)
#os.makedirs(directory, mode=0o777, exist_ok=True)

# ----------------------------------------------------------------------------
# METHOD 2:
# Re-running does not overwrite existing directories and files; no errors.

# out_dir = 'output/corpus3'                ## works
# out_dir = 'output/corpus3/'               ## works
# out_dir = 'output/corpus3/doc1'           ## works
# out_dir = 'output/corpus3/doc1/'          ## works
# out_dir = 'output/corpus3/doc1/doc.txt'   ## no error but creates a .../doc.txt./ dir
# out_dir = 'output/corpus2/tfidf/'         ## fails with "Errno 20" (existing file named "corpus2")
# out_dir = 'output/corpus3/tfidf/'         ## works
# out_dir = 'output/corpus3/a/b/c/d/'       ## works

# Uncomment these to run "Method 2":

#import os, errno
#try:
#       os.makedirs(out_dir)
#except OSError as e:
#       if e.errno != errno.EEXIST:
#               raise
# ----------------------------------------------------------------------------
</code></pre>
<p>Conclusion: in my opinion, "Method 2" is more robust.</p>
<p>[1] <a href="https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist">How can I create a directory if it does not exist?</a></p>
<p>[2] <a href="https://docs.python.org/3/library/os.html#os.makedirs" rel="noreferrer">https://docs.python.org/3/library/os.html#os.makedirs</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I saw <a href="https://stackoverflow.com/a/5032238/3051142">Heikki Toivonen</a> and <a href="https://stackoverflow.com/a/14364249">A-B-B</a>'s answers and thought of this variation.</p>
<pre><code>import os
import errno

def make_sure_path_exists(path):
    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST or not os.path.isdir(path):
            raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When working with file I/O, the important thing to consider is</p>
<h2>TOCTTOU (time of check to time of use)</h2>
<p>So doing a check with <code>if</code> and then reading or writing later may end up in an unhandled I/O exception. The best way to do it is:</p>
<pre><code>try:
    os.makedirs(dir_path)
except OSError as e:
    if e.errno != errno.EEXIS:
        raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you consider the following: </p>
<pre><code>os.path.isdir('/tmp/dirname')
</code></pre>
<p>means a directory (path) exists AND is a directory. So for me this way does what I need. So I can make sure it is folder (not a file) and exists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Call the function <code>create_dir()</code> at the entry point of your program/project.</p>
<pre><code>import os

def create_dir(directory):
    if not os.path.exists(directory):
        print('Creating Directory '+directory)
        os.makedirs(directory)

create_dir('Project directory')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not use subprocess module if running on a machine that supports shell languages? 
Works on python 2.7 and python 3.6</p>
<pre><code>from subprocess import call
call(['mkdir', '-p', 'path1/path2/path3'])
</code></pre>
<p>Should do the trick on most systems.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use this command check and create dir</p>
<pre><code> if not os.path.isdir(test_img_dir):
     os.mkdir(str("./"+test_img_dir))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
if os.path.isfile(filename):
    print "file exists"
else:
    "Your code here"
</code></pre>
<blockquote>
<p>Where your code here is use the (touch) command</p>
</blockquote>
<p>This will check if the file is there if it is not then it will create it.</p>
</div>
<span class="comment-copy">In general you might need to account for the case where there's no directory in the filename.  On my machine dirname('foo.txt') gives '', which doesn't exist and causes makedirs() to fail.</span>
<span class="comment-copy">In python 2.7 <code>os.path.mkdir</code> doesn't exist. It's <a href="http://docs.python.org/2/library/os.html#os.mkdir" rel="nofollow noreferrer"><code>os.mkdir</code></a>.</span>
<span class="comment-copy">if the path exists one has not only to check if it is a directory and not a regular file or another object (many answers check this) it is also necessary to check if it is writable (I did not find an answer that checked this)</span>
<span class="comment-copy">In case you came here to create parent directories of file path string <code>p</code>, here is my code snippet: <code>os.makedirs(p[:p.rindex(os.path.sep)], exist_ok=True)</code></span>
<span class="comment-copy"><a href="https://meta.stackoverflow.com/q/361254/839601">meta discussion of answers in this question</a></span>
<span class="comment-copy">agreed the try/except solution is better</span>
<span class="comment-copy">Remember that os.path.exists() isn't free. If the normal case is that the directory will be there, then the case where it isn't should be handled as an exception. In other words, try to open and write to your file, catch the OSError exception and, based on errno, do your makedir() and re-try or re-raise. This creates duplication of code unless you wrap the writing in a local method.</span>
<span class="comment-copy"><code>os.path.exists</code> also returns <code>True</code> for a file. I have posted an answer to address this.</span>
<span class="comment-copy">As commenters to other answers here have noted, the <code>exists_ok</code> parameter to <code>os.makedirs()</code> can be used to cover how prior existence of the path is handled, since Python 3.2.</span>
<span class="comment-copy">so the actual answer should be <a href="http://stackoverflow.com/questions/273192/check-if-a-directory-exists-and-create-it-if-necessary/14364249#14364249" title="check if a directory exists and create it if necessary">stackoverflow.com/questions/273192/…</a></span>
<span class="comment-copy">This answer covers pretty much every special case as far as I can tell.  I plan on wrapping this in a "if not os.path.isdir()" though since I expect the directory to exist almost every time and I can avoid the exception that way.</span>
<span class="comment-copy">@CharlesL. An exception is probably cheaper than the disk IO of the check, if your reason is performance.</span>
<span class="comment-copy">@jpmc26 but makedirs does additional stat, umask, lstat when only checking to throw OSError.</span>
<span class="comment-copy">This is the wrong answer, as it introduces a potential FS race cond. See answer from Aaron Hall.</span>
<span class="comment-copy">as @sleepycal has said, this suffers from a similar race condition as the accepted answer. If between raising the error and checking <code>os.path.isdir</code> someone else deletes the folder, you will raise the wrong, outdated, and confusing error that folder exists.</span>
<span class="comment-copy">The accepted answer is actually dangerous because it has a race-condition. It is simpler, though, so if you are unaware of the race-condition, or think it won't apply to you, that would be your obvious first pick.</span>
<span class="comment-copy">Raising the exception only when <code>exception.errno != errno.EEXIST</code> will unintentionally ignore the case when path exists but is a non-directory object such as a file. The exception should ideally be raised if the path is a non-directory object.</span>
<span class="comment-copy">Note that the above code is equivalent to <code>os.makedirs(path,exist_ok=True)</code></span>
<span class="comment-copy">@Navin The <code>exist_ok</code> parameter was introduced in Python 3.2.  It is not present in Python 2.x.  I will incorporate it into my answer.</span>
<span class="comment-copy">@HeikkiToivonen Technically speaking, if another program is modifying the directories and files at the same time your program is, your entire program is one giant race condition. What's to stop another program from just deleting this directory after the code creates it and before you actually put files in it?</span>
<span class="comment-copy">If you use 'isdir' only, won't you still have a problem when you attempt to create the directory and a file with the same name already exists?</span>
<span class="comment-copy">@MrWonderful The resulting exception when creating a directory over an existing file would correctly reflect the problem back to the caller.</span>
<span class="comment-copy">This is bad advice.  See <a href="http://stackoverflow.com/a/5032238/763269">stackoverflow.com/a/5032238/763269</a>.</span>
<span class="comment-copy">with the try/except, you will mask errors in directory creation, in the case when the directory didn't exist but for some reason you can't make it</span>
<span class="comment-copy">This is the only safe way.</span>
<span class="comment-copy"><code>OSError</code> will be raised here if the path is an existing file or directory. I have posted an answer to address this.</span>
<span class="comment-copy">This is halfway there.  You do need to check the sub-error condition of <code>OSError</code> before deciding to ignore it.  See <a href="http://stackoverflow.com/a/5032238/763269">stackoverflow.com/a/5032238/763269</a>.</span>
<span class="comment-copy">I was going to comment on the question, but do we mean os.mkdir? My python (2.5.2) has no os.path.mkdir....</span>
<span class="comment-copy">There is no <code>os.path.mkdir()</code> method. <a href="http://docs.python.org/library/os.path.html" rel="nofollow noreferrer">os.path</a> module implements some useful <i>functions on pathnames</i>.</span>
<span class="comment-copy">This is terrible advice.  See <a href="http://stackoverflow.com/a/5032238/763269">stackoverflow.com/a/5032238/763269</a>.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror" title="is there a cross platform way of getting information from pythons oserror">stackoverflow.com/questions/273698/…</a></span>
<span class="comment-copy">Two problems: (1) you need to check the sub-error condition of OSError before deciding to check <code>os.path.exists</code> - see stackoverflow.com/a/5032238/763269, and (2) success on <code>os.path.exists</code> does not mean the directory exists, just that the path exists - could be a file, or a symlink, or other file system object.</span>
<span class="comment-copy">It's supported in 2.7 too: <a href="https://pypi.python.org/pypi/pathlib/" rel="nofollow noreferrer">pypi.python.org/pypi/pathlib</a></span>
<span class="comment-copy">@JanuszSkonieczny it is not supported in Python 2.7; only it has been backported there. In Python 3.4 it is a built-in module.</span>
<span class="comment-copy">And what's the difference between supported and backported? It works doesn't it? And yeah, we all get it, it's not a core py 2.7 library, that's why I posted, a link to PYPI listing ;P</span>
<span class="comment-copy">If the information in the comments were in the answer, the comments would be obsolete.</span>
<span class="comment-copy">@JanuszSkonieczny <a href="https://pypi.python.org/pypi/pathlib2/" rel="nofollow noreferrer">pypi.python.org/pypi/pathlib2</a> is the newer backport. The older one is unmaintained.</span>
<span class="comment-copy"><code>distutils.dir_util</code> is not a part of the distutil public API and has problems in multi threaded environments: <a href="http://bugs.python.org/issue10948" rel="nofollow noreferrer">bugs.python.org/issue10948</a></span>
<span class="comment-copy">Yes. As noted in the <a href="https://bugs.python.org/msg126540" rel="nofollow noreferrer">first message</a> of the bug, the problem with <code>distutils.dir_util.mkpath</code> is that if you create a directory, then delete it from inside or outside Python, then use <code>mkpath</code> again, <code>mkpath</code> will simply use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, <code>os.makedirs</code> doesn't rely on any such cache.</span>
<span class="comment-copy">New IPython documentation <a href="https://ipython.readthedocs.io/en/stable/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists" rel="nofollow noreferrer">available here</a>.</span>
<span class="comment-copy">The <code>IPython</code> module is absolutely not guaranteed to be present. It is natively present on my Mac, but not on any of my Linux installs of Python. Basically, it is not one of the modules listed in the <a href="https://docs.python.org/py-modindex.html" rel="nofollow noreferrer">Python Module Index</a>.</span>
<span class="comment-copy">Sure. In order to install the package, just run the usual <code>pip install ipython</code> or include the dependency in your <i>requirements.txt</i> or <i>pom.xml</i>. Documentation: <a href="https://ipython.org/install.html" rel="nofollow noreferrer">ipython.org/install.html</a></span>
<span class="comment-copy">Does this add anything to the already published questions?</span>
<span class="comment-copy">Works perfectly well. Thanks. On the other hand I get unexpected results if I try this: call(['mkdir', '-p', 'archive/calls', 'archive/transcripts'])</span>
<span class="comment-copy">Fixed. Just wanted an absolute path. call(['mkdir', '-p', '/Users/zog/archive/calls', '/Users/zog/archive/transcripts'])</span>
<span class="comment-copy">nice one @Geoff Paul Bremner -  combining a bash call is usually [one of] the cleanest and simplest solutions to a simple os task, competing nicely with the classic pythonic solutions</span>
