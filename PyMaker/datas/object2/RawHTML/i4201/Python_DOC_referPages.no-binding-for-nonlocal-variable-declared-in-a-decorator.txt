<div class="post-text" itemprop="text">
<pre><code>def decorator(func):
    def returning():
        var = 1
        func()
        print(var)
    return(returning)
@decorator
def function():
    nonlocal var
    var = 5
function()
</code></pre>
<p>var is declared inside the returning() function before calling func(), yet I get a binding error. </p>
<p>I don't understand why this happens.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python determines scopes <strong>at compile time</strong>, making the <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope" rel="nofollow noreferrer">scope model <em>static</em>, not dynamic</a>. The <code>nonlocal</code> and <code>global</code> statements tell the <em>compiler</em> to alter the scope where a name is set. <code>nonlocal</code> tells the compiler that a given name is to be assigned to as a closure, living in an enclosing scope. See the <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow noreferrer"><em>Naming and binding</em> section</a> of the Python execution model documentation:</p>
<blockquote>
<p>If a name is bound in a block, it is a local variable of that block, unless declared as <code>nonlocal</code> or <code>global</code>.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Each assignment or import statement occurs within a block defined by a class or function definition or at the module level (the top-level code block).</p>
</blockquote>
<p>and</p>
<blockquote>
<p>A <em>scope</em> defines the visibility of a name within a block. If a local variable is defined in a block, its scope includes that block. If the definition occurs in a function block, the scope extends to any blocks contained within the defining one, unless a contained block introduces a different binding for the name.</p>
</blockquote>
<p>So only function <em>definitions</em>, class definitions and the module level are blocks where assignments take place. <code>nonlocal</code> can only act on names in a nested scope:</p>
<blockquote>
<p>The <code>nonlocal</code> statement causes corresponding names to refer to previously bound variables in the nearest enclosing function scope.</p>
</blockquote>
<p><code>function()</code> is not a nested block, there is no enclosing function scope.</p>
<p>Decorators are a <em>runtime</em> feature, and do not produce a new encloding function scope. You didn't nest <code>function()</code> inside the decorator, you only passed in a reference to the function object. The function has already been created, compilation is done and the scope of the names is set in stone.</p>
<p>The only way to do what you want would require <em>re-compilation</em> or <em>bytecode manipulation</em>, both subjects that are very much on the very advanced side of Python hacking. </p>
<p>For example, with access to the source code (usually the case), you could use <code>inspect</code> and <code>ast</code> to merge the abstract syntax tree of <code>function</code> into that of <code>returning</code> to create a nested scope, then compile that new tree into bytecode that would do what you want. Or you'd have to do something similar with the bytecode of both functions to make <code>returning</code> produce a closure, and <code>function()</code> take that closure for the value of <code>var</code>. This would require an intimate knowledge of how Python closures work, and what bytecode the compiler produces to handle closures.</p>
<p>All this means that it would be much easier to find yourself a different approach to your problem. Perhaps use a class with state to alter the state in different contexts, etc.</p>
</div>
<span class="comment-copy">Scopes can't be altered with a decorator. <code>function()</code> is not a nested scope and will never be.</span>
<span class="comment-copy">@GT77 Python follows static scoping rules -- a variable's scope can be determined by textual analysis, without looking at the runtime call chain. The expectation here would only be true in a language with dynamic scope.</span>
