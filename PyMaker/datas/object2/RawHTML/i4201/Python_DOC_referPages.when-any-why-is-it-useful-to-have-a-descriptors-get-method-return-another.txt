<div class="post-text" itemprop="text">
<p>I had a container holding an object's methods, and possibly some descriptors. I wanted to test whether the descriptors had already been unwrapped or not by checking whether they had had a '<strong>get</strong>' method. To my surprise, the <code>__get__</code> method of a class-method returns an object which also has a <code>__get__</code> method. Do you know when this behavior is useful? Does it have something to do with overriding class methods in a derived class?</p>
<pre><code>import inspect

class K:    
    @classmethod
    def cm(cls, a, b, c):
        pass

def get_attr_info(attr):
    try:
        sig = inspect.signature(attr)
    except:
        sig = None

    attr_info = [
        ('id ', id(attr),),
        ('type  ', type(attr),),
        ('hasattr ', '__get__', hasattr(attr, '__get__'),),
        ('hasattr ', '__call__', hasattr(attr, '__call__'),),
        ('SIG:  ', sig,)
    ]
    return attr_info

get_label = lambda tpl: ' '.join([str(x) for x in tpl[0:-1]]).ljust(20)

kinst = K()
cm = object.__getattribute__(type(kinst), '__dict__')['cm']

try:
    for idx in range(0, 5):
        info = get_attr_info(cm)        
        print('\n' + '\n'.join([get_label(tpl) + str(tpl[-1]) for tpl in info]))
        cm = cm.__get__(kinst, type(kinst))
except AttributeError:
    print(idx)
</code></pre>
<p><strong>The Output Is:</strong></p>
<pre><code>id                  44545808
type                &lt;class 'classmethod'&gt;
hasattr  __get__    True
hasattr  __call__   False
SIG:                None

id                  6437832
type                &lt;class 'method'&gt;
hasattr  __get__    True
hasattr  __call__   True
SIG:                (a, b, c)

id                  6437832
type                &lt;class 'method'&gt;
hasattr  __get__    True
hasattr  __call__   True
SIG:                (a, b, c)

id                  6437832
type                &lt;class 'method'&gt;
hasattr  __get__    True
hasattr  __call__   True
SIG:                (a, b, c)

id                  6437832
type                &lt;class 'method'&gt;
hasattr  __get__    True
hasattr  __call__   True
SIG:                (a, b, c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The specific behavior you're seeing used to make sense because of unbound method objects. Back in Python 2, if you did</p>
<pre><code>class Foo(object):
    def useful_method(self):
        do_stuff()

class Bar(object):
    useful_method = Foo.useful_method
</code></pre>
<p><code>Foo.useful_method</code> would evaluate to an <em>unbound method object</em>, something similar to but slightly different from a function. Unbound method objects needed a <code>__get__</code> so <code>Bar().useful_method</code> would auto-bind <code>self</code>, just like if <code>Foo.useful_method</code> had evaluated to a function instead of an unbound method during the definition of <code>Bar</code>.</p>
<p>Unbound method objects and bound method objects were implemented with the same type, so bound methods shared the same <code>__get__</code> method unbound methods had. For bound method objects, though, <code>__get__</code> would just return the bound method object, as if no descriptor logic was involved.</p>
<p>Now that unbound methods no longer exist, the <code>__get__</code> method of method objects is superfluous, but it hasn't been removed.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the specific question of why bound methods are descriptors (it should be obvious why <code>classmethod</code> objects are, right?), see <a href="https://stackoverflow.com/a/50050148/908494">user's answer</a>.</p>
<hr/>
<p>For the general question of why non-data descriptors need to be allowed: it would be more painful to write them. After all, the most obvious way to write a non-data descriptor is often to just return a function. And functions have to be non-data descriptors, or methods wouldn't work, defeating the whole reason descriptors were added to the language.</p>
<p>For example, consider the "pure-Python <code>classmethod</code>" example in <a href="https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">the HOWTO</a>:</p>
<pre><code>class ClassMethod(object):
    "Emulate PyClassMethod_Type() in Objects/funcobject.c"

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        def newfunc(*args):
            return self.f(klass, *args)
        return newfunc
</code></pre>
<p>Or, more simply, consider <code>staticmethod</code>, which even in the builtin implementation just returns the function itself when bound.</p>
<p>Of course you could also implement any of these by building an object with a custom <code>__call__</code> method, and sometimes that's worth doing (e.g., you could implement <code>classmethod</code> with <code>partial</code>, or with something that acts like <code>partial</code>, in which case there'd be no reason to add <code>__get__</code>)—but when a function just works, why not use a function?</p>
<hr/>
<p>For the more abstract question of whether you could possibly find a use for this feature… Well, sure. Among the things you can do are:</p>
<ul>
<li>Create explicit 2.x-style unbound methods—that are then inspectable as methods, rather than as functions.</li>
<li>Create "rebindable" methods as part of building a prototype object system. (Normal method objects just ignore their arguments in <code>__get__</code>, except for checking that either the second one is a type, or the second is <code>None</code> and the first is a type…)</li>
<li>Create an object that mimics a function (rather than just a callable, the way methods, partials, etc. do), including being able to act as an unbound method, the result of a staticmethod, etc.</li>
</ul>
<p>None of these are things you're going to want to do very often, but they're also not things Python has any reason to prevent you from doing.</p>
</div>
<span class="comment-copy">Are you asking specifically why <code>types.MethodType.__get__</code> exists, or are you asking the more general question in your title?</span>
<span class="comment-copy">Also, consider that most non-data descriptors are going to return a plain-old function from <code>__get__</code>. See the pure-Python <code>ClassMethod</code> at the end of the the descriptor HOWTO for an example. And functions obviously have to be non-data descriptors or methods couldn't work at all.</span>
<span class="comment-copy">I think there was some argument about it not being superfluous because "methods should continue to act like functions". Although that argument is probably spurious (their <code>__get__</code> may exist, but it doesn't do the same thing as a function's <code>__get__</code>; the interpreter never does this reflection; if an end-user wants to do this reflection they should be using <code>inspect</code> which will treat them as different in every way except for both being callable; etc.), without actually hashing the argument out in full, the default is always to err on the side of backward compatibility.</span>
