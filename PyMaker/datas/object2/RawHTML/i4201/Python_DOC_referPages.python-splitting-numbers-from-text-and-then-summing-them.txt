<div class="post-text" itemprop="text">
<p>All I have a text file formatted like below which I am bringing into Python:</p>
<pre><code>    hammer#9.95
    saw#20.15
    shovel#35.40
</code></pre>
<p>Ultimately I want to develop a dynamic query that allows me to remove the '#' symbol and replace with a '$' symbol, and then add up the values within the text file/count the number of items within. I came up with this through some trial and error, but it isn't dynamic to handle changes in the text file:</p>
<pre><code> # display header line for items list
print('{0: &lt;10}'.format('Item'), '{0: &gt;17}'.format('Cost'), sep = '' )

# add your remaining code below
with open('invoice.txt','rt') as infile:
    for line in infile:
        print("{:&lt;21} {}".format(line.strip().split('#')[0],"$"+line.strip().split("#")[1]))

print(' ')
str1 = 'Total cost\t' +'      ' + '$65.50'
print(str1)

str2 = 'Number of tools\t' + '           ' +'3'
print(str2)
</code></pre>
<p>Any suggestions? Thanks ahead of time for reading.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it the following way:</p>
<pre><code>d = ['hammer#9.95', 'saw#20.15', 'shovel#35.40']

## replace hash
values = []
items = set()
for line in d:
    line = line.replace('#', '$')
    values.append(line.split('$')[1])
    items.add(line.split('$')[0])

## sum values
sum(map(lambda x: float(x), values)) 
65.5

## count items
len(items)
3
</code></pre>
<p><strong>Explanation:</strong> </p>
<ol>
<li>To count items, we've used a set to get unique count. If you want all, use a list instead.</li>
<li>We've calculated sum by extracting the numbers from list by splitting on dollar sign.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<pre><code>prices = []
with open(...) as infile:
    for line in infile.readlines()
        price = line.split('#')[-1]
        prices.append(float(price))
result = sum(prices)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about:</p>
<pre><code>items = {}
with open("temp.txt") as f:
    for line in f:
        item,cost = line.split('#')
        cost = float(cost)
        items[item] = cost
</code></pre>
<p>Now, you have a dictionary, keyed by item "name" (so they need to be unique in your file, otherwise a dictionary isn't the best structure here) and each value is a float corresponding to the parsed cost.</p>
<pre><code># Print items and cost
print(items.items())
#&gt; dict_items([('hammer', 9.95), ('saw', 20.15), ('shovel', 35.4)])

# Print Number of Items
print(len(items))
#&gt; 3

# Print Total Cost (unformatted)
print(sum(items.values()))
#&gt; 65.5

# Print Total Cost (formatted)
print("$%.02f" % sum(items.values()))
#&gt; $65.50
</code></pre>
<p>There are some corner cases you may want to look at to make this solution more robust.  For example if the item "name" includes a # sign (i.e. there is more than one # per line), the values aren't properly formatted to be parsed by <code>float</code>, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code>total_price, total_products = 0, 0
for line in [open('invoice.txt').read().split("\n")]: 
    total_price += float(line.split("#")[1]); total_products += 1
print("Total Price\n${}".format(total_price))
print("Number of tools\n{}".format(total_products))
</code></pre>
<hr/>
<pre><code>Total Price
$65.5
Number of tools
3
</code></pre>
<hr/>
<p>We have to <code>cast</code> the <strong>price</strong> (<code>line.split("#")[1]</code>), which is a <code>string</code>,  to a <code>float</code>, otherwise we get a <code>Type Error</code> when we try to <code>add</code> it to <code>total_price</code>.</p>
<pre><code>float(line.split("#")[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since it is long due that i should refresh my Python skills i had some fun with your question and came up with a parser class:</p>
<pre><code>import re
from contextlib import contextmanager


class Parser(object):

    def __init__(self, file_path, regex):
        self.file_path = file_path
        self.pattern = re.compile(regex, flags=re.LOCALE | re.IGNORECASE | re.UNICODE)
        self.values = []
        self.parse()

    @contextmanager
    def read_lines(self):
        try:
            with open(self.file_path, "r", encoding="utf-8") as f:
                yield f.readlines()
        except FileNotFoundError:
            print("Couldn't open file: ", self.file_path)

    def parse_line(self, line):
        try:
            return self.pattern.match(line).groupdict()
        except AttributeError:
            return None

    def parse(self):
        with self.read_lines() as lines:
            self.values = [value for value in map(self.parse_line, lines) if value]

    def get_values(self, converters=dict()):
        if len(converters) is 0:
            return self.values
        new_values = []
        for value in self.values:
            new_value = {}
            for key in value:
                if key in converters:
                    new_value[key] = converters[key](value[key])
                else:
                    new_value[key] = value[key]
            new_values.append(new_value)
        return new_values
</code></pre>
<p>This class takes a file path and a regex-like string, which is then compiled to a regex object. On instantiation it reads and parses the contents of the file while ignoring invalid lines (not matching the regex syntax like empty lines).</p>
<p>I also added a <code>get_values</code> method which can apply converters to named groups from the regex, see the example (it converts the named group <code>price</code> of every line into a float value):</p>
<pre><code>parser = Parser(r"fully_qualified_file_path.txt", r".\s*(?P&lt;name&gt;[\w\s]+)\#(?P&lt;price&gt;[\d\.]+)")

total = 0
count = 0
for line in parser.get_values({'price': lambda x: float(x)}):
    total += line['price']
    count += 1
    print('Item: {name}, Price: ${price}'.format(**line))

print()
print('Item count:', count)
print('Total:', "${0}".format(total))
</code></pre>
<p>Result</p>
<pre><code>Item: hammer, Price: $9.95
Item: saw, Price: $20.15
Item: shovel, Price: $35.4

Item count: 3
Total: $65.5
</code></pre>
<p>But coding fun aside, i suggest you try to get clean csv-like data and handle it properly through the <code>csv</code> class.</p>
</div>
<span class="comment-copy">For "dynamicity", see regex: <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">docs.python.org/3/library/re.html</a></span>
