<div class="post-text" itemprop="text">
<p>I need the dependencies because I want to add these to my RPM meta-data.</p>
<p>To build I use:</p>
<pre><code>python setup.py bdist_rpm
</code></pre>
<p>When I build the package <code>cryptography-2.2.2</code> it creates a file <code>/src/cryptography.egg-info/requires.txt</code></p>
<p>It contains:</p>
<pre><code>idna&gt;=2.1
asn1crypto&gt;=0.21.0
six&gt;=1.4.1

[:platform_python_implementation != 'PyPy']
cffi&gt;=1.7

[:python_version &lt; '3']
enum34
ipaddress
</code></pre>
<p>How can I read all dependencies, evaluating the expression between <code>[]</code>?</p>
<p>I'm using Python 2.7 (don't ask)</p>
<p>I need the following output:</p>
<pre><code>idna&gt;=2.1
asn1crypto&gt;=0.21.0
six&gt;=1.4.1
cffi&gt;=1.7
enum34
ipaddress
</code></pre>
<p>I want to omit other sections like <code>[doc]</code>, <code>[test]</code> etcetera.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>requires.txt</code> is part of the <a href="http://setuptools.readthedocs.io/en/latest/formats.html#dependency-metadata" rel="nofollow noreferrer">dependency metadata</a>, so you can use the same tools <code>easy_install</code> uses when installing the egg. Assuming the file <code>requires.txt</code> is in the current directory:</p>
<pre><code>In [1]: from pkg_resources import Distribution, PathMetadata

In [2]: dist = Distribution(metadata=PathMetadata('.', '.'))
</code></pre>
<p>Now you can filter all dependencies for your current platform with <code>Distribution.requires()</code>:</p>
<pre><code>In [3]: sys.version
Out[3]: '3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) \n[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]'

In [4]: dist.requires()
Out[4]:
[Requirement.parse('idna&gt;=2.1'),
 Requirement.parse('asn1crypto&gt;=0.21.0'),
 Requirement.parse('six&gt;=1.4.1'),
 Requirement.parse('cffi!=1.11.3,&gt;=1.7'),
 Requirement.parse('cffi&gt;=1.7')]
</code></pre>
<p>The list would be different if I used Python 2.7:</p>
<pre><code>In [4]: sys.version
Out[4]: '2.7.10 (default, Oct  6 2017, 22:29:07) \n[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.31)]'

In [5]: dist.requires()
Out[5]:
[Requirement.parse('idna&gt;=2.1'),
 Requirement.parse('asn1crypto&gt;=0.21.0'),
 Requirement.parse('six&gt;=1.4.1'),
 Requirement.parse('cffi!=1.11.3,&gt;=1.7'),
 Requirement.parse('cffi&gt;=1.7'),
 Requirement.parse('enum34'),
 Requirement.parse('ipaddress')]
</code></pre>
<p>or PyPy:</p>
<pre><code>In [2]: sys.version
Out[2]: '3.5.3 (fdd60ed87e941677e8ea11acf9f1819466521bf2, Apr 26 2018, 01:25:35)\n[PyPy 6.0.0 with GCC 4.2.1 Compatible Apple LLVM 9.1.0 (clang-902.0.39.1)]'

In [3]: d.requires()
Out[3]:
[Requirement.parse('idna&gt;=2.1'),
 Requirement.parse('asn1crypto&gt;=0.21.0'),
 Requirement.parse('six&gt;=1.4.1'),
 Requirement.parse('cffi!=1.11.3,&gt;=1.7')]
</code></pre>
<p>Now, if you want to generate a list of requirement strings (like when you want to generate a requirements file for <code>pip</code>), convert the requirements to strings:</p>
<pre><code>In [8]: os.linesep.join(str(r) for r in dist.requires())
Out[8]:
'idna&gt;=2.1\nasn1crypto&gt;=0.21.0\nsix&gt;=1.4.1\ncffi!=1.11.3,&gt;=1.7'
</code></pre>
<hr/>
<h3>PEP 508</h3>
<p>If you also want to take <a href="https://www.python.org/dev/peps/pep-0508/#environment-markers" rel="nofollow noreferrer">PEP 508 environment markers</a> into account independent of the current platform, things can get a bit trickier, but still manageable. First, convert the requirements with env markers:</p>
<pre><code>In [22]: dep_map_pep508 = {k: v for k, v in dist._build_dep_map().items() if k and k.startswith(':')}

In [24]: reqs_pep508 = [str(r) + ';' + k.lstrip(':') for k, v in dep_map_pep508.items() for r in v]

In [25]: reqs_pep508
Out[25]:
["cffi&gt;=1.7;platform_python_implementation != 'PyPy'",
 "enum34;python_version &gt;= '3'",
 "ipaddress;python_version &gt;= '3'"]
</code></pre>
<p>Now handle the platform-independent deps, these house under the <code>None</code> key in <code>dist</code>'s dependency map:</p>
<pre><code>In [26]: reqs_no_platform = [str(r) for r in dist._build_dep_map()[None]]

In [27]: reqs_no_platform
Out[27]: ['idna&gt;=2.1', 'asn1crypto&gt;=0.21.0', 'six&gt;=1.4.1', 'cffi!=1.11.3,&gt;=1.7']
</code></pre>
<p>Combine both lists to a string ready to be written to requirements file:</p>
<pre><code>In [28]: os.linesep.join(reqs_no_platform + reqs_pep508)
Out[28]: "idna&gt;=2.1\nasn1crypto&gt;=0.21.0\nsix&gt;=1.4.1\ncffi!=1.11.3,&gt;=1.7\ncffi&gt;=1.7;platform_python_implementation != 'PyPy'\nenum34;python_version &gt;= '3'\nipaddress;python_version &gt;= '3'"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So I was able to find one working solution for the same, there might be other possibilities as well, but i think this should work on most versions</p>
<pre><code>import pkg_resources

lines = open("requirements.txt").readlines()

load_packages = True
for line in lines:
    if line.strip().startswith("#"):
        continue

    if line.startswith("[:"):
        # this is marker, let's evaluate
        load_packages = pkg_resources.evaluate_marker(line.strip()[2:-1])
        continue
    elif line.startswith("["):
        # this is a subsection ignore it
        load_packages = False

    if load_packages and line.strip():
        print(line.strip())
</code></pre>
<p>The output of the same is below</p>
<pre><code>idna&gt;=2.1
asn1crypto&gt;=0.21.0
six&gt;=1.4.1
cffi&gt;=1.7
enum34
ipaddress
</code></pre>
<p>If I change the <code>requirements.txt</code> like below</p>
<pre><code>idna&gt;=2.1
asn1crypto&gt;=0.21.0
six&gt;=1.4.1

[:platform_python_implementation == 'PyPy']
cffi&gt;=1.7

[:python_version &gt; '3']
enum34
ipaddress
</code></pre>
<p>The output changes to</p>
<pre><code>idna&gt;=2.1
asn1crypto&gt;=0.21.0
six&gt;=1.4.1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could test the beginning of each line to whether or not it is a match to the pip dependency declaration format.</p>
<p>Regex is probably the best solution to pattern matching:</p>
<pre><code>pattern = r'^[\w\d_-]+'
</code></pre>
<p>Where:</p>
<ul>
<li><code>^</code> matches to beginning of line/file</li>
<li><code>[\w\d_-]+</code> matches any word (<code>\w</code>), digit (<code>\d</code>), underscore (<code>_</code>), and dash (<code>-</code>) more than once.</li>
</ul>
<p>All in all:</p>
<pre><code>from re import match

pattern = r'^[\w\d_-]+'
with open('requires.txt') as file:
    for line in file:
        if match(pattern, line):
            print(line.strip())
</code></pre>
<p>Result:</p>
<pre><code>$ python2.7 test.py
idna&gt;=2.1
asn1crypto&gt;=0.21.0
six&gt;=1.4.1
cffi&gt;=1.7
enum34
ipaddress
</code></pre>
</div>
<span class="comment-copy">Have you tried <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer">docs.python.org/3/library/configparser.html</a> ?</span>
<span class="comment-copy">@ChristianSauer When I do a pip install it evaluates the expressions such as <code>[:python_version &lt; '3']</code>. I'd like to access what has been used during the build of the package.</span>
<span class="comment-copy"><code>pip freeze</code> after install gives the exactly installed versions. Not per dependency, just the whole set. Otherwise look at <code>pipenv</code>.</span>
<span class="comment-copy">@ThePjot Good idea, but it also lists build time dependencies which are not runtime dependencies. I don't want the tools required to build documentation on my target system, only the minimum it needs to run. I'll check out <code>pipenv</code>.</span>
<span class="comment-copy">Is this file pip compatible? Because my pip will error out with this requirements file with error <code>InvalidRequirement: Invalid requirement, parse error at "u'[:platfo'"</code></span>
<span class="comment-copy">This is great. It allows me to pick up a full list after building a package. Thanks!</span>
<span class="comment-copy">Nice. This works in most cases but, I want to omit other sections like [doc], [test] etcetera. The accepted answer covers that.</span>
<span class="comment-copy">@EddyPronk My solution omits those sections but I agree, the accepted answer is what I would go with as well.</span>
