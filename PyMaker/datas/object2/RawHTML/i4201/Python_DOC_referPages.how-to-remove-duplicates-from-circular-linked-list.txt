<div class="post-text" itemprop="text">
<p>My code is given below. It appends some numbers to the circular list. My program works fine. It gives an exact output of [5,3,3] or any numbers entered. But I want to make some changes in the output. without adding any new function what kind of changes to make in the <code>def append(....)</code> and <code>def add_before(...)</code> so it gives a unique number which means it gets rid of the duplicates. for example, will give [5,3]</p>
<pre><code>class CirList:
    def __init__(self):
        head_node = NodeDLL(None)
        head_node.next = head_node
        head_node.prev = head_node
        self.__head = head_node

    def append(self, item):
        curr = self.__head
        new_node = NodeDLL(item, curr, curr.get_prev())
        curr.set_prev(new_node)
        new_node.get_prev().set_next(new_node)

    def add_before(self, item, old_item):
        curr = self.__head.next
        found = False
        while curr.get_data() != None and not found:
            if curr.get_data() == old_item:
                found = True  
            else:
                curr = curr.get_next()
        if found:
            new_node = NodeDLL(item, curr, curr.get_prev())
            curr.set_prev(new_node)
            new_node.get_prev().set_next(new_node)
        return found
    def remove(self, item):
        curr = self.__head.next
        found = False
        while curr.get_data() != None and not found:
            if curr.get_data() == item:
                found = True
            else:
                curr = curr.get_next()
        if found:       
            curr.get_prev().set_next(curr.get_next())
            curr.get_next().set_prev(curr.get_prev())
    def printall(self):
        curr = self.__head.next
        while curr.get_data() != None:
            print(curr.get_data(), end=" ")
            curr = curr.get_next()
        print()
    def __str__(self):
        result = "["
        curr = self.__head.next 
        while curr.get_data() != None:
            result += str(curr.get_data()) + " "
            curr = curr.get_next()
        result = result.rstrip(" ")
        result += "]"
        return result 
</code></pre>
<p>Test </p>
<pre><code>listA = CirList()
listA.append(5)
listA.append(3)
listA.append(3)
print(listA)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two options (I can think of): </p>
<p><em>Don't add duplicates</em>:</p>
<pre><code>class CirList:
    def __init__(self):
        head_node = NodeDLL(None)
        head_node.next = head_node
        head_node.prev = head_node
        self.__head = head_node
        self._knownNumbers = set() # optimized lookup if number known

    def append(self, item):
        if item not in self._knownNumbers: # only add if not known
            self.__knownNumbers__.add(item)
            curr = self.__head
            new_node = NodeDLL(item, curr, curr.get_prev())
            curr.set_prev(new_node)
            new_node.get_prev().set_next(new_node)

    def add_before(self, item, old_item):
        if item not in self._knownNumbers: # only add if not known
            self.__knownNumbers__.add(item)
            curr = self.__head.next
            found = False
            while curr.get_data() != None and not found:
                if curr.get_data() == old_item:
                    found = True  
                else:
                    curr = curr.get_next()
            if found:
                new_node = NodeDLL(item, curr, curr.get_prev())
                curr.set_prev(new_node)
                new_node.get_prev().set_next(new_node)
            return found
    def remove(self, item):
        self._knownNumbers.remove(item) # forget this number again
        curr = self.__head.next
        found = False
        while curr.get_data() != None and not found:
            if curr.get_data() == item:
                found = True
            else:
                curr = curr.get_next()
        if found:       
            curr.get_prev().set_next(curr.get_next())
            curr.get_next().set_prev(curr.get_prev())
</code></pre>
<p>Or simply <em>do not print duplicates</em>:</p>
<pre><code>def __str__(self):
    result = "["
    curr = self.__head.next
    known = set() # keep what we added already
    while curr.get_data() != None:
        if curr.get_data() not in known: # only add if not yet added
            result += str(curr.get_data()) + " "
            known.add(curr.get_data())   # remember this one
        curr = curr.get_next()
    result = result.rstrip(" ")
    result += "]"
    return result 
</code></pre>
<p>You would have to modify your <code>printall()</code> accordingly if you want it to mimic this behaviour  - you would still store all duplicates though so does not make much sense to me, unless you create a seperate <code>def printNoDuplicates(self)</code> specificly for this purpose.</p>
</div>
<span class="comment-copy">You'll need to search the list to see if it exists and only if it doesn't add it</span>
<span class="comment-copy">Why not simply use a <code>set</code> instead?</span>
<span class="comment-copy">@Thomas then it wouldn't be a circular linked list</span>
<span class="comment-copy">@NickA True. But most of the time, our aim is not to "use a circular linked list" but to "store some items". (Maybe in a particular order, in which case <a href="https://stackoverflow.com/questions/1653970/does-python-have-an-ordered-set">click here</a>.)</span>
<span class="comment-copy">@Thomas, true, i cant think of any reasons to actually use a circularly linked list (over some other structure)</span>
<span class="comment-copy">Thank you. Would you able to explain me    self.__knownNumbers__ = set() in the <b>init</b> function.. is it a function ...</span>
<span class="comment-copy">@mini, have a look at <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">Sets in Python</a>.</span>
<span class="comment-copy">It's a very bad use a <code>__dunder__</code> name for that attribute. Names with leading and trailing double underscores like that are reserved for the Python language designers. It's possible (though unlikely, I'll admit) that <code>__knownNumbers__</code> will get some interpreter-enforced meaning in the future, which would break code that used it for its own purposes. Just use a normal name instead. I'd also suggest that the questioner use <code>self.head</code> instead of <code>self.__head</code>. Name mangling is not at all necessary here (it's intended to help mixin and proxy classes avoid name clashes, not for data protection).</span>
<span class="comment-copy">@Blckknght changed <code>self.__knownNumbers__</code> to <code>self._knownNumbers</code> according to pep-8. Thanks &amp; do not delete the comment - I like to find those gems at answers.</span>
<span class="comment-copy">@mini set is a datatype - esssentially an unordered "list" of unique values - no duplicates/no order with a very fast lookup. Think math, middle grades and set theory. Its very good at checking if something is in it, and has several cool operations like union, difference, symetric diff, subset/superset etc. and does lookups in O(1) - much faster then a list can do which has to traverse its element.</span>
