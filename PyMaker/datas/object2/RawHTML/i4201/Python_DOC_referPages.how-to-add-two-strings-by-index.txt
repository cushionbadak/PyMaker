<div class="post-text" itemprop="text">
<p>I tried many times but could not do it.</p>
<p>Here is an example:</p>
<pre><code>print( concat_corresponding( "12345", "6789XYZ" ) )
</code></pre>
<p>Desired output:</p>
<pre><code>162738495XYZ
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one way with <code>itertools</code>:</p>
<pre><code>from itertools import chain, zip_longest

a = "12345"
b = "6789XYZ"

res = ''.join(list(chain.from_iterable(zip_longest(a, b, fillvalue=''))))

# '162738495XYZ'
</code></pre>
<p>Note the list conversion is not required, but <a href="https://stackoverflow.com/a/37782238/9209546">improves performance</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can levarege list comprehensions, join and zip:</p>
<pre><code>te1 = "12345"
te2 = "6789XYZ"

print (''.join( ''.join(x) for x in zip(te1,te2)) + (te1[len(te2):] if len(te1)&gt;len(te2) else te2[len(te1):]))
                                                    # ^^^^ this part adds the remainer of longer list to result
</code></pre>
<p>output:</p>
<pre><code>162738495XYZ
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#zip</a></p>
<p><a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#str.join</a></p>
<p>Explanation:</p>
<p>zip pairs up the characters by position, the rest makes the list of pairs back into a string.</p>
<p>Zip only works for the shorter length string - you can switch to itertools.zip_longest (<a href="https://stackoverflow.com/a/50068970/7505395">see JimDennis answer</a>) or append the longer lists part (like I did here)</p>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">itertools.zip_longest(*iterables, fillvalue=None)</a> </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import izip_longest
''.join(['%s%s' % (x ,y)\
         for x,y in izip_longest("12345","6789XYZ", fillvalue='')])

## Was: ''.join(['%s%s' % (x if x else '',y if y else '') \
##         for x,y in izip_longest("12345","6789XYZ")])
</code></pre>
<p>To break that down a bit:  </p>
<ul>
<li>the builtin <em>zip()</em> function zips only to the shorter of the two sequences; so we use <em>izip_longest()</em> from the <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">itertools</a> standard library module</li>
<li><em>izip_longest()</em> pads the generated sequences with <em>None</em> by default; so we add the <em>fillvalue=''</em> optional (keyword) argument</li>
<li>the resulting substrings are all just joined together to form your results.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I think this solution is a little cleaner and takes advantage of the <code>fillvalue</code> keyword argument for <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a>.</p>
<pre><code>from itertools import zip_longest 

''.join(a+b for a, b in zip_longest(s1, s2, fillvalue=''))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one is basic but useful</p>
<pre><code>str1="12345"
str2="6789XYZ"
str3=""
i=0
for i, ch in enumerate(zip(str1, str2)):
    str3 += ch[0] + ch[1]

if len(str1) &lt; len(str2):
    str3 += str2[i+1:]
else:
    str3 += str1[i+1:]
print(str3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way of doing it is the following:</p>
<pre><code>def concat_corresponding(string1, string2):
    minimum, maximum = sorted([string1, string2], key=len)
    return "".join(string1[i]+string2[i] for i in range(len(minimum))) + maximum[len(minimum):]

print(concat_corresponding( "12345", "6789XYZ" )) 
</code></pre>
<p>Output:</p>
<pre><code>162738495XYZ   
</code></pre>
</div>
<span class="comment-copy">show us what you've tried...show us <code>concat_corresponding</code> code. Is <code>162738495XYZ</code> the expected output or what you're getting?</span>
<span class="comment-copy">Did an answer below help? Feel free to accept an answer (green tick on left), or ask for clarification.</span>
<span class="comment-copy">This cuts off YZ since the strings are of different lengths.</span>
<span class="comment-copy">Yeah, need to either zip up the slices that can be matched (and then append a slice from the longer one ... or use something like <i>itertools.izip_longest()</i> and munge the None values into empty strings (see my answer).</span>
<span class="comment-copy">@WStokvis fixed that</span>
<span class="comment-copy">@JimDennis thanks for the comment, was just editing that ;)#</span>
<span class="comment-copy">You can simply give <code>''</code> as fillvalue: <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">itertools.zip_longest(*iterables, fillvalue=None)</a> no need to munge</span>
<span class="comment-copy">Good point.  Fixed in the posting.</span>
