<div class="post-text" itemprop="text">
<p>I'm attempting to match words in a string that contain two or more distinct vowels.  The question can be restricted to lowercase.</p>
<blockquote>
<p>string = 'pool pound polio papa pick pair'</p>
</blockquote>
<p>Expected result:</p>
<blockquote>
<p>pound, polio, pair</p>
</blockquote>
<p>pool and papa would fail because they contain only one distinct vowel. However, polio is fine, because even though it contains two 'o's, it contains two distinct vowels ('i' and 'o').  mississippi would fail, but albuquerque would pass).</p>
<p>Thought process: Using a lookaround, perhaps five times (ignore uppercase), wrapped in a parenthesis, with a {2} afterward.  Something like:</p>
<pre><code>re.findall(r'\w*((?=a{1})|(?=e{1})|(?=i{1})|(?=o{1})|(?=u{1})){2}\w*', string)
</code></pre>
<p>However, this matches on all six words.</p>
<p>I killed the {1}s, which makes it prettier (the {1}s seem to be unnecessary), but it still returns all six:</p>
<pre><code>re.findall(r'\w*((?=a)|(?=e)|(?=i)|(?=o)|(?=u))\w*', string)
</code></pre>
<p>Thanks in advance for any assistance.  I checked other queries, including <a href="https://stackoverflow.com/questions/29689858/how-to-find-words-with-two-vowels">"How to find words with two vowels"</a>, but none seemed close enough.  Also, I'm looking for pure RegEx.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>\w*((?=a)|(?=e)|(?=i)|(?=o)|(?=u))\w*</code> regex matches all words that have at least 1 any vowel. <code>\w*</code> matches 0+ word chars, so the first pattern grabs the whole chunk of letters, digits and underscores. Then, backtracking begins, the regex engine tries to find a location that is followed with either <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, or <code>u</code>. Once it finds that location, the previously grabbed word chars are again grabbed and consumed with the trailing <code>\w*</code>.</p>
<p>To match whole words with at least 2 different vowels, you may use</p>
<pre><code>\b(?=\w*([aeiou])\w*(?!\1)[aeiou])\w+
</code></pre>
<p>See the <a href="https://regex101.com/r/gWrubw/1" rel="nofollow noreferrer">regex demo</a>.</p>
<p><strong>Details</strong></p>
<ul>
<li><code>\b</code> - word boundary</li>
<li><code>(?=\w*([aeiou])\w*(?!\1)[aeiou])</code> - a <a href="https://www.regular-expressions.info/lookaround.html" rel="nofollow noreferrer">positive lookahead</a> that, immediately to the left of the current location, requires 

<ul>
<li><code>\w*</code> - 0+ word chars</li>
<li><code>([aeiou])</code> - <a href="https://www.regular-expressions.info/brackets.html" rel="nofollow noreferrer"><strong>Capturing group</strong></a> 1 (its value is referenced to with <a href="https://www.regular-expressions.info/backref.html" rel="nofollow noreferrer"><code>\1</code> <strong>backreference</strong></a> later in the pattern): any vowel</li>
<li><code>\w*</code> - 0+ word chars</li>
<li><code>(?!\1)[aeiou]</code> - any vowel from the <code>[aeiou]</code> set that is not equal to the vowel stored in Group 1 (due to the negative lookahead <code>(?!\1)</code> that fails the match if, immediately to the right of the current location, the <a href="https://www.regular-expressions.info/lookaround.html" rel="nofollow noreferrer">lookahead</a> pattern match is found)</li>
</ul></li>
<li><code>\w+</code> - 1 or more word chars.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You don't need 5 separate lookaheads, that's complete overkill. Just capture the first vowel in a <a href="https://docs.python.org/3/howto/regex.html#grouping" rel="nofollow noreferrer">capture group</a>, and then use a <a href="https://docs.python.org/3/howto/regex.html#lookahead-assertions" rel="nofollow noreferrer">negative lookahead</a> to assert that it's different from the second vowel:</p>
<pre><code>[a-z]*([aeiou])[a-z]*(?!\1)[aeiou][a-z]*
</code></pre>
<p><a href="https://regex101.com/r/K2Yppn/1" rel="nofollow noreferrer">See the online demo.</a></p>
</div>
<span class="comment-copy">"The {1}s seem unnecessary" suggests you are not quite aware what it does. The parentheses make things unclear but I don't think you can repeat a lookahead two times â€“ if the syntax allows it (and apparently it does, because else you'd get an error), then it tests the same lookahead <i>twice</i>.</span>
<span class="comment-copy">Wonderful, thank you.  It would seem "capturing groups" and that funky little "\1" will be my next focus of study.  Thanks again!</span>
