<div class="post-text" itemprop="text">
<p>In my application, I need a fast look up of attributes. Attributes are in this case a composition of a string and a list of dictionaries. These attributes are stored in a wrapper class. Let's call this wrapper class <code>Plane</code>:</p>
<pre><code>class Plane(object):
    def __init__(self, name, properties):
        self.name = name
        self.properties = properties

    @classmethod
    def from_idx(cls, idx):
        if idx == 0:
            return cls("PaperPlane", [{"canFly": True}, {"isWaterProof": False}])
        if idx == 1:
            return cls("AirbusA380", [{"canFly": True}, {"isWaterProof": True}, {"hasPassengers": True}])
</code></pre>
<p>To better play with this class, I added a simple classmethod to construct instances by providing and integer.</p>
<p>So now in my application I have many Planes, of the order of 10,000,000. Each of these planes can be accessed by a universal unique id (uuid). What I need is a fast lookup: given an uuid, what is the Plane. The natural solution is a dict. A simple class to generate planes with uuids in a dict and to store this dict in a file may look like this:</p>
<pre><code>class PlaneLookup(object):
    def __init__(self):
        self.plane_dict = {}

    def generate(self, n_planes):
        for i in range(n_planes):
            plane_id = uuid.uuid4().hex
            self.plane_dict[plane_id] = Plane.from_idx(np.random.randint(0, 2))

    def save(self, filename):
        with gzip.open(filename, 'wb') as f:
            pickle.dump(self.plane_dict, f, pickle.HIGHEST_PROTOCOL)

    @classmethod
    def from_disk(cls, filename):
        pl = cls()
        with gzip.open(filename, 'rb') as f:
            pl.plane_dict = pickle.load(f)
        return pl
</code></pre>
<p>So now what happens is that if I generate some planes?</p>
<pre><code>pl = PlaneLookup()
pl.generate(1000000)
</code></pre>
<p>What happens is, that lots of memory gets consumed! If I check the size of my <code>pl</code> object with the getsize() method <a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">from this question</a>, I get on my 64bit machine a value of 1,087,286,831 bytes. Looking at htop, my memory demand seems to be even higher (around 2GB).
<a href="https://stackoverflow.com/questions/10264874/python-reducing-memory-usage-of-dictionary">In this question</a>, it is explained quite well, why python dictionaries need much memory. </p>
<p>However, I think this does not have to be the case in my application. The plane object that is created in the PlaneLookup.generate() method contains very often the same attributes (i.e. the same name and the same properties). So it has to be possible, to save this object once in the dict and whenever the same object (same name, same attribute) is created again, only a reference to the already existing dict entry is stored. As a simple Plane object has a size of 1147 bytes  (according to the <code>getsize()</code> method), just saving references may save a lot of memory! </p>
<p>The question is now: How do I do this? In the end I need a function that takes a uuid as an input and returns the corresponding <code>Plane</code> object as fast as possible with as little memory as possible.
Maybe lru_cache can help?</p>
<p>Here is again the full code to play with:
<a href="https://pastebin.com/iTZyQQAU" rel="nofollow noreferrer">https://pastebin.com/iTZyQQAU</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Did you think about having another dictionary with idx -&gt; plane? then in <code>self.plane_dict[plane_uuid]</code> you would just store idx instead of object. this will save memory and speed up your app, though you'd need to modify the lookup method.</p>
</div>
<span class="comment-copy">Are planes supposed to be treated as immutable?</span>
<span class="comment-copy">Can you use a small database?</span>
<span class="comment-copy"><code>Plane</code> doesn't appear to need to be a class, as you don't have any methods. Representing each <code>Plane</code> as a simple tuple may be a better idea.</span>
<span class="comment-copy">I would suggest using Python's <a href="https://docs.python.org/3/library/shelve.html#module-shelve" rel="nofollow noreferrer">shelve</a> module which provides an dictionary-like interface to a file-based databaseâ€”so doesn't require it all to be in memory.</span>
<span class="comment-copy">Why are you storing a list of single-element <code>dict</code> objects for the <code>properties</code> attribute??? That is perhaps the least useful data structure you could possible come up with. Just use a single <code>dict</code>, or better yet, make them <i>individual attributes</i> on your object (which pretty much is a dict anyway...)</span>
<span class="comment-copy">My example was bad here, i guess. This is not possible, since there might be planes which were not generated by an index but by the class constructor. The indices are just a helper function.</span>
<span class="comment-copy">then try to have a registry of all planes generates and store new indexes by instance. or do make use of <code>__hash__</code> function and store planes in the registry only if the hash is not present and store the hash in <code>plane_dict</code>.</span>
