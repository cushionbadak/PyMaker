<div class="post-text" itemprop="text">
<p>I am flipping through the book Fluent Python. It states that for a sequence of all numbers, array is more efficient and faster than a List. From what I gather from this, it also has less of a memory overhead. It states "A Python array is as lean as a C array." </p>
<p>I am curious as to why an array here would show as having more memory than an list.</p>
<pre><code>import array
from random import random
import sys

floats = array.array('d', (random() for i in range(10**7)))
L = [random() for i in range(10**7)]
print(sys.getsizeof(floats))
print(sys.getsizeof(L))
</code></pre>
<p>output</p>
<pre><code>81940352
81528056
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You just picked the wrong example. The point of using <code>array</code> is when you need to store items whose native representation is smaller than that of a Python object reference. (Which seems to be 8 bytes here.) E.g. if you do:</p>
<pre><code>from array import array
from os import urandom
a = array('B', urandom(1024))
l = list(a)
sys.getsizeof(a) # =&gt; 1155
sys.getsizeof(l) # =&gt; 9328
</code></pre>
<p>Since <code>double</code>s are also 8 bytes wide there really isn't a more compact way to store them than a different 8 bytes.</p>
<hr/>
<p>As for the rest of the claims in the book take them with a grain of salt - you can't run Python code - that is, have operations be executed by the Python interpreter - and be as fast as C. You're still incurring overhead when writing Python objects to or reading them from the array, what would be faster is doing some sort of big operation over the entire array in a native function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sorry, but I don't think the answer of @millimoose explains well, what is really going on or what the author meant, when he said that an array is faster than a list.</p>
<p><strong>Memory footprint:</strong></p>
<p>A double needs 8 bytes and that is exactly how much memory is needed if you store it in an <code>array</code> - it is not stored as a Python-Float, but as a raw 8-byte value. There is however a small overhead due to overallocation and some additional data saved in the array object (size of the array, size of the buffer, type of the values in the array and so on).</p>
<p>A Python-Float needs more than 8 bytes:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; f=1.0
&gt;&gt;&gt; sys.getsizeof(f)
24
</code></pre>
<p>24 bytes - quite small for a Python-object! For example an usual empty Python-object would need (Python3):</p>
<pre><code>&gt;&gt;&gt; class A:
      pass

&gt;&gt;&gt; a=A()
&gt;&gt;&gt; sys.getsizeof(a)
56
</code></pre>
<p>56 bytes. There are tricks to reduce the number of needed bytes and they are all used for Python-Floats but you still need  8 bytes for the double-value, another 8 Bytes for the reference counter and also 8 bytes for a pointer to the type-description (so the object know it is a Float-object).</p>
<p>In addition, not the object itself is stored in the list but a reference (i.e. pointer) to it, which needs 8 bytes itself. So there are basically 32 bytes needed to save a Python-float in a list - 4 times the amount of memory used.</p>
<p>So why do you see something different when calling <code>sys.getsizeof</code> for the list? The answer: <code>sys.getsizeof</code> is <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer">not recursive</a>:</p>
<blockquote>
<p>sys.getsizeof(object[, default])</p>
<p>....</p>
<p>Only the memory consumption <strong>directly attributed</strong> to the object is accounted for, not the memory consumption of objects it refers to.</p>
</blockquote>
<p>That means the <code>getsizeof</code> for the list counts only the memory needed for the references to Float-objects (8 bytes per reference) and not the size of the objects. To illustrate that:</p>
<pre><code>&gt;&gt;&gt; lst=[list(range(1000))]
&gt;&gt;&gt; sys.getsizeof(lst)
72
</code></pre>
<p>Obviously, more memory than the reported 72 bytes is used.</p>
<p>To see the real memory consumption you need to consider the memory needed by the interpreter:</p>
<pre><code>&gt;&gt;&gt; /usr/bin/time -fpeak_used_memory:%M python -c "l=list((float(i) for i in range(10**7)))"
peak_used_memory:326832
&gt;&gt;&gt; /usr/bin/time -fpeak_used_memory:%M python -c "import array; a=array.array('d',(float(i) for i in range(10**7)))"
peak_used_memory:88076
</code></pre>
<p>As we can see the difference (320 MB vs 80MB) is about the expected factor 4.</p>
<p><strong>Speed:</strong></p>
<p>The author is not saying, that using <code>array.array</code> with python-interpreter will give you a speed up. On the contrary, using <code>array.array</code> with python-operations will make it slower, because first the raw double values must be converted to Python-Floats:</p>
<pre><code>lst=list(range(10**6))
%timeit sum(lst)
7.19 ms ± 461 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

import array
a=array.array('i',range(10**6))
%timeit sum(a)
17.9 ms ± 43.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>almost 3 times slower!</p>
<p>However, there is potential to speed things up - it is just not as straightforward. For that one would use numpy, cython or numba. For example:</p>
<pre><code>import numpy as np
b=np.array(range(10**6), dtype=np.int32)
%timeit b.sum()
1.07 ms ± 24.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>Almost 10 times faster!</p>
</div>
<span class="comment-copy">The array is probably taking more memory because of the way you constructed it. If you do <code>floats = array.array('d', L)</code> then the array will occupy less memory than the list. But not much less.</span>
<span class="comment-copy">the implementation of a list in python is dynamic i.e it always allocates more memory than the existing number of items in the list actually x2 times. Whereas array is just a wrapper of c and store homogeneous data. But Both of them use <code>sizeof(element)×(number of elements) bytes</code>plus a small fixed header for overhead.</span>
<span class="comment-copy">@Aidenhjj - where does Python do "type detection" in lists? Also the internal implementation of <code>list</code> isn't a linked list. Are you just making stuff up?</span>
<span class="comment-copy">You're comparing an <code>array</code> of <code>double</code>s - i.e. 8-byte items to a list, that's an edge case. The point of an <code>array</code> is being able to compactly store smaller items. An <code>array</code> of bytes will be much, much smaller than a list of equivalent Python ints because a <code>list</code> can only contain 8-byte object references.</span>
