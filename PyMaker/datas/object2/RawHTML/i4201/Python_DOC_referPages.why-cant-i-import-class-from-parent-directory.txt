<div class="post-text" itemprop="text">
<p>I am running Python 2.5.</p>
<p>This is my folder tree:</p>
<pre><code>ptdraft/
  nib.py
  simulations/
    life/
      life.py
</code></pre>
<p>(I also have <code>__init__.py</code> in each folder, omitted here for readability)</p>
<p>How do I import the <code>nib</code> module from inside the <code>life</code> module? I am hoping it is possible to do without tinkering with sys.path.</p>
<p>Note: The main module being run is in the <code>ptdraft</code> folder.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems that the problem is not related to the module being in a parent directory or anything like that.</p>
<p>You need to add the directory that contains <code>ptdraft</code> to PYTHONPATH</p>
<p>You said that <code>import nib</code> worked with you, that probably means that you added <code>ptdraft</code> itself (not its parent) to PYTHONPATH.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use relative imports (python &gt;= 2.5):</p>
<pre><code>from ... import nib
</code></pre>
<p><a href="http://docs.python.org/2/whatsnew/2.5.html#pep-328-absolute-and-relative-imports" rel="noreferrer">(What’s New in Python 2.5) PEP 328: Absolute and Relative Imports</a></p>
<p><strong>EDIT</strong>: added another dot '.' to go up two packages</p>
</div>
<div class="post-text" itemprop="text">
<p>Relative imports (as in <code>from .. import mymodule</code>) only work in a package.
To import 'mymodule' that is in the parent directory of your current module:</p>
<pre><code>import os,sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir) 

import mymodule
</code></pre>
<p><strong>edit</strong>: the <code>__file__</code> attribute is not always given. Instead of using <code>os.path.abspath(__file__)</code> I now suggested using the inspect module to retrieve the filename (and path) of the current file</p>
</div>
<div class="post-text" itemprop="text">
<p>If adding your module folder to the PYTHONPATH didn't work, You can modify the <strong>sys.path</strong> list in your program where the Python interpreter searches for the modules to import, the <a href="http://docs.python.org/tutorial/modules.html#the-module-search-path">python documentation</a> says:</p>
<blockquote>
<p>When a module named <strong>spam</strong> is imported, the interpreter first searches for a built-in module with that name. If not found, it then searches for a file named <strong>spam.py</strong> in a list of directories given by the variable sys.path. sys.path is initialized from these locations:</p>
<blockquote>
<ul>
<li>the directory containing the input script (or the current directory).</li>
<li>PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH).</li>
<li>the installation-dependent default.</li>
</ul>
<p>After initialization, Python programs can modify <strong>sys.path</strong>. The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory. This is an error unless the replacement is intended. </p>
</blockquote>
</blockquote>
<p>Knowing this, you can do the following in your program:</p>
<pre><code>import sys
# Add the ptdraft folder path to the sys.path list
sys.path.append('/path/to/ptdraft/')

# Now you can import your module
from ptdraft import nib
# Or just
import ptdraft
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>I posted a similar answer also to the question regarding imports from sibling packages. You can see it <a href="https://stackoverflow.com/a/50193944/3015186">here</a>. The following is tested with Python 3.6.5, (Anaconda, conda 4.5.1), Windows 10 machine.</em></p>
<h1>Solution without sys.path hacks</h1>
<h2>Setup</h2>
<p>I assume the same folder structure as in the question</p>
<pre><code>.
└── ptdraft
    ├── __init__.py
    ├── nib.py
    └── simulations
        ├── __init__.py
        └── life
            ├── __init__.py
            └── life.py
</code></pre>
<p>I call the <code>.</code> the root folder, and in my case it is located in <code>C:\tmp\test_imports</code>.</p>
<h2>Steps</h2>
<h2>1) Add a setup.py to the root folder</h2>
<p>The contents of the <code>setup.py</code> can be simply</p>
<pre><code>from setuptools import setup, find_packages

setup(name='myproject', version='1.0', packages=find_packages())
</code></pre>
<p>Basically "any" setup.py would work. This is just a minimal working example.</p>
<h2>2) Use a virtual environment</h2>
<p><em>If you are familiar with virtual environments, activate one, and skip to the next step.</em> Usage of virtual environments are not <em>absolutely</em> required, but they will <em>really</em> help you out in the long run (when you have more than 1 project ongoing..). The most basic steps are (run in the root folder)</p>
<ul>
<li>Create virtual env

<ul>
<li><code>python -m venv venv</code></li>
</ul></li>
<li>Activate virtual env

<ul>
<li><code>. /venv/bin/activate</code> (Linux) or <code>./venv/Scripts/activate</code> (Win)</li>
</ul></li>
</ul>
<p>To learn more about this, just Google out "python virtual env tutorial" or similar. You probably never need any other commands than creating, activating and deactivating. </p>
<p>Once you have made and activated a virtual environment, your console should give the name of the virtual environment in parenthesis</p>
<pre><code>PS C:\tmp\test_imports&gt; python -m venv venv
PS C:\tmp\test_imports&gt; .\venv\Scripts\activate
(venv) PS C:\tmp\test_imports&gt;
</code></pre>
<h2>3) pip install your project in editable state</h2>
<p>Install your top level package <code>myproject</code> using <code>pip</code>. The trick is to use the <code>-e</code> flag when doing the install. This way it is installed in an editable state, and all the edits made to the .py files will be automatically included in the installed package. </p>
<p>In the root directory, run</p>
<p><code>pip install -e .</code> (note the dot, it stands for "current directory")</p>
<p>You can also see that it is installed by using <code>pip freeze</code> </p>
<pre><code>(venv) PS C:\tmp\test_imports&gt; pip install -e .
Obtaining file:///C:/tmp/test_imports
Installing collected packages: myproject
  Running setup.py develop for myproject
Successfully installed myproject
(venv) PS C:\tmp\test_imports&gt; pip freeze
myproject==1.0
</code></pre>
<h2>4) Import by appending <code>mainfolder</code> to every import</h2>
<p>In this example, the <code>mainfolder</code> would be <code>ptdraft</code>. This has the advantage that you will not run into name collisions with other module names (from python standard library or 3rd party modules).</p>
<hr/>
<h1>Example Usage</h1>
<h2>nib.py</h2>
<pre><code>def function_from_nib():
    print('I am the return value from function_from_nib!')
</code></pre>
<h2>life.py</h2>
<pre><code>from ptdraft.nib import function_from_nib

if __name__ == '__main__':
    function_from_nib()
</code></pre>
<h2>Running life.py</h2>
<pre><code>(venv) PS C:\tmp\test_imports&gt; python .\ptdraft\simulations\life\life.py
I am the return value from function_from_nib!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use OS depending path in "module search path" which is listed in <strong>sys.path</strong> .
So you can easily add parent directory like following </p>
<pre><code>import sys
sys.path.insert(0,'..')
</code></pre>
<p>If you want to add parent-parent directory,</p>
<pre><code>sys.path.insert(0,'../..')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't know much about python 2.<br/>
In python 3, the parent folder can be added as follows:</p>
<pre><code>import sys 
sys.path.append('..')
</code></pre>
<p>...and then one is able to import modules from it</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an answer that's simple so you can see how it works, small and cross-platform.<br/>
It only uses built-in modules (<code>os</code>, <code>sys</code> and <code>inspect</code>) so should work<br/>
on any operating system (OS) because Python is designed for that.</p>
<h3>Shorter code for answer - fewer lines and variables</h3>
<pre><code>from inspect import getsourcefile
import os.path as path, sys
current_dir = path.dirname(path.abspath(getsourcefile(lambda:0)))
sys.path.insert(0, current_dir[:current_dir.rfind(path.sep)])
import my_module  # Replace "my_module" here with the module name.
sys.path.pop(0)
</code></pre>
<p>For less lines than this, replace the second line with <code>import os.path as path, sys, inspect</code>,<br/>
add <code>inspect.</code> at the start of <code>getsourcefile</code> (line 3) and remove the first line.<br/>
 - however this imports all of the module so could need more time, memory and resources.</p>
<h3>The code for my answer (<em>longer version</em>)</h3>
<pre><code>from inspect import getsourcefile
import os.path
import sys

current_path = os.path.abspath(getsourcefile(lambda:0))
current_dir = os.path.dirname(current_path)
parent_dir = current_dir[:current_dir.rfind(os.path.sep)]

sys.path.insert(0, parent_dir)

import my_module  # Replace "my_module" here with the module name.
</code></pre>
<p>It uses an example from a Stack Overflow answer <em><a href="https://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python/33531619#33531619">How do I get the path of the current<br/>
executed file in Python?</a></em> to find the source (filename) of running code with a built-in tool.</p>
<blockquote>
<pre><code>from inspect import getsourcefile  
from os.path import abspath  
</code></pre>
<p>Next, wherever you want to find the source file from you just use:</p>
<pre><code>abspath(getsourcefile(lambda:0))
</code></pre>
</blockquote>
<p>My code adds a file path to <code>sys.path</code>, the <em>python path list</em><br/>
because this allows Python to import modules from that folder.</p>
<p>After importing a module in the code, it's a good idea to run <code>sys.path.pop(0)</code> on a new line<br/>
when that added folder has a module with the same name as another module that is imported<br/>
later in the program. You need to remove the list item added before the import, not other paths.<br/>
If your program doesn't import other modules, it's safe to not delete the file path because<br/>
after a program ends (or restarting the Python shell), any edits made to <code>sys.path</code> disappear.</p>
<h3>Notes about a filename variable</h3>
<p>My answer doesn't use the <code>__file__</code> variable to get the file path/filename of running<br/>
code because users here have often described it as <strong>unreliable</strong>. You shouldn't use it<br/>
for <em>importing modules from parent folder</em> in programs used by other people.  </p>
<p><strong>Some examples where it doesn't work (quote from <a href="https://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python/">this</a> Stack Overflow question):</strong></p>
<p>• it <a href="https://stackoverflow.com/questions/714063/importing-modules-from-parent-folder/11158224#11158224">can't be</a> found on some platforms • it sometimes <a href="https://stackoverflow.com/questions/714063/importing-modules-from-parent-folder/33532002#comment33997203_19409830">isn't the full file path</a></p>
<blockquote>
<ul>
<li><code>py2exe</code> doesn't have a <code>__file__</code> attribute, but there is a workaround</li>
<li>When you run from IDLE with <code>execute()</code> there is no <code>__file__</code> attribute</li>
<li>OS X 10.6 where I get <code>NameError: global name '__file__' is not defined</code></li>
</ul>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Here is more generic solution that includes the parent directory into sys.path (works for me):</p>
<pre><code>import os.path, sys
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), os.pardir))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>
import sys
sys.path.append('../')
</code></p>
</div>
<div class="post-text" itemprop="text">
<p>For me the shortest and my favorite oneliner for accessing to the parent directory is:</p>
<pre><code>sys.path.append(os.path.dirname(os.getcwd()))
</code></pre>
<p>or:</p>
<pre><code>sys.path.insert(1, os.path.dirname(os.getcwd()))
</code></pre>
<p>os.getcwd() returns the name of the current working directory, os.path.dirname(directory_name) returns the directory name for the passed one.</p>
<p>Actually, in my opinion Python project architecture should be done the way where no one module from child directory will use any module from the parent directory. If something like this happens it is worth to rethink about the project tree.</p>
<p>Another way is to add parent directory to PYTHONPATH system environment variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>When not being in a package environment with <code>__init__.py</code> files the pathlib library (included with &gt;= Python 3.4) makes it very concise and intuitive to append the path of the parent directory to the PYTHONPATH:</p>
<pre><code>import sys
from pathlib import Path
sys.path.append(str(Path('.').absolute().parent))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Above mentioned solutions are also fine. Another solution to this problem is</p>
<p>If you want to import anything from top level directory. Then,</p>
<pre><code>from ...module_name import *
</code></pre>
<p>Also, if you want to import any module from the parent directory. Then,</p>
<pre><code>from ..module_name import *
</code></pre>
<p>Also, if you want to import any module from the parent directory. Then,</p>
<pre><code>from ...module_name.another_module import *
</code></pre>
<p>This way you can import any particular method if you want to.</p>
</div>
<div class="post-text" itemprop="text">
<p>same sort of style as the past answer - but in fewer lines :P</p>
<pre><code>import os,sys
parentdir = os.path.dirname(__file__)
sys.path.insert(0,parentdir)
</code></pre>
<p>file returns the location you are working in</p>
</div>
<div class="post-text" itemprop="text">
<p>Work with libraries.
Make a library called nib, install it using setup.py, let it reside in site-packages and your problems are solved.
You don't have to stuff everything you make in a single package. Break it up to pieces.</p>
</div>
<div class="post-text" itemprop="text">
<p>In a Linux system, you can create a soft link from the "life" folder to the nib.py file. Then, you can simply import it like:</p>
<pre><code>import nib
</code></pre>
</div>
<span class="comment-copy">What's your PYTHONPATH setting?</span>
<span class="comment-copy">Ross: I looked there. What should I do about it? I already have a <code>__init__.py</code>.  S.Lott: I don't know how to check...</span>
<span class="comment-copy">echo $PYTHONPATH from the shell; import sys; print sys.path from within Python.  <a href="http://docs.python.org/tutorial/modules.html?highlight=pythonpath#modules" rel="nofollow noreferrer">docs.python.org/tutorial/…</a></span>
<span class="comment-copy">@FlipMcF Google is a bubbled search engine, so the fact that this result is pretty high up for you doesn't matter. Far more important is the fact that the non-bubbled search engine, DuckDuckGo, also ranks this very highly.</span>
<span class="comment-copy">I strongly recommend skipping past all <code>sys.path</code> or <code>PYTHONPATH</code> answers and checking out <a href="https://stackoverflow.com/a/50194143/1222951">np8's excellent answer</a>. Yes, it's a long read. Yes, it looks like a lot of work. But it's the only answer that actually solves the problem correctly and cleanly.</span>
<span class="comment-copy"><code>ValueError: Attempted relative import in non-package</code></span>
<span class="comment-copy">@endolith: You have to be in a package, i.e., you must have an <b>init</b>.py file.</span>
<span class="comment-copy">Attempted relative import beyond toplevel package</span>
<span class="comment-copy">To be even more precise, you need a <code>__init__.py</code> file.</span>
<span class="comment-copy">See also the following answer, since adding <code>__init__.py</code> is not the only thing you have to do: <a href="http://stackoverflow.com/questions/11536764/attempted-relative-import-in-non-package-even-with-init-py/27876800#27876800" title="attempted relative import in non package even with init py">stackoverflow.com/questions/11536764/…</a></span>
<span class="comment-copy">something a little shorter: <code>sys.path.insert(1, os.path.join(sys.path[0], '..'))</code></span>
<span class="comment-copy">Any reason to avoid sys.path.append() instead of the insert?</span>
<span class="comment-copy">@Tyler - It can matter if somewhere else then the <code>parentdir</code>, but in one of the paths allready specified in <code>sys.path</code>, there is another module with the name 'mymodule'. Inserting the <code>parentdir</code> as the first element of the <code>sys.path</code> list assures that the module from <code>parentdir</code> will be imported instead.</span>
<span class="comment-copy">@JHolta If you're not dealing with packages, yours is the best solution.</span>
<span class="comment-copy">@JHolta great idea. <code>sys.path.insert(1, os.path.realpath(os.path.pardir))</code> works too.</span>
<span class="comment-copy">Your answer is good, but may not always work and is not very portable. If the program was moved to a new location, <code>/path/to/ptdraft</code> would have to be edited. There are solutions that work out the current directory of the file and import it from the parent folder that way as well.</span>
<span class="comment-copy">@Edward what are those techniques?</span>
<span class="comment-copy">@Shuklaswag for example, the answer <a href="https://stackoverflow.com/questions/714063/importing-modules-from-parent-folder/33532002#33532002" title="importing modules from parent folder">stackoverflow.com/questions/714063/…</a>.</span>
<span class="comment-copy">Why does this work? Is it changing the PYTHONPATH behind the scenes somehow?</span>
<span class="comment-copy">Your PYTHONPATH variable remains the same. You simply install your python code with pip (in an editable state).</span>
<span class="comment-copy">And what does the installation process do? Isn't it including the root folder in the pythonpath? How is it helping python find the module nib.py when referred in life.py?</span>
<span class="comment-copy">Also, why is this better or more elegant than using the sys.path approach?</span>
<span class="comment-copy">@HomeroBarrocasSEsmeraldo Good questions. PYTHONPATH env var is untouched. This installs into <a href="https://stackoverflow.com/a/52638888/674039">site-packages</a>, which is already on <code>sys.path</code> and where the code would typically be installed by end users. That's better than <code>sys.path</code> hacks (and you can include using PYTHONPATH in that category of path hacks) because it means the code in development should behave the same way for you as it does for other users. In contrast, when using path modifications, import statements would be resolved in a different way.</span>
<span class="comment-copy">This only works if your current working directory is such that <code>'..'</code> leads to the directory with the module in question.</span>
<span class="comment-copy">I did this and removed the new path entry with  <code>sys.path.pop(0)</code> immediately after importing the desired module. However, subsequent imports still went to that location. For example, I have <code>app/config</code>, <code>app/tools</code> and <code>app/submodule/config</code>. From <code>submodule</code>, I insert <code>app/</code> to import <code>tools</code>, then remove <code>app/</code> and try to import <code>config</code>, but I get <code>app/config</code> instead of <code>app/submodule/config</code>.</span>
<span class="comment-copy">I figured out that one of <code>tools</code>'s imports was also importing <code>config</code> from the parent dir. So when I later tried to do <code>sys.path.pop(0); import config</code> inside <code>submodule</code>, expecting to get  <code>app/submodule/config</code>, I was actually getting <code>app/config</code>. Evidently Python returns a cached version of a module with the same name instead of actually checking the <code>sys.path</code> for a module matching that name. <code>sys.path</code> in this case was being altered correctly, Python was just not checking it due to the same-named module already having been loaded.</span>
<span class="comment-copy">I think this is the exact reference to the issue I had: <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">docs.python.org/3/reference/import.html#the-module-cache</a></span>
<span class="comment-copy">Some useful information from <i>5.3.1. The module cache</i> on the <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">documentation page</a>: During import, the module name is looked up in <code>sys.modules</code> <i>...</i> sys.modules is writable. Deleting a key will invalidate the cache entry for the named module, causing Python to search anew upon its next import. <i>...</i> Beware though, as if you keep a reference to the module object, invalidate its cache then re-import, the two objects will be different. By contrast, <code>importlib.reload()</code> will reuse and reinitialise the module contents <i>...</i></span>
<span class="comment-copy">Even shorter: <code>os.path.realpath(getsourcefile(lambda:0) + "/../..")</code>. Will get current source file appended with two parent directory symbols. I didn't use <code>os.path.sep</code> as <code>getsourcefile</code> was returns a string using <code>/</code> even on Windows. <code>realpath</code> will take care of popping off two directory entries from the full path (in this case, the filename, and then the current directory) which gives the parent directory.</span>
<span class="comment-copy"><code>import os, sys\n sys.path.insert(0,os.path.pardir)</code>  same thing, but sorther :) (no line feeds in comments)</span>
<span class="comment-copy">@antiveeranna, if you use <code>os.path.pardir</code> you won't be getting the realpath of the parent, just relative path from where you're calling the <code>sys.path.insert()</code></span>
<span class="comment-copy">This answer uses the <code>__file__</code> variable which can be <b>unreliable</b> (isn't always the full file path, doesn't work on every operating system etc.) as StackOverflow users have often mentioned. Changing the answer to not include it will cause less problems and be more cross-compatible. For more information, see <a href="https://stackoverflow.com/a/33532002/3787376">stackoverflow.com/a/33532002/3787376</a>.</span>
<span class="comment-copy">this will not work when executed from a different directory.</span>
<span class="comment-copy">+1 for mentioning the possibility of having to restructure the project (as opposed to throwing a hack at the problem)</span>
<span class="comment-copy">is it possible to use <b>init</b>.py to circumvent this problem?</span>
<span class="comment-copy">For me <b>file</b> is the filename <i>without</i> the path included. I run it using "ipy filename.py".</span>
<span class="comment-copy">Hi @CurtisYallop in the example above we are adding the dir that contains the file [that we are currently in] that the python file is in. The os.path.dirname call with the file name should return the path  of the file and we are adding THAT to to the path and not the file explicitly - HTH's :-)</span>
<span class="comment-copy">You are assuming that __file__ always contains the path plus the file. Sometimes it contains only the filename without the path.</span>
<span class="comment-copy">@CurtisYallop - not at all sir, I am assuming <b>file</b> is the file name and I am using os.path.dirname() to get the path for the file. Have you got an example of this not working? I would love the steps to reproduce</span>
<span class="comment-copy">@CurtisYallop - No I am not! I am saying that: print <i>/_/file/_/</i> will give you the filename in your example above "file.py" - I am then saying that you can use os.path.dirname() to pull the full path from that. If you are calling from some weird location and you would like that relational then you can easily find your working dir through the os module -- Jeez!</span>
<span class="comment-copy">Your idea is good but some people may want to bundle their module in with their code - perhaps to make it portable and not require putting their modules in <code>site-packages</code> every time they run it on a different computer.</span>
