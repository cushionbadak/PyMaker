<div class="post-text" itemprop="text">
<p>I am writing a lexer + parser in JFlex + CUP, and I wanted to have Python-like syntax regarding blocks; that is, indentation marks the block level.</p>
<p>I am unsure of how to tackle this, and whether it should be done at the lexical or sintax level.</p>
<p>My current approach is to solve the issue at the lexical level - newlines are parsed as instruction separators, and when one is processed I move the lexer to a special state which checks how many characters are in front of the new line and remembers in which column the last line started, and accordingly introduces and open block or close block character.</p>
<p>However, I am running into all sort of trouble. For example:</p>
<ol>
<li>JFlex cannot match empty strings, so my instructions need to have at least one blanck after every newline.</li>
<li>I cannot close two blocks at the same time with this approach.</li>
</ol>
<p>Is my approach correct? Should I be doing things different?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your approach of handling indents in the lexer rather than the parser is correct. Well, it’s doable either way, but this is usually the easier way, and it’s the way Python itself (or at least CPython and PyPy) does it.</p>
<p>I don’t know much about JFlex, and you haven’t given us any code to work with, but I can explain in general terms.</p>
<p>For your first problem, you're already putting the lexer into a special state after the newline, so that "grab 0 or more spaces" should be doable by escaping from the normal flow of things and just running a regex against the line.</p>
<p>For your second problem, the simplest solution (and the one Python uses) is to keep a stack of indents. I'll demonstrate something a bit simpler than what Python does.</p>
<p>First:</p>
<pre><code>indents = [0]
</code></pre>
<p>After each newline, grab a run of 0 or more spaces as <code>spaces</code>. Then:</p>
<pre><code>if len(spaces) == indents[-1]:
    pass
elif len(spaces) &gt; indents[-1]:
    indents.append(len(spaces))
    emit(INDENT_TOKEN)
else:
    while len(spaces) != indents[-1]:
        indents.pop()
        emit(DEDENT_TOKEN)
</code></pre>
<p>Now your parser just sees <code>INDENT_TOKEN</code> and <code>DEDENT_TOKEN</code>, which are no different from, say, <code>OPEN_BRACE_TOKEN</code> and <code>CLOSE_BRACE_TOKEN</code> in a C-like language.</p>
<p>Of you’d want better error handling—raise some kind of tokenizer error rather than an implicit <code>IndexError</code>, maybe use <code>&lt;</code> instead of <code>!=</code> so you can detect that you’ve gone too far instead of exhausting the stack (for better error recovery if you want to continue to emit further errors instead of bailing at the first one), etc. </p>
<p>For real-life example code (with error handling, and tabs as well as spaces, and backslash newline escaping, and handling non-syntactic indentation inside of parenthesized expressions, etc.), see the <a href="https://docs.python.org/3/library/tokenize.html" rel="nofollow noreferrer"><code>tokenize</code></a> docs and source in the stdlib.</p>
</div>
