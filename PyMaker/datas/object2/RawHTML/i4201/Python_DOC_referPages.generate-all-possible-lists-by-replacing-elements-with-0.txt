<div class="post-text" itemprop="text">
<p>I would like to create from a list all the different list were 0,1,2,3...all element are replaced by an other
For example, if the replacement item is 0:</p>
<pre><code>L=[1,2,3]
-&gt;[1,2,3],[0,2,3],[1,0,3],[1,2,0],[0,0,3],[0,2,0],[1,0,0],[0,0,0]
</code></pre>
<p>So far, I've tried I managed to do what I whant using Itertools but only in the case where 1 value is replaced by 0
Does anyone know how to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one way using <code>itertools</code>. The benefit of this method is that it is lazy.</p>
<p>A new list is produced on every <code>__next__</code> call of the generator <code>transformer</code>.</p>
<p>Alternatively, as below, you can output all combinations by calling <code>list</code> on the generator function.</p>
<pre><code>from itertools import combinations, chain

A = [1, 2, 3]

def transformer(x):
    idx = chain.from_iterable(combinations(range(len(x)), i) for i in range(len(x)+1))
    for indices in idx:
        y = x.copy()
        for j in indices:
            y[j] = 0
        yield y

res = list(transformer(A))

print(res)

[[1, 2, 3], [0, 2, 3], [1, 0, 3], [1, 2, 0], [0, 0, 3], [0, 2, 0], [1, 0, 0], [0, 0, 0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Everyone's trying too hard here.  We want each value to be either the original value or 0 -- we want pairs like (1,0), (2,0), and (3,0):</p>
<pre><code>&gt;&gt;&gt; from itertools import product, repeat
&gt;&gt;&gt; L = [1, 2, 3]
&gt;&gt;&gt; zip(L, repeat(0))
&lt;zip object at 0x7f931ad1bf08&gt;
&gt;&gt;&gt; list(zip(L, repeat(0)))
[(1, 0), (2, 0), (3, 0)]
</code></pre>
<p>and then we can just pass that into <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a>:</p>
<pre><code>&gt;&gt;&gt; list(product(*zip(L, repeat(0))))
[(1, 2, 3), (1, 2, 0), (1, 0, 3), (1, 0, 0), (0, 2, 3), (0, 2, 0), (0, 0, 3), (0, 0, 0)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use recursion. First, create a function that can generate a full combinations for each index of the input:</p>
<pre><code>def full_combinations(d, current = []):
   if len(d) == len(current):
     yield current
   else:
     yield current
     for i in range(len(d)):
        if len(set(current+[i])) == len(current)+1:
           yield from full_combinations(d, current+[i])

combination_list = list(full_combinations([1, 2, 3]))
new_results = [[0 if c in i else a for c, a in enumerate([1, 2, 3])] for i in combination_list]
full = [a for i, a in enumerate(new_results) if a not in new_results[:i]]
</code></pre>
<p>Output:</p>
<pre><code>[[1, 2, 3], [0, 2, 3], [0, 0, 3], [0, 0, 0], [0, 2, 0], [1, 0, 3], [1, 0, 0], [1, 2, 0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not pretty, but I'm sure you can get this idea to work.</p>
<p>The idea is to use itertools.combinations to get all combinations of indices for every length, then we flatten this list with itertools.chain().</p>
<p>Then we loop through this list of lists, setting those indices to the replace character.</p>
<pre><code>import itertools
l = [1,2,3]
replace = 0

indices = list(itertools.chain(*[list(itertools.combinations(list(range(len(l))),z+1)) for z in range(len(l))]))

allcombs = [[l]]
for i in indices:
    l2 = l[:]
    for j in i:
        l2[j] = replace
    allcombs.append(l2)

print(allcombs)
</code></pre>
<p>[[[1, 2, 3]], [0, 2, 3], [1, 0, 3], [1, 2, 0], [0, 0, 3], [0, 2, 0], [1, 0, 0], [0, 0, 0]]</p>
</div>
<span class="comment-copy"><code>[1, 2, 3]</code> is missing and it's horribly unreadable with 0 explanation.</span>
<span class="comment-copy">Simply add:      allcombs = [[l]]  At the initialisation of allcombs to include this case.  The idea is we get the combinations of all indices for different length combinations, then flatten the list with itertools.chain - and then loop through that list of lists setting those elements to the replace_char.</span>
