<div class="post-text" itemprop="text">
<p>How do I remove an element from a list by index in Python?</p>
<p>I found the <code>list.remove</code> method, but say I want to remove the last element, how do I do this? It seems like the default remove searches the list, but I don't want any search to be performed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>del</code> and specify the index of the element you want to delete:</p>
<pre><code>&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; del a[-1]
&gt;&gt;&gt; a
[0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>Also supports slices:</p>
<pre><code>&gt;&gt;&gt; del a[2:4]
&gt;&gt;&gt; a
[0, 1, 4, 5, 6, 7, 8, 9]
</code></pre>
<p><a href="http://docs.python.org/tutorial/datastructures.html#the-del-statement" rel="noreferrer">Here</a> is the section from the tutorial.</p>
</div>
<div class="post-text" itemprop="text">
<p>You probably want <code>pop</code>:</p>
<pre><code>a = ['a', 'b', 'c', 'd']
a.pop(1)

# now a is ['a', 'c', 'd']
</code></pre>
<p>By default, <code>pop</code> without any arguments removes the last item:</p>
<pre><code>a = ['a', 'b', 'c', 'd']
a.pop()

# now a is ['a', 'b', 'c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like others mentioned pop and del are <em>the</em> efficient ways to remove an item of given index. Yet just for the sake of completion (since the same thing can be done via many ways in Python):</p>
<p><strong>Using slices (this does not do in place removal of item from original list):</strong></p>
<p>(Also this will be the least efficient method when working with Python list, but this could be useful (but not efficient, I reiterate) when working with user defined objects that do not support pop, yet do define a <code>__getitem__</code> ):</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; index = 3 # Only positive index

&gt;&gt;&gt; a = a[:index] + a[index+1 :]
# a is now [1, 2, 3, 5, 6]
</code></pre>
<p><strong>Note:</strong> Please note that this method does not modify the list in place like <code>pop</code> and <code>del</code>. It instead makes two copies of lists (one from the start until the index but without it (<code>a[:index]</code>) and one after the index till the last element (<code>a[index+1:]</code>)) and creates a new list object by adding both. This is then reassigned to the list variable (<code>a</code>). The old list object is hence dereferenced and hence garbage collected (provided the original list object is not referenced by any variable other than a).</p>
<p>This makes this method very inefficient and it can also produce undesirable side effects (especially when other variables point to the original list object which remains un-modified).</p>
<p>Thanks to @MarkDickinson for pointing this out ...</p>
<p><a href="https://stackoverflow.com/a/509295/3244627">This</a> Stack Overflow answer explains the concept of slicing.</p>
<p>Also note that this works only with positive indices.</p>
<p>While using with objects, the <code>__getitem__</code> method must have been defined and more importantly the <strong><code>__add__</code></strong> method must have been defined to return an object containing items from both the operands.</p>
<p>In essence, this works with any object whose class definition is like:</p>
<pre><code>class foo(object):
    def __init__(self, items):
        self.items = items

    def __getitem__(self, index):
        return foo(self.items[index])

    def __add__(self, right):
        return foo( self.items + right.items )
</code></pre>
<p>This works with <code>list</code> which defines <code>__getitem__</code> and <code>__add__</code> methods.</p>
<p><strong>Comparison of the three ways in terms of efficiency:</strong></p>
<p>Assume the following is predefined:</p>
<pre><code>a = range(10)
index = 3
</code></pre>
<p><strong>The <code>del object[index]</code> method:</strong></p>
<p>By far the most efficient method. It works will all objects that define a <code>__del__</code> method.</p>
<p>The disassembly is as follows:</p>
<p>Code:</p>
<pre><code>def del_method():
    global a
    global index
    del a[index]
</code></pre>
<p>Disassembly:</p>
<pre><code> 10    0 LOAD_GLOBAL     0 (a)
       3 LOAD_GLOBAL     1 (index)
       6 DELETE_SUBSCR   # This is the line that deletes the item
       7 LOAD_CONST      0 (None)
      10 RETURN_VALUE
None
</code></pre>
<p><strong><code>pop</code> method:</strong></p>
<p>It is less efficient than the del method and is used when you need to get the deleted item.</p>
<p>Code:</p>
<pre><code>def pop_method():
    global a
    global index
    a.pop(index)
</code></pre>
<p>Disassembly:</p>
<pre><code> 17     0 LOAD_GLOBAL     0 (a)
        3 LOAD_ATTR       1 (pop)
        6 LOAD_GLOBAL     2 (index)
        9 CALL_FUNCTION   1
       12 POP_TOP
       13 LOAD_CONST      0 (None)
       16 RETURN_VALUE
</code></pre>
<p><strong>The slice and add method.</strong></p>
<p>The least efficient.</p>
<p>Code:</p>
<pre><code>def slice_method():
    global a
    global index
    a = a[:index] + a[index+1:]
</code></pre>
<p>Disassembly:</p>
<pre><code> 24     0 LOAD_GLOBAL    0 (a)
        3 LOAD_GLOBAL    1 (index)
        6 SLICE+2
        7 LOAD_GLOBAL    0 (a)
       10 LOAD_GLOBAL    1 (index)
       13 LOAD_CONST     1 (1)
       16 BINARY_ADD
       17 SLICE+1
       18 BINARY_ADD
       19 STORE_GLOBAL   0 (a)
       22 LOAD_CONST     0 (None)
       25 RETURN_VALUE
None
</code></pre>
<p>Note: In all three disassembles ignore the last two lines which basically are <code>return None</code>. Also the first two lines are loading the global values <code>a</code> and <code>index</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/library/stdtypes.html#mutable-sequence-types"><code>pop</code></a> is also useful to remove and keep an item from a list.  Where <code>del</code> actually trashes the item.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4]

&gt;&gt;&gt; p = x.pop(1)
&gt;&gt;&gt; p
    2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generally, I am using the following method:</p>
<pre><code>&gt;&gt;&gt; myList = [10,20,30,40,50]
&gt;&gt;&gt; rmovIndxNo = 3
&gt;&gt;&gt; del myList[rmovIndxNo]
&gt;&gt;&gt; myList
[10, 20, 30, 50]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This depends on what you want to do.</p>
<p>If you want to return the element you removed, use <code>pop()</code>:</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 3, 4, 5]
&gt;&gt;&gt; l.pop(2)
3
&gt;&gt;&gt; l
[1, 2, 4, 5]
</code></pre>
<p>However, if you just want to delete an element, use <code>del</code>:</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 3, 4, 5]
&gt;&gt;&gt; del l[2]
&gt;&gt;&gt; l
[1, 2, 4, 5]
</code></pre>
<p>Additionally, <code>del</code> allows you to use slices (e.g. <code>del[2:]</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another way to remove an element(s) from a list by index.</p>
<pre><code>a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# remove the element at index 3
a[3:4] = []
# a is now [0, 1, 2, 4, 5, 6, 7, 8, 9]

# remove the elements from index 3 to index 6
a[3:7] = []
# a is now [0, 1, 2, 7, 8, 9]
</code></pre>
<p>a[x:y] points to the elements from index <code>x</code> to <code>y-1</code>. When we declare that portion of the list as an empty list (<code>[]</code>), those elements are removed.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just search for the item you want to delete. It is really simple.
Example:</p>
<pre><code>    letters = ["a", "b", "c", "d", "e"]
    letters.remove(letters[1])
    print(*letters) # Used with a * to make it unpack you don't have to (Python 3.x or newer)
</code></pre>
<p>Output: a c d e</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the following code to remove element from the list: </p>
<pre><code>list = [1, 2, 3, 4]
list.remove(1)
print(list)

output = [2, 3, 4]
</code></pre>
<p>If you want to remove index element data from the list use:</p>
<pre><code>list = [1, 2, 3, 4]
list.remove(list[2])
print(list)
output : [1, 2, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As previously mentioned, best practice is del(); or pop() if you need to know the value.</p>
<p>An alternate solution is to re-stack only those elements you want:</p>
<pre><code>    a = ['a', 'b', 'c', 'd'] 

    def remove_element(list_,index_):
        clipboard = []
        for i in range(len(list_)):
            if i is not index_:
                clipboard.append(list_[i])
        return clipboard

    print(remove_element(a,2))

    &gt;&gt; ['a', 'b', 'd']
</code></pre>
<p>eta: hmm... will not work on negative index values, will ponder and update</p>
<p>I suppose </p>
<pre><code>if index_&lt;0:index_=len(list_)+index_
</code></pre>
<p>would patch it... but suddenly this idea seems very brittle. Interesting thought experiment though.  Seems there should be a 'proper' way to do this with append() / list comprehension.  </p>
<p><em>pondering</em></p>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't sound like you're working with a list of lists, so I'll keep this short.  You want to use pop since it will remove elements not elements that are lists, you should use del for that.  To call the last element in python it's "-1"</p>
<pre><code>&gt;&gt;&gt; test = ['item1', 'item2']
&gt;&gt;&gt; test.pop(-1)
'item2'
&gt;&gt;&gt; test
['item1']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>l</strong> - list of values; we have to remove indexes from <strong>inds2rem</strong> list.</p>
<pre><code>l = range(20)
inds2rem = [2,5,1,7]
map(lambda x: l.pop(x), sorted(inds2rem, key = lambda x:-x))

&gt;&gt;&gt; l
[0, 3, 4, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to remove the specific position element in a list, like the 2th, 3th and 7th. you can't use</p>
<pre><code>del my_list[2]
del my_list[3]
del my_list[7]
</code></pre>
<p>Since after you delete the second element, the third element you delete actually is the fourth element in the original list. You can filter the 2th, 3th and 7th element in the original list and get a new list, like below:</p>
<pre><code>new list = [j for i, j in enumerate(my_list) if i not in [2, 3, 7]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <strong>"del"</strong> function:    </p>
<pre><code>del listName[-N]
</code></pre>
<p>For example, if you want to remove the last 3 items, your code should be:</p>
<pre><code>del listName[-3:]
</code></pre>
<p>For example, if you want to remove the last 8 items, your code should be:</p>
<pre><code>del listName[-8:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One can either use del or pop, but I prefer del, since you can specify index and slices, giving the user more control over the data.</p>
<p>For example, starting with the list shown, one can remove its last element with <code>del</code> as a slice, and then one can remove the last element from the result using <code>pop</code>.</p>
<pre><code>&gt;&gt;&gt; l = [1,2,3,4,5]
&gt;&gt;&gt; del l[-1:]
&gt;&gt;&gt; l
[1, 2, 3, 4]
&gt;&gt;&gt; l.pop(-1)
4
&gt;&gt;&gt; l
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use either del or pop to remove element from list based on index.  Pop will print member it is removing from list, while list delete that member without printing it.</p>
<pre><code>&gt;&gt;&gt; a=[1,2,3,4,5]
&gt;&gt;&gt; del a[1]
&gt;&gt;&gt; a
[1, 3, 4, 5]
&gt;&gt;&gt; a.pop(1)
 3
&gt;&gt;&gt; a
[1, 4, 5]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or if multiple indexes should be removed:</p>
<pre><code>print([v for i,v in enumerate(your_list) if i not in list_of_unwanted_indexes])
</code></pre>
<p>Of course then could also do:</p>
<pre><code>print([v for i,v in enumerate(your_list) if i != unwanted_index])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>But never use pop() with loop .it will cause an error .use pop() without loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use the <a href="https://docs.python.org/3.1/tutorial/datastructures.html" rel="nofollow noreferrer"><code>remove</code></a> function of Python. Like this:</p>
<pre><code>v = [1, 2, 3, 4, 5, 6]
v.remove(v[4]) # I'm removing the number with index 4 of my array
print(v) # If you want verify the process

# It gave me this:
#[1,2,3,4,6]
</code></pre>
</div>
<span class="comment-copy">The scalable answer is to use <a href="http://docs.python.org/2/library/collections.html#collections.deque" rel="nofollow noreferrer">collections.deque</a></span>
<span class="comment-copy">@smci: deletion in the middle is O(n) whether it is a list or deque.</span>
<span class="comment-copy">Yes @j-f-sebastian, you're correct. I subsequently found out that deque only improves scalability of insertions; not lookups (O(1)) or deletions. I deleted my incorrect answer. However I thought (list) deletions-by-index are just a lookup followed by a delete (and internal memory reallocation), so surely they're O(1) not O(n)? Deletions-by-value are indeed O(n) since they involve a traversal.</span>
<span class="comment-copy">@smci: Python list is array-based:  to delete an item in the middle, you have to move all items on the right to remove the gap that is why it is <code>O(n)</code> in time operation. <code>deque()</code> provides efficient operations on both ends but it does not provide O(1) insertions/lookups/deletions in the middle.</span>
<span class="comment-copy">@J.F.Sebastian: cPython implementation, yes, thanks for correcting me. Strictly the <a href="https://docs.python.org/2/reference/index.html" rel="nofollow noreferrer">language spec</a> doesn't specify how to implement list, alternative implementations could choose to use a linked-list.</span>
<span class="comment-copy">Thanks, what's the difference between pop and del?</span>
<span class="comment-copy">del is overloaded.  For example del a deletes the whole list</span>
<span class="comment-copy">another example del a[2:4], deletes elements 2 and 3</span>
<span class="comment-copy">pop() returns the element you want to remove. del just deletes is.</span>
<span class="comment-copy">I cannot see a proof of "linked list" there. Look at <a href="http://svn.python.org/projects/python/trunk/Objects/listobject.c" rel="nofollow noreferrer">svn.python.org/projects/python/trunk/Objects/listobject.c</a> how <code>PyList_GetItem()</code> essentially returns <code>((PyListObject *)op) -&gt; ob_item[i];</code> - the <code>i</code>th element of an array.</span>
<span class="comment-copy">Don't forget pop(-1).  Yes, it's the default, but I prefer it so I don't have to remember which end pop uses by default.</span>
<span class="comment-copy">Good point... that does increase readability.</span>
<span class="comment-copy">I disagree. If you know the programmer's etymology of "pop" (it's the the operation that removes and returns the <b>top</b> of a 'stack' data structure), then <code>pop()</code> by itself is very obvious, while <code>pop(-1)</code> is potentially confusing precisely <i>because</i> it's redundant.</span>
<span class="comment-copy">@zx1986 a <code>pop</code> in most programming languages usually removes the last item, as it does in Python. So whether you specify -1 or nothing is the same.</span>
<span class="comment-copy">By the way, <code>pop()</code> returns whatever element it removed.</span>
<span class="comment-copy">Your slicing method does not remove an element from a list:  instead it creates a <i>new</i> list object containing all but the ith entry from the original list.  The original list is left unmodified.</span>
<span class="comment-copy">@MarkDickinson Have edited the answer to clarify the same ... Please let me know if it looks good now ?</span>
<span class="comment-copy">Maybe the answer wasn't entirely on topic, but the indexing method is useful if you need to omit an item from an immutable object, such as a tuple. pop() and del() will not work in that case.</span>
<span class="comment-copy">@rvraghav93 out of all presented methods during the entire post, the <code>a = a[:index] + a[index+1 :]</code>-trick was the savest, when it comes to huge lists. All the other methods ended up in a deadlock. So thank you very much</span>
<span class="comment-copy">Indeed Mark, you are grumpy. This answer is the one I prefered because it was really pedagogical. I learned most from this answer and the desassembly details that were provided and the impact on performanc. Plus the slicing method, yes, create another object, but now it is specified and sometimes that is also what you need.</span>
<span class="comment-copy">The variable name you define is <code>letters</code>, but you then refer to it as <code>numbers</code></span>
<span class="comment-copy">I like this solution, but of course it assumes your list does not have duplicates.</span>
<span class="comment-copy">Comes with the caveat that your list cannot contain duplicates.</span>
<span class="comment-copy">This is not removing by index, but removing by matching value. That might be valuable information for some people visiting here, but doesn't try to answer OPs question at all.</span>
<span class="comment-copy">Which version of Python has a function <code>del()</code>? For that function you provide the list as the first argument to that function and then the index, or the index first and then the list? Does it return the list argument without the item, or does it do the deleting in place. I know about the <code>del</code> statement, but not about a function with the same name.</span>
<span class="comment-copy"><code>pop()</code> and <code>del</code> both remove an element at the provided index, independent of whether that element is itself a list or not. <code>a = [1, [2, 3], 4]; del a[1]; b = [1, [2, 3], 4]; b.pop(1); assert a == b</code></span>
<span class="comment-copy">not working, the answer is <code>&lt;map at 0x7f4d54109a58&gt;</code>. and l is range(0,20)</span>
<span class="comment-copy">The best answer among all, and it works :)</span>
<span class="comment-copy">oh my god you like it ^) gratz</span>
<span class="comment-copy">THANK YOU! This is what I was looking for, all the other solutions assume that we want to remove a contiguous slice.</span>
<span class="comment-copy"><code>del</code> is a <a href="https://docs.python.org/3/tutorial/datastructures.html#the-del-statement" rel="nofollow noreferrer">statement</a>. If it were a function, you would have to write <code>del(listame[-N])</code></span>
<span class="comment-copy">Why don't you just sort the list of indices in reverse order and then delete them one by one? That way you don't have to make a new list.</span>
<span class="comment-copy">This is not the best way and it has already been mentioned. Someone needs to protect this question to prevent more answers like this.</span>
<span class="comment-copy">This only works, if your list doesn't have duplicates.</span>
