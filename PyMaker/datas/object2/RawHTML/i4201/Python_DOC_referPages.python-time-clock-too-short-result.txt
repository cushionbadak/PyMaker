<div class="post-text" itemprop="text">
<p>I'm using this code on test time.clock() function in python</p>
<pre><code>start = time.clock()
print(start)
time.sleep(3)
end = time.clock()
print(end)
print(end-start)
</code></pre>
<p>and the result is</p>
<pre><code>0.282109
0.282151
4.199999999998649e-05
</code></pre>
<p>the doc say "On Unix, return the current processor time as a floating point number expressed in seconds." but if the thread is sleeping for 3 seconds how is the result  of end-start so low?</p>
</div>
<div class="post-text" itemprop="text">
<p>Processor time means what is usually called CPU time, which is how much work the processor has done on the current process's behalf. That is next to nothing if you have only slept for 3 seconds.</p>
<p>Use <code>time.time()</code> instead. </p>
</div>
<div class="post-text" itemprop="text">
<p>As @decece quoted from the manual, <a href="https://docs.python.org/3.4/library/time.html#time.perf_counter" rel="nofollow noreferrer">perf_counter()</a> would be a better choice here.</p>
<pre><code>import time

start = time.perf_counter()
time.sleep(3)
end = time.perf_counter()

print(end-start) # 3.003116666999631
</code></pre>
<p>If you want to test arbritary code, the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit - module</a> is a good choice:</p>
<pre><code>import timeit
n = 4
print( timeit.timeit( "time.sleep(3)", setup="import time", number=n)/n) 
</code></pre>
<p>Output:</p>
<pre><code>3.00312000513
</code></pre>
<p>You can give it a <code>setup=</code> code that is executed once and let it execute your sourcecode a <code>number</code> of times, getting the total time for all executions with otherwise default settings. </p>
<p>This will average out timings if you divide by number again - making the resulting time more robust.</p>
<p>API: <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a></p>
<hr/>
<p>Your concrete measurements for the <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow noreferrer">sleep-method</a> will vary, as it mostly guarantees to wait "at least" the amount of seconds given, depending on OS - rescheduling and interrupts it might take longer:</p>
<blockquote>
<p>Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.</p>
<p>Changed in version 3.5: The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale).</p>
</blockquote>
</div>
<span class="comment-copy"><i>"The behaviour of this function depends on the platform: use <code>perf_counter()</code> or <code>process_time()</code> instead, depending on your requirements, to have a well defined behaviour."</i></span>
<span class="comment-copy">Are you on Unix?  Because it looks like you're getting the <a href="https://docs.python.org/3/library/time.html#time.clock" rel="nofollow noreferrer">Windows behavior</a> "On Windows, this function returns wall-clock seconds elapsed since the first call to this function, as a floating point number, based on the Win32 function <code>QueryPerformanceCounter()</code>. The resolution is typically better than one microsecond."</span>
<span class="comment-copy">@PatrickHaugh That's a very strange wall clock you have there where only 0.00004 seconds have passed during the 3 seconds of sleeping :P</span>
<span class="comment-copy">@PatrickHaugh I'm on Unix</span>
<span class="comment-copy">Like the documentation says, it is <i>expressed</i> in seconds. It's not guaranteed to be one or more seconds. In your case the results is .00004 seconds. Processor time is not the same as wall clock time.</span>
