<div class="post-text" itemprop="text">
<p>A Django website I maintain currently uses Python 2.7 but I know that I'll have to upgrade it to Python 3 in a couple of months.  If I'm writing code right now that has to work in Python 2, is there a <em>Pythonic</em> way to write it such that it would also work in Python 3 without any changes if I know what the syntax is going to be in Python 3?  Ideally I'd like the code to continue to work even after the upgrade without changing it but it would be easy for me to spot where I've done this in the codebase so that I can change the code when I have time.  Here's an example of what I'm talking about:</p>
<pre><code># Python 2 uses 'iteritems'
def log_dict(**kwargs):
    for key, value in kwargs.iteritems():
        log.info("{0}: {1}".format(key, value))

# Python 3 uses 'items'
def log_dict(**kwargs):
    for key, value in kwargs.items():
        log.info("{0}: {1}".format(key, value))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">official documentation</a> suggesting ways to do this. That documentation has changed over time as the situation has changed, so it's worth going directly to the source (especially if you're reading this answer a year or two after it was written).</p>
<p>It's also worth reading the <a href="https://portingguide.readthedocs.io/en/latest/" rel="nofollow noreferrer">Conservative Python 3 Porting Guide</a> and skimming Nick Coghlan's Python 3 Q&amp;A, especially <a href="http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#what-other-changes-have-occurred-that-simplify-migration" rel="nofollow noreferrer">this section</a>.</p>
<p>Going back in time from the early 2018:</p>
<h2>futurize</h2>
<p>The current official suggestions are:</p>
<ul>
<li>Only worry about supporting Python 2.7</li>
<li>Make sure you have good test coverage (<a href="https://pypi.python.org/pypi/coverage" rel="nofollow noreferrer">coverage.py</a> can help; <code>pip install coverage</code>)</li>
<li>Learn the differences between Python 2 &amp; 3</li>
<li>Use <a href="http://python-future.org/automatic_conversion.html" rel="nofollow noreferrer">Futurize</a> (or <a href="https://python-modernize.readthedocs.org/en/latest/" rel="nofollow noreferrer">Modernize</a>) to update your code (e.g. <code>pip install future</code>)</li>
<li>Use <a href="https://pypi.python.org/pypi/pylint" rel="nofollow noreferrer">Pylint</a> to help make sure you don’t regress on your Python 3 support (<code>pip install pylint</code>)</li>
<li>Use <a href="https://pypi.python.org/pypi/caniusepython3" rel="nofollow noreferrer">caniusepython3</a> to find out which of your dependencies are blocking your use of Python 3 (<code>pip install caniusepython3</code>)</li>
<li>Once your dependencies are no longer blocking you, use continuous integration to make sure you stay compatible with Python 2 &amp; 3 (<a href="https://pypi.python.org/pypi/tox" rel="nofollow noreferrer">tox</a> can help test against multiple versions of Python; <code>pip install tox</code>)</li>
<li>Consider using optional static type checking to make sure your type usage works in both Python 2 &amp; 3 (e.g. use <a href="http://mypy-lang.org/" rel="nofollow noreferrer">mypy</a> to check your typing under both Python 2 &amp; Python 3).</li>
</ul>
<p>Notice the last suggestion. Guido and another of the core devs have both been heavily involved in leading large teams to port large 2.7 codebases to 3.x, and found mypy to be very helpful (especially in dealing with bytes-vs.-unicode issues). In fact, that's a large part of the reason gradual static typing is now an official part of the language.</p>
<p>You also almost certainly want to use all of the <a href="https://docs.python.org/3/library/__future__.html" rel="nofollow noreferrer"><code>future</code></a> statements available in 2.7. This is so obvious that they seem to have forgotten to leave it out of the docs, but, besides making your life easier (e.g., you can write <code>print</code> function calls), <code>futurize</code> and <code>modernize</code> (and <code>six</code> and <code>sixer</code>) require it.</p>
<h2>six</h2>
<p>The documentation is aimed at people making an irreversible transition to Python 3 in the near future. If you're planning to stick with dual-version code for a long time, you <em>might</em> be better off following the previous recommendations, which largely revolved around using <a href="https://pypi.org/project/six/" rel="nofollow noreferrer">six</a> instead of futurize. Six covers more of the differences between the two languages, and also makes you write code that's explicit about being dual-version instead of being as close to Python 3 as possible while still running in 2.7. But the downside is that you're effectively doing two ports—one from 2.7 to six-based dual-version code, and then, later, from 3.x-only six code to 3.x-only "native" code.</p>
<h2>2to3</h2>
<p>The original recommended answer was to use <a href="https://docs.python.org/3/library/2to3.html" rel="nofollow noreferrer">2to3</a>, a tool that can automatically convert Python 2 code to Python 3 code, or guide you in doing so. If you want your code to work in <em>both</em>, you need to deliver Python 2 code, then run <code>2to3</code> at installation time to port it to Python 3. Which means you need to test your code both ways, and usually modify it so that it still works in 2.7 but also works in 3.x after 2to3, which isn't always easy to work out. This turns out to not be feasible for most non-trivial projects, so it's no longer recommended by the core devs—but it is still built in with Python 2.7 and 3.x, and getting updates.</p>
<p>There are also two variations on 2to3: <a href="https://pypi.org/project/sixer/" rel="nofollow noreferrer">sixer</a> auto-ports your Python 2.7 code to dual-version code that uses six, and <a href="https://pypi.org/project/3to2/" rel="nofollow noreferrer">3to2</a> lets you write your code for Python 3 and auto-port back to 2.7 at install time. Both of these were popular for a time, but don't seem to be used much anymore; modernize and futurize, respectively, are their main successors.</p>
<hr/>
<p>For your specific question,</p>
<ul>
<li><code>kwargs.items()</code> will work on both, if you don't mind a minor performance cost in 2.7.</li>
<li>2to3 can automatically change that <code>iteritems</code> to <code>items</code> at install time on 3.x.</li>
<li>futurize can be used to do either of the above.</li>
<li>six will allow you to write <code>six.iteritems(kwargs)</code>, which will do <code>iteritems</code> in 2.7 and <code>items</code> in 3.x.</li>
<li>six will also allow you to write <code>six.viewitems(kwargs)</code>, which will do <code>viewitems</code> in 2.7 (which is identical to what <code>items</code> does in 3.x, rather than just similar).</li>
<li>modernize and sixer will automatically change that <code>kwargs.iteritems()</code> to <code>six.iteritems(kwargs)</code>.</li>
<li>3to2 will let you write <code>kwargs.items()</code> and autmatically convert it to <code>viewitems</code> at install time on 2.x.</li>
<li>mypy can verify that you're just using the result as a general iterable (rather than specifically as an iterator), so changing to <code>viewitems</code> or <code>items</code> leaves your code still correctly typed.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>you can import the future package</p>
<pre><code>from future import ....
</code></pre>
<p>nested_scopes   2.1.0b1 2.2 PEP 227: Statically Nested Scopes</p>
<p>generators  2.2.0a1 2.3 PEP 255: Simple Generators</p>
<p>division    2.2.0a2 3.0 PEP 238: Changing the Division Operator</p>
<p>absolute_import 2.5.0a1 3.0 PEP 328: Imports: Multi-Line and Absolute/Relative</p>
<p>with_statement  2.5.0a1 2.6 PEP 343: The “with” Statement</p>
<p>print_function  2.6.0a2 3.0 PEP 3105: Make print a function</p>
<p>unicode_literals    2.6.0a2 3.0 PEP 3112: Bytes literals in Python 3000</p>
</div>
<div class="post-text" itemprop="text">
<p>Making your Django project compatible with both Python versions consists of the following steps:</p>
<ol>
<li><p>Add <code>from __future__ import unicode_literals</code> at the top of each module and then use usual quotes without a u prefix for Unicode strings and a b prefix for bytestrings.</p></li>
<li><p>To ensure that a value is bytestring, use the <code>django.utils.encoding.smart_bytes</code> function. To ensure that a value is Unicode, use the <code>django.utils.encoding.smart_text</code> or <code>django.utils.encoding.force_text</code> function.</p></li>
<li><p>In your models use <code>__str__</code> method instead of <code>__unicode__</code> and add the <code>python_2_unicode_compatible</code> decorator.</p>
<pre><code># models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible

@python_2_unicode_compatible
class NewsArticle(models.Model):
    title = models.CharField(_("Title"), max_length=200)
     content = models.TextField(_("Content"))

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = _("News Article")
        verbose_name_plural = _("News Articles")
</code></pre></li>
<li><p>To iterate through dictionaries, use iteritems() , iterkeys() , and itervalues() from django.utils.six . Take a look at the following:</p>
<pre><code>from django.utils.six import iteritems

d = {"imported": 25, "skipped": 12, "deleted": 3}
for k, v in iteritems(d):
    print("{0}: {1}".format(k, v))
</code></pre></li>
<li><p>At the time of capturing exceptions, use the as keyword, as follows:</p>
<pre><code>try:
    article = NewsArticle.objects.get(slug="hello-world")
except NewsArticle.DoesNotExist as exc:
    pass
except NewsArticle.MultipleObjectsReturned as exc:
    pass
</code></pre></li>
<li><p>Use django.utils.six to check the type of a value as shown in the following:</p>
<pre><code>from django.utils import six

isinstance(val, six.string_types) # previously basestring
isinstance(val, six.text_type) # previously unicode
isinstance(val, bytes) # previously str
isinstance(val, six.integer_types) # previously (int, long)
</code></pre></li>
<li><p>Use range from django.utils.six.moves ,Instead of xrange , as follows:</p>
<pre><code>from django.utils.six.moves import range

for i in range(1, 11):
   print(i)
</code></pre></li>
</ol>
<p><strong><a href="https://github.com/localboy/django-python-2-3" rel="nofollow noreferrer">Source link</a></strong></p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to importing from future, there is also the six project that aims to provide api compatibility between Python 2 and Python 3: <a href="https://pypi.org/project/six/" rel="nofollow noreferrer">https://pypi.org/project/six/</a>.</p>
<p>Your example code could be made compatible between version 2 and 3:</p>
<pre><code>import six

for key, value in six.iteritems(dict):
    log.info("{0}: {1}".format(key, value))
</code></pre>
<p>There are still things that won't be compatible between 2 and 3 like f-strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few different tools that will help you make sure you are writing python2/3 compatible code. </p>
<p>If you are interested in porting python2 code into python3, then the 2to3 program that comes with the standard library will try to convert a python 2 program to python 3.</p>
<p><a href="https://docs.python.org/2/library/2to3.html" rel="nofollow noreferrer">https://docs.python.org/2/library/2to3.html</a></p>
<p>Another great tool is pylint. pylint is a python linter that will describe issues to you without fixing them. If you pip install pylint on a python3 environment, then it will analyze your code based on python 3's rules. If you use python 2 to install pylint, it will do the same but with python 2's rules.</p>
<p>There are other popular and similar tools like flake8 or autopep8, but I am not familiar with them enough to advertise them.</p>
</div>
<div class="post-text" itemprop="text">
<p>six and future is a golden rule, enough to make easy a coming migration</p>
<p>add to every python2 file, this as first line:</p>
<pre><code>from __future__ import absolute_import, unicode_literals
</code></pre>
<p>use below working with strings, iteration, metaclasses, ...</p>
<pre><code>isinstance(sth, six.string_types)

six.iteritems(dict)

@six.add_metaclass(Meta)
</code></pre>
<p>and so on <a href="https://pythonhosted.org/six/" rel="nofollow noreferrer">six reference</a></p>
</div>
<span class="comment-copy">I don't see why a question which of immediate relevance to the Python community with the 2.7 upcoming Jan 1 2020 EOL is to be considered off topic. Neither do I see it as overly broad - <i>how do I keep my code runnable in both 2 and 3</i> is the gist here.   @abarnet's answer is an excellent starting point for anyone looking to SO for guidance on this topic.  Folk not interested by this subject can just ignore it.</span>
<span class="comment-copy">I posted two contrasting code examples.  How much more specific and detailed can I be about this problem?  This smacks of the elitist attitudes discussed in this article: <a href="https://shrtm.nu/L6ql" rel="nofollow noreferrer">shrtm.nu/L6ql</a>.</span>
<span class="comment-copy">This will be very helpful when it comes time to switch to Python 3 but it doesn't quite address my more general question on how to write code that will work in both 2 and 3 at the same time.  Still, I appreciate the tips.</span>
