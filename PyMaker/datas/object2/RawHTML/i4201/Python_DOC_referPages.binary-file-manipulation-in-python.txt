<div class="post-text" itemprop="text">
<p>I need a help in my code, I am not able to do the binary file manipulation.</p>
<p>code for creating the binary file:</p>
<pre><code>import struct
numeros = [-9 ,20.5, 6, 10.8, 10, 8.0, 45, -99.6 ,12, -54.7];

try:
  with open('value.bin', "wb") as arq:
    arq.write(struct.pack("i", 5))
    for num in numeros:
        if isinstance(num, int):
            arq.write(struct.pack("i", num))
        elif isinstance(num, float):
            arq.write(struct.pack("f", num))
except IOError:
        print("Error opening or handling file.")
</code></pre>
<p>code for file manipulation:</p>
<pre><code>try:

    with open('value.bin', 'r+b') as arq:
      n  = struct.unpack('=i', arq.read(4))[0]
      for i in range(n):
        j = i
        numInt= struct.unpack('=i', arq.read(4))
        numFloat = struct.unpack('=f', arq.read(4))
        arq.seek(4)
        if numInt[0] &lt;10:
            arq.write(struct.pack("i", -1))
        elif numFloat[0] &gt;9.0:
            arq.write(struct.pack("f", 9999.0))

except IOError:
        print('Error opening or handling file.')
</code></pre>
<p>correct output:</p>
<pre><code> 5 -1 9999.0 -1 9999.0 10 8.0 45 -99.6 12 -54.7
</code></pre>
<p>Exit from my code:</p>
<pre><code>5  -9 20.5 6 10.80000019073486310 8.0 45 -99.599998474121112 -54.70000076293945
</code></pre>
<p>the numbers -9, 20.5, 6, 10.8 are not being changed.</p>
<p>I need this help.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>code.py</em>:</p>
<pre><code>import sys
import struct
import struct
import os


int_format = "i"
float_format = "f"
int_size = struct.calcsize(int_format)
float_size = struct.calcsize(float_format)


def write_file(file_name):
    numeros = [-9, 20.5, 6, 10.8, 10, 8.0, 45, -99.6, 12, -54.7]
    print("Original numbers:", numeros)
    try:
        with open(file_name, "wb") as arq:
            arq.write(struct.pack(int_format, len(numeros) // 2))
            for num in numeros:
                if isinstance(num, int):
                    arq.write(struct.pack(int_format, num))
                elif isinstance(num, float):
                    arq.write(struct.pack(float_format, num))
    except IOError as e:
        print("Error opening or handling file:", e)


def read_file(file_name):
    ret = list()
    try:
        with open(file_name, "rb") as arq:
            n  = struct.unpack(int_format, arq.read(int_size))[0]
            ret.append(n)
            for i in range(n):
                #num_int = struct.unpack(int_format, arq.read(int_size))[0]
                #num_float = struct.unpack(float_format, arq.read(float_size))[0]
                num_int, num_float = struct.unpack(int_format + float_format, arq.read(int_size + float_size))
                ret.extend([num_int, num_float])
    except IOError as e:
        print("Error opening or handling file:", e)
    return ret


def modify_file(file_name):
    int_replacement = struct.pack(int_format, -1)
    float_replacement = struct.pack(float_format, 9999.0)
    try:
        with open(file_name, "r+b") as arq:
            n  = struct.unpack(int_format, arq.read(int_size))[0]
            for i in range(n):
                #num_int = struct.unpack(int_format, arq.read(int_size))[0]
                #num_float = struct.unpack(float_format, arq.read(float_size))[0]
                num_int, num_float = struct.unpack(int_format + float_format, arq.read(int_size + float_size))
                if num_int &lt; 10:
                    arq.seek(-(int_size + float_size), os.SEEK_CUR)
                    arq.write(int_replacement)
                    arq.seek(float_size, os.SEEK_CUR)
                if num_float &gt; 9.0:
                    arq.seek(-float_size, os.SEEK_CUR)
                    arq.write(float_replacement)
    except IOError as e:
        print("Error opening or handling file:", e)


def main():
    file_name = "value.bin"
    write_file(file_name)
    print("Original file content:", read_file(file_name))
    modify_file(file_name)
    print("Modified file content:", read_file(file_name))


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Module documentation: <a href="https://docs.python.org/3/library/struct.html#module-struct" rel="nofollow noreferrer">[Python]: struct - Interpret bytes as packed binary data</a></li>
<li>Stored values used many times in the code as variables. Example: the <em>int format</em>: <code>int_format = "i"</code></li>
<li>Also used <code>struct.calcsize</code> to replace the value sizes that are read from file (as a coincidence both <code>int</code> and <code>float</code> are <strong><em>4</em></strong>, but it's more general this way)</li>
<li>Split the program in functions:

<ul>
<li><code>write_file</code> - generates the file based on the <code>numeros</code> list</li>
<li><code>read_file</code> - reads (and parses) file content and returns it as a list</li>
<li><code>modify_file</code> - reads the file content and replaces some of the values on the way

<ul>
<li>Calculates the new values that are going to replace old ones (e.g. <code>int_replacement</code> <strong>once</strong>, before the loop)</li>
<li>The conditions (e.g. <code>if numInt[0] &gt; 10</code>) were reversed (got corrected in the meantime)</li>
<li>By using <code>if</code> / <code>elif</code> when converting the <code>int</code>, if the <code>float</code> coming after it needs to be converted as well, it wouldn't be. Changed to 2 separate <code>if</code> statements</li>
<li>The main flaw was the way how <a href="https://docs.python.org/3/library/io.html#io.IOBase.seek" rel="nofollow noreferrer">[Python]: <strong>seek</strong>(<em>offset[, whence])</em></a> was performed: always to the beginning of the file. This is not correct: seek from the current position (<code>os.SEEK_CUR</code>):

<ul>
<li>When changing the <code>int</code>: seek back 8 bytes (the <code>float</code> and the <code>int</code>), write 4 bytes (which will move the file pointer 4 bytes forward) and then seek forward 4 more bytes (the <code>float</code> that comes after it) - so at the end the file pointer is in the same position</li>
<li>When changing the <code>float</code>: simpler, seek back 4 bytes, and write 4 bytes (which will move the file pointer 4 bytes forward - where it was)</li>
</ul></li>
</ul></li>
<li><code>main</code>- aggregates the above</li>
</ul></li>
<li>In <code>read_file</code> and <code>modify_file</code>, the <code>int</code> and the <code>float</code> are read at once, so the 2 commented lines are equivalent to the line below them</li>
<li>Some other minor changes, there could be more, but I don't want to overcomplicate the code</li>
<li>The <code>float</code>s are different because of <em>precision loss</em> during conversion, but if printed with one decimal only, will match the original ones</li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>(py35x64_test) e:\Work\Dev\StackOverflow\q050106975&gt;python code.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

Original numbers: [-9, 20.5, 6, 10.8, 10, 8.0, 45, -99.6, 12, -54.7]
Original file content: [5, -9, 20.5, 6, 10.800000190734863, 10, 8.0, 45, -99.5999984741211, 12, -54.70000076293945]
Modified file content: [5, -1, 9999.0, -1, 9999.0, 10, 8.0, 45, -99.5999984741211, 12, -54.70000076293945]
</code></pre>
</blockquote>
</div>
<span class="comment-copy">What exactly would you  like <i>manipulation</i> code to do? If you need to modify the values that are in the file, why not writing them modified in the 1st place? Where does that output come from (as I don't see anything in the code)?</span>
<span class="comment-copy">I have this file and I need to exchange these values, it's for my learning</span>
<span class="comment-copy">can you help me</span>
<span class="comment-copy">can you help me</span>
<span class="comment-copy">Again, how do you want to modify them? The code and correct output don't match. The last 4 numbers from the correct output should also be changed.</span>
