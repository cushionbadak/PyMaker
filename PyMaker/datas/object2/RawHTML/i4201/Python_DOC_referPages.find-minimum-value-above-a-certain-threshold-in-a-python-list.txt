<div class="post-text" itemprop="text">
<p>I'm trying to find the minimum in a list, above a certain threshold without using the min() function (I'm doing things the hard way for practice). </p>
<p>I've managed by first creating a list of values above the threshold and then looping through the list, saving a value to a variable if it is smaller than the previously seen values: </p>
<pre><code>def minpass(mymarks, mypass):
    passed= [x for x in mymarks if x &gt;= mypass]
    min_value = passed[0]
    for x in passed: 
        if x &lt; min_value:
            min_value = x
    return min_value

x = [2, 53, 90]
y = 50

minpass(x, y)
</code></pre>
<p>This correctly returns 53. </p>
<p>Is it possible to do it without creating a second list (passed)?
Why doesn't it work to add a second condition? e.g. </p>
<pre><code>def minpass(mymarks, mypass):
    min_value = mymarks[0]
    for x in mymarks: 
        if x &lt; min_value and x &gt;= mypass:
            min_value = x
    return min_value

x = [2, 53, 90]
y = 50

minpass(x, y)
</code></pre>
<p>This incorrectly returns 2 rather than 53. </p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're doing this as a learning experience:</p>
<p>To avoid creating a second list, the most interesting alternative is to create a lazy iterator instead. Under the covers, this works out the next filtered value on demand, instead of building a list of them up-front. But from much of your code, it can actually look as if you created a list.</p>
<p>There are different ways to create lazy iterators—an explicit iterator class, the <code>filter</code> builtin, a generator function—but in your case, you can just use a generator expression instead of a list comprehension:</p>
<pre><code>passed = (x for x in mymarks if x &gt;= mypass)
</code></pre>
<p>All I had to do was change the square brackets to parentheses, and you've magically got a lazy iterator.</p>
<p>However, an iterator can only be used to go through the values in order, once. You can't do things like indexing (<code>passed[0]</code>). So you need to rethink your code a bit. But that turns out to be very easy:</p>
<pre><code>def minpass(mymarks, mypass):
    passed = (x for x in mymarks if x &gt;= mypass)
    min_value = next(passed) # this consumes the first value
    for x in passed: # this loops over all the remaining values
        if x &lt; min_value:
            min_value = x
    return min_value
</code></pre>
<hr/>
<p>While we're at it, you might want to consider refactoring your code into two functions—write your own <code>minvalue</code> function that takes any iterable (an iterable is a lazy iterator, or a sequence like a list, or anything else that can go in a <code>for</code> loop) and returns the minimum value:</p>
<pre><code>def minvalue(it):
    it = iter(it) # this makes sure we have a lazy iterator
    min_value = next(it) # this consumes the first value
    for x in it: # this loops over all the remaining values
        if x &lt; min_value:
            min_value = x
    return min_value

def minpass(mymarks, mypass):
    return minvalue(x for x in mymarks if x &gt;= mypass)
</code></pre>
<p>Or maybe refactor further:</p>
<pre><code>def passvalues(it, mypass):
    return (x for x in it if x &gt;= mypass)

def minpass(mymarks, mypass):
    return minvalue(passvalues(mymarks, mypass))
</code></pre>
<hr/>
<p>Notice that this approach solves your second problem automatically. Your problem was that <code>mymarks[0]</code> might not be <code>&gt;= mypass</code>. To rewrite things to work, you'd have to do something like this:</p>
<pre><code>def minpass(mymarks, mypass):
    for x in mymarks:
        if x &gt;= mypass:
            min_value = x
            break
    for x in mymarks: 
        if x &lt; min_value and x &gt;= mypass:
            min_value = x
    return min_value
</code></pre>
<p>But writing things as a chain of iterator transformations forces you to put them in order—do the filtering first, and then the min-finding, which means you're automatically getting the first filtered value rather than the first value—while still interleaving the work (and avoiding the time and space costs of creating a whole unnecessary list) the way you wanted.</p>
<hr/>
<p>If you want a more in-depth introduction to these ideas, David Beazley's <a href="http://www.dabeaz.com/generators/" rel="nofollow noreferrer">Generator Tricks for Systems Programmers</a> is amazing.</p>
<hr/>
<p>One last thing to consider: is there a way to get rid of the special treatment for the first value?</p>
<p>You could start with a value that will be greater than anything, or you could use a flag to specify whether you'd found a minimum value so far:</p>
<pre><code>def minvalue(it):
    found_min = False
    for x in it:
        if not found_min or x &lt; min_value:
            min_value = x
            found_min = True
    return min_value
</code></pre>
<p>This has the advantage (or maybe disadvantage, depending on what you wanted…) of still failing when passed an empty list, but it simplifies the looping (no need to pull out the first value, which means no need to call <code>iter</code>). But the manual flag management might add more noise than it helps you remove. Still, it's worth comparing the two and deciding for yourself.</p>
<hr/>
<p>Other things you might want to consider trying for yourself:</p>
<ul>
<li>Rewrite <code>minvalue</code> around <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce</code></a>.</li>
<li>Rewrite <code>minvalue</code> to use a "smaller than anything" value.

<ul>
<li><code>float('inf')</code> will work if all of your values are ints or floats.</li>
<li>If the values can be anything at all, you can define a <code>BiggestThing</code> class with <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">a custom <code>__lt__</code> method</a>, and use <code>BiggestThing()</code>.</li>
</ul></li>
<li>Figure out all the different options for what to do with an empty input—or an input that isn't empty but doesn't have any values that pass the filter—and how to implement them.</li>
<li>Try using a sorted data structure, like the one in <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code></a> to do <code>minvalue</code>—then you can expand it to return the two lowest values instead of just the lowest, or take an <code>numlowest</code> parameter and and return that many.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In general, find the <code>min</code> (or <code>max</code>) using a loop requires you to initialize the return variable to something huge (or a huge negative value).</p>
<p>In your case you are initializing the minimum to the first element in the list. Then for subsequent elements, the <code>x &lt; min_value</code> check will evaluate to <code>False</code> since this value is already the minimum of the whole list.</p>
<p>Here is one way to modify your code:</p>
<pre><code>def minpass(mymarks, mypass):
    min_value = 1e10  # something bigger than your maximum value
    for x in mymarks: 
        if x &lt; min_value and x &gt;= mypass:
            min_value = x
    return min_value

x = [2, 53, 90]
y = 50

minpass(x, y)
#53
</code></pre>
</div>
<span class="comment-copy">Your second version doesn't work because you use the first value in your array as your initial minimum.  Use <code>float('inf')</code> and see what happens.  When you set your minimum to 2, 53 is <i>not</i> less than 2.  You never find a value you can reset to.</span>
<span class="comment-copy">@pault Thanks; fixed. (This is all off the top of my head and untested, so there may well be other problems; I'll test them all to see…)</span>
<span class="comment-copy">I think it works- I tested parts of it. Looks good and great explanation!</span>
<span class="comment-copy">Wow! Great answer! Thank you :)</span>
<span class="comment-copy">Thanks! If the initial value is &lt;53, why doesn't the second condition, x &gt;= mypass, get evaluated?</span>
<span class="comment-copy">Python boolean operators <a href="https://stackoverflow.com/a/14892812/5858851">support short circuiting</a>- so in an <code>and</code> operation, <code>False</code> will be returned once the first <code>False</code>-y value is encountered. But in this case, the non-evaluation of <code>x&gt;=mypass</code> does not make a difference because both conditions have to be <code>True</code>. So even if you reversed the order of the checks, you'd have the same result. Does this make sense?</span>
<span class="comment-copy">Yes, thank you!</span>
