<div class="post-text" itemprop="text">
<p>I am trying to write in Python a script that takes a string and returns a list of string by iteratively moves the letters in the original sequence.</p>
<p>For example : ACGT--&gt;TACG --&gt;GTAC--&gt;CGTA--&gt;STOP (original sequence)</p>
<p>I am a beginner in programming, here is what I've succeed to do </p>
<pre><code>liste=[]
seq=list('ACGT')
nseq=list("test")
while nseq!=seq:
    for i in range (0, len(seq)):
        nseq[i]=seq[i-1]
        ''.join(nseq)
        liste.append(nseq)
</code></pre>
<p>It only returns the first step like TACG and doesn't go on. </p>
<p>Output : <code>['T', 'A', 'C', 'G']</code>multiple time (endless loop)</p>
<p>Expected output : </p>
<p><code>TACG
GTAC
CGTA</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Basically, you need to move the last element to the beginning until you come to the original sequence. For this <a href="https://docs.python.org/3.6/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> and it's <a href="https://docs.python.org/3.6/library/collections.html#collections.deque.rotate" rel="nofollow noreferrer"><code>rotate()</code></a> method (which is equivalent to <code>d.appendleft(d.pop())</code>)  should be the most efficient:</p>
<pre><code>from collections import deque

def rotations(s):
    yield s
    d = deque(s)

    for _ in range(len(d) - 1):
        d.rotate(1)
        yield ''.join(d)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; for r in rotations('ACGT'):
...     print(r)
... 
ACGT
TACG
GTAC
CGTA
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple solution without any import.</p>
<pre><code>def rot(s, n):
    return s[-n:] + s[:-n]

for i in range(4):
    print(rot('ACGT', i))
</code></pre>
<p><strong>Output</strong></p>
<blockquote>
<p>ACGT</p>
<p>TACG</p>
<p>GTAC</p>
<p>CGTA</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>One option is to use <code>collections.deque</code> and <code>rotate</code>:</p>
<pre><code>from collections import deque

def rotator(x):
    yield x
    y = deque(x)
    for _ in range(len(y)-1):
        y.rotate(1)
        yield ''.join(y)

res = list(rotator('ACGT'))

print(res)

['ACGT', 'TACG', 'GTAC', 'CGTA']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def move_letter_forward(string):
    str_list = [string]
    for i in range(len(string) - 1):
        str_list.append(str_list[-1][-1] + str_list[-1][:-1])
    return str_list
</code></pre>
<hr/>
<p>If you want the output to be:</p>
<pre><code>TACG
GTAC
CGTA
</code></pre>
<p>The above code can be change to:</p>
<pre><code>def move_letter_forward(string):
    str_list = [string]
    for i in range(len(string) - 1):
        str_list.append(str_list[-1][-1] + str_list[-1][:-1])
    return str_list[1:]
for string in move_forward('ACGT'):
        print(string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>list = []
seq = "ACGT"
for i in range(len(seq), 0, -1):
    list.append(seq[i:]+seq[:i])
# list = ['ACGT', 'TACG', 'GTAC', 'CGTA']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you only need rotations to be printed, have a look at this:</p>
<pre><code>&gt;&gt;&gt; s = 'ACGT'
&gt;&gt;&gt; '--&gt;'.join(s[i:]+s[0:i] for i in range(len(s),0,-1))
'ACGT--&gt;TACG--&gt;GTAC--&gt;CGTA'
</code></pre>
<p>If you need in a list just omit the <code>'--&gt;'.join</code> part:</p>
<pre><code>&gt;&gt;&gt; rotations = [s[i:]+s[0:i] for i in range(len(s),0,-1)]
&gt;&gt;&gt; rotations
['ACGT', 'TACG', 'GTAC', 'CGTA']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be achieved using queue data structure.</p>
<p>Here is the general version</p>
<ol>
<li><p>pop the element from the last index</p></li>
<li><p>push the element to first index</p></li>
<li>repeat it for the length of the input string.</li>
</ol>
<p>I leave the implementation to you, use this as reference <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">Queue DS in python</a></p>
<p>Here is the implementation
Code</p>
<pre><code>from collections import deque
ip = 'ACGT'
d = deque(ip)

for i in range(len(ip)):
    temp = d.pop()
    d.appendleft(temp)
    print(''.join(d))


OUTPUT
TACG
GTAC
CGTA
ACGT
</code></pre>
</div>
<span class="comment-copy">Please update your question with the actual output from your code, plus your required output to help us work out what the problem is.</span>
<span class="comment-copy">Can you explain more about the context, this is obviously DNA, what's the bioinformatic problem you're trying to solve?</span>
<span class="comment-copy">I am working with tandem repeats sequence. I have patterns as output of a software and want to put together all the "identical" patterns (same sequence but not cut at the same point by the software.)</span>
<span class="comment-copy">You want to align the tandem repeats?</span>
<span class="comment-copy">No I am just doing quantification so I just want to select one tandem (and its "brothers") and sum the number of time it has been detected.</span>
<span class="comment-copy">upvote from me, seems like the best approach to the programmatic issue as stated</span>
<span class="comment-copy">Downvoter care to comment? Don't worry I don't retaliate.. just want to know what I can improve.</span>
<span class="comment-copy">plus 1 for simple answer.</span>
<span class="comment-copy">The output is the wrong order</span>
<span class="comment-copy">@Chris_Rands Your are right. I edited my answer.</span>
<span class="comment-copy">string can't be pop..</span>
<span class="comment-copy">Well there is certainly conversion of string into list of characters in the intermediate steps.</span>
<span class="comment-copy">yes, that can be option</span>
<span class="comment-copy">see the implementation. this method is generic and can be used with any string</span>
<span class="comment-copy">yes, got your point. but somewhat lengthy process.</span>
