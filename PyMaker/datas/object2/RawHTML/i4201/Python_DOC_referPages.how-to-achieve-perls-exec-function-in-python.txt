<div class="post-text" itemprop="text">
<p>Assume using Linux:</p>
<p>In Perl, the <a href="http://perldoc.perl.org/functions/exec.html" rel="nofollow noreferrer"><code>exec</code> function</a> executes an external program and immediately exits itself, leaving the external program in same shell session.</p>
<p>A very close answer using Python is <a href="https://stackoverflow.com/a/13256908">https://stackoverflow.com/a/13256908</a></p>
<p>However, the Python solution using <code>start_new_session=True</code> starts an external program using setsid method, that means that solution is suitable for making a daemon, not an interactive program.</p>
<p>Here is an simple example of using perl:</p>
<pre><code>perl -e '$para=qq(-X --cmd ":vsp");exec "vim $para"'
</code></pre>
<p>After vim is started, the original Perl program has exited and the vim is still in the same shell session(vim is not sent to new session group).</p>
<p>How to get the same solution with Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perl is just wrapping the <a href="http://man7.org/linux/man-pages/man3/exec.3.html" rel="nofollow noreferrer"><code>exec*</code> system call functions</a> here. Python has the same wrappers, in the <code>os</code> module, see the <a href="https://docs.python.org/3/library/os.html#os.execl" rel="nofollow noreferrer"><code>os.exec*</code> documentation</a>:</p>
<blockquote>
<p>These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller.</p>
</blockquote>
<p>To do the same in Python:</p>
<pre><code>python -c 'import os; para="-X --cmd \":vsp\"".split(); os.execlp("vim", *para)'
</code></pre>
<p><code>os.execlp</code> accepts an argument list and looks up the binary in <code>$PATH</code> from the first argument.</p>
<p>The <code>subprocess</code> module is only ever suitable for running processes <em>next</em> to the Python process, not to replace the Python process. On POSIX systems, the <code>subprocess</code> module uses the low-level <code>exec*</code> functions to implement it's functionality, where a <em>fork</em> of the Python process is then replaced with the command you wanted to run with <code>subprocess</code>.</p>
</div>
<span class="comment-copy">Actually, <code>exec</code> simply replaces the program running in the existing process.</span>
