<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/20052327/merging-repeated-items-in-a-list-into-a-python-dictionary">Merging repeated items in a list into a python dictionary</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/960733/python-creating-a-dictionary-of-lists">Python creating a dictionary of lists</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>Imagine we have a list of lists where the nested list contains two elements [A, B]. Now, you want to convert such list into a dictionary where the first element should be the key and the second element should be its value. For example:</p>
<pre><code>[['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'B1'], ['B', 'C1'], ['C', 'B2'], ['C', 'C2'], ['C', 'D2']] --&gt;

{'A': ['B', 'C', 'D'], 'B': ['B1', 'C1'], 'C': ['B2', 'C2', 'D2']}
</code></pre>
<p>The order of the values should be kept. </p>
<p>I have a straightforward solution:</p>
<pre><code>lst = [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'B1'], ['C', 'C1']]
dic = {}
for el in lst:
    if dic.get(el[0]) is None:
        dic[el[0]] = [el[1]]
        continue
    dic[el[0]].append(el[1])
</code></pre>
<p>And an ugly list comprehension solution which is significantly slower because it performs a loop over complete data for each single key.</p>
<pre><code>dic = dict([(el[0], [e[1] for r in lst if e[0] == el[0]])
            for el in lst])
</code></pre>
<p>There should be a better and more elegant way to do this. Can you come up with something?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a defaultdict:</p>
<pre><code>from collections import defaultdict
dic = defaultdict(list)
for k, v in lst:
    dic[k].append(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative to <code>defaultdict</code> is to use the <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>.setdefault</code></a> method of a plain <code>dict</code>.</p>
<pre><code>lst = [
    ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'B1'],
    ['B', 'C1'], ['C', 'B2'], ['C', 'C2'], ['C', 'D2'],
]

dic = {}
for key, val in lst:
    dic.setdefault(key, []).append(val)
print(dic)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{'A': ['B', 'C', 'D'], 'B': ['B1', 'C1'], 'C': ['B2', 'C2', 'D2']}
</code></pre>
<p>This will preserve the order of the values in all versions of Python, and in Python 3.6+ it will also preserve the order of the keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach would be this:</p>
<pre><code>l = [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'B1'], ['B', 'C1'], ['C', 'B2'], ['C', 'C2'], ['C', 'D2']]

d = dict((elem[0],[]) for elem in l)
for elem in l:
    d[elem[0]].append(elem[1])
print(d)
</code></pre>
<p>Output:</p>
<pre><code>{'A': ['B', 'C', 'D'], 'B': ['B1', 'C1'], 'C': ['B2', 'C2', 'D2']}
</code></pre>
</div>
<span class="comment-copy">come on it's a 100th time duplicate...</span>
<span class="comment-copy">yes, and it's a duplicate answered many times</span>
<span class="comment-copy">@Jean-FrançoisFabre Fair enough. But couldn't you find a good dupe target that uses <code>.append</code> instead of <code>.extend</code>? Sure, they're similar, but the extend case used in your target is a little more complex than doing a simple append.</span>
<span class="comment-copy">I've seen that a lot of times. It's just that I cannot find the dupes I've seen right now.</span>
<span class="comment-copy">ah found a better one. That said, I like this particular question. It's clear, as opposed to the questions linked. I may not have found the perfect dupe, but there <i>is</i> one :)</span>
<span class="comment-copy">@Jean-FrançoisFabre It's tricky to find a good dupe for this. The questions tend to be fairly specific, and while an expert may be able to apply the code from a different question it might not be so easy for a newer coder, so it's easier to just write a fresh answer.</span>
