<div class="post-text" itemprop="text">
<p>This is not a duplicate of <a href="https://stackoverflow.com/questions/6282042/assignment-inside-lambda-expression-in-python">Assignment inside lambda expression in Python</a>, i.e., I'm <em>not</em> asking how to trick Python into assigning in a <code>lambda</code> expression.</p>
<p>I have some λ-calculus background.  Considering the following code, it
looks like Python is quite willing to perform side-effects in <code>lambda</code>
expressions:</p>
<pre><code>#!/usr/bin/python

def applyTo42(f):
    return f(42)

def double(x):
    return x * 2

class ContainsVal:
    def __init__(self, v):
        self.v = v

    def store(self, v):
        self.v = v

def main():

    print('== functional, no side effects')

    print('-- print the double of 42')
    print(applyTo42(double))

    print('-- print 1000 more than 42')
    print(applyTo42(lambda x: x + 1000))

    print('-- print c\'s value instead of 42')
    c = ContainsVal(23)
    print(applyTo42(lambda x: c.v))


    print('== not functional, side effects')

    print('-- perform IO on 42')
    applyTo42(lambda x: print(x))

    print('-- set c\'s value to 42')
    print(c.v)
    applyTo42(lambda x: c.store(x))
    print(c.v)

    #print('== illegal, but why?')
    #print(applyTo42(lambda x: c.v = 99))

if __name__ == '__main__':
    main()
</code></pre>
<p>But if I uncomment the lines</p>
<pre><code>    print('== illegal, but why?')
    print(applyTo42(lambda x: c.v = 99))
</code></pre>
<p>I'll get</p>
<pre><code>SyntaxError: lambda cannot contain assignment
</code></pre>
<p>Why not?  <strong>What is the deeper reason behind this?</strong></p>
<ul>
<li><p>As the code demonstrates, it cannot be about “purity” in a
functional sense.</p></li>
<li><p>The only explanation I can imagine is that assignemts do not
return anything, not even <code>None</code>.  But that sounds lame and would
be easy to fix (one way: make lambda expressions return <code>None</code> if
body is a statement).</p></li>
</ul>
<p>Not an answer:</p>
<ul>
<li><p>Because it's defined that way (I want to know why it's defined that way).</p></li>
<li><p>Because it's in the grammar (see above).</p></li>
<li><p>Use <code>def</code> if you need statements (I did not ask for how to get
statements into a function).</p></li>
</ul>
<p>“This would change syntax / the language / semantics” would be ok as an answer if you can come up with an example of such a change, and why it would be bad.</p>
</div>
<div class="post-text" itemprop="text">
<p>The entire reason <code>lambda</code> exists is that it's an expression.<sup>1</sup> If you want something that's like <code>lambda</code> but is a statement, that's just <code>def</code>.</p>
<p>Python expressions cannot contain statements. This is, in fact, fundamental to the language, and Python gets a lot of mileage out of that decision. It's the reason indentation for flow control works instead of being clunky as in many other attempts (like CoffeeScript). It's the reason you can read off the state changes by skimming the first object in each line. It's even part of the reason the language is easy to parse, both for the compiler and for human readers.<sup>2</sup></p>
<p>Changing Python to have some way to "escape" the statement-expression divide, except maybe in a very careful and limited way, would turn it into a completely different language, and one that no longer had many of the benefits that cause people to choose Python in the first place.</p>
<p>Changing Python to make most statements expressions (like, say, Ruby) would again turn it into a completely different language without Python's current benefits.</p>
<p>And if Python <em>did</em> make either of those changes, then there'd no longer be a reason for <code>lambda</code> in the first place;<sup>2,3</sup> you could just use <code>def</code> statements inside an expression.</p>
<hr/>
<p>What about changing Python to instead make assignments expressions? Well, it should be obvious that would break "you can read off the state changes by skimming the first object in each line". Although Guido usually focuses on the fact that <code>if spam=eggs</code> is an error more often than a useful thing.</p>
<p>The fact that Python does give you ways to get around that when needed, like <code>setattr</code> or even explicitly calling <code>__setitem__</code> on <code>globals()</code>, doesn't mean it's something that should have direct syntactic support. Something that's very rarely needed doesn't deserve syntactic sugar—and even more so for something that's unusual enough that it should raise eyebrows and/or red flags when it actually is done.</p>
<hr/>
<p><sub>1. I have no idea whether that was Guido's understanding when he originally added <code>lambda</code> back in Python 1.0. But it's definitely the reason <code>lambda</code> wasn't removed in Python 3.0.</sub></p>
<p><sub>2. In fact, Guido has, multiple times, suggested that allowing an LL(1) parser that humans can run in their heads is sufficient reason for the language being statement-based, to the point that other benefits don't even need to be discussed. <a href="http://stupidpythonideas.blogspot.com/2015/01/statements-and-expressions.html" rel="noreferrer">I wrote about this a few years ago</a> if anyone's interested.</sub></p>
<p><sub>3. If you're wondering why so many languages <em>do</em> have a <code>lambda</code> expression despite already having <code>def</code>: In many languages, ranging from C++ to Ruby, function aren't first-class objects that can be passed around, so they had to invent a second thing that is first-class but works like a function. In others, from Smalltalk to Java, functions don't even <em>exist</em>, only methods, so again, they had to invent a second thing that's not a method but works like one. Python has neither of those problems.</sub></p>
<p><sub>4. A few languages, like C# and JavaScript, actually had perfectly working inline function definitions, but added some kind of <code>lambda</code> syntax as pure syntactic sugar, to make it more concise and less boilerplatey. That might actually be worth doing in Python (although every attempt at a good syntax so far has fallen flat), but it wouldn't be the current <code>lambda</code> syntax, which is nearly as verbose as <code>def</code>.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>There is a <em>syntax</em> problem: an assignment is a <em>statement</em>, and the body of a lambda can only have <em>expressions</em>. Python's syntax is designed this way<sup>1</sup>. Check it out at <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">https://docs.python.org/3/reference/grammar.html</a>.</p>
<p>There is also a <em>semantics</em> problem: <em>what does each statement return</em>?</p>
<p>I don't think there is interest in changing this, as lambdas are meant for very simple and short code. Moreover, a statement would allow <em>sequences</em> of statements as well, and that's not desirable for lambdas.</p>
<p>It could be also fixed by selectively allowing certain statements in the lambda body, and specifying the semantics (e.g. an assignment returns <code>None</code>, or returns the assigned value; the latter makes more sense to me). But what's the benefit?</p>
<p>Lambdas and functions are interchangeable. If you really have a use-case for a particular statement in the body of a lambda, you can define a function that executes it, and your specific problem is solved.</p>
<hr/>
<p>Perhaps you can create a syntactic macro to allow that with <a href="http://macropy3.readthedocs.io" rel="nofollow noreferrer">MacroPy3</a> (I'm just guessing, as I'm a fan of the project, but still I haven't had the time to dive in it).</p>
<p>For example MacroPy would allow you to define a macro that transforms <code>f[_ * _]</code> into <code>lambda a, b: a * b</code>, so it should not be impossible to define the syntax for a lambda that calls a function you defined.</p>
<hr/>
<p><sup>1</sup> A good reason to not change it is that it would cripple the syntax, because a lambda can be in places where expressions can be. And statements should not. But that's a very subjective remark of my own.</p>
</div>
<div class="post-text" itemprop="text">
<p>My answer is based on <a href="https://stackoverflow.com/questions/50090868/why-are-assignments-not-allowed-in-pythons-lambda-expressions#comment87197942_50090868">chepner's comment</a> above and doesn't draw from any other credible or official source, however I think that it will be useful.</p>
<p>If assignment was allowed in lambda expressions, then the error of confusing <code>==</code> (equality test) with <code>=</code> (assignment) would have more chances of escaping into the wild.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; # Correct use of equality test
... list(filter(lambda x: x==1, [0, 1, 0.0, 1.0, 0+0j, 1+0j]))
[1, 1.0, (1+0j)]

&gt;&gt;&gt; # Suppose that assignment is used by mistake instead of equality testing
... # and the return value of an assignment expression is always None
... list(filter(lambda x: None, [0, 1, 0.0, 1.0, 0+0j, 1+0j]))
[]

&gt;&gt;&gt; # Suppose that assignment is used by mistake instead of equality testing
... # and the return value of an assignment expression is the assigned value
... list(filter(lambda x: 1, [0, 1, 0.0, 1.0, 0+0j, 1+0j]))
[0, 1, 0.0, 1.0, 0j, (1+0j)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As long as <code>exec()</code> (and <code>eval()</code>) is allowed inside <code>lambda</code>, you can do assignments inside <code>lambda</code>:</p>
<pre><code>q = 3

def assign(var_str, val_str):
    exec("global " + var_str + "; " + 
    var_str + " = " + val_str)

lambda_assign = lambda var_str, val_str: assign(var_str, val_str)

q ## gives: 3

lambda_assign("q", "100")

q ## gives: 100

## what would such expression be a win over the direct:

q = 100

## ? `lambda_assign("q", "100")` will be for sure slower than
##   `q = 100` isn't it?

q_assign = lambda v: assign("q", v)

q_assign("33")

q ## 33

## but do I need lambda for q_assign?

def q_assign(v): assign("q", v) 

## would do it, too, isn't it?
</code></pre>
<p><strong>But since lambda expressions allow only 1 expression to be defined inside their body (at least in Python ...), what would be the point of to allow an assignment inside a lambda? Its net effect would be to assign directly (without using any lambda) <code>q = 100</code>, isn't it?</strong></p>
<p>It would be even faster than doing it over a defined lambda, since you have at least one function lookup and execution less to execute  ...</p>
</div>
<div class="post-text" itemprop="text">
<p>There's not really any deeper reasons, it has nothing to do with lambda or functional language designs, it's just to avoid programmers from mixing = and == operators, which is a very common mistake in other languages</p>
<p>IF there's more to this story, I assume like MAYBE because python bdfl GVR has expressed his unloving sides to lambda and other functional features and attempted(and conceded) to remove them from python 3 altogether <a href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">https://www.artima.com/weblogs/viewpost.jsp?thread=98196</a></p>
<p>At the time of this writing the core devs were seen having a heated discussions recently on whether to include a limited name binding expression assignment, the debate is still on going so perhaps someday we may see it in lambda(unlikely)</p>
<p>As you said it yourself it is definitely not about side effects or purity, they just don't want lambda to be more than a single expression... ... ...</p>
<p>With that said, here's something about multi expressions assignments in lambda, read on if you're interested</p>
<p>It is not at all impossible in python, in fact it was sometimes necessary to capture variable and sidestep late bindings by (ab)using kwargs(keyword arguments)</p>
<p>edit:</p>
<h1>code example</h1>
<pre><code>f = lambda x,a=1: (lambda c = a+2, b = a+1: (lambda e = x,d = c+1: print(a,b,c,d,e))())()

f("w")

# output 1 2 3 4 w

# expression assignment through an object's method call

if let(a=1) .a &gt; 0 and let(b=let.a+1) .b != 1 and let(c=let.b+let.a) .c:
    print(let.a, let.b, let.c)

# output 1 2 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As it stands, Python was designed as a statement-based language. Therefore assignment and other name bindings are statements, and do not have any result.</p>
<p>The Python core developers are currently discussing PEP 572, which would introduce a <a href="https://www.python.org/dev/peps/pep-0572/" rel="nofollow noreferrer">name-binding expression</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think all the fellows answered this already. We use mostly lambdas function when we just want to:</p>
<p>-create some simple functions that do the work perfectly in a specific place(most of the time hidden inside some other big functions
-The lambda function does not have a name 
-Can be used with some other built-ins functions such as map, list and so forth ...</p>
<pre><code>&gt;&gt;&gt; Celsius = [39.2, 36.5, 37.3, 37.8] 
&gt;&gt;&gt; Fahrenheit = map(lambda x: (float(9)/5)*x + 32, Celsius) # mapping the list here  
&gt;&gt;&gt; print Fahrenheit
[102.56, 97.700000000000003, 99.140000000000001, 100.03999999999999]
</code></pre>
<p>Please visit this webpage , this could be useful.Keep it up !!! 
<a href="https://www.python-course.eu/lambda.php" rel="nofollow noreferrer">https://www.python-course.eu/lambda.php</a></p>
</div>
<span class="comment-copy">Because <code>lambdas</code> are <i>limited to only expressions on purpose</i>. If you want all the rest, just use a full function definition. Here is the spec: <a href="https://docs.python.org/3/reference/expressions.html#lambda" rel="nofollow noreferrer">docs.python.org/3/reference/expressions.html#lambda</a></span>
<span class="comment-copy">The rational for making assignments a statement, rather than an expression, is so that a typo like <code>if x = 3:</code> (instead of <code>if x == 3:</code>) becomes a syntax error rather than a subtle runtime semantic error.</span>
<span class="comment-copy">See this explanation: <a href="http://effbot.org/pyfaq/why-can-t-lambda-forms-contain-statements.htm" rel="nofollow noreferrer">effbot.org/pyfaq/why-can-t-lambda-forms-contain-statements.htm</a></span>
<span class="comment-copy">There is a loophole for your particular example, though: <code>lambda x: setattr(c, 'v', 99)</code>.</span>
<span class="comment-copy">None of above comments is useful to the question.  Some might not have even read my question completely.</span>
<span class="comment-copy">I get the impression that you want to tell me something I don't yet understand.  Maybe you could elaborate on how the language would dramatically change or even break if statements were allowed in a lambda expression (which would then, e.g., return <code>None</code>).</span>
<span class="comment-copy">“you can read off the state changes by skimming the first object in each line” — not true.  It would imply that only one object could change state in each line.</span>
<span class="comment-copy">@stefan It is true in idiomatic Python: in the vast majority of statements, only the things to the left of an <code>=</code> get assigned in an assignment statement, or the first object in an expression statement has a single mutating operation. Of course you can violate that by writing an expression full of a dozen <code>setattr</code> calls if you want. Or you can put nine statements on one huge lines with semicolons. Python doesn’t make it <i>impossible</i> to write code that’s hard to follow; it just makes it <i>easy</i> to write code that’s not hard to follow, and encourages doing so through opinionated idioms.</span>
<span class="comment-copy"><code>fileHandle.write(stack.pop())</code> hard to follow?  But two state changes.</span>
<span class="comment-copy">I think your footnote isn't just a subjective remark, it's the whole point of <code>lambda</code> existing in the first place (and not being removed in 3.0).</span>
<span class="comment-copy">“Python's syntax is designed this way” — obviously it is, but why?  What would break otherwise?</span>
<span class="comment-copy">“But what's the benefit?” — Passing a callback that just assigns to an accumulator: <code>foobar(lambda x: acc = x)</code>.</span>
<span class="comment-copy">Could be useful to set a variable when a signal is triggered. I'm using pyQt and i change runtime variables when an user change something in the UI</span>
<span class="comment-copy">PEP-572 wouldn't help here, though, because the name-binding proposed there is <i>local</i>; you won't be able to set global variables.</span>
