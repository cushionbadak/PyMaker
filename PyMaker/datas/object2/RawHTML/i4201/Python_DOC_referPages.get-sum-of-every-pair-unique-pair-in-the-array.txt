<div class="post-text" itemprop="text">
<p>I am doing this array pair sum problem which says:
Given an integer array, output all the unique pairs that sum up to a specific value <code>k</code>.</p>
<p>So the input:</p>
<pre><code>pair_sum([1,3,2,2],4)
</code></pre>
<p>would return 2 pairs:</p>
<pre class="lang-none prettyprint-override"><code>(1,3)
(2,2)
</code></pre>
<p>Seems a pretty simple problem. This is what I my script looks like:</p>
<pre><code>def pair_sum(arr,k):
    count =0
    l = []
    y = []
    for i in range(len(arr)-1):
            l.append((arr[i], arr[i+1]))
            y.append((arr[i-1],arr[i]))
    res = list(set(y+l))
    for i,j in res:
        if i + j == k:
            print (i,j)
            count +=1
    return count
</code></pre>
<p>And I is working fine with few test cases except this one:
<code>pair_sum([1,9,2,8,3,7,4,6,5,5,13,14,11,13,-1],10)</code></p>
<p>My code is returning 5 but it should return 6. I know that this can be manually calculated and then I can check which pair is missing but what if the test case is sufficiently large. I can't check manually for each case.</p>
<p>Can anyone tell what am I doing wrong here because I might have considered almost every possible pair. Also, like what if I don't want to use <code>set</code> here like can there be a more general solution which is not specific to any language. Because how can you get unique pair without using <code>set</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>I can't vouch for the efficiency of this, but:</p>
<pre><code>[(x,y) 
 for (i,x) in enumerate(arr) 
 for (j,y) in enumerate(arr) 
 if i &lt; j and x+y == k]
</code></pre>
<p>Just loop over all pairs, keeping only those whose first element comes before the second so as to avoid duplicates. </p>
</div>
<div class="post-text" itemprop="text">
<p>What I did is I added the elements to the set and took the difference between my sum and the element of list. If difference is in my set then I paired them </p>
<pre><code>def pair_sum(arr,k):
count = 0
seen  = set()
output = set()
for i in arr:
    num = k - i
    if num not in seen:
        seen.add(i)
    else:
         output.add( (num,i) )
return len(output)            
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this by using the <code>pairwise()</code> recipe shown in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools documentation</a> as shown below.</p>
<pre><code>import itertools

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)

def pair_sum(arr, k):
    for pair in (pair for pair in pairwise(arr) if sum(pair) == k):
        print(pair)

pair_sum([1, 3, 2, 2], 4)
print()
pair_sum([1, 2, 3, 1], 3)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>(1, 3)
(2, 2)

(1, 2)
</code></pre>
</div>
<span class="comment-copy">Why don't you just do something like <code>for i in range(len(arr-1)): for j in range(i, len(arr)): if arr[i]+arr[j]==k: print((i,j))</code>?</span>
<span class="comment-copy">It looks like your code is only summing up <i>adjacent</i> numbers?</span>
<span class="comment-copy">@Aran-Fey exactly. This requires a different approach that should take all the numbers into consideration. But than it would take O(n^2). I was looking for O(n)</span>
<span class="comment-copy"><code>itertools.combinations(arr, r=2)</code> will iteratively generate all the possible combinations of pairs of the numbers in <code>arr</code>.</span>
<span class="comment-copy">@martineau It will work but will fail for the following test case <code>[1,2,3,1],3)</code> for which it should output 1 but will give 2 . Anyway I found a way around of doing it</span>
<span class="comment-copy">If you're going to participate here, you need to learn how to properly format/indent the Python code you post.</span>
