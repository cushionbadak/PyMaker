<div class="post-text" itemprop="text">
<p>I have 2 events on the canvas on mouse click.</p>
<p>one on the canvas ...</p>
<pre><code>self.canvas.bind( '&lt;ButtonPress-1&gt;', self.left_mouse_down )
</code></pre>
<p>other on a shape in the canvas ...</p>
<pre><code>self.canvas.tag_bind( self.shape, '&lt;Button-1&gt;', self.on_left_click )
</code></pre>
<p>The problem I am having is that both the events are getting fired. Is there a way to consume the click event on the shape itself (hopefully not using a global variable)?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no mechanism to prevent the handling of the event by the widget, when both the canvas and a canvas item both are bound to an event.</p>
<p>From the canonical documentation:</p>
<blockquote>
<p>If bindings have been created for a canvas window using the bind command, then they are invoked in addition to bindings created for the canvas's items using the bind widget command. The bindings for items will be invoked before any of the bindings for the window as a whole.</p>
</blockquote>
<p>Since the binding for the item is invoked first, one solution is to use a variable that the widget binding can use to know it should ignore the event.</p>
<p>Another solution would be to <em>not</em> bind to the canvas items, and let all handling come from the binding to the widget. Within the bound function you can ask the canvas which item was clicked, and then do the item-specific function if something was clicked on.</p>
<p>Here's an example of the second technique:</p>
<pre><code>import tkinter as tk
import random

def on_click(event):
    current = event.widget.find_withtag("current")
    if current:
        item = current[0]
        color = canvas.itemcget(item, "fill")
        label.configure(text="you clicked on item with id %s (%s)" % (item, color))
    else:
        label.configure(text="You didn't click on an item")

root = tk.Tk()
label = tk.Label(root, anchor="w")
canvas = tk.Canvas(root, background="bisque", width=400, height=400)
label.pack(side="top", fill="x")
canvas.pack(fill="both", expand=True)

for color in ("red", "orange", "yellow", "green", "blue", "violet"):
    x0 = random.randint(50, 350)
    y0 = random.randint(50, 350)
    canvas.create_rectangle(x0, y0, x0+50, y0+50, outline="black", fill=color)
    canvas.bind('&lt;ButtonPress-1&gt;', on_click)

root.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's something that's very similar to the second technique mentioned in @Bryan Oakley's <a href="https://stackoverflow.com/a/50121135/355230">answer</a> except that <em>does</em> bind an event handler to each canvas item, not the the <code>Canvas</code> widget itself. </p>
<p>To detect button clicks on widget itself that aren't on any item within it, a background rectangle item that fills the entire canvas is added first and given a special tag, which allows clicks which aren't on top of any other items on the canvas to be handled as special cases (such as calling a different event handler function). </p>
<pre><code>import tkinter as tk
import random

BKGR_TAG = '_background'
BKGR_COLOR = 'bisque'
RECT_SIZE = 50
WIDTH, HEIGHT = 400, 400

def on_click(event):
    current = event.widget.find_withtag('current')
    if current:
        item = current[0]
        tags = canvas.gettags(item)
        if BKGR_TAG in tags:
            msg = 'You clicked the background'
            # Do other things like call event handler for whole canvas...
        else:
            color = canvas.itemcget(item, 'fill')
            msg = 'You clicked on item with id %s (%s)' % (item, color)
        label.configure(text=msg)

root = tk.Tk()
label = tk.Label(root, anchor='w')
canvas = tk.Canvas(root, width=WIDTH, height=HEIGHT)
label.pack(side='top', fill='x')
canvas.pack(fill='both', expand=True)

# Create background rect same size as canvas.
bkgr = canvas.create_rectangle(0, 0, WIDTH, HEIGHT, width=0, fill=BKGR_COLOR,
                               tags=BKGR_TAG) # Marked with special tag.
canvas.tag_bind(bkgr, '&lt;ButtonPress-1&gt;', on_click)

for color in ('red', 'orange', 'yellow', 'green', 'blue', 'violet'):
    x0 = random.randint(RECT_SIZE, WIDTH-RECT_SIZE)
    y0 = random.randint(RECT_SIZE, HEIGHT-RECT_SIZE)
    id = canvas.create_rectangle(x0, y0, x0+RECT_SIZE, y0+RECT_SIZE,
                                 outline='black', fill=color)
    canvas.tag_bind(id, '&lt;ButtonPress-1&gt;', on_click)

root.mainloop()
</code></pre>
</div>
<span class="comment-copy">tkinter event handler functions are all passed an <code>event</code> argument (per <a href="http://effbot.org/tkinterbook/tkinter-events-and-bindings.htm" rel="nofollow noreferrer">this documentation</a>). Seems like you could you modify yours to check the <code>event.widget</code> attribute of what's passed to see if the proper widget generated the call to it.</span>
<span class="comment-copy">Rather than bind event handlers to each object, why not just bind the event to the canvas and check the <code>CURRENT</code> tag. See an example <a href="http://effbot.org/zone/tkinter-canvas-find-withtag.htm" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">I noticed that the linked documentation says "An easier solution is to prevent Tkinter from propagating the event to other handlers; just return the string <code>“break”</code> from your event handler". That also sounds promising.</span>
<span class="comment-copy">@martineau Yeah, it does seem to consistently process the tag_bind event first.</span>
<span class="comment-copy">@martineau: returning <code>"break"</code> doesn't work for bindings on items within a canvas, because bindings on canvas items don't use the binding tags mechanism.</span>
<span class="comment-copy">This is good to know. BTW, where's the "canonical documentation"? effbot? Source file?</span>
<span class="comment-copy">@martineau: the canonical tk documentation is written for the Tcl language, which translates fairly easily to python. You can find it here: <a href="http://tcl.tk/man/tcl8.5/TkCmd/contents.htm" rel="nofollow noreferrer">tcl.tk/man/tcl8.5/TkCmd/contents.htm</a>. Documentation on how to translated it to tkinter is in the <a href="https://docs.python.org/3/library/tkinter.html#tkinter-life-preserverr" rel="nofollow noreferrer">Tkinter Life Preserver</a> section of the official python documentation.</span>
<span class="comment-copy">Thanks for the links. Your second alternative also works the other way around. i.e. not bind the event handler to the <code>Canvas</code> widget itself as a whole, but instead use <code>canvas.tag_bind()</code> and bind it to each canvas item individually. Seems like that might be better in some circumstances depending on what else is going on.</span>
<span class="comment-copy">@martineau: it won't work the other way around, because if you bind to an object or tag, it will _only _ fire when you click on a canvas object. It won't fire if you click on the canvas as a whole (unless you draw an object that covers the entire canvas as a background).</span>
<span class="comment-copy">Yes, I suppose you're right, especially given that the OP has different handlers for each kind of event (implying that they want to differentiate between the two and have them processed in different ways).</span>
