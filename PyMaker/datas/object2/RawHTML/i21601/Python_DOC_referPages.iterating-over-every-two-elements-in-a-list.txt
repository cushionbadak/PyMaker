<div class="post-text" itemprop="text">
<p>How do I make a <code>for</code> loop or a list comprehension so that every iteration gives me two elements?</p>
<pre><code>l = [1,2,3,4,5,6]

for i,k in ???:
    print str(i), '+', str(k), '=', str(i+k)
</code></pre>
<p>Output:</p>
<pre><code>1+2=3
3+4=7
5+6=11
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need a <strong><code>pairwise()</code></strong> (or <strong><code>grouped()</code></strong>) implementation.</p>
<p>For Python 2:</p>
<pre><code>from itertools import izip

def pairwise(iterable):
    "s -&gt; (s0, s1), (s2, s3), (s4, s5), ..."
    a = iter(iterable)
    return izip(a, a)

for x, y in pairwise(l):
   print "%d + %d = %d" % (x, y, x + y)
</code></pre>
<p>Or, more generally:</p>
<pre><code>from itertools import izip

def grouped(iterable, n):
    "s -&gt; (s0,s1,s2,...sn-1), (sn,sn+1,sn+2,...s2n-1), (s2n,s2n+1,s2n+2,...s3n-1), ..."
    return izip(*[iter(iterable)]*n)

for x, y in grouped(l, 2):
   print "%d + %d = %d" % (x, y, x + y)
</code></pre>
<p>In Python 3, you can replace <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="noreferrer"><code>izip</code></a> with the built-in <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip()</code></a> function, and drop the <code>import</code>.</p>
<p>All credit to <a href="https://stackoverflow.com/users/355230/martineau">martineau</a> for <a href="https://stackoverflow.com/questions/4356329/creating-a-python-dictionary-from-a-line-of-text/4356415#4356415">his answer</a> to <a href="https://stackoverflow.com/q/4356329/78845">my question</a>, I have found this to be very efficient as it only iterates once over the list and does not create any unnecessary lists in the process. </p>
<p><strong>N.B</strong>: This should not be confused with the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer"><strong><code>pairwise</code></strong> recipe</a> in Python's own <a href="https://docs.python.org/3/library/itertools.html" rel="noreferrer"><strong><code>itertools</code></strong> documentation</a>, which yields <code>s -&gt; (s0, s1), (s1, s2), (s2, s3), ...</code>, as pointed out by <a href="https://stackoverflow.com/users/566644/lazyr">@lazyr</a> in the comments.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well you need tuple of 2 elements, so</p>
<pre><code>data = [1,2,3,4,5,6]
for i,k in zip(data[0::2], data[1::2]):
    print str(i), '+', str(k), '=', str(i+k)
</code></pre>
<p>Where:</p>
<ul>
<li><code>data[0::2]</code> means create subset collection of elements that <code>(index % 2 == 0)</code></li>
<li><code>zip(x,y)</code> creates a tuple collection from x and y collections same index elements.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; l = [1,2,3,4,5,6]

&gt;&gt;&gt; zip(l,l[1:])
[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]

&gt;&gt;&gt; zip(l,l[1:])[::2]
[(1, 2), (3, 4), (5, 6)]

&gt;&gt;&gt; [a+b for a,b in zip(l,l[1:])[::2]]
[3, 7, 11]

&gt;&gt;&gt; ["%d + %d = %d" % (a,b,a+b) for a,b in zip(l,l[1:])[::2]]
['1 + 2 = 3', '3 + 4 = 7', '5 + 6 = 11']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple solution.</p>
<pre>
l = [1, 2, 3, 4, 5, 6]

for i in range(0, len(l), 2):
    print str(l[i]), '+', str(l[i + 1]), '=', str(l[i] + l[i + 1])
</pre>
</div>
<div class="post-text" itemprop="text">
<p>While all the answers using <code>zip</code> are correct, I find that implementing the functionality yourself leads to more readable code:</p>
<pre><code>def pairwise(it):
    it = iter(it)
    while True:
        yield next(it), next(it)
</code></pre>
<p>The <code>it = iter(it)</code> part ensures that <code>it</code> is actually an iterator, not just an iterable. If <code>it</code> already is an iterator, this line is a no-op.</p>
<p>Usage:</p>
<pre><code>for a, b in pairwise([0, 1, 2, 3, 4, 5]):
    print(a + b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Apologies for being late.I hope this will be even more elegant way of doing it.</p>
<pre><code>a = [1,2,3,4,5,6]
zip(a[::2], a[1::2])

[(1, 2), (3, 4), (5, 6)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case you're interested in the performance, I did a small benchmark to compare the performance of the solutions and I included a function from one of my packages: <a href="http://iteration-utilities.readthedocs.io/en/latest/generated/grouper.html#iteration_utilities.grouper" rel="noreferrer"><code>iteration_utilities.grouper</code></a></p>
<pre><code>def Johnsyweb(l):
    def pairwise(iterable):
        "s -&gt; (s0, s1), (s2, s3), (s4, s5), ..."
        a = iter(iterable)
        return zip(a, a)

    for x, y in pairwise(l):
        pass

def Margus(data):
    for i, k in zip(data[0::2], data[1::2]):
        pass

def pyanon(l):
    list(zip(l,l[1:]))[::2]

def taskinoor(l):
    for i in range(0, len(l), 2):
        l[i], l[i+1]

def mic_e(it):
    def pairwise(it):
        it = iter(it)
        while True:
            try:
                yield next(it), next(it)
            except StopIteration:
                return

    for a, b in pairwise(it):
        pass

def MSeifert(it):
    for item1, item2 in grouper(it, 2):
        pass

from iteration_utilities import grouper
from simple_benchmark import benchmark_random_list

b = benchmark_random_list(
    [Johnsyweb, Margus, pyanon, taskinoor, mic_e, MSeifert],
    sizes=[2**i for i in range(1, 20)])

b.plot_both(relative_to=MSeifert)
</code></pre>
<p><a href="https://i.stack.imgur.com/jRoSU.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/jRoSU.png"/></a></p>
<p>Windows 10 64 bit Anaconda Python 3.6</p>
<p>So if you want the fastest solution without external dependencies you probably should just use the approach given by Johnysweb (at the time of writing it's the most upvoted and accepted answer).</p>
<p>If you don't mind the additional dependency then the <code>grouper</code> from <code>iteration_utilities</code> will probably be a bit faster.</p>
<h2>Additional thoughts</h2>
<p>Some of the approaches have some restrictions, that haven't been discussed here.</p>
<p>For example a few solutions only work for sequences (that is lists, strings, etc.), for example Margus/pyanon/taskinoor solutions which uses indexing while other solutions work on any iterable (that is sequences <strong>and</strong> generators, iterators) like Johnysweb/mic_e/my solutions.</p>
<p>Then Johnysweb also provided a solution that works for other sizes than 2 while the other answers don't (okay, the <code>iteration_utilities.grouper</code> also allows setting the number of elements to "group").</p>
<p>Then there is also the question about what should happen if there is an odd number of elements in the list. Should the remaining item be dismissed? Should the list be padded to make it even sized? Should the remaining item be returned as single? The other answer don't address this point directly, however if I haven't overlooked anything they all follow the approach that the remaining item should be dismissed (except for taskinoors answer - that will actually raise an Exception).</p>
<p>With <code>grouper</code> you can decide what you want to do:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import grouper

&gt;&gt;&gt; list(grouper([1, 2, 3], 2))  # as single
[(1, 2), (3,)]

&gt;&gt;&gt; list(grouper([1, 2, 3], 2, truncate=True))  # ignored
[(1, 2)]

&gt;&gt;&gt; list(grouper([1, 2, 3], 2, fillvalue=None))  # padded
[(1, 2), (3, None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for (i, k) in zip(l[::2], l[1::2]):
    print i, "+", k, "=", i+k
</code></pre>
<p><code>zip(*iterable)</code> returns a tuple with the next element of each iterable.</p>
<p><code>l[::2]</code> returns the 1st, the 3rd, the 5th, etc. element of the list: the first colon indicates that the slice starts at the beginning because there's no number behind it, the second colon is only needed if you want a 'step in the slice' (in this case 2).</p>
<p><code>l[1::2]</code> does the same thing but starts in the second element of the lists so it returns the 2nd, the 4th, 6th, etc. element of the <strong>original</strong> list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>zip</code> and <code>iter</code> commands together:</p>
<p>I find this solution using <code>iter</code> to be quite elegant:</p>
<pre><code>it = iter(l)
list(zip(it, it))
# [(1, 2), (3, 4), (5, 6)]
</code></pre>
<p>Which I found in the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer" title="Python 3 zip documentation">Python 3 zip documentation</a>.</p>
<pre><code>it = iter(l)
print(*(f'{u} + {v} = {u+v}' for u, v in zip(it, it)), sep='\n')

# 1 + 2 = 3
# 3 + 4 = 7
# 5 + 6 = 11
</code></pre>
<hr/>
<p>To generalise to <code>N</code> elements at a time:</p>
<pre><code>N = 2
list(zip(*([iter(l)] * N)))
# [(1, 2), (3, 4), (5, 6)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For anyone it might help, here is a solution to a similar problem but with overlapping pairs (instead of mutually exclusive pairs).</p>
<p>From the Python <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">itertools documentation</a>:</p>
<pre><code>from itertools import izip

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b)
</code></pre>
<p>Or, more generally:</p>
<pre><code>from itertools import izip

def groupwise(iterable, n=2):
    "s -&gt; (s0,s1,...,sn-1), (s1,s2,...,sn), (s2,s3,...,sn+1), ..."
    t = tee(iterable, n)
    for i in range(1, n):
        for j in range(0, i):
            next(t[i], None)
    return izip(*t)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use <a href="http://more-itertools.readthedocs.io/en/latest/api.html#grouping" rel="nofollow noreferrer">more_itertools</a> package.</p>
<pre><code>import more_itertools

lst = range(1, 7)
for i, j in more_itertools.chunked(lst, 2):
    print(f'{i} + {j} = {i+j}')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I need to divide a list by a number and fixed like this. </p>
<pre><code>l = [1,2,3,4,5,6]

def divideByN(data, n):
        return [data[i*n : (i+1)*n] for i in range(len(data)//n)]  

&gt;&gt;&gt; print(divideByN(l,2))
[[1, 2], [3, 4], [5, 6]]

&gt;&gt;&gt; print(divideByN(l,3))
[[1, 2, 3], [4, 5, 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The title of this question is misleading, you seem to be looking for consecutive pairs, but if you want to iterate over the set of all possible pairs than this will work :</p>
<pre><code>for i,v in enumerate(items[:-1]):
        for u in items[i+1:]:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using typing so you can verify data using <a href="http://mypy-lang.org/" rel="nofollow noreferrer">mypy</a> static analysis tool:</p>
<pre><code>from typing import Iterator, Any, Iterable, TypeVar, Tuple

T_ = TypeVar('T_')
Pairs_Iter = Iterator[Tuple[T_, T_]]

def legs(iterable: Iterator[T_]) -&gt; Pairs_Iter:
    begin = next(iterable)
    for end in iterable:
        yield begin, end
        begin = end
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simplistic approach:</p>
<pre><code>[(a[i],a[i+1]) for i in range(0,len(a),2)]
</code></pre>
<p>this is useful if your array is a and you want to iterate on it by pairs. 
To iterate on triplets or more just change the "range" step command, for example:</p>
<pre><code>[(a[i],a[i+1],a[i+2]) for i in range(0,len(a),3)]
</code></pre>
<p>(you have to deal with excess values if your array length and the step do not fit) </p>
</div>
<div class="post-text" itemprop="text">
<p>Thought that this is a good place to share my generalization of this for n&gt;2, which is just a sliding window over an iterable:</p>
<pre><code>def sliding_window(iterable, n):
    its = [ itertools.islice(iter, i, None) 
            for i, iter
            in enumerate(itertools.tee(iterable, n)) ]                               

    return itertools.izip(*its)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here we can have <code>alt_elem</code> method which can fit in your for loop.</p>
<pre><code>def alt_elem(list, index=2):
    for i, elem in enumerate(list, start=1):
        if not i % index:
           yield tuple(list[i-index:i])


a = range(10)
for index in [2, 3, 4]:
    print("With index: {0}".format(index))
    for i in alt_elem(a, index):
       print(i)
</code></pre>
<p>Output:</p>
<pre><code>With index: 2
(0, 1)
(2, 3)
(4, 5)
(6, 7)
(8, 9)
With index: 3
(0, 1, 2)
(3, 4, 5)
(6, 7, 8)
With index: 4
(0, 1, 2, 3)
(4, 5, 6, 7)
</code></pre>
<p>Note: Above solution might not be efficient considering operations performed in func.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a_list = [1,2,3,4,5,6]
empty_list = [] 
for i in range(0,len(a_list),2):
   empty_list.append(a_list[i]+a_list[i+1])   
print(empty_list)
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2631189/python-every-other-element-idiom">Python "Every Other Element" Idiom</a></span>
<span class="comment-copy">I think so, but @Johnsyweb solution already look better than the answer of "Every Other Element".</span>
<span class="comment-copy">Not to be confused with the pairwise function suggested in the <a href="http://docs.python.org/library/itertools.html" rel="nofollow noreferrer">itertools</a> recipes section, which yields <code>s -&gt; (s0,s1), (s1,s2), (s2, s3), ...</code></span>
<span class="comment-copy">It does a different thing.  Your version only yields half the number of pairs compared to the <code>itertools</code> recipe function with the same name.  Of course yours is faster...</span>
<span class="comment-copy">Huh? Your function and the function I referred to do different things, and that was the point of my comment.</span>
<span class="comment-copy">BE CAREFUL!  Using these functions puts you at risk of not iterating over the last elements of an iterable.  Example: list(grouped([1,2,3],2)) &gt;&gt;&gt; [(1, 2)] .. when you'd expect [(1,2),(3,)]</span>
<span class="comment-copy">@Erik49: In the case specified in the question, it wouldn't make sense to have an 'incomplete' tuple. If you wanted to include an incomplete tuple, you could use <code>izip_longest()</code> instead of <code>izip()</code>. E.g: <code>list(izip_longest(*[iter([1, 2, 3])]*2, fillvalue=0))</code> --&gt; <code>[(1, 2), (3, 0)]</code>. Hope this helps.</span>
<span class="comment-copy">This can also be extended in case more  than two elements are required. For e.g. <code>for i, j, k in zip(data[0::3], data[1::3], data[2::3]):</code></span>
<span class="comment-copy">So much cleaner than pulling in an import and defining a function!</span>
<span class="comment-copy">@kmarsh: But this only works on sequences, the function works on any iterable; and this uses O(N) extra space, the function doesn't; on the other hand, this is generally faster. There are good reasons to pick one or the other; being afraid of <code>import</code> is not one of them.</span>
<span class="comment-copy">This is not working on Python-3.6.0 but still working on Python-2.7.10</span>
<span class="comment-copy">@HamidRohani <code>zip</code> returns a <code>zip</code> object in Python 3, which is not subscriptable. It needs to be converted to a sequence (<code>list</code>, <code>tuple</code>, etc.) first, but <i>"not working"</i> is a bit of a stretch.</span>
<span class="comment-copy">what if your list is not even, and you want to just show the last number as it is?</span>
<span class="comment-copy">@HansdeJong didn't get you. Please explain a little bit more.</span>
<span class="comment-copy">Thanks. I figured already out how to do it. Problem was if you had a list that had not even amount of numbers in it, it would get an index error. Solved it with a try: except:</span>
<span class="comment-copy">Or <code>((l[i], l[i+1])for i in range(0, len(l), 2))</code> for a generator, can be easily modified for longer tuples.</span>
<span class="comment-copy">This solution allows to generalization to size of tuples &gt; 2</span>
<span class="comment-copy">Very elegant and generalization ready solution.</span>
<span class="comment-copy">This solution also works if <code>it</code> is only an iterator and not an iterable. The other solutions seem to rely on the possibility to create two independent iterators for the sequence.</span>
<span class="comment-copy">I found this approach at <a href="https://stackoverflow.com/a/16815056/2480481">stackoverflow.com/a/16815056/2480481</a> before see this answer. Is cleaner, easier than dealing with zip().</span>
<span class="comment-copy">I like that it allows to avoid tripling memory usage as the accepted answer.</span>
<span class="comment-copy">This answer was already given by Margus two years ago. <a href="http://stackoverflow.com/questions/5389507/iterating-over-every-two-elements-in-a-list#answer-5389578" title="iterating over every two elements in a list%23answer 5389578">stackoverflow.com/questions/5389507/…</a></span>
<span class="comment-copy">1 for explaining how <code>[number::number]</code> syntax works. helpful for who doesn't use python often</span>
