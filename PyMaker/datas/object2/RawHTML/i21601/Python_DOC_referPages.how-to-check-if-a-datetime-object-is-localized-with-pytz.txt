<div class="post-text" itemprop="text">
<p>I want to store a datetime object with a localized UTC timezone. The method that stores the datetime object can be given a non-localized datetime (naive) object or an object that already has been localized. How do I determine if localization is needed?</p>
<p>Code with missing if condition:</p>
<pre><code>class MyClass:
  def set_date(self, d):
    # what do i check here?
    # if(d.tzinfo):
      self.date = d.astimezone(pytz.utc)
    # else:
      self.date = pytz.utc.localize(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How do I determine if localization is needed?</p>
</blockquote>
<p>From <a href="https://docs.python.org/3/library/datetime.html#datetime.timezone" rel="noreferrer"><code>datetime</code> docs</a>:</p>
<ul>
<li><p>a datetime object <code>d</code> is aware iff:</p>
<pre><code>d.tzinfo is not None and d.tzinfo.utcoffset(d) is not None
</code></pre></li>
<li><p><code>d</code> is naive iff:</p>
<pre><code>d.tzinfo is None or d.tzinfo.utcoffset(d) is None
</code></pre></li>
</ul>
<p>Though if <code>d</code> is a datetime object representing time in UTC timezone then you could use in both cases:</p>
<pre><code>self.date = d.replace(tzinfo=pytz.utc)
</code></pre>
<p>It works regardless <code>d</code> is timezone-aware or naive.</p>
<p>Note: <a href="https://stackoverflow.com/a/27592919/4279">don't use <code>datetime.replace()</code> method with a timezone with a non-fixed utc offset</a> (it is ok to use it with UTC timezone but otherwise you should use <code>tz.localize()</code> method).</p>
</div>
<div class="post-text" itemprop="text">
<p>if you want to check if a datetime object 'd' is localized, check the d.tzinfo, if it is None, no localization.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a more complete function to convert or coerce a timestamp obj to utc. If it reaches the exception this means the timestamp is not localized. Since it's good practice to always work in UTC within the code, this function is very useful at the entry level from persistence. </p>
<pre><code>def convert_or_coerce_timestamp_to_utc(timeobj):
        out = timeobj
        try:
            out = timeobj.astimezone(pytz.utc) # aware object can be in any timezone
        except (ValueError,TypeError) as exc: # naive
            out = timeobj.replace(tzinfo=pytz.utc)
        return out
</code></pre>
<p>The small addition from the 'try catch' in the answer by J.F. Sebastian is the additional catch condition, without which not all naive cases will be caught by the function. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a function wrapping up the top answer.</p>
<pre><code>def tz_aware(dt):
    return dt.tzinfo is not None and dt.tzinfo.utcoffset(dt) is not None
</code></pre>
</div>
<span class="comment-copy">I know that's what the docs say, but in what scenario can you have a tzinfo object that is not really specifying a timezone and thus <code>d.tzinfo.utcoffset(d) is None</code> is needed?</span>
<span class="comment-copy">@Geekfish: no idea. All sane implementations should either return non-None value or raise an exception.</span>
<span class="comment-copy">Since Python 3.6 <code>astimezone</code> can be called on naive instances and it assumes system timezone.</span>
<span class="comment-copy">@Mitar: yes. It is unfortunate.</span>
<span class="comment-copy">But what if it has a tzinfo object that is not from pytz?</span>
<span class="comment-copy">you want to force the localization to be in pytz format ?</span>
<span class="comment-copy">note: it is not enough to check if <code>d.tzinfo is not None</code>. Also, <a href="http://stackoverflow.com/a/27596917/4279"><code>d.tzinfo.utcoffset(d)</code> should not be <code>None</code> for <code>d</code> to be called an aware datetime object</a>.</span>
<span class="comment-copy">This answer it is not true, here is the definition of when it is naive or aware , from datetime official docs : "An object of type time or datetime may be naive or aware. A datetime object d is aware if d.tzinfo is not None and d.tzinfo.utcoffset(d) does not return None. If d.tzinfo is None, or if d.tzinfo is not None but d.tzinfo.utcoffset(d) returns None, d is naive. A time object t is aware if t.tzinfo is not None and t.tzinfo.utcoffset(None) does not return None. Otherwise, t is naive."</span>
<span class="comment-copy">Why do you catch <code>TypeError</code> as well? I don't see that mentioned in the other answers.</span>
<span class="comment-copy">As I wrote, without the additional catch not all naive cases will be caught. This is simply an addition based on direct experience. I had originally worked with the first catch alone, and some naive timestamps got through  :)</span>
<span class="comment-copy">The answer could be improved if you show a specific example of a naive object that throws TypeError here.</span>
<span class="comment-copy">And return <code>None</code> the rest of the time?</span>
<span class="comment-copy">It's sufficient to just say <code>return dt.tzinfo is not None and dt.tzinfo.utcoffset(dt) is not None</code></span>
