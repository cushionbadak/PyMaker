<div class="post-text" itemprop="text">
<p>In Python, it's possible to extend a list in a lazy way by using <code>itertools.chain</code>:</p>
<pre><code>L = itertools.chain(L1, L2)
</code></pre>
<p>Is there a lazy map "gluing" operator?  I.e.,</p>
<pre><code>M = glue(M1, M2)
</code></pre>
<p>where</p>
<pre><code>M['blah']
</code></pre>
<p>returns</p>
<pre><code>M1['blah'] if 'blah' in M1 else M2['blah']
</code></pre>
<p>and, <code>M</code> has appropriate generators for <code>keys()</code> and <code>values()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.3 added <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow">collections.ChainMap</a> that does exactly that.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's straightforward to build a class to represent lazy evaluations against a list of maps, and tailor the behavior to your application.  For example:</p>
<pre><code>from UserDict import DictMixin

class Map(object, DictMixin):
    def __init__(self, *maps):
        self.maps = maps
    def __getitem__(self, key):
        for m in self.maps:
            if key in m:
                return m[key]
    def keys(self):
        return list(self.iterkeys())
    def iterkeys(self):
        return (k for m in self.maps for k in m.iterkeys())
    def values(self):
        return list(self.itervalues())
    def itervalues(self):
        return (v for m in self.maps for v in m.itervalues())

def glue(*maps):
    return Map(*maps)

M1 = {'blah': 1}
M2 = {'duh': 2}

M = glue(M1, M2)
print M['blah']
print M['duh']
print list(M.keys())
print list(M.values())
</code></pre>
<p>Output:</p>
<pre><code>1
2
['blah', 'duh']
[1, 2]
</code></pre>
</div>
<span class="comment-copy">Add collections.ChainMap as an answer. An off-the-shelf class is better than custom code.</span>
<span class="comment-copy">There is a typo in the module name (should be collection<b>s</b>), can you please fix it? I can't do it myself, because the edit would be too short and I don't yet have 2000+ reputation. Thanks!</span>
<span class="comment-copy">@plamut: done, thanks</span>
<span class="comment-copy">Do you need to explicitly mention <code>object</code> there? Doesn't <code>DictMixin</code> already inherit <code>object</code>?</span>
<span class="comment-copy">At least through Python 2.7 UserDict.DictMixin is an old-style class.</span>
<span class="comment-copy">I was unaware of that. Thank you.</span>
<span class="comment-copy">Perhaps you should do a deep copy of the dictionaries. Your code will do unexpected things with <code>M1['duh'] = 3; print M['duh']</code></span>
