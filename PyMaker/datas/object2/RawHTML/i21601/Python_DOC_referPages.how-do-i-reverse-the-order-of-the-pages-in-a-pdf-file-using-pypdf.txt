<div class="post-text" itemprop="text">
<p>I have a pdf file "myFile.pdf". I would like to reverse the order of its pages using <a href="http://pybrary.net/pyPdf/" rel="nofollow">pyPdf</a>. How?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from pyPdf import PdfFileWriter, PdfFileReader
output_pdf = PdfFileWriter()

with open(r'input.pdf', 'rb') as readfile:
    input_pdf = PdfFileReader(readfile)
    total_pages = input_pdf.getNumPages()
    for page in xrange(total_pages - 1, -1, -1):
        output_pdf.addPage(input_pdf.getPage(page))
    with open(r'output.pdf', "wb") as writefile:
        output_pdf.write(writefile)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for sharing suggestions. I used them and edited a bit to make the interface more graphical when selecting and saving a file. New to all of this and what I added might not be efficient or clean, but it worked for me and thought to share.</p>
<pre><code>from PyPDF2 import PdfFileWriter, PdfFileReader
import tkinter as tk
from tkinter import filedialog
import ntpath
import os


output_pdf = PdfFileWriter()

# grab the location of the file path sent
def path_leaf(path):
    head, tail = ntpath.split(path)
    return head

# graphical file selection
def grab_file_path():
    # use dialog to select file
    file_dialog_window = tk.Tk()
    file_dialog_window.withdraw()  # hides the tk.TK() window
    # use dialog to select file
    grabbed_file_path = filedialog.askopenfilename()
    return grabbed_file_path


# file to be reversed
filePath = grab_file_path()

# open file and read
with open(filePath, 'rb') as readfile:
    input_pdf = PdfFileReader(readfile)

    # reverse order one page at time
    for page in reversed(input_pdf.pages):
        output_pdf.addPage(page)

    # graphical way to get where to select file starting at input file location
    dirOfFileToBeSaved = path_leaf(filePath)
    locationOfFileToBeSaved=filedialog.asksaveasfilename(initialdir=dirOfFileToBeSaved, initialfile='name of reversed file.pdf',title="Select or type file name and location", filetypes=[("pdf files", "*.pdf")])
    # write the file created
    with open(locationOfFileToBeSaved, "wb") as writefile:
        output_pdf.write(writefile)

# open the file when done
os.startfile(locationOfFileToBeSaved)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of (long before) January 2019, <a href="http://pybrary.net/pyPdf/" rel="nofollow noreferrer">pyPdf</a> is no longer updated, and upon testing is not compatible with (at least) Python 3.6, and likely at all with Python 3:</p>
<pre><code>In [1]: import pyPdf
---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
&lt;ipython-input-1-bba5a42e9137&gt; in &lt;module&gt;
----&gt; 1 import pyPdf

c:\temp\envminecart\lib\site-packages\pyPdf\__init__.py in &lt;module&gt;
----&gt; 1 from pdf import PdfFileReader, PdfFileWriter
      2 __all__ = ["pdf"]

ModuleNotFoundError: No module named 'pdf'
</code></pre>
<p>(Moving the <code>__all__</code> assignment above the <code>import</code> fixes this specific problem, but other <code>SyntaxError</code>s due to Python 2 syntax then pop up.)</p>
<p>Fortunately, its successor project, <a href="http://mstamy2.github.io/PyPDF2/" rel="nofollow noreferrer">PyPDF2</a>, works cleanly on Python 3.6 (at least). It appears the core user-facing API was intentionally maintained to be compatible with pyPdf, so <a href="https://stackoverflow.com/a/5425501">nosklo's answer</a> can be used in modern Python after a <code>pip install PyPDF2</code> just by changing to <code>PyPDF2</code> in the <code>import</code> statement, and switching <code>xrange</code> to <code>range</code>:</p>
<pre><code>from PyPDF2 import PdfFileWriter, PdfFileReader
output_pdf = PdfFileWriter()

with open(r'input.pdf', 'rb') as readfile:
    input_pdf = PdfFileReader(readfile)
    total_pages = input_pdf.getNumPages()
    for page in range(total_pages - 1, -1, -1):
        output_pdf.addPage(input_pdf.getPage(page))
    with open(r'output.pdf', "wb") as writefile:
        output_pdf.write(writefile)
</code></pre>
<p>I would also recommend the more Pythonic approach of just iterating over the pages directly using <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow noreferrer"><code>reversed</code></a>:</p>
<pre><code>from PyPDF2 import PdfFileWriter, PdfFileReader

output_pdf = PdfFileWriter()

with open('input.pdf', 'rb') as readfile:
    input_pdf = PdfFileReader(readfile)

    for page in reversed(input_pdf.pages):
        output_pdf.addPage(page)

    with open('output.pdf', "wb") as writefile:
        output_pdf.write(writefile)
</code></pre>
<p>I don't know if this <code>.pages</code> collection was available in the original <code>pyPdf</code>, but arguably it doesn't really matter much at this point.</p>
</div>
<span class="comment-copy">@Tom: What I've tried so far was kind of similar to nosklo's answer. We both had the same bug (I/O operation on closed file). The reason is of course that we both used <code>output_pdf</code> after closing it. I've just fixed his solution.</span>
<span class="comment-copy">Thanks for this, it helped me to identify my error causing I/O Operation on a closed file: You have to keep the PdfFileReader open untill PdfFileWriter is done writing.  (Counter-intuitively, to me).  Presumably this is because the writer doesn't actually seek the data from the reader's pages until it needs to, for improved performance.</span>
