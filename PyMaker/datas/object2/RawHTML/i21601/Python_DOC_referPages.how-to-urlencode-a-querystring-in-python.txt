<div class="post-text" itemprop="text">
<p>I am trying to urlencode this string before I submit. </p>
<pre><code>queryString = 'eventName=' + evt.fields["eventName"] + '&amp;' + 'eventDescription=' + evt.fields["eventDescription"]; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to pass your parameters into <a href="http://docs.python.org/2/library/urllib.html#urllib.urlencode" rel="noreferrer"><code>urlencode()</code></a> as either a mapping (dict), or a sequence of 2-tuples, like:</p>
<pre><code>&gt;&gt;&gt; import urllib
&gt;&gt;&gt; f = { 'eventName' : 'myEvent', 'eventDescription' : 'cool event'}
&gt;&gt;&gt; urllib.urlencode(f)
'eventName=myEvent&amp;eventDescription=cool+event'
</code></pre>
<p><strong>Python 3 or above</strong></p>
<p>Use:</p>
<pre><code>&gt;&gt;&gt; urllib.parse.urlencode(f)
eventName=myEvent&amp;eventDescription=cool+event
</code></pre>
<p>Note that this does <em>not</em> do url encoding in the commonly used sense (look at the output). For that use <code>urllib.parse.quote_plus</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Python 2</h1>
<p>What you're looking for is <a href="https://docs.python.org/2/library/urllib.html#urllib.quote_plus" rel="noreferrer" title="urllib.quote_plus"><code>urllib.quote_plus</code></a>:</p>
<pre><code>&gt;&gt;&gt; urllib.quote_plus('string_of_characters_like_these:$#@=?%^Q^$')
'string_of_characters_like_these%3A%24%23%40%3D%3F%25%5EQ%5E%24'
</code></pre>
<h1>Python 3</h1>
<p>In Python 3, the <code>urllib</code> package has been broken into smaller components. You'll use <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote_plus" rel="noreferrer"><code>urllib.parse.quote_plus</code></a> (note the <code>parse</code> child module)</p>
<pre><code>import urllib.parse
urllib.parse.quote_plus(...)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Context</h3>
<ul>
<li>Python (version 2.7.2 )</li>
</ul>
<h3>Problem</h3>
<ul>
<li>You want to generate a urlencoded query string.</li>
<li>You have a dictionary or object containing the name-value pairs.</li>
<li>You want to be able to control the output ordering of the name-value pairs.</li>
</ul>
<h3>Solution</h3>
<ul>
<li>urllib.urlencode</li>
<li>urllib.quote_plus</li>
</ul>
<h3>Pitfalls</h3>
<ul>
<li>dictionary output arbitrary ordering of name-value pairs

<ul>
<li>(see also: <a href="https://stackoverflow.com/questions/526125">Why is python ordering my dictionary like so?</a>)</li>
<li>(see also: <a href="https://stackoverflow.com/questions/15479928">Why is the order in dictionaries and sets arbitrary?</a>)</li>
</ul></li>
<li>handling cases when you <em>DO NOT</em> care about the ordering of the name-value pairs</li>
<li>handling cases when you <em>DO</em> care about the ordering of the name-value pairs</li>
<li>handling cases where a single name needs to appear more than once in the set of all name-value pairs</li>
</ul>
<h3>Example</h3>
<p>The following is a complete solution, including how to deal with some pitfalls.</p>
<pre><code>### ********************
## init python (version 2.7.2 )
import urllib

### ********************
## first setup a dictionary of name-value pairs
dict_name_value_pairs = {
  "bravo"   : "True != False",
  "alpha"   : "http://www.example.com",
  "charlie" : "hello world",
  "delta"   : "1234567 !@#$%^&amp;*",
  "echo"    : "user@example.com",
  }

### ********************
## setup an exact ordering for the name-value pairs
ary_ordered_names = []
ary_ordered_names.append('alpha')
ary_ordered_names.append('bravo')
ary_ordered_names.append('charlie')
ary_ordered_names.append('delta')
ary_ordered_names.append('echo')

### ********************
## show the output results
if('NO we DO NOT care about the ordering of name-value pairs'):
  queryString  = urllib.urlencode(dict_name_value_pairs)
  print queryString 
  """
  echo=user%40example.com&amp;bravo=True+%21%3D+False&amp;delta=1234567+%21%40%23%24%25%5E%26%2A&amp;charlie=hello+world&amp;alpha=http%3A%2F%2Fwww.example.com
  """

if('YES we DO care about the ordering of name-value pairs'):
  queryString  = "&amp;".join( [ item+'='+urllib.quote_plus(dict_name_value_pairs[item]) for item in ary_ordered_names ] )
  print queryString
  """
  alpha=http%3A%2F%2Fwww.example.com&amp;bravo=True+%21%3D+False&amp;charlie=hello+world&amp;delta=1234567+%21%40%23%24%25%5E%26%2A&amp;echo=user%40example.com
  """ 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try <a href="http://docs.python-requests.org/en/latest/" rel="noreferrer">requests</a> instead of urllib and you don't need to bother with urlencode!</p>
<pre><code>import requests
requests.get('http://youraddress.com', params=evt.fields)
</code></pre>
<p><strong>EDIT:</strong></p>
<p>If you need <strong>ordered name-value pairs</strong> or multiple values for a name then set params like so:</p>
<pre><code>params=[('name1','value11'), ('name1','value12'), ('name2','value21'), ...]
</code></pre>
<p>instead of using a dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3:</p>
<p><a href="http://docs.python.org/py3k/library/urllib.parse.html?highlight=urllib#urllib.parse.quote_plus">urllib.parse.quote_plus(string, safe='', encoding=None, errors=None)</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Note that the urllib.urlencode does not always do the trick. The problem is that some services care about the order of arguments, which gets lost when you create the dictionary. For such cases, urllib.quote_plus is better, as Ricky suggested.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>urllib.pathname2url(stringToURLEncode)
</code></pre>
<p><code>urlencode</code> won't work because it only works on dictionaries. <code>quote_plus</code> didn't produce the correct output.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, this worked with me</p>
<pre class="lang-py prettyprint-override"><code>import urllib

urllib.parse.quote(query)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>for future references (ex: for python3)</p>
<pre><code>&gt;&gt;&gt; import urllib.request as req
&gt;&gt;&gt; query = 'eventName=theEvent&amp;eventDescription=testDesc'
&gt;&gt;&gt; req.pathname2url(query)
&gt;&gt;&gt; 'eventName%3DtheEvent%26eventDescription%3DtestDesc'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>If the urllib.parse.urlencode( ) is giving you errors , then Try the urllib3 module .</h3>
<p>The <strong>syntax</strong> is as follows : </p>
<pre><code>import urllib3
urllib3.request.urlencode({"user" : "john" }) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For use in scripts/programs which need to support both python 2 and 3, the six module provides quote and urlencode functions:</p>
<pre><code>&gt;&gt;&gt; from six.moves.urllib.parse import urlencode, quote
&gt;&gt;&gt; data = {'some': 'query', 'for': 'encoding'}
&gt;&gt;&gt; urlencode(data)
'some=query&amp;for=encoding'
&gt;&gt;&gt; url = '/some/url/with spaces and %;!&lt;&gt;&amp;'
&gt;&gt;&gt; quote(url)
'/some/url/with%20spaces%20and%20%25%3B%21%3C%3E%26'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another thing that might not have been mentioned already is that <code>urllib.urlencode()</code> will encode empty values in the dictionary as the string <code>None</code> instead of having that parameter as absent. I don't know if this is typically desired or not, but does not fit my use case, hence I have to use <code>quote_plus</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/urllib.html#urllib.urlencode" rel="nofollow">urllib.urlencode()</a></p>
</div>
<span class="comment-copy">Since Python 3 the module is called <code>urllib.parse</code>.</span>
<span class="comment-copy">"Note that the urllib.urlencode does not always do the trick. The problem is that some services care about the order of arguments, which gets lost when you create the dictionary. For such cases, urllib.quote_plus is better, as Ricky suggested."</span>
<span class="comment-copy">Technically, that's a bug in the services, isn't it?</span>
<span class="comment-copy">For python 3, the import needs to be: <code>import urllib.parse</code> and the function call is <code>urllib.parse.urlencode(...)</code></span>
<span class="comment-copy">and how would one do this if you just want to make a string URL safe, without building a full query argument string?</span>
<span class="comment-copy">urllib.parse.quote_plus in python3</span>
<span class="comment-copy">quote_plus? I can only guess this nonsensical name means something to someone?</span>
<span class="comment-copy">Thanks! In my case however I need to put: <code>import urllib.parse ... urllib.parse.quote_plus(query)</code></span>
<span class="comment-copy">@cbare <code>Like quote(), but also replaces spaces by plus signs, as required for quoting HTML form values when building up a query string to go into a URL. Plus signs in the original string are escaped unless they are included in safe. It also does not have safe default to '/'.</code> as per the link.</span>
<span class="comment-copy">This works great, but I couldn't access some online services (REST) until I added this parameter   safe=';/?:@&amp;=+$,'</span>
<span class="comment-copy">This does not address the issue of ordering the name value pairs, also this requires the permission to install external libraries which might not be doable for the project.</span>
<span class="comment-copy">I posted the minimal code that would work for the OP. The OP did not request ordered pairs however it is also doable, see my update.</span>
<span class="comment-copy">@dreftymac: this does address ordering (although it was not part of the question), please read my updated answer.</span>
<span class="comment-copy">or alternatively urllib.parse.urlencode(f)</span>
<span class="comment-copy">I prefer <code>urllib.parse.quote()</code> myself since it uses <code>%20</code> rather than <code>+</code>.</span>
<span class="comment-copy">Luckily urlencode works with OrderedDict too :)</span>
<span class="comment-copy">It works fine and preserves order if you pass a list of tuples: <code>&gt;&gt;&gt; import urllib &gt;&gt;&gt; urllib.urlencode([('name', 'brandon'), ('uid', 1000)]) 'name=brandon&amp;uid=1000' </code></span>
<span class="comment-copy"><code>urlencode</code> need a dict as argument</span>
<span class="comment-copy">That's really helpful! In my case, I only have a portion of string that I want to URL-encode, for example I want to transform <code>my string</code> to <code>my%20string</code>. Your solution works like a charm for that!</span>
<span class="comment-copy">Worked for me to get <code>%20</code> instead of <code>+</code>. Thanks</span>
<span class="comment-copy">usually you only want to url encode the values, what you have done here would make an invalid GET query</span>
<span class="comment-copy">The output for <code>'c:/2 &lt; 3'</code> on Windows is <code>'///C://2%20%3C%203'</code>. I want something that would just output <code>'c:/2%20%3C%203'</code>.</span>
<span class="comment-copy">I already tried this already I kept getting.  TypeError: not a valid non-string sequence or mapping object</span>
<span class="comment-copy">@Johnathan: that's because you're passing a string, while this method expects a dictionary (ie, pairs of key:value) -- look at bgporter's example.</span>
