<div class="post-text" itemprop="text">
<p>i have a little problem with my script, where i need to convert ip in form 'xxx.xxx.xxx.xxx' to integer representation and go back from this form.</p>
<pre><code>def iptoint(ip):
    return int(socket.inet_aton(ip).encode('hex'),16)

def inttoip(ip):
    return socket.inet_ntoa(hex(ip)[2:].decode('hex'))


In [65]: inttoip(iptoint('192.168.1.1'))
Out[65]: '192.168.1.1'

In [66]: inttoip(iptoint('4.1.75.131'))
---------------------------------------------------------------------------
error                                     Traceback (most recent call last)

/home/thc/&lt;ipython console&gt; in &lt;module&gt;()

/home/thc/&lt;ipython console&gt; in inttoip(ip)

error: packed IP wrong length for inet_ntoa`
</code></pre>
<p>Anybody knows how to fix that?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/env python
import socket
import struct


def ip2int(addr):
    return struct.unpack("!I", socket.inet_aton(addr))[0]


def int2ip(addr):
    return socket.inet_ntoa(struct.pack("!I", addr))


print(int2ip(0xc0a80164)) # 192.168.1.100
print(ip2int('10.0.0.1')) # 167772161
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 has <a href="https://docs.python.org/3/library/ipaddress.html" rel="noreferrer">ipaddress</a> module which features very simple conversion:</p>
<pre><code>int(ipaddress.IPv4Address("192.168.0.1"))
str(ipaddress.IPv4Address(3232235521))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In pure python without use additional module</p>
<pre><code>def IP2Int(ip):
    o = map(int, ip.split('.'))
    res = (16777216 * o[0]) + (65536 * o[1]) + (256 * o[2]) + o[3]
    return res


def Int2IP(ipnum):
    o1 = int(ipnum / 16777216) % 256
    o2 = int(ipnum / 65536) % 256
    o3 = int(ipnum / 256) % 256
    o4 = int(ipnum) % 256
    return '%(o1)s.%(o2)s.%(o3)s.%(o4)s' % locals()

# Example
print('192.168.0.1 -&gt; %s' % IP2Int('192.168.0.1'))
print('3232235521 -&gt; %s' % Int2IP(3232235521))
</code></pre>
<p>Result:</p>
<pre><code>192.168.0.1 -&gt; 3232235521
3232235521 -&gt; 192.168.0.1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You lose the left-zero-padding which breaks decoding of your string.</p>
<p>Here's a working function:</p>
<pre><code>def inttoip(ip):
    return socket.inet_ntoa(hex(ip)[2:].zfill(8).decode('hex'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Below are the fastest and most straightforward (to the best of my knowledge)
convertors for IPv4 and IPv6:</p>
<pre><code>    try:
        _str = socket.inet_pton(socket.AF_INET, val)
    except socket.error:
        raise ValueError
    return struct.unpack('!I', _str)[0]
    -------------------------------------------------
    return socket.inet_ntop(socket.AF_INET, struct.pack('!I', n))
    -------------------------------------------------
    try:
        _str = socket.inet_pton(socket.AF_INET6, val)
    except socket.error:
        raise ValueError
    a, b = struct.unpack('!2Q', _str)
    return (a &lt;&lt; 64) | b
    -------------------------------------------------
    a = n &gt;&gt; 64
    b = n &amp; ((1 &lt;&lt; 64) - 1)
    return socket.inet_ntop(socket.AF_INET6, struct.pack('!2Q', a, b))
</code></pre>
<p>Python code not using <code>inet_ntop()</code> and <code>struct</code> module is like order of magnitude slower than this regardless of what it is doing.</p>
</div>
<div class="post-text" itemprop="text">
<p>One line</p>
<pre><code>reduce(lambda out, x: (out &lt;&lt; 8) + int(x), '127.0.0.1'.split('.'), 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let me give a more understandable way:</p>
<p><strong>ip to int</strong> </p>
<pre><code>def str_ip2_int(s_ip='192.168.1.100'):
    lst = [int(item) for item in s_ip.split('.')]
    print lst   
    # [192, 168, 1, 100]

    int_ip = lst[3] | lst[2] &lt;&lt; 8 | lst[1] &lt;&lt; 16 | lst[0] &lt;&lt; 24
    return int_ip   # 3232235876
</code></pre>
<p>The above:</p>
<pre><code>lst = [int(item) for item in s_ip.split('.')]
</code></pre>
<p>equivalent to :</p>
<pre><code>lst = map(int, s_ip.split('.'))
</code></pre>
<p>also:</p>
<pre><code>int_ip = lst[3] | lst[2] &lt;&lt; 8 | lst[1] &lt;&lt; 16 | lst[0] &lt;&lt; 24
</code></pre>
<p>equivalent to :</p>
<pre><code>int_ip = lst[3] + (lst[2] &lt;&lt; 8) + (lst[1] &lt;&lt; 16) + (lst[0] &lt;&lt; 24)

int_ip = lst[3] + lst[2] * pow(2, 8) + lst[1] * pow(2, 16) + lst[0] * pow(2, 24)
</code></pre>
<p><strong>int to ip:</strong></p>
<pre><code>def int_ip2str(int_ip=3232235876):
    a0 = str(int_ip &amp; 0xff)
    a1 = str((int_ip &amp; 0xff00) &gt;&gt; 8) 
    a2 = str((int_ip &amp; 0xff0000) &gt;&gt; 16)
    a3 = str((int_ip &amp; 0xff000000) &gt;&gt; 24)

    return ".".join([a3, a2, a1, a0])
</code></pre>
<p>or:</p>
<pre><code>def int_ip2str(int_ip=3232235876):
    lst = []
    for i in xrange(4):
        shift_n = 8 * i
        lst.insert(0, str((int_ip &gt;&gt; shift_n) &amp; 0xff))

    return ".".join(lst)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My approach is to straightforwardly look at the the number the way it is stored, rather than displayed, and to manipulate it from the display format to the stored format and vice versa.</p>
<p>So, <strong>from an IP address to an int</strong>:</p>
<pre><code>def convertIpToInt(ip):
    return sum([int(ipField) &lt;&lt; 8*index for index, ipField in enumerate(reversed(ip.split('.')))])
</code></pre>
<p>This evaluates each field, and shifts it to its correct offset, and then sums them all up, neatly converting the IP address' display into its numerical value.</p>
<p>In the opposite direction, <strong>from an int to an IP address</strong>:</p>
<pre><code>def convertIntToIp(ipInt):
    return '.'.join([str(int(ipHexField, 16)) for ipHexField in (map(''.join, zip(*[iter(str(hex(ipInt))[2:].zfill(8))]*2)))])
</code></pre>
<p>The numerical representation is first converted into its hexadecimal string representation, which can be manipulated as a sequence, making it easier to break up. Then, pairs are extracted by mapping ''.join onto tuples of pairs provided by zipping a list of two references to an iterator of the IP string (see <a href="https://stackoverflow.com/questions/2233204/how-does-zipitersn-work-in-python">How does zip(*[iter(s)]*n) work?</a>), and those pairs are in turn converted from hex string representations to int string representations, and joined by '.'.</p>
</div>
<div class="post-text" itemprop="text">
<h1>I used following:</h1>
<pre><code>ip2int = lambda ip: reduce(lambda a,b: long(a)*256 + long(b), ip.split('.'))

ip2int('192.168.1.1')

#output

3232235777L

# from int to ip
int2ip = lambda num: '.'.join( [ str((num &gt;&gt; 8*i) % 256)  for i in [3,2,1,0] ])

int2ip(3232235777L)

#output

'192.168.1.1'
</code></pre>
</div>
<span class="comment-copy">Doesn't work at all in my Python 2.6.6: <code>inttoip</code> raises a <code>TypeError: Odd-length string</code>.</span>
<span class="comment-copy">@Ilkka use socket.inet_ntoa(hex(ip)[2:].decode('hex')) for inttoip</span>
<span class="comment-copy">This requires <code>import struct</code>.</span>
<span class="comment-copy">i realise that this post is fairly old, but you can also use <code>pow</code>:: <code>res = (o[0] * pow(256, 3)) + (o[1] * pow(256, 2)) + (o[2] * 256) + o[3]</code></span>
<span class="comment-copy">This is what I came here for, thank you</span>
<span class="comment-copy">Yeah, you also fixed the <code>[2:-1]</code> slice to <code>[2:]</code>, that was causing the error I commented about above.</span>
<span class="comment-copy">Wow thats a line of :)</span>
<span class="comment-copy">@thc_flow: Please don't forget to accept the answer</span>
<span class="comment-copy">If ip is a LONG there will be a <code>'L'</code> turd at the end of the string.  Either replace <code>hex(ip)</code> with <code>hex(int(ip))</code> or add <code>.rstrip('L')</code> after <code>[2:]</code>.</span>
<span class="comment-copy">socket.inet_pton and inet_ntop are only available on Unix</span>
