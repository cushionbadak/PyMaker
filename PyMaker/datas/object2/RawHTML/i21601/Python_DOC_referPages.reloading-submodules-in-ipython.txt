<div class="post-text" itemprop="text">
<p>Currently I am working on a python project that contains sub modules and uses numpy/scipy. Ipython is used as interactive console. Unfortunately I am not very happy with workflow that I am using right now, I would appreciate some advice.</p>
<p>In IPython, the framework is loaded by a simple <code>import</code> command. However, it is often necessary to change code in one of the submodules of the framework. At this point a model is already loaded and I use IPython to interact with it. </p>
<p>Now, the framework contains many modules that depend on each other, i.e. when the framework is initially loaded the main module is importing and configuring the submodules.  The changes to the code are only executed if the module is reloaded using <code>reload(main_mod.sub_mod)</code>. This is cumbersome as I need to reload all changed modules individually using the full path. It would be very convenient if <code>reload(main_module)</code> would also reload all sub modules, but without reloading numpy/scipy..</p>
</div>
<div class="post-text" itemprop="text">
<p>IPython comes with some <a href="http://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html" rel="noreferrer">automatic reloading</a> magic:</p>
<pre><code>%load_ext autoreload
%autoreload 2
</code></pre>
<p>It will reload all changed modules every time before executing a new line. The way this works is slightly different than <code>dreload</code>. Some caveats apply, type <code>%autoreload?</code> to see what can go wrong.</p>
<hr/>
<p>If you want to always enable this settings, modify your IPython configuration file <code>~/.ipython/profile_default/ipython_config.py</code>[1] and appending:</p>
<pre><code>c.InteractiveShellApp.extensions = ['autoreload']     
c.InteractiveShellApp.exec_lines = ['%autoreload 2']
</code></pre>
<p><em>Credit to @Kos via a comment below.</em></p>
<p>[1]
If you don't have the file <code>~/.ipython/profile_default/ipython_config.py</code>, you need to call <code>ipython profile create</code> first. Or the file may be located at <code>$IPYTHONDIR</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In IPython 0.12 (and possibly earlier), you can use this:</p>
<pre><code>%load_ext autoreload
%autoreload 2
</code></pre>
<p>This is essentially the same as the answer by <a href="https://stackoverflow.com/users/108184/pv">pv.</a>, except that the extension has been renamed and is now loaded using <code>%load_ext</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>IPython offers <a href="http://ipython.github.com/ipython-doc/rel-0.10.1/html/interactive/reference.html#dreload" rel="noreferrer"><code>dreload()</code></a> to recursively reload all submodules.  Personally, I prefer to use the <a href="http://ipython.github.com/ipython-doc/rel-0.10.1/html/interactive/tutorial.html#the-run-magic-command" rel="noreferrer"><code>%run()</code></a> magic command (though it does not perform a deep reload, as pointed out by John Salvatier in the comments).</p>
</div>
<div class="post-text" itemprop="text">
<p>For some reason, neither <code>%autoreload</code>, nor <code>dreload</code> seem to work for the situation when you <a href="https://stackoverflow.com/a/16966830/304209">import code from one notebook to another</a>. Only plain Python <code>reload</code> works:</p>
<pre><code>reload(module)
</code></pre>
<p>Based on <a href="https://stackoverflow.com/a/6420389/304209">[1]</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>import inspect

# needs to be primed with an empty set for loaded
def recursively_reload_all_submodules(module, loaded=None):
    for name in dir(module):
        member = getattr(module, name)
        if inspect.ismodule(member) and member not in loaded:
            recursively_reload_all_submodules(member, loaded)
    loaded.add(module)
    reload(module)

import mymodule
recursively_reload_all_submodules(mymodule, set())
</code></pre>
<p>This should effectively reload the entire tree of modules and submodules you give it. You can also put this function in your .ipythonrc (I think) so it is loaded every time you start the interpreter.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://shawnleezx.github.io/blog/2015/08/03/some-notes-on-ipython-startup-script/" rel="nofollow noreferrer">http://shawnleezx.github.io/blog/2015/08/03/some-notes-on-ipython-startup-script/</a></p>
<p>To avoid typing those magic function again and again, they could be put in the ipython startup script(Name it with .py suffix under .ipython/profile_default/startup. All python scripts under that folder will be loaded according to lexical order), which looks like the following:</p>
<pre><code>from IPython import get_ipython
ipython = get_ipython()

ipython.magic("pylab")
ipython.magic("load_ext autoreload")
ipython.magic("autoreload 2")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option:</p>
<pre><code>$ cat &lt;&lt; EOF &gt; ~/.ipython/profile_default/startup/50-autoreload.ipy
%load_ext autoreload
%autoreload 2
EOF
</code></pre>
<p>Verified on ipython and ipython3 v5.1.0 on Ubuntu 14.04.</p>
</div>
<div class="post-text" itemprop="text">
<p>My standard practice for reloading is to combine both methods following first opening of <code>IPython</code>:</p>
<pre><code>from IPython.lib.deepreload import reload
%load_ext autoreload
%autoreload 2
</code></pre>
<p>Loading modules before doing this will cause them not to be reloaded, even with a manual <code>reload(module_name)</code>. I still, very rarely, get inexplicable problems with class methods not reloading that I've not yet looked into.</p>
</div>
<div class="post-text" itemprop="text">
<p>Module named <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer"><code>importlib</code></a> allow to access to import internals. Especially, it provide function <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer"><code>importlib.reload()</code></a>:</p>
<pre><code>import importlib
importlib.reload(my_module)
</code></pre>
<p>In contrary of <code>%autoreload</code>, <code>importlib.reload()</code> also reset global variables set in module. In most cases, it is what you want.</p>
<p><code>importlib</code> is only available since Python 3.1. For older version, you have to use module <a href="https://docs.python.org/3/library/imp.html" rel="nofollow noreferrer"><code>imp</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>On Jupyter Notebooks on Anaconda, doing this:</p>
<pre><code>%load_ext autoreload
%autoreload 2
</code></pre>
<p>produced the message:</p>
<blockquote>
<p>The autoreload extension is already loaded. To reload it, use:
    <code>%reload_ext autoreload</code></p>
</blockquote>
<p>It looks like it's preferable to do:</p>
<pre><code>%reload_ext autoreload
%autoreload 2
</code></pre>
<p>Version information: </p>
<blockquote>
<p>The version of the notebook server is 5.0.0 and is running on:
  Python 3.6.2 |Anaconda, Inc.| (default, Sep 20 2017, 13:35:58) [MSC v.1900 32 bit (Intel)]</p>
</blockquote>
</div>
<span class="comment-copy">Would you care to elaborate more on <code>However, it is often necessary to change code in one of the submodules of the framework.</code> So why it's <code>necessary to change code</code>? Thanks</span>
<span class="comment-copy">@eat: The framework is continually being developed, so there are constant changes to the code base.</span>
<span class="comment-copy">How do you make these changes permanently?</span>
<span class="comment-copy">I have <code>c.InteractiveShellApp.extensions = ['autoreload']</code> and <code>c.InteractiveShellApp.exec_lines = ['%autoreload 2']</code> in my <code>~/.ipython/profile_default/ipython_config.py</code>.</span>
<span class="comment-copy">That might be a performance hit, though, so use with caution.</span>
<span class="comment-copy">This works pretty fine when debugging packages, so what is the purpose of dreload, it seems dreload is too invasive and prints error when some packages like matplotlib are loaded.</span>
<span class="comment-copy">If you use @Kos method, make sure c is defined: c = get_config()</span>
<span class="comment-copy">I think that (unfortunately) %run script.py only reloads the script you're calling, not the packages it imports. If you're trying to debug a package you're building, this can be a pain.</span>
<span class="comment-copy">NB. <code>dreload</code> has been replaced in recent IPython (e.g. IPython 6.0) by <a href="http://ipython.readthedocs.io/en/stable/api/generated/IPython.lib.deepreload.html" rel="nofollow noreferrer">deepreload</a>.</span>
<span class="comment-copy"><code>reload</code> worked while <code>%autoreload</code> magic didn't</span>
<span class="comment-copy">In Python 3.4+, you can find reload in the importlib module. See <a href="https://stackoverflow.com/a/27387813/525169">this question</a>.</span>
<span class="comment-copy">This method works when adding an instance method, unlike the <code>%autoreload</code> technique. There's an <a href="https://github.com/ipython/ipython/issues/8771" rel="nofollow noreferrer">open bug report to add support to <code>%autoreload</code> for this.</a>.</span>
<span class="comment-copy">That looks good, however, it might be that it is not covering modules or members of modules that are imported using <code>from ... import ...</code> or <code>import ... as</code>. At least that's giving me often some trouble when working interactively on the terminal. I've moved on to use stored macros in IPython that do the necessary imports and setups to start working in a predefined state.</span>
<span class="comment-copy">It actually does cover <code>from ... import ...</code> and <code>import ... as</code> as long as the thing you imported is a module. The only thing that it doesn't cover is modules in a package that weren't loaded from it's <code>__init__.py</code> file. For packages, you can probably check if the module's <code>__path__</code> attribute is a directory. If it is, traverse it and recursively import all the modules you could find. I didn't write this part because the author has not asked for a solution for packages.</span>
<span class="comment-copy">Indeed this looks good. I thought about this possibility, at the same I would expect that there would be some built in functionality, i.e. based on <a href="http://ipython.scipy.org/ipython/ipython/ticket/154" rel="nofollow noreferrer">this</a>. However, it was not clear to me how to use this. After some digging that should have occurred before I posted the original question, I found this <a href="http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython">extension</a>.</span>
<span class="comment-copy">Also you can use <code>pkgutil</code> to get all submodules in a package, even if the package does not import the submodules into the top module. <a href="http://stackoverflow.com/a/1707786/1243926">stackoverflow.com/a/1707786/1243926</a></span>
