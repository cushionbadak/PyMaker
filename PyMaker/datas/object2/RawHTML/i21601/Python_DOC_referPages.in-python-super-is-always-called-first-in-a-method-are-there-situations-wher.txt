<div class="post-text" itemprop="text">
<p>Are there situations where you want to do some processing before you call super()?</p>
<p>This is a contrived example.  Are there better examples?  Is this considered pythonic?</p>
<pre><code>class Base(object):
    def __init__(self, name):
        print "Base %s created" % name
        self._name = name

class UpperBase(A):
    """ Similar to base but the name is in uppercase. """
    def __init__(self, name):
        name = name.upper() 
        super(UpperBase, self).__init__(name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes you need to validate the arguments before calling <code>super()</code>:</p>
<pre><code>class UpperBase(Base):
    def __init__(self, name):
        if not name_valid(name):
            raise ValueError()
        super(UpperBase, self).__init__(name)
</code></pre>
<p>I don't see why this wouldn't be pythonic, because it's the easiest way to do it and it's straightforward.
Also, read @JHSaunders' comment, he makes a good point.</p>
</div>
<span class="comment-copy">Your example is <i>precisely</i> the kind of situation where you perform additional calculations before the upcall to the parent class. I know I do it quite often when defining <code>Thread</code> subclasses - I usually have some logic in there to give the thread a meaningful name based on the constructor arguments.</span>
<span class="comment-copy">I think you should avoid <i>modifying</i> the instance state before calling the <code>super()..</code> method. So just doing some calculations on the arguments (transforming, validating, etc) is OK but you should not alter the state of the instance.</span>
<span class="comment-copy">@frans Why?  (I've seen plenty of code do it)</span>
<span class="comment-copy">On the one side it's some sort of gut feeling which I can't fully explain. Maybe it's easier to understand what's happening if the <code>super()</code> method is <i>always</i> being called before anything else happens (without any <i>exceptions</i> you'd have to explain. It also feels like strange architecture If you <i>need</i> to change the state of the instance before the base class' method can be called safely (which would be a semantic dependency from base class to derived class)</span>
<span class="comment-copy">Ya, the init method in python is not a constructor like C++, it does not do the actual memory allocation. By the time init is called the memory is allocated. So it is really just a normal method that happens to have certain semantics (It is called after an object is constructed). So in short you should be able to call it anywhere. (If I am wrong some one please correct me)</span>
<span class="comment-copy">In C++ the constructor does not allocate memory but initialize it and other things can be done there, too. There are indeed a lot of differences between C++ constructors and Python's <code>__init__()</code>-method but this question is about <code>super()</code> in general, not <code>super().__init__()</code> only.</span>
<span class="comment-copy">In Python 3, you can simply call <code>super()</code> rather than <code>super(UpperBase, self)</code>: <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#super</a></span>
