<div class="post-text" itemprop="text">
<p>For some reason, I can not depend on Python's "import" statement to generate .pyc file automatically</p>
<p>Is there a way to implement a function as following?</p>
<pre><code>def py_to_pyc(py_filepath, pyc_filepath):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use compileall in the terminal. The following command will go recursively into sub directories and make pyc files for all the python files it finds. The <a href="https://docs.python.org/2/library/compileall.html" rel="noreferrer">compileall</a> module is part of the python standard library, so you don't need to install anything extra to use it. This works exactly the same way for python2 and python3.</p>
<pre><code>python -m compileall .
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can compile individual files(s) from the command line with:</p>
<pre><code>python -m compileall &lt;file_1&gt;.py &lt;file_n&gt;.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's been a while since I last used Python, but I believe you can use <a href="https://docs.python.org/3/library/py_compile.html#py_compile.compile" rel="noreferrer"><code>py_compile</code></a>:</p>
<pre><code>import py_compile
py_compile.compile("file.py")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found <strong>several</strong> ways to compile python scripts into bytecode</p>
<ol>
<li><p>Using <code>py_compile.compile</code>:</p>
<pre><code>import py_compile
py_compile.compile('YourFileName.py')
</code></pre></li>
<li><p>Using <code>py_compile.main()</code>:</p>
<p>It compiles several files at a time.</p>
<pre><code>import py_compile
py_compile.main(['File1.py','File2.py','File3.py'])
</code></pre>
<p>The list can grow as long as you wish. Alternatively you can obviously pass a list of files in main or even file names in command line args.</p>
<p>Or, if you pass <code>['-']</code> in main then it can compile files interactively.</p></li>
<li><p>Using <code>py_compile</code> in terminal:</p>
<pre><code>python -m py_compile File1.py File2.py File3.py ...
</code></pre>
<p><code>-m</code> specifies the module(s) name to be compiled. </p>
<p>Or, for interactive compilation of files</p>
<pre><code>python -m py_compile -
File1.py
File2.py
File3.py
   .
   .
   .
</code></pre></li>
<li><p>Using <code>compileall.compile_dir()</code>:</p>
<pre><code>import compileall
compileall.compile_dir(direname)
</code></pre>
<p>It compiles every single Python file present in the supplied directory.</p></li>
<li><p>Using <code>compileall.compile_file()</code>:</p>
<pre><code>import compileall
compileall.compile_file('YourFileName.py')
</code></pre></li>
</ol>
<p>Take a look at the links below:</p>
<p><a href="https://docs.python.org/3/library/py_compile.html" rel="nofollow noreferrer">https://docs.python.org/3/library/py_compile.html</a></p>
<p><a href="https://docs.python.org/3/library/compileall.html" rel="nofollow noreferrer">https://docs.python.org/3/library/compileall.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would use <a href="http://docs.python.org/library/compileall.html" rel="noreferrer">compileall</a>. It works nicely both from scripts and from the command line. It's a bit higher level module/tool than the already mentioned <a href="http://docs.python.org/library/py_compile.html" rel="noreferrer">py_compile</a> that it also uses internally.</p>
</div>
<div class="post-text" itemprop="text">
<p>To match the original question requirements (source path and destination path) the code should be like that:</p>
<pre><code>import py_compile
py_compile.compile(py_filepath, pyc_filepath)
</code></pre>
<p>If the input code has errors then the <em>py_compile.PyCompileError</em> exception is raised.</p>
</div>
<div class="post-text" itemprop="text">
<h1>In Python2 you could use:</h1>
<pre><code>python -m compileall &lt;pythonic-project-name&gt;
</code></pre>
<p>which makes compile all <code>.py</code> to <code>.pyc</code> in the project which contained the subfolders.</p>
<hr/>
<h1>In Python3 you could use:</h1>
<pre><code>python3 -m compileall &lt;pythonic-project-name&gt;
</code></pre>
<p>which makes compile all <code>.py</code> to the <code>__pycache__</code> folders in the project which contained the subfolders.</p>
<p>Or with browning from <a href="https://stackoverflow.com/a/53945327/3702377">this post</a>:</p>
<blockquote>
<p>You can enforce the same layout of <code>.pyc</code> files in the folders as in
  Python2 by using:</p>
<p><code>python3 -m compileall -b &lt;pythonic-project-name&gt;</code></p>
<p>The option -b triggers the output of <code>.pyc</code> files to their
  legacy-locations (i.e. the same as in Python2).</p>
</blockquote>
</div>
<span class="comment-copy">This should be the accepted answer --at least in my need to compile all *.py into *.pyc: recursively :)</span>
<span class="comment-copy">Is it possible to distribute a PYC file containing all the libraries used? So users doesn't have to install them, just ran the PYC file, I know in java this is possible using a JARs are there any similar method for Python?</span>
<span class="comment-copy">check out <a href="https://www.python.org/dev/peps/pep-0273/" rel="nofollow noreferrer">python.org/dev/peps/pep-0273</a> it let's you do that</span>
<span class="comment-copy">I heard also something about meta files in Python. This compileall also build some cache? If not, what is the command for that?? Since the end-users doesn't have write permission to the lib directory. And I want to speed up things here... PS. also take a look at the <code>-O</code> flag, for bytecode (.pyo file iso .pyc) compilation.</span>
<span class="comment-copy">be careful with this command. I did accidentally do a <code>compileall</code> on my site-packages folder and it messed up everything</span>
<span class="comment-copy">You probably want to include the second parameter, which determines the output file. Otherwise, it defaults to something like <code>__pycache__/file.cpython-32.pyc</code> and you get that as the return value.</span>
<span class="comment-copy">One small correction is that the module name you are loading is <code>py_compile</code> and <code>compileall</code> NOT <code>py_compile.py</code> or <code>compileall.py</code>. In other words, it should be <code>python3 -m py_compile PYTHON_FILENAME</code> or <code>python3 -m compileall PYTHON_FILES_DIRECTORY</code>.</span>
<span class="comment-copy"><code>compileall</code> does not include logic to skip files for which the corresponding <code>.pyc</code> file is already up-to-date, does it?</span>
<span class="comment-copy">@KyleStrand <code>compileall</code> does skip files that already have an up-to-date <code>.pyc</code> (tested with Python 2.7.11)</span>
<span class="comment-copy">@Eponymous Interesting. Not sure why I thought otherwise. Thanks for checking.</span>
