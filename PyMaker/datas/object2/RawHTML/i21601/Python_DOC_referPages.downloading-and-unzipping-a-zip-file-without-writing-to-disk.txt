<div class="post-text" itemprop="text">
<p>I have managed to get my first python script to work which downloads a list of .ZIP files from a URL and then proceeds to extract the ZIP files and writes them to disk.</p>
<p>I am now at a loss to achieve the next step. </p>
<p>My primary goal is to download and extract the zip file and pass the contents (CSV data) via a TCP stream. I would prefer not to actually write any of the zip or extracted files to disk if I could get away with it.</p>
<p>Here is my current script which works but unfortunately has to write the files to disk.</p>
<pre><code>import urllib, urllister
import zipfile
import urllib2
import os
import time
import pickle

# check for extraction directories existence
if not os.path.isdir('downloaded'):
    os.makedirs('downloaded')

if not os.path.isdir('extracted'):
    os.makedirs('extracted')

# open logfile for downloaded data and save to local variable
if os.path.isfile('downloaded.pickle'):
    downloadedLog = pickle.load(open('downloaded.pickle'))
else:
    downloadedLog = {'key':'value'}

# remove entries older than 5 days (to maintain speed)

# path of zip files
zipFileURL = "http://www.thewebserver.com/that/contains/a/directory/of/zip/files"

# retrieve list of URLs from the webservers
usock = urllib.urlopen(zipFileURL)
parser = urllister.URLLister()
parser.feed(usock.read())
usock.close()
parser.close()

# only parse urls
for url in parser.urls: 
    if "PUBLIC_P5MIN" in url:

        # download the file
        downloadURL = zipFileURL + url
        outputFilename = "downloaded/" + url

        # check if file already exists on disk
        if url in downloadedLog or os.path.isfile(outputFilename):
            print "Skipping " + downloadURL
            continue

        print "Downloading ",downloadURL
        response = urllib2.urlopen(downloadURL)
        zippedData = response.read()

        # save data to disk
        print "Saving to ",outputFilename
        output = open(outputFilename,'wb')
        output.write(zippedData)
        output.close()

        # extract the data
        zfobj = zipfile.ZipFile(outputFilename)
        for name in zfobj.namelist():
            uncompressed = zfobj.read(name)

            # save uncompressed data to disk
            outputFilename = "extracted/" + name
            print "Saving extracted file to ",outputFilename
            output = open(outputFilename,'wb')
            output.write(uncompressed)
            output.close()

            # send data via tcp stream

            # file successfully downloaded and extracted store into local log and filesystem log
            downloadedLog[url] = time.time();
            pickle.dump(downloadedLog, open('downloaded.pickle', "wb" ))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My suggestion would be to use a <a href="http://docs.python.org/library/stringio.html" rel="noreferrer"><code>StringIO</code></a> object. They emulate files, but reside in memory. So you could do something like this:</p>
<pre><code># get_zip_data() gets a zip archive containing 'foo.txt', reading 'hey, foo'

from StringIO import StringIO
zipdata = StringIO()
zipdata.write(get_zip_data())
myzipfile = zipfile.ZipFile(zipdata)
foofile = myzipfile.open('foo.txt')
print foofile.read()

# output: "hey, foo"
</code></pre>
<p>Or more simply (apologies to Vishal):</p>
<pre><code>myzipfile = zipfile.ZipFile(StringIO(get_zip_data()))
for name in myzipfile.namelist():
    [ ... ]
</code></pre>
<p>In Python 3 use BytesIO instead of StringIO.</p>
</div>
<div class="post-text" itemprop="text">
<p>Below is a code snippet I used to fetch zipped csv file, please have a look: </p>
<p><strong>Python 2</strong>:</p>
<pre><code>from StringIO import StringIO
from zipfile import ZipFile
from urllib import urlopen

resp = urlopen("http://www.test.com/file.zip")
zipfile = ZipFile(StringIO(resp.read()))
for line in zipfile.open(file).readlines():
    print line
</code></pre>
<p><strong>Python 3</strong>:</p>
<pre><code>from io import BytesIO
from zipfile import ZipFile
from urllib.request import urlopen
# or: requests.get(url).content

resp = urlopen("http://www.test.com/file.zip")
zipfile = ZipFile(BytesIO(resp.read()))
for line in zipfile.open(file).readlines():
    print(line.decode('utf-8'))
</code></pre>
<p>Here <code>file</code> is a string.  To get the actual string that you want to pass, you can use <code>zipfile.namelist()</code>.  For instance,</p>
<pre><code>resp = urlopen('http://mlg.ucd.ie/files/datasets/bbc.zip')
zipfile = ZipFile(BytesIO(resp.read()))
zipfile.namelist()
# ['bbc.classes', 'bbc.docs', 'bbc.mtx', 'bbc.terms']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to offer an updated Python 3 version of Vishal's excellent answer, which was using Python 2, along with some explanation of the adaptations / changes, which may have been already mentioned. </p>
<pre><code>from io import BytesIO
from zipfile import ZipFile
import urllib.request

    url = urllib.request.urlopen("http://www.unece.org/fileadmin/DAM/cefact/locode/loc162txt.zip")

    with ZipFile(BytesIO(url.read())) as my_zip_file:
        for contained_file in my_zip_file.namelist():
            # with open(("unzipped_and_read_" + contained_file + ".file"), "wb") as output:
            for line in my_zip_file.open(contained_file).readlines():
                print(line)
                # output.write(line)
</code></pre>
<p>Necessary changes:</p>
<ul>
<li>There's no <code>StringIO</code> in Python 3. Instead, I use <code>io</code>, and from it I import <code>BytesIO</code>, because we will be handling a bytestream -- <a href="https://docs.python.org/3/whatsnew/3.0.html" rel="noreferrer">Docs</a>, also <a href="https://stackoverflow.com/questions/31064981/python3-error-initial-value-must-be-str-or-none">this thread</a>. </li>
<li>urlopen:

<ul>
<li>"The legacy urllib.urlopen function from Python 2.6 and earlier has been discontinued; urllib.request.urlopen() corresponds to the old urllib2.urlopen.",  <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen" rel="noreferrer">Docs</a>. </li>
</ul></li>
<li>import urllib.request:

<ul>
<li><a href="https://stackoverflow.com/questions/37042152/python-3-5-1-urllib-has-no-attribute-request">This thread</a>. </li>
</ul></li>
</ul>
<p>Note:</p>
<ul>
<li>In Python 3, the printed output lines will look like so: <code>b'some text'</code>. This is expected, as they aren't strings - remember, we're reading a bytestream. Have a look at <a href="https://stackoverflow.com/questions/6269765/what-does-the-b-character-do-in-front-of-a-string-literal">Dan04's excellent answer</a>.</li>
</ul>
<p>A few minor changes I made:</p>
<ul>
<li>I use <code>with ... as</code> instead of <code>zipfile = ...</code> according to <a href="https://docs.python.org/3/library/zipfile.html" rel="noreferrer">the Docs</a>. </li>
<li>The script now uses <code>namelist()</code> to cycle through all the files in the zip and print their contents.</li>
<li>I moved the creation of the <code>ZipFile</code> object into the with-statement, altough I'm not sure if that's better.</li>
<li>I added (and commented out) an option to write the bytestream to file (per file in the zip), in response to NumenorForLife's comment; it adds <code>"unzipped_and_read_"</code> to the beginning of the filename and a <code>".file"</code> extension (I prefer not to use <code>".txt"</code> for files with bytestrings). The indenting of the code will, of course, need to be adjusted if you want to use it. 

<ul>
<li>Need to be careful here -- because we have a byte string, we use binary mode, so <code>"wb"</code>; I have a feeling that writing binary opens a can of worms anyway...</li>
</ul></li>
<li>I am using an example file, the <a href="http://www.unece.org/cefact/codesfortrade/codes_index.html" rel="noreferrer">UN/LOCODE text archive</a>:</li>
</ul>
<p>What I didn't do:</p>
<ul>
<li>NumenorForLife asked about saving the zip to disk. I'm not sure what he meant by it -- downloading the zip file? That's a different task; see <a href="https://stackoverflow.com/questions/7243750/download-file-from-web-in-python-3">Oleh Prypin's excellent answer</a>. </li>
</ul>
<p>Here's a way: </p>
<pre><code>import urllib.request
import shutil

with urllib.request.urlopen("http://www.unece.org/fileadmin/DAM/cefact/locode/2015-2_UNLOCODE_SecretariatNotes.pdf") as response, open("downloaded_file.pdf", 'w') as out_file:
    shutil.copyfileobj(response, out_file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>write to a temporary file which resides in RAM</p>
<p>it turns out the <code>tempfile</code> module ( <a href="http://docs.python.org/library/tempfile.html" rel="noreferrer">http://docs.python.org/library/tempfile.html</a> ) has just the thing:</p>
<blockquote>
<p>tempfile.SpooledTemporaryFile([max_size=0[,
  mode='w+b'[, bufsize=-1[, suffix=''[,
  prefix='tmp'[, dir=None]]]]]])</p>
<p>This
  function operates exactly as
  TemporaryFile() does, except that data
  is spooled in memory until the file
  size exceeds max_size, or until the
  fileâ€™s fileno() method is called, at
  which point the contents are written
  to disk and operation proceeds as with
  TemporaryFile().</p>
<p>The resulting file has one additional
  method, rollover(), which causes the
  file to roll over to an on-disk file
  regardless of its size.</p>
<p>The returned object is a file-like
  object whose _file attribute is either
  a StringIO object or a true file
  object, depending on whether
  rollover() has been called. This
  file-like object can be used in a with
  statement, just like a normal file.</p>
<p>New in version 2.6.</p>
</blockquote>
<p>or if you're lazy and you have a tmpfs-mounted <code>/tmp</code> on Linux, you can just make a file there, but you have to delete it yourself and deal with naming</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to add my Python3 answer for completeness:</p>
<pre><code>from io import BytesIO
from zipfile import ZipFile
import requests

def get_zip(file_url):
    url = requests.get(file_url)
    zipfile = ZipFile(BytesIO(url.content))
    zip_names = zipfile.namelist()
    if len(zip_names) == 1:
        file_name = zip_names.pop()
        extracted_file = zipfile.open(file_name)
        return extracted_file
    return [zipfile.open(file_name) for file_name in zip_names]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Adding on to the other answers using <strong>requests</strong>:</p>
<pre><code> # download from web

 import requests
 url = 'http://mlg.ucd.ie/files/datasets/bbc.zip'
 content = requests.get(url)

 # unzip the content
 from io import BytesIO
 from zipfile import ZipFile
 f = ZipFile(BytesIO(content.content))
 print(f.namelist())

 # outputs ['bbc.classes', 'bbc.docs', 'bbc.mtx', 'bbc.terms']
</code></pre>
<p>Use <strong>help(f)</strong> to get more functions details for e.g. <strong>extractall()</strong> which extracts the contents in zip file which later can be used with <strong>with open</strong>. </p>
</div>
<div class="post-text" itemprop="text">
<p>It wasn't obvious in Vishal's answer what the file name was supposed to be in cases where there is no file on disk. I've modified his answer to work without modification for most needs.</p>
<pre><code>from StringIO import StringIO
from zipfile import ZipFile
from urllib import urlopen

def unzip_string(zipped_string):
    unzipped_string = ''
    zipfile = ZipFile(StringIO(zipped_string))
    for name in zipfile.namelist():
        unzipped_string += zipfile.open(name).read()
    return unzipped_string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Vishal's example, however great, confuses when it comes to the file name, and I do not see the merit of redefing 'zipfile'. </p>
<p>Here is my example that downloads a zip that contains some files, one of which is a csv file that I subsequently read into a pandas DataFrame:</p>
<pre><code>from StringIO import StringIO
from zipfile import ZipFile
from urllib import urlopen
import pandas

url = urlopen("https://www.federalreserve.gov/apps/mdrm/pdf/MDRM.zip")
zf = ZipFile(StringIO(url.read()))
for item in zf.namelist():
    print("File in zip: "+  item)
# find the first matching csv file in the zip:
match = [s for s in zf.namelist() if ".csv" in s][0]
# the first line of the file contains a string - that line shall de ignored, hence skiprows
df = pandas.read_csv(zf.open(match), low_memory=False, skiprows=[0])
</code></pre>
<p>(Note, I use Python 2.7.13)</p>
</div>
<span class="comment-copy">Why not use temporary files?</span>
<span class="comment-copy">ZIP format isn't designed to be streamed. It uses footers, meaning you need the <i>end</i> of the file to figure out where things belong inside it, meaning you need to have the whole file before you can do anything with a subset of it.</span>
<span class="comment-copy">"The StringIO object can accept either Unicode or 8-bit strings" Doesn't this mean that if the number of bytes you expect to write is not congruent to 0 mod 8, then you will either throw an exception or write incorrect data?</span>
<span class="comment-copy">Not at all -- why would you only be able to write 8 bytes at a time? Conversely, when do you ever write fewer than 8 bits at a time?</span>
<span class="comment-copy">Ah, of course, silly question on my part.</span>
<span class="comment-copy">Small comment on the above code: when you read multiple files out of the .zip, make sure you read the data out one by one, because calling zipfile.open two times will remove the reference in the first.</span>
<span class="comment-copy">Notice that as of Python 3 you have to use <code>from io import StringIO</code></span>
<span class="comment-copy">+1: this is why I love python... I search for something, and there's a python way to do it in 3 lines.</span>
<span class="comment-copy">I count 6 lines.</span>
<span class="comment-copy">You should clarify what you mean by "file" in the code above. Otherwise great, concise example.</span>
<span class="comment-copy">So file in the for-loop refers to the name of the file unzipped. Is there a way to programatically get its name?</span>
<span class="comment-copy">Use <code>namelist</code>: <a href="https://docs.python.org/2/library/zipfile.html#zipfile.ZipFile.namelist" rel="nofollow noreferrer">docs.python.org/2/library/zipfile.html#zipfile.ZipFile.namelist</a></span>
<span class="comment-copy">If you want to write all the files to disk the easier way is to use my_zip_file.extractall('my_target')` instead of looping. But that's great!</span>
<span class="comment-copy">+1 -- didn't know about SpooledTemporaryFile. My inclination would still be to use StringIO explicitly, but this is good to know.</span>
<span class="comment-copy">This should be the accepted answer :)</span>
