<div class="post-text" itemprop="text">
<p>Think about a function that I'm calling for it's side effects, not return values (like printing to screen, updating GUI, printing to a file, etc.).</p>
<pre><code>def fun_with_side_effects(x):
    ...side effects...
    return y
</code></pre>
<p>Now, is it <em>Pythonic</em> to use list comprehensions to call this func:</p>
<pre><code>[fun_with_side_effects(x) for x in y if (...conditions...)]
</code></pre>
<p><em>Note that I don't save the list anywhere</em></p>
<p>Or should I call this func like this:</p>
<pre><code>for x in y:
    if (...conditions...):
        fun_with_side_effects(x)
</code></pre>
<p>Which is better and why?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is very anti-Pythonic to do so, and any seasoned Pythonista will give you hell over it. The intermediate list is thrown away after it is created, and it could potentially be very, very large, and therefore expensive to create.</p>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't use a <em>list</em> comprehension, because as people have said that will build a large temporary list that you don't need. The following two methods are equivalent:</p>
<pre><code>consume(side_effects(x) for x in xs)

for x in xs:
    side_effects(x)
</code></pre>
<p>with the definition of <code>consume</code> from the <code>itertools</code> man page:</p>
<pre><code>def consume(iterator, n=None):
    "Advance the iterator n-steps ahead. If n is none, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)
</code></pre>
<p>Of course, the latter is clearer and easier to understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions are for creating lists. And unless you are actually creating a list, you should <em>not</em> use list comprehensions.</p>
<p>So I would got for the second option, just iterating over the list and then call the function when the conditions apply.</p>
</div>
<div class="post-text" itemprop="text">
<p>Second is better.</p>
<p>Think of the person who would need to understand your code. You can get bad karma easily with the first :)</p>
<p>You could go middle between the two by using filter(). Consider the example:</p>
<pre><code>y=[1,2,3,4,5,6]
def func(x):
    print "call with %r"%x

for x in filter(lambda x: x&gt;3, y):
    func(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Depends on your goal.</p>
<p>If you are trying to do some operation on each object in a list, the second approach should be adopted.</p>
<p>If you are trying to generate a list from another list, you may use list comprehension.</p>
<blockquote>
<p>Explicit is better than implicit.
  Simple is better than complex. (Python Zen)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can do</p>
<pre><code>for z in (fun_with_side_effects(x) for x in y if (...conditions...)): pass
</code></pre>
<p>but it's not very pretty.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a list comprehension for its side effects is ugly, non-Pythonic, inefficient, and I wouldn't do it. I would use a <code>for</code> loop instead, because a <code>for</code> loop signals a procedural style in which side-effects are important.</p>
<p>But, if you absolutely insist on using a list comprehension for its side effects, you should avoid the inefficiency by using a generator expression instead. If you absolutely insist on this style, do one of these two:</p>
<pre><code>any(fun_with_side_effects(x) and False for x in y if (...conditions...))
</code></pre>
<p>or:</p>
<pre><code>all(fun_with_side_effects(x) or True for x in y if (...conditions...))
</code></pre>
<p>These are generator expressions, and they do not generate a random list that gets tossed out. I think the <code>all</code> form is perhaps slightly more clear, though I think both of them are confusing and shouldn't be used.</p>
<p>I think this is ugly and I wouldn't actually do it in code. But if you insist on implementing your loops in this fashion, that's how I would do it.</p>
<p>I tend to feel that list comprehensions and their ilk should signal an attempt to use something at least faintly resembling a functional style. Putting things with side effects that break that assumption will cause people to have to read your code more carefully, and I think that's a bad thing.</p>
</div>
<span class="comment-copy">this is borderline, but you'll probably get more opposed than in support. I'm going to sit this one out :^)</span>
<span class="comment-copy">This is an easy choice. Readability counts - do it the second way. If you can't fit 2 extra lines on your screen get a bigger monitor :)</span>
<span class="comment-copy">The list comprehension is unpythonic since it violates "explicit is better than implicit" -- you're hiding a loop in a different construct.</span>
<span class="comment-copy">@larsmans: if only GvR had realised that when he introduced list comprehensions in the first place!</span>
<span class="comment-copy">@larsmans, Steve Jessop, I think it's incorrect to conceive a list comprehension as a loop. It may well be implemented as a loop, but the point of constructs like this is to operate on aggregate data in a functional and (conceptually) parallel way. If there's a problem with the syntax, it's that <code>for ... in</code> is used in both cases -- leading to questions like this one!</span>
<span class="comment-copy">So what would be a more pythonic way?</span>
<span class="comment-copy">The one that doesn't keep the list around; i.e. some variant of the second way (I have been known to use a genex in the <code>for</code> before, to get rid of the <code>if</code>).</span>
<span class="comment-copy">+1 a filter() would do indeed</span>
<span class="comment-copy">@Joachim Sauer:   Example 2 above.  A proper, explicit, non-list-comprehension loop.  Explicit.  Clear.  Obvious.</span>
<span class="comment-copy">@Paul: I think it should be. And indeed you can, though <code>map</code> may not be as intuitive if one hasn't done functional programming before.</span>
<span class="comment-copy">Not sure this is especially idiomatic. There's no advantage over using the explicit loop.</span>
<span class="comment-copy">Solution is <code>consume = collections.deque(maxlen=0).extend</code></span>
<span class="comment-copy">I would go even further and state that side effects inside a list comprehension are unusual, unexpected, and therefore evil, even if you're using the resulting list when you're done.</span>
<span class="comment-copy">urw [XXXXXXXXXX]</span>
<span class="comment-copy">Your lambda is much better written as <code>lambda x : x &gt; 3</code>.</span>
<span class="comment-copy">-1: Unreadable and (much less important) inefficient.</span>
<span class="comment-copy">+1 for <code>filter</code></span>
<span class="comment-copy">You don't even need filter. Just put a generator expression in parens here: <code>for el in (x for x in y if x &gt; 3):</code>. <code>el</code> and <code>x</code> can have the same name, but that might confuse people.</span>
<span class="comment-copy">What if <code>fun_with_side_effects</code> returns True?</span>
<span class="comment-copy">@katrielalex: <i>grin</i> Already fixed. I noticed it myself.</span>
<span class="comment-copy">I think this cure is worse than the disease - itertools.consume is much cleaner.</span>
<span class="comment-copy">@PaulMcG - <code>itertools.consume</code> no longer exists, probably because using comprehensions with side-effects is ugly.</span>
<span class="comment-copy">It turns out I was mistaken, and it <i>never</i> existed as a method in the stdlib. It <i>is</i> a recipe in the itertools docs: <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools#itertools-recipes" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
