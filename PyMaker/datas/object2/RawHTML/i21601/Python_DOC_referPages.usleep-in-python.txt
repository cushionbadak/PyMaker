<div class="post-text" itemprop="text">
<p>I was searching for a usleep() function in Python 2.7.</p>
<p>Does anybody know if it does exist, maybe with another function name?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>usleep</code> generally means you want to delay execution for x microseconds, you must divide the seconds value by 1000000.</p>
<pre><code>import time
time.sleep(seconds/1000000.0)
</code></pre>
<p><code>time.sleep()</code> takes seconds as a parameter.</p>
<p><a href="http://docs.python.org/library/time.html#time.sleep" rel="noreferrer">http://docs.python.org/library/time.html#time.sleep</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import time
usleep = lambda x: time.sleep(x/1000000.0)

usleep(100) #sleep during 100μs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from time import sleep
sleep(0.1) #sleep during 100ms
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Be very very careful with time.sleep.  I got burned by python3 using time.sleep because it is non-monotonic.  If the wall clock changes backwards, the time.sleep call won't finish until the wall clock catches up with where it would have been if the sleep had gone forward as planned.  I have not yet found a monotonic blocked sleep for python.</p>
<p>Instead, I recommend Event.wait, like this:</p>
<pre><code>def call_repeatedly(interval, func, *args, **kwargs):
    stopped = Event()
    def loop():
        while not stopped.wait(interval):  # the first call is in `interval` secs
            try:
                func(*args)
            except Exception as e:
                logger.error(e);
                if kwargs.get('exception'):
                    kwargs.get('exception')(e) # SEND exception to the specified function if there is one.
                else:
                    raise Exception(e)
    Thread(target=loop).start()
    return stopped.set
</code></pre>
<p><a href="http://pastebin.com/0rZdY8gB" rel="nofollow">http://pastebin.com/0rZdY8gB</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from time import sleep
sleep(seconds)
</code></pre>
<p><a href="http://docs.python.org/library/time.html#time.sleep" rel="nofollow">More info</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternate sleep function for python.</p>
<p>Note: Should not be used for multiple threads due to GIL lock, but for multiple subprocesses its fine. Same with time.sleep()</p>
<p>I'm wrapping a C function to Python. I'm using nanosleep() of C library, which halts that thread running for that much amount of time. It is not a busy-wait type of delay which uses much CPU to evaluate some math. The codes are as follows. Put all in a folder, say CWrapper.</p>
<p>C_functions.h</p>
<pre><code>#include &lt;time.h&gt;
int c_sleep_msec(long milliseconds);
int c_sleep_nsec(long nanoseconds);
</code></pre>
<p>C_functions.c</p>
<pre><code>#include "C_functions.h"
int c_sleep_msec(long milliseconds) {
    struct timespec req;
    //struct timespec rem;
    if(milliseconds &gt; 999) {
      req.tv_sec = (int)(milliseconds / 1000);  /* Must be Non-Negative */
      req.tv_nsec = (milliseconds - ((long)req.tv_sec * 1000)) * 1000000; /* Must be in range of 0 to 999999999 */
    }
    else {
      req.tv_sec = 0;                         /* Must be Non-Negative */
      req.tv_nsec = milliseconds * 1000000;    /* Must be in range of 0 to 999999999 */
    }
    //rem = NULL;
    return nanosleep(&amp;req , NULL);
}
//------------------------------------------------------
int c_sleep_nsec(long nanoseconds) {
    struct timespec req;
    //struct timespec rem;
    if (nanoseconds &gt; 999999999) {
      req.tv_sec = (int)(nanoseconds / 1000000000);
      req.tv_nsec = (nanoseconds - ((long)req.tv_sec * 1000000000));
    }
    else {
      req.tv_sec = 0;
      req.tv_nsec = nanoseconds;
    }
    //rem = NULL;
    return nanosleep(&amp;req , NULL);
}
</code></pre>
<p>You can also create a function for micro seconds using the same nanosleep()</p>
<p>CWrapper.pyx</p>
<pre><code>cdef extern from "C_functions.h":
    int c_sleep_msec(long milliseconds)
    int c_sleep_nsec(long nanoseconds)

def sleep_msec(milliseconds):
    return c_sleep_msec(milliseconds)

def sleep_nsec(nanoseconds):
    return c_sleep_nsec(nanoseconds)
</code></pre>
<p>setup.py</p>
<pre><code>from distutils.core import setup
from distutils.extension import Extension
from Pyrex.Distutils import build_ext

setup(
  name = "CWrapper",
  ext_modules=[ Extension("CWrapper", ["CWrapper.pyx", "C_functions.c"]) ],
  cmdclass = {'build_ext': build_ext}
)
</code></pre>
<p>Install python-pyrex. Then run in linux terminal</p>
<pre><code>python setup.py build_ext -i
</code></pre>
<p>It will create CWrapper.c, build, and CWrapper.so files. Use CWrapper.so where ever you want, and just import in python.</p>
<p>Note: Compile separately for Raspberry Pi.</p>
<p>Now, test the function</p>
<p>Test_sleep.py</p>
<pre><code>import serial
from multiprocessing import Process
import time
import CWrapper


class TestSleep:
    def __init__(self):
        self.delay_sec = 0.00000100
        self.delay_msec = 30
        self.delay_nsec = 1000 #200000000
        self.start_time = time.time()

        self.process_1 = Process(name="process_1", target=self.process_1_task, args=("process_1",))
        self.process_1.daemon = True
        self.process_1.start()

        self.process_2 = Process(name="process_2", target=self.process_1_task, args=("process_2",))
        self.process_2.daemon = True
        self.process_2.start()

        self.process_3 = Process(name="process_3", target=self.process_1_task, args=("process_3",))
        self.process_3.daemon = True
        self.process_3.start()

    def process_1_task(self, process_name):
        start = self.start_time
        delay_msec = self.delay_msec
        delay_sec = self.delay_sec
        delay_nsec = self.delay_nsec

        t1 = start
        for i in range(1, 81):
            status = CWrapper.sleep_msec(delay_msec)
            # status = CWrapper.sleep_nsec(delay_nsec)
            #status = time.sleep(delay_sec)
            t2 = time.time()
            elapsed_time = t2 - t1
            t1 = t2
            print process_name, i, "status:", status, "Elapsed-time:", elapsed_time


if __name__ == '__main__':
    test = TestSleep()
    # for i in range(1,10000):
    #     print "main thread", i
        # time.sleep(0.1)
    while True:    # Since daemon=True, main thread should check join() or stay in loop
        pass
</code></pre>
<p>Vary the parameters delay_sec for time.sleep(), delay_msec for CWrapper.sleep_msec(), delay_nsec for CWrapper.sleep_nsec(). Uncomment the function which you want to test in thread_1_task().</p>
</div>
<div class="post-text" itemprop="text">
<p>how about this:</p>
<pre><code>import time
def usleep(delay):
   mdelay = delay /1000
   now = time.time()
   while now + mdelay &gt; time.time():
      pass
</code></pre>
</div>
<span class="comment-copy">Careful, read up on the <a href="http://stackoverflow.com/questions/1133857/how-accurate-is-pythons-time-sleep">accuracy of sleep()</a></span>
<span class="comment-copy">mind to add code?</span>
<span class="comment-copy">Sure, I'd love to:<a href="http://pastebin.com/0rZdY8gB" rel="nofollow noreferrer">http://pastebin.com/0rZdY8gB</a></span>
<span class="comment-copy">I believe <code>time.sleep</code> should now be monotonic in Python 3; at least, the <a href="https://github.com/python/cpython/blob/v3.6.3/Modules/timemodule.c#L1430" rel="nofollow noreferrer">source code</a> says <code>_PyTime_GetMonotonicClock()</code> to get the current time. I can't say for sure what the past behavior was like.</span>
<span class="comment-copy">I don't see any python doc. reference that says <i>time.sleep</i> is monotonic. The time module in Python3 has the function <code>monotonic</code> which gives monotonic time. <a href="https://docs.python.org/3/library/time.html#time.monotonic" rel="nofollow noreferrer">docs.python.org/3/library/time.html#time.monotonic</a></span>
<span class="comment-copy">So this is where you copied this post? Your example is still abusing threads (both busy spinning and preventing them from running) so the comparison doesn't hold up. When addressing a perceived issue, please define it better than "improper".</span>
<span class="comment-copy">As for your proof, it's not sleep that busy waits, it's still your main thread; the routines you wrote just stop <i>all</i> Python threads.</span>
<span class="comment-copy">Please read <a href="http://docs.cython.org/en/latest/src/userguide/external_C_code.html#acquiring-and-releasing-the-gil" rel="nofollow noreferrer">docs.cython.org/en/latest/src/userguide/…</a></span>
<span class="comment-copy">My application need was independent sleep operation in each thread</span>
<span class="comment-copy">Sleep performance improvement of my function is negligible for milli seconds range as compared to python's time.sleep(). Problems was in threads.</span>
<span class="comment-copy">You consume 100% CPU until the delay is over? This is what developers did in the MSDOS days, please don't do this on modern multitasking systems. With <code>time.sleep()</code> you tell the OS kernel to leave your process in a pause until the timeout is complete, so all other processes can just do their work instead.</span>
<span class="comment-copy">This might consume 100% of the CPU but at least it is far more accurate than sleep. If you have to sleep a lot to keep a timing, e.g. when bitbanging a protocol on a Rapsberry Pi time.sleep() is sometimes WAY of (I am talking about a factor 20!)</span>
<span class="comment-copy">By keeping CPU 100% loaded you can actually slow down clock if your clocksource is affected by system load and drop of voltage... Bear that in mind you will lose not only sleeping precision that way</span>
