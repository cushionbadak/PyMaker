<div class="post-text" itemprop="text">
<p>I want to create a decorator that profiles a method and logs the result. How can this be done?</p>
</div>
<div class="post-text" itemprop="text">
<p>The decorator would look something like:</p>
<pre><code>import time
import logging

def profile(func):
    def wrap(*args, **kwargs):
        started_at = time.time()
        result = func(*args, **kwargs)
        logging.info(time.time() - started_at)
        return result

    return wrap

@profile
def foo():
    pass
</code></pre>
<p>Anyway, if you want to do some serious profiling I would suggest you use the profile or cProfile packages.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want proper profiling instead of timing, you can use an undocumented feature of <code>cProfile</code> (from <a href="https://stackoverflow.com/questions/1584425/return-value-while-using-cprofile">this question</a>):</p>
<pre><code>import cProfile

def profileit(func):
    def wrapper(*args, **kwargs):
        datafn = func.__name__ + ".profile" # Name the data file sensibly
        prof = cProfile.Profile()
        retval = prof.runcall(func, *args, **kwargs)
        prof.dump_stats(datafn)
        return retval

    return wrapper

@profileit
def function_you_want_to_profile(...)
    ...
</code></pre>
<p>If you want more control over the file name then you will need another layer of indirection:</p>
<pre><code>import cProfile

def profileit(name):
    def inner(func):
        def wrapper(*args, **kwargs):
            prof = cProfile.Profile()
            retval = prof.runcall(func, *args, **kwargs)
            # Note use of name from outer scope
            prof.dump_stats(name)
            return retval
        return wrapper
    return inner

@profileit("profile_for_func1_001")
def func1(...)
    ...
</code></pre>
<p>It looks complicated, but if you follow it step by step (and note the difference in invoking the profiler) it should become clear.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a decorator with two parameters, the profile output's file name, and the field to sort by the results. The default value is the cumulative time, which is useful to find bottlenecks.</p>
<pre><code>def profileit(prof_fname, sort_field='cumtime'):
    """
    Parameters
    ----------
    prof_fname
        profile output file name
    sort_field
        "calls"     : (((1,-1),              ), "call count"),
        "ncalls"    : (((1,-1),              ), "call count"),
        "cumtime"   : (((3,-1),              ), "cumulative time"),
        "cumulative": (((3,-1),              ), "cumulative time"),
        "file"      : (((4, 1),              ), "file name"),
        "filename"  : (((4, 1),              ), "file name"),
        "line"      : (((5, 1),              ), "line number"),
        "module"    : (((4, 1),              ), "file name"),
        "name"      : (((6, 1),              ), "function name"),
        "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
        "pcalls"    : (((0,-1),              ), "primitive call count"),
        "stdname"   : (((7, 1),              ), "standard name"),
        "time"      : (((2,-1),              ), "internal time"),
        "tottime"   : (((2,-1),              ), "internal time"),
    Returns
    -------
    None

    """
    def actual_profileit(func):
        def wrapper(*args, **kwargs):
            prof = cProfile.Profile()
            retval = prof.runcall(func, *args, **kwargs)
            stat_fname = '{}.stat'.format(prof_fname)
            prof.dump_stats(prof_fname)
            print_profiler(prof_fname, stat_fname, sort_field)
            print('dump stat in {}'.format(stat_fname))
            return retval
        return wrapper
    return actual_profileit


def print_profiler(profile_input_fname, profile_output_fname, sort_field='cumtime'):
    import pstats
    with open(profile_output_fname, 'w') as f:
        stats = pstats.Stats(profile_input_fname, stream=f)
        stats.sort_stats(sort_field)
        stats.print_stats()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you've understood how to write a decorator for cProfile, consider using <a href="https://docs.python.org/3/library/functools.html?highlight=functools%20wraps#functools.wraps" rel="nofollow noreferrer">functools.wraps</a>.</p>
<p>Simply adds one line can help you debugging decorators much easier. Without the use of functools.wraps, the name of the decorated function would have been 'wrapper', and the docstring of would have been lost.</p>
<p>So the improved version would be</p>
<pre><code>import cProfile
import functools

def profileit(func):
    @functools.wraps(func)  # &lt;-- Changes here.
    def wrapper(*args, **kwargs):
        datafn = func.__name__ + ".profile" # Name the data file sensibly
        prof = cProfile.Profile()
        retval = prof.runcall(func, *args, **kwargs)
        prof.dump_stats(datafn)
        return retval

    return wrapper

@profileit
def function_you_want_to_profile(...)
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like the answer of @detly. But sometimes its a problem to use <strong>SnakeViz</strong> to view the result.</p>
<p>I made a slightly different version that writes the result as text to the same file:</p>
<pre><code>import cProfile, pstats, io

def profileit(func):
    def wrapper(*args, **kwargs):
        datafn = func.__name__ + ".profile" # Name the data file sensibly
        prof = cProfile.Profile()
        retval = prof.runcall(func, *args, **kwargs)
        s = io.StringIO()
        sortby = 'cumulative'
        ps = pstats.Stats(prof, stream=s).sort_stats(sortby)
        ps.print_stats()
        with open(datafn, 'w') as perf_file:
            perf_file.write(s.getvalue())
        return retval

    return wrapper

@profileit
def function_you_want_to_profile(...)
    ...
</code></pre>
<p>I hope this helps someone...</p>
</div>
<span class="comment-copy">What do you mean by "profiles"? Timing? Or locating code to optimize? If the latter, <a href="http://stackoverflow.com/questions/4295799/how-to-improve-performance-of-this-code/4299378#4299378">try this</a>.</span>
<span class="comment-copy">Isn't this what was asked? He never asked anything about timing. He did ask about profiling.</span>
<span class="comment-copy">Presumably import time, not timeit.</span>
<span class="comment-copy">It's not very clear what some_variation_on is. I figured its a file as dump_stats takes a file? But it looks like a method.</span>
<span class="comment-copy">@lacks - it's just a hypothetical function that takes the name of the function and turns it into a filename, eg. <code>func.__name__ + .profile</code>. It doesn't have to be anything.</span>
<span class="comment-copy">You could make this clearer, as its calling a method outside the scope that could be anything and its not even clear that its going to be a filename until you actually know what its doing! Putting a string here or a comment explaining would be alot more helpful!</span>
<span class="comment-copy">How do you read the <code>.profile</code> file? It doesn't appear to be text.</span>
<span class="comment-copy">The canonical means of visualizing profile files as of 2016 is <b><a href="https://jiffyclub.github.io/snakeviz/" rel="nofollow noreferrer">SnakeViz</a>,</b> the Python 3-compatible successor to <a href="http://www.vrplumber.com/programming/runsnakerun/" rel="nofollow noreferrer">RunSnakeRun</a>. (You know... <i>just sayin'.</i>)</span>
