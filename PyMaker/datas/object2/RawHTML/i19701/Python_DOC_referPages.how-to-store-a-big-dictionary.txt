<div class="post-text" itemprop="text">
<p>I have a big dictionary(28 MB) 'MyDict' stored in a <code>MyDict.py</code> file.</p>
<p>If I execute the statement:</p>
<pre><code>from MyDict import MyDict
</code></pre>
<p>A <code>MemoryError</code> exception is thrown.</p>
<p>How can I access this dictionary using <code>cPickle</code> or <code>shelve</code> modules.</p>
<p>How can I write this <code>MyDict.py</code> file to <code>cPickle</code> or <code>shelve</code> without accessing MyDict.</p>
<p>This MyDict is generated by writing into a file.
Here is a key-value pair from the dictionary:</p>
<pre><code>{"""ABCD""" : [[(u'2011-03-21', 35.5, 37.5, 35.3, 35.85, 10434.0, 35.85), (u'2012-03-03', 86.0, 87.95, 85.55, 86.2, 30587.0, 86.2), (u'2011-03-23', 36.9, 36.9, 35.25, 36.1, 456.0, 36.1)],
    [(u'2011-03-18', 37.0, 38.0, 36.5, 36.5, 861.0, 36.5), (u'2012-03-03', 86.0, 87.95, 85.55, 86.2, 30587.0, 86.2), (u'2011-03-21', 35.5, 37.5, 35.3, 35.85, 10434.0, 35.85)],
    [(u'2011-03-16', 37.0, 37.9, 36.3, 36.7, 3876.0, 36.7), (u'2012-03-03', 86.0, 87.95, 85.55, 86.2, 30587.0, 86.2), (u'2011-03-21', 35.5, 37.5, 35.3, 35.85, 10434.0, 35.85)],
    [(u'2010-12-09', 40.5, 41.95, 36.3, 36.75, 42943.0, 36.75), (u'2011-10-26', 67.95, 71.9, 66.45, 70.35, 180812.0, 70.35), (u'2011-03-21', 35.5, 37.5, 35.3, 35.85, 10434.0, 35.85)],
    [(u'2009-01-16', 14.75, 15.0, 14.0, 14.15, 14999.0, 14.05), (u'2010-01-11', 50.0, 52.8, 49.0, 50.95, 174826.0, 50.95), (u'2009-01-27', 14.3, 15.0, 13.9, 14.15, 3862.0, 14.15)]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>shelve</code> is actually a pretty good choice here. It acts just like a dictionary, but it's backed by a BDB (or similar) key-value database file, and Python will handle all the caching, etc., so it doesn't need to load the whole thing into memory at once.</p>
<p>Here's how to create the shelve file. Note that shelf keys have to be strings. Also note that I'm creating the shelf in-place, rather than first creating a <code>dict</code> and shelving it. That way you avoid the cost of having to build that giant in-memory <code>dict</code> that was causing problems in the first place.</p>
<pre><code>from contextlib import closing
import shelve

def makedict(shelf):
    # Put the real dict-generating code here, obviously
    for i in range(500000);
        shelf[str(i)] = i

with closing(shelve.open('mydict.shelf', 'c')) as shelf:
    makedict(shelf)
</code></pre>
<p>And to use it, don't actually read it in; leave it as an on-disk shelf:</p>
<pre><code>from contextlib import closing
import shelve

with closing(shelve.open('mydict.shelf')) as d:
    # Put all your actual work here.
    print len(d)
</code></pre>
<p>If your dictionary-using code doesn't fit easily into a scope, replace the <code>with</code> statement with a plain <code>open</code>, and explicitly <code>close</code> it when you're done.</p>
<p><code>pickle</code> is probably not as good of an idea, because you still have to read the whole thing into memory. It will probably use a lot less transient memory, and maybe disk space, than importing a module that defines a giant literal, but still, having an in-memory hash table that huge could still be a problem. But you can always test it and see how well it works.</p>
<p>Here's how to create the pickle file. Note that you can use (nearly) anything you want as a key, not just strings. However, you have to build the whole <code>dict</code> before you can <code>pickle</code> it.</p>
<pre><code>import cPickle

def makedict():
    # Put the real dict-generating code here, obviously
    return {i:i for i in range(500000)}

with open('mydict.pickle', 'wb') as f:
    cPickle.dump(d, f, -1)
</code></pre>
<p>This creates a 47MB file.</p>
<p>Now, to use it in your main app:</p>
<pre><code>import cPickle

def loaddict():
    with open('mydict.pickle', 'rb') as f:
        return cPickle.load(f)
</code></pre>
<p>The same basic problems with <code>pickle</code> go for any other persistence format that has to be saved and loaded—whether something custom that you write yourself, or something standard like JSON or YAML. (Of course if you need interoperability with other programs, especially in other languages, something like JSON is the way to go.) You're better off with a database; the only question is, what kind of database.</p>
<p>The advantage of an <code>anydbm</code> type database is that you can use it as if it were a <code>dict</code>, without worrying about how to load/save/access it (other than the <code>open</code> and <code>close</code> lines). The problem with <code>anydbm</code> is that it only lets you map strings to strings.</p>
<p>The <code>shelve</code> module effectively wraps <code>anydbm</code>, with pickling of each value. Your keys still have to be strings, but your values can be almost anything. So as long as your keys are strings, and you don't have any references from the values to external objects, it's a pretty transparent drop-in replacement for a <code>dict</code>.</p>
<p>The other options—<code>sqlite3</code>, various modern nosql databases, etc.—require you to change the way you access data, and even the way you organize it. (A "list of lists" isn't a clear ER model.) Of course in the long run, this might result in a better design, so if you think you really should be using a relational model, consider this idea.</p>
<hr/>
<p>From the comments, @ekta wanted me to explain why some of the restrictions on <code>dbm</code> and <code>shelve</code> exist.</p>
<p>First, <code>dbm</code> goes back to the 70s. A database that could map 8-bit strings to strings simply and efficiently was a pretty huge deal back then. It was also pretty common for values of all kinds to be stored as their string representation—or, if not that, then just storing the bytes that happen to represent the value natively on the current machine. (XML, JSON, or even endianness-swapping may have been too expensive for the machines of the day, or at least the thinking of the day.)</p>
<p>Extending <code>dbm</code> to handle other data types for the values isn't hard. They never need to be hashed or compared, just stored and retrieved losslessly. Since <code>pickle</code> can handle a very wide variety of types, isn't too horribly inefficient, and comes with Python, it makes sense to use <code>pickle</code> for that, so <code>shelve</code> does exactly that.</p>
<p>But the keys are a different story. You need an encoding that's not only losslessly reversible, but also ensures that two values will encode to equal bytes if and only if they're actually equal. Keep in mind that in Python, <code>1 == True</code>, but obviously <code>pickle.dumps(1) != pickle.dumps(True)</code>, <code>b'1' != b'True'</code>, etc.</p>
<p>There are plenty of types that can be losslessly and equality-preservingly converted to bytes if you only care about that type. For example, for Unicode strings, just use UTF-8. (Actually, <code>shelve</code> takes care of that one for you.) For 32-bit signed integers, use <code>struct.pack('&gt;I')</code>. For tuples of three strings, encode to UTF-8, backslash-escape, and join them with newlines. And so on. For many specific domains, there's an easy answer; there's just no general-purpose answer that works for most domains.</p>
<p>So, if you want to use a <code>dbm</code> to use, say, tuples of three UTF-8 strings as keys, you can write your own wrapper around <code>dbm</code> (or <code>shelve</code>). As with many modules in the stdlib, <code>shelve</code> is intended to be helpful sample code as well as a usable feature, which is why <a href="https://docs.python.org/3/library/shelve.html" rel="nofollow">the docs</a> have a link to <a href="http://hg.python.org/cpython/file/default/Lib/shelve.py" rel="nofollow">the source</a>. It's simple enough that a novice should be able to figure out how to either fork it, subclass it, or wrap it to do his own custom key encoding. (Note that if you wrap <code>shelve</code>, you will have to encode your custom values to <code>str</code> just so it can encode that <code>str</code> to <code>bytes</code>; if you fork it, or subclass it and override the relevant methods, you can instead encode directly to <code>bytes</code>—e.g., that <code>struct.pack</code> call above. This may be better for both simplicity/readability and performance.)</p>
</div>
<span class="comment-copy">Have you tried storing the big dictionary in a separate text file using JSON?</span>
<span class="comment-copy">Perhaps a database would be better suited for storing data of that size or use a text format</span>
<span class="comment-copy">Can you post us an excerpt or two from this file?  Depending on how close the file is to valid JSON you may be able to open the file for reading and parse it iteratively to write values out to another file that's more accessible in the future.</span>
<span class="comment-copy">Well, shelve actually <i>is</i> a DB. Yes, it's a BDB, rather than, say, a sqlite DB, but that may actually be better for the OP's use case.</span>
<span class="comment-copy">@g.d.d.c The dictionary values contain list of lists</span>
<span class="comment-copy">I think the trouble is not so much how to use cPickle (though it's possible) and more that he's getting a memory error before he can reach your <code>return</code> line.  Also, you don't need context lib to use <code>with</code> and a <code>shelve</code>.  They provide <code>__enter__</code> and <code>__exit__</code> on their own.</span>
<span class="comment-copy">@g.d.d.c: <code>shelve</code> objects don't provide an <code>__exit__</code> in either 2.7 or 3.3, so you <i>do</i> need <code>contextlib</code>. But for your other point, you're right, it probably makes more sense to make the shelf directly than to create the <code>dict</code> and then <code>shelve</code> it. I'll edit the answer.</span>
<span class="comment-copy">@ekta: As for performance, it actually depends on how you're using them. Of course you can hash a medium-sized int faster than a medium-sized string, but if you have <i>very</i> short strings, or huge ints, that's no longer true. Also, if you're passing around the same string object (rather than independent strings that happens to be equal), the hash value will get cached, making it faster than hashing a mid-sized int.</span>
<span class="comment-copy">@ekta: There's really no such thing as a "1-digit floating number". For example, <code>1.1</code> cannot be exactly represented by a <code>float</code>; try <code>format(1.1, '.50')</code> to see what you've really got. If you want exact values for 1-decimal-digit numbers, use <code>decimal.Decimal</code> (or a third-party or custom fixed-point type), not <code>float</code>. (See <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="nofollow noreferrer">What Every Computer Scientist Should Know About Floating-Point</a> for more.)</span>
<span class="comment-copy">@ekta: Meanwhile, instead of trying to build a string representation for a pair of two floats and then encode it to UTF-8, and reverse it by decoding and parsing, it might be worth finding a better representation. For example, <code>struct.pack('&gt;dd')</code> will convert two <code>float</code> values into 16 bytes, and <code>struct.unpack</code> will get them back. (But again, <code>float</code> may be a mistake.)</span>
