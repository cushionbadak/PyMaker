<div class="post-text" itemprop="text">
<p>There is a json like this:</p>
<pre><code>{
  "P1": "ss",
  "Id": 1234,
  "P2": {
      "P1": "cccc"
  },
  "P3": [
      {
          "P1": "aaa"
      }
  ]
}
</code></pre>
<p>How can I find all <code>P1</code>'s value without it iterating all json?</p>
<p>PS:<code>P1</code> can be anywhere in json.</p>
<p>If no method can do this, can you tell me how to iterate through the json?</p>
</div>
<div class="post-text" itemprop="text">
<p>My approach to this problem would be different.</p>
<p>As JSON doesn't allow depth first search, so convert the json to a Python Object, feed it to an XML decoder and then extract the Node you are intending to search</p>
<pre><code>from xml.dom.minidom import parseString
import json        
def bar(somejson, key):
    def val(node):
        # Searches for the next Element Node containing Value
        e = node.nextSibling
        while e and e.nodeType != e.ELEMENT_NODE:
            e = e.nextSibling
        return (e.getElementsByTagName('string')[0].firstChild.nodeValue if e 
                else None)
    # parse the JSON as XML
    foo_dom = parseString(xmlrpclib.dumps((json.loads(somejson),)))
    # and then search all the name tags which are P1's
    # and use the val user function to get the value
    return [val(node) for node in foo_dom.getElementsByTagName('name') 
            if node.firstChild.nodeValue in key]

bar(foo, 'P1')
[u'cccc', u'aaa', u'ss']
bar(foo, ('P1','P2'))
[u'cccc', u'cccc', u'aaa', u'ss']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As I said in my other answer, I don't think there is a way of finding all values associated with the <code>"P1"</code> key without iterating over the whole structure. However I've come up with even better way to do that which came to me while looking at the <a href="https://stackoverflow.com/a/6633651/355230">accepted answer</a> to a different question <a href="https://stackoverflow.com/questions/956867/how-to-get-string-objects-instead-of-unicode-from-json"><strong>How to get string objects instead of Unicode from JSON?</strong></a></p>
<p>The basic idea is to use the <code>object_hook</code> parameter that <code>json.loads()</code> accepts just to watch what is being decoded and check for the sought-after value. <strong>Note:</strong> This will only work if the representation is of a JSON <code>Object</code> (i.e. something enclosed in curly braces <code>{}</code>), as in your sample json.</p>
<pre><code>import json

def find_values(id, json_repr):
    results = []

    def _decode_dict(a_dict):
        try: results.append(a_dict[id])
        except KeyError: pass
        return a_dict

    json.loads(json_repr, object_hook=_decode_dict)  # Return value ignored.
    return results

json_repr = '{"P1": "ss", "Id": 1234, "P2": {"P1": "cccc"}, "P3": [{"P1": "aaa"}]}'
print find_values('P1', json_repr)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>[u'cccc', u'aaa', u'ss']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had the same issue just the other day. I wound up just searching through the entire object and accounted for both lists and dicts. The following snippets allows you to search for the <em>first</em> occurrence of a multiple keys.</p>
<pre><code>import json

def deep_search(needles, haystack):
    found = {}
    if type(needles) != type([]):
        needles = [needles]

    if type(haystack) == type(dict()):
        for needle in needles:
            if needle in haystack.keys():
                found[needle] = haystack[needle]
            elif len(haystack.keys()) &gt; 0:
                for key in haystack.keys():
                    result = deep_search(needle, haystack[key])
                    if result:
                        for k, v in result.items():
                            found[k] = v
    elif type(haystack) == type([]):
        for node in haystack:
            result = deep_search(needles, node)
            if result:
                for k, v in result.items():
                    found[k] = v
    return found

deep_search(["P1", "P3"], json.loads(json_string))
</code></pre>
<p>It returns a dict with the keys being the keys searched for. Haystack is expected to be a Python object already, so you have to do json.loads before passing it to deep_search.</p>
<p>Any comments for optimization are welcomed!</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>json</code> to convert the json to Python objects and then going through recursively works best.  This example <em>does</em> include going through lists.</p>
<pre><code>import json
def get_all(myjson, key):
    if type(myjson) == str:
        myjson = json.loads(myjson)
    if type(myjson) is dict:
        for jsonkey in myjson:
            if type(myjson[jsonkey]) in (list, dict):
                get_all(myjson[jsonkey], key)
            elif jsonkey == key:
                print myjson[jsonkey]
    elif type(myjson) is list:
        for item in myjson:
            if type(item) in (list, dict):
                get_all(item, key)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Converting the JSON to Python and recursively searching is by far the easiest:</p>
<pre><code>def findall(v, k):
  if type(v) == type({}):
     for k1 in v:
         if k1 == k:
            print v[k1]
         findall(v[k1], k)

findall(json.loads(a), 'P1')
</code></pre>
<p>(where a is the string)</p>
<p>The example code ignores arrays.  Adding that is left as an exercise.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there's any way of finding all values associated with P1 without iterating over the whole structure. Here's a recursive way to do it that first deserializes the json object in a file into an equivalent Python object. To simplify things most of the work is done via a private nested function.</p>
<pre><code>def find_values(id, obj):
    results = []

    def _find_values(id, obj):
        try:
            for key, value in obj.iteritems():
                if key == id:
                    results.append(value)
                elif not isinstance(value, basestring):
                    _find_values(id, value)
        except AttributeError:
            pass

        try:
            for item in obj:
                if not isinstance(item, basestring):
                    _find_values(id, item)
        except TypeError:
            pass

    if not isinstance(obj, basestring):
        _find_values(id, obj)
    return results

import json

with open('data.json') as json_file:
    obj = json.load(json_file)

print find_values('P1', obj)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Bearing in mind that json is simply a string, using regular expressions with look-ahead and look-behind can accomplish this task very quickly.</p>
<p>Typically, the json would have been extracted from a request to external api, so code to show how that would work has been included but commented out.</p>
<pre><code>import re
#import requests
#import json

#r1 = requests.get( ... url to some api ...)
#JSON = str(json.loads(r1.text))
JSON = """
 {
  "P1": "ss",
  "Id": 1234,
  "P2": {
      "P1": "cccc"
  },
  "P3": [
     {
          "P1": "aaa"
     }
  ]
 }
"""
rex1  = re.compile('(?&lt;=\"P1\": \")[a-zA-Z_\- ]+(?=\")')
rex2 = rex1.findall(JSON)  
print(rex2)

#['ss', 'cccc', 'aaa']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also use a generator to search the object after json.load().</p>
<p>Code example from my answer here: <a href="https://stackoverflow.com/a/39016088/5250939">https://stackoverflow.com/a/39016088/5250939</a></p>
<pre><code>def item_generator(json_input, lookup_key):
    if isinstance(json_input, dict):
        for k, v in json_input.iteritems():
            if k == lookup_key:
                yield v
            else:
                for child_val in item_generator(v, lookup_key):
                    yield child_val
    elif isinstance(json_input, list):
        for item in json_input:
            for item_val in item_generator(item, lookup_key):
                yield item_val
</code></pre>
</div>
<span class="comment-copy">If it can be anywhere in the set of nested structures, then you're going to have to look through all of it. That's just how reality works.</span>
<span class="comment-copy">Maybe this is what you need? <a href="https://www.p6r.com/articles/2008/05/06/xslt-and-xpath-for-json/" rel="nofollow noreferrer">p6r.com/articles/2008/05/06/xslt-and-xpath-for-json</a></span>
<span class="comment-copy">Thanks, that what i want!</span>
<span class="comment-copy">What is <code>xmlrpclib</code>? I think python 3 doesn't support it. I am getting error.</span>
<span class="comment-copy">@JafferWilson: The <a href="https://docs.python.org/2/library/xmlrpclib.html" rel="nofollow noreferrer">Python 2 documentation</a> says "The <code>xmlrpclib</code> module has been renamed to <code>xmlrpc.client</code> in Python 3." The Python 3 documentation for it being <a href="https://docs.python.org/3/library/xmlrpc.client.html" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">unfortunately, it seems to be working only when the value is string or I am doing something wrong.</span>
<span class="comment-copy">@viveksinghggits: In python there is no json data type. You have to pass the json as string.</span>
<span class="comment-copy">I know that this is an old answer but I just wanted to say that I adapted your solution by checking <code>len(needles) == len(found)</code> in both loops to cut the execution short in the case that I had already found all keys.</span>
<span class="comment-copy">You code can not find key in array.</span>
<span class="comment-copy">@lichengwu -- As I wrote, "The example code ignores arrays. Adding that is left as an exercise."  Add an <code>elif</code>.</span>
