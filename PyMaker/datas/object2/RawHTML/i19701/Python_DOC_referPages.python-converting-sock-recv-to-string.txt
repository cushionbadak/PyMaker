<div class="post-text" itemprop="text">
<p>I'm digging around with python and networking.</p>
<pre><code>while True:
   data = sock.recv(10240)
</code></pre>
<p>This is definitely listening.  But it seems to need to be converted to a text string.</p>
<p>I've seen some people using <strong>struct.unpack()</strong>, but I'm not sure exactly how it works.
What's the way to convert? </p>
</div>
<div class="post-text" itemprop="text">
<p>What you get back from <a href="http://docs.python.org/3/library/socket.html#socket.socket.recv" rel="noreferrer"><code>recv</code></a> is a <code>bytes</code> string:</p>
<blockquote>
<p>Receive data from the socket. The return value is a bytes object representing the data received.</p>
</blockquote>
<p>In Python 3.x, to convert a <a href="http://docs.python.org/3/library/stdtypes.html#bytes" rel="noreferrer"><code>bytes</code></a> string into a Unicode text <a href="http://docs.python.org/3/library/stdtypes.html#str" rel="noreferrer"><code>str</code></a> string, you have to know what character set the string is encoded with, so you can call <a href="http://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="noreferrer"><code>decode</code></a>. For example, if it's UTF-8:</p>
<pre><code>stringdata = data.decode('utf-8')
</code></pre>
<p>(In Python 2.x, <code>bytes</code> is the same thing as <code>str</code>, so you've already <em>got</em> a string. But if you want to get a Unicode text <code>unicode</code> string, it's the same as in 3.x.)</p>
<p>The reason people often use <a href="http://docs.python.org/3/library/struct.html" rel="noreferrer"><code>struct</code></a> is that the data isn't just 8-bit or Unicode text, but some other format. For example, you might send each message as a "<a href="http://en.wikipedia.org/wiki/Netstring" rel="noreferrer">netstring</a>": a length (as a string of ASCII digits) followed by a <code>:</code> separator, then <code>length</code> bytes of UTF-8, then a <code>,</code>—such as <code>b"3:Abc,"</code>. (There are variants on the format, but this is the Bernstein standard netstring.)</p>
<p>The reason people use netstrings, or other similar techniques, is that you need some way to delimit messages when you're using TCP. Each <code>recv</code> could give you half of what the other side passed with <code>send</code>, or it could give your 3 <code>send</code>s and part of the 4th. So, you have to accumulate a buffer of <code>recv</code> data, and then pull the messages out of it. And you need some way to tell when one message ends and the next begins. If you're just sending plain text messages without any newlines, you can just use newlines as a delimiter. Otherwise, you'll have to come up with something else—maybe netstrings, or using <code>\0</code> as a delimiter, or using newlines as a delimiter but escaping actual newlines within the data, or using some self-delimited structured format like JSON.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.7.x and before, <code>data</code> is already a string.  In Python 3.x, <code>data</code> is a bytes object.  TO convert bytes to string, use the <code>decode()</code> method.  <code>decode()</code> will require a codec argument, like 'utf-8'.</p>
</div>
<span class="comment-copy">What version of python are you using?  The answer will be different for 2.x versus 3.x.</span>
<span class="comment-copy">Version 3.3.0  As I understand it, the 2.x is different than 3.x in certain networking functionalities</span>
<span class="comment-copy">@coffeemonitor: It's not all that different in networking functionalities—but it's pretty different in text-handling functionalities, which is why Joshua D. Boyd asked that question.</span>
<span class="comment-copy">And it works! The recv just needed that conversion. I assume if I'm to send data back to it's source, I'll have to encode it?</span>
<span class="comment-copy">@coffeemonitor: Exactly, if you've got a string, encode it and <code>send</code> the results.</span>
<span class="comment-copy">@abarnert could you mind sharing exactly how to determine if a message ends with half a codepoint (the other half being in the next message). For example,  if you are reading from a socket, and you know it will be utf-8, how can you know when to use .decode() on the bytes when you don't know if the last byte is a valid utf-8 codepoint..</span>
