<div class="post-text" itemprop="text">
<p>I'm using python3.3.
I want to get a <code>slice</code> object and use it to make a new <code>range</code> object.</p>
<p>It goes something like that:</p>
<pre><code>&gt;&gt;&gt; class A:
    def __getitem__(self, item):
        if isinstance(item, slice):
            return list(range(item.start, item.stop, item.step))

&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a[1:5:2] # works fine
[1, 3]
&gt;&gt;&gt; a[1:5] # won't work :(
Traceback (most recent call last):
  File "&lt;pyshell#18&gt;", line 1, in &lt;module&gt;
    a[1:5] # won't work :(
  File "&lt;pyshell#9&gt;", line 4, in __getitem__
    return list(range(item.start, item.stop, item.step))
TypeError: 'NoneType' object cannot be interpreted as an integer
</code></pre>
<p>Well, the problem is obvious here - <code>range</code> doesn't accept <code>None</code> as a value:</p>
<pre><code>&gt;&gt;&gt; range(1, 5, None)
Traceback (most recent call last):
  File "&lt;pyshell#19&gt;", line 1, in &lt;module&gt;
    range(1, 5, None)
TypeError: 'NoneType' object cannot be interpreted as an integer
</code></pre>
<p>But what is not obvious (to me) is the solution. How will I call <code>range</code> so it will work in every case?
I'm searching for a nice pythonic way to do it.</p>
<p>Thanks :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Try</p>
<pre><code>class A:
    def __getitem__(self, item):
        ifnone = lambda a, b: b if a is None else a
        if isinstance(item, slice):
            if item.stop is None:
                # do something with itertools.count()
            else:
                return list(range(ifnone(item.start, 0), item.stop, ifnone(item.step, 1)))
        else:
            return item
</code></pre>
<p>This will reinterpret <code>.start</code> and <code>.step</code> appropriately if they are <code>None</code>.</p>
<hr/>
<p>Another option could be the <code>.indices()</code> method of a slice. It is called with the number of entries and reinterprets <code>None</code> to the appropriate values and wraps negative values around the given length parameter:</p>
<pre><code>&gt;&gt;&gt; a=slice(None, None, None)
&gt;&gt;&gt; a.indices(1)
(0, 1, 1)
&gt;&gt;&gt; a.indices(10)
(0, 10, 1)
&gt;&gt;&gt; a=slice(None, -5, None)
&gt;&gt;&gt; a.indices(100)
(0, 95, 1)
</code></pre>
<p>It depends what you intend to do with negative indices...</p>
</div>
<div class="post-text" itemprop="text">
<p>There's an easier way to do this (at least in 3.4, I don't have 3.3 at the moment, and I don't see it in the changelog).</p>
<p>Assuming your class already has a known length you can just slice a range of that size:</p>
<pre><code>&gt;&gt;&gt; range(10)[1:5:2]
range(1, 5, 2)
&gt;&gt;&gt; list(range(10)[1:5:2])
[1, 3]
</code></pre>
<p>If you don't know the length a priori you'll have to do:</p>
<pre><code>&gt;&gt;&gt; class A:
    def __getitem__(self, item):
        if isinstance(item, slice):
            return list(range(item.stop)[item])
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a[1:5:2]
[1, 3]
&gt;&gt;&gt; a[1:5]
[1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>The problem:</h2>
<p>A slice consists of <code>start</code>, <code>stop</code>, and <code>step</code> parameters and can be created with either <a href="https://stackoverflow.com/questions/509211/explain-pythons-slice-notation">slice notation</a> or using the <code>slice</code> <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer"> built-in</a>.  Any (or all) of the <code>start</code>, <code>stop</code>, and <code>step</code> parameters can be <code>None</code>.</p>
<pre><code># valid
sliceable[None:None:None]

# also valid
cut = slice(None, None, None)
sliceable[cut]
</code></pre>
<p>However, as pointed out in the original question, the <code>range</code> function does not accept <code>None</code> arguments.  You can get around this in various ways...</p>
<h2>The solutions</h2>
<h3>With conditional logic:</h3>
<pre><code>if item.start None:
    return list(range(item.start, item.stop))
return list(range(item.start, item.stop, item.step))
</code></pre>
<p>...which can get unnecessarily complex since any or all of the parameters may be <code>None</code>.</p>
<h3>With conditional variables:</h3>
<pre><code>start = item.start if item.start is None else 0
step = item.step if item.step is None else 1
return list(range(item.start, item.stop, item.step))
</code></pre>
<p>... which is explicit, but a little verbose.</p>
<h3>With conditionals directly in the statement:</h3>
<pre><code>return list(range(item.start if item.start else 0, item.stop, item.step if item.step else 1))
</code></pre>
<p>... which is also unnecessarily verbose.</p>
<h3>With a function or lambda statement:</h3>
<pre><code>ifnone = lambda a, b: b if a is None else a
range(ifnone(item.start, 0), item.stop, ifnone(item.step, 1)
</code></pre>
<p>...which can be difficult to understand.</p>
<h3>With 'or':</h3>
<pre><code>return list(range(item.start or 0, item.stop or len(self), item.step or 1))
</code></pre>
<p>I find using <code>or</code> to assign sensible default values the simplest. It's explicit, simple, clear, and concise.</p>
<h2>Rounding out the implementation</h2>
<p>To complete the implementation you should also handle integer indexes (<code>int</code>, <code>long</code>, etc) by checking <code>isinstance(item, numbers.Integral)</code> (see <a href="https://stackoverflow.com/questions/8203336/difference-between-int-and-numbers-integral-in-python">int vs numbers.Integral</a>).</p>
<p>Define <code>__len__</code> to allow for using <code>len(self)</code> for a default stop value.</p>
<p>Finally raise an appropriate <code>TypeError</code> for invalid indexes (e.g. strings, etc).</p>
<h2>TL;DR;</h2>
<pre><code>class A:
    def __len__(self):
        return 0

    def __getitem__(self, item):
        if isinstance(item, numbers.Integral):  # item is an integer
            return item
        if isinstance(item, slice):  # item is a slice
            return list(range(item.start or 0, item.stop or len(self), item.step or 1))
        else:  # invalid index type
            raise TypeError('{cls} indices must be integers or slices, not {idx}'.format(
                cls=type(self).__name__,
                idx=type(item).__name__,
            ))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would special-case the <code>item.step is None</code> branch:</p>
<pre><code>def __getitem__(self, item):
    if isinstance(item, slice):
        if item.step is None:
            return list(range(item.start, item.stop))
        return list(range(item.start, item.stop, item.step))
</code></pre>
<p>and you'll handle ranges that need to count down correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your last example <code>a[1:5]</code>, <code>item.step == None</code> and you are trying to do <code>range(1, 5, None)</code>, which of course causes the error. Fast way to fix:</p>
<pre><code>class A:
    def __getitem__(self, item):
        if isinstance(item, slice):
            return list(range(item.start, item.stop, item.step if item.step else 1)) #Changed line!
</code></pre>
<p>But it is just to show you your problem. It is not the best approach.</p>
</div>
<span class="comment-copy">Does it help that in Python 3 you can slice a <code>range</code> object to get a new <code>range</code> object?</span>
<span class="comment-copy">For those looking for a simple and more general answer, from <a href="https://stackoverflow.com/users/7510791/labrys-knossos">Labrys Knossos</a>'s answer below: <code>range(item.start or 0, item.stop or len(self), item.step or 1)</code>.  Replace <code>len(self)</code> as needed if not in a class with <code>__len__</code> defined.</span>
<span class="comment-copy">That's really cool! How the hell did you find this old question? :)</span>
<span class="comment-copy">Well, I was looking to do a similar thing (actually looking for the length of a slice into a range of known length). Came across this question, and then figured out how to do it myself.</span>
<span class="comment-copy">this is a fantastic little trick.</span>
<span class="comment-copy">This is fantastic. One thing I want to note is that <code>list(range(10)[0:20])</code> does not throw an error, which could be problematic!</span>
<span class="comment-copy">Fails in the case of <code>slice(0, None, 1)</code> with <code>TypeError: 'NoneType' object cannot be interpreted as an integer</code>. You should check for None and hanle the case. glglgl proposes using <code>itertools.count()</code>.</span>
<span class="comment-copy">Great explanation and one-liner.</span>
<span class="comment-copy">/!\ <i>or</i> in case item.step is 0.</span>
<span class="comment-copy">That's cool, but <code>item.start</code> can  be <code>None</code> too, and I think that too many <code>if</code>s in the code can make it look pretty ugly, so i used in the <code>indices</code> method that suggested in another answer.</span>
<span class="comment-copy">@slallum: The <code>start = item.start if item.start is not None else 0</code> conditional expression might work well enough for that (then use <code>range(start, item.stop ..</code>).</span>
<span class="comment-copy">What if <code>stop</code> is lower than <code>start</code>? Then step should be <code>-1</code>!</span>
<span class="comment-copy">@MartijnPieters - then it wouldn't return anything, as expected, like slice works in lists.</span>
<span class="comment-copy">@slallum: but this is a range. Lists may <i>interpret</i> the slice as an empty list, but in a range a stop lower than start results in an automatic <code>-1</code> step.</span>
<span class="comment-copy">@MartijnPieters - Are you sure? I have python3.3 and python2.7 and in both of them <code>list(range(7,2))</code> returns an empty list..</span>
<span class="comment-copy">@slallum: golly, not sure how I got the idea it'd automatically deal with the right <code>step</code> there then. Shows you how often I used a negative range..</span>
