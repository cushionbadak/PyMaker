<div class="post-text" itemprop="text">
<p>Does range function allows concatenation ? Like i want to make a <code>range(30)</code> &amp; concatenate it with <code>range(2000, 5002)</code>.  So my concatenated range will be <code>0, 1, 2, ... 29, 2000, 2001,  ... 5001</code> </p>
<p>Code like this does not work on my latest python (ver: 3.3.0)</p>
<pre><code>range(30) + range(2000, 5002)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a> for this:</p>
<pre><code>from itertools import chain
concatenated = chain(range(30), range(2000, 5002))
for i in concatenated:
     ...
</code></pre>
<p>It works for arbitrary iterables. Note that there's a difference in behavior of <a href="http://docs.python.org/3/library/functions.html#func-range" rel="noreferrer"><code>range()</code></a> between Python 2 and 3 that you should know about: in Python 2 <a href="http://docs.python.org/2/library/functions.html#range" rel="noreferrer"><code>range</code></a> returns a list, and in Python3 an iterator, which is memory-efficient, but not always desirable.</p>
<p>Lists can be concatenated with <code>+</code>, iterators cannot.</p>
</div>
<div class="post-text" itemprop="text">
<p>Can be done using <a href="http://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list-comprehension</a>.</p>
<pre><code>&gt;&gt;&gt; [i for j in (range(10), range(15, 20)) for i in j]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 15, 16, 17, 18, 19]
</code></pre>
<p>Works for your request, but it is a long answer so I will not post it here.</p>
<p>note: can be made into a generator for increased performance:</p>
<pre><code>for x in (i for j in (range(30), range(2000, 5002)) for i in j):
    # code
</code></pre>
<p>or even into a generator variable.</p>
<pre><code>gen = (i for j in (range(30), range(2000, 5002)) for i in j)
for x in gen:
    # code
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like the most simple solutions that are possible (including efficiency). It is not always clear whether the solution is such. Anyway, the <code>range()</code> in Python 3 is a generator. You can wrap it to any construct that does iteration. The <code>list()</code> is capable of construction of a list value from any iterable. The <code>+</code> operator for lists does concatenation. I am using smaller values in the example:</p>
<pre><code>&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]
&gt;&gt;&gt; list(range(10, 20))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
&gt;&gt;&gt; list(range(5)) + list(range(10,20))
[0, 1, 2, 3, 4, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<p>This is what <code>range(5) + range(10, 20)</code> exactly did in Python 2.5 -- because <code>range()</code> returned a list.</p>
<p>In Python 3, it is only useful if you really want to construct the list. Otherwise, I recommend the <a href="https://stackoverflow.com/a/14099894/1346705">Lev Levitsky's</a> solution with <a href="http://docs.python.org/3.3/library/itertools.html#itertools.chain" rel="noreferrer">itertools.chain</a>. The documentation also shows the very straightforward implementation:</p>
<pre><code>def chain(*iterables):
    # chain('ABC', 'DEF') --&gt; A B C D E F
    for it in iterables:
        for element in it:
            yield element
</code></pre>
<p>The solution by <a href="https://stackoverflow.com/a/14100069/1346705">Inbar Rose</a> is fine and functionally equivalent. Anyway, my +1 goes to Lev Levitsky and to his argument about using the standard libraries. From <em>The Zen of Python</em>...</p>
<blockquote>
<p>In the face of ambiguity, refuse the temptation to guess.</p>
</blockquote>
<pre><code>#!python3
import timeit
number = 10000

t = timeit.timeit('''\
for i in itertools.chain(range(30), range(2000, 5002)):
    pass
''',
'import itertools', number=number)
print('itertools:', t/number * 1000000, 'microsec/one execution')

t = timeit.timeit('''\
for x in (i for j in (range(30), range(2000, 5002)) for i in j):
    pass
''', number=number)
print('generator expression:', t/number * 1000000, 'microsec/one execution')
</code></pre>
<p>In my opinion, the <code>itertools.chain</code> is more readable. But what really is important...</p>
<pre><code>itertools: 264.4522138986938 microsec/one execution
generator expression: 785.3081048010291 microsec/one execution
</code></pre>
<p>... it is about 3 times faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>With the help of the extend method, we can concatenate two lists.</p>
<pre><code>&gt;&gt;&gt; a = list(range(1,10))
&gt;&gt;&gt; a.extend(range(100,105))
&gt;&gt;&gt; a  
[1, 2, 3, 4, 5, 6, 7, 8, 9, 100, 101, 102, 103, 104]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>range()</code> in Python 2.x returns a list:</p>
<pre><code>&gt;&gt;&gt; range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p><code>xrange()</code> in Python 2.x returns an iterator:</p>
<pre><code>&gt;&gt;&gt; xrange(10)
xrange(10)
</code></pre>
<p>And in Python 3 <code>range()</code> also returns an iterator:</p>
<pre><code>&gt;&gt;&gt; r = range(10)
&gt;&gt;&gt; iterator = r.__iter__()
&gt;&gt;&gt; iterator.__next__()
0
&gt;&gt;&gt; iterator.__next__()
1
&gt;&gt;&gt; iterator.__next__()
2
</code></pre>
<p>So it is clear that you can not concatenate iterators other by using <code>chain()</code> as the other guy pointed out.</p>
</div>
<div class="post-text" itemprop="text">
<p>I came to this question because I was trying to concatenate an unknown number of ranges, that might overlap, and didn't want repeated values in the final iterator. My solution was to use <code>set</code> and the <a href="https://docs.python.org/3.5/library/stdtypes.html?highlight=set#set.union" rel="nofollow"><code>union</code></a> operator like so:</p>
<pre><code>range1 = range(1,4)
range2 = range(2,6)
concatenated = set.union(set(range1), set(range2)
for i in concatenated:
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this is a bit old thread, but for me, the following works.</p>
<pre><code>&gt;&gt;&gt; for i in range(30) + range(2000, 5002):
...    print i
</code></pre>
<p>So does this </p>
<pre><code>&gt;&gt;&gt; for i in range(30) , range(2000, 5002):
...  print i
</code></pre>
<p>Of course the print output is different in the 2nd from the 1st.</p>
<p>Edit: I missed the follow-up comment form the OP stating python 3. This is in my python 2 environment.</p>
</div>
<span class="comment-copy">python version?</span>
<span class="comment-copy">the version of my python is  version 3.3.0 .. i have also updated in my question</span>
<span class="comment-copy">What do you want to get as a result (as in, what type of data - a plain list, a generator, something else)? What do you want to do with the result?</span>
<span class="comment-copy">+1 for no additional dependencies</span>
<span class="comment-copy">@mkind thanks, i hate dependencies, people always jump and answer with tons of imports and libraries, but they are not always available, and they often times do the same thing that normal code does, only wrapped in a package, its not magic. :)</span>
<span class="comment-copy">I don't think that <i>not using standard libraries</i> is a virtue on its own, but this is a nice answer.</span>
<span class="comment-copy">@inbar, you're right. two additional advantage are that you know what the code does and that you are learning something about the problem.</span>
<span class="comment-copy">@mkind and Inbar Rose: Hating dependencies may be OK, but the <code>itertools</code> module is the standard one. Because of its more efficient implementation, the solution with <code>itertools.chain</code> is about 3 times faster -- see <a href="http://stackoverflow.com/a/14101734/1346705">stackoverflow.com/a/14101734/1346705</a>. The moral is: <i>"Never say never!"</i></span>
<span class="comment-copy">this is great, i will admit defeat by efficiently built standard library modules. but your timing is strange, on my machine after numerous tests, i found that my solution is only about 1.8 times slower, as opposed to 3 times slower. but it is still slower.</span>
<span class="comment-copy">It is definitely hardware dependent and could be also OS dependent. I did use my rather obsolete computer with AMD Athlon 64 X2 Dual Core Processor 3800+ at 2.01 GHz, with 3 GB of memory. The OS is Windows 7 Home Premium 64 bit (both processor and memory score is only 4,9 -- <a href="http://windows.microsoft.com/en-US/windows7/What-is-the-Windows-Experience-Index" rel="nofollow noreferrer">windows.microsoft.com/en-US/windows7/â€¦</a>). I am not sure about the Python implementation. Say, you may have more processor cores.</span>
<span class="comment-copy">This is for Python 2, the OP uses Python 3.</span>
<span class="comment-copy">Extend is not a keyword, it is a method on Python lists.</span>
<span class="comment-copy">your answer is helpful, but does not provide a solution.</span>
