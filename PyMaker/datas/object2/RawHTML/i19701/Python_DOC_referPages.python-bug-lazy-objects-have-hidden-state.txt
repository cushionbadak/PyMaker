<div class="post-text" itemprop="text">
<p>Consider this (Python 3.3):</p>
<pre><code>a=enumerate([2,3,5])
print(list(a))
print(list(a))
</code></pre>
<p>Do you really expect two print calls to print different things?
Neither did I.</p>
<p>The same thing happens if you replace list with <code>set</code>, <code>tuple</code> or <code>dict</code>. It also happens if you replace <code>enumerate</code> object with <code>map</code> or <code>filter</code>, but curiously, not if you replace it with <code>range</code>.</p>
<p>Maybe it is a feature. But it's very surprising, not documented (at least I haven't been able to find anything about it), and not consistent (range works differently). What do you think?</p>
</div>
<div class="post-text" itemprop="text">
<p>The behaviour is documented at <a href="http://docs.python.org/3/glossary.html#term-iterator" rel="nofollow">http://docs.python.org/3/glossary.html#term-iterator</a></p>
<blockquote>
<p>One notable exception is code which attempts multiple iteration
  passes. ... Attempting this with an iterator will just return the same
  exhausted iterator object used in the previous iteration pass, making
  it appear like an empty container.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>enumerate()</code> returns an iterator, as do the other calls.. You can only loop through an iterator once; it is then exhausted.</p>
<p>You can create such an iterator yourself with a generator function:</p>
<pre><code>def somelist_generator():
    somelist = [1, 2, 3]
    while somelist:
        yield somelist.pop()
</code></pre>
<p>If you were to loop over <code>somelist_generator()</code>, the list <code>somelist</code> would be emptied. You can only do that once, since <code>.pop()</code> removes elements:</p>
<pre><code>&gt;&gt;&gt; it = somelist_generator()
&gt;&gt;&gt; for i in it:
...     print(i)
... 
3
2
1
&gt;&gt;&gt; next(it)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>The <code>next()</code> call tries to get another value from the <code>it</code> iterator; it is already empty so the <code>StopIteration</code> exception is raised. That exception signals there are no more elements to be gotten, and that's why you end up with an empty list the second time you try and get anything from an iterator:</p>
<pre><code>&gt;&gt;&gt; list(it)
[]
</code></pre>
<p><code>range()</code> does <em>not</em> return an iterator. It returns a <a href="http://docs.python.org/3/library/stdtypes.html#ranges" rel="nofollow">range object</a> instead, which represents a memory-efficient series of numbers; only the start, end and stride need to be stored and everything else can be derived from those 3 points.</p>
</div>
<span class="comment-copy">I really expect the two print calls to print different things.</span>
<span class="comment-copy">Ah, I see. I have confused iterators with iterables. Iterators are kinda iterables, but only once. :-) That's too bad for the code I'm writing... I suppose there is no nice way iterators can be "rewound"?</span>
<span class="comment-copy">If you want to rewind an iterator then you should convert it to a list and use that instead. If the iterator is too large (or even infinite) to convert to a list then there is no general way to rewind it.</span>
<span class="comment-copy">You could probably build a structure that allows you to "step back" only once or twice. A limited rewind if you will</span>
