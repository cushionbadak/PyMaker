<div class="post-text" itemprop="text">
<p>I 'm trying to solve <a href="http://projecteuler.net/problem=240" rel="nofollow">Project Euler problem 240</a>:</p>
<blockquote>
<p><strong>In how many ways can twenty 12-sided dice (sides numbered 1 to 12) be rolled so that the top ten sum to 70?</strong></p>
</blockquote>
<p>I've come up with code to solve this. But it really takes a lot of time to compute. I know this approach is pretty bad. Can someone suggest me how I can fix this code to perform better?</p>
<pre><code>import itertools
def check(a,b):   # check all the elements in a list a, are lesser than or equal to value b
    chk=0
    for x in a:
        if x&lt;=b:
            chk=1
    return chk

lst=[]
count=0
for x in itertools.product(range(1,13),repeat=20):
    a=sorted([x[y] for y in range(20)])
    if sum(a[-10:])==70 and check(a[:10],min(a[-10:])):
        count+=1
</code></pre>
<p>Below code is for the problem defined in the description of the <a href="http://projecteuler.net/problem=240" rel="nofollow">problem</a>. It works perfectly and gives the exact solution....</p>
<pre><code>import itertools
def check(a,b):
     chk=1
     for x in a:
         if x&gt;b:
             chk=0
             break
     return chk


count=0
for x in itertools.product(range(1,7),repeat=5):
    a=sorted([x[y] for y in range(5)])
    if sum(a[-3:])==15 and check(a[:2],min(a[-3:])):
        count+=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's no good iterating over all possibilities, because there are 12<sup>20</sup> = 3833759992447475122176 ways to roll 20 twelve-sided dice, and at, say, a million rolls per second, that would take millions of years to complete.</p>
<p>The way to solve this kind of problem is to use <a href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="nofollow noreferrer">dynamic programming</a>. Find some way to split up your problem into the sum of several smaller problems, and build up a table of the answers to these sub-problems until you can compute the result you need.</p>
<p>For example, let T(<em>n</em>, <em>d</em>, <em>k</em>, <em>t</em>) be the number of ways to roll <em>n</em> <i>d</i>-sided dice so that the top <em>k</em> of them sum to <em>t</em>. How can we split this up into sub-problems? Well, we could consider the number of dice, <em>i</em>, that roll <em>d</em> exactly. There are <sup><em>n</em></sup>C<sub><em>i</em></sub> ways to choose these <em>i</em> dice, and T(<em>n</em> − <em>i</em>, <em>d</em> − 1, ...) ways to choose the <em>n</em> − <em>i</em> remaining dice which must roll at most <em>d</em> − 1. (For some suitable choice of parameters for <em>k</em> and <em>t</em> which I've elided.)</p>
<p>Take the product of these, and sum it up for all suitable values of <em>i</em> and you're done. (Well, not quite done: you have to specify the base cases, but that should be easy.)</p>
<p>The number of sub-problems that you need to compute will be at most (<em>n</em> + 1)(<em>d</em> + 1)(<em>k</em> + 1)(<em>t</em> + 1), which in the Project Euler case (<em>n</em> = 20, <em>d</em> = 12, <em>k</em> = 10, <em>t</em> = 70) is at most 213213. (In practice, it's much less than this, because many branches of the tree reach base cases quickly: in my implementation it turns out that the answers to just 791 sub-problems are sufficient to compute the answer.)</p>
<p>To write a dynamic program, it's usually easiest to express it recursively and use <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memoization</a> to avoid re-computing the answer to sub-problems. In Python you could use the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>@functools.lru_cache</code> decorator</a>.</p>
<p>So the skeleton of your program could look like this. I've replaced the crucial details by <code>???</code> so as not to deprive you of the pleasure of working it out for yourself. Work with small examples (e.g. "two 6-sided dice, the top 1 of which sums to 6") to check that your logic is correct, before trying bigger cases.</p>
<pre><code>def combinations(n, k):
    """Return C(n, k), the number of combinations of k out of n."""
    c = 1
    k = min(k, n - k)
    for i in range(1, k + 1):
        c *= (n - k + i)
        c //= i
    return c

@lru_cache(maxsize=None)
def T(n, d, k, t):
    """Return the number of ways n distinguishable d-sided dice can be
    rolled so that the top k dice sum to t.

    """
    # Base cases
    if ???: return 1
    if ???: return 0

    # Divide and conquer. Let N be the maximum number of dice that
    # can roll exactly d.
    N = ???
    return sum(combinations(n, i)
               * T(n - i, d - 1, ???)
               for i in range(N + 1))
</code></pre>
<p>With appropriate choices for all the <code>???</code>, this answers the Project Euler problem in a few milliseconds:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; timeit(lambda:T(20, 12, 10, 70), number=1)
0.008017531014047563
&gt;&gt;&gt; T.cache_info()
CacheInfo(hits=1844, misses=791, maxsize=None, currsize=791)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this solution should work - not sure how long it will take on your system.</p>
<pre><code>from itertools import product

lg = (p for p in product(xrange(1,13,1),repeat=10) if sum(p) == 70)

results = {}
for l in lg:
    results[l] = [p for p in product(xrange(1,min(l),1),repeat=10)]
</code></pre>
<p>what it does is create the "top ten" first. then adds to each "top ten" a list of the possible "next ten" items where the max value is capped at the minimum item in the "top ten"</p>
<p>results is a dict where the <code>key</code> is the "top ten" and the value is a list of the possible "next ten"</p>
<p>the solution (amount of combinations that fit the requirements) would be to count the number of lists in all the result dict like this:</p>
<pre><code>count = 0
for k, v in results.items():    
    count += len(v)
</code></pre>
<p>and then <code>count</code> will be the result.</p>
<p><strong>update</strong></p>
<p>okay, i have thought of a slightly better way of doing this.</p>
<pre><code>from itertools import product
import math

def calc_ways(dice, sides, top, total):
    top_dice = (p for p in product(xrange(1,sides+1,1),repeat=top) if sum(p) == total)
    n_count = dict((n, math.pow(n, dice-top)) for n in xrange(1,sides+1,1))

    count = 0
    for l in top_dice:
        count += n_count[min(l)]

    return count
</code></pre>
<p>since im only counting the length of the "next ten" i figured i would just pre-calculate the amount of options for each 'lowest' number in "top ten" so i created a dictionary which does that. the above code will run much smoother, as it is comprised only of a small dictionary, a counter, and a generator. as you can imagine, it will probably still take much time.... but i ran it for the first 1 million results in under 1 minute. so i'm sure its within the feasible range.</p>
<p>good luck :)</p>
<p><strong>update 2</strong></p>
<p>after another comment by you, i understood what i was doing wrong and tried to correct it.</p>
<pre><code>from itertools import product, combinations_with_replacement, permutations
import math

def calc_ways(dice, sides, top, total):
    top_dice = (p for p in product(xrange(1,sides+1,1),repeat=top) if sum(p) == total)
    n_dice = dice-top
    n_sets = len(set([p for p in permutations(range(n_dice)+['x']*top)]))
    n_count = dict((n, n_sets*len([p for p in combinations_with_replacement(range(1,n+1,1),n_dice)])) for n in xrange(1,sides+1,1))

    count = 0
    for l in top_dice:
        count += n_count[min(l)]

    return count
</code></pre>
<p>as you can imagine it is quite a disaster, and does not even give the right answer. i think i am going to leave this one for the mathematicians. since my way of solving this would simply be:</p>
<pre><code>def calc_ways1(dice, sides, top, total):
    return len([p for p in product(xrange(1,sides+1,1),repeat=dice) if sum(sorted(p)[-top:]) == total])
</code></pre>
<p>which is an elegant 1 line solution, and provides the right answer for <code>calc_ways1(5,6,3,15)</code> but takes forever for the <code>calc_ways1(20,12,10,70)</code> problem.</p>
<p>anyway, math sure seems like the way to go on this, not my silly ideas.</p>
</div>
<span class="comment-copy">you should re-think the question. you have 20 slots, you need to fill them with numbers from 1-12 such that the 10 slots with the greatest numbers sum will add up to 70.  already we can reduce this, you have 10 slots, 1-12 = 70. and then for each solution you have 10 more slots which can be arranged such that none of their values are greater than any value in the solution slots. remember, the question is how many ways can this be done - so each solution 10, has many other slots that can be arranged in MANY different ways.</span>
<span class="comment-copy">Inbar,.. Initially i tested this code for simialr puzzle where in it was asked for 5 dices and sum of top three should be 15 and how many such combintaions? this code instantly gave out the solution as 1111 which is exactly correct. Now that the complexity has increased to 20 dices and also 12 faced.. it takes so much time.. i need an alternative approach or way it could be solved without brute force.</span>
<span class="comment-copy">i'l try it out Gareth .... thanks for your kind help.</span>
<span class="comment-copy">+1 for use memoize</span>
<span class="comment-copy">@Gareth : U r awesome :)</span>
<span class="comment-copy">@Gareth: i would need a little help on solving it via recursion...I tried hard to come up with a recursive way to find the combination of numbers to sum up to 70 for the said problem. I wasnt successful enuf...</span>
<span class="comment-copy">What have you got?</span>
<span class="comment-copy">Thanks Inbar for a quick response but i tried this divide and conquer approach.. Still it takes a long time...</span>
<span class="comment-copy">where u able to get the count in ur system?</span>
<span class="comment-copy">I tried this and it gave the wrong answer (82) for the smaller example in the <a href="http://projecteuler.net/problem=240" rel="nofollow noreferrer">problem description</a>.</span>
<span class="comment-copy">Gareth... can u try the code which i've put in the main description. It should give u 1111.  import itertools def check(a,b):      chk=1      for x in a:          if x&gt;b:              chk=0              break      return chk  lst=[] count=0 for x in itertools.product(range(1,6),repeat=5):     a=sorted([x[y] for y in range(5)])     if sum(a[-3:])==70 and check(a[:2],min(a[-10:])):         count+=1</span>
<span class="comment-copy">@Inbar: your revised code still gives the wrong answer (82) for the number of ways to roll 5 6-sided dice such that the top 3 sum to 15.</span>
