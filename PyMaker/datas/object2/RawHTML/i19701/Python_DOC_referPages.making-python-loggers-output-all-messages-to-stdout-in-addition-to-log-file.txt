<div class="post-text" itemprop="text">
<p>Is there a way to make Python logging using the <code>logging</code> module automatically output things to stdout <em>in addition</em> to the log file where they are supposed to go? For example, I'd like all calls to <code>logger.warning</code>, <code>logger.critical</code>, <code>logger.error</code> to go to their intended places but in addition always be copied to <code>stdout</code>. This is to avoid duplicating messages like:</p>
<pre><code>mylogger.critical("something failed")
print "something failed"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All logging output is handled by the handlers; just add a <a href="http://docs.python.org/library/logging.handlers.html#streamhandler" rel="noreferrer"><code>logging.StreamHandler()</code></a> to the root logger.</p>
<p>Here's an example configuring a stream handler (using <code>stdout</code> instead of the default <code>stderr</code>) and adding it to the root logger:</p>
<pre><code>import logging
import sys

root = logging.getLogger()
root.setLevel(logging.DEBUG)

handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
root.addHandler(handler)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the simplest way:</p>
<pre><code>import logging
import sys
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's possible using multiple handlers.</p>
<pre><code>import logging
import auxiliary_module

# create logger with 'spam_application'
log = logging.getLogger('spam_application')
log.setLevel(logging.DEBUG)

# create formatter and add it to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# create file handler which logs even debug messages
fh = logging.FileHandler('spam.log')
fh.setLevel(logging.DEBUG)
fh.setFormatter(formatter)
log.addHandler(fh)

# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.ERROR)
ch.setFormatter(formatter)
log.addHandler(ch)

log.info('creating an instance of auxiliary_module.Auxiliary')
a = auxiliary_module.Auxiliary()
log.info('created an instance of auxiliary_module.Auxiliary')

log.info('calling auxiliary_module.Auxiliary.do_something')
a.do_something()
log.info('finished auxiliary_module.Auxiliary.do_something')

log.info('calling auxiliary_module.some_function()')
auxiliary_module.some_function()
log.info('done with auxiliary_module.some_function()')

# remember to close the handlers
for handler in log.handlers:
    handler.close()
    log.removeFilter(handler)
</code></pre>
<p>Please see: <a href="https://docs.python.org/2/howto/logging-cookbook.html" rel="noreferrer">https://docs.python.org/2/howto/logging-cookbook.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could create two handlers for file and stdout and then create one logger with <code>handlers</code> argument to <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="noreferrer"><code>basicConfig</code></a>. It could be useful if you have the same log_level and format output for both handlers:</p>
<pre><code>import logging
import sys

file_handler = logging.FileHandler(filename='tmp.log')
stdout_handler = logging.StreamHandler(sys.stdout)
handlers = [file_handler, stdout_handler]

logging.basicConfig(
    level=logging.DEBUG, 
    format='[%(asctime)s] {%(filename)s:%(lineno)d} %(levelname)s - %(message)s',
    handlers=handlers
)

logger = logging.getLogger('LOGGER_NAME')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way to log to file and to stderr:</p>
<pre><code>  import logging
  logging.basicConfig(filename="logfile.txt")
  stderrLogger=logging.StreamHandler()
  stderrLogger.setFormatter(logging.Formatter(logging.BASIC_FORMAT))
  logging.getLogger().addHandler(stderrLogger)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since no one has shared a neat two liner, I will share my own:</p>
<pre><code>logging.basicConfig(filename='logs.log', level=logging.DEBUG, format="%(asctime)s:%(levelname)s: %(message)s")
logging.getLogger().addHandler(logging.StreamHandler())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution based on the <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" rel="nofollow noreferrer"><code>dictConfig</code> configuration function</a>.
Instead of sending every log message to stdout, it sends messages with log level ERROR and higher to stderr and everything else to stdout.
This can be useful if other parts of the system are listening to stderr/stdout.</p>
<pre><code>import logging
import logging.config
import sys

class _ExcludeErrorsFilter(logging.Filter):
    def filter(self, record):
        """Filters out log messages with log level ERROR (numeric value: 40) or higher."""
        return record.levelno &lt; 40


config = {
    'version': 1,
    'filters': {
        'exclude_errors': {
            '()': _ExcludeErrorsFilter
        }
    },
    'formatters': {
        'my_formatter': {
            'format': '(%(process)d) %(asctime)s %(name)s (line %(lineno)s) | %(levelname)s %(message)s'
        }
    },
    'handlers': {
        'console_stderr': {
            # Directs log messages with log level ERROR or higher to stderr
            'class': 'logging.StreamHandler',
            'level': 'ERROR',
            'formatter': 'my_formatter',
            'stream': sys.stderr
        },
        'console_stdout': {
            # Directs log messages with log level lower than ERROR to stdout
            'class': 'logging.StreamHandler',
            'level': 'DEBUG',
            'formatter': 'my_formatter',
            'filters': ['exclude_errors'],
            'stream': sys.stdout
        },
        'file': {
            # Directs all log messages to a file
            'class': 'logging.FileHandler',
            'level': 'DEBUG',
            'formatter': 'my_formatter',
            'filename': 'my.log',
            'encoding': 'utf8'
        }
    },
    'root': {
        'level': 'NOTSET',
        'handlers': ['console_stderr', 'console_stdout', 'file']
    },
}

logging.config.dictConfig(config)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a look to the <a href="https://github.com/Delgan/loguru" rel="nofollow noreferrer">loguru</a> module.</p>
<pre><code>from loguru import logger

logger.debug("That's it, beautiful and simple logging!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an extremely simple example:</p>
<pre><code>import logging
l = logging.getLogger("test")

# Add a file logger
f = logging.FileHandler("test.log")
l.addHandler(f)

# Add a stream logger
s = logging.StreamHandler()
l.addHandler(s)

# Send a test message to both -- critical will always log
l.critical("test msg")
</code></pre>
<p>The output will show "test msg" on stdout and also in the file.</p>
</div>
<span class="comment-copy">Please check this answer <a href="https://stackoverflow.com/questions/9321741/printing-to-screen-and-writing-to-a-file-at-the-same-time" title="printing to screen and writing to a file at the same time">stackoverflow.com/questions/9321741/â€¦</a></span>
<span class="comment-copy">That's fine but if it's already redirected to a file how can I have it be printed to <code>stdout</code> in addition?</span>
<span class="comment-copy">@user248237: By adding a <i>new</i> handler as illustrated. New handlers do not replace the existing handlers, they <i>also</i> get to process the log entries.</span>
<span class="comment-copy">@PrakharMohanSrivastava I'd guess you can just add it to the string passed into <code>logging.Formatter</code>.</span>
<span class="comment-copy">I'd suggest s/root/logger/g.</span>
<span class="comment-copy">@Dan: what difference does that make? It's just the variable holding a reference to the root logging object (hence the name).</span>
<span class="comment-copy">Hm, but this isn't logged to a file, right? The question was how to do logging to file <i>and</i> to console.</span>
<span class="comment-copy">This might not be what the OP was asking, but it's exactly what I was looking for and the first hit on Google. +1</span>
<span class="comment-copy">Probably the answer you need, but not what asked for  :-P</span>
<span class="comment-copy">@TaylorEdmiston Yeah, but it's the stderr stream AFAIK. Try redirecting the output from the shell.</span>
<span class="comment-copy">This is by far the best answer that did not answer the question. : )</span>
<span class="comment-copy">Wonderful answer, albeit a bit messy. Love how you show how to use different levels and formats for streams and files. +1, but +2 in spirit.</span>
<span class="comment-copy">IMHO the best answer.  It is good formatted, easy to understand, the code is not too long, covers the whole question and .. is correct!</span>
<span class="comment-copy">This doesn't show labels INFO, DEBUG, and ERROR before the logging message in the console. It does show those labels in the file. Any ideas to also show the labels in the console ?</span>
<span class="comment-copy">Thanks, @JahMyst, I added the Formatter. Unfortunately, it's not so short any longer, but still the simplest way. :-)</span>
<span class="comment-copy">Thanks, that's great !</span>
