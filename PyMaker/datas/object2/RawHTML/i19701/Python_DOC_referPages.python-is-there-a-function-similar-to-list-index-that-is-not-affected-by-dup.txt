<div class="post-text" itemprop="text">
<p><code>list.index()</code> will give you the index of the first time the value is shown in the list, but I am looking for a way  that will return the index of that specific item, regardless of whether it is repeated, for example, if  were to use it like so:</p>
<pre><code>lst = [1,4,5,1,4]

for i in lst:
    lst.something(i)
</code></pre>
<p>would return</p>
<pre><code>0
1
2
3
4
</code></pre>
<p>Any help appreciated</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you looking for <a href="http://docs.python.org/3/library/functions.html?highlight=enumerate#enumerate"><code>enumerate</code></a>?</p>
<pre><code>&gt;&gt;&gt; lst = [1,4,5,1,4]
&gt;&gt;&gt; for index, elm in enumerate(lst):
...  print index, elm
...
0 1
1 4
2 5
3 1
4 4
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use enumerate</p>
<pre><code>for i,_ in enumerate(listt):
    print i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, it's not possible for <code>lst.something(1)</code> to know whether to return 0 or 3 depending on which 1 it was called with. <code>int</code> is a primitive type, so any <code>1</code> is just the same as another <code>1</code>.</p>
<p>As proof, you can use the <code>is</code> operator:</p>
<pre><code>lst = [1, 4, 5, 1, 4]
print lst[0] is lst[3]
# True
</code></pre>
<p>So when the hypothetical function <code>lst.something(1)</code> is called, it won't know which <code>1</code> you meant, regardless of how you called it.</p>
</div>
<span class="comment-copy">No, it's not possible for <code>lst.something(1)</code> to know whether to return <code>0</code> or <code>3</code> depending on <i>which</i> <code>1</code> it was called with. <code>int</code> is a primitive type, so <code>1</code> is just the same as another <code>1</code>.</span>
<span class="comment-copy">Is there no way for a for loop to know what item it is currently performing the function on? If there is, can it not return that value?</span>
<span class="comment-copy">In that case, you want <code>enumerate</code> (see @D.Shawley's answer below)</span>
<span class="comment-copy">Would I be right in saying that enumerate only works with iterations? Is there a similar function I can use that doesn't require it to be part of a loop?</span>
<span class="comment-copy">Yes, enumerate works only with iterations. What you're asking for isn't possible; please see my answer.</span>
<span class="comment-copy">I don't think this is the question- I think the question is for <code>lst.something(lst[0])</code> to return <code>0</code>, and <code>lst.something(lst[3])</code> to return <code>3</code>, which isn't possible.</span>
<span class="comment-copy">@DavidRobinson - Of course it's not possible, but usually it's because the OP is looking for the functionality behind enumerate in whatever they're doing.</span>
<span class="comment-copy">@DavidRobinson If you read the reply to your comment on the OP, I think you're wrong. :)</span>
<span class="comment-copy">You're right- nice!</span>
<span class="comment-copy">@DavidRobinson Yes, that is what I was looking for actually; so there is no way to achieve that? Even by defining a new function?</span>
<span class="comment-copy">I'd prefer <code>in range(len(listt))</code></span>
<span class="comment-copy">Even if <code>is</code> <i>didn't</i> return <code>True</code> -- say for two distinct but equal <code>int</code> objects -- you'd still be right.  I think equality is the right condition, not identity.  <code>enumerate</code> is the right way to get as close as we can in practice, but the fact that there's not going to be a way to tell which element we're referring to is inescapable.  (Assuming random access, anyway: we could make a stateful indexer which remembers where it was, or what it's yielded, etc, but I'd need to see a use case because I suspect there would be a simpler way to get there, wherever 'there' would be.)</span>
<span class="comment-copy">Note that your <code>is</code> test returning True is a CPython implementation detail; for larger values for <code>int()</code> that won't be true at all, in any Python implementation.</span>
