<div class="post-text" itemprop="text">
<p>In python how can we create a new object without having a predefined Class and later dynamically add properties to it ?</p>
<p>example: </p>
<pre><code>dynamic_object = Dynamic()
dynamic_object.dynamic_property_a = "abc"
dynamic_object.dynamic_property_b = "abcdefg"
</code></pre>
<p>What is the best way to do it?</p>
<p><strong>EDIT</strong> Because many people advised in comments that I might not need this. </p>
<p>The thing is that I have a function that serializes an object's properties. For that reason, I don't want to create an object of the expected class due to some constructor restrictions, but instead create a similar one, let's say like a <strong>mock</strong>, add any "custom" properties I need, then feed it back to the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just define your own class to do it:</p>
<pre><code>class Expando(object):
    pass

ex = Expando()
ex.foo = 17
ex.bar = "Hello"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using an object just to hold values isn't the most Pythonic style of programming. It's common in programming languages that don't have good associative containers, but in Python, you can use use a dictionary:</p>
<pre><code>my_dict = {} # empty dict instance

my_dict["foo"] = "bar"
my_dict["num"] = 42
</code></pre>
<p>You can also use a "dictionary literal" to define the dictionary's contents all at once:</p>
<pre><code>my_dict = {"foo":"bar", "num":42}
</code></pre>
<p>Or, if your keys are all legal identifiers (and they will be, if you were planning on them being attribute names), you can use the <code>dict</code> constructor with keyword arguments as key-value pairs:</p>
<pre><code>my_dict = dict(foo="bar", num=42) # note, no quotation marks needed around keys
</code></pre>
<p>Filling out a dictionary is in fact what Python is doing behind the scenes when you do use an object, such as in Ned Batchelder's answer. The attributes of his <code>ex</code> object get stored in a dictionary, <code>ex.__dict__</code>, which should end up being equal to an equivalent <code>dict</code> created directly.</p>
<p>Unless attribute syntax (e.g. <code>ex.foo</code>) is absolutely necessary, you may as well skip the object entirely and use a dictionary directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you take metaclassing approach from @Martijn's answer, @Ned's answer can be rewritten shorter (though it's obviously less readable, but does the same thing).</p>
<pre><code>obj = type('Expando', (object,), {})()
obj.foo = 71
obj.bar = 'World'
</code></pre>
<p>Or just, which does the same as above using <code>dict</code> argument:</p>
<pre><code>obj = type('Expando', (object,), {'foo': 71, 'bar': 'World'})()
</code></pre>
<p>For Python 3, passing object to <code>bases</code> argument is not necessary (see <a href="https://docs.python.org/3/library/functions.html#type" rel="noreferrer"><code>type</code> </a> documentation).</p>
<p>But for simple cases instantiation doesn't have any benefit, so is okay to do:</p>
<pre><code>ns = type('Expando', (object,), {'foo': 71, 'bar': 'World'})
</code></pre>
<p>At the same time, personally I prefer a plain class (i.e. without instantiation) for ad-hoc test configuration cases as simplest and readable: </p>
<pre><code>class ns:
    foo = 71
    bar = 'World'
</code></pre>
<h1>Update</h1>
<p>In Python 3.3+ there is <em>exactly</em> what OP asks for, <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer"><code>types.SimpleNamespace</code></a>. It's just:</p>
<blockquote>
<p>A simple <code>object</code> subclass that provides attribute access to its namespace, as well as a meaningful repr.</p>
<p>Unlike <code>object</code>, with <code>SimpleNamespace</code> you can add and remove attributes. If a <code>SimpleNamespace</code> object is initialized with keyword arguments, those are directly added to the underlying namespace. </p>
</blockquote>
<pre><code>import types
obj = types.SimpleNamespace()
obj.a = 123
print(obj.a) # 123
print(repr(obj)) # namespace(a=123)
</code></pre>
<p>However, in stdlib of both Python 2 and Python 3 there's <a href="https://docs.python.org/3/library/argparse.html#argparse.Namespace" rel="noreferrer"><code>argparse.Namespace</code></a>, which has the same purpose:</p>
<blockquote>
<p>Simple object for storing attributes.</p>
<p>Implements equality by attribute names and values, and provides a simple string representation.</p>
</blockquote>
<pre><code>import argparse
obj = argparse.Namespace()
obj.a = 123
print(obj.a) # 123 
print(repr(obj)) # Namespace(a=123)
</code></pre>
<p>Note that both can be initialised with keyword arguments:</p>
<pre><code>types.SimpleNamespace(a = 'foo',b = 123)
argparse.Namespace(a = 'foo',b = 123)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow"><code>collections.namedtuple()</code> class factory</a> to create a custom class for your return value:</p>
<pre><code>from collections import namedtuple
return namedtuple('Expando', ('dynamic_property_a', 'dynamic_property_b'))('abc', 'abcdefg')
</code></pre>
<p>The returned value can be used both as a tuple and by attribute access:</p>
<pre><code>print retval[0]                  # prints 'abc'
print retval.dynamic_property_b  # prints 'abcdefg'  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way that I found is also by creating a lambda. It can have sideeffects and comes with some properties that are not wanted. Just posting for the interest. </p>
<pre><code>dynamic_object = lambda:expando
dynamic_object.dynamic_property_a = "abc"
dynamic_object.dynamic_property_b = "abcdefg"
</code></pre>
</div>
<span class="comment-copy">What exactly is a "dynamic property"?  as in <code>setattr(dynamic_object, variable_with_property_name, variable_with_property_value)</code>? you need a collection to associate some 'properties' to values, and the "type" of that thing is used in one place... could you maybe really want a <code>dict</code>?</span>
<span class="comment-copy">@TokenMacGuy check updated question</span>
<span class="comment-copy">This. Defining a class is cheap, why not use just them?</span>
<span class="comment-copy">Is it ok if I define the Expando class inside a the only function that needs the dynamic object ?</span>
<span class="comment-copy">@JimmyKane: that sounds suspiciously like a different question, but yes, its "ok";  on the other hand, it doesn't buy you a thing; put it at the module scope and save the overhead of creating one-use classes.</span>
<span class="comment-copy">@JimmyKane: It sounds suspiciously much like you wanted to use a <code>namedtuple</code> class instead.</span>
<span class="comment-copy">@MartijnPieters Please check updated question.</span>
<span class="comment-copy">Did you try your code?  You can't add attributes to an <code>object()</code>.</span>
<span class="comment-copy">Hmm, how odd, I could have sworn I'd done it before. I'll take that part out and just leave the part about the <code>dict</code>s, which was my main suggestion.</span>
<span class="comment-copy">Or use the <code>collections.namedtuple</code> class factory..</span>
<span class="comment-copy">You created a lambda. That's not the best way to create an instance; the fact that you can add attributes to it is now being used as a side-effect.</span>
<span class="comment-copy">Note that  this comes with a couple of attributes predefined (for instance, try <code>dynamic_object.__name__</code>)</span>
<span class="comment-copy">@DavidRobinson Yes this might create a problem. Indeed you are right.</span>
