<div class="post-text" itemprop="text">
<p>I would like to get callback notification every time <code>heapq.heapify</code> function changes elements in my heap-list (this is, btw, needed to keep track of objects in the list and how their indexes get changed).</p>
<p>My plan was to subclass from <code>list</code> and override the <code>__setitem__</code> method from which I would track changes in my list. So here is the subclass:
</p>
<pre><code>class List2(list):

    def __setitem__(self, key, value):
        print 'setitem: key=',key,' value=',value
        list.__setitem__(self, key, value)

    def __getitem__(self, key):
        print 'getitem: key=',key
        return list.__getitem__(self, key)
</code></pre>
<p>Then I create an instance of <code>List2</code> and call heapify for it:</p>
<pre><code>h = List2([12, -3, 0, 5, 1, 7])
heapq.heapify(h)
</code></pre>
<p>The problem is that the overridden <code>__setitem__</code> is not called from within <code>heapq.heapify</code>. It looks like <code>heapq.heapify</code> treats an instance of List2 as if it's the default list.
I guess it has something to do with the fact that <code>heapq.heapify</code> is a built-in function, but I still don't get it.</p>
<p>Why the overridden <code>__setitem__</code> is not called from <code>heapq.heapify</code>?</p>
<p>An interesting thing here is that if I copy-paste the heapq's code into my local module (so it's not a built-in function anymore), then it works as expected and I get calls to <code>List2.__settiem__</code>, but it does not work with the default (built-in) <code>heapq</code>.</p>
<p>Python 2.7 if it matters</p>
</div>
<div class="post-text" itemprop="text">
<p>As part of the Python 3.0 project, and again for 3.3, they went through the docs making it more explicitly when something takes a <code>list</code> vs. a general <code>sequence type</code> or <code>mutable sequence type</code> or <code>iterable</code>, and <a href="http://docs.python.org/3/library/heapq.html" rel="nofollow"><code>heapq</code></a> definitely says <code>list</code> in 3.3, which implies that the same is true in 2.7.</p>
<p>If you track down into the code, if you have the C implementation, in <a href="http://hg.python.org/cpython/file/2.7/Modules/_heapqmodule.c" rel="nofollow"><code>_heapqmodule.c</code></a>, <code>heapify</code> explicitly calls <code>PyList_Check</code> to verify that the type is a real <code>list</code> rather than a <code>list</code>-like sequence. This won't catch subclasses of <code>list</code>, but you can see that it directly calls <code>PyList_GETSIZE</code> and (within <code>_siftup</code>)  <code>PyList_GET_ITEM</code> and <code>PyList_SET_ITEM</code>, so it will treat a <code>list</code> subclass as a base <code>list</code> object. (And this isn't changed as of the current trunk.)</p>
<p>So, there are a few ways around this.</p>
<p>First, as @FogleBird suggests, you can just fork the pure-Python implementation of <a href="http://hg.python.org/cpython/file/2.7/Lib/heapq.py" rel="nofollow"><code>heapq</code></a>—just copy the exact same thing into your project, give it a different name, and remove the <code>from _heapq import *</code> bit at lines 318-321.</p>
<p>However, this may be a whole lot slower.</p>
<p>Switching from CPython to <a href="http://pypy.org" rel="nofollow">PyPy</a> may solve that automatically (and it also means you'll get the pure Python implementation whether you want it or not).</p>
<p>In fact, I ran a quick test with a 1,000,000-item list. After verifying that PyPy actually does use the <code>List2</code> class, I modified it so that, instead of printing, it stores a string into a global variable. (Otherwise, the printing took 3x longer than the actual work on Mac, 40x longer on Windows…) Then I ran it with various different Pythons:</p>
<ul>
<li>CPython 2.7.2 64-bit Mac: 2.079s</li>
<li>CPython 3.3.0 64-bit Mac: 1.997s</li>
<li>CPython 3.3.0 32-bit Mac: 2.197s</li>
<li><p>PyPy 2.7.2/1.9.0 64-bit Mac: 1.619s</p></li>
<li><p>CPython 2.7.3 32-bit Win: 3.997s</p></li>
<li>PyPy 2.7.21.9.0 32-bit Win: 2.334s</li>
</ul>
<p>So, PyPy blew away everything else, despite actually calling my Python list overrides. (I didn't test Jython or IronPython—partly because the startup and warmup time of the JVM or .NET are so long that you need a much longer test for it to be at all fair… But they must also use the pure Python <code>heapq</code> module.)</p>
<p>But that may be a more dramatic change than you want to make. The other alternative is to fork <code>_heapqmodule.c</code> as well. Even if you don't know the C API at all, this is really just a search-and-replace job. For each <code>PyList_FOO</code> function, replace it with the corresponding <a href="http://docs.python.org/2/c-api/sequence.html" rel="nofollow"><code>PySequence_Foo</code></a> function (<code>PyList_SIZE</code> -&gt; <code>PySequence_Size</code>, <code>PyList_GETITEM</code> -&gt; <code>PySequence-&gt;GetItem</code>, etc.). And replace the module name both places it appears. That's it. Then build the module, and have your fork <code>myheapq.py</code> try to <code>import _myheapq</code> instead of <code>import _heapq</code>. This will still not be quite as fast as the built-in implementation, but only because it will be calling your <code>__getitem__</code> and <code>__setitem__</code> methods a bunch of times, which is exactly what you want.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>heapq</code> uses C implementation if <code>_heapq</code> is available.</p>
<p>When you copied <code>heapq</code> module to your local package, <code>_heapq</code> cannot be found, and the <code>Python implementation</code> get used, which indeed uses <code>__setitem__</code> and <code>__getitem__</code> as you can find statements like <code>heap[pos] = heap[childpos]</code> in <code>_siftup</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>heapq uses native code if available on your platform, which I assume is the problem although I don't fully grok the reason why.</p>
<p>Perhaps you can take a different approach, and track the original indicies of the list items.</p>
<pre><code>&gt;&gt;&gt; n = [12, -3, 0, 5, 1, 7]
&gt;&gt;&gt; m = [(v, i) for i, v in enumerate(x)]
&gt;&gt;&gt; heapq.heapify(m)
&gt;&gt;&gt; m
[(-3, 1), (1, 4), (0, 2), (5, 3), (12, 0), (7, 5)]
</code></pre>
<p>Then you can extract the values and indicies after heapify...</p>
<pre><code>&gt;&gt;&gt; values, indicies = zip(*m)
&gt;&gt;&gt; values
(-3, 1, 0, 5, 12, 7)
&gt;&gt;&gt; indicies
(1, 4, 2, 3, 0, 5)
</code></pre>
<p><strong>Edit</strong>: I tried to "trick" heapq by providing a instance of a class not derived from list. It did not work, it requires lists, presumably because the native code uses that as an assumption for performance reasons.</p>
<pre><code>&gt;&gt;&gt; class List(object):
...     def __init__(self, data):
...         self.data = data
...     def __getitem__(self, key):
...         print 'getitem', key
...         return self.data[key]
...     def __setitem__(self, key, value):
...         print 'setitem', key, value
...         self.data[key] = value
... 
&gt;&gt;&gt; x = List([12, -3, 0, 5, 1, 7])
&gt;&gt;&gt; heapq.heapify(x)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: heap argument must be a list
</code></pre>
<p><strong>Edit 2</strong>: Note this code in heapq.py. This overrides the Python implementations.</p>
<pre><code># If available, use C implementation
try:
    from _heapq import *
except ImportError:
    pass
</code></pre>
<p><strong>Edit 3</strong>: The Python documentation discusses your root issue. Namely, "if a pending task needs to be deleted, how do you find it and remove it from the queue?"</p>
<p><a href="http://docs.python.org/2/library/heapq.html#priority-queue-implementation-notes" rel="nofollow">http://docs.python.org/2/library/heapq.html#priority-queue-implementation-notes</a></p>
<p>The idea is to simply mark entries as removed. When you see these items at the top of your priority queue, you ignore them. The documentation has sample code.</p>
</div>
<span class="comment-copy">Hm, it looks you are right here! How can I track indexes of the objects then? :( But that's probably another question...</span>
<span class="comment-copy">@alveko Maybe a little more context on why you are trying to do this would be helpful ;) There may be some other solutions to your problem. Also, the source code of <code>_heapq</code> should also provide useful information. I'm still searching for it.</span>
<span class="comment-copy">It's simple, _heapqmodule.c uses functions like <code>PyList_GET_ITEM</code> which do not invoke the special methods <code>__getitem__</code>, etc.</span>
<span class="comment-copy">@Satoru.Logic Context: The heap contains objects with their priorities. I would like to delete an object from the heap in log(n).  It is possible to delete an element from the heap in log(n) if you know its index. So I have to resolve an object to its index in the heap to be able to delete it quicker than O(n). Such object-&gt;index resolution requires tracking of objects' indexes during heap operations like heapify.</span>
<span class="comment-copy">@alveko source code of <code>_heapq</code>: <a href="http://hg.python.org/releasing/2.7.3/file/7bb96963d067/Modules/_heapqmodule.c#l73" rel="nofollow noreferrer">hg.python.org/releasing/2.7.3/file/7bb96963d067/Modules/…</a></span>
<span class="comment-copy">Sorry, but that's not I want. I would like to track objects moved within the heap-list after multiple heapify calls and constantly maintain the correspondence between the object and its current index in the heap-list. Basically, I would like to get an index of a given object in O(1) after multiple pop/push/heapify calls.</span>
<span class="comment-copy">Why not just use the Python heapq.py source in your project then?</span>
<span class="comment-copy">As for your Edit, my assumption is that it should work with classes derived from list as well. And it actually works, but not as I expect,  and not according to the heapq code (since if I copy-paste it, then it works as expected).</span>
<span class="comment-copy">2 FogleBird, I don't like copying the code for no use</span>
<span class="comment-copy">It simply won't work with the native heapq implementation.</span>
