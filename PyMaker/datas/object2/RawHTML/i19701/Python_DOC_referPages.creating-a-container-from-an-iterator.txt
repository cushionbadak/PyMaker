<div class="post-text" itemprop="text">
<p>I want to create a <code>set</code>, <code>list</code>, etc. from an iterator. Unfortunately, their constructors require an iterable rather than an iterator. I don't want to create an iterable that will be discarded shortly.</p>
<p>Of course, I could simply use list or set comprehension, which can do precisely what I want (and more). However, the syntax for them is idiosyncratic. So when I tried to write a function:</p>
<pre><code>def create_from_gen(container_type, generator):
  return container_type(generator)
</code></pre>
<p>I got stuck. For user-defined containers, I can of course define my own constructors; for library and built-in types I have no choice. I could check for <code>list</code> and <code>set</code>, and use the special syntax I suppose, but that's ugly.</p>
</div>
<div class="post-text" itemprop="text">
<p>An iterator is also an iterable object. It should always have an <code>__iter__</code> method that returns itself. This is part of <a href="http://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">the specification for iterators</a> in Python.</p>
<p>So just pass your iterator to the <code>list</code> or <code>set</code> constructor, and it should work just fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>All iterators are iterable. The definition of "iterable" is that an iterator can be created from it.</p>
<pre><code>&gt;&gt;&gt; list(iter((1, 2, 3)))
[1, 2, 3]
</code></pre>
</div>
<span class="comment-copy">Can you give an example of the iterator you have?</span>
<span class="comment-copy">Every iterator is  by definition iterable. Give a concrete example of the problem you have.</span>
<span class="comment-copy">@NedBatchelder Sorry I was wrong... Apparently, all built-in types work fine with generators, just <code>numpy.array</code> doesn't. And that's just a problem specific to <code>numpy</code>. So my question is kinda pointless :(</span>
