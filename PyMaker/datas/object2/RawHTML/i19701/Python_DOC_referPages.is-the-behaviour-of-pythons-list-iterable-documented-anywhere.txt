<div class="post-text" itemprop="text">
<p>It would appear that in Python, <code>list += x</code> works for any iterable <code>x</code>:</p>
<pre><code>In [6]: l = []

In [7]: l += [1]

In [8]: l += (2, 3)

In [9]: l += xrange(5)

In [10]: l
Out[10]: [1, 2, 3, 0, 1, 2, 3, 4]
</code></pre>
<p>Is this behaviour documented anywhere?</p>
<p>To contrast this with <code>list + x</code>, the latter only works if <code>x</code> is also a <code>list</code>. This is spelled out in the <a href="http://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange" rel="nofollow noreferrer">documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://plus.google.com/118069851186709403898/posts/YoNDMKjTuJh">Guido van Rossum</a>:</p>
<blockquote>
<p>It works the same way as <code>.extend()</code> except that it also returns <code>self</code>. I
  can't find docs explaining this. :-(</p>
</blockquote>
<p>Here is the relevant source code taken from <a href="http://hg.python.org/cpython/file/2d2d4807a3ed/Objects/listobject.c#l892"><code>listobject.c</code></a>:</p>
<pre><code>list_inplace_concat(PyListObject *self, PyObject *other)
{
     PyObject *result;

     result = listextend(self, other);
     if (result == NULL)
         return result;
     Py_DECREF(result);
     Py_INCREF(self);
     return (PyObject *)self;
}
</code></pre>
<p>I've raised a bug report to have the documentation fixed: <a href="http://bugs.python.org/issue16701">http://bugs.python.org/issue16701</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It is <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow noreferrer">now documented</a> in Python 3.4+ and Python 2.7:</p>
<blockquote>
<p><strong>4.6.3. Mutable Sequence Types</strong></p>
<p>The operations in the following table are defined on mutable sequence types. The <code>collections.abc.MutableSequence</code> ABC is provided to make it easier to correctly implement these operations on custom sequence types.</p>
<p><em>[Below]</em> <code>s</code> is an instance of a mutable sequence type, <code>t</code> is any iterable object and <code>x</code> is an arbitrary object that meets any type and value restrictions imposed by <code>s</code> (for example, <code>bytearray</code> only accepts integers that meet the value restriction <code>0 &lt;= x &lt;= 255</code>).</p>
<hr/>
<p><strong><code>s.extend(t)</code> or <code>s += t</code></strong></p>
<p>extends <code>s</code> with the contents of <code>t</code>  (for the most part the same as <code>s[len(s):len(s)] = t</code>)</p>
</blockquote>
<p>So it is now documented that for any mutable sequence type <code>s</code>, <code>s += t</code> is synonymous with <code>s.extend(t)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>No (<a href="https://plus.google.com/118069851186709403898/posts/YoNDMKjTuJh" rel="nofollow noreferrer">Guido confirms</a>; thanks to Ashwini Chaudhary). The behaviour of <code>+=</code> for sequences in general is underspecified. I conclude that it is not required by the specification that <code>x + y</code> where <code>x</code> is a list, and <code>y</code> some other iterable be an error (so other implementations could choose to allow it), and that other implementations could restrict <code>+=</code> to require homogenous operands.</p>
<p>However, the reasons not to do this are obvious: python in general tries to do the right thing with operands, rather than requiring rigid type equality. The real mystery is why heterogenous addition is not allowed with lists.</p>
<p>Update: I've never really thought about the nonhomogenous addition problem, largely because <code>itertools.chain</code> is pretty much a complete solution to the problem. </p>
<p>Comments from those more familiar with Python's internals are welcome to explain why addition is required to be homogenous. (Question here: <a href="https://stackoverflow.com/questions/13905008/why-must-python-list-addition-be-homogenous">Why must Python list addition be homogenous?</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>For the performance freaks out there, yes, <code>+=</code> is a tiny bit faster than <code>extend</code>:</p>
<pre><code>&gt;&gt;&gt; from timeit import repeat
&gt;&gt;&gt; min(repeat('a.extend((1,2,3,4,5,6,7))', 'a=[]'))
0.23489440699995612
&gt;&gt;&gt; min(repeat('e((1,2,3,4,5,6,7))', 'a=[]; e = a.extend'))
0.2214308570000867
&gt;&gt;&gt; min(repeat('a+=(1,2,3,4,5,6,7)', 'a=[]'))
0.21909333300027356
</code></pre>
<p>And here is how it compares to <code>append</code>:</p>
<pre><code>&gt;&gt;&gt; min(repeat('a.append(1)', 'a=[]'))
0.062107428999297554
&gt;&gt;&gt; min(repeat('p(1)', 'a=[]; p = a.append'))
0.04968810399986978
&gt;&gt;&gt; min(repeat('a+=(1,)', 'a=[]'))
0.0501599309991434
</code></pre>
<p>(Testing on Python 3.7 64-bit, Windows)</p>
</div>
<span class="comment-copy">I'll look for some documentation to back it up, but I believe in the case of a list the <code>+=</code> operator mimics <code>extend</code>. I'll see if I can find something to confirm this.</span>
<span class="comment-copy"><a href="http://www.python.org/dev/peps/pep-0203/" rel="nofollow noreferrer">python.org/dev/peps/pep-0203</a></span>
<span class="comment-copy">@AshwiniChaudhary: I actually looked at the PEP before posting the question, but didn't find anything specifically about <code>+=</code> and lists. Is there some part I am overlooking?</span>
<span class="comment-copy">@NPE may be this <a href="http://p.boxnet.eu/16970/" rel="nofollow noreferrer">p.boxnet.eu/16970</a>, also from the same PEP: <code>The </code>i' in <code>__iadd__' stands for </code>in-place<code>, and if you call the module </code>dis` on <code>+=</code> then you'll see that it is in-place add only.</span>
<span class="comment-copy">The closest I have found is a remark in the <a href="http://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="nofollow noreferrer"><code>__iadd__</code> documentation</a> that " These methods should attempt to do the operation in-place (modifying self) [...]".</span>
<span class="comment-copy">Ha, +1 - you were two sections ahead of me :)</span>
<span class="comment-copy">The question asks for <i>documentation</i> of this behavior. Source code isn't documentation, and the PEP does not (as far as I can tell from skimming and grepping) define the semantics of <code>+=</code> for lists, only the fallback behavior (which lists override). Am I missing something or are you not actually answering the question? -1 for now.</span>
<span class="comment-copy">@delnan What if this thing is actually missing from the docs, docs can have bugs too.</span>
<span class="comment-copy">@downvoters kindly explain your downvotes as well.</span>
<span class="comment-copy">(+1) for going to the source (GvR, not the source code).</span>
<span class="comment-copy">Nice answer, thanks. Pretty much echoes my conclusions. (+1)</span>
<span class="comment-copy">@NPE I'm very surprised to realise that this behaviour is not documented. I've never actually questioned the nonheterogenous <code>+</code>, largely because where I want to concatenate a list, and other iterables, I use <code>itertools.chain</code> to avoid the need for copying, except in relation to strings.</span>
<span class="comment-copy">I think the last paragraph deserves a separate SO question. I too have been wondering about this for a long time.</span>
<span class="comment-copy">@NPE I'll do that now.</span>
