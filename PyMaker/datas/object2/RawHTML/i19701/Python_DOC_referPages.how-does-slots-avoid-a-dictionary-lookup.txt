<div class="post-text" itemprop="text">
<p>I've heard that <code>__slots__</code> makes objects faster by avoiding a dictionary lookup. My confusion comes from Python being a dynamic language. In a static language, we avoid a dictionary lookup for <code>a.test</code> by doing a compile-time optimisation to save the index in the instruction we run.  </p>
<p>Now, in Python, <code>a</code> could just as easily be another object that has a dictionary or a different set of attributes. It seems like we'll still have to do a dictionary lookup - the only difference seems to be that we only need one dictionary for the class, rather than a dictionary for each object.</p>
<p>With this rational,</p>
<ol>
<li>How does <code>__slots__</code> avoid a dictionary lookup?</li>
<li>Does slots make accessing objects faster?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><code>__slots__</code> does not (significantly) speed up attribute access:</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     __slots__ = ('spam',)
...     def __init__(self):
...         self.spam = 'eggs'
... 
&gt;&gt;&gt; class Bar(object):
...     def __init__(self):
...         self.spam = 'eggs'
... 
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('t.spam', 'from __main__ import Foo; t=Foo()')
0.07030296325683594
&gt;&gt;&gt; timeit.timeit('t.spam', 'from __main__ import Bar; t=Bar()')
0.07646608352661133
</code></pre>
<p>The goal of using <code>__slots__</code> is to <em>save memory</em>; instead of using a <code>.__dict__</code> mapping on the instance, the class has <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors objects</a> for each and every attribute named in <code>__slots__</code> and instances have the attribute assigned <em>wether or not</em> they have an actual value:</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     __slots__ = ('spam',)
... 
&gt;&gt;&gt; dir(Foo())
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', 'spam']
&gt;&gt;&gt; Foo().spam
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: spam
&gt;&gt;&gt; Foo.spam
&lt;member 'spam' of 'Foo' objects&gt;
&gt;&gt;&gt; type(Foo.spam)
&lt;type 'member_descriptor'&gt;
</code></pre>
<p>So python still has to look at the class for each attribute access on an instance of <code>Foo</code> (to find the descriptor). Any unknown attribute (say, <code>Foo.ham</code>) will still result in Python looking through the class MRO to search for that attribute, and that includes dictionary searches. And you can still assign additional attributes to the <em>class</em>:</p>
<pre><code>&gt;&gt;&gt; Foo.ham = 'eggs'
&gt;&gt;&gt; dir(Foo)
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', 'ham', 'spam']
&gt;&gt;&gt; Foo().ham
'eggs'
</code></pre>
<p>The slot descriptors are created when the class is created, and access memory assigned to each instance to store and retrieve a reference to the associated value (the same chunk of memory that tracks instance reference counts and a reference back to the class object). Without slots, a descriptor for <code>__dict__</code> is used accessing a reference to a <code>dict</code> object in the same manner.</p>
</div>
<div class="post-text" itemprop="text">
<p>It might speed up a program where you instantiate <em>lots</em> of objects of the same class, genuinely never change what attributes they have, and cache misses on all those duplicate dictionaries present a real performance problem.</p>
<p>This is really just a special case of the general situation where saving space <em>sometimes</em> saves time as well, where cache is the limiting factor.</p>
<p>So, it probably won't make accessing <em>one</em> object faster, but may speed up accessing <em>many</em> objects of the same type.</p>
<p>See also <a href="https://stackoverflow.com/q/472000/212858">this question</a>.</p>
</div>
<span class="comment-copy">@JBernardo No, that question is about how it should be used, while this is about (a specific aspect of) how it's implemented.</span>
<span class="comment-copy">I don't think it does, the reasoning in your second paragraph seems correct. Where did you hear that it avoids a dict lookup?</span>
<span class="comment-copy">@delnan: Because the documentation states that it removes the instance <code>__dict__</code>; descriptors are used for each named slot instead.</span>
<span class="comment-copy">@MartijnPieters That's eliminating a dictionary, which is not the same thing as eliminating a dictionary <i>lookup</i>. As OP reasons (and I agree), there's still a lookup, just on the class's dictionary.</span>
<span class="comment-copy">@delnan: I agree with that completely, just explaining why the OP might have confused the two. :-)</span>
<span class="comment-copy"><i>"not significantly"</i>? 10% improvement for a single line change is quite significant in my book.If you understand <code>__slots__</code>'s obscure side-effects, of course :)</span>
<span class="comment-copy">See also: <a href="http://code.activestate.com/recipes/532903-how-__slots__-are-implemented/" rel="nofollow noreferrer"><code>http://code.activestate.com/recipes/532903-how-__slots__-are-implemented/</code></a></span>
<span class="comment-copy">For the curious: if you don't use <code>__slots__</code> and instead declare the member at the class level, you'll see a speed <i>penalty</i> of about 5% over the plain non-slots version.</span>
