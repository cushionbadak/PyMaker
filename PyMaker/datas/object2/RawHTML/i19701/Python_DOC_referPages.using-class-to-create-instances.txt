<div class="post-text" itemprop="text">
<p>Is it a good idea to use <code>__class__</code> to create new instances within the class?</p>
<p>The following code is an example of doing this:</p>
<pre><code>from collections import namedtuple

_Position = namedtuple('Position', ['x', 'y'])
class Position(_Position):
    def __add__(self, other):
        return __class__(self.x + other.x, self.y + other.y)
</code></pre>
<p>Using the actual class name sounds like duplicated code to me. If the name of the class changes I'd have to change it in all occurrences, even though modern IDE's can do that for you.</p>
<p>btw. What kind of variable is <code>__class__</code>? Shouldn't you only be able to access it with <code>self.</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>To support the zero-argument form of <a href="http://docs.python.org/3/library/functions.html#super" rel="noreferrer"><code>super()</code></a>, the compiler adds an implicit reference to the class if <code>__class__</code> or <code>super()</code> are being used in a class method. See <a href="http://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="noreferrer">Creating the class object</a>.</p>
<p>The example code you found (ab)uses this little factoid to create new instances of <code>Position</code> when adding.</p>
<p>Personally, I'd use <code>type(self)</code> instead, as that is the proper API method of determining the type or class of any object. <code>type(self)</code> will use <code>self.__class__</code> where appropriate:</p>
<pre><code>def __add__(self, other):
    return type(self)(self.x + other.x, self.y + other.y)
</code></pre>
<p>That <em>is</em> a good idea if you want to support subclassing. Any subclasses of <code>Position</code> will return the correct subclassed type when being added together. Using <code>__class__</code> does <em>not</em> do that, as it will always be pointing to <code>Position</code>, even for subclasses:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def method(self):
...         print(__class__)
...         print(type(self))
... 
&gt;&gt;&gt; class Bar(Foo):
...     pass
... 
&gt;&gt;&gt; Bar().method()
&lt;class '__main__.Foo'&gt;
&lt;class '__main__.Bar'&gt;
</code></pre>
<p>Of course, if that was your intention all along (to bypass subclasses), I'd still prefer using the explict class name over using <code>__class__</code>; explicit is better than implicit.</p>
</div>
<span class="comment-copy">If you're subclassing <code>namedtuple</code>, why don't you just create an object from scratch?</span>
<span class="comment-copy">Here's a good explanation: <a href="http://stackoverflow.com/questions/8060751/what-in-the-world-is-the-attribute-class-in-python" title="what in the world is the attribute class in python">stackoverflow.com/questions/8060751/â€¦</a></span>
<span class="comment-copy">@favoretti Thanks.</span>
<span class="comment-copy">@Blender This is just an example. I could indeed create an object from scratch.</span>
<span class="comment-copy">Does this mean you could also use self.__class__(...) instead of type(self)(...), which would be faster, right?</span>
<span class="comment-copy">@Joschua: That'd be a false optimization. I'd use <code>type(self)</code> still, as you should use API methods over directly accessing hooks wherever possible.</span>
<span class="comment-copy">@Martijin Pieters And why should you use them over the others?</span>
<span class="comment-copy">@Joschua: Because the hooks are there for the API to use, allowing for the API to expand in the future and use other hooks if needed.</span>
<span class="comment-copy">@Martijin Pieters: Thanks!</span>
