<div class="post-text" itemprop="text">
<p>I am doing some testing regarding the speed of if-statements in loops and their effect on speed. Something I found was that consistently, the if-statement improved performance. My code:</p>
<pre><code>import time
t = time.time

start = t()
x = 0
while x &lt; 10000000:
    x += 1
time1 = t()
x = 0
while x &lt; 10000000:
    x += 1
    if True:
        pass
time2 = t()

print(start)
print(time1 - start) # Time for simple while-loop
print(time2 - time1) # Time for while+if
</code></pre>
<p>A sample output would be:</p>
<pre><code>1355517837.993
1.7850000858306885
1.7209999561309814
</code></pre>
<p>Which is completely counter-intuitive. The while-if-loop is working ever-so-slightly faster than the standard while-loop. This happens almost every time I run it; perhaps 1 in 20 times take longer. Does anyone know why?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd guess that the compiler would remove the if True block since it is constant.</p>
<p>When I run I get mostly the opposite results from you.  I may just be random effects of the execution environment.</p>
<p>1355519587.2
0.832797050476
1.04382395744</p>
<p>1355519590.03
0.863899946213
1.09347200394</p>
<p>1355519593.72
0.831655025482
1.05389809608</p>
<p>1355519599.71
0.831452131271
1.41783499718</p>
<p>1355519602.99
0.815280914307
1.05724310875</p>
<p>1355519605.72
0.826404094696
1.05700492859</p>
<p>1355519608.94
0.827296972275
1.07807898521</p>
</div>
<div class="post-text" itemprop="text">
<p>The dis shows that there are more steps to the if statement while loop.</p>
<pre><code>In [4]: dis.dis(t2)
  2           0 LOAD_CONST               1 (0)
              3 STORE_FAST               0 (x)

  3           6 SETUP_LOOP              26 (to 35)
        &gt;&gt;    9 LOAD_FAST                0 (x)
             12 LOAD_CONST               2 (10000000)
             15 COMPARE_OP               0 (&lt;)
             18 POP_JUMP_IF_FALSE       34

  4          21 LOAD_FAST                0 (x)
             24 LOAD_CONST               3 (1)
             27 INPLACE_ADD
             28 STORE_FAST               0 (x)
             31 JUMP_ABSOLUTE            9
        &gt;&gt;   34 POP_BLOCK
        &gt;&gt;   35 LOAD_CONST               0 (None)
             38 RETURN_VALUE

In [5]: dis.dis(t1)
  2           0 LOAD_CONST               1 (0)
              3 STORE_FAST               0 (x)

  3           6 SETUP_LOOP              35 (to 44)
        &gt;&gt;    9 LOAD_FAST                0 (x)
             12 LOAD_CONST               2 (10000000)
             15 COMPARE_OP               0 (&lt;)
             18 POP_JUMP_IF_FALSE       43

  4          21 LOAD_FAST                0 (x)
             24 LOAD_CONST               3 (1)
             27 INPLACE_ADD
             28 STORE_FAST               0 (x)

  5          31 LOAD_GLOBAL              0 (True)
             34 POP_JUMP_IF_FALSE        9

  6          37 JUMP_ABSOLUTE            9
             40 JUMP_ABSOLUTE            9
        &gt;&gt;   43 POP_BLOCK
        &gt;&gt;   44 LOAD_CONST               0 (None)
             47 RETURN_VALUE
</code></pre>
</div>
<span class="comment-copy">What happens if you move <code>x=0</code> out of both timed blocks?  I bet what you're seeing is the interpreter having to allocate <code>x</code> for the first block but not the second.</span>
<span class="comment-copy">not the same here, tho'; i have timings like: <code>$ python t.py  1355519439.65 1.92616391182 2.65010595322</code>; ran on Python 2.7.3</span>
<span class="comment-copy">Is result the same if you first run the if loop and then the one without it? For me the first one is always faster.</span>
<span class="comment-copy">I'm getting the results you'd expect in 2.7, and the strange ones in 3.2.</span>
<span class="comment-copy">I also consistently get longer times for the second version (in Python 3.2.3), as expected. Remember that <code>time.time()</code> is not the correct way to profile your program (since other tasks may affect the results). Use <code>timeit.timeit()</code> instead.</span>
<span class="comment-copy">Which engine? There is no just-in-time compiler or anything. At least not in CPython. In fact, there is no compiler at all, we're talking about Python here.</span>
<span class="comment-copy">agree. my results are: 1355519852.98, 0.830796003342, 1.11595201492 with python 2.7.1</span>
<span class="comment-copy">@TimPietzcker, it is 2.7.1.  Python does compile, but to bytecode.  You can't execute raw text in most operating environments.</span>
<span class="comment-copy">@delnan: Can you give an example or a link to some documentation about what kinds of optimization the compiler can do? It's obviously not able to remove the empty <code>if</code> statement.</span>
<span class="comment-copy">@TimPietzcker I don't think this is documented, as it's an implementation detail and very rarely matters. One mention of the optimizer I've seen is in the <a href="http://docs.python.org/3/whatsnew/3.2.html#optimizations" rel="nofollow noreferrer">3.2 whatsnew</a>. And of course, there's the source: <a href="http://hg.python.org/cpython/file/default/Python/peephole.c" rel="nofollow noreferrer">peephole.c</a> (there are quite a few comments detailing the optimizations performed). See line 446 for <i>a</i> optimization of jumps depending on constants.</span>
<span class="comment-copy">Thanks for posting this, I was not aware of the dis module before now. However it is still confusing that the while-if-loop runs faster, when even at this very low level it takes more steps.</span>
