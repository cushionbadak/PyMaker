<div class="post-text" itemprop="text">
<p>I've been trying to learn how CPython is implemented under the scenes. It's great that Python is high level, but I don't like treating it like a black box. </p>
<p>With that in mind, how are tuples implemented? I've had a look at <a href="https://github.com/python/cpython/blob/master/Objects/tupleobject.c" rel="nofollow noreferrer">the source (tupleobject.c)</a>, but it's going over my head. </p>
<p>I see that <code>PyTuple_MAXSAVESIZE = 20</code> and <code>PyTuple_MAXFREELIST = 2000</code>, what is saving and the "free list"? (Will there be a performance difference between tuples of length 20/21 or 2000/2001? What enforces the maximum tuple length?)</p>
</div>
<div class="post-text" itemprop="text">
<p>As a caveat, everything in this answer is based on what I've gleaned from looking over the implementation you linked.</p>
<p>It seems that the standard implementation of a tuple is simply as an array.  However, there are a bunch of optimizations in place to speed things up.</p>
<p>First, if you try to make an empty tuple, CPython instead will hand back a canonical object representing the empty tuple.  As a result, it can save on a bunch of allocations that are just allocating a single object.</p>
<p>Next, to avoid allocating a bunch of small objects, CPython recycles memory for many small lists.  There is a fixed constant (<code>PyTuple_MAXSAVESIZE</code>) such that all tuples less than this length are eligible to have their space reclaimed.  Whenever an object of length less than this constant is deallocated, there is a chance that the memory associated with it will not be freed and instead will be stored in a "free list" (more on that in the next paragraph) based on its size.  That way, if you ever need to allocate a tuple of size n and one has previously been allocated and is no longer in use, CPython can just recycle the old array.</p>
<p>The free list itself is implemented as an array of size <code>PyTuple_MAXSAVESIZE</code> storing pointers to unused tuples, where the nth element of the array points either to NULL (if no extra tuples of size n are available) or to a reclaimed tuple of size n.  If there are multiple different tuples of size n that could be reused, they are chained together in a sort of linked list by having each tuple's zeroth entry point to the next tuple that can be reused.  (Since there is only one tuple of length zero ever allocated, there is never a risk of reading a nonexistent zeroth element).  In this way, the allocator can store some number of tuples of each size for reuse.  To ensure that this doesn't use too much memory, there is a second constant <code>PyTuple_MAXFREELIST</code>) that controls the maximum length of any of these linked lists within any bucket.  There is then a secondary array of length <code>PyTuple_MAXSAVESIZE</code> that stores the length of the linked lists for tuples of each given length so that this upper limit isn't exceeded.</p>
<p>All in all, it's a very clever implementation!</p>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>Because in the course of normal operations Python will create and destroy a <em>lot</em> of small tuples, Python keeps an internal cache of small tuples for that purpose. This helps cut down on a lot of memory allocation and deallocation churn. For the same reasons small integers from -5 to 255 are interned (made into singletons).</p>
<p>The <code>PyTuple_MAXSAVESIZE</code> definition controls at the maximum size of tuples that qualify for this optimization, and the <code>PyTuple_MAXFREELIST</code> definition controls <em>how many</em> of these tuples keeps around in memory. When a tuple of length &lt; <code>PyTuple_MAXSAVESIZE</code> is discarded, it is added to the free list if there is still room for one (in <code>tupledealloc</code>), to be re-used when Python creates a new small tuple (in <code>PyTuple_New</code>).</p>
<p>Python is being a little clever about how it stores these; for each tuple of length &gt; 0, it'll reuse the first element of each cached tuple to chain up to <code>PyTuple_MAXFREELIST</code> tuples together into a linked list. So each element in the <code>free_list</code> array is a linked list of Python tuple objects, and all tuples in such a linked list are of the same size. The only exception is the empty tuple (length 0); only one is ever needed of these, it is a singleton.</p>
<p>So, yes, for tuples over length <code>PyTuple_MAXSAVESIZE</code> python is guaranteed to have to allocate memory separately for a new C structure, and that could affect performance if you create <em>and</em> discard such tuples a lot.</p>
<p>If you want to understand Python C internals, I do recommend you study the <a href="http://docs.python.org/3/c-api/">Python C API</a>; it'll make it easier to understand the various structures Python uses to define objects, functions and methods in C.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to templatetypedef's Answer!
I was curious about the exact value of PyTuple_MAXSAVESIZE and PyTuple_MAXFREELIST, so I used google and found it out:</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/05HFM.png"/></p>
<p><a href="https://github.com/python/cpython/blob/master/Objects/tupleobject.c" rel="nofollow noreferrer">https://github.com/python/cpython/blob/master/Objects/tupleobject.c</a></p>
<p>google search keyword:
PyTuple_MAXSAVESIZE site:github.com</p>
</div>
<span class="comment-copy">FWIW, <a href="http://hg.python.org/cpython" rel="nofollow noreferrer">hg.python.org/cpython</a> is the authoritative repository, so you may want to look at that.</span>
<span class="comment-copy">Excellent explanation, thanks a lot!</span>
<span class="comment-copy">Just to be clear, does it cache the tuple objects including contents, or does it "just" maintain a free list of memory blocks of the appropriate size? My impression was the latter, but your first paragraph reads kind of like the first.</span>
<span class="comment-copy">You beat me to it by two minutes. :-)</span>
<span class="comment-copy">@delnan: A cache of the tuple objects themselves, which are just fixed lists of object references. The contents themselves are not cached. The objects referenced by a tuple have their own memory blocks.</span>
<span class="comment-copy">@templatetypedef: For this clever and cool piece of code, it can not hurt to have two different explanations of what is going on!</span>
<span class="comment-copy">That sounds like how functional languages implement their immutable lists. (e.g. <code>Data.List</code> in Haskell.) Nice to see that Python has it too!</span>
