<div class="post-text" itemprop="text">
<p>Sometimes i need to create an anonymous class instance in python, just like c#:</p>
<pre><code>var o= new {attr1="somehing", attr2=344};
</code></pre>
<p>but in python i do it in this way:</p>
<pre><code>class Dummy: pass
o = Dummy()
o.attr1 = 'something'
o.attr2 = 344
#EDIT 1
print o.attr1, o.attr2
</code></pre>
<p>how can do that in pythonic way in single statement?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>o = type('Dummy', (object,), { "attr1": "somehing", "attr2": 344 })
</code></pre>
<pre><code>o.attr3 = "test"
print o.attr1, o.attr2, o.attr3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>type</h2>
<p>while this is not precisely a single statement I think creating a wrapper around the magic of the accepted answer makes it by far more readable.  </p>
<pre><code>import inspect 

# wrap the type call around a function 
# use kwargs to allow named function arguments
def create_type(name, **kwargs):
    return type(name, (object,), kwargs)

# example call to make a structure
p = create_type('foobar', xxx='barfoo', seti=0)

assert p.xxx == 'barfoo'
assert p.seti == 0

print inspect.getmembers(p)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[('__class__', &lt;type 'type'&gt;),
 ('__delattr__', &lt;slot wrapper '__delattr__' of 'object' objects&gt;),
 ('__dict__', &lt;dictproxy object at 0x9a5050&gt;),
 ('__doc__', None),
 ('__format__', &lt;method '__format__' of 'object' objects&gt;),
 ('__getattribute__', &lt;slot wrapper '__getattribute__' of 'object' objects&gt;),
 ('__hash__', &lt;slot wrapper '__hash__' of 'object' objects&gt;),
 ('__init__', &lt;slot wrapper '__init__' of 'object' objects&gt;),
 ('__module__', '__main__'),
 ('__new__', &lt;built-in method __new__ of type object at 0x399c578460&gt;),
 ('__reduce__', &lt;method '__reduce__' of 'object' objects&gt;),
 ('__reduce_ex__', &lt;method '__reduce_ex__' of 'object' objects&gt;),
 ('__repr__', &lt;slot wrapper '__repr__' of 'object' objects&gt;),
 ('__setattr__', &lt;slot wrapper '__setattr__' of 'object' objects&gt;),
 ('__sizeof__', &lt;method '__sizeof__' of 'object' objects&gt;),
 ('__str__', &lt;slot wrapper '__str__' of 'object' objects&gt;),
 ('__subclasshook__', &lt;built-in method __subclasshook__ of type object at 0x919370&gt;),
 ('__weakref__', &lt;attribute '__weakref__' of 'foobar' objects&gt;),
 # here they are
 ('seti', 0),
 ('xxx', 'barfoo')]
</code></pre>
<h2>namedtuple</h2>
<pre><code>from collections import namedtuple

d = { 'a' : 'foo', 'b' : 'bar' }
foobar = namedtuple('foobar', d.keys())(**d)
print foobar
</code></pre>
<p><strong>Output</strong></p>
<pre><code>Python 2.7.5 (default, May 30 2013, 16:55:57) [GCC] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; d  =  { 'a' : 'foo', 'b' : 'bar' }
&gt;&gt;&gt; foobar = namedtuple('foobar', d.keys())(**d)
&gt;&gt;&gt; print foobar
foobar(a='foo', b='bar')
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python 3.3 or later, you can use <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">types.SimpleNamespace</a>:</p>
<pre><code>from types import SimpleNamespace

o = SimpleNamespace(attr1="something", attr2=344)
print(o)

# namespace(attr1='something', attr2=344)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class attrdict(dict):
    def __getattr__(self, key):
        return self[key]

o = attrdict(attr1='something', attr2=344)

o.attr1
</code></pre>
<p>But it seems like you should probably just use a standard dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>I prefer the dict answer from mwhite, but here's how I've done it in the past using the "magic" of kwargs (pun intended). </p>
<pre><code>class ObjectFromDict(object):
    def __init__(**kwargs):
        for k in kwargs:
            if k not in self.__dict__:
                setattr(k,v)

myObj = ObjectFromDict(**{'foo': 'bar', 'baz': 'monkey'})
print myObj.foo #bar
</code></pre>
</div>
<span class="comment-copy">I wouldn't use a class as just a container object. Use a named tuple or a dictionary. What are you trying to accomplish with these classes?</span>
<span class="comment-copy">@Blender: named tuples need to be defined firstly, then make instance of it. i need single statement(the pythonic way)</span>
<span class="comment-copy">What are you using these classes for? Do they have methods or are they just containers? If they're containers, use a container object, not a class.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1123000/does-python-have-anonymous-classes">Does Python have anonymous classes?</a></span>
<span class="comment-copy">@pylover, the pythonic way would really be a <code>dict</code>, this is a hack.</span>
<span class="comment-copy">yes, but i need a python class instance for some purposes</span>
<span class="comment-copy">@pylover @rid I don't want to get bizantine but an <code>AttrBunch</code>-like type that is essentially a <code>dict</code> with attribute access will fit the bill with arguably nicer syntax and without offending the python arbiters of good taste. What seems to me very unpythonic and unnecesary here is the creation of an ad hoc type. It's not that python is all for a class-less society, but that it likes classes when you have some predefined, conceptual structure in mind, not for a random bunch of attributes, even less if the class is dynamically created.</span>
<span class="comment-copy">What happens when you try to create a different "type" with the same name? Is it allowed? I wonder how the <code>easydict</code> package work (It's a package that makes you feel like JS - you give it a JSON string and you get objects accessible using real fields instead of dictionary keys)</span>
<span class="comment-copy">that's it, thanks</span>
<span class="comment-copy">@pylover: if the type is used more often and consistently it seems named tuples are preferable. See also: <a href="http://stackoverflow.com/questions/2970608/what-are-named-tuples-in-python" title="what are named tuples in python">stackoverflow.com/questions/2970608/â€¦</a></span>
<span class="comment-copy">i cannot set attr on this kind of object just like a class instance, i.e: <code>o.attr3 = 345</code>.</span>
<span class="comment-copy">@pylover: Override <code>__setitem__</code>.</span>
<span class="comment-copy">@mwhite: Don't you mean <code>__getattr__</code> (and <code>__setattr__</code>) rather than <code>__getitem__</code>?</span>
<span class="comment-copy">hey man, just single statement</span>
<span class="comment-copy">i using this solution for many years, but it needs to define a class , then instantiate it.</span>
<span class="comment-copy">hey man,just single statement</span>
<span class="comment-copy">Did you really run this code? I see no <code>self</code> argument, no <code>v</code> being defined, 2 arguments in <code>setattr</code>...</span>
