<div class="post-text" itemprop="text">
<p>I would like to get the unique elements from a list of dictionary based on the value of a field and retain the other fields.</p>
<p>Following the is the format of data I have.</p>
<pre><code>[ {id:"1000", text: "abc", time_stamp: "10:30"},
  {id:"1001", text: "abc", time_stamp: "10:31"},
  {id:"1002", text: "bcd", time_stamp: "10:32"} ]
</code></pre>
<p>I would like an output as follows: (Unique based on the text but retains other fields)</p>
<pre><code>[ {id:"1000", text: "abc", time_stamp: "10:30"}, # earlier time stamp
  {id:"1002", text: "bcd", time_stamp: "10:32"} ]
</code></pre>
<p>Here please notice that the uniqueness is based on the text, and I would like to retain the id and the time_stamp value as well. This question is different from <a href="https://stackoverflow.com/questions/11092511/python-list-of-unique-dictionaries">Python - List of unique dictionaries</a> question asked previously.</p>
<p>I tried:</p>
<p>Method 1: Collecting only text values from the dictionary, converting it to a list, passing it to a set, and getting the unique text values, but I lost the id and time_stamp.</p>
<p>Method 2: I also tried ahead, I traversed through the list of the dictionary and checked if the text value was present in the unique_list_of_text, if not append to a list_of_unique_dictionary. But this code was taking a lot of time, as I am working with a data set which has 350,000 records. Is there a better way to do it?
Code for method 2:</p>
<pre><code>def find_unique_elements(list_of_elements):
    no_of_elements = len(list_of_elements)
        unique_list_of_text = []
        unique_list_of_elements = []
        for iterator in range(0, no_of_elements):
            if not list_of_elements[iterator]['text'] in unique_list_of_text:
                unique_list_of_full_text.append(list_of_elements[iterator]['text'])
                unique_list_of_elements.append(list_of_elements[iterator])
        return unique_list_of_elements
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could make a new <code>list</code> and just check if the item is there or not,</p>
<p>To make it a bit more faster, may be i'd use a better datastructure</p>
<pre><code>$ cat unique.py

id = 'id'
text = 'text'
time_stamp = 'time_stamp'

data = [ {id:"1000", text: "abc", time_stamp: "10:30"},
   {id:"1001", text: "abc", time_stamp: "10:31"},
   {id:"1002", text: "bcd", time_stamp: "10:32"} ]

keys = set()
unique_items = []
for item in data:
    if item['text'] not in keys:
        unique_items.append(item)
    keys.add(item['text'])

print(unique_items)

$ python data.py 
[{'text': 'abc', 'id': '1000', 'time_stamp': '10:30'}, {'text': 'bcd', 'id': '1002', 'time_stamp': '10:32'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a dictionary from the reversed list and get values from that dictionary:</p>
<pre><code>id, text, time_stamp = 'id', 'text', 'timestamp'

l = [ {id:"1000", text: "abc", time_stamp: "10:30"},
  {id:"1001", text: "abc", time_stamp: "10:31"},
  {id:"1002", text: "bcd", time_stamp: "10:32"} ]

d = {i[text]: i for i in reversed(l)}
new_l = list(d.values())
print(new_l)
# [{'id': '1002', 'text': 'bcd', 'timestamp': '10:32'}, {'id': '1000', 'text': 'abc', 'timestamp': '10:30'}]

# if the order should be preserved
new_l.reverse()
print(new_l)
# [{'id': '1000', 'text': 'abc', 'timestamp': '10:30'}, {'id': '1002', 'text': 'bcd', 'timestamp': '10:32'}]
</code></pre>
<p>If the order in the final list is impotant use <code>OrderedDict</code>  instead of <code>dict</code> in Python 3.6 and below.</p>
</div>
<span class="comment-copy">If you wanna go with retaining the first value then the <code>set</code> is th way to go. <code>in</code> for a list is O(N) but for a <code>set</code> it's O(1)</span>
<span class="comment-copy">The first timestamp needs to be retained @roganjosh</span>
<span class="comment-copy">Dict and set membership is the same complexity, but the <code>any()</code> wasn't making use of it. That was scanning a <i>list</i></span>
<span class="comment-copy">That's a neat trick. Emphasis on Python 3.6+</span>
<span class="comment-copy">so the logic behind taking the reverse of the list is to overwrite the earlier time stamp right? ... This is a really good solution. Thanks!!</span>
<span class="comment-copy">@YashTibrewal Exactly.</span>
