<div class="post-text" itemprop="text">
<p>I have an input file that I am trying to build a data base from.  <br/>
<strong>Each line looks like this:</strong> <br/></p>
<pre><code>Amy Shchumer, Trainwreck, I Feel Pretty, Snatched, Inside Amy Shchumer  
Bill Hader,Inside Out,  Trainwreck, Tropic Thunder 
</code></pre>
<p>And so on.  <br/>
The first string is an actor\actress, and then movies they played in.  <br/>
The data isn't sorted and they are some trailing whitespaces.  <br/></p>
<p><strong>I would like to create a dictionary that would look like this:</strong> <br/>
<code>{'Trainwreck': {'Amy Shchumer', 'Bill Hader'}}</code> <br/>
The key would be the movie, the values should be the actors in it, unified in a set data type.  <br/></p>
<pre><code>def create_db():
   my_dict = {}
   raw_data = open('database.txt','r+') 
   for line in raw_data:
      lst1 = line.split(",") //to split by the commas 
      len_row = len(lst1)
      lst2 = list(lst1) 
      for j in range(1,len_row):
         my_dict[lst2[j]] = set([lst2[0]])
print(my_dict)
</code></pre>
<p>It doesn't work... it doesn't solve the issue that when a key already exists then the actor should be unified in a set with the prev actor  <br/></p>
<p><strong>Instead I end up with:</strong> <br/>
<code>'Trainwreck': {'Amy Shchumer'}, 'Inside Out': {'Bill Hader'}</code> <br/></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def create_db():
    db = {}
    with open("database.txt") as data:
        for line in data.readlines():
            person, *movies = line.split(",")
            for m in movies:
                m = m.strip()
                db[m] = db.get(m, []) + [person]

    return db
</code></pre>
<p>Output:</p>
<pre><code>{'Trainwreck': ['Amy Shchumer', 'Bill Hader'], 
 'I Feel Pretty': ['Amy Shchumer'], 
 'Snatched': ['Amy Shchumer'], 
 'Inside Amy Shchumer': ['Amy Shchumer'], 
 'Inside Out': ['Bill Hader'], 
 'Tropic Thunder': ['Bill Hader']}
</code></pre>
<p>This will loop through the data and assign the first value of each line to <code>person</code> and the rest to <code>movies</code> (see <a href="https://www.geeksforgeeks.org/unpacking-a-tuple-in-python/" rel="nofollow noreferrer">here</a> for an example of how <code>*</code> unpacks tuples). Then for all the movies, it uses <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">.get</a> to check if it’s in the database yet, returning the list if it is and an empty list if it isn’t. Then it adds the new actor to the list.</p>
<p>Another way to do this would be to use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a>:</p>
<pre><code>from collections import defaultdict

def create_db():
    db = defaultdict(lambda: [])
    with open("database.txt") as data:
        for line in data.readlines():
            person, *movies = line.split(",")
            for m in movies:
                db[m.strip()].append(person)

    return db
</code></pre>
<p>which automatically assigns <code>[]</code> if the key does not exist.</p>
</div>
