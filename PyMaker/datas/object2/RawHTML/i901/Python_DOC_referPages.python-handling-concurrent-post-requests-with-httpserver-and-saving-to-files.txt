<div class="post-text" itemprop="text">
<p>I have the code below that I would like to use to receive POST requests with data that I will then use to print labels on a label printer. In order to print the labels I will need to write a file with print commands and then do a <code>lp</code> command via the command line to copy the file to the label printer.</p>
<p>The problem I have is that multiple people could be printing labels at the same time. So my question is do I have to change the code below to use <code>ThreadingMixIn</code> in order to handle concurrent POST requests or can I leave the code as is and there will only be a slight delay for secondary request in a concurrent scenario (that is any further requests will be queued and not lost)?</p>
<p>If I have to go the threaded way how does that impact the writing of the file and subsequent command line call to <code>lp</code> if there are now multiple threads trying to write to the same file?</p>
<p>Note that there are multiple label printers that are being accessed through print queues (CUPS).</p>
<pre><code>import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from io import BytesIO

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'Hello, world!')
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        body = self.rfile.read(content_length)
        try:
            result = json.loads(body, encoding='utf-8')
            self.send_response(200)
            self.end_headers()
            response = BytesIO()
            response.write(b'This is POST request. ')
            response.write(b'Received: ')
            response.write(body)
            self.wfile.write(response.getvalue())
        except Exception as exc:
            self.wfile.write('Request has failed to process. Error: %s', exc.message)

httpd = HTTPServer(('localhost', 8000), SimpleHTTPRequestHandler)
httpd.serve_forever()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not trying to use unique file name?
In this way you are sure that there will be no names clash.
Have a look on <a href="https://docs.python.org/2/library/tempfile.html" rel="nofollow noreferrer">https://docs.python.org/2/library/tempfile.html</a> , consider NamedTemporaryFile function. You should use delete=False, otherway the file is deleted imediatelly after close() .</p>
</div>
<div class="post-text" itemprop="text">
<p>according to your question what I understand is that you have only one label printer and you have multiple producers who try to print labels on it. </p>
<p>So even if you switch to a multithreading option you will have to synchronize threads in order to avoid deadlocks and infinite waiting,</p>
<p>So my best take is to go with a builtin python data structure called <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">queue</a></p>
<p>according to the <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">doc</a></p>
<blockquote>
<p>The queue module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads. The Queue class in this module implements all the required locking semantics. It depends on the availability of thread support in Python,</p>
</blockquote>
<p>Even though its a multi-consumer, multi-producer queue I suppose it will still work for you like a charm.</p>
<p><strong>So here is what you need to do</strong></p>
<ol>
<li>Your server receives a request to print the label, </li>
<li>do the necessary processing/cleanup and put it in the queue</li>
<li>A worker thread pops the items from the queue and executes the task</li>
</ol>
<p>or if you would expect the system to be big enough, here are some links, but steps would be same as above</p>
<ul>
<li><p><a href="https://www.rabbitmq.com/" rel="nofollow noreferrer">RabbitMq</a> - A scalable message broker (simply put a queue)</p></li>
<li><p><a href="http://www.celeryproject.org/" rel="nofollow noreferrer">Celery</a> - A python package for popping items from a message broker such as rabbitmq and executes it</p></li>
</ul>
</div>
<span class="comment-copy">This does not answer any of my questions</span>
<span class="comment-copy">I have multiple label printers. I've had a look at RabbitMq and Celery before but found them too complex to understand. My question really is whether I can avoid threading. Are you saying I can't?</span>
<span class="comment-copy"><code>&gt;I have multiple label printers</code>. in this case, you should go with a message broker system such as rabbitmq, and celery. And if you use these then thread management is out of the question. Which saves much pain in the future</span>
<span class="comment-copy">maybe you can take a look at these alternatives for celery <a href="https://stackoverflow.com/q/46517613/2693543">stackoverflow.com/q/46517613/2693543</a></span>
<span class="comment-copy">Not sure what you mean by "if you use these then thread management is out of the question"</span>
<span class="comment-copy">The post data will identify the printer to be used and the python <code>httpserver</code> would then route it to the appropriate printer queue. Was hoping for more than "should be fine".</span>
