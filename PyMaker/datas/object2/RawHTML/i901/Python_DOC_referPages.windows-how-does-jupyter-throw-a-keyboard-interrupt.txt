<div class="post-text" itemprop="text">
<p>I know how to interrupt the kernel (such as by tapping <code>I</code> twice or by interrupting the kernel on the web interface). However, I built a C-extension for Python (I'm using Windows) that handles CTRL-C events in my C++ code (a toy example):</p>
<pre><code>static int s_interrupted = 0;

BOOL WINAPI consoleHandler(DWORD fdwCtrlType) {

  switch (fdwCtrlType)
  {
  // Handle the CTRL-C signal.
  case CTRL_C_EVENT:
      s_interrupted = 1;
      return TRUE;
  }
}

int main() {
    s_interrupted = 0;
    int output = 1;
    if (!SetConsoleCtrlHandler(consoleHandler, TRUE)) {
        std::cout&lt;&lt;"ERROR: Could not set control handler"&lt;&lt;std::endl;
    } else {
        std::cout&lt;&lt;"Control hanlder installed"&lt;&lt;std::endl;
    }
    int k = 10000;
    while (int i &lt; k) {
        if (s_interrupted == 1) {
            output = -1;
            break;
        }
         output = i
         i = i + 1;
    }
    return output;
}
</code></pre>
<p>The output of my main program changes depending on the value of <code>s_interrupted</code>. In other words, if I don't press CTRL+C, the program will finish the while loop and return an integer. If I press CTRL+C, the while loop will be terminated and return a different integer. I don't expect to see a <code>KeyboardInterrupt</code> in my Python terminal.</p>
<p>It works fine, when I call this C extension in the terminal. However, when I do it in a Jupyter notebook, the program behaves as if I never interrupted the kernel. Does Jupyter not send a <code>SIGINT</code> when I interrupt the kernel?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code does not install signal handlers and <code>s_signal_handler</code> is not used. You need to call <code>signal</code> function to register your callback.</p>
<pre><code>#include &lt;atomic&gt;
#include &lt;signal.h&gt;

::std::atomic&lt;bool&gt; s_interrupted{};

static void signal_handler(int signal)
{
  s_interrupted = true;
}

int main()
{
    ::signal(SIGINT, &amp;::signal_handler);
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't use <code>consoleHandler()</code> here, because <em>there is no console</em>. The IPython kernel is a 'headless' child process that executes code on request, directed by the Jupyter frontend.</p>
<p>To interrupt a running IPython kernel, the Jupyter front-end uses the <code>SIGINT</code> signal. It does so on both POSIX and on Windows; on Windows Jupyter uses additional infrastructure built around <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-createeventa" rel="nofollow noreferrer"><code>CreateEventA</code></a>, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-setevent" rel="nofollow noreferrer"><code>SetEvent</code></a> and <a href="https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjects" rel="nofollow noreferrer"><code>WaitForMultipleObjects</code></a> to achieve the same result as a POSIX <code>os.killpg(PID, SIGINT)</code> call; a separate thread polls for the event and triggers a <code>SIGINT</code> signal in the main thread.</p>
<p>Note that the IPython kernel explicitly restores the Python default signal handler for every message it handles. See the <a href="https://github.com/ipython/ipykernel/blob/34ca17011c1e79f65290b88f1deb18ac03e142af/ipykernel/kernelbase.py#L280-L287" rel="nofollow noreferrer"><code>ipykernel.kernelbase.Kernel</code> implementations for the <code>pre_</code> and <code>post_handler_hook</code> methods</a>:</p>
<pre><code> self.saved_sigint_handler = signal(SIGINT, default_int_handler)
</code></pre>
<p>and</p>
<pre><code> signal(SIGINT, self.saved_sigint_handler)
</code></pre>
<p>These two hooks are executed before and after every message handler (so for <a href="https://jupyter-client.readthedocs.io/en/stable/messaging.html" rel="nofollow noreferrer">every message sent by the frontend to the kernel process</a>, including <a href="https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute" rel="nofollow noreferrer">execute messages</a>).</p>
<p>It is <code>signal.default_int_handler</code> that raises <code>KeyboardInterrupt</code> in the main Python thread. If your code must detect interrupts, it will need to register its own <code>signal</code> handler each time IPython exeucutes a cell.</p>
<p>As a side note: a standalone interactive Python interpreter doesn't use <code>SetConsoleCtrlHandler</code> to detect keyboard interrupts <em>either</em>; the only place that is used in the Python source code is in the <a href="https://docs.python.org/3/using/windows.html#launcher" rel="nofollow noreferrer"><code>py</code> launcher</a>, and only then to silence control codes with a handler that returns <code>TRUE</code>, always. Instead, Python relies on <a href="https://docs.microsoft.com/en-us/windows/console/ctrl-c-and-ctrl-break-signals" rel="nofollow noreferrer">Windows sending the <code>SIGINT</code> signal to all attached console processes for the active console window</a>.</p>
</div>
<span class="comment-copy">Have you read the <a href="https://jupyter-client.readthedocs.io/en/stable/messaging.html" rel="nofollow noreferrer">Jupyter messaging documentation</a>? Restarting a kernel is just another message from front-end to back-end.</span>
<span class="comment-copy">Sorry, I updated my code. <code>s_signal_handler</code> is not necessary here. I already have <code>consoleHandler</code>. What does <code>::signal()</code> do?</span>
<span class="comment-copy">@user1691278 <code>signal</code> function registers signal handlers so you can actually handle <code>SIGINT</code></span>
<span class="comment-copy">doesn't <code>SetConsoleCtrlHandler</code> do the job though?</span>
<span class="comment-copy">@user1691278 It kinda does, but it is a windows specific thing and signal handlers are more portable. And <code>CTRL+C</code> is not exactly the same as <code>SIGINT</code></span>
<span class="comment-copy">What is <code>CTRL+C</code> then?</span>
