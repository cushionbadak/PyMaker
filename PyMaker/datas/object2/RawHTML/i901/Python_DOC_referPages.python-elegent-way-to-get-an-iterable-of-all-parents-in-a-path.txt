<div class="post-text" itemprop="text">
<p>Working with a path-based resource system, the application needs to find the first working resource that manages a given resource based on paths. I need a succinct, pythonic way to generate the following:</p>
<p><strong>Input:</strong></p>
<pre><code>/house/dogs/ralph/bone
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>/house/dogs/ralph/bone
/house/dogs/ralph
/house/dogs
/house
</code></pre>
<p>Note: It's okay to use <code>os.path</code> or similar built-ins, but these are not filesystem resources. Output can be anything iterable (list, set, generator, etc.).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a>. <a href="https://docs.python.org/3/library/pathlib.html#pure-paths" rel="nofollow noreferrer"><code>PurePath</code></a>s offer an abstract interface to path-like objects that have no relationship to the file system. In particular, <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePosixPath" rel="nofollow noreferrer"><code>PurePosixPath</code></a> is the kind that uses forward slashes (<code>/</code>) as separators:</p>
<pre><code>&gt;&gt;&gt; from pathlib import PurePosixPath
&gt;&gt;&gt; p = PurePosixPath('/house/dogs/ralph/bone')
&gt;&gt;&gt; str(p.parent)
/house/dogs/ralph
&gt;&gt;&gt; str(p.parent.parent)
/house/dogs
</code></pre>
<p>You can loop this easily:</p>
<pre><code>p = PurePosixPath(...)
while p != p.root:
    # Do stuff to p
    p = p.parent
</code></pre>
<p>A fairly pythonic finishing touch would be to make it a generator:</p>
<pre><code>def receding_path(p):
    p = PurePosixPath(p)
    while p != p.root:
        yield str(p)
        p = p.parent

for item in receding_path('/house/dogs/ralph/bone'):
    # do stuff to each item
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way would be to split the string on <code>"/"</code> and take successive slices.</p>
<pre><code>in_string = "/house/dogs/ralph/bone"
s = in_string.split("/")
out_strings = list(filter(None, ("/".join(s[:i+1]) for i in range(len(s)))))
print(out_strings)
#['/house', '/house/dogs', '/house/dogs/ralph', '/house/dogs/ralph/bone']
</code></pre>
<p>The <code>filter(None, ...)</code> is used to remove empty strings.</p>
<p>Or reverse the range if you want the output in the order you specified in your post:</p>
<pre><code>out_strings = list(filter(None, ("/".join(s[:i]) for i in range(len(s), 0, -1))))
print(out_strings)
#['/house/dogs/ralph/bone',
# '/house/dogs/ralph',
# '/house/dogs',
# '/house']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something of a combination of the previous two answers:</p>
<pre><code>import pathlib
import os
def resources(path):
  parts = pathlib.Path(path).parts
  for n in range(len(parts), 1, -1):
    yield os.path.join(*parts[:n])
</code></pre>
</div>
<span class="comment-copy">Why can't  you split the string on <code>/</code> and take slices?</span>
<span class="comment-copy">I can. I'm looking for the best (pythonic) way to do it.  My first thought is to split/join in a recursive function, <code>yield</code>ing the result, but there's got to be a better way.</span>
<span class="comment-copy">I've updated my answer to emphasize the non-file nature of pure posix paths</span>
<span class="comment-copy">Curious: is there a reason that you are filtering instead of just referencing <code>[:-1]</code> since only the last element is empty?</span>
<span class="comment-copy">@Bobby the delimiter can appear at the start or end of the string in a path. After the <code>split</code>, this causes empty strings. Using the <code>filter</code> I don't have to figure out which index to exclude, and it maintains the generator (which can't be indexed).</span>
<span class="comment-copy">You might want to use <code>'/'.join</code> instead of <code>os.path.join</code> to make it OS independent. Then maybe strip off the first element?</span>
<span class="comment-copy">I'm under the impression that os.path.join is OS independent, and that using '/' would make it OS-dependent (works in Unix based systems only). os.path.join also does the right thing with the top level element automatically.</span>
<span class="comment-copy">@JeffreyFroman, I believe what @MadPhysicist is saying is that if you use <code>os.path.join</code>, the outcome will be different if you aren't on a *nix system.  It's OS independence will make your solution not run on Linux.</span>
<span class="comment-copy">Right, I undertsand that @Bobby:  <code>os.path.join</code> will use the OS. path separator for that OS. If we ARE dealing with strings that are filesystem paths, then presumably those strings will include the separator appropriate to that OS. If the strings are not filesystem paths for the OS we'll be running on, then pathlib won't work at all, and we have to operate on raw strings and characters as such. We agree how os.path.join works -- if we're going to be using pathlib, we are already making the assumption that we're using a <i>path</i> appropriate to the OS we're running on.</span>
<span class="comment-copy">@Bobby. The opposite. It will run as desired on Linux, but not on Windows. OP is looking for a forward slash separated path, on all systems.</span>
