<div class="post-text" itemprop="text">
<p>I want to compactly encode a large unsigned or signed integer having an arbitrary number of bits into a base64, base32, or base16 (hexadecimal) representation. The output will ultimately be used as a string which will be used as a filename, but this should be beside the point. I am using the latest Python 3.</p>
<p>This works but is far from compact:</p>
<pre><code>&gt;&gt;&gt; import base64, sys
&gt;&gt;&gt; i: int = 2**62 - 3  # Can be signed or unsigned.
&gt;&gt;&gt; b64: bytes =  base64.b64encode(str(i).encode()) # Not a compact encoding.
&gt;&gt;&gt; len(b64), sys.getsizeof(b64)
(28, 61)
</code></pre>
<p>There is a <a href="https://stackoverflow.com/questions/18616657/how-to-encode-integer-in-to-base64-string-in-python-3/">prior question</a>, now closed, the answers for which strictly concern with an inefficient representations. Note again that we don't want to use any strings or needlessly long sequences of bytes in this exercise. As such, this question is not a duplicate of that question.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer is motivated in part by disparate comments by Erik A., such as for <a href="https://stackoverflow.com/a/18616883/832230">this</a> answer. The integer is first compactly converted to bytes, following which the bytes are encoded to a variable <a href="https://docs.python.org/library/base64.html" rel="nofollow noreferrer">base</a>.</p>
<p>Refer to the included tests for usage examples.</p>
<pre><code>from typing import Callable, Optional
import base64

class IntBaseEncoder:
    """Reversibly encode an unsigned or signed integer into a customizable encoding of a variable or fixed length."""
    # Ref: https://stackoverflow.com/a/54152763/
    def __init__(self, encoding: str, *, bits: Optional[int] = None, signed: bool = False):
        """
        :param encoder: Name of encoding from base64 module, e.g. b64, urlsafe_b64, b32, b16, etc.
        :param bits: Max bit length of int which is to be encoded. If specified, the encoding is of a fixed length,
        otherwise of a variable length.
        :param signed: If True, integers are considered signed, otherwise unsigned.
        """
        self._decoder: Callable[[bytes], bytes] = getattr(base64, f'{encoding}decode')
        self._encoder: Callable[[bytes], bytes] = getattr(base64, f'{encoding}encode')
        self.signed: bool = signed
        self.bytes_length: Optional[int] = bits and self._bytes_length(2 ** bits - 1)

    def _bytes_length(self, i: int) -&gt; int:
        return (i.bit_length() + 7 + self.signed) // 8

    def encode(self, i: int) -&gt; bytes:
        length = self.bytes_length or self._bytes_length(i)
        i_bytes = i.to_bytes(length, byteorder='big', signed=self.signed)
        return self._encoder(i_bytes)

    def decode(self, b64: bytes) -&gt; int:
        i_bytes = self._decoder(b64)
        return int.from_bytes(i_bytes, byteorder='big', signed=self.signed)

# Tests:
import unittest

class TestIntBaseEncoder(unittest.TestCase):

    ENCODINGS = ('b85', 'b64', 'urlsafe_b64', 'b32', 'b16')

    def test_unsigned_with_variable_length(self):
        for encoding in self.ENCODINGS:
            encoder = IntBaseEncoder(encoding)
            previous_length = 0
            for i in range(1234):
                encoded = encoder.encode(i)
                self.assertGreaterEqual(len(encoded), previous_length)
                self.assertEqual(i, encoder.decode(encoded))

    def test_signed_with_variable_length(self):
        for encoding in self.ENCODINGS:
            encoder = IntBaseEncoder(encoding, signed=True)
            previous_length = 0
            for i in range(-1234, 1234):
                encoded = encoder.encode(i)
                self.assertGreaterEqual(len(encoded), previous_length)
                self.assertEqual(i, encoder.decode(encoded))

    def test_unsigned_with_fixed_length(self):
        for encoding in self.ENCODINGS:
            for maxint in range(257):
                encoder = IntBaseEncoder(encoding, bits=maxint.bit_length())
                maxlen = len(encoder.encode(maxint))
                for i in range(maxint + 1):
                    encoded = encoder.encode(i)
                    self.assertEqual(len(encoded), maxlen)
                    self.assertEqual(i, encoder.decode(encoded))

    def test_signed_with_fixed_length(self):
        for encoding in self.ENCODINGS:
            for maxint in range(257):
                encoder = IntBaseEncoder(encoding, bits=maxint.bit_length(), signed=True)
                maxlen = len(encoder.encode(maxint))
                for i in range(-maxint, maxint + 1):
                    encoded = encoder.encode(i)
                    self.assertEqual(len(encoded), maxlen)
                    self.assertEqual(i, encoder.decode(encoded))

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>If using the output as a filename, initializing the encoder with the encoding <a href="https://docs.python.org/3/library/base64.html#base64.urlsafe_b64encode" rel="nofollow noreferrer"><code>'urlsafe_b64'</code></a> or even <code>'b16'</code> are safer choices.</p>
<p>Usage examples:</p>
<pre><code># Variable length encoding
&gt;&gt;&gt; encoder = IntBaseEncoder('urlsafe_b64')
&gt;&gt;&gt; encoder.encode(12345)
b'MDk='
&gt;&gt;&gt; encoder.decode(_)
12345

# Fixed length encoding
&gt;&gt;&gt; encoder = IntBaseEncoder('b16', bits=32)
&gt;&gt;&gt; encoder.encode(12345)
b'00003039'
&gt;&gt;&gt; encoder.encode(123456789)
b'075BCD15'
&gt;&gt;&gt; encoder.decode(_)
123456789

# Signed
encoder = IntBaseEncoder('b32', signed=True)
encoder.encode(-12345)
b'Z7DQ===='
encoder.decode(_)
-12345
</code></pre>
</div>
<span class="comment-copy">What is the <i>goal</i> of the base64 encoding here? What kind of data is being stored, are you encoding to make transfer easy, what kind of clients need to read this data again?</span>
<span class="comment-copy">I'm asking for context because it is possible, almost likely, that there are better options available. base64 is not a common encoding for individual integer values.</span>
<span class="comment-copy">@A-B-B: if the goal is to embed the value, compactly, into a string, then there are more options available. Is base85 acceptable? What restrictions do you place on the value, characterwise?</span>
<span class="comment-copy">@A-B-B; base85 is not safe for filenames, so no, that'd not be a better answer at this point.</span>
<span class="comment-copy">the goal is to encode an int as a string efficiently ans using as many builtins as possible and have it not be limited by the size of the string.  the best way to do this is to a) convert the <code>int.to_bytes</code>, then convert the bytes to a string.   selecting the base64 "safe" versions will allow embedding in filenames and urls.</span>
