<div class="post-text" itemprop="text">
<p>I am trying to take a list, and from it choose a number <code>i</code> randomly. Following which, I want to select a second element <code>j</code>. The probability of choosing a <code>j</code> decays as <code>1/|i-j|</code>. For example, the relative probability of it choosing a <code>j</code> four steps away from my initial <code>i</code> is 1/4, the probability of selecting a <code>j</code> immediately next to my <code>i</code>.</p>
<p>So far what I have been trying to do is populate my list, choose my <code>i</code>, first then calculate weights using <code>|i-j|</code> for all the other elements in the list.</p>
<pre><code>import numpy as np
import random as random
list = [1,2,3,4,5,6,7,8,9,10]
a = 1
n1 = random.choice(range(len(list)))
n1_coord = (n1, list[n1])
print(n1_coord)
prob_weights = []
for i in range(0, n1):
    wt = 1/((np.absolute(n1-i)))
    #print(wt)
    prob_weights.append(wt)
for i in range(n1+1,len(list)):
    wt = 1/((np.absolute(n1-i)))
    prob_weights.append(wt)
</code></pre>
<p>Is there a function built in python that I can feed these weights into which will choose a <code>j</code> with this probability distribution.  Can I feed my array of weights in to:</p>
<pre><code>numpy.random.choice(a, size=None, replace=True, p=None)
</code></pre>
<p>I suppose I will let p=prob_weights in my code?</p>
<pre><code> import numpy as np
    import random as random
    list = [1,2,3,4,5,6,7,8,9,10]
    a = 1
    n1 = random.choice(range(len(list)))
    n1_coord = (n1, list[n1])
    print(n1_coord)
    prob_weights = []
    for i in range(0, n1):
        wt = 1/((np.absolute(n1-i)))
        #print(wt)
        prob_weights.append(wt)
    for i in range(n1+1,len(list)):
        wt = 1/((np.absolute(n1-i)))
        prob_weights.append(wt)
    n2 = np.random.choice(range(len(list)), p=prob_weights)
    n2_coord = (n2, list[n2])
</code></pre>
<p>Running this above with <code>np.random.choice</code> gives me an error. I am not even sure if this is doing what I want it do in the first place. Is there an alternate way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a built in function for this: <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a>, which accepts a <code>weights</code> argument.</p>
<p>Given your first selected index <code>n1</code>, you can do something like</p>
<pre><code>indices = range(len(mylist))
weights = [0 if i == n1 else 1 / abs(i - n1) for i in indices]
n2 = random.choices(indices, weights=prb_wts, k=1).
</code></pre>
<p>By setting the weight of the first item to zero, you prevent it form bering selected.</p>
<p>Numerical operations do tend to be faster when using numpy, so you can use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html#numpy.random.choice" rel="nofollow noreferrer"><code>np.random.choice</code></a>, which accepts a <code>p</code> argument:</p>
<pre><code>values = np.array([...])
indices = np.arange(values.size)

n1 = np.random.choice(indices)
i = values[n1]

delta = np.abs(indices - n1)
weights = np.divide(1.0, delta, where=delta)
n2 = np.random.choice(indices, p=weights)
j = values[n2]
</code></pre>
<p>As minor nitpicks, don't call a variable <code>list</code>, since that shadows a built-in, and <code>import x as x</code> is just <code>import x</code>.</p>
</div>
<span class="comment-copy">Oh wow! I did not need two for loops to make my array of weights. would the indices of the weights be ordered in the same way the indices of the original list?</span>
<span class="comment-copy">@jcp yes. The list of weights is the same size as the list of numbers. The elements correspond by index. Since the weight only depends on position, not value, the list comprehension does not reference the list directly.</span>
<span class="comment-copy">Oh great. Thank you. I guess the error I was having with my original code was a size mismatch. Doing it your way certainly fixes it.</span>
<span class="comment-copy">Just to make sure: prb_wts = [0 if i == n1 else 1/abs(i - n1) for i in range(len(mylist))] n2 = np.random.choices(range(len(mylist)), weights=prb_wts, k=1). This throws a new error: AttributeError: module 'numpy.random' has no attribute 'choices'. I am running python 3.7.0. Is this function only available in more recent versions?</span>
<span class="comment-copy">@jcp. Choices is in the plain Python random module, not np.random. The linked docs should make that clear. I've added a numpy solution too. You should probably add a numpy tag to your question.</span>
