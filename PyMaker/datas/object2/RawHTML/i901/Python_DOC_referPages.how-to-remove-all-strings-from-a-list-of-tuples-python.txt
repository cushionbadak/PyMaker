<div class="post-text" itemprop="text">
<p>I am trying to remove all strings from a list of tuples</p>
<pre><code>ListTuples = [(100, 'AAA'), (80, 'BBB'), (20, 'CCC'), (40, 'DDD'), (40, 'EEE')]
</code></pre>
<p>I have started to try and find a solution:</p>
<pre><code>output = [i for i in ListTuples if i[0] == str]

print(output)
</code></pre>
<p>But I can't seem to get my head around how I would get an output like:</p>
<pre><code>[(100), (80), (20), (40), (40)]
</code></pre>
<p>The format is always (<code>int</code>, <code>str</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a nested tuple comprehension and <code>isinstance</code>:</p>
<pre><code>output = [tuple(j for j in i if not isinstance(j, str)) for i in ListTuples]
</code></pre>
<p>Output:</p>
<pre><code>[(100,), (80,), (20,), (40,), (40,)]
</code></pre>
<p>Note that there are trailing commas in the tuples to distinguish them from e.g. <code>(100)</code> which is identical to <code>100</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since extracting the first item of each tuple is sufficient, you can unpack and use a list comprehension. For a list of tuples:</p>
<pre><code>res = [(value,) for value, _ in ListTuples]  # [(100,), (80,), (20,), (40,), (40,)]
</code></pre>
<p>If you need just a list of integers:</p>
<pre><code>res = [value for value, _ in ListTuples]     # [100, 80, 20, 40, 40]
</code></pre>
<p>For a functional alternative to the latter, you can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a>:</p>
<pre><code>from operator import itemgetter
res = list(map(itemgetter(0), ListTuples))   # [100, 80, 20, 40, 40]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another solution using <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter()</code></a>:</p>
<pre><code>def non_string(x):
    return not isinstance(x, str)

print([tuple(filter(non_string, x)) for x in ListTuples])
# [(100,), (80,), (20,), (40,), (40,)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this</p>
<pre><code>ListTuples = [(100, 'AAA'), (80, 'BBB'), (20, 'CCC'), (40, 'DDD'), (40, 'EEE')]

ListInt = []
ListStr = []

for item in ListTuples:
    strAux = ''
    intAux = ''
    for i in range(0, len(item)):

        if(isinstance(item[i], str)):
            strAux+=item[i] 
        else:
            intAux+=str(item[i])


    ListStr.append(strAux)
    ListInt.append(intAux)


print(ListStr)

'''TO CONVERT THE STR LIST TO AN INT LIST'''
output= list(map(int, ListInt)) 
print(output)
</code></pre>
<p>The output is <code>[100, 80, 20, 40, 40]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>We check if a particular value is a string or not using <code>type(value)</code>.</p>
<pre><code>output = [tuple([j for j in i if type(j)!=str]) for i in ListTuples]
print(output)
    [(100,), (80,), (20,), (40,), (40,)]
</code></pre>
</div>
<span class="comment-copy">Do you know that you are always going to have items of the form <code>[(&lt;int&gt;, &lt;str&gt;), ...]</code>?</span>
<span class="comment-copy">If the format is always (<code>int</code>, <code>str</code>) the following could be a simple solution: <code>output = [(i[0],) for i in ListTuples]</code></span>
<span class="comment-copy">@MarkNijboer Yes this is also perfect</span>
<span class="comment-copy">This answer does no match OP's desired output!</span>
<span class="comment-copy">@RoadRunner, Not true, <code>[(100), (80), (20), (40), (40)]</code> is valid Python, it's a list of integers!</span>
<span class="comment-copy">Thank you, this worked perfectly! I just have to change the isinstance(j, str) to isinstance(j, int) to get the integer values I'm after. I will accept this answer</span>
<span class="comment-copy">I think this <i>does</i> match OP's desired output, or rather what OP (probably) intended to show, not how that's interpreted by Python.</span>
<span class="comment-copy">@a.rowland If you want to "remove all strings", then you should use <code>not isinstance(j, str)</code>, otherwise it would be "keep all integers", which is not strictly the same. (In your example, both would be equivalent, though.)</span>
<span class="comment-copy">What are those "aux" accumulators for? Why not directly <code>appen</code> in the <code>if/else</code>? This will fail for <code>[(1, "foo", 3)]</code> or any other tuple that has more than one of each type, and for any other cases those "aux" variables have no use, either.</span>
<span class="comment-copy">If you <code>appen</code> in <code>if/else</code> it you retrieve <code>'A', 'A', 'A', 'B' 'B' </code> and so on, because its inside <code>for loop</code>. If you try <code>[(1, "foo", 3)]</code>it will return <code>13</code> and <code>foo</code></span>
<span class="comment-copy">No, it does not, as you are not iterating the characters <i>in</i> the string, just the elements in the tuple. And, yes, it will return <i>that</i>, and I don't think that that's what OP intended.</span>
