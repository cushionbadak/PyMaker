<div class="post-text" itemprop="text">
<p>I have the following my_func.py with create_config function.</p>
<p>*my_func.py</p>
<pre><code>from fabric.state import env

def create_config(node_name):
    config = {
    "log_level": "INFO",
    "addr1": "127.0.0.1",
    }
    config["addr2"] = env.host
    return config
</code></pre>
<p>I tried the following approach to mock env.host variable where env is an import from fabric.state.</p>
<p>*test.py</p>
<pre><code>import unittest
import my_func
import mock


class MyTestCase(unittest.TestCase):
    def setUp(self):
        self.master_config = {
              "log_level": "INFO",
              "addr2": "0.0.0.0",
              "addr1": "127.0.0.1",
        }

    @mock.patch('env.host')
    def test_create_consul_config(self, mock_host):
        mock_host.return_value = "0.0.0.0"
        result = my_func.create_config('master')
        self.assertDictEqual(self.master_config, result)


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>I am getting import error with 'env'. What is the best way to mock variable within a function with python mock.</p>
<pre><code>ImportError: No module named env
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>mock variable <code>env.host</code>?</p>
</blockquote>
<p>get the type of <code>env</code> first</p>
<pre><code>In [6]: from fabric.state import env

In [7]: type(env)
Out[7]: fabric.utils._AttributeDict
</code></pre>
<p><code>env.host</code> is instance variable of a class, the mock is a little different, mock_env is object(AttributeDict), the assignment of instance_variable host is direct assignment, not with a return_value</p>
<pre><code>@mock.patch('my_func.env')
def test_create_consul_config(self, mock_env):
    mock_env.host = 'xxx'
    result = my_func.create_config('master')

    self.assertDictEqual(self.master_config, result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">unittest.mock documentation on patch</a> (note <code>target</code> is the first argument of <code>patch</code>):</p>
<blockquote>
<p>target should be a string in the form 'package.module.ClassName'. The
  target is imported and the specified object replaced with the new
  object, so the target must be importable from the environment you are
  calling patch() from. The target is imported when the decorated
  function is executed, not at decoration time.</p>
</blockquote>
<p>So you need to include the full path to the function you are patching. Note also in <a href="https://docs.python.org/3/library/unittest.mock.html#id5" rel="nofollow noreferrer">where to patch</a> that the target should be the path to where the function/object is used, not where it is defined.</p>
<p>So changing your <code>patch</code> call to:</p>
<pre><code>@mock.patch("my_func.env.host")
</code></pre>
<p>should fix the <code>ImportError</code>.</p>
</div>
<span class="comment-copy">the code says <code>provision</code> but you label the file <code>my_func.py</code> which one is it?</span>
<span class="comment-copy">now getting AttributeError: host, I can see the "0.0.0.0" in mock_host object's return_value but it is not being assigned to config["addr2"]</span>
<span class="comment-copy">@Anish, actually looking back, <code>@mock.patch('my_func.env')</code> make more sense than mock env.host</span>
<span class="comment-copy">@Anish, the host is a instance variable, which ends up with different patching technique</span>
