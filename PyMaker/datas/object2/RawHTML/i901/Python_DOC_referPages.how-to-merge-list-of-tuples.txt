<div class="post-text" itemprop="text">
<p>I have two lists of tuples like this:</p>
<pre><code>x1 = [('A', 3), ('B', 4), ('C', 5)]

x2 = [('B', 4), ('C', 5), ('D', 6)]
</code></pre>
<p>I want to merge the two lists as a new one x3 so that the values in the list are added.</p>
<pre><code>x3 = [('A', 3), ('B', 8), ('C', 10),('D',6)]
</code></pre>
<p>Could you please show me how I can do this? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a dictionary and then loop over the values in each list, and either adding to the current value for each key in the dictionary, or setting the value equal to the current value if no value currently exists. Afterwards you can cast back to a list.</p>
<p>For example:</p>
<pre><code>full_dict = {}
for x in [x1, x2]:
    for key, value in x:
        full_dict[key] = full_dict.get(key, 0) + value # add to the current value, if none found then use 0 as current value

x3 = list(full_dict.items())
</code></pre>
<p>Result for <code>x3</code>:</p>
<pre><code>[('A', 3), ('B', 8), ('C', 10), ('D', 6)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you tag <code>pandas</code> </p>
<pre><code>df1,df2=pd.DataFrame(x1),pd.DataFrame(x2)
pd.concat([df1,df2]).groupby(0,as_index=False).sum().apply(tuple,1).tolist()
[('A', 3), ('B', 8), ('C', 10), ('D', 6)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a></p>
<pre><code>&gt;&gt;&gt; x1 = [('A', 3), ('B', 4), ('C', 5)]
&gt;&gt;&gt; x2 = [('B', 4), ('C', 5), ('D', 6)]
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c1 = Counter(dict(x1))
&gt;&gt;&gt; c2 = Counter(dict(x2))
&gt;&gt;&gt; c3 = c1 + c2   
&gt;&gt;&gt; c3.items()
dict_items([('A', 3), ('B', 8), ('C', 10), ('D', 6)])
</code></pre>
<p>Just create a <code>Counter</code> for each list, you can do this by turning the list of tuples into an intermediate dict. Then just add the Counters. </p>
<p>To get the list back just call the items method of the counter. Technically what is returned is a <code>dict_items</code> object, if it really matters that its a <code>list</code> then just call list on <code>c3.items()</code> i.e. <code>list(c3.items())</code>.</p>
<p>An alternative 1 liner using groupby and heapq.merge.</p>
<pre><code>from heapq import merge
from itertools import groupby
from operator import itemgetter

x1 = [('A', 3), ('B', 4), ('C', 5)]
x2 = [('B', 4), ('C', 5), ('D', 6)]

result = [(a, sum(t[1] for t in b)) for a, b in groupby(merge(x1, x2), key=itemgetter(0))]
print(result)
</code></pre>
<p><a href="https://docs.python.org/3.7/library/heapq.html#heapq.merge" rel="nofollow noreferrer"><code>heapq.merge</code></a> is roughly equivalent to <code>sorted(itertools.chain(*iterables))</code>. It basically provides a sorted, merged list of the tuples, ready to be fed to groupby.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the following code works</p>
<pre><code>dict_x1=dict(x1)
for item in x2:
  if item[0] in dictx1:
    dictx1[item[0]] += item[1]
  else:
    dictx1[item[0] = item[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also solve this with <code>itertools</code></p>
<pre><code>from itertools import groupby
from operator import itemgetter

first = itemgetter(0)
second = itemgetter(1)
res = {}
data = x1 + x2

for _, g in groupby(sorted(data, key=first), key=first):
    group = list(g)
    k = first(first(group))
    v = sum(second(gr) for gr in group)
    res[k] = v

print(sorted(res.items(), key=first))

[('A', 3), ('B', 8), ('C', 10), ('D', 6)]
</code></pre>
</div>
<span class="comment-copy">use <code>collections.Counter</code>. You just add 2 instances directly.</span>
<span class="comment-copy">If you are doing this as an exercise, then talk through the logic youâ€™ve tried a bit more. Otherwise, use the Counter object from the collections package. High performance and does what you need.</span>
