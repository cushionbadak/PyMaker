<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/16033017/how-to-override-the-slice-functionality-of-list-in-its-derived-class">How to override the slice functionality of list in its derived class</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have a class called AudioBuffer that is derived from Python's list type.</p>
<p>Before you ask, yes, I <em>did</em> pass the necessary parameters up the parent chain.</p>
<pre><code>def __init__(self, *args, **kwargs):
    super(AudioBuffer, self).__init__(*args, **kwargs)
</code></pre>
<p>Everything works like a charm. I can use all list functionality including indexing.</p>
<p>The problem is: <strong>When I use index slicing on my objects, the returning object is a "list", instead of my AudioBuffer.</strong></p>
<p>Example:</p>
<pre><code>foo = AudioBuffer([15, 25, 35])
foo[1:].methodFromAudioBuffer()

AttributeError: 'list' object has no attribute 'methodFromAudioBuffer'
</code></pre>
<p>Now, <code>AudioBuffer(foo[1:]).methodFromAudioBuffer</code> comes to mind. But that creates a new instance of AudioBuffer. And I don't want that. I want a reference to my original object, because I want to modify parts of it. Just like Python's native index slicing functionality.</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Youâ€™d need to override the <code>__getitem__</code> method:</p>
<pre><code>class AudioBuffer(list):
    def __init__(self, *args, **kwargs):
       super(AudioBuffer, self).__init__(*args, **kwargs)

    def __getitem__(self, key):
        return AudioBuffer(list.__getitem__(self, key))

    def methodFromAudioBuffer(self):
        print("my list is", self)

&gt;&gt;&gt; foo = AudioBuffer([15, 25, 35])
&gt;&gt;&gt; foo[1:].methodFromAudioBuffer()
my list is [25, 35]
</code></pre>
<p>Also it is recommended when subclassing a sequence to subclass <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence" rel="nofollow noreferrer"><code>collections.MutableSequence</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to implement <code>__getitem__(self, key)</code> and there return your class.</p>
<p>From the Python documentation:</p>
<blockquote>
<p>Called to implement evaluation of self[key]. For sequence types, the
  accepted keys should be integers and slice objects. Note that the
  special interpretation of negative indexes (if the class wishes to
  emulate a sequence type) is up to the <strong>getitem</strong>() method. If key is
  of an inappropriate type, TypeError may be raised; if of a value
  outside the set of indexes for the sequence (after any special
  interpretation of negative values), IndexError should be raised. For
  mapping types, if key is missing (not in the container), KeyError
  should be raised.</p>
</blockquote>
<p>When you call <code>obj[0]</code> this is syntactic sugar for <code>obj.__getitem__(0)</code>. Therefore just override the <code>__getitem__</code> of your class to return an instance of your class instead.</p>
</div>
<span class="comment-copy">While I know nothing of Python I assume that the slicing is a language or list facility which is defined to return a list. That facility knows nothing of your class and thus returns a list. (Btw, I think it is a dup, the answer in @sedders123 link seems entirely relevant.)</span>
<span class="comment-copy">@PeterA.Schneider Thanks for that piece of wisdom, I appreciate it.</span>
<span class="comment-copy">Thank you. I appreciate the advice on MutableSequence. I'll definitely do that from now on.</span>
