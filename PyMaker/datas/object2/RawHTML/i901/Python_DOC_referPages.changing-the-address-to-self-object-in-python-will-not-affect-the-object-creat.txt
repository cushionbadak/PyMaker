<div class="post-text" itemprop="text">
<p>This code changes the address of self object to initial object address in init function from Subsequent initialization of object. But it actually creates new address for the object created. I understand scope of self is only during init function execution. My question is after init method finishes execution does it return anything?</p>
<hr/>
<pre><code>class A:
 addr = None
 def __init__(self):
  if A.addr:
   print("Current object address:",id(self))
   print("First object address:",id(A.addr))
   self = A.addr
   print("Current object address after modification:",id(self))
  else:
   print("Initial address",id(self))
   A.addr = self

&gt;&gt;&gt; a = A()
Initial address 2433753170104
&gt;&gt;&gt; b = A()
Current object address: 2433753170216
First object address: 2433753170104
Current object address after modification: 2433753170104
&gt;&gt;&gt; id(a),id(b)
(2433753170104, 2433753170216)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on my comment -- if you want a constructor to always return the exact same instance (this is known as a singleton) use the <code>__new__</code> constructor like so:</p>
<pre><code>class Singleton:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance


s1 = Singleton()

s2 = Singleton()

s1 is s2  # --&gt; True  (this is the same as id(s1) == id(s2))
</code></pre>
</div>
<span class="comment-copy">You're only changing what the identifier <code>self</code> refers to. You can't change the object on which <code>__init__</code> is running.</span>
<span class="comment-copy">Doing <code>self=</code> only overrides <code>self</code> in that method. It doesn't actually change the object. If you want to actually edit how an object is created, you'll have to use the <code>__new__</code> <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">method</a>.</span>
