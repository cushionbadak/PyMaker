<div class="post-text" itemprop="text">
<p>Given 1 to 100 numbers, for multiples of 3 it should print "he" ,for multiples of 5 it should print "llo" ,for both multiples of 3 and 5 it should print "hello". </p>
<p>This is what I have:</p>
<pre><code>for i in range (1,100):
if(i%3==0):
    print("he")
elif(i%5==0):
    print("llo")
elif(i%3==0 and i%5==0):
    print("hello")
</code></pre>
<p>How would I do this recursively? </p>
</div>
<div class="post-text" itemprop="text">
<p>How about the code below?</p>
<pre><code>def find_multiples(current, last_num=100):

    # Base Case
    if current &gt; last_num:
        return

    result = ""

    if current % 3 == 0:
        result += "he"

    if current % 5 == 0:
        result += "llo"

    if result:
        print(f"{current}: {result}")

    find_multiples(current+1, last_num)

find_multiples(1)
</code></pre>
<p>Base case is if <code>current</code> reaches <code>last_num</code> or the maximum number you'd like to check.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a general outline for doing simple recursive things in python:</p>
<pre><code>BASE_CASE = 1 #TODO

def f(current_case):
    if current_case == BASE_CASE:
        return #TODO: program logic here
    new_case = current_case - 2 #TODO: program logic here ("decrement" the current_case somehow)
    #TODO: even more program logic here
    return f(new_case) + 1 #TODO: program logic here
</code></pre>
<p>Of course, this doesn't handle all possible recursive programs.  However, it fits your case, and many others.  You would call <code>f(100)</code>, <code>100</code> would be <code>current_value</code>, you check to see if you've gotten to the bottom yet, and if so, return the appropriate value up the call stack.  If not, you create a new case, which, in your case, is the "decrement" logic normally handled by the "loop" construct.  You then do things for the current case, and then call the function again on the new case.  This repeated function calling is what makes it "recursive".  If you don't have an "if then" at the beginning of the function to handle the base case, and somewhere in the function recall the function on a "smaller" value, you're probably going to have a bad time with recursion.</p>
</div>
<span class="comment-copy">what have you tried so far?</span>
<span class="comment-copy">your code and 15 only prints "he" - not all 3  ...seems wrong and <code>i%5==5</code> is not possible at all ...</span>
<span class="comment-copy">@PatrickArtner You're right. The conditions shown aren't checked in the right order.</span>
<span class="comment-copy">@PatrickArtner you're right,  I meant i%5==0. Would it still be wrong?</span>
<span class="comment-copy">@Miraclefruit A problem is that as @PatrickArtner pointed out, <code>15</code> should've said "hello" but it didn't because it went to the first if statement, <code>if( 15 % 3 == 0):</code> which it is and it will print out "he" and exit out of that entire if statement without checking if could've been a multiple of 5. The order needs to be different.</span>
<span class="comment-copy">That makes sense! I've never seen print(f"{current}: {result}") before though. So this syntax just takes the result associated with current?</span>
<span class="comment-copy">@Miraclefruit:  <a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings" rel="nofollow noreferrer">docs.python.org/3/reference/lexical_analysis.html#f-strings</a></span>
<span class="comment-copy">Your internal recursive call <code>find_multiples(current+1)</code> should be <code>find_multiples(current+1, last_num)</code> otherwise an external call to <code>find_multiples(1, 10)</code> will go to 100 instead.</span>
<span class="comment-copy">@cdlane You're right. Good catch. Edited</span>
