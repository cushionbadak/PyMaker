<div class="post-text" itemprop="text">
<p>According to the documentation, this does not work because of this:</p>
<blockquote>
<p>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary. That behaviour is the reason why the following code raises an exception:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; class C:
...     pass
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.__len__ = lambda: 5
&gt;&gt;&gt; len(c)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object of type 'C' has no len()
</code></pre>
<p><a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#special-method-lookup</a></p>
</blockquote>
<p>I had tried this on a function generator, which does not have <code>__len__</code>, but I knew beforehand its length, then, I tried monkey patch it with something like <code>c.__len__ = lambda: 5</code>, but it kept saying the generator object had no length.</p>
<p>This is the generator:</p>
<pre class="lang-py prettyprint-override"><code>def get_sections(loaded_config_file):
    for module_file, config_parser in loaded_config_file.items():
        for section in config_parser.sections():
            yield section, module_file, config_parser
</code></pre>
<p>I was passing the generator (which has no length) to this other function (yet, another generator), which requires the iterable length by calling <code>len()</code>:</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>def sequence_timer(sequence, info_frequency=0):
    i = 0
    start = time.time()
    if_counter = start
    length = len(sequence)
    for elem in sequence:
        now = time.time()
        if now - if_counter &lt; info_frequency:
            yield elem, None
        else:
            pi = ProgressInfo(now - start, float(i)/length)
            if_counter += info_frequency
            yield elem, pi
        i += 1
</code></pre>
<p><a href="https://github.com/arp2600/Etc/blob/60c5af803faecb2d14b5dd3041254ef00a5a79a9/etc.py" rel="nofollow noreferrer">https://github.com/arp2600/Etc/blob/60c5af803faecb2d14b5dd3041254ef00a5a79a9/etc.py</a></p>
</blockquote>
<p>Then, when trying to add the <code>__len__</code> attribute to <code>get_sections</code>, hence the error:</p>
<pre class="lang-py prettyprint-override"><code>get_sections.__len__ = lambda: calculated_length
for stuff, progress in sequence_timer( get_sections ):
    section, module_file, config_parser = stuff
</code></pre>
<p><code>TypeError: object of type 'function' has no len()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can't add it to an existing object, so make your own wrapper class that has a class level definition you control:</p>
<pre><code>class KnownLengthIterator:
    def __init__(self, it, length):
        self.it = it
        self.length = int(length)

    def __len__(self):
        return self.length

    def __iter__(self):
        yield from self.it
</code></pre>
<p>Now you just change your invalid attempt to set a length of:</p>
<pre><code>get_sections.__len__ = lambda: calculated_length
</code></pre>
<p>to a valid rewrapping that makes <code>get_sections</code> continue to be a valid generator (<code>yield from</code> will delegate all iteration behaviors to the wrapped generator), while exposing a length too:</p>
<pre><code>get_sections = KnownLengthIterator(get_sections, calculated_length)
</code></pre>
<p>No other code needs to change.</p>
</div>
<span class="comment-copy">What's your question? You quoted the section of the documentation that says it's not expected to work. If you want to customize <code>len()</code>, you need to define a class.</span>
<span class="comment-copy">Yeah, easiest thing here is to just write a custom-class wrapper with a <code>__len__</code> that delegates everything else you need to the generator object</span>
<span class="comment-copy">I would make <code>KnownLengthIterator</code> an actual iterator. So just <code>__iter__(self): return iter(self.it)</code> and <code>__next__(self): return next(self.it)</code></span>
<span class="comment-copy">@juanpa.arrivillaga: You could do it, but that's not the way to do it; you've just violated <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">the iterator protocol</a>. If you define <code>__next__</code>, <code>__iter__</code> <i>must</i> be the identity function (doing nothing but <code>return self</code>). Python code actually relies on being able to detect iterators by testing <code>iter(x) is x</code> and having it be true only for iterators. The advantage to <code>yield from</code> is that the delegation means even coroutine behaviors like <code>send</code> continue to work (at the expense of making the class technically an iterable, not an iterator).</span>
<span class="comment-copy">Ah, this is a good point. But you could just use <code>return self</code> in <code>__iter__</code>. I suppose maintaining coroutine behaviors might be worth it, depending on the use-case.</span>
