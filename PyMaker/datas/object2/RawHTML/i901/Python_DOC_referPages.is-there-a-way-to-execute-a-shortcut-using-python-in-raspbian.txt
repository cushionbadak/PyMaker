<div class="post-text" itemprop="text">
<p>How can I call an external command (as if I'd typed it at the Unix shell or Windows command prompt) from within a Python script?</p>
</div>
<div class="post-text" itemprop="text">
<p>Look at the <a href="https://docs.python.org/library/subprocess.html" rel="noreferrer">subprocess module</a> in the standard library:</p>
<pre><code>import subprocess
subprocess.run(["ls", "-l"])
</code></pre>
<p>The advantage of <strong>subprocess</strong> vs. <strong>system</strong> is that it is more flexible (you can get the stdout, stderr, the "real" status code, better error handling, etc...).</p>
<p>The <a href="https://docs.python.org/library/os.html#os.system" rel="noreferrer">official documentation</a> recommends the <strong>subprocess</strong> module over the alternative os.system():</p>
<blockquote>
<p>The <strong>subprocess</strong> module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function [<a href="https://docs.python.org/library/os.html#os.system" rel="noreferrer"><code>os.system()</code></a>].</p>
</blockquote>
<p>The "<a href="https://docs.python.org/library/subprocess.html#replacing-older-functions-with-the-subprocess-module" rel="noreferrer">Replacing Older Functions with the subprocess Module</a>" section in the <strong>subprocess</strong> documentation may have some helpful recipes.</p>
<p>Older versions of Python use call:</p>
<pre><code>import subprocess
subprocess.call(["ls", "-l"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a summary of the ways to call external programs and the advantages and disadvantages of each:</p>
<ol>
<li><p><code>os.system("some_command with args")</code> passes the command and arguments to your system's shell.  This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection.  For example:  </p>
<pre><code>os.system("some_command &lt; input_file | another_command &gt; output_file")  
</code></pre>
<p>However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, etc.  On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.  See <a href="https://docs.python.org/2/library/os.html#os.system" rel="noreferrer">the documentation</a>.</p></li>
<li><p><code>stream = os.popen("some_command with args")</code> will do the same thing as <code>os.system</code> except that it gives you a file-like object that you can use to access standard input/output for that process.  There are 3 other variants of popen that all handle the i/o slightly differently.  If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything.  See <a href="https://docs.python.org/2/library/os.html#os.popen" rel="noreferrer">the documentation</a>.</p></li>
<li><p>The <code>Popen</code> class of the <code>subprocess</code> module.  This is intended as a replacement for <code>os.popen</code> but has the downside of being slightly more complicated by virtue of being so comprehensive.  For example, you'd say:</p>
<pre><code>print subprocess.Popen("echo Hello World", shell=True, stdout=subprocess.PIPE).stdout.read()
</code></pre>
<p>instead of: </p>
<pre><code>print os.popen("echo Hello World").read()
</code></pre>
<p>but it is nice to have all of the options there in one unified class instead of 4 different popen functions.  See <a href="https://docs.python.org/2/library/subprocess.html#popen-constructor" rel="noreferrer">the documentation</a>.</p></li>
<li><p>The <code>call</code> function from the <code>subprocess</code> module.  This is basically just like the <code>Popen</code> class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code.  For example:</p>
<pre><code>return_code = subprocess.call("echo Hello World", shell=True)  
</code></pre>
<p>See <a href="https://docs.python.org/2/library/subprocess.html#subprocess.call" rel="noreferrer">the documentation</a>.</p></li>
<li><p>If you're on Python 3.5 or later, you can use the new <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run" rel="noreferrer"><code>subprocess.run</code></a> function, which is a lot like the above but even more flexible and returns a <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.CompletedProcess" rel="noreferrer"><code>CompletedProcess</code></a> object when the command finishes executing.</p></li>
<li><p>The os module also has all of the fork/exec/spawn functions that you'd have in a C program, but I don't recommend using them directly.</p></li>
</ol>
<p>The <code>subprocess</code> module should probably be what you use.</p>
<p>Finally please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. <strong>There are serious security implications</strong> if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:</p>
<pre><code>print subprocess.Popen("echo %s " % user_input, stdout=PIPE).stdout.read()
</code></pre>
<p>and imagine that the user enters "my mama didnt love me &amp;&amp; rm -rf /".</p>
</div>
<div class="post-text" itemprop="text">
<p>I typically use:</p>
<pre><code>import subprocess

p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
for line in p.stdout.readlines():
    print line,
retval = p.wait()
</code></pre>
<p>You are free to do what you want with the <code>stdout</code> data in the pipe.  In fact, you can simply omit those parameters (<code>stdout=</code> and <code>stderr=</code>) and it'll behave like <code>os.system()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some hints on detaching the child process from the calling one (starting the child process in background).</p>
<p>Suppose you want to start a long task from a CGI-script, that is the child process should live longer than the CGI-script execution process.</p>
<p>The classical example from the subprocess module docs is:</p>
<pre><code>import subprocess
import sys

# some code here

pid = subprocess.Popen([sys.executable, "longtask.py"]) # call subprocess

# some more code here
</code></pre>
<p>The idea here is that you do not want to wait in the line 'call subprocess' until the longtask.py is finished. But it is not clear what happens after the line 'some more code here' from the example.</p>
<p>My target platform was freebsd, but the development was on windows, so I faced the problem on windows first.</p>
<p>On windows (win xp), the parent process will not finish until the longtask.py has finished its work. It is not what you want in CGI-script. The problem is not specific to Python, in PHP community the problems are the same.</p>
<p>The solution is to pass DETACHED_PROCESS <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx" rel="noreferrer">Process Creation Flag</a> to the underlying CreateProcess function in win API.
If you happen to have installed pywin32 you can import the flag from the win32process module, otherwise you should define it yourself:</p>
<pre><code>DETACHED_PROCESS = 0x00000008

pid = subprocess.Popen([sys.executable, "longtask.py"],
                       creationflags=DETACHED_PROCESS).pid
</code></pre>
<p>/* <em>UPD 2015.10.27</em> @eryksun in a comment below notes, that the semantically correct flag is CREATE_NEW_CONSOLE (0x00000010) */</p>
<p>On freebsd we have another problem: when the parent process is finished, it finishes the child processes as well. And that is not what you want in CGI-script either. Some experiments showed that the problem seemed to be in sharing sys.stdout. And the working solution was the following:</p>
<pre><code>pid = subprocess.Popen([sys.executable, "longtask.py"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
</code></pre>
<p>I have not checked the code on other platforms and do not know the reasons of the behaviour on freebsd. If anyone knows, please share your ideas. Googling on starting background processes in Python does not shed any light yet.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend using the subprocess module instead of os.system because it does shell escaping for you and is therefore much safer: <a href="http://docs.python.org/library/subprocess.html" rel="noreferrer">http://docs.python.org/library/subprocess.html</a></p>
<pre><code>subprocess.call(['ping', 'localhost'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
cmd = 'ls -al'
os.system(cmd)
</code></pre>
<p>If you want to return the results of the command, you can use <a href="https://docs.python.org/2/library/os.html#os.popen" rel="noreferrer"><code>os.popen</code></a>. However, this is deprecated since version 2.6 in favor of the <a href="https://docs.python.org/2/library/subprocess.html#module-subprocess" rel="noreferrer">subprocess module</a>, which other answers have covered well.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
os.system("your command")
</code></pre>
<p>Note that this is dangerous, since the command isn't cleaned. I leave it up to you to google for the relevant documentation on the 'os' and 'sys' modules. There are a bunch of functions (exec* and spawn*) that will do similar things.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are lots of different libraries which allow you to call external commands with Python. For each library I've given a description and shown an example of calling an external command. The command I used as the example is <code>ls -l</code> (list all files). If you want to find out more about any of the libraries I've listed and linked the documentation for each of them.</p>
<blockquote>
<p><strong>Sources:</strong></p>
</blockquote>
<ul>
<li>subprocess: <a href="https://docs.python.org/3.5/library/subprocess.html" rel="noreferrer">https://docs.python.org/3.5/library/subprocess.html</a></li>
<li>shlex: <a href="https://docs.python.org/3/library/shlex.html" rel="noreferrer">https://docs.python.org/3/library/shlex.html</a></li>
<li>os: <a href="https://docs.python.org/3.5/library/os.html" rel="noreferrer">https://docs.python.org/3.5/library/os.html</a></li>
<li>sh: <a href="https://amoffat.github.io/sh/" rel="noreferrer">https://amoffat.github.io/sh/</a></li>
<li>plumbum: <a href="https://plumbum.readthedocs.io/en/latest/" rel="noreferrer">https://plumbum.readthedocs.io/en/latest/</a></li>
<li>pexpect: <a href="https://pexpect.readthedocs.io/en/stable/" rel="noreferrer">https://pexpect.readthedocs.io/en/stable/</a></li>
<li>fabric: <a href="http://www.fabfile.org/" rel="noreferrer">http://www.fabfile.org/</a></li>
<li>envoy: <a href="https://github.com/kennethreitz/envoy" rel="noreferrer">https://github.com/kennethreitz/envoy</a></li>
<li>commands: <a href="https://docs.python.org/2/library/commands.html" rel="noreferrer">https://docs.python.org/2/library/commands.html</a></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p><strong>These are all the libraries:</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>Hopefully this will help you make a decision on which library to use :)</p>
<blockquote>
<p><strong>subprocess</strong></p>
</blockquote>
<p>Subprocess allows you to call external commands and connect them to their input/output/error pipes (stdin, stdout, and stderr). Subprocess is the default choice for running commands, but sometimes other modules are better.</p>
<pre><code>subprocess.run(["ls", "-l"]) # Run command
subprocess.run(["ls", "-l"], stdout=subprocess.PIPE) # This will run the command and return any output
subprocess.run(shlex.split("ls -l")) # You can also use the shlex library to split the command
</code></pre>
<blockquote>
<p><strong>os</strong></p>
</blockquote>
<p>os is used for "operating system dependent functionality". It can also be used to call external commands with <code>os.system</code> and <code>os.popen</code> (Note: There is also a subprocess.popen). os will always run the shell and is a simple alternative for people who don't need to, or don't know how to use <code>subprocess.run</code>.</p>
<pre><code>os.system("ls -l") # run command
os.popen("ls -l").read() # This will run the command and return any output
</code></pre>
<blockquote>
<p><strong>sh</strong></p>
</blockquote>
<p>sh is a subprocess interface which lets you call programs as if they were functions. This is useful if you want to run a command multiple times.</p>
<pre><code>sh.ls("-l") # Run command normally
ls_cmd = sh.Command("ls") # Save command as a variable
ls_cmd() # Run command as if it were a function
</code></pre>
<blockquote>
<p><strong>plumbum</strong></p>
</blockquote>
<p>plumbum is a library for "script-like" Python programs. You can call programs like functions as in <code>sh</code>. Plumbum is useful if you want to run a pipeline without the shell.</p>
<pre><code>ls_cmd = plumbum.local("ls -l") # get command
ls_cmd() # run command
</code></pre>
<blockquote>
<p><strong>pexpect</strong></p>
</blockquote>
<p>pexpect lets you spawn child applications, control them and find patterns in their output. This is a better alternative to subprocess for commands that expect a tty on Unix.</p>
<pre><code>pexpect.run("ls -l") # Run command as normal
child = pexpect.spawn('scp foo user@example.com:.') # Spawns child application
child.expect('Password:') # When this is the output
child.sendline('mypassword')
</code></pre>
<blockquote>
<p><strong>fabric</strong></p>
</blockquote>
<p>fabric is a Python 2.5 and 2.7 library. It allows you to execute local and remote shell commands. Fabric is simple alternative for running commands in a secure shell (SSH)</p>
<pre><code>fabric.operations.local('ls -l') # Run command as normal
fabric.operations.local('ls -l', capture = True) # Run command and receive output
</code></pre>
<blockquote>
<p><strong>envoy</strong></p>
</blockquote>
<p>envoy is known as "subprocess for humans". It is used as a convenience wrapper around the <code>subprocess</code> module.</p>
<pre><code>r = envoy.run("ls -l") # Run command
r.std_out # get output
</code></pre>
<blockquote>
<p><strong>commands</strong></p>
</blockquote>
<p><code>commands</code> contains wrapper functions for <code>os.popen</code>, but it has been removed from Python 3 since <code>subprocess</code> is a better alternative.</p>
<p>The edit was based on J.F. Sebastian's comment.</p>
</div>
<div class="post-text" itemprop="text">
<p>I always use <code>fabric</code> for this things like:</p>
<pre><code>from fabric.operations import local
result = local('ls', capture=True)
print "Content:/n%s" % (result, )
</code></pre>
<p>But this seem to be a good tool: <a href="https://github.com/amoffat/sh" rel="noreferrer"><code>sh</code> (Python subprocess interface)</a>.</p>
<p>Look an example:</p>
<pre><code>from sh import vgdisplay
print vgdisplay()
print vgdisplay('-v')
print vgdisplay(v=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check the "pexpect" Python library, too.</p>
<p>It allows for interactive controlling of external programs/commands, even ssh, ftp, telnet, etc. You can just type something like:</p>
<pre><code>child = pexpect.spawn('ftp 192.168.0.24')

child.expect('(?i)name .*: ')

child.sendline('anonymous')

child.expect('(?i)password')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need the output from the command you are calling,
then you can use <a href="https://docs.python.org/3.6/library/subprocess.html#subprocess.check_output" rel="noreferrer">subprocess.check_output</a> (Python 2.7+).</p>
<pre><code>&gt;&gt;&gt; subprocess.check_output(["ls", "-l", "/dev/null"])
'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
</code></pre>
<p>Also note the <a href="https://docs.python.org/3.6/library/subprocess.html#frequently-used-arguments" rel="noreferrer">shell</a> parameter.</p>
<blockquote>
<p>If shell is <code>True</code>, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user’s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, <code>glob</code>, <code>fnmatch</code>, <code>os.walk()</code>, <code>os.path.expandvars()</code>, <code>os.path.expanduser()</code>, and <code>shutil</code>).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<h1>With Standard Library</h1>
<p>The
Use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noreferrer">subprocess module</a> (Python 3):</p>
<pre><code>import subprocess
subprocess.run(['ls', '-l'])
</code></pre>
<p>It is the recommended standard way. However, more complicated tasks (pipes, output, input, etc.) can be tedious to construct and write.</p>
<p><em>Note on Python version: If you are still using Python 2, <a href="https://docs.python.org/2/library/subprocess.html#subprocess.call" rel="noreferrer">subprocess.call</a> works in a similar way.</em></p>
<p><em>ProTip: <a href="https://docs.python.org/2/library/shlex.html#shlex.split" rel="noreferrer">shlex.split</a> can help you to parse the command for <code>run</code>, <code>call</code>, and other <code>subprocess</code> functions in case you don't want (or you can't!) provide them in form of lists:</em></p>
<pre><code>import shlex
import subprocess
subprocess.run(shlex.split('ls -l'))
</code></pre>
<h1>With External Dependencies</h1>
<p>If you do not mind external dependencies, use <a href="https://pypi.python.org/pypi/plumbum" rel="noreferrer">plumbum</a>:</p>
<pre><code>from plumbum.cmd import ifconfig
print(ifconfig['wlan0']())
</code></pre>
<p>It is the best <code>subprocess</code> wrapper. It's cross-platform, i.e. it works on both Windows and Unix-like systems. Install by <code>pip install plumbum</code>.</p>
<p>Another popular library is <a href="https://pypi.python.org/pypi/sh" rel="noreferrer">sh</a>:</p>
<pre><code>from sh import ifconfig
print(ifconfig('wlan0'))
</code></pre>
<p>However, <code>sh</code> dropped Windows support, so it's not as awesome as it used to be. Install by <code>pip install sh</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is how I run my commands. This code has everything you need pretty much</p>
<pre><code>from subprocess import Popen, PIPE
cmd = "ls -l ~/"
p = Popen(cmd , shell=True, stdout=PIPE, stderr=PIPE)
out, err = p.communicate()
print "Return code: ", p.returncode
print out.rstrip(), err.rstrip()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Update:</h1>
<p><code>subprocess.run</code> is the recommended approach <a href="https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-subprocess" rel="noreferrer">as of Python 3.5</a> if your code does not need to maintain compatibility with earlier Python versions. It's more consistent and offers similar ease-of-use as Envoy. (Piping isn't as straightforward though. See <a href="https://stackoverflow.com/questions/7389662/link-several-popen-commands-with-pipes">this question for how</a>.)</p>
<p>Here's some examples from <a href="https://docs.python.org/3.6/library/subprocess.html#subprocess.run" rel="noreferrer">the docs</a>.</p>
<p>Run a process:</p>
<pre><code>&gt;&gt;&gt; subprocess.run(["ls", "-l"])  # doesn't capture output
CompletedProcess(args=['ls', '-l'], returncode=0)
</code></pre>
<p>Raise on failed run:</p>
<pre><code>&gt;&gt;&gt; subprocess.run("exit 1", shell=True, check=True)
Traceback (most recent call last):
  ...
subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1
</code></pre>
<p>Capture output:</p>
<pre><code>&gt;&gt;&gt; subprocess.run(["ls", "-l", "/dev/null"], stdout=subprocess.PIPE)
CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,
stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n')
</code></pre>
<h1>Original answer:</h1>
<p>I recommend trying <a href="https://github.com/kennethreitz/envoy" rel="noreferrer">Envoy</a>. It's a wrapper for subprocess, which in turn <a href="http://docs.python.org/2/library/subprocess.html" rel="noreferrer">aims to replace</a> the older modules and functions. Envoy is subprocess for humans.</p>
<p>Example usage from <a href="https://github.com/kennethreitz/envoy#readme" rel="noreferrer">the readme</a>:</p>
<pre><code>&gt;&gt;&gt; r = envoy.run('git config', data='data to pipe in', timeout=2)

&gt;&gt;&gt; r.status_code
129
&gt;&gt;&gt; r.std_out
'usage: git config [options]'
&gt;&gt;&gt; r.std_err
''
</code></pre>
<p>Pipe stuff around too:</p>
<pre><code>&gt;&gt;&gt; r = envoy.run('uptime | pbcopy')

&gt;&gt;&gt; r.command
'pbcopy'
&gt;&gt;&gt; r.status_code
0

&gt;&gt;&gt; r.history
[&lt;Response 'uptime'&gt;]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without the output of the result:</p>
<pre><code>import os
os.system("your command here")
</code></pre>
<p>With output of the result:</p>
<pre><code>import commands
commands.getoutput("your command here")
or
commands.getstatusoutput("your command here")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/subprocess.html" rel="noreferrer">https://docs.python.org/2/library/subprocess.html</a></p>
<p>...or for a very simple command:</p>
<pre><code>import os
os.system('cat testfile')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is also <a href="http://plumbum.readthedocs.org/en/latest/">Plumbum</a></p>
<pre><code>&gt;&gt;&gt; from plumbum import local
&gt;&gt;&gt; ls = local["ls"]
&gt;&gt;&gt; ls
LocalCommand(&lt;LocalPath /bin/ls&gt;)
&gt;&gt;&gt; ls()
u'build.py\ndist\ndocs\nLICENSE\nplumbum\nREADME.rst\nsetup.py\ntests\ntodo.txt\n'
&gt;&gt;&gt; notepad = local["c:\\windows\\notepad.exe"]
&gt;&gt;&gt; notepad()                                   # Notepad window pops up
u''                                             # Notepad window is closed by user, command returns
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>os.system</code> is OK, but kind of dated.  It's also not very secure.  Instead, try <code>subprocess</code>.  <code>subprocess</code> does not call sh directly and is therefore more secure than <code>os.system</code>.</p>
<p>Get more information <a href="https://docs.python.org/library/subprocess.html" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>Calling an external command in Python</h2>
</blockquote>
<p>Simple, use <code>subprocess.run</code>, which returns a <code>CompletedProcess</code> object:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; completed_process = subprocess.run('python --version')
Python 3.6.1 :: Anaconda 4.4.0 (64-bit)
&gt;&gt;&gt; completed_process
CompletedProcess(args='python --version', returncode=0)
</code></pre>
<h3>Why?</h3>
<p>As of Python 3.5, the documentation recommends <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noreferrer">subprocess.run</a>:</p>
<blockquote>
<p>The recommended approach to invoking subprocesses is to use the run() function for all use cases it can handle. For more advanced use cases, the underlying Popen interface can be used directly.</p>
</blockquote>
<p>Here's an example of the simplest possible usage - and it does exactly as asked:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; completed_process = subprocess.run('python --version')
Python 3.6.1 :: Anaconda 4.4.0 (64-bit)
&gt;&gt;&gt; completed_process
CompletedProcess(args='python --version', returncode=0)
</code></pre>
<p><code>run</code> waits for the command to successfully finish, then returns a <code>CompletedProcess</code> object. It may instead raise <code>TimeoutExpired</code> (if you give it a <code>timeout=</code> argument) or <code>CalledProcessError</code> (if it fails and you pass <code>check=True</code>).</p>
<p>As you might infer from the above example, stdout and stderr both get piped to your own stdout and stderr by default.</p>
<p>We can inspect the returned object and see the command that was given and the returncode:</p>
<pre><code>&gt;&gt;&gt; completed_process.args
'python --version'
&gt;&gt;&gt; completed_process.returncode
0
</code></pre>
<h3>Capturing output</h3>
<p>If you want to capture the output, you can pass <code>subprocess.PIPE</code> to the appropriate <code>stderr</code> or <code>stdout</code>:</p>
<pre><code>&gt;&gt;&gt; cp = subprocess.run('python --version', 
                        stderr=subprocess.PIPE, 
                        stdout=subprocess.PIPE)
&gt;&gt;&gt; cp.stderr
b'Python 3.6.1 :: Anaconda 4.4.0 (64-bit)\r\n'
&gt;&gt;&gt; cp.stdout
b''
</code></pre>
<p>(I find it interesting and slightly counterintuitive that the version info gets put to stderr instead of stdout.)</p>
<h2>Pass a command list</h2>
<p>One might easily move from manually providing a command string (like the question suggests) to providing a string built programmatically. <strong>Don't build strings programmatically.</strong> This is a potential security issue. It's better to assume you don't trust the input. </p>
<pre><code>&gt;&gt;&gt; import textwrap
&gt;&gt;&gt; args = ['python', textwrap.__file__]
&gt;&gt;&gt; cp = subprocess.run(args, stdout=subprocess.PIPE)
&gt;&gt;&gt; cp.stdout
b'Hello there.\r\n  This is indented.\r\n'
</code></pre>
<p>Note, only <code>args</code> should be passed positionally.</p>
<h2>Full Signature</h2>
<p>Here's the actual signature in the source and as shown by <code>help(run)</code>:</p>
<blockquote>
<pre><code>def run(*popenargs, input=None, timeout=None, check=False, **kwargs):
</code></pre>
</blockquote>
<p>The <code>popenargs</code> and <code>kwargs</code> are given to the <code>Popen</code> constructor. <code>input</code> can be a string of bytes (or unicode, if specify encoding or <code>universal_newlines=True</code>) that will be piped to the subprocess's stdin.</p>
<p>The documentation describes <code>timeout=</code> and <code>check=True</code> better than I could:</p>
<blockquote>
<p>The timeout argument is passed to Popen.communicate(). If the timeout
  expires, the child process will be killed and waited for. The
  TimeoutExpired exception will be re-raised after the child process has
  terminated.</p>
<p>If check is true, and the process exits with a non-zero exit code, a
  CalledProcessError exception will be raised. Attributes of that
  exception hold the arguments, the exit code, and stdout and stderr if
  they were captured.</p>
</blockquote>
<p>and this example for <code>check=True</code> is better than one I could come up with:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; subprocess.run("exit 1", shell=True, check=True)
Traceback (most recent call last):
  ...
subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1
</code></pre>
</blockquote>
<h3>Expanded Signature</h3>
<p>Here's an expanded signature, as given in the documentation:</p>
<blockquote>
<pre><code>subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, 
shell=False, cwd=None, timeout=None, check=False, encoding=None, 
errors=None)
</code></pre>
</blockquote>
<p>Note that this indicates that only the args list should be passed positionally. So pass the remaining arguments as keyword arguments.</p>
<h3>Popen</h3>
<p>When use <code>Popen</code> instead? I would struggle to find use-case based on the arguments alone. Direct usage of <code>Popen</code> would, however, give you access to its methods, including <code>poll</code>, 'send_signal', 'terminate', and 'wait'.</p>
<p>Here's the <code>Popen</code> signature as given in <a href="https://github.com/python/cpython/blob/master/Lib/subprocess.py#L587" rel="noreferrer">the source</a>. I think this is the most precise encapsulation of the information (as opposed to <code>help(Popen)</code>):</p>
<pre><code>def __init__(self, args, bufsize=-1, executable=None,
             stdin=None, stdout=None, stderr=None,
             preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
             shell=False, cwd=None, env=None, universal_newlines=False,
             startupinfo=None, creationflags=0,
             restore_signals=True, start_new_session=False,
             pass_fds=(), *, encoding=None, errors=None):
</code></pre>
<p>But more informative is <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="noreferrer">the <code>Popen</code> documentation</a>:</p>
<blockquote>
<pre><code>subprocess.Popen(args, bufsize=-1, executable=None, stdin=None,
                 stdout=None, stderr=None, preexec_fn=None, close_fds=True,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0, restore_signals=True,
                 start_new_session=False, pass_fds=(), *, encoding=None, errors=None)
</code></pre>
<p>Execute a child program in a new process. On POSIX, the class uses
  os.execvp()-like behavior to execute the child program. On Windows,
  the class uses the Windows CreateProcess() function. The arguments to
  Popen are as follows.</p>
</blockquote>
<p>Understanding the remaining documentation on <code>Popen</code> will be left as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use:</p>
<pre><code>import os

cmd = 'ls -al'

os.system(cmd)
</code></pre>
<p><strong>os - This module provides a portable way of using operating system-dependent functionality.</strong></p>
<p>For the more <code>os</code> functions, <a href="https://docs.python.org/2/library/os.html" rel="noreferrer">here</a> is the documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>It can be this simple:</p>
<pre><code>import os
cmd = "your command"
os.system(cmd)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>subprocess.check_call</code> is convenient if you don't want to test return values. It throws an exception on any error.</p>
</div>
<div class="post-text" itemprop="text">
<p>I tend to use <a href="https://docs.python.org/2/library/subprocess.html" rel="noreferrer">subprocess</a> together with <a href="https://docs.python.org/2/library/shlex.html" rel="noreferrer">shlex</a> (to handle escaping of quoted strings):</p>
<pre><code>&gt;&gt;&gt; import subprocess, shlex
&gt;&gt;&gt; command = 'ls -l "/your/path/with spaces/"'
&gt;&gt;&gt; call_params = shlex.split(command)
&gt;&gt;&gt; print call_params
["ls", "-l", "/your/path/with spaces/"]
&gt;&gt;&gt; subprocess.call(call_params)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>os.system</code> does not allow you to store results, so if you want to store results in some list or something <code>subprocess.call</code> works.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is another difference here which is not mentioned previously.</p>
<p><code>subprocess.Popen</code> executes the &lt;command&gt; as a subprocess. In my case, I need to execute file &lt;a&gt; which needs to communicate with another program, &lt;b&gt;. </p>
<p>I tried subprocess, and execution was successful. However &lt;b&gt; could not communicate with &lt;a&gt;.
Everything is normal when I run both from the terminal.</p>
<p>One more: 
(NOTE: kwrite behaves different from other applications. If you try the below with Firefox, the results will not be the same.)</p>
<p>If you try <code>os.system("kwrite")</code>, program flow freezes until the user closes kwrite. To overcome that I tried instead <code>os.system(konsole -e kwrite)</code>. This time program continued to flow, but kwrite became the subprocess of the console.</p>
<p>Anyone runs the kwrite not being a subprocess (i.e. in the system monitor it must appear at the leftmost edge of the tree).</p>
</div>
<div class="post-text" itemprop="text">
<p>use the os module</p>
<pre><code>import os
os.system("your command")
</code></pre>
<p>eg</p>
<pre><code>import os
os.system("ifconfig")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I quite like <a href="http://shell-command.readthedocs.org/en/latest/index.html" rel="noreferrer">shell_command</a> for its simplicity.  It's built on top of the subprocess module.</p>
<p>Here's an example from the docs:</p>
<pre><code>&gt;&gt;&gt; from shell_command import shell_call
&gt;&gt;&gt; shell_call("ls *.py")
setup.py  shell_command.py  test_shell_command.py
0
&gt;&gt;&gt; shell_call("ls -l *.py")
-rw-r--r-- 1 ncoghlan ncoghlan  391 2011-12-11 12:07 setup.py
-rw-r--r-- 1 ncoghlan ncoghlan 7855 2011-12-11 16:16 shell_command.py
-rwxr-xr-x 1 ncoghlan ncoghlan 8463 2011-12-11 16:17 test_shell_command.py
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Shameless plug, I wrote a library for this :P
<a href="https://github.com/houqp/shell.py" rel="noreferrer">https://github.com/houqp/shell.py</a></p>
<p>It's basically a wrapper for popen and shlex for now. It also supports piping commands so you can chain commands easier in Python. So you can do things like:</p>
<pre><code>ex('echo hello shell.py') | "awk '{print $2}'"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Under Linux, in case you would like to call an external command that will execute independently (will keep running after the python script terminates), you can use a simple queue as <a href="http://vicerveza.homeunix.net/~viric/soft/ts/" rel="noreferrer">task spooler</a> or the <a href="https://linux.die.net/man/1/at" rel="noreferrer">at</a> command</p>
<p>An example with task spooler:</p>
<pre><code>import os
os.system('ts &lt;your-command&gt;')
</code></pre>
<p>Notes about task spooler (<code>ts</code>): </p>
<ol>
<li><p>You could set the number of concurrent processes to be run ("slots") with:</p>
<p><code>ts -S &lt;number-of-slots&gt;</code></p></li>
<li><p>Installing <code>ts</code> doesn't requires admin privileges. You can download and compile it from source with a simple <code>make</code>, add it to your path and you're done.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>In Windows you can just import the <code>subprocess</code> module and run external commands by calling <code>subprocess.Popen()</code>, <code>subprocess.Popen().communicate()</code> and <code>subprocess.Popen().wait()</code> as below:</p>
<pre><code># Python script to run a command line
import subprocess

def execute(cmd):
    """
        Purpose  : To execute a command and return exit status
        Argument : cmd - command to execute
        Return   : exit_code
    """
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (result, error) = process.communicate()

    rc = process.wait()

    if rc != 0:
        print "Error: failed to execute command:", cmd
        print error
    return result
# def

command = "tasklist | grep python"
print "This process detail: \n", execute(command)
</code></pre>
<p>Output:</p>
<pre><code>This process detail:
python.exe                     604 RDP-Tcp#0                  4      5,660 K
</code></pre>
</div>
<span class="comment-copy">Is there a way to use variable substitution? IE I tried to do <code>echo $PATH</code> by using <code>call(["echo", "$PATH"])</code>, but it just echoed the literal string <code>$PATH</code> instead of doing any substitution. I know I could get the PATH environment variable, but I'm wondering if there is an easy way to have the command behave exactly as if I had executed it in bash.</span>
<span class="comment-copy">@KevinWheeler You'll have to use <code>shell=True</code> for that to work.</span>
<span class="comment-copy">@KevinWheeler You should NOT use <code>shell=True</code>, for this purpose Python comes with <a href="https://docs.python.org/2/library/os.path.html#os.path.expandvars" rel="nofollow noreferrer">os.path.expandvars</a>. In your case you can write: <code>os.path.expandvars("$PATH")</code>. @SethMMorton please reconsider your comment -&gt; <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">Why not to use shell=True</a></span>
<span class="comment-copy">To simplify at least conceptually:\n call("ls -l".split())</span>
<span class="comment-copy">you forgot to say it needs python 3.5 at least. It doesn't work on python 3.4.3 for example, which is default for Ubuntu 14.04 LTS</span>
<span class="comment-copy">Nice answer/explanation.  How is this answer justifying Python's motto as described in this article ?  <a href="http://www.fastcompany.com/3026446/the-fall-of-perl-the-webs-most-promising-language" rel="nofollow noreferrer">fastcompany.com/3026446/…</a>  "Stylistically, Perl and Python have different philosophies. Perl’s best known mottos is " There’s More Than One Way to Do It". Python is designed to have one obvious way to do it"  Seem like it should be the other way! In Perl I know only two ways to execute a command - using back-tick or <code>open</code>.</span>
<span class="comment-copy">If using Python 3.5+, use <code>subprocess.run()</code>. <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run" rel="nofollow noreferrer">docs.python.org/3.5/library/subprocess.html#subprocess.run</a></span>
<span class="comment-copy">What one typically needs to know is what is done with the child process's STDOUT and STDERR, because if they are ignored, under some (quite common) conditions, eventually the child process will issue a system call to write to STDOUT (STDERR too?) that would exceed the output buffer provided for the process by the OS, and the OS will cause it to block until some process reads from that buffer. So, with the currently recommended ways, <code>subprocess.run(..)</code>, what exactly does <i>"This does not capture stdout or stderr by default."</i> imply? What about <code>subprocess.check_output(..)</code> and STDERR?</span>
<span class="comment-copy">@Pitto yes, but that is not what gets executed by the example. Notice the <code>echo</code> in front of the string passed to <code>Popen</code>? So the full command will be <code>echo my mama didnt love me &amp;&amp; rm -rf /</code>.</span>
<span class="comment-copy">This is arguably the wrong way around. Most people only need <code>subprocess.run()</code> or its older siblings <code>subprocess.check_call()</code> et al. For cases where these do not suffice, see <code>subprocess.Popen()</code>. <code>os.popen()</code> should perhaps not be mentioned at all, or come even after "hack your own fork/exec/spawn code".</span>
<span class="comment-copy"><code>.readlines()</code> reads <i>all</i> lines at once i.e., it blocks until the subprocess exits (closes its end of the pipe). To read in real time (if there is no buffering issues) you could: <code>for line in iter(p.stdout.readline, ''): print line,</code></span>
<span class="comment-copy">Could you elaborate on what you mean by "if there is no buffering issues"?  If the process blocks definitely, the subprocess call also blocks.  The same could happen with my original example as well. What else could happen with respect to buffering?</span>
<span class="comment-copy">the child process may use block-buffering in non-interactive mode instead of line-buffering so <code>p.stdout.readline()</code> (note: no <code>s</code> at the end) won't see any data until the child fills its buffer. If the child doesn't produce much data then the output won't be in real time. See the second reason in <a href="http://www.noah.org/wiki/Pexpect#Q:_Why_not_just_use_a_pipe_.28popen.28.29.29.3F" rel="nofollow noreferrer">Q: Why not just use a pipe (popen())?</a>. Some workarounds are provided <a href="http://stackoverflow.com/a/12471855/4279">in this answer</a> (pexpect, pty, stdbuf)</span>
<span class="comment-copy">the buffering issue only matters if you want output in real time and doesn't apply to your code that doesn't print anything until <i>all</i> data is received</span>
<span class="comment-copy">This answer was fine for its time, but we should no longer recommend <code>Popen</code> for simple tasks. This also needlessly specifies <code>shell=True</code>. Try one of the <code>subprocess.run()</code> answers.</span>
<span class="comment-copy">i noticed a possible "quirk" with developing py2exe apps in pydev+eclipse. i was able to tell that the main script was not detached because eclipse's output window was not terminating; even if the script executes to completion it is still waiting for returns. but, when i tried compiling to a py2exe executable, the expected behavior occurs (runs the processes as detached, then quits). i am not sure, but the executable name is not in the process list anymore. this works for all approaches (os.system("start *"), os.spawnl with os.P_DETACH, subprocs, etc.)</span>
<span class="comment-copy">you might also need CREATE_NEW_PROCESS_GROUP flag. See <a href="http://stackoverflow.com/q/13243807/4279">Popen waiting for child process even when the immediate child has terminated</a></span>
<span class="comment-copy">The following is incorrect: "[o]n windows (win xp), the parent process will not finish until the longtask.py has finished its work". The parent will exit normally, but the console window (conhost.exe instance) only closes when the last attached process exits, and the child may have inherited the parent's console. Setting <code>DETACHED_PROCESS</code> in <code>creationflags</code> avoids this by preventing the child from inheriting or creating a console. If you instead want a new console, use <code>CREATE_NEW_CONSOLE</code> (0x00000010).</span>
<span class="comment-copy">I didn't mean that executing as a detached process is incorrect. That said, you may need to set the standard handles to files, pipes, or <code>os.devnull</code> because some console programs exit with an error otherwise. Create a new console when you want the child process to interact with the user concurrently with the parent process. It would be confusing to try to do both in a single window.</span>
<span class="comment-copy">is there not an OS-agnostic way to have the process run in the background?</span>
<span class="comment-copy">If you want to <b>create a list out of a command with parameters</b>, a list which can be used with <code>subprocess</code> when <code>shell=False</code>, then use <code>shlex.split</code> for an easy way to do this <a href="https://docs.python.org/2/library/shlex.html#shlex.split" rel="nofollow noreferrer">docs.python.org/2/library/shlex.html#shlex.split</a> (it's the recommended way according to the docs <a href="https://docs.python.org/2/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">docs.python.org/2/library/subprocess.html#popen-constructor</a>)</span>
<span class="comment-copy">This is incorrect: "<b>it does shell escaping for you and is therefore much safer</b>". subprocess doesn't do shell escaping, subprocess doesn't pass your command through the shell, so there's no need to shell escape.</span>
<span class="comment-copy">popen <a href="https://docs.python.org/2/library/os.html#os.popen" rel="nofollow noreferrer">is deprecated</a> in favor of <a href="https://docs.python.org/2/library/subprocess.html" rel="nofollow noreferrer">subprocess</a>.</span>
<span class="comment-copy">You can also save your result with the os.system call, since it works like the UNIX shell itself, like for example os.system('ls -l &gt; test2.txt')</span>
<span class="comment-copy">What do you mean by <i>"the command isn't cleaned"</i>?</span>
<span class="comment-copy">No idea what I meant nearly a decade ago (check the date!), but if I had to guess, it would be that there's no validation done.</span>
<span class="comment-copy">This should now point to <code>subprocess</code> as a slightly more versatile and portable solution. Running external commands is of course inherently unportable (you have to make sure the command is available on every architecture you need to support) and passing user input as an external command is inherently unsafe.</span>
<span class="comment-copy">Note the timestamp on this guy: the "correct" answer has 40x the votes and is answer #1.</span>
<span class="comment-copy">Note that <code>check_output</code> requires a list rather than a string. If you don't rely on quoted spaces to make your call valid, the simplest, most readable way to do this is <code>subprocess.check_output("ls -l /dev/null".split())</code>.</span>
<span class="comment-copy">Passing commands as strings is normally a bad idea</span>
<span class="comment-copy">I think it's acceptable for hard-coded commands, if it increases readability.</span>
<span class="comment-copy"><code>commands</code> is no longer available in Python 3. You should prefer <code>subprocess</code> over <code>os.system()</code></span>
<span class="comment-copy">While I agree with the overall recommendation, <code>subprocess</code> does not remove all of the security problems, and has some pesky issues of its own.</span>
<span class="comment-copy">A simple example of two-way communication between a primary process and a subprocess can be found here: <a href="https://stackoverflow.com/a/52841475/1349673">stackoverflow.com/a/52841475/1349673</a></span>
<span class="comment-copy">The first example should probably have <code>shell=True</code> or (better yet) pass the command as a list.</span>
<span class="comment-copy">it's also deprecated.  use subprocess</span>
<span class="comment-copy">This fails to point out the drawbacks, which are explained in much more detail in <a href="https://www.python.org/dev/peps/pep-0324/" rel="nofollow noreferrer">PEP-324</a>. The documentation for <code>os.system</code> explicitly recommends avoiding it in favor of <code>subprocess</code>.</span>
<span class="comment-copy">What do you mean by <i>"Anyone runs the kwrite not being a subprocess"</i>?</span>
<span class="comment-copy">This duplicates a (slightly) more detailed answer from the previous April, which however also fails to point out the caveats.</span>
<span class="comment-copy"><code>ts</code> is not standard on any distro I know of, though the pointer to <code>at</code> is mildly useful. You should probably also mention <code>batch</code>. As elsewhere, the <code>os.system()</code> recommendation should probably at least mention that <code>subprocess</code> is its recommended replacement.</span>
