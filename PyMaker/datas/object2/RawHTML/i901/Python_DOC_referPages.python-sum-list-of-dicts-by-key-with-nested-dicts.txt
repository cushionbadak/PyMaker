<div class="post-text" itemprop="text">
<p>I have a list of dicts and would like to design a function to output a new dict which contains the sum for each unique key across all the dicts in the list.</p>
<p>For the list:</p>
<pre><code>[
    {
         'apples': 1,
         'oranges': 1,
         'grapes': 2
    },
    {
         'apples': 3,
         'oranges': 5,
         'grapes': 8
    },
    {
         'apples': 13,
         'oranges': 21,
         'grapes': 34
    }
]
</code></pre>
<p>So far so good, this can be done with a counter:</p>
<pre><code>def sumDicts(listToProcess):
    c = Counter()
    for entry in listToProcess:
        c.update(entry)
    return (dict(c))
</code></pre>
<p>Which correctly returns:</p>
<pre><code>{'apples': 17, 'grapes': 44, 'oranges': 27}
</code></pre>
<p>The trouble comes when the dicts in my list start to contain nested dicts:</p>
<pre><code>[
    {
        'fruits': {
            'apples': 1,
            'oranges': 1,
            'grapes': 2
            },
        'vegetables': {
            'carrots': 6,
            'beans': 3,
            'peas': 2
        },
        'grains': 4,
        'meats': 1  
    },
    {
        'fruits': {
            'apples': 3,
            'oranges': 5,
            'grapes': 8
            },
        'vegetables': {
            'carrots': 7,
            'beans': 4,
            'peas': 3
        },
        'grains': 3,
        'meats': 2  
    },
    {
        'fruits': {
            'apples': 13,
            'oranges': 21,
            'grapes': 34
            },
        'vegetables': {
            'carrots': 8,
            'beans': 5,
            'peas': 4
        },
        'grains': 2,
        'meats': 3
    },
]
</code></pre>
<p>Now the same function will give a TypeError because the counter can't add two Dicts. </p>
<p>The desired result would be:</p>
<pre><code>{
    'fruits': {
        'apples': 17,
        'oranges': 27,
        'grapes': 44
        },
    'vegetables': {
        'carrots': 21,
        'beans': 12,
        'peas': 9
    },
    'grains': 9,
    'meats': 6  
}
</code></pre>
<p>Any ideas on how to do this in a reasonably efficient, Pythonic, generalizable way?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do this by performing a recursive merge on a <a href="https://stackoverflow.com/a/26496899/4909087">recursively defined</a> <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> object.</p>
<pre><code>from collections import defaultdict

def merge(d, new_d):
    for k, v in new_d.items():
        if isinstance(v, dict):
            merge(d[k], v)
        else: 
            d[k] = d.setdefault(k, 0) + v

# https://stackoverflow.com/a/19189356/4909087    
nested = lambda: defaultdict(nested)
d = nested()

for subd in data:
    merge(d, subd)
</code></pre>
<p></p>
<p>Using <a href="https://stackoverflow.com/a/26496899/4909087"><code>default_to_regular</code></a> to convert it back, we have:</p>
<pre><code>default_to_regular(d)
# {
#     "fruits": {
#         "apples": 17,
#         "oranges": 27,
#         "grapes": 44
#     },
#     "vegetables": {
#         "carrots": 21,
#         "beans": 12,
#         "peas": 9
#     },
#     "grains": 9,
#     "meats": 6
# }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use recursion. This solution finds all the dictionary keys in the input passed to <code>merge</code>, and then sums the values for each key if the values are integers. If the values are dictionaries, however, <code>merge</code> is called again:</p>
<pre><code>def merge(c):
  _keys = {i for b in c for i in b}
  return {i:[sum, merge][isinstance(c[0][i], dict)]([h[i] for h in c]) for i in _keys}

d = [{'fruits': {'apples': 1, 'oranges': 1, 'grapes': 2}, 'vegetables': {'carrots': 6, 'beans': 3, 'peas': 2}, 'grains': 4, 'meats': 1}, {'fruits': {'apples': 3, 'oranges': 5, 'grapes': 8}, 'vegetables': {'carrots': 7, 'beans': 4, 'peas': 3}, 'grains': 3, 'meats': 2}, {'fruits': {'apples': 13, 'oranges': 21, 'grapes': 34}, 'vegetables': {'carrots': 8, 'beans': 5, 'peas': 4}, 'grains': 2, 'meats': 3}]
</code></pre>
<hr/>
<pre><code>import json
print(json.dumps(merge(d), indent=4))
</code></pre>
<p>Output:</p>
<pre><code>{
 "meats": 6,
 "grains": 9,
 "fruits": {
    "grapes": 44,
    "oranges": 27,
    "apples": 17
 },
"vegetables": {
     "beans": 12,
     "peas": 9,
     "carrots": 21
  }
}
</code></pre>
</div>
<span class="comment-copy">When I run <code>for subd in data: print(merge(d, subd))</code> I get 3 x None.</span>
<span class="comment-copy">@MykolaZotko You are not meant to print it. It modifies <code>d</code> in-place.</span>
<span class="comment-copy">Of course. Your function doesn’t return any value. It wasn’t clear where the final result was.</span>
<span class="comment-copy">Thanks for reminding me about using them for this! I had actually been playing with defaultdicts before for the original problem of summing dicts by keys but had settled on using a counter as it seemed to be a simpler solution for the non-nested variant.</span>
<span class="comment-copy">Whoever downvoted my answer and upvoted this must have very skewed beliefs as to what readable code looks like. I understand what you are trying to do with <code>[sum, merge][isinstance(c[0][i], dict)]([h[i] for h in c])</code> but using booleans to index this way is discouraged. A simple if-else can do the same thing and look twice as readable in the process. Granted you won't be able to fit it in a single line of 80 characters, but the beauty of it is that you don't have to.</span>
