<div class="post-text" itemprop="text">
<p>I'm trying to take a nested DataFrame and convert it to a nested Dictionary.</p>
<p>Here is my original DataFrame with the following unique values:</p>
<p>input: <code>df.head(5)</code></p>
<p>output:</p>
<pre><code>    reviewerName                                  title    reviewerRatings
0        Charles       Harry Potter Book Seven News:...                3.0
1      Katherine       Harry Potter Boxed Set, Books...                5.0
2           Lora       Harry Potter and the Sorcerer...                5.0
3           Cait       Harry Potter and the Half-Blo...                5.0
4          Diane       Harry Potter and the Order of...                5.0
</code></pre>
<p>input: <code>len(df['reviewerName'].unique())</code></p>
<p>output: <code>66130</code></p>
<p>Given that there are multiple values in each of the 66130 unqiue values (ie. "Charles" would occur 3 times), I took the 66130 unique "reviewerName" and assign them all as the <strong>key</strong> in the new nested DataFrame, then assign the <strong>value</strong> using "title" and "reviewerRatings" as another layer of key:value in the same nested DataFrame.</p>
<p>input: <code>df = df.set_index(['reviewerName', 'title']).sort_index()</code></p>
<p>output:</p>
<pre><code>                                                       reviewerRatings
    reviewerName                               title
         Charles    Harry Potter Book Seven News:...               3.0
                    Harry Potter and the Half-Blo...               3.5
                    Harry Potter and the Order of...               4.0
       Katherine    Harry Potter Boxed Set, Books...               5.0
                    Harry Potter and the Half-Blo...               2.5
                    Harry Potter and the Order of...               5.0
...
230898 rows x 1 columns
</code></pre>
<p>As a follow up to the
 <a href="https://stackoverflow.com/questions/54209548/filter-all-unique-items-in-column1-as-a-key-along-with-column2-and-column3-as-k?noredirect=1#comment95248962_54209548">first question</a>, I tried to convert the nested DataFrame to a nested Dictionary.</p>
<p>The new nested DataFrame column indexing above shows "reviewerRatings" in the 1st row (column 3) and "reviewerName" and "title" in the 2nd row (column 1 and 2), and when I run the <code>df.to_dict()</code> method below, output shows <code>{reviewerRatingsIndexName: {(reviewerName, title): reviewerRatings}}</code></p>
<p>input: <code>df.to_dict()</code></p>
<p>output:</p>
<pre><code>{'reviewerRatings': 
 {
  ('Charles', 'Harry Potter Book Seven News:...'): 3.0, 
  ('Charles', 'Harry Potter and the Half-Blo...'): 3.5, 
  ('Charles', 'Harry Potter and the Order of...'): 4.0,   
  ('Katherine', 'Harry Potter Boxed Set, Books...'): 5.0, 
  ('Katherine', 'Harry Potter and the Half-Blo...'): 2.5, 
  ('Katherine', 'Harry Potter and the Order of...'): 5.0,
 ...}
}
</code></pre>
<p>But for my desired output below, I'm looking to get my output as <code>{reviewerName: {title: reviewerRating}}</code> which is exactly the way I had sorted in the nested DataFrame.</p>
<pre><code>{'Charles': 
 {'Harry Potter Book Seven News:...': 3.0, 
  'Harry Potter and the Half-Blo...': 3.5, 
  'Harry Potter and the Order of...': 4.0},   
 'Katherine':
 {'Harry Potter Boxed Set, Books...': 5.0, 
  'Harry Potter and the Half-Blo...': 2.5, 
  'Harry Potter and the Order of...': 5.0},
...}
</code></pre>
<p>Is there any way to manipulate the nested DataFrame or nested Dictionary so that when I run <code>df.to_dict()</code> method, it would show <code>{reviewerName: {title: reviewerRating}}</code>.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of approaches. You can use <code>groupby</code> with <code>to_dict</code>, or iterate rows with <code>collections.defaultdict</code>. Notably, the latter isn't <em>necessarily</em> less efficient.</p>
<h3><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html" rel="nofollow noreferrer"><code>groupby</code></a> + <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.to_dict.html" rel="nofollow noreferrer"><code>to_dict</code></a></h3>
<p>Construct a series from each <code>groupby</code> object and convert it to a dictionary to give a series of dictionary values. Finally, convert this to a dictionary of dictionaries via another <code>to_dict</code> call.</p>
<pre><code>res = df.groupby('reviewerName')\
        .apply(lambda x: x.set_index('title')['reviewerRatings'].to_dict())\
        .to_dict()
</code></pre>
<h3><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a></h3>
<p>Define a <code>defaultdict</code> of <code>dict</code> objects and iterate your dataframe by row.</p>
<pre><code>from collections import defaultdict

res = defaultdict(dict)
for row in df.itertuples(index=False):
    res[row.reviewerName][row.title] = row.reviewerRatings
</code></pre>
<p>The resulting <code>defaultdict</code> does not need to be converted back to a regular <code>dict</code> as <code>defaultdict</code> is a subclass of <code>dict</code>.</p>
<h3>Performance benchmarking</h3>
<p>Benchmarking is set-up and data dependent. You should test with your own data to see what works best.</p>
<pre><code># Python 3.6.5, Pandas 0.19.2

from collections import defaultdict
from random import sample

# construct sample dataframe
np.random.seed(0)
n = 10**4  # number of rows
names = np.random.choice(['Charles', 'Lora', 'Katherine', 'Matthew',
                          'Mark', 'Luke', 'John'], n)
books = [f'Book_{i}' for i in sample(range(10**5), n)]
ratings = np.random.randint(0, 6, n)

df = pd.DataFrame({'reviewerName': names, 'title': books, 'reviewerRatings': ratings})

def jez(df):
    return df.groupby('reviewerName')['title','reviewerRatings']\
             .apply(lambda x: dict(x.values))\
             .to_dict()

def jpp1(df):
    return df.groupby('reviewerName')\
             .apply(lambda x: x.set_index('title')['reviewerRatings'].to_dict())\
             .to_dict()

def jpp2(df):
    dd = defaultdict(dict)
    for row in df.itertuples(index=False):
        dd[row.reviewerName][row.title] = row.reviewerRatings
    return dd

%timeit jez(df)   # 33.5 ms per loop
%timeit jpp1(df)  # 17 ms per loop
%timeit jpp2(df)  # 21.1 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html" rel="nofollow noreferrer"><code>groupby</code></a> with lambda function for <code>dictionaries</code> per <code>reviewerName</code> and then output <code>Series</code> convert by <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.to_dict.html" rel="nofollow noreferrer"><code>to_dict</code></a>:</p>
<pre><code>print (df)
  reviewerName                             title  reviewerRatings
0      Charles  Harry Potter Book Seven News:...              3.0
1      Charles  Harry Potter Boxed Set, Books...              5.0
2      Charles  Harry Potter and the Sorcerer...              5.0
3    Katherine  Harry Potter and the Half-Blo...              5.0
4    Katherine   Harry otter and the Order of...              5.0
</code></pre>
<hr/>
<pre><code>d = (df.groupby('reviewerName')['title','reviewerRatings']
       .apply(lambda x: dict(x.values))
       .to_dict())
print (d)

{
    'Charles': {
        'Harry Potter Book Seven News:...': 3.0,
        'Harry Potter Boxed Set, Books...': 5.0,
        'Harry Potter and the Sorcerer...': 5.0
    },
    'Katherine': {
        'Harry Potter and the Half-Blo...': 5.0,
        'Harry otter and the Order of...': 5.0
    }
}
</code></pre>
</div>
<span class="comment-copy">thanks for your help!</span>
<span class="comment-copy">@Mick - You are welcome!</span>
