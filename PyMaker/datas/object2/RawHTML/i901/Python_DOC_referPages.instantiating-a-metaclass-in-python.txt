<div class="post-text" itemprop="text">
<p>I wrote a class in python which inherits from <code>type</code> . I thought that this was the only requirement for a class so as to be called as a metaclass but had not defined a <code>__new__</code> method for it. But on instantiating with this new class as the metaclass I got an error stating the below : </p>
<pre><code>TypeError: type.__new__() takes exactly 3 arguments (0 given)
</code></pre>
<p>The following is my code  :</p>
<pre><code>class a(type) :
    pass 
c= a()
</code></pre>
<p>Now when the class statement is being processed , that the <code>__new__</code> method of <code>type</code> is being called is my assumption. This is because the default metaclass of all classes in python is <code>type</code> . </p>
<p>Now when I am instantiating the class <code>a</code> , which I have assumed to be a metaclass under the assumption that any class inheriting from (<code>type</code>) is a metaclass , isn't it the same as creating a class ? Why should this not result in <code>type.__new__</code> being called with correct arguments ? </p>
</div>
<div class="post-text" itemprop="text">
<p>This does not work:</p>
<pre><code>class a(type) :
    pass 
c = a()
</code></pre>
<p>...for the same reason for which this does not work:</p>
<pre><code>c = type()
</code></pre>
<p>In the end, both do the same.</p>
<p>To use it as a metaclass, do this:</p>
<pre><code>&gt;&gt;&gt; class Class(metaclass=a):
...     pass
...
&gt;&gt;&gt; Class
&lt;class '__main__.Class'&gt;
&gt;&gt;&gt; type(Class)
&lt;class '__main__.a'&gt;
</code></pre>
<p>You could also instantiate the class directly, as you tried, but you have to provide the correct arguments:</p>
<pre><code>AnotherClass = type('AnotherClass', (), {})

YetAnotherClass = a('YetAnotherClass', (), {})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This error is due to you not respecting <code>type</code>'s signature.</p>
<p>Inheriting from <code>type</code> is indeed <em>enough</em> for a class to be used as a metaclass, but the thing is you actually have to <em>use</em> it as a metaclass.</p>
<p><code>type</code> itself has "two working modes:  if called with <em>3</em> positional arguments, it creates a <em>new</em> class. And then <em>type</em> is the metaclass of that class. If called with <em>1</em> positional argument, it creates no new class or object at all - instead, it just returns that object's class. </p>
<p>But it makes no sense calling <code>type</code> with <em>no</em> arguments at all. And the arguments in the modes above are not optional. So, you will get a <code>TypeError</code> if your try to call type with no arguments at all - and that is not  a "TypeError because something went wrong with the type class" - it is a "TypeError because your call did not match the callable signature".</p>
<p>When you inherit from <code>type</code> and change nothing, you class will behave exactly the same as the original <code>type</code>: you can call it with either <em>one</em> or <em>three</em> positional arguments, and the code responsible for working in either mode lies in <code>type.__new__</code>.</p>
<p>Now, if you want to use your class as a metaclass, you can indeed call it, but in the three argument form: you ass it the new class name, its bases and its attributes - which can actually be all empty, but you have to pass a string, a tuple and a dictionary as these three arguments:</p>
<pre><code>class A(type): pass

myclass = A("", (), {})
</code></pre>
<p>And now, <code>A</code> is working as the metaclass for <code>myclass</code>:</p>
<pre><code>In [16]: type(myclass)                                                                                   
Out[16]: __main__.A
</code></pre>
<p>However, whenever one defines a metaclass it is more usual to use it with the <code>metaclass=</code> named argument when declaring a class body:</p>
<pre><code>In [17]: class  MyOtherClass(metaclass=A): 
    ...:     pass 
    ...:                                                                                                 

In [18]: type(MyOtherClass)                                                                              
Out[18]: __main__.A
</code></pre>
<p>Python's runtime will then compile this class body, and when the bytecod for it is executed, it will make the call to your metaclass' <code>__new__</code> (and then <code>__init__</code>, and before that its <code>__prepare__</code>) method, so that it works as a metaclass.</p>
<p>So, just in case it is not clear: when you derive a class from <code>type</code> intending to use it as a metaclass, there is no need to further instantiate it to say that "it is now a metaclass". A subclass of type already can be a metaclass, and its <em>instances</em> will be classes, that will have it as a metaclass.  </p>
</div>
<span class="comment-copy">Maybe there is a x-y problem going on here. Normally the need for metaclasses arise naturally if we have a problem that will actually need then. And in this case, we will have a good idea of what they are - that does not seem to be the case. What it is that you want to achieve with your metaclass?</span>
<span class="comment-copy">@zvzone : In the second example here , you are calling the <b>init</b> of the type class which is implicitly calling up the <b>new</b> method right ?</span>
<span class="comment-copy">@itpdusra <code>__init__</code> does not call <code>__new__</code>. When an instance is constructed, <code>__new__</code> is called first and then <code>__init__</code> is called. <code>__new__</code> creates a new instance and <code>__init__</code> initializes it. In other words, result of <code>__new__</code> is passed to <code>__init__</code> as <code>self</code>. See <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">Python doc on <code>__new__</code></a> for more details.</span>
<span class="comment-copy">Understood that , what I wanted to be sure of is whether with the second line of instantiation you are calling the constructor of the metaclass</span>
<span class="comment-copy">@itpdusra I see. The metaclass constructor is called after the last line of class definition, i.e. after <code>class Class(metaclass=a):</code> and <code>pass</code>. Try creating a metaclass with <code>print</code>s in <code>__new__</code> and <code>__init__</code> and then see when they are printed.</span>
