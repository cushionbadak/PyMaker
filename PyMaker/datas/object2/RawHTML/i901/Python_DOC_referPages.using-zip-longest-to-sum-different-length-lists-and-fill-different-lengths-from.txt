<div class="post-text" itemprop="text">
<p>I have two lists <code>[1,2,3,4]</code> and <code>[1,2,3]</code></p>
<p>I would like to sum these to give me the following: <code>[1,3,5,7]</code>.</p>
<p>This was done by doing <code>1+0=1</code>, <code>2+1=3</code>, <code>3+2=5</code> and <code>4+3=7</code>.</p>
<p>I understand that <code>itertools.zip_longest</code> would do this, but it would fill the mismatch in length with <code>0</code> at the end, giving me <code>[2,3,6,4]</code> and not the value I want.</p>
<p>I would like the mismatch in length to be solved by filling the first length with zero.</p>
</div>
<div class="post-text" itemprop="text">
<p>The built-in <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow noreferrer"><code>reversed()</code></a> function could be used to do it like this:</p>
<pre><code>from itertools import zip_longest    

def sum_lists(*iterables):
    iterables = (reversed(it) for it in iterables)
    return list(reversed([a+b for a, b in zip_longest(*iterables, fillvalue=0)]))


if __name__ == '__main__':
    result = sum_lists([1, 2, 3, 4], [1, 2, 3])
    print(result)  # -&gt; [1, 3, 5, 7]
    result = sum_lists([1, 2, 3], [1, 2, 3, 4])
    print(result)  # -&gt; [1, 3, 5, 7]    # Order of args doesn't matter.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pad the second list with zeros and use <code>zip</code>:</p>
<pre><code>s1, s2 = [1,2,3,4], [1, 2, 3]
new_result = [a+b for a, b in zip(s1, ([0]*(len(s1)-len(s2)))+s2)]
</code></pre>
<p>Output:</p>
<pre><code>[1, 3, 5, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could build a <em>shift</em> by using <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer">repeat</a>, then concatenate the shift with the shorter one using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">chain</a>:</p>
<pre><code>from itertools import repeat, chain

first = [1, 2, 3, 4]
second = [1, 2, 3]

shift = repeat(0, abs(len(first) - len(second)))

result = [a + b for a, b in zip(first, chain(shift, second))]

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[1, 3, 5, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>reversed</code> function to generate the two lists in reverse order so that <code>zip_longest</code> would align the zipping from the other end, and then reverse the result afterwards:</p>
<pre><code>from itertools import zip_longest
lists = [1,2,3,4], [1, 2, 3]
print(list(map(sum, zip_longest(*map(reversed, lists), fillvalue=0)))[::-1])
</code></pre>
<p>This outputs:</p>
<pre><code>[1, 3, 5, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could go around this problem be <em>reversing</em> your lists befor <code>zip</code>ing with <code>zip_longest</code>.</p>
<pre><code>from itertools import zip_longest

s1, s2 = [1,2,3,4], [1, 2, 3]
res = [a+b for a, b in zip_longest(reversed(s1), reversed(s2), fillvalue=0)]
</code></pre>
<p>and finally, <em>reverse</em> again, to produce the desired result:</p>
<pre><code>res = res[::-1]
print(res)  # [1, 3, 5, 7]
</code></pre>
<hr/>
<p>The main advantage of this method as @CoryKramer says in his comment is that you do not have to know beforehand which list is the longest.</p>
</div>
<span class="comment-copy">This is assuming that <code>s2</code> is always the shorter list, <code>zip_longest</code> will determine which is shorter. Not a bad solution, but would likely need one previous step to determine which list to pad in the front.</span>
<span class="comment-copy">does not differ much from mine, does it?</span>
<span class="comment-copy">I saw yours after I posted mine. They're indeed the same in idea, but since mine is somewhat more generalized in that it can accommodate multiple lists, I decided to leave mine here.</span>
