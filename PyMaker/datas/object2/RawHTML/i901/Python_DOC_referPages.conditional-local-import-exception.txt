<div class="post-text" itemprop="text">
<p>Consider the snippet</p>
<pre class="lang-py prettyprint-override"><code>import something
import sys
print(sys.version)

def f(a):
    b = a
    if a==1:
        import something
    b *= something.value # &lt;&lt;&lt;&lt;&lt;
    return b

print(f(1))
print(f(2))
</code></pre>
<p>where the module <code>something</code> defines <code>value = 1</code>. Running that script with Python 3.6.7, the call <code>f(1)</code> succeeds but the call <code>f(2)</code> fails with an exception:</p>
<pre><code>UnboundLocalError: local variable 'something' referenced before assignment
</code></pre>
<p>at the line marked with <code>&lt;&lt;&lt;&lt;&lt;</code>. I really don't understand that. I found the same issue with Python 2.7, so I would bet this is not a simple regression but really tied to the way Python handles such local imports. I could not find any hint in the documentation. Has anybody an explanation?</p>
</div>
<div class="post-text" itemprop="text">
<p>An <code>import x</code> statement does two things*</p>
<ol>
<li>It loads (and runs) the module being referenced if it hasn't already been</li>
<li>It assigns the module to a variable of the same name</li>
</ol>
<p>Your function only assigns the module <code>something</code> to the <em>variable</em> <code>something</code> when <code>a == 1</code>. If <code>a != 1</code>, even if the module has been <strong>loaded</strong>, it is not assigned to a variable, so cannot be referenced.</p>
<p>This is why what you're doing fails. It's also why what you're trying to do provides you with absolutely no advantage because modules are only loaded and run the first time they are imported. Every subsequent time is just doing step 2.</p>
<p>The reason your code is not referencing the global <code>something</code> is because python overrides global names if a local variable of the same name appears anywhere in a function, even if it is never reached. The following function <code>f</code> fails similar to how yours does.</p>
<pre><code>x = 1
def f(y):
    if False:
       x = y
    return x
</code></pre>
<p>The solution is to not use <code>x</code> as both a local and global variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>If there is a assignment to a variable in a given scope, the variable is local to that scope. If that assignment is conditional and you can run your code such as it never happens (or it is referenced in that scope after being assigned to), you get this very exception. Smaller example of the same:</p>
<pre><code>def f():
    if False:
        a = 1
    print(a)

a = 1
f()
</code></pre>
<p>And the obligatory FAQ <a href="https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">link</a>.</p>
</div>
<span class="comment-copy">Because import statements cannot be used like that plus the fact you are importing something 2 times</span>
<span class="comment-copy">For that you should make a function called <code>get_value()</code> in the module and just return the value. Then you can call that in this code.</span>
<span class="comment-copy">@Hippolippo getters in python are never the answer! They certainly don't solve the problem here.</span>
<span class="comment-copy">You need a <code>else</code> to specify what happens if <code>a != 1</code>, otherwise Python expects a <i>local</i> variable <code>something</code> which was not yet defined</span>
<span class="comment-copy">For the record, it was an oversight that the local import was added although there was already a global one: the local import can just be deleted indeed (there is more code in that if branch in reality). The second part of your explanation is what enlightened me: I forgot that something is just another variable.</span>
<span class="comment-copy">I think this answer makes more sense to me.</span>
