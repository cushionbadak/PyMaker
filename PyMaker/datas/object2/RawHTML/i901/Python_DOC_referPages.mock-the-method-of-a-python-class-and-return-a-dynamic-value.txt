<div class="post-text" itemprop="text">
<p>How can Python's <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">unittest.mock</a> module be used to mock a method that uses a member of the same class?</p>
<pre><code>class NameHelper(object):
    def __init__(self):
        self.local_id = 0

    def next_id(self):
        self.local_id += 1
        return str(self.local_id)
</code></pre>
<p>Note, I'm <a href="https://docs.python.org/3.5/library/unittest.mock.html#start-and-stop" rel="nofollow noreferrer">patch.start and patch.stop</a> to do patching in the <code>setUp</code> method:</p>
<pre><code>class TestSomeClient(unittest.TestCase):

    def setUp(self):
        patcher = patch('helpers.name_helper.NameHelper')
        self.addCleanup(patcher.stop)
        self.mock_name_helper = patcher.start()

        # The actual mocked values
        self.mock_name_helper.return_value.local_id = 0
        self.mock_name_helper.return_value.next_id.return_value = 'mock-name'
</code></pre>
<p>Clearly, <strong>mock-name</strong> is not a sensible mock return value. The return value should use the <code>local_id</code> member of <code>NameHelper</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm unsure why the question was down-voted with no comments. The answer is, IMO, not clear.</p>
<p>The Python documentation for <a href="https://docs.python.org/3.5/library/unittest.mock.html#start-and-stop" rel="nofollow noreferrer">patch.start and patch.stop</a>, provides the following example for patching in setUp:</p>
<pre><code>class MyTest(TestCase):
     def setUp(self):
         self.patcher1 = patch('package.module.Class1')
         self.MockClass1 = self.patcher1.start()

     def tearDown(self):
         self.patcher1.stop()

MyTest('test_something').run()
</code></pre>
<p>However, when patching entire class, this is misleading. The following is more helpful:</p>
<pre><code>class MockClass1():
    pass

class MyTest(TestCase):
    def setUp(self):
        self.patcher1 = patch('package.module.Class1')
        self.MockClass1 = self.patcher1.start()
        self.MockClass1.return_value = MockClass1()

    def tearDown(self):
        self.patcher1.stop()
</code></pre>
<p>Note, the additional line:</p>
<pre><code>self.MockClass1.return_value = MockClass1()
</code></pre>
<p>The <code>return_value</code> should be a new instance of the class <code>MockClass1</code>. Applied to my example:</p>
<pre><code>class MockNameHelper(object):
    def __init__(self):
        self.local_id = 0

    def next_id(self):
        self.local_id += 1
        return str(self.local_id)

class TestSomeClient(unittest.TestCase):

    def setUp(self):
        patcher = patch('helpers.name_helper.NameHelper')
        self.addCleanup(patcher.stop)
        self.MockNameHelper = patcher.start()
        self.MockNameHelper.return_value = MockNameHelper()
</code></pre>
</div>
