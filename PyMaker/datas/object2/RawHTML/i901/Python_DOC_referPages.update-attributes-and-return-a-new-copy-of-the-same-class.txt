<div class="post-text" itemprop="text">
<pre><code>class Main(object):

    def __init__(self,  config):
        selt.attributes = config

    def return_new_copy(self, additional_attributes):
        addtional_attributes.update(self.attributes)
        return Main(additional_attributes) 
</code></pre>
<p>I want to update the instance attributes and return a new instance of the same class. I guess I am trying to find out if the above code is Pythonic or if it's a dirty approach. I can't use classmethod for several reasons not mentioned here. Is there another recommended approach. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>return_new_copy</code> modifies the parameter passed in which is probably undesirable.  It also overrides in the wrong direction (giving precedence to <code>self.attributes</code>)</p>
<p>I'd write it as follows:</p>
<pre><code>def return_new_copy(self, additional_attributes):
     # python&lt;3.5 if there are only string keys:
     #     attributes = dict(self.attributes, **additional_attributes)
     # python&lt;3.5 if there are non-string keys:
     #     attributes = self.attributes.copy()
     #     attributes.update(additional_attributes)
     # python3.5+
     attributes = {**self.attributes, **additional_attributes}
     return type(self)(attributes)
</code></pre>
<p>A few subtleties:
- I make sure to copy both the input attributes and the self attributes
- I merge the additional attributes on top of the self attributes</p>
<p>If you're looking for something to do this automatically, you might want to check out <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a></p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; C = collections.namedtuple('C', ('a', 'b'))
&gt;&gt;&gt; x = C(1, 2)
&gt;&gt;&gt; x
C(a=1, b=2)
&gt;&gt;&gt; y = x._replace(b=3)
&gt;&gt;&gt; y
C(a=1, b=3)
&gt;&gt;&gt; x
C(a=1, b=2)
</code></pre>
</div>
<span class="comment-copy">Why not just update them? I.e. <code>m1 = Main({'a': 1}); m2 = Main({'b': 2}); m2.attributes.update(m1.attributes)</code>. Regarding your approach I'd use <code>type(self)</code> instead of <code>Main</code> but apart from that it's fine. You could also define <code>+</code> operator by defining <code>__add__</code> then you can use <code>m1 = Main({'a': 1}); m2 = m1 + {'b': 2}</code>.</span>
<span class="comment-copy">you can use copy module for deepcopy and return that instance.</span>
<span class="comment-copy">Do you want the original <code>Main</code> instance and the new one to share attribute values or should it get a copy of them? AFAIK, there's nothing particularly "unpythonic" about what you're doing.</span>
