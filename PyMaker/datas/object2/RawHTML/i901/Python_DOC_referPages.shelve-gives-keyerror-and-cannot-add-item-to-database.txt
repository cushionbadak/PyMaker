<div class="post-text" itemprop="text">
<p>My following code:</p>
<pre><code>shelve_object = shelve.open('data/shelve_data', writeback=True)
print([key for key in shelve_object])
for key in shelve_object:
    print(shelve_object[key])
</code></pre>
<p>gives me the following output:</p>
<pre><code>['251784238314029058', '259650808973492225', '493076669914152965', '525293044375879690', '272814395237859330']

Traceback (most recent call last):
  File "/usr/lib/python3.6/shelve.py", line 111, in __getitem__
    value = self.cache[key]
KeyError: '251784238314029058'
</code></pre>
<p>I also noticed the following errors in my logs:</p>
<pre><code>  File "/usr/lib/python3.6/shelve.py", line 113, in __getitem__
    f = BytesIO(self.dict[key.encode(self.keyencoding)])
_dbm.error
</code></pre>
<pre><code>  File "/usr/lib/python3.6/shelve.py", line 125, in __setitem__
    self.dict[key.encode(self.keyencoding)] = f.getvalue()
_dbm.error: cannot add item to database
</code></pre>
<p>How is it possible that shelve returns keys that doesn't seem to exist?</p>
</div>
<div class="post-text" itemprop="text">
<p>Either the dbm file backing your shelve is corrupted, or you have some kind of incompatibility between your file and the <code>dbm</code> backend library used for your shelve file.</p>
<p><code>shelve</code> is backed by the <a href="https://docs.python.org/3/library/dbm.html" rel="nofollow noreferrer"><code>dbm</code> module</a>, and it depends on your OS exactly what specific implementation is used, but generally speaking a <code>dbm</code> file is an on-disk <a href="https://en.wikipedia.org/wiki/Hash_table" rel="nofollow noreferrer">hash table</a>, a data structure that uses a sparse table structure to efficiently find keys again later on.</p>
<p>To show you all the keys in a file, a <code>dbm</code> library would scan over the table and give you each key as it finds a non-empty slot. But to find the value for a given key, it would <em>hash</em> the key to come to a number between zero and the maximum size of the table, look at the corresponding row in the table and get you the value.</p>
<p>Between those two techniques there is a discrepancy; you appear to have keys in the <em>wrong location in the table</em>. How that happened is hard to say, it could be that file corruption changed the bookkeeping and the actual table size differs from what the bookkeeping info states it should be. It could be that you changed machines and the hashing implementation is now wrong. Or something else, but we can't really help there, sorry.</p>
</div>
