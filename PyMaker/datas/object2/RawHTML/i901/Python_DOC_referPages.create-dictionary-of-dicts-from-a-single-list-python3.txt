<div class="post-text" itemprop="text">
<p>Python 3.6.5/3.7.1 on Linux</p>
<p>Struggling to create a dictionary with dictionaries as values.</p>
<p>I want to create a dictionary from a list date &amp; time data (ultimately to create charts with bokeh).</p>
<p>This must have been asked before, but I can't find a set of search terms that returns a result that clarifies matters for me.</p>
<p>nb I'm essentially a hobby coder, &amp; I don't easily think algorithmically like a real programmer. </p>
<p>The data is in a list (max 3200 items):
Each item is a record of the occurrence of an event on a date in a clock period of one hour.</p>
<p>Thus; <code>['03/01/19 09:00', '03/01/19 09:00', '03/01/19 09:00',]</code> indicates 3 events between 0900-1000 on 03/01/2019.</p>
<p>Only clock periods with events are recorded, so if no event, no timestamp.</p>
<p>nb date format is <code>ddmmyy</code></p>
<p>Example data:</p>
<pre><code>dtl = [
    '06/01/19 12:00', '06/01/19 12:00', '06/01/19 11:00', '05/01/19 21:00',
    '05/01/19 17:00', '05/01/19 17:00', '05/01/19 14:00', '03/01/19 21:00',
    '03/01/19 17:00', '03/01/19 12:00', '03/01/19 12:00', '03/01/19 12:00',
    '03/01/19 12:00', '03/01/19 12:00', '03/01/19 11:00', '03/01/19 10:00',
    '03/01/19 10:00', '03/01/19 09:00','03/01/19 09:00','03/01/19 09:00',
]
</code></pre>
<p>The desired dictionary would look like this:</p>
<pre><code>dtd = {
    '03/01/19': {
         '00': 0, '01': 0, '02': 0, '03': 0, '04': 0, '05': 0,
         '06': 0, '07': 0, '08': 0, '09': 3, '10': 2, '11': 1,
         '12': 5, '13': 0, '14': 0, '15': 0, '16': 0, '17': 1,
         '18': 0, '19': 0, '20': 0, '21': 1, '22': 0, '23': 0,
     },
     '04/01/19': {
         '00': 0, ... '23': 0
     },
     '05/01/19': {
         '00': 0, ... 
     } ... etc
}
</code></pre>
<p>Clearly I can initialise a dictionary with at least the keys:</p>
<pre><code>{i.split()[0]:{} for i in dtl}
</code></pre>
<p>But then I can't get my head round what I need to do to update the subdicts with the counts, &amp; so can't see a way to get from the original list to the desired dictionary. I'm going round in circles!</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest the use of <code>collections.defaultdict</code> since some of your counts can be 0.</p>
<p>Here's an option:</p>
<pre><code>from collections import defaultdict

dtl = ['06/01/19 12:00', '06/01/19 12:00', '06/01/19 11:00', 
       '05/01/19 21:00', '05/01/19 17:00', '05/01/19 17:00', 
       '05/01/19 14:00', '03/01/19 21:00', '03/01/19 17:00',
       '03/01/19 12:00', '03/01/19 12:00', '03/01/19 12:00', 
       '03/01/19 12:00', '03/01/19 12:00', '03/01/19 11:00', 
       '03/01/19 10:00', '03/01/19 10:00', '03/01/19 09:00',
       '03/01/19 09:00','03/01/19 09:00',]

# Nested defaultdict
result = defaultdict(lambda: defaultdict(int))

for date_time in dtl:
    date, time = date_time.split()
    result[date][time.split(':')[0]] += 1
</code></pre>
<p>Output (using <code>pprint</code>):</p>
<pre><code>defaultdict(&lt;function &lt;lambda&gt; at 0x7f20d5c37c80&gt;,
            {'03/01/19': defaultdict(&lt;class 'int'&gt;,
                                     {'09': 3,
                                      '10': 2,
                                      '11': 1,
                                      '12': 5,
                                      '17': 1,
                                      '21': 1}),
             '05/01/19': defaultdict(&lt;class 'int'&gt;,
                                     {'14': 1,
                                      '17': 2,
                                      '21': 1}),
             '06/01/19': defaultdict(&lt;class 'int'&gt;, {'12': 2, '11': 1})})
</code></pre>
<p>If you really want to show the <code>0</code> for printing then I don't really see a way around keeping an array of <code>times</code> as I've done here and initializing your <code>dict</code> that way. </p>
<pre><code>times = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10',
         '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21',
         '22', '23']

dtl = ['06/01/19 12:00', '06/01/19 12:00', '06/01/19 11:00', 
       '05/01/19 21:00', '05/01/19 17:00', '05/01/19 17:00', 
       '05/01/19 14:00', '03/01/19 21:00', '03/01/19 17:00',
       '03/01/19 12:00', '03/01/19 12:00', '03/01/19 12:00', 
       '03/01/19 12:00', '03/01/19 12:00', '03/01/19 11:00', 
       '03/01/19 10:00', '03/01/19 10:00', '03/01/19 09:00',
       '03/01/19 09:00','03/01/19 09:00']

result = {date_time.split()[0] : {time : 0 for time in times} for date_time in dtl}

for date_time in dtl:
    date, time = date_time.split()
    result[date][time.split(':')[0]] += 1
</code></pre>
<p>Output below:</p>
<pre><code>{'06/01/19': {'00': 0, '01': 0, '02': 0, '03': 0, '04': 0, '05': 0, '06': 0, '07': 0, '08': 0, '09': 0, '10': 0, '11': 1, '12': 2, '13': 0, '14': 0, '15': 0, '16': 0, '17': 0, '18': 0, '19': 0, '20': 0, '21': 0, '22': 0, '23': 0}, '05/01/19': {'00': 0, '01': 0, '02': 0, '03': 0, '04': 0, '05': 0, '06': 0, '07': 0, '08': 0, '09': 0, '10': 0, '11': 0, '12': 0, '13': 0, '14': 1, '15': 0, '16': 0, '17': 2, '18': 0, '19': 0, '20': 0, '21': 1, '22': 0, '23': 0}, '03/01/19': {'00': 0, '01': 0, '02': 0, '03': 0, '04': 0, '05': 0, '06': 0, '07': 0, '08': 0, '09': 3, '10': 2, '11': 1, '12': 5, '13': 0, '14': 0, '15': 0, '16': 0, '17': 1, '18': 0, '19': 0, '20': 0, '21': 1, '22': 0, '23': 0}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could combine a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> with a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> to do this pretty effectively once you have split into a dictionary by date. So first split by date:</p>
<pre><code>from collections import Counter, defaultdict

dtd = defaultdict(list)
for date, time in (item.split() for item in dtl):
    dtd[date].append(time[:2])
</code></pre>
<p>Now you can easily count the existing items, and use them to initialize a <code>defaultdict</code> that will return zeros for the missing times:</p>
<pre><code>for key in dtd:
    dtd[key] = defaultdict(int, Counter(dtd[key]))
</code></pre>
<p>The result is:</p>
<pre><code>defaultdict(list, {
    '03/01/19': defaultdict(int, {
        '09': 3,
        '10': 2,
        '11': 1,
        '12': 5,
        '17': 1,
        '21': 1
    }),
    '05/01/19': defaultdict(int, {'14': 1, '17': 2, '21': 1}),
    '06/01/19': defaultdict(int, {'11': 1, '12': 2})
})
</code></pre>
<p>Since the objects here are <code>defaultdict</code>s, you will be able to query dates and times that were not in the original dataset. You can avoid this by converting the result to a regular <code>dict</code> containing only the keys you want after you finish:</p>
<pre><code>hours = ['%02d' % h for h in range(24)]
dtd = {date: {h: d[h] for h in hours} for date, d in dtd}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One quick and dirty way is this:</p>
<pre><code>#!/usr/bin/env python3

def convert(dt):
    ret = {}
    for elem in dt:
        d,t = elem.split()
        t = t.split(":")[0]
        # not a valid value
        if not d: pass

        # we inserted d already
        if d in ret:
            if t in ret[d]:
                ret[d][t] += 1
        else:
            ret[d] = {'00': 0, '01': 0, '02': 0, '03': 0, '04': 0, '05': 0,
                    '06': 0, '07': 0, '08': 0, '09': 0, '10': 0, '11': 0, 
                    '12': 0, '13': 0, '14': 0, '15': 0, '16': 0, '17': 0, 
                    '18': 0, '19': 0, '20': 0, '21': 0, '22': 0, '23': 0 }
    return ret

dtl = ['06/01/19 12:00', '06/01/19 12:00', '06/01/19 11:00', '05/01/19 21:00', '05/01/19 17:00', '05/01/19 17:00', '05/01/19 14:00', '03/01/19 21:00', '03/01/19 17:00','03/01/19 12:00', '03/01/19 12:00', '03/01/19 12:00', '03/01/19 12:00', '03/01/19 12:00', '03/01/19 11:00', '03/01/19 10:00', '03/01/19 10:00', '03/01/19 09:00','03/01/19 09:00','03/01/19 09:00']

print(convert(dtl))
</code></pre>
</div>
<span class="comment-copy">Just to confirm all the times are on the hour? Won't see any <code>09:30</code>?</span>
<span class="comment-copy">@hqkhan correct</span>
<span class="comment-copy">Both this answer and that by @mad-physicist are to the point and extremely helpful, but this one has the edge for me as it provides for filling the 'empty' values in the final dict.</span>
<span class="comment-copy">Slightly confused by the remark "use them to initialize a defaultdict that will return zeros for the missing times:" as in the example output, the 'missing hours' aren't shown; But I may have misunderstood the intent.</span>
<span class="comment-copy">@CodeRedacted So this has to do with the way <code>defaultdict</code> works. It will initialize your value to something if the <code>key</code> you tried wasn't in fact inside the <code>dict</code>. For instance if <code>test = {1: 20, 2: 25}</code>. Assuming <code>test</code> is a <code>defaultdict</code>, you tried issuing <code>test[15]</code>, even though <code>15</code> doesn't exist inside <code>test</code>, you will get back <code>0</code> and not a <code>KeyError</code>. The same behavior can be done using <code>.get(key, default_value)</code> I believe but <code>defaultdict</code> makes things look neat.</span>
<span class="comment-copy">@hqkhan. The advantage of <code>defaultdict</code> over <code>get</code> or <code>setdefault</code> is that <code>defaultdict</code> only calls the constructor you pass in when the key is missing. With the <code>dict</code> methods, you call the constructor every time, before calling the method, resulting in usually harmless but unnecessary overhead.</span>
<span class="comment-copy">@MadPhysicist Nice. Good to know.</span>
<span class="comment-copy">@CodeRedacted. A defaultdict only shows the keys you set, but it allows you to query any key at all. <code>dtd['blah']</code> will return <code>[]</code>, while <code>dtd[03/01/19]['blah']</code> will return 0. Since it makes sense that you wouldn't want to have this happen for arbitrary times and dates, I've added a snippet to quickly convert to a normal nested dictionary to my answer.</span>
<span class="comment-copy"><code>ret[d] = {}</code>. Did you forget to insert the first time and add 1? Similarly, in the <code>if</code> portion, you should be starting with 1, not 0.</span>
<span class="comment-copy">yup you are right, was not in the right format, too.</span>
