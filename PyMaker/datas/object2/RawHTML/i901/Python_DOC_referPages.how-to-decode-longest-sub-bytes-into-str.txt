<div class="post-text" itemprop="text">
<p>Suppose I read a long <code>bytes</code> object from somewhere, knowing it is <code>utf-8</code> encoded. But the read may not fully consume the available content so that the last character in the stream may be incomplete. Calling <code>bytes.decode()</code> on this object may result in a decode error. But what really fails is only the last few bytes. Is there a function that works in this case, returning the longest decoded string and the remaining bytes?</p>
<p><code>utf-8</code> encodes a character into at most 4 bytes, so trying to decode truncated bytes should work, but a vast majority of computation will be wasted, and I don't really like this solution.</p>
<p>To give a simple but concrete example:</p>
<pre><code>&gt;&gt;&gt; b0 = b'\xc3\x84\xc3\x96\xc3'
&gt;&gt;&gt; b1 = b'\x9c\xc3\x84\xc3\x96\xc3\x9c'
&gt;&gt;&gt; (b0 + b1).decode()
&gt;&gt;&gt; '√Ñ√ñ√ú√Ñ√ñ√ú'
</code></pre>
<p><code>(b0 + b1).decode()</code> is fine, but <code>b0.decode()</code> will raise. The solution should be able to decode <code>b0</code> for as much as possible and return the bytes that cannot be decoded.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are describing the basic use-case of <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow noreferrer"><code>io.TextIOWrapper</code></a>: a buffered text stream over a binary stream. </p>
<pre><code>&gt;&gt;&gt; import io 
&gt;&gt;&gt; txt = 'before\N{PILE OF POO}after' 
&gt;&gt;&gt; b = io.BytesIO(txt.encode('utf-8'))
&gt;&gt;&gt; t = io.TextIOWrapper(b) 
&gt;&gt;&gt; t.read(5) 
'befor'
&gt;&gt;&gt; t.read(1) 
'e'
&gt;&gt;&gt; t.read(1)
'üí©'
&gt;&gt;&gt; t.read(1) 
'a'
</code></pre>
<p>Contrast with reading a bytes stream directly, where it would be possible to read halfway through an encoded pile of poo:</p>
<pre><code>&gt;&gt;&gt; b.seek(0) 
0
&gt;&gt;&gt; b.read(5)
b'befor'
&gt;&gt;&gt; b.read(1)
b'e'
&gt;&gt;&gt; b.read(1)
b'\xf0'
&gt;&gt;&gt; b.read(1)
b'\x9f'
&gt;&gt;&gt; b.read(1)
b'\x92'
&gt;&gt;&gt; b.read(1)
b'\xa9'
&gt;&gt;&gt; b.read(1)
b'a'
</code></pre>
<p>Specify <code>encoding="utf-8"</code> if you want to be explicit. The default encoding, i.e. <code>locale.getpreferredencoding(False)</code>, would usually be utf-8 anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I mentioned in the comments under @wim's answer, I think you could use the <a href="https://docs.python.org/3/library/codecs.html#codecs.iterdecode" rel="nofollow noreferrer"><code>codecs.iterdecode()</code></a> incremental decoder to do this. Since it's a generator function, there's no need to manually save and restore its state between iterative calls to it.</p>
<p>Here's how how it might be used to handle a situation like the one you described:</p>
<pre><code>import codecs
from random import randint


def reader(sequence):
    """ Yield random length chunks of sequence until exhausted. """

    plural = lambda word, n, ending='s': (word+ending) if n &gt; 1 else word

    i = 0
    while i &lt; len(sequence):
        size = randint(1, 4)
        chunk = sequence[i: i+size]

        hexrepr = '0x' + ''.join('%02X' % b for b in chunk)
        print('read {} {}: {}'.format(size, plural('byte', len(chunk)), hexrepr))

        yield chunk
        i += size


bytes_obj = b'\xc3\x84\xc3\x96\xc3\x9c\xc3\x84\xc3\x96\xc3\x9c'  # '√Ñ√ñ√ú√Ñ√ñ√ú'

for decoded in codecs.iterdecode(reader(bytes_obj), 'utf-8'):
    print(decoded)
</code></pre>
<p>Sample output:</p>
<pre class="lang-none prettyprint-override"><code>read 3 bytes: 0xC384C3
√Ñ
read 1 byte: 0x96
√ñ
read 1 byte: 0xC3
read 3 bytes: 0x9CC384
√ú√Ñ
read 2 bytes: 0xC396
√ñ
read 4 bytes: 0xC39C
√ú
</code></pre>
</div>
<span class="comment-copy">@usr2564301 That's true. UTF-8 is self synchronizing. So I can check each byte backwards discarding non-first bytes. All right. But the question still has its value when you don't know about the encoding of the text.</span>
<span class="comment-copy">Sir/Madam, after consuming all decodeable bytes with <code>TextIOWrapper</code>, how do I get the remaining bytes? Furthermore, doc says it is <a href="https://docs.python.org/3/library/io.html#id3" rel="nofollow noreferrer">slow</a> and <a href="https://docs.python.org/3/library/io.html#io.TextIOBase.tell" rel="nofollow noreferrer">opaque</a>.</span>
<span class="comment-copy">I'm possibly reinventing wheels and I'm wondering if that's worthwhile... I really want to only keep one copy of binary data and decode when needed, and that reconstruction thing feared me: Is it reconstructing bytes from chars? That would be encoding not decoding.</span>
<span class="comment-copy">The title Sir/Madam is inappropriate, henceforth please address as <b>"Your Royal Badgerness"</b>.  If the stream is not complete, you should wait for more bytes, either blocking (sync) or yielding (async), leaving some bytes buffered if necessary.</span>
<span class="comment-copy">Badgerness: Couldn't <code>codecs.iterdecode()</code> be used somehow to do this?</span>
<span class="comment-copy">@martineau Looks good. The incremental decoder has a <code>getstate()</code> method whose return value includes undecoded input.</span>
