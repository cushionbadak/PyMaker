<div class="post-text" itemprop="text">
<p>I'm using Regular Expression to check the validity of a string.
In particular I want the test pass if the String contains <strong>unique uppercase name</strong> (one or more), eventually seprated by <strong>comma</strong>.</p>
<p>Each name lenght should be between <strong>3</strong> and <strong>20</strong>.</p>
<p>Accepted strings:</p>
<blockquote>
<p>JOHN,MARK,EDDIE</p>
<p>JOHN</p>
</blockquote>
<p>NOT Accepted strings:</p>
<blockquote>
<p>JOHN,</p>
<p>JOHN MARK</p>
<p><strong>JOHN</strong>,MARK,EDDIE,<strong>JOHN</strong></p>
</blockquote>
<p>I'm using the following Regex that ensure that names must be separated by comma (if more than one), but how can I tell that names should be unique?</p>
<pre><code>^([A-Z]{3,20})(,[A-Z]{3,20})*$
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/re.html#index-20" rel="nofollow noreferrer">negative lookahead</a> that <a href="https://docs.python.org/3/library/re.html#index-18" rel="nofollow noreferrer">quotes</a> a <a href="https://docs.python.org/3/library/re.html#index-17" rel="nofollow noreferrer">matched name</a>:</p>
<pre><code>r'(([a-z]+),?(?!.*\2))+'
</code></pre>
<p>The <code>(?!.*\2)</code> part ensures that the matched name does not occur later on. This serves as an example for how to use negative lookahead. The complete regex as per OP requirements is:</p>
<pre><code>re.match(r'^(([A-Z]{3,20})(?![A-Z,]*,\2,),)+$', string + ',')
</code></pre>
<p>Note that this tests against <code>string + ','</code>, i.e. an artificial comma appended, to avoid messing with two different groups for first and subsequent parts.</p>
<p>I suppose the negative lookahead is short-circuiting in a sense that it fails as soon as it encounters a match. That means worst case performance should be O(N^2). We can check that by generating strings that only contain unique names and measure the regex performance. The quadratic fit gives <code>t = a*N**2 + c</code> and <code>a = 0.06 us, c = 3 us</code>.</p>
<p><a href="https://i.stack.imgur.com/ZqLg9.png" rel="nofollow noreferrer"><img alt="Timing plot" src="https://i.stack.imgur.com/ZqLg9.png"/></a></p>
<h3>Code</h3>
<pre><code>from random import choice, sample
from string import ascii_lowercase as lowercase
import re
import time

N = 500
data = [None] * N
for i in range(N):
    length = choice(range(3, 21))
    x = ''.join(sample(lowercase, length))
    while sample in data:
        length = choice(range(3, 21))
        x = ''.join(sample(lowercase, length))
    data[i] = x

pattern = re.compile(r'^(([a-z]+),?(?!.*\2))+$')
timings = []
for i in range(2, N+1):
    print('Begin iteration. ', end='', flush=True)
    string = ','.join(data[:i])
    print(f'Run for {i} unique names (lenght = {len(string)}) ... ', end='', flush=True)
    t1 = time.clock()
    m = re.match(pattern, string)
    t2 = time.clock()
    print('done.', end='', flush=True)
    assert m is not None
    timings.append(t2 - t1)
    print(' End iteration.', flush=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you might do is first find the valid strings using your regex without the capturing groups:</p>
<p><code>^[A-Z]{3,20}(?:,[A-Z]{3,20})*$</code></p>
<p>If the string is valid, then you can split on a comma, and compare the length of the items against the length of the items by using a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a> to make them unique.
If those values match, then your string is valid.</p>
<p>For example</p>
<pre><code>import re
strings = ["JOHN,MARK,EDDIE", "JOHN", "JOHN,", "JOHN MARK", "JOHN,MARK,EDDIE,JOHN"]

for s in strings:
    m = re.match("^[A-Z]{3,20}(?:,[A-Z]{3,20})*$", s)

    if m:
        parts = s.split(',')
        res = len(parts) == len(set(parts))
        print("{}:{}".format(s, res))
</code></pre>
<p>Result</p>
<pre><code>JOHN,MARK,EDDIE:True
JOHN:True
JOHN,MARK,EDDIE,JOHN:False
</code></pre>
<p>See the <a href="https://regex101.com/r/FwQgDH/1" rel="nofollow noreferrer">regex demo</a> | <a href="https://ideone.com/7GAaLa" rel="nofollow noreferrer">Python demo</a></p>
</div>
<span class="comment-copy">That's not something that can easily done with a regex. Use a regex to parse the valid names and then check for uniqueness separately.</span>
<span class="comment-copy">I agree with @glibdud, you could process the lines using <code>split(',')</code>, then match names and check the unique-ness of each list</span>
<span class="comment-copy">Thank you for your suggestes, I know that at worst, I'll split the string, but I'd like to achieve that with regex, if possible. For numbers I saw this example: <a href="https://stackoverflow.com/questions/45946266/regex-unique-numbers-delimited-by-comma" title="regex unique numbers delimited by comma">stackoverflow.com/questions/45946266/…</a>  So it seems possible</span>
<span class="comment-copy"><a href="https://regex101.com/r/bX1S5k/7" rel="nofollow noreferrer">regex101.com/r/bX1S5k/7</a></span>
<span class="comment-copy">What about <code>JEAN-FRANÇOIS</code>?</span>
<span class="comment-copy">Interesting - I was convinced this would run in O(number of names ^ 2) time, but it seems quite zippy on my machine even for large inputs. Maybe negative lookaheads are faster than I give them credit for...</span>
<span class="comment-copy">@Kevin I suppose negative lookahead is short-circuiting so only worst case performance should be O(N^2). I quickly checked with some data and it seems to be the case. However I also observed some weird behavior, when running the script multiple times, sometimes for larger N the script would get stuck completely (I had to interrupt it); I printed out during the loop so I could observe the matching getting slower and slower and then suddenly for some N it would just get stuck. From the prints I can also see it is the <code>match</code> function. Not sure what is the reason for that. Maybe you have an idea?</span>
<span class="comment-copy">@a_guest your pattern accept "john,mark,". If there is no subsequent name, the comma must not be present</span>
<span class="comment-copy">@RedSparrow As per your question it appeared that you only wanted to know how to check if matched names are unique, not how to deal with trailing commas. Anyway I added a complete example for the corresponding regex.</span>
