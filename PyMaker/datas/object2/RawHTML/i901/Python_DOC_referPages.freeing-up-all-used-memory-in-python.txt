<div class="post-text" itemprop="text">
<p><strong>Setup:</strong></p>
<p>I am running a python code where:</p>
<ol>
<li>I open a file.</li>
<li>For every line in file, I create an object</li>
<li>Do some operations with the object</li>
</ol>
<p>Note that once I am done with the operations part, I no longer need the object. Every new line is independent. </p>
<p><strong>Relevant Code as per request:</strong></p>
<p>I have commented all the parts of my code, leaving below the following code:</p>
<pre><code>import gc
for l in range(num_lines):
    inp = f.readline()[:-1]
    collector = [int(i) for i in inp]
    M = BooleanFunction(collector)
    deg = M.algebraic_degree()
    del M
    gc.collect()
</code></pre>
<p><strong>The problem</strong>:</p>
<p>The object once created, is consuming some amount of memory. After performing the operations, I am not able to free it. So while looping over the file, my memory keeps getting accumulated with new objects, and by around 793 lines into the file, my 16 GB of RAM is completely depleted.</p>
<p><strong>What I have tried:</strong></p>
<p>Using the garbage collector:</p>
<p><code>import gc
 del Object
 gc.collect()
</code></p>
<p>However, the garbage collector will not free up the RAM (or) python is not giving up the memory to the system. Creating child-processes is an idea, but not what I am up for.</p>
<p><strong>Questions:</strong></p>
<ol>
<li>Is there any way I can free up all the memory currently occupied by the program to the OS? That means removing all variables (loop vars, global vars, etc). Something similar to what happens when you press CTRL+C to terminate the program, it returns all the memory to the OS.</li>
<li>A way to specifically de-allocate an object (If I am not doing it right).</li>
</ol>
<p>Previous questions do not answer what if gc.collect() fails to do so and how do I completely give up the memory allocated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Objects in Python can be garbage-colleted once their reference count drops to zero.</p>
<p>Looking at your code, every variable gets re-assigned in every iteration. So their reference count <em>should</em> be zero.</p>
<p>If that doesn't happen then I can see three main possibilities;</p>
<ol>
<li>You are unwittingly keeping a reference to that object.</li>
<li>Garbage collection is disabled (<code>gc.disable()</code>) or frozen (<code>gc.freeze()</code> in Python 3.7).</li>
<li>The objects are made by a Python extension written in C that manages its own memory.</li>
</ol>
<p>Note that (1) or (2) doesn't have to happen in <em>your</em> code. It can also happen in modules that you use.</p>
<p>In your case (2) should not be an issue since you force garbage collection.</p>
<p>For an example of (1), consider what would happen if <code>BooleanFunction</code> was <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer"><em>memoized</em></a>. Then a reference to each object (that you wouldn't see and can't delete) would be kept.</p>
<p>The only way to give <em>all</em> memory back to the OS is to terminate the program.</p>
<p><strong>Edit 1:</strong></p>
<p>Try running your program with the garbage collection debug flags enabled (<code>gc.DEBUG_LEAK</code>). Run <code>gc.get_count()</code> at the end of every loop. And maybe <code>gc.garbage()</code> as well.</p>
<p>For a better understanding of where the memory allocation happens and what exactly happens, you could run your script under the <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">Python debugger</a>. Step through the program line by line while monitoring the resident set size of the Python process with <code>ps</code> in another terminal.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/q/1316767/608639">How can I explicitly free memory in Python?</a>, <a href="https://stackoverflow.com/q/15455048/608639">Releasing memory in Python</a>, etc. Also see <a href="https://stackoverflow.com/q/1421491/608639">Does calling free or delete ever release memory back to the “system”</a> since Python is written in C.</span>
<span class="comment-copy">I have read this post, doesn't answer my question or solve it.</span>
<span class="comment-copy">Can you show your code? The objects’ implementation might have a bug (holding onto non-Python resources), or you might be keeping references to them by accident, or…</span>
<span class="comment-copy">Pseudo code is useless when the details matter. I think you should focus on the problem of the memory leak rather than garbage collection which (as you have found) can’t fix a leak. If there is a cpython extension that should be your first focus.</span>
<span class="comment-copy">Regarding the three possibilities: 1) I am sure I am not, however the underlying class BooleanFunction allocates some space for generating algebraic_degree(), and this uses up memory. Now, in the next iteration l=1, a new memory is allocated and used to calculate the degree again.   When I say M = BooleanFunction() I am actually only assigning the newly declared memory the same label from previous iteration. The old memory cannot be referenced anymore. gc.collect() cannot collect it (I am deleting all items in gc.garbage in every iteration after setting gc.set_debug(gc.DEBUG_SAVEALL)).</span>
<span class="comment-copy">2) cannot happen, but a combination of (1) and (3) is surely happening. gc.get_count() prints (0,0,0) every loop</span>
<span class="comment-copy">@AkhileshSiddhanti Try the python debugger. See updated answer.</span>
