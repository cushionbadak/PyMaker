<div class="post-text" itemprop="text">
<p>I have two (sorted) arrays, A and B, of different lengths each containing unique labels that are repeated a number of times.
The count for each label in A is less than or equal to that in B.
All labels in A will be in B, but some labels in B do not appear in A.</p>
<p>I need an object the same length as B where, for each label <code>i</code> in A (which occurs <code>k_i</code> times), the first <code>k_i</code> occurrences of label <code>i</code> in B need to be set to <code>False</code>.
The remaining elements should be <code>True</code>.</p>
<p>The following code gives me what I need, but if A and B are large, this can take a long time:</p>
<pre><code>import numpy as np

# The labels and their frequency
A = np.array((1,1,2,2,3,4,4,4))
B = np.array((1,1,1,1,1,2,2,3,3,4,4,4,4,4,5,5))

A_uniq, A_count = np.unique(A, return_counts = True)
new_ind = np.ones(B.shape, dtype = bool)
for i in range(len(A_uniq)):
    new_ind[np.where(B == A_uniq[i])[0][:A_count[i]]] = False

print(new_ind)
#[False False  True  True  True False False False  True False False False
#  True  True  True  True]
</code></pre>
<p>Is there a faster or more efficient way to do this? I feel like I may be missing some obvious broadcasting or vectorized solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's one with <code>np.searchsorted</code> -</p>
<pre><code>idx = np.searchsorted(B, A_uniq)
id_ar = np.zeros(len(B),dtype=int)
id_ar[idx] = 1
id_ar[A_count+idx] -= 1
out = id_ar.cumsum()==0
</code></pre>
<p>We can optimize further to compute <code>A_uniq,A_count</code> using its sorted nature instead of using <code>np.unique</code>, like so -</p>
<pre><code>mask_A = np.r_[True,A[:-1]!=A[1:],True]
A_uniq, A_count = A[mask_A[:-1]], np.diff(np.flatnonzero(mask_A))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Example without numpy</p>
<pre><code>A = [1,1,2,2,3,4,4,4]
B = [1,1,1,1,1,2,2,3,3,4,4,4,4,4,5,5]

a_i = b_i = 0
while a_i &lt; len(A):
  if A[a_i] == B[b_i]:
    a_i += 1
    B[b_i] = False
  else:
    B[b_i] = True
  b_i += 1
# fill the rest of B with True
B[b_i:] = [True] * (len(B) - b_i)
# [False, False, True, True, True, False, False, False, True, False, False, False, True, True, True, True]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution is inspired by the one by @Divakar, using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a>:</p>
<pre><code>import numpy as np
from itertools import groupby
A = np.array((1, 1, 2, 2, 3, 4, 4, 4))
B = np.array((1, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 4, 5, 5))

indices = [key + i for key, group in groupby(np.searchsorted(B, A)) for i, _ in enumerate(group)]
result = np.ones_like(B, dtype=np.bool)
result[indices] = False

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[False False  True  True  True False False False  True False False False
  True  True  True  True]
</code></pre>
<p>The idea is to use <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.searchsorted.html" rel="nofollow noreferrer">np.searchsorted</a> to find the insertion position of each element of <code>A</code>, as equal elements will have the same insertion position you have to shift by one each of them, hence the groupby. Then create an array of <code>True</code> and set the values of the <code>indices</code> to <code>False</code>.</p>
<p>If you can use <code>pandas</code>, compute the <code>indices</code> like this:</p>
<pre><code>values = np.searchsorted(B, A)
indices = pd.Series(values).groupby(values).cumcount() + values
</code></pre>
</div>
