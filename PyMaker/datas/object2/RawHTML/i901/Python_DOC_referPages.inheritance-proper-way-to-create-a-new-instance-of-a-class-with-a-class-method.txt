<div class="post-text" itemprop="text">
<p>I'm God (or evolution, or whatever you believe in). I am trying to create all living things with Python.</p>
<p>I have defined a class that is able to "reproduce", i.e is able to create a new instance of itself (ignore the fact that it looks more like cloning than reproduction, this is for a beta version of Earth) :</p>
<pre><code>class Animal:
    def __init__(self, **kwargs):
         self.characteristics = kwargs

    def reproduce(self):
        return Animal(**self.characteristics)
</code></pre>
<p>This works fine in the case of a base class, but what happens when I create a class that inherits from <code>Animal</code> ?</p>
<pre><code>class Fox (Animal):
    def __init__ (self, **kwargs):
        self.color = 'red'
        super().__init__(dict(self.color, **kwargs))
</code></pre>
<p>If a <code>Fox</code> tries to <code>reproduce</code>, I will have an instance of type <code>Animal</code> rather than <code>Fox</code> (even though it still has the color <code>'red'</code>).</p>
<p>I could overload the method for a fox to be able to reproduce:</p>
<pre><code>def reproduce(self):
     return Fox(self.characteristics)
</code></pre>
<p>However, I would have to do that for every new creature I define!</p>
<p>How can I create a class from which I could make all my creatures inherit so when they <code>reproduce</code> an object of the same class is created? So that I could be sure that:</p>
<pre><code>parent = Fox()
child = parent.reproduce()
assert type(parent) == type(child)
</code></pre>
<p>I know I can use <code>type</code> to make <code>reproduce</code> return <code>type(self)(self.characteristics)</code> or <code>self.__class__(**self.characteristics)</code>, but it does not seem very pytonic to me. Is there a more proper way to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Note: you changed your question from one where your subclasses took different numbers of arguments. If you stick to such a design, then you have no choice here but to override <code>reproduce()</code>, because there is no consistent API to create a new instance of the 'current class'.</p>
<p>If you were to standardise your class API, you can then also standardise creating new instances, at which point you can write a <code>reproduce()</code> method that just takes <code>type(self)</code> to reference the current class and then proceed to make a new instance of this class.</p>
<p>Note that having to write a new <code>reproduce()</code> method for each subclass is a good option <em>too</em>, because that's a good way of delegating creating new instances of specialised subclasses. You give each subclass the responsibility of handling the details of reproduction.</p>
<p>But if you don't want to do that, then you take away that responsibility from the subclass and put it in the base class, at which point the base <em>design</em> of how you create instances also is the responsibility of that base class.</p>
<p>There are middle grounds between those two options, of course, but all of them come down to some form of delegation. You could have the base classes provide some kind of structure that details what attributes should be copied across when creating an instance, you could have subclasses implement the <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer"><code>__copy__</code> or <code>__deepcopy__</code> hooks</a> to handle 'reproduction' via <code>copy.copy()</code> or <code>copy.deepcopy()</code> calls, etc.</p>
<p>Your updated question structure is just another example of that delegation; you added a <code>characteristics</code> dictionary, so subclasses are responsible of keeping that dictionary updated so that the base class can implement reproduction as:</p>
<pre><code>def reproduce(self):
    return type(self)(**self.characteristics)
</code></pre>
<p>That's perfectly Pythonic, but more because this is a decent OO design where you have made choices to minimise what subclasses are responsible for and have the base class do as much of the reproducing as possible.</p>
</div>
<span class="comment-copy"><code>type(self)()</code> would be perfectly appropriate, but for that all your constructors would need to be identical, which they're not.</span>
<span class="comment-copy">You're right, I will reformulate my question for the override to be the only solution</span>
<span class="comment-copy">We'll need to work out a middle ground here. Your updated question is still answered by my answer below, but now that answer reads awkward because you suddenly implemented the 'delegate attributes' option I mention. The answer is still the same here, but I rather see your question go back to the starting point it was at.</span>
<span class="comment-copy">(and note the difference between how my <code>reproduce()</code> uses <code>self.characteristics</code> and how you use it; your version causes a type error as <code>__init__</code> doesn't take any positional arguments beyond <code>self</code>).</span>
