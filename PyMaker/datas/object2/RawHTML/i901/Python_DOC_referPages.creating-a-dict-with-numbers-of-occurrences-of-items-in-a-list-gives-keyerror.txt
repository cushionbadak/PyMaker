<div class="post-text" itemprop="text">
<p>I try to put the values in the list to the dictionary, and count how many times they appear in that list, however the second way doesn't work. Does anyone know the reason?</p>
<pre><code>#one way
list1=['1','2','2','3','2','2']
dict1={}
for keys in list1:
  dict1[keys]=0
for keys in list1:
  dict1[keys]=dict1[keys]+1
print('dict1 is',dict1)

#second way
list2=list1
dict2={}
for keys in list2:
  dict2[keys]+=1
print('dict2 is',dict2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Way 2 does not work because the keys do not exists yet. You can not use <code>+=</code> for values on non existent keys - only on keys that contain (f.e.) integers.</p>
<hr/>
<p><strong>Collection of alternate ways:</strong></p>
<p><strong><em><code>O(n**2)</code> - solution:</em></strong></p>
<pre><code>list1=['1','2','2','3','2','2']

# the worst petrformance I can imagine:
worst = {}
for item in list1:
    worst[item] = list1.count(item)

print(worst) # {'1': 1, '3': 1, '2': 4} 
</code></pre>
<p><em>Worst because:</em> <code>list.count()</code> iterates the whole list to count one elements occurences. It touches this list 6 times for every number in it. It counts <code>2</code> four times (just to make sure) and reassignes the counted value to the key of over and over.</p>
<p>It is a O(n**2) approach. You can "optimize" it by only looping over the <code>set(list1)</code> which reduces it to counting only each unique number (3*6 instead of 6*6) - but the problem has several O(n) solution == one pass over the list.</p>
<p>Your solution is O(2*n) - iterating the list twice to create zero-indexes and then count them.</p>
<p><strong><em><code>O(n)</code> - solutions</em></strong> (that differ in performance)<strong><em>:</em></strong></p>
<pre><code># zeroth'st way: check and test and create if needed else add
ddd = {}
for item in list1:   # touches each item exactly once
    if item in ddd:       # but uses additional checks and conditions 
        ddd[item] += 1
    else:
        ddd[item] = 1

print(ddd) 
</code></pre>
<hr/>
<pre><code>#second way   # slowish - but better then two for loops (kinda your one way optimized)
dict2={}
for key in list1:             # touches each element once, no checks but
    dict2.setdefault(key,0)   # setdefault + assignment is slower then defaultdict
    dict2[key]+=1

print('dict2 is',dict2)
</code></pre>
<hr/>
<pre><code># third way     # faster then setdefault due to  optimizations in defaultdict
from collections import defaultdict

d = defaultdict(int)
for key in list1:
    d[key]+=1

print("defaultdict is", d)
</code></pre>
<hr/>
<pre><code># fourth way     # slower because it needs additional list sorting to work
from itertools import groupby

dd = { k:len(list(v)) for k,v in groupby(sorted(list1))} #needs sorted list here

print("groupby is", dd)
</code></pre>
<hr/>
<pre><code># fifth way using Counter
from collections import Counter 

print(     Counter(list1))   
print(dict(Counter(list1)))  
</code></pre>
<p><strong>Output's:</strong></p>
<pre><code>{'1': 1, '3': 1, '2': 4} 
dict2 is {'1': 1, '2': 4, '3': 1}
defaultdict is defaultdict(&lt;class 'int'&gt;, {'1': 1, '2': 4, '3': 1})
groupby is {'1': 1, '2': 4, '3': 1}
Counter({'2': 4, '1': 1, '3': 1})
{'1': 1, '3': 1, '2': 4}    
</code></pre>
<hr/>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a></li>
<li><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">collections.defaultdict</a></li>
<li><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a></li>
<li><a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">sorted()</a></li>
</ul>
<p>with Counter and defaultdict being the fastisht methods - you would have to measure to get a "winner".</p>
</div>
<span class="comment-copy"><code>list2=list1</code> is a common beginner error - its just another name for the same data - see <a href="https://stackoverflow.com/questions/2612802/how-to-clone-or-copy-a-list" title="how to clone or copy a list">stackoverflow.com/questions/2612802/how-to-clone-or-copy-a-list</a>  ... it is a NullOp that does nothing for your code#</span>
<span class="comment-copy">yea you are right. Actually, I just wanna account the list's values in two way. However, there is a mistake in the second way, but I do not know how to fix that, the first way can get the dict such as{'1':1,'2':4,'3':1}, but I think that the code is so complex,</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/36597869/best-way-to-handle-a-keyerror-in-a-dict-in-python">Best way to handle a keyerror in a dict in python</a></span>
<span class="comment-copy">There's actually a class purpose built for this task in the <code>collections</code> module: <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a>.  <code>Counter(list1)</code> is <code>Counter({'2': 4, '1': 1, '3': 1})</code>, and can be treated as a dict.</span>
<span class="comment-copy">It seems most idiomatic (if not most efficient) is <code>collections.Counter(list1)</code>.</span>
<span class="comment-copy">wow, thanks for these comments</span>
<span class="comment-copy">@jpp added, thx - forgot that one</span>
<span class="comment-copy">@MZ edited in some more infos :)</span>
