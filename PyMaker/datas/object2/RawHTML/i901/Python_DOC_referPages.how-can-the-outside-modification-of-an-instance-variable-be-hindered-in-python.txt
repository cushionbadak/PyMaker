<div class="post-text" itemprop="text">
<p>My understanding was that there are not really private methods/attributes in Python, meaning that as long as you know the name of the method or attribute you will always be able to access and/or modify it (I might be understanding wrongly the concept of privacy).</p>
<p>Taking into account the framework described above, I came across with a situation I cannot quite wrap my head around. When creating a <code>matplotlib.pyplot</code> plot:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import matplotlib

fig, ax = plt.subplots()

x = np.arange(100)
ax.plot(x, np.sin(x), label='sinus')
ax.legend()
</code></pre>
<p>I get a <code>matplotlib.legend.Legend</code> object holding a list of all <code>matplotlib.text.Text</code> objects that resemble the text entries displayed in the legend:</p>
<pre><code>&gt;&gt;&gt; fig.axes[0].legend()
&lt;matplotlib.legend.Legend at 0x28f6aa4d898&gt;
&gt;&gt;&gt; fig.axes[0].legend().get_texts()
&lt;a list of 1 Text objects&gt;
&gt;&gt;&gt; fig.axes[0].legend().get_texts()[0]
&lt;matplotlib.text.Text at 0x28f6aa17198&gt;
&gt;&gt;&gt; print(fig.axes[0].legend().get_texts()[0])
Text(0,0,'sinus')
</code></pre>
<p>According to the source code, seems to me that the list returned by the method <code>matplotlib.legend.Legend.get_texts()</code> is filled with the content of the <code>matplotlib.legend.Legend</code> instance variable <code>self.texts</code>, which is itself a list. Accessing and modifying this instance variable does not work:</p>
<pre><code>&gt;&gt;&gt; fig.axes[0].legend().texts
[&lt;matplotlib.text.Text at 0x28f6420db38&gt;]
&gt;&gt;&gt; print(fig.axes[0].legend().texts[0])
Text(0,0,'sinus')
&gt;&gt;&gt; fig.axes[0].legend().texts = [matplotlib.text.Text(0,0,'foo')]
&gt;&gt;&gt; print(fig.axes[0].legend().texts[0])
Text(0,0,'sinus')
</code></pre>
<p>I am not an expert in Python, but I was not expecting this behavior, and I do not understand how this happens at an object/property level, and I haven't followed deeper if there are any special constraints in the construction of the <code>matplotlib.legend.Legend.texts</code> instance variable. </p>
<p>The only general reason for this to happen I could come up with has been that at some level of depth there is some kind of "ghost" setter that just does not modify a class property:</p>
<pre><code>class Foo:

    def __init__(self, value):
        self._x = value

    @property
    def x(self): 
        return self._x

    @x.setter
    def x(self, value):
        # This setter blocks outside access
        pass
</code></pre>
<p>This setter blocks control from the outside to modify the variable value:</p>
<pre><code>&gt;&gt;&gt; f = Foo(3)
&gt;&gt;&gt; f.x
3
f.x = 5
&gt;&gt;&gt; f.x
3
</code></pre>
<p>Nevertheless, the <code>matplotlib.legend.Legend</code> instance variable <code>self.texts</code> seems defined like a regular instance variable and I have not been able to find it defined as a property or any getters or setters related to it.</p>
<p>So, given this situation, I have three questions:</p>
<p>1) Is this little class example an accepted/legit way of getting "some sort" of privacy, in the sense that the attribute cannot be modified?</p>
<p>2) Are there some other/equivalent ways of blocking access/control over attributes or methods in Python?</p>
<p>3) How does it work or is it arranged in the particular case of <code>matplotlib.legend.Legend</code> objects (focus on the <code>self.texts</code> instance variable)?</p>
<p>Considerations:</p>
<p>1) I have tried to find answers to these questions and have not succeeded. Particularly the question to how is this behavior implemented in <code>matplotlib.legend.Legend</code> objects remains yet unanswered to me.</p>
<p>2) I have taken a look at the <code>matplotlib.legend.Legend</code> source code and I can see that the function <code>matplotlib.legend.Legend.get_texts()</code> returns a <code>silent_list</code> object, which apparently is just a list object with an overridden <code>__repr__</code> method. Still does not help me get the understanding that I am missing.</p>
<p>3) I am aware of the bunch of higher-level methods in <code>matplotlib.legend.Legend</code> objects that allow me to modify the legend in many/all possible ways. I though just want to understand how the mechanism works under the hood.</p>
<p>Thanks very much in advance for your time and help.</p>
</div>
<div class="post-text" itemprop="text">
<p>This has nothing to do with the attribute machinery. You're just getting different objects from the <code>legend()</code> call each time. These objects have different attributes, so screwing with one <code>legend()</code> return value doesn't automatically affect another.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptors</a></span>
<span class="comment-copy">I suspect that simply <code>.legend()</code> returns a distinct object each time. You could probably test that out easily.</span>
<span class="comment-copy">Indeed, <code>.legend()</code> creates a new instance. This is by design; you may want to update your plot, and just call <code>.legend()</code> again, which will produce a new updated legend for you. To obtain an <i>existing</i> legend, best use a handle in the first place, <code>leg = ax.legend()</code> and use it later on, or, if that is not possible, use <code>ax.get_legend()</code> to obtain the existing legend.</span>
