<div class="post-text" itemprop="text">
<p>So I'm trying to write a function which takes multiple arguments, say <code>a,b,c</code>, some of which may be a list of length X and some of which may be single values, but this is unknown in advance. </p>
<p>The function should then create parameter sets <code>(a[i],b[i],c[i])</code> which will be passed to a multiprocessing pool. If a single value for a variable is given, it will just be repeated for each parameter set. </p>
<p>Now, if I want to loop over each variable, I can write an if statement for each:</p>
<pre><code>def foo(a, b, c):
    if type(a) == int:
        # make list of length needed
    # Repeat for each variable
</code></pre>
<p>but in practice this gets messy and long very quickly. I would like to know if there is an easier way to loop over the input variables.</p>
<p>I'm hoping there is something like</p>
<pre><code>def foo(a, b, c):
    for variable in foo.__variables__:
        if type(variable) == int:
            # Make list of length needed
</code></pre>
<p><strong>Edit: additional info</strong></p>
<p>So as pointed out by Lauro Bravar, the above could be solved by passing the arguments as a list. Unfortunately the full problem I am trying to solve includes the presence of multiple optional variables so this does not work. So I am looking more for code which will solve in this context:</p>
<pre><code>def foo(a, b, c, d=None, e=None):
    for variable in foo.__variables__:
        if variable is not None:
           if type(variable) == int:
                # Make list of length needed
</code></pre>
<p>Is there a way to do this without using <code>**kwarg</code>? Ideally I would like all the arguments visible in the definition as readability is important (this will be used by students with little coding experience)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can pass your variables via <code>*args</code></p>
<pre><code>def foo(*args):
    for item in args:
        print(type(item))

foo([3,4,5],4,"foo")
</code></pre>
<p>Out:</p>
<pre><code>&lt;type 'list'&gt;
&lt;type 'int'&gt;
&lt;type 'str'&gt;
</code></pre>
<h2>1st Edit to my answer:</h2>
<p>regarding your additional information in the question: <code>*args</code> takes up as many arguments as you wish. When iterating over all elements of <code>*args</code> and checking their type, you can store the result in a <code>dictionary</code> or <code>list</code> to make it accessible:</p>
<pre><code>def foo(*args):
    mylist = list()
    for item in args:
        if type(item) == int:
            mylist.append([item])
        elif type(item) == list:
            mylist.append(item)
    return mylist

result = foo([3,4,5],4,"foo")
</code></pre>
<p>Out:</p>
<pre><code>[[3, 4, 5], [4]]
</code></pre>
<h2>2nd Edit to my answer:</h2>
<p>In the comment section you added two conditions: </p>
<ol>
<li>the <code>help()</code> function needs to return the arguments of <code>foo</code></li>
<li>You cannot use <code>*args</code> because you want to create parameter sets of specified parameters (not the open passing scheme <code>*args</code> supports) </li>
</ol>
<p>So my new approach deals with the built-in function <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">locals()</a>, which returns the "current local symbol table". When <code>locals()</code> is called within a function, it will return all arguments of the function and their values as a dictionary. Make sure to call it at the very beginning, because at runtime new locals may be created in the function and you could end up in a loop. </p>
<p>How about this?</p>
<pre><code>def foo(a, b, c, d=None, e=None):
    foo_arguments = locals()
    for variable in foo_arguments:
        if foo_arguments[variable] is not None:
            if type(foo_arguments[variable]) == int:
                print("Detected argument named {} which is an integer of value {:d}"
                      .format(variable, foo_arguments[variable]))

result = foo([3,4,5], 4, "foo", d=10)
</code></pre>
<p>This allows you to pass your arguments for <code>a</code>, <code>b</code>, <code>c</code> and optionally <code>d</code>, <code>e</code>. Together with</p>
<pre><code>print(help(foo))
</code></pre>
<p>it returns</p>
<pre><code>Detected argument named b which is an integer of value 4
Detected argument named d which is an integer of value 10
Help on function foo in module __main__:
foo(a, b, c, d=None, e=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Easiest way I can imagine is doing something like this:</p>
<pre><code>def foo(*args):
    for variable in args:
        if type(variable) == int:
            # Make list of length needed
</code></pre>
<p>You do not <em>have</em> to define each variable in your function, it's just easier for usage in the function. Because of the setup of above, you'll have to retrieve the desired argument from the arg list. Such as:</p>
<pre><code>a = args[0]
b = args[1]
c = args[2]
</code></pre>
<p>Which I can imagine is also harder in readability, but it depends on your use case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could pass the arguments as a list and iterate over that list.</p>
<pre><code>def foo(bar):
    for item in bar:
         print(type(item))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pass your variables and optional variables via *args and **kwargs:</p>
<pre><code>def foo(*args, **kwargs):
    for x in (args + tuple(kwargs.values())):
        print(type(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This could take any number of arguments including positional as well.</p>
<pre><code>def print_keyword_args(*args, **kwargs):
    print(kwargs)
    print(args)

print_keyword_args(7, 8, [1,2,3], a = 5, b = 4)
</code></pre>
<p>Output:</p>
<pre><code>{'a': 5, 'b': 4}
(7, 8, [1, 2, 3])
</code></pre>
<p>Note: Optional arguments are caught in <code>kwargs</code>.</p>
</div>
<span class="comment-copy">Thanks for the answer. I've elaborated a bit on the full problem in context in the question, as there are optional arguments involved and I would like to avoid using <code>**kwarg</code> as ideally I want every variable easily visible</span>
<span class="comment-copy">Please find my update to the answer. Still sure <code>*args</code> is not what you seek? With <code>**kwarg</code> you can pass the name of the variable together with the value. It is a one-liner to restore this to actual variables if needed. Also default values are no problem</span>
<span class="comment-copy">Ideally not, as there are a set list of parameters which I need to appear when <code>help()</code> is called, and unnamed variables will not show up. If there is no way of getting both effects then I will just have to loop over them all explicitly.</span>
<span class="comment-copy">Please find another update ;)</span>
<span class="comment-copy">I have considered this. The problem with that is that in the full problem, I have some optional arguments and if specified then these should be treated in exactly the same way. I will update the question with this info.</span>
