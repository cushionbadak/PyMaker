<div class="post-text" itemprop="text">
<p>The idea is to create all possible combinations of [a,b,c,d][e,f,g,h] where a,b,c,d,e,f,g,h are distinct integers ranging from 1 to n. Order doesn't matter so if I have [a,b,c,d] I don't want [c,b,d,a]. Same applies for [e,f,g,h].</p>
<p>I have the code below which works but has the drawback of being a) extremely slow and b) take an insane amount of memory (I'm currently trying n=30 and using 13+ GB of memory.)</p>
<pre><code>def build(n):
    a = []
    b = []
    for i in range(1,n):
       for j in [x for x in range(1,n) if x!= i]:
            for k in [y for y in range(1,n) if (y!= i and y !=j)]:
                for l in [z for z in range(1,n) if (z!= i and z!=j and z !=k)]:
                    if sorted([i,j,k,l]) not in a:
                        a.append(sorted([i,j,k,l]))



    b = a

    c = [i for i in product(a,b) if list(set(i[0]).intersection(i[1])) == []]
    print 'INFO: done building (total: %d sets)'%len(c)
    return c
</code></pre>
<p>Is there a more efficient way of achieving what I want?</p>
</div>
<div class="post-text" itemprop="text">
<p>Going off the top of my head, so there might be some bad syntax in here. Should be enough to give you an idea how you could properly approach the problem on your own, though:</p>
<pre><code>import itertools

def quads(n, required_results=None):
    arr1, arr2 = range(1,n+1), range(1,n+1)
    results = set() # only admits unique combinations
    for combination in itertools.product(arr1, arr2):
        results.add(combination)
        if required_results and required_results = len(results): 
            # if the second argument is passed, no need to go through the whole combination-space
            break
    return results
</code></pre>
</div>
<span class="comment-copy">Take a look at <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.combinations</a></span>
