<div class="post-text" itemprop="text">
<p>In the Python <a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow noreferrer">documentation</a> about threads and the GIL, it says:</p>
<blockquote>
<p>In order to emulate concurrency of execution, the interpreter regularly tries to switch threads (see <code>sys.setswitchinterval()</code>)</p>
</blockquote>
<p>Why would it do this? These context switches appear to do nothing other than waste time. Wouldn't it be quicker to run each process until it releases the GIL, and then run the next?</p>
</div>
<div class="post-text" itemprop="text">
<p>A thread doesn't neccessarly have any I/O. You could have one thread doing number crunching, another handling I/O. The number-crunching thread with your proposal would never drop the GIL so the other thread could handle the I/O. </p>
<p>To ensure every thread gets to run, a thread will by default drop the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">GIL</a> after 5 ms (Python 3) if it hasn't done so before because of waiting for I/O.</p>
<p>You can change this interval with <code>sys.setswitchinterval()</code>.</p>
<p>Threading is a simple concurrency technique. For a more efficient concurrency technique look into <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> which offers single-threaded concurrency using coroutines.</p>
</div>
<span class="comment-copy">It makes a difference if some of your "threads" (green threads) are stuck doing IO operations.</span>
<span class="comment-copy">You are misunderstanding the docs. <code>sys.setswitchinterval</code> is setting the interval a thread maximally would hold the GIL. @devoured elysium Python-threads are real OS-threads, not green-threads.</span>
<span class="comment-copy">@Darkonaut but why have a maximum time that a thread can hold the GIL if it is automatically released in the event of blocking I/O? Why would you want more context switching? Why bother 'emulating concurrency' if it slower?</span>
<span class="comment-copy">Because then you would have only context switches on I/O.  A thread doesn't necessarily have any I/O. If you want to trade simplicity for more efficiency you'll have to look into <code>asyncio</code> for single-threaded concurrency.</span>
<span class="comment-copy">You could have one thread doing number crunching, another handling I/O. The number-chrunching thread with your proposal would never drop the GIL so the other thread could handle the I/O.</span>
