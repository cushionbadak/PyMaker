<div class="post-text" itemprop="text">
<p>I have an ecel sheet like this:</p>
<pre><code>A    B    C    D
          9    someString
          9    someString
1    5         someString
2    6         someString
100  7         someString
101  8         someString
</code></pre>
<p>Now i am trying to split it into two dataframes:</p>
<pre><code>df = df[df['C'].isnull()]
for i in range(0, len(df)-1):
    if (df.loc[i+1,'A'] - df.loc[i,'A']) &gt;= 10:
        df1 = df.iloc[:i+1, :]
        df2 = df.iloc[i+1:, :]
    else:
        pass
print(df1)
print(df2)
</code></pre>
<p>What I am trying to achieve:</p>
<p>df1:</p>
<pre><code>A    B    C    D
1    5   NaN   someString
2    6   NaN   someString
</code></pre>
<p>df2:</p>
<pre><code>A    B    C    D
100  7   NaN   someString
101  8   NaN   someString
</code></pre>
<p>This cause the problem: <code>KeyError: 'the label [1] is not in the [index]'</code></p>
<p>I guess it is because of the <code>isnull()</code> function, but i do not know what to do against this. Could need some help here.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Avoid a variable number of variables</h3>
<p>Use a dictionary instead. For example, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a> to generate keys for successive dataframes, and <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.diff.html" rel="nofollow noreferrer"><code>pd.Series.diff</code></a> to determine indices where to make splits. The splitting itself can be processed using <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.split.html" rel="nofollow noreferrer"><code>np.split</code></a>.</p>
<pre><code>from itertools import count

c = count()
dfs = {}

c_valid = df['C'].notnull()
dfs[next(c)] = df[c_valid]

split_indices = np.where(df.loc[~c_valid, 'A'].diff() &gt; 10)[0]
for df_split in np.split(df[~c_valid], split_indices):
    dfs[next(c)] = df_split
</code></pre>
<p>Result:</p>
<pre><code>print(*dfs.items(), sep='\n'*2)

(0,     A   B    C
0 NaN NaN  9.0
1 NaN NaN  9.0)

(1,      A    B   C
2  1.0  5.0 NaN
3  2.0  6.0 NaN)

(2,        A    B   C
4  100.0  7.0 NaN
5  101.0  8.0 NaN)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The indices get preserved when you divide two dataframes, if you print the second one you would see that there is no "1" in the index:</p>
<pre><code>df2
&gt;&gt;     A    B   C
4  100  7.0 NaN
5  101  8.0 NaN
</code></pre>
<p>You can use <code>iloc</code> to access the first row:</p>
<pre><code>df2.iloc[0]
&gt;&gt;A    101.0
B      8.0
C      NaN
Name: 5, dtype: float64
</code></pre>
<p>Also, a piece of advice: avoid using <code>for</code> in pandas. For your case, use <code>.diff</code> if you want to split the database when 'A' jumps:</p>
<pre><code>ix=df[df.diff()['A']&gt;10].index[-1]
ix
&gt;&gt; 4
df1, df2 = df.loc[:ix-1], df.loc[ix:]
</code></pre>
</div>
<span class="comment-copy">what do you mean by two dataframe ?</span>
<span class="comment-copy">splitting the pandas dataframe <code>df</code> and store the values in two new pandas dataframes <code>df1</code> and <code>df2</code></span>
<span class="comment-copy">Can you explain what your expected output is? Maybe show us what <code>df1</code> and <code>df2</code> should look like in this example.</span>
<span class="comment-copy">Edited my post.</span>
<span class="comment-copy">It works, also with the edited string column in my question. But unfortunately i don't understand every line in Ã½our code. I see what you did with <code>split_indices = np.where....</code> and <code>np.split</code> but i don't see what this <code>c_valid</code> is all about. Maybe if you have some time you could explain it to me a little bit more detailed. I would realy appreciate it.</span>
<span class="comment-copy"><code>c_valid</code> is to separate out the rows where <code>c</code> is null / not null. <code>df['C'].notnull()</code> is a Boolean series which we can use for indexing, we take its negative later using the negation <code>~</code> operator.</span>
<span class="comment-copy">Ok in my real code <code>c_valid = df['C'].notnull()</code> gives me an empty dataframe. At first I have to sort the dataframe after A <code>df=df.sort_values('A')</code> and because of this I have to get rid of column C <code>df = df[df['C'].isnull()]</code>. But after this your code still works fine, so thanks !</span>
<span class="comment-copy">Thanks! But I get the error <code>TypeError: unsupported operand type(s) for -: 'str' and 'str'</code>. I guess it is because in my real sheet i have an additional column with strings. i did not know that this would be important for this issue. I'll update my question. Is there an easy fix?</span>
