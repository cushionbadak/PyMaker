<div class="post-text" itemprop="text">
<p>I am doing some large number maths in both Java and Python. The sums are the same however the results are different.</p>
<pre><code>python_n1 = int(math.floor(math.pow(int((int(361) * (int(4900 + 4489))) * int(4356)), int(6))))
BigInteger Java_n1 = (x[20].multiply(x[7].add(x[15])).multiply(x[10])).pow(6);

python_simple_sum = 14764352724**6 #or math.pow(14764352724, 6)
BigInteger Java_simple_sum = new BigInteger("14764352724 ").pow(6)
</code></pre>
<p>Python Answers = <code>10358251994780842724998096890217137953445700726699419360034816</code>
Java Answers = <code>10358251994780842575401275783021915748383652186833068257611776</code></p>
<p>Java is getting the correct result but python is not. I am not using Floating point numbers as far as I know. Whats the issue here.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do</p>
<pre><code>int(math.pow(14764352724, 6))
</code></pre>
<p>you get a big number elevated to a power but using a floating point method, even if arguments are integers. Converting to integer loses precision (the original result is a float: <code>1.0358251994780843e+61</code>)</p>
<p>When you do</p>
<pre><code>14764352724**6
</code></pre>
<p>you get a big number elevated to a power using a <em>binary power</em> method using only integer multiplication.</p>
<p>So the second result is accurate, whereas the first isn't</p>
<pre><code>&gt;&gt;&gt; int(math.pow(14764352724,6))
10358251994780842724998096890217137953445700726699419360034816   # wrong
&gt;&gt;&gt; 14764352724**6
10358251994780842575401275783021915748383652186833068257611776   # correct
</code></pre>
<p>Let's try a disassembly of both <code>**</code> and <code>math.pow</code> functions:</p>
<pre><code>import dis,math

def test(n):
    return n ** 3

def test2(n):
    return math.pow(n,3)

dis.dis(test)
dis.dis(test2)
</code></pre>
<p>output</p>
<pre><code>  4           0 LOAD_FAST                0 (n)
              3 LOAD_CONST               1 (3)
              6 BINARY_POWER
              7 RETURN_VALUE

  7           0 LOAD_GLOBAL              0 (math)
              3 LOAD_ATTR                1 (pow)
              6 LOAD_FAST                0 (n)
              9 LOAD_CONST               1 (3)
             12 CALL_FUNCTION            2 (2 positional, 0 keyword pair)
             15 RETURN_VALUE
</code></pre>
<p>as you see, the functions aren't equivalent. <a href="https://docs.python.org/3/library/dis.html#opcode-BINARY_POWER" rel="nofollow noreferrer"><code>BINARY_POWER</code></a> is called in the first case. This function has a chance to perform integer multiply accurately <em>when parameters are integer</em>:</p>
<blockquote>
<p>BINARY_POWER()</p>
<p>Implements TOS = TOS1 ** TOS</p>
</blockquote>
<p>Binary power yields the same value as <code>math.pow</code> when parameters aren't all integer:</p>
<pre><code>&gt;&gt;&gt; 14764352724**6.0
1.0358251994780843e+61
&gt;&gt;&gt; int(14764352724**6.0)
10358251994780842724998096890217137953445700726699419360034816
</code></pre>
<p>Note: what probably adds to the confusion is the built-in <a href="https://docs.python.org/3/library/functions.html#pow" rel="nofollow noreferrer"><code>pow</code></a> method, which is different from <a href="https://docs.python.org/3/library/math.html#math.pow" rel="nofollow noreferrer"><code>math.pow</code></a> (and overridden by the latter when using <code>from math import pow</code>), but is equivalent to <code>**</code> operator when used without modulo argument:</p>
<blockquote>
<p>pow(x, y[, z])</p>
<p>Return x to the power y; if z is present, return x to the power y, modulo z (computed more efficiently than pow(x, y) % z). The two-argument form pow(x, y) <strong>is equivalent to using the power operator</strong>: x**y.</p>
</blockquote>
</div>
<span class="comment-copy">python 3.4 answers <code>10358251994780842575401275783021915748383652186833068257611776</code> when using <code>14764352724**6</code>. Never use <code>pow</code> for integer power, in <i>any</i> language</span>
<span class="comment-copy">Same answer in Python2.7 when executed <code>14764352724**6</code>. Also <code>math.pow(14764352724, 6)!=14764352724**6</code></span>
<span class="comment-copy">good question but <code>14764352724**6 #or math.pow(14764352724, 6)</code> doesn't cut it. You get the correct result with the first one. Are you sure? (see my answer)</span>
<span class="comment-copy">While I was going through the documentation of <code>math.pow</code> I found there is a built in as well called <code>pow</code> which gives the correct result. For <code>math.pow</code> it is better to follow @Jean-Fran√ßoisFabre's answer below</span>
<span class="comment-copy"><code>pow</code>, good call.</span>
<span class="comment-copy">I found the same results. But I feel there should be a way to get around this. when using <code>pow</code></span>
<span class="comment-copy">not possible, as <code>pow</code> uses floating point exponentiation.</span>
<span class="comment-copy">isn't that a deliberate choice in the design of Python's libraries?  e.g. compare <code>14764352724**6</code> and <code>14764352724**6.0</code></span>
<span class="comment-copy">@mad why would you think that? math.pow uses floating point math internally (and is documented to do so) which means its result is limited to floating point accuracies and limits. There's simply no way around that.</span>
