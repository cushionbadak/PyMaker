<div class="post-text" itemprop="text">
<h2>Background</h2>
<p>I once worked on a Python2 system that had a lot of custom I/O code written synchronously, and was scaled using threads. At some point, we couldn't scale it any further, and realised we have to switch to asynchronous programming.</p>
<ul>
<li><a href="https://twistedmatrix.com/trac/" rel="nofollow noreferrer">Twisted</a> was the popular choice, but we wanted to avoid its callback hell.</li>
<li>It did have the <a href="https://twistedmatrix.com/documents/13.2.0/api/twisted.internet.defer.inlineCallbacks.html" rel="nofollow noreferrer"><code>@inlineCallbacks</code></a> decorator, which effectively implemented coroutines using generator magic, as did some other libraries. That was more tolerable, but felt a bit flaky.</li>
<li>And then we found <a href="http://www.gevent.org/" rel="nofollow noreferrer">gevent</a>. All you had to do was:</li>
</ul>
<pre><code>from gevent import monkey
monkey.patch_all()
</code></pre>
<p>And just like that, all your standard I/O - sockets, database transactions, everything written in pure Python, really - was asynchronous, yielding and switching behind the scenes using greenlets.</p>
<p>It wasn't perfect:</p>
<ul>
<li>Back then, it didn't work well on Windows (and it still has some limitations today). Luckily, we were running on Linux.</li>
<li>It couldn't monkey-patch C extensions, so we couldn't use MySQLdb, for example. Luckily, there were many pure Python alternatives, like PyMySQL.</li>
</ul>
<h2>Question</h2>
<p>Nowadays, Python 3 is much more popular, and with it - <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a>. Personally, I think it's great, but I was recently asked how is it better than what we did with gevent, and couldn't come up with a good enough answer.</p>
<p>This might sound subjective, but I'm actually looking for <strong>real use-cases</strong> where one would significantly outperform the other, or allow something that the other does not. Here are the considerations I've gathered so far:</p>
<ol>
<li><p>Like I said, gevent is rather limited on Windows. Then again, most production code I know of runs on Linux.</p>
<p><strong>If you need to run on Windows, use asyncio</strong>.</p></li>
<li><p>Gevent can't monkey-patch C extensions. But, asyncio can't monkey-patch <em>anything</em>.</p>
<p>Imagine that a new DB technology comes up, and you'd like to use it, but there's isn't a pure Python library for it, so you can't integrate it with Gevent. The thing is, you're just as stuck when there isn't an io* library that you can integrate with asyncio! There are worker threads and executors, of course, but that's not the point, and works just as well in both cases anyway.</p></li>
<li><p>Some people say it's a matter of personal taste, but I think it's fair to say that synchronous programming is inherently easier that asynchronous programming (think about it: have you ever met a novice programmer that can work with sockets, but has a hard time understanding how to properly select/poll them, or thinking in futures/promises? And have you ever met the reverse?).</p>
<p>Anyway, let's not go there. I wanted to address this point because it comes up frequently (<a href="https://www.reddit.com/r/Python/comments/7a3ikv/should_i_stick_with_asyncio_or_return_to_gevent/" rel="nofollow noreferrer">here's</a> a discussion on reddit), but what I'm really after is scenarios where you have a <em>practical</em> reason to use one or the other.</p></li>
<li><p>Asyncio is part of the standard library. That's huge: it means it's well maintained, well documented, and everybody knows about it and uses it by default.</p>
<p>But, considering how little of Gevent you need to know to use it (and that it's pretty well maintained and documented as well), it doesn't seem as crucial. So while there are multiple answers on StackOverflow for even the most complicated scenarios involving futures, the possibility to not use futures at all seems just as viable.</p></li>
</ol>
<p>So: what are some concrete use-cases where asyncio prevails? Surely Guido and the Python community had a good reason to put so much effort into it, and even introduce new keywords into the languages - I just can't seem to find them.</p>
</div>
<div class="post-text" itemprop="text">
<p>"Simple" answer from real-world usage:</p>
<ol>
<li>Good thing about gevent — you can <em>patch</em> things, which means that you [theoretically] can use synchronous libraries. I.e. you can patch django.</li>
<li>Bad thing about gevent — not everything can be patched, if you <em>must</em> use some DB driver that can't be patched, you're doomed</li>
<li>Worst thing about gevent — it's "magical". Amount of effort required to understand what happens with "patch_all" is enormous, the same effort applies to finding/hiring new people for your dev team. What is even worse — debugging gevent-based code is hell. I'd say, pretty much the same hell, as callbacks, if not worse.</li>
</ol>
<p>Later point is key, I think. Most underestimated thing in software engineering is that code is meant to be <em>read</em>, not written or run effectively (if later is the case, you'd rather switch from python to system-level language). Asyncio came with missing part for async programming — <em>pre-defined and controlled</em> context switch points. You actually writing sync code (i.e. you're not thinking about sudden thread switch, locks, queues, etc.), and using <code>await ...</code> when you <em>know</em> call is IO blocking, so you let event loop pick on something else, that is ready for CPU, and pick up current state later.</p>
<p>This is what makes asyncio so good — it's easy to maintain. The downside is that pretty much all "world" must be async too — DB drivers, http tools, file handlers. And sometimes you'll be missing libraries, that's pretty much guaranteed.</p>
</div>
<span class="comment-copy">I'm not convinced this is objective but I'm not going vote to close as "primarily opinion". I would suggest that you could cut a <i>lot</i> of the chatty aspects to make this much more objective, though.</span>
<span class="comment-copy">For example: "Sure, it's nice to have multiple answers on StackOverflow for even the most complicated scenarios involving futures - but it's nicer still to not have to use futures at all." how is that <i>not</i> subjective?</span>
<span class="comment-copy">Thanks for understanding! The reason I feel safe to say that "asynchronous programming is harder than synchronous programming" or that "futures are an advanced feature and it's nice to not have to use it" was actually encouraged by a question about concrete uses for metaclasses (<a href="https://stackoverflow.com/questions/392160/what-are-some-concrete-use-cases-for-metaclasses/31061875#31061875" title="what are some concrete use cases for metaclasses">stackoverflow.com/questions/392160/…</a>). Not unlike asyncio, it's a standard and useful feature in Python - but it's relatively fair to say that it's more advanced than the alternatives discussed.</span>
<span class="comment-copy">Eep, ok. You've clearly given a very detailed answer there but also the standards of SO have changed <i>a lot</i> since that question was asked. Still only my opinion, but I worry you'll face close votes on this unless you cut it back; of course, it's for others to decide and you whether you want to change the text. In any case, I'm not in a position to give you a suitable answer, though.</span>
<span class="comment-copy">I appreciate your candour. I'll try to cut it back as much as I can.</span>
<span class="comment-copy">I'm not sure I understand the comparison. You don't have to understand what <code>patch_all</code> does any more than you have to understand how <code>asyncio</code> is implemented; you just write straightforward, readable and maintainable synchronous code (and debug it as such), then magically make it asynchronous. What am I missing?</span>
<span class="comment-copy">You can't debug patched code patched code in same way as sync code, that's the point. Running gevent-patched code with single-user load and, lets say, 100k is different — in terms of when and how context will be switched. Implementation of asyncio (which is hard, for sure) is different from understanding concept of event loop. Later is simple enough.</span>
<span class="comment-copy">@DanGittik "you just write ... synchronous code ..., then magically make it asynchronous" - if you try to do it, you won't get any benefit from making code asynchronous. You'll have to run some tasks (coroutines) concurrently to get benefit (<a href="http://www.gevent.org/intro.html#example" rel="nofollow noreferrer">example how gevent does it</a>). And where appeared concurrency will sooner or later appear synchronization between coroutines, problems like deadlocks and many other async specific things. These are usually non-trivial things and <code>asyncio</code> allows you to read and debug them better than "magical" approach.</span>
