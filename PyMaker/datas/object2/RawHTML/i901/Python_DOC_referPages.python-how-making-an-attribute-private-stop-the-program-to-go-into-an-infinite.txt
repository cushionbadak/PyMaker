<div class="post-text" itemprop="text">
<p>I am a naive to Object oriented concept in python. While reading the OOP concept from <a href="https://www.python-course.eu/python3_properties.php" rel="nofollow noreferrer">here</a> I encounter an example.</p>
<pre><code>class P1:

    def __init__(self,x):
        self.x = x

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        if x &lt; 0:
            self.__x = 0
        elif x &gt; 1000:
            self.__x = 1000
        else:
            self.__x = x

e = P(x = 2100)
f = e.x*2

print(f)
2000
</code></pre>
<p>If I don't make my variable private (in case of class P2) then I guess it will run into an infinite loop.</p>
<pre><code>class P2:

    def __init__(self,x):
        self.x = x

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        if x &lt; 0:
            self.x = 0
        elif x &gt; 1000:
            self.x = 1000
        else:
            self.x = x

e = P(x = 2100) #Infinite loop 
</code></pre>
<p>In order to inspect what actually class P2 is doing I restructured my code to </p>
<pre><code>class P2:
    def __init__(self,x):
        print('init area1')
        self.x = x

    @property
    def x(self):
        print('property area2')
        return self.x

    @x.setter
    def x(self, x):
        print('setter area3')
        if x &lt; 0:
            print('setter area4')
            self.x = 0
        elif x &gt; 1000:
            print('setter area5')
            self.x = 1000
        else:
            print('setter area6')
            self.x = x
</code></pre>
<p>When I tried to run P2(x = 2100) it gives me an unstoppable output like:</p>
<pre><code>init area1
setter area3
setter area5
setter area3
setter area6
setter area3
setter area6
setter area3
setter area6.......
</code></pre>
<p>It appears that my program first called init method and after that it is continuously running back and forth from <strong>setter area 3</strong> to <strong>setter area 6</strong>.
Can anyone explain</p>
<ol>
<li><p>what is happening behind the scene ? How the program is running ?</p></li>
<li><p>Why magic private attribute are making here so that the program is not running into an infinite loop</p></li>
<li><p>How @property and @x.setter are related to each other here ? Can't I write @setter without writing @property</p></li>
</ol>
<p>I know these are basic questions but I went through so much of online stuff and I didn't find a better answer to these question. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>"Why magic private attribute are making here so that the program is
  not running into an infinite loop"</p>
</blockquote>
<p>It is actually not a good place to use double-underscore name-mangling. I like that tutorial, except for that one detail. You can use a single underscore, or any valid python identifier <em>except</em> the one occupied by the property, and you will see the same effect. </p>
<p>A <code>property</code> is an object that implements <a href="https://docs.python.org/3.7/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">the descriptor protocol</a>.  It is a handy descriptor, for a common descriptor use-case. But we can make our own descriptor types.</p>
<p>Fundamentally, a descriptor is any python type that implements any combination of <code>__get__</code>, <code>__set__</code> or <code>__delete__</code>.</p>
<p>These will get invoked when you do <code>some_object.some_attribute</code>, <code>some_object.some_attribute = value</code>, and <code>del some_object.some_attribute</code> where <code>some_attribute</code> is a descriptor on <code>some_object.__class__</code>. </p>
<p>So, consider a concrete example:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def __get__(self, obj, objtype):
...         print('inside Foo.__get__')
...         return 42
...
&gt;&gt;&gt; class Bar:
...     foo = Foo()
...
&gt;&gt;&gt; bar = Bar()
&gt;&gt;&gt; bar.foo
inside Foo.__get__
42
</code></pre>
<p>Descriptors <em>intercept</em> attribute access and modification, and deletion <em>on the instance of the class that has the descriptor as an attribute</em> to allow for all sorts of fun stuff.</p>
<p>Notice, The descriptor belongs to the class:</p>
<pre><code>&gt;&gt;&gt; vars(bar)
{}
&gt;&gt;&gt; vars(Bar)
mappingproxy({'__module__': '__main__', 'foo': &lt;__main__.Foo object at 0x1025272e8&gt;, '__dict__': &lt;attribute '__dict__' of 'Bar' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Bar' objects&gt;, '__doc__': None})
</code></pre>
<p>If I set an instance attribute as the same name as the class attribute holding the property, the normal python behavior of shadowing occurs:</p>
<pre><code>&gt;&gt;&gt; bar.foo = 99
&gt;&gt;&gt; bar.foo
99
&gt;&gt;&gt; vars(bar)
{'foo': 99}
</code></pre>
<p>But we can control this, we can implement <code>__set__</code>:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...    def __get__(self, obj, objtype):
...       return 42
...    def __set__(self, obj, val):
...       print('nah-ah-ah')
...
...
&gt;&gt;&gt; class Bar:
...     foo = Foo()
...
&gt;&gt;&gt; bar = Bar()
&gt;&gt;&gt; bar.foo
42
&gt;&gt;&gt; bar.foo = 99
nah-ah-ah
&gt;&gt;&gt; bar.foo
42
</code></pre>
<p>The <code>property</code> object just lets you provide functions that will get delegated to when you use <code>property.__get__</code>, <code>property.__set__</code>, and <code>property.__delete__</code>. The docstrings is quite informative, just use <code>help(property)</code> in a python shell:</p>
<pre><code>class property(object)
 |  property(fget=None, fset=None, fdel=None, doc=None)
 |
 |  Property attribute.
 |
 |    fget
 |      function to be used for getting an attribute value
 |    fset
 |      function to be used for setting an attribute value
 |    fdel
 |      function to be used for del'ing an attribute
 |    doc
 |      docstring
 |
 |  Typical use is to define a managed attribute x:
 |
 |  class C(object):
 |      def getx(self): return self._x
 |      def setx(self, value): self._x = value
 |      def delx(self): del self._x
 |      x = property(getx, setx, delx, "I'm the 'x' property.")
 |
 |  Decorators make defining new properties or modifying existing ones easy:
 |
 |  class C(object):
 |      @property
 |      def x(self):
 |          "I am the 'x' property."
 |          return self._x
 |      @x.setter
 |      def x(self, value):
 |          self._x = value
 |      @x.deleter
 |      def x(self):
 |          del self._x
</code></pre>
<p>So whatever you decorate with <code>@property.setter</code>, you can imagine that get's passed to <code>property(fset=&lt;whatever&gt;)</code>. So now, whenever your instance tries to set <code>x.some_attribute = value</code> where <code>.some_attribute</code> is a property on <code>class X:</code>, the the <code>property.__set__</code> is invoked, you can imagine it goes <code>x.some_attribute = value</code> gets translated into <code>X.some_attribute.__set__(x, value)</code> </p>
<p>So, to get to the <strong>crux of your question</strong>, why the infinite recursion, because using <code>obj.x = val</code> where <code>.x</code> is a <em>property</em>, will call <code>fset</code>, but in your <em>fset you use <code>obj.x = val</code></em>, and <code>fset</code> <em>gets called again</em>, and here is your hidden recursion.</p>
<p>The <code>@decorator</code> syntax is for convenience, and always accepts the <em>getter</em> first, but you can simply provide only the setter using the long-form way:</p>
<pre><code>&gt;&gt;&gt; class Weird:
...    def setx(self, value):
...       self._x = value
...    x = property(fset=setx)
...
&gt;&gt;&gt; w = Weird()
&gt;&gt;&gt; w.x = 'foo'
&gt;&gt;&gt; w.x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: unreadable attribute
</code></pre>
<p>I highly recommend reading the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor HOWTO</a>. Spoiler alert, <code>classmethod</code> and <code>staticmethod</code> are all descriptors, and so is how Python magically passes instances to methods (that is, <em>all function objects are descriptors who's <code>__get__</code> method passes the instance as the first argument to the function itself when accessed by an instance on a class!</em>. It also shows Python implementations of all of these things, including how you could implement <code>property</code> in pure Python!</p>
</div>
<span class="comment-copy">Thanks a lot for your answer. One more thing I am not able to understand here is that in case of class P1 how self.__x = 1000 able to set the value for self.x despite the case that property is defined for x. Please explain.</span>
<span class="comment-copy">@user110244 it doesn't, it sets the value for <code>self.__x</code> which is what the property getter returns.</span>
<span class="comment-copy">Thanks a lot for the reply. I have two more questions : 1) Inside class P2 when it is executed it never prints "property area" . Is this mean program is not entering the property area ? I am confused about the program flow now.  As per my understanding the flow is init &gt; property (go to setter to check property)&gt; setter (return value from there) ?  2) In class P1 if I change the code in setter to elif &gt; 1000: self.__y = 1000 it still return the value even when there is not self.__y in "@property". Shouldn't it break if it doesn't find self.__y or returning what is not in "@property" ?</span>
