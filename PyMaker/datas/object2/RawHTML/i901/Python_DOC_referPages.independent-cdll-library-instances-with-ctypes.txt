<div class="post-text" itemprop="text">
<p>I am trying to use ctypes and load the same compiled Fortran library twice, such that I have two independent instances of it, such that any module variables that the library contains are not stored in the same memory locations. The general solution described (for example, here: <a href="https://mail.python.org/pipermail/python-list/2010-May/575368.html" rel="nofollow noreferrer">https://mail.python.org/pipermail/python-list/2010-May/575368.html</a>) is to provide the full path to the library instead of just its name. However, I am not able to get this to work like this. Here is a minimal working example that demonstrates the problem:</p>
<p>test.f90:</p>
<pre><code>module test
    use iso_c_binding, only: c_int
    implicit none
    integer :: n
contains
    integer(c_int) function get() bind(c, name='get')
        get = n
    end function get

    subroutine set(new_n) bind(c, name='set')
        integer(c_int), intent(in) :: new_n
        n = new_n
    end subroutine set
end module test
</code></pre>
<p>test.py:</p>
<pre><code>import os
from ctypes import cdll, c_int, byref

if __name__ == '__main__':
    lib1 = cdll.LoadLibrary(os.path.abspath('test.so'))
    lib2 = cdll.LoadLibrary(os.path.abspath('test.so'))

    lib1.set(byref(c_int(0)))
    lib2.set(byref(c_int(1)))

    print(lib1.get())
</code></pre>
<p>The Fortran library is compiled using the command:</p>
<pre><code>gfortran -shared -fPIC -o test.so test.f90
</code></pre>
<p>When I run <code>python test.py</code> I get <code>1</code> as output, while I want to get <code>0</code>. Does anyone know how to make this work?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>ctypes</em> (<a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a>) loads libraries (on <em>Nix</em>) using <em>dlopen</em>. According to <a href="http://man7.org/linux/man-pages/man3/dlopen.3.html" rel="nofollow noreferrer">[man7]: DLOPEN(3)</a>:</p>
<blockquote>
<p>If the same shared object is loaded again with <strong>dlopen()</strong>, the same object handle is returned.  The dynamic linker maintains reference counts for object handles, so a dynamically loaded shared object is not deallocated until <strong>dlclose()</strong> has been called on it as many times as <strong>dlopen()</strong> has succeeded on it.</p>
</blockquote>
<p>I've prepared a small example.</p>
<p><em>dll.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#if defined(_WIN32)
#  define DLL_EXPORT __declspec(dllexport)
#else
#  define DLL_EXPORT
#endif


static int val = -1;


DLL_EXPORT int get() {
    return val;
}


DLL_EXPORT void set(int i) {
    val = i;
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import os
import shutil
import ctypes


DLL0_NAME = "./dll0.so"
DLL1_NAME = "./dll1.so"
DIR0_NAME = "dir0"


def get_dll_funcs(dll):
    get_func = dll.get
    get_func.argtypes = None
    get_func.restype = ctypes.c_int
    set_func = dll.set
    set_func.argtypes = [ctypes.c_int]
    set_func.restype = None
    return get_func, set_func


def main():
    os.makedirs(DIR0_NAME, exist_ok=True)
    shutil.copy(DLL0_NAME, DIR0_NAME)
    shutil.copy(DLL0_NAME, DLL1_NAME)

    dll_names = [DLL0_NAME, os.path.abspath(DLL0_NAME), os.path.join(DIR0_NAME, DLL0_NAME), DLL1_NAME]
    dlls = [ctypes.CDLL(item) for item in dll_names]

    for idx, dll in enumerate(dlls):
        print("Item {:d} ({:s}) was loaded at {:08X}".format(idx, dll_names[idx], dll._handle))
        set_func = get_dll_funcs(dll)[1]
        set_func(idx * 10)

    for idx, dll in enumerate(dlls):
        get_func = get_dll_funcs(dll)[0]
        print("Item {:d} get() returned {: d}".format(idx, get_func()))


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q054243176]&gt; ls
code.py  dll.c
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q054243176]&gt; gcc -o dll0.so -shared dll.c
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q054243176]&gt; ls
code.py  dll0.so  dll.c
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q054243176]&gt; ./code.py
Python 3.5.2 (default, Nov 12 2018, 13:43:14)
[GCC 5.4.0 20160609] on linux

Item 0 (./dll0.so) was loaded at 02437A80
Item 1 (/home/cfati/Work/Dev/StackOverflow/q054243176/dll0.so) was loaded at 02437A80
Item 2 (dir0/./dll0.so) was loaded at 02438690
Item 3 (./dll1.so) was loaded at 02438EF0
Item 0 get() returned  10
Item 1 get() returned  10
Item 2 get() returned  20
Item 3 get() returned  30
</code></pre>
</blockquote>
<p>As seen from the output (also pay attention to the <em>_handle</em> attribute), trying to load the same <em>.dll</em> (via its  path) more than once (same behavior on <em>Win</em>):</p>
<ul>
<li>If located in the same path (even if it's differently specified), doesn't actually load it again, it just increases its <em>refcount</em></li>
<li>If either its name or location differs, it is loaded again</li>
</ul>
<p>In short, to answer your question: simply copy it under a different name and load that.</p>
</div>
<span class="comment-copy">See the more recent discussions: <a href="https://stackoverflow.com/questions/28181014/loading-and-accessing-multiple-ctype-instances" title="loading and accessing multiple ctype instances">stackoverflow.com/questions/28181014/â€¦</a></span>
<span class="comment-copy">In short, it seems impossible. I tried locally (Linux x86_64, Python 3) and could only achieve the result by compiling twice the shared library with different names.</span>
<span class="comment-copy">Language the lib is written in is irrelevant. Did you try copying the <i>.so</i> under a different name and then load both of them?</span>
