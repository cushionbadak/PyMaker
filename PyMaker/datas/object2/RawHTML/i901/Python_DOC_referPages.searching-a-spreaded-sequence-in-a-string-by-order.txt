<div class="post-text" itemprop="text">
<p>Is there any way to search for a sequence by order (which is not continuous in the input) in a string in one command or a short block?</p>
<p>I'll give an example to the problem:</p>
<p>I gen a string from <code>raw_input</code> in the form of <code>(+ or - or void)(number or void)X^2 (+ or -) (+ or - or void)X (+ or -) (+ or - or void)(number)</code>, and I want to assign a flag for <code>(-+)aX^2 +- (-+)bX +- (+-)c</code> and a flag for only <code>c</code> and a flag for only <code>b</code>... only <code>b</code> and <code>c</code>, only <code>a</code> and <code>c</code>, etc in any order of input <code>(abc, cba, ac, cb, etc)</code> by defining a search by characters <code>"x^2", "x"</code> "number" and assigning each order to a flag...</p>
<p>Can it be done without writing 300+ lines with tons of <code>if</code>s and <code>elif</code>s? (I got frustrated in line 107).</p>
<p>I have tried the long agonizing way:</p>
<pre><code>def sorting_abc():
    polinput = raw_input("insert a pol.: ")  # input as string
    a = 0
    b = 0
    c = 0
    temp = [] * 5

    splinput = polinput.split() #splitted string input
    lensplin = len(splinput)  #Length of splinput
    temp = splinput

    flag_1var = bool(lensplin == 1)
    flag_2var = bool(lensplin == 3)
    flag_3var = bool(lensplin == 5)
    flag_minusplus = bool(temp[1] == '-' and temp[3] == '+')
    flag_plusminus = bool(temp[1] == '+' and temp[3] == '-')
    flag_minusminus = bool(temp[1] == '-' and temp[3] == '-')
    flag_plusplus = bool(temp[1] == '+' and temp[3] == '+')
    flag_2var_minus = bool(splinput &lt;= 3 and temp[1] == '-')
    flag_2var_plus = bool(splinput &lt;= 3 and temp[1] == '+')

    if (flag_1var):
        p1 = tamp[0]
        p1i = p1.find('x^2')
        a = p1[:p1i:]
        if (a == ''):
            a = 1
        if (a == '-'):
            a = -1
        a = int(a)

    if (flag_2var):
        p1 = temp[0]
        p2 = temp[1]
        p3 = temp[2]
        if ('x^2' in p1):
            p1i = p1.find('x^2')
            a = p1[:p1i:]
            if (a == ''):
                a = 1
            if (a == '-'):
                a = -1
            c = p3
            if (p3 == '-'):
                c -= int(c)
        if ('x^2' in p3):
            p3i = p3.find('x^2')
            a = p3[:p3i:]
            if (a == ''):
                a = 1
            if (p2 == '-'):
                a -= int(a)
            c = p1

    if (flag_3var):
        p1 = temp[0]
        p2 = temp[1]
        p3 = temp[2]
        p4 = temp[3]
        p5 = temp[4]
        if ('x^2' in p1):
            p1i = p1.find('x^2')
            a = p1[:p1i:]
            if (a == ''):
                a = 1
            if (a == '-'):
                a = -1
            if ('x' in p3):
                p3i = p3.find('x')
                b = p3[:p3i:]
                if (b == ''):
                    b = 1
                if (p2 == '-'):
                    b -= int(b)
                c = p5
                if (p4 == '-'):
                    c -= int(c)
            if ('x' in p5):
                p5i = p5.find('x')
                b = p5[:p5i:]
                if (b == ''):
                    b = 1
                if (p4 == '-'):
                    b -= int(b)
                if (p2 == '-'):
                    c -= int(c)
                c = p3
        elif ('x^2' in p3):
            p3i = p3.find('x^2')
            a = p3[:p3i:]
            if (a == ''):
</code></pre>
<p>Any chance to shorten this significantly?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with the help of <a href="https://docs.python.org/3/howto/regex.html" rel="nofollow noreferrer">regular expressions</a> if you choose. The advantage of doing it like that is that you will know if your input matches immediately, and what all the elements are when you query the match object.</p>
<p>The solution shown here relies on <a href="https://docs.python.org/3/library/re.html#re.match" rel="nofollow noreferrer"><code>re.match</code></a> to repeatedly find terms in your equation. The neat thing about doing it this way is that you can add up the coefficients to allow for terms with repeated exponents. It also makes it trivial to add support for terms beyond quadratic.</p>
<p>The result will be a dictionary keyed by the exponent (0 for the constant term), with the total coefficient aa the value.
The regex shown here relies on a pattern for matching numbers taken from <a href="https://stackoverflow.com/a/4703508/2988730">this answer</a> to <a href="https://stackoverflow.com/q/4703390/2988730">this question</a>:</p>
<pre><code>import re
from collections import defaultdict

string = '-12.5e-1 x^3 + -5 x^2 --0.5x +-0.75x^3 +6'

number = r'[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?'
pattern = re.compile(fr'\s*([+-])\s*({number})\s*(x(\^\d+)?)?')

coefficients = defaultdict(int)
# prepend a + to avoid special-casing the first term
string = '+' + string.rstrip()
while string:
    match = pattern.match(string)
    if not match:
        raise ValueError(f'Invalid input starting with {string}')
    sign = 1 if match.group(1) == '+' else -1
    coefficient = sign * float(match.group(2))
    if match.group(3):
        exp = match.group(4)
        exp = 1 if exp is None else int(exp[1:])
    else:
        exp = 0
    coefficients[exp] += coefficient
    string = string[match.end():]
</code></pre>
<p>For the example <code>string</code>, the resulting <code>coefficients</code> are</p>
<pre><code>defaultdict(&lt;class 'int'&gt;, {0: 6.0, 1: 0.5, 2: -5.0, 3: -2.0})
</code></pre>
<p>Here is an UDEOne link: <a href="https://ideone.com/TwtY2e" rel="nofollow noreferrer">https://ideone.com/TwtY2e</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would approach it this way:</p>
<ol>
<li>remove all the spaces from your input string.</li>
<li>apply 'all uppercase' or 'all lowercase' to your input string.</li>
<li>split your string into a list, using the <code>+</code> or <code>-</code> symbols (both) as separators.  For this, Google 'splitting strings using regular expressions' or check this <a href="https://stackoverflow.com/questions/4998629/split-string-with-multiple-delimiters-in-python">post</a>.</li>
<li>using a loop, for each of the elements of the list, remove the parentheses if they exist.</li>
<li>using a loop, for each of the elements of the list, check if they contain <code>X^2</code>, <code>X</code> or none (using uppercase or lowercase X depending on your previous choice).</li>
</ol>
<p>You can combine 4. and 5. in the same loop if you want.</p>
<p>That should give you the answer you need, with relatively short, flexible, reusable code.   Hope it helps.</p>
<p>Note: edit made after having a look at the example input.</p>
</div>
<span class="comment-copy">It will be easier to help if you provide some sample input and desired output.</span>
<span class="comment-copy">Sounds like a great usecase for regex for once. Add parentheses and it won't be any more.</span>
<span class="comment-copy">inputs: 4x^2 + 2x - 22; -2x + (-4x^2) - (+22); 22 - 3x + 3x^2;  output (for the last example): bool flag_c_minus_b_plus_a = true  by using this flag to execute some cutting and filtering actions I should get: a = 3 b = -3 c = 22 (all ints)</span>
<span class="comment-copy">What's the end goal? Do you need the flags or are you really trying to get the coefficients a, b, c from the text as numbers?</span>
<span class="comment-copy">"line 107" isn't very meaningful when no line numbers are being displayed.</span>
<span class="comment-copy">You should probably mention that you must specify the split pattern as a capture group.</span>
