<div class="post-text" itemprop="text">
<p>I was reading the Python documentation and <a href="https://pymotw.com/3/index.html" rel="nofollow noreferrer">PyMotW</a> book trying to learn Async/Await, Futures, and Tasks. </p>
<p><a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" rel="nofollow noreferrer">Coroutines and Tasks documentation</a>:</p>
<blockquote>
<p>Normally there is no need to create Future objects at the application
  level code.</p>
</blockquote>
<p>From the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#creating-futures-and-tasks" rel="nofollow noreferrer">future documentation</a> it states the following: </p>
<blockquote>
<p>loop.create_future()</p>
<p>Create an asyncio.Future object attached to the event loop.</p>
<p>This is the preferred way to create Futures in asyncio. This lets third-party event loops provide alternative implementations of the
  Future object (with better performance or instrumentation).</p>
</blockquote>
<p>However, in <a href="https://pymotw.com/3/asyncio/futures.html#waiting-for-a-future" rel="nofollow noreferrer">PyMotW chapter on Future</a>, the author creates a <code>future</code> object like this:</p>
<pre><code>all_done = asyncio.Future()
</code></pre>
<p>I assume because the book is slightly behind the current version of Python. To correct this, I did the following:</p>
<pre><code>future_Obj = event_loop.create_future()
</code></pre>
<p>So the authors full code becomes:</p>
<pre><code>import asyncio


def mark_done(future, result):
    print('setting future result to {!r}'.format(result))
    future.set_result(result)


event_loop = asyncio.get_event_loop()

try:

    future_Obj = event_loop.create_future()
    print('scheduling mark_done')
    event_loop.call_soon(mark_done, future_Obj, 'the result')

    print('entering event loop')
    result = event_loop.run_until_complete(future_Obj)
    print('returned result: {!r}'.format(result))
finally:
    print('closing event loop')
    event_loop.close()

print('future result: {!r}'.format(future_Obj.result()))
</code></pre>
<p><strong>Question:</strong></p>
<p>Is <code>future_Obj = event_loop.create_future()</code> in the sample above, the correct way to create a <code>future</code> object according to the documentation?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is <code>future_Obj = event_loop.create_future()</code> in the sample above, the correct way to create a future object according to the documentation?</p>
</blockquote>
<p>Yes, in the code as shown, that is exactly the way to do it.</p>
<p>One thing to watch out for is that a future is tied to an event loop, so creating a future at top-level creates a future tied to the loop that <code>asyncio.get_event_loop()</code> returns initially. Once you switch to <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run" rel="nofollow noreferrer"><code>asyncio.run</code></a>, you will get an error because each invocation of <code>asyncio.run</code> creates a new event loop.</p>
<p>To avoid that issue, a top-level future can start off as <code>None</code> and be created inside a coroutine, using <code>global</code> as appropriate. And since you're passing the future explicitly (which is a good practice to follow), you don't need a global variable at all:</p>
<pre><code>def mark_done(future, result):
    print('setting future result to {!r}'.format(result))
    future.set_result(result)

async def main():
    loop = asyncio.get_event_loop()
    future = loop.create_future()
    print('scheduling mark_done')
    loop.call_soon(mark_done, future, 'the result')
    print('suspending the coroutine')
    result = await future
    print('awaited result: {!r}'.format(result))
    print('future result: {!r}'.format(future.result()))
    return result

if __name__ == '__main__':
    print('entering the event loop')
    result = asyncio.run(main())
    print('returned result: {!r}'.format(result))
</code></pre>
<p>Note that when using <code>asyncio.run</code>, you never need to explicitly close the loop, that is done automatically. If you are using Python 3.6 or earlier, you can replace <code>asyncio.run(main())</code> with <code>asyncio.get_event_loop().run_until_complete(main())</code>.</p>
</div>
<span class="comment-copy">Just out of curiosity before Python 3.7, was the way to create a future object done like this, <code>all_done = asyncio.Future()</code>? The author runs a bug tracker, so we could tell him that line has changed in Python 3.7.</span>
<span class="comment-copy">The <code>create_future</code> event loop method was introduced in Python 3.5.2, so it's not a 3.7 novelty. A more serious issue with the guide is that creating and manipulating raw futures is considered bad style in modern async programming. Practically all examples that use <code>x.add_done_callback(foo)</code> would benefit from being expressed as coroutines that await <code>x</code> and then do <code>foo</code>.</span>
<span class="comment-copy">Should I just abandon that guide/book as a learning resource? If so, what other resources are there to learn async/await, tasks, and futures?</span>
<span class="comment-copy">@EmilyScott I wouldn't go that far, it's not <i>that</i> bad. As for other resources, <a href="https://morestina.net/blog/1213/asyncio-reading-list" rel="nofollow noreferrer">here</a> is a reading list that I compiled when I was studying asyncio. Perhaps it helps.</span>
<span class="comment-copy">Thanks for this, I bookmarked it :D. You even have PyMotW under the intermediate section.</span>
