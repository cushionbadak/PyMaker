<div class="post-text" itemprop="text">
<p>I need to transfer users and their passwords from a python 2 system to a python 3 system.</p>
<p>The PW hash looks like this:</p>
<pre><code>PBKDF2$sha256$10000$KlCW+ewerd19fS9f$l+5LgvcWTzghtz77086MSVG+q5z2Lij
</code></pre>
<p>In the python 2 system I used these functions to check hashes:</p>
<pre><code>def check_hash(password, hash_):
    """Check a password against an existing hash."""
    if isinstance(password, unicode):
        password = password.encode('utf-8')
    algorithm, hash_function, cost_factor, salt, hash_a = hash_.split('$')
    assert algorithm == 'PBKDF2'
    hash_a = b64decode(hash_a)
    hash_b = pbkdf2_bin(password, salt, int(cost_factor), len(hash_a),
                        getattr(hashlib, hash_function))
    assert len(hash_a) == len(hash_b)  # we requested this from pbkdf2_bin()
    # Same as "return hash_a == hash_b" but takes a constant time.
    # See http://carlos.bueno.org/2011/10/timing.html
    diff = 0
    for char_a, char_b in izip(hash_a, hash_b):
        diff |= ord(char_a) ^ ord(char_b)
    return diff == 0
</code></pre>
<p>and this:</p>
<pre><code>_pack_int = Struct('&gt;I').pack

def pbkdf2_bin(data, salt, iterations=1000, keylen=24, hashfunc=None):
    """Returns a binary digest for the PBKDF2 hash algorithm of `data`
    with the given `salt`.  It iterates `iterations` time and produces a
    key of `keylen` bytes.  By default SHA-1 is used as hash function,
    a different hashlib `hashfunc` can be provided.
    """
    hashfunc = hashfunc or hashlib.sha1
    mac = hmac.new(data, None, hashfunc)
    def _pseudorandom(x, mac=mac):
        h = mac.copy()
        h.update(x)
        return map(ord, h.digest())
    buf = []
    for block in xrange(1, -(-keylen // mac.digest_size) + 1):
        rv = u = _pseudorandom(salt + _pack_int(block))
        for i in xrange(iterations - 1):
            u = _pseudorandom(''.join(map(chr, u)))
            rv = starmap(xor, izip(rv, u))
        buf.extend(rv)
    return ''.join(map(chr, buf))[:keylen]
</code></pre>
<p>What have I done so far:</p>
<p>Right after copying the code into my python 3 scripts I had to change some variables:</p>
<p><code>izip</code> -&gt; <code>zip</code></p>
<p>I kept unicode: <code>from past.builtins import unicode</code></p>
<p>I kept xrange: <code>from past.builtins import xrange</code></p>
<p>Now I had no script errors, but after executing the script I got an error here (in the <code>pbkdf2_bin</code> function):</p>
<pre><code>rv = u = _pseudorandom(salt + _pack_int(block))
TypeError: must be str, not bytes
</code></pre>
<p>So I fixed it by converting bytes to str:</p>
<pre><code>rv = u = _pseudorandom(salt + _pack_int(block).decode('utf-8'))
</code></pre>
<p>Now the next error appears (in the <code>pbkdf2_bin</code> function):</p>
<pre><code>h.update(x)
TypeError: Unicode-objects must be encoded before hashing
</code></pre>
<p>I also fixed this with the proper encoding:</p>
<pre><code>h.update(x.encode('utf-8'))
</code></pre>
<p>Next error:</p>
<pre><code>  File "C:\Users\User\Eclipse-Workspace\Monteurzimmer-Remastered\hash_passwords.py", line 123, in check_hash
    getattr(hashlib, hash_function))
  File "C:\Users\User\Eclipse-Workspace\Monteurzimmer-Remastered\pbkdf2.py", line 125, in pbkdf2_bin_old_2
    u = _pseudorandom(''.join(map(chr, u)))
TypeError: ord() expected string of length 1, but int found
</code></pre>
<p>There was an issue with the return value of <code>_pseudorandom</code> (in the <code>pbkdf2_bin</code> function). It had to be converted, so I fixed it:</p>
<p><strong>Maybe the issue is here</strong></p>
<pre><code>#return map(ord, h.digest()) # throws the error
#return map(int, h.digest()) # returns nothing (length 0)
#return list(map(ord, h.digest())) # throws the error
return list(map(int, h.digest())) # seems to work with the correct length
</code></pre>
<p>The last error is at the end of the <code>check_hash</code> function:</p>
<pre><code>File "C:\Users\User\Eclipse-Workspace\Monteurzimmer-Remastered\hash_passwords.py", line 129, in check_hash
    diff |= ord(char_a) ^ ord(char_b)
TypeError: ord() expected string of length 1, but int found

for char_a, char_b in zip(hash_a, hash_b):
    diff |= ord(char_a) ^ ord(char_b)
</code></pre>
<p>char_a is an integer and chat_b is not. I was able to fix this by converting char_a to the real char:</p>
<pre><code>for char_a, char_b in zip(hash_a, hash_b):
    diff |= ord(chr(char_a)) ^ ord(char_b)
</code></pre>
<p>Finally I had no errors, but it tells me the entered password is wrong,
so somewhere is an error, because I know that the password is correct and it works on the python 2 app.</p>
<p><strong>EDIT</strong></p>
<p>Someone mentioned the 2to3 library, so I tried it. All in all it has done the same things, which I have done already and the problem is the same.</p>
<p><strong>EDIT for bounty</strong></p>
<p>To sum it up. The 2 functions which I posted above come from python 2 and work in python 2. </p>
<p>This hash:</p>
<pre><code>PBKDF2$sha256$10000$r+Gy8ewTkE7Qv0V7$uqmgaPgpaT1RSvFPMcGb6cGaFAhjyxE9
</code></pre>
<p>is this password: <code>Xs12'io!12</code></p>
<p>I can correctly login with this password on my python 2 app.</p>
<p>Now I want to use the same two functions in python 3, but eventhough I worked through all errors, it tells me the password is wrong.</p>
<p>The imports:</p>
<pre><code>import hmac
import hashlib
from struct import Struct
from operator import xor
from itertools import izip, starmap

from base64 import b64encode, b64decode
import hashlib
from itertools import izip
from os import urandom
import random
import string
</code></pre>
<p>These imports are used in the python 2 script.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think I got it working. I found the original code on <a href="https://github.com/mitsuhiko/python-pbkdf2/blob/master/pbkdf2.py" rel="nofollow noreferrer">github</a> which helped me create a test case. After looking at the issues I followed the solution you came up with and I decoded the bytes to <code>iso-8859-1</code> instead of <code>utf-8</code> and it worked.</p>
<pre class="lang-py prettyprint-override"><code>from struct import Struct
from base64 import b64decode
import hashlib
import hmac
from operator import xor
from itertools import starmap


_pack_int = Struct('&gt;I').pack


def check_hash(password, hash_):
    """Check a password against an existing hash."""
    if isinstance(password, str):
        password = password.encode('utf-8')
    algorithm, hash_function, cost_factor, salt, hash_a = hash_.split('$')
    assert algorithm == 'PBKDF2'
    hash_a = b64decode(hash_a).decode('iso-8859-1')
    hash_b = pbkdf2_bin(password, salt, int(cost_factor), len(hash_a),
                        getattr(hashlib, hash_function))
    assert len(hash_a) == len(hash_b)  # we requested this from pbkdf2_bin()
    # Same as "return hash_a == hash_b" but takes a constant time.
    # See http://carlos.bueno.org/2011/10/timing.html
    diff = 0
    for char_a, char_b in zip(hash_a, hash_b):
        diff |= ord(char_a) ^ ord(char_b)
    return diff == 0


def pbkdf2_bin(data, salt, iterations=1000, keylen=24, hashfunc=None):
    """Returns a binary digest for the PBKDF2 hash algorithm of `data`
    with the given `salt`.  It iterates `iterations` time and produces a
    key of `keylen` bytes.  By default SHA-1 is used as hash function,
    a different hashlib `hashfunc` can be provided.
    """
    hashfunc = hashfunc or hashlib.sha1
    mac = hmac.new(data, None, hashfunc)
    def _pseudorandom(x, mac=mac):
        h = mac.copy()
        h.update(x)
        return list(map(ord, h.digest().decode('iso-8859-1')))
    buf = []
    for block in range(1, -(-keylen // mac.digest_size) + 1):
        myx = salt.encode('utf-8') + _pack_int(block)
        rv = u = _pseudorandom(myx)
        for i in range(iterations - 1):
            u = _pseudorandom(''.join(map(chr, u)).encode('iso-8859-1'))
            rv = starmap(xor, zip(rv, u))
        buf.extend(rv)
    return ''.join(map(chr, buf))[:keylen]


if __name__ == "__main__":
    print(check_hash('Xs12\'io!12', 'PBKDF2$sha256$10000$r+Gy8ewTkE7Qv0V7$uqmgaPgpaT1RSvFPMcGb6cGaFAhjyxE9'))
</code></pre>
<p>Instead of continuing to finegale this script and maintain it, I'd suggest looking at python3 implementations of this same function. </p>
<p>References</p>
<ul>
<li><a href="https://wiki.python.org/moin/Python3UnicodeDecodeError" rel="nofollow noreferrer">https://wiki.python.org/moin/Python3UnicodeDecodeError</a></li>
<li><a href="https://github.com/sfstpala/python3-pbkdf2" rel="nofollow noreferrer">https://github.com/sfstpala/python3-pbkdf2</a></li>
<li><a href="https://www.dlitz.net/software/python-pbkdf2/" rel="nofollow noreferrer">https://www.dlitz.net/software/python-pbkdf2/</a></li>
</ul>
</div>
<span class="comment-copy">I would just try <code>h.update(x)</code> =&gt; <code>h.update(x.encode("utf-8"))</code></span>
<span class="comment-copy">I am doing this already, you missed it, while reading the question. I know its long. Thanks for the reply!</span>
<span class="comment-copy">Aside, but out of curiosity: if you want to convert the code to Python 3, why keep <code>unicode</code> and <code>xrange</code>, instead of replacing them with their Python 3 equivalents?</span>
<span class="comment-copy">You should do some proper debugging: litter some print statements/functions in both codes, then compare all intermediate values (it may compare <code>str</code> and <code>bytes</code>, but the contents should be the same). That may show you where the scripts go wrong.</span>
<span class="comment-copy">I have done all this already, I didnt wanted to post all prints and tests as it would be a lot more code and would look messy. I hoped that someone would immediately recognize the issue, but as it seems, its a very hard issue. Thanks for the reply!</span>
<span class="comment-copy">Thank you a lot, I made a very stupid mistake. The first time I was working with this code (some years ago), god knows why, I added a script comment to modify the coding and it was <code>iso-8859-1</code>, but in the script I used <code>utf-8</code>, I had overwritten the decoding only there. At the time this was my first web project and now I simply overlooked that there was this line. Thank you very much for solving the issue. I am sorry you had to look for the complete version everywhere, you should have asked me. But you helped me A LOT.</span>
<span class="comment-copy">Bounty can will be awarded in 21 hours.</span>
<span class="comment-copy">No problem. I learned a bit on encodings and the limitations of the <code>2to3</code> package. I'm glad I could help.</span>
<span class="comment-copy">Note: Python 3 <a href="https://docs.python.org/3/library/hashlib.html#key-derivation" rel="nofollow noreferrer">already implements PBKDF2 hmac hashing</a>, there is no need to re-implement this.</span>
<span class="comment-copy"><code>hashlib.pbkdf2_hmac(hash_function, password.encode('ascii'), salt.encode('ascii'), int(cost_factor))[:len(hash_a)]</code> can replace <code>pbkdf2_bin()</code>.</span>
