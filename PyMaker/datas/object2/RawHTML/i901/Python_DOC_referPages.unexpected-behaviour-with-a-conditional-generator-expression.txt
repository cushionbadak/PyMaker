<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/52968312/generator-expression-uses-list-assigned-after-the-generators-creation">Generator expression uses list assigned after the generator's creation</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>I was running a piece of code that unexpectedly gave a logic error at one part of the program. When investigating the section, I created a test file to test the set of statements being run and found out an unusual bug that seems very odd.</p>
<p>I tested this simple code:</p>
<pre><code>array = [1, 2, 2, 4, 5] # Original array
f = (x for x in array if array.count(x) == 2) # Filters original
array = [5, 6, 1, 2, 9] # Updates original to something else

print(list(f)) # Outputs filtered
</code></pre>
<p>And the output was:</p>
<pre><code>&gt;&gt;&gt; []
</code></pre>
<p>Yes, nothing. I was expecting the filter comprehension to get items in the array with a count of 2 and output this, but I didn't get that:</p>
<pre><code># Expected output
&gt;&gt;&gt; [2, 2]
</code></pre>
<p>When I commented out the third line to test it once again:</p>
<pre><code>array = [1, 2, 2, 4, 5] # Original array
f = (x for x in array if array.count(x) == 2) # Filters original
### array = [5, 6, 1, 2, 9] # Ignore line

print(list(f)) # Outputs filtered
</code></pre>
<p>The output was correct (you can test it for yourself):</p>
<pre><code>&gt;&gt;&gt; [2, 2]
</code></pre>
<p>At one point I outputted the type of the variable <code>f</code>:</p>
<pre><code>array = [1, 2, 2, 4, 5] # Original array
f = (x for x in array if array.count(x) == 2) # Filters original
array = [5, 6, 1, 2, 9] # Updates original

print(type(f))
print(list(f)) # Outputs filtered
</code></pre>
<p>And I got:</p>
<pre><code>&gt;&gt;&gt; &lt;class 'generator'&gt;
&gt;&gt;&gt; []
</code></pre>
<p>Why is updating a list in Python changing the output of another generator variable? This seems very odd to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's generator expressions are late binding (see <a href="https://www.python.org/dev/peps/pep-0289/" rel="noreferrer">PEP 289 -- Generator Expressions</a>) (what the other answers call "lazy"):</p>
<blockquote>
<h2>Early Binding versus Late Binding</h2>
<p>After much discussion, it was decided that the first (outermost) for-expression [of the generator expression] should be evaluated immediately and that the remaining expressions be evaluated when the generator is executed.</p>
<p>[...] Python takes a late binding approach to lambda expressions and has no precedent for automatic, early binding. It was felt that introducing a new paradigm would unnecessarily introduce complexity.</p>
<p>After exploring many possibilities, a consensus emerged that binding issues were hard to understand and that users should be strongly encouraged to use generator expressions inside functions that consume their arguments immediately. For more complex applications, full generator definitions are always superior in terms of being obvious about scope, lifetime, and binding.</p>
</blockquote>
<p>That means it <strong>only</strong> evaluates the outermost <code>for</code> when creating the generator expression. So it actually <strong>binds</strong> the value with the name <code>array</code> in the "subexpression" <code>in array</code> (in fact it's binding the equivalent to <code>iter(array)</code> at this point). But when you iterate over the generator the <code>if array.count</code> call actually refers to what is currently named <code>array</code>.</p>
<hr/>
<p>Since it's actually a <code>list</code> not an <code>array</code> I changed the variable names in the rest of the answer to be more accurate.</p>
<p>In your first case the <code>list</code> you iterate over and the <code>list</code> you count in will be different. It's as if you used:</p>
<pre><code>list1 = [1, 2, 2, 4, 5]
list2 = [5, 6, 1, 2, 9]
f = (x for x in list1 if list2.count(x) == 2)
</code></pre>
<p>So you check for each element in <code>list1</code> if its count in <code>list2</code> is two.</p>
<p>You can easily verify this by modifying the second list:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 2]
&gt;&gt;&gt; f = (x for x in lst if lst.count(x) == 2)
&gt;&gt;&gt; lst = [1, 1, 2]
&gt;&gt;&gt; list(f)
[1]
</code></pre>
<p>If it iterated over the first list and counted in the first list it would've returned <code>[2, 2]</code> (because the first list contains two <code>2</code>). If it iterated over and counted in the second list the output should be <code>[1, 1]</code>. But since it iterates over the first list (containing one <code>1</code>) but checks the second list (which contains two <code>1</code>s) the output is just a single <code>1</code>.</p>
<h2>Solution using a generator function</h2>
<p>There are several possible solutions, I generally prefer not to use "generator expressions" if they aren't iterated over immediately. A simple generator function will suffice to make it work correctly:</p>
<pre><code>def keep_only_duplicated_items(lst):
    for item in lst:
        if lst.count(item) == 2:
            yield item
</code></pre>
<p>And then use it like this:</p>
<pre><code>lst = [1, 2, 2, 4, 5]
f = keep_only_duplicated_items(lst)
lst = [5, 6, 1, 2, 9]

&gt;&gt;&gt; list(f)
[2, 2]
</code></pre>
<p>Note that the PEP (see the link above) also states that for anything more complicated a full generator definition is preferrable.</p>
<h2>A better solution using a generator function with a Counter</h2>
<p>A better solution (avoiding the quadratic runtime behavior because you iterate over the whole array for each element in the array) would be to count (<a href="https://docs.python.org/library/collections.html#collections.Counter" rel="noreferrer"><code>collections.Counter</code></a>) the elements once and then do the lookup in constant time (resulting in linear time):</p>
<pre><code>from collections import Counter

def keep_only_duplicated_items(lst):
    cnts = Counter(lst)
    for item in lst:
        if cnts[item] == 2:
            yield item
</code></pre>
<h2>Appendix: Using a subclass to "visualize" what happens and when it happens</h2>
<p>It's quite easy to create a <code>list</code> subclass that prints when specific methods are called, so one can verify that it really works like that.</p>
<p>In this case I just override the methods <code>__iter__</code> and <code>count</code> because I'm interested over which list the generator expression iterates and in which list it counts. The method bodies actually just delegate to the superclass and print something (since it uses <code>super</code> without arguments and f-strings it requires Python 3.6 but it should be easy to adapt for other Python versions):</p>
<pre><code>class MyList(list):
    def __iter__(self):
        print(f'__iter__() called on {self!r}')
        return super().__iter__()

    def count(self, item):
        cnt = super().count(item)
        print(f'count({item!r}) called on {self!r}, result: {cnt}')
        return cnt
</code></pre>
<p>This is a simple subclass just printing when the <code>__iter__</code> and <code>count</code> method are called:</p>
<pre><code>&gt;&gt;&gt; lst = MyList([1, 2, 2, 4, 5])

&gt;&gt;&gt; f = (x for x in lst if lst.count(x) == 2)
__iter__() called on [1, 2, 2, 4, 5]

&gt;&gt;&gt; lst = MyList([5, 6, 1, 2, 9])

&gt;&gt;&gt; print(list(f))
count(1) called on [5, 6, 1, 2, 9], result: 1
count(2) called on [5, 6, 1, 2, 9], result: 1
count(2) called on [5, 6, 1, 2, 9], result: 1
count(4) called on [5, 6, 1, 2, 9], result: 0
count(5) called on [5, 6, 1, 2, 9], result: 1
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others have mentioned <a href="https://wiki.python.org/moin/Generators" rel="noreferrer">Python generators</a> are lazy. When this line is run:</p>
<pre><code>f = (x for x in array if array.count(x) == 2) # Filters original
</code></pre>
<p>nothing actually happens yet. You've just declared how the generator function f will work. Array is not looked at yet. Then, you create a new array that replaces the first one, and finally when you call </p>
<pre><code>print(list(f)) # Outputs filtered
</code></pre>
<p>the generator now needs the actual values and starts pulling them from the generator f. But at this point, array already refers to the second one, so you get an empty list.</p>
<p>If you need to reassign the list, and can't use a different variable to hold it, consider creating the list instead of a generator in the second line:</p>
<pre><code>f = [x for x in array if array.count(x) == 2] # Filters original
...
print(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Others have already explained the root cause of the issue - the generator is binding to the name of the <code>array</code> local variable, rather than its value.</p>
<p>The most pythonic solution is definitely the list comprehension:</p>
<pre><code>f = [x for x in array if array.count(x) == 2]
</code></pre>
<hr/>
<p><strong>However</strong>, if there is some reason that you don't want to create a list, you <em>can</em> also <a href="https://stackoverflow.com/questions/11366375/how-can-i-force-python-to-create-a-new-variable-new-scope-inside-a-loop">force a scope close</a> over <code>array</code>:</p>
<pre><code>f = (lambda array=array: (x for x in array if array.count(x) == 2))()
</code></pre>
<p>What's happening here is that the <code>lambda</code> captures the reference to <code>array</code> at the time the line is run, ensuring that the generator sees the variable you expect, even if the variable is later redefined.</p>
<p>Note that this still binds to the <em>variable</em> (reference), not the <em>value</em>, so, for example, the following will print <code>[2, 2, 4, 4]</code>:</p>
<pre><code>array = [1, 2, 2, 4, 5] # Original array

f = (lambda array=array: (x for x in array if array.count(x) == 2))() # Close over array
array.append(4)  # This *will* be captured

array = [5, 6, 1, 2, 9] # Updates original to something else

print(list(f)) # Outputs [2, 2, 4, 4]
</code></pre>
<hr/>
<p>This is a common pattern in some languages, but it's not very pythonic, so only really makes sense if there's a very good reason for not using the list comprehension  (e.g., if <code>array</code> is very long, or is being used in a nested generator comprehension, and you're concerned about memory).</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not using a generator correctly if this is the primary use of this code. Use a list comprehension instead of a generator comprehension. Just replace the parentheses with brackets. It evaluates to a list if you don't know.</p>
<pre><code>array = [1, 2, 2, 4, 5]
f = [x for x in array if array.count(x) == 2]
array = [5, 6, 1, 2, 9]

print(f)
#[2, 2]
</code></pre>
<p>You are getting this response because of the nature of a generator. You're calling the generator when it't contents will evaluate to <code>[]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Generators are lazy, they won't be evaluated until you iterate through them. In this case that's at the point you create the <code>list</code> with the generator as input, at the <code>print</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The root cause of the problem is that generators are lazy; variables are evaluated each time:</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 2, 4, 5, 5, 5]
&gt;&gt;&gt; filtered = (x for x in l if l.count(x) == 2)
&gt;&gt;&gt; l = [1, 2, 4, 4, 5, 6, 6]
&gt;&gt;&gt; list(filtered)
[4]
</code></pre>
<p>It iterates over the original list and evaluates the condition with the current list. In this case, 4 appeared twice in the new list, causing it to appear in the result. It only appears once in the result because it only appeared once in the original list. The 6s appear twice in the new list, but never appear in the old list and are hence never shown.</p>
<p>Full function introspection for the curious (the line with the comment is the important line):</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 2, 4, 5]
&gt;&gt;&gt; filtered = (x for x in l if l.count(x) == 2)
&gt;&gt;&gt; l = [1, 2, 4, 4, 5, 6, 6]
&gt;&gt;&gt; list(filtered)
[4]
&gt;&gt;&gt; def f(original, new, count):
    current = original
    filtered = (x for x in current if current.count(x) == count)
    current = new
    return list(filtered)

&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; dis(f)
  2           0 LOAD_FAST                0 (original)
              3 STORE_DEREF              1 (current)

  3           6 LOAD_CLOSURE             0 (count)
              9 LOAD_CLOSURE             1 (current)
             12 BUILD_TUPLE              2
             15 LOAD_CONST               1 (&lt;code object &lt;genexpr&gt; at 0x02DD36B0, file "&lt;pyshell#17&gt;", line 3&gt;)
             18 LOAD_CONST               2 ('f.&lt;locals&gt;.&lt;genexpr&gt;')
             21 MAKE_CLOSURE             0
             24 LOAD_DEREF               1 (current)
             27 GET_ITER
             28 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             31 STORE_FAST               3 (filtered)

  4          34 LOAD_FAST                1 (new)
             37 STORE_DEREF              1 (current)

  5          40 LOAD_GLOBAL              0 (list)
             43 LOAD_FAST                3 (filtered)
             46 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             49 RETURN_VALUE
&gt;&gt;&gt; f.__code__.co_varnames
('original', 'new', 'count', 'filtered')
&gt;&gt;&gt; f.__code__.co_cellvars
('count', 'current')
&gt;&gt;&gt; f.__code__.co_consts
(None, &lt;code object &lt;genexpr&gt; at 0x02DD36B0, file "&lt;pyshell#17&gt;", line 3&gt;, 'f.&lt;locals&gt;.&lt;genexpr&gt;')
&gt;&gt;&gt; f.__code__.co_consts[1]
&lt;code object &lt;genexpr&gt; at 0x02DD36B0, file "&lt;pyshell#17&gt;", line 3&gt;
&gt;&gt;&gt; dis(f.__code__.co_consts[1])
  3           0 LOAD_FAST                0 (.0)
        &gt;&gt;    3 FOR_ITER                32 (to 38)
              6 STORE_FAST               1 (x)
              9 LOAD_DEREF               1 (current)  # This loads the current list every time, as opposed to loading a constant.
             12 LOAD_ATTR                0 (count)
             15 LOAD_FAST                1 (x)
             18 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             21 LOAD_DEREF               0 (count)
             24 COMPARE_OP               2 (==)
             27 POP_JUMP_IF_FALSE        3
             30 LOAD_FAST                1 (x)
             33 YIELD_VALUE
             34 POP_TOP
             35 JUMP_ABSOLUTE            3
        &gt;&gt;   38 LOAD_CONST               0 (None)
             41 RETURN_VALUE
&gt;&gt;&gt; f.__code__.co_consts[1].co_consts
(None,)
</code></pre>
<p>To reiterate: The list to be iterated is only loaded once. Any closures in the condition or expression, however, are loaded from the enclosing scope each iteration. They are not stored in a constant.</p>
<p>The best solution for your problem would be to create a new variable referencing the original list and use that in your generator expression,.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generator evaluation is "lazy" -- it doesn't get executed until you actualize it with a proper reference.  With your line:</p>
<p>Look again at your output with the type of <code>f</code>: that object is a <em>generator</em>, not a sequence.  It's waiting to be used, an iterator of sorts.</p>
<p>Your generator isn't evaluated until you start requiring values from it.  At that point, it uses the available values <em>at that point</em>, <strong>not</strong> the point at which it was defined.</p>
<hr/>
<p><strong>Code to "make it work"</strong></p>
<p>That depends on what you mean by "make it work".  If you want <code>f</code> to be a filtered list, then use a list, not a generator:</p>
<pre><code>f = [x for x in array if array.count(x) == 2] # Filters original
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generators are <strong>lazy</strong> and your newly defined <code>array</code> is used when you exhaust your generator after redefining. Therefore, the output is correct. A quick fix is to use a list comprehension by replacing parentheses <code>()</code> by brackets <code>[]</code>.</p>
<p>Moving on to how better to write your logic, counting a value in a loop has quadratic complexity. For an algorithm that works in linear time, you can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> to count values, and <em>keep a copy of your original list</em>:</p>
<pre><code>from collections import Counter

array = [1, 2, 2, 4, 5]   # original array
counts = Counter(array)   # count each value in array
old_array = array.copy()  # make copy
array = [5, 6, 1, 2, 9]   # updates array

# order relevant
res = [x for x in old_array if counts[x] &gt;= 2]
print(res)
# [2, 2]

# order irrelevant
from itertools import chain
res = list(chain.from_iterable([x]*count for x, count in counts.items() if count &gt;= 2))
print(res)
# [2, 2]
</code></pre>
<p>Notice the second version doesn't even require <code>old_array</code> and is useful if there is no need to maintain ordering of values in your original array.</p>
</div>
<span class="comment-copy">You redefine <code>array</code> and your <i>new array</i> is what gets referenced by the <b>lazy</b> generator comprehension.</span>
<span class="comment-copy">Would be good to see an answer that mentions scope.</span>
<span class="comment-copy">This is a variation of the question of <b>"late binding" of python closures</b>. The generator is essentially acting like a closure here. (I'm not sure why the answers are so focused on laziness... that, I think, is <i>obvious</i> to anyone using a generator.)</span>
<span class="comment-copy">This is the only answer that explains all the subtleties involved in the questioned behavior.</span>
<span class="comment-copy">Your example as given (with result [1]) might only look at the second list. It would be even better if you used something like [1, 1, 2, 2, 3, 4, 5] and [1, 2, 2, 3, 3, 4, 6], with result [2, 2, 3].</span>
<span class="comment-copy">See for example <a href="https://tio.run/##RYxBCoAgAATvvmKPChKk1c2XRKdAEkRFDez1pgUFA3vYYcKVD@9krTZlKKwjR0M8SI6JY96Ibg8t0D6iwDh01@g@w@5Pl2lhUAqCkb/yJd7KspEQTVOtSZlqxmq9AQ" rel="nofollow noreferrer">tio.run/…</a></span>
<span class="comment-copy">@hkBst Thank you for the additional example. But I'm not sure what you mean with my example being ambguous. I thought in case it would look only at the first list the result would be <code>[2,2]</code>, if it would only look at the second list the result would be <code>[1, 1]</code>. That the result is <code>[1]</code> shows that it iterates over the first list, but filters based on the second list. Is my thinking incorrect there?</span>
<span class="comment-copy">Wow, that's about as counter-intuitive as it gets. Usually Python is easier to explain than that.</span>
<span class="comment-copy">This is <b>incorrect</b>. As <a href="https://stackoverflow.com/a/54249614/5600363">stackoverflow.com/a/54249614/5600363</a> explains <code>array</code> in <code>in array</code> is bound immediately but <code>array</code> in <code>array.count</code> only later. You could also try to explain <a href="https://tio.run/##RYxBCoAgAATvvmKPChKk1c2XRKdAEkRFDez1pgUFA3vYYcKVD@9krTZlKKwjR0M8SI6JY96Ibg8t0D6iwDh01@g@w@5Pl2lhUAqCkb/yJd7KspEQTVOtSZlqxmq9AQ" rel="nofollow noreferrer">tio.run/…</a></span>
<span class="comment-copy">Useful answer for showing how to override the default behavior!</span>
<span class="comment-copy">Thank you. I seem to have used the wrong brackets. But in general using a generator comprehension seems odd.</span>
<span class="comment-copy">With your change, <code>list(f)</code> becomes redundant.</span>
<span class="comment-copy">Lol @Mark Ransom, copy paste got me, I edited.</span>
<span class="comment-copy">@SurajKothari It is not odd, it's a great tool! It just takes some time to wrap the ole brain around. Do some research you'll find that generators are amazing!</span>
<span class="comment-copy">This does not explain the observed behavior and so does not answer the question.</span>
<span class="comment-copy">When am I iterating through them. Am I meant to?</span>
<span class="comment-copy">@SurajKothari when you create the <code>list</code> it will iterate for you without you needing to do it explicitly.</span>
<span class="comment-copy">Also which list? When I declare the first one, or re-assign the second?</span>
<span class="comment-copy">What first &amp; second?  You define only one list, at the final line of your code.</span>
<span class="comment-copy">This could have been my own answer, but it is <b>incorrect</b> (see MSeifert's answer) or try to explain <a href="https://tio.run/##RYxBCoAgAATvvmKPChKk1c2XRKdAEkRFDez1pgUFA3vYYcKVD@9krTZlKKwjR0M8SI6JY96Ibg8t0D6iwDh01@g@w@5Pl2lhUAqCkb/yJd7KspEQTVOtSZlqxmq9AQ" rel="nofollow noreferrer">tio.run/…</a></span>
<span class="comment-copy">I somewhat understand. Could you show some code to make it work, because I need to re-assign the same list again in the main code.</span>
