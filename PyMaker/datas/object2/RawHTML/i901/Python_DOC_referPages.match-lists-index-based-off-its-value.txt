<div class="post-text" itemprop="text">
<p>I am new to Python and working on a problem where I have to match a list of indices to a list of value with 2 conditions: </p>
<ol>
<li>If there is a repeated index, then the values should be summed</li>
<li>If there is no index in the list, then value should be 0</li>
</ol>
<p>For example, below are my 2 lists: 'List of Inds' and 'List of Vals'. So at index 0, my value is 5; at index 1, my value is 4; at index 2, my value is 3 (2+1), at index 3, may value 0 (since no value associated with the index) and so on.</p>
<pre class="lang-none prettyprint-override"><code>Input:

'List of Inds' = [0,1,4,2,2]
'List Vals' = [5,4,3,2,1]
</code></pre>
<pre class="lang-none prettyprint-override"><code>Output = [5,4,3,0,3]
</code></pre>
<p>I have been struggling with it for few days and can't find anything online that can point me in the right direction. Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>List_of_Inds = [0,1,4,2,2]
List_Vals = [5,4,3,2,1]
dic ={}

i = 0
for key in List_of_Inds:
    if key not in dic:
        dic[key] = 0
    dic[key] = List_Vals[i]+dic[key]
    i = i+1

output = []
for key in range(0, len(dic)+1):
    if key in dic:
        output.append(dic[key])
    else:
        output.append(0)

print(dic)
print(output)
</code></pre>
<p>output:</p>
<pre><code>{0: 5, 1: 4, 4: 3, 2: 3}
[5, 4, 3, 0, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following code works as desired. In computer science it is called "Sparse Matrix" where the data is kept only for said indices, but the "virtual size" of the data structure seems large from the outside.</p>
<pre><code>import logging

class SparseVector:
    def __init__(self, indices, values):
        self.d = {}
        for c, indx in enumerate(indices):
            logging.info(c)
            logging.info(indx)
            if indx not in self.d:
                self.d[indx] = 0
            self.d[indx] += values[c]

    def getItem(self, key):
        if key in self.d:
            return self.d[key]
        else:
            return 0

p1 = SparseVector([0,1,4,2,2], [5,4,3,2,1])
print p1.getItem(0);
print p1.getItem(1);
print p1.getItem(2);
print p1.getItem(3);
print p1.getItem(4);
print p1.getItem(5);
print p1.getItem(6);
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Answer code is</p>
<pre><code>def ans(list1,list2):
    dic={}
    ans=[]
    if not(len(list1)==len(list2)):
        return "Not Possible"
    for i in range(0,len(list1)):
        ind=list1[i]
        val=list2[i]
        if not(ind in dic.keys()):
            dic[ind]=val
        else:
            dic[ind]+=val
    val=len(list1)
    for i in range(0,val):
        if not(i in dic.keys()):
            ans.append(0)
        else:
            ans.append(dic[i])
    return ans
</code></pre>
<p>To test:</p>
<pre><code>  print(ans([0,1,4,2,2], [5,4,3,2,1]))
</code></pre>
<p>output:</p>
<pre><code>  [5, 4, 3, 0, 3]
</code></pre>
<p>Hope it helps </p>
<p>Comment if you dont understand any step</p>
</div>
<div class="post-text" itemprop="text">
<p>what you can do is sort the indexes and values in an ascending order, and then sum it up. Here is an example code:</p>
<pre><code>import numpy as np

ind = [0,1,4,2,2]
vals = [5,4,3,2,1]

points = zip(ind,vals)

sorted_points = sorted(points)

new_ind = [point[0] for point in sorted_points]
new_val = [point[1] for point in sorted_points]

output = np.zeros((len(new_ind)))

for i in range(len(new_ind)):
    output[new_ind[i]] += new_val[i]    
</code></pre>
<p>In this code, the index values are sorted to be in ascending order and then the value array is rearranged according to the sorted index array. Then, using a simple for loop, you can sum the values of each existing index and calculate the output.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a grouping problem. You can use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> to build a dictionary mapping, incrementing values in each iteration. Then use a list comprehension:</p>
<pre><code>indices = [0,1,4,2,2]
values = [5,4,3,2,1]

from collections import defaultdict
dd = defaultdict(int)
for idx, val in zip(indices, values):
    dd[idx] += val

res = [dd[idx] for idx in range(max(dd) + 1)]

## functional alternative:
# res = list(map(dd.get, range(max(dd) + 1)))

print(res)
# [5, 4, 3, 0, 3]
</code></pre>
</div>
<span class="comment-copy">How big are those lists? It's important to understand the physical size of the arrays in order to give a proper answer. One way to solve it would be to arrange the keys and values ahead of the calculation with appropriate data structures</span>
<span class="comment-copy">Need to assume max length</span>
<span class="comment-copy">what is the formula to calculate the output</span>
<span class="comment-copy">Also is length of both lists equal</span>
<span class="comment-copy">you need t o provide more information'</span>
