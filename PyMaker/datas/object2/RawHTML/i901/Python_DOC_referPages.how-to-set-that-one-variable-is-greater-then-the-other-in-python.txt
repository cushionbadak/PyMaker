<div class="post-text" itemprop="text">
<p>I'm trying to make a "rock, paper, scissors" game in Python and i want to set one variable to be greater then the other one.</p>
<p>something like: </p>
<pre class="lang-py prettyprint-override"><code>paper &gt; rock
scissors &gt; paper
rock &gt; scissors
</code></pre>
<p>how could i do it..?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes as Daniel said, with the override of <code>__cmp__</code> you can acheive this :</p>
<pre><code>class Comparable(object):
    def __init__(self, below_class, above_class):
        self.above_class = above_class
        self.below_class = below_class

    def __cmp__(self, other):
        if isinstance(other, self.below_class):
            return 1
        if isinstance(other, self.above_class):
            return -1
        return 0

class Paper(Comparable):
    pass

class Rock(Comparable):
    pass

class Scissors(Comparable):
    pass

scissors = Scissors(Paper, Rock)
paper = Paper(Rock, Scissors)
rock = Rock(Scissors, Paper)

# True

print paper &gt; rock
print scissors &gt; paper
print rock &gt; scissors

# False

print paper &lt; rock
print scissors &lt; paper
print rock &lt; scissors
</code></pre>
<p>The documentation on the way this works is available here : <a href="https://docs.python.org/2.6/reference/datamodel.html#object.__cmp__" rel="noreferrer">https://docs.python.org/2.6/reference/datamodel.html#object.<strong>cmp</strong></a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is actually an interesting question, because it raises some useful ideas.</p>
<p>If, for example, paper-rock-scissors followed the laws of <a href="https://en.wikipedia.org/wiki/Inequality_(mathematics)" rel="nofollow noreferrer">mathematical inequality</a> it would be a trivial problem. Let's say <code>paper &gt; rock &gt; scissors</code> is <em>mathematically</em> true (i.e. <code>paper &gt; scissors</code>, contrary to the rules of the game):</p>
<pre><code>class fist(object):

   def __init__(self, weapon):
       WEAPON_VALUES = {'paper': 2, 'rock': 1, 'scissors': 0}
       self.weapon_value = WEAPON_VALUES[weapon]

   def __gt__(self, other):
       return self.weapon_value &gt; other.weapon_value

   def __lt__(self, other):
       return self.weapon_value &lt; other.weapon_value

   def __eq__(self, other):
       return self.weapon_value == other.weapon_value

   def __ne__(self, other):
       return self.weapon_value != other.weapon_value    

paper = fist('paper')

rock = fist('rock')

scissors = fist('scissors')
</code></pre>
<p>Now we can check:</p>
<pre><code>In [7]: paper &gt; rock
Out[7]: True

In [8]: rock == rock
Out[8]: True

In [9]: paper &lt; scissors
Out[9]: False

In [10]: scissors &lt; rock
Out[10]: True
</code></pre>
<p>Unfortunately, paper-rock-scissors has a circular logic, and so the usual concept of inequality doesn't work in this case (hence <code>paper &lt; scissors</code> evaluates to <code>False</code>).</p>
<p>You could use custom comparables <a href="https://stackoverflow.com/a/54257103">as explained in another answer</a>, but bear in mind that this raises paradoxes like <code>rock &gt; scissors &gt; paper == True</code> when of course <code>rock &lt; paper</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>What I would suggest in your case is to create a function that would return the winner. Something like</p>
<pre><code>def winner(J1, J2):
    if J1 == 'rock':
        if J2 == 'paper':
            return('J2')
        if J2 == 'rock':
            return('draw')
        if J2 == 'paper':
            return('J1')
    ...
</code></pre>
<p>That would allow you to see who wins.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can override the behavior of the <code>&gt;</code> operator by defining a <code>__gt__</code> method on the object. See the <a href="https://docs.python.org/3/reference/datamodel.html#object.__gt__" rel="nofollow noreferrer">documentation on the Python data model</a> for more information.</p>
</div>
<div class="post-text" itemprop="text">
<p>For a simple solution that doesn't involve redefining operators:</p>
<p>First define the rules of the game:</p>
<pre><code>rules = ['paper&gt;rock', 'rock&gt;scissors', 'scissors&gt;paper']
</code></pre>
<p>and use a function like this to check the data against the rules:</p>
<pre><code>def greater(opt1, opt2):
    if opt1 == opt2:
        return None # draw
    return "{0}&gt;{1}".format(opt1, opt2) in rules

&gt;&gt;&gt; greater('paper','rock')
True
&gt;&gt;&gt; greater('paper','scissors')
False
&gt;&gt;&gt; greater('rock','paper')
False
</code></pre>
</div>
<span class="comment-copy">Have you tried anything? It is always nice to us if you also show us the code you have tried.</span>
<span class="comment-copy">Note that this kind of thing is generally not a good idea, because you can't create a <a href="https://en.wikipedia.org/wiki/Total_order" rel="nofollow noreferrer">total order</a> over objects with these relationships. Basically, if you define <code>&gt;</code> as you describe, it would break other built-in mechanisms like <code>sort()</code> because the ordering is circular.</span>
<span class="comment-copy">Show us your code.</span>
<span class="comment-copy">could you explain this <code>class Paper(Comparable):     pass  class Rock(Comparable):     pass  class Scissors(Comparable):     pass</code></span>
<span class="comment-copy">@ikuro those simply generate 3 subclasses of <code>Comparable</code> that aren't really different from <code>Comparable</code> except they have different types. Because they have different types you can compare the types as done in <code>__cmp__</code>.</span>
<span class="comment-copy">I don't know why this is getting upvotes, it doesn't solve the problem as given by your own test case: <code>paper &lt; scissors == False</code>.</span>
<span class="comment-copy">@MarkRansom Yes I explained in the answer that this is for an example where paper &gt; rock &gt; scissors is <i>mathematically</i> true (i.e. paper &gt; scissors). And then explained why this approach wouldn't be recommended for the actual rules of paper-rock-scissors (inequality paradoxes). But perhaps it's not clear enough - do you have a suggestion for how I could communicate this more clearly?</span>
<span class="comment-copy">The paradox exists for <i>any</i> valid solution, I thought that was the best part of your answer. The problem I have is that it fails for some tests that <i>shouldn't</i> be paradoxes. I.E. you didn't answer the actual question.</span>
<span class="comment-copy">Sure, I wanted to run through why no solution was a sensible idea, because you break the concept of inequality as it is properly understood. I have now linked to the correct solution, so hopefully this serves as a useful addition to the accepted answer. I do understand your concerns, though. (My implicit answer to the actual question is: "don't do this".)</span>
