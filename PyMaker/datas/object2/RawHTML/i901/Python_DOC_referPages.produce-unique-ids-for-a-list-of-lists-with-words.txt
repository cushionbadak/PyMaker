<div class="post-text" itemprop="text">
<p>I have list of lists with pairs of words and want to depict words on ids. Ids should be from 0 till the len(set(words)). The list now looks like that:</p>
<pre><code>[['pluripotent', 'Scharte'],
 ['Halswirbel', 'pr√§ventiv'],
 ['Kleiber', 'Blauspecht'],
 ['Kleiber', 'Scheidung'],
 ['Nillenlutscher', 'Salzstangenlecker']]    
</code></pre>
<p>The result should have the same formats, but with ids instead. So for example:</p>
<pre><code>[[0, 1],
 [2, 3],
 [4, 5],
 [4, 6],
 [7, 8]]
</code></pre>
<p>I have till now this, but it doesn't give me the right output:</p>
<pre><code>def words_to_ids(labels):
  vocabulary = []
  word_to_id = {}
  ids = []
  for word1,word2 in labels:
      vocabulary.append(word1)
      vocabulary.append(word2)

  for i, word in enumerate(vocabulary):
      word_to_id [word] = i
  for word1,word2 in labels:
      ids.append([word_to_id [word1], word_to_id [word1]])
  print(ids)
</code></pre>
<p>Output: </p>
<pre><code>[[0, 0], [2, 2], [6, 6], [6, 6], [8, 8]]
</code></pre>
<p>It is repeating ids where there are unique words.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two errors. First, you have a simple typo, here:</p>
<pre><code>for word1,word2 in labels:
    ids.append([word_to_id [word1], word_to_id [word1]])
</code></pre>
<p>You are adding the id for <code>word1</code> <strong>twice</strong>, there. Correct the second <code>word1</code> to look up <code>word2</code> instead.</p>
<p>Next, you are not testing if you have seen a word before, so for <code>'Kleiber'</code> you first give it the id <code>4</code>, then overwrite that entry with <code>6</code> the next iteration. You need to give <em>unique</em> words numbers, not all words:</p>
<pre><code>counter = 0
for word in vocabulary:
    if word not in word_to_id:
        word_to_id[word] = counter
        counter += 1
</code></pre>
<p>or you could simply not add a word to <code>vocabulary</code> if you already have that word listed. You don't really need a separate <code>vocabulary</code> list here, by the way. A separate loop doesn't buy you anything, so the following works too:</p>
<pre><code>word_to_id = {}
counter = 0
for words in labels:
    for word in words:
        word_to_id [word] = counter
        counter += 1
</code></pre>
<p>You can simplify your code quite a bit by using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code> object</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count()</code></a> to supply default values:</p>
<pre><code>from collections import defaultdict
from itertools import count

def words_to_ids(labels):
    word_ids = defaultdict(count().__next__)
    return [[word_ids[w1], word_ids[w2]] for w1, w2 in labels]
</code></pre>
<p>The <code>count()</code> object gives you the next integer value in a series each time <code>__next__</code> is called, and <code>defaultdict()</code> will call that each time you try to access a key that doesn't yet exist in the dictionary. Together, they ensure a unique ID for each unique word.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two issues:</p>
<ol>
<li>You made a typo by repeating a lookup of <code>word1</code> in <code>word_to_id</code>.</li>
<li>When constructing your <code>word_to_id</code> dictionary you need to consider unique values only.</li>
</ol>
<p>For example, in Python 3.7+ you can take advantage of insertion-ordered dictionaries:</p>
<pre><code>for i, word in enumerate(dict.fromkeys(vocabulary)):
    word_to_id[word] = i

for word1, word2 in labels:
    ids.append([word_to_id[word1], word_to_id[word2]])
</code></pre>
<p>An alternative for versions pre-3.7 is to use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> or the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>unique_everseen</code> recipe</a>.</p>
<p>If there is no ordering requirement, you can just use <code>set(vocabulary)</code>.</p>
</div>
<span class="comment-copy">I'm assuming that you want to start at 0, given your attempted output. Feel free to correct these assumptions.</span>
<span class="comment-copy">oh, thanx. the only thing is, now i get [[0, 1], [2, 3], [6, 5], [6, 7], [8, 9]] So I ask me, what happens with number 4</span>
<span class="comment-copy">@NastjaKr: you gave <code>Kleiber</code> a number <i>twice</i>. I'll update.</span>
<span class="comment-copy">yes, some word appear in the list several time, but the id of it should be the same everywhere</span>
<span class="comment-copy">There is no requirement for the numbers to be ordered matching the input order, so <code>set()</code> <i>would</i> have sufficed.</span>
<span class="comment-copy">@MartijnPieters, Fair enough, <code>set</code> is fine then!</span>
