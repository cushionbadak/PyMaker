<div class="post-text" itemprop="text">
<p>I'm looking for a good pattern for how to implement Python sub-commands, where the main command looks up the subcommand at run time (instead of knowing the list of all possible sub-commands; this allows the "application" to be easily extended with new sub-commands without having to change the main code)</p>
<p>E.g:</p>
<pre><code> topcmd.py foo
</code></pre>
<p>will look in <code>/some/dir</code> for <code>foo.py</code> and if it exists, run it. Or some variation of it.</p>
<p>The code invoked in <code>foo.py</code> should preferably be a well-defined function or method on a class or object.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>__import__</code> function to dynamically import a module using a string name passed on the command line. </p>
<pre><code>mod = sys.argv[1]
command =__import__(mod)
# assuming your pattern has a run method defined. 
command.run()
</code></pre>
<p>Error handling, etc left as an exercise for the reader</p>
<p>Edit: This would depend on user plugins being installed via pip. If you want users to drop plugins into a folder without installing, then you would have to add that folder to your python path. </p>
</div>
<div class="post-text" itemprop="text">
<p>While this question is actually quite broad, there are sufficient tools available within a typical default Python installation (i.e. with <code>setuptools</code>) that this is relatively achievable, in a way that is actually extensible so that other packages can be created/installed in a manner that provide new, discoverable subcommands for your main program.</p>
<p>Your base package can provide a standard entry_point in the form of <a href="https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html#the-console-scripts-entry-point" rel="nofollow noreferrer"><code>console_scripts</code></a> that point to your entry point that will feed all arguments into an instance of some argument parser (such as <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a>), and some kind of registry which you might implement under a similar scheme as <code>console_scripts</code>, except under your specific entry_points group so that it would iterate through every entry and instantiate the objects that would also provide their own <code>ArgumentParser</code> instances which your main entry point would dynamically register to itself as a subcommand, thus showing your users what subcommands are actually available and what their invocation might be like.</p>
<p>To provide an example, in your main package's <code>setup.py</code>, you might have an entry like</p>
<pre><code>setup(
    name='my.package',
    # ...
    entry_points={
        'console_scripts': [
            'topcmd = my.package.runtime:main',
        ],
        'my.package.subcmd': [
            'subcmd1 = my.package.commands:subprog1',
            'subcmd2 = my.package.commands:subprog2',
        ],
    },
    # ...
)
</code></pre>
<p>Inside the <code>my/package/runtime.py</code> source file, a <code>main</code> method will have to construct a new ArgumentParser instance, and while iterating through the entry points provided by <code>pkg_resources.working_set</code>, for example:</p>
<pre><code>from pkg_resources import working_set

def init_parser(argparser):  # pass in the argparser provided by main
    commands = argparser.add_subparsers(dest='command')
    for entry_point in working_set.iter_entry_points('my.package.subcmd'):
        subparser = commands.add_parser(entry_point.name)
        # load can raise exception due to missing imports or error in object creation
        subcommand = entry_point.load()
        subcommand.init_parser(subparser) 
</code></pre>
<p>So in the <code>main</code> function, the argparser instance it created could be passed into a function like one in above, and the entry point <code>'subcmd1 = my.package.commands:subprog1'</code> will be loaded.  Inside <code>my/package/command.py</code>, an implemented <code>init_parser</code> method must be provided, which will take the provided subparser and populate it with the required arguments:</p>
<pre><code>class SubProgram1(object):
    def init_parser(self, argparser)
        argparser.add_argument(...) 

subprog1 = SubProgram1() 
</code></pre>
<p>Oh, one final thing, after passing in the arguments to the main <code>argparser.parse_args(...)</code>, the name of the command is provided to <code>argparser.command</code>.  It should be possible to change that to the actual instance, but that may or may not achieve what you exactly want (because the main program might want to do further work/validation before actually using the command).  That part is another complicated part, but at least the argument parser should contain the information required to actually run the correct subprogram.</p>
<p>Naturally, this includes absolutely no error checking, and it must be implemented in some form to prevent faulty subcommand classes from blowing up the main program.  I have made use of a pattern like this one (albeit with a lot more complex implementation) that can support an arbitrary amount of nested subcommand.  Also packages that want to implement custom commands can simply add their own entry to the entry point group (in this case, to <code>my.package.subcmd</code>) for their own <code>setup.py</code>.  For example:</p>
<pre><code>setup(
    name="some.other.package",
    # ...
    entry_points={
        'my.package.subcmd': [
            'extracmd = some.other.package.commands:extracmd',
        ],
    },
    # ...
)
</code></pre>
<p>Addendum:</p>
<p>As requested, an actual implementation that's used in production is in a package (<a href="https://pypi.org/project/calmjs/" rel="nofollow noreferrer">calmjs</a>) that I currently maintain.  Installing that package (into a virtualenv) and running <code>calmjs</code> on the command line should show a listing of subcommands identical to the entries defined in the main package's <a href="https://github.com/calmjs/calmjs/blob/3.3.1/setup.py#L68,L72" rel="nofollow noreferrer">entry points</a>.  Installing an additional package that extends the functionality (such as <a href="https://pypi.org/project/calmjs.webpack/" rel="nofollow noreferrer">calmjs.webpack</a>) and running <code>calmjs</code> again will now list <code>calmjs.webpack</code> as an additional subcommand.</p>
<p>The entry points references instances of subclasses to the <code>Runtime</code> class, and in it there is a place where <a href="https://github.com/calmjs/calmjs/blob/3.3.1/src/calmjs/runtime.py#L516,L517" rel="nofollow noreferrer">the subparser is added</a> and if satisfies registration requirements (many statements following that relate to various error/sanity checking, such as what to do when multiple packages define the same subcommand name for runtime instances, amongst other things), <a href="https://github.com/calmjs/calmjs/blob/3.3.1/src/calmjs/runtime.py#L424" rel="nofollow noreferrer">registered</a> to the argparser instance on that particular runtime instance, and the <a href="https://github.com/calmjs/calmjs/blob/3.3.1/src/calmjs/runtime.py#L443" rel="nofollow noreferrer">subparser is passed into the <code>init_argparser</code> method</a> of the runtime that encapsulates the subcommand.  As an example, the <code>calmjs webpack</code> subcommand subparser is set up by <a href="https://github.com/calmjs/calmjs.webpack/blob/1.2.0/src/calmjs/webpack/runtime.py#L65" rel="nofollow noreferrer">its <code>init_argparser</code></a> method, and that package <a href="https://github.com/calmjs/calmjs.webpack/blob/1.2.0/setup.py#L97" rel="nofollow noreferrer">registers the <code>webpack</code> subcommand</a> in its own <code>setup.py</code>.  (To play with them, please just simply use <code>pip</code> to install the relevant packages).</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest answer seems to be, if all my commands are in <code>foo.commands</code>:</p>
<pre><code>import foo.commands
import importlib

for importer, modname, ispkg in pkgutil.iter_modules(foo.commands.__path__):
    mod=importlib.import_module('foo.commands.' + cmd)
    mod.run()
</code></pre>
<p>This will run all the sub-commands. (Well, in the real code I will run just one. This is the howto.)</p>
</div>
<span class="comment-copy">Do you know about <code>argparse</code> ?</span>
<span class="comment-copy"><code>argparse</code> requires that the top command knows about all the subcommands, no? I'd like it to discover them at run-time.</span>
<span class="comment-copy">Mmmmm, this sound like a job for metaclasses.</span>
<span class="comment-copy">This sounds like a job for dictionaries or os</span>
<span class="comment-copy">In that direction, I discovered importlib: <a href="https://docs.python.org/3.5/library/importlib.html#importlib.import_module" rel="nofollow noreferrer">docs.python.org/3.5/library/â€¦</a></span>
<span class="comment-copy">This solution would require changing the main code in setup.py when someone wanted to add a plugin wouldn't it?</span>
<span class="comment-copy">@JoshJ Not necessary, the external package will add their own entry points to their own <code>setup.py</code> which the default <code>iter_entry_points</code> function will pick up, which means that <code>topcmd</code> will see the new command. Added an example to illustrate how this might look for the other package.</span>
<span class="comment-copy">@JoshJ Also, I have actually used this pattern (though with a lot more code than this) in a number of packages to implement subcommands for a main program that I have on production on PyPI already, and end-users only get the additional commands if they also install the extra packages, and those entry points are defined only in the relevant packages. Not linking directly to not appear as self-promotion, but I will link if requested.</span>
<span class="comment-copy">@metatoaster by all means, provide the link: I'm looking for code I don't have to write myself :-)</span>
<span class="comment-copy">@JohannesErnst I don't have the related classes decoupled to a separate package, due to work/lack of time required for separating related code into a new package. Note that it has error checking for cases which may not be required your needs (like that recursive definition check; this set of classes is generic enough so that a system of nested of subcommands may be defined provided certain rules are followed). Please feel free to use the linked code as a guide on how you might want to build your system, should you wish to support a use case in a similar manner. Links appended as addendum.</span>
