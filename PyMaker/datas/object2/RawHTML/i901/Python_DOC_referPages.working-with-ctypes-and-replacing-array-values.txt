<div class="post-text" itemprop="text">
<p>I am working on modifying a python wrapper using ctypes found here:
<a href="https://github.com/Grix/helios_dac/blob/master/sdk/examples/python/linux_example.py" rel="nofollow noreferrer">https://github.com/Grix/helios_dac/blob/master/sdk/examples/python/linux_example.py</a></p>
<p>I am using the logic of mutability and passing by reference of usual python code and the code no longer works if I change the lines 33 and 39:</p>
<pre><code>for j, f in enumerate(frames[i]):
    if (j &lt; 500):
        x = round(j * 0xFFF / 500)
    else:
        x = round(0xFFF - ((j - 500) * 0xFFF / 500))

    f = HeliosPoint(int(x),int(y),255,255,255,255)
</code></pre>
<p>Can someone explain why? Is f not equivalent to frames[i][j]?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">[Python 3]: The for statement</a>:</p>
<blockquote>
<p>The for-loop makes assignments to the variables(s) in the target list. This overwrites all previous assignments to those variables including those made in the suite of the for-loop:</p>
<pre class="lang-py prettyprint-override"><code>for i in range(10):
    print(i)
    i = 5             # this will not affect the for-loop
                      # because i will be overwritten with the next
                      # index in the range
</code></pre>
</blockquote>
<p>I'll present a simpler example, and then extend to yours.</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; l = [1, 2, 3]
&gt;&gt;&gt; for i in l:
...     i += 5
...     print(i)
...
6
7
8
&gt;&gt;&gt; print(l)
[1, 2, 3]
</code></pre>
</blockquote>
<p>The same code but without the loop would be:</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; i = l[0]
&gt;&gt;&gt; i += 5
&gt;&gt;&gt; print(i)
6
&gt;&gt;&gt; i = l[1]
&gt;&gt;&gt; i += 5
&gt;&gt;&gt; print(i)
7
&gt;&gt;&gt; i = l[2]
&gt;&gt;&gt; i += 5
&gt;&gt;&gt; print(i)
8
&gt;&gt;&gt; print(l)
[1, 2, 3]
</code></pre>
</blockquote>
<p>As seen, assigning another value to the looping variable, <strong>doesn't change the original value</strong>. This can be put even simpler:</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; some_variable = 1
&gt;&gt;&gt; some_variable
1
&gt;&gt;&gt; some_other_variable = some_variable
&gt;&gt;&gt; some_other_variable  # Here it will have value 1
1
&gt;&gt;&gt; some_other_variable = 2  #  The value will change, but it won't affect `some_variable`
&gt;&gt;&gt; some_other_variable
2
&gt;&gt;&gt; some_variable  # Its value is unchanged
1
</code></pre>
</blockquote>
<p>To change the values in the list while iterating, one way would be using <em>enumerate</em> (as you're already using it in your code):</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; l
[1, 2, 3]
&gt;&gt;&gt; for idx, elem in enumerate(l):
...     l[idx] = elem + 5
...
&gt;&gt;&gt; print(l)
[6, 7, 8]
</code></pre>
</blockquote>
<p>Applying the same principle to your problem: the last line in your snippet:</p>
<pre class="lang-py prettyprint-override"><code>f = HeliosPoint(int(x),int(y),255,255,255,255)
</code></pre>
<p>should become:</p>
<pre class="lang-py prettyprint-override"><code>frames[i][j] = HeliosPoint(int(x), int(y), 255, 255, 255, 255)
</code></pre>
</div>
<span class="comment-copy">In the last line, you only assign a new value to <i>f</i>, but that <b>doesn't change</b> <i>f</i>'s <b>old</b> value (<code>frames[i][j]</code>). Same thing as: <code>for item in [1, 2, 3]: item = 5</code>.</span>
<span class="comment-copy">please answer so I can accept. Thanks!</span>
<span class="comment-copy">Thanks for notifying me. I will, most likely tomorrow.</span>
<span class="comment-copy">So, did this answer your question?</span>
