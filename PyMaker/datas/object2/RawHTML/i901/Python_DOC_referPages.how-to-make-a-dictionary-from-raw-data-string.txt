<div class="post-text" itemprop="text">
<p>Essentially I need to create a dictionary from a string of data</p>
<p>Given :</p>
<pre><code>data = "electron1, gamma5, proton43, boson98, ..."
</code></pre>
<p><code>d(data)</code> would result in:</p>
<pre><code>{'electron':1, 'gamma':5, 'proton':43, 'boson':98, ...}
</code></pre>
<p>My current code is showing an error message of "base 10..."</p>
<pre><code>def d(n):
        pair = dict()
        for i in range(0,n):
                word = input().split()
                key = word[0]
                value = word[1]
                pair[key]=value
        print(pair)

n = int(input())          
d ={}                     
for i in range(n):        
    text = input().split()
    d[text[0]] = text[1]
print(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do that with a regular expression and a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> like:</p>
<h3>Code:</h3>
<pre><code>END_NUMS_RE = re.compile(r'^(\D+)(\d+)$')
dict(END_NUMS_RE.match(x.strip()).groups() for x in data.split(','))
</code></pre>
<h3>Test Code:</h3>
<pre><code>import re
END_NUMS_RE = re.compile(r'^(\D+)(\d+)$')
data = "electron1, gamma5, proton43, boson98"
print(dict(END_NUMS_RE.match(x.strip()).groups() for x in data.split(',')))
</code></pre>
<h3>Results:</h3>
<pre><code>{'electron': '1', 'gamma': '5', 'proton': '43', 'boson': '98'}
</code></pre>
<h3>But! A Regex:</h3>
<p>So for those that are concerned about using a regex:</p>
<p>Let's benchmark a regex answer vs the second most voted answer here:</p>
<pre><code>import re
END_NUMS_RE = re.compile(r'^(\D+)(\d+)$')
data = "electron1, gamma5, proton43, boson98"

def method1():
    return dict(END_NUMS_RE.match(x.strip()).groups()
                for x in data.split(','))

def method2():
    l = data.split(',')
    return {
        ''.join(
            [x for x in item if not x.isdigit()]):
            int(''.join([x for x in item if x.isdigit()])) for item in l
    }


from timeit import timeit
print(timeit(method1, number=10000))
print(timeit(method2, number=10000))
</code></pre>
<h3>Timing Results:</h3>
<pre><code>0.05789754982012146
0.10536237238963242
</code></pre>
<p>The regex answer is twice as fast.</p>
</div>
<div class="post-text" itemprop="text">
<p>An approach without re</p>
<pre><code>Data = "electron1, gamma5, proton43, boson98"
l=Data.split(',')
d={''.join([x for x in item if not x.isdigit()]):int(''.join([x for x in item if x.isdigit()])) for item in l}
print(d)
</code></pre>
<p>Output</p>
<pre><code>{'electron': 1, ' gamma': 5, ' proton': 43, ' boson': 98}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of different ways you could do this.  If you know your list all has entries in the form of strings ending in some numbers, and you want to split those into keys and values in the form of <code>&lt;non_numerical_string&gt;: &lt;integer&gt;</code>, then here's one way to build off of what you have without using regular expressions:</p>
<pre><code>def d(original_string):
    data_dict = {}

    for item in original_string.split(', '):
        for t in enumerate(item):
            if t[1].isdigit():
                split_pos = t[0]
                break
        data_dict[item[:split_pos]] = int(item[split_pos:])

    return data_dict

data = "electron1, gamma5, proton43, boson98"
print(d(data))
</code></pre>
<p>In your original example, <code>n = int(input())</code> takes the user input and tries to transform all of it into an integer.  Later on, when you use <code>.split()</code> on the string, this breaks it up by spaces, but that means the commas are part of the individual strings of your new list.  So passing in "<code>(", ")</code>" gives you the split you want (though this means your original string has to have everything separated by commas and a space!).</p>
<p>The <code>enumerate(item)</code> part takes a string like <code>boson98</code> and returns an object that can be treated like the list <code>[(0, 'b'), (1, 'o'), (2, 's'), (3, 'o'), (4, 'n'), (5, '3'), (6, '8')]</code>.  Though personally I prefer the simplicity of a regexp.</p>
</div>
<span class="comment-copy">Do you have a question? What have you tried so far?</span>
<span class="comment-copy">@roganjosh Thank you, but is there a solution without importing anything?</span>
<span class="comment-copy">@Lana, homework?</span>
<span class="comment-copy">@Lana I misread the question. My original comments on this answer don't stand and I have no alternative to give. <code>re</code> is part of the standard library.</span>
<span class="comment-copy">Nice!  I like how condense this is without using regexp.</span>
