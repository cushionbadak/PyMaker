<div class="post-text" itemprop="text">
<p>Recently, I've been trying to figure out a 20 by 20 square grid. so far I've only figured out how to draw 4 no matter what I put as my # of. it would be greatly appreciated if someone can figure out my flaws in the code!</p>
<p>what I'm trying to achieve</p>
<p><a href="https://i.stack.imgur.com/uyN2t.png" rel="nofollow noreferrer"><img alt="what I'm trying to achieve" src="https://i.stack.imgur.com/uyN2t.png"/></a></p>
<p><strong>my code</strong></p>
<pre><code>import turtle
turtle.hideturtle()
t = turtle.Turtle()
t.hideturtle()

def draw_square(t, size, num, angle):

for i in range(num):
    for x in range(4):
        turtle.forward(size)
        turtle.left(90)
    turtle.right(angle)

draw_square(t, 25, 4, 90)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your main problem is that you turn the turtle 90 degrees left after every square.  This means that you'll simply make the same 4 squares over and over.</p>
<p>Instead, you have to advance the turtle <code>size</code> units and draw the next square.  Do this 20 times; <em>then</em> you can go to the next row.</p>
<p>For this, I suggest that you write a loop to draw one row.  Then write a few lines to come back to the starting point, but down <code>size</code> units.  Loop on that process 20 times.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an interesting approach I did that draws rows and then columns:</p>
<pre><code>import turtle as tur


def make_grid(rows, columns):
    tur.color('black', 'white')
    tur.begin_fill()
    dir = 1
    tur.forward(20 * columns)
    for _ in range(rows):
        if dir &gt; 0:
            tur.right(90)
            tur.forward(20)
            tur.right(90)
            tur.forward(20 * columns)
        else:
            tur.left(90)
            tur.forward(20)
            tur.left(90)
            tur.forward(20 * columns)
        dir *= -1
    tur.penup()
    tur.home()
    tur.pendown()
    tur.right(90)
    dir = 1
    tur.forward(20 * rows)
    for _ in range(columns):
        if dir &gt; 0:
            tur.left(90)
            tur.forward(20)
            tur.left(90)
            tur.forward(20 * rows)
        else:
            tur.right(90)
            tur.forward(20)
            tur.right(90)
            tur.forward(20 * rows)
        dir *= -1
    tur.end_fill()
    tur.done()


make_grid(10, 10)
</code></pre>
<p>I think it's more fun to watch like this, as opposed to making a bunch of squares in a row. Obviously it could be improved with an adjustable square size though...</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few ways to draw a 20 x 20 grid with Python, here are a couple:</p>
<p>Using turtle:</p>
<pre><code>import turtle

def draw_box(t,x,y,size,fill_color):
    t.penup() # don't draw
    t.goto(x,y) # move to position
    t.pendown() # draw

    t.fillcolor(fill_color)
    t.begin_fill()  # set fill color

    for i in range(0,4):
        grid.forward(size) # move forward
        grid.right(90) # turn right 90 degrees

    t.end_fill()


def draw_grid():
    fill_color = 'white'
    start_x = -320 # starting x position of the grid
    start_y = -100 # starting y position of the grid
    box_size = 30 # pixel size of each square in the grid
    for i in range(0,20): # 20x20 grid
        for j in range(0,20):
            draw_box(grid,start_x+j*box_size,start_y+i*box_size,box_size,fill_color)


grid = turtle.Turtle()
draw_grid()
turtle.done()
</code></pre>
<p>Using pillow (PIL):</p>
<pre><code>from PIL import Image, ImageDraw

def main():
    steps = 25
    height = 600
    width = 600
    img = Image.new(mode='L', size=(height, width), color=255) # create blank image
    # img = Image.open('filename.png') # or load an image

    draw = ImageDraw.Draw(img)
    y_start = 0
    y_end = img.height
    step_size = int(img.width / steps)

    for x in range(0, img.width, step_size):
        line = ((x, y_start), (x, y_end))
        draw.line(line, fill='black')

    x_start = 0
    x_end = img.width

    for y in range(0, img.height, step_size):
        line = ((x_start, y), (x_end, y))
        draw.line(line, fill='black')

    del draw
    img.show()


if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code has a <em>pair</em> of nested loops.  However, given the way you're drawing the grid, you really need <em>three</em> nested loops.  Trying to figure out the least amount of code to get from where you are to where you want to be, I came up with the following:</p>
<pre><code>from turtle import Screen, Turtle

def draw_square(turtle, size, num):
    for y in range(num):
        for x in range(num):
            for _ in range(4):
                turtle.forward(size)
                turtle.left(90)

            turtle.forward(size)

        parity = y % 2 == 0
        turn = turtle.left if parity else turtle.right

        turn(90)
        turtle.forward(size * 2 * parity)
        turn(90)

screen = Screen()

yertle = Turtle(visible=False)
yertle.speed('fastest')  # because I have no patience

draw_square(yertle, 25, 20)

screen.exitonclick()
</code></pre>
<p>This code is inefficient drawing-wise as the same lines get redrawn which is something to be avoided.  My personal favorite solution to this problem is my <em>Tholian Web</em> approach using generators:</p>
<pre><code>from turtle import Turtle, Screen

UNIT_SIZE, GRID_SQUARES = 25, 20

GRID_SIZE = GRID_SQUARES * UNIT_SIZE

def half_grid(turtle):
    speed = turtle.speed()

    for brick in range(GRID_SQUARES):
        direction = [turtle.right, turtle.left][brick % 2 == 1]

        for _ in range(0, GRID_SIZE, speed):
            turtle.forward(speed)
            yield(0)

        direction(90)

        for _ in range(0, UNIT_SIZE, speed):
            turtle.forward(speed)
            yield(0)

        direction(90)

    for _ in range(0, GRID_SIZE, speed):
        turtle.forward(speed)
        yield(0)

heckle = Turtle(shape='arrow')
heckle.speed(5)  # speed needs to be a factor of UNIT_SIZE
heckle.penup()
heckle.goto(-GRID_SIZE / 2, -GRID_SIZE / 2)
heckle.pendown()
heckle.left(90)

jeckle = Turtle(shape='arrow')
jeckle.speed(5)
jeckle.penup()
jeckle.goto(GRID_SIZE / 2, -GRID_SIZE / 2)
jeckle.pendown()
jeckle.left(180)

generator1, generator2 = half_grid(heckle), half_grid(jeckle)

while (next(generator1, 1) + next(generator2, 1) &lt; 2):
    pass

heckle.hideturtle()
jeckle.hideturtle()

screen = Screen()
screen.exitonclick()
</code></pre>
<p><a href="https://i.stack.imgur.com/H9BBy.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/H9BBy.png"/></a></p>
<p>But that's probably overkill for your purposes...</p>
</div>
<span class="comment-copy">This is a good start!  It's clear to me why the turtle can only make 4 squares.  What path is the turtle taking?  Can you trace it out by hand on a piece of paper by following the steps that the code will take?</span>
