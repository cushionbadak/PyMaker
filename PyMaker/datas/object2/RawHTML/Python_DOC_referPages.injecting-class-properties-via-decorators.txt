<div class="post-text" itemprop="text">
<p>I have a whole bunch of Django TestCases that use the setUp method to initialize some properties that are used throughout numerous tests, the way they're constructed and depend on each other is logic I want to move out of the test cases and reuse</p>
<pre><code>def setUp(self):
    self.property_1 = ##some logic
    ...
</code></pre>
<p>I wanted to rewrite these as some convenience wrapper that could be injected into the class with a simple inheritance or decorator, e.g.</p>
<pre><code>@with_property_1(x=1, y=2)
def setUp(self):
    ...


def with_property_1(**model_kwargs):
    def wrapper(f):
        def wrapped(*args, **kwargs):
            self = args[0]
            self.property_1 = ## logic
            f(*args, **kwargs)
        return wrapped
    return wrapper
</code></pre>
<p>but the trouble is that PyCharm doesn't recognize that those instance properties exist because nothing inside the TestCase class proper ever sets them. Is there a either another way I can achieve this nicely, or a way to cajole PyCharm into recognizing these properties are legitimate given the existence of the decorator?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Disclaimer: this is untested.</em></p>
<p>The issue here is that Python cannot just magically put <code>self</code> into context in the decorator (that will not work in any IDE). What you may be forgetting is that <code>self</code> is one of the arguments passed into each class method when you call it. Therefore, it's present in your <code>*args</code> and you can manipulate it.</p>
<p>Here's my trial code:</p>
<pre><code>def with_property_1(**model_kwargs):
  def wrapper(f):
    def wrapped(*args, **kwargs):
      for key, value in model_kwargs.items():
        setattr(args[0], key, value)
      f(*args, **kwargs)
    return wrapped
  return wrapper
</code></pre>
<p>Explanation:</p>
<ol>
<li><p>Iterate over each key/value in your <code>**model_kwargs</code>.</p></li>
<li><p>Modify <code>args[0]</code>, which should be the <code>self</code> variable, with the kwargs that were provided, using <code>setattr</code>.</p></li>
<li><p>Call the function as normal with your updated <code>self</code> variable.</p></li>
</ol>
<p>Hopefully this helped you. Great question!</p>
</div>
<span class="comment-copy">Maybe its better to use something third party such as <a href="https://factoryboy.readthedocs.io/en/latest/introduction.html" rel="nofollow noreferrer">factoryboy.readthedocs.io/en/latest/introduction.html</a></span>
<span class="comment-copy">@ruddra That seems like complete overkill for this situation.</span>
<span class="comment-copy">I missed that line out of my code, sorry. I was already using args[0] as the instance of the class. The question was more related to using <code>self.property_1</code> in the Class itself, where PyCharm gives a compile warning, since it can't see the property being set anywhere</span>
