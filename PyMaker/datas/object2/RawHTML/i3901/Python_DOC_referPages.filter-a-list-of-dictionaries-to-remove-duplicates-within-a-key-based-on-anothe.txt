<div class="post-text" itemprop="text">
<p>I have a list of dictionaries in Python 3.5.2 that I am attempting to "deduplicate". All of the dictionaries are unique, but there is a specific key I would like to deduplicate on, keeping the dictionary with the most non-null values.</p>
<p>For example, I have the following list of dictionaries:</p>
<pre><code>d1 = {"id":"a", "foo":"bar", "baz":"bat"}
d2 = {"id":"b", "foo":"bar", "baz":None}
d3 = {"id":"a", "foo":"bar", "baz":None}
d4 = {"id":"b", "foo":"bar", "baz":"bat"}
l = [d1, d2, d3, d4]
</code></pre>
<p>I would like to filter <code>l</code> to just dictionaries with unique <code>id</code> keys, keeping the dictionary that has the fewest nulls. In this case the function should keep <code>d1</code> and <code>d4</code>.</p>
<p>What I attempted was to create a new key,val pair for "value count" like so:</p>
<pre><code>for d in l:
    d['val_count'] = len(set([v for v in d.values() if v]))
</code></pre>
<p>now what I am stuck on is how to go about filtering my list of dicts for unique <code>ids</code> where the <code>val_count</code> key is the greater value.</p>
<p>I am open to other approaches, but I am unable to use <code>pandas</code> for this project due to resource constraints.</p>
<p>Expected output:</p>
<pre><code>l = [{"id":"a", "foo":"bar", "baz":"bat"},
 {"id":"b", "foo":"bar", "baz":"bat"}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a> and just pick the first one from each group:</p>
<p>1) First sort your list by key (to create the groups) and descending count of nulls (your stated goal):</p>
<pre><code>&gt;&gt;&gt; l2=sorted(l, key=lambda d: (d['id'], -sum(1 for v in d.values() if v))) 
</code></pre>
<p>2) Then group by <code>id</code> and take the first element of each iterator presented as <code>d</code> in the groupby on the sorted list:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [next(d) for _,d in groupby(l2, key=lambda _d: _d['id'])]
[{'id': 'a', 'foo': 'bar', 'baz': 'bat'}, {'id': 'b', 'foo': 'bar', 'baz': 'bat'}]
</code></pre>
<p>If you want a 'tie breaker' to select the first dict if otherwise they have the same null count, you can add an enumerate decorator:</p>
<pre><code>&gt;&gt;&gt; l2=sorted(enumerate(l), key=lambda t: (t[1]['id'], t[0], -sum(1 for v in t[1].values() if v)))
&gt;&gt;&gt; [next(d)[1] for _,d in groupby(l2, key=lambda t: t[1]['id'])]
</code></pre>
<p>I doubt that additional step is <em>actually</em> necessary though since Python's sort (and <code>sorted</code>) is a <a href="https://stackoverflow.com/q/1915376/298607">stable sort</a> and the sequence will only change from list order based on the key and void counts. So use the first version unless you are sure you need to use the second. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you are open to using a 3rd party library, you can sort by number of <code>None</code> values and then feed into <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="nofollow noreferrer"><code>toolz.unique</code></a>:</p>
<pre><code>from toolz import unique
from operator import itemgetter

l_sorted = sorted(l, key=lambda x: sum(v is None for v in x.values()))
res = list(unique(l_sorted, key=itemgetter('id')))

[{'baz': 'bat', 'foo': 'bar', 'id': 'a'},
 {'baz': 'bat', 'foo': 'bar', 'id': 'b'}]
</code></pre>
<p>If you cannot use <code>toolz</code>, the <a href="https://toolz.readthedocs.io/en/latest/_modules/toolz/itertoolz.html#unique" rel="nofollow noreferrer">source code</a> is small enough to implement yourself.</p>
<hr/>
<p><strong>Performance benchmarking</strong></p>
<p>I have only included solutions which give exactly one result per id. Many solutions do not cater for a duplicate dictionary.</p>
<pre><code>l = [d1, d2, d3, d4]*1000

%timeit dawg(l)  # 11.4 ms
%timeit jpp(l)   # 7.91 ms
%timeit tsw(l)   # 4.23 s

from operator import itemgetter
from itertools import groupby
from toolz import unique

def dawg(l):
    l2=sorted(enumerate(l), key=lambda t: (t[1]['id'], -sum(1 for v in t[1].values() if v), t[0]))
    return [next(d)[1] for _,d in groupby(l2, key=lambda t: t[1]['id'])]

def jpp(l):
    l_sorted = sorted(l, key=lambda x: sum(v is None for v in x.values()))
    return list(unique(l_sorted, key=itemgetter('id')))

def tsw(l):
    for d in l:
        d['val_count'] = len(set([v for v in d.values() if v]))
    new = [d for d in l if d['val_count'] == max([d_other['val_count'] for d_other in l if d_other['id'] == d['id']])]
    return [x for i, x in enumerate(new) if x['id'] not in {y['id'] for y in new[:i]}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>max</code>:</p>
<pre><code>d1 = {"id":"a", "foo":"bar", "baz":"bat"}
d2 = {"id":"b", "foo":"bar", "baz":None}
d3 = {"id":"a", "foo":"bar", "baz":None}
d4 = {"id":"b", "foo":"bar", "baz":"bat"}
l = [d1, d2, d3, d4]
max_none = max(sum(c is None for c in i.values()) for i in l)
new_l = [i for i in l if sum(c is None for c in i.values()) &lt; max_none]
</code></pre>
<p>Output:</p>
<pre><code>[{'foo': 'bar', 'baz': 'bat', 'id': 'a'}, {'foo': 'bar', 'baz': 'bat', 'id': 'b'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way using a list comprehension which uses the <code>'val_count'</code> values which you've already calculated:</p>
<pre><code>new = [d for d in l if d['val_count'] == max([d_other['val_count'] for d_other in l if d_other['id'] == d['id']])]
</code></pre>
<p>Giving:</p>
<pre><code>[{'baz': 'bat', 'foo': 'bar', 'id': 'a', 'val_count': 3},
 {'baz': 'bat', 'foo': 'bar', 'id': 'b', 'val_count': 3}]
</code></pre>
<p>This works by comparing the current dictionary's <code>'val_count'</code> to the maximum '<code>val_count'</code> of all dictionaries with the same <code>'id'</code>. Note that in the case of ties, all dictionaries which have the max <code>'val_count'</code> are kept. </p>
<p>The following line should handle ties, keeping the first instance of a certain <code>'id'</code> only:</p>
<pre><code>final = [x for i, x in enumerate(new) if x['id'] not in {y['id'] for y in new[:i]}]
</code></pre>
<p>There will almost certainly be more efficient ways to solve this problem, but this should at least work and may be suitable for your needs depending on the size of your dataset. </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>@cdc200</strong>, you can try the below code. Here I have used the concept of dictionary.</p>
<blockquote>
<p><strong>Note</strong>» Dictionary is defined as an unordered collection of data items with unique keys.</p>
<p>I have used <strong>OrderedDict ()</strong> in place of <strong>dict()</strong> to preserve the order of keys. Check this nice little article   <a href="https://www.google.co.in/amp/s/www.geeksforgeeks.org/ordereddict-in-python/amp/" rel="nofollow noreferrer">OrderedDict in Python - GeeksforGeeks</a>.</p>
</blockquote>
<pre><code>import json
from collections import OrderedDict

d1 = {"id":"a", "foo":"bar", "baz":"bat"}
d2 = {"id":"b", "foo":"bar", "baz":None}
d3 = {"id":"a", "foo":"bar", "baz":None}
d4 = {"id":"b", "foo":"bar", "baz":"bat"}
l = [d1, d2, d3, d4]

d = OrderedDict ();

for index, item in enumerate(l):
    if item["id"] not in d:
        d[item["id"]] =item
    else:
        nones1, nones2 = 0, 0
        for k in item:
            if item[k] is None:
                 nones1 = nones1 + 1
            if d[item["id"]][k] is None:
                 nones2 = nones2 + 1

        if nones2 &gt; nones1:
            d[item["id"]] = item

l = [dict_item for dict_item in d.values()]

print (l)

"""
{'foo': 'bar', 'id': 'a', 'baz': 'bat'}, {'foo': 'bar', 'id': 'b', 'baz': 'bat'}]
"""

# Pretty printing the above dictionary
print(json.dumps(l, indent=4))

"""
[
    {
        "foo": "bar",
        "id": "a",
        "baz": "bat"
    },
    {
        "foo": "bar",
        "id": "b",
        "baz": "bat"
    }
]
"""
</code></pre>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do like this:</p>
<pre><code>num = [list(x.values()).count(None) for x in l]
ls = [x for _,x in sorted(zip(num, l), key=lambda z: z[0])]
</code></pre>
<p>Then keep as many values as you want from the sorted list (<code>ls</code>).</p>
<p>For example, in order to keep only those dictionaries with the highest number non-<code>None</code> values (all dictionaries with <em>the same</em> number of non-<code>None</code>s), you can do this:</p>
<pre><code>num = [list(x.values()).count(None) for x in l]
ls, ns = zip(*[(x, d) for d, x in sorted(zip(num, l), key=lambda z: z[0])])
top_l = ls[:list(reversed(ns)).index(ns[0])]
</code></pre>
<hr/>
<p><strong>EDIT:</strong> Based on <a href="https://stackoverflow.com/questions/50453416/filter-a-list-of-dictionaries-to-remove-duplicates-within-a-key-based-on-anothe/50453920#comment87930542_50453920">@jpp's comment</a>, I have updated my code to take care of duplicate <code>id</code> keys. Here is the updated code:</p>
<pre><code>def agn(l):
    num = [list(x.values()).count(None) for x in l]
    ls, ns = zip(*[(x, d) for d, x in sorted(zip(num, l), key=lambda z: z[0])])
    top_l = ls[:list(reversed(ns)).index(ns[0])]
    return list(dict((d['id'], d) for d in top_l).values())
</code></pre>
<p>Let's also add timing comparison using the same definitions and setup as in <a href="https://stackoverflow.com/a/50458138">@jpp's answer</a>:</p>
<pre><code>In [113]: %timeit tsw(l)
3.9 s ± 60.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [114]: %timeit dawg(l)
7.48 ms ± 191 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

In [115]: %timeit jpp(l)
5.83 ms ± 104 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

In [116]: %timeit agn(l)
4.58 ms ± 86.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<span class="comment-copy">It would be helpful if you could provide an example of expected output. The description of you <i>unsuccessful</i> attempt does not hurt but in this case it does not help much.</span>
<span class="comment-copy">@AGNGazer I will make an update to make it more clear but I included this in the post:  <code>In this case the function should keep d1 and d4.</code></span>
<span class="comment-copy">What should happen when all <code>d</code>s have the same number of <code>None</code> or when all <code>d</code>s contain at least one <code>None</code>?</span>
<span class="comment-copy">@AGNGazer I am open to keeping just the first occurrence in this case.</span>
<span class="comment-copy">Nice, I like the use of <code>next</code>. Performs well too, +1.</span>
<span class="comment-copy">This definitely performed the best of all answers. Thank you!</span>
<span class="comment-copy">@dawg what is the purpose of the underscores?</span>
<span class="comment-copy">@cdc200: <i>what is the purpose of the underscores?</i> <code>grouby</code> returns a key and an iterator to the items grouped by that key. Since we are not using the key in this case, it is a common Python idiom to use <code>_</code> as a throw away place holder. The other underscore for <code>_d</code> is a compact way of having a different <code>_d</code> vs <code>d</code>. Some versions of Python do not separate the namespace of the lambda from the surrounding comprehension and bad things can happen if you unexpectedly change a loop variable.</span>
<span class="comment-copy">I am a sucker for benchmarks. Thanks for that. For apples to apples however, you would use the non enumerated version from my answer since the <code>tool.unique</code> is also not enumerated. That makes the time a little faster on the <code>dawg</code> version...</span>
<span class="comment-copy">to clarify, I am looking for a solution that picks the dictionary with the <code>fewest</code> null/None values, meaning I could potentially keep a dictionary with None if the duplicate id key dictionary had more Nones. Would this still work in that case?</span>
<span class="comment-copy">@cdc200 Please see my recent edit.</span>
<span class="comment-copy">Why the downvote?</span>
<span class="comment-copy">@Ajax1234, No idea, but I hate to see an unexplained downvote. So +1.</span>
<span class="comment-copy">Fyi, this solution doesn't seem to deal with duplicate dictionaries (i.e. the same dictionary repeated will get output twice).</span>
<span class="comment-copy">do you have any suggestions for how to break a tie?</span>
<span class="comment-copy">@cdc200 - please see edit for a way to keep only the first instance of a certain <code>'id'</code> in case of ties.</span>
<span class="comment-copy">This solution is inefficient for large lists (see <a href="https://stackoverflow.com/a/50458138/9209546">benchmarking</a>).</span>
<span class="comment-copy">@jpp - yes that's not surprising, this was a bit of a quick 'thinking out loud' solution because at the time I wrote it the other solutions were not yielding the correct results. Solutions posted since are clearly better.</span>
<span class="comment-copy">Would be nice if you actually explained what you are doing with the concepts you mention.</span>
<span class="comment-copy">@jpp I have updated my solution to eliminate duplicates. Didn't notice this requirement before. Thanks!</span>
