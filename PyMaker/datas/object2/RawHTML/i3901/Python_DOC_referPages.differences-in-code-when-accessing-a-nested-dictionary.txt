<div class="post-text" itemprop="text">
<pre><code>def extract_full_name(names):

    firstname = []
    lastname = []
    for z in range(0,len(names)):
        firstname.append(names[z]['first'])
    for k in range(0,len(names)):
        lastname.append(names[k]['last'])

    return list(zip(firstname,lastname))
</code></pre>
<p>VS </p>
<pre><code>def extract_full_name(l):
     return list(map(lambda val: "{} {}".format(val['first'], val['last']), l))
</code></pre>
<p>SO I am doing this course on udemy and it requires me to do something like this:</p>
<pre><code>names = [{'first': 'Elie', 'last': 'Schoppik'}, {'first': 'Colt', 'last': 'Steele'}]
extract_full_name(names) # ['Elie Schoppik', 'Colt Steele']
</code></pre>
<p>What is the difference in my code and Colt's solution</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's build upon what you have done:</p>
<ol>
<li><p>In python, sequences are iterable with a for loop. When you don't need the index, don't count it:</p>
<pre><code>def extract_full_name(names):
    firstname = []
    lastname = []
    for item in names:
        firstname.append(item['first'])
    for item in names:
        lastname.append(item['last'])
    return list(zip(firstname,lastname))
</code></pre></li>
<li><p>To simply generate a list out of another one, you may use a <a href="https://stackoverflow.com/questions/34835951/what-does-list-comprehension-mean-how-does-it-work-and-how-can-i-use-it"><strong>list comprehension</strong></a>:</p>
<pre><code>def extract_full_name(names):
    firstname = [item['first'] for item in names]
    lastname = [item['last'] for item in names]
    return list(zip(firstname,lastname))
</code></pre></li>
<li><p>Since you iterate twice the same sequence we could also avoid the <code>zip</code> by combining as we go:</p>
<pre><code>def extract_full_name(names):
    return [(item['first'], item['last']) for item in names]
</code></pre></li>
<li><p>Now, let's fix the mistake in your output: you output each full name as a 2-tuple containing two strings (the first name and the last name). Let's <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer"><strong>format</strong></a> them into a full name instead:</p>
<pre><code>def extract_full_name(names):
    return ['{} {}'.format(item['first'], item['last']) for item in names]
</code></pre>
<p>That version is pretty much the one that confuses you, but it uses a list comprehension instead of <code>map</code>.</p></li>
<li><p><strong><em>[bonus]</em></strong> Since we use format, we could also use its <a href="https://docs.python.org/3/library/string.html#formatspec" rel="nofollow noreferrer"><strong>rich syntax</strong></a> to access item's entries:</p>
<pre><code>def extract_full_name(names):
    return ['{name[first]} {name[last]}'.format(name=item) for item in names]
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>In both cases you will have to iterate through the <code>names</code> list in one way or another.</p>
<p>The way you do it is by iterating once to get all the first names and then iterating again to get all the last names - then you put the first name and the corresponding last name in a tuple and return a list of tuples.</p>
<p>The 2nd function iterates only once, and it does that using the <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">map</a> function. In the <code>map</code> function, there's a <code>lambda</code> function that will be applied for every item of the list. The <code>lambda</code> function takes a dictionary <code>val</code> from the list and puts first and last name in a string, separating them with a space:</p>
<pre><code>a = "Hello"
b = "world!"
string = "{} {}".format(a, b)
</code></pre>
<p><code>string</code> now equals to <code>"Hello world!"</code>. This is repeated for every dictionary in the list where <code>a</code> is the first name and <code>b</code> is the last name. The map object is then converted to a list and returned.</p>
<p>The key difference in the output, is that you are returning a list of tuples, and not a list of strings. To fix that problem, modify the end of your function from this:</p>
<pre><code>return list(zip(firstname,lastname))
</code></pre>
<p>to this:</p>
<pre><code>return [" ".join(names) for names in zip(firstname,lastname)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would rather to do as follow:</p>
<pre><code>names = [{'first': 'Elie', 'last': 'Schoppik'}, {'first': 'Colt', 'last': 'Steele'}]
fullnames = [f"{n.get('first', '')} {n.get('last', '')}" for n in names]
</code></pre>
</div>
<span class="comment-copy">Your chose to use an iterative approach while he chose to use <code>map</code>.  Your approach could be cleaned up, but I see nothing wrong with choosing iteration over <code>map</code> here.</span>
<span class="comment-copy">Your solution also returns a list of tuples that you'll have to <code>' '.join</code> to get the same name strings.</span>
<span class="comment-copy">But doesn't Colt need to use something like this to access a dictionary within a list . list[0]['first] that is equal to the name rather first and last only. Plus my solution is wrong. Why?</span>
<span class="comment-copy">miradulo why wouldn't zip help?</span>
<span class="comment-copy">Note: you can create the tuple using just one loop, e.g. <code>for z in names: result.append((z['first'], z['last']))</code> but you can just <code>' '.join()</code> instead, e.g. <code>for z in names: result.append(' '.join([z['first'], z['last']]))</code></span>
