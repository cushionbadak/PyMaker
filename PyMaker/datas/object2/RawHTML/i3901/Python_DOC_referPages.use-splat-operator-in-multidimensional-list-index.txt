<div class="post-text" itemprop="text">
<p>Say I have the list</p>
<pre><code>a = [[1, 2, 3], 
     [4, 5, 6]]
</code></pre>
<p>and I have an index that I want to use to access an element of this list.</p>
<pre><code>index = [1,2]
</code></pre>
<p>I want to use something like </p>
<pre><code>a[*index] = 9
</code></pre>
<p>to mean <code>a[index[0]][index[1]] = 9</code>, but this doesn't work and neither does <code>a[**index] = 9</code>. Is there a similar way to do this without having a chain of index calls?</p>
<p>I would like a method to do this without using any libraries that must be imported.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce()</code></a>, which is part of the standard library:</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2, 3], 
...      [4, 5, 6]]
&gt;&gt;&gt; index = [1, 2]

&gt;&gt;&gt; import functools, operator
&gt;&gt;&gt; functools.reduce(operator.getitem, index, a)
6
</code></pre>
<p>Or, you can write your own class that supports that kind of multi-dimensional indexing:</p>
<pre><code>import functools, operator

class Matrix:

    def __init__(self, lst):
        self._lst = lst

    def __getitem__(self, index):
        return functools.reduce(operator.getitem, index, self._lst)


a = Matrix([[1, 2, 3],
            [4, 5, 6]])
index = [1, 2]

print(a[index])  # -&gt; 6
</code></pre>
<p>Otherwise, this is not possible using just lists and without loops or other functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all <code>a[c, d, e]</code> is equivalent to <code>a[(c, d, e)]</code> which is equivalent to <code>a.__getitem__((c, d, e))</code>. Note the double parentheses. Any <code>__getitem__</code> implementation that wants to play nice with the Python data model always expects exactly one (explicit) argument.</p>
<p>That's why unpacking values from <code>index</code> inside the <code>[]</code> does not make much sense. <code>a[*index]</code> will give you a <code>SyntaxError</code> and <code>a.__getitem__(*index)</code> gives you a <code>TypeError</code> (because you are providing too many arguments).</p>
<p>Standard Python lists expect integer arguments to <code>__getitem__</code>, but <code>numpy</code> supports indexing with tuples (a numpy array still only takes exactly one argument for <code>__getitem__</code>, but it's allowed to be a tuple).</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; a[(1,2)]
6
</code></pre>
<p>Of course, you can omit the parentheses, because </p>
<pre><code>&gt;&gt;&gt; a[1,2]
6
</code></pre>
<p>is exactly equivalent.</p>
</div>
<span class="comment-copy">You should look into <code>numpy</code> if you want to do this type of indexing</span>
<span class="comment-copy">Or you can create your own <code>Matrix</code> class</span>
<span class="comment-copy">Or you can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce()</code></a></span>
<span class="comment-copy">Thanks. I'm guessing there is no simple way to do this without any libraries.</span>
<span class="comment-copy">@dylnan: well, you could use a simple for-loop if you don't want to use any external module. But if you want to use lists only, then no: there is no way</span>
<span class="comment-copy">How would I use the first method to redefine an element of <code>a</code> in place?</span>
<span class="comment-copy">@dylnan: well, if you want a one-liner, then it would be <code>functools.reduce(operator.getitem, index[:-1], a)[index[-1]] = &lt;new-value&gt;</code>. But if you need such functionality, then using your own class is the best way to go. Python is a high-level language, take advantage of it!</span>
