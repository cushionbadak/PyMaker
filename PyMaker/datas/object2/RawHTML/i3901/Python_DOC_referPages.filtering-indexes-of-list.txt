<div class="post-text" itemprop="text">
<p>I have the following list of numbers:</p>
<pre><code>List = [1, 2, 3, 4, 5, 6, 15]
</code></pre>
<p>I want the indexes of those numbers which are multiple of n,  so I do:</p>
<pre><code>def indexes(List, n):
      # to enumerate the numbers
      E = enumerate(List)
      # filtering tuples
      F = list(filter(lambda x:  x[1] % n == 0, E))
      return [ i[0] for i in F]

     indexes(List, 2)
     [1, 3, 5]
</code></pre>
<p>That's ok, but what happens when I add the variable m?   </p>
<pre><code>def Index( L, n, m):
      # enumeration
      E = enumerate(L)
      # filtering tuples
      F_n = list(filter(lambda x: x[1]%n == 0, E))
      F_m = list(filter(lambda x: x[1]%m == 0, E))
      L_n = [ l[0] for l in F_n]
      L_m = [ J[0] for J in F_m]
      return L_n + L_m

  &gt;&gt;&gt;Index(List, 2, 5):
        [1, 3, 5]
</code></pre>
<p>Why that code doesn't returns [1, 3, 5, 4, 6]?</p>
<p>What is the mistake?</p>
<p>And how to create the function that returns that list?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <em>list comprehension</em> in combination with <code>enumerate</code> method. 
Also, you can apply <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">extended iterable unpacking</a> operator in order to pass parameters as many you need.</p>
<pre><code>List = [1, 2, 3, 4, 5, 6, 15]
def indexes(List, *vars):
   return [index for index, item in enumerate(List) for i in vars if item % i == 0 ]

print(indexes(List, 2, 5))
</code></pre>
<p>Output</p>
<pre><code>[1, 3, 5, 4, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A more general and Pythonic approach that works for any number of variables is to use an <code>any()</code> or <code>all()</code> function that check the Truth value of the condition for all the arguments. If you want the index to belongs to an item that is divisible buy all the arguments you need <code>all()</code> other wise you can use <code>any()</code> that returns True right after it encounters a match.</p>
<pre><code>def indexes(lst, *args):
    return [i for i, j in enumerate(lst) if any(j % arg == 0 for arg in args)]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6, 15, 99, 200, 13, 17, 400]

&gt;&gt;&gt; indexes(lst, 99, 5, 2, 100)
[1, 3, 4, 5, 6, 7, 8, 11]
&gt;&gt;&gt; 
</code></pre>
<p>And with <code>all()</code>:</p>
<pre><code>&gt;&gt;&gt; indexes(lst, 5, 2, 100)
[8, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The issue is <code>enumerate</code> <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">returns an <em>iterator</em> from an <em>iterable</em></a>. Once it is exhausted, you may not use it again. Therefore, you can simply define a new <code>enumerate</code> iterator:</p>
<pre><code>lst = [1, 2, 3, 4, 5, 6, 15]

def Index( L, n, m):

    # enumeration - notice we define 2 objects
    E, F = enumerate(L), enumerate(L)

    F_n = list(filter(lambda x: x[1]%n == 0, E))
    F_m = list(filter(lambda x: x[1]%m == 0, F))
    L_n = [ l[0] for l in F_n]
    L_m = [ J[0] for J in F_m]
    return L_n + L_m

res = Index(lst, 2, 5)

print(res)
[1, 3, 5, 4, 6]
</code></pre>
<p>Note there are better ways you can implement your algorithm.</p>
</div>
<span class="comment-copy">How about <code>list(filter(lambda x: x[1] % n == 0 or x[1] % m == 0, E))</code>?</span>
<span class="comment-copy">By the wait, note that filter() and list comprehension are more or less the same thing, especially in your case. Consider using just list comprehensions, which are more readable</span>
<span class="comment-copy">What I didn't know is that the or operator can join the two Lists thanks</span>
<span class="comment-copy">This is a more Pythonic way to go in this case but won't be this neat when the number of variables increase.</span>
<span class="comment-copy">Excellent thanks</span>
<span class="comment-copy">@IntiLopez Welcome, you can also tell this to community by accepting the answer ;))</span>
