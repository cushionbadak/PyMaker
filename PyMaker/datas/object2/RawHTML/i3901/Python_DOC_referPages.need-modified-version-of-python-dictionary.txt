<div class="post-text" itemprop="text">
<p>What methods need to be altered if want to change the default behaviour of the dictionary?</p>
<p>Some of the methods I am aware of like <code>__getitem__(), __missing__(), __iter__()</code> etc.</p>
<p>I am trying to implement the dictionary in such a way that if I tried to assign the value to key(already existed) then the old value should not go away while should be kept in some list and when we try to remove the key like pop(key), it should remove older value.</p>
<p>What methods need to be modified to override the dict class to achieve this behaviour?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is the <code>__setitem__</code> method that you want to update. You want it to create a list whenever a new key is set in your dictionary and append to that list if the key exists. You can then extend the <code>__getitem__</code> method as well to take the index of the item you want in a list. As for the <code>pop</code> method, you will also need to override <code>dict.pop</code>.</p>
<pre><code>class ListDict(dict):
    def __setitem__(self, key, value):
        if key not in self:
            super().__setitem__(key, [])

        self[key].append(value)

    def __getitem__(self, item):
        if isinstance(item, tuple):
            item, pos = item
            return super().__getitem__(item)[pos]
        else:
            return super().__getitem__(item)

    def pop(self, k):
        v = self[k].pop(0)
        if not self[k]:
            super().__delitem__(k)
        return v
</code></pre>
<p>Example:</p>
<pre><code># Setting items
d = ListDict()
d['foo'] = 'bar'
d['foo'] = 'baz'
d  # {'foo': ['bar', 'baz']}

# Getting items
d['foo', 0]  # 'bar'
d['foo', 1]  # 'baz'
d['foo', 0:2]  # ['bar', 'baz']

# Popping a key
d.pop('foo')
d  # {'foo': ['baz']}
d.pop('foo')
d  # {}
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">Special Method Names</a>.  Try it.  subclass dict then put print statements in the dunder methods to see what happens when you add, delete, set/change, update....</span>
<span class="comment-copy">Thank you @wwii. I will try them out. As a newbie, it will give me fair idea.</span>
<span class="comment-copy">How many <i>older values</i> do you want to keep?</span>
<span class="comment-copy">Yeah, It could be up to 10 values.</span>
<span class="comment-copy">How about <code>...remove the key like pop(key), it should remove older value</code>?</span>
<span class="comment-copy">@wwii Thanks for pointing out, I'll add on that</span>
<span class="comment-copy">There might be more, search around for subclassing dict. <code>.update()</code> doesn't use <code>__setitem__</code>, and what about <code>del d['foo']</code>?</span>
<span class="comment-copy">@wwii I'm sure we can do a lot more, but I just want to update the minimum so OP can build from that. As for using super().__del__ it's because I forsee that one might want del to delete the last added item.</span>
<span class="comment-copy">Hopefully it doesn't seem that I'm sniping - just urging for a complete solution.</span>
