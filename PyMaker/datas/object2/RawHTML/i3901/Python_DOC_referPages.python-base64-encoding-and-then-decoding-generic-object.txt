<div class="post-text" itemprop="text">
<p>i am trying to convert a numpy.ndarray to base64 and then convert it back.
Is base64 library the way to go?
the very simple code below does not even works as expected.
What am I missing?</p>
<pre><code>import numpy as np

x = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
print(x)
print(type(x))

encoded = base64.b64encode(x)
decoded = base64.b64decode(encoded)
print(decoded)
print(type(decoded))
</code></pre>
<p>is there a way to obtain back the original variable?</p>
<p>The general question is:
can i convert "any" object to a binary string and then convert back to the original type?</p>
<p>I maybe can use pickle BUT I would need a compressed format (not in a file):
something like</p>
<pre><code>x_compressed = zipped(pickle.dumps(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure what you are trying to accomplish, but you can base-64 encode any object that has a <code>bytes</code> representation.  In the example you gave, you are encoding a numpy array to base64.  </p>
<p>This works because a numpy array has a <code>bytes</code> form.  You can reach it by either wrapping <code>bytes()</code> around the array or by use the <code>.tobytes()</code> method.</p>
<pre><code>import numpy as np

x = np.array([1,2,3])

bytes(x)
# returns:
b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'

x.tobytes()
# returns:
b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'
</code></pre>
<p>Since we have a <code>bytes</code> representation of the array, you can pass it to the base64 encoder.  Note that if the object is not a byte-like object, it will <code>base64</code> will try to convert it before encoding, as in the following example:</p>
<pre><code>base64.b64encode(x)
# returns
b'AQAAAAIAAAADAAAA'

base64.b64encode(x.tobytes())
# returns
b'AQAAAAIAAAADAAAA'
</code></pre>
<p>The byte array is nothing special.  It is just a sequence of numbers!  That's it.  You reason you did not recover the numpy array is because encoding-decoding process still just leaves you with the result from <code>x.tobytes()</code> not <code>x</code> itself.  </p>
<p>To get back the original object, you need to an interface that can read a sequence of bytes and return an object of some sort.  Luckily, numpy can do just that via the <code>frombuffer</code> function.  However, you will need to tell numpy what TYPE of array it is reading as bytes.  </p>
<p>In other words, you could have a <code>int32</code> array and an <code>int16</code> array that have identical byte representations, but to recover the correct one, you need to tell numpy which TYPE is correct.  So you need some sort of knowledge of the object. </p>
<pre><code>x = np.array([1,2,3])

# encode as base 64
x_64 = base64.b64encode(x.tobytes())

# decode back to bytes
x_bytes = base64.b64decode(x_64)

# use numpy to recreate original array of ints
np.frombuffer(x_bytes, dtype=int)
# returns:
np.array([1, 2, 3])
</code></pre>
<hr/>
<p>If you want to save an object and then recover it later, that process is called serialization.  There are two very good packages that handles serialization, the first is in the standard library, call <code>pickle</code>, the second is called <code>dill</code> and can handle more complicated objects.</p>
<pre><code>import pickle

x = np.array([1,2,3])
pickled_x = pickle.dumps(x)
# pickled_x is a bytes-object that is a hard to read by humans. 

pickle.loads(x)
# returns:
np.array([1, 2, 3])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>base64 encoding is probably not a great choice here.  It may be a good choice if you need to store or transfer data in environments that, perhaps for legacy reasons, are restricted to ASCII.</p>
<p>For numpy arrays, there are simpler methods <code>tostring</code> and <code>frombuffer</code> with the caveat that you need to know the dtype and shape.  If you're using fixed sizes and types you may use it directly:</p>
<pre><code>&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6]], dtype=int32)
&gt;&gt;&gt; x.tostring()
b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00'
&gt;&gt;&gt; np.frombuffer(x.tostring(), dtype=x.dtype).reshape(x.shape)
array([[1, 2, 3],
       [4, 5, 6]], dtype=int32)
</code></pre>
<p>Otherwise, just use numpy's serializer and deserializer, <code>np.save</code> and <code>np.load</code>, which will take care of those details for you:</p>
<pre><code>&gt;&gt;&gt; import io
&gt;&gt;&gt; f = io.BytesIO()
&gt;&gt;&gt; np.save(f, x)
&gt;&gt;&gt; f.getvalue()
b"\x93NUMPY\x01\x00v\x00{'descr': '&lt;i4', 'fortran_order': False, 'shape': (2, 3), }                                                          \n\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00"
&gt;&gt;&gt; f.seek(0); np.load(f)
array([[1, 2, 3],
       [4, 5, 6]], dtype=int32)
</code></pre>
<p><em>Note:</em> You can always add b64 encode/decode pass over those serialized bytes (i.e. the <code>f.getvalue()</code> string) if you need to - but for all practical purposes you can probably just transport numpy's bytes directly without converting to/from b64.</p>
<blockquote>
<p>The general question is: can I convert "any" object to a binary string and then convert back to the original type?</p>
</blockquote>
<p>In theory, yes, because the objects are just bytes on your computer anyway.
For general serialization of Python objects, the standard library provides <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer"><code>pickle</code></a>.  Compression could be added with <a href="https://docs.python.org/3/library/zlib.html" rel="nofollow noreferrer"><code>zlib</code></a>, to give just one example.</p>
</div>
<span class="comment-copy">you should be able too as long as you know the exact object type or inherited type.  You should look into object serialization</span>
<span class="comment-copy">Thanks. I thought about pickle. The point is that the object should be "compressed" and not saved on any file. Just be stored in a variable and sent through requests.</span>
<span class="comment-copy">Thanks for the explanation, very clear.</span>
