<div class="post-text" itemprop="text">
<p>I have the following code snippet:</p>
<pre><code>#!/usr/bin/env python3

print(float(b'5'))
</code></pre>
<p>Which prints <code>5.0</code> with no error (on Linux with utf-8 encoding). I'm very surprised that it doesn't give an error since Python is not supposed to know what encoding is used for the bytes object.</p>
<p>Any insight?</p>
</div>
<div class="post-text" itemprop="text">
<p>When passed a <code>bytes</code> object, <code>float()</code> treats the contents of the object as ASCII bytes. That's sufficient here, as the conversion from string to float only accepts ASCII digits and letters, plus <code>.</code> and <code>_</code> anyway (the only non-ASCII codepoints that would be permitted are whitespace codepoints), and this is analogous to the way <code>int()</code> treats <code>bytes</code> input.</p>
<p>Under the hood, the implementation does this:</p>
<ul>
<li>because the input is not a string, <a href="https://docs.python.org/3/c-api/number.html#c.PyNumber_Float" rel="noreferrer"><code>PyNumber_Float()</code></a> is called on the object (for <code>str</code> objects the code jumps straight to <code>PyFloat_FromString</code>).</li>
<li><code>PyNumber_Float()</code> checks for a <code>__float__</code> method, but if that's not available, it calls <a href="https://docs.python.org/3/c-api/float.html#c.PyFloat_FromString" rel="noreferrer"><code>PyFloat_FromString()</code></a></li>
<li><code>PyFloat_FromString()</code> accepts not only <code>str</code> objects, but any <a href="https://docs.python.org/3/c-api/buffer.html#bufferobjects" rel="noreferrer">object implementing the buffer protocol</a>. The <code>String</code> name is a Python 2 holdover, the Python 3 <code>str</code> type is called <code>Unicode</code> in the C implementation.</li>
<li><code>bytes</code> objects implement the buffer protocol, and the <a href="https://docs.python.org/3/c-api/bytes.html#c.PyBytes_AS_STRING" rel="noreferrer"><code>PyBytes_AS_STRING</code> macro</a> is used to access the internal C buffer holding the bytes.</li>
<li>A combination of two internal functions named <code>_Py_string_to_number_with_underscores()</code> and <code>float_from_string_inner()</code> is then used to parse ASCII bytes into a floating point value.</li>
</ul>
<p>For actual <code>str</code> strings, the CPython implementation actually converts any non-ASCII string into a sequence of ASCII bytes by only looking at ASCII codepoints in the input value, and converting any non-ASCII whitespace character to ascii 0x20 spaces, to then use the same <code>_Py_string_to_number_with_underscores()</code> / <code>float_from_string_inner()</code> combo.</p>
<p>I see this as a bug in the documentation and have <a href="https://bugs.python.org/issue33567" rel="noreferrer">filed issue with the Python project</a> to have it updated.</p>
</div>
<span class="comment-copy">Have you rad the <a href="https://docs.python.org/3/howto/unicode.html#encodings" rel="nofollow noreferrer">documentation</a>? and <a href="https://docs.python.org/3.6/c-api/buffer.html#bufferobjects" rel="nofollow noreferrer">docs.python.org/3.6/c-api/buffer.html#bufferobjects</a></span>
<span class="comment-copy">@Kasramvd: the documentation for <code>float()</code> states it accepts a <code>str</code>, a number, or a type that implements <code>__float__</code>. <code>bytes</code> doesn't implement <code>__float__</code>.</span>
<span class="comment-copy">@MartijnPieters <a href="https://docs.python.org/3/library/functions.html#float" rel="nofollow noreferrer">Here</a> it's mentioned that If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. doesn't <code>b'5'</code>  follow that rule? Although it should have been specified clearly in the documentation.</span>
<span class="comment-copy">Fair question, since <a href="https://stackoverflow.com/q/6531750/4014959">not all encodings are supersets of ASCII</a>.</span>
<span class="comment-copy">@Kasramvd: no, it doesn't. The <code>bytes</code> type is not considered a string.</span>
<span class="comment-copy">I know there won't be a thing about python that this guy doesn't know.</span>
<span class="comment-copy">Thanks for the great answer. So, just to be clear, this will fail with certain encodings, such as UTF-16?</span>
<span class="comment-copy">@static_rtti: absolutely, because the <code>\x00</code> bytes won't be accepted. The bytes <b>must</b> be ASCII only, and fit the <code>float()</code> string interpretation rules.</span>
