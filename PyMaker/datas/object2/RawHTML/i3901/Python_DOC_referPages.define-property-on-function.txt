<div class="post-text" itemprop="text">
<p>In JavaScript, we can do the following to any object or function</p>
<pre><code>const myFn = () =&gt; {};
Object.defineProperties(myFn, {
    property: {
        get: () =&gt; console.log('property accessed')
    }
});
</code></pre>
<p>This will allow for a <code>@property</code> like syntax by defining a getter function for the property <code>property</code>.</p>
<pre><code>myFn.property
// property accessed
</code></pre>
<p>Is there anything similar for <code>functions</code> in Python?
I know we can't use <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a> since it's not a new-style class, and assigning a <code>lambda</code> with <code>setattr</code> will not work since it'll be a function.</p>
<p>Basically what I want to achieve is that whenever <code>my_fn.property</code> is to return a new instance of another class on each call.
What I currently have with <code>setattr</code> is this</p>
<pre><code>setattr(my_fn, 'property', OtherClass())
</code></pre>
<p>My hopes are to design an API that looks like this <code>my_fn.property.some_other_function()</code>.</p>
<p>I would prefer using a function as <code>my_fn</code> and not an instance of a class, even though I realize that it might be easier to implement.</p>
<p>Below is the gist of what I'm trying to achieve</p>
<pre><code>def my_fn():
    pass

my_fn = property('property', lambda: OtherClass())
my_fn.property
// will be a new instance of OtherClass on each call
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not possible to do exactly what you want. <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">The descriptor protocol</a> that powers <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">the <code>property</code> built-in</a> is only invoked when:</p>
<ol>
<li>The descriptor is <em>defined</em> on a <em>class</em></li>
<li>The descriptor's name is <em>accessed</em> on an <em>instance</em> of said class</li>
</ol>
<p>Problem is, the class behind functions defined in Python (aptly named <code>function</code>, <a href="https://docs.python.org/3/library/types.html#types.FunctionType" rel="nofollow noreferrer">exposed directly as <code>types.FunctionType</code></a> or indirectly by calling <code>type()</code> on any function defined at the Python layer) is a single shared, immutable class, so you can't add descriptors to it (and even if you could, they'd become attributes of <em>every</em> Python level function, not just one particular function).</p>
<p>The closest you can get to what you're attempting would be to define a callable <em>class</em> (defining <code>__call__</code>) that defines the descriptor you're interested in as well. Make a single instance of that class (you can throw away the class itself at this point) and it will behave as you expect. Make <code>__call__</code> a <code>staticmethod</code>, and you'll avoid changing the signature to boot.</p>
<p>For example, the behavior you want could be achieved with:</p>
<pre><code>class my_fn:
    # Note: Using the name "property" for a property has issues if you define
    # other properties later in the class; this is just for illustration
    @property
    def property(self):
        return OtherClass()
    @staticmethod
    def __call__(...whatever args apply; no need for self...):
        ... function behavior goes here ...
my_fn = my_fn()  # Replace class with instance of class that behaves like a function
</code></pre>
<p>Now you can call the "function" (really a functor, to use C++ parlance):</p>
<pre><code>my_fn(...)
</code></pre>
<p>or access the property, getting a brand new <code>OtherClass</code> each time:</p>
<pre><code>&gt;&gt;&gt; type(my_fn.property) is type(my_fn.property)
True
&gt;&gt;&gt; my_fn.property is my_fn.property
False
</code></pre>
<p>No, this isn't what you asked for (you seem set on having a plain function do this for you), but you're asking for a very JavaScript specific thing which doesn't exist in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you want is not currently possible, because the property would have to be set on the function type to be invoked correctly.  And you are not allowed to monkeypatch the function type:</p>
<pre><code>&gt;&gt;&gt; type(my_fn).property = 'anything else'
TypeError: can't set attributes of built-in/extension type 'function'
</code></pre>
<p>The solution: use a callable class instead.</p>
<p><strong>Note:</strong> What you want <em>may</em> become possible in Python 3.8 if <a href="https://www.python.org/dev/peps/pep-0575/" rel="nofollow noreferrer">PEP 575</a> is accepted.</p>
</div>
<span class="comment-copy">I fail to see the connection between <i>"readonly"</i> and <i>"return a new instance ... on each call"</i> Those are not even related to oneanother. What exactly are you trying to do? To always return a new instance, you simply always return a new instance, right?</span>
<span class="comment-copy">I'm trying to define an attribute on a function, which is a function but acts as a normal attribute much like @property decorator works for classes</span>
<span class="comment-copy">Baller answer, thanks! I'm not deadset on using a function, it's just that I love that approach in JavaScript and wanted to mimic it as much as possible in Python. I had no idea about the <code>function</code> type - so TIL! :)</span>
<span class="comment-copy">This worked like a charm, and I'm happy with the API it resulted in! :)</span>
<span class="comment-copy">Since I can't accept two answers I'm going for the one with "most" content. Thanks for the answer I had no idea that functions had 1 shared, immutable class! Also, thanks for pointing out the PEP, will give it a good read!</span>
<span class="comment-copy">@wim: On your note: Looks like making it possible would still require the definition of a custom <code>function</code> subclass. Problem is, it looks like <a href="https://www.python.org/dev/peps/pep-0575/#function" rel="nofollow noreferrer">you'd need a new subclass for each set of properties</a> you'd want to define on functions, which doesn't save you much over callable "functors". Interesting PEP though, hadn't read that one yet.</span>
