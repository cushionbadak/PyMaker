<div class="post-text" itemprop="text">
<p>Since CPU-bound parellelization is not achievable in CPython due to GIL.
The official documentation recommends to use multiprocessing instead of multithreading.
So, is the use of multiple processes more intensive on resources than multiple threads, if compared to multiprocessing/multithreading performance of any other programming language like Java or C++ which support true parellelization in both multiprocessing and multithreading? </p>
</div>
<div class="post-text" itemprop="text">
<p>There is little inherent additional cost to multiprocessing in python beyond the cost of forking (unix-like systems) or respawning a process. The expense is when data or state needs to be shared among the processes. This could be anything from the iterable given to <code>Pool.map</code> to the proxies in <code>Manager</code>. As long as those costs are kept low compared to the per-process work load, its a wash. (Note that python is usually slower than java and c++ for other reasons unrelated to mp).</p>
</div>
<span class="comment-copy">What would that even mean? <i>"Intensive on resources"</i>? I'd say Python is more <i>"intensive on resources"</i> (i.e. slower) in general. BTW, <i>"official documentation recommends to use multiprocessing instead of multithreading"</i>? Do you have a quote? I'm sure it is only recommended in some circumstances and not always. There are pros and cons to any approach. Anyway, communication between threads is easier than between processes, regardless of the language of choice. That said, I think this question is off topic for two reasons: it is too broad and primarily opinion based.</span>
<span class="comment-copy">"CPython implementation detail: In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multi-core machines, you are advised to use multiprocessing or concurrent.futures.ProcessPoolExecutor. However, threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously." <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">docs.python.org/3/library/threading.html</a></span>
<span class="comment-copy">Exactly, <i>"if you want your application to make better use of the computational resources of multi-core machines"</i>, which isn't something you <i>always</i> want (or even <i>usually</i>, probably not even <i>often</i>).</span>
