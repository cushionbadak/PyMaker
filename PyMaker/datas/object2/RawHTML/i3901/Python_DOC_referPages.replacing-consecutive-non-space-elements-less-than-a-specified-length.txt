<div class="post-text" itemprop="text">
<p>I have a python string </p>
<pre><code>'AAAAA     BBB      AAAAA   AA     BBBBBB'
</code></pre>
<p>with the blank spaces in between. </p>
<p>I need the output to have the non zero islands below a certain length to be replaced by blank spaces.</p>
<p>Say for example I need to replace strings smaller than 4 characters long, then my output should look like:</p>
<pre><code>'AAAAA              AAAAA          BBBBBB'
</code></pre>
<p>with the position of other characters being the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a regular expression, using the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code> module</a>:</p>
<pre><code>import re

re.sub(r'\b\w{1,3}\b', lambda m: ' ' * len(m.group()), inputstring)
</code></pre>
<p>The <code>3</code> is your maximum number of consecutive characters.</p>
<p>Breaking this down:</p>
<ul>
<li><a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub(pattern, replacement, string)</code></a> will find matches in <code>string</code> using <code>pattern</code>, then uses the <code>replacement</code> pattern or function to produce replacements, and a new string is returned.</li>
<li>The pattern <code>\b\w{1,3}\b</code> uses.

<ul>
<li><code>\b</code> word boundaries; these match <em>between</em> word and non-word characters or at the start or end; here between a space and a letter. By putting these at either end of <code>\w</code> means we only want matches that have spaces or the start or end of the string on each side.</li>
<li><code>\w</code> matches 'word' characters, which are letters and digits and underscores.</li>
<li><code>{n,m}</code> states a pattern must be repeated between <em>n</em> and <em>m</em> times; you can leave one or the other out for <em>none</em> or <em>as many as you like</em>. <code>{1,3}</code> means between 1 and 3 times a character that matches <code>\w</code>.</li>
</ul></li>
<li>The replacement is a function, that is passed a <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">match object</a> for each matching substring. Here, it returns a number of spaces matching the input string length.</li>
</ul>
<p>See the <a href="https://docs.python.org/3/howto/regex.html#regex-howto" rel="nofollow noreferrer"><em>Regular Expression HOWTO</em></a> for more info.</p>
<p>If you want to keep the length variable, use formatting to add the number into the pattern:</p>
<pre><code>def blank_out_up_to(string, length):
    return re.sub(
        rf'\b\w{{1,{length}}}\b',
        lambda m: ' ' * len(m.group()), 
        string)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; example = 'AAAAA     BBB      AAAAA   AA     BBBBBB'
&gt;&gt;&gt; for i in range(1, 6):
...     print(f'{i}: {blank_out_up_to(example, i)}')
...
1: AAAAA     BBB      AAAAA   AA     BBBBBB
2: AAAAA     BBB      AAAAA          BBBBBB
3: AAAAA              AAAAA          BBBBBB
4: AAAAA              AAAAA          BBBBBB
5:                                   BBBBBB
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another variation using <code>re</code>,</p>
<pre><code>inp = 'AAAAA     BBB      AAAAA   AA     BBBBBB'

''.join([x if len(x) &gt; 3 else ' ' * len(x) for x in re.split(r'(\s+)', inp)])

&gt;&gt; 'AAAAA              AAAAA          BBBBBB'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an anti-regex solution using <code>itertools</code>.</p>
<p>This works if, as in your example, your groups consist of identical characters. If this is not guaranteed, you should use a regex method.</p>
<pre><code>from itertools import groupby, chain

x = 'AAAAA     BBB      AAAAA   AA     BBBBBB'

res = ''.join(chain.from_iterable(i if len(i)&gt;3 else ' '*len(i) for i in
                                  (''.join(j) for _, j in groupby(x))))

print(res)
# "AAAAA              AAAAA          BBBBBB"
</code></pre>
</div>
<span class="comment-copy">Have you made any attempts at this yet? We can help much better when there is code already.</span>
<span class="comment-copy">Read substrings and their lengths. If substring is smaller than 4 characters long, replace it with character length many spaces. Ignore spaces while reading.</span>
<span class="comment-copy">Your example happens to use <i>matching characters</i> in each group. Must the consecutive letters be the same for them to be considered an 'island'?</span>
<span class="comment-copy">Note that this will only group identical characters. The OP didn't specify, but it's possible that something like <code>AABB</code> should be considered a single group of 4 characters. In that case you'll have to pass a key function like <code>str.isspace</code> or something similar to <code>groupby</code>.</span>
<span class="comment-copy">@Aran-Fey, Sure, I added a disclaimer. Hopefully, OP returns to provide clarification.</span>
