<div class="post-text" itemprop="text">
<p>I'm writing a CLI to interact with elasticsearch using the elasticsearch-py library. I'm trying to mock elasticsearch-py functions in order to test my functions without calling my real cluster.</p>
<p>I read <a href="https://stackoverflow.com/questions/44984887/python-mock-what-is-return-value-in-the-following">this question</a> and <a href="https://stackoverflow.com/questions/24431084/python-mock-getting-address-instead-return-value">this one</a> but I still don't understand.</p>
<p><strong>main.py</strong></p>
<p><code>Escli</code> inherits from cliff's <code>App</code> <a href="https://github.com/openstack/cliff/blob/master/cliff/app.py" rel="noreferrer">class</a></p>
<pre><code>class Escli(App):
    _es = elasticsearch5.Elasticsearch()
</code></pre>
<p><strong>settings.py</strong></p>
<pre><code>from escli.main import Escli

class Settings:
    def get(self, sections):
        raise NotImplementedError()

class ClusterSettings(Settings):

    def get(self, setting, persistency='transient'):
        settings = Escli._es.cluster\
                    .get_settings(include_defaults=True, flat_settings=True)\
                    .get(persistency)\
                    .get(setting)

        return settings
</code></pre>
<p><strong>settings_test.py</strong></p>
<pre><code>import escli.settings


class TestClusterSettings(TestCase):
    def setUp(self):
        self.patcher = patch('elasticsearch5.Elasticsearch')
        self.MockClass = self.patcher.start()

    def test_get(self):
        # Note this is an empty dict to show my point
        # it will contain childs dict to allow my .get(persistency).get(setting)
        self.MockClass.return_value.cluster.get_settings.return_value = {}

        cluster_settings = escli.settings.ClusterSettings()
        ret = cluster_settings.get('cluster.routing.allocation.node_concurrent_recoveries', persistency='transient')
        # ret should contain a subset of my dict defined above
</code></pre>
<p>I want to have <code>Escli._es.cluster.get_settings()</code> to return what I want (a <code>dict</code> object) in order to not make the real HTTP call, but it keeps doing it.</p>
<p><strong>What I know:</strong></p>
<ul>
<li><p>In order to mock an instance method I have to do something like
<code>MagicMockObject.return_value.InstanceMethodName.return_value = ...</code></p></li>
<li><p>I cannot patch <code>Escli._es.cluster.get_settings</code> because Python tries to import <code>Escli</code> as module, which cannot work. So I'm patching the whole lib.</p></li>
</ul>
<p>I desperately tried to put some <code>return_value</code> everywhere but I cannot understand why I can't mock that thing properly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should be mocking with respect to where you are testing. Based on the example provided, this means that the <code>Escli</code> class you are using in the <code>settings.py</code> module needs to be mocked with respect to <code>settings.py</code>. So, more practically, your <code>patch</code> call would look like this inside <code>setUp</code> instead: </p>
<pre><code>self.patcher = patch('escli.settings.Escli')
</code></pre>
<p>With this, you are now mocking what you want in the right place based on how your tests are running. </p>
<p>Furthermore, to add more robustness to your testing, you might want to consider speccing for the <code>Elasticsearch</code> instance you are creating in order to validate that you are in fact calling valid methods that correlate to <code>Elasticsearch</code>. With that in mind, you can do something like this, instead: </p>
<pre><code>self.patcher = patch('escli.settings.Escli', Mock(Elasticsearch))
</code></pre>
<p>To read a bit more about what exactly is meant by <code>spec</code>, check the <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">patch</a> section in the documentation. </p>
<p>As a final note, if you are interested in exploring the great world of <a href="https://docs.pytest.org/en/latest/" rel="nofollow noreferrer">pytest</a>, there is a <a href="https://pypi.org/project/pytest-elasticsearch/" rel="nofollow noreferrer">pytest-elasticsearch</a> plugin created to assist with this. </p>
</div>
<span class="comment-copy">You have to mock with respect to where you are testing. Since you are testing the <code>settings.py</code> module, then you need to reference your mocking accordingly. So, in your <code>setUp</code>, your <code>patch</code> path should be something like: <code>patch('escli.settings.Escli')</code>. So now when you call the <code>settings</code> code explicitly like you are in your tests, you are now properly mocking in the right place.</span>
<span class="comment-copy">Furthermore, you might want spec your <code>Mock</code> with the Elasticsearch class in order to validate you are using the valid attributes available in the class. So, you might want to do the following: <code>patch('escli.settings.Escli', Mock(Elasticsearch))</code></span>
<span class="comment-copy">Just to put it out there, <code>pytest</code> does provide a plugin you can use for elasticsearch if you are interested in other options as well: <a href="https://pypi.org/project/pytest-elasticsearch/" rel="nofollow noreferrer">pypi.org/project/pytest-elasticsearch</a></span>
<span class="comment-copy">You made my day ! I will dig to understand that <code>Mock()</code> thing. Would you consider making an answer as you solved the case ?</span>
<span class="comment-copy">Glad it helped! I posted the answer. Cheers.</span>
