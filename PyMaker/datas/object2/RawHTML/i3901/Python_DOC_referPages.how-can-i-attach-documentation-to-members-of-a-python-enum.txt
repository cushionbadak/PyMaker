<div class="post-text" itemprop="text">
<p>I'd like to give documentation for each member of a python enum in a way that IPython can find it. What I have right now is something like:</p>
<pre><code>class Color(Enum):
    """
    RED: The color red
    GREEN: The color green
    BLUE: The color blue. These docstrings are more useful in the real example
    """
    RED = 1
    GREEN = 2
    BLUE = 3
</code></pre>
<p>This isn't great, as it duplicates the member names, and makes it harder to ask for the documentation for just one member.</p>
<p>I can get what I'm after with</p>
<pre><code>class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
Color.RED.__doc__ = "The color red"
Color.GREEN.__doc__ = "The color green"
Color.BLUE.__doc__ = "The color blue. These docstrings are more useful in the real example"
</code></pre>
<p>But this still suffers from repetition of the names.</p>
<p>Is there an easier way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can override <code>Enum.__new__</code> to take a second <code>doc</code> argument as follows:</p>
<pre><code>class DocEnum(Enum):
    def __new__(cls, value, doc=None):
        self = object.__new__(cls)  # calling super().__new__(value) here would fail
        self._value_ = value
        if doc is not None:
            self.__doc__ = doc
        return self
</code></pre>
<p>Which can be used as:</p>
<pre><code>class Color(DocEnum):
    """ Some colors """
    RED   = 1, "The color red"
    GREEN = 2, "The color green"
    BLUE  = 3, "The color blue. These docstrings are more useful in the real example"
</code></pre>
<p>Which in IPython, gives the following:</p>
<pre><code>In [17]: Color.RED?
Type:            Color
String form:     Color.RED
Docstring:       The color red
Class docstring: Some colors
</code></pre>
<hr/>
<p>This can also be made to work for <code>IntEnum</code>:</p>
<pre><code>class DocIntEnum(IntEnum):
    def __new__(cls, value, doc=None):
        self = int.__new__(cls, value)  # calling super().__new__(value) here would fail
        self._value_ = value
        if doc is not None:
            self.__doc__ = doc
        return self
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@Eric has shown <a href="https://stackoverflow.com/a/50473952/208880">how to do it</a> using the stdlib <code>Enum</code>; this is how to do it using <a href="https://pypi.org/project/aenum/" rel="nofollow noreferrer"><code>aenum</code></a><sup>1</sup>:</p>
<pre><code>from aenum import Enum  # or IntEnum

class Color(Enum):                     # or IntEnum
    _init_ = 'value __doc__'
    RED = 1, 'The color red'
    GREEN = 2, 'The color green'
    BLUE = 3, 'The color blue'
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<span class="comment-copy">could it be more flexible with <code>def __new__(cls, value, doc=''):</code> ?</span>
<span class="comment-copy">You can do the same thing with <code>__init__</code> instead of <code>__new__</code>. Or if you want to stick with <code>__new__</code>, at least implement it properly with <code>super().__new__(cls)</code> rather than <code>object.__new__(cls)</code>. Also, you forgot to make <code>Color</code> inherit from <code>DocEnum</code>.</span>
<span class="comment-copy">@Aran-Fey: Calling <code>super().__new__(cls)</code> doesn't work, as that calls <code>Enum.__new__</code> which isn't ready to be called yet. Overriding <code>__init__</code> also doesn't work, because then it's too late and now <code>Color.RED.value</code> is a tuple, not the intended integer.</span>
<span class="comment-copy">@PRMoureu: Good suggestion, updated</span>
<span class="comment-copy">It looks like <code>Enum</code> is just really weird, in that <code>Enum.__new__</code> does not support being used for initial construction of enum instances at all; it <i>only</i> handles retrieving already-constructed instances once the class is already set up. During enum class initialization, <code>Enum.__new__</code> is explicitly bypassed for instance creation.</span>
<span class="comment-copy">I was hoping that your package might support this, but I'd forgotten its name, and your docs don't mention using <code>__doc__</code> explicitly. Perhaps an example like this in the documentation would be useful?</span>
<span class="comment-copy">Is <code>value</code> handled specially here? In the stdlib, I have to use <code>_value_</code> in my <code>__new__</code>.</span>
<span class="comment-copy">@Eric:  Yes, <code>value</code> is handled specially; if it's mentioned in <code>_init_</code> then it's peeled off and used during <code>EnumMeta</code>'s <code>__new__</code>, while the rest are sent to the default <code>__init__</code> which assigns to attributes of the same name (sort of like <code>**kwargs</code>).</span>
