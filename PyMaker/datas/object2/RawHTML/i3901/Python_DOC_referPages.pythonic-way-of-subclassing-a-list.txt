<div class="post-text" itemprop="text">
<p>Here's my general problem space:</p>
<p>I have a byte/bit protocol with a device over I2C.</p>
<p>I've got a "database" of the commands to fully describe all the bitfields types and values and enumerations.</p>
<p>I have a class to consume the database and a i2c driver/transactor so that I can then call commands and get responses.</p>
<pre><code>MyProtocol = Protocol('database.xml',I2CDriver())
theStatus = MyProtocol.GET_STATUS()
</code></pre>
<p>creates the proper byte stream for the GET_STATUS command, sends it over the i2c and returns the response as a byte array currently.  I can get it to pretty print the response inside of the GET_STATUS() implementation, but I want to move that behavior to return object, rather than in the command.</p>
<p>I want my return object to be 'smart':  <code>theStatus</code> needs to have the list/array of bytes plus a reference to its field definitions.</p>
<p>I want <code>theStatus</code> to act like an list/bytearray, so I can directly inspect the bytes.  I don't care if slices are anything other than lists of bytes or bytearray.   Once they've been sliced out they're just bytes.</p>
<p>I want 'theStatus' to be able to be printed <code>print(theStatus)</code> and have it pretty print all the fields in the status.  I'm comfortable on how to make this happen once I settle on a workable data structure that allows me to access the bytes and the data base.</p>
<p>I want to inspect <code>theStatus</code> by field name with something like <code>theStatus.FIELDNAME</code> or maybe <code>theStatus['FIELDNAME']'</code>.   Same thing:  once I have a workable data structure that has the byte array and database as members, I can make this happen.</p>
<p>The problem is I don't know the "right" data structure to cause the least amount of problems.   </p>
<p>Any suggestions on the most pythonic way to accomplish this?  My initial thought was to subclass <code>list</code> and add the field definitions as a member, but it seems like python doesn't like that idea at all.</p>
<p>Composition seems like the next bet, but getting it to act like a proper <code>list</code> seems like that might be a bunch of work to get it 'right'.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you really want is to implement a new <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer"><em>sequence</em> type</a>, one that is perhaps mutable. You can either create one from scratch by implementing the <a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types" rel="nofollow noreferrer">special methods needed to emulate container types</a>, or you can use a suitable <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow noreferrer"><code>collections.abc</code> collection ABC</a> as a base.</p>
<p>The latter is probably the easiest path to take, as the ABCs provide implementations for many of the methods as base versions that rely on a few abstract methods you must implement.</p>
<p>For example, the (immutable) <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" rel="nofollow noreferrer"><code>Sequence</code> ABC</a> only requires you to provide implementations for <code>__getitem__</code> and <code>__len__</code>; the base ABC implementation provides the rest:</p>
<pre><code>from collections.abc import Sequence

class StatusBytes(Sequence):
    def __init__(self, statusbytes):
        self._bytes = statusbytes

    def __getitem__(self, idx_or_name):
        try:
            return self._bytes[idx_or_name]
        except IndexError:
            # assume it is a fieldname
            return FIELDNAMES[idx_or_name]

    def __len__(self):
        return len(self._bytes)
</code></pre>
<p>If you really need a full list implementation, including support for rich comparisons (<code>list_a &lt;= list_b</code>), sorting (<code>list_a.sort()</code>), copying [<code>list_a.copy()</code>] and multiplication (<code>list_a * 3</code>), then there is also the <a href="https://docs.python.org/3/library/collections.html#collections.UserList" rel="nofollow noreferrer"><code>collections.UserList()</code> class</a>. This class inherits from <code>collections.abc.MutableSequence</code>, and adds the extra functionality that <code>list</code> offers over the base sequence ABCs. If you <em>don't</em> need that extra functionality, stick to base ABCs.</p>
</div>
<div class="post-text" itemprop="text">
<p>Make a subclass which inherits from <code>collections.UserList</code>, that's exactly what its for  <a href="https://docs.python.org/3/library/collections.html#collections.UserList" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html#collections.UserList</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you're looking for <a href="https://docs.python.org/3/library/collections.html#collections.UserList" rel="nofollow noreferrer">collections.UserList</a>.</p>
</div>
<span class="comment-copy">I've done this and it's working fine.  I actually went with <code>UserList</code> for some reason (extend maybe?  something like that)   Out of curiosity, why isn't there a call to super() in <code>__init__</code>?</span>
<span class="comment-copy">@RussSchultz: in the <code>__init__</code> of <code>UserList</code> or in the <code>__init__</code> I defined in my example class? <code>super().__init__()</code> is not always appropriate, and requires that all <code>__init__</code> methods in the MRO can handle the same number of arguments. That makes using it not so cut and dry. The ABCs in <code>collections.abc</code> have no <code>__init__</code> methods, there is no need to use <code>super().__init__()</code> here unless you want to support further subclassing with multiple inheritance.</span>
