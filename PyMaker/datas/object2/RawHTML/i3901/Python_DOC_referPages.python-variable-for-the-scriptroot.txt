<div class="post-text" itemprop="text">
<p>I would like to see what is the best way to determine the current script directory in python?</p>
<p>I discovered that, due to the many ways of calling python code, it is hard to find a good solution.</p>
<p>Here are some problems:</p>
<ul>
<li><code>__file__</code> is not defined if the script is executed with <code>exec</code>, <code>execfile</code></li>
<li><code>__module__</code> is defined only in modules</li>
</ul>
<p>Use cases: </p>
<ul>
<li><code>./myfile.py</code></li>
<li><code>python myfile.py</code></li>
<li><code>./somedir/myfile.py</code></li>
<li><code>python somedir/myfile.py</code></li>
<li><code>execfile('myfile.py')</code> (from another script, that can be located in another directory and that can have another current directory.</li>
</ul>
<p>I know that there is no perfect solution, but I'm looking for the best approach that solves most of the cases.</p>
<p>The most used approach is <code>os.path.dirname(os.path.abspath(__file__))</code> but this really doesn't work if you execute the script from another one with <code>exec()</code>.</p>
<h2>Warning</h2>
<p>Any solution that uses current directory will fail, this can be different based on the way the script is called or it can be changed inside the running script.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>os.path.dirname(os.path.abspath(__file__))
</code></pre>
<p>is indeed the best you're going to get.</p>
<p>It's unusual to be executing a script with <code>exec</code>/<code>execfile</code>; normally you should be using the module infrastructure to load scripts. If you must use these methods, I suggest setting <code>__file__</code> in the <code>globals</code> you pass to the script so it can read that filename.</p>
<p>There's no other way to get the filename in execed code: as you note, the CWD may be in a completely different place.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really want to cover the case that a script is called via <code>execfile(...)</code>, you can use the <code>inspect</code> module to deduce the filename (including the path).  As far as I am aware, this will work for all cases you listed:</p>
<pre><code>filename = inspect.getframeinfo(inspect.currentframe()).filename
path = os.path.dirname(os.path.abspath(filename))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/env python
import inspect
import os
import sys

def get_script_dir(follow_symlinks=True):
    if getattr(sys, 'frozen', False): # py2exe, PyInstaller, cx_Freeze
        path = os.path.abspath(sys.executable)
    else:
        path = inspect.getabsfile(get_script_dir)
    if follow_symlinks:
        path = os.path.realpath(path)
    return os.path.dirname(path)

print(get_script_dir())
</code></pre>
<p>It works on CPython, Jython, Pypy. It works if the script is executed using <code>execfile()</code> (<code>sys.argv[0]</code> and <code>__file__</code> -based solutions would fail here). It works if the script is inside <a href="https://stackoverflow.com/a/5356563/4279">an executable zip file (/an egg)</a>. It works if the script is "imported" (<code>PYTHONPATH=/path/to/library.zip python -mscript_to_run</code>) from a zip file; it returns the archive path in this case. It works if the script is compiled into a standalone executable (<code>sys.frozen</code>). It works for symlinks (<code>realpath</code> eliminates symbolic links). It works in an interactive interpreter; it returns the current working directory in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.4+ you can use the simpler <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> module:</p>
<pre><code>from inspect import currentframe, getframeinfo
from pathlib import Path

filename = getframeinfo(currentframe()).filename
parent = Path(filename).resolve().parent
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use <code>os.path.dirname(os.path.abspath(__file__))</code> and examine very carefully whether there is a real need for the case where <code>exec</code> is used.  It could be a sign of troubled design if you are not able to use your script as a module.  </p>
<p>Keep in mind <em>Zen of Python #8</em>, and if you believe there is a good argument for a use-case where it must work for <code>exec</code>, then please let us know some more details about the background of the problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>os.path...</code> approach was the 'done thing' in Python 2.</p>
<p>In Python 3, you can find directory of script as follows:</p>
<pre><code>from pathlib import Path
cwd = Path(__file__).parents[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First.. a couple missing use-cases here if we're talking about ways to inject anonymous code..</p>
<pre><code>code.compile_command()
code.interact()
imp.load_compiled()
imp.load_dynamic()
imp.load_module()
__builtin__.compile()
loading C compiled shared objects? example: _socket?)
</code></pre>
<p>But, the real question is, what is your goal - are you trying to enforce some sort of security? Or are you just interested in whats being loaded.</p>
<p>If you're interested in <a href="http://en.wikipedia.org/wiki/Security_through_obscurity" rel="nofollow">security</a>, the filename that is being imported via exec/execfile is inconsequential - you should use <a href="http://docs.python.org/library/rexec.html" rel="nofollow">rexec</a>, which offers the following:</p>
<blockquote>
<p>This module contains the RExec class,
  which supports r_eval(), r_execfile(),
  r_exec(), and r_import() methods, which 
  are restricted versions of the standard
  Python functions eval(), execfile() and 
  the exec and import statements. Code 
  executed in this restricted environment
  will only have access to modules and 
  functions that are deemed safe; you can 
  subclass RExec add or remove capabilities as
  desired.</p>
</blockquote>
<p>However, if this is more of an academic pursuit.. here are a couple goofy approaches that you
might be able to dig a little deeper into.. </p>
<p>Example scripts:</p>
<p><strong>./deep.py</strong></p>
<pre><code>print ' &gt;&gt; level 1'
execfile('deeper.py')
print ' &lt;&lt; level 1'
</code></pre>
<p><strong>./deeper.py</strong></p>
<pre><code>print '\t &gt;&gt; level 2'
exec("import sys; sys.path.append('/tmp'); import deepest")
print '\t &lt;&lt; level 2'
</code></pre>
<p><strong>/tmp/deepest.py</strong></p>
<pre><code>print '\t\t &gt;&gt; level 3'
print '\t\t\t I can see the earths core.'
print '\t\t &lt;&lt; level 3'
</code></pre>
<p><strong>./codespy.py</strong></p>
<pre><code>import sys, os

def overseer(frame, event, arg):
    print "loaded(%s)" % os.path.abspath(frame.f_code.co_filename)

sys.settrace(overseer)
execfile("deep.py")
sys.exit(0)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>loaded(/Users/synthesizerpatel/deep.py)
&gt;&gt; level 1
loaded(/Users/synthesizerpatel/deeper.py)
    &gt;&gt; level 2
loaded(/Users/synthesizerpatel/&lt;string&gt;)
loaded(/tmp/deepest.py)
        &gt;&gt; level 3
            I can see the earths core.
        &lt;&lt; level 3
    &lt;&lt; level 2
&lt;&lt; level 1
</code></pre>
<p>Of course, this is a resource-intensive way to do it, you'd be tracing
all your code.. Not very efficient. But, I think it's a novel approach
since it continues to work even as you get deeper into the nest.
You can't override 'eval'. Although you <em>can</em> override execfile().</p>
<p>Note, this approach only coveres exec/execfile, not 'import'.
For higher level 'module' load hooking you might be able to use use
<a href="http://blog.doughellmann.com/2009/11/pymotw-sys-part-7-modules-and-imports.html" rel="nofollow">sys.path_hooks</a> (Write-up courtesy of PyMOTW).</p>
<p>Thats all I have off the top of my head. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a partial solution, still better than all published ones so far.</p>
<pre><code>import sys, os, os.path, inspect

#os.chdir("..")

if '__file__' not in locals():
    __file__ = inspect.getframeinfo(inspect.currentframe())[0]

print os.path.dirname(os.path.abspath(__file__))
</code></pre>
<p>Now this works will all calls but if someone use <code>chdir()</code> to change the current directory, this will also fail.</p>
<p>Notes: </p>
<ul>
<li><code>sys.argv[0]</code> is not going to work, will return <code>-c</code> if you execute the script with <code>python -c "execfile('path-tester.py')"</code></li>
<li>I published a complete test at <a href="https://gist.github.com/1385555" rel="nofollow">https://gist.github.com/1385555</a> and you are welcome to improve it.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This should work in most cases:</p>
<pre><code>import os,sys
dirname=os.path.dirname(os.path.realpath(sys.argv[0]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import sys

def get_script_path():
    return os.path.dirname(os.path.realpath(sys.argv[0]))


my_script_dir = get_script_path()
print my_script_dir
</code></pre>
<p>This gives you the directory of the script at the top of the stack (i.e. the one being executed - not Python's, which is usually the first executed, returning <code>C:/</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>Would</p>
<pre><code>import os
cwd = os.getcwd()
</code></pre>
<p>do what you want?  I'm not sure what exactly you mean by the "current script directory".  What would the expected output be for the use cases you gave?</p>
</div>
<div class="post-text" itemprop="text">
<p>Hopefully this helps:- 
If you run a script/module from anywhere you'll be able to access the <code>__file__</code> variable which is a module variable representing the location of the script. </p>
<p>On the other hand, if you're using the interpreter you don't have access to that variable, where you'll get a name <code>NameError</code> and <code>os.getcwd()</code> will give you the incorrect directory if you're running the file from somewhere else. </p>
<p><a href="https://stackoverflow.com/a/18489147/7609849">This</a> solution should give you what you're looking for in all cases:</p>
<pre><code>from inspect import getsourcefile
from os.path import abspath
abspath(getsourcefile(lambda:0))
</code></pre>
<p>I haven't thoroughly tested it but it solved my problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>just <code>pwd</code><br/>
at jupyter notebook : <code>pwd</code> + shift + enter<br/>
at spyder : <code>pwd</code> + F9</p>
</div>
<span class="comment-copy">Can you be more specific where you need to know where the file comes from? - in the code thats importing the file (include-aware host) or in the file thats imported? (self-aware slave)</span>
<span class="comment-copy">See Ron Kalian's <code>pathlib</code> solution if you're using python 3.4 or higher: <a href="https://stackoverflow.com/a/48931294/1011724">stackoverflow.com/a/48931294/1011724</a></span>
<span class="comment-copy">So the solution is NOT to use any current directory in code, but to use some config file?</span>
<span class="comment-copy">Interesting discovery, I just made: When doing <code>python myfile.py</code> from a shell, it works, but both <code>:!python %</code> and <code>:!python myfile.py</code> from within <b>vim</b> fail with <i>The system cannot find the path specified.</i> This is quite annoying. Can anyone comment on the reason behind this and potential workarounds?</span>
<span class="comment-copy">Never say never?  According to this:  <a href="https://stackoverflow.com/a/18489147">stackoverflow.com/a/18489147</a>   answer a cross-platform solution is abspath(getsourcefile(lambda:0))? Or is there something else I'm missing?</span>
<span class="comment-copy">I think this is indeed the most robust method, but I question the OP's stated need for this. I often see developers do this when they are using data files in locations relative to the executing module, but IMO data files should be put in a known location.</span>
<span class="comment-copy">@Ryan LOL, if would be great if you would be able to define a "known location" that is multiplatform and that also comes with the module. I'm ready to bet that the only safe location is the script location. Note, this doesn't meat that the script should write to this location, but for reading data it is safe.</span>
<span class="comment-copy">Still, the solution is not good, just try to call <code>chdir()</code> before the function, it will change the result. Also calling the python script from another directory will alter the result, so it's not a good solution.</span>
<span class="comment-copy"><code>os.path.expanduser("~")</code> is a cross-platform way to get the user's directory. Unfortunately, that isn't the Windows best practice for where to stick application data.</span>
<span class="comment-copy">@sorin: I've tried <code>chdir()</code> before running the script; it produces correct result. I've tried calling the script from another directory and it also works. The results are the same as <a href="http://stackoverflow.com/a/22881871/4279"><code>inspect.getabsfile()</code>-based solution</a>.</span>
<span class="comment-copy">Works perfectly well with PyInstaller.</span>
<span class="comment-copy">Is there any reason why <code>getabsfile(..)</code> is not mentioned in <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer">the documentation for <code>inspect</code></a>? It appears in the source that's linked off that page.</span>
<span class="comment-copy">@EvgeniSergeev it might be a bug. It is a simple wrapper around <code>getsourcefile()</code>, <code>getfile()</code> that  are documented.</span>
<span class="comment-copy">Excellent simplicity!</span>
<span class="comment-copy">You probably can use <code>Path(__file__)</code> (no need for the <code>inspect</code> module).</span>
<span class="comment-copy">@Peque doing that produces a path including the name of the current file, not the parent directory. If I'm trying to get the current script directory in order to point to a file in the same directory e.g. expecting to load a config file in the same directory as the script, <code>Path(__file__)</code> gives <code>/path/to/script/currentscript.py</code> when the OP wanted to get <code>/path/to/script/</code></span>
<span class="comment-copy">Oh I misunderstood, you mean to avoid the inspect module and just use something like <code>parent = Path(__file__).resolve().parent</code>  That's much nicer.</span>
<span class="comment-copy">@Dut A. You should use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.joinpath" rel="nofollow noreferrer"><code>.joinpath()</code></a> (or the <code>/</code> operator) for this, not <code>+</code>.</span>
<span class="comment-copy">If you do not running with exec() you will loose debugger context. Also exec() is supposed to be considerably faster than starting a new process.</span>
<span class="comment-copy">@sorin It's not a question of exec vs starting a new process, so that's a strawman argument. It's a question of exec vs using an import or function call.</span>
<span class="comment-copy">Or just <code>Path(__file__).parent</code>. But <code>cwd</code> is a misnomer, that's not the <i>current working directory</i>, but the <i>file's directory</i>. They could be the same, but that's not usually the case.</span>
<span class="comment-copy">This solution uses the current directory and it's explicitly stated in the question that such solution will fail.</span>
<span class="comment-copy">It wouldn't help. I believe @bogdan is looking for the directory for the script that is at the top of the call stack. i.e. in all his/her  cases, it should print the directory where 'myfile.py' sits. Yet your method would only print the directory of the file that calls <code>exec('myfile.py')</code>, same as <code>__file__</code> and <code>sys.argv[0]</code>.</span>
<span class="comment-copy">Yeah, that makes sense.  I just wanted to make sure @bogdan wasn't overlooking something simple, and I couldn't tell exactly what they wanted.</span>
<span class="comment-copy">The question is obviously about programatically finding the path from Python code, not about the development environment.</span>
