<div class="post-text" itemprop="text">
<p>To give a little background, I am coding a genetic algorithm to solve the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="nofollow noreferrer">Traveling Salesman Problem (TSP)</a>. In my population, I have an ordered list of paths from shortest to longest (fittest to least fit), and their respective distances, like this:</p>
<pre><code>population = [
[[a, b, c, d], [10.12]],
[[b, c, a, d], [11.33]],
[[d, a, c, b], [11.5]],
[[b, a, d, c], [12.07]]
...]
</code></pre>
<p>After the population is ordered by their fitness, I need to kill half of them randomly, but in such a fashion that the fitter the member, the better their chance of surviving.</p>
<ol>
<li><p>I've tried using <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices()</code></a> and passing a list with chances of probability <em>(bias)</em> into the <code>weights</code> parameter, and my desired size of half the original population as <code>k</code> like this:</p>
<pre><code># returns something like [0.99, 0.75, 0.65, 0.22...]
bias_weights = [x / len(population) for x in range(len(population))]

random.choices(population, weights=bias_weights, k=len(population) / 2)
</code></pre>
<p>The problem with the code above is that it <strong>produces duplicates</strong> in my list, and it's very messy to get rid of them and keep the population size at 50%.</p></li>
<li><p>I've also tried using the <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.random.choice.html#numpy.random.choice" rel="nofollow noreferrer"><code>np.random.choices()</code></a> from the <code>numpy</code> library, but it requires the list that I am passing <strong>to be 1D</strong>, and the list of weights and biases to <strong>add up to 1</strong>.</p></li>
</ol>
<p>Is there any other way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would still use <code>np.random.choice()</code>. Solve the first problem by asking <code>np.random.choice()</code> to choose the <em>index</em> of the path rather than the path itself. Solve the second problem by scaling the weights so they sum to 1.</p>
<pre><code>import numpy as np

a, b, c, d = 1, 2, 3, 4

population = [
[[a, b, c, d], [10.12]],
[[b, c, a, d], [11.33]],
[[d, a, c, b], [11.5]],
[[b, a, d, c], [12.07]]
]

# Build probability array
bias_weights = [x / len(population) for x in range(len(population))]
prob = np.array(bias_weights) / np.sum(bias_weights)

# Get random integers between 0 and len(prob)-1, drawn according to prob
sample_size = 2
choice_indices = np.random.choice(len(prob), size=sample_size, replace=False, p=prob)

# Get corresponding paths
paths = [population[i][0] for i in choice_indices]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Choose one element at a time, put it into a set to guarantee it's unique, and continue until you have enough elements:</p>
<pre><code>bias_weights = [x / len(population) for x in range(len(population))]

chosen = set()

while size(chosen) &lt; len(population) // 2:
    chosen.add(random.choices(population, weights=bias_weights, k=1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>EDIT: Actually, I would recommend to just use the following:</p>
<pre><code>while &lt;variable&gt; not in &lt;list&gt;:
    &lt;list&gt;.append(&lt;variable&gt;)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For no duplicates you have to use random shuffle. Algorithm is called weighted random shuffle, and is solved in </p>
<p><a href="http://nicky.vanforeest.com/probability/weightedRandomShuffling/weighted.html" rel="nofollow noreferrer">http://nicky.vanforeest.com/probability/weightedRandomShuffling/weighted.html</a></p>
<p>C++ version is right here</p>
<p><a href="https://stackoverflow.com/questions/50221136/c-weighted-stdshuffle">C++. Weighted std::shuffle</a></p>
<p>UPDATE: Fast weighted random shuffle copied from first link verbatim</p>
<pre><code>from random import random
from bisect import bisect_right
import numpy as np

def weighted_shuffle(a,w):
    r = np.empty_like(a)
    cumWeights = np.cumsum(w)
    for i in range(len(a)):
         rnd = random() * cumWeights[-1]
         j = bisect_right(cumWeights,rnd)
         #j = np.searchsorted(cumWeights, rnd, side='right')
         r[i]=a[j]
         cumWeights[j:] -= w[j]
    return r

a = np.arange(1,1000)
w = np.arange(1,1000)
r = weighted_shuffle(a,w)
print(r[:2])
</code></pre>
</div>
<span class="comment-copy">How would I be able to scale this for 50% of the original data? The problem with the code above is that the same element could be chosen twice, which I do not want. Also, if I were to get rid of them in some kind of loop, I would also have to change the size of the <code>prob</code> list according to which element has been taken out. very messy.</span>
<span class="comment-copy">@KomronAripov You can still use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html" rel="nofollow noreferrer"><code>choice()</code></a>. I updated my code above to allow an arbitrary sample size.</span>
<span class="comment-copy">this produces the following error: <code>ValueError: Fewer non-zero entries in p than size</code></span>
<span class="comment-copy">Could you possibly provide code along with your answer? I'm struggling on the technical side of things with Python.</span>
<span class="comment-copy">This does not seem like a good solution as the number of elements <code>[a, b, c and d]</code> can change any time (that is the nature of the program) and I would not be able to add <code>for</code> clauses dynamically.</span>
<span class="comment-copy">It's actually fairly easy to handle a dynamic list size with "for item in all_stuff:" with "battle_royale.append(item)", but the number of times each item should be appended to the battle_royale list requires a more intricate approach.  It could be accomplished with classes, for example.    Anyway, I just realized my suggestion is way overly complicated.  What you have is good, just use "while ___ not in ___:"</span>
<span class="comment-copy">Is there a python version of what you've described?</span>
<span class="comment-copy">@KomronAripov did you check first link? It is Python as far as I can see</span>
<span class="comment-copy">@KomronAripov just copied code from first link</span>
