<div class="post-text" itemprop="text">
<p>I'm using django ORM in a project(outside of django). My workflow is </p>
<ol>
<li>selecting objects by the django ORM and</li>
<li>then send it to a message queue using an asyncio lib</li>
</ol>
<p>The problem is you can't call blocking functions in async environment and you can not use async/await in blocking environment.</p>
<p>I have come up with 2 solutions:</p>
<ol>
<li><p>The whole program should be async. And use <code>loop.run_in_executor</code> to call blocking functions when needed.</p></li>
<li><p>The whole program should be sync. And use <code>asyncio.run()</code>(Python 3.7) to call async functions needed.</p></li>
</ol>
<p>I can't decide which one is better approach.</p>
<p>I know a <a href="https://stackoverflow.com/questions/41063331/how-to-use-asyncio-with-existing-blocking-library">similar question</a> has been asked before. My question is is there a general rule when trying to combine blocking and non-blocking code?</p>
</div>
<div class="post-text" itemprop="text">
<p>Given the choice between those two, I would definitely recommend approach #1.</p>
<p>#2 has the downside that you're missing out on a lot of asyncio functionality by splitting up asyncio calls into separate little event loop runs. For example, you can't create a "background" task whose execution spans several calls to <code>asyncio.run()</code>, and that kind of thing can be very useful for logging, monitoring, or timeout. (Using <a href="https://docs.python.org/3.7/library/asyncio-task.html?#asyncio.run" rel="nofollow noreferrer"><code>asyncio.run</code></a> could also be a performance issue because it creates a whole new event loop on every invocation, but this can be fixed by switching to <a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_until_complete" rel="nofollow noreferrer"><code>run_until_complete</code></a>.)</p>
<p>But there is also a third option:</p>
<ul>
<li>Create a separate thread that only executes <a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_forever" rel="nofollow noreferrer"><code>loop.run_forever()</code></a> and waits to be given work to do. The remainder of the program consists of normal blocking code that can request something from asyncio using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe()</code></a>. That function doesn't block; it immediately returns a <a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects" rel="nofollow noreferrer"><code>concurrent.futures.Future</code></a> which you can pass around and whose <code>result()</code> method automatically waits for the result to be available. It supports additional features, such as waiting for multiple instances to complete in parallel using <a href="https://docs.python.org/3/library/concurrent.futures.html?#concurrent.futures.wait" rel="nofollow noreferrer"><code>wait</code></a>, the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed" rel="nofollow noreferrer"><code>as_completed</code></a> iterator, etc.</li>
</ul>
<p>This approach IMHO combines the best characteristics of the two options from the question. It leaves blocking code truly blocking, still being allowed to wait for things to happen, spawn threads etc., without forcing the use of <code>async def</code> and <code>run_in_executor</code> across the board. At the same time the asyncio parts can be written using asyncio best practices, with a long-running event loop servicing the whole program. You just need to be careful for <em>all</em> interfacing with the event loop from the rest of the application (even to call something as simple as <a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.stop" rel="nofollow noreferrer"><code>loop.stop</code></a>) to be done using <a href="https://docs.python.org/3.7/library/asyncio-task.html?#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>loop.call_soon_threadsafe</code></a> and <code>asyncio.run_coroutine_threadsafe</code>.</p>
</div>
