<div class="post-text" itemprop="text">
<p>In recent Python 3.x, the default behavior of <code>open</code> is to open files in the <em>universal newlines</em> mode (<code>newline=None</code>), which means that if I open a file like this:</p>
<pre><code>f = open("file.txt")
</code></pre>
<p>then all the different line endings (CRLF/CR/LF) get converted into <code>"\n"</code> when using <code>f.readline()</code>, <code>for line in f:</code>, etc.</p>
<p>However, when dealing with <code>sys.stdin</code>, the different line endings are not converted (at least on Linux, reading a CRLF file means that the result of <code>sys.stdin.readline()</code> ends with <code>"\r\n"</code>). This means that <code>sys.stdin</code> is opened using a different <code>newline</code> setting. Is there any way of influencing the parameters that are used for opening <code>sys.stdin</code>?</p>
<p>More generally, is there in Python something akin to Perl's <code>binmode</code> that would allow changing the way reading from <code>sys.stdin</code> / writing to <code>sys.stdout</code> works?</p>
<p>Just to be clear, I know that I can do the CRLF→LF conversion myself. That is not what this question is about.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no way to fully replace how Python wraps the stdin and stdout pipes in <code>sys.stdin</code> and <code>sys.stdout</code>. (There is some <em>limited</em> control, like <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-u" rel="nofollow noreferrer">the <code>-u</code> option`</a>, but that's it.)</p>
<p>However, you're asking for multiple other things, all of which are possible, and some of which might be what you want.</p>
<hr/>
<p>First, <code>sys.stdin</code> is just a normal <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow noreferrer"><code>TextIOWrapper</code></a>, as returned by <code>open</code> (in text mode). This means you can access its underlying binary object, or the raw unbuffered file object underneath that, or the OS file descriptor underneath that, the same as for any other text file:</p>
<pre><code>sys.stdin.buffer
sys.stdin.buffer.raw
sys.stdin.fileno()
</code></pre>
<p>Often, that's all you need. You wouldn't want to actually replace <code>sys.stdin = sys.stdin.buffer</code>. That would break <code>input</code>, the <code>fileinput</code> module, and who knows what else that's expecting <code>stdin</code> to be a text file. But you can just use <code>sys.stdin.buffer</code> instead of <code>sys.stdin</code>, and it's roughly the equivalent of what I think you were looking for from perl's <code>binmode</code>.</p>
<hr/>
<p>And you want a <code>TextIOWrapper</code> with different options wrapped around the same underlying file, you can do that too.</p>
<p>For the simplest cases, the easiest way to do that is just to call <code>open</code> the way you wanted to call <code>open</code>, passing the file descriptor:</p>
<pre><code>sin = open(sys.stdin.fileno(), &lt;your open arguments here&gt;)
</code></pre>
<p>For less trivial cases, you may need to read the <code>TextIOWrapper</code> docs (and <code>BufferedReader</code> and other types in the <code>io</code> module) and wrap exactly the part you want in exactly the way you want. But usually, <code>open</code> will be good enough.</p>
<p>Either way, you can just use <code>sin</code> in place of <code>sys.stdin</code>.</p>
<p>Or, since this now <em>is</em> a perfectly good <code>TextIOWrapper</code> (assuming you <code>open</code>ed in text mode), it <em>is</em> safe and reasonable to replace <code>sys.stdin</code>:</p>
<pre><code>sys.stdin = sin
</code></pre>
<p>… and now <code>input</code>, etc., will continue to work—and will work the way you wanted them to.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be solved as follows:</p>
<pre><code>sys.stdin = io.TextIOWrapper(sys.stdin.buffer)
</code></pre>
<p>This causes <code>sys.stdin</code> to behave as if it were opened using <code>open</code> with default parameters (including <code>newline=None</code>). TextIOWrapper's constructor takes the same parameters <code>open</code> does, so we can also do things like:</p>
<pre><code>sys.stdin = io.TextIOWrapper(sys.stdin.buffer, newline="", encoding="utf-8")
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, newline="\r\n")
</code></pre>
<p>etc.</p>
<p>We thus have a way of influencing the way stdin/stdout is opened, similarly to Perl's <code>binmode</code> (the <code>binmode FILEHANDLE, LAYERS</code> version).</p>
<p>Thanks to @abarnert for the comment about TextIOWrapper.</p>
</div>
<span class="comment-copy">In Python 3.x, <code>stdout</code> and <code>stdin</code> are just normal <code>TextIOWrapper</code> objects, so you don't <i>need</i> something like <code>binmode</code>; you can just access <code>sys.stdout.buffer</code> to get the binary file (or <code>sys.stdout.buffer.raw</code> to get the raw unbuffered file underneath it). Does that give you what you're looking for?</span>
<span class="comment-copy">Im guessing there must be a way to open stdin as a file (using the open command), at least using linux (Although I couldn't find one).</span>
<span class="comment-copy">@abarnert I want <code>sys.stdin</code> to behave the same as the file handle returned by <code>open</code> and I want to be able to specify the parameters to <code>open</code> (such as <code>newline</code>). How do I accomplish that using the underlying binary or raw file?</span>
<span class="comment-copy">Well, your question is asking multiple things. Using <code>buffer</code> or <code>buffer.raw</code> gives you the equivalent of Perl's <code>binmode</code>, which is what you said you wanted "more generally". You can't actually make <code>sys.stdin</code> act like <code>sys.stdin.buffer</code> (well, you can always do <code>sys.stdin = sys.stdin.buffer</code>, but doing so will break calls to <code>input</code>, and any libs that expect <code>stdin</code> to be a text file, and will confuse any readers, so I guess it's more <i>shouildn't</i> than <i>can't</i>), but you can just use <code>sys.stdin.buffer</code>.</span>
<span class="comment-copy">You also seem to be asking whether you can wrap the same fd in a new file object? That's easy: <code>myin = open(sys.stdin.fileno(), &lt;whatever options you want&gt;)</code> and then use <code>myin</code>. And in this case, if you're opening in text mode, you <i>can</i> safely <code>sys.stdin = myin</code> without breaking anything.</span>
