<div class="post-text" itemprop="text">
<p>Homework assistance</p>
<p>I need to write a function which has the ability to take in a string containing DNA codons from a user e.g.</p>
<pre><code>'ACATTTGCTTCTGACACAACTGTGTTCACTAGCAACCTCAAAC'
</code></pre>
<p>separate the string into groups of 3, then match each group with the dictionary items. but the program must only print out the keys, not the values.</p>
<p>input: <code>ATTGHIATGTTTTTCTYU</code></p>
<p>separation:<code>[ATT] [GHI] [ATG] [TTT] [TTC] [TYU]</code></p>
<p>output: <code>IMFF</code></p>
<p>This is what I have so far</p>
<pre><code>dna_codons = {'I': 'ATT' 'ATC' 'ATA',
              'L': 'CTT' 'CTC' 'CTA' 'CTG' 'TTA' 'TTG',
              'V': 'GTT' 'GTC' 'GTA' 'GTG',
              'F': 'TTT' 'TTC',
              'M': 'ATG',
              }
def translate(sequence):
    n = 3
    MyList = [sequence[i:i+n] for i in range(0, len(sequence), n)]
    for codon in MyList:
        for slc in dna_codons.keys():
            if codon == slc:
                print slc

print translate(raw_input('type in DNA sequence: '))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve the goal easier with list comprehensions and a generator to split input string by to chunks.</p>
<p>Try something like this:</p>
<pre><code>in_seq = 'ATTGHIATGTTTTTCTYU'  # change this to input()

_codes = {  # your original dict is incorrect
    'ATT': 'I', 'ATC': 'I', 'ATA': 'I',
    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'TTA': 'L', 'TTG': 'L',
    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',
    'TTT': 'F', 'TTC': 'F',
    'ATG': 'M',
}


def split_seq(s, n=2):
    """ split string to chunks of size n """
    i = 0
    while i &lt; len(s):
        yield s[i:i + n]
        i += n

out_codes = [_codes[z.upper()] for z in split_seq(in_seq, 3) if z.upper() in _codes]
result = ''.join(out_codes)
print(result)
</code></pre>
<p>Output:</p>
<blockquote>
<p><code>IMFF</code></p>
</blockquote>
<p>If you want to see separated list, type <code>print(list(split_seq(in_seq, 3)))</code>:</p>
<blockquote>
<p><code>['ATT', 'GHI', 'ATG', 'TTT', 'TTC', 'TYU']</code></p>
</blockquote>
<hr/>
<h3>update</h3>
<p>If you don't want to use generator, replace it with this ordinary function:</p>
<pre><code>def split_seq(s, n=2):
    res = []
    i = 0
    while i &lt; len(s):
        res.append(s[i:i + n])
        i += n
    return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The main issue with your code is that <code>'I': 'ATT' 'ATC' 'ATA',</code> won't work. The strings just get concatinated together (<code>ATTATCATA</code>). You need to turn those strings into lists: <code>'I': ['ATT', 'ATC', 'ATA'],</code>. You can then use nested loops to iterate over the dictionary and the lists:</p>
<pre><code>for slc in dna_codons.keys():
    for item in dna_codons[slc]:
        if codon == item:
            print slc
</code></pre>
<p>Finally, the print statement at the end will always print <code>none</code> because your function doesn't return anything to print. Ideally your function should return the desired output rather than printing it as a side effect:</p>
<pre><code>aa_seq =''
for codon in MyList:  
    for slc in dna_codons.keys():
        for item in dna_codons[slc]:
            if codon == item:
                aa_seq += slc
return aa_seq
</code></pre>
<p>Of course, you're not getting much benefit from using a dictionary if you have to loop over all the values for every codon. It would be a lot more efficient to make the codons the <em>keys</em> and the amino acids the <em>values</em>. That way you could just use:</p>
<pre><code>aa_seq = ''
for codon in MyList:
    aa_seq += dna_codons[codon]
return aa_seq
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, you have to change you <code>dna_codons</code> to have values as a list or a tuple. Currently, the strings of triples will just get concatenated into a single string.</p>
<pre><code>dna_codons = {
    'I': ['ATT', 'ATC', 'ATA'],
    'L': ['CTT', 'CTC', 'CTA', 'CTG', 'TTA', 'TTG'],
    'V': ['GTT', 'GTC', 'GTA', 'GTG'],
    'F': ['TTT', 'TTC'],
    'M': ['ATG'],
}
</code></pre>
<p>Now you can use @heathobrien's nested loops, however those are quite inefficient. I think you should change the dictionary, so that it maps from codon to amino acid. You can do it with:</p>
<pre><code>def transpose(d):
    out = {}
    for key, values in d.items():
        for val in values:
            out[val] = key
    return out

codon_to_aa = transpose(dna_codons)
</code></pre>
<p>This produces a dictionary <code>{'ATG': 'M', 'ATT': 'I', 'ATC': 'I', ...}</code>.
After that, the rest is pretty straight forward. You just need to split the sequence and find appropriate mapping. Reusing your code:</p>
<pre><code>def translate(sequence):
    n = 3
    codons = (sequence[i:i+n] for i in range(0, len(sequence), n))
    for codon in codons:
        print codon_to_aa.get(codon, ''),
    print

translate(raw_input('type in DNA sequence: '))
</code></pre>
<p>The comma after the first <code>print</code> makes sure that the next character gets printed out on the same line. The empty <code>print</code> will end the line. However, I'd suggest you aggregate the output into a variable and print it all at once.</p>
<p>Alternatively:</p>
<pre><code>def translate(sequence):
    n = 3
    return ''.join(codon_to_aa.get(codon, '') for codon in   
                      (sequence[i:i + n] for i in xrange(0, len(sequence), n)))

print translate(raw_input('type in DNA sequence: '))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to do it using the <code>itertools</code> recipe for a generator function named <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>grouper()</code></a>.</p>
<pre><code>from itertools import zip_longest

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # s -&gt; (s0,s1,...sn-1), (sn,sn+1,...s2n-1), (s2n,s2n+1,...s3n-1), ...
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)

DNA_CODONS = {
    'ATT': 'I', 'ATC': 'I', 'ATA': 'I',
    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'TTA': 'L', 'TTG': 'L',
    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',
    'TTT': 'F', 'TTC': 'F',
    'ATG': 'M',
}

def translate(sequence, n=3):
    return [codeon for codeon in (''.join(nt) for nt in grouper(sequence, n, ' ')
            if codeon in DNA_CODONS)]

input_sequence = 'ACATTTGCTTCTGACACAACTGTGTTCACTAGCAACCTCAAAC'
print(translate(input_sequence))  # -&gt; [['TTT'], ['GTG'], ['TTC'], ['CTC']]
</code></pre>
</div>
<span class="comment-copy">Thanks mate. I haven't learned about 'yield' as yet. That's new to me. What does that do?</span>
<span class="comment-copy">You're welcome:) <code>yield</code> is somewhat similar to <code>return</code>. It is used in special functions called generators. You can learn more about it here - <a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do" title="what does the yield keyword do">stackoverflow.com/questions/231767/â€¦</a>.</span>
<span class="comment-copy">Updated an answer. You can replace a generator with an ordinary function which simple returns a <code>list</code> which represents a splitted input string.</span>
<span class="comment-copy">You have a typo in <code>def transponse(d):</code></span>
