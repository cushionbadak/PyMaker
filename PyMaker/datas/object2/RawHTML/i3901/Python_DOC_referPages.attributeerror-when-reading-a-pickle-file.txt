<div class="post-text" itemprop="text">
<p>I get the following error when I'm reading my .pkl files on spyder (python 3.6.5):</p>
<pre><code>IN: with open(file, "rb") as f:
       data = pickle.load(f)  

Traceback (most recent call last):

 File "&lt;ipython-input-5-d9796b902b88&gt;", line 2, in &lt;module&gt;
   data = pickle.load(f)

AttributeError: Can't get attribute 'Signal' on &lt;module '__main__' from 'C:\\Python36\\lib\\site-packages\\spyder\\utils\\ipython\\start_kernel.py'&gt;
</code></pre>
<p><strong>The context:</strong></p>
<p>My program is made of one file: <code>program.py</code>
In the program, a class <code>Signal</code> is defined as well as many functions. A simplified overview of the program is provided below:</p>
<pre><code>import numpy as np
import _pickle as pickle
import os

# The unique class
class Signal:
    def __init__(self, fq, t0, tf):
        self.fq = fq
        self.t0 = t0
        self.tf = tf
        self.timeline = np.round(np.arange(t0, tf, 1/fq*1000), 3)

# The functions
def write_file(data, folder_path, file_name):
    with open(join(folder_path, file_name), "wb") as output:
        pickle.dump(data, output, -1)

def read_file(folder_path, file_name):
    with open(join(folder_path, file_name), "rb") as input:
        data= pickle.load(input)
    return data

def compute_data(# parameters):
    # do stuff
</code></pre>
<p>The function <code>compute_data</code> will return a list of tuples of the form:</p>
<pre><code>data = [((Signal_1_1, Signal_1_2, ...), val 1), ((Signal_2_1, Signal_2_2, ...), val 2)...]
</code></pre>
<p>With, of course, the Signal_i_k being an object <code>Signal</code>. This list will be saved in .pkl format. Moreover, I'm doing a lot of iteration with different parameters for the <code>compute_data</code> functions. Many iterations will use past computed data as a starting point, and thus will read the corresponding and needed .pkl files.</p>
<p>Finally, I'm using several computers at the same time, each of them saving the computed data on the local network. Thus each computer can access the data generated by the others and use it as a starting point.</p>
<p><strong>Back to the error:</strong></p>
<p>My main issue is that I never have this error when I start my programs by double-clicking the file or by the windows cmd or PowerShell. The program never crashes throwing this error and runs without apparent issues.</p>
<p>However, <em>I can not read a .pkl file in spyder. Every time I try, the error is thrown.</em></p>
<p>Any idea why I got this weird behavior?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>When you dump stuff in a <code>pickle</code> you should avoid pickling classes and functions declared in the main module. Your problem is (in part) because you only have one file in your program. <code>pickle</code> is lazy and does not serialize class definitions or function definitions. Instead it saves a reference of how to find the class (the module it lives in and its name). </p>
<p>When python runs  a script/file directly it runs the program as the <code>__main__</code> module (regardless of its actual file name). However, when a file is loaded and is <em>not</em> the main module (eg. when you do something like <code>import program</code>) then its module name is based on its name. So <code>program.py</code> gets called <code>program</code>.</p>
<p>When you are running from the command line you are doing the former, and the module is called <code>__main__</code>. As such, pickle creates references to your classes like <code>__main__.Signal</code>. When <code>spyder</code> tries to load the pickle file it gets told to import <code>__main__</code> and look for <code>Signal</code>. But, spyder's <code>__main__</code> module is the module that is used to start <code>spyder</code> and not your <code>program.py</code> and so pickle fails to find <code>Signal</code>. </p>
<p>You can inspect the contents of a pickle file by running (<code>-a</code> is prints a description of each command). From this you will see that your class is being referenced as <code>__main__.Signal</code>.</p>
<pre><code>python -m pickletools -a file.pkl
</code></pre>
<p>And you'll see something like:</p>
<pre><code>    0: \x80 PROTO      3              Protocol version indicator.
    2: c    GLOBAL     '__main__ Signal' Push a global object (module.attr) on the stack.
   19: q    BINPUT     0                 Store the stack top into the memo.  The stack is not popped.
   21: )    EMPTY_TUPLE                  Push an empty tuple.
   22: \x81 NEWOBJ                       Build an object instance.
   23: q    BINPUT     1                 Store the stack top into the memo.  The stack is not popped.
   ...
   51: b    BUILD                        Finish building an object, via __setstate__ or dict update.
   52: .    STOP                         Stop the unpickling machine.
highest protocol among opcodes = 2
</code></pre>
<h1>Solutions</h1>
<p>There are a number of solutions available to you:</p>
<ol>
<li>Don't serialise instances of classes that are defined in your <code>__main__</code> module. The easiest and best solution. Instead move these classes to another module, or write a <code>main.py</code> script to invoke your program (both will mean such classes are no longer found in the <code>__main__</code> module).</li>
<li>Write a custom derserialiser</li>
<li>Write a custom serialiser</li>
</ol>
<p>The following solutions will be working with a pickle file called <code>out.pkl</code> created by the following code (in a file called <code>program.py</code>):</p>
<pre><code>import pickle

class MyClass:
    def __init__(self, name):
        self.name = name

if __name__ == '__main__':
    o = MyClass('test')
    with open('out.pkl', 'wb') as f:
        pickle.dump(o, f)
</code></pre>
<h2>The Custom Deserialiser Solution</h2>
<p>You can write a customer deserialiser that knows when it encounters a reference to the <code>__main__</code> module what you really mean is the <code>program</code> module.</p>
<pre><code>import pickle

class MyCustomUnpickler(pickle.Unpickler):
    def find_class(self, module, name):
        if module == "__main__":
            module = "program"
        return super().find_class(module, name)

with open('out.pkl', 'rb') as f:
    unpickler = MyCustomUnpickler(f)
    obj = unpickler.load()

print(obj)
print(obj.name)
</code></pre>
<p>This is the easiest way to load pickle files that have already been created. The program is that it pushes the responsibility on to the deserialising code, when it should really be the responsibility of the serialising code to create pickle files correctly.</p>
<h1>The Custom Serialisation Solution</h1>
<p>In contrast to the previous solution you can make sure that serialised pickle objects can be deserialised easily by anyone without having to know the custom deserialisation logic. To do this you can use the <a href="https://docs.python.org/3/library/copyreg.html#copyreg.pickle" rel="noreferrer"><code>copyreg</code></a> module to inform <code>pickle</code> how to deserialise various classes. So here, what you would do is tell <code>pickle</code> to deserialise all instances of <code>__main__</code> classes as if they were instances of <code>program</code> classes. You will need to register a custom serialiser for each class</p>
<pre><code>import program
import pickle
import copyreg

class MyClass:
    def __init__(self, name):
        self.name = name

def pickle_MyClass(obj):
    assert type(obj) is MyClass
    return program.MyClass, (obj.name,)

copyreg.pickle(MyClass, pickle_MyClass)

if __name__ == '__main__':
    o = MyClass('test')
    with open('out.pkl', 'wb') as f:
        pickle.dump(o, f)
</code></pre>
</div>
<span class="comment-copy">You are likely using a different version of Python within Spyder than on the command lines. Have you checked the version numbers?</span>
<span class="comment-copy">@IonicSolutions Can you tell me how to do that properly? I do not think this is the problem since once my laptop, the only version installed is python 3.6.5. Spyder was installed with the cmd and the command line: <code>py -3.6 -m pip install spyder</code>. (Situation slightly different with the 2 workstations where python 2.7 is also installed).</span>
<span class="comment-copy"><code>import sys</code> <code>print(sys.version)</code> gives you the exact version used by the interpreter.</span>
<span class="comment-copy">@IonicSolutions As expected: <code>3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 17:00:18) [MSC v.1900 64 bit (AMD64)] </code></span>
<span class="comment-copy">Ok thanks for the great explanation. For the <code>.pkl</code> files already computed, the only way to access them in spyder would be to make a program loading them as I'm currently doing, and then reserializing them with the custom method (via cmd). Correct?</span>
<span class="comment-copy">In that case I would try to move to using the first solution (keeping your classes out of the <code>__main__</code> module. Once you've done that, load any preexisting pickle files using a custom deserialiser and then save them again (this will save them with non <code>__main__</code> references).</span>
<span class="comment-copy">Okay but there is just one thing I've understood now: I'm actually already doing this. My class is defined at the top of my program after <code># -*- coding: utf-8 -*-</code> and the imports; then I got the functions, and finally this: <code>if __name__ == '__main__':</code> with the multiprocessing program following, which calls functions defined above.</span>
<span class="comment-copy">Does it means I have to put the class in an other file and import it?</span>
