<div class="post-text" itemprop="text">
<p>I have a class instance with several properties:</p>
<pre><code>class MyClass(object):
    @property
    def func(self):
        return [1,4,5] 

    @property
    def func2(self):
        return 6
</code></pre>
<p>I would like to dynamically change a property from a user supplied new method, for example:</p>
<pre><code>obj = MyClass()

def patch_property(name, new_return):
    source = '@property\ndef %s(self):\n   return %s' % (parameter_name, new_return) 
    code = compile(source, file_name, 'exec')`

    class SubMyClass(MyClass):
        eval(code)

    obj.__class__ = SubMyClass

patch_property('func', [6,7,8])
</code></pre>
<p>This works, however it changes <code>type(obj)</code>, which messes up some other stuff. Doing the following does not:</p>
<pre><code>cls = type(obj)
new_cls = type(cls.__name__, (cls,), {})
obj.__class__ = new_cls
</code></pre>
<p>However, I can't figure out how to properly get the <code>eval(code)</code> from above in the new_cls. Any ideas on how to solve this?</p>
<p>I also tried monkeypatching the property:</p>
<pre><code>    def patch_fun(code):
        def patched_fun(self):
            eval(code)

        return patched_fun

patched_fun = patch_fun(code)
setattr(cls, name, property(patched_fun))
</code></pre>
<p>or the bound method:</p>
<pre><code>patched_fun = patch_fun(code).__get__(obj, type(obj))
setattr(cls, name, property(patched_fun))
</code></pre>
<p>(I couldn't figure it out from these: <a href="https://stackoverflow.com/questions/24509737/dynamically-adding-a-property-to-a-class">Dynamically adding a property to a class
</a>, <a href="https://stackoverflow.com/questions/2954331/dynamically-adding-property-in-python">Dynamically adding @property in python</a>, <a href="https://stackoverflow.com/questions/21640714/monkey-patching-an-attribute-within-a-class?lq=1&amp;utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">Monkey Patching an attribute within a class</a>, <a href="https://stackoverflow.com/questions/31590152/monkey-patching-a-property?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">Monkey patching a @property
</a>, <a href="https://stackoverflow.com/questions/962962/python-changing-methods-and-attributes-at-runtime">Python: changing methods and attributes at runtime
</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would avoid using eval due to the potential security implications. </p>
<p>This do what you are after without eval:</p>
<pre><code>def patch_property(name, new_return):
    def _new_property(self):
        return new_return

    setattr(obj.__class__, name, property(_new_property))
</code></pre>
<p>Demo:</p>
<pre><code>In [39]: class MyClass:
    ...:     pass
    ...:

In [40]: obj = MyClass()

In [41]: type(obj)
Out[41]: __main__.MyClass

In [42]: patch_property('func', [6,7,8])

In [43]: type(obj)
Out[43]: __main__.MyClass

In [44]: obj.func
Out[44]: [6, 7, 8]
</code></pre>
<p>This will of course change all objects from this class. </p>
<p>Look into <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">metaclasses</a> for doing this sort of stuff. </p>
<p>Edit, this version of <code>patch_property</code> takes a custom callable:</p>
<pre><code>In [105]: class MyClass(object):
     ...:     def __init__(self):
     ...:         self.a = 10  #accounts for attribute referenced
     ...:
     ...:     @property
     ...:     def func(self):
     ...:         return [1,4,5]
     ...:
     ...:     @property
     ...:     def func2(self):
     ...:         return 6


In [106]: def patch_property(name, new_return):
     ...:     def _new_property(self):
     ...:         return new_return
     ...:
     ...:     setattr(obj.__class__, name, property(new_return if callable(new_return) else _new_property))


In [107]: def custom_func(self):
     ...:     x = self.a * 4
     ...:     z = x * 9
     ...:     return z

In [108]: obj = MyClass()

In [109]: patch_property('func', custom_func)

In [110]: obj.func
Out[110]: 360

In [111]: patch_property('func', [4, 5, 6])

In [112]: obj.func
Out[112]: [4, 5, 6]
</code></pre>
</div>
<span class="comment-copy"><code>compile()</code> inside your code seems like a massive securiry breach. In previous posts there are attempts to use setatrr and a lambda function, which feel more reasonable.</span>
<span class="comment-copy">so how about instead of new_return I would like a multiline function. For example <code>'x = self.a * 4\nz = x *9\nreturn z'</code></span>
<span class="comment-copy">@jasp116 Then pass the whole <code>_new_property</code> as argument, rather than just <code>new_return</code>.</span>
<span class="comment-copy">@jasp116 what zvone says, have the function take a callable. I edited a version that takes either a value or a callable.</span>
<span class="comment-copy">@salparadise unfortunately the setattr way of patching doesn't work as the  method has to be created from inside MyClass for some other stuff to work. So like the MySubClass method but then inside MyClass somehow..</span>
<span class="comment-copy">@zvone and how would that work if it was a string as in my comment above?</span>
