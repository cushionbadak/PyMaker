<div class="post-text" itemprop="text">
<p>I am trying to make a dictionary from this file: with the key being the first word, and the values being all words afterwards.</p>
<pre><code>andrew fred
fred
judy andrew fred
george judy andrew
john george
</code></pre>
<p>This is the code I have:</p>
<pre><code>follows_file = open("C:\\Users\\Desktop\\Python\\follows.txt")
followers = {}
for line in follows_file:   #==&gt; [Judy Andrew Fred]
    users = line.split(' ')     #==&gt; [Judy, andrew, Fred, ....]
    follower = users[0]     #==&gt; [Judy]
    followed_by = users[1:] #==&gt; [Andrew, Fred]

    for user in followed_by:
        # Add the 'follower to the list of followers user
        if user not in followers:
            followers[user] = []
        followers[user].append(follower)
print(followers.items())
</code></pre>
<p>When I print the <em>follower</em> and <em>followed by</em> variable, they are correct, but i'm having trouble adding them into the dictionary correctly; with this being the output</p>
<pre><code>dict_items([('fred\n', ['andrew', 'judy']), ('andrew', ['judy']), ('judy' ['george']), ('andrew\n', ['george']), ('george', ['john'])])
</code></pre>
<p>My desired output would be </p>
<pre><code>(Andrew[Fred])(Fred[])(judy[Andrew Fred])(George[Judy Fred])(john[george])
</code></pre>
<p>Any assistance is much appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edited answer, improved thanks to the comments from @PM2Ring and @IljaEverilä.</strong></p>
<p>Here is my original solution using a dictionary comprehension</p>
<pre><code>followers = {line.split()[0]: line.split()[1:] for line in follows_file}
</code></pre>
<p>A more efficient alternative proposed by @IljaEverilä, which avoids calling <code>split</code> twice, is:</p>
<pre><code>followers = {follower: followees for follower, *followees in map(str.split, follows_file)}
</code></pre>
<p>Result:</p>
<pre><code>{'andrew': ['fred'],
 'fred': [],
 'george': ['judy', 'andrew'],
 'john': ['george'],
 'judy': ['andrew', 'fred']}
</code></pre>
<p>Note that both of the above solutions assume that your file contains no duplicate keys.</p>
<p>Don't forget to close your file afterwards:</p>
<pre><code>follows_file.close()
</code></pre>
<p>Or better, just use a context manager, which handles the file closing for you:</p>
<pre><code>with open('C:\\Users\\zacan\\Desktop\\Python\\follows.txt', 'r') as follows_file:
    followers = {follower: followees for follower, *followees in map(str.split, follows_file)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a> as a dictionary factory and just append the users following a person, e.g.:</p>
<pre><code>import collections

followers = collections.defaultdict(list)  # use a dict factory to save some time on checks
with open("path/to/your_file", "r") as f:  # open the file for reading
    for line in f:  # read the file line by line
        users = line.split()  # split on any white space
        followers[users[0]] += users[1:]  # append the followers for the current user
</code></pre>
<p>Which will produce, for your data:</p>
<pre><code>{'andrew': ['fred'],
 'fred': [],
 'judy': ['andrew', 'fred'],
 'george': ['judy', 'andrew'],
 'john': ['george']}
</code></pre>
<p>This will also allow you to have multiple lists appended to the user on a repeating record - otherwise you can just use a normal <code>dict</code> for <code>followers</code> and set them as <code>followers[users[0]] = users[1:]</code>.</p>
<p>The data structure you've shown as your desired output is not valid Python, do you really want it presented that way? I mean, if you insist you can do it as:</p>
<pre><code>print("".join("({}[{}])".format(k, " ".join(v)) for k, v in followers.items()))
# (andrew[fred])(fred[])(judy[andrew fred])(george[judy andrew])(john[george])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one solution using <code>str.split</code> and a <code>try</code> / <code>except</code> clause to capture instances where only a key exists.</p>
<p>Note <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow noreferrer"><code>io.StringIO</code></a> lets us read from a string as if it were a file.</p>
<pre><code>from io import StringIO
import csv

mystr = StringIO("""andrew fred
fred
judy andrew fred
george judy andrew
john george""")

# replace mystr with open("C:\\Users\\zacan\\Desktop\\Python\\follows.txt")
with mystr as follows_file:
    d = {}
    for users in csv.reader(follows_file):
        try:
            key, *value = users[0].split()
        except ValueError:
            key, value = users[0], []

        d[key] = value

print(d)

{'andrew': ['fred'],
 'fred': [],
 'george': ['judy', 'andrew'],
 'john': ['george'],
 'judy': ['andrew', 'fred']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>followers = dict()
with open('C:\\Users\\zacan\\Desktop\\Python\\follows.txt', 'r') as f:
    for line in f:
        users = line.split(' ')
        followers[users[0]] = [_ for _ in users[1:]]
</code></pre>
<p>this should work, didn't test it</p>
</div>
<span class="comment-copy">Use <code>line.split()</code> to get rid of all the whitespace, including the newlines.</span>
<span class="comment-copy">At least you forgot to strip newlines, so you have <code>('andrew', ['judy'])</code> and <code>('andrew\n', ['george'])</code> separately.</span>
<span class="comment-copy"><a href="https://meta.stackoverflow.com/questions/306820/is-defacing-own-posts-worth-a-mod-flag">You're not allowed to vandalize your own questions if they're helpful to somebody else</a>. If you keep doing it there will be automatic moderator flags. Please roll back.</span>
<span class="comment-copy">Why call <code>.strip()</code> on a string that you're passing to <code>.split()</code>? And why perform that expensive operations twice on every line? Use a proper <code>for</code> loop so you don't need to do that.</span>
<span class="comment-copy"><code>{follower: followees for follower, *followees in map(str.split, f)}</code></span>
<span class="comment-copy">@PM2Ring - I hadn't realised that <code>split()</code> took care of the trailing <code>\n</code> for each line, will edit the <code>strip()</code> calls out of my answer. @IljaEverilä, nice, I was trying to think of a way to do a comprehension without calling <code>split()</code> twice, but hadn't thought of that.</span>
<span class="comment-copy">There is absolutely no reason to do list comprehension when setting the value of user followers. Also, <code>line.split(' ')</code> will produce the last user in line with a <code>\n</code> added to it, or register a new followed user with a <code>\n</code> as its last character.</span>
