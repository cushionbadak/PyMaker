<div class="post-text" itemprop="text">
<p>Hi I'm a beginner in programming but have some basic understanding.
I'm trying to do a python script which given a cpp file like this:</p>
<pre><code>///////////////////////////////////
// experimentOrientVertices.cpp
// (modifying square.cpp)
// 
// Sumanta Guha.
///////////////////////////////////

#ifdef __APPLE__
#  include &lt;GL/glew.h&gt;
#  include &lt;GL/freeglut.h&gt;
#  include &lt;OpenGL/glext.h&gt;
#else
#  include &lt;GL/glew.h&gt;
#  include &lt;GL/freeglut.h&gt;
#  include &lt;GL/glext.h&gt;
#pragma comment(lib, "glew32.lib") 
#endif

// Drawing routine.
void drawScene(void)
{
   glClear(GL_COLOR_BUFFER_BIT);

   glColor3f(0.0, 0.0, 0.0);

   // Draw a polygon with specified vertices.
   glPolygonMode(GL_FRONT, GL_LINE);
   glPolygonMode(GL_BACK, GL_FILL);
   glBegin(GL_POLYGON);
      glVertex3f(20.0, 20.0, 0.0);
      glVertex3f(80.0, 20.0, 0.0);
      glVertex3f(80.0, 80.0, 0.0);
      glVertex3f(20.0, 80.0, 0.0);
   glEnd();

   /*
   glPolygonMode(GL_FRONT, GL_LINE);
   glPolygonMode(GL_BACK, GL_FILL);
   glBegin(GL_POLYGON);
      glVertex3f(20.0, 80.0, 0.0);
      glVertex3f(20.0, 20.0, 0.0);
      glVertex3f(80.0, 20.0, 0.0);
      glVertex3f(80.0, 80.0, 0.0);
   glEnd();
   */

   /*
   glPolygonMode(GL_FRONT, GL_LINE);
   glPolygonMode(GL_BACK, GL_FILL);
   glBegin(GL_POLYGON);
      glVertex3f(80.0, 80.0, 0.0);
      glVertex3f(80.0, 20.0, 0.0);
      glVertex3f(20.0, 20.0, 0.0);
      glVertex3f(20.0, 80.0, 0.0);
   glEnd();
   */

   glFlush(); 
}

// Initialization routine.
void setup(void) 
{
   glClearColor(1.0, 1.0, 1.0, 0.0); 
}

// OpenGL window reshape routine.
void resize(int w, int h)
{
   glViewport(0, 0, w, h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glOrtho(0.0, 100.0, 0.0, 100.0, -1.0, 1.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
}

// Keyboard input processing routine.
void keyInput(unsigned char key, int x, int y)
{
   switch(key) 
   {
      case 27:
         exit(0);
         break;
      default:
         break;
   }
}

// Main routine.
int main(int argc, char **argv) 
{
   glutInit(&amp;argc, argv);

   glutInitContextVersion(4, 3);
   glutInitContextProfile(GLUT_COMPATIBILITY_PROFILE);

   glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA); 
   glutInitWindowSize(500, 500);
   glutInitWindowPosition(100, 100); 
   glutCreateWindow("experimentOrientVertices.cpp");
   glutDisplayFunc(drawScene); 
   glutReshapeFunc(resize);  
   glutKeyboardFunc(keyInput);

   glewExperimental = GL_TRUE;
   glewInit();

   setup(); 

   glutMainLoop(); 
}
</code></pre>
<p>Should output this:</p>
<pre><code>[['21=&gt;59']]
[['63=&gt;65']]
[['69=&gt;76']]
[['80=&gt;89'], ['82=&gt;88']]
[['93=&gt;113']]
</code></pre>
<p>And here's the problem, the script below output this:</p>
<pre><code>[['21=&gt;59']]
[['63=&gt;65'], ['65=&gt;63']]
[['69=&gt;76'], ['76=&gt;69']]
[['80=&gt;89'], ['82=&gt;88'], ['88=&gt;82'], ['89=&gt;80']]
[['93=&gt;113'], ['113=&gt;93']]
</code></pre>
<p>And.. really I'm not able how to figure it out
Thanks you for your time, I hope to have written the question good!</p>
<p>Here is my script:</p>
<pre><code>from sys import argv

token = {
        '{': 0
        }
level = ["" for i in range(10)]

funcStartStop = [] #list to store each function start and stop brackets value

def functionCount(filename):
    inFile = open(filename, 'r')
    currLine = 0
    mbracketopenline = [] #list to store the currLine value if a { is found
    mbracketcloseline = [] #list to store the currLine value if a } is found
    first = True
    for line in inFile:
        currLine += 1
        if "{" in line:
            token["{"] += 1
            if first:
                first = False
            mbracketopenline.append(currLine)
        if "}" in line:
            token["{"] -= 1
            mbracketcloseline.append(currLine)
        if not first and token["{"] == 0:
            first = True
            tmpfuncStartStop = []
            for i in range(mgraffeopenline.__len__()):
                tmpfuncStartStop.append([str(str(mbracketopenline[i])+"=&gt;"+str(mbracketcloseline[-i-1]))]) #store opening and
                                                                        #closing brackets in a list of list, so at the end of the cycle
                                                                        #should be something like: [['1=&gt;10'],['3=&gt;8']]
            funcStartStop.append(tmpfuncStartStop)
            mbracketcloseline = mbracketopenline = []

if __name__ == '__main__':
    functionCount(argv[1])
    for i in funcStartStop:
        print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ignoring the code errors made when you were adapting your example for SO (e.g. <code>mgraffeopenline</code> instead of <code>mbracketopenline</code>, <code>functionCount()</code> not returning a result etc.) at one point you have:</p>
<pre><code>mbracketcloseline = mbracketopenline = []
</code></pre>
<p>Effectively setting both <code>mbracketcloseline</code> and <code>mbracketopenline</code> to the same new list and whenever you modify each of them you're modifying the same list. That's primarily what causes your issue, but there are others to consider.</p>
<p>Also, as I've stated in my comment, having multiple braces on the same line is perfectly valid and you need to account for them (including their positions) so you actually need to go through your code character by character and pick up every occurrence, something like:</p>
<pre><code>def function_count(source):
    result = []
    progress = []  # a temporary list to keep our progress
    level = -1  # we'll use an index to reference the level we're at
    with open(source, "r") as f:  # open the `source` file for reading
        for i, line in enumerate(f):  # enumerate and read the file line by line
            # you can check `if "{" in line or "}" in line: ...` for a marginal speed-up
            for char in line:  # iterate over the characters in each line
                if char == "{":
                    if level == -1:  # we're at the root, start a root level
                        progress = []
                        result.append(progress)
                    progress.append([i + 1, None])  # store the line # at the level's start
                    level += 1  # increase the level
                elif char == "}":
                    if level &gt; -1:  # if we're already deep in the source tree...
                        progress[level][1] = i + 1  # store the line # at the level's end
                        level -= 1  # decrease the level
    return result
</code></pre>
<p>Which for your file produces:</p>
<pre><code>[[[21, 59]],
 [[63, 65]],
 [[69, 76]],
 [[80, 89], [82, 88]],
 [[93, 113]]]
</code></pre>
<p>But if you were to change the <code>keyInput</code> function to:</p>
<pre class="lang-c prettyprint-override"><code>void keyInput(unsigned char key, int x, int y)
{ switch(key) {
      case 27:
         exit(0);
         break;
      default:
         break;
}}
</code></pre>
<p>It will still produce a valid result:</p>
<pre><code>[[[21, 59]],
 [[63, 65]],
 [[69, 76]],
 [[80, 86], [80, 86]],
 [[90, 110]]]
</code></pre>
<p>And if you want it printed as in your example (I find having actual line indexes separated far more useful) just replace the line:</p>
<pre><code>progress[level][1] = i + 1  # store the line # at the level's end
</code></pre>
<p>With:</p>
<pre><code>progress[level] = "{}=&gt;{}".format(progress[level][0], i + 1)
</code></pre>
<p>However, this doesn't address the issue <a href="https://stackoverflow.com/users/389289/zvone"><code>zvone</code></a> mentioned where you can have braces in comments, macros, strings... and all of these will be picked up as valid starts/end of functions. There's far more to a code parser than simple character matching.</p>
<p>If you really want to dig into parsing C code, there is a very useful module <a href="https://github.com/eliben/pycparser" rel="nofollow noreferrer"><code>pycparser</code></a> designed to do just that. It might take a bit longer to set up, but it will give you far more code insight than this sort of a stab-in-the-dark parsing. Of course, it all depends on what's your actual use case...</p>
</div>
<span class="comment-copy">What would happen if you had two curly brackets in a single line which is perfectly valid even if not aesthetically pleasing?</span>
<span class="comment-copy">Be aware that your parser will probably never handle everything and will only work on <i>relatively simple</i> c++ code (e.g. an <code>#include</code> which includes a file with <code>#define int {</code> will probably break everything), so consider using an existing solution (at least if you care for such weird cases;) )</span>
<span class="comment-copy">@zwer it should handle It, i think.. btw i don't need nothing complex, i'd use It Just for move the functions above the main() and leave the prototypes up the main or maybe implement something able to split cpp files into source and header, there exist some tools which may fit my purpouse?</span>
<span class="comment-copy">@zvone i problably don't care about such weird cases,because of the the simple c++ files i need ti paese, but what solution can I use? And for last which kind or theory do i need to implement parser? Thank you</span>
<span class="comment-copy">Really thank you, now i know that mbracketcloseline = mbracketopenline = [] will reference to the same list, so it behaves like the C pointers? Something like that:       free(mBracketCloseLine);       free(mBracketOpenLine);       char <i>tmp = (char</i>) malloc(sizeof(char));       mBracketCloseLine = tmp;       mBracketOpenLine = tmp;</span>
<span class="comment-copy">@Soras - They act as pointers, but they are not - they are names bound to objects. Whenever you create an object memory is allocated for it and whenever you assign it to a name (variable) that name is bound to that object's memory location. However, when you assign one name to another (e.g. <code>var1 = var2</code>) you're not binding <code>var1</code> to <code>var2</code> but instead to the object <code>var2</code> is bound to. That's why <code>a = 1; b = a; a = 3</code> will result in <code>b</code> having a value of <code>1</code> and not <code>3</code>. You can read more on this @ <a href="https://docs.python.org/3/reference/executionmodel.html#binding-of-names" rel="nofollow noreferrer">the official docs</a>.</span>
