<div class="post-text" itemprop="text">
<p>My understanding is that the typical GIL manipulations involve, e.g., blocking I/O operations. Hence one would want to release the lock before the I/O operation and reacquire it once it has completed.</p>
<p>I'm currently facing a different scenario with a C extension: I am creating X windows that are exposed to Python via the <code>Canvas</code> class. When the method <code>show()</code> is called on an instance, a new UI thread is started using <code>PyThreads</code> (with a call to <code>PyThread_start_new_thread</code>). This new thread is responsible for drawing on the X window, using the Python code specified in the <code>on_draw</code> method of a subclass of <code>Canvas</code>. A pure C event loop is started in the main thread that simply checks for events on the X window and, for the time being, only captures the <code>WM_DELETE_EVENT</code>.</p>
<p>So I have potentially many threads (one for each X window) that want to execute Python code and the main thread that does not execute any Python code at all.</p>
<p>How do I release/acquire the GIL in order to allow the UI threads to get into the interpreter orderly?</p>
</div>
<div class="post-text" itemprop="text">
<p>The rule is easy: <strong>you need to hold the GIL to access Python machinery (any API starting with <code>Py&lt;...&gt;</code> and any <code>PyObject</code>).</strong></p>
<p>So, you can release it whenever you don't need any of that.</p>
<p>Anything further than this is the <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)#Granularity" rel="nofollow noreferrer">fundamental problem of locking granularity</a>: potential benefits vs locking overhead. <a href="http://dabeaz.blogspot.ru/2011/08/inside-look-at-gil-removal-patch-of.html" rel="nofollow noreferrer">There was an experiment for Py 1.4 to replace the GIL with more granular locks that failed exactly because the overhead proved prohibitive.</a></p>
<p>That's why it's typically released for code chunks involving call(s) to extental facilities that can take arbitrary time (especially if they involve waiting for external events) -- if you don't release the lock, Python will be just idling during this time.</p>
<hr/>
<p>Heeding this rule, you will get to your goal automatically: whenever a thread can't proceed further (whether it's I/O, signal from another thread, or even so much as a <code>time.sleep()</code> to avoid a busy loop), it will release the lock and allow other threads to proceed in its stead. The GIL assigning mechanism strives to be <a href="https://en.wikipedia.org/wiki/Fair_queuing" rel="nofollow noreferrer">fair</a> (see <a href="https://bugs.python.org/issue8299" rel="nofollow noreferrer">issue8299</a> for exploration on how fair it is), releasing the programmer from bothering about any bias stemming solely from the engine.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem stems from the fact that, in my opinion, the <a href="https://docs.python.org/3/c-api/init.html#non-python-created-threads" rel="nofollow noreferrer">official documentation</a> is a bit ambiguous on the meaning of <em>Non-Python created threads</em>. Quoting from it:</p>
<blockquote>
<p>When threads are created using the <strong>dedicated Python APIs</strong> (such as the <code>threading</code> module), a thread state is automatically associated to them and the code showed above is therefore correct. However, when threads are created from C (for example by a <strong>third-party library</strong> with its own thread management), they don’t hold the GIL, nor is there a thread state structure for them.</p>
</blockquote>
<p>I have highlighted in bold the parts that I find off-putting. As I have stated in the OP, I am calling <code>PyThread_start_new_thread</code>. Whilst this creates a new thread from C, this function is not part of a third-party library, but of the dedicated Python (C) APIs. Based on this assumption, I ruled out that I actually needed to use the <code>PyGILState_Ensure/PyGILState_Release</code> paradigm.</p>
<p>As far as I can tell from what I've seen with my experiments, a thread created from C with (just) <code>PyThread_start_new_thread</code> should be considered as a <em>non-Python created thread</em>.</p>
</div>
<span class="comment-copy">This article might be of interest:  <a href="https://opensource.com/article/17/4/grok-gil" rel="nofollow noreferrer">opensource.com/article/17/4/grok-gil</a></span>
<span class="comment-copy">Thanks but I've already been through that post. I have the feeling that the key is in the PyEval_* functions. However, it seems that a call to PyEval_AcquireLock from a third thread causes <code>Fatal Python error: PyEval_AcquireLock: current thread state is NULL</code> and I cannot understand why.</span>
<span class="comment-copy">Did you read this also?  <a href="https://docs.python.org/2.4/api/threads.html" rel="nofollow noreferrer">docs.python.org/2.4/api/threads.html</a></span>
<span class="comment-copy">Yes, that too, and I couldn't figure out what exactly the thread state is and how, if possible at all, you could create one manually.</span>
<span class="comment-copy">Thanks for the answer. I thought that the GIL was required to guard just Python bytecode, and that C APIs would be fine outside of it. Anyhow, I have tried what you suggest but, unless I've forgotten some lines of code, I am still getting a NULL current thread state in the third thread. This is where a SIGSEGV is generated: <code>0x569d26 &lt;PyErr_Clear+6&gt;        mov    rax,QWORD PTR [rip+0x4f71c3]        # 0xa60ef0 &lt;_PyThreadState_Current&gt;</code>. After this instruction <code>rax</code> is 0.</span>
<span class="comment-copy">@Phoenix87 you'll need to give a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> for us to be able to tell anything specific. All I can say now is that <code>PyErr_Clear</code> is Python API so you need to hold the GIL; and that you need to get/release the GIL with <code>By_BEGIN/END_ALLOW_THREADS</code> macros that not only handles the lock but also saves/restores Python thread state from a local variable introduced by these macros.</span>
<span class="comment-copy">@Phoenix87 Since this question asks about the general principle and your problem may have nothing to do with the GIL whatsoever (e.g. you might be using the API incorrectly), this probably warrants a separate question.</span>
<span class="comment-copy">AFAICS, <code>PyThread_start_new_thread</code> is not a part of public API, so if you use it, all bets are off. You should rather use fns from <code>threading</code> or <code>_thread</code> module. Or start a regular C thread, then convert it into Python thread as per <a href="https://stackoverflow.com/questions/29595222/multithreading-with-python-and-c-api" title="multithreading with python and c api">stackoverflow.com/questions/29595222/…</a> .</span>
<span class="comment-copy">How can one tell whether it is public or not if it can be used by importing the containing header file?</span>
<span class="comment-copy">It's public if it's documented. If it's not documented, you just don't have any guarantess about its presence and behavior. I dunno why nonpublic symbols are in <code>Python.h</code>. Probably for simplicity 'cuz it's widely used around the codebase. You can ask at the <code>python-dev</code> mailing list about this.</span>
