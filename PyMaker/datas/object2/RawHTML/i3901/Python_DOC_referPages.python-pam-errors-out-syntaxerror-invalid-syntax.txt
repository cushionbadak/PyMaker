<div class="post-text" itemprop="text">
<p>I am working on Python 3 and tried installing pam, which was successful. It installed the pam-0.1.4 version. </p>
<pre><code>C:\Users\anjan&gt;pip install pam
Collecting pam
  Downloading https://files.pythonhosted.org/packages/d6/cb/73c7725f4c7ee14205d85c6777a44f9b33e51d31fd5fc1bb0aa7f35cf8d2/pam-0.1.4.tar.gz
Building wheels for collected packages: pam
  Running setup.py bdist_wheel for pam ... done
  Stored in directory: C:\Users\anjan\AppData\Local\pip\Cache\wheels\24\8d\30\48fca5978b858d699565ee0cde875798229022bbb4e86e8b43
Successfully built pam
Installing collected packages: pam
Successfully installed pam-0.1.4
</code></pre>
<p>Next when I try to import pam it throws out the following syntax error. Looks like the pam.py file is still on Python2.x. </p>
<p>Does anyone know how to resolve this issue?</p>
<pre><code>    &gt;&gt;&gt; import pam
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\Users\anjan\Anaconda3\lib\site-packages\pam.py", line 129
    print authenticate(getpass.getuser(), getpass.getpass())
                     ^
SyntaxError: invalid syntax
</code></pre>
<p>The pam.py file looks like as shown below.</p>
<pre><code># (c) 2007 Chris AtLee &lt;chris@atlee.ca&gt;
# Licensed under the MIT license:
# http://www.opensource.org/licenses/mit-license.php
"""
PAM module for python

Provides an authenticate function that will allow the caller to authenticate
a user against the Pluggable Authentication Modules (PAM) on the system.

Implemented using ctypes, so no compilation is necessary.
"""
__all__ = ['authenticate']

from ctypes import CDLL, POINTER, Structure, CFUNCTYPE, cast, pointer, sizeof
from ctypes import c_void_p, c_uint, c_char_p, c_char, c_int
from ctypes.util import find_library

LIBPAM = CDLL(find_library("pam"))
LIBC = CDLL(find_library("c"))

CALLOC = LIBC.calloc
CALLOC.restype = c_void_p
CALLOC.argtypes = [c_uint, c_uint]

STRDUP = LIBC.strdup
STRDUP.argstypes = [c_char_p]
STRDUP.restype = POINTER(c_char) # NOT c_char_p !!!!

# Various constants
PAM_PROMPT_ECHO_OFF = 1
PAM_PROMPT_ECHO_ON = 2
PAM_ERROR_MSG = 3
PAM_TEXT_INFO = 4

class PamHandle(Structure):
    """wrapper class for pam_handle_t"""
    _fields_ = [
            ("handle", c_void_p)
            ]

    def __init__(self):
        Structure.__init__(self)
        self.handle = 0

class PamMessage(Structure):
    """wrapper class for pam_message structure"""
    _fields_ = [
            ("msg_style", c_int),
            ("msg", POINTER(c_char)),
            ]

    def __repr__(self):
        return "&lt;PamMessage %i '%s'&gt;" % (self.msg_style, self.msg)

class PamResponse(Structure):
    """wrapper class for pam_response structure"""
    _fields_ = [
            ("resp", POINTER(c_char)),
            ("resp_retcode", c_int),
            ]

    def __repr__(self):
        return "&lt;PamResponse %i '%s'&gt;" % (self.resp_retcode, self.resp)

CONV_FUNC = CFUNCTYPE(c_int,
        c_int, POINTER(POINTER(PamMessage)),
               POINTER(POINTER(PamResponse)), c_void_p)

class PamConv(Structure):
    """wrapper class for pam_conv structure"""
    _fields_ = [
            ("conv", CONV_FUNC),
            ("appdata_ptr", c_void_p)
            ]

PAM_START = LIBPAM.pam_start
PAM_START.restype = c_int
PAM_START.argtypes = [c_char_p, c_char_p, POINTER(PamConv),
        POINTER(PamHandle)]

PAM_END = LIBPAM.pam_end
PAM_END.restpe = c_int
PAM_END.argtypes = [PamHandle, c_int]

PAM_AUTHENTICATE = LIBPAM.pam_authenticate
PAM_AUTHENTICATE.restype = c_int
PAM_AUTHENTICATE.argtypes = [PamHandle, c_int]

def authenticate(username, password, service='login'):
    """Returns True if the given username and password authenticate for the
    given service.  Returns False otherwise

    ``username``: the username to authenticate

    ``password``: the password in plain text

    ``service``: the PAM service to authenticate against.
                 Defaults to 'login'"""
    @CONV_FUNC
    def my_conv(n_messages, messages, p_response, app_data):
        """Simple conversation function that responds to any
        prompt where the echo is off with the supplied password"""
        # Create an array of n_messages response objects
        addr = CALLOC(n_messages, sizeof(PamResponse))
        p_response[0] = cast(addr, POINTER(PamResponse))
        for i in range(n_messages):
            if messages[i].contents.msg_style == PAM_PROMPT_ECHO_OFF:
                pw_copy = STRDUP(str(password))
                p_response.contents[i].resp = pw_copy
                p_response.contents[i].resp_retcode = 0
        return 0

    handle = PamHandle()
    conv = PamConv(my_conv, 0)
    retval = PAM_START(service, username, pointer(conv), pointer(handle))

    if retval != 0:
        # TODO: This is not an authentication error, something
        # has gone wrong starting up PAM
        PAM_END(handle, retval)
        return False

    retval = PAM_AUTHENTICATE(handle, 0)
    e = PAM_END(handle, retval)
    return retval == 0 and e == 0

if __name__ == "__main__":
    import getpass
    print authenticate(getpass.getuser(), getpass.getpass())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>print</code> is a function in Python 3.</p>
<p>Change it to</p>
<pre><code>print(authenticate(getpass.getuser(), getpass.getpass()))
#    ^ Note the braces that make it a function call
</code></pre>
<p>The way you have it written is valid only in Python 2. </p>
</div>
<div class="post-text" itemprop="text">
<p>Pam 0.1.4 is for python2, hence the error. There is a pam available for python3 , but it is called as simplepam -0.1.5 . I guess this should be a probable fix for my question. 
[link] (pypi.org/project/simplepam)</p>
</div>
<span class="comment-copy">The pam.py file is from the package and not self written. I tried to resolve this issue by just changing the print statement to print(...) , which is suitable to python3. But this just temporarily solves the issue.  Later I am getting more issues as the functions and references in pam.py are suitable for python2 and not 3.</span>
<span class="comment-copy">@AnjanaShivangi Then you'll need to convert all the sources that you intend to use with 3 to be compatible with 3. There's a tool available via pip called (iirc) py2to3, but it was pretty bad last time I tried to use it. If the entirety of the source is aimed at 2, and conversion isn't feasible, you'll have to run it under a Python 2 interpreter.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/2to3.html" rel="nofollow noreferrer">docs.python.org/3/library/2to3.html</a></span>
<span class="comment-copy">Thanks for your response. Yes, I am aware of Py2to3 and used it on rest of my project as I has to upgrade from Python2.6 to 3.5. Like you said, it's not that great and also not ideal to use Py2to3 on a file from any python package, as it may have many functions that Py2to3 may not replace.  However, after more digging I found that there is a pam available for python3 , but it is called as simplepam -0.1.5 . I guess this should be a probable fix for my question.  [link] (<a href="https://pypi.org/project/simplepam/" rel="nofollow noreferrer">pypi.org/project/simplepam</a>)</span>
