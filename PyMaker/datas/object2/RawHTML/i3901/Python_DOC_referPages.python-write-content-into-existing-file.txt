<div class="post-text" itemprop="text">
<p>So my aim is to delete all the \n from the end of every file in a directory, then append the file. Struggling to do the appending part of it.</p>
<pre><code>import os
print("Copy paste full directory path here:")
directory = input()


for filename in os.listdir(directory):
    if filename.endswith(".txt"):
        with open(os.path.join(directory, filename), "r+") as f:
            lines = f.readlines()        
            for line in lines:
                if lines[-1] in ['\n', '\r']:
                    lines = lines[:-1]
                    print(lines)     
            f.writelines(lines)
</code></pre>
<p>So this does practically what I want, however its adds everything underneath the content, rather than replacing it. Could I get help for this please :)?</p>
</div>
<div class="post-text" itemprop="text">
<p>An easier way is to memory map the file using <a href="https://docs.python.org/3/library/mmap.html#module-mmap" rel="nofollow noreferrer"><code>mmap()</code></a>. This allows you to manipulate the file as both a <code>bytearray</code> or a file. Changes made to map are reflected in the underlying file.</p>
<p>You can use a regular expression to determine the beginning of a trailing run of new line or carriage returns, and then overwrite the file directly.</p>
<pre><code>import re
from mmap import mmap

append_string = b'\nhi there\n'

with open('/tmp/hosts', "r+b") as f:
    with mmap(f.fileno(), 0) as m:
        match = re.search(rb'[\r\n]+$', m)
        append_pos = match.start() if match else m.size()
        m.resize(append_pos + len(append_string))
        m[append_pos:] = append_string
</code></pre>
<p>You might actually want to replace the whitespace at the end of the file, e.g. a line might contain spaces. If so change the regex pattern to <code>rb'\s+$'</code>.</p>
<p>The above code should run on Unix. You might need to tinker with the call to <code>mmap()</code> if you are using a different platform.</p>
<p>For larger files, i.e. those that are larger than the page size used by <code>mmap()</code>, you might be able to make this more efficient by scanning from the end of the map for new lineish characters to determine the position in the file from which to overwrite.</p>
</div>
<div class="post-text" itemprop="text">
<p>Look for os.walk() and 'r+' mode .</p>
</div>
<div class="post-text" itemprop="text">
<p>As people have pointed out you need to first open the file and read the data. Then open the file in write mode and write it back.</p>
<p>The following code should do the trick and is reading the whole file and thereby remove some complexity of loops as well</p>
<pre><code>import os
directory = './test'

for filename in os.listdir(directory):
    if filename.endswith(".txt"):
        clean = open(directory + "/" +filename).read().replace('\n', '')
        outfile = open(directory + "/" +filename, 'w')
        outfile.write(clean)
        outfile.close()
</code></pre>
</div>
<span class="comment-copy">You need to open the file in append mode, I guess (use a instead of r+)</span>
<span class="comment-copy">First read the file and then open it in append mode (<code>'a'</code>) to write to it</span>
<span class="comment-copy">Opps. Added the variable i in it, using a, flags an io error (out of range)</span>
<span class="comment-copy">Trying remove \n from end of the file, not each line. thanks :)</span>
