<div class="post-text" itemprop="text">
<p>When line 2 in the text file has 'nope' then it will ignore the line and continue the next one. Is there another way to write this without using try and except? Can I use if else statement to do this?</p>
<p>Example of text file:</p>
<pre><code>0 1 
0 2 nope
1 3 
2 5 nope
</code></pre>
<p>Code:    </p>
<pre><code>e = open('e.txt')
alist = []
for line in e:
    start = int(line.split()[0])
    target = int(line.split()[1])
    try:
        if line.split()[2] == 'nope':
            continue
    except IndexError:
        alist.append([start, target])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can use <a href="https://docs.python.org/3/library/stdtypes.html#str.endswith" rel="nofollow noreferrer"><code>str.endswith()</code></a> method to check the trailing of the lines.</p>
<pre><code>with  open('e.txt') as f:
    for line in f:
        if not line.endswith(('nope', 'nope\n')):
            start, target = line.split()
            alist.append([int(start), int(target)])
</code></pre>
<p>Note that when you use a <code>with</code> statement to open a file you don't need to close the file explicitly the file will be closed automatically at the end of the block.</p>
<p>Another but more optimized approach to solve this is to use a list comprehension in order to refuse appending to the list at each iteration and benefit from its performance compare to a regular loop.</p>
<pre><code>with open('e.txt') as f:
    alist = [tuple(int(n) for i in line.split()) for line in f if not line.endswith(('nope', 'nope\n'))]
</code></pre>
<p>Note that still, since your code is exception prone because of converting strings to integer and splitting the lines, etc. It's better to use a try-except in order to prevent your code from possible exceptions and handle them properly.</p>
<pre><code>with  open('e.txt') as f:
    for line in f:
        if not line.endswith(('nope', 'nope\n')):
            try:
                start, target = line.split()
            except ValueError:
                # the line.split() returns more or less than two items
                pass # or do smth else
            try:
                alist.append([int(start), int(target)])
            except ValueError:
                # invalid literal for int() with base 10
                pass # or do smth else
</code></pre>
<p>Another and yet Pythonic approach is to use <code>csv</code> module for reading the file. In that case you don't need to split the lines and/or use <code>str.endswith()</code>.</p>
<pre><code>import csv
with open("e.txt") as f:
    reader = csv.reader(f, delimiter=' ')
    alist = [(int(i), int(j)) for i, j, *rest in reader if not rest[0]]
    # rest[0] can be either an empty string or the word 'nope' if it's
    # an empty string we want the numbers. 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open('e.txt', 'r') as f:
    alist = []
    for line in f:
        words = line.split()
        if len(words) &gt; 2 and words[2] == 'nope':
            continue
        else:
            alist.append([int(words[0]), int(words[1])])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>nope</code> can be not only at the end of the line you can use this</p>
<pre><code>with open('e.txt') as e:
    alist = [line.split() for line in e if 'nope' not in line]

print(alist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Can I use if else statement to do this?</p>
</blockquote>
<p>You should use if-else statements, not exceptions, to control the flow in case of ordinary “events” which you expect. This is common “rule” in many languages, <s>I think Python doesn't raise an exception here</s>, Python <em>is</em> an exception here, but hopefully not in cases like this.</p>
<p>Following your code but without calling <code>line.split()</code> each time, removing the try-except and using a proper condition in the <code>if</code>:</p>
<pre><code>alist = []
with open('e.txt') as e:
    for line in e:
        splitted = line.split()
        if len(splitted) &gt; 2 and splitted[2] == 'nope':
            continue
        else:
            alist.append([int(splitted[0]), int(splitted[1])])
</code></pre>
<p>And of course you can negate the condition and avoid the <code>continue</code>:</p>
<pre><code>if len(splitted) &lt;= 2 or splitted[2] != 'nope':
    alist.append([int(splitted[0]), int(splitted[1])])
</code></pre>
<p>Which shows (another) weakness in case when you have less than 2 elements. Here you could use <em>try</em>: the exception in this case tells you that the input format is wrong (because you expect at least 2 elements, it seems), so you have to reject the input and warn the user. Also, you could intercept <code>ValueError</code> if those 2 elements aren't integers.</p>
<p>Moreover, if your input is allowed to contain extra spaces, you can use something like <code>splitted[2].strip()</code>.</p>
<hr/>
<p>Readings on SO/SE about the try-except matter.</p>
<ul>
<li><a href="https://stackoverflow.com/questions/1835756/using-try-vs-if-in-python">Using try vs if in python</a>, whence I like to quote: “It's perfectly OK (and "pythonic") to use try/except for flow control, but it makes sense most when <code>Exceptions</code> are actually exceptional.”</li>
<li><a href="https://stackoverflow.com/questions/16138232/is-it-a-good-practice-to-use-try-except-else-in-python">Is it a good practice to use try-except-else in Python?</a></li>
<li><a href="https://stackoverflow.com/questions/2522005/cost-of-exception-handlers-in-python">Cost of exception handlers in Python</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/351110/are-exceptions-for-flow-control-best-practice-in-python">Are exceptions for flow control best practice in Python?</a></li>
<li><a href="https://stackoverflow.com/questions/7274310/python-using-exceptions-for-control-flow-considered-bad">Python using exceptions for control flow considered bad?</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>alist = []
with open('e.txt') as fin:
    for line in fin:
        rest_line, nope = line.strip().rsplit(' ', 1)
        if nope != 'nope':
            alist.append([int(rest_line), int(nope)])
</code></pre>
</div>
<span class="comment-copy">What are you trying to achieve here? Two possibilities spring to mind: 1. test for the length of the split string, 2 test for the presence of 'nope at the end of/in the string.</span>
<span class="comment-copy">I don't know if it is common practice in Python, but otherwise you shouldn't use exception to control the flow of you program in case of expected things happening: here you know "nope" could not exist, hence split and count how many elements you have, then decide to check the third or not. And also, I'd use a variable instead of splitting the line each time you need it: do it once, <code>splitted = line.split()</code>, then use this…</span>
<span class="comment-copy">But what if the line ends with "Deuteranope"?</span>
<span class="comment-copy">@Aran-Fey <code>line.endswith(' nope')</code> haha</span>
<span class="comment-copy">The OP appended integers, not strings, in <code>alist</code>. Missed that at first even in my answer.</span>
<span class="comment-copy">@ShinTakezou Yes, just updated.</span>
<span class="comment-copy">And the OP appends integers, not strings (I missed it at first even in my answer)</span>
<span class="comment-copy">Come on, <code>all([len(words) &gt; 2, words[2] == 'nope']</code> is not only a really obscure way to write <code>len(words) &gt; 2 and words[2] == 'nope'</code>, it also completely misses the point as the evaluation is not lazy here and your code will still raise the same exception.</span>
<span class="comment-copy">@Frax  I had only len(words) &gt; 2 bcoz I thought that's should be enough. Then, Aran-Fey mentioned that the second words must be 'nope'. I understand your concern.</span>
<span class="comment-copy">@mamun I'm not sure you understand seriousness of the issue: to evaluate <code>all([len(words) &gt; 2, words[2] == 'nope']</code> you need to evaluate <code>words[2] == 'nope'</code> first, so if it's out of bounds you will trigger an exception before actually calling <code>all()</code>. (note: the issue is already fixed)</span>
<span class="comment-copy">@mamun the last line, <code>alist.append([int(words[0]), int(words[1])])</code></span>
<span class="comment-copy">In Python, throwing exceptions for normal situations, and catching exceptions rather than preventing them, is more idiomatic than in other languages. For instance, an iterator's <code>next</code> method throws an exception to indicate when all elements have been visited.</span>
<span class="comment-copy">See, for example, <a href="https://stackoverflow.com/questions/11360858/what-is-the-eafp-principle-in-python" title="what is the eafp principle in python">stackoverflow.com/questions/11360858/…</a> .</span>
<span class="comment-copy">@Sneftel Indeed, the general rule allows and even encourages to use exceptions, so this remark in the answer is wrong. However, I don't think this rule applies to this specific case. Here you have straighforward condition that is more readable (and shorter) to check directly.</span>
<span class="comment-copy">@Sneftel I read something eons ago, which likely is what triggered the doubt <a href="https://stackoverflow.com/questions/50432668/other-options-instead-of-using-try-except/50432859?noredirect=1#comment87879706_50432668">in this comment</a>. I disagree here is good, and likely elsewhere, unless the <code>except</code> is anyway an exception (i.e., it occurs less than, say, half the time). If this probable efficiency loss doesn't matter—since efficiency doesn't always matter—it still looks more a matter of taste and (maybe) readability - maintainability than anything else. I don't think the <i>try</i> adds anything here.</span>
