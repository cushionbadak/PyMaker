<div class="post-text" itemprop="text">
<p>I've been studying algorithms like crazy for a big interview. This particular algorithm is driving me crazy I've added comments to some lines that don't understand.</p>
<pre><code>def permute(s):
    out = []

    if len(s) == 1:
        # wouldn't setting out replace everything in out?
        out = [s]

    else:
        for i, let in enumerate(s):

            # how does it know that I only want 2 strings?
            for perm in permute(s[:i] + s[i+1:]):

                out += [let + perm]

    return out

print permute("cat")
</code></pre>
<p>Is it correct to say that the time complexity of this algorithm is O(n!)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Initially out is defined inside the context of the permute method, so each call will have its own out vector. So when redefining <code>out = [s]</code> you just overriding the <code>out=[]</code> inside the method context.</p>
<p>If the input is bigger than one char this is what happens:</p>
<pre><code># Iterate for each char
for i, let in enumerate(s):
    # Iterate for each permutation of the string without the char i
    for perm in permute(s[:i] + s[i+1:]):
            # Put the removed char in the beginning of the permutation
            # and add it to the list.
            out += [let + perm]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun, here's a generator version of that algorithm. It's a bit nicer because it doesn't require those <code>out</code> lists.</p>
<pre><code>def permute(s):
    if len(s) == 1:
        yield s
    else:
        for i, let in enumerate(s):
            for perm in permute(s[:i] + s[i+1:]):
                yield let + perm

for s in permute("abc"):
    print(s)
</code></pre>
<p><strong>output</strong></p>
<pre><code>abc
acb
bac
bca
cab
cba
</code></pre>
<p>Of course, it's almost always better to avoid recursion (especially in Python) unless the problem needs recursion (eg processing recursive data structure, like trees). And of course a real Python program would normally use <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a>, unless it needs to correctly handle repeating items in the base sequence. In that case, I recommend the iterative algorithm of Narayana Pandita, as shown in <a href="https://stackoverflow.com/a/31678111/4014959">this answer</a>.</p>
</div>
<span class="comment-copy">As an aside - In an interview the interviewer does not usually care if you get the correct answer. What they are trying to find out how you approach a problem.</span>
<span class="comment-copy">It's actually a little worse than O(n!), <a href="https://oeis.org/A002627" rel="nofollow noreferrer">A002627</a> gives the sequence: 1, 3, 10, 41, 206, 1237, 8660, ...</span>
<span class="comment-copy">I don't get this comment: "# how does it know that I only want 2 strings?" <code>s[:i] + s[i+1:]</code> creates a single string which is a copy of <code>s</code> with the char at index <code>i</code> removed.</span>
<span class="comment-copy">As for your 1st comment, bear in mind that each recursive call to <code>permute</code> gets its own fresh <code>out</code> list.</span>
<span class="comment-copy">I would actually change <code>out = [s]</code> to <code>return [s]</code>. It's a base case and returning directly from it seems clearer to me.</span>
