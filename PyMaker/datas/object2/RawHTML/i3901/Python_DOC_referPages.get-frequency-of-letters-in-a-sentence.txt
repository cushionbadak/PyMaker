<div class="post-text" itemprop="text">
<p>I am trying to make a code where I can input a random sentence, and count the frequency of the times a letter returns in this string:</p>
<pre><code>def getfreq(lines):
    """ calculate a list with letter frequencies

    lines - list of lines (character strings)

    both lower and upper case characters are counted.
    """
    totals = 26*[0]
    chars = []
    for line in lines:
       for ch in line:
           chars.append(totals)

    return totals

    # convert totals to frequency
    freqlst = []
    grandtotal = sum(totals)

    for total in totals:
        freq = totals.count(chars)
        freqlst.append(freq)
    return freqlst
</code></pre>
<p>So far I have achieved to append each letter of the input in the list (chars). But now I need a way to count the amount of times a character returns in that list, and express this in a frequency.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without a <code>collections.Counter</code>:</p>
<pre><code>import collections

sentence = "A long sentence may contain repeated letters"

count = collections.defaultdict(int)  # save some time with a dictionary factory
for letter in sentence:  # iterate over each character in the sentence
    count[letter] += 1  # increase count for each of the sentences
</code></pre>
<p>Or if you really want to do it fully manually:</p>
<pre><code>sentence = "A long sentence may contain repeated letters"

count = {}  # a counting dictionary
for letter in sentence:  # iterate over each character in the sentence
    count[letter] = count.get(letter, 0) + 1  # get the current value and increase by 1
</code></pre>
<p>In both cases <code>count</code> dictionary will have each different letter as its key and its value will be the number of times a letter was encountered, e.g.:</p>
<pre><code>print(count["e"])  # 8
</code></pre>
<p>If you want to have it case-insensitive, be sure to call <code>letter.lower()</code> when adding it to the count.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a very handy function, <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a>, within the <code>collections</code> module which will compute the frequency of objects within a sequence:</p>
<pre><code>import collections
collections.Counter('A long sentence may contain repeated letters')
</code></pre>
<p>which will produce:</p>
<pre><code>Counter({' ': 6,
         'A': 1,
         'a': 3,
         'c': 2,
         'd': 1,
         'e': 8,
         'g': 1,
         'i': 1,
         'l': 2,
         'm': 1,
         'n': 5,
         'o': 2,
         'p': 1,
         'r': 2,
         's': 2,
         't': 5,
         'y': 1})
</code></pre>
<p>In your case, you might want to concatenate your lines, e.g. using <code>''.join(lines)</code> before passing into the <code>Counter</code>.</p>
<p>If you want to achieve a similar result using raw dictionaries, you might want to do something like the following:</p>
<pre><code>counts = {}
for c in my_string:
    counts[c] = counts.get(c, 0) + 1
</code></pre>
<p>Depending on your version of Python, this may be slower, but uses the <code>.get()</code> method of <code>dict</code> to either return an existing count or a default value before incrementing the count for each character in your string.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a set to reduce the text to unique characters and then just count: </p>
<pre><code>text = ' '.join(lines)  # Create one long string
# Then create a set of all unique characters in the text
characters = {char for char in text if char.isalpha()}
statistics = {}         # Create a dictionary to hold the results
for char in characters: # Loop through unique characters
    statistics[char] = text.count(char) # and count them
</code></pre>
</div>
<span class="comment-copy">Why does your function have 2 <code>return</code> statements? The second part will never run...</span>
<span class="comment-copy">A better way to organize your results might be a dictionary such as <code>{'a': 5, 'b': 2, 'G': 7, ... }</code></span>
<span class="comment-copy"><i>"Unsurprisingly, that will be <b>much</b> slower"</i>  &lt;-- That's actually not true. On Python 2.x <code>collections.Counter</code> will be much slower (like double the time, depends on the data of course) and on Python 3.x <code>collections.Counter</code> will only be marginally faster (like ~10%). The only consistently speedy way to do it is with a dictionary factory or with an actual <code>if letter in count: count[letter] += 1 else: count[letter] = 1</code> check (which should be the fastest of them all, in all Python versions).</span>
<span class="comment-copy">Thanks to @zwer for checking the relative speeds - I've adjusted the answer to make more conservative claims.</span>
