<div class="post-text" itemprop="text">
<p>Below tornado APP has 2 end points. One(/) is slow because it waits for an IO operation and other(/hello) is fast.
My requirement is to make a request to both end points simultaneously.I observed it takes 2nd request only after it finishes the 1st one. Even though It is asynchronous why it is not able to handle both requests at same time ?
How to make it to handle simultaneously?</p>
<p>Edit : I am using windows 7, Eclipse IDE</p>
<pre><code>****************Module*****************
import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
    @tornado.web.asynchronous
    def get(self):
        self.do_something()
        self.write("FINISHED")
        self.finish()

    def do_something(self):
        inp = input("enter to continue")
        print (inp)
class HelloHandler(tornado.web.RequestHandler):

    def get(self):
        print ("say hello")
        self.write("Hello bro")
        self.finish(
def make_app():
    return tornado.web.Application([
    (r"/", MainHandler),
    (r"/hello", HelloHandler)
])
if __name__ == "__main__":
    app = make_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.current().start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is asynchronous only if you make it so. A Tornado server runs in a single thread. If that thread is blocked by a synchronous function call, nothing else can happen on that thread in the meantime. What <code>@tornado.web.asynchronous</code> enables is the use of generators:</p>
<pre><code>@tornado.web.asynchronous
def get(self):
    yield from self.do_something()
    ^^^^^^^^^^
</code></pre>
<p>This <code>yield</code>/<code>yield from</code> (in current Python versions <code>await</code>) feature <em>suspends</em> the function and lets other code run on the same thread while the asynchronous call completes elsewhere (e.g. waiting for data from the database, waiting for a network request to return a response). I.e., if Python doesn't actively have to do something but is waiting for external processes to complete, it can yield processing power to other tasks. But since your function is very much running in the foreground and blocking the thread, nothing else will happen.</p>
<p>See <a href="http://www.tornadoweb.org/en/stable/guide/async.html" rel="nofollow noreferrer">http://www.tornadoweb.org/en/stable/guide/async.html</a> and <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio.html</a>.</p>
</div>
<span class="comment-copy"><code>input</code> is a blocking function. You need a non-blocking alternative like <code>sys.stdin</code> to capture user input. I have answered a similar question a little while ago - <a href="https://stackoverflow.com/q/49871048/1925257">stackoverflow.com/q/49871048/1925257</a></span>
<span class="comment-copy">Thanks @deceze Ok, I use Windows 7 , does it make any difference?</span>
<span class="comment-copy">Not as far as I know.</span>
<span class="comment-copy"><a href="http://www.tornadoweb.org/en/stable/gen.html" rel="nofollow noreferrer">tornadoweb.org/en/stable/gen.html</a> , according to this we can either use coroutines or asynchronous right ?</span>
<span class="comment-copy">If you're using a recent Python version (3.5+ off the top of my head?), you should use <code>async def foo(self): await some_async_task()</code> syntax. These are just different syntaxes for the same underlying thing, and <code>async def</code>/<code>await</code> is the current standard.</span>
