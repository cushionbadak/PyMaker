<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/25336726/why-cant-i-iterate-twice-over-the-same-data">Why can't I iterate twice over the same data?</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/14637154/performing-len-on-list-of-a-zip-object-clears-zip">Performing len on list of a zip object clears zip [duplicate]</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have the <code>zip</code> object:</p>
<pre><code>L_RANGES = zip(range(10, 20), range(11, 21))
</code></pre>
<p>First call of <code>L_RANGES</code> is ok:</p>
<pre><code>print(type(L_RANGES))
for a, b in L_RANGES:
  print(a, b)
</code></pre>
<p>Output:</p>
<pre><code>&lt;class 'zip'&gt;
10 11
11 12
12 13
13 14
14 15
15 16
16 17
17 18
18 19
19 20
</code></pre>
<p>Bu the next calls do not display anything. Is there any way to maintain or reset that. So far I can just convert it to the list:</p>
<pre><code>L_RANGES = list(zip(range(10, 20), range(11, 21)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you were to create a generator each time you loop, that would solve everything, because you could reuse that multiple times. For that, convert <code>L_RANGES</code> from a simple generator to a <code>lambda</code> creating generators, but don't forget to "call" it each time with <code>()</code>:</p>
<pre><code>L_RANGES = lambda: zip(range(10, 20), range(11, 21))

for a, b in L_RANGES():
  print(a, b)

for a, b in L_RANGES():
  print(a, b)

#works as many times as you want
</code></pre>
<p>Compared to the other answers this doesn't take up memory (which is the downside of converting to a list) and doesn't require multiple variables for each time you want to loop (by using <code>tee</code>) which makes this way more flexible (you can iterate 1000 times if necessary, without creating <code>L_RANGES_1...L_RANGES_999</code>) for example:</p>
<pre><code>for i in range(1000):
    for a, b in L_RANGES():
        print(a, b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An iterator, once exhausted, may not be reused. In Python 3.x, <code>zip</code> returns an iterator. One solution is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a> to copy an iterator <em>n</em> times.</p>
<p>For example, setting <code>n = 2</code>, we can do the following:</p>
<pre><code>from itertools import tee

L_RANGES_1, L_RANGES_2 = tee(zip(range(10, 20), range(11, 21)), 2)

for item in L_RANGES_1:
    # do something

for item in L_RANGES_2:
    # do something else
</code></pre>
<p>Conversion to a <code>list</code> allows use an arbitrary number of times, but is inadvisable for large iterables due to the memory overhead.</p>
<p>For a large number of copies, you can use a dictionary. For example:</p>
<pre><code>L_RANGES = dict(zip(range(1000), tee(zip(range(10, 20), range(11, 21)), 1000)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x <code>zip()</code> returns iterator that gets exhausted.</p>
<p>Simplest way to avoid it is:</p>
<pre><code>L_RANGES = list(zip(range(10, 20), range(11, 21)))
</code></pre>
</div>
<span class="comment-copy">Related: <a href="//stackoverflow.com/q/3266180">Can iterators be reset in Python?</a></span>
<span class="comment-copy">For an arbitrary number of variables, you would use a dictionary rather than many named variables. But the rest of your answer makes sense.</span>
<span class="comment-copy">Good point @jpp</span>
