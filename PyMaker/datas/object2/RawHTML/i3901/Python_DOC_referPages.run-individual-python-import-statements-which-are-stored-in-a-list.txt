<div class="post-text" itemprop="text">
<p>I have a list of libraries i'd like to import, but some of them may not be in the filesystem.</p>
<p>Basically, i want to do something like this:</p>
<pre><code>list_of_imports = ['from path1.path2.path3 import x', 'from path1.path2.path4 import y', 'from path1.path2.path3 import z', 'from path1.path2.path2 import a']

for statement in list_of_imports:
    try:
        execute statement
    except:
        ignore error and import the next statement
</code></pre>
<p>The reason i want to do this, is because some of the libraries in the list may not be in the filesystem, and i don't want one failure to make the entire file to throw an import error.</p>
<p>How do i do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try like this:</p>
<pre><code>list_of_imports = ['from path1.path2.path3 import x', 'from path1.path2.path4 import y', 'from path1.path2.path3 import z', 'from path1.path2.path2 import a']

for statement in list_of_imports:
    try:
        exec(statement)
    except ImportError as e:
        continue
</code></pre>
<p>Explanation:</p>
<p>Iterating over each element from the list using <code>exec()</code> you can execute those <code>import</code> statements. So if there is no error it will import that modules</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you probably don't actually want to do this—and if you explained why you think you do, we could probably show you a better way to do it.</p>
<p>But there are some cases where it might be reasonable. For example, I could imagine a <code>PYTHONSTARTUP</code> file that pre-loads a bunch of modules for an interactive session; as an interactive user, you can then look at what got loaded and decide what to do.</p>
<hr/>
<p>If you only need a handful of these, it's probably best to do them explicitly:</p>
<pre><code>try:
    from path1.path2.path3 import x
except ImportError:
    pass
try:
    from path1.path2.path4 import y
except ImportError:
    pass
try:
    from path1.path2.path3 import z
except ImportError:
    pass
</code></pre>
<hr/>
<p>For anything other than interactive use, you're probably going to actually want something like <code>x = None</code> rather than <code>pass</code>, unless you want to wrap a bunch of <code>try:</code>/<code>except NameError:</code> tests all over your code.</p>
<pre><code>try:
    from path1.path2.path3 import x
except ImportError:
    x = None
# etc.
</code></pre>
<hr/>
<p>If you want to make each one a 1-liner instead of a 4-liner, you can do that using <a href="https://docs.python.org/3/library/importlib.html#examples" rel="nofollow noreferrer"><code>importlib</code></a>, at the cost of repeating yourself:</p>
<pre><code>from importlib.util import find_spec
if find_spec('path1.path2.path3.x'): from path1.path2.path3 import x
if find_spec('path1.path2.path4.y'): from path1.path2.path4 import y
if find_spec('path1.path2.path3.z'): from path1.path2.path3 import z
</code></pre>
<hr/>
<p>If you need to do a whole bunch of these, you may be better off writing a wrapper function, using <code>importlib</code> again:</p>
<pre><code>import importlib
def try_import(mod):
    try:
        return importlib.import_module(mod)
    except ImportError:
        return None
x = try_import('path1.path2.path3.x')
y = try_import('path1.path2.path4.y')
z = try_import('path1.path2.path3.z')
</code></pre>
<hr/>
<p>If you have a dynamically-generated list of modules, you need to figure out how you want to store the results, because presumably you also need to <em>access</em> them dynamically. One obvious possibility is to stick them into a dict:</p>
<pre><code>import importlib
def try_import(mod):
    try:
        return importlib.import_module(mod)
    except ImportError:
        return None
names = ['path1.path2.path3.x', 'path1.path2.path4.y', 'path1.path2.path3.z']
mods = [try_import(name) for name in names]
mods = {name.split('.')[-1]: mod for name, mod in zip(names, mods)}
</code></pre>
<p>… or, if you want to skip missing modules instead of using <code>None</code>:</p>
<pre><code>mods = {name.split('.')[-1]: mod for name, mod in zip(names, mods) if mod}
</code></pre>
<p>… or, if this is for something quasi-static, like the interactive example, maybe a namespace, so you can just access <code>mods.x</code>:</p>
<pre><code>import types
mods = types.SimpleNamespace(**mods)
</code></pre>
<p>… or, if you want to dump them into globals, so you can access them as <code>x</code>, that's just as simple:</p>
<pre><code>globals().update(mods)
</code></pre>
<hr/>
<p>If you really need to build a list of statements rather than a list of modules, use <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a>:</p>
<pre><code>statements = ['from path1.path2.path3 import x', 'from path1.path2.path4 import y']
for statement in statements:
    try:
        exec(statement)
    except ImportError:
        pass
</code></pre>
<p>But notice that, besides having to repeat yourself a lot more this way than with the other dynamic options, you also can't do anything sensible like <code>x = None</code> without parsing the statement inside the <code>exec</code> block, because otherwise you don't have the name <code>x</code>. That isn't exactly <em>hard</em> in this case, but it adds even more complexity, and code smell…</p>
</div>
<span class="comment-copy">Change <code>execute statement</code> to <code>exec(statement)</code> and <code>ignore error and import the next statement</code> to <code>pass</code> and you are good to go</span>
<span class="comment-copy">If you really need to do this dynamically, instead of making a list of statements to execute, it's better to make a list of modules to try to load, then write a function that uses <code>importlib</code> (see the <a href="https://docs.python.org/3/library/importlib.html#examples" rel="nofollow noreferrer">examples</a>) to try to load each one, then call that function on each element of the list. But if you <i>must</i> use statements for some reason, you can <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a> them.</span>
<span class="comment-copy">Meanwhile, how do you plan to deal with modules that failed later in you code? You don't want a <code>try: x.spam</code> <code>except NameError: pass</code> every time you want to use <code>x</code>, do you? If you can provide a realistic example, it will be easier to show you a complete answer. (You can write it with static <code>try: from path1.path2.path3 import x except: pass</code>, and then ask how to make those try-imports dynamic and less repetitive.)</span>
<span class="comment-copy">Thanks for pointing out the flaw in my approach, @abarnert.</span>
<span class="comment-copy">@Randomly Named User: This is tested in my PC.Did you got the required one ?</span>
<span class="comment-copy">Yep, it worked for me</span>
<span class="comment-copy">That's sounds great !!</span>
<span class="comment-copy">Amazing effort put into the answer, appreciate it!</span>
