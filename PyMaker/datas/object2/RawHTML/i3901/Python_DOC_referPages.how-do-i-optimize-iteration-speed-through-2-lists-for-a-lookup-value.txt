<div class="post-text" itemprop="text">
<p>I have two lists built from a "cursor.fetchall()" statement from two different data sources.</p>
<p>List 1's structure (when doing call to print()):</p>
<pre><code>[(23026, ), (23038, ), (23039, ), (23040, ), (23041, )]
</code></pre>
<p>List 2's structure, seemingly truncated (when doing a print() statement):</p>
<pre><code>[(23038, 'Foo', 'Bar', 0), 
 (23039, 'Foo', 'Bar', 0), 
 (23054, 'Foo', 'Bar', 0)]
</code></pre>
<p>I'm needing to look up each value in list_1 to see if it exists in list_2. And then, vice versa, in a separate task to see if each of the list_2[0] values are in list_1.</p>
<p>Example of what I'm currently using:</p>
<pre><code>    # Loop Through Rows In A List
    for a in list_a:
        if a == None:
            break

        # Loop Through Rows In B List
        keep_item = False
        for b in list_b:
            # Check If Item From A Database Is Still In B Database
            if a[0] == b[0]:
                keep_item = True
                break

        if not keep_item:
            # Delete Item
            print("Deleting Item " + str(a[0]))
            items_deleted += 1
</code></pre>
<p>Each list contains roughly 30,000 records, and is currently very slow when using this method.</p>
<p>Is there a faster way to perform these lookups? I'm performing a SQL INSERT or DELETE for each iteration (if that matters).</p>
</div>
<div class="post-text" itemprop="text">
<p>First: you've already got these values in a SQL database. Presumably with an appropriate index. So let the database do the work. Instead of reading all of A and all of B into memory, use a join or a subselect to read only those elements of A that have a match in B.</p>
<hr/>
<p>But let's assume that's not appropriate somehow.</p>
<p>To look up many values quickly, you usually want to use a set or dict instead of a list.</p>
<p>In your case, you're trying to look up values on <code>b[0]</code> rather than all of <code>b</code>, so that would be a dict, with your current <code>b[0]</code> as the keys. Instead of this:</p>
<pre><code>lst2 = [(23038, 'Foo', 'Bar', 0), 
        (23039, 'Foo', 'Bar', 0), 
        (23054, 'Foo', 'Bar', 0)]
</code></pre>
<p>… you want this:</p>
<pre><code>dct2 = {23038: ('Foo', 'Bar', 0), 
        23039: ('Foo', 'Bar', 0), 
        23054: ('Foo', 'Bar', 0)}
</code></pre>
<p>Ideally, you want to build the dict instead of the list in the first place. If you can't do that, you can convert in linear time:</p>
<pre><code>dct2 = {b[0]: b[1:] for b in lst2}
</code></pre>
<p>Since you appear to be getting these from a database cursor: Most database libraries for Python have cursors that act as lazy iterators of rows (fetching a buffered chunk at a time in whatever way is most efficient), so you can just use the cursor itself:</p>
<pre><code>dct2 = {row[0]: row[1:] for row in cursor}
</code></pre>
<p>However you build your dict or set, lookups take constant time instead of linear—and they're simpler to write, to boot:</p>
<pre><code>try:
    b = dct2[a[0]]
except KeyError:
    print("Deleting Item " + str(a[0]))
    items_deleted += 1
</code></pre>
<p>… or:</p>
<pre><code>if a[0] not in dct2:
    print("Deleting Item " + str(a[0]))
    items_deleted += 1
</code></pre>
<p>No need for a loop and a <code>found</code> flag.</p>
<hr/>
<p>For many cases—although I don't think it will work here—you can make things even simpler. If you have two sets, or a set and a dict, and you just want the intersection of the first set with the second set, or with the dict's keys, that's just:</p>
<pre><code>set1 &amp; dct2
</code></pre>
<hr/>
<p>When a hash-based structure like a set or dict isn't appropriate (e.g., if the keys can't be hashed), you can still get logarithmic time—not quite as good as constant, but a lot better than linear. If you can just <code>sort</code> the list after building it, you can use <code>bisect</code> to search it. If you have to keep modifying the list between searches, you'll want to use a data structure that stays sorted—a balanced binary search tree, something wider like a b-tree, a hybrid b-tree/deque structure like <code>blist</code>, a skiplist, etc. There are many options on PyPI to choose from, and you can even more to implement yourself in a good book on data structures.</p>
</div>
<span class="comment-copy"><code>print</code> is no linger a statement in Python 3 - it's a function</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html#sets</a></span>
<span class="comment-copy">revised question fwiw... but not sure how helpful your comment is. Equivalent of me saying you spelled "longer" wrong...</span>
<span class="comment-copy">To look up many values quickly, use a set or dict instead of a list. When that isn't appropriate (e.g., the keys can't be hashed), use a sorted list and <code>bisect</code>. Or, if you need to modify the list between searches, use a logarithmic data structure like a red-black tree, b-tree, skiplist, etc. (there are many options on PyPI).</span>
<span class="comment-copy">I'll research sets. Is it possible to set the result of a "cursor.fetchall()" to a set or dict instead of a list? Not sure if helpful, but I do not modify either list when iterating.</span>
<span class="comment-copy">Thanks abarnert. Playing with the "cursor" code you posted to see if I can cobble something together with that. These come from two separate databases unfortunately, so a Join/SQL method won't work for me. For list 1, I'm using the same cursor statement, but using row[0] for both. Is that acceptable? Aiming to get them both as dictionaries.</span>
