<div class="post-text" itemprop="text">
<p>If I can choose between list of objects, lists of integers and dictionaries (is there any other data structure option?), which is the most efficient data structure to discover if a group is a subgroup of other group, and how to implement? </p>
<p>I have a class with unique integers atributes, so I can "represent" the class object's by the integer they contain, or the object (pointer) itself.</p>
<pre><code>a.atributeEx = 1
b.atributeEx = 2
c.atributeEx = 3

listOfPointers = [a,b,c]
listAtributes = [1,2,3]
dictEx = ['1':1, '2':2, '3':3]
</code></pre>
<p>One option is to use issubset, as bellow:</p>
<pre><code>listAtributes2 = [1,2]
set(listAtributes).issubset(listAtributes2)
</code></pre>
<p>However, using the issubset function with a list of atributes, my code would take months to years to finish to run, as this has to be performed billions of times. Usually, one list has from 1 to 4 elements while the other has from 200 to 2000 elements.</p>
<p>What is the best approach for this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>set</code> methods should be fairly efficient. In particular, if you do <code>x.issubset(y)</code>, only the size of <code>x</code> matters since a <code>set</code> uses hashing to check if it contains a given item.</p>
<p>Although, if you are instantiating a set for every comparison, then you are adding a big overhead to your computations.</p>
<p>One solution is to instantiate a new <code>set</code> in your <code>__init__</code> method only and to populate it in your <code>__setattr__</code> method. To allow attribute deletion as well, you can define a <code>__delattr__</code> method that removes elements from the <code>set</code>. Finally, you can use the <code>__contains__</code> method to execute the subset comparison when using the keyword <code>in</code>.</p>
<pre><code>class Container:
    def __init__(self, **kwargs):
        self.__dict__['_attr_set'] = set()
        for k, v in kwargs.items():
            setattr(self, k, v)

    def __setattr__(self, key, value):
        self._attr_set.add((key, value))
        super().__setattr__(key, value)

    def __delattr__(self, item):
        for x in self._attr_set:
            if x[0] == item:
                self._attr_set.remove(x)
                break
        super().__delattr__(item)


    def __contains__(self, item):
        return item._attr_set.issubset(self._attr_set)
</code></pre>
<h3>Example</h3>
<pre><code>x = Container(a=1, b=2, c=3)
y = Container(a=1, b=2)

print(y in x) # True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Look at python sets.  The <code>set</code> datatype has all of the operations you need (e.g. <code>issubset</code>) and is really fast.  If you can streamline your calling code and let the sets do the work, you will see this perform well.</p>
<pre><code>&gt;&gt;&gt; x = set(range(1000))
&gt;&gt;&gt; y = {8,37,29,983}
&gt;&gt;&gt; y.issubset(x) 
True
</code></pre>
<p>So I put this in a loop.  It ran 100,000,000 times in 27 seconds.</p>
<p>I think that if you pre-compute your sets instead of building them for each comparison, you will find this to be a super-effective way of handling it.</p>
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#sets</a></p>
</div>
<span class="comment-copy">What do you want to use that for? Using <code>set.issubset</code> should be fairly efficient, maybe you picked the wrong language... or the wrong abstraction.</span>
<span class="comment-copy">Can you pre-convert your data to the set type to prevent the need for it iterating and creating set objects on every comparison?  How much raw data are you talking about here?</span>
<span class="comment-copy"><code>set(listAttributes) &lt;= set(listAttributes2)</code> should be fairly efficient and fast, certainly faster than anything else native Python has to offer. In what scenario would that take months to years?</span>
<span class="comment-copy">are any of the two sets the same on two ore more comparision? Of so, how often are they the same? E.g. are there just halv billion different sets with 20-200 elements and one billion with 1-4, or any othe ratio that can be relevant when deciding on data structure and algorithm.</span>
<span class="comment-copy">@gahooa  I changed the code to pre-convert to data to the set type, and I'm having much better results now. However, I noticed some efficiency difference between using set.issubset with sets of numbers, strings and objects (sets of numbers are the fastest). Is there any way to use set.issubset to <b>compare pointers</b>? So that:   <code>a = 1</code>, <code>b = a</code>,  <code>set(a).issubset(b)</code> would return <code>True</code>,  and  <code>a = 1</code>, <code>b = 1</code>,  <code>set(a).issubset(b)</code> would return False?</span>
