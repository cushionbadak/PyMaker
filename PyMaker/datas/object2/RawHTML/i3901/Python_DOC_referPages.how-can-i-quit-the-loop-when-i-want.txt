<div class="post-text" itemprop="text">
<p>I working with <code>R-Pi</code> and <code>cam</code>. I have made code that iterate procedure over an hour. </p>
<pre><code>import numpy as np
import cv2
import time

ret, frame = cam0.read()
timecheck = time.time()
future = 60
runNo = 0
while ret:
    if time.time() &gt;= timecheck:
        ret, frame = cam0.read()
        #Do something here

        timecheck = time.time()+future
        runNo=runNo+1

        if(runNo&gt; 60):
            break
    else:
        ret = cam0.grab()

#save log as .txt file
with open("acc_list.txt", "w") as output:
    output.write(str(acc_list))
</code></pre>
<p>But sometimes, it takes less than hour to finish work. I want to quit  the iteration before <code>runNo</code> get to <code>60</code>. Because I have to save <code>acc_list.txt</code> file, I can't just shut the program down.</p>
<p>If it was video streaming, I would use this:</p>
<pre><code>while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        if cv2.waitKey(1) &amp; 0xFF == ord('q'):
            break
</code></pre>
<p>But I have encountered errors while modifying this to my code. </p>
<p>Is there nice way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are lots of possible approaches, some are cleaner and some are dirtier :-)</p>
<p>In no particular order, here are some. I will probably add code for them as I find spare time to explain them properly.</p>
<hr/>
<p><strong>Method 1 - Use a <em>sentinel</em> file</strong></p>
<p>An easy (and <em>"hacky"</em>) way to do this is to check inside the loop for the existence of a file called <code>stop</code>. Then in the shell/Terminal, just do:</p>
<pre><code>touch stop   
</code></pre>
<p>and the program will exit. If you happen to use <code>bash</code>, you can just type:</p>
<pre><code>&gt; stop
</code></pre>
<p>Remember to delete the file called <code>stop</code> at the beginning and end of your program.</p>
<p>I am no Python programmer but this works:</p>
<pre><code>#!/usr/local/bin/python3
import os
from time import sleep

# Remove any sentinel "stop" files from previous runs
def CleanUp():
    try:
        os.remove('stop')
    except:
        pass

CleanUp()
runNo=0
while True:
    print("Running...")
    sleep(1)
    if runNo&gt;60 or os.path.exists('stop'):
        break
    runNo=runNo+1

print("Writing results")
CleanUp()
</code></pre>
<hr/>
<p><strong>Method 2 - Use a second thread</strong></p>
<p>Another way to do it is to start a second thread that does a blocking read from the terminal, and when the user enters something, it sets a flag which the main thread checks on each iteration through its loop the same as it checks <code>runNo</code>.</p>
<p>This demonstrates:</p>
<pre><code>#!/usr/local/bin/python3
import threading
import os
from time import sleep

ExitRequested=False

def InputHandlerThread():
    global ExitRequested
    s=input('Press Enter/Return to exit\n')
    print("Exit requested")
    ExitRequested=True

# Start user input handler - start as daemon so main() can exit without waiting
t=threading.Thread(target=InputHandlerThread,daemon=True)
t.start()

runNo=0
while True:
    print('runNo: {}'.format(runNo))
    sleep(1)
    if runNo&gt;60 or ExitRequested:
        break
    runNo=runNo+1

print("Writing results")
</code></pre>
<p>This may not work best with OpenCV because the <code>imshow()</code> function somehow uses spare time (given as the <em>milliseconds</em> parameter) in the <code>waitKey()</code> function to update the screen. You will see this if you call <code>imshow()</code> without any following <code>waitKey()</code> - nothing will appear on the screen.</p>
<p>So, if you are using <code>imshow()</code> you must use <code>waitKey()</code> and that will interfere with reading the keyboard in the second thread. If that's the case, use one of the other methods.</p>
<hr/>
<p><strong>Method 3 - Write results incrementally</strong></p>
<p>A third way to do it is to open your results file <strong>for append</strong> inside the loop and add each new result as it comes available rather than waiting till the end.</p>
<p>I don't know enough about your algorithm to know if this is a possibility for you. </p>
<p>I'm still no Python programmer, but this works:</p>
<pre><code>#!/usr/local/bin/python3
import os
from time import sleep

runNo=0
while True:
    print("Running...")
    # Append results to output file
    with open("results.txt", "a") as results:
        results.write("Result {}\n".format(runNo))
    sleep(1)
    if runNo&gt;60:
        break
    runNo=runNo+1
</code></pre>
<hr/>
<p><strong>Method 4 - Use a signal</strong></p>
<p>A fourth way to do it is to set up a signal handler and when it receives the signal it sets a flag which the main loop checks on every iteration. Then in the terminal you use:</p>
<pre><code>pkill -SIGUSR1 yourScript.py
</code></pre>
<p>See <a href="http://docs.python.org/3/library/signal.html" rel="nofollow noreferrer">documentation on signals.</a></p>
<p>Here is some working code:</p>
<pre><code>#!/usr/local/bin/python3
import signal
import os
from time import sleep

def handler(signum,stack):
    print("Signal handler called with signal ",signum)
    global ExitRequested
    ExitRequested=True

ExitRequested=False

# Install signal handler
signal.signal(signal.SIGUSR1,handler)


runNo=0
while True:
    print('runNo: {} Stop program with: "kill -SIGUSR1 {}"'.format(runNo,os.getpid()))
    sleep(1)
    if runNo&gt;60 or ExitRequested:
        break
    runNo=runNo+1

print("Writing results")
</code></pre>
<p><strong>Sample Output</strong></p>
<pre><code>runNo: 0 Stop program with: "kill -SIGUSR1 16735"
runNo: 1 Stop program with: "kill -SIGUSR1 16735"
runNo: 2 Stop program with: "kill -SIGUSR1 16735"
runNo: 3 Stop program with: "kill -SIGUSR1 16735"
runNo: 4 Stop program with: "kill -SIGUSR1 16735"
runNo: 5 Stop program with: "kill -SIGUSR1 16735"
runNo: 6 Stop program with: "kill -SIGUSR1 16735"
runNo: 7 Stop program with: "kill -SIGUSR1 16735"
Signal handler called with signal  30
Writing results
</code></pre>
<hr/>
<p><strong>Discussion</strong></p>
<p>YMMV, but my feeling is that Method 3 is the cleanest, and that Method 1 is the biggest hack. Method 2 is probably closest to what you asked for and I did Method 4 (and all the others, in fact) so I could learn something.</p>
<p>If any real Python programmers have any comments, I'd be happy to learn.</p>
</div>
<span class="comment-copy">How do you know that the work is finished?</span>
<span class="comment-copy">@zwer It is installed in manufacturing machine. Human can judge if it is finished. Finished condition is hardly detected by <code>cam image</code>. But my question is that How can I break the loop in running <code>python shell</code> manually. For example, typing <code>q</code> button to quit the loop in video streaming.</span>
<span class="comment-copy">Can you post the errors you are getting?</span>
<span class="comment-copy">I don't know python well but you should search for something like 'python keyboard input non blocking' e.g. <a href="https://stackoverflow.com/questions/2408560/python-nonblocking-console-input" title="python nonblocking console input">stackoverflow.com/questions/2408560/â€¦</a></span>
<span class="comment-copy">this is why SO is the best !!!! +1</span>
