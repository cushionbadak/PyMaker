<div class="post-text" itemprop="text">
<pre><code>def straight():
    print("You went straight ahead")
    print("You run into a locked door. You try to break down the door but it 
    doesn't work..")
    print("Then you see the writing on the wall next to the door..")
    print("Call a number and then we call it even!")

    try:
        number = int(input("--&gt; "))
    except:
        print("Not a number!")
        straight()

    if number % 2 == 0:
        print(f"You cracked the code! Your even number {number} gave you access 
        to this door")
        print("The door opens..")
        final_room()
    elif number % 2 &gt;= 1:
        dead(f"The wrong number ({number}) caused the tunnel to collapse!")
    else:
        print("test else?")
        straight()
</code></pre>
<p>I am pretty new to programming so I hope someone can help me in "regular" language haha!</p>
<p>I looked at similar questions on this forum and other sites, but I still can't figure out what I am doing wrong. This is the function where I get an error messsage. The rest of my code works fine.</p>
<p>I keep getting the following message:
UnboundLocalError: local variable 'number' referenced before assignment</p>
<p>But the variable has been set inside my function so I would think it would work. It also works when I give the wrong input (so a string in this case) right away. It does not work when I first give a string like: hkjadhjkas</p>
<p>Then this script will ask me again since it will run again. If i put in like the number 20 after that it will give this error. But at my first try giving in 20 it will work. So this error does not appear all the time. </p>
<p>So what am I not doing right? Thank you in advance for helping me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that after recursing in your <code>except</code> block, you keep running the original function as if the exception had not occurred, but the original function failed to set <code>number</code>.</p>
<p>That is, this code:</p>
<pre><code>try:
    number = int(input("--&gt; "))  # Oh no, not a number
except:
    print("Not a number!")  # Jumps here
    straight()              # Runs straight
# Keeps going!!!

if number % 2 == 0:  # number never assigned!!!
</code></pre>
<p>tries to parse and assign to <code>number</code>, prints the error, invokes <code>straight</code> recursively, then when that finishes, it continues on as if the error had not occurred, causing <code>if number % 2 == 0:</code> to read <code>number</code>, without having set it.</p>
<p>If the goal is to use the recursive call's result, just change your code from:</p>
<pre><code>try:
    number = int(input("--&gt; "))
except:
    print("Not a number!")
    straight()
</code></pre>
<p>to:</p>
<pre><code>try:
    number = int(input("--&gt; "))
except:
    print("Not a number!")
    return straight()  # &lt;-- Makes you return the result from the recursive call
</code></pre>
<p>A similar change would be needed in the other place you recursively call <code>straight</code>.</p>
<p>I'd also recommend limiting your <code>except</code> to something more specific than "all possible exceptions"; as is, you'll ignore the user hitting Ctrl-C, the system running out of memory, etc. I'd suggest using <code>except ValueError:</code> which is the only exception that <code>int()</code> itself would raise while parsing a string, rather than blindly catching all errors and assuming it was invalid input.</p>
</div>
<span class="comment-copy">Thank you for your fast reply! It fixed it. Would not have thought about returning straight(). But if I understand correctly, if you in this case return straight() it will loop back to the beginning instead of moving forward to the next line?  I also never heard of ValueError, so I learned something new! Thank you for that.   My code now works :)</span>
<span class="comment-copy">@Marije: <code>return straight()</code> will exit the current invocation early; it just runs a brand new invocation first (which effectively "loops back to the beginning"). If you want more info on specific exceptions, the Python docs have <a href="https://docs.python.org/3/library/exceptions.html" rel="nofollow noreferrer">a single point of reference for the common exceptions</a>.</span>
<span class="comment-copy">Thank you for your reply</span>
