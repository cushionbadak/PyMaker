<div class="post-text" itemprop="text">
<p>I have a class with a str instance variable. From this instance variable, I calculate a second instance variable, which is basically just the string broken up into certain 'atoms'. The second instance variable is completely determined by the first. I've made it an instance variable because I think that it is best regarded as a 'property' of the class. I'm a bit unsure about how to treat derived instance variables. In particular:</p>
<p>1) I think that they should be get-only properties. However, since the computation of the derived instance variable is quite intensive, I want it to be done when the class is initiated, not when the variable is called.
2) If I make a function purely for calculating the instance variable, is there a way to mark this? 
3) Also, should I pass the first instance variable as a parameter, or just read it in the method from self? (in general I'm still a bit unsure of when to pass instance variables as parameters to methods.)
4) Is there a better way to do this that I haven't mentioned?
Thanks</p>
<p>EDIT: Here's a simplified example of what I mean:</p>
<pre><code>class Amendment:

    def __init__(self, string):
        self.string = string
        self.atoms = generate_atoms()


    def generate_atoms():
        return do_something_that_takes_long(self.string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You forgot <code>self</code> in a couple of places. But here's how to make <code>.string</code> and <code>.atoms</code> get-only properties. We use a couple of <a href="https://docs.python.org/3/tutorial/classes.html#tut-private" rel="nofollow noreferrer">"private"</a> attributes that are created during <code>__init__</code>, and use <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">@property</a> to create the actual getters.</p>
<pre><code>class Amendment:
    def __init__(self, string):
        self._string = string
        self._atoms = self.generate_atoms()

    def generate_atoms(self):
        #return do_something_that_takes_long(self.string)
        return list(self.string)

    @property
    def string(self):
        return self._string

    @property
    def atoms(self):
        return self._atoms

# Test

a = Amendment('abc')
print(a.string, a.atoms)
# This will raise an error because `.string` is a get-only property.
a.string = 'xyz'
</code></pre>
<p><strong>output</strong></p>
<pre><code>abc ['a', 'b', 'c']
Traceback (most recent call last):
  File "./qtest.py", line 53, in &lt;module&gt;
    a.string = 'xyz'
AttributeError: can't set attribute
</code></pre>
<p>If you like, you could also mark <code>generate_atoms</code> as private, but there's probably no need. And nothing stops an insistent user from accessing such things anyway, as the linked docs explain.</p>
<p>As for your 3rd question, methods should normally access the attributes they need via <code>self</code>. In some cases you can use the same method on different attributes, and then it makes sense to pass the attribute as a parameter, but if that's not the case it just looks weird. ;)</p>
</div>
<span class="comment-copy">You're more likely to get help with this if you post a small example so we know exactly how you're constructing this class (we don't need to see the details of your actual "atom" constructing algorithm, a simplified version is sufficient). And that way we can use the attribute names from your code, rather than having to talk about "the first instance variable" etc.</span>
<span class="comment-copy">In the meantime, does the the first instance variable get changed during the lifetime of an instance?</span>
<span class="comment-copy">Edited. And no, the first instance variable will not be changed. Therefore, the calculation of atoms can happen once and then persist in that object forever.</span>
<span class="comment-copy">Thanks. So you want both <code>.string</code> and <code>.atoms</code> to be get-only properties?</span>
<span class="comment-copy">Yes .string will also be a get only poperty</span>
<span class="comment-copy">Awesome, this looks neat. Thanks!</span>
<span class="comment-copy">@Neil No worries. I've added a few more remarks to my answer.</span>
