<div class="post-text" itemprop="text">
<p>I am trying to produce a code that verifies whether or not a user input meets the criteria of a pascal triangle. I know how to go about inputting the number of lines and having it develop a pascal triangle, but I am having trouble figuring out how to get a user to input something like <code>1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1</code>, and having my program say whether it is a pascal triangle or not. </p>
<pre><code>values = input("Enter the numbers: ").split()

pascals_triangle = list(map(list, values))
</code></pre>
<p>I know the first line could split the numbers, and the second line would assign the numbers into individual lists of a list. Every time I attempt to have the lists increase by 1 in every row, I get <code>str/int</code> errors. Once I get past this little road block, I should be able to figure out the rest of the code. </p>
<pre><code>data = input("Enter values: ").split()


def pascal_triangle(data):
    size = int(data[0])
    n = 2 * size + 1
    grid = [[0 for x in range(n)] for y in range(size)]

    left = 1
    for i in range(size, 0, -1):
        grids = data[i].split(' ')
        count = 0
        for g in grids:
            grid[i - 1][left + 2 * count] = int(g)
            count += 1
        left += 1
        if count != i:
            return False

    left = 1
    for i in range(size - 1, -1, -1):
        if i == 0:
            return grid[i][left] == 1
        numbers = i + 1
        count = 0
        while count &lt; numbers:
            current = grid[i][left + count * 2]
            upper_left = grid[i - 1][left - 1 + count * 2]
            upper_right = grid[i - 1][left + 1 + count * 2]
            if current != (upper_left + upper_right):
                return False
            count += 1

        left += 1
    return False



status = pascal_triangle(data)
if status:
    print('It is a pascal triangle')
else:
    print('It is not a pascal triangle')
</code></pre>
<p>So, in this code, why am I still not getting the accurate answers? </p>
</div>
<div class="post-text" itemprop="text">
<p>If you're trying to do this in some fancy way, like adapting the <code>grouper</code> recipe in the <code>itertools</code> docs to take an iterable of group sizes instead of a fixed group size… take a step back and write the "dumb" version first.—just write a loop. </p>
<p>First, split the whole string, the same way you split each line in your line-by-line version.</p>
<p>One thing: mapping <code>list</code> over your values won't do any good; that'll just turn, e.g., <code>'23'</code> into <code>['2', '3']</code>, and there's not much good you can do with that. You want a list of numbers, which you're then going to break up into a rows (each row also being a list of numbers—the same row you got by mapping <code>int</code> over <code>line.split()</code> in your line-by-line version).</p>
<p>So, here's some pseudocode:</p>
<pre><code>values = input("Enter the numbers: ").split()
nums = [int(value) for value in values]
size = 1
start = 0
while start &lt; len(nums):
    rownums = nums[start:start+size]
    make sure len(rownums) == size
    check rownums the same way you checked each line
    update size and start
if you got here without seeing any errors, it's valid
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this is to generate each row of Pascal's triangle, and use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>islice</code></a> to grab a list of the current row length from the user data and see if the data matches the row.</p>
<pre><code>from itertools import islice

def pascal():
    """ Pascal's triangle generator """
    a = [1]
    while True:
        yield a
        #Generate next row from current row
        a = [x + y for x, y in zip([0] + a, a + [0])]

def test_pascal(values):
    it = map(int, values.split())
    ok = True
    for row in pascal():
        data = list(islice(it, len(row)))
        if not data:
            break
        if data != row:
            ok = False
            print('bad data', data, row)
            break
    return ok

# Test

values = '1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1'
print(test_pascal(values))

values = '1 1 1 1 2 1 1 3 3 1 1 4 6 5 1'
print(test_pascal(values))
</code></pre>
<p><strong>output</strong></p>
<pre><code>True
bad data [1, 4, 6, 5, 1] [1, 4, 6, 4, 1]
False
</code></pre>
</div>
<span class="comment-copy">Show us an attempt where you get it wrong so we can either explain the error or how you go wrong about it. A simple, but generic answer would be to use slices with increasing length.</span>
<span class="comment-copy">"Every time I attempt to have the lists....." Can you show your attempt? That would be easier for us too.</span>
<span class="comment-copy">If one of the answers below fixes your issue, you should accept it (click the check mark next to the appropriate answer). That does two things. It lets everyone know your issue has been resolved to your satisfaction, and it gives the person that helps you credit for the assist. See <a href="http://meta.stackexchange.com/a/5235">here</a> for a full explanation.</span>
<span class="comment-copy">@random_student <code>itertools</code> has some very handy things in it (in fact, it's one of the <a href="https://stackoverflow.com/q/8370206/4014959">built-in modules</a>), but it does take a little while to learn how to use them effectively. <code>islice</code> is pretty simple: <code>islice(it, n)</code> says grab the next <code>n</code> items from the iterable named <code>it</code>. It returns an iterator, so we need to turn that into  list.</span>
