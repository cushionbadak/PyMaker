<div class="post-text" itemprop="text">
<p>I have a list of tuples (approximately 300) each of which is composed of two items. The first item is a keyword, the second is a list of strings that contain the keyword. The below function should initially generate a tuple composed of lists that are either long strings or blank. For example</p>
<pre><code>beginning = [('keyword1', [] [] ['$5'] ['This has $6.50'], ['this has 4']), ('keyword2', [] [] [] [], []['5.5'])]
</code></pre>
<p>I would like my final output to delete the blank lists and provide a list of tuples with the first time being the keyword, the second being any mention of price made within comments that that contain the keyword and the last item being any digit mentioned that does not have a currency symbol attached. For example, </p>
<pre><code>desired_output = [('keyword1', ['$6.50'] ['$5'], ['4']), ('keyword2',[],['5.5'])]
</code></pre>
<p>I have the below function but I am getting an error reading:</p>
<pre><code>  TypeError: expected string or bytes-like object
</code></pre>
<p>Is there a way to amend the below function to either be more efficient or run with its current structure.</p>
<pre><code>import re
def collect_keyterms(list_of_tuples):
    price_re = re.compile(r'^.*[\$\£\€]\s?\d{1,3}(?:[.,]\d{3})*(?:[.,]\d{1,2})?.*$')
number_re = re.compile(r'\b\d[.]\d{1,2}\b')
new_list = [(keyword, [re.findall(price_re, post) for post in posts], [re.findall(number_re, post) for post in posts]) for keyword, posts in tuples_with_keyword_posts]
final = [(keyword, list(filter(lambda x:re.findall(r'\d', x), currencies)), list(filter(lambda y:re.findall(r'\d', y), posts))) for keyword, currencies, posts in new_list]
return final
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use unpacking with <code>re</code>:</p>
<pre><code>import re
def sort_key(d):
  return (bool(re.findall('^\$[\d\.]+|\£[\d\.]+|\€[\d\.]+', d[0])), float(d[0][1:]) if not d[0][0].isdigit() else float(d[0])) if len(d) else (False, 0)

beginning = [('keyword1', [], [], ['$5'], ['This has $6.50'], ['this has 4']), ('keyword2', [] ,[] ,[] ,[], [],['5.5'])]
new_results = [(a, *sorted([re.findall('^\$[\d\.]+|\£[\d\.]+|\€[\d\.]+|[\d\.]+', i[0]) for i in b if i], key=sort_key)) for a, *b in map(lambda x:filter(None, x), beginning)]
</code></pre>
<p>Output:</p>
<pre><code>[('keyword1', ['4'], ['6.50'], ['$5']), ('keyword2', ['5.5'])]
</code></pre>
</div>
<span class="comment-copy">As documented here, <a href="https://docs.python.org/3/library/stdtypes.html#str.isdigit" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str.isdigit</a> isdigit() is a string method, it can't be called for integers or floats.</span>
