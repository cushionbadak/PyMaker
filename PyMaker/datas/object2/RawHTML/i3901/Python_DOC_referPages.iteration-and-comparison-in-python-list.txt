<div class="post-text" itemprop="text">
<p>I have a list of values (the order of the list matters):</p>
<pre><code>[7, 5, 3, 4, 6, 4, 7] 
</code></pre>
<p>My goal is to find the most important loss. For example, in the list above the most important loss is <code>4</code>, because <code>7 - 3 = 4</code>.
How can I iterate a list, so that if <code>list[x] &gt; list[x + 1]</code> I go on to the next one?</p>
</div>
<div class="post-text" itemprop="text">
<p>You define loss as the difference between an element <code>l[i] - l[i+x]</code> where <code>l[i:i+x+1]</code> is a decreasing subsequence.</p>
<p>Then we can traverse the list an have a loss counter on each decreasing sub sequence, keeping the max loss.</p>
<pre><code>from itertools import chain
from math import inf

def max_loss(l):
    a, b, max_loss = iter(l), chain(l, (inf,)), 0
    top = next(b, None)

    for prev, curr in zip(a, b):
        if curr &gt; prev:
            max_loss, top = max(top - prev, max_loss), curr

    return max_loss
</code></pre>
<p>Example:</p>
<pre><code>l = [7, 5, 3, 4, 2, 6, 4, 7]
loss = max_loss(l)
loss # 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get the largest decrease between consecutive elements, it's not pretty, but we could make a <code>for</code> loop like so:</p>
<pre><code>data = [7, 5, 3, 4, 6, 4, 7]

largestDrop = 0
currentDrop = 0
previousValue = None

for currentValue in data:
    if previousValue != None and previousValue &gt;= currentValue:
        currentDrop += previousValue - currentValue
    else:
        currentDrop = 0

    if currentDrop &gt; largestDrop:
        largestDrop = currentDrop

    previousValue = currentValue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a brute-force method:</p>
<pre><code>A = [7, 5, 3, 4, 6, 4, 7]

res = max(A[j] - A[i] for i in range(len(A)) for j in range(i, len(A)))

print(res)  # 4
</code></pre>
<p>The idea is to take every number and every subsequent number pairwise, calculate difference, and then take the maximum of these differences. Using a generator expression as above means that no intermediary lists are built in the process.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is possible using vectorised logic via 3rd party library <code>numpy</code>.</p>
<p>The idea is to use <a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html" rel="nofollow noreferrer">broadcasting</a> to take the difference between the array and its transposed representation. Then take the maximum of the lower triangle from the resulting array.</p>
<pre><code>import numpy as np

A = np.array([7, 5, 3, 4, 6, 4, 7])

B = A - A[:, None]
res = np.max(B[np.tril_indices(B.shape[0])])

print(res)
4
</code></pre>
</div>
<span class="comment-copy">Are you saying that you want <code>largest_element - smallest_element</code>?  If so, you can do <code>max(list) - min(list)</code>.</span>
<span class="comment-copy">Also, be careful not to name variables like <code>list</code>, because that will override the <code>list</code> keyword.</span>
<span class="comment-copy">@TimJohns I don't think that's it, I think it's more largest difference between a larger element and a smaller element that comes later in the list</span>
<span class="comment-copy">If you want to iterate over adjacent pairs of values, you can either use the <code>pairwise</code> function in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> docs recipes</a>, or loop over <code>for i in range(len(x)-1)</code> and use <code>x[i:i+2]</code>. But I don't see how that will help you find <code>7 - 3</code>, because those aren't adjacent.</span>
<span class="comment-copy">@StephenTG So we're looking for largest monotonic drop, which might be spread over multiple values?</span>
<span class="comment-copy">This dont work on every dataset, Im trying to debug it. Thanks for your help</span>
<span class="comment-copy">@remc what does not work? Provide details and examples of input-output. I read your other solution required a lot of memory, this one should be both O(n) in time and O(1) in memory.</span>
<span class="comment-copy">@OlivierMelan√ßon in fact, it work completly ! Thanls for your help :D</span>
