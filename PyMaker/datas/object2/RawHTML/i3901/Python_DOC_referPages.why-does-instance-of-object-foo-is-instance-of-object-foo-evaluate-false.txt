<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/48736670/two-methods-inherited-from-one-method-in-class-are-different-in-instances-aren">Two methods inherited from one method in class are different in instances, aren't they?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>If I have a </p>
<pre><code>class A:
  def foo(self):
    pass
</code></pre>
<p>this evaluates to <code>True</code>:</p>
<pre><code>getattr(A, 'foo') is A.foo
</code></pre>
<p>but this evaluates to <code>False</code>:</p>
<pre><code>a = A()
getattr(a, 'foo') is a.foo
</code></pre>
<p>as does</p>
<pre><code>a.foo is a.foo
</code></pre>
<p>Why?</p>
<p>I found that <code>getattr(a, 'foo')</code> and <code>a.foo</code> both are represented by </p>
<pre><code>&lt;bound method A.foo of &lt;__main__.A object at 0x7a2c4de10d50&gt;&gt;)
</code></pre>
<p>So no hint there....</p>
</div>
<div class="post-text" itemprop="text">
<p>At least in CPython, bound methods are implemented as an instance of a class <code>method</code>. Every time you ask for the value of a bound function, you get a <em>new</em> instance of this class.</p>
<pre><code>x = a.foo
y = a.foo

assert x is not y
id(x)  # E.g. 139664144271304
id(y)  # E.g. 139664144033992
type(x)  # &lt;class 'method'&gt;
type(y)  # &lt;class 'method'&gt;
</code></pre>
<p>All this class does is store a reference to the instance and the <em>unbound</em> function, and when you call the class it calls the unbound function with the stored instance (along with your other arguments).</p>
<p>Unbound functions, like <code>A.foo</code>, are just regular old functions - no new instances of proxy classes are being constructed, so identity works as you expect.</p>
<p>The reason for this difference is that the semantic meaning of <code>a.foo</code> depends on <strong>two</strong> things, the value of <code>a</code> and the value of <code>A.foo</code>. In order to be able to get this meaning at any point in time later, both of these values need to be stored. This is what the <code>method</code> class does.</p>
<p>Conversely, the meaning of <code>A.foo</code> depends only on a single value: <code>A.foo</code>. So no additional work is required to store anything, and the value itself is used.</p>
<p>You might consider the idea of pre-allocating bound method instances, so that <code>a.foo</code> always returns the same immutable object - but given the dynamic nature of Python, it is simpler and cheaper to just construct a new one each time, even if they could be the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>To add to <a href="https://stackoverflow.com/a/50498830/8033585">@GManNickG</a> answer:</p>
<pre><code>getattr(a, 'foo').__func__ is a.foo.__func__ 
</code></pre>
<p>will return <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some objects stored in classes are <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>, which don't follow normal rules for object lookups. The <code>foo</code> method you're dealing with in your example is one (function objects are descriptors).</p>
<p>A descriptor is an instance of a class that defines a <code>__get__</code> (and optionally <code>__set__</code> and <code>__delete__</code>) method(s). Those methods control what happens when you look up the desciptor on an instance of the class it's stored in.</p>
<p>I think an example will make this more clear:</p>
<pre><code>class DescriptorClass:
    def __get__(*args):
        print("__get__ was called")
        return "whatever"

class OtherClass:
    descriptor_instance = DescriptorClass() # the descriptor instance is a class variable

other_instance = OtherClass()

# this calls the descriptor's __get__ method, which prints "__get__ was called"
result = other_instance.descriptor_instance

print(result) # will print "whatever", since that's what the __get__ method returned
</code></pre>
<p>A <code>__get__</code> method doesn't need to return the same thing every time it's called. In fact, it usually won't. In the specific case of functions being used as descriptors (i.e. methods), a new "bound method" object will be created each time you look the function up. Thus the <code>is</code> operator will not see multiple bound methods as the same object, even though they may be binding the same function to the same instance.</p>
</div>
<span class="comment-copy">It's not a <code>getattr</code> thing; <code>a.foo is not a.foo</code> too.</span>
<span class="comment-copy">@user2357112 Why not?</span>
<span class="comment-copy">Yep, <code>a.foo is a.foo</code> is <code>False</code>!</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/41900639/python-unable-to-compare-bound-method-to-itself" title="python unable to compare bound method to itself">stackoverflow.com/questions/41900639/â€¦</a></span>
<span class="comment-copy">@101 That link helps but the answer by GManNickG here is better, IMO.</span>
<span class="comment-copy">So there is one more layer of abstraction. A method is not actually part of a class, but an instance of class <code>method</code>, which in turn knows the function body and the "hosting" class. Correct?</span>
<span class="comment-copy">mmhh... what you call "regular old functions" are instances of class "function". So again: why the different behaviour?</span>
<span class="comment-copy">Yes, <code>A.foo</code> is a function just like any non-class function is (compare the types, for example). The difference in behavior is that <code>a.foo</code> represents, abstractly, "the function <code>A.foo</code> called with <code>a</code>, as they each were at the time this was invoked". In order to actually make this call later, you must store the value of both of them for later as well, and <code>method</code> is this storage. Simply referring to <code>A.foo</code> requires no additional storage, as you already have the reference to the sole value in question, so regular Python reference semantics suffice.</span>
<span class="comment-copy">Thank you @GManNickG for a very good answer! Just to add/confirm - see <code>new.instancemethod</code> in <a href="https://docs.python.org/2/library/new.html" rel="nofollow noreferrer">docs.python.org/2/library/new.html</a></span>
<span class="comment-copy">ok, I just played around with <code>setattr</code> and  the class and instances of the class. It is necessary to generate <code>a.foo</code> everytime again, because <code>A.foo</code> might have changed (or <code>other_instance_of_A.foo</code> for that matter) and I want to keep <code>a.foo</code> as it was when creating <code>a</code>.  Please add that just for completeness.</span>
<span class="comment-copy">thanks, that makes it a little clearer.</span>
<span class="comment-copy">Found this in your link which explains the exact case <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">docs.python.org/3/howto/descriptor.html#functions-and-methods</a></span>
