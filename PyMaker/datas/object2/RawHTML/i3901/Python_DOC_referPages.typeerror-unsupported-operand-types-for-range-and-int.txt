<div class="post-text" itemprop="text">
<p>Write a Python program to find numbers between 120 and 200 which are divisible by 7 and multiples of 5 without using a "for loop".</p>
<p>I tried to work it out this way...</p>
<pre><code>x = range(120, 200)
if x % 7 == 0 and x % 5 == 0:
    print(x)
</code></pre>
<p>But rather I do get this error. What could I be missing out?</p>
<pre><code>Traceback (most recent call last):
File "C:\Users\User\Desktop\skillshare-code\if else statements\4.py", line 
    11, in &lt;module&gt;
if x % 7 == 0 and x % 5 == 0:
TypeError: unsupported operand type(s) for %: 'range' and 'int'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you're not allowed to use the <code>for</code> construct, you can accomplish this with the <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter</code></a> method:</p>
<pre><code>valid_nums = filter(lambda x: x % 35 == 0, range(120, 200))
</code></pre>
<p>Note that the problem is not asking you to print the numbers but rather "find" them which means to create some form of list or collection of the valid values</p>
<p>PS: I did <code>x % 35 == 0</code> because "divisble by" and "multiples of" means the same thing and so 35 is from <code>7*5</code>.</p>
<p>PPS: <code>filter</code> returns a filter object which is a generator. You will need to convert that to a list if you want to view the list by doing <code>list(valid_nums)</code>. You don't need to do the conversion if you just need to iterate through the values and use them for something else since the generator will work just fine for that</p>
</div>
<div class="post-text" itemprop="text">
<p>Your teacher likes it twisted. Divisible by 7 and multiple of 5 just means divisible by both 7 and 5, so 35...</p>
<p>Your original code <em>needs</em> a loop. But python has built-ins that generate loops without a <code>for</code> or <code>while</code> statement (and they're much faster than <code>for</code> or <code>while</code> because they're usually using native compiled C code)</p>
<p>sshashank124 gave a nice answer, but it can be simplified even more by:</p>
<ul>
<li>choosing the proper <code>range</code> start point by "aligning" 120 on the next multiple of 35</li>
<li>use a step of 35 in <code>range</code></li>
</ul>
<p>like this:</p>
<pre><code>&gt;&gt;&gt; list(range(((120//35)+1)*35,200,35))
[140, 175]
</code></pre>
<p>It's probably much faster because it only uses one division &amp; multiplication, then only additions.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think using a list comprehension is more idiomatic for Python than <code>filter</code> (of course if you are allowed).</p>
<pre><code>x = range(120, 200)
valid_nums = [num for num in x if num % 35 == 0]
</code></pre>
<p>Or at creation:</p>
<pre><code>valid_nums = [num for num in range(120, 200) if num % 35 == 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are trying to do is define x as a range of numbers but that will make x a list of numbers and you will still have to go through every number to check it. Since "for loop" is not allowed, you can use a while loop or call a function recursively starting from lower limit till the passable parameter hits upper limit.</p>
<pre><code>def func(x):
       if (condition satisfied):
            print(x)
       if x&lt;upper_limit:
            func(x+1)
       return
</code></pre>
</div>
<span class="comment-copy">You need to loop through all the values in <code>x</code> but you're not allowed to use the <code>for</code> construct</span>
<span class="comment-copy">"What could I be missing out?" <code>%</code> only works on single numbers, you're trying to use it on a range of numbers.</span>
<span class="comment-copy">Most operations don't automatically loop themselves if you give them an iterable object.</span>
<span class="comment-copy">"which are divisible by 7 and multiples of 5": your teacher has a sense of humour (and mindscrew :))</span>
<span class="comment-copy">@Jean-FrançoisFabre I was staring at that for so long thinking, does he just mean 35? haha</span>
<span class="comment-copy">that's probably what the (evil) teacher had in mind. You could explain the 35, and also note that <code>filter</code> needs to be iterated upon (wrapping it to <code>list</code> for instance) in python 3 else it just returns a generator.</span>
<span class="comment-copy">but it uses a <code>for</code> loop <i>inside</i> the list comprehension.</span>
<span class="comment-copy">@Jean-FrançoisFabre Not a Python for loop. Internally filter also uses loop.</span>
