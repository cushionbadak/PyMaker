<div class="post-text" itemprop="text">
<p>Here's my current code</p>
<pre><code>pN ={'dave': 10, 'jacinta': 10, 'james': 8, 'john': 6, 'jack': 3, 'sam': 2}
highestCount = max(pN.values())

for k, v in pN.items():
  if v == highestCount:
    print(v,k)
</code></pre>
<p>However this only prints the top user and if that position is shared, prints it again as such</p>
<pre><code>10 dave
10 jacinta
</code></pre>
<p>I need to be able to print any amount of top users (<code>n</code>) and have it formatted as such, e.g. for <code>n = 5</code>:</p>
<pre><code>10 john, jacinta, 
8 james
6 john
3 jack
2 sam
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><strong><code>collections.defaultdict</code></strong></a>, swap your <strong><code>keys</code></strong> and <strong><code>values</code></strong></p>
<pre><code>from collections import defaultdict
dct = defaultdict(list)

for k, v in pN.items():
  dct[v].append(k)

# defaultdict(&lt;class 'list'&gt;, {10: ['dave', 'jacinta'], 8: ['james'], 6: ['john'], 3: ['jack'], 2: ['sam']})
</code></pre>
<p>Use <strong><code>sorted</code></strong> for output:</p>
<pre><code>for k, v in sorted(dct.items(), reverse=True):
  print(k, ', '.join(v))

# Result

10 dave, jacinta
8 james
6 john
3 jack
2 sam
</code></pre>
<p><strong><code>function</code></strong> to return top <strong><code>n</code></strong> users (treats ties as one entry):</p>
<pre><code>def top_n(d, n):
  dct = defaultdict(list) 
  for k, v in d.items():
    dct[v].append(k)      
  return sorted(dct.items())[-n:][::-1]

top_n(pN, 3)

# [(10, ['dave', 'jacinta']), (8, ['james']), (6, ['john'])]
</code></pre>
<h3>Using a <code>defaultdict</code> is simple and fast, and here are some timings to prove it:</h3>
<p><strong><em>Functions that will be timed</em></strong></p>
<pre><code>def chris_z(d, n):
  dct = defaultdict(list) 
  for k, v in d.items():
    dct[v].append(k)      
  return sorted(dct.items())[-n:][::-1]

def tim_lombard(score_dict, n):
  lot = [(k,v) for k, v in score_dict.items()] #make list of tuple from scores dict
  nl = []
  while len(lot)&gt; 0:
      nl.append(max(lot, key=lambda x: x[1]))
      lot.remove(nl[-1])

def ajax(d, n:'n_users', top = True):
  _ranks = sorted(d.values())
  _ranks = _ranks[-n:] if top else _ranks[:n]
  return {i:[a for a, b in d.items() if b == i] for i in _ranks}
</code></pre>
<p><strong><em>Results</em></strong></p>
<pre><code>x = [''.join(i) for i in itertools.permutations('chrisz', 6)]    
y = [random.randint(0, 100) for _ in range(720)]  
z = dict(zip(x, y))

In [40]: %timeit chris_z(z, 500)
110 µs ± 259 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

In [42]: %timeit tim_lombard(z, 500)
26.2 ms ± 60 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [43]: %timeit ajax(z, 500)
15.3 ms ± 227 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>sorted</code> and a dictionary comprehension:</p>
<pre><code>from typing import Dict, List
def ranking(d, n:'n_users', top = True) -&gt; Dict[int, List[str]]:
  _ranks = sorted(d.values())
  _ranks = _ranks[-n:] if top else _ranks[:n]
  return {i:[a for a, b in d.items() if b == i] for i in _ranks}

pN ={'dave': 10, 'jacinta': 10, 'james': 8, 'john': 6, 'jack': 3, 'sam': 2}
for a, b in sorted(ranking(pN, 10).items(), key=lambda x:x[0], reverse=True):
  print('{} {}'.format(a, ', '.join(b)))
</code></pre>
<p>Output:</p>
<pre><code>10 dave, jacinta
8 james
6 john
3 jack
2 sam
</code></pre>
<p>Edit: for any number of top users, pass the value to the function:</p>
<pre><code>_r = ranking(pN, 5) #for the top 5 users
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Would this work for you? </p>
<pre><code>pN ={'dave': 10, 'jacinta': 10, 'james': 8, 'john': 6, 'jack': 3, 'sam': 2}

def top_n_scores(n, score_dict):
  ''' returns the n scores from a name:score dict'''
  lot = [(k,v) for k, v in pN.items()] #make list of tuple from scores dict
  nl = []
  while len(lot)&gt; 0:
      nl.append(max(lot, key=lambda x: x[1]))
      lot.remove(nl[-1])

  return nl[0:n]   
</code></pre>
<p>To get the top 4 scores:</p>
<pre><code>top_n_scores(4, pN) 

[('dave', 10), ('jacinta', 10), ('james', 8), ('john', 6)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should try it with <code>collections.defaultdict</code> with in-built <code>sorted()</code> funct.</p>
<pre><code>from collections import defaultdict

def sort_it(_dict, n):
    result = defaultdict(list)
    for name, num in _dict.items():
        result[num].append(name)
    return sorted(result.items(), reverse=True)[:n]

&gt;&gt;&gt; pN = {'dave': 10, 'jacinta': 10, 'james': 8, 'john': 6, 'jack': 3, 'sam': 2}
&gt;&gt;&gt; top3 = sort_it(pN, 3)
[(10, ['jacinta', 'dave']), (8, ['james']), (6, ['john'])] # Output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you want to group by scores, it would make sense to use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>scores ={'dave': 10, 'jacinta': 10, 'james': 8, 'john': 6, 'jack': 3, 'sam': 2}

from itertools import groupby
from operator import itemgetter

get_score = itemgetter(1)

def group_users_by_score(scores, n=-1):
    sorted_users = sorted(scores.items(), key=get_score, reverse=True)
    top_n = sorted_users[:n]
    return groupby(top_n, key=get_score)

def display_top_users(scores, n=-1):
    for score, users in group_users_by_score(scores, n):
        print("%3d %s" % (score, ', '.join(u for (u,s) in users)))
</code></pre>
<p>As an example:</p>
<pre><code>&gt;&gt;&gt; display_top_users(scores, 3)
 10 dave, jacinta
  8 james
&gt;&gt;&gt; display_top_users(scores)
 10 dave, jacinta
  8 james
  6 john
  3 jack
</code></pre>
</div>
<span class="comment-copy">Thanks, this fixes one of the problems I have but how would you include the feature to grab any "n" amount of top users? say you wanted the top 5 or top 3 (the top 3 might have 4 because two users have the same number)?</span>
<span class="comment-copy">@Lara You just pass the value you want to the function. Please see my recent edit, as I added annotations to clarify this.</span>
<span class="comment-copy">using <code>groupby</code> with <code>sorted</code> introduces more complexity.</span>
<span class="comment-copy">@Jean-FrançoisFabre: <code>groupby</code> needs to be applied on sorted values though. What do you propose? A <code>defaultdict</code>?</span>
