<div class="post-text" itemprop="text">
<p>This function converts string roman numerals into integers by iterating from the right and adding to the symbol on the left unless it is greater, then it subtracts. What I don't understand is how <code>i</code> gets assigned to a index in the string. How does it bind to the iterator from <code>range</code> when it reduces?</p>
<pre><code>import functools

def roman_to_integer(s):
    T = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    return functools.reduce(lambda val, i: val + (-T[s[i]] if T[s[i]] &lt; T[s[i + 1]] else T[s[i]]), reversed(range(len(s) - 1)), T[s[-1]])
</code></pre>
<p>I know this is very un-Pythonic. I found this example in a book on interview questions in Python and want to understand why this works. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer"><code>lambda</code></a> is - in simplified terms- a simple, anonymous function. You can break it up just like a function based on the colon:</p>
<pre><code>f = lambda x,*args,k = 5, **kw: print(x,args,k,kw)

def f (x, *args, k = 5, **kw): return print(x,args,k,kw)
</code></pre>
<p>The string <code>s</code> and the dictionary <code>T</code> are available in a <a href="https://docs.python.org/3.6/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">scope</a> higher than the <code>lambda</code> and neither is assigned within the <code>lambda</code> statement, so the <code>lambda</code> has access to both.</p>
<p><a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> is a function that basically maps another callable across an iterable. As you can see in the docs, <code>reduce</code> applies the current result as the first argument to the given callable, and the current item as the second argument. A third argument can be supplied to reduce, which is the starting value; if not supplied, the first element in iterable will be used instead.</p>
<pre><code>## This is just an example, obviously...
import functools, operator
functools.reduce(operator.add,range(4))
## Step 0: No default, so first element of range is used as the current value: 0
## Step 1: add(0,next(range)) =&gt; add(0,1) =&gt; 1
## Step 2: add(1,next(range)) =&gt; add(1,2) =&gt; 3
## Step 3: add(3,next(range)) =&gt; add(3,3) =&gt; 6
## Step 4: No more items in range, so return current value: 6
</code></pre>
<p>So, as you can see, the current element of <code>range</code> (the iterable passed to <code>reduce</code>) is passed at each Step as the second argument (<code>i</code>) to the function passed to <code>reduce</code> (<code>lambda</code>). The <code>lambda</code> function then uses the second argument (<code>i</code>) to index string <code>s</code></p>
</div>
<span class="comment-copy">Let's get this straight: this is NOT how you should be writing code in python.</span>
<span class="comment-copy">The second argument to <code>reduce</code> is an element from the list <code>reversed(range(len(s) - 1))</code></span>
