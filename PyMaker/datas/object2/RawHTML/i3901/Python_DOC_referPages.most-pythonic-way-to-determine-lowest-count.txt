<div class="post-text" itemprop="text">
<p>I find myself wanting to keep a lowest/largest count when iterating through dictionaries. </p>
<p>For example:</p>
<pre><code>d = {
    'Bob': 2000,
    'Larry': 6000,
    'Mary': 5
}

lowest_value = 1000000
list_of_keys = []

for key, value in d.items():
    if value &gt; 100:
        list_of_keys.append(key)
        if value &lt; lowest_value:
            lowest_value = value
</code></pre>
<p>Rather than setting my <code>lowest_value</code> to a number that will certainly be greater than the first <code>if value &lt; lowest_value:</code>, is there a nicer way of doing this?</p>
<p>For <code>largest_count</code> I can usually just use 0 or -1. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#min" rel="noreferrer"><code>min()</code></a> or <a href="https://docs.python.org/3/library/functions.html#max" rel="noreferrer"><code>max()</code></a> like:</p>
<h3>Code:</h3>
<pre><code>min(d.values())
</code></pre>
<h3>Test Code:</h3>
<pre><code>d = {
    'Bob': 2000,
    'Larry': 6000,
    'Mary': 5
}
print(min(d.values()))
</code></pre>
<h3>Results:</h3>
<pre><code>5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>from math import inf</code> and use <code>inf</code> rather than some ad-hoc number. Ints compare against floats just fine in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's builtin <code>min</code> can take an iterable. You can also put the <code>&gt; 100</code> filter in a genexpr. Python dicts can also return an iterable of values only, since you dont' care about the keys.</p>
<pre><code>lowest_value = min(value for value in d.values() if value &gt; 100)
</code></pre>
<p>You can get the list of keys in a list comp separately.</p>
<pre><code>list_of_keys = [key for key, value in d.items() if value &gt; 100]
</code></pre>
<p>This iterates twice, but that's OK unless your dict is really large (in which case, consider using pandas dataframes instead.)</p>
<p>To avoid duplicating the filter step, you can use a dict comp first.</p>
<pre><code>d2 = {k: v for k, v in d.items() if v &gt; 100}
lowest_value = min(d2.values())
list_of_keys = list(d2.keys())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The one-liner.</p>
<pre><code>ks, low = [f(i) for f, i in zip([list, min], zip(*((k, v) for k, v in d.items() if v&gt;100)))]
</code></pre>
</div>
<span class="comment-copy">@StephenRauch I mean setting <code>lowest_value</code> initially. You don't have value then</span>
<span class="comment-copy">Or do you mean <code>max(list(d.values()))</code> ? I guess that could work</span>
<span class="comment-copy">There is also <code>float('inf')</code></span>
<span class="comment-copy">You can also avoid the filtering step with <code>list_of_keys = [...]; lowest_value = d[min(list_of_keys, key=d.get)]</code>. BTW: your one-liner is the slowest approach.</span>
<span class="comment-copy">Or even <code>lowest_value = min(map(d.get, list_of_keys))</code></span>
