<div class="post-text" itemprop="text">
<p>Here are two discrete objects:</p>
<pre><code>class Field(object):
    pass

class MyClass(object):
    spam = Field()
    eggs = Field()
    potato = Field()
</code></pre>
<p>For any <code>Field</code> object, is there inherently a way for that object to be aware of the attribute name that <code>MyClass</code> assigned it?</p>
<p>I know I could pass parameters to the <code>Field</code> object, like <code>potato = Field(name='potato')</code>, but that would be messy and tedious in my actual case so I'm just wondering if there's a non-manual way of doing the same thing.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can make the <code>Field</code> class a <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor</a>, and then use <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" rel="nofollow noreferrer"><code>__set_name__</code></a> method to bind the name.  No special handling is needed in <code>MyClass</code>.</p>
<blockquote>
<p><code>object.__set_name__(self, owner, name)</code>
  Called at the time the owning class owner is created. The descriptor has been assigned to name.</p>
</blockquote>
<p>This method is <a href="https://www.python.org/dev/peps/pep-0487/" rel="nofollow noreferrer">available in Python 3.6+</a>.</p>
<pre><code>&gt;&gt;&gt; class Field:
...     def __set_name__(self, owner, name):
...         print('__set_name__ was called!')
...         print(f'self: {self!r}')  # this is the Field instance (descriptor)
...         print(f'owner: {owner!r}')  # this is the owning class (e.g. MyClass) 
...         print(f'name: {name!r}')  # the name the descriptor was bound to
... 
&gt;&gt;&gt; class MyClass:
...     potato = Field()
... 
__set_name__ was called!
self: &lt;__main__.Field object at 0xcafef00d&gt;
owner: &lt;class '__main__.MyClass'&gt;
name: 'potato'
</code></pre>
</div>
<span class="comment-copy">There sort of is a way, but before I write up the answer, I want to make sure you're not making the mistake of thinking those are instance attributes. Those are supposed to be on the <i>class</i>, not the instance?</span>
<span class="comment-copy">They are supposed to be class-level attributes, yes, not instance attributes. I realize my example lends itself better to the latter case. Apologies if my use of terminology is incorrect, I'm trusting you understand what I'm getting at.</span>
<span class="comment-copy">Related: <a href="//stackoverflow.com/q/1373164">How do I create a variable number of variables?</a> (tl;dr: It's quite likely that you're doing something wrong. Maybe you should store those instances in a dict instead?)</span>
<span class="comment-copy">@Aran-Fey I'm not actually looking to create a variable number of variables; the example implies that but it's just an abstraction. 'timmy, jeff and bobby' are the only attributes that will ever exist in this scenario; they could just as easily be "firstname, lastname and email".</span>
<span class="comment-copy">@Aran-Fey  I disagree.  This is standard practice for fields in ORMs, and has use-cases in several other types of frameworks.</span>
<span class="comment-copy">Oooo this is new. I didn't realize this was added in 3.6</span>
<span class="comment-copy">Yep.  Before PEP 487, people (e.g. Django) were already doing the same thing with metaclasses / introspection hacks.</span>
<span class="comment-copy">+1 Thanks, looks promising and I appreciate the trouble you went to with the example. 3.6 is a bit bleeding edge (I should have specified version) but I'll accept this and upgrade if no universal answers come along.</span>
<span class="comment-copy">@Ivan I suggest upgrading to 3.6 for the new <code>dict</code> implementation alone. They maintain insertion order and are significantly more compact, especially for small dicts (which tend to litter Python programs since most user defined objects carry one around d for attributes).</span>
