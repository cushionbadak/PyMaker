<div class="post-text" itemprop="text">
<p>Now that <a href="https://www.python.org/dev/peps/pep-0572/" rel="nofollow noreferrer">PEP 572</a> has been accepted, Python 3.8 is destined to have <em>assignment expressions</em>, so we can use an assignment expression in <code>with</code>, i.e.</p>
<pre><code>with (f := open('file.txt')):
    for l in f:
        print(f)
</code></pre>
<p>instead of </p>
<pre><code>with open('file.txt') as f:
    for l in f:
        print(f)
</code></pre>
<p>and it would work as before. </p>
<p>What use does the <code>as</code> keyword have with the <code>with</code> statement in Python 3.8? Isn't this against the Zen of Python: <em>"There should be one -- and preferably only one -- obvious way to do it."</em>?</p>
<hr/>
<p>When the feature was originally proposed, it wasn't clearly specified whether the assignment expression should be parenthesized in <code>with</code> and that </p>
<pre><code>with f := open('file.txt'):
    for l in f:
        print(f)
</code></pre>
<p>could work. However, in Python 3.8a0, </p>
<pre><code>with f := open('file.txt'):
    for l in f:
        print(f)
</code></pre>
<p>will cause</p>
<pre><code>  File "&lt;stdin&gt;", line 1
    with f := open('file.txt'):
           ^
SyntaxError: invalid syntax
</code></pre>
<p>but the parenthesized expression works.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong>: The behaviour is not the same for both constructs, even though there wouldn't be discernible differences between the 2 examples.</p>
<p>You should almost never need <code>:=</code> in a <code>with</code> statement, and sometimes it is very wrong. When in doubt, always use <code>with ... as ...</code> when you need the managed object within the <code>with</code> block.</p>
<hr/>
<p>In <code>with context_manager as managed</code>, <code>managed</code> is bound to the <em>return value</em> of <code>context_manager.__enter__()</code>, whereas in <code>with (managed := context_manager)</code>, <code>managed</code> is bound to the <code>context_manager</code> itself and the return value of the <code>__enter__()</code> method call is <em>discarded</em>. The behaviour is <em>almost</em> identical for open files, because their <code>__enter__</code> method returns <code>self</code>.</p>
<p>The first excerpt is <a href="https://stackoverflow.com/questions/26096435/is-python-with-statement-exactly-equivalent-to-a-try-except-finally-bloc"><em>roughly</em> analogous to</a></p>
<pre><code>_mgr = (f := open('file.txt')) # `f` is assigned here, even if `__enter__` fails
_mgr.__enter__()               # the return value is discarded

exc = True
try:
    try:
        BLOCK
    except:
        # The exceptional case is handled here
        exc = False
        if not _mgr.__exit__(*sys.exc_info()):
            raise
        # The exception is swallowed if exit() returns true
finally:
    # The normal and non-local-goto cases are handled here
    if exc:
        _mgr.__exit__(None, None, None)
</code></pre>
<p>whereas the <code>as</code> form would be</p>
<pre><code>_mgr = open('file.txt')   # 
_value = _mgr.__enter__() # the return value is kept

exc = True
try:
    try:
        f = _value        # here f is bound to the return value of __enter__
                          # and therefore only when __enter__ succeeded
        BLOCK
    except:
        # The exceptional case is handled here
        exc = False
        if not _mgr.__exit__(*sys.exc_info()):
            raise
        # The exception is swallowed if exit() returns true
finally:
    # The normal and non-local-goto cases are handled here
    if exc:
        _mgr.__exit__(None, None, None)
</code></pre>
<p>i.e. <code>with (f := open(...))</code> would set <code>f</code> to the return value of <code>open</code>, whereas <code>with open(...) as f</code> binds <code>f</code> to the return value of the <em>implicit</em> <code>__enter__()</code> method call.</p>
<p>Now, in case of <strong>files and streams</strong>, <code>file.__enter__()</code> will return <code>self</code> if it succeeds, so the behaviour for these two approaches is <em>almost</em> the same - the only difference is in the event that <code>__enter__</code> throws an exception.</p>
<p>The fact that assignment expressions will often work instead of <code>as</code> is deceptive, because there are many classes where <code>_mgr.__enter__()</code> returns an object that is <em>distinct</em> from <code>self</code>. In that case an assignment expression works differently: the context manager is assigned, instead of the <em>managed object</em>. For example <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer"><code>unittest.mock.patch</code></a> is a context manager that will return the <em>mock</em> object. The documentation for it has the following example:</p>
<pre><code>&gt;&gt;&gt; thing = object()
&gt;&gt;&gt; with patch('__main__.thing', new_callable=NonCallableMock) as mock_thing:
...     assert thing is mock_thing
...     thing()
...
Traceback (most recent call last):
  ...
TypeError: 'NonCallableMock' object is not callable
</code></pre>
<p>Now, if it were to be written to use an assignment expression, the behaviour would be different:</p>
<pre><code>&gt;&gt;&gt; thing = object()
&gt;&gt;&gt; with (mock_thing := patch('__main__.thing', new_callable=NonCallableMock)):
...     assert thing is mock_thing
...     thing()
...
Traceback (most recent call last):
  ...
AssertionError
&gt;&gt;&gt; thing
&lt;object object at 0x7f4aeb1ab1a0&gt;
&gt;&gt;&gt; mock_thing
&lt;unittest.mock._patch object at 0x7f4ae910eeb8&gt;
</code></pre>
<p><code>mock_thing</code> is now bound to the context manager instead of the new mock object.</p>
</div>
