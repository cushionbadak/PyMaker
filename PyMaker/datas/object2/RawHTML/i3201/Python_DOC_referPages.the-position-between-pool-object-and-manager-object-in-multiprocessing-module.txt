<div class="post-text" itemprop="text">
<pre><code> 1 from multiprocessing import Pool, Manager
 2 
 3 
 4 def test(num):
 5     queue.put(num)
 6 
 7 
 8 queue = Manager().Queue()
 9 pool = Pool(5)
 10 
 11 for i in range(30):
 12     pool.apply_async(test, (i, ))
 13     
 14 pool.close()
 15 pool.join()
 16 
 17 print(queue.qsize())
</code></pre>
<p>The output of the code above is 30. However, if line 8 is exchanged with line 9 (see the code below), the output will be 0. So is there anybody who knows why? Thank you!</p>
<pre><code>1 from multiprocessing import Pool, Manager
2 
3 
4 def test(num):
5     queue.put(num)
6 
7 
8 pool = Pool(5)
9 queue = Manager().Queue()
10 
11 for i in range(30):
12     pool.apply_async(test, (i, ))
13     
14 pool.close()
15 pool.join()
16 
17 print(queue.qsize())
</code></pre>
<hr/>
<pre><code>from multiprocessing import Process, Queue 


def test():
    queue.put(1)


p = Process(target=test) 
queue = Queue()
p.start()
p.join()

print(queue.qsize())
</code></pre>
<p>The output is 1, which means the child process put the number into the queue created by the parent. Is that correct?</p>
</div>
<div class="post-text" itemprop="text">
<p>I assume you are using a Unix based operating system as on NT ones your logic would most likely break.</p>
<p>To understand what happens we need to dig into the <code>multiprocessing</code> internals. On Unix, when creating a new process, the <a href="https://docs.python.org/3/library/multiprocessing.html?highlight=process#contexts-and-start-methods" rel="nofollow noreferrer"><code>fork</code></a> primitive is used. When a process forks, the parent continues its execution and the child starts as an exact copy of the parent.</p>
<p>Python tends to hide a lot of things in the <code>multiprocessing</code> module (I particularly dislike that) and leads to lots of misunderstandings. In your logic, the <code>fork</code> happens when you create the <code>Pool</code> (line 9 in the first example, 8 in the second). </p>
<p>In the first example, the children inherits the same <code>queue</code> object the parent created. Therefore, they successfully manage to communicate as they share the same channel. </p>
<p>In the second one instead, parent and children create their own separated <code>queue</code> objects which are totally independent. When a child puts an element in the <code>queue</code> it puts it in its own one which is not shared by anybody.   </p>
<p>In the third and last example you create a <code>Process</code> object, then a <code>Queue</code> and then you call <code>start</code> on the process. Guess when the <code>fork</code> happens? When you call <code>start</code> and not when you create the <code>Process</code> object. That's why the <code>queue</code> is successfully shared. This is what I mean when I say that <code>multiprocessing</code> APIs are a bit misleading.</p>
</div>
<span class="comment-copy">Please remove line numbers at the side of the code snippets. They make it hard for people to copy-paste your code for try.</span>
<span class="comment-copy">Thank you for your answer! But when I tried Process() to achieve multiprocessing, the Queue object created after the Process object is shared by the parent (I can get the element that was put in the child). So does your logic apply to this?</span>
<span class="comment-copy">Can you link the logic using <code>Process</code> instead? Maybe append it to the above question.</span>
<span class="comment-copy">I have appended the code to the above question.</span>
<span class="comment-copy">Extended my answer to cover the last case.</span>
