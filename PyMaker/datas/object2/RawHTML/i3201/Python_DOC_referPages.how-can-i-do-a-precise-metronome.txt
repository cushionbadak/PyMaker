<div class="post-text" itemprop="text">
<p>I tried to do a very simple metronome that is working at 30 bpm:</p>
<pre><code>While True:
    winsound.Beep(1000, 200)
    time.sleep(2 - 0.2)
</code></pre>
<p>Then, I turned on a metronome app on my phone together with the beep in the computer, and it became less precise as the time went on.
Is there another way to do the "time.sleep()"? Is it even the "time.sleep()" guilt?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is difficult to do on a multitasking operating system: it's not easy for the system to give you the exact <code>sleep</code> delay that you request. See <a href="https://stackoverflow.com/questions/1133857/how-accurate-is-pythons-time-sleep">How accurate is python's time.sleep()?</a> for details. </p>
<p>But we can get fairly close by measuring the time span and adjusting the sleep delay. Python 3.3+ provides <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer"><code>time.perf_counter</code></a>, which is supposed to be pretty good at measuring time intervals, although the exact precision depends on your OS and hardware.</p>
<p>Here's a simple demo that just prints the difference between the requested and the measured time delay for each tick. The initial outputs are a bit sloppy, but it soon settles down to giving ticks that are within 10 microseconds of the requested interval. However, playing a sound takes more system resources than printing to the terminal, and that may impact the precision of this technique. For best results, minimize the task load on your machine, especially if it's single core.</p>
<p>I've set the delay here to 0.2 seconds = 300 bpm. Slower beat rates may give <em>less</em> precision because there's more time during each sleep cycle for the CPU to do other tasks that may cause the sleep to be a little longer than requested.</p>
<pre><code>from time import sleep, perf_counter

delay = d = 0.2
print(60 / delay, 'bpm')
prev = perf_counter()
for i in range(20):
    sleep(d)
    t = perf_counter()
    delta = t - prev - delay
    print('{:+.9f}'.format(delta))
    d -= delta
    prev = t
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>300.0 bpm
+0.000262488
+0.000151862
-0.000019085
-0.000011358
+0.000023078
-0.000015817
-0.000004357
+0.000009283
-0.000012252
+0.000020515
-0.000009061
+0.000003249
-0.000011482
+0.000029230
+0.000001554
-0.000023614
-0.000003286
+0.000000127
-0.000003732
+0.000016311
</code></pre>
<p>These results are from an old single core 32 bit 2GHz machine running Linux, YMMV.</p>
</div>
<span class="comment-copy">If you need a real timer, don't rely on sleep intervals. Run your interval poll, and then check clock time. I ran into this in Nodejs the other day, I'm sure the solution can be adapted to Python with minimal effort. <a href="https://stackoverflow.com/questions/49540098/preventing-a-bpm-ticker-from-slowly-drifting-out-of-sync-with-a-real-metronome" title="preventing a bpm ticker from slowly drifting out of sync with a real metronome">stackoverflow.com/questions/49540098/â€¦</a> - effectively: you know the clock time when your timer starts, you know the clock time when your metronome should "tick", so run your poller faster than the metronome ticks, and tick whenever your BPM value says you should.</span>
<span class="comment-copy">So is there no real solution for all the speeds of the metronome? Can't I get over this?</span>
<span class="comment-copy">@Python You can set the BPM to anything you want, using <code>delay = d = 60 / bpm</code>. The errors will generally be small, mostly less than a millisecond, and usually less than that. Eg, I just tested it on 30 BPM and the errors were mostly around 5 microseconds. And since they tend to alternate between positive &amp; negative fairly regularly the long-term drift should be quite small. But you'll have to run it on your system at various speeds to see what results you get.</span>
