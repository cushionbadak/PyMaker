<div class="post-text" itemprop="text">
<p>I am trying to simply replace missing date values from two strings, but splitting them into a dictionary of "year", "month", etc. However I am running into a very odd issue I did not find the answer for after 20 minutes googling.</p>
<p>Here's my code:</p>
<pre><code>def date_split(date):
    parts = date.split('-')
    if len(parts) == 1:
        year = parts[0]
        dates = {'y' : year}
    if len(parts) == 2:
        year = parts[0]
        month = parts[1]
        dates = {'y' : year, 'm' : month}
    if len(parts) == 3:
        year = parts[0]
        month = parts[1]
        day = parts[2]
        dates = {'y' : year, 'm' : month, 'd' : day}
    return dates

def recompile(date):
    lista = list(date.values())
    date = "-".join(lista)
    return date

std = "2018-07-18"
x = "XXXX-01"

if date_split(x)['y'] == 'XXXX':
    new = str(date_split(std)['y'])
    date_split(x)['y'] = new
    date = recompile(date_split(x))
    print(date)
</code></pre>
<p>I just began twiddling with it so it's very rough, but I am working on it. However, while <code>date_split(std)['y']</code> prints out as <code>2018</code>, after <code>date_split(x)['y'] = new</code>, the value of <code>date_split(x)['y']</code> prints out as <code>"XXXX"</code> still. So the dictionary does not update the value. Is there something I'm missing about how dictionaries work in python? I'm quite new to it. I've tried also different forms of the dictionary update command.</p>
<p>Using Python 3.6 with Anaconda.</p>
</div>
<div class="post-text" itemprop="text">
<p>You change the return value of a function. Since you don't store it anywhere, it's lost. Instead, do something like</p>
<pre><code> custom_date = date_split(x)
 custom_date['y'] = new
 date = recompile(custom_date)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Each time you call <code>date_split(x)</code> it returns a new dict, so updating it won't have an effect on the next call. Instead, you should assign the returning value of <code>date_split(x)</code> to a variable and then use that variable for further processing.</p>
<pre><code>std = "2018-07-18"
x = "XXXX-01"
s = date_split(x)
if s['y'] == 'XXXX':
    new = str(date_split(std)['y'])
    s['y'] = new
    date = recompile(s)
    print(date)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def date_split(date):
    parts = date.split('-')
    if len(parts) == 1:
        year = parts[0]
        dates = {'y' : year}
    if len(parts) == 2:
        year = parts[0]
        month = parts[1]
        dates = {'y' : year, 'm' : month}
    if len(parts) == 3:
        year = parts[0]
        month = parts[1]
        day = parts[2]
        dates = {'y' : year, 'm' : month, 'd' : day}
    return dates

def recompile(date):
    lista = list(date.values())
    date = "-".join(lista)
    return date

std = "2018-07-18"
x = "XXXX-01"

if date_split(x)['y'] == 'XXXX':
    old = date_split(x)
    new = str(date_split(std)['y'])
    print(old)
    print(new)
    old['y'] = new
    date = recompile(old)
    print(date)
</code></pre>
<p>you cannot save changes on a function call, you have to store it in a variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have said you need to save the dictionary returned by <code>date_split</code> so you can modify it. However, your <code>date_split</code> function is much larger than it needs to be, so I've written a more compact version using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a>. </p>
<p>Your <code>recompile</code> function won't always work correctly on earlier versions of Python, where a dict is an unordered collection, but it's ok on Python 3.6+ since dict now retains the insertion order. Also, there's no need to call <code>str</code> in <code>new = str(date_split(std)['y'])</code>. All the values in the dict returned by <code>date_split</code> are already strings. </p>
<pre><code>def date_split(date):
    return dict(zip("ymd", date.split("-")))

def recompile(date):
    return "-".join(date.values())

std = "2018-07-18"
x = "XXXX-01"

x_split = date_split(x)
print("Original", x_split)
if x_split["y"] == "XXXX":
    x_split["y"] = date_split(std)["y"]
    print("Updated ", x_split)
    date = recompile(x_split)
    print("String  ", date)
</code></pre>
<p><strong>output</strong></p>
<pre><code>Original {'y': 'XXXX', 'm': '01'}
Updated  {'y': '2018', 'm': '01'}
String   2018-01
</code></pre>
</div>
<span class="comment-copy">The function returns a <i>new dictionary object</i>. <code>date_split(x)['y'] = ...</code> produces that new dictionary object, alters it, and then... the dictionary is lost as nothing else references it. Either share a dictionary object that the function modifies in-place, or first store the result of <code>date_split()</code> so you can later on refer to it again.</span>
<span class="comment-copy">Thank you everyone! Should have thought of this</span>
