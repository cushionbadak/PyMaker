<div class="post-text" itemprop="text">
<p>I created two functions that returns a sorted a list. Both of them take as argument a list containg instances of Employee Class. The first sorts by name attribute and the second by age and both of them use lambda function</p>
<pre><code>class Employee():

    allEmployees = []

    def __init__(self, name, age):
        self.name = name
        self.age = age
        Employee.allEmployees.append(self)


def sortEmployeesByName(some_list, name):
    return sorted(some_list, key=lambda employee: employee.name)

def sortEmployeesByAge(some_list, age):
    return sorted(some_list, key=lambda employee: employee.age)
</code></pre>
<p>How can I create only one function <code>sortEmployees</code>, where I pass the attribute as the second parameter and also use lambda function?</p>
<p>e.g.</p>
<pre><code>def sortEmployess(some_list, attribute):
    return sorted(some_list, key=lambda employee: employee.attribute)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you want <code>operator.attrgetter</code>, no need for lambdas. This should also perform better:</p>
<pre><code>sorted(some_list, key=operator.attrgetter('name'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <code>operator.attrgeter</code>. I added <code>__repr__</code> method to see the example:</p>
<pre><code>from operator import attrgetter

class Employee:

    allEmployees = []

    def __init__(self, name, age):
        self.name = name
        self.age = age
        Employee.allEmployees.append(self)

    def __repr__(self):
        return f'Employee({self.name}, {self.age})'

def sortEmployees(some_list, attribute):
    f = attrgetter(attribute)
    return sorted(some_list, key=f)

l = [Employee('John', 30),
Employee('Miranda', 20),
Employee('Paolo', 42)]

print(sortEmployees(Employee.allEmployees, 'name'))
print(sortEmployees(Employee.allEmployees, 'age'))
</code></pre>
<p>Prints:</p>
<pre><code>[Employee(John, 30), Employee(Miranda, 20), Employee(Paolo, 42)]
[Employee(Miranda, 20), Employee(John, 30), Employee(Paolo, 42)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another version using <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>operator.attrgetter</code></a>. I think it makes sense here to give the <code>Employee</code> class a <code>.sort</code> <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer">classmethod</a>. I've "borrowed" the <code>__repr__</code> method and test data from Andrej Kesely. ;)</p>
<pre><code>from operator import attrgetter

class Employee:
    allEmployees = []

    def __init__(self, name, age):
        self.name = name
        self.age = age
        Employee.allEmployees.append(self)

    def __repr__(self):
        return f'Employee({self.name}, {self.age})'

    @classmethod
    def sort(cls, attr):
        return sorted(cls.allEmployees, key=attrgetter(attr))   

Employee('John', 30)
Employee('Miranda', 20)
Employee('Paolo', 42)

print(Employee.sort('name'))
print(Employee.sort('age'))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[Employee(John, 30), Employee(Miranda, 20), Employee(Paolo, 42)]
[Employee(Miranda, 20), Employee(John, 30), Employee(Paolo, 42)]
</code></pre>
<hr/>
<p>A nice thing about <code>operator.attrgetter</code> is that we can pass it multiple attributes and it will return a tuple of attributes. We can use this to sort by multiple attributes in a single pass. But we need to modify the <code>.sort</code> method slightly. The other code remains the same.</p>
<pre><code>    @classmethod
    def sort(cls, *attrs):
        return sorted(cls.allEmployees, key=attrgetter(*attrs))


Employee('John', 30)
Employee('Miranda', 20)
Employee('Paolo', 42)
Employee('John', 20)

print(Employee.sort('name'))
print(Employee.sort('age'))
print(Employee.sort('name', 'age'))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[Employee(John, 30), Employee(John, 20), Employee(Miranda, 20), Employee(Paolo, 42)]
[Employee(Miranda, 20), Employee(John, 20), Employee(John, 30), Employee(Paolo, 42)]
[Employee(John, 20), Employee(John, 30), Employee(Miranda, 20), Employee(Paolo, 42)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You probably don't want to do this, but I'll show you how anyway, using <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a>:</p>
<pre><code>getattr(object, name[, default])
</code></pre>
<blockquote>
<p>Return the value of the named attribute of <em>object</em>. <em>name</em> must be a string. If the string is the name of one of the object’s attributes, the result is the value of that attribute. For example, <code>getattr(x, 'foobar')</code> is equivalent to <code>x.foobar</code>. If the named attribute does not exist, <em>default</em> is returned if provided, otherwise <code>AttributeError</code> is raised.</p>
</blockquote>
<p>So:</p>
<pre><code>def sortEmployees(some_list, age, key_attr):
    return sorted(some_list, key=lambda employee: getattr(employee, key_attr))
</code></pre>
<p>However, if the only thing you're using this for is a sort key, <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>attrgetter</code></a> in the stdlib wraps that up for you so you'd don't need to <code>lambda</code> up your own function:</p>
<pre><code>def sortEmployees(some_list, age, key_attr):
    return sorted(some_list, key=operator.attrgetter(key_attr))
</code></pre>
<hr/>
<p>The reason you probably don't want to do this is that mixing up data and variable names is generally a bad idea, <a href="https://nedbatchelder.com/blog/201112/keep_data_out_of_your_variable_names.html" rel="nofollow noreferrer">as explained by Ned Batchelder better than I could.</a></p>
<p>You end up with something that looks—to the human reader, and to your IDE, and to static checkers like linters and type checkers, and maybe even the optimizer—like dynamic code, even though what it actually does is purely static. You're getting all of the disadvantages of dynamic code without any of the benefits.</p>
<p>You don't even get shorter method calls:</p>
<pre><code>sortEmployeesByName(some_list, name)
sortEmployees(some_list, name, "name")
</code></pre>
<hr/>
<p>However, the reason this is just "probably" rather than "definitely" is that there are cases where the same tradeoff goes the other way. </p>
<p>For example, if you had 15 of these attributes instead of 2, copying and pasting and editing the code 15 times would be a massive DRY violation. Or, imagine you were building the class or its instances dynamically, and the names weren't even known until runtime.</p>
<p>Of course you could write code that dynamically generates the methods at class or instance creation time, so they can then be used statically by client code. And this is a great pattern (used in various places in the stdlib). But for a dead simple case, it may be overcomplicating things badly. (A typical reader can figure out what a <code>getattr</code> means more easily than figuring out a <code>setattr</code> plus a descriptor <code>__get__</code> call to manually bind a method, obviously.) And it still won't help many static tools understand your type's methods.</p>
<p>In many such cases, the way to fix that is to stop having separate named attributes and instead have a single attribute that's a dict holding all the not-quite-attribute things. But again, that's just "many", not "all", and the tradeoff can go the other way. For example, an ORM class, or something that acts like a Pandas DataFrame, you'd expect to be able to access the attributes as attributes.</p>
<p>So, that's why the feature is there: because sometimes you need it. I don't think you do need it in this case, but it's a judgment call.</p>
</div>
<span class="comment-copy">Why not use a normal (<code>def</code>) function?</span>
<span class="comment-copy">@RafaelC Because <code>sorted</code> takes a function as a key, but the OP's method takes an attribute name, and wraps that in a function to pass to <code>sorted</code>. You can't just write <code>sorted(some_list, key="age")</code>.</span>
<span class="comment-copy">@abarnert Any reasons to want to pass a <code>str</code> rather than <code>lambda e: e.name</code>?</span>
<span class="comment-copy">@RafaelC In general, no, but in specific cases, sure. Think of half the Pandas code out there, which passes around column names as names in various places.</span>
<span class="comment-copy">As an amendment, you can also do <code>from operator import attrgetter</code> and just reference it without the module as <code>sorted(some_list, key=attrgetter('name'))</code></span>
<span class="comment-copy">Nice answer. Mind if I steal some of it? :)</span>
<span class="comment-copy">@PM2Ring No problem :) (I wanted to make Employee subclass of collections.abc.MutableSequence too...)</span>
<span class="comment-copy">@Andrej Kesely Yeah I also have <b>repr</b> in my code. I just stripped it down for stack overflow, so its easier to read. But I like the way you instantiate Employees, by using a list!</span>
<span class="comment-copy">Yeah I also think that class method makes more sense. I currently have the function inside another class, but I think I like you way more, cause is tidier.</span>
<span class="comment-copy">@johnlock1 Thanks. To me, it makes sense for the sort function to belong to the class it's sorting. BTW, I've added a little enhancement to my answer. You may not need it, but it may come in useful.</span>
<span class="comment-copy">So it the last example in multiple attributes case, it sorts by both name AND age? I guess that the second attribute is used to sort objects could have the same sorted position, like 'John' objects.</span>
<span class="comment-copy">@johnlock1 Yes, it first compares by name, and if they match then it compares by age. That's just the standard way that Python compares tuples or lists. And if you think about it, that's what happens when you compare strings, too.</span>
<span class="comment-copy">@johnlock1 But here's a brief illustration of the technique on a simple list of tuples: <code>seq = [('John', 30), ('Paolo', 42), ('Miranda', 20), ('John', 20)]; print(sorted(seq, key=lambda t: (t[0], -t[1])))</code>.</span>
