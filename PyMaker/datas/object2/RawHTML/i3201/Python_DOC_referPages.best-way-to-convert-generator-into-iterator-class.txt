<div class="post-text" itemprop="text">
<p>Consider the following dummy example:</p>
<pre><code>def common_divisors_generator(n, m):

    # Init code
    factors_n = [i for i in range(1, n + 1) if n%i == 0]
    factors_m = [i for i in range(1, m + 1) if m%i == 0]

    # Iterative code
    for fn in factors_n:
        for fm in factors_m:
            if fn == fm:
                yield fn

# The next line is fast because no code is executed yet
cdg = common_divisors_generator(1537745, 373625435)
# Next line is slow because init code is executed on first iteration call
for g in cdg:
    print(g)
</code></pre>
<p>The init code, which takes a long time to compute, is executed once the generator has been iterated for the first time (as opposed to when the generator it is initialized). I would prefer that the init code it is executed as the generator is initialized. </p>
<p>For this purpose I convert the generator into an iterator class as follows:</p>
<pre><code>class CommonDivisorsIterator(object):

    def __init__(self, n, m):
        # Init code
        self.factors_n = [i for i in range(1, n + 1) if n%i == 0]
        self.factors_m = [i for i in range(1, m + 1) if m%i == 0]

    def __iter__(self):
        return self

    def __next__(self):
        # Some Pythonic implementation of the iterative code above
        # ...
        return next_common_divisor
</code></pre>
<p>All ways I can think of implementing the <code>__next__</code> method above are very cumbersome as compared to the simplicity of the iterative code in the generator with the <code>yield</code> keyword.</p>
<p>What would be the most Pythonic way of implementing the <code>__next__</code> method in the iterator class?</p>
<p>Alternatively, how can I modify the the generator so that the init code is executed at init time?</p>
</div>
<div class="post-text" itemprop="text">
<p>In both cases (whether you use a function or a class), the solution is to split the implementation into two functions: a setup function and a generator function.</p>
<p>Using <code>yield</code> in a function turns it into a generator function, which means that it returns a generator when it's called. But even without using <code>yield</code>, nothing's preventing you from creating a generator and returning it, like so:</p>
<pre><code>def common_divisors_generator(n, m):
    factors_n = [i for i in range(1, n + 1) if n%i == 0]
    factors_m = [i for i in range(1, m + 1) if m%i == 0]

    def gen():
        for fn in factors_n:
            for fm in factors_m:
                if fn == fm:
                    yield fn

    return gen()
</code></pre>
<p>And if you're using a class, there's no need to implement a <code>__next__</code> method. You can just use <code>yield</code> in the <code>__iter__</code> method:</p>
<pre><code>class CommonDivisorsIterator(object):
    def __init__(self, n, m):
        self.factors_n = [i for i in range(1, n + 1) if n%i == 0]
        self.factors_m = [i for i in range(1, m + 1) if m%i == 0]

    def __iter__(self):
        for fn in self.factors_n:
            for fm in self.factors_m:
                if fn == fm:
                    yield fn
</code></pre>
</div>
<span class="comment-copy">there is nothing recursive about this code btw..</span>
<span class="comment-copy">If you look into <code>itertools</code>, you could avoid even building the lists. Then it doesn't matter where you initialise it.</span>
<span class="comment-copy">@Ev.Kounis Regarding your first comment, you are right: I have edited the question replacing 'recursive' by 'iterative'. Regarding your second comment, the code isn't escecuted until starting iterating the generator as Aran-Fey points out (I have tested).</span>
<span class="comment-copy">@DanielArteaga Why not create the lists then outside the generator and just pass them to it?</span>
<span class="comment-copy">@jonrsharpe You are right, but this is only a minimal example reflecting an issue I found in a larger piece of code. I know that this particular code is not optimized and that could be improved in many different ways.</span>
<span class="comment-copy">The use of the <code>yield</code> keyword in the <code>__iter__</code> method as if it was a generator I find it very interesting, and exactly addresses my problem. Do you know where is it documented?</span>
<span class="comment-copy">@DanielArteaga The <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">specification</a> for the <code>__iter__</code> method is "It must return an iterator". If you <code>return self</code>, then <code>self</code> must be an iterator (which means it has to have a <code>__next__</code>). But you can return any kind of iterator, and using <code>yield</code> in a function does exactly that - it makes the function return an iterator. (Technically a generator, but generators are also iterators.)</span>
<span class="comment-copy">The second solution strictly speaking does not define an Iterator but a container according to the specification. This means that looping over it with <code>for</code> will work, but an explicit call of <code>next()</code> will not.</span>
<span class="comment-copy">If needed, this can be fixed by using a class decorator that takes an iterable and returns an iterator.</span>
