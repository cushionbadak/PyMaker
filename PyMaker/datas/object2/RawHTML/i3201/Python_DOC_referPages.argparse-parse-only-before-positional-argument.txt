<div class="post-text" itemprop="text">
<p>How can I have argparse only parse commands that come after a positional argument?</p>
<p>Aka if I have the command <code>pythonfile.py -d dir -e test pos_cmd_1 -d</code></p>
<p>How can I have it so that the first <code>-d</code> is parsed by argparse, and anything after the positional command is parsed by that command itself (read <code>pos_cmd_1 -d</code> as a single argument basically)</p>
<p>So that the argument list would be </p>
<ul>
<li>pythonfile.py</li>
<li>-d dir</li>
<li>-e test</li>
<li>pos_cmd_1 -d -s -etc</li>
</ul>
<p>So anything before the positional command would be optional.  And anything after the positional command would be part of the positional command itself.</p>
<p>Edit:  When trying to run the command with double dashes, it tells me that the arguments that come after aren't recognized.</p>
<pre><code>pythonfile.py -d testdir -e test -- command -d -s
</code></pre>
<p>It says <code>-d -s</code> are unrecognized arguments instead of bundling them with the command.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can achieve this just by slightly changing your command line to</p>
<pre><code>pythonfile.py -d dir -e test -- pos_cmd_1 -d
</code></pre>
<p>by adding <code>--</code>, you tell argparse to stop looking for options. So all remaining arguments are set in the positional argument list instead.</p>
<p>An alternative is quoting the rest of arguments:</p>
<pre><code>pythonfile.py -d dir -e test "pos_cmd_1 -d"
</code></pre>
<p>and (because it creates just one positional argument) use argument parser again on the splitted string (not ideal if you want to pass quoted strings in those args)</p>
<p>The advantages of those approaches is that they're natively supported by <code>argparse</code>, <code>getopt</code> and also that is a standard mechanism that won't surprise the users of your command.</p>
<p>if you want to stick to your approach, maybe you could pre-process argument list to insert the double dash by detecting 2 non-option arguments in a row:</p>
<pre><code>args = "-d dir -e test pos_cmd_1 -d".split()
oldarg=""
for i,a in enumerate(args):
    if oldarg and oldarg[0]!='-' and a[0]!='-':
        args.insert(i,'--')
        break
    oldarg = a
</code></pre>
<p><code>args</code> is now: <code>['-d', 'dir', '-e', 'test', '--', 'pos_cmd_1', '-d']</code></p>
</div>
<div class="post-text" itemprop="text">
<p>With the simple parser:</p>
<pre><code>In [2]: p = argparse.ArgumentParser()
In [3]: p.add_argument('-d');
In [4]: p.add_argument('-e');
In [5]: p.parse_args('-d dir -e test pos_cmd_1 -d'.split())
usage: ipython3 [-h] [-d D] [-e E]
ipython3: error: argument -d: expected one argument
</code></pre>
<p>It tries to parse the last '-d' and hits an error.  <code>parse_known_args</code> doesn't help.</p>
<p>With strings other than '-d' and '-e' <code>parse_known_args</code> works:</p>
<pre><code>In [7]: p.parse_known_args('-d dir -e test pos_cmd_1 -s'.split())
Out[7]: (Namespace(d='dir', e='test'), ['pos_cmd_1', '-s'])
</code></pre>
<p>A positional with a <code>REMAINDER</code> nargs appears to work:</p>
<pre><code>In [8]: a1 = p.add_argument('rest', nargs='...') # argparse.REMAINDER
In [9]: p.parse_args('-d dir -e test pos_cmd_1 -s'.split())
Out[9]: Namespace(d='dir', e='test', rest=['pos_cmd_1', '-s'])
In [10]: p.parse_args('-d dir -e test pos_cmd_1 -d'.split())
Out[10]: Namespace(d='dir', e='test', rest=['pos_cmd_1', '-d'])
</code></pre>
<p><code>REMAINDER</code> is supposed to work  much like the '--', capturing input for use by another parser or command.</p>
<p>It can have problems if it's expected to catch the whole commandline, as in:</p>
<pre><code>In [12]: p.parse_args('-s pos_cmd_1 -d'.split())
usage: ipython3 [-h] [-d D] [-e E] ...
ipython3: error: unrecognized arguments: -s
</code></pre>
<p><a href="https://docs.python.org/3/library/argparse.html#nargs" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#nargs</a></p>
</div>
<span class="comment-copy">how about ending the switches with double dash? <code>pythonfile.py -d dir -e test -- pos_cmd_1 -d</code> at least it's clear where options stop</span>
<span class="comment-copy">Could you give some context: why do you think you want to do this?</span>
<span class="comment-copy">@jonrsharpe writing a wrapper for docker-compose that lets me add custom extensibility, and some of the arguments flags overlap with those of the docker command.  So like have <code>-d</code> be parsed as my command if it comes before the compose command (up/start/kill/etc) but if it comes after, it would be part of the docker command.  So <code>python.py -d test up -d</code> where the second <code>-d</code> would be parsed by docker.</span>
<span class="comment-copy">In that case use the <code>--</code>, which often appears for "...then pass <i>these</i> arguments to whatever <i>that</i> calls".</span>
<span class="comment-copy">In my view, the utility should be invoked properly (i.e. according to its documented usage) from a shell. Use quoting or double dash for that prupose. Those are well-known standards that should be obeyed. Example: <code>pythonfile.py -d dir -e test "pos_cmd_1 -d"</code></span>
<span class="comment-copy">Both of those do work, but is there no option that would allow me to do this without the user having to input the -- themselves?  Is my only option to preparse the string to get everything after the positional command?  There's a set amount of things that the positional command could be so would I just have to put it and everything after it into its own string by comparing every item in the arg list to the possible commands?</span>
