<div class="post-text" itemprop="text">
<p>I have a query running in SQL, which is returning the results in to a variable via a loop then punting that in to an HTML file. When I test this by printing to the console in Jupyter Notebook it prints as expected, the next 30 days of the calendar in order of date.</p>
<p>However, when I tell it to join the data using</p>
<pre><code>dates = ''.join(variable)
</code></pre>
<p>it seems to not only reorder the dates so that the 13th of August sits oddly before the 13th of July, but it repeats the date div's 4 times in the page. See below for full code;</p>
<pre><code>from os import getenv
import pyodbc
import os

cnxn = pyodbc.connect('DRIVER={ODBC Driver 13 for SQL Server};SERVER=MYVM\SQLEXPRESS;DATABASE=MyTables;UID=test;PWD=t')

cursor = cnxn.cursor() #makes connection
cursor.execute('DECLARE @today as date SET @today = GetDate() SELECT style112, day, month, year, dayofweek, showroom_name, isbusy from ShowroomCal where Date Between @today and dateadd(month,1,@today) order by style112') #runs statement


while row is not None:
    inset = inset + ['&lt;div class="'+ str(row.isbusy) + '"&gt;&lt;a href="#" id="' + str(row.style112) + '" onclick="parent.updateField(field38, ' + str(row.style112) + ');"&gt;' + str(row.day) + '&lt;/a&gt;&lt;/div&gt;']
    row = cursor.fetchone()



dates = ''.join(inset)    
f = open("C:\\tes.html",'r') # open file with read permissions
filedata = f.read() # read contents
f.close() # closes file
filedata = filedata.replace("{inset}", dates) 

#os.remove("c:\\inetpub\\wwwroot\\cal\\tes.html")



f = open("c:\\inetpub\\wwwroot\\cal\\tes.html",'w') 
f.write(filedata) # update it replacing the previous strings 
f.close() # closes the file

cnxn.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>''.join()</code> does not alter the order in any way. If you get a different order then the <em>database query</em> produced rows in a different order.</p>
<p>I don't think you are telling the database to order your results by date. You order by <code>style112</code>, and the database is free to order values with the same <code>style112</code> column value in any order it pleases. If <code>style112</code> doesn't include date information (as a year, month, day sequence of fixed length) and date order is important, tell the database to use a correct order! Here that'd include <code>year, month, day</code> <em>at the very least</em>.</p>
<p>I'd also refactor the code to avoid quadratic performance behaviour; the <code>inset = inset + [....]</code> expression has to create a new list object each time, copying across all elements from <code>inset</code> and the new list into that. When adding N elements to a list this way, Python has to execute N * N steps. For 1000 elements, that's 1 million steps to execute! Use <code>list.append()</code> to add single elements, which will reduce the workload to roughly N steps.</p>
<p>You can loop directly over a cursor; this is more efficient as it can buffer rows, here's <code>cursor.fetchone()</code> can't assume you'll fetch more data. A <code>for row in cursor:</code> loop is also more readable.</p>
<p>You can also use <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">string formatting</a> rather than string concatenation, it'll help avoid all those <code>str()</code> calls and redundancy, as well as further reduce performance issues; all those string concatenations also create and recreate a lot of intermediate string objects that you don't need to create at all.</p>
<p>So use this:</p>
<pre><code>cnxn = pyodbc.connect(
    'DRIVER={ODBC Driver 13 for SQL Server};SERVER=MYVM\SQLEXPRESS;'
    'DATABASE=MyTables;UID=test;PWD=t')

cursor = cnxn.cursor()
cursor.execute('''
    DECLARE @today as date
    SET @today = GetDate()
    SELECT
        style112, day, month, year, dayofweek, showroom_name, isbusy
    from ShowroomCal
    where Date Between @today and dateadd(month,1,@today)
    order by year, month, day, style112
''')

inset = []
for row in cursor:
    inset.append(
        '&lt;div class="{r.isbusy}"&gt;'
        '&lt;a href="#" id="{r.style112}"'
        ' onclick="parent.updateField(field38, {r.style112});"&gt;'
        '{r.day}&lt;/a&gt;&lt;/div&gt;'.format(r=row))

with open(r"C:\tes.html") as template:
    template = f.read()

html = template.format(inset=''.join(inset))

with open(r"C:\inetpub\wwwroot\cal\tes.html", 'w') as output:
    output.write(html)
</code></pre>
<p>Note: if <em>any of your database data</em> was entered by your users, you <strong>must</strong> ensure that the data is properly escaped for inclusion in HTML <em>first</em>, or you'll leave yourself open to <a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)" rel="nofollow noreferrer">XSS cross-site scripting attacks</a>. Personally, I'd use a HTML templating engine with default escaping support, such as <a href="http://jinja.pocoo.org/" rel="nofollow noreferrer">Jinja</a>.</p>
</div>
<span class="comment-copy">Instead of <code>row is not None</code> just use a loop: <code>for row in cursor:</code> If <code>inset</code> is a list, don't use <code>inset = inset +</code>; rather use <code>inset.extend([...])</code> or <code>inset += [...]</code> to avoid quadratic performance degradation (you are currently executing a O(N**2) algorithm by replacing the <code>inset</code> list with a new list concatenated with the previous one, which requires a loop over all elements each time).</span>
<span class="comment-copy">the <code>''.join()</code> is not special; your rows are not ordered by day, the database is free to return those in any order it pleases. Set your <code>ORDER BY</code> to sort by date.</span>
<span class="comment-copy">another side note: rather than <code>f = open(...)</code> (read from or write to <code>f</code>) then <code>f.close()</code>, use the file as a context manager. <code>with open(...) as f:</code> then in the indented block read from or write to <code>f</code>. The file is closed automatically, even if there is an exception.</span>
<span class="comment-copy">Last but not least, creating a cursor doesn't create a connection to the database. The <code>pyodbc.connect()</code> call made the connection.</span>
<span class="comment-copy">style112 is a formatted version of the date which represents as 20180713 but I'll take the rest of your answer and run with it as it seems like a more elegant and potentially ideal solution (plus, what harm can be done from ordering by the date even more)?</span>
<span class="comment-copy">@C-Sway: right, that wasn't clear from the context. :-) Yes, <code>style112</code> is a YYYYMMDD-format string then ordering on that <i>should</i> have been enough.</span>
<span class="comment-copy">This worked fantastically. In the end the order was working well with just the Style112 column as predicted, so I presume there must have been something about the way the do while loop was working that was lumping the dates in the wrong order.</span>
