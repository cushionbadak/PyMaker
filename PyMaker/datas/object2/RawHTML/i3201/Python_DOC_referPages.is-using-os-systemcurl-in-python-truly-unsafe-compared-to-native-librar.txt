<div class="post-text" itemprop="text">
<p>I'm writing a project with Angular on the frontend, and a backend written in Python.</p>
<p>For certain API calls, instead of using Python's built-in libraries (and since I am more of a C/C++/bash programmer) and did not know how to do a similar normal system call in python,  I just did a <code>os.system('curl ...')</code>.</p>
<p>When people were reviewing my code they said that it would be better practice to use Python's built in libraries instead of doing a <code>system()</code> call since it looks better and could be less dangerous.</p>
<p><strong>Is this a legitimate criticism? How could it be more dangerous if the python library is probably doing the same thing anyway?</strong></p>
<p>I am not asking for opinions on style but legitimate problems with this method. </p>
</div>
<div class="post-text" itemprop="text">
<h3>The objection is entirely legitimate.</h3>
<p>Let's say that your command looks like:</p>
<pre><code>def post_result(result_string):
  os.system('curl http://example.com/report-result/%s' % (result_string,))
</code></pre>
<p>Now, what happens if you're told to report a result that contains <code>; rm -rf ~</code>? The shell invoked by <code>os.system()</code> runs <code>curl http://example.com/report-result/</code>, and then it runs a second command of <code>rm -rf ~</code>.</p>
<h3>Several naive attempts at fixes don't work.</h3>
<p>Consider, for example:</p>
<pre><code># Adding double quotes should work, right?
# WRONG: ''; rm -rf ~'' doesn't work here, but $(rm -rf ~) still does.
os.system('curl http://example.com/report-result/"%s"' % (result_string,))

# ...so, how about single quotes?
# STILL WRONG: $(rm -rf ~) doesn't work on its own, but result_string="'$(rm -rf ~)'" does.
os.system("curl http://example.com/report-result/'%s'" % (result_string,))
</code></pre>
<h3>Even if you avoid direct shell injection vulnerabilities, using a shell exposes you to other kinds of bugs.</h3>
<p>At startup time, a shell does a number of operations based on filesystem contents and environment variables. If an untrusted user can manipulate your program into setting environment variables of their choice before calling <code>os.system()</code>, they can cause a file named in <code>ENV</code> to have its commands executed; can shadow commands with exported functions, or can cause other mischief. See <a href="https://en.wikipedia.org/wiki/Shellshock_(software_bug)" rel="nofollow noreferrer">ShellShock</a> for a well-publicized historical example.</p>
<p>And that's before considering other things that can happen to your data. If you're passing a filename to a shell, but unknown to you it contains whitespace and glob characters, that filename can be split into / replaced with other names.</p>
<hr/>
<h3>The official Python documentation warns against shell use.</h3>
<p>Quoting a warning from <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">the Python <code>subprocess</code> module documentation</a>, which is also relevant here:</p>
<blockquote>
<p><strong>Warning:</strong> Executing shell commands that incorporate unsanitized input from an untrusted source makes a program vulnerable to shell injection, a serious security flaw which can result in arbitrary command execution. For this reason, the use of <code>shell=True</code> is <strong>strongly discouraged</strong> in cases where the command string is constructed from external input:</p>
<pre><code>&gt;&gt;&gt; from subprocess import call
&gt;&gt;&gt; filename = input("What file would you like to display?\n")
What file would you like to display?
non_existent; rm -rf / #
&gt;&gt;&gt; call("cat " + filename, shell=True) # Uh-oh. This will end badly...
</code></pre>
<p><code>shell=False</code> disables all shell based features, but does not suffer from this vulnerability; see the Note in the <code>Popen</code> constructor documentation for helpful hints in getting <code>shell=False</code> to work.</p>
<p>When using <code>shell=True</code>, <code>pipes.quote()</code> can be used to properly escape whitespace and shell metacharacters in strings that are going to be used to construct shell commands.</p>
</blockquote>
<p><code>os.system()</code> has all the same faults as <code>subprocess.Popen(..., shell=True)</code> -- even <em>more</em> faults, since <code>subprocess.Popen()</code> provides a way to pass data out-of-band from code, and so <em>can</em> be used safely.</p>
<hr/>
<h3>Native Python libraries don't call shells for work that the Python runtime can do.</h3>
<p>Python has a <a href="https://docs.python.org/2/library/socket.html" rel="nofollow noreferrer"><code>socket</code> library</a> in its standard library interface, which directly invokes operating system and libc calls to create network connections and interact with them. There is no shell involved in these syscalls; arguments are C structs, C strings, etc; so they aren't prone to shell injection vulnerabilities in the same way that <code>os.system()</code> is.</p>
<p>Some Python libraries, like <code>libcurl</code>, may be slightly less native insofar as they use their own C libraries rather than only calling out to the operating system through functions included in the Python runtime itself; even then, though, these OS-level syscalls are at a much lower level than any shell.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/51329156/1833711">This answer</a> is entirely correct.
But I'd also like to point out to other cases in which you <em>might think</em> that security doesn't matter. E.g. the command you are running is hard-coded or you have 100% control or trust over what is supplied to it.
Even it that case using <code>os.system()</code> is <em>wrong</em>.
In fact:</p>
<ul>
<li>You have to rely on external tools that might not be present or, even worse, you might have <em>a</em> command with that name, but it doesn't do what you expect it to do. Maybe because it has a different version or maybe because it's a different implementation of that command (e.g. GNUtar != BSDtar). Manging python dependencies will be much more easy and reliable.</li>
<li>It is more difficult to handle errors. You only have a return code which is not always enough to understand what is going on. And I hope that your solution to this problem isn't to parse the command output.</li>
<li>Environment variables can modify the way a program works unexpectedly. Many programs use environment variables as an alternative to command line or configuration options. If your python script relies on specific behavior from the command, an unexpected variable in the user's environment can break it.</li>
<li>If at some point in the future you will need to let the user customize a bit your script behavior you will need to rewrite it from scratch without <code>os.system()</code> or you might have security problems.</li>
</ul>
</div>
<span class="comment-copy">One random advice if you decide to go calling like that, use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">Popen</a>, and use <a href="https://docs.python.org/3.6/library/shlex.html" rel="nofollow noreferrer">shlex</a> to quote out stuff and make it safer.</span>
<span class="comment-copy">@DusanGligoric, ...it's only <code>shlex.quote()</code> in Python 3.x; it's <code>pipes.quote()</code> in 2.x. But if you're using <code>Popen()</code> without <code>shell=True</code>, you don't need to do any quoting at all, and can just pass an explicit argument list.</span>
<span class="comment-copy">@DusanGligoric, ...by contrast, if you're suggesting <code>shlex.parse()</code>, please don't. It's <i>less</i> vulnerable than parsing a string to an argument list with <code>shell=True</code>, but still vulnerable to undesired division between argv elements being injected from data.</span>
<span class="comment-copy">@CharlesDuffy Proper reply! In that case one more random advice, please use Py3. I meant shlex.quote(), pasted whole lib tho, neat catch.</span>
<span class="comment-copy">@Vladimir_314159, ...in terms of "the Python library is probably doing the same thing anyway" -- no, it's not. If it's <code>libcurl</code>-based it's invoking a C function call with literal strings passed through; otherwise, it's using native Python socket functionality. In neither case is content passed as part of the URL to connect to parsed in such a way as to enable injection attacks.</span>
<span class="comment-copy">That is the case when strings are passed, if you were to hard code it would be safer, still invoking a shell is not something you would called optimization so yes, built in all the way.</span>
