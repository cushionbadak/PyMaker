<div class="post-text" itemprop="text">
<p>I searched some sources online but they are not exactly what I am looking for.</p>
<p>So for a set of images. I want to generate a color histogram that is in the form of  {color1: p1, color2: p2,..... color100: p100} where colorxxx represent a color from RGB images. and p represent the prob of that color.</p>
<p>Is there a easy way to do such things in python?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Method 1</strong>:</p>
<pre><code>{k:np.sum(a==k) for k in set(a.ravel().tolist())}
</code></pre>
<p>or a little more readably</p>
<pre><code>count = lambda A, key : np.sum(A==key)
unique_keys = set(A.ravel().tolist())
return {key : count(A,key) for key in unique_keys}
</code></pre>
<hr/>
<p>Walking through it:</p>
<pre><code>{...}
</code></pre>
<p><a href="https://stackoverflow.com/questions/1747817/create-a-dictionary-with-list-comprehension-in-python">dictionary comprehension</a> to generate the mapping</p>
<pre><code>set(a.ravel().tolist())
</code></pre>
<p><code>a.ravel</code> <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" rel="nofollow noreferrer">flattens the image</a>; to list allows it to be cast to a <a href="https://docs.python.org/2/library/sets.html" rel="nofollow noreferrer">set</a>, which is a container for the unique elements.</p>
<pre><code>np.sum(a==k)
</code></pre>
<p>Count how many times the element is in the image. This <a href="https://docs.scipy.org/doc/numpy/reference/routines.sort.html" rel="nofollow noreferrer">is not the most efficient way to do this</a>, but puts the histogram into the format you requested</p>
<hr/>
<p>Taken together, if your image is the 3x3</p>
<pre><code>a = np.array([[1,2,3],[1,3,3],[3,3,3]])
</code></pre>
<p>then </p>
<pre><code>set(a.ravel().tolist()) # yields set([1, 2, 3])
</code></pre>
<p>and the entire expression yields</p>
<pre><code>{1: 2, 2: 1, 3: 6}
</code></pre>
<hr/>
<p><strong>Method 2</strong></p>
<pre><code>from PIL.Image import fromarray
b = fromarray(a.astype(np.uint8)) # convert to a PIL image
hist =  {idx:count for idx, count in enumerate(b.histogram()) if count}
</code></pre>
<p>This works very similarly (using a dictionary comprehension), but makes use of the PIL <a href="http://pillow.readthedocs.io/en/4.1.x/reference/Image.html#PIL.Image.Image.histogram" rel="nofollow noreferrer">histogram</a> functionality, and <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> to fetch the indices. It may have some domain limitations.</p>
<p><strong>"Binning"</strong></p>
<p>If you want to have "bins" of colors, as you indicated, then the remaining work is just defining your bin structure, which an be done many number of ways. For example, in the previous example, we can create fixed size integer bins by</p>
<pre><code>num_bins = 2
b = fromarray(a.astype(np.uint8)//num_bins) # convert to a PIL image, binned
hist =  {idx*num_bins:count for idx, count in enumerate(b.histogram()) if count}
</code></pre>
</div>
<span class="comment-copy">Did you not find PIL's function <a href="http://effbot.org/imagingbook/image.htm" rel="nofollow noreferrer"><code>histogram</code></a>, or did you but you decided it does not fit your purpose because it does not work for a <i>set</i> of images?</span>
<span class="comment-copy">It returns a list with length 256*3. But It only counted frequency for each channel and concat them together. It is different from what I needed as what I needed is actually  clustering the colors into a set of color and count the frequency of the cluster. In one dimension, the just need to set the bin for the interval and count frequency of each bin, but what about for images with 3 channels?</span>
<span class="comment-copy">@jack if you could enhance your question by specifying <i>which</i> online sources you searched and <i>exactly why</i> they're not what you're looking for, I think usr256 and others (myself included) would have an easier time answering your question</span>
<span class="comment-copy">You could access the individual RGB pixels of the image with <code>PIL</code> and use a <code>collections.Counter</code> intance to count how many of each color are present by just sending them to as a <code>tuple</code> composed the three color channel values. This will work because these tuples would be valid dictionary keys like (255, 0, 128)<code>â€”this is important because </code>Counter` is a <code>dict</code> subclass which requires keys to be hashable (in other words it can only count hashable things). After sending all the pixels, the <code>Counter</code> instance <i>is</i> effectively a histogram of the image.</span>
<span class="comment-copy">Sorry for replying so late. Thanks for answer. But here you only generated a dictionary with index from 0 - 784, which is not what I wanted. Because this is only the flattened count for each channels' intensity count. What I want is to group the color space into a smaller subspace, from 256 x 256 x 256  to say 100 color categories. And get a distribution for colors fall into those 100 categories(we may define the color category by a cube in the color space, say with width, height, length 10 by 10 by 10 ). I guess in that sense, it could not be called a color histogram in the usual sense then.</span>
<span class="comment-copy">@jack that's fine, does the edit address your question?</span>
<span class="comment-copy">sorry but I am afraid not..... When you divided by num_bins, I think you only divided each value of the array. That does not make a bin I think...</span>
<span class="comment-copy">@jack hmm I think it does :) Did you try it on the example? If your input array was [1,2,3,4,5] and you divide by 2 using integer division, you get [0,1,1,2,2]; they are now binned by size 2. The algorithm correctly interprets that there is 1 element in bin [0,2), two elements between [2,4), and two elements between [4,6). As I said there are many <i>possible</i> ways to do binning, but this is a very common one</span>
<span class="comment-copy">I see. But I am afraid that it still only treat intensity values from different channels independently, didn't it? So if I want to generate random color based on the histogram you gave, I would only be able to sample from each channel independently and concate them together?</span>
