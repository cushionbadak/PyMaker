<div class="post-text" itemprop="text">
<p><a href="https://www.codewars.com/kata/best-travel/train/python" rel="nofollow noreferrer">https://www.codewars.com/kata/best-travel/train/python</a></p>
<p>my code times out, what could i have done better?</p>
<pre><code>def choose_best_sum(t, k, ls):
import itertools
values=list(itertools.combinations(ls,k))
distances=[]
for row in values:
    dis=0
    for i in range(k):
        dis+=row[i]
    distances.append(dis)
while len(distances)!=0 and max(distances)&gt;t:
    #print("max:",max(distances),"min:",min(distances))
    distances.pop(distances.index(max(distances)))
if len(distances)==0:
    result="None"
else:
    result=max(distances)
return result

xs = [100, 76, 56, 44, 89, 73, 68, 56, 64, 123, 2333, 144, 50, 132, 123, 34, 89]
choose_best_sum(230, 4, xs)#, 230)
choose_best_sum(430, 5, xs)#, 430)
choose_best_sum(430, 8, xs)#, None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar to the answer by @Aaron but without sorting the list. Just keep track of the running best.</p>
<pre><code>import itertools

def choose_best_sum(t, k, ls):
    best_sum = 0
    best_set = None
    combinations = itertools.combinations(ls, k)
    for combination in combinations:
        combi_sum = sum(combination)
        if combi_sum &lt;= t and combi_sum &gt; best_sum:
             best_set = combination
             best_sum = combi_sum
    return (best_set, best_sum)

xs = [100, 76, 56, 44, 89, 73, 68, 56, 64, 123, 2333, 144, 50, 132, 123, 34, 89]
xs = [item for item in xs if item &lt; 430]
choose_best_sum(230, 4, xs)#, 230)
choose_best_sum(430, 5, xs)#, 430)
choose_best_sum(430, 8, xs)#, None)
</code></pre>
<p>The first thing you can do is just ditch 2333 from <code>xs</code> because that can never be in a combination. I'm not sure why, in addition to creating your own <code>sum</code>, you have <code>while len(distances)!=0 and max(distances)&gt;t:</code> and so much list manipulation (appending and popping). The <code>%timeit</code> result:</p>
<pre><code>%timeit choose_best_sum(430, 8, xs)
5.43 ms ± 72.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Writing your own <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a> is probably slowing you down a lot. using the built in function is almost always going to be faster: </p>
<pre><code>def choose_best_sum(t, k, ls):
    import itertools
    values=list(itertools.combinations(ls,k))
    distances= [sum(row) for row in values]
    #...
</code></pre>
<p>When you go to find the largest value smaller than <code>t</code>, you modify the list a bunch before coming up with your result. Python lists are not terribly efficient at getting longer or shorter, so it would be much better to just sort the list and either just iterate until you find the edge of what is greater than <code>t</code> or you could use a <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="nofollow noreferrer">binary search</a>.</p>
<pre><code>    #...
    for distance in reversed(sorted(distances)):
        if distance &lt;= t:
            return distance
</code></pre>
</div>
<span class="comment-copy">you can't rule out the test case; and the response should've been none so i made a little change;  result= None  if best_sum!=0:             result=best_sum       return (result)</span>
<span class="comment-copy">I'm not going to sign up to see my final score, but this worked for me on the sample tests.</span>
