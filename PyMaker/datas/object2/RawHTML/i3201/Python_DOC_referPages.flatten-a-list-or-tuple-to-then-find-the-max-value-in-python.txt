<div class="post-text" itemprop="text">
<p>I'm trying to find the max value of a list or tuple that contains other lists or tuples. My first thought is to flatten it out and then use the max() function to find the maximum from the overall list, but I'm having difficulty doing that.
Any suggestions?</p>
<p>An example is you have the tuple: (1, 2, 3, (1, 2)) and the expected output would be 3</p>
<p>Another example is the list [1, (2, 3), [4, 5]] and the output should be 5</p>
<p>This is take two using a flatten function and recalling it:</p>
<pre><code>def flatten(t):
output = []
for item in t:
    if type(item) != type([]) or type(()):
        output.append(item)
    else:
        output.extend(flatten(item))
return output

def max_val(t):
    flatten(t)
    return max(output)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can define a generic function to flatten your inputs using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>chain.from_iterable</code></a> and <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow noreferrer"><code>collections.Iterable</code></a>:</p>
<pre><code>from itertools import chain
from collections import Iterable

x = (1, 2, 3, (1, 2))
y = [1, (2, 3), [4, 5]]

def flatten(x):
    return chain.from_iterable([i] if not isinstance(i, Iterable) else i for i in x)

res = max(flatten(x)) # 3

res = max(flatten(y)) # 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the package more_itertools to flatten what you have.</p>
<pre><code>import more_itertools
lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
res = list(more_itertools.flatten(lst))
</code></pre>
<p>Then you just need to use the max() function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make custom function to flatten your iterable and the use standard <code>max</code> or <code>min</code> functions:</p>
<pre><code>from collections.abc import Iterable

x = (1, 2, 3, (1, 2))

def my_flatten(iterable):
    for value in iterable:
        if isinstance(value, Iterable):
            yield from my_flatten(value)
        else:
            yield value

print('min = ', min(my_flatten(x)))
print('max = ', max(my_flatten(x)))
</code></pre>
<p>Outputs:</p>
<pre><code>min =  1
max =  3
</code></pre>
</div>
<span class="comment-copy">That sounds a perfectly reasonable approach. What difficulties are you having particularly? Have you got some semi-working code someone could help you correct?</span>
<span class="comment-copy">def a flatten function and recursively call it.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python">Making a flat list out of list of lists in Python</a></span>
<span class="comment-copy">does this work for tuples as well? It says a tuple is not a callable item with that function</span>
<span class="comment-copy">btw <code>isinstance('', Iterable)</code> is <code>True</code>, i'm not sure if this is related to OP, but it's good to keep in mind</span>
