<div class="post-text" itemprop="text">
<p>Why is <code>sys.getsizeof()</code> larger for a Python <code>str</code> of length 1 than for a string of length 2?  (For length &gt; 2, the relationship seems to increase monotonically as expected.)</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; from string import ascii_lowercase
&gt;&gt;&gt; import sys

&gt;&gt;&gt; strings = [ascii_lowercase[:i] for i, _ in enumerate(ascii_lowercase, 1)]
&gt;&gt;&gt; strings
['a',
 'ab',
 'abc',
 'abcd',
 'abcde',
 'abcdef',
 'abcdefg',
 # ...

&gt;&gt;&gt; sizes = dict(enumerate(map(sys.getsizeof, strings), 1))
&gt;&gt;&gt; sizes
{1: 58,   # &lt;--- ??
 2: 51,
 3: 52,
 4: 53,
 5: 54,
 6: 55,
 7: 56,
 8: 57,
 9: 58,
 10: 59,
 11: 60,
 12: 61,
 13: 62,
 14: 63,
 15: 64,
 16: 65,
 # ...
</code></pre>
<p>It seems it has to do with <code>str.__sizeof__</code>, but I don't know C well enough at all to dig into what's going on in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you <code>import pandas</code>, it does a whole ton of NumPy stuff, including calling <a href="https://github.com/numpy/numpy/blob/master/numpy/core/src/multiarray/arraytypes.c.src#L468" rel="nofollow noreferrer"><code>UNICODE_setitem</code></a> on all the single-ASCII-letter strings, and presumably somewhere else doing something similar on the single-ASCII-digit strings.</p>
<p>That NumPy function calls the deprecated C API <a href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsUnicode" rel="nofollow noreferrer"><code>PyUnicode_AsUnicode</code></a>.</p>
<p>When you call that in CPython 3.3+, that caches the <code>wchar_t *</code> representation on the string's internal struct, in its <code>wstr</code> member, as the two wchar_t values <code>w'a'</code> and <code>'\0'</code>, which takes 8 bytes on a 32-bit-<code>wchar_t</code> build of Python. And <code>str.__size__</code> takes that into account.</p>
<p>So, all of the single-character interned strings for ASCII letters and digits‚Äîbut nothing else‚Äîend up 8 bytes larger.</p>
<hr/>
<p>First, we know that it's apparently something that happens on <code>import pandas</code> (per <a href="https://stackoverflow.com/a/51370877/908494">Brad Solomon's answer</a>.) It may happen on <code>np.set_printoptions(precision=4, threshold=625, edgeitems=10)</code> (miradulo posted, but then deleted, a comment to that effect on <a href="https://stackoverflow.com/a/51370746/908494">ShadowRanger's answer</a>), but definitely not on <code>import numpy</code>.</p>
<p>Second, we know that it happens to <code>'a'</code>, but what about other single-character strings?</p>
<p>To verify the former, and to test the latter, I ran this code:</p>
<pre><code>import sys

strings = [chr(i) for i in (0, 10, 17, 32, 34, 47, 48, 57, 58, 64, 65, 90, 91, 96, 97, 102, 103, 122, 123, 130, 0x0222, 0x12345)]

sizes = {c: sys.getsizeof(c) for c in strings}
print(sizes)

import numpy as np
sizes = {c: sys.getsizeof(c) for c in strings}
print(sizes)

np.set_printoptions(precision=4, threshold=625, edgeitems=10)
sizes = {c: sys.getsizeof(c) for c in strings}
print(sizes)

import pandas
sizes = {c: sys.getsizeof(c) for c in strings}
print(sizes)
</code></pre>
<p>On multiple CPython installations (but all 64-bit CPython 3.4 or later on Linux or macOS), I got the same results:</p>
<pre><code>{'\x00': 50, '\n': 50, '\x11': 50, ' ': 50, '"': 50, '/': 50, '0': 50, '9': 50, ':': 50, '@': 50, 'A': 50, 'Z': 50, '[': 50, '`': 50, 'a': 50, 'f': 50, 'g': 50, 'z': 50, '{': 50, '\x82': 74, '»¢': 76, 'íçÖ': 80}
{'\x00': 50, '\n': 50, '\x11': 50, ' ': 50, '"': 50, '/': 50, '0': 50, '9': 50, ':': 50, '@': 50, 'A': 50, 'Z': 50, '[': 50, '`': 50, 'a': 50, 'f': 50, 'g': 50, 'z': 50, '{': 50, '\x82': 74, '»¢': 76, 'íçÖ': 80}
{'\x00': 50, '\n': 50, '\x11': 50, ' ': 50, '"': 50, '/': 50, '0': 50, '9': 50, ':': 50, '@': 50, 'A': 50, 'Z': 50, '[': 50, '`': 50, 'a': 50, 'f': 50, 'g': 50, 'z': 50, '{': 50, '\x82': 74, '»¢': 76, 'íçÖ': 80}
{'\x00': 50, '\n': 50, '\x11': 50, ' ': 50, '"': 50, '/': 50, '0': 58, '9': 58, ':': 50, '@': 50, 'A': 58, 'Z': 58, '[': 50, '`': 50, 'a': 58, 'f': 58, 'g': 58, 'z': 58, '{': 50, '\x82': 74, '»¢': 76, 'íçÖ': 80}
</code></pre>
<p>So, <code>import numpy</code> changes nothing, and so does <code>set_printoptions</code> (presumably why miradulo deleted the comment‚Ä¶), but <code>import pandas</code> does.</p>
<p>And it apparently affects ASCII digits and letters, but nothing else.</p>
<p>Also, if you change all of the <code>print</code>s to <code>print(sizes.values())</code>, so the strings never get encoded for output, you get the same results, which implies that either it's not about caching the UTF-8, or it is but that's always happening even if we don't force it.</p>
<hr/>
<p>The obvious possibility is that whatever Pandas is calling is using one of the <a href="https://docs.python.org/3/c-api/unicode.html#deprecated-py-unicode-apis" rel="nofollow noreferrer">legacy <code>PyUnicode</code> API</a> to generate single-character strings for all of the ASCII digits and letters. So these strings end up not in compact-ASCII format, but in legacy-ready format, right? (For details on what that means, see <a href="https://github.com/python/cpython/blob/master/Include/unicodeobject.h#L193" rel="nofollow noreferrer">the comments in the source</a>.)</p>
<p>Nope. Using the code from my <a href="https://github.com/abarnert/superhackyinternals" rel="nofollow noreferrer"><code>superhackyinternals</code></a>, we can see that it's still in compact-ascii format:</p>
<pre><code>import ctypes
import sys
from internals import PyUnicodeObject

s = 'a'
print(sys.getsizeof(s))
ps = PyUnicodeObject.from_address(s)
print(ps, ps.kind, ps.length, ps.interned, ps.ascii, ps.compact, ps.ready)
addr = id(s) + PyUnicodeObject.utf8_length.offset
buf = (ctypes.c_char * 2).from_address(addr)
print(addr, bytes(buf))

import pandas
print(sys.getsizeof(s))
s = 'a'
ps = PyUnicodeObject.from_address(s)
print(ps, ps.kind, ps.length, ps.interned, ps.ascii, ps.compact, ps.ready)
addr = id(s) + PyUnicodeObject.utf8_length.offset
buf = (ctypes.c_char * 2).from_address(addr)
print(addr, bytes(buf))
</code></pre>
<p>We can see that Pandas changes the size from 50 to 58, but the fields are still:</p>
<pre><code>&lt;__main__.PyUnicodeObject object at 0x101bbae18&gt; 1 1 1 1 1 1
</code></pre>
<p>‚Ä¶ in other words, it's <code>1BYTE_KIND</code>, length 1, mortal-interned, ASCII, compact, and ready.</p>
<p>But, if you look at <code>ps.wstr</code>, before Pandas it's a null pointer, while after Pandas it's a pointer to the <code>wchar_t</code> string <code>w"a\0"</code>. And <code>str.__sizeof__</code> takes that <code>wstr</code> size into account.</p>
<hr/>
<p>So, the question is, how do you end up with an ascii-compact string that has a <code>wstr</code> value?</p>
<p>Simple: you call <a href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsUnicode" rel="nofollow noreferrer"><code>PyUnicode_AsUnicode</code></a> on it (or one of the other deprecated functions or macros that accesses the 3.2-style native <code>wchar_t *</code> internal storage. That native internal storage doesn't actually exist in 3.3+. So, for backward compatibility, those calls are handled by creating that storage on the fly, sticking it on the <code>wstr</code> member, and calling the appropriate <code>PyUnicode_AsUCS[24]</code> function to decode to that storage. (Unless you're dealing with a compact string whose kind happens to match the <code>wchar_t</code> width, in which case <code>wstr</code> is just a pointer to the native storage after all.)</p>
<p>You'd expect <code>str.__sizeof__</code> to ideally include that extra storage, and <a href="https://github.com/python/cpython/blob/master/Objects/unicodeobject.c#L13759" rel="nofollow noreferrer">from the source</a>, you can see that it does.</p>
<p>Let's verify that:</p>
<pre><code>import ctypes
import sys
s = 'a'
print(sys.getsizeof(s))
ctypes.pythonapi.PyUnicode_AsUnicode.argtypes = [ctypes.py_object]
ctypes.pythonapi.PyUnicode_AsUnicode.restype = ctypes.c_wchar_p
print(ctypes.pythonapi.PyUnicode_AsUnicode(s))
print(sys.getsizeof(s))
</code></pre>
<p>Tada, our 50 goes to 58.</p>
<hr/>
<p>So, how do you work out where this gets called?</p>
<p>There are actually a ton of calls to <code>PyUnicode_AsUnicode</code>, and the <code>PyUnicode_AS_UNICODE</code> macro, and other functions that call them, throughout Pandas and Numpy. So I ran Python in lldb and attached a breakpoint to <code>PyUnicode_AsUnicode</code>, with a script that skips if the calling stack frame is the same as last time.</p>
<p>The first few calls involve datetime formats. Then there's one with a single letter. And the stack frame is:</p>
<pre><code>multiarray.cpython-36m-darwin.so`UNICODE_setitem + 296
</code></pre>
<p>‚Ä¶ and above <code>multiarray</code> it's pure Python all the way up to the <code>import pandas</code>. So, if you want to know exactly where Pandas is calling this function, you'd need to debug in <code>pdb</code>, which I haven't done yet. But I think we've got enough info now.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://www.python.org/dev/peps/pep-0393/" rel="nofollow noreferrer">Python 3.3+'s <code>str</code> is quite a complicated structure</a>, and can end up storing the underlying data in up to three different ways, depending on which APIs have been used with the string and the code points represented by the string. The most common alternate representation case is a cached UTF-8 representation, but that only applies to non-ASCII strings so it doesn't apply here.</p>
<p>In this case, I suspect the single character string (which, as an implementation detail, is a singleton) was used in a way that triggered the creation of the legacy <code>wchar_t*</code> representation (extensions using <a href="https://docs.python.org/3/c-api/unicode.html#deprecated-py-unicode-apis" rel="nofollow noreferrer">the legacy <code>Py_UNICODE</code> APIs</a> can cause this), and your Python build uses a four byte <code>wchar_t</code>, leading to the string being eight bytes bigger than it otherwise would be (four for the <code>a</code> itself, four more for the <code>NUL</code> terminator). The fact that it's a singleton means that even though you may never have triggered such a legacy API call, any extension which retrieved a reference to the singleton would affect the observed size for <em>everyone</em> by using it with the legacy API.</p>
<p>Personally, I don't reproduce at all on my Linux 3.6.5 install (the sizes increase smoothly), indicating no <code>wchar_t</code> representation was created, and on my Windows 3.6.3 install, <code>'a'</code> is only 54 bytes, not 58 (which matched Windows' native two byte <code>wchar_t</code>). In both cases I'm running with <code>ipython</code>; it's possible different <code>ipython</code> dependencies with different versions are responsible for your (and my) inconsistent observations.</p>
<p>To be clear, this extra cost is fairly immaterial; since the single character string is a singleton, the incremental cost of use is really just 4-8 bytes (depending on pointer width). You're not going to break the bank on memory if a handful of strings ended up used with the legacy APIs.</p>
</div>
<div class="post-text" itemprop="text">
<p>This appears to be related to a single Pandas import in an IPython startup file.</p>
<p>I can reproduce the behavior in a plain Python session also:</p>
<pre><code> ~$ python
Python 3.6.6 |Anaconda, Inc.| (default, Jun 28 2018, 11:07:29) 
[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from string import ascii_lowercase
&gt;&gt;&gt; import sys
&gt;&gt;&gt; strings = [ascii_lowercase[:i] for i, _ in enumerate(ascii_lowercase, 1)]
&gt;&gt;&gt; sizes = dict(enumerate(map(sys.getsizeof, strings), 1))
&gt;&gt;&gt; sizes
{1: 50, 2: 51, 3: 52, 4: 53, 5: 54, 6: 55, 7: 56, 8: 57, 9: 58, 10: 59, 11: 60, 12: 61, 13: 62, 14: 63, 15: 64, 16: 65, 17: 66, 18: 67, 19: 68, 20: 69, 21: 70, 22: 71, 23: 72, 24: 73, 25: 74, 26: 75}
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; sizes = dict(enumerate(map(sys.getsizeof, strings), 1))
&gt;&gt;&gt; sizes
{1: 58, 2: 51, 3: 52, 4: 53, 5: 54, 6: 55, 7: 56, 8: 57, 9: 58, 10: 59, 11: 60, 12: 61, 13: 62, 14: 63, 15: 64, 16: 65, 17: 66, 18: 67, 19: 68, 20: 69, 21: 70, 22: 71, 23: 72, 24: 73, 25: 74, 26: 75}
&gt;&gt;&gt; pd.__version__
'0.23.2'
</code></pre>
</div>
<span class="comment-copy">What version of Python 3.x are you on? (And platform, 32- or 64-bit, python.org installer or some other thing, etc.) Because I get <code>50</code> for the first string on every 64-bit CPython 3.4, 3.6, or 3.7 that I have access to.</span>
<span class="comment-copy">I'm also getting 50.</span>
<span class="comment-copy">Seconding abarnert,  no repro on 3.6.6 or 3.7.</span>
<span class="comment-copy"><a href="https://repl.it/repls/OpaqueFittingParallelprocessing" rel="nofollow noreferrer">Same on repl.it</a> (although that's not surprising, as I suspect they're running the same 3.6.1 distro package as one of my two linux containers‚Ä¶).</span>
<span class="comment-copy">Interesting -- I'm on 3.6.6, Anaconda distro, 64bit.  Let me double-check question code.</span>
<span class="comment-copy">Right on about my comment, apologies for everyone's confusion - confounding variables :)</span>
<span class="comment-copy">The most common case is not the cached UTF-8 representation, it‚Äôs a 1-, 2-, or 4-byte fixed width string, which may or may not also have a cached UTF-8 rep (which can be the same as the fixed width only if that‚Äôs 1-byte).</span>
<span class="comment-copy">@abarnert: I phrased it poorly; I meant the most common <i>alternate</i> representation (I've edited it to fix that statement). And it's not the same as the fixed width if the fixed width is 1 byte and latin-1, only if it's 1 byte and ASCII.</span>
<span class="comment-copy">I have a <code>startup.py</code> file that is executed at launch.  When I comment that out, this inconsistency goes away.  The only funky thing it does is temporarily redirect <code>sys.stdout</code> to <code>os.devnull</code>.  But I have no clue whether that is the cause.  Suffice it to say your answer is helpful regardless.</span>
<span class="comment-copy">@BradSolomon: Does it use <i>any</i> non-builtin APIs? Granted, my reproducing setup only does some tweaking with <code>prompt_toolkit</code> (an <code>ipython</code> dependency which I'd assume wouldn't change anything). I'm content to just call it a mystery of non-default setups.</span>
<span class="comment-copy">@miradulo Not surprising; that function does all kinds of stuff, and does it in C code originally written for early 2.x Python, and code that probably hasn‚Äôt been a priority to update (since you obviously never use it in an inner loop or anything), so‚Ä¶</span>
<span class="comment-copy">Amusing. That's not the reason it happens for me (I don't have <code>pandas</code> installed at all). I suspect the answer is going to differ for everyone who has a repro. Yay!</span>
<span class="comment-copy">@ShadowRanger I wouldn‚Äôt be too surprised if Pandas called <code>set_printoptions</code>, or if it unconditionally calls some numpy C API that numpy only calls conditionally but <code>set_printoptions</code> forces it to do so, or‚Ä¶</span>
<span class="comment-copy">By the way, this reproduces on repl.it (but I can‚Äôt get it to give me the updated share link from the mobile interface, so you‚Äôll have to trust me, or go to the link from my comment on the question and add the <code>import pandas</code> yourself.)</span>
