<div class="post-text" itemprop="text">
<p>Doing my best at understanding how python works. I come from a somewhat solid C background.</p>
<p>Trying to translate the following line into C:
    <code>p, q = q, p - x // y * q</code></p>
<p>My problem is that multiple assertions/attributions (please correct me on terminology) don't work as I expect them to.</p>
<p>How does that line of code actually unwrap into C-like syntax?</p>
</div>
<div class="post-text" itemprop="text">
<p>Any <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">assignment statement</a> works by first evaluating the expression on the right side, then assigning it to the target list.<sup>1</sup></p>
<hr/>
<p>In your case, the right side is a <a href="https://docs.python.org/3/tutorial/datastructures.html#tut-tuples" rel="nofollow noreferrer">tuple display</a> with two elements:</p>
<pre><code>q, p - x // y * q
</code></pre>
<p>So, Python evaluates the first element, <code>q</code>, then it evaluates the second element, <code>p - x // y * q</code>, then it builds a tuple out of those two values.</p>
<p>Next, since you have a target list with two targets on the left side, Python uses iterable unpacking (described in the same Tuples and Sequences tutorial section)<sup>2</sup> to unpack that tuple into two separate values, and assign one to each target.</p>
<p>So, in C terms, it's roughly:</p>
<pre><code>_tmp1 = q
_tmp2 = p - x // y * q
_tmp3 = (_tmp1, _tmp2)
p = _tmp3[0]
q = _tmp3[1]
</code></pre>
<p>In fact, a real Python implementation might optimize out that build-a-tuple/unpack-a-tuple code, the same way you would if writing this yourself, so what you get is more like:</p>
<pre><code>_tmp = p - x // y * q
p = q
q = _tmp
</code></pre>
<hr/>
<p>If you're used to C, you might be used to looking at the assembly that a compiler generates (without optimizations disabled) to figure out what something really means. You can do the same thing in Python with the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module, except that the assembly language is for CPython bytecode rather than x86_64 or ARM9 or whatever:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis('p, q = q, p - x // y * q')
  1           0 LOAD_NAME                0 (q)
              2 LOAD_NAME                1 (p)
              4 LOAD_NAME                2 (x)
              6 LOAD_NAME                3 (y)
              8 BINARY_FLOOR_DIVIDE
             10 LOAD_NAME                0 (q)
             12 BINARY_MULTIPLY
             14 BINARY_SUBTRACT
             16 ROT_TWO
             18 STORE_NAME               1 (p)
             20 STORE_NAME               0 (q)
             22 LOAD_CONST               0 (None)
             24 RETURN_VALUE
</code></pre>
<p>And as you can see, in CPython 3.7, it actually <em>did</em> optimize out the tuple, and also optimized out the temporary local variables and just stored intermediate values anonymously on the stack.</p>
<hr/>
<p><sub>1. This is slightly oversimplified, because a target like <code>spam[eggs][0] = …</code> actually requires evaluating <code>spam[eggs]</code> as an expression, and then treating <code>&lt;the result of that&gt;[0]</code> as a target… but that isn't relevant here.</sub></p>
<p><sub>2. The tutorial calls this "sequence unpacking", because it hasn't gotten to the notion of "iterable" yet.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>You'd do the equivalent thing in C with:</p>
<pre class="lang-c prettyprint-override"><code>temp = p - x / y * q; 
p = q; 
q = temp;
</code></pre>
<p>But what's <em>really</em> going on is that the right hand side creates a tuple, with the tuple items being built left to right:</p>
<pre class="lang-py prettyprint-override"><code>t = (q, p - x // y * q)
</code></pre>
<p>And then that tuple gets unpacked on the left hand side:</p>
<pre><code>p = t[0]
q = t[1]
</code></pre>
<p>This use of tuples for essentially parallel assignment comes in <em>very</em> handy. And I'm sure you'll get used to it very quickly. </p>
<p>But one thing that may take a little longer to get used to is Python's data model, which works rather differently to C's. You may find this article helpful: <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a>, which was written by SO veteran Ned Batchelder.</p>
</div>
