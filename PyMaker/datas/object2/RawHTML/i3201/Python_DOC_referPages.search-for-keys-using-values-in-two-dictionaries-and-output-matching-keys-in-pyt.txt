<div class="post-text" itemprop="text">
<p>I've written some code (or at least tried to) to compare the keys and values of two dictionaries (X and Y) which have the exact same keys but not always the same values, like an x-y coordinate map. The code is supposed to:</p>
<ol>
<li>Search for the keys using their values (the specifically needed value to be searched for is provided by a pre-set variable). </li>
<li>Compare the result keys against each other for matches and return either as output if they match.</li>
</ol>
<p>I have used Python 2.7 in all my code (I'm quite new to the language), however Python 3 solutions are welcome but not preferred.</p>
<p>Here is the code:</p>
<pre><code>XDict = {
    "Jersey" : 0,
    "Boston" : -1,
    "York" : 0,
    "Vegas" : 1,
    "Diego" : 0
    }

YDict = {
    "Jersey" : 0,
    "Boston" : 0,
    "York" : -1,
    "Vegas" : 0,
    "Diego" : 1
    }


hereX = 0
hereY = 0

def GetLocation(Dict1, Dict2):
    locationX = "_"
    locationY = "not_"
    Location = ''

    for placeX, positionX in Dict1.iteritems():                  
        if positionX == hereX:
            locationX = placeX

    for placeY, positionY in Dict2.iteritems():
        if positionY == hereY:
            locationY = placeY

    if locationX == locationY:
        Location = locationX
        Location = locationY

    print Location

GetLocation(XDict, YDict)
</code></pre>
<p>The expected output is <code>"Jersey"</code></p>
<p>Unfortunately, the code doesn't produce the expected output (produces <code>None</code>), probably as a result of locationX and locationY never matching.
I've tried using a different form of the above code by removing the last <code>if</code> block and inserting a <code>while locationX &lt;&gt; locationY:</code> at the top of the function. But that only causes the code to loop forever.</p>
<p>My larger aim with the code is to write a <code>GetLocation()</code> function for a Player class which returns the location of the player using x-y coordinates assigned to each location. I understand that I could probably achieve this using a single dictionary and keys with unique values but I would much rather use the x-y coordinates.</p>
<p>I ran out of solutions I could think of and tried searched for solutions elsewhere on the internet including Stack Overflow and have found similar and somewhat helpful suggestions, but these do not solve the problem either including
<a href="https://stackoverflow.com/questions/23288989/get-values-for-matching-keys-in-dictionaries">this</a>. </p>
<p>Thank you for your time.</p>
</div>
<div class="post-text" itemprop="text">
<p>My take on the problem:</p>
<pre><code>XDict = {
    "Jersey" : 0,
    "Boston" : -1,
    "York" : 0,
    "Vegas" : 1,
    "Diego" : 0
    }

YDict = {
    "Jersey" : 0,
    "Boston" : 0,
    "York" : -1,
    "Vegas" : 0,
    "Diego" : 1
    }


hereX = 0
hereY = 0

for ((n1, x), (n2, y)) in zip(XDict.items(), YDict.items()):
    if (x==hereX) and (y==hereY):
        print(n1)
        break
</code></pre>
<p>Prints:</p>
<blockquote>
<p>Jersey</p>
</blockquote>
<p>However, it's unclear why you store the city names in both dictionaries. Better solution would be storing the dataset like this:</p>
<pre><code>d = {(0, 0): "Jersey",
     (-1, 0): "Boston",
     (0, -1): "York",
     (1, 0): "Vegas",
     (0, 1): "Diego"}
</code></pre>
<p>That way you can index it by <code>d[(hereX, hereY)]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You aren't storing all the keys with the required values. You need to store all of them and then find the intersection. </p>
<pre><code>XDict = {
    "Jersey" : 0,
    "Boston" : -1,
    "York" : 0,
    "Vegas" : 1,
    "Diego" : 0
    }

YDict = {
    "Jersey" : 0,
    "Boston" : 0,
    "York" : -1,
    "Vegas" : 0,
    "Diego" : 1
    }


hereX = 0
hereY = 0

def GetLocation(Dict1, Dict2):
    locationX = []
    locationY = []
    Location = ''

    for placeX, positionX in Dict1.items():                  
        if positionX == hereX:
            locationX.append(placeX)

    for placeY, positionY in Dict2.items():
        if positionY == hereY:
            locationY.append(placeY)

    print(set(locationX).intersection(set(locationY)))

GetLocation(XDict, YDict)
</code></pre>
<p>Output:</p>
<pre><code>{'Jersey'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all please follow some <strong>style guide</strong> for example <strong>PEP8</strong>.</p>
<p>I have for You solution using generator </p>
<pre><code>XDict = {
"Jersey" : 0,
"Boston" : -1,
"York" : 0,
"Vegas" : 1,
"Diego" : 0
}

YDict = {
    "Jersey" : 0,
    "Boston" : 0,
    "York" : -1,
    "Vegas" : 0,
    "Diego" : 1
    }

def keys_of_equal_vales(dict1, dict2):
    for key in dict1 :
        if key in dict2 and dict1[key]==dict2[key]:
            yield key
        else :
            continue 
    raise StopIteration 

print(list(keys_of_equal_vales(XDict,YDict)))
</code></pre>
<p>Result :</p>
<pre><code>['Jersey']
</code></pre>
</div>
<span class="comment-copy">Brilliant. This is just what I needed. Correct me if I'm wrong (new to Python) but I'm guessing that zip produces a set of items from the key-value pairs of both dictionaries. Like a set of a set or something.</span>
<span class="comment-copy">@NashDaru Yes, <code>zip()</code> aggregates elements from all it's arguments (which need to be iterable) - <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#zip</a></span>
