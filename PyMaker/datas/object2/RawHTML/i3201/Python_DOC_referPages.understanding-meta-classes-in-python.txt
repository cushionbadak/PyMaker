<div class="post-text" itemprop="text">
<p>I am trying to learn <code>metaclasses</code> in python, from my research i found a example like follow.</p>
<p>i have a <code>Base</code> and <code>Derived</code> classes like follow</p>
<pre><code>class Base():
    def foo(self):
        return self.bar() 

class Derived(Base):
    def foo2(self):
        return "i am foo2"
</code></pre>
<p>now, when i want to make sure that whoever extending <code>Base</code> class, must need to implement <code>bar()</code> method, so i created the meta class to hook the constuction of derived class,so now <code>Base</code> class looks like follow with <code>BaseMeta</code> meta class.</p>
<pre><code>class BaseMeta(type):
  def __new__(cls, name, bases, body):
    if not "bar" in body:
      raise TypeError("bar not implemented")
    return super().__new__(cls, name, bases, body)

class Base(metaclass=BaseMeta):
   def foo(self):
        return self.bar() 
</code></pre>
<p>The problem is when i get looks into body it returns 2 records for <code>Base</code> and <code>Derived</code> class,  like follow.</p>
<pre><code> {'__module__': '__main__', '__qualname__': 'Base', 'foo': &lt;function 
 Base.foo at 0x7ffbaae436a8&gt;}
 {'__module__': '__main__', '__qualname__': 'Derived', 'bar': &lt;function 
 Derived.bar at 0x7ffbaae437b8&gt;}
</code></pre>
<p>my code in <code>__new__</code> breaks since <code>Base</code> not have  <code>bar</code>, but i want to check only in the Derived class so i rewrite my <code>metaclass</code> like follow.</p>
<pre><code>def __new__(cls, name, bases, body):
    if name !="Base" and not "bar" in body:
      raise TypeError("bar not implemented")
    return super().__new__(cls, name, bases, body)
</code></pre>
<p>I am checking <code>name != Base</code> in my <code>__new__</code> method. </p>
<blockquote>
<p>Is that the right way to do it or we can use some other best way?</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>abc</code> module in the stdlib, which has tools for doing exactly this.
<a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">https://docs.python.org/3/library/abc.html</a></p>
<pre><code>import abc

class Base(abc.ABC):

    @abc.abstractmethod
    def bar(self):
         pass

class Derived(Base):
    pass

# This will raise an error because foo is not implemented
# &gt;&gt;&gt; Derived() 
# TypeError: Can't instantiate abstract class Derived with abstract methods bar
</code></pre>
<p>Another strategy would be to have a <code>bar</code> method on your Base class that raises a NotImplementedError.  The main difference is that no error is raised until you actually call something that requires <code>bar</code>. e.g.</p>
<pre><code>class Base():
    def foo(self):
        return self.bar() 

    def bar(self):
        raise NotImplementedError
</code></pre>
</div>
<span class="comment-copy">fyi, what you are talking about is not a metaclass but a baseclass. <a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">Metaclass</a> has a very specific meaning and refers to something completely different.</span>
<span class="comment-copy">We can also use <code>metaclass</code> to achieve this right?</span>
<span class="comment-copy">Theoretically, I am sure. But metaclasses are intended to achieve something different called <i>class alteration</i>. Sorry that I am so vague, but I don't understand their use very well myself and just trust the top-voted answer from the question I linked which says that <a href="https://stackoverflow.com/a/6581949/962190">99% of the time you need class alteration, you are better off using [monkey patching or decorators]. But 98% of the time, you don't need class alteration at all</a> and go about my day ignoring that metaclasses exist.</span>
<span class="comment-copy">That looks interesting, I'll try to have a look and get back if it turns out that I misunderstood your question.</span>
<span class="comment-copy">Note that you could implement <a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="nofollow noreferrer"><code>__init_subclass__</code></a> to verify assertions about a child without defining a metaclass.</span>
<span class="comment-copy">I want to enforce constraint for <code>derived</code> class without implementing <code>bar</code> method in my <code>Base</code> class, and i am confused about example 1, i think it enforce <code>foo</code> right? but i need to enforce <code>bar()</code></span>
<span class="comment-copy">To enforce <code>bar</code> for a derived class, declare an abstract method on your base class for that method.  Edited response to reflect this.</span>
