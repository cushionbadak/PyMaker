<div class="post-text" itemprop="text">
<p>I am currently getting a list of random numbers that end with a random len of 0’s in Python 3.x.  So for example, I get the following set of random string of numbers:</p>
<pre><code>String 1 = 203502000000
String 2 = 302933000
String 3 = 000023123389270
</code></pre>
<p>Is there a way to remove the series of 0’s found at the end of each string without deleting any other series of 0’s such as those found in the beginning of String 3?  Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that your variables are strings like you claim, and not integers like they are in the question, you are looking for <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="nofollow noreferrer"><strong><code>rstrip</code></strong></a>:</p>
<pre><code>&gt;&gt;&gt; s1 = '203502000000'
&gt;&gt;&gt; s1.rstrip('0')
'203502'
</code></pre>
<p>This will remove all trailing zeros from the string, but none anywhere else.</p>
<p>To apply this to your entire list, you may use a list comprehension:</p>
<pre><code>[s.rstrip('0') for s in my_list]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>String manipulation method</h3>
<p>You could use the fact that leading zeros are ignored when casting to an integer. As such, you would reverse your string, make an integer cast, then cast back to a string, and reverse it again. Here's an example:</p>
<pre><code>In [20]: s
Out[20]: '125647124004170000'

In [21]: s[::-1]
Out[21]: '000071400421746521'

In [22]: int(_)
Out[22]: 71400421746521

In [23]: str(_)
Out[23]: '71400421746521'

In [24]: _[::-1]
Out[24]: '12564712400417'
</code></pre>
<p>In lines 21 and 24, we use a complete slice with a step of <code>-1</code>, which reverses the string.</p>
<p>As a one-liner list comprehension, you could do the following with your string <code>s</code>:</p>
<pre><code>[str(int(s[::-1]))[::-1] for s in strings_list]
</code></pre>
<h3>Numerical method</h3>
<p>A simple way to do that would be to divide the integer cast of your strings by 10 using integer division until the time integer division produces a different result from floating point division. After we're done, we convert it back to a string, if your use case so requires it. The time it takes is linear in terms of the number of zeros at the end. Worst, case, <code>O(n)</code>, where <code>n</code> is the length of your string.</p>
<pre><code>In [7]: s = '125647124004170000'

In [8]: b = int(s)
Out[8]: 125647124004170000
</code></pre>
<p>(modified after @AChampion's comment)</p>
<pre><code>In [9]: while b % 10 == 0:
   ...:     b //= 10

In [10]: b
Out[10]: 12564712400417

In [11]: str(b)
Out[11]: '12564712400417'
</code></pre>
</div>
<span class="comment-copy">A better numerical approach would be <code>while b % 10 == 0: b //= 10</code>, this keeps everything in the integer space.</span>
<span class="comment-copy">It is mathematically the same, but true, cleaner code. Let me incorporate that into the answer.</span>
<span class="comment-copy">This is not mathematically the same, you are assuming that you don't introduce comparison challenges due to float arithmetic, try <code>0.1 + 0.2 == 0.3</code> - see: <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken" title="is floating point math broken">stackoverflow.com/questions/588004/…</a></span>
<span class="comment-copy">That's a good point</span>
