<div class="post-text" itemprop="text">
<p>I am trying to do</p>
<pre><code>ls = [myfunc(a,b,i) for a in a_list for b in b_list]
</code></pre>
<p>but also pass in <code>i</code> into myfunc, which is an index starting at 0 and incrementing for each new element.</p>
<p>For example:</p>
<pre><code>a_list = 'abc'
b_list = 'def'
</code></pre>
<p>should result in</p>
<pre><code>ls = [myfunc('a','d',0),
      myfunc('a','e',1),
      myfunc('a','f',2),
      myfunc('b','d',3),
      myfunc('b','e',4),
      ...
      myfunc('c','f',8]
</code></pre>
<p>I know that I can use <code>enumerate()</code> for just the normal case, ie.</p>
<pre><code>ls = [myfunc(a,i) for a,i in enumerate(a_list)]
</code></pre>
<p>But I can't figure out how to do it cleanly when there are two <code>for</code>s. I couldn't find this question posted previously either. </p>
</div>
<div class="post-text" itemprop="text">
<p>You are creating a <a href="https://stackoverflow.com/questions/533905/get-the-cartesian-product-of-a-series-of-lists">Cartesian product</a> over two lists, so use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a> instead of a double <code>for</code> loop. This gives you a single iterable you can easily add <code>enumerate()</code> to:</p>
<pre><code>from itertools import product

ls = [myfunc(a, b, i) for i, (a, b) in enumerate(product(a_list, b_list))]
</code></pre>
<p>For cases where you can't use <code>product()</code>, you'd put the multiple loops in a generator expression, then add <code>enumerate()</code> to that. Say you needed to filter some values of <code>a_list</code>:</p>
<pre><code>gen = (a, b for a in a_list if some_filter(a) for b in b_list)
ls = [myfunc(a, b, i) for i, (a, b) in enumerate(gen)]
</code></pre>
<p>Another option is to add a separate counter; <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count()</code></a> gives you a counter object that produces a new value with <code>next()</code>:</p>
<pre><code>from itertools import count

counter = count()
ls = [myfunc(a, b, next(counter)) 
      for a in a_list if some_filter(a)
      for b in b_list]
</code></pre>
<p>After all, in essence <code>enumerate(iterable, start=0)</code> is the equivalent of <code>zip(itertools.count(start), iterable)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use enumerate on the sequence of pairs.</p>
<pre><code>ls = [myfunc(a,b,i) for (i,(a,b)) in
      enumerate((a,b) for a in a_list for b in b_list)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a simple nested loop, use <code>itertools.product()</code> as @Martijn suggested.</p>
<p>If the expression is more complex you can use <code>itertools.count</code>:</p>
<pre><code>i_gen = itertools.count()
ls = [myfunc(a, b, next(i_gen)) for a in a_list for b in b_list]
</code></pre>
</div>
<span class="comment-copy">Do it in two steps.</span>
<span class="comment-copy">@tobias_k: that wasn't me. That was that guy over there with the paper bag over their head.</span>
<span class="comment-copy"><a href="https://meta.stackoverflow.com/a/344792/5292302">This guy</a>?</span>
<span class="comment-copy">@PetterFriberg: <i>That's the one!</i> He keeps breaking into my house! They think I can't see them, but I can spot them when I walk past a mirror!</span>
<span class="comment-copy">I'll give you an upvote if you split that unreadable line into two readable ones (: Edit: That's not really what I meant, but it's readable enough I guess.</span>
<span class="comment-copy">@Aran-Fey Sure.</span>
