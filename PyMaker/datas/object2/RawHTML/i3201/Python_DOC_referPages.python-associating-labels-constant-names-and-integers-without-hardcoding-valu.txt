<div class="post-text" itemprop="text">
<p>I'm looking for a way to associate:</p>
<ul>
<li>A human-readable label: <code>"Option one"</code> or even <code>u'Premi√®re option'</code></li>
<li>A "constant name": <code>OPTION_ONE</code></li>
<li>A integer value (from 0 up)</li>
</ul>
<p>Given that:</p>
<ul>
<li>The code passes the list of labels to some API, that displays it to the user</li>
<li>The API returns an integer value, which is the index of the user's choice in the sequence above</li>
<li>I want to later compare this integer value to one of the constant names (or something quickly derived from them)</li>
<li>I want to be able to easily insert/remove/reorder labels in the sequence</li>
<li>I don't want to hardcode any integer value (except <code>0</code> as a the base index, if necessary).</li>
</ul>
<p>Of course this is to make the code look clean, so a reasonable terseness is required. This should run in Python 2.7 using the standard libraries.</p>
</div>
<div class="post-text" itemprop="text">
<p>Solution using a namedtuple:</p>
<ul>
<li><p>First define a small function</p>
<pre><code>from collections import namedtuple

def createOpts(name,pairs):
    # namedtuple('FooType',['OPTION1',...,'OPTIONn','labels']
    optsclass=namedtuple(name+'Type',[symbol for symbol,label in pairs]+['labels'])
    # FooType(0,..,n-1,['Option 1',...,'Option N']) 
    opts=optsclass(*(range(len(pairs))+[[label for symbol,label in pairs]]))
    return opts
</code></pre></li>
<li><p>The list if options is defined like this</p>
<pre><code>Options=createOpts('Opt',[('OPTION1','Option one'),('OPTION2','Options two'),('OPTION3','Option three'),])
</code></pre></li>
<li><p>Then in the code it is used like this. </p>
<pre><code>print type(Options)
print 'Option labels:',Options.labels
print 'Option one:',Options.OPTION1
print 'Option two compares to 1:',1==Options.OPTION2
print 'Option 2 in set:', 1 in [Options.OPTION2,Options.OPTION3]
print 'Option 1 not in set:', 0 not in [Options.OPTION2,Options.OPTION3]

&lt;class '__main__.OptType'&gt;
Option labels: ['Option one', 'Options two', 'Option three']
Option one: 0
Option two compares to 1: True
Option 2 in set: True
Option 1 not in set: True
</code></pre></li>
</ul>
</div>
<span class="comment-copy">It looks like you're asking for <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer"><code>enum</code></a>. But that requires Python 3.4+. There is no equivalent in the 2.7 stdlib. You can install the backport off PyPI, or any of a zillion or so third-party enum libraries with variations on the features, but you say you want to do it with the stdlib only. Which basically means you need to grab the code for one of those libraries, stick it in your project, and (if necessary) edit it until it works embedded like that instead of installed.</span>
<span class="comment-copy">Looked at at enums (there is a backport standard in 2.7), but they only associate the integers and the constant names, and the labels are left out.</span>
<span class="comment-copy">I am wondering, very naively, why not using two different data structures, as there are two different kind of data? I am thinking about a dictionary which link the "constant name" to a readable label and a list of "constant name" which provides the option order</span>
<span class="comment-copy">Parallel data structures are a capital sin in my book :) Currently looking at a list of <code>(value,label)</code> tuples in a class with a few methods for access but it looks a bit clumsy.</span>
<span class="comment-copy">You can add anything you want to the enumeration constants. For example, <code>Color.RED.label = 'color whose paradigm is around 700nm'</code>. You can even store the labels in <code>__doc__</code> so they show up in <code>help</code>, although you have to do that manually. (I'm pretty sure some of the third-party enum libraries let you use docstring syntax, but not the stdlib one.)</span>
