<div class="post-text" itemprop="text">
<p>Consider the following instance behavior in Python.</p>
<pre><code>def change(elements):
    elements[0] = 888
    elements = [-3, -1, -2, -3, -4]
    print(elements[0])

numbers = [1, 4, 5]

print(numbers[0])
change(numbers)
print(numbers[0])
print(numbers)
</code></pre>
<p>The Python snippet below prints </p>
<pre><code>1
-3, 
888 
[888,4,5]
</code></pre>
<p>Shouldn't it print </p>
<pre><code>1, 
-3, 
-3, 
[-3,-1,-2,-3,-4]
</code></pre>
<p>Why would an element in a list by successfully overwritten, but not the entire list object?</p>
</div>
<div class="post-text" itemprop="text">
<p>The list is passed as a reference to the function. So the list is shared between the global space and function. The first change modifies the list and that change is reflected in both spaces. But then you do and assignment to the list variable. That creates a new list in the function. The original list exists in the global space, but it no longer exists in the function. So all of the changes made to the list in the function from that point on are only visible within the function.</p>
<p>Another way of thinking about this instance is that the list is a type of container. The first line of the function changes what is in the container. The second line (the assignment) actually changes the container you are using. This is something that is true for lists but also for any object. This is why the solution given by @Chris_Rands in the comments works: it modifies what is in the container, it doesn't change the container.</p>
</div>
<div class="post-text" itemprop="text">
<p>That is a classic Python variable naming reference confusion. What I really like to to do to understand that though is print a reference to see what is going on.</p>
<pre><code>def change(elements):
    elements[0] = 888
    print("ID of elements is: %d",id(elements))
    elements = [-3, -1, -2, -3, -4]
    print("ID of elements is: %d",id(elements))
    print(elements[0])

numbers = [1, 4, 5]
print("ID of number is: %d",id(numbers))

print(numbers[0])
change(numbers)
print(numbers[0])
print(numbers)

&gt;&gt;&gt;&gt; ('ID of number is: %d', 140036366181584)
1
('ID of elements is: %d', 140036366181584)
('ID of elements is: %d', 140036366181944)
-3
888
[888, 4, 5]
</code></pre>
<p>The ID here represents an emplacement in memory. If you run the code the number might be different, but the behavior stays the same. </p>
<p>Basically, when you call </p>
<pre><code> elements[0] = 888
</code></pre>
<p>You're actually mutating <code>numbers</code> (same ID of <code>140036366181584</code> in my example).</p>
<p>But, when you call</p>
<pre><code>elements = [-3, -1, -2, -3, -4]
</code></pre>
<p>You're creating a new list (different ID of <code>140036366181944</code> in my example) and <strong>re-assigning the local name <code>elements</code> to it</strong>. Yo're simply assigning the name <code>elements</code> to another object. It's not the same list anymore. </p>
<p>So, at this point all you did to <code>numbers</code> is change its first index with the value <code>888</code> and this is what the output shows empirically. </p>
</div>
<div class="post-text" itemprop="text">
<p>In <code>change</code> function first you use <code>elements</code> from outer scope, that was passed as the argument and is referenced - can be changed within function and those changed will affect the object even out of the local scope.</p>
<p>Then you create local instance of <code>elements</code>, modify it and end the function. Since the <code>elements</code> in global scope were changed earlier, you see "unexpected" result.</p>
<p>Check <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">https://docs.python.org/3/reference/executionmodel.html</a> for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>No it shouldn't because in first line you override first value of parameter <code>elements</code> and on the second you define <strong>new local variable</strong> for function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Looking at ID's will make understand ... </p>
<pre><code>def change(elements):
    print('inner first elements ID ',id(elements))
    elements[0] = 888
    print('inner second elements ID ',id(elements))
    elements = [-3, -1, -2, -3, -4]
    print('inner third elements ID ',id(elements))
    print('inner third numbers ID ',id(numbers))

numbers = [1, 4, 5]
print(numbers[0])
print('outer numbers ID ',id(numbers))
change(numbers)
print('c ',numbers[0])
print('d', numbers)
</code></pre>
</div>
<span class="comment-copy"><code>elements[:] = [-3, -1, -2, -3, -4]</code> would produce your expected output...</span>
<span class="comment-copy">Reading this will clear up your misunderstanding: <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a></span>
<span class="comment-copy">@Chris_Rands: True, but absent an explanation why the OP isn't left with a better understanding of of the language.  The key difference is <code>elements = somelist</code> is simple assignment and merely rebinds the local name to a different object, whereas <code>elements[:] = somelist</code> only looks like assignment.  It's really syntactic sugar for calling a mutating method on the existing object referred to be the name <code>elements</code>.</span>
<span class="comment-copy">Thanks guys, these are great comments.</span>
<span class="comment-copy">"Pass by reference" carries baggage that isn't quite correct with Python (but it is good enough). "Pass by assignment" has become a popular way of describing it because follows the semantics of Python's assignment.</span>
<span class="comment-copy">@StevenRumbalski Thanks for pointing that out. I didn't really think about the distinction between a reference to an object versus a reference to memory, but it makes sense. I learned something new today too! :)</span>
