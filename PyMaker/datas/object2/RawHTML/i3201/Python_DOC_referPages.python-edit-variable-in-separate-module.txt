<div class="post-text" itemprop="text">
<p>I've found plenty about calling variables from another module, but I can't find anything about editing a variable in a separate module.</p>
<p>For my first actual project with python I'm writing a little text adventure.</p>
<p>I've got GV.py for global variables, and Classes.py for weapons/armor etc.</p>
<p>I want Classes.Longsword() to modify a variable in GV.py, specifically variable GV.weapon.</p>
<p>In GV.py</p>
<pre><code>import Classes
global weapon
weapon = 'Unarmed'    
</code></pre>
<p>in Classes.py</p>
<pre><code>import GV
def Longsword():
    GV.weapon = 'Longsword'
</code></pre>
<p>This does not edit the variable weapon in GV.py.. Am I missing something?</p>
<p>Since it was asked I'll put the output here.</p>
<p>repl from GV.py</p>
<pre><code>weapon
'Unarmed'
Classes.Longsword()
&gt;&gt;&gt;&gt;
weapon
'Unarmed'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that, when you run the script <code>GV.py</code>, what you get isn't a module named <code>GV</code>, but a special module named <code>__main__</code>.</p>
<hr/>
<p>If you've seen the familiar main guard idiom, that can be used to write a single file that works as a module or as a top-level script, this is exactly how it works:</p>
<pre><code>if __name__ == '__main__':
</code></pre>
<p>That will be true when you're running the file as a script, and it will not be true when you're importing the file as a module.</p>
<hr/>
<p>Now, when you do <code>import GV</code> from inside <code>Classes</code>, that imports the exact same <code>GV.py</code> file, and builds a second module object out of it (and this one, of course, <em>is</em> named <code>GV</code>).</p>
<p>So when you then do <code>GV.weapon = 'longsword'</code>, you're changing the <code>weapon</code> global in the <code>GV</code> module, not the <code>__main__</code> module.</p>
<hr/>
<p>If you're wondering how this works under the covers: the way Python makes sure there's only one <code>Classes</code> module object no matter how many times you <code>import Classes</code> is dead simple: it just caches loaded modules in a dict, <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code></a>, and looks them up by name.</p>
<hr/>
<p>If you fix that, you've got a second problem here: the first thing <code>GV.py</code> does is to <code>import Classes</code>. The first thing <code>Classes.py</code> does is to <code>import GV</code>. This is a circular import. </p>
<hr/>
<p>The usual way to deal with <em>both</em> of these problems is pretty simple: put the shared globals in a simple module that does little or nothing beyond holding those shared globals, so everyone can <code>import</code> it:</p>
<pre><code># main.py
import classes
import GV
GV.weapon = 'Unarmed'

# Classes.py
import GV
def Longsword():
    GV.weapon = 'Longsword'

# GV.py
# empty... or you can move weapon = 'Unarmed' here
</code></pre>
</div>
<span class="comment-copy">Did you actually <i>call</i> the function?</span>
<span class="comment-copy">yes. running the repl from GV.py. If I call the function the variable weapon does not change.</span>
<span class="comment-copy">So.. I see what its doing.. its creating a local GV.weapon IN Classes.py.. not quite what I want it to do though.</span>
<span class="comment-copy">No, it's not creating a local <code>GV</code>, or a local <code>GV.weapon</code>. I think I know where your mind is heading, but that's a rare problem, and one you only run into if you start doing <code>import</code>s inside a function definition.</span>
<span class="comment-copy">Meanwhile, what does "repl from GV.py" mean? I assume it means you're doing something like <code>python -i GV.py</code>, but I'm not <i>sure</i> about that.</span>
<span class="comment-copy">Ohhh, ok. That makes a ton of sense.. just tested it and it functioned as expected. Thank you so much! I'd been googling for hours.</span>
<span class="comment-copy">@JohnFarley Yeah, it's one of those things that's hard to google for unless you already know the answer you're looking for. (If you search for <code>__main__</code> you'll find lots of answers, but how could you know to search for <code>__main__</code>?)</span>
