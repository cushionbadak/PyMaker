<div class="post-text" itemprop="text">
<p>I have been trying to figure out how I can accomplish this with the <code>for</code> loop and the <code>enumerate</code> objects that I am given in python. I have a time in the format of <code>HH:MM</code>. And I have a csv file in which the first column is a timestamp that follows in that same format. I then search the file for the matching time, and then I extract that row to later be converted into an XML File. However, I need to extract the row before and the row after that target row as well. I have tried the following piece of code:</p>
<pre><code>def findRow(timeID, filename):
    rows = []
    csvFile = csv.reader(open(filename, "rb"), delimiter=",")
    for i, row in enumerate(csvFile):
        if timeID == timeInRow:
            rows.append(i-1)
            rows.append(i)
            rows.append(i+1)
            return rows
</code></pre>
<p>However, I realized shortly after that this is not the correct way to do this because I am extracting the index and not the value. What I need is something something like row[i-1],row[i],row[i+1]. In other words, I need i's element that matches the row.</p>
<p>Is there an easy way to do this? I have thought about using <code>range(csvFile)</code> but I honestly have no idea what that would end up doing. </p>
</div>
<div class="post-text" itemprop="text">
<p>I would use a different approach:</p>
<ul>
<li>store the previous row in your loop</li>
<li>if matches, then use <code>next</code> to get the next row, and return the 3 rows</li>
</ul>
<p>like this (I added a comment since <code>timeInRow</code> should be extracted from <code>row</code> but your code doesn't show it):</p>
<pre><code>prev_row = []  # just in case it matches at first row
for row in csvFile:
    # something must be done to extract timeInRow from row here!
    if timeID == timeInRow:
        return [prev_row,row,next(csvFile,[])]
    prev_row = row  # save current row for next iteration
</code></pre>
<p><code>next</code> uses a default empty list value just in case the <em>last</em> line matches (avoids <code>StopIteration</code> exception)</p>
<p>This linear approach works, but if the rows are sorted by time and you need to perform several searches, a better approach (faster) would probably to create a list of rows, a list of times, then use <code>bisect</code> module to compute the insertion point in the list of times, check that the times match, and use the index to return a slice of the list of rows.</p>
<p>Something like:</p>
<pre><code>list_of_rows = list(csvFile)
list_of_times = [x[3] for x in list_of_rows] # assume that the time is the 4th column here
i = bisect.bisect(list_of_rows,timeInRow)
if i &lt; len(list_of_rows) and list_of_rows[i] == timeInRow:
    return list_of_rows[max(i-1,0):min(i+2,len(list_of_rows)]
</code></pre>
<p>If you only need to perform 1 search, this is slower because you have to create the list anyway so <code>O(n) + O(log(n))</code>. But if you want to perform several time searches in the same list, the cost is <code>O(log(n))</code> per search.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">deque</a> for this.</p>
<p>Given:</p>
<pre><code>$ cat /tmp/file.csv
firstName,lastName,email,phoneNumber
John,Doe,john@doe.com,0123456789
Jane,Doe,jane@doe.com,9876543210
James,Bond,james.bond@mi6.co.uk,0612345678
</code></pre>
<p>Presume you want the line with <code>Jane</code> and the line before and after. </p>
<p>Try:</p>
<pre><code>import csv 
from collections import deque 

dq=deque([[None] for _ in range(3)],maxlen=3)
with open(fn,'r') as f:
    for row in csv.reader(f):
        dq.append(row)
        if dq[-2][0]=='Jane': break # here you can use your custom function 
</code></pre>
<p>Then:</p>
<pre><code> &gt;&gt;&gt; dq
 deque([['John', 'Doe', 'john@doe.com', '0123456789'], ['Jane', 'Doe', 'jane@doe.com', '9876543210'], ['James', 'Bond', 'james.bond@mi6.co.uk', '0612345678']], maxlen=3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternate (functional) approach to those above would be to use <code>zip</code> or a variation of it.  Something like:</p>
<pre><code>rows = list(csv.reader(f))
for x, y, z in zip(rows, rows[1:], rows[2:]):
    # y is the middle row, x is above it, and z below it
    pass
</code></pre>
<p>If you wanted to include the first two and last two rows in your iteration as</p>
<pre><code>(None, None, rows[0])
(None, rows[0], rows[1])
(rows[-2], rows[-1], None)
(rows[-1], None, None)
</code></pre>
<p>then you would have to pre- and post-pend the <code>rows</code> list by two None's on both ends.</p>
<p>Not saying this is necessarily better than other answers, but it is an alternative approach that I would consider writing.</p>
<p>[Edit]</p>
<p>Using itertools.islice per suggestion of Jean-François:</p>
<pre><code>rows = list(csv.reader(f))
from itertools import islice
for x, y, z in zip(rows, islice(rows, 1, None), islice(rows, 2, None)):
    # y is the middle row, x is above it, and z below it
    pass
</code></pre>
</div>
<span class="comment-copy"><code>timeInRow</code> is extracted via another function that I wrote. I have attempted this method and I get the error message <code>TypeError: list object is not an iterator</code>.</span>
<span class="comment-copy">ooops fixed my <code>next</code> part that must apply to the <code>csvFile</code> object, not <code>row</code> :)</span>
<span class="comment-copy">Apologies for getting back to you so late, how will this method account for going out of bounds in the CSV file? If the match ends up being the first or last thing in the file will this break?</span>
<span class="comment-copy">no it wont because slicing will stop first. Well, maybe there's a corner case, editing</span>
<span class="comment-copy">no in first method, if found at start, it will return empty list for previous, and if found at end will return empty list for next one.</span>
<span class="comment-copy">Will <code>dq.append(row)</code> append everything to the deque and kick everything out once it has reached a max length of 3?</span>
<span class="comment-copy">@Sailanarmo: Yes. Whatever the <code>maxlen=3</code> value is, items are added on one end and then are removed on the other end to keep the length at <code>maxlen</code>. It acts like a rolling window into a longer data element. You can also have no <code>maxlen</code> and therefore the deque will behave more like a list (with some differences, including performant push and pops on either end)</span>
<span class="comment-copy">apologies for getting back so late, will this method account for out of bounds? What if the match ends up being the last thing in the CSV file or the first? Will this break? Or is there an exception I can catch? Or can I somehow fill that entry with null?</span>
<span class="comment-copy">If the first, you would get <code>[[None], [Line 1], [Line 2]]</code> If your match is the last line, you can add an <code>else</code> to the <code>for</code> loop and test that condition at the end of the loop. Then the deque would be the last three lines.</span>
<span class="comment-copy">in that case, it would be better to use <code>itertools.islice</code> to avoid creating 2 copies of the <code>rows</code> list.</span>
<span class="comment-copy">Something like the above edit @Jean-FrançoisFabre ? I haven't used islice, but seems reasonable for this use case.</span>
