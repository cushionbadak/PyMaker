<div class="post-text" itemprop="text">
<blockquote>
<p>The <code>is</code> operator does not match the values of the variables, but the
  instances themselves.</p>
</blockquote>
<p>What does it really mean?</p>
<p>I declared two variables named <code>x</code> and <code>y</code> assigning the same values in both variables, but it returns false when I use the <code>is</code> operator.</p>
<p>I need a clarification. Here is my code.</p>
<pre><code>x = [1, 2, 3]
y = [1, 2, 3]

print x is y #It prints false!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You misunderstood what the <code>is</code> operator tests. It tests if two variables point the <em>same object</em>, not if two variables have the same value.</p>
<p>From the documentation for the <a href="http://docs.python.org/2/reference/expressions.html#is" rel="noreferrer"><code>is</code> operator</a>:</p>
<blockquote>
<p>The operators <code>is</code> and <code>is not</code> test for object identity: <code>x is y</code> is true if and only if <code>x</code> and <code>y</code> are the same object.</p>
</blockquote>
<p>Use the <code>==</code> operator instead:</p>
<pre><code>print x == y
</code></pre>
<p>This prints <code>True</code>. <code>x</code> and <code>y</code> are two <em>separate</em> lists:</p>
<pre><code>x[0] = 4
print(y)  # prints [1, 2, 3]
print(x == y)   # prints False
</code></pre>
<p>If you use the <a href="http://docs.python.org/2/library/functions.html#id" rel="noreferrer"><code>id()</code> function</a> you'll see that <code>x</code> and <code>y</code> have different identifiers:</p>
<pre><code>&gt;&gt;&gt; id(x)
4401064560
&gt;&gt;&gt; id(y)
4401098192
</code></pre>
<p>but if you were to assign <code>y</code> to <code>x</code> then both point to the same object:</p>
<pre><code>&gt;&gt;&gt; x = y
&gt;&gt;&gt; id(x)
4401064560
&gt;&gt;&gt; id(y)
4401064560
&gt;&gt;&gt; x is y
True
</code></pre>
<p>and <code>is</code> shows both are the same object, it returns <code>True</code>.</p>
<p>Remember that in Python, <a href="https://nedbatchelder.com/text/names.html" rel="noreferrer">names are just labels referencing values</a>; you can have multiple names point to the same object. <code>is</code> tells you if two names point to one and the same object. <code>==</code> tells you if two names refer to objects that have the same value.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/25757465/why-does-a-bc-result-in-a-different-non-is-string-from-abc">Another duplicate</a> was asking why two equal strings are generally not identical, which isn't really answered here:</p>
<pre><code>&gt;&gt;&gt; x = 'a' 
&gt;&gt;&gt; x += 'bc'
&gt;&gt;&gt; y = 'abc'
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x is y
False
</code></pre>
<p>So, why aren't they the same string? Especially given this:</p>
<pre><code>&gt;&gt;&gt; z = 'abc'
&gt;&gt;&gt; w = 'abc'
&gt;&gt;&gt; z is w
True
</code></pre>
<hr/>
<p>Let's put off the second part for a bit. How could the first one be true?</p>
<p>The interpreter would have to have an "interning table", a table mapping string values to string objects, so every time you try to create a new string with the contents <code>'abc'</code>, you get back the same object. <a href="http://en.wikipedia.org/wiki/String_interning" rel="noreferrer">Wikipedia</a> has a more detailed discussion on how interning works.</p>
<p>And Python <em>has</em> a string interning table; you can manually intern strings with the <a href="https://docs.python.org/3/library/sys.html#sys.intern" rel="noreferrer"><code>sys.intern</code></a> method.</p>
<p>In fact, Python is <em>allowed</em> to automatically intern any immutable types, but not <em>required</em> to do so. Different implementations will intern different values.</p>
<p>CPython (the implementation you're using if you don't know which implementation you're using) auto-interns small integers and some special singletons like <code>False</code>, but not strings (or large integers, or small tuples, or anything else). You can see this pretty easily:</p>
<pre><code>&gt;&gt;&gt; a = 0
&gt;&gt;&gt; a += 1
&gt;&gt;&gt; b = 1
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a = False
&gt;&gt;&gt; a = not a
&gt;&gt;&gt; b = True
a is b
True
&gt;&gt;&gt; a = 1000
&gt;&gt;&gt; a += 1
&gt;&gt;&gt; b = 1001
&gt;&gt;&gt; a is b
False
</code></pre>
<hr/>
<p>OK, but why were <code>z</code> and <code>w</code> identical?</p>
<p>That's not the interpreter automatically interning, that's the compiler folding values.</p>
<p>If the same compile-time string appears twice in the same module (what exactly this means is hard to define—it's not the same thing as a string literal, because <code>r'abc'</code>, <code>'abc'</code>, and <code>'a' 'b' 'c'</code> are all different literals but the same string—but easy to understand intuitively), the compiler will only create one instance of the string, with two references.</p>
<p>In fact, the compiler can go even farther: <code>'ab' + 'c'</code> can be converted to <code>'abc'</code> by the optimizer, in which case it can be folded together with an <code>'abc'</code> constant in the same module.</p>
<p>Again, this is something Python is allowed but not required to do. But in this case, CPython always folds small strings (and also, e.g., small tuples). (Although the interactive interpreter's statement-by-statement compiler doesn't run the same optimization as the module-at-a-time compiler, so you won't see exactly the same results interactively.)</p>
<hr/>
<p>So, what should you do about this as a programmer?</p>
<p>Well… nothing. You almost never have any reason to care if two immutable values are identical. If you want to know when you can use <code>a is b</code> instead of <code>a == b</code>, you're asking the wrong question. Just always use <code>a == b</code> except in two cases:</p>
<ul>
<li>For more readable comparisons to the singleton values like <code>x is None</code>.</li>
<li>For mutable values, when you need to know whether mutating <code>x</code> will affect the <code>y</code>.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><code>is</code> only returns true if they're actually the same object. If they were the same, a change to one would also show up in the other. Here's an example of the difference.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = [1, 2, 3]
&gt;&gt;&gt; print x is y
False
&gt;&gt;&gt; z = y
&gt;&gt;&gt; print y is z
True
&gt;&gt;&gt; print x is z
False
&gt;&gt;&gt; y[0] = 5
&gt;&gt;&gt; print z
[5, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Prompted by a <a href="https://stackoverflow.com/questions/25757465/string-identity-in-python">duplicate question</a>, this analogy might work:</p>
<pre><code># - Darling, I want some pudding!
# - There is some in the fridge.

pudding_to_eat = fridge_pudding
pudding_to_eat is fridge_pudding
# =&gt; True

# - Honey, what's with all the dirty dishes?
# - I wanted to eat pudding so I made some. Sorry about the mess, Darling.
# - But there was already some in the fridge.

pudding_to_eat = make_pudding(ingredients)
pudding_to_eat is fridge_pudding
# =&gt; False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>is</code> and <code>is not</code> are the two identity operators in Python. <code>is</code> operator does not compare the values of the variables, but compares the identities of the variables. Consider this:</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = [1,2,3]
&gt;&gt;&gt; hex(id(a))
'0x1079b1440'
&gt;&gt;&gt; hex(id(b))
'0x107960878'
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt;
</code></pre>
<p>The above example shows you that the identity (can also be the memory address in Cpython) is different for both <code>a</code> and <code>b</code> (even though their values are the same). That is why when you say <code>a is b</code> it returns false due to the mismatch in the identities of both the operands. However when you say <code>a == b</code>, it returns true because the <code>==</code> operation only verifies if both the operands have the same value assigned to them.</p>
<p>Interesting example (for the extra grade):</p>
<pre><code>&gt;&gt;&gt; del a
&gt;&gt;&gt; del b
&gt;&gt;&gt; a = 132
&gt;&gt;&gt; b = 132
&gt;&gt;&gt; hex(id(a))
'0x7faa2b609738'
&gt;&gt;&gt; hex(id(b))
'0x7faa2b609738'
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt;
</code></pre>
<p>In the above example, even though <code>a</code> and <code>b</code> are two different variables, <code>a is b</code> returned <code>True</code>. This is because the type of <code>a</code> is <code>int</code> which is an immutable object. So python (I guess to save memory) allocated the same object to <code>b</code> when it was created with the same value. So in this case, the identities of the variables matched and <code>a is b</code> turned out to be <code>True</code>.</p>
<p>This will apply for all immutable objects:</p>
<pre><code>&gt;&gt;&gt; del a
&gt;&gt;&gt; del b
&gt;&gt;&gt; a = "asd"
&gt;&gt;&gt; b = "asd"
&gt;&gt;&gt; hex(id(a))
'0x1079b05a8'
&gt;&gt;&gt; hex(id(b))
'0x1079b05a8'
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt;
</code></pre>
<p>Hope that helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you can check here to a small integers. Numbers above 257 are not an small ints, so it is calculated as a different object.</p>
<p>It is better to use <code>==</code> instead in this case.</p>
<p>Further information is here: <a href="http://docs.python.org/2/c-api/int.html" rel="nofollow">http://docs.python.org/2/c-api/int.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>x is y</code> is same as <code>id(x) == id(y)</code>, comparing identity of objects.  </p>
<p>As @tomasz-kurgan pointed out in the comment below <code>is</code> operator behaves unusually with certain objects.  </p>
<p>E.g.</p>
<pre><code>&gt;&gt;&gt; class A(object):
...   def foo(self):
...     pass
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.foo is a.foo
False
&gt;&gt;&gt; id(a.foo) == id(a.foo)
True
</code></pre>
<p>Ref;<br/>
<a href="https://docs.python.org/2/reference/expressions.html#is-not" rel="nofollow noreferrer">https://docs.python.org/2/reference/expressions.html#is-not</a><br/>
<a href="https://docs.python.org/2/reference/expressions.html#id24" rel="nofollow noreferrer">https://docs.python.org/2/reference/expressions.html#id24</a></p>
</div>
<div class="post-text" itemprop="text">
<p>X points to an array, Y points to a different array. Those arrays are identical, but the <code>is</code> operator will look at those pointers, which are not identical.</p>
</div>
<div class="post-text" itemprop="text">
<p>It compares object identity, that is, whether the variables refer to the same object in memory. It's like the <code>==</code> in Java or C (when comparing pointers).</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple example with fruits   </p>
<pre><code>fruitlist = [" apple ", " banana ", " cherry ", " durian "]
newfruitlist = fruitlist
verynewfruitlist = fruitlist [:]
print ( fruitlist is newfruitlist )
print ( fruitlist is verynewfruitlist )
print ( newfruitlist is verynewfruitlist )
</code></pre>
<p>Output:</p>
<pre><code>True
False
False
</code></pre>
<p>If you try </p>
<pre><code>fruitlist = [" apple ", " banana ", " cherry ", " durian "]
newfruitlist = fruitlist
verynewfruitlist = fruitlist [:]
print ( fruitlist == newfruitlist )
print ( fruitlist == verynewfruitlist )
print ( newfruitlist == verynewfruitlist )
</code></pre>
<p>The output is different:</p>
<pre><code>True
True
True
</code></pre>
<p>That's because the == operator compares just the content of the variable. To compare the identities of 2 variable use the <strong>is</strong> operator </p>
<p>To print the identification number: </p>
<pre><code>print ( id( variable ) )
</code></pre>
</div>
<span class="comment-copy">Related question <a href="http://stackoverflow.com/questions/38189660/two-variables-in-python-have-same-id-but-not-lists-or-tuples-why/38189759#38189759" title="two variables in python have same id but not lists or tuples why">stackoverflow.com/questions/38189660/…</a></span>
<span class="comment-copy">So, <code>A is B</code> is the same as <code>id(A) == id(B)</code>.</span>
<span class="comment-copy">@imallett: that's a proxy for the same test, provided you don't store <code>id(A)</code> in a variable and later expect <code>variable == id(B)</code> to still work; if <code>A</code> was deleted in the meantime then <code>B</code> could have been given the same memory location.</span>
<span class="comment-copy">Makes sense, and it's also the Right Thing; <code>variable</code> is storing a property of something that formerly existed. There's no way for the runtime to detect that the later usage is erroneous. The key part of the standard is "[id() ]is guaranteed to be unique and constant for this object <i>during its lifetime</i>. Two objects with non-overlapping lifetimes may have the same id() value."</span>
<span class="comment-copy">Could not format in comments. But there is an interesting thing. :)   &gt;&gt;&gt; x = 5 <code>\n</code> &gt;&gt;&gt; y = 5 <code>\n</code> &gt;&gt;&gt; x is y <code>\n</code> True <code>\n</code> &gt;&gt;&gt; x == y <code>\n</code> True <code>\n</code> &gt;&gt;&gt; <code>\n</code></span>
<span class="comment-copy">Small integers are interned in CPython since they are used so often. It's an optimization. x=5;y=5;x is y =&gt; True because id(x) == id(y). It's the same integer object which is reused. Works in Python since integers are immutable. If you do x=1.0; y=1.0 or x=9999;y=9999, it won't be the same identity, because floats and larger ints aren't interned.</span>
<span class="comment-copy">Excellent explanation, especially your advice at the end.</span>
<span class="comment-copy">Could be just personal taste (no pun intended) but I found this analogy more confusing than helpful and has got me wanting to eat pudding when I don't have any in my fridge :(  I think Mark Ransom's answer, although more boring, is probably more instructive</span>
<span class="comment-copy">@TomClose: There are many fine answers on this question, enough so that there is space for levity. Also, I want pudding too.</span>
<span class="comment-copy">this is real nice example. thanks for detailed info.</span>
<span class="comment-copy">But try a=123456789 b=123456789</span>
<span class="comment-copy">Everything less than <code>-5</code> or higher than <code>256</code> in Python will be False. Python caches numbers in range [-5, 256].</span>
<span class="comment-copy">Not, it doesn't. It might behave similar in most cases, but it's not always true.  See <a href="https://docs.python.org/2/reference/expressions.html" rel="nofollow noreferrer">this</a> - the very bottom of the page, bullet 6.: &gt; (...), you may notice seemingly unusual behaviour in certain uses of the <b>is</b> operator, like those involving comparisons between instance methods, or constants  And the minimal working example: ` class A(object):     def foo(self):         pass   a = A() print a.foo is a.foo print id(a.foo) == id(a.foo) `</span>
<span class="comment-copy">@tomasz-kurgan Thank you</span>
<span class="comment-copy">Python doesn't have pointers. You need to tighten up your terminology.</span>
<span class="comment-copy">It does internally, just like Java and so many other languages. In fact, the <code>is</code> operator's functionality shows this.</span>
<span class="comment-copy">The implementation details are not what matters. The documentation uses the terminology "object identity". So should you. "The operators is and is not test for object identity: x is y is true if and only if x and y are the same object. x is not y yields the inverse truth value."</span>
<span class="comment-copy">@Neko: CPython internally uses pointers. But obviously Jython (implemented in Java) and PyPy (implemented in a subset of Python) don't use pointers. In PyPy, some objects won't even have an <code>id</code> unless you ask for it.</span>
