<div class="post-text" itemprop="text">
<p>when assign a variable to another they point to a same object, So, how to value change for one of them but variables still point same object! </p>
<pre><code>a = 10
b = a
a -= 1
print(b) #expect to print 9 but it print 10
</code></pre>
<p>how to re-assign variable in python without changing id?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure whether you're confused about variables in Python, or about immutable values. So I'm going to explain both, and half the answer will probably seem like "no duh, I already knew that", but the other half should be useful.</p>
<hr/>
<p>In Python—unlike, say, C—a variable is not a location where values live. It's just a name. The values live wherever they want to.<sup>1</sup> So, when you do this:</p>
<pre><code>a = 10
b = a
</code></pre>
<p>You're not making <code>b</code> into a reference to <code>a</code>. That idea doesn't even make sense in Python. You're making <code>a</code> into a name for <code>10</code>, and then making <code>b</code> into another name for <code>10</code>. And if you later do this:</p>
<pre><code>a = 11
</code></pre>
<p>… you've made <code>a</code> into a name for <code>11</code>, but this has no effect on <code>b</code>—it's still just a name for <code>10</code>.</p>
<hr/>
<p>This also means that <code>id(a)</code> is not giving you the ID of the variable <code>a</code>, because there <em>is</em> no such thing. <code>a</code> is just a name that gets looked up in some namespace (e.g., a module's globals dict). It's the <em>value</em>, <code>11</code> (or, if you ran it earlier, the different value <code>10</code>) that has an ID. (While we're at it: it's also values, not variables, that are typed. Not relevant here, but worth knowing.)</p>
<hr/>
<p>Things get a bit tricky when it comes to mutability. For example:</p>
<pre><code>a = [1, 2, 3]
b = a
</code></pre>
<p>This still makes <code>a</code> and <code>b</code> both names for a list.</p>
<pre><code>a[0] = 0
</code></pre>
<p>This doesn't assign to <code>a</code>, so <code>a</code> and <code>b</code> are still names for the same list. It <em>does</em> assign to <code>a[0]</code>, which is part of that list. So, the list that <code>a</code> and <code>b</code> both name now holds <code>[0, 2, 3]</code>.</p>
<pre><code>a.extend([4, 5])
</code></pre>
<p>This obviously does the same thing: <code>a</code> and <code>b</code> now name the list <code>[0, 2, 3, 4, 5]</code>.</p>
<hr/>
<p>Here's where things get confusing:</p>
<pre><code>a += [6]
</code></pre>
<p>Is it an assignment that rebinds <code>a</code>, or is it just mutating the value that <code>a</code> is a name for? In fact, it's both. What this means, under the covers, is:</p>
<pre><code>a = a.__iadd__([6])
</code></pre>
<p>… or, roughly:</p>
<pre><code>_tmp = a
_tmp.extend([6])
a = _tmp
</code></pre>
<p>So, we <em>are</em> assigning to <code>a</code>, but we're assigning the same value back to it that it already named. And meanwhile, we're also mutating that value, which is still the value that <code>b</code> names.</p>
<hr/>
<p>So now:</p>
<pre><code>a = 10
b = 10
a += 1
</code></pre>
<p>You probably can guess that the last line does something like this:</p>
<pre><code>a = a.__iadd__(1)
</code></pre>
<p>That's not quite true, because <code>a</code> doesn't define an <code>__iadd__</code> method, so it falls back to this:</p>
<pre><code>a = a.__add__(1)
</code></pre>
<p>But that's not the important bit.<sup>2</sup> The important bit is that, because integers, unlike lists, are immutable. You can't turn the number 10 into the number 11 the way you could in INTERCAL or (sort of) Fortran or that weird dream you had where you were the weirdest X-Man. And there's no "variable holding the number 10" that you can set to 11, because this isn't C++. So, this <em>has</em> to return a new value, the value <code>11</code>.</p>
<p>So, <code>a</code> becomes a name for that new <code>11</code>. Meanwhile, <code>b</code> is still a name for <code>10</code>. It's just like the first example.</p>
<hr/>
<p>But, after all this telling you how impossible it is to do what you want, I'm going tell you how easy it is to do what you want.</p>
<p>Remember earlier, when I mentioned that you can mutate a list, and all the names for that list will see the new value? So, what if you did this:</p>
<pre><code>a = [10]
b = a
a[0] += 1
</code></pre>
<p>Now <code>b[0]</code> is going to be <code>11</code>.</p>
<hr/>
<p>Or you can create a class:</p>
<pre><code>class Num:
    pass

a = Num()
a.num = 10
b = a
a.num += 1
</code></pre>
<p>Now, <code>b.num</code> is <code>11</code>.</p>
<hr/>
<p>Or you can even create a class that implements <code>__add__</code> and <code>__iadd__</code> and <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">all the other numeric methods</a>, so it can hold numbers (almost) transparently, but do so mutably.</p>
<pre><code>class Num:
    def __init__(self, num):
        self.num = num
    def __repr__(self):
        return f'{type(self).__name__}({self.num})'
    def __str__(self):
        return str(self.num)
    def __add__(self, other):
        return type(self)(self.num + other)
    def __radd__(self, other):
        return type(self)(other + self.num)
    def __iadd__(self, other):
        self.num += other
        return self
    # etc.
</code></pre>
<p>And now:</p>
<pre><code>a = Num(10)
b = a
a += 1
</code></pre>
<p>And <code>b</code> is a name for the same <code>Num(11)</code> as <code>a</code>.</p>
<p>If you really want to do this, though, you should consider making something specific like <code>Integer</code> rather than a generic <code>Num</code> that holds anything that acts like a number, and using the appropriate ABC in the <a href="https://docs.python.org/3/library/numbers.html" rel="nofollow noreferrer"><code>numbers</code></a> module to verify that you covered all the key methods, to get free implementations for lots of optional methods, and to be able to pass <code>isinstance</code> type checks. (And probably call <code>num.__int__</code> in its constructor the way <code>int</code> does, or at least special-case <code>isinstance(num, Integer)</code> so you don't end up with a reference to a reference to a reference… unless that's what you want.)</p>
<hr/>
<p><sub>1. Well, they live wherever the interpreter wants them to live, like Romanians under Ceaușescu. But if you're a builtin/extension type written in C and a paid-up member of the Party, you could override <code>__new__</code> with a constructor that doesn't rely on <code>super</code> to allocate, but otherwise you have no choice.</sub></p>
<p><sub>2. But it's not completely unimportant. By convention (and of course in all builtin and stdlib types follow the convention), <code>__add__</code> doesn't mutate, <code>__iadd__</code> does. So, mutable types like <code>list</code> define both, meaning they get in-place behavior for <code>a += b</code> but copying behavior for <code>a + b</code>, while immutable types like <code>tuple</code> and <code>int</code> define only <code>__add__</code>, so they get copying behavior for both. Python doesn't force you to do things this way, but your type would be very strange if it didn't pick one of those two. If you're familiar with C++, it's the same—you usually implement <code>operator+=</code> by mutating in-place and returning a reference to <code>this</code>, and <code>operator+</code> by copying and then returning <code>+=</code> on the copy, but the language doesn't force you to, it's just confusing if you don't.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Variables don't have id, an id belongs to an object.
Integers e.g.: 10,9 are <strong>separate</strong> and <strong>immutable</strong> objects, 'a','b' variables are references only. id(a) really gives the id of the referenced object. The object '10' can not be mutated in place.</p>
<pre><code>id(10), id(9)
Out[16]: (10943296, 10943264)

In [17]: a,b=10,10

In [18]: id(a),id(b)
Out[18]: (10943296, 10943296)

In [19]: b=a-1

In [20]: id(b)==id(9)
Out[20]: True
</code></pre>
<p>However, lists are mutable objects and can be changed in place with the [:] operator (and of course, with their methods,e.g.: append,extend):</p>
<pre><code>l=[10,5]

In [29]: id(l),id(l[0]),id(l[1])
Out[29]: (139638954619720, 10943296, 10943136)

In [30]: id(l[0])==id(10)
Out[30]: True

In [31]: l=[10,5]  # a new list object created, though the content is the same

In [32]: id(l)
Out[32]: 139638920490248

In [33]: l[:]=["a","b"]  # in place changes

In [34]: id(l)
Out[34]: 139638920490248
</code></pre>
</div>
<span class="comment-copy"><code>int</code> objects are immutable. the augmented assignment operator <code>-=</code> actually creates a new <code>int</code> object and assigns it to <code>b</code>. (CPython implementation detail: small integers are cached)</span>
