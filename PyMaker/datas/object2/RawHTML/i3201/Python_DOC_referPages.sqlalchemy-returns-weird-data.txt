<div class="post-text" itemprop="text">
<p>I am trying to export a date from a table. I want to just pull the raw created object out.</p>
<p>I am running the query below:</p>
<pre><code>return model.Session.query(cls).filter(cls.issue_id == issue_id).order_by(desc("created")).first()
</code></pre>
<p>But it returns the entire record as so and I have no idea how to export created out.</p>
<pre><code>&lt;IssueComment id=32 comment=ay user_id=578042a3-d879-4b32-96a9-10f9aabe152c issue_id=19 created=2018-07-17 20:17:09.653809 visibility=visible abuse_status=0&gt;
</code></pre>
<p>If i try calling created in cls.created as so</p>
<pre><code>return model.Session.query(cls.created).filter(cls.issue_id == issue_id).order_by(desc("created")).first()
</code></pre>
<p>and it exports a weird datetime version. I just want the raw version</p>
<pre><code>(datetime.datetime(2018, 7, 17, 20, 17, 9, 653809),)
</code></pre>
<p>How can i export the value for created out as the raw string?</p>
</div>
<div class="post-text" itemprop="text">
<p>SqlAlchemy queries for attributes (as opposed to the entire model) return <a href="http://docs.sqlalchemy.org/en/latest/orm/query.html#sqlalchemy.util.KeyedTuple" rel="nofollow noreferrer"><code>KeyedTuples</code></a> which behave like a <a href="https://docs.python.org/3.7/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a>. Like normal Python tuples, a <a href="https://docs.python.org/3.7/library/stdtypes.html#tuple" rel="nofollow noreferrer">tuple</a> with a single element is constructed by a trailing comma.  This is why your result <code>(datetime.datetime(2018, 7, 17, 20, 17, 9, 653809),)</code> shows the datetime object followed by a comma.</p>
<pre><code>&gt;&gt;&gt; row = session.query(User.creation_timestamp).first()
&gt;&gt;&gt; row
(datetime.datetime(2018, 4, 22, 9, 20, 56),)  # &lt;- trailing comma because it's a tuple
</code></pre>
<p>Values can be accessed by index</p>
<pre><code>&gt;&gt;&gt; row[0]
datetime.datetime(2018, 4, 22, 9, 20, 56)
</code></pre>
<p>Or by name</p>
<pre><code>&gt;&gt;&gt; row.creation_timestamp
datetime.datetime(2018, 4, 22, 9, 20, 56)
</code></pre>
<p>The values are python objects with all their usual methods</p>
<pre><code>&gt;&gt;&gt; row.creation_timestamp.isoformat()
'2018-04-22T09:20:56'
&gt;&gt;&gt; str(row.creation_timestamp)
'2018-04-22 09:20:56'
</code></pre>
<p>It is a little confusing that the <a href="http://docs.sqlalchemy.org/en/latest/orm/tutorial.html#returning-lists-and-scalars" rel="nofollow noreferrer">tutorial</a> says that <code>.first()</code> </p>
<blockquote>
<p>applies a limit of one and returns the first result as a scalar</p>
</blockquote>
<p>and the example shows a single object being returned, like this:</p>
<pre><code>&gt;&gt;&gt; q = session.query(User).first()
&gt;&gt;&gt; q
&lt;User object at 0x7f97d8c6b590&gt;
</code></pre>
<p>whereas calling first on your query by attribute returns a value wrapped in a tuple.  It makes sense if you consider the tuple to be a row in the resultset.  If you called <code>.all()</code> on your query you would get a list of tuples (rows).  If you called <code>.limit(1).all()</code> on your query you would get a list containing a single tuple.  So when you call <code>.first()</code> you are getting the first result from <code>.limit(1).all()</code>, which is a tuple.</p>
<pre><code>&gt;&gt;&gt; row = session.query(User.creation_timestamp).all()
&gt;&gt;&gt; row
[(datetime.datetime(2018, 4, 22, 9, 20, 56),), (datetime.datetime(2018, 4, 22, 9, 20, 56),), ...]

&gt;&gt;&gt; row = session.query(User.creation_timestamp).limit(1).all()
&gt;&gt;&gt; row
[(datetime.datetime(2018, 4, 22, 9, 20, 56),)]

&gt;&gt;&gt; row = session.query(User.creation_timestamp).first()
&gt;&gt;&gt; row
(datetime.datetime(2018, 4, 22, 9, 20, 56),)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the column is a datetime column, the raw value isn't a string, it's… well, a datetime.</p>
<p>In most database engines, under the covers, the <em>actual</em> raw value stored in the database for datetime columns is some kind of number. For example, IIRC, in Microsoft SQL Server, it's a 64-bit integer of decimicroseconds since 1901. But you don't want that number. What would you do with it?</p>
<p>If you want a string in some particular format, you can of course ask the database to format it for you to whatever string formats it accepts, but why? </p>
<p>Your engine and/or SQLAlchemy has represented the datetime value as a Python <a href="https://docs.python.org/3/library/datetime.html#datetime-objects" rel="nofollow noreferrer"><code>datetime</code></a> object. That's smaller, faster to pass over the wire from the database, and more flexible (e.g., you can do comparisons and arithmetic with them) than a string.</p>
<p>And you can always format it to whatever string format you want. For example:</p>
<pre><code>&gt;&gt;&gt; d = datetime.datetime(2018, 7, 17, 20, 17, 9, 653809)
&gt;&gt;&gt; str(d)
'2018-07-17 20:17:09.653809'
&gt;&gt;&gt; d.isoformat()
'2018-07-17T20:17:09.653809'
&gt;&gt;&gt; d.strftime('%Y%m%d%H%M%S')
'20180717201709'
&gt;&gt;&gt; d.strftime('%m/%d/%Y %I:%M %p%S')
'07/17/18 08:18 PM'
</code></pre>
<p>… and so on.</p>
</div>
<span class="comment-copy">There is nothing <i>weird</i> about what your query returns, it's just a normal <code>datetime</code> object, and that is part of the Python standard library.</span>
<span class="comment-copy">Does <code>(datetime.datetime(2018, 7, 17, 20, 17, 9, 653809),)</code> look right to you?</span>
<span class="comment-copy">Yes. You're missing the fact that you also get tuples back from queries, regardless of the data type it contains. You need to take the 0th index and you have a perfectly normal datetime object.</span>
<span class="comment-copy">In addition to the great answers you're already given,  if you want a single <code>datetime</code>, you can use <code>Query.scalar()</code> instead of <code>Query.first()</code> in the latter single attribute query. It fetches the first column of the first row for you, compared to fetching the first row, which you seem to have been confused about.</span>
<span class="comment-copy">The problem is even if i do str(d) it still returns <code>(datetime.datetime(2018, 7, 17, 20, 17, 9, 653809),)</code> which isnt even formatted correctly.</span>
