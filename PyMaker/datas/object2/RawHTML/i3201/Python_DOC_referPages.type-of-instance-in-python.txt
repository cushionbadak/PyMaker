<div class="post-text" itemprop="text">
<p>I came across this piece of code, and I am surprised that it adds an element to the list.</p>
<p>Here's the code: </p>
<pre><code>class Wrapper:
    def __init__(self, object):
        self.wrapped = object
    def __getattr__(self,attrname):
        print('Trace: '+attrname)
        return getattr(self.wrapped,attrname)

X = Wrapper([1,2,3])
X.append(4)
print(X.wrapped)
</code></pre>
<p>I am surprised because if I run <code>type(X)</code>, I get <code>__main__.Wrapper</code>, which makes sense because <code>X</code> is an object of class <code>Wrapper</code>. Hence, I am unsure why <code>X.append</code> adds to the list in the attribute <code>wrapped</code> directly. After all, the type of <code>X</code> isn't <code>list</code> but <code>Wrapper.</code></p>
<p>Shouldn't the call have been <code>X.wrapped.append(4)</code>? This works as well. </p>
<p>I am a beginner, and this might be a basic question. I'd appreciate any thoughts, and thanks for any help.</p>
<hr/>
<p>This code was adopted from Mark Lutz's book. I am using Anaconda 3.6 distribution</p>
</div>
<div class="post-text" itemprop="text">
<p>This class is just adding a print statement before the original attribute of the object is accessed.</p>
<p>To understand how this works, you have to understand a bit about what <code>__getattr__</code> does. The documentation for these methods is under the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">data model section</a> of the Python manual:</p>
<blockquote>
<p>Called when the default attribute access fails with an <code>AttributeError</code>
  (either <code>__getattribute__()</code> raises an <code>AttributeError</code> because name is
  not an instance attribute or an attribute in the class tree for self;
  or <code>__get__()</code> of a name property raises <code>AttributeError</code>). This method
  should either return the (computed) attribute value or raise an
  <code>AttributeError</code> exception.</p>
</blockquote>
<p>The <code>.</code> (dot) operator is really a search or lookup operator, when you write a statement like this:</p>
<pre><code>foo.append(x)
</code></pre>
<p>You and I understand this to mean "call the append method of the foo object, with the argument x" - Python is trying to search for an attribute "append" on the foo object, then trying to call it with an argument of <em>x</em>.</p>
<p>In the custom object, we don't have an <code>append</code> attribute, which triggers the <code>__getattr__</code> call. </p>
<p>We then intercept this call to <code>__getattr__</code>, print out a debug statement, and then pass on this call to the actual object (a reference to it is in <code>self.wrapped</code>).</p>
<p>In short, we are saying - hey - we understand that our wrapper object doesn't have this property, but <em>try and see if the wrapped object does</em>, by calling its <code>__getattr__</code> instead.</p>
<p>This concept of passing along the call up the chain allows flexibility in that we mimic what the original (wrapped) object would do - making our wrapper very generic. It would work even if you passed in a string or any other Python object.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3.5/reference/datamodel.html?highlight=__getattr__#customizing-attribute-access" rel="nofollow noreferrer"><code>__getattr__</code></a> is an operator overload <a href="https://dbader.org/blog/python-dunder-methods" rel="nofollow noreferrer">magic method</a> for the <a href="https://docs.python.org/3.5/reference/expressions.html?highlight=attribute%20reference#operator-precedence" rel="nofollow noreferrer">attribute reference <code>.</code> operator</a>. There are several other ways to do this, like <a href="https://docs.python.org/3.5/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a> for single attributes or <code>__getattribute__</code> that overrides even existing attributes.</p>
</div>
<span class="comment-copy">The existing call is <code>X.__getattr__('append')(4)</code>.</span>
<span class="comment-copy">Firstly, <code>Object</code> is a built-in name. Don't use it as your variable names. Secondly, It's because <code>self.wrapped</code> is a list and <code>__getattr__</code> is calling the <code>list</code>'s <code>append</code> method.</span>
