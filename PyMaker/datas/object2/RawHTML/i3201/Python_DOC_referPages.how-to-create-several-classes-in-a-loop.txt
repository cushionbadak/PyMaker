<div class="post-text" itemprop="text">
<p>I have a script, where I have to define several classes:</p>
<pre><code>class track1:
    number = 0
    min_class = 0
    members = []

class track2:
    number = 0
    min_class = 0
    members = []

class track3:
    number = 0
    min_class = 0
    members = []
</code></pre>
<p>And so on...</p>
<p>Later I change in some classes the values. For example: min_class will be 10 in the classes 2,5 and 6. Or the members list will contain different members in every different track.</p>
<p>But sometimes I have to define four classes, sometimes 16.</p>
<p>So my question is: Is there a way, to define classes in Python in a loop?</p>
<pre><code>for i in range(x):
    #define class track i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type</code></a> function to dynamically create classes.</p>
<pre><code>track = []
for i in range(x):
    track.append(type('track%d' % i, (), {'number': 0, 'min_class': 0, 'members': []}))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes - this can be done. The only strange part is to force the classes created dynamically to actually have a name in the module - although it can be done by writting to the <code>globals()</code> dictionary.</p>
<p>Anyway, what creates a class dynamically in Python is a call to <code>type</code>: the class of which classes are instances.</p>
<p>So, a simple way there, if the classes have all the same body, is to create a Base class for all of then, and then you could do at module level:</p>
<pre><code>class Base:
    attributes = 0
    ...

for i in range(16):
    globals()[f'class{i}'] = type(f'class{i}', (Base,), {})
</code></pre>
<p>Depending on what how you intend your code to be read, if the name is the only issue, you could just write a for loop, and declare the class inside it as well, just taking care of the name - creating a class with a <code>class</code> kewyord block and using <code>type</code> are equivalent (but for static analysis tools, like autocompleters used by IDEs - this stuff will get lost eitherway)</p>
<pre><code>for i in range(16):
    class Base:
        attributes = []
        ...
    Base.__name__ = f"class{i}"
    globals()[f"class{i}"] = Base
</code></pre>
<p>However, as I stated in the very beggining, it is not usual to dynamically create variables in Python code - and by variables here, I mean anything with a static name , including functions and classes - if you are typing the hardcoded name of such a class in another ".py"  file, it should be typed hardcoded here. 
So, if your classes are to be used dymically, let's say some other code have to select an specific class of these based on some other data, it is not conveninent they are bound to the module as "class1, class2", etc... rather, they should be part of another data structures, such as a list or dictionary  - let's suppose you want one such class depending on a "product category" some other part of the code would have - You could just as well create a dicionary whose keys are product categories, and the values the classes. 
Or, to keep things simple, let's just do a list:</p>
<pre><code>myclasses = []
for i in range(16):
    myclasses.append(type(f"class{i}", (Base,), {})
</code></pre>
<p>(The form with the class body is valid as well, the only difference is that you don't assign your generated classes to the dict in <code>globals()</code> , and rather, to another data structure.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your class <em>definitions</em> are identical.
Why not have one class definition:</p>
<pre><code>class track:
    number = 0
    min_class = 0
    members = []
</code></pre>
<p>and then create as many <em>instances</em> as you need?</p>
<pre><code>L = []
for i in range(x):
    L.append(track())
</code></pre>
<p>Now, you possibly want the class members to be instance members, so need to use <code>self</code> appropriately.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've created your class <code>trackX</code> multiple times, however you need to create instances of one class:</p>
<pre><code>class Track:
  number = 0
  min_class = 0
  members = []
  def __init__(number, min_class, members):
      self.number = number
      self.min_class = min_class
      self.members = members
</code></pre>
<p>Then in your loop you want to create instances of your class:</p>
<pre><code>for i in range(x):
    track = Track(number, min_class, members)
</code></pre>
<p>If you want a list of tracks just append this track to your list of tracks:</p>
<pre><code> tracks = []
 for i in range(x):
    track = Track(number, min_class, members)
    tracks.append(track)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A large part of design and programming is avoiding or removing duplication.</p>
<p>This is what you are trying to do, so that's a good start.</p>
<p>However, the only thing that varies is the name of the class, which seems a strange thing to need.</p>
<p>When you instantiate the classes there will essentially be no other difference between the object types.</p>
<p>In design you want to encapsulate what stays the same (a class or algorithm for example), and parameterize it with what varies (data).</p>
<p>I'd advise you to parameterize the object constructor with the track name:</p>
<pre><code>class Track:
    def init(name, number, min_class, members):
        self.name = name
        self.number = number
        self.min_class = min_class
        self.members = members
</code></pre>
</div>
<span class="comment-copy"><a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">What is the XY Problem?</a></span>
<span class="comment-copy">Do you need to generate (identical) class definitions? Or want lots of instances? Why do you need a class - as it stands you could make tuples (maybe named ones) in a loop.</span>
<span class="comment-copy">If you need different values for each <code>track</code> you need different instances of the <i>same</i> class.</span>
<span class="comment-copy">from the 6 current answers, this is the other one besdes the more complete I spelled out that is actually correct. Yet it is the one to get a downvote. Go figure those stack-overflowers?</span>
<span class="comment-copy">thanks, you helped me a lot</span>
<span class="comment-copy">this creates instances, not classes.  It is not what is asked - though the person may be focusing on the wrong problem.</span>
<span class="comment-copy">True, though your comment has an <code>if</code> - I was hoping to flush out a more specific question by answering and will delete my answer if the question changes.</span>
<span class="comment-copy">Even with this answer, multiple instances would all share the same values</span>
<span class="comment-copy">@cricket_007 the integers are immutable so that's not a problem. Modifying <code>members</code> would lead to more questions (c:</span>
<span class="comment-copy">@PeterWood I didn't see any mention about modifying the variables <code>¯\_(ツ)_/¯</code></span>
<span class="comment-copy">If the OP needs classes, he needs classes, not instances - you could question him in the comments if he is taking the correct approach, but this is an incorrect answer to the question as it is.</span>
<span class="comment-copy">Why do you have class and instance members?</span>
