<div class="post-text" itemprop="text">
<p>For example, I have a basic method that will return a list of permutations.</p>
<pre><code>import itertools
def perms(elements,setLength=elements):
    data=[]
    for x in range(elements):
        data.append(x+1)
    return(list(itertools.permutations(data,setLength)))
</code></pre>
<p>Now I understand, that in its current state this code won't run because the second <code>elements</code> isn't defined, but is there and elegant way to accomplish what I'm trying to do here? If that's still not clear, I want to make the default <code>setLength</code> value equal to the first argument passed in. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, function keyword parameter defaults are determined when the function is <em>defined</em>, not when the function is executed.</p>
<p>Set the default to <code>None</code> and detect that:</p>
<pre><code>def perms(elements, setLength=None):
    if setLength is None:
        setLength = elements
</code></pre>
<p>If you need to be able to specify <code>None</code> as a argument, use a different sentinel value:</p>
<pre><code>_sentinel = object()

def perms(elements, setLength=_sentinel):
    if setLength is _sentinel:
        setLength = elements
</code></pre>
<p>Now callers can set <code>setLength</code> to <code>None</code> and it won't be seen as the default.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because of the way Python handles bindings and default parameters...</p>
<p>The standard way is:</p>
<pre><code>def perms(elements, setLength=None):
    if setLength is None:
        setLength = elements
</code></pre>
<p>And another option is:</p>
<pre><code>def perms(elements, **kwargs):
    setLength = kwargs.pop('setLength', elements)
</code></pre>
<p>Although this requires you to explicitly use <code>perms(elements, setLength='something else')</code> if you don't want a default...</p>
</div>
<div class="post-text" itemprop="text">
<p>You should do something like :</p>
<pre><code>def perms(elements,setLength=None):
    if setLength is None:
        setLength = elements
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Answer 1:</h2>
<p>The solution from above looks like this:</p>
<pre class="lang-py prettyprint-override"><code>def cast_to_string_concat(a, b, c=None):
  c = a if c is None else c

  return str(a) + str(b) + str(c)
</code></pre>
<p>While this approach will solve a myriad of potential problems, (and maybe yours)! I wanted to write a function where a possible input for variable "<code>c</code>" is indeed the singleton <code>None</code>, so I had to do more digging. </p>
<p>To explain that further, calling the function with the following variables:</p>
<pre class="lang-py prettyprint-override"><code>A='A'
B='B'
my_var = None
</code></pre>
<p>Yields:</p>
<pre><code>cast_to_string_concat(A, B, my_var):
&gt;&gt;&gt;'ABA'
</code></pre>
<p>Whereas the user might expect that since they called the function with three variables, then it should print the three variables, like this:</p>
<pre class="lang-py prettyprint-override"><code>cast_to_string_concat(A, B, my_var):
&gt;&gt;&gt; 'ABNone' # simulated and expected outcome
</code></pre>
<p>So, this implementation ignores the third variable, even when it was declared, so this means the function no longer has the ability to determine whether or not variable "<code>c</code>" was defined. </p>
<p>So, for my use case, a default value of <code>None</code> would not quite do the trick. </p>
<p>For the answers that suggest this solution, read these:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/17157272/is-there-a-way-to-set-a-default-parameter-equal-to-another-parameter-value">Is there a way to set a default parameter equal to another parameter value?</a></li>
<li><a href="https://stackoverflow.com/questions/54791015/python-shortcut-for-variable-default-value-to-be-another-variable-value-if-it-is">Python shortcut for variable default value to be another variable value if it is None</a></li>
<li><a href="https://stackoverflow.com/questions/33527745/function-arguments-default-value-equal-to-another-argument">Function argument's default value equal to another argument</a></li>
<li><a href="https://stackoverflow.com/questions/366422/what-is-the-pythonic-way-to-avoid-default-parameters-that-are-empty-lists?noredirect=1&amp;lq=1">What is the pythonic way to avoid default parameters that are empty lists?</a></li>
</ul>
<hr/>
<p>But, if that doesn't work for you, then maybe keep reading!</p>
<hr/>
<p>A comment in the first link above mentions using a <code>_sentinel</code> defined by <code>object()</code>. </p>
<p>So this solution removes the use of a None, and replaces it with the <code>object()</code> through using the <a href="https://www.geeksforgeeks.org/private-variables-python/" rel="nofollow noreferrer">implied</a> private <code>sentinel</code>.</p>
<hr/>
<h2>Answer 2:</h2>
<pre class="lang-py prettyprint-override"><code>_sentinel = object()
def cast_to_string_concat(a, b, c=_sentinel):
  c = a if c == _sentinel else c

  return str(a) + str(b) + str(c)
</code></pre>
<pre class="lang-py prettyprint-override"><code>A='A'
B='B'
C='C'

cast_to_string_append(A,B,C)
&gt;&gt;&gt; 'ABC'

cast_to_string_concat(A,B)
&gt;&gt;&gt; 'ABA'
</code></pre>
<hr/>
<p>So this is pretty awesome! It correctly handles the above edge case! See for yourself:</p>
<hr/>
<pre class="lang-py prettyprint-override"><code>A='A'
B='B'
C = None

cast_to_string_concat(A, B, C)
&gt;&gt;&gt; 'ABNone'
</code></pre>
<p>So, we're done, right? Is there any plausible way that this might not work? Hmm... probably not! But I did say this was a three-part answer, so onward! ;)</p>
<hr/>
<p>For the sake of completeness, let's imagine our program operates in a space where every possible scenario is indeed possible. (This may not be a warranted assumption, but I imagine that one could derive the value of <code>_sentinel</code> with enough information about the computer's architecture and the implementation of the choice of the object. So, if you are willing, let us assume that is indeed possible, and let's imagine we decide to test that hypothesis referencing <code>_sentinel</code> as defined above.</p>
<hr/>
<pre><code>_sentinel = object()
def cast_to_string_concat(a, b, c=_sentinel):
  c = a if c == _sentinel else c

  return str(a) + str(b) + str(c)
</code></pre>
<pre><code>A='A'
B='B'
S = _sentinel

cast_to_string_append(A,B,S)
&gt;&gt;&gt; 'ABA'
</code></pre>
<hr/>
<p>Wait a minute! I entered three arguments, so I should see the string concatenation of the three of them together! </p>
<hr/>
<p><em>*queue entering the land of unforeseen consequences*</em></p>
<p>I mean, not actually. A response of: "That's negligible edge case territory!!" or its ilk is perfectly warranted.</p>
<p>And that sentiment is right! For this case (and probably most cases) this is really not worth worrying about! </p>
<p>But if it is worth worrying about, or if you just want the mathematical satisfaction of eliminating all edge cases you're aware of ... onward!</p>
<blockquote>
<p>Exercise left to reader: </p>
<blockquote>
<p>Deviating from this technique, you can directly assert <code>c=object()</code>, however, in honesty, I haven't gotten that way to work for me. My investigation shows <code>c == object()</code> is <code>False</code>, and <code>str(c) == str(object())</code> is also <code>False</code>, and that's why I'm using the implementation from <a href="https://stackoverflow.com/a/17157303/10583199">Martin Pieters</a>.</p>
</blockquote>
</blockquote>
<hr/>
<p><strong>Okay, after that long exercise, we're back!</strong></p>
<p>Recall the goal is to write a function that could potentially have <code>n</code> inputs, and only when one variable is not provided - then you will copy another variable in position <code>i</code>. </p>
<p>Instead of defining the variable by default, what if we change the approach to allow an arbitrary number of variables?</p>
<p>So if you're looking for a solution that does not compromise on potential inputs, where a valid input could be either <code>None</code>, <code>object()</code>, or <code>_sentinel</code> ... then (and only then), at this point, I'm thinking my solution will be helpful. The inspiration for the technique came from the <a href="https://stackoverflow.com/a/17157298/10583199">second part of Jon Clements' answer</a>.</p>
<hr/>
<h2>Answer 3:</h2>
<p>My solution to this problem is to change the naming of this function, and  <em>wrap</em> this function with a a function of the previous naming convention, but instead of using variables, we use <code>*args</code>. You then define the original function within the local scope (with the new name), and only allow the few possibilities you desire.</p>
<p>In steps:</p>
<ol>
<li>Rename function to something similar</li>
<li>Remove the default setup for your optional parameter</li>
<li>Begin to create a new function just above and tab the original function in.</li>
</ol>
<pre class="lang-py prettyprint-override"><code> def cast_to_string_concat(*args):
</code></pre>
<ol start="4">
<li>Determine the the <em>arity</em> of your function - (I found that word in my search... that is the number of the parameters passed into a given function)</li>
<li>Utilize a case statement inside that determines if you entered a valid number of variables, and adjust accordingly!</li>
</ol>
<pre class="lang-py prettyprint-override"><code>def cast_to_string_append(*args):

    def string_append(a, b, c):
        # this is the original function, it is only called within the wrapper
        return str(a) + str(b) + str(c)

    if len(args) == 2:
        # if two arguments, then set the third to be the first
        return string_append(*args, args[0])

    elif len(args) == 3:
        # if three arguments, then call the function as written
        return string_append(*args)

    else:
        raise Exception(f'Function: cast_to_string_append() accepts two or three arguments, and you entered {len(args)}.')

</code></pre>
<pre><code># instantiation

A='A'
B='B'
C='C'
D='D'

_sentinel = object()
S = _sentinel

N = None
</code></pre>
<pre class="lang-py prettyprint-override"><code>""" Answer 3 Testing """

# two variables

cast_to_string_append(A,B)

&gt;&gt;&gt; 'ABA'


# three variables

cast_to_string_append(A,B,C)

&gt;&gt;&gt; 'ABC'


# three variables, one is _sentinel

cast_to_string_append(A,B,S)

&gt;&gt;&gt;'AB&lt;object object at 0x10c56f560&gt;'


# three variables, one is None

cast_to_string_append(A,B,N)

&gt;&gt;&gt;'ABNone'


# one variable

cast_to_string_append(A)

&gt;&gt;&gt;Traceback (most recent call last):
&gt;&gt;&gt;  File "&lt;input&gt;", line 1, in &lt;module&gt;
&gt;&gt;&gt;  File "&lt;input&gt;", line 13, in cast_to_string_append
&gt;&gt;&gt;Exception: Function: cast_to_string_append() accepts two or three arguments, and you entered 1.

# four variables

cast_to_string_append(A,B,C,D)

&gt;&gt;&gt;Traceback (most recent call last):
&gt;&gt;&gt;  File "&lt;input&gt;", line 1, in &lt;module&gt;
&gt;&gt;&gt;  File "&lt;input&gt;", line 13, in cast_to_string_append
&gt;&gt;&gt;Exception: Function: cast_to_string_append() accepts two or three arguments, and you entered 4.


# ten variables

cast_to_string_append(0,1,2,3,4,5,6,7,8,9)

&gt;&gt;&gt;Traceback (most recent call last):
&gt;&gt;&gt;  File "&lt;input&gt;", line 1, in &lt;module&gt;
&gt;&gt;&gt;  File "&lt;input&gt;", line 13, in cast_to_string_append
&gt;&gt;&gt;Exception: Function: cast_to_string_append() accepts two or three arguments, and you entered 10.


# no variables

cast_to_string_append()

&gt;&gt;&gt;Traceback (most recent call last):
&gt;&gt;&gt;  File "&lt;input&gt;", line 1, in &lt;module&gt;
&gt;&gt;&gt;  File "&lt;input&gt;", line 13, in cast_to_string_append
&gt;&gt;&gt;Exception: Function: cast_to_string_append() accepts two or three arguments, and you entered 0.

""" End Answer 3 Testing """
</code></pre>
<hr/>
<h2>So, in summary:</h2>
<ul>
<li><strong>Answer 1</strong> - the simplest answer, and works for most cases.</li>
</ul>
<pre class="lang-py prettyprint-override"><code>def cast_to_string_concat(a, b, c=None):
  c = a if c is None else c

  return str(a) + str(b) + str(c)
</code></pre>
<ul>
<li><strong>Answer 2</strong> - use if <code>None</code> does not actually signify an empty parameter by switching to <code>object()</code> , through <code>_sentinel</code> .</li>
</ul>
<pre class="lang-py prettyprint-override"><code>_sentinel = object()
def cast_to_string_concat(a, b, c=_sentinel):
  c = a if c == _sentinel else c

  return str(a) + str(b) + str(c)
</code></pre>
<ul>
<li><strong>Answer 3</strong> seeks out a general solution utilizing a wrapper function with arbitrary arity using <code>*args</code>, and handles the acceptable cases inside:</li>
</ul>
<pre class="lang-py prettyprint-override"><code>def cast_to_string_append(*args):

    def string_append(a, b, c):
        # this is the original function, it is only called within the wrapper
        return str(a) + str(b) + str(c)

    if len(args) == 2:
        # if two arguments, then set the third to be the first
        return string_append(*args, args[0])

    elif len(args) == 3:
        # if three arguments, then call the function as written
        return string_append(*args)

    else:
        raise Exception(f'Function: cast_to_string_append() accepts two or three arguments, and you entered {len(args)}.')

</code></pre>
<p>Use what works for you! But for me, I'll be using Option 3 ;)</p>
</div>
<span class="comment-copy">It seems like 3 people agree on the solution. Please also have a look at the "Important warning" on <a href="http://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">docs.python.org/3/tutorial/â€¦</a></span>
