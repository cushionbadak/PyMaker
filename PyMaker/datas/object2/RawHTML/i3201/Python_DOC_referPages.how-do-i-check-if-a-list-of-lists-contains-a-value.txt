<div class="post-text" itemprop="text">
<p>I'm trying to get my program to repeat an operation on a list of lists until there are no zeroes in the entire thing. I decided to go with seventy lists of ninety zeroes each (this is being used for a maze generator).</p>
<pre><code>x=int(input("How many columns?\n"))
y=int(input("How many rows?\n"))
maze=[[0]*x for n in range(y)]
</code></pre>
<p>So with the inputs 90 and 70, there should be a total of 6300 zeroes. However, when I use</p>
<pre><code>while 0 in maze[:]:
    #stuff
</code></pre>
<p>...the loop ends instantly without doing anything. I've also tried</p>
<pre><code>while 0 in maze:
    #stuff
</code></pre>
<p>It's like Python completely ignores every single one of the six thousand three hundred zeroes in the maze list. I know of a way to fix this, but it involves slowly scrolling through the range of y values for every iteration. Is there a simpler way that allows it to look at all of the sublists in one line?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>any()</code> function together with a generator expression:</p>
<pre><code>while any(0 in sublist for sublist in maze):
    # do stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you could use <code>numpy</code> array to do what you want. The <code>in</code> operator will not find <code>0</code> in your list of lists, bu would work as intended with numpy.</p>
<p>Minimal and verifiable example:</p>
<pre><code>x = [[0,0,0,1], [1,2,3,1]]
&gt;&gt;&gt; 0 in x
False

np_x = np.array(x)
&gt;&gt;&gt; 0 in np_x
True
</code></pre>
<hr/>
<p><em>Why <code>0 in x</code> won't work?</em> </p>
<p>Because <code>x</code> holds lots of objects of type <code>list</code>, and an object of type <code>list</code> will not be equal to <code>0</code> in any occasion. The <code>in</code> operator will not dig in to deepest level of your list to find out if there are zeroes there or not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Checking if 0 exists in a 2-D matrix is always going to cost O(n*m), which is rather inefficient especially since your loop is going to iterate many times.</p>
<p>For your purpose I would suggest that you simply use a counter and increment it whenever your operation inside the loop sets an item of 0 to a non-0 value, so that you can use something like this as a condition for the <code>while</code> loop:</p>
<pre><code>while counter &lt; x * y:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>0</code> is <code>False</code> in Boolean and all the items in <code>maze</code> are going to be numbers, you can use this instead:</p>
<pre><code>while not all(map(all, maze)):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Numpy does not convert it to array if your sub-lists have different sizes</p>
<p>So, you'd better unravel your list: </p>
<pre><code>x = [[0,0,0,1], [1,2,3,1,4,3,22,-4]]
x_flat = [val for sublist in x for val in sublist]
0 in x_flat 
&gt;&gt; True 
</code></pre>
</div>
<span class="comment-copy">Because 0 is not in maza, [0]*x is in, so it instantly break from the while function.... I suggest you use while True..</span>
<span class="comment-copy">There is a simpler way that doesn’t involve “y values”, but it’s just as slow from a performance standpoint. (You have a list of lists, so you need to do the <code>in</code> check on every list, and you can do that with <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a>.) Maybe you can keep a count of how many zeros remain instead, decrementing it in <code>#stuff</code> when appropriate?</span>
<span class="comment-copy"><code>maze</code> is a list of lists. So there is no <code>0</code> there, only some objects of type <code>list</code>. However, inside <i>those</i> objects of type <code>list</code> you'll find some zeroes</span>
<span class="comment-copy"><code>while 0 in maze:</code> doesn't work because maze does not contain <code>0</code> as a direct element.   <code>while 0 in maze[:]:</code>  creates an identical copy of maze and looks at the copy, so the outcome is the same.</span>
