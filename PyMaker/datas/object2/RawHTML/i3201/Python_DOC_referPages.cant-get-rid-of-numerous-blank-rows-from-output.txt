<div class="post-text" itemprop="text">
<p>I've written a script in python in combination with selenium to get some information from a webpage. To reach the content it is necessary to click on the <code>+</code> sign next to each name within the larger table. When clicking on those <code>+</code> sign is done, all the table connected to each name shows up. My script can do it very efficiently. However, the next step is to parse those tabular data. This is where I'm stuck with messy content. The data of each table are getting parsed but lots of blank rows come along out of nowhere. </p>
<p>How can I kick out those blank rows and keep on parsing only those tabular data?</p>
<p><a href="http://agmarknet.gov.in/MarketProfile/MarketProfile.aspx" rel="nofollow noreferrer"><strong><em>link to that site</em></strong></a></p>
<p>This is my script:</p>
<pre><code>from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

url = "replace with above link"

def get_info(driver,link):
    driver.get(link)
    for items in wait.until(EC.presence_of_all_elements_located((By.CSS_SELECTOR,"table.tableagmark img[style^='cursor:']"))):
        items.location
        items.click()
        wait.until(EC.invisibility_of_element_located((By.CSS_SELECTOR,"table[style='font-size:16px;']")))
    fetch_table()

def fetch_table():
    for items in wait.until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, "table[style='font-size:16px;'] tr"))):
        data = [item.text for item in items.find_elements_by_css_selector("td")]
        print(data)

if __name__ == '__main__':
    driver = webdriver.Chrome()
    wait = WebDriverWait(driver,10)
    try:
        get_info(driver,url)
    finally:
        driver.quit()
</code></pre>
<p>This is how the output looks like (before and after each tabular content):</p>
<pre><code>['', '']
['', '']
['', '']
['', '']
['', '']
['', '']
['', '']
['', '']
['', '']
['', '']
[]
['Achanta', 'Apr 16 2018 11:24AM']
['Addanki', 'Apr 13 2018 6:00PM']
['Adoni', 'Apr 18 2018 12:17PM']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can skip handling empty text nodes with some kind of filtering and save much time just by using correct selectors:</p>
<pre><code>def get_info(driver,link):
    driver.get(link)
    for items in wait.until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, "img[src='../images/plus.png']"))):
        items.click()
    fetch_table()

def fetch_table():
    for items in wait.until(EC.presence_of_all_elements_located((By.XPATH, "//td/table//tr[not(th)]"))):
        data = [item.text for item in items.find_elements_by_css_selector("td")]
        print(data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're just asking how to now print out the all-empty results, you can just write a loop that filters them. Assuming each line is a single <code>data</code> valueâ€¦</p>
<p>The simplest thing is to use the implicit loop with the implicit bool filter inside <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a>:</p>
<pre><code>if any(data):
    print(data)
</code></pre>
<p><code>any(data)</code> is true for a sequence <code>data</code> if <code>data</code> is not empty, and at least one of the elements of <code>data</code> is truthy. Empty strings are falsey, non-empty strings are truthy. So, this does exactly what you want: it skips over <code>[]</code> and <code>['', '']</code>, but not things like <code>['Achanta', 'Apr 16 2018 11:24AM']</code>.</p>
<p>But if you have a hard time understanding it, it may be better to be more explicit:</p>
<pre><code>for value in data:
    if value:
        print(data)
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming <code>data</code> contains your table, you can use <code>any</code> to filter out
empty rows </p>
<pre><code>non_empty = [row for row in data if any(row)]
</code></pre>
<p>here <code>any</code> returns <code>True</code> if at least one of <code>row</code>'s element is not empty </p>
</div>
<span class="comment-copy">No way!! This is definitely better and I should surely stick to your logic @sir Andersson. Prevention is better than cure. Can you provide me with an <code>xpath</code> or <code>cssselector</code> so that i can differentiate which table (under the name) I'm parsing. To be clearer: if first name is <code>Andhra Pradesh</code>, I expect to parse the name first and then the table connected to it and so on otherwise, it's hard to differentiate.</span>
<span class="comment-copy">Selector is quite simple: <code>//span[starts-with(@id, "cphBody_rptCustomers_lblStateName_")]</code> or <code>[id^="cphBody_rptCustomers_lblStateName_"]</code>, but to be able to extract these values you might need to completely modify the structure of your script...</span>
<span class="comment-copy">Unable to accept your answer until the time is right @abarnert. It just awesomely did the trick. Btw, can you tell me in comment why it happens, I meant the blank rows appearance? Thanks.</span>
<span class="comment-copy">What's the point in <code>(col for col in row)</code>? That just does the same thing as <code>iter(row)</code>, but more complicated and slower, and either way it's unnecessary because <code>any</code> can take a sequence just as well as an iterator.</span>
<span class="comment-copy">Agree, one can simply use <code>any(row)</code>.</span>
