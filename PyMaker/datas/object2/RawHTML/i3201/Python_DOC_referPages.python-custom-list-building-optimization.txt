<div class="post-text" itemprop="text">
<p>I'm programming a genetic algorithm in Python, however, my operator (MMX) takes too long (10 seconds) to execute for individuals with 3 million weights (each individual is a list of 3.000.000 elements).</p>
<p>This is the code for the operator:</p>
<pre><code>def calc_gen(maxel,minel, rec1, rec2, phiC):
    g = maxel - minel
    phi = 0
    if g &gt; phiC:
        # Recta 2
        phi = rec2[0] * g + rec2[1]
    elif g &lt; phiC:
        # Recta 1
        phi = rec1[0] * g + rec1[1]
    #Hay que asegurarse que no nos salimos del rango:
    maxv = min(1, maxel - phi)
    minv = max(0, minel + phi)
    gen1 = random.uniform(minv, maxv)  # Guardar el gen del primer hijo
    # Si C es el centro y A el elemento que ya tenemos y B el simétrico de A: C - A + C = B -&gt; 2C - A = B
    # C = (maxv + minv) / 2; 2C - A = B -&gt; maxv + minv - A = B
    # center = (maxv + minv) / 2
    gen2 = maxv + minv - gen1
    return gen1, gen2
    #return gen1, maxv + minv - gen1

def cxMMX(poblacion, rec1, rec2, phiC):
    start = timer()
    # Calcular el maximo y el minimo de cada gen en toda la población
    max_genes = numpy.amax(poblacion, axis=0).tolist()
    min_genes = numpy.amin(poblacion, axis=0).tolist()
    gis = timer()
    hijo1 = Individual()
    hijo2 = Individual()
    # Iterar dos listas a la vez (zip) con su indice (enumerate). Así crearemos los hijos simultáneamente en un loop
    for i, (maxel, minel) in enumerate(zip(max_genes, min_genes)):
        gen1, gen2 = calc_gen(maxel, minel, rec1, rec2, phiC)
        hijo1.append(gen1)
        hijo2.append(gen2)
    end = timer()
    #print("Tiempo Gi: %f Tiempo init: %f Tiempo calc gen: %f Tiempo mate total: %f" % (gis-start, init-gis, end-init, end-start))
    return [hijo1, hijo2]
</code></pre>
<p>rec1, rec2 and phiC are parameters that determine how the crossover is done, you shouldn't bother about them. They have the same value all across the algorithm.</p>
<p>poblacion is a list of lists, lets say it's shape is [7,3000000].
Individual() is a custom class. It is bassicaly inheriting "list" and adding some attributes to store the fitness value.</p>
<p>Doing numpy.amax and numpy.amin separately seems like doing extra work. Also, there's probably a more pythonic way to do the "calc_gen()" loop.</p>
<p>PD: "gen1" depends on "gen2": gen1 obtained randomly within a range, and then gen2 is obtained looking for the simetrical point.</p>
<p>PD2: A more detailed explanation on MMX operator can be found on the  <a href="https://link.springer.com/chapter/10.1007/3-540-44522-6_73" rel="nofollow noreferrer">original paper</a>, however, you can assume the code is okey and does what it has to do. The doi is <a href="https://doi.org/10.1007/3-540-44522-6_73" rel="nofollow noreferrer">https://doi.org/10.1007/3-540-44522-6_73</a></p>
<p>PD: the enumerate() and the i are there from the old code, forgot to remove them!</p>
<p><strong>EDIT: Reduced 20% time with Dillon Davis's solution. Its a pretty clean solution which will work with any custom list building function, provided you obtain each value of the list by executing one function:</strong></p>
<pre><code>def calc_gen_v2(maxel,minel, rec1m, rec1b, rec2m, rec2b, phiC):
    g = maxel - minel
    phi = 0
    if g &gt; phiC:
        # Recta 2
        phi = rec2m * g + rec2b
    elif g &lt; phiC:
        # Recta 1
        phi = rec1m * g + rec1b
    #Hay que asegurarse que no nos salimos del rango:
    maxv = min(1, maxel - phi)
    minv = max(0, minel + phi)
    gen1 = random.uniform(minv, maxv)  # Guardar el gen del primer hijo
    # Si C es el centro y A el elemento que ya tenemos y B el simétrico de A: C - A + C = B -&gt; 2C - A = B
    # C = (maxv + minv) / 2; 2C - A = B -&gt; maxv + minv - A = B
    # center = (maxv + minv) / 2
    gen2 = maxv + minv - gen1
    return gen1, gen2

def cxMMX_v3(poblacion, rec1, rec2, phiC):
    start = timer()
    # Calcular el maximo y el minimo de cada gen en toda la población
    max_genes = numpy.amax(poblacion, axis=0)
    min_genes = numpy.amin(poblacion, axis=0)
    gis = timer()
    hijo1, hijo2 = map(Individual, numpy.vectorize(calc_gen_v2)(max_genes, min_genes, rec1[0], rec1[1], rec2[0], rec2[1], phiC))
    end = timer()
    #print("Tiempo Gi: %f Tiempo init: %f Tiempo calc gen: %f Tiempo mate total: %f" % (gis-start, init-gis, end-init, end-start))
    return [hijo1, hijo2]
</code></pre>
<p><strong>EDIT 2: As Dillon Davis suggested I implemented it in pure numpy, reducing the time to 3,5 seconds! (65% time save)</strong></p>
<pre><code>def cxMMX_numpy(poblacion, rec1, rec2, phiC):
    # Calculate max and min for every gen in the population
    max_genes = numpy.amax(poblacion, axis=0)
    min_genes = numpy.amin(poblacion, axis=0)
    g_pop = numpy.subtract(max_genes, min_genes)
    phi_pop = numpy.where(g_pop &lt; phiC, numpy.multiply(g_pop, rec1[0]) + rec1[1], numpy.where(g_pop &gt; phiC, numpy.multiply(g_pop, rec2[0]) + rec2[1], 0))
    maxv = numpy.minimum(numpy.subtract(max_genes, phi_pop), 1)
    minv = numpy.maximum(numpy.sum([min_genes, phi_pop], axis=0), 0)
    hijo1 = numpy.random.uniform(low=minv, high=maxv, size=minv.size)
    hijo2 = numpy.subtract(numpy.sum([maxv, minv], axis=0), hijo1)
    return [Individual(hijo1), Individual(hijo2)]
</code></pre>
<p>NOTE: In case you want to reuse, Individual inherits from list</p>
<p>NOTE: if g=phiC then rec1[0] * g_pop + rec1[1]=0, allways, rec1[0] and rec1[1] guarantee that! so maybe it is better to do the math instead of a triple option?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try replacing your for loop in <code>cxMMX()</code> with something like:</p>
<pre><code>hijo1, hijo2 = map(Individual, numpy.vectorize(calc_gen)(max_genes, min_genes, rec1, rec2, phiC))
</code></pre>
<p>and drop the <code>.tolist()</code> from your <code>numpy.amin()</code> and <code>numpy.amax()</code>.</p>
<p>This will vectorize your your calc_gen function, avoid a zip and the function overhead from several <code>.append()</code> calls, and should overall be quite a bit faster.</p>
<p>Edit:</p>
<p>Also consider converting <code>calc_gen()</code> to work directly on the numpy arrays. Replace calls to <code>random.uniform()</code> with <code>numpy.random.uniform()</code>, <code>min()</code> or <code>max()</code> with <code>numpy.minimum()</code> or <code>numpy.maximum()</code>, and then eliminate the for loop / map + vectorize completely. This would ultimately be the fastest option.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried using a <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="nofollow noreferrer"><code>multiprocessing.Pool</code></a>?</p>
<p>You'd need to make a wrapper for <code>calc_gen</code> first:</p>
<pre><code># after calc_gen def
def get_calc_gen(rec1, rec2, phiC):
    return lambda maxel, minel: calc_gen(maxel, minel, rec1, rec2, phiC)
</code></pre>
<p>Then instead of the <code>for</code> loop you'd do something like:</p>
<pre><code># replacing for loop section
cgen = get_calc_gen(rec1, rec2, phiC)
minmax_genes = zip(max_genes, min_genes)
pool = multiprocessing.Pool()
mapped_genes = pool.map(cgen, minmax_genes)
for gen1, gen2 in mapped_genes:
    hijo1.append(gen1)
    hijo2.append(gen2)
</code></pre>
<p>P.S. You don't need <code>enumerate</code> in your original code since you don't seem to be using <code>i</code></p>
</div>
<span class="comment-copy">Did you try to run a Python profiler? I can recommend <a href="https://docs.python.org/3.6/library/profile.html" rel="nofollow noreferrer">docs.python.org/3.6/library/profile.html</a> and <a href="https://github.com/rkern/line_profiler" rel="nofollow noreferrer">github.com/rkern/line_profiler</a>.</span>
<span class="comment-copy">Why are you building lists at all when you have NumPy?</span>
<span class="comment-copy">@user2357112 I use those values to initialize a neural network's weights later. With numpy arrays it takes ages to move the individuals through memory, so I use tolist() so only the references to the lists move trough functions. Maybe I'm doing it wrong anyway, I'm new to Python.</span>
<span class="comment-copy">@KirillBulygin Hello. I did, but I'm new in Python so by now i'm measuring time in the wrong way. I've got 32 threads and the PC is a linux that is just doing that, not even x server loaded, so time() should be a "reliable" measure. I run it 20 times and measure mean and min</span>
<span class="comment-copy">@DGoiko Profiling is used not to measure time reliably (it doesn't because of its overhead) but rather to find out the slowest functions/lines (that are worth to change).</span>
<span class="comment-copy">I used tolist because later I pass the list to different functions, and passing numpy arrays was slower. using my code, removing tolist makes it slower. I'm going to try your solution. Thanks.</span>
<span class="comment-copy">Just implemented it (had to make some modifications in order to pass rec1 and rec2). It reduced 20% of the time so far. Not bad. I'm thinking about how to convert it to numpy, and it looks easy, except for the part if g&lt;phiC do something, elif do another thing. I'll try to convert it tomorrow and post both modifications on the OP. Would you mind to check again if I comment to see if I did it in the proper way? I'm pretty new to Python xD  Thanks. I'll give you a point now.</span>
<span class="comment-copy">Just implemented the pure numpy version, however, I couldn't implement the if/else statement. Could you give it a look? It is now saving 65% of the execution time. Any efficiency tip that comes to your mind for python and numpy would be appreciated aswell.</span>
<span class="comment-copy">Try something like <code>phi_pop = numpy.where(g_pop &lt; phiC, numpy.multiply(g_pop, rec1[0]) + rec1[1], numpy.where(g_pop &gt; phiC, numpy.multiply(g_pop, rec2[0]) + rec2[1], 0))</code></span>
<span class="comment-copy">Works perfectly. I'll have to check if I made any mistakes in the rest of the code, but it looks like everything works as expected. Thank you so much. Marked as accepted answer</span>
<span class="comment-copy">Hello.  I tried it at some point, but it added more overhead than the time it saved on a 2 CPU x8 cores x 2 threads PC</span>
<span class="comment-copy">BTW, I gave you a point. Even if your answer doesnt save me time for this, I was looking forward the way to do something like that, so you helped me anyway.</span>
