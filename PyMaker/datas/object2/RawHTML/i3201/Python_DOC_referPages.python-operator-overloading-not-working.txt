<div class="post-text" itemprop="text">
<p>I have a Vector2 class: </p>
<pre><code>class Vector2():
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector2(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector2(self.x - other.x, self.y - other.y)

    def __mul__(self, other):
        return Vector2(self.x * other, self.y * other)

    def __neg__(self):
        return Vector2(-self.x, -self.y)

    def magnitude(self):
        return math.sqrt(self.x ** 2 + self.y ** 2)

    @classmethod
    def distance(self, v1, v2):
        return math.sqrt((v2.x - v1.x) ** 2 + (v2.y - v1.y) ** 2)

    def normalize(self):
        return self * (1/self.magnitude())
</code></pre>
<p>When I try to do <code>1.0 * Vector2()</code>, I get the error:
TypeError: unsupported operand type(s) for *: 'float' and 'instance'</p>
<p>However, sometimes it works as intended:</p>
<pre><code>#this works as intended, s is a float
ball.pos -= ball.vel.normalize() * s
</code></pre>
<p>ball.vel is a vector and I am able to multiply by a float.
Vectors are multiplied by floats in many sections of my code without errors.</p>
<p>Does anyone know where this inconsistency comes from?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Define an <code>__rmul__</code> method to get <code>a_float * a_vector</code> working. It can be as simple as</p>
<pre><code>def __rmul__(self, other):
    return self * other
</code></pre>
<p>The other operators also have <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer">a dunder-<code>r</code> version</a>. These reflected operators are called when the normal version is not defined for the given types. See the docs for the <a href="https://docs.python.org/3/library/constants.html?highlight=notimplemented" rel="nofollow noreferrer"><code>NotImplemented</code></a> builtin constant.</p>
<p>The expression <code>a * b</code> is equivalent to <code>a.__mul__(b)</code>, unless <code>b</code> is an instance of a subclass of <code>a</code>'s class or <code>a.__mul__(b)</code> returns <code>NotImplemented</code>, in which case it's <code>b.__rmul__(a)</code> instead.</p>
</div>
<span class="comment-copy">Are you sure you did <code>Vector2() * 1.0</code> and not <code>1.0 * Vector2()</code>?</span>
<span class="comment-copy">Wow that was it. Why does it matter though?</span>
<span class="comment-copy">because <code>float * whatever</code> is defined by <code>float</code>, whereas <code>whatever * float</code> is defined by <code>whatever</code></span>
<span class="comment-copy">Makes sense, thanks for the quick response!</span>
<span class="comment-copy">Even simpler: <code>__rmul__ = __mul__</code>.  Obviously, this only works for commutative operators.</span>
<span class="comment-copy">@dan04 good point, but what if a subclass overrides <code>__mul__</code>? Then <code>__rmul__</code> would still use the old version!</span>
<span class="comment-copy">@gilch: If a subclass overrides <code>__mul__</code> and not <code>__rmul__</code>, that's the subclass's fault.</span>
