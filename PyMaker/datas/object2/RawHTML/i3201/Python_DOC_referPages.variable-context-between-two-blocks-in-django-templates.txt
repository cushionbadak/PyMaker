<div class="post-text" itemprop="text">
<p>I have two blocks that call the same method with same variables. I want to call the method only once, but the result is then outsite the scope of the block tags. I've tried calling this method in the parent template <code>header.html</code> and with a <code>with</code> tag, but nothing seems to work.</p>
<p>This is the layout:</p>
<pre><code>{% extends "header.html" %}

{% load navigation_tags %}

{% block header %}
    {% get_section site=site as section %}
    {% include "foobar.html" with section=section %}
{% endblock header %}

{% block navigation %}
    &lt;nav&gt;
        &lt;div class="container"&gt;
            {% get_section site=site as section %}
            {% navigation section.slug %}
        &lt;/div&gt;
    &lt;/nav&gt;
{% endblock navigation %}
</code></pre>
<p>navigation_tags.py</p>
<pre><code>@register.assignment_tag
def get_parent_section(site):
    if site.id == settings.FOOBAR_SITE_ID:
        section = Section.objects.get(id=settings.FOOBAR_SECTION_ID)
    else:
        # This is also a section instance.
        return site.default_section
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned by <a href="https://stackoverflow.com/users/6866546/2pacho">2pacho</a> in another answer and <a href="https://stackoverflow.com/users/1619435/fernando-cezar">Fernando Cezar</a> in a comment, the easiest way to share values between different sections is to set it in the template context. If you are using the <a href="https://docs.djangoproject.com/en/2.0/topics/http/shortcuts/#render" rel="nofollow noreferrer"><em>render</em></a> shortcut function, you can pass a <code>dict</code> as the <em>context</em> parameter to add a value to the rendering context of the template. That would be a good place to add it and this would be the easiest place to put it.</p>
<pre><code>return render(request, 'template.html', {'section': get_parent_section(site)})
</code></pre>
<p>However, if for some reason, you can't include it in the context, you can use a decorator to add <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memoization</a> to your function, so that it will cache the computation results and return it immediately when called with the same parameters. You can use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a> to do so, or it's Django backport at <code>django.utils.lru_cache.lru_cache</code> if you are using Python 2.x.</p>
<pre><code>@register.assignment_tag
@functools.lru_cache()
def get_parent_section(site):
    if site.id == settings.FOOBAR_SITE_ID:
        section = Section.objects.get(id=settings.FOOBAR_SECTION_ID)
    else:
        # This is also a section instance.
        return site.default_section
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wouldn't call a method outside .py . Think that this is using Jinja2 templates, 
it's powerful but not in the way that the backend can be.</p>
<p>What I recommend you doing in this case is to generate a context for the template and use this variables there.</p>
<p>Would be as simple as adding it to your context where it's being generated.</p>
<pre><code>context['site_parent'] = get_parent_section(site)
</code></pre>
<p>Think that Jinja2 (html) has to be as simple as possible and that can help you with basic coding and time saving (like loops to print the exact same information or show and hide code depending on the context) but I would keep it as simple you can when rendering.</p>
<p>If you would like you can read official django website about templates <a href="https://docs.djangoproject.com/en/2.0/topics/templates/" rel="nofollow noreferrer">https://docs.djangoproject.com/en/2.0/topics/templates/</a> </p>
<p>But from my expirience I would keep the method calls in the views.py</p>
</div>
<span class="comment-copy">Might be a good idea to include the code for <code>get_section</code> as well....    Also if it isn't an expensive call it might be easier to just do it twice</span>
<span class="comment-copy">@ResleyRodrigues question updated.</span>
<span class="comment-copy">Could it be because you don't return anything in the <code>if</code> condition?</span>
<span class="comment-copy">@ResleyRodrigues good pointing out, forgot about that. However, this isnt the issue. The return value is still out of scope.</span>
<span class="comment-copy">Since it's the same template, can't you include the <code>section</code> info in the context being injected there by the view?</span>
<span class="comment-copy">Thanks. I knew I could just set it in context in views, but I wanted to know if there was something I could do on template level. This works fine.</span>
<span class="comment-copy">Understood. Django's template are designed to be limited in what they can do, so I've found that the solution is usually to look outside of them.</span>
