<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/21031093/python-and-arbitrary-precision-integers">Python and “arbitrary precision integers”</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>This is my code in python but the answer it gives is not correct according to projecteuler.net.</p>
<pre><code>a = 2**1000
total = 0
while a &gt;= 1:
    temp = a % 10
    total = total + temp
    a = int(a/10)
print(total)
</code></pre>
<p>It gives an output 1189. Am I making some mistake?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your logic is fine. The problem is that <code>2 ** 1000</code> is too big for all the digits to fit into a float, so the number gets rounded when you do <code>a = int(a/10)</code>. A Python <code>float</code> only has 53 bits of precision, you can read about it in the official tutorial article: <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">Floating Point Arithmetic: Issues and Limitations</a>, and on Wikipedia: <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow noreferrer">Double-precision floating-point format</a>. Also see <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>.</p>
<p>This is <code>2 ** 1000</code></p>
<blockquote>
<p>10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376</p>
</blockquote>
<p>But <code>print(format(2**1000 / 10, 'f'))</code> gives us this:</p>
<blockquote>
<p>1071508607186267380429101388171324322483904737701556012694158454746129413355810495130824665231870799934327252763807170417136096893411236061781867579266085792026680021578208129860941078404632071895251811587214122307926025420797364998626502669722909817741077261714977537247847201331018951634334519394304.000000</p>
</blockquote>
<p>You can see that the digits start going wrong after <code>10715086071862673</code>.</p>
<p>So you need to use integer arithmetic, which in Python has arbitrary precision (only limited by how much memory Python can access). To do that, use the <code>//</code> <a href="https://docs.python.org/3/glossary.html#term-floor-division" rel="nofollow noreferrer">floor division</a> operator.</p>
<pre><code>a = 2**1000
total = 0
while a &gt;= 1:
    temp = a % 10
    total = total + temp
    a = a // 10
print(total)
</code></pre>
<p><strong>output</strong></p>
<pre><code>1366
</code></pre>
<p>We can condense that code a little by using <a href="https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow noreferrer">augmented assignment</a> operators.</p>
<pre><code>a = 2**1000
total = 0
while a:
    total += a % 10
    a //= 10
print(total)
</code></pre>
<hr/>
<p>Here's a faster way. Convert <code>a</code> to a string then convert each digit back to <code>int</code> and sum them. I use bit shifting to compute <code>a</code> because it's faster than exponentiation.</p>
<pre><code>print(sum(int(u) for u in str(1 &lt;&lt; 1000)))
</code></pre>
</div>
<span class="comment-copy">Have a look <a href="https://www.quora.com/How-do-you-find-the-sum-of-the-digits-of-2-1000" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">@abccd That question is relevant, and there's good info there in the answers and comments, but I don't think it's close enough to this question to use it as a duplicate target.</span>
<span class="comment-copy">@PM2Ring your answer's great. When I left the link, I was hoping to see if the community think if it's a dupe if not, a relevant post. I guess the verdict (at least by two other voters) was it's a close-enough dupe. Feel free to spark a reopen vote:)</span>
<span class="comment-copy">@abccd I could re-open it by myself. It doesn't bother me too much that others wanted to close it with that dupe target, although I'd prefer it if a better matching question was the target.</span>
<span class="comment-copy">Won't any errors or warning be shown? It's an overflow, right?</span>
<span class="comment-copy">@J...S: Python ints are arbitrary-precision.</span>
<span class="comment-copy">@user2357112 But PM said something about number being too big to fit in a  float.</span>
<span class="comment-copy">@J...S 2**1000 is not too large in magnitude for a float in python, but it does require more bits to store exactly than a python float provides, so the result is erroneous but does not throw an exception.</span>
<span class="comment-copy">@J...S Because a float can only hold 53 bits of precision, which is  not enough to accurately represent a number with 1001 bits.</span>
