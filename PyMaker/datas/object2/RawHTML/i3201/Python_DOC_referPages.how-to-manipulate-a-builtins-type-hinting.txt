<div class="post-text" itemprop="text">
<p>I use <code>ElementTree</code> to parse/build a number of slightly complicated but well-defined xml files, and use <code>mypy</code> for static typing. I have <code>.find</code> statements strewn all over the place, which leads to things like this:</p>
<pre><code>from xml.etree.ElementTree import Element
...
root.find('tag_a').append(Element('tag_b'))

# run mypy..
-&gt; type None from Optional[Element] has no attribute append
</code></pre>
<p>This makes sense, since <code>find</code> could simply not find the tag I give it. But I know that it's there and don't want to add stuff like <code>try..except</code> or <code>assert</code> statements to essentially simply silence <code>mypy</code> without adding functionality while making the code less readable. I'd also like to avoid commenting <code># type: ignore</code> everywhere.</p>
<hr/>
<p>I tried monkey patching <code>Element.find.__annotations__</code>, which would be a good solution in my opinion. But since it's a builtin I can't do that, and subclassing <code>Element</code> feels like too much again. </p>
<p>Is there a good way to solve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>We can write an utility function which internally handles <code>None</code>-found cases and raises an exception/returns some dummy value of given type:</p>
<pre><code>from xml.etree.ElementTree import Element


def find(element: Element,
         tag: str) -&gt; Element:
    result = element.find(tag)
    assert result is not None, ('No tag "{tag}" found '
                                'in element "{element}".'
                                .format(tag=tag,
                                        element=element))
    return result
</code></pre>
<p>advantage of assertions (compared to raising an exception manually) is that they <a href="https://stackoverflow.com/questions/1273211/disable-assertions-in-python/43668496#43668496">can be disabled</a> <strong>but</strong> if you are working with some provided-by-user data I recommend to raise an exception like</p>
<pre><code>if result is None:
    raise LookupError('No tag "{tag}" found '
                      'in element "{element}".'
                      .format(tag=tag,
                              element=element))
</code></pre>
<h2>Digression</h2>
<p>I use type annotations since it helps to IDE and it also saves a lot of time while reading API, but I'm not a mypy user because I don't like an idea of checking everything like in this case: if a function user passes garbage then it is his fault, we should let him do this instead of writing something about "you have a union of types and not handling cases with some of them", <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP after all</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Mypy does not use <code>__annotations__</code>, that is a runtime construct. Mypy's analysis is completely static.</p>
<p>"builtin" types (aka types from the standard library) are sourced from <a href="https://github.com/python/typeshed" rel="nofollow noreferrer">typeshed</a>. If you wish to modify these types for your own purposes, you can (though I would strongly discourage it as a solution to your problem). To use a custom typeshed with mypy, you can do <code>mypy --custom-typeshed-dir=/path/to/my/typeshed ...</code> and mypy will use your modified typeshed.</p>
<p>A more ergonomic solution would be to do as Azat suggests, and write a wrapper that moves type narrowing to a utility function, so that the local readability does not suffer and you maintain type safety.  </p>
</div>
<div class="post-text" itemprop="text">
<p>I think here, there are three different options you can take.</p>
<ol>
<li>The first option is the approach suggested in <a href="https://stackoverflow.com/a/51335625/646543">Azat Ibrakov's answer</a>: create a helper method that explicitly performs a 'None' check at runtime to satisfy mypy. This is the most typesafe option.</li>
<li><p>The second option is to configure mypy and loosen how it handles values of type 'None'. Currently, mypy will consider 'None' and 'Element' to be two distinct types: if you have a value that's 'None', it can't be an 'Element' and vice-versa. You can actually weaken this by giving mypy the <code>--no-strict-optional</code> flag, which will make mypy treat values of type 'None' as being a member of <em>all</em> types.</p>
<p>Or to put it another way, if you're familiar with languages like Java, it's legal to do things like this:</p>
<pre><code>String myString = null;
</code></pre>
<p>Passing in the <code>--no-strict-optional</code> flag to mypy will make it start accepting code like the above.</p>
<p>This obviously means that your code will be less typesafe: mypy is no longer capable of detecting potential "null pointer exceptions". To help mitigate this, you can try disabling strict-optional <em>locally</em>, rather then <em>globally</em>, by creating a <a href="http://mypy.readthedocs.io/en/latest/config_file.html" rel="nofollow noreferrer">mypy config file</a>.</p>
<p>In a nutshell, you'd create a config file that looks roughly like this:</p>
<pre><code>[mypy]
# Global options can go here. We'll leave this empty since we don't
# want to change any of the defaults.

[mypy-mycodebase.my.xml.processing.module]
# We weaken mypy in *just* this module
strict_optional = False
</code></pre></li>
<li><p>The third option is to just stop using static typing for your XML parsing code altogether: cast your <code>root</code> variable to be of type 'Any' and go to town. Then, as you collect useful data from your XML, do any necessary runtime checks to validate your data and create (typesafe!) objects to store the relevant info. (You can continue using static typing on the rest of your code, of course).</p>
<p>The observation here is that any runtime input is going to be inherently dynamic: the user could always pass in malformed XML, the data could be structured incorrectly, etc... The only real way of checking these kinds of issues is using runtime checks: static type checking won't be of much help. So, if static type checking provides minimal value in a certain region of code, why continue using it there?</p>
<p>This tactic does have several downsides, of course. In particular, mypy won't be able to detect blatant misuses of the ElementTree API, you'lll need to be fairly diligent with your runtime checks to make sure bad data doesn't creep into the typechecked regions of your code, etc...</p></li>
</ol>
</div>
<span class="comment-copy">i guess there is no way to be sure that some tag is presented, you can write a function which calls <code>.find</code> method and checks if result is not <code>None</code> like <code>assert result is not None</code>, then specify its return type as <code>Element</code>, may work (less ugly than subclassing I guess)</span>
<span class="comment-copy">@AzatIbrakov Ah, like <code>def certain_find(elem, tag)</code> which handles the typing stuff once? Feel free to post it as an answer, it sounds reasonable.</span>
<span class="comment-copy">Thanks for the in depth answer, I really appreciate that you added reasoning to each route.</span>
<span class="comment-copy">@Arne: fixed -- I meant to just end at "this is the most typesafe option" and defer to Azat's answer, but clearly I missed the trailing thought while proofreading... Eh, whatever.</span>
