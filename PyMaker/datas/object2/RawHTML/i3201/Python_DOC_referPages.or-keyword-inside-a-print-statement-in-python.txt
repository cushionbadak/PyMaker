<div class="post-text" itemprop="text">
<p>How does Python decide the output of this ?</p>
<pre><code>print([1, 2] or ["hello"])
</code></pre>
<p>I mean why will always print([2] or ["az"]) output [2] and not ["az"] ? </p>
</div>
<div class="post-text" itemprop="text">
<p>Since those lists contain elements, they will evaluate to <code>True</code> so Python prints whichever <code>True</code> literal comes first.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two things you have to understand here. First:</p>
<pre><code>x or y
</code></pre>
<p>If <code>x</code> is truthy, it has the value of <code>x</code> (without even evaluating <code>y</code>, so <code>23 or launch_nukes()</code> doesn't launch the nukes).</p>
<p>Otherwise, it has the value of <code>y</code>.</p>
<p>Or, as <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">the docs</a> put it:</p>
<blockquote>
<p>The expression <code>x or y</code> first evaluates <em>x</em>; if <em>x</em> is true, its value is returned; otherwise, <em>y</em> is evaluated and the resulting value is returned.</p>
</blockquote>
<p>Notice that it uses the word "true" here, not the value <code>True</code>. This is a bit confusing (even more so if you're talking out loud, or typing in ASCII without formatting…), which is why everyone says "truthy".</p>
<hr/>
<p>So, what do "truthy" and "falsey" mean?<sup>1</sup></p>
<ul>
<li>"x is truthy" does <em>not</em> mean <code>x == True</code>, it means <code>bool(x) == True</code>.</li>
<li>"x is falsey" does <em>not</em> mean <code>x == False</code>, it means <code>bool(x) == False</code>.</li>
</ul>
<p>For all builtin and stdlib types:</p>
<ul>
<li><code>False</code> is falsey.</li>
<li><code>None</code> is falsey.</li>
<li>Numeric zero values are falsey.</li>
<li>Empty containers are falsey.</li>
<li>Everything else is truthy.</li>
</ul>
<p>Notice that <code>None</code> and empty containers are falsey, but they're not equal to <code>False</code>.</p>
<p>By convention, third-party types (including types that you define<sup>2</sup>) should follow the same rules. But sometimes there are good reasons not to. (For example, a NumPy array is neither truthy nor falsey.<sup>3</sup>)</p>
<p>This is covered loosely in <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">the same docs section</a>:</p>
<blockquote>
<p>In the context of Boolean operations, and also when expressions are used by control flow statements, the following values are interpreted as false: False, None, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true. User-defined objects can customize their truth value by providing a <code>__bool__()</code> method.</p>
</blockquote>
<p>The exact details for all builtin types are buried in <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">the standard type hierarchy</a>, which is where you learn things like whether <code>bytes</code> is covered by "strings and containers" (yes) or whether there's anything special about <code>NotImplemented</code> (nope, it's truthy).</p>
<hr/>
<p>So, let's go through your examples:</p>
<pre><code>[1, 2] or ["hello"]
</code></pre>
<p>Since <code>[1, 2]</code> is a non-empty container, it's truthy. So this equals <code>[1, 2]</code>.</p>
<pre><code>[] or ["hello"]
</code></pre>
<p>Since <code>[]</code> is an empty container, it's falsey. So this equals <code>["hello"]</code>.</p>
<pre><code>[] == False
</code></pre>
<p><code>[]</code> may be falsey, but it's not <code>False</code>, or even equal to <code>False</code>. Only numbers equal other numbers, and <code>False</code> is the number 0 in the numeric type <code>bool</code>,<sup>4</sup> but <code>[]</code> is not a number. So this is <code>False</code>.</p>
<hr/>
<p>Just be glad you didn't ask about <code>is</code>. :)</p>
<hr/>
<p><sub>1. Technically, these terms aren't defined, even though everyone, even the core devs, uses them all the time. The official reference defines things in terms of evaluating to true or false as a boolean, and then explains what that means elsewhere.</sub></p>
<p><sub>2. You can control whether your types' values are truthy by defining a <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="nofollow noreferrer"><code>__bool__</code></a> method—or by defining <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="nofollow noreferrer"><code>__len__</code></a>. The only things you're allowed to do are return <code>True</code>, return <code>False</code>, or raise an exception; if you try to return anything different, it raises a <code>TypeError</code>. So, everything is either truthy, or falsey, or untestable.</sub></p>
<p><sub>3. If you try to check its truthiness, it will raise an exception. That's because NumPy uses boolean arrays widely—e.g., <code>array([1, 2]) &lt; array([2, 1])</code> is <code>array([True, False])</code>, and you don't want people writing <code>if array([1, 2]) &lt; array([2, 1]):</code>, since whatever they're expecting it to do probably doesn't make sense.</sub></p>
<p><sub>4. Yes, <code>bool</code> is a numeric type—in fact, a subclass of <code>int</code>. This is a little weird when you're first learning, but it turns out to be useful more often than it's dangerous, so it's not <em>just</em> preserved for historic reasons.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p><code>x or y [or z or z1 or z2 or ...]</code> returns the first Truthy element in sequence, or the last Falsey element if all are Falsey.</p>
<p><code>x and y [and z and z1 and z2 and ...]</code> returns the first Falsey element in sequence, or the last Truthy element if all are Truthy.</p>
<hr/>
<p>Python has a notion of Truthiness and Falsiness that is separate from <code>True</code> and <code>False</code>. An empty list is not <code>False</code>, but it is <em>Falsey</em>. <code>bool(something_truthy) == True</code> and <code>bool(something_falsey) == False</code>.</p>
<p>Most things are Truthy, so it's easier to list the Falsey things:</p>
<ul>
<li><code>0</code> (note that <code>-1</code> is Truthy)</li>
<li><code>None</code></li>
<li>Empty collections (<code>[]</code>, <code>{}</code>, <code>set()</code>, <code>""</code>, and etc. Note that non-empty collections containing entirely Falsey elements are <em>still</em> truthy e.g. <code>[None, None, None, None]</code>)</li>
<li><code>False</code></li>
</ul>
<p>Everything else is Truthy.</p>
<hr/>
<p>In your example: <code>[1, 2] or ["hello"] == [1, 2]</code> because the first element, <code>[1, 2</code> is Truthy (the fact that <code>["hello"]</code> is also Truthy is irrelevant in this case). Note that <code>[1, 2] and ["hello"] == ["hello"]</code>.</p>
</div>
<span class="comment-copy">I'm not sure it's a duplicate, but <a href="https://stackoverflow.com/questions/18212574/">this question</a> and the dozens of other dups of the same problem all have answers that explain why this expression evaluates to <code>[1, 2]</code>.</span>
<span class="comment-copy">So why my interpreter returns false on this: " [ ] == False" ?</span>
<span class="comment-copy">@MikeDelta Just because <code>[]</code> is falsey doesn't mean it's <code>== False</code>. <code>None</code>, numeric zero, and empty containers are all falsey, but only zero is equal to False.</span>
<span class="comment-copy">But the way this answer is worded, I can see how you were confused by that…</span>
