<div class="post-text" itemprop="text">
<p>I asked this because it is possible in R. Note that both 1.5 and 1 are in numeric type (double-precision), and only 1L is an integer. When coercing a string into numeric type, it doesn't show a decimal point if there's not one in the string.</p>
<pre><code>class(1.5)
# "numeric"
class(1)
# "numeric"
class(1L)
# "integer"
x &lt;- as.numeric("3")
x
# 3
class(x)
# "numeric"
</code></pre>
<p>Am I allowed to have similar operations in Python? Let's say I have a function called <code>key_in_a_number</code>:</p>
<pre><code>def key_in_a_number():
    num = input("Key in a number here: ")
    try:
        return float(num)
    except ValueError:
        return "Please key in only numbers."
</code></pre>
<p>Now if one keys in "40", it will return 40.0, but <em>40.0 and 40 are different in certain digits</em>. Thus, 40 should be returned if "40" is keyed in, while 40.0 should be returned only when "40.0" is keyed in.</p>
<p>My work around is:</p>
<pre><code>def key_in_a_number():
    num = input("Key in a number here: ")
    try:
        return int(num)
    except ValueError:
        try:
            return float(num)
        except ValueError:
            return "Please key in only numbers."
</code></pre>
<p>However, in this way, I cannot be sure that the results are always in the same type, which could be problematic in following data storage or processing. Is there any way to have a number in float type without a decimal point?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your core problem here is that you're misunderstanding what <code>float</code> is.</p>
<p>A <code>float</code> represents a C double, which almost always means an IEEE 754-1985 <code>double</code> (or an IEEE 754-2008 <code>binary64</code>, which is basically the same thing but slightly better defined). It always has 53 binary digits of precision. It doesn't matter whether you specify it as <code>40.</code>, <code>40.00000</code>, <code>float(40)</code>, <code>float('40')</code>, or <code>float('40.00')</code>; those are all identical in every way.</p>
<p>So, the main problem you're asking about doesn't make any sense:</p>
<blockquote>
<p>Now if one keys in "40", it will return 40.0, but 40.0 and 40 are different in certain digits.</p>
</blockquote>
<p>No, they aren't. <code>float("40")</code> and <code>float("40.0")</code> are both the exact same value, with no differences in any digits, and no difference in their precision, or anything else.</p>
<hr/>
<p>There's a <em>different</em> type in Python, in the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer"><code>decimal</code></a> library, that represents an IEEE  754-2008 arbitrary-sized <code>decimal</code>. It has as many decimal digits of precision as you tell it to have. </p>
<p>So, <code>Decimal('40')</code> and <code>Decimal('40.')</code> have two digits; <code>Decimal('40.000')</code> has five digits—they may be <em>equal</em>, but they're not <em>identical</em>, because the last one is more precise.</p>
<hr/>
<p><code>Decimal</code>, on the other hand, prints out however many digits of precision it actually has:</p>
<pre><code>&gt;&gt;&gt; print(Decimal('40'))
40
&gt;&gt;&gt; print(Decimal('40.'))
40
&gt;&gt;&gt; print(Decimal('40.0'))
40.0
</code></pre>
<hr/>
<p>While we're at it, if you <em>do</em> want <code>float</code> and <code>int</code> values, here's how to translate each line of R into Python:</p>
<pre><code>class(1.5) # numeric
type(1.5) # float
class(1) # numeric
type(1) # int
type(1.) # float
class(1L) # integer
type(1) # int
x &lt;- as.numeric("3") # numeric
x = float(3) # float
x = float("3") # float
</code></pre>
<p>Notice that, just like <code>as.numeric("3")</code> gives you a <code>numeric</code> rather than an <code>integer</code>, float("3")<code>gives you a</code>float<code>rather than an</code>int`. I'm not sure why that Python behavior puzzles you given that it's identical to the equivalent R behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes,</p>
<p><code>10</code> would be an integer in Python, whereas <code>10.</code> which represents the same number would be a float.</p>
</div>
<span class="comment-copy">Why precisely do you need this? Could you possibly use strings, filtered for digits, instead?</span>
<span class="comment-copy">It sounds like what you may <i>really</i> want here is not <code>float</code> but [<code>decimal.Decimal</code>]. The float values <code>40.</code>, <code>40.0</code>, and <code>40.0000</code> are all the same value. But <code>Decimal('40.')</code>, <code>Decimal('40.0')</code>, and <code>Decimal('40.0000')</code>, while all being equal, carry around additional information about how many digits of precision they have. (A <code>float</code> always has the same 52 binary digits of precision; a <code>Decimal</code> has as many decimal digits as you told it to have.)</span>
<span class="comment-copy">You could also take a look at built-in <code>eval</code>: <code>type(eval('40.0'))</code> is <code>float</code> and <code>type(eval('40'))</code> is <code>int</code></span>
<span class="comment-copy">@ReblochonMasque I am doing OCR from physical exam reports. As you know there will be lots of numeric data. They are recognized from Google Vision API as strings, but should be stored and presented to users as numbers. Since 40 and 40.0 can have different meanings in different tests, that's why I need this.</span>
<span class="comment-copy">As a side note, you can flatten out that nested <code>try</code> with a loop: <code>for typ in (int, float):</code> <code>try: return typ(num)</code> <code>except ValueError: pass</code> <code>else: return "Please key in only numbers"</code>. But that's probably overcomplicating things when there's just two nested <code>try</code> statements rather than six or N-not-known-until-runtime or something…</span>
<span class="comment-copy">Thank you but there are something I'd like to clarify. First, thank you for teaching me that <code>float("40")</code> and <code>float("40.0")</code> are identical, but 40 and 40.0 are <i>indeed different</i> in scientific measurements. Please see <a href="https://en.wikipedia.org/wiki/Significant_figures#Estimating_tenths" rel="nofollow noreferrer">Significant figures - Estimating tenths</a>. What I am asking should make sense.</span>
<span class="comment-copy">As for your last part, comparison between Python and R, I knew that <code>float("3")</code> in Python gives me a float rather than an int, that I understood. However, what I am asking is: can <code>float("3")</code> gives me just 3, not 3.0, since <code>as.numeric("3")</code> in R gives me 3, not 3.0 - unless I do <code>as.numeric("3.0")</code>.</span>
<span class="comment-copy">@ytu Yes, as scientific measurements, <code>40</code> (or <code>40.</code>) and <code>40.0</code> are different—and that's exactly why <code>Decimal</code> lets you track them differently. But <code>float</code> is the wrong type for that. That's the whole point f my answer. A <code>float</code> doesn't know its precision, and, even if it did, it would be in binary digits, not decimal digits; a <code>Decimal</code> knows its precision, in decimal digits, which is exactly what you're asking for here.</span>
<span class="comment-copy">@ytu And <code>float("3")</code> already <i>does</i> just give you <code>3</code> as a <code>float</code>, because that's the same value as <code>3.0</code> a a <code>float</code>, and either way, you get <code>'3.0'</code> as the <code>repr</code> but <code>'3'</code> as the <code>str</code>. The former is useful to you as a programmer—you can copy <code>3.0</code> as a literal int your source code to get that value. The latter is useful to you and/or your users as scientists—<code>3</code> is the actual value (plus or minus some error that you don't know because you just stored it in a <code>float</code>—but of course you <i>can</i> always store error as a second <code>float</code> for each one…).</span>
<span class="comment-copy">I appreciate your elaboration. What I tried to clarify at the first point is: you quoted my sentence "Now if one keys in '40', it will return 40.0, but 40.0 and 40 are different in certain digits.", and you said "No, they aren't.", "the main problem you're asking about doesn't make any sense". However, 40 and 40.0, as numbers, <b>are</b> different as we both agreed. So I'd say "Yes, they are.", "the problem is making sense". Just because I chose the wrong tool (<code>float</code> instead of <code>Decimal</code>) doesn't mean that the question doesn't make sense, or 40 and 40.0 are the same.</span>
<span class="comment-copy">Sorry, I may not be clear enough. I don't want the decimal point at all.</span>
