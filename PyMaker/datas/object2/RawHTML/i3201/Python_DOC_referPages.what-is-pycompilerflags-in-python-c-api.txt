<div class="post-text" itemprop="text">
<p>If you checked Python C- API <a href="https://docs.python.org/2/c-api/veryhigh.html#c.PyCompilerFlags" rel="nofollow noreferrer">documentation</a> about running python code via the C calls, you will always find mention to <code>PyCompilerFlags</code>, but nothing really describes what is it except the last portion of documentation and says nothing about its possible values and their effect on execution.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>PyCompilerFlags</code> is the C API equivalent to the <em>flags</em> argument passed to <code>compile</code> and related functions in Python. This probably isn't at all obvious if you don't already know the Python docs forward and backward before looking at the CPython C-API docs. </p>
<p>From <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow noreferrer"><code>compile</code></a>:</p>
<blockquote>
<p>The optional arguments <em>flags</em> and <em>dont_inherit</em> control which <a href="https://docs.python.org/3/reference/simple_stmts.html#future" rel="nofollow noreferrer">future statements</a> affect the compilation of source. If neither is present (or both are zero) the code is compiled with those future statements that are in effect in the code that is calling <code>compile()</code>. If the <em>flags</em> argument is given and <em>dont_inherit</em> is not (or is zero) then the future statements specified by the <em>flags</em> argument are used in addition to those that would be used anyway. If <em>dont_inherit</em> is a non-zero integer then the <em>flags</em> argument is it – the future statements in effect around the call to compile are ignored.</p>
<p>Future statements are specified by bits which can be bitwise ORed together to specify multiple statements. The bitfield required to specify a given feature can be found as the <code>compiler_flag</code> attribute on the <code>_Feature</code> instance in the <a href="https://docs.python.org/3/library/__future__.html#module-__future__" rel="nofollow noreferrer"><code>__future__</code></a> module.</p>
</blockquote>
<p>Following the link to <a href="https://docs.python.org/3/reference/simple_stmts.html#future" rel="nofollow noreferrer">future statements</a> gives more details on how they work, and the link to the <a href="https://docs.python.org/3/library/__future__.html#module-__future__" rel="nofollow noreferrer"><code>__future__</code></a> has a chart showing the list of future statements available.</p>
<hr/>
<p>Another thing that may not be obvious: each future feature flag corresponds to a flag that ends up in the <code>co_flags</code> attribute of a <code>code</code> object. So:</p>
<pre><code>code = compile('1 &lt;&gt; 2', '', 'eval', flags=__future__.barry_as_FLUFL.compiler_flag)
assert code.co_flags &amp; CO_FUTURE_BARRY_AS_BDFL
</code></pre>
<p>In C, if you pass <code>struct PyCompilerFlags flags = { CO_FUTURE_BARRY_AS_BDFL }</code> to get the same effect.</p>
<p>If you want to see the actual numeric values for those flags, you have to look up the corresponding <a href="https://github.com/python/cpython/blob/master/Include/code.h#L77" rel="nofollow noreferrer"><code>CO_*</code></a> constants in the C source or in the <a href="https://github.com/python/cpython/blob/master/Lib/__future__.py" rel="nofollow noreferrer"><code>__future__</code></a> source. </p>
<hr/>
<p>Things are slightly different in the C API, in a few ways.</p>
<ul>
<li>Rather than passing both <em>flags</em> and <em>dont_inherit</em>, you only pass <em>flags</em>, which is a complete set of all of the future statements you want to be in effect during the <code>PyRun_*</code> or <code>PyCompile_*</code> call.</li>
<li>Most of the functions take a <code>PyCompile_Flags</code> struct holding an int, instead of a raw int. This is just for the purpose of type checking; in memory, a struct holding an int is stored the same way as an int.</li>
<li>Many functions take their flags by pointer, so you can retrieve the possibly-updated set of flags after running the code.</li>
</ul>
<hr/>
<p>Let's look at a complete example. I'll use Python 2.7 even though I've been linking to 3.7 docs, just because an example using <code>print</code> is simpler than one using forward annotations.</p>
<p>This code prints an empty tuple:</p>
<pre><code>print()
</code></pre>
<p>But if you run the first one with <code>PyRun_SimpleStringFlags</code>, passing <code>CO_FUTURE_PRINT_FUNCTION</code> (0x10000) as the <em>flags</em>`, it will print a blank line, a la Python 3.</p>
<p>If you run this code:</p>
<pre><code>from __future__ import print_function
print()
</code></pre>
<p>… then whether you passed in <code>0</code> or <code>CO_FUTURE_PRINT_FUNCTION</code>, it will print a blank line. And after the call, if you look at the <em>flags</em> you passed in by reference, it will have that <code>CO_FUTURE_PRINT_FUNCTION</code> or'd onto it. So, if you're compiling and running a chunk at a time, you can pass that same value along to the next string, and it'll inherit that future flag. (Much like when you write a future statement in the interactive interpreter, it affects all the statements you interpret after that.)</p>
</div>
<span class="comment-copy">It’s the bitmask of all <code>__future__</code> flags you want to use when compiling or running some code. (When running code, you usually pass it by ref so you can see if that code added any more <code>__future__</code> statements.) IIRC, the details are described in the Library reference for <code>compile</code> and <code>__future__</code>, and the C API docs sort of assume you’ve already read all of the Python docs and can quote them from memory.</span>
<span class="comment-copy">Anyway, is there something in particular you wanted to know? Like links to/summaries of the appropriate part of the Python docs, or an example of using it in a trivial embedding app that calls the VHL functions, or how to find out which functions pass it by ref vs. by copy (and I think a few just pass the raw int even?), or…?</span>
<span class="comment-copy">@abarnert, I am currently embedding python inside an application plus making a few extensions that shall be used only inside the app. I just asked out of curiosity because I found it haunting me everywhere.  Would you give the link for <code>compile</code> documentation you are referring to, just to be on the same page and have a better source than reading source code of python interpreter ') Thanks</span>
