<div class="post-text" itemprop="text">
<p>Let's say I have two python lists like so:</p>
<blockquote>
<p>[30, 400, 500]</p>
<p>[55, 396, 478]</p>
</blockquote>
<p>I want to find the sum of minimum (absolute value of the) difference between the elements. In this case it would be easy: (55-30) + (400-396) + (500-478) = 51</p>
<p>But how would I go about doing this efficiently when the lists don't have an equal number of elements. For example:</p>
<blockquote>
<p>Set 1: </p>
<p>list1 = [30, 400, 500]</p>
<p>list2 = [412, 489]</p>
</blockquote>
<p>or even if it was </p>
<blockquote>
<p>Set 2</p>
<p>list1 = [30, 400, 500]</p>
<p>list2 = [24, 563]</p>
</blockquote>
<p>lastly, </p>
<blockquote>
<p>Set 3</p>
<p>list1 = [30, 50]</p>
<p>list2 = [20, 31, 90]</p>
</blockquote>
<p>For Set 1, the answer would be (412-400) + (500-489) = 23</p>
<p>For Set 2, the answer would be (30-24) + (563-500) = 69</p>
<p>For Set 3, the answer would be (30-20) + (50-31) =29</p>
<p>I can't compare by element. In set 1, the sum of the minimum difference is achieved by comparing the second element of list1 to the first element of list2, and the third element of list1 to the second element of list2. In set 2, the sum of the minimum difference is achieved by comparing the first element of list1 to the first element of list2, and the third element of list1 to the second element of list2. </p>
<p>Any help is appreciated.</p>
<p>Some other info:</p>
<ul>
<li>The lists will never be more than 2 times longer than the other, but there is no bound on whether list1 is the bigger list or if list2 is the bigger list.</li>
<li>The lists will be in sorted order</li>
<li>All elements in the shorter list have to be used at least once</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In order to be sure to get the right answer I would use a bipartite weighted matching, where the abs-diff between each pair are the weights. This will avoid all the pitfalls from sorting based approaches, such as </p>
<pre><code>list1=[30, 50], list2=[20, 31, 90], ans= 29
</code></pre>
<p>where most intuitve algorithms would pair 30 with 31. (giving sum 41)</p>
<p>Here is a solution using scipy's <code>linear_sum_assignment</code>:</p>
<pre><code>import numpy as np
from scipy.optimize import linear_sum_assignment
def min_diff_sum(list1, list2):
    arr1 = np.asanyarray(list1)
    arr2 = np.asanyarray(list2)
    cost_matrix = np.abs(arr1-arr2[:, None])
    pairs = linear_sum_assignment(cost_matrix)
    return np.sum(cost_matrix[pairs])
</code></pre>
<p>This should always give the right result.</p>
<pre><code>In [45]: min_diff_sum([30, 400, 500], [412, 489])
Out[45]: 23

In [46]: min_diff_sum([30, 400, 500], [24, 563])
Out[46]: 69
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you could use the <code>bisect</code> module:</p>
<pre><code>import bisect

list1 = [30, 400, 500]
list2 = [412, 489]


list1.sort() # list1 must be sorted

result = []

for el in sorted(list2): # walk through the elements in sorted order
    pos = bisect.bisect_left(list1, el) # find the closest elements
    if pos &gt;= len(list1): # el is bigger than last element, use it
        pos -= 1
    elif pos &gt; 0 and abs(list1[pos-1] - el) &lt;= abs(list1[pos] - el):
        pos = pos - 1
    result.append(abs(list1[pos] - el))
    del list1[pos]

print(result)
</code></pre>
<p>results in <code>[12, 11]</code> (which is <code>[412-400, 500-489]</code>)</p>
<p>If you use <code>list2 = [24, 563]</code> then you get <code>[6, 63]</code> (which is <code>[30-24, 563-500]</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this problem is to choose the smaller list first. Take numbers one by one from smaller list and search for the minimum absolute difference (keep track of index as well) and once you found the minimum absolute difference add it to your final <code>sum</code> and delete that element from bigger list so you won't consider that again. </p>
<p>This solution is O(NM). Assuming list size constraint are N, M for list1 and list2 respectively. You can optimise the solution to O(NLogN + NLogM) it by sorting the bigger list in O(NLogN) and using binary search to find the minimum absolute difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay before jumping into coding this is how I would reason about the problem:
1. Simply calculate all the possible values. 
2. Just take out the minimum 
I don't think anything more complex will be more efficient because, eventually, you still have to test all the combinations to have full certainty.
With this in mind I will do:</p>
<pre><code>ll1, ll2 = len(l1), len(l2) 
if ll2 &lt; ll1:
    l1, l2, ll1, ll2 = l2, l1, ll2, ll1
# Now any longer list will be l2 and ll2 &gt;= ll1
</code></pre>
<p>At this stage we need a function to be able to split a single list into a list of lists where each child list (that is item) has the length given by the number specified. They also cannot contain the same item (from the split list) twice. Enter itertools. </p>
<pre><code>from itertools import combinations, permutations 
# All the lists within l2 that will be mixed with l1 (that is they have same length as l1) :
l2_sublists = combinations(l2, ll1) 
mixes = [l1 + item for item in l2_sublists] 
</code></pre>
<p>To get all the sums of differences for each mix we find all the combinations; partition them in twos; then for each combination sum the absolute values of the difference of the items in each partition... </p>
<pre><code>diffs = (sum(abs(p[0] - p[1]) for p in (perm[i:i + 2] for i in range(0, len(perm), 2))) for m in mixes for perm in permutations(m, 2 * ll1)) 
result = min(diffs) 
print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use sorted and zip.</p>
<pre><code>&gt;&gt;&gt; list1 = [30, 400, 500]
&gt;&gt;&gt; list2 = [412, 489]
&gt;&gt;&gt; l3 = zip(sorted(list1), sorted(list2))
&gt;&gt;&gt; s = 0
&gt;&gt;&gt; for i in l3:
...   s += abs(i[0] - i[1])
...
&gt;&gt;&gt; s
23
</code></pre>
<p>If you need to still use the "hanging" values in the list you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">zip_longest</a> with <code>fillvalue</code> being the default value to pair the hanging values. Then with sorted, you can add <code>reverse=True</code> to change list to descending order.</p>
<p><strong>Edit</strong></p>
<p>With the added info, removing <code>reverse=True</code> pretty much does it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If i've understood this correctly, I believe the following should work:</p>
<pre><code>list1 = [30, 400, 500]
list2 = [412, 489]

diffs = []
pairs = []
for l2 in list2:
    min_diff = float('inf')
    pair     = None
    for l1 in list1:
        abs_diff = abs(l2-l1)
        if abs_diff &lt; min_diff:
            min_diff = abs_diff
            pair = (l1,l2)
    diffs.append(min_diff)
    pairs.append(pair)

print(diffs)
print(sum(diffs))
print(pairs)
</code></pre>
<p>A mistake was pointed out in the comments, here is the revised version.</p>
<pre><code>import itertools
def min_abs_diff(l1,l2):
    bigger, smaller = sorted([l1,l2],key=len,reverse=True)
    diffs = [abs(x-y) for x,y in itertools.product(bigger,smaller)]
    return sum(min(diffs[i*len(bigger):(i+1)*len(bigger)]) 
               for i in range(len(diffs)//len(bigger)))
</code></pre>
</div>
<span class="comment-copy">Are there universal rules, such as what you've implied with your Set 1 and Set 2 examples?  What if list1 is 2, 3, or more times longer than list1?  What if list1 is shorter?  Outlining the rules will help you get better, more complete answers.</span>
<span class="comment-copy">Can you post what is your expected result for Set1 and Set2?</span>
<span class="comment-copy">The lists will never be more than 2 times longer than the other, but there is no bound on whether list1 is the bigger list or if list2 is the bigger list</span>
<span class="comment-copy">Are the lists always in sorted order? Do all of the elements in the shorter list have to get used at least once? Also, instead of answering everything in comments, edit your question, so it’s clear what rule you’re actually after here.</span>
<span class="comment-copy">Maybe add <code>list1=[30, 50], list2=[20, 31, 90], ans= 29</code> as a testcase, since that's a case many faulty algorithms will get wrong</span>
<span class="comment-copy">This relies on list2 being smaller than list1, which the op edited after you posted. pretty sure an <code>if len(l2 &gt; l1): l1, l2 = l2, l1</code> is all that's needed to make it order agnostic.</span>
<span class="comment-copy">For list1=[20, 31, 90], list2=[30, 50] this gives [1, 30], while the correct result is 29.</span>
<span class="comment-copy">This will fail in a case like <code>[6, 20]</code> and <code>[1, 10]</code>: <code>10-6 + 20-1 = 23</code> is not the absolute minimum, but instead we must pick the non-optimal pairing for 6 to greatly reduce the distance for 20 =&gt; <code>6-1 + 20-10 = 15</code>.</span>
<span class="comment-copy">This relies on the structure of the original example data, it fails on: <code>[1, 2, 100][3, 4]</code> (and also Set 2 in the OPs post)</span>
<span class="comment-copy">Yeah, @TemporalWolf I should've tested set 2. Let me think around it a bit. Thanks.</span>
<span class="comment-copy">@TemporalWolf removed <code>reverse=True</code> in <code>sorted()</code> and it works</span>
<span class="comment-copy">Which breaks the original example. Ultimately, you cannot rely on the order of the list to pair nodes: <code>[1, 10, 11, 100]</code> and <code>[12,13]</code> breaks forward and reverse lists.</span>
<span class="comment-copy">Granted it's not efficient (n^2), but given your constraint of only two lists, I don't find that to be a huge issue unless your lists are going to be gargantuan.</span>
<span class="comment-copy">This doesn't produce valid output for <code>[6, 20] [1, 10]</code>. It finds that <code>6</code> is closer to <code>1</code> and <code>10</code> and then uses it for both.</span>
<span class="comment-copy">@TemporalWolf you're right - revised.</span>
<span class="comment-copy">There is still some issue: <code>[6, 20][1, 10]</code> gives 14, which is correct while <code>[1, 10][6, 20]</code> gives 9... it appears to still be able to select an item from the second list twice.</span>
<span class="comment-copy">@TemporalWolf sigh... I'v spent enough time on this for now, if you have any suggestions feel free.  This turned out to be trickier than I thought.</span>
