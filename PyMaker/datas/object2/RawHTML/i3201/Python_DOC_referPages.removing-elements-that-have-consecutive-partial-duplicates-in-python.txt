<div class="post-text" itemprop="text">
<p>My question is <a href="https://stackoverflow.com/questions/5738901/removing-elements-that-have-consecutive-duplicates-in-python">similar to this</a>, but instead of removing full duplicates I'd like to remove consecutive partial "duplicates" from a list in python.</p>
<p>For my particular use case, I want to remove words from a list that start consecutive with the same character, and I want to be able to define that character. For this example it's <code>#</code>, so</p>
<pre><code>['#python', 'is', '#great', 'for', 'handling', 
'text', '#python', '#text', '#nonsense', '#morenonsense', '.']
</code></pre>
<p>should become</p>
<pre><code>['#python', 'is', '#great', 'for', 'handling', 'text', '.']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one solution using <code>itertools.groupby</code>. The idea is to group items depending on whether the first character is equal to a given <code>k</code>. Then apply your 2 criteria; if they are not satisfied, you can yield the items.</p>
<pre><code>L = ['#python', 'is', '#great', 'for', 'handling', 'text',
     '#python', '#text', '#nonsense', '#morenonsense', '.']

from itertools import chain, groupby

def list_filter(L, k):
    grouper = groupby(L, key=lambda x: x[0]==k)
    for i, j in grouper:
        items = list(j)
        if not (i and len(items) &gt; 1):
            yield from items

res = list_filter(L, '#')

print(list(res))

['#python', 'is', '#great', 'for', 'handling', 'text', '.']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; lst = ['#python', 'is', '#great', 'for', 'handling', 'text', '#python', '#text', '#nonsense', '#morenonsense', '.']    
&gt;&gt;&gt; [s for k, g in ((k, list(g)) for k, g in groupby(lst, key=lambda s: s.startswith("#")))
...    if not k or len(g) == 1 for s in g]
...
['#python', 'is', '#great', 'for', 'handling', 'text', '.']
</code></pre>
<p>This groups elements by whether they start with a <code>#</code>, then uses only those elements that do not or where the group only has a single element.</p>
</div>
<div class="post-text" itemprop="text">
<p>One single iteration is enough, provided you keep some context: the previous element and whether pre-previous was kept.</p>
<pre><code>def filter_lst(lst, char):
    res = []               # the future returned value
    keep = True            # initialize context
    old = lst[0]
    for word in lst[1:]:   # and iterate (first element is already in old)
        if old[0] != char or (keep and word[0] != char):
            res.append(old)
            keep = True
        else:
            keep = False
        old = word
    if keep or (old[0] != char):   # don't forget last element!
        res.append(old)
    return res
</code></pre>
<p>It gives:</p>
<pre><code>&gt;&gt;&gt; lst = ['#python', 'is', '#great', 'for', 'handling', 
       'text', '#python', '#text', '#nonsense', '#morenonsense', '.']
&gt;&gt;&gt; filter_lst(lst, '#')
['#python', 'is', '#great', 'for', 'handling', 'text', '.']
</code></pre>
</div>
