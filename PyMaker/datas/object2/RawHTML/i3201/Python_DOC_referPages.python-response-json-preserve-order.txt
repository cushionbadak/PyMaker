<div class="post-text" itemprop="text">
<p>I have a json object which is returned against a post call</p>
<pre><code>r = requests.post("url", json=data)
</code></pre>
<p>I was doing <code>r.json()</code> to get the json object. But as I understand it creates a dict object which is unordered. I need to preserve the order.</p>
<p>I saw the solution described here: <a href="https://stackoverflow.com/questions/10844064/items-in-json-object-are-out-of-order-using-json-dumps">Items in JSON object are out of order using "json.dumps"?</a></p>
<p>But my challenge is my starting point is a response object. How do I take it and convert to a json with the order preserved?</p>
<p>Adding some more details:</p>
<p>My API call returns an object of form:</p>
<pre><code>[{
    "key01": "value01",
    "key02": "value02",
    "keyN": "valueN"
},
{
    "key01": "value01",
    "key02": "value02",
    "keyN": "valueN"
},
{
    "key01": "value01",
    "key02": "value02",
    "keyN": "valueN"
}
]
</code></pre>
<p>I have a table with three columns as key01,key02 and keyN.</p>
<p>I need to post this json object after some minor manipulations to a software maintaining that specific order of key01,key02 and keyN.</p>
<p>But as soon as I do response.json() it is changing the order. I have tried to use the orderedlist approach as mentioned in the two other threads but so far my object is looking like this: </p>
<pre><code>b"OrderedDict([('key01','value01'),('key02','value02'),('keyN','valueN')])
</code></pre>
<p>How do I get a json which looks like this instead: <code>{"key01":"value01","key02":"value02","keyN":"valueN"}</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The requests doesn't have the best documentation, but from reading its source code <a href="https://github.com/requests/requests/blob/master/requests/models.py#L876-L900" rel="nofollow noreferrer">on the <code>.json()</code> method</a>, we can see that it's defined as followed:</p>
<pre><code>def json(self, **kwargs):
    r"""Returns the json-encoded content of a response, if any.
    :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
    :raises ValueError: If the response body does not contain valid json.
    """

    if not self.encoding and self.content and len(self.content) &gt; 3:
        # No encoding set. JSON RFC 4627 section 3 states we should expect
        # UTF-8, -16 or -32. Detect which one to use; If the detection or
        # decoding fails, fall back to `self.text` (using chardet to make
        # a best guess).
        encoding = guess_json_utf(self.content)
        if encoding is not None:
            try:
                return complexjson.loads(
                    self.content.decode(encoding), **kwargs
                )
            except UnicodeDecodeError:
                # Wrong UTF codec detected; usually because it's not UTF-8
                # but some other 8-bit codec.  This is an RFC violation,
                # and the server didn't bother to tell us what codec *was*
                # used.
                pass
    return complexjson.loads(self.text, **kwargs)
</code></pre>
<p>where <code>complexjson</code> is the std <code>json</code> library or <code>simplejson</code> if you have that installed.</p>
<p>Knowing that, you can actually pass in keyword arguments to <code>.json()</code> which will directly go to <code>json.loads()</code>. Which means that you can do what the <a href="https://stackoverflow.com/a/23820416/6622817">answer you linked</a> proposed:</p>
<hr/>
<pre><code>from collections import OrderedDict
r.json(object_pairs_hook=OrderedDict)
</code></pre>
<hr/>
<blockquote>
<p><a href="https://docs.python.org/3/library/json.html#json.load" rel="nofollow noreferrer"><strong><code>json.loads()</code></strong></a></p>
<p><em><code>object_pairs_hook</code></em> is an optional function that
  will be called with the result of any object literal decoded with an
  ordered list of pairs. The return value of <code>object_pairs_hook</code> will be
  used instead of the <code>dict</code>. This feature can be used to implement custom
  decoders. If <code>object_hook</code> is also defined, the <code>object_pairs_hook</code> takes
  priority.</p>
</blockquote>
<p><br/></p>
<blockquote>
<p><a href="https://simplejson.readthedocs.io/en/latest/#simplejson.load" rel="nofollow noreferrer"><strong><code>simplejson.loads()</code></strong></a></p>
<p><em><code>object_pairs_hook</code></em> is an optional function that will be called with the
  result of any object literal decode with an ordered list of pairs. The
  return value of <code>object_pairs_hook</code> will be used instead of the <code>dict</code>.
  This feature can be used to implement custom decoders that rely on the
  order that the <code>key</code> and <code>value</code> pairs are decoded (for example,
  <code>collections.OrderedDict</code> will remember the order of insertion). If
  <code>object_hook</code> is also defined, the <code>object_pairs_hook</code> takes priority.</p>
</blockquote>
<p>Therefore, either way you will be able to provide the <code>object_pairs_hook</code> keyword argument to <code>r.json()</code>.</p>
<hr/>
<p>From the information I received from the comments, you don't even need to parse the json, just do:</p>
<pre><code>text = r.content.decode(requests.utils.guess_json_utf(r.content)).encode('utf-8')
</code></pre>
<p>and you can "post" text to wherever you desire.</p>
</div>
<div class="post-text" itemprop="text">
<p>Relying on the order of json keys from a server (especially one that you don't control) is very fragile. The <a href="https://tools.ietf.org/html/rfc7159" rel="nofollow noreferrer">RFC says</a>:</p>
<blockquote>
<p>An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</p>
</blockquote>
<p>It also specifically comments:</p>
<blockquote>
<p>JSON parsing libraries have been observed to differ as to whether or not they make the ordering of object members visible to calling software.  Implementations whose behavior does not depend on member ordering will be interoperable in the sense that they will not be affected by these differences.</p>
</blockquote>
<p>Thus, it is RFC compliant for an implementation (on the server) to change how it orders the produced JSON.</p>
<p>If you don't know if the server is using a serialization library that guarantees order, then this could break in the future (if the library changes). Even if you do, if that library takes the server language's equivalent of a <code>dict</code>, upgrading the language or standard library could change the semantics of that <code>dict</code> such that the ordering changes (and your code breaks). As an example, from Python 3.6 to 3.7 <code>dicts</code> changed from arbitrary order to ordered by insertion. In other languages such as <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html" rel="nofollow noreferrer">rust</a>, which seed the hash function used by their hashmaps to <a href="https://arstechnica.com/information-technology/2011/12/huge-portions-of-web-vulnerable-to-hashing-denial-of-service-attack/" rel="nofollow noreferrer">prevent DoS attacks</a>, the ordering could be dependent on the randomness used to seed these hash functions (decided at runtime, and may be different if you, say, restart the server).</p>
<p>It's much more safe if you know that you need the data in a certain order to construct it that way yourself:</p>
<pre><code>from collections import OrderedDict

ORDERED_KEYS = ['first', 'second', 'third']
ordered_json = OrderedDict((k, r.json()[k]) for k in ORDERED_KEYS)
</code></pre>
<p>From your comment, it seems like you need that dictionary serialized again. If you use <code>json.dumps</code> on an <code>OrderedDict</code>, the serialization will be in insertion order:</p>
<pre><code>import json

serialized_ordered_json = json.dumps(ordered_json)
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/10844064/items-in-json-object-are-out-of-order-using-json-dumps">Items in JSON object are out of order using "json.dumps"?</a></span>
<span class="comment-copy">In particular, on &lt;3.7, make <code>data</code> an <code>OrderedDict</code></span>
<span class="comment-copy">@BaileyParker The OP is asking for the return json to be ordered (accessed by <code>r.json()</code>), they're not asking about <code>data</code>.</span>
<span class="comment-copy">Indeed, I misread. I'd contest that relying on the order of json keys from a server (especially one you don't control, but even one you do) is pretty fragile. I'd recommend against it. If you want to iterate over the <code>dict</code> in a particular order, why not make a list of the keys <code>keys = ['first', 'second', ...]</code> and then <code>for k in key: r.json()[k]</code>?</span>
<span class="comment-copy">Hi @BaileyParker thanks for your response. I have an internal process which takes a json object and maps it to a database table. The order of rows in the . table must match the exact sequence in the json. Unfortunately I cannot change the intermediate logic (it's a vendor product). The sequence of elements returned from the API is same as in the table. The response.json() method is changing it.</span>
<span class="comment-copy">Hi @abccd , thanks for your detailed description. Very helpful. I have added a little more details to the question. Does that help in anyway to solve my problem?</span>
<span class="comment-copy">Still... does <code>r.json(object_pairs_hook=OrderedDict)</code> not work? The object it returns is basically the ordered version of your desired <code>dict</code>. For Python&lt;=3.5, <code>dict</code> are not ordered.</span>
<span class="comment-copy">Nope :(. It is transforming my json to look like this: b"OrderedDict([('key01','value01'),('key02','value02'),('keyN','valueN')]) WHEREAS I need it to look like this: {"key01":"value01","key02":"value02","keyN":"valueN"}. Thats my original format in which it is in the response object BTW.</span>
<span class="comment-copy">@Anubis05 from reading your other comment, I think you want <code>text = r.content.decode(requests.utils.guess_json_utf(r.content)).encode('utf-8')</code></span>
<span class="comment-copy">BTW I am using python 3.5.2</span>
<span class="comment-copy">I just tried this approach. This does what you described. But now my json object looks like this: b"OrderedDict([('key01','value01'),('key02','value02'),('keyN','valueN')]) .  Which however MUST look like this:  {"key01":"value01","key02":"value02","keyN":"valueN"}. Thats the only format which the next process accepts. I am getting my initial json in the same format as is expected at next steps.</span>
<span class="comment-copy">Or in another way to describe. I would ideally like responseObj -&gt;json -&gt;utf-8 encoding -&gt;post the json . The json at last step need to look like this {"key01":"value01","key02":"value02","keyN":"valueN"} which is what I am getting in 2nd step. But since I am doing a response.json() to arrive at step 2, it is messing up the order. Can't I just take a json object as is from a response object, apply utf-8 and pass along to next steps?</span>
<span class="comment-copy">See my edit for how to get this back in a serialized form.</span>
