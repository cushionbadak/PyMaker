<div class="post-text" itemprop="text">
<pre><code>def initial_number_adder(first_number_ever):
    # takes an integer from user and adds 1
    added_number = first_number_ever + 1
    return added_number


async def repeated_number_adder(old_result):
    while 1:
        await asyncio.sleep(0.5)
        if datetime.utcnow().second == 0 or datetime.utcnow().second == 30:
            # takes the integer from the initial fxn, initially.

            # takes the return value from itself on the 0th and 30th second of 
            # every minute, from then on.

            # adds 1 as well.

            new_result = old_result + 1
            print(new_result)
            return await new_result


async def other_cool_fxn():
    print('extra function to make things more complex')
    await asyncio.sleep(1)


async def main():
    first_time = 0
    # first result comes from user input. for example '1'
    if first_time == 0:
        first_result = initial_number_adder(1)
        first_time = 1
        second_result = await asyncio."""wait or gather?"""([repeated_number_adder(first_result)])
    else:
        # for all results after the first (and the second in this case. I'm hoping to clean this up and only run repeated_number_adder in the loop below.
        all_subsequent_results = await asyncio."""wait/gather"""([repeated_number_adder("""result of return of repeated_number_adder"""),other_cool_fxn()])
        # want something like a future here   



loop = asyncio.get_event_loop() 
loop.run_forever(main())
</code></pre>
<p>I'm hoping to run an initial (synchronous) function (initial_number_adder), pass it's return to a second function that's async (repeated_number_adder), and then run that function in a loop, passing it's previous return value back into itself, forever.
<br/><br/>
If I can make both functions async, and manage the single initial run of the first, from the task list, that would be great also. This was just the best way I could imagine doing it to begin with (initial synchronous pass into async loop)
<br/><br/>
I'll be using a setup like this with aiohttp to make GET requests. One function returns a large DataFrame initially, the second function will async append one new row and make calculations every 15 minutes, then pass the DataFrame and calcs back into itself. (just wanted to give a gist for anyone curious)
<br/><br/>
I appreciate your time. Let me know if there's anything that needs clarification.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are several issues with the pseudo-code in the question.</p>
<ul>
<li><p><code>run_forever()</code> doesn't accept a coroutine; it accepts no arguments and runs the <em>event loop</em> forever (or until <code>loop.stop()</code> is invoked). To run a coroutine forever, simply use a <code>while True</code> loop in its body, and add it to the loop before calling <code>run_forever()</code>.</p></li>
<li><p><code>await new_result</code> won't work because <code>new_result</code> is an integer. Valid arguments to <code>await</code> are <a href="https://docs.python.org/3/glossary.html#term-awaitable" rel="nofollow noreferrer"><em>awaitable objects</em></a>, such as coroutines and futures. If the result is ready, it is perfectly fine to return it from the coroutine using the regular <code>return</code> statement.</p></li>
<li><p>You don't need <code>gather</code> or <code>wait</code> to await a single coroutine, as in the first invocation of <code>repeated_number_adder</code>, you can <code>await</code> it directly. You need <code>gather</code> to await the results of multiple coroutines running in parallel.</p></li>
</ul>
<p>With those in mind, you could write the program as follows:</p>
<pre><code>import asyncio
from datetime import datetime

def initial_number_adder(first_number_ever):
    # takes an integer from user and adds 1
    added_number = first_number_ever + 1
    return added_number

async def repeated_number_adder(old_result):
    while True:
        await asyncio.sleep(0.5)
        if datetime.utcnow().second == 0 or datetime.utcnow().second == 30:
            return old_result + 1

async def other_cool_fxn():
    print('extra function to make things more complex')
    await asyncio.sleep(1)

async def main():
    next_number = initial_number_adder(1)
    while True:
        next_number, _cool_result = await asyncio.gather(
            repeated_number_adder(next_number), other_cool_fxn())
        print('got', next_number)

loop = asyncio.get_event_loop()
# or simply loop.run_until_complete(main()), which will never complete
loop.create_task(main())
loop.run_forever()
</code></pre>
</div>
