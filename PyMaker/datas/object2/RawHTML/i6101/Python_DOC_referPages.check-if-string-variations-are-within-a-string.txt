<div class="post-text" itemprop="text">
<p>I should note that we are only allowed to use built in python string functions and loop functions.</p>
<p>A = 'bet[bge]geee[tb]bb'</p>
<p>B = 'betggeeetbb'</p>
<p>The square brackets mean any single one of the characters inside the bracket can be used so you could have</p>
<ol>
<li>bet<code>b</code>geee<code>t</code>bb</li>
<li>bet<code>g</code>geee<code>t</code>bb</li>
<li>bet<code>e</code>geee<code>t</code>bb</li>
<li>bet<code>b</code>geee<code>b</code>bb</li>
<li>bet<code>g</code>geee<code>b</code>bb</li>
<li>bet<code>e</code>geee<code>b</code>bb</li>
</ol>
<p>How do I check A will have a combination that can be found within B.
A can have any number of brackets, with a minimum of 2 characters and a maximum of 4 characters in each square bracket</p>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Read up on the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expressions library</a>. The solution is literally the <code>re.match</code> function, whose documentation includes the following bit:</p>
<blockquote>
<p><code>[]</code> Used to indicate a set of characters. In a set:</p>
<ul>
<li>Characters can be listed individually, e.g. [amk] will match 'a', 'm', or 'k'.</li>
</ul>
</blockquote>
<p>Since regular expressions use backslashes for their own purpose (beyond Python's normal escapes, e.g. <code>"\n"</code> to represent a newline), <a href="https://docs.python.org/3/tutorial/introduction.html#strings" rel="nofollow noreferrer">raw strings</a> are idiomatic in the matching string.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; A = r'bet[bge]geee[tb]bb'
&gt;&gt;&gt; B = 'betggeeetbb'
&gt;&gt;&gt; m = re.match(A, B)
&gt;&gt;&gt; m
&lt;_sre.SRE_Match object; span=(0, 11), match='betggeeetbb'&gt;
&gt;&gt;&gt; m.group(0)
'betggeeetbb'
</code></pre>
<p>You can also verify that it doesn't match if (say) the second bracket is not matched:</p>
<pre><code>&gt;&gt;&gt; C = "betggeeezbb"
&gt;&gt;&gt; m = re.match(A, C)
&gt;&gt;&gt; m is None
True
</code></pre>
<p>Before you go about adding this liberally to an existing project, make sure you understand:</p>
<ul>
<li>What is the difference between <a href="https://docs.python.org/3/library/re.html#re.search" rel="nofollow noreferrer">re.search</a> and <a href="https://docs.python.org/3/library/re.html#re.match" rel="nofollow noreferrer">re.match</a>?</li>
<li>What is the cost of creating a regular expression? <a href="https://docs.python.org/3/library/re.html#re.compile" rel="nofollow noreferrer">How can you avoid</a> this cost if the regular expression is used repeatedly?</li>
<li>How can you <a href="https://docs.python.org/3/library/re.html#re.match.group" rel="nofollow noreferrer">extract parts of a matching expression</a> (e.g. the character matched by <code>[bge]</code> in your example)?</li>
<li>How can you perform <a href="https://docs.python.org/3/library/re.html#re.M" rel="nofollow noreferrer">matches on strings that contain newlines</a>?</li>
</ul>
<p>Finally, when learning regular expressions (similarly to learning class inheritance), it's tempting to use them everywhere. Meditate on <a href="http://regex.info/blog/2006-09-15/247" rel="nofollow noreferrer">this koan from Jamie Zawinski</a>:</p>
<blockquote>
<p>Some people, when confronted with a problem, think “I know, I'll use regular expressions.” Now they have two problems.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It's easiest to break your problem up into simpler tasks. There are many ways to convert your pattern from just a plain string into something with more structure, but here's something that uses only plain string operations to get you started:</p>
<pre><code>def parse_pattern(pattern):
    '''
    &gt;&gt;&gt; parse_pattern('bet[bge]geee[tb]bb')
    ['b', 'e', 't', ['b', 'g', 'e'], 'g', 'e', 'e', 'e', ['t', 'b'], 'b', 'b']
    '''

    in_group = False
    group = []
    result = []

    # Iterate through the pattern, character by character
    for c in pattern:
        if in_group:
            # If we're currently parsing a character
            # group, we either add a char into current group
            # or we end the group and go back to looking at 
            # normal characters
            if c == ']':
                in_group = False
                result.append(group)
                group = []
            else:
                group.append(c)
        elif c == '[':
            # A [ starts a character group
            in_group = True
        else:
            # Otherwise, we just handle normal characters
            result.append(c)

    return result

def check_if_matches(string, pattern):
    parsed_pattern = parse_pattern(pattern)

    # Useful thing to note: `string` and `parsed_pattern`
    # have the same number of elements once we parse the
    # `pattern`

    ...

if __name__ == '__main__':
    print(check_if_matches('betggeeetbb', 'bet[bge]geee[tb]bb'))
</code></pre>
</div>
<span class="comment-copy">Have you tried anything to solve this problem yourself? Please show it</span>
<span class="comment-copy">So, you're looking for regex then</span>
<span class="comment-copy">@everyone suggesting regex: Regex has a lot more features than just "things in square brackets". Correctly escaping all the regex metacharacters <i>except</i> the character classes is probably more difficult than writing a non-regex solution.</span>
<span class="comment-copy">@roganjosh I can't wrap my head around how to do so when you consider there could be any number of brackets. I can split the string and check for the text before the bracket, then check for any possibility in the brackets, then check the text after the bracket. But I am unsure of how to loop it to cover n loops</span>
<span class="comment-copy">How would you do it without a computer? Work that out, turn it into a step-by-step procedure, and translate that into working code.</span>
<span class="comment-copy"><i>"The solution is literally the re.match function"</i> It's not. You have to use <code>re.fullmatch</code>, or add an end-of-string anchor <code>$</code> to the regex. Also, please don't use the term "raw string"; it gives newbies the impression that they're some kind of special string. Please call them "raw string literals" instead.</span>
<span class="comment-copy">The question asked if the string variation was within another string. <code>fullmatch</code> isn't quite it, and maybe even my suggestion of <code>match</code> was wrong.</span>
