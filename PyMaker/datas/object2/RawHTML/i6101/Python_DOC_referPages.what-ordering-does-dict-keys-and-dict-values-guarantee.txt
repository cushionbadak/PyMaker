<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/835092/python-dictionary-are-keys-and-values-always-the-same-order">Python dictionary: are keys() and values() always the same order?</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<blockquote>
<p>This question arises from <a href="https://stackoverflow.com/a/23600844/4909087">this
  answer</a> where one user
  uses <code>d.keys()</code> and <code>d.values()</code> separately to initialise a dataframe.</p>
</blockquote>
<p>It's common knowledge that dictionaries in python versions under 3.6 are not ordered. </p>
<p>Consider a generic dictionary of the form:</p>
<pre><code>d = {k1 : v1, k2 : v2, k3 : v3}
</code></pre>
<p>Where the keys <code>k*</code> are any hashable objects, and the values <code>v*</code> being any object. Of course, order cannot be guaranteed, but what about the order of <code>d.keys()</code> and <code>d.values()</code>?</p>
<p><strong>Python 2.x</strong></p>
<p>Both <code>d.keys()</code> and <code>d.values()</code> return lists. Say, <code>.keys()</code> returns <code>d</code>'s keys in the order <code>[k2, k1, k3]</code>. Is it now <em>always guaranteed</em> that <code>d.values()</code> returns the same relative ordering as <code>[v2, v1, v3]</code>? Furthermore, does the ordering remain the same no matter how many times these functions are called?</p>
<p><strong>Python 3.x (&lt;3.6)</strong></p>
<p>I'm not 100% sure, but I believe that <code>.keys</code> and <code>.values</code> do not guarantee any ordering at all here because they are set-like structures, thus having no order by definition and enabling you to perform set-like operations on them. But I'd still be interested to know if there is <em>any</em> sort of relative ordering between the two calls in this instance. <strong>I'm guessing not.</strong> I'd appreciate if someone could affirm or correct me.</p>
</div>
<div class="post-text" itemprop="text">
<p>The general rules:</p>
<ol>
<li>Before talking about what is guaranteed and what isn't, even if some ordering seems to be "guaranteed", it isn't.  You should not rely on it. It is considered bad practice, and could lead to nasty bugs.</li>
<li><code>d.keys()</code>, <code>d.values()</code>, and <code>d.items()</code> all return the elements in a respective order.  The order should be treated as arbitrary (no assumptions should be made about it). (<a href="https://docs.python.org/2/library/stdtypes.html#dict.items" rel="nofollow noreferrer">docs</a>)</li>
<li>consecutive calls to <code>d.keys()</code>, <code>d.values()</code>, and <code>d.items()</code> are "stable", in the sense they are guaranteed to preserve the order of previous calls (assuming no insertion/deletion happens between the calls).</li>
<li>Since CPython's V3.6, <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-compactdict" rel="nofollow noreferrer"><code>dict</code> has been reimplemented</a>, and it now preserves <em>insertion</em> order.  This was not the goal of the change, but a side effect, and it is NOT part of the python spec, only a detail of the CPython implementation.  See point #1 above: relying on this is bad practice and should not be done.  Anyways, you should avoid writing CPython-specific code.</li>
<li>In Python2, order is deterministic (i.e. creating a dict twice in the same way will result with the same order).  In Python &lt;3.6, it is no longer deterministic, so you can't rely on that either (I'm not sure if this non-determinism is part of the spec or just a CPython implementation detail).</li>
</ol>
<p>EDIT: added point #5, thanks to @AndyHayden's comment.</p>
</div>
<span class="comment-copy">In python 3.6+ (I think) there're ordered, the question is not whether you can use it,  but whether you should (I'm in the "you should" camp). See also <a href="https://stackoverflow.com/a/39980744/1240268">stackoverflow.com/a/39980744/1240268</a></span>
<span class="comment-copy">Looks like <code>keys()</code> and <code>values()</code> come out in the same order. In python 2 it's arbitrary (but consistent) - but in python 3 it seems to be in definition order. Either way, it isn't a good idea to rely on this... There's no reason to, with <code>items()</code>. Python 2 = <a href="https://repl.it/NwCu/0" rel="nofollow noreferrer">repl.it/NwCu/0</a> Python 3 = <a href="https://repl.it/NwDC/0" rel="nofollow noreferrer">repl.it/NwDC/0</a></span>
<span class="comment-copy">@AndyHayden - the fact it's not guaranteed in the spec is by far the most overwhelming reason to not rely on it in my opinion :P They even say in the docs that it's an implementation detail that you shouldn't rely on...</span>
<span class="comment-copy">@Shadow I'm with <a href="https://twitter.com/raymondh/status/850102884972675072" rel="nofollow noreferrer">Raymond Hettinger</a>. I also use f-strings everywhere now so everyone is forced to upgrade if they want to run my code.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ and for python 3 also <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#dictionary-view-objects</a>. Which is to say the answer you linked to isn't broken hmmm, it's still a little fishy - mainly as you want the .keys() and .values() calls to be close together. If there was somewhere to bet that it'd make it to the spec I would.</span>
<span class="comment-copy">Thanks, this reaffirms my suspicions. Do you have any sources you can draw from?</span>
<span class="comment-copy">Especially part 3) about the stable ordering is very useful information that I didn't know about. So, to summarise, whether there is relative ordering or not, I shouldn't assume there is. Am I right?</span>
<span class="comment-copy">For any future readers, see CPython implementation footnote <a href="https://docs.python.org/2/library/stdtypes.html#dict.items" rel="nofollow noreferrer">here</a>, and the bit about guaranteed correspondence just below.</span>
<span class="comment-copy">@AndyHayden I don't have a reference, but when you think about it, it is a direct result of point #2. If calling <code>keys()</code> and then <code>values()</code> preservers order, and calling <code>values()</code> and then <code>keys()</code> preserves order, it follows that calling <code>keys()</code> and then <code>keys</code>() preserves order.  It is easy to give a formal proof for that.</span>
<span class="comment-copy">The non-determinism mentioned in point #5 is due to the non-determinism of the Python 3 <code>hash</code> function, which by default uses a random value to seed the hashes of str, bytes and datetime objects. You can set the PYTHONHASHSEED environment variable to a (machine) integer to make it deterministic. This is briefly mentioned in the command-line help, although that help claims that you need to set PYTHONHASHSEED to 'random' to invoke the random behaviour, that hasn't been true for several versions.</span>
