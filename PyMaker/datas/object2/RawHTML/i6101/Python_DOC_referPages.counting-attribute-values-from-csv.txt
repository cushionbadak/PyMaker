<div class="post-text" itemprop="text">
<p>I want to create a function that returns the count of each attribute value from a csv, the output should be a dictionary (for every attribute one) where the keys are the distinct attribute values and the associated values are the number of times that value occurs in the data...</p>
<p>for example I have the following CSV-File (the first line is the header):</p>
<pre class="lang-none prettyprint-override"><code>First_Name,Last_Name,Age
Johnny,Got,22
Michael,Jackson,22
Johnny,Jackson,50
Andrea,Got,12
</code></pre>
<p>and I would wish to have that as output then,</p>
<pre><code>for first name: {'Johnny': 2, 'Michael': 1, 'Andrea': 1}
for the second name: {'Jackson': 2, 'Got': 2}
and for the age: {22: 2, 50: 1, 12: 1}
</code></pre>
<p>I think I could do it with using the <code>Counter</code> class from the python <code>collections</code> module when I use the <code>DictReader</code> type for the CSV so that each row is a dictionary as well. But I still can't bring it to work, does anyone have an idea if that is possible? Here what I tried until now. <code>:)</code></p>
<pre><code>import csv
import os
import collections

FIRSTNAME_ATT = 'First_Name'
LASTNAME_ATT = 'Last_Name'
AGE_ATT = 'Age'


def count_attributes(file_name):
    firstname_counts = {}
    lastname_counts = {}
    age_counts = {}

    with open(file_name, encoding='utf-8') as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            for i, val in enumerate(row):
                count_number[i][val] += 1
# Here I don't get any further :(
    return firstname_counts, lastname_counts, age_counts


if __name__ == '__main__':
    data_file = os.path.join("..", "data", "thecsvfile.csv")
    firstname_counts, lastname_counts, age_counts = attribute_counts(data_file)
    print(firstname_counts)
    print(lastname_counts)
    print(age_counts)
</code></pre>
<p>Would be great if anyone has an hint or an idea how to solve that. <code>:)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to <code>collections.Counter</code>, you could use a <code>collections.OrderedDict</code> to keep things simple plus make the processing largely "date-driven" in the sense that the contents of the csv file itself will determine what the attributes are (instead of hardcoding their names).</p>
<p>The use of <code>OrderedDict</code> preserves the order of the attributes in the csv file's header row. </p>
<p>Here's what I'm saying:</p>
<pre><code>import os
import csv
from collections import Counter, OrderedDict

def count_attributes(file_name):
    with open(file_name, encoding='utf-8', newline='') as csv_file:
        reader = csv.DictReader(csv_file)
        counters = OrderedDict((attr, Counter()) for attr in reader.fieldnames)
        for row in reader:
            for attr, value in row.items():
                counters[attr][value] += 1

    return counters

if __name__ == '__main__':
#    data_file = os.path.join("..", "data", "thecsvfile.csv")
    data_file = "thecsvfile.csv"  # Slight simplification for testing.
    for attr, counts in count_attributes(data_file).items():
        print('{}: {}'.format(attr.replace('_', ' '), dict(counts)))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>First Name: {'Johnny': 2, 'Michael': 1, 'Andrea': 1}
Last Name: {'Got': 2, 'Jackson': 2}
Age: {'22': 2, '50': 1, '12': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Solution</strong>:</p>
<pre><code>firstname_counts = {}
lastname_counts = {}
age_counts = {}

with open(file_name, encoding='utf-8') as csv_file:
    reader = csv.DictReader(csv_file)
    for row in reader:
        firstname_counts[row['First_Name']] = firstname_counts.get(row['First_Name'], 0) + 1
        lastname_counts[row['Last_Name']] = lastname_counts.get(row['Last_Name'], 0) + 1
        # similar for age...
</code></pre>
<p>You just need to check if the key in the dictionaries exist, if it does, add value 1 or get 0 when it does not exist and add 1. <code>.get</code> method 
 in dictionary solves it.</p>
<p>Ref: <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">dict .get method</a></p>
<p>EDIT:</p>
<p><strong>Solution 2 (Using <code>collections.Counter</code>)</strong>:</p>
<pre><code>from collections import Counter

firstname_counts = Counter()
lastname_counts = Counter()
age_counts = Counter()

# same code as in the above solution.
</code></pre>
</div>
<span class="comment-copy">wow, that's a very nice way to do it, thank you so much!</span>
<span class="comment-copy">Sandra: That's good to hear...one of our aims here is to please. <code>;Â¬)</code></span>
<span class="comment-copy">Is <code>0</code> is the fallback value here? <code>firstname_counts.get(row['First_Name'], 0)</code></span>
<span class="comment-copy">@bhansa Yes. It is the fallback (default) value, if the key does not exist in the <code>dict</code> object.</span>
<span class="comment-copy">thanks for your reply! I wanted to use the Counter type from the python collections module because then it would be sorted by the value (attribute with highest number in first position), I guess I need to do it completely different then?</span>
<span class="comment-copy">answer updated.</span>
