<div class="post-text" itemprop="text">
<p>I'm making a couple of functions via <code>exec</code>, that could possibly error. However when Python errors out it doesn't display the line that the error occurred on.</p>
<p>For example using:</p>
<pre><code>fn_str = '''\
def fn():
    raise Exception()
'''

globs = {}
exec(fn_str, globs)
fn = globs['fn']

fn()
</code></pre>
<p>Gives us the output:</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "...", line 10, in &lt;module&gt;
    fn()
  File "&lt;string&gt;", line 2, in fn
Exception
</code></pre>
<hr/>
<p>If we however, don't use eval. Then we get the line that the program errored on:</p>
<pre><code>def fn():
    raise Exception()

fn()
</code></pre>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "...", line 4, in &lt;module&gt;
    fn()
  File "...", line 2, in fn
    raise Exception()
Exception
</code></pre>
<hr/>
<p>I've looked into using the <code>__traceback__</code>, however I couldn't find a way to add to the traceback under the 'File' line. And so the best I could get was this:</p>
<pre><code>fn_str = '''\
def fn():
    try:
        raise Exception()
    except BaseException as e:
        tb = e.__traceback__
        if 1 &lt;= tb.tb_lineno &lt;= len(fn_lines):
            e.args = ((e.args[0] if e.args else '') + ' - ' + fn_lines[tb.tb_lineno - 1].strip(),)
        raise
'''

globs = {'fn_lines': fn_str.split('\n')}
exec(fn_str, globs)
fn = globs['fn']

fn()
</code></pre>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "...", line 16, in &lt;module&gt;
    fn()
  File "&lt;string&gt;", line 3, in fn
Exception:  - raise Exception()
</code></pre>
<p>The biggest problem with this is if the <code>eval</code> calls other code, it becomes confusing where the <code>- raise Exception()</code> comes from.</p>
<hr/>
<p>Is there a way to make the eval code provide the line that it errored on?</p>
</div>
<div class="post-text" itemprop="text">
<p>That happens when the interpreter is unable to find the source code for
that line for whatever reason. This is the case for built-in modules,
compiled files, <code>exec</code> strings, etc. More specifically, in the traceback
you can see that the filename for the <code>fn</code>'s code object is set to 
<code>&lt;string&gt;</code></p>
<pre><code>File "&lt;string&gt;", line 2, in fn
</code></pre>
<p>Because <code>&lt;string&gt;</code> is not a valid filename, the reference to the
source code is lost.</p>
<p>One option is to create a temporary file, write <code>fn_str</code> in there,
compile <code>fn_str</code> to set the filename, execute the compiled code, and
finally call the function. Note that you'll need to keep the file alive
at least until the source lines are cached by the traceback-printing
facility</p>
<pre><code>from tempfile import NamedTemporaryFile
import traceback

with NamedTemporaryFile('w') as temp:
    code = compile(fn_str, temp.name, 'exec')
    print(fn_str, file=temp, flush=True)
    globs = {}
    exec(code, globs)
    fn = globs['fn']
    try:
        fn()
    except:
        traceback.print_exc()
</code></pre>
<p>prints</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 16, in &lt;module&gt;
    fn()
  File "/tmp/tmp9q2bogm6", line 2, in fn
    raise Exception()
Exception
</code></pre>
<p>Since we already create a "real" file, we can delegate the
compilation and execution of code to <a href="https://docs.python.org/3/library/runpy.html#runpy.run_path" rel="nofollow noreferrer"><code>runpy.run_path</code></a>:</p>
<pre><code>from tempfile import NamedTemporaryFile
import runpy, traceback

with NamedTemporaryFile('w') as temp:
    print(fn_str, file=temp, flush=True)
    fn = runpy.run_path(temp.name)['fn']
    try:
        fn()
    except:
        traceback.print_exc()
</code></pre>
</div>
