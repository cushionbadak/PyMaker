<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer">documentation for <code>lru_cache</code></a> gives the function definition:</p>
<blockquote>
<pre><code>@functools.lru_cache(maxsize=128, typed=False)
</code></pre>
</blockquote>
<p>This says to me that <code>maxsize</code> is optional.</p>
<p>However, it doesn't like being called without an argument:</p>
<pre><code>Python 3.6.3 (default, Oct 24 2017, 14:48:20) 
[GCC 7.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import functools
&gt;&gt;&gt; @functools.lru_cache
... def f(): ...
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.6/functools.py", line 477, in lru_cache
    raise TypeError('Expected maxsize to be an integer or None')
TypeError: Expected maxsize to be an integer or None
 &gt;&gt;&gt; 
</code></pre>
<p>Calling with an argument is fine:</p>
<pre><code>&gt;&gt;&gt; @functools.lru_cache(8)
... def f(): ...
... 
&gt;&gt;&gt; 
</code></pre>
<p>Am I misreading the documentation?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to at least call lru_cache without args : </p>
<pre><code>@lru_cache()
def f():
    #content of the function
</code></pre>
<p>This way, lru_cache is initialized with default parameters.</p>
<p>This is because decorators in python (with the <code>@</code> notation) are special functions which are evaluated and called when the parser is reading the source.</p>
<p>When you write <code>@decorator_name</code> you tell python that <code>decorator_name</code> is a function that will be called with the function (or class) defined after. 
Example: </p>
<pre><code>@my_decorator
def function():
    pass
</code></pre>
<p>is equivalent to :</p>
<pre><code>def function():
    pass
decorated_function = my_decorator(function)
</code></pre>
<p>The <code>lru_cache</code> decorator is a little bit more complex because before wrapping the function, it has to create the cache (related to the function), and then wrap the function with another function that will do the cache management.
Here is the (shorted) code of the <a href="https://github.com/python/cpython/blob/master/Lib/functools.py#L445" rel="noreferrer">CPython implementation</a> :</p>
<pre><code>def lru_cache(maxsize=128, typed=False):
    # first, there is a test about the type of the parameters
    if maxsize is not None and not isinstance(maxsize, int):
        raise TypeError('Expected maxsize to be an integer or None')
    # then, the decorating function is created, this function will be called each time you'll call the 'cached' function
    def decorating_function(user_function):
        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)  # in _lru_wrapper is all the magic about the cache management, it is a 2nd layer of decorator
        return update_wrapper(wrapper, user_function)
    return decorating_function
</code></pre>
<p>So, when you wrote only </p>
<pre><code>@lru_cache
def f():
</code></pre>
<p>python called <code>lru_cache(f)</code>, and definitively, it wasn't made to handle such thing.</p>
<p>To make it compliant with this write, we should add a test to check if the first parameter (maxsize) is a callable function :</p>
<pre><code>def lru_cache(maxsize=128, typed=False):
    # first, there is a test about the type of the parameters
    if callable(maxsize):
        def decorating_function(user_function):
            wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)
            return update_wrapper(wrapper, user_function)
        return decorating_function(maxsize) # yes, maxsizeis the function in this case O:)
    if maxsize is not None and not isinstance(maxsize, int):
        raise TypeError('Expected maxsize to be an integer or None')
    # then, the decorating function is created, this function will be called each time you'll call the 'cached' function
    def decorating_function(user_function):
        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)  # in _lru_wrapper is all the magic about the cache management, it is a 2nd layer of decorator
        return update_wrapper(wrapper, user_function)
    return decorating_function
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Think about it that way: lru_cache is a decorator factory.  You call it (with or without params, but you call it) and it gives you a decorator.</p>
<p>Calling the decorator factory and applying the decorator on one line is the equivalent of this:</p>
<pre><code>with_small_cache = lru_cache(max_size=5)

@with_small_cache
def function():
    ...
</code></pre>
</div>
<span class="comment-copy">Thanks! Where does the token <code>user_function</code> defined in your code?</span>
<span class="comment-copy">@TomHale <code>user_fuinction</code> is the name of the parameter of the internal decorator, it is the/your decorated function</span>
<span class="comment-copy">Cheers! I raised <a href="https://bugs.python.org/issue32001" rel="nofollow noreferrer">this issue</a> based on your answer.</span>
<span class="comment-copy">@TomHale nice, BTW, it isn't a real code issue, probably more a hole in the documentation.</span>
<span class="comment-copy">To me, Least Surprise says that most decorators don't require <code>()</code> after them... I really like what you've done with not requiring them.</span>
