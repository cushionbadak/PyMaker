<div class="post-text" itemprop="text">
<p>I have a nest list like</p>
<pre><code>seq = [ [['a'], ['b', 'c']], ['d'], ['e', 'f']]
</code></pre>
<p>I want to turn this to a ordered dictionary like </p>
<pre><code>seq_order_dict = { '0_0_0': ['a'],
                   '0_0_1': ['b', 'c'],
                   '1_0': ['d'],
                   '2_0': ['e', 'f']}
</code></pre>
<p>the requirement is that </p>
<ol>
<li><code>seq_order_dict['2_0']</code> will get some information from previous item <code>seq_order_dict['1_0']</code> to do some thing.</li>
<li>if <code>seq_order_dict['1_0']</code> previous item <code>seq_order_dict['0_0']</code> is not exist, <code>seq_order_dict['1_0']</code> will get <code>seq_order_dict['0_0_x']</code> to do some thing. (x = 0, 1, 2, ...)</li>
</ol>
<p>I'm at my wits' end......</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe this solution will be accepted even if it does not fit all requirements:</p>
<pre><code>import collections


seq = [[['a'], ['b', 'c']], ['d'], ['e', 'f']]


def flatten(d, parent_key='', sep='_'):
    flatten_dict = collections.OrderedDict()

    for k, v in d.items():
        new_key = str(parent_key) + str(sep) + str(k) if parent_key else str(k)
        if isinstance(v, collections.MutableMapping):
            flatten_dict.update(flatten(v, new_key, sep=sep))
        else:
            flatten_dict[new_key] = v

    return flatten_dict

def list_to_dict(seq):
    if isinstance(seq, list) and all(isinstance(x, list) for x in seq):
        nested_dict = collections.OrderedDict()
        for i, item in enumerate(seq):
            nested_dict[i] = list_to_dict(item)
        return flatten(nested_dict)
    return seq


print(list_to_dict(seq))
</code></pre>
<p>Instead of <code>{ '0_0_0': ['a'], '0_0_1': ['b', 'c'], ... }</code> if will produce following:</p>
<pre><code>OrderedDict([('0_0', ['a']), ('0_1', ['b', 'c']), ('1', ['d']), ('2', ['e', 'f'])])
</code></pre>
</div>
<span class="comment-copy">Python dictionaries are <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">unordered by definition</a>. If you need an ordered sequence, you may want to use a different data structure.</span>
<span class="comment-copy">@ErickShepherd: Well, that's why <code>collections.OrderedDict</code> exists. That said, as of CPython 3.6, <code>dict</code>s are ordered as an implementation detail, which is likely (but not guaranteed) to become contractual in 3.7.</span>
<span class="comment-copy">@ShadowRanger I knew about <code>collections.OrderedDict</code> but hadn't yet heard of <code>dict</code>s being ordered in CPython 3.6. Evidently I've got some more documentation to read through. Thank you for the correction!</span>
<span class="comment-copy">Actually, the ordered dictionary is not very necessary. But it might easy to meet the requirement?</span>
<span class="comment-copy">{ '0_0': ['a'], '0_1': ['b', 'c'],  '1': ['d'], '2': ['e', 'f'], } should be the output right?</span>
<span class="comment-copy">Wow! To iterate is human, to recurse, divine! Thanks!</span>
