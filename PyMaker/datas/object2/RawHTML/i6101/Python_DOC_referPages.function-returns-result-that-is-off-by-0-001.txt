<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong>: Returned float value is off by <code>0.0001</code>. Are my implementations of my functions causing this or is it just the wonder that is floating values and computer science in that not all values can be represented accordingly? I do not think it is the latter, so I am wondering if somebody can spot the problem, give a suggestion or ask me to try things to debug.</p>
<p>I've written two functions to determine the centroid of a polygon on the Earth's surface.</p>
<p>The first function calculates the bearing between two of the vertices. It does so twice, once for the UR to LL then once for the LR to UL.</p>
<p>The second function calculates the intersection point given the two previously calculated bearings and the starting point from each of those calculations. So UR &amp; its bearing and LR &amp; its bearing.</p>
<p>My results are slightly off in the Longitude. For example, I supply <code>interest()</code> with:</p>
<pre><code>x1 = 120.6272
y1 = 36.9647
x2 = 120.6128
y2 = 36.9508
b1 = 265.02976409662136
b2 = 354.4744218802173
</code></pre>
<p>My result is <code>[36.96359071593996, 120.61125138605212]</code>. The Latitude is corrected, but the Longitude should be <code>120.61135138605212</code>.</p>
<p>The equations are transcribed from <a href="http://www.movable-type.co.uk/scripts/latlong.html" rel="nofollow noreferrer">here</a>. There is a calculator to which you can supply the decimal degrees and bearings under the "Intersection of two paths" section to see the expected result. This result, when converted from DMS to DD aligns with that of the centroid calculation performed by the same polygon in ArcGIS. I am aware of a gisstackexchange, however I am not focused on the GIS piece of this problem. Rather my question lies within this:</p>
<p><strong>Question:</strong></p>
<p><em>With my current implementation(s), is the storing of functions [i.e. <code>cos = math.cos</code>], native use of squaring [i.e. <code>x ** 2</code> vs <code>math.pow()</code>] or something else I am unware of causing the decimal places of the float to be ever so slightly off (the 0.0001 matters for my purposes)?</em></p>
<p><strong>Bearing Function</strong></p>
<pre><code>def bearing(x1, y1, x2, y2):

    cos = math.cos
    sin = math.sin
    atan2 = math.atan2
    rad = math.radians
    deg = math.degrees

    rx1 = rad(x1)
    ry1 = rad(y1)
    rx2 = rad(x2)
    ry2 = rad(y2)

    b = atan2(sin(rx2-rx1) * cos(ry2),
              cos(ry1) * sin(ry2) - (sin(ry1) * cos(ry2) * cos(rx2-rx1)))

    return ((deg(b) + 360) % 360) # normalize to -180...+180
</code></pre>
<p><strong>Intersect Function</strong></p>
<pre><code>def intersect(x1, y1, b1, x2, y2, b2):

    cos = math.cos
    sin = math.sin
    atan2 = math.atan2
    asin = math.asin
    acos = math.acos

    sqrt = math.sqrt

    rad = math.radians
    deg = math.degrees
    pi = math.pi

    rx1 = rad(x1)
    ry1 = rad(y1)
    rx2 = rad(x2)
    ry2 = rad(y2)
    rb1 = rad(b1)
    rb2 = rad(b2)

    dx = rx2 - rx1
    dy = ry2 - ry1

    # Angular dist x1,y1 to x2,y2
    a12 = 2 * asin(sqrt((sin(dy/2)**2) +
                        (cos(ry1) * cos(ry2) * (sin(dx/2)**2))))

    # Initial bearing from x1,y1 to x2,y2
    bi = acos((sin(ry2) - (sin(ry1) * cos(a12))) / (sin(a12) * cos(ry1)))

    if math.isnan(bi):
        bi = 0

    # Final bearing
    bf = acos((sin(ry1) - (sin(ry2) * cos(a12))) / (sin(a12) * cos(ry2)))

    if (dx) &gt; 0:
        # Bearing from x1,y1 to x2,y2
        b12 = bi
        # Bearing from x2,y2 to x1,y1
        b21 = (2 * pi) - bf
    else:
        b12 = (2 * pi) - bi
        b21 = bf

    # Angle x2,y2 -&gt; x1,y1 -&gt; x3,y3
    n1 = rb1 - b12

    # Angle x1,y1 -&gt; x2,y2 -&gt; x3,y3
    n2 = b21 - rb2

    n3 = acos(-(cos(n1) * cos(n2)) +
              (sin(n1) * sin(n2) * cos(a12)))

    # Angular dist x1,y1 to x3,y3
    a13 = atan2(sin(a12) * sin(n1) * sin(n2),
                cos(n2) + (cos(n1) * cos(n3)))

    # Latitude
    ry3 = asin((sin(ry1) * cos(a13)) +
               (cos(ry1) * sin(a13) * cos(rb1)))

    # Longitude Delta from x1 to x3
    dx13 = atan2(sin(rb1) * sin(a13) * cos(ry1),
                 cos(a13) - (sin(ry1) * sin(ry3)))

    # Longitude
    rx3 = rx1 + dx13

    return [deg(ry3), (deg(rx3) + 540) % 360 - 180]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The very last thing you do in each function is to convert from radians to degrees in a lossy way.
Try the same code but without the rounding in each of the return lines: for example</p>
<pre><code>return deg(b)
</code></pre>
<p>instead of </p>
<pre><code>return ((deg(b) + 360) % 360)
</code></pre>
</div>
<span class="comment-copy">You're doing math with irrationals. Of <i>course</i> it's going to be the standard FP BS.</span>
<span class="comment-copy">Pretty sure every division you do in there contributes a little.</span>
<span class="comment-copy">It's off by exactly 0.001. Isn't that odd?</span>
<span class="comment-copy">This isn't a Python issue. It's a floating point math issue. Doing lots of floating point operations will tend to result in a loss of precision unless you take care in how you perform the operations. See <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">here</a> and <a href="https://www.soa.org/News-and-Publications/Newsletters/Compact/2014/may/Losing-My-Precision--Tips-For-Handling-Tricky-Floating-Point-Arithmetic.aspx" rel="nofollow noreferrer">here</a> for more details and some tips.</span>
<span class="comment-copy">How did you determine the correct value?</span>
<span class="comment-copy">This produces the exact same result</span>
<span class="comment-copy">You changed both functions? Sorry. Loss of precision happens every time we do floating point math, but especially when the results of intermediary calculations are either very large or very small. Have you tried several inputs to verify the error is as exact as you suggest?</span>
<span class="comment-copy">Yes in both functions. Ill have to do more tomorrow.</span>
