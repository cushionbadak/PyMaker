<div class="post-text" itemprop="text">
<p>Let's say I have this two snippet of code in python :</p>
<pre><code>1 --------------------------
import numpy as np
x = np.array([1,2,3,4])
y = x
x = x + np.array([1,1,1,1])
print y

2 --------------------------
import numpy as np
x = np.array([1,2,3,4])
y = x
x += np.array([1,1,1,1])
print y
</code></pre>
<p>I thought the result of <code>y</code> will be the same in both examples since <code>y</code> point out to <code>x</code> and <code>x</code> become <code>(2,3,4,5)</code>, <strong>BUT</strong> it wasn't</p>
<p>The results were <code>(1,2,3,4) for 1</code> and <code>(2,3,4,5) for 2</code>.</p>
<p>After some research I find out that in <em>first example</em></p>
<pre><code>#-First example---------------------------------------
x = np.array([1,2,3,4]) # create x --&gt; [1,2,3,4] 
y = x                   # made y point to x
# unril now we have x --&gt; [1,2,3,4]
#                          |
#                          y
x = x + np.array([1,1,1,1]) 
# however this operation **create a new array** [2,3,4,5] 
# and made x point to it instead of the first one
# so we have y --&gt; [1,2,3,4] and x --&gt; [2,3,4,5]

#-Second example--------------------------------------
x = np.array([1,2,3,4]) # create x --&gt; [1,2,3,4] 
y = x                   # made y point to x
# unril now the same x --&gt; [1,2,3,4]
#                            |
#                            y
x += np.array([1,1,1,1])
# this operation **Modify the existing array**
# so the result will be
# unril now the same x --&gt; [2,3,4,5]
#                            |
#                            y
</code></pre>
<p>You can find out more about this behaviors (not only for this example) in this link <a href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noreferrer"><strong>In-place algorithm</strong></a></p>
<p>My question is : Being aware of this behavior why should I use in-place algorithm in term of performance? (time of excution faster? less memory alocation?..)</p>
<p><strong>EDIT : Clarification</strong> </p>
<p>The example of (+, =+) was just to explain simply the in-place algorithm to the one who don't know.. but the question was in general the use of in-place algorithm not only in this case..</p>
<p>As another more complex example: loading a CSV file (just 10 Million rows) in a variable then sorting the result, is the idea of in-place algorithm is to produce an output in the same memory space that contains the input by successively transforming that data until the output is produced? - This avoids the need to use twice the storage - one area for the input and an equal-sized area for the output ( Using the minimum amount of RAM, hard disk ... )</p>
</div>
<div class="post-text" itemprop="text">
<h1>x = x + 1 vs x += 1</h1>
<h2>Performance</h2>
<p>It seems that you understand the semantical difference between <code>x += 1</code> and <code>x = x + 1</code>.</p>
<p>For benchmarking, you can use <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a> in IPython.</p>
<p>After defining those functions:</p>
<pre><code>import numpy as np
def in_place(n):
    x = np.arange(n)
    x += 1

def not_in_place(n):
    x = np.arange(n)
    x = x + 1

def in_place_no_broadcast(n):
    x = np.arange(n)
    x += np.ones(n, dtype=np.int)
</code></pre>
<p>You can simply use the <a href="https://stackoverflow.com/a/29280612/6419007"><code>%timeit</code> syntax</a> to compare performances:</p>
<pre><code>%timeit in_place(10**7)
20.3 ms ± 81.4 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

%timeit not_in_place(10**7)
30.4 ms ± 253 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

%timeit in_place_no_broadcast(10**7)
35.4 ms ± 101 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre>
<p><code>not_in_place</code> is 50% slower than <code>in_place</code>.</p>
<p>Note that <a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html" rel="nofollow noreferrer">broadcasting</a> also makes a huge difference : numpy understands <code>x += 1</code> as adding a <code>1</code> to every single element of <code>x</code>, without having to create yet another array.</p>
<h2>Warning</h2>
<p><code>in_place</code> should be the preferred function: it's faster and uses less memory. You might run into bugs if you use and mutate this object at different places in your code, though. The typical example would be :</p>
<pre><code>x = np.arange(5)
y = [x, x]
y[0][0] = 10
y
# [array([10,  1,  2,  3,  4]), array([10,  1,  2,  3,  4])]
</code></pre>
<h1>Sorting</h1>
<p>Your understanding of the advantages of in-place sorting is correct. It can make a huge difference in memory requirements when sorting large data sets.</p>
<p>There are other desirable features for a sorting algorithm (stable, acceptable worst-case complexity, ...) and it looks like the standard Python algorithm (<a href="https://en.wikipedia.org/wiki/Timsort" rel="nofollow noreferrer">Timsort</a>) has <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms" rel="nofollow noreferrer">many of them</a>.</p>
<p>Timsort is an hybrid algorithm. Some parts of it are in-place and some require extra memory. It will never use more than <a href="http://wiki.c2.com/?TimSort" rel="nofollow noreferrer"><code>n/2</code></a> though.</p>
</div>
<span class="comment-copy">I think you should use the operator that semantically makes more sense as that will perform better in terms of development time spent to make the code do what you ask (and keep the code doing what you ask).  If you profile and find that you have a bottleneck somewhere, then you can optimize by doing <i>experiments</i> with <i>real data</i> and at that point you can definitively say which way is faster (or if there is no difference at all).  My guess is that in most cases, <code>numpy</code> will have a free block of memory so there won't be a huge performance difference, but I <i>could</i> be wrong.</span>
<span class="comment-copy">If you care about this sort of micro-optimization, don't use Python. If the job is so complex/large that a minute difference matters it's probably worth re-coding it in Java or even C.</span>
<span class="comment-copy">I don't understand the question. Since there is a clear semantic difference between <code>+</code> and <code>+=</code> for numpy, what does performance matter?</span>
<span class="comment-copy">Why the downvotes guys? They are different operands...</span>
<span class="comment-copy">Its not about what gains this might give OP. This is an interesting question in general!</span>
<span class="comment-copy">yes I got it, while <code>y = [x, x]</code> you didn't create a new variable you just made <code>y</code> point to the <code>x</code>.. so this <code>y[0][0] = 10</code> will change the result of <code>x</code> to become <code>[10,1,2,3,4]</code>...</span>
<span class="comment-copy">@AnouarZ: Exactly. This behaviour can be more subtly hidden though, e.g. with this <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument">bug/feature</a>.</span>
<span class="comment-copy">i was looking into the broadcasting algorith and the post you linked. it was wrotten there that <a href="https://stackoverflow.com/questions/47309818/when-broadcasting-is-a-bad-idea-numpy">broadcasting may be a bad idea</a>, I craeted another question to that subject in case you have explaination to how and when that happened</span>
