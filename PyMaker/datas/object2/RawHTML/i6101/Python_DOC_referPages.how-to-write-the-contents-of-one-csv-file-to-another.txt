<div class="post-text" itemprop="text">
<p>I have a csv file and I want to transfer the raw data without the headers to a new csv file and have the rows and columns the same as the original.</p>
<pre><code>IRIS_data = "IRIS_data.csv"

with open(IRIS_data, 'wb') as data:
    wr = csv.writer(data, quoting=csv.QUOTE_ALL)
    with open(IRIS) as f:
        next(f)
        for line in f:
            wr.writerow(line)
</code></pre>
<p>The code above is my most recent attempt, when I try run it I get the following error: </p>
<pre><code>a bytes-like object is required, not 'str'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's because you opened the input file with <code>with open(IRIS_data, 'wb')</code>, which opens it in binary mode, and the output file with just <code>with open(IRIS)</code> which opens it in text mode.</p>
<p>In Python 3, you should open both files in text mode and specify <code>newline=''</code> option)—see the examples in the <code>csv</code> module's <a href="https://docs.python.org/3/library/csv.html#module-csv" rel="nofollow noreferrer">documentation</a>)</p>
<p>To fix it, change them as follows:</p>
<p><code>with open(IRIS_data, 'w', newline='') as data:</code></p>
<p>and </p>
<p><code>with open(IRIS, newline='') as f:</code></p>
<p>However there are other issues with you code. Here's how to use those statements to get what I think you want:</p>
<pre><code>import csv

IRIS = "IRIS.csv"
IRIS_data = "IRIS_data.csv"

with open(IRIS, 'r', newline='') as f, open(IRIS_data, 'w', newline='') as data:
    next(f)  # Skip over header in input file.
    writer = csv.writer(data, quoting=csv.QUOTE_ALL)
    writer.writerows(line.split() for line in f)
</code></pre>
<p>Contents of <code>IRIS_data.csv</code> file after running the script with your sample input data:</p>
<pre class="lang-none prettyprint-override"><code>"6.4","2.8","5.6","2.2","2"
"5","2.3","3.3","1","1"
"4.9","2.5","4.5","1.7","2"
"4.9","3.1","1.5","0.1","0"
"5.7","3.8","1.7","0.3","0"
"4.4","3.2","1.3","0.2","0"
"5.4","3.4","1.5","0.4","0"
"6.9","3.1","5.1","2.3","2"
"6.7","3.1","4.4","1.4","1"
"5.1","3.7","1.5","0.4","0"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to encode the line you are writing like this:</p>
<pre><code>wr.writerow( line.encode(”utf8”))
</code></pre>
<p>Also open your file using <code>open(..., ‘wb’)</code>. This will open the file in binary mode. So you are certain the file is actually open in binary mode. Indeed it is better to now explicitly the encoding than assuming it. Enforcing encoding for both reading and writing will save you lots of trouble.</p>
</div>
<span class="comment-copy">You are in Python 3, presumably. Why did you open the file in <code>'wb'</code> mode? The easiest thing is just to open the file in <code>'w'</code> mode.</span>
<span class="comment-copy">This is the correct answer but one more problem is the way its writing the doubles from the first csv to the second, its adding the first number, . and then second number of the double to there own columns</span>
<span class="comment-copy">@conortighe.: It may have something to do with fact that you're taking data read directly from the file—a string, which is a sequence of characters— and passing that to a <code>csv.writer</code>. I might know how to fix that issue, too, but you'll need to <b>edit your question</b> and describe the format of the lines in <code>IRIS</code> input file in more detail.</span>
<span class="comment-copy">Updated there any help appreciated</span>
<span class="comment-copy">The code in the update to your question is definitely wrong—and you didn't add information about what the contents in the <b>input</b> file looks like (the file associated with the variable <code>IRIS</code> used in the <code>open(IRIS, newline='')</code> statement.</span>
<span class="comment-copy">Included it there</span>
