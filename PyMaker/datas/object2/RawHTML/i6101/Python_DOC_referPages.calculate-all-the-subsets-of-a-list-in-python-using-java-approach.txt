<div class="post-text" itemprop="text">
<p>I'm working through some interview problems and one of the classic ones, which uses backtracking, is to calculate the powerset (all the subsets) of a list. I have the java solution for the problem:</p>
<pre><code>    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
     List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();
     Arrays.sort(nums);
     backtrack(list, new ArrayList&lt;&gt;(), nums, 0);
     return list;
    }

   private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; {
     tempList, int [] nums, int start){
     list.add(new ArrayList&lt;&gt;(tempList));
     for(int i = start; i &lt; nums.length; i++){
      tempList.add(nums[i]);
     backtrack(list, tempList, nums, i + 1);
     tempList.remove(tempList.size() - 1);
   }
 }
</code></pre>
<p>I'm trying to do the same thing but using python instead:</p>
<pre><code>class Solution:
  def subsets(self, nums):
   lista = []
   self.backtrack(lista, [], sorted(nums), 0)
   return lista
 def backtrack(self, lista, tempList, nums, start):
   lista.append(tempList)
   for i in range(start, len(nums)):
     tempList.append(nums[i])
     self.backtrack(lista, tempList, nums, i+1)
     tempList.pop()
</code></pre>
<p>I printed the tempList and it seems to be working as expected. The problem I believe is that it lista.append(tempList) is not working as I expected. Is there some particularity in python that is yielding this different result? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>list.add(new ArrayList&lt;&gt;(tempList));
</code></pre>
<p>Makes a copy of <code>tempList</code>, which you ought to do in your Python version as well!</p>
<pre><code>lista.append(tempList[:])
# OR
lista.append(list(tempList))  # which is closer in syntax to your java version
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to make a copy of <code>tempList</code>. Otherwise, you're just appending multiple references to the same <code>tempList</code> object to <code>lista</code>. When <code>backtrack</code> finally returns, <code>tempList</code> is empty, so <code>lista</code> will just contain multiple references to that empty list. </p>
<p>Here's a more Pythoic way to write your code. This version <em>doesn't</em> need to make a copy because each recursive call creates a new <code>templist</code> rather than modifying the original <code>templist</code> object.</p>
<pre><code>def subsets(nums):
    lista = []
    backtrack(lista, [], sorted(nums), 0)
    return lista

def backtrack(lista, templist, nums, start):
    lista.append(templist)
    for i in range(start, len(nums)):
        backtrack(lista, templist + nums[i:i+1], nums, i+1)

# Test

for t in subsets([1,2,3]):
    print(t)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[]
[1]
[1, 2]
[1, 2, 3]
[1, 3]
[2]
[2, 3]
[3]
</code></pre>
<hr/>
<p>Just for fun, here's the same algorithm in the form of a generator function. I've eliminated the sorting step, the caller can sort the input if they really want that.</p>
<pre><code>def subsets(nums, templist=None, start=0):
    if templist is None:
        templist = []
    yield templist
    for i in range(start, len(nums)):
        yield from subsets(nums, templist + nums[i:i+1], i+1)

for t in subsets([1, 2, 3]):
    print(t)
</code></pre>
<p>This code produces the same output as the earlier code.</p>
<hr/>
<p>Here's a non-recursive way to make subsets that's a little more compact. It uses a similar algorithm to the earlier code, but it produces the subsets in a slightly different order. It may be helpful to work through the algorithm by hand, on paper, to see how it works.</p>
<pre><code>def subsets(seq):
    z = [[]]
    for x in seq:
        z += [y + [x] for y in z]
    return z

for t in subsets([1, 2, 3]):
    print(t)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[]
[1]
[2]
[1, 2]
[3]
[1, 3]
[2, 3]
[1, 2, 3]
</code></pre>
<p>And here's the almost-unreadable one-liner version of that algorithm. ;)</p>
<pre><code>from functools import reduce

def subsets(seq):
    return reduce(lambda z, x: z + [y + [x] for y in z], seq, [[]])
</code></pre>
<p>Lastly, here's a way to make subsets using binary numbers. This is handy if you want to get specific subsets without producing them all.</p>
<p>Given a set S of n items there are <code>2**n</code> subsets. Each subset of S corresponds to a n-bit binary number: a 1 bit in the number means the corresponding item in S is in the subset.</p>
<pre><code>def subsets(seq):
    for i in range(1&lt;&lt;len(seq)):
        a = []
        for u in seq:
            if not i:
                break
            if i &amp; 1:
                a.append(u)
            i &gt;&gt;= 1
        yield a
</code></pre>
<p>This generator yields subsets in the same order as the last 2 versions.</p>
</div>
<div class="post-text" itemprop="text">
<p>This problem (powerset iterator) is addressed already in the standard documentation of <a href="https://docs.python.org/3/library/itertools.html?highlight=powerset" rel="nofollow noreferrer">itertools module</a>:</p>
<pre><code> def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
</code></pre>
<p>To address the problem of the final paragraph:</p>
<p><em>tempList.append(n)</em> appends the argument as a whole (since a list is heterogeneous in Python, able to contain all types). You might replace it by <em>temPist.extend(n)</em> instead, which moves the elements, as you seem to expect.</p>
</div>
<span class="comment-copy">You need to make a shallow copy so <code>lista.append(tempList[:])</code>. Or even a deep copy if you want the objects to be unique. In your Java approach you also write <code>new ArrayList&lt;&gt;(tempList)</code> (so you construct a new list as well.</span>
<span class="comment-copy">Why on earth are you doing this in a class? That's not necessary in Python. FWIW, I'd be inclined to re-write this code as a generator that yields the subsets, rather than storing them in a list.</span>
<span class="comment-copy">Thanks for the answer! Why do I need a copy again?</span>
<span class="comment-copy">You may find this article helpful to understand the differences between Java's and Python's data model: <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a>, which was written by SO veteran Ned Batchelder.</span>
<span class="comment-copy">Thank you! PM 2Ring</span>
<span class="comment-copy">That worked, thanks a lot! Why do I have to make a copy, though?</span>
<span class="comment-copy">@RodrigoProença because you are modifying it  later on (pop), but you don't want to this affect the list you add to <code>lista</code>.</span>
<span class="comment-copy">oh that makes sense, thanks for the answer!</span>
<span class="comment-copy">Jesus, here I am struggling with the problem and you can think of different approaches. Want to be like that someday haha</span>
<span class="comment-copy">@RodrigoProença :) I just made a few minor transformations to your algorithm. But since you mention it, I'll add a couple of alternative, non-recursive approaches.</span>
<span class="comment-copy">True enough, and that recipe is almost twice as fast as my fastest offering, the non-recursive version that starts <code>z = [[]]</code>. However, the question isn't just asking how to make powersets. The OP wanted to know why his code didn't work correctly, and how to fix it, while still using the same algorithm.</span>
