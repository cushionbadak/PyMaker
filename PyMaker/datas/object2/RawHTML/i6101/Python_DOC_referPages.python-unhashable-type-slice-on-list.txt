<div class="post-text" itemprop="text">
<p>I am trying to write a little script that will look at a string of text, remove the stop words, then return the top 10 most commonly used words in that string as a list.</p>
<p>This is my code:</p>
<pre><code>from collections import Counter as c
from nltk.corpus import stopwords
stop = set(stopwords.words('english'))
description = ("This is some place holder text for a shop that sells shoes, coats and jumpers.  We sell lots of shoes but never sell t-shirts.  Please come to our shop if you want some jumpers")
description = ([word for word in description.lower().split() if word not in stop])
common_list = c(description)
top_ten = (common_list[:9])
</code></pre>
<p>However, this gives me the error message <code>unhashable type: slice</code>.  I think this is because common_list might not actually be a list..  I am very new to python so please excuse if this is really silly.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with the <code>Counter</code> object's <code>most_common</code> <code>method</code> which makes it really easy:</p>
<pre><code>top_ten = c(description).most_common(10)
</code></pre>
<p>The documentation states:</p>
<blockquote>
<p>Return a list of the n most common elements and their counts from the most common to the least. </p>
</blockquote>
<p>So as it returns both the <code>element</code> and their <code>counts</code> and we only want the <code>element</code>, we still need to use a <code>list-comprehension</code>:</p>
<pre><code>top_ten = [i[0] for i in c(description).most_common(10)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>common_list is a dictionary, can't slice it (common_list[:9] won't work). You probably have to convert the common_list into an actual list and sort that one based on the occurrences.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following one-liner:</p>
<pre><code>top_ten = sorted(c(description).items(), key=lambda p:p[1])[::-1][:10]
</code></pre>
<hr/>
<p><strong>why?</strong></p>
<p>Well you essentially have a <code>list</code> of words:</p>
<pre><code>description = ["cat", "fish", "cat", "cat", "dog", "dog"]
</code></pre>
<p>and then you can get the counts of each elements with the <code>c()</code> <code>function</code> so by taking <code>c(description)</code> which gives:</p>
<pre><code>Counter({'cat': 3, 'dog': 2, 'fish': 1})
</code></pre>
<p>and then we need to sort this and that is done by sorting on the second element of each <code>tuple</code> with <code>key=lambda p:p[1]</code>. Which in our case would give:</p>
<pre><code>[('fish', 1), ('dog', 2), ('cat', 3)]
</code></pre>
<p>then we need to reverse it with <code>[::-1]</code> and take the first <code>10</code> elements with <code>[:10]</code>. Which would leave us with:</p>
<pre><code>[('cat', 3), ('dog', 2), ('fish', 1)]
</code></pre>
<hr/>
<p>If you just want the <code>words</code>, just take the first element from each <code>list</code> in the <code>top_ten</code> list with:</p>
<pre><code>[i[0] for i in top_ten]
</code></pre>
</div>
<span class="comment-copy"><code>from collections import Counter as c</code> whhhhyyy would you ever do this? Do you hate people being able to read and understand your code?</span>
<span class="comment-copy">And yes, <code>common_list</code> is <i>not a list</i>, it is a <code>Counter</code>, which may have been more obvious if you didn't use <code>c</code> instead of <code>Counter</code>. A <code>Counter</code> object works almost exactly like <code>dict</code>, except it is specialized for counting. When you do <code>my_counter[:9]</code> that's like doing <code>my_dict[:9]</code>, i.e., it passes a <i>slice</i> to <code>__getitem__</code>, but <code>dict</code> objects don't impement slicing...</span>
<span class="comment-copy">And note that of course Counter items have a specific method to get the top n items, namely <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>most_common(n)</code></a>.</span>
<span class="comment-copy">@juanpa.arrivillaga So would my answer work...? I can't properly test it but I think it does.</span>
<span class="comment-copy">@JoeIddon yeah, it looks like it would work, but it's not necessary. <code>Counter</code> objects have a <code>most_common</code> method.</span>
<span class="comment-copy">See comments 2 and 3 for a much better answer.</span>
<span class="comment-copy">This can be simplified to: <code>sorted(c(description).items(), key=lambda p:p[1], reversed=True)[:10]</code></span>
<span class="comment-copy">@juanpa.arrivillaga I agree, there was an unnecessary <code>list</code> conversion, but does this actually have any performance improvements (using <code>reverse=True</code>)?</span>
<span class="comment-copy">well, yes. slicing creates a whole new list.</span>
