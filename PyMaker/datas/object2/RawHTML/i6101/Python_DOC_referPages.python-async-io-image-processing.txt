<div class="post-text" itemprop="text">
<p>I'm currently taking images from a webcam that should be processesed as soon as they are captured. The code uses the cv2.videocapture() function afterwards the images are extracted. </p>
<p>Idea: As soon as an Image is captured I want to use the time the system needs to capture a new image for computation on the previous image. </p>
<p>To achieve this task I use the asyncio library. </p>
<p>First of all I define a function that produces n images which should be stored in a queue 
`</p>
<pre><code>async def produce(queue, n):
    for x in range(n):
        # produce an item
        print('producing {}/{}'.format(x, n))
        # simulate i/o operation using sleep
        await asyncio.sleep(random.random())
        item = obtainImage()
        z.append(x)
        # put the item in the queue
        await queue.put(item)`
</code></pre>
<p>After that I implemented a producer method which waits for a entry in the queue and computes some image features (here a simple threshold):</p>
<pre><code> async def consume(queue):
        while True:
            # wait for an item from the producer
            # Load the image stored in the queue 
            item = await queue.get()
            # process the item and store value
            ret,thresh1 = cv2.threshold(item,127,255,cv2.THRESH_BINARY)

            # simulate i/o operation using sleep
            await asyncio.sleep(random.random())

            # Notify the queue that the item has been processed
            queue.task_done() 

            #Return the Processesed image
            return thresh1
</code></pre>
<p>To start the functions I created a run function and added it into an event loop (The run method contains a parameter of how many images i want to process):</p>
<pre><code>async def run(n):
    queue = asyncio.Queue()
    # schedule the consumer
    consumer = asyncio.ensure_future(consume(queue))
    # run the producer and wait for completion
    await produce(queue, n)
    # wait until the consumer has processed all items
    await queue.join()
    # the consumer is still awaiting for an item, cancel it
    consumer.cancel()

  loop = asyncio.get_event_loop()
  loop.run_until_complete(run(10))
  print(loop)
  loop.close()
</code></pre>
<p>As long as I use print statements I get a async output like this:</p>
<p>producing 0/10</p>
<p>producing 1/10</p>
<p>consuming 0...</p>
<p>producing 2/10</p>
<p>consuming 1...</p>
<p>producing 3/10</p>
<p>consuming 2...</p>
<p>producing 4/10</p>
<p>consuming 3...</p>
<p>Which is exactly what I desire in terms of order. However, I cant get back any thresholded image. What am I missing? </p>
<p>Thank you in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>Minimal example with global queue for results returning (tested with Python 3.5.2)</p>
<pre><code>import asyncio
import random

outQ = asyncio.Queue() 

async def produce(queue, n):
    for x in range(n):
        print('producing {}/{}'.format(x, n))
        await asyncio.sleep(random.random())
        item = x
        await queue.put(item)

async def consume(queue):
    while True:
        print('consume ')
        item = await queue.get()
        thresh1 = item**2
        print("... adding %d" % thresh1)
        await outQ.put(thresh1)
        await asyncio.sleep(random.random())
        queue.task_done()


async def run(n):
    queue = asyncio.Queue()
    consumer = asyncio.ensure_future(consume(queue))
    await produce(queue, n)
    await queue.join()
    consumer.cancel()

loop = asyncio.get_event_loop()
loop.run_until_complete(run(10))
loop.close()

while not outQ.empty():
    print(outQ.get_nowait())
</code></pre>
<p>Output:</p>
<pre><code>...
producing 9/10
... adding 64
consume 
... adding 81
consume 
0
1
4
9
16
25
36
49
64
81
</code></pre>
</div>
<span class="comment-copy">I usually have an "output" queue where I store what I want to return from the async functions. So instead of returning, add them to a queue and loop/parse the queue after <code>loop.close()</code></span>
<span class="comment-copy">Do I have to declare them before I call the run function and hand it into the run method? Or could it be used like a global variable?</span>
<span class="comment-copy">I would go with a global variable if the script is small. In cases where my producers/consumers are more complex I make them classes and I pass the results queue to the <code>__init__</code>. From what I can tell, a global queue should work...</span>
<span class="comment-copy">From my point of view it doesn't seem to work the global queue has allways size 0. In addition the code get stuck after reaching the 9th iteration. Even the for loop after the loop.close() statement cant be reached :-/</span>
<span class="comment-copy">Hmmm not sure why is that... you used an <a href="https://docs.python.org/3/library/asyncio-queue.html" rel="nofollow noreferrer">asyncio.Queue</a> with just calling <code>outQ.put(thresh1)</code>? I am not sure I can help more without a runnable example...</span>
<span class="comment-copy">Forgot the await before the Output_Queue</span>
<span class="comment-copy">Glad it worked :)</span>
