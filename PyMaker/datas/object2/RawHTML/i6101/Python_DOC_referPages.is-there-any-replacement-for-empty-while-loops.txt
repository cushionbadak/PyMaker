<div class="post-text" itemprop="text">
<p>I'm using empty while loops a lot, for example:
I have a thread running in the background that will change a value called "a" in 5 seconds. however, I'm using a different function at the same time, and I want to let the second function know that the value has changed, so what I always did was:</p>
<pre><code>import threading, time
class example:
       def __init__(self):
          self.a = 0


       def valchange(self):
          time.sleep(5)
          self.a += 1
          time.sleep(1)
          print("im changing the a value to " + str(self.a))
          print("those print commands needs to run after notifier stopped his while and started printing")

def notifier(exam :example, num :int):
    while(exam.a != num):
        pass
    print("it changed to " + str(num))


exa = example()
i = 1
while(i &lt;= 16):
    temp= threading.Thread(target=notifier, args=(exa, i, ))
    temp.start()
    i += 3
i = 1
while(i &lt;= 16):
    exa.valchange()
    i += 1
</code></pre>
<p><strong>It's important to mention, that example could not use wait and set to an  event, because there is no indication to when you need to run set, and how much threads are running in the background, and even what numbers will have a thread waiting for them to change.
And also you can't use join because changing 'a' is not a sign to print, only the condition is the sign.
Async and select can't help me as well because of the last reason.</strong></p>
<p>Is there any way to create something, that will stop the program fromrunning until the condition will become true? you can provide your solution with any programming language you want, but mainly I'm using python 3.</p>
<p><strong><em>EDIT: please remember that I need it to work with every condition. And my code example- is only an example, so if something works there, it doesn't necessarily will work with a different condition.</em></strong></p>
<p>Thank you very much in advance :)</p>
<p>Idea:</p>
<pre><code>wait(a == 5) // will do nothing until a == 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <a href="https://docs.python.org/2/library/select.html" rel="nofollow noreferrer"><code>select</code></a> or <code>epoll</code> system calls if you're waiting for some system operation to finish. In case you're waiting for a certain IO event, then you can use <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> (provided your Python version &gt; 3.3), otherwise you could consider <code>twisted</code>.</p>
<p>If you're doing some CPU bound operations you need to consider multiple processes or threads, only then you can do any such monitoring effectively. Having a while loop running infinitely without any interruption is a disaster waiting to happen.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your thread only changes <code>a</code>'s value once, at the end of its life, then you can use <code>.join()</code> to wait for the thread to terminate.</p>
<pre><code>import threading
import time

class example:
   def __init__(self):
      self.a = 0
      self.temp = threading.Thread(target=self.valchange)
      self.temp.start()
      self.notifier()

   def valchange(self):
      time.sleep(5)
      self.a = 1

   def notifier(self):
      self.temp.join()
      print("the value of a has changed")

example()
</code></pre>
<p>If the thread might change <code>a</code>'s value at any point in its lifetime, then you can use one of the <code>threading</code> module's more generalized control flow objects to coordinate execution. For instance, the <code>Event</code> object.</p>
<pre><code>import threading
import time

class example:
   def __init__(self):
      self.a = 0
      self.event = threading.Event()
      temp = threading.Thread(target=self.valchange)
      temp.start()
      self.notifier()

   def valchange(self):
      time.sleep(5)
      self.a = 1
      self.event.set()

   def notifier(self):
      self.event.wait()
      print("the value of a has changed")

example()
</code></pre>
<p>One drawback to this <code>Event</code> approach is that the thread target has to explicitly call <code>set()</code> whenever it changes the value of <code>a</code>, which can be irritating if you change <code>a</code> several times in your code. You could automate this away using a property:</p>
<pre><code>import threading
import time

class example(object):
    def __init__(self):
        self._a = 0
        self._a_event = threading.Event()

        temp = threading.Thread(target=self.valchange)
        temp.start()
        self.notifier()

    @property
    def a(self):
        return self._a

    @a.setter
    def a(self, value):
        self._a = value
        self._a_event.set()

    def valchange(self):
        time.sleep(5)
        self.a = 1

    def notifier(self):
        self._a_event.wait()
        print("the value of a has changed")

example()
</code></pre>
<p>Now <code>valchange</code> doesn't have to do anything special after setting <code>a</code>'s value.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are describing is a spin lock, and might be fine, depending on your use case.</p>
<p>The alternative approach is to have the code you are waiting on call you back when it reaches a certain condition. This would require an async framework such as <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-task.html</a></p>
<p>There are some nice simple examples in those docs so I won't insult your intelligence by pasting them here.</p>
</div>
<span class="comment-copy">If your while loop is doing nothing indefinitely, how is any other code executing that might cause the loop to break? The answer to your post might depend on how you're doing this. Threading? Multiprocessing? There are a number of ways to get parallel threads/processes/whatever to play nice together, but some solutions will be specific to certain modules. <a href="https://docs.python.org/2/library/threading.html#threading.Lock" rel="nofollow noreferrer">threading.Lock</a> would only be useful if you were using threading, for instance.</span>
<span class="comment-copy">Where's the code for said threads?</span>
<span class="comment-copy">@hspandher Is it better now?</span>
<span class="comment-copy">Can you please give more details, or an example of how to use it. Thank you very much:)</span>
<span class="comment-copy">@user6516763 You have provided no details on what you are waiting for.</span>
<span class="comment-copy">I'm sorry I will edit my post now</span>
<span class="comment-copy">First of all, thank you very much for your incredible help, and for the time you have wasted to help me, I really appreciate it :D but actually, I edited my question, and I added a little different code this time, a bit more complicated, and I can't use your method to get the answer I want..</span>
<span class="comment-copy">"there is no indication [...] what numbers will have a thread waiting for them to change" Hmm, that's quite tricky indeed...</span>
<span class="comment-copy">Please have a look at my edit :) thank you anyway</span>
