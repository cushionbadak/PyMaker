<div class="post-text" itemprop="text">
<p>The code below explains my problem. It works as expected in Python 2.7, yet, all of the encode calls I've tried fail in Python 3.5 (see exception below)... does anyone on a way to circumvent this error and make it work in Python 3.5 as it did on Python 2.7?</p>
<pre><code>import sys

if sys.version_info[0] &lt;= 2:
    chr = unichr

out = chr(0xdfff)
print(repr(out)) # outputs '\udfff' both in Python 2 and 3
assert out.encode('utf-8').decode('utf-8') == out
assert out.encode('utf-8', errors='surrogateescape').decode('utf-8') == out
assert out.encode('utf-8', errors='strict').decode('utf-8') == out
</code></pre>
<p>Error in Python 3.5:</p>
<pre><code>Traceback (most recent call last):
  File "W:\rocky40\Projects\etk\coilib50\source\python\coilib50\io\xmlpickle\snippet.py", line 8, in &lt;module&gt;
    assert out.encode('utf-8').decode('utf-8') == out
UnicodeEncodeError: 'utf-8' codec can't encode character '\udfff' in position 0: surrogates not allowed
</code></pre>
<p>Note that a different encoding wouldn't really suit it as I have files written this way to disk in Python 2 and I need to be able to load it back and dump it again on Python 3 so that Python 2 can read it again (so, the actual bytes written shouldn't really change).</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that char belongs to utf-16:</p>
<pre><code>import sys

if sys.version_info[0] &lt;= 2:
    chr = unichr

out = chr(0xdfff)

print(out.encode('utf-16-le', 'ignore').decode('utf-16-le', 'ignore') == out)
print(out.encode('utf-16-le', 'ignore').decode('utf-16-le', 'ignore') == out)
print(out.encode('utf-16-le', 'ignore').decode('utf-16-le', 'ignore') == out)
</code></pre>
<p>That compiles and works, but... acording to <a href="https://stackoverflow.com/questions/31898353/python-cant-encode-with-surrogateescape">this answer</a>, you will have problems with surrogates</p>
</div>
<div class="post-text" itemprop="text">
<p>After searching a bit more I noticed that <a href="https://docs.python.org/3/library/codecs.html#codec-base-classes" rel="nofollow noreferrer">https://docs.python.org/3/library/codecs.html#codec-base-classes</a> points to a <code>surrogatepass</code> which is specific to <code>utf-X</code> codecs, so, using <code>surrogatepass</code> instead of <code>surrogateescape</code> does seem to get the trick done and works properly on Python 3:</p>
<pre><code>assert out.encode('utf-8', errors='surrogatepass'
    ).decode('utf-8', errors='surrogatepass') == out
</code></pre>
</div>
<span class="comment-copy">Why would you expect this to work?</span>
<span class="comment-copy">@JoshLee because it works on Python 2 ;)</span>
<span class="comment-copy">Actually, I've found a better way using <code>surrogatepass</code> on encode/decode: <a href="https://stackoverflow.com/a/47283019/110451">stackoverflow.com/a/47283019/110451</a></span>
