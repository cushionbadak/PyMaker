<div class="post-text" itemprop="text">
<p>In the following code under test the Generator class contains two methods each of which calls the <code>next_count</code> method of the Counter class. </p>
<p>These two calls to <code>next_count</code> are tested with two almost identical tests using <code>assert_called_with</code>. The test of the generator method fails. Why? How can this call be tested?</p>
<p><strong>Code Under Test</strong></p>
<p>generator.py</p>
<pre><code>class Counter:
    def __init__(self):
        self.count = 1

    def next_count(self):
        self.count += 1
        return self.count


class Generator:
    def __init__(self):
        self.counter = Counter()

    def direct_call(self):
        self.counter.next_count()

    def iter_event(self):
        while True:
            yield self.counter.count
            self.counter.next_count()
</code></pre>
<p><strong>Test Module</strong></p>
<p>test_generator.py</p>
<pre><code>import unittest
import unittest.mock

import generator


class Generator(unittest.TestCase):
    def setUp(self):
        p = unittest.mock.patch('generator.Counter')
        self.addCleanup(p.stop)
        self.mock_counter = p.start()

    def test_next_count_called_in_direct_call(self):  # Passes
        g = generator.Generator()
        g.direct_call()
        self.mock_counter.assert_called_with()

    def test_next_count_called_in_iter_event(self):  # Fails
        g = generator.Generator()
        count_gen = g.iter_event()
        next(count_gen)
        next(count_gen)
        self.mock_counter.next_count.assert_called_with()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This has nothing to do with generators. You test 2 different things, and tested the wrong thing in both tests.</p>
<p>Your two tests test something different:</p>
<pre><code>def test_next_count_called_in_direct_call(self):  # Passes
    # ...
    self.mock_counter.assert_called_with()
</code></pre>
<p>This tests if the <em>class</em> was called. It is indeed called, as <code>Counter()</code>. Remember that <code>mock_counter</code> mocked the <em>class</em>, not an instance.</p>
<pre><code>def test_next_count_called_in_iter_event(self):  # Fails
    # ...
    self.mock_counter.next_count.assert_called_with()
</code></pre>
<p>This tests if an attribute <code>Counter.next_count</code> was called. This was never called, because it is instead called on the instance.</p>
<p>The correct test is to see if that attribute <em>on an instance</em> is called:</p>
<pre><code>self.mock_counter.return_value.next_count.assert_called_with()
</code></pre>
<p>or</p>
<pre><code>self.mock_counter().next_count.assert_called_with()
</code></pre>
<p>Use this is <em>both tests</em>.</p>
<p>Because <code>mock_counter</code> is the class, it could perhaps be better named <code>MockCounter</code>.</p>
<p>In future, print out the <a href="https://docs.python.org/3/library/unittest.mock.html#Mock.mock_calls" rel="nofollow noreferrer"><code>mock_calls</code> attribute</a> of your mock; it'll show what <em>was</em> called instead. For both tests this prints:</p>
<pre><code>[call(), call().next_count()]
</code></pre>
</div>
