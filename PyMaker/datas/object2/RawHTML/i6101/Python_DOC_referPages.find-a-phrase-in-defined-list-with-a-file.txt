<div class="post-text" itemprop="text">
<p>I have a list name <code>my= ['cbs is down','abnormal']</code>
and I have opened a file in read mode</p>
<p>Now I want to search any of the string available in list that exist in that file and perform the if action</p>
<pre><code>fopen  =  open("test.txt","r")
my =['cbs is down', 'abnormal']
for line in fopen:
    if my in line:
            print ("down")
</code></pre>
<p>and when I execute it, I get the following</p>
<pre><code>Traceback (most recent call last):
  File "E:/python/fileread.py", line 4, in &lt;module&gt;
    if my in line:
TypeError: 'in &lt;string&gt;' requires string as left operand, not list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should work things out:</p>
<pre><code>if any(i in line for i in my):
    ...
</code></pre>
<p>Basically you are going through <code>my</code> and checking whether <code>any</code> of its elements is present in line.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>fopen  =  open("test.txt","r")
my =['cbs is down', 'abnormal']
for line in fopen:
    for x in my:
        if x in line:
            print ("down")
</code></pre>
<p>Sample input</p>
<pre><code>Some text cbs is down
Yes, abnormal
not in my list
cbs is down
</code></pre>
<p>Output</p>
<pre><code>down
down
down
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><sub>The reason for your error:</sub></p>
<p>The <code>in</code> operator as used in:</p>
<pre><code>if my in line: ...
   ^       ^
   |_ left | hand side 
           |
           |_ right hand side
</code></pre>
<p>for a string operand on the right side (i.e. <code>line</code>) requires a corresponding string operand on the left hand side. This operand consistency check is implemented by the <code>str.__contains__</code> method, where the call to <code>__contains__</code> is made from the string on the right hand side (see <a href="https://github.com/python/cpython/blob/master/Objects/unicodeobject.c#L11201" rel="nofollow noreferrer">cpython implemenetation</a>). Same as:</p>
<pre><code>if line.__contains__(my): ...
</code></pre>
<p>You're however passing a list, <code>my</code>, instead of a string.</p>
<p>An easy way to resolve this is by check that <strong>any</strong>  of the items in the list are contained in the current line using the builtin <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><strong><code>any</code></strong> </a> function:</p>
<pre><code>for line in fopen:
    if any(item in line for item in my):
       ...
</code></pre>
<p>Or since you have just two items use the <a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="nofollow noreferrer"><strong><code>or</code></strong></a> operator (pun unintended) which <em>short-circuits</em> in the same way as <code>any</code>:</p>
<pre><code>for line in fopen:
    if 'cbs is down' in line or 'abnormal' in line:
       ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also <code>join</code> the terms in <code>my</code> to a <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expression</a> like <code>\b(cbs is down|abnormal)\b</code> and use <code>re.findall</code> or <code>re.search</code> to find the terms. This way, you can also enclose the pattern in word-boundaries <code>\b...\b</code> so it does not match parts of longer words, and you also see <em>which</em> term was matched, and where.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; my = ['cbs is down', 'abnormal']
&gt;&gt;&gt; line = "notacbs is downright abnormal"
&gt;&gt;&gt; p = re.compile(r"\b(" + "|".join(map(re.escape, my)) + r")\b")
&gt;&gt;&gt; p.findall(line)
['abnormal']
&gt;&gt;&gt; p.search(line).span()
(21, 29)
</code></pre>
</div>
<span class="comment-copy">This prints <code>down</code> once for <i>each</i> match in <code>my</code>. Might or might not be what OP wants, but I think it's not. On the plus side, you know <i>which</i> <code>x</code> was found, and you can still <code>break</code> after the first one.</span>
