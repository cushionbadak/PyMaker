<div class="post-text" itemprop="text">
<p>I am working with a piece of code that looks like this:</p>
<pre><code># This code is not modifiable

from package import distance as dist

class A:
    def calculate(self):
        ...
        # call to dist()
        ...
</code></pre>
<p>My code:</p>
<pre><code>from package import A

a = A()
a.calculate()
</code></pre>
<p>As you can see, the <code>distance()</code> function is imported at the top of the code. The class <code>A</code> makes a call to a <code>distance()</code> function. It does so, in several places and not only in <code>calculate()</code>.</p>
<p>I want the class to use my custom distance function. However, the class does not let me pass it in the constructor and I cannot modify the code of <code>A</code>. How would I do this? Is this possible via subclassing? I tryed the following, which did not work:</p>
<pre><code>from package import A

class B(A):
    def __init__(self):
        from mypackage import mydistance as dist
        return super().__init__()

b = B()
b.calculate()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer"><code>mock.patch</code></a> function as follows:</p>
<p>distance.py:</p>
<pre><code>def distance():
    print('distance called')
</code></pre>
<p>mydistance.py:</p>
<pre><code>def mydistance():
    print('mydistance called')
</code></pre>
<p>a.py:</p>
<pre><code>from distance import distance as dist


class A:
    def calculate(self):
        dist()
</code></pre>
<p>main.py:</p>
<pre><code>from unittest import mock

from a import A
from mydistance import mydistance


class B(A):
    def calculate(self):
        with mock.patch('a.dist', wraps=mydistance):
            super().calculate()


if __name__ == '__main__':
    b = B()
    b.calculate()
</code></pre>
<p>Output is:</p>
<pre><code>mydistance called
</code></pre>
<p>Depending on your use case, you might want to put the <code>with</code> statement somewhere else (such as in the call site). For example:</p>
<pre><code>if __name__ == '__main__':
    b = B()
    with mock.patch('a.dist', wraps=mydistance):
        for _ in range(0, 100):
            b.calculate()
</code></pre>
<p>Patching causes some overhead. Another solution (basically the same as oetoni suggests) is to reassign the attribute (remember to <code>import a</code>):</p>
<pre><code>if __name__ == '__main__':
    b = B()
    old_dist = a.dist
    a.dist = mydistance
    for _ in range(0, 100):
        b.calculate()
    a.dist = old_dist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can do this immediately from you code without adding new imports or using mock.patch or any third class B. Immediately from yourcode where you are referencing A</p>
<p>Now you just need to do a small change on you code, don't just do <code>from package import A</code> but import directly <code>import baseA</code> that way we control all the variables in it also the imports ;) and as such we can. Then we can use it's local variable name in order to catch it and change it in runtime :D as such:</p>
<p>Supposed distance() function in import of A</p>
<p><strong>distance.py</strong></p>
<pre><code>def distance(something):
    return something + 1
</code></pre>
<p>then I assume the name baseA for the file that contains the class A</p>
<p><strong>baseA.py</strong></p>
<pre><code># This code is not modifiable

from distance import distance as dist


class A:
    def calculate(self):
        something = dist(1)
        return something
</code></pre>
<p>finally youcode file that contains you running code and the place from where we want to modify the dist() that it is imported in baseA</p>
<p><strong>yourcode.py</strong></p>
<pre><code>import baseA


def newDist(something):
    return something + 2


baseA.dist = newDist
a = baseA.A()


something = a.calculate()
print(something)
</code></pre>
<p>I successfully managed to change the behavior of dist in baseA as such :)
<code>baseA.dist = newDist</code> remember not to put parenthesis because we are passing the function as an object in order to assign its behavior to the <strong>baseA.dist</strong> that is imported from <strong>distance.py</strong> file </p>
<p>testing the solution</p>
<p><a href="https://i.stack.imgur.com/7MAze.gif" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/7MAze.gif"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this using the <code>patch@</code> decorator in <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">unittest.mock</a>.</p>
</div>
<span class="comment-copy">put another version of <code>package</code> earlier in the python path? can you change <code>package</code> ?</span>
<span class="comment-copy">@Jean-FrançoisFabre no, i cannot really change the package. it is from scipy <a href="https://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.spatial.distance.cdist.html" rel="nofollow noreferrer">docs.scipy.org/doc/scipy-0.15.1/reference/generated/…</a></span>
<span class="comment-copy">Python is a dynamic language, It's classes, functions and veriables are stored in lookup dicts and can be accessed and modified. Try doing something like <code>import package; package.dist = lambda x: 10</code> Then try running the code again and see if it was updated</span>
<span class="comment-copy">check the answers bellow ;) I will post the screen shot in a bit. it worked like a charm!</span>
