<div class="post-text" itemprop="text">
<p>I need my code to work faster, this one I currently have sometimes even takes up to 5 seconds to print an answer.</p>
<pre><code>import math 

n, k = [int(x) for x in input().split()]
myList = [int(i) for i in input().split()]
range_is = math.factorial(n) / (math.factorial(3) * math.factorial(n-3))
range_is = int(range_is)

answer_list = []
q = 0
w = 1
e = 2

for l in range(range_is):
    o = myList[q]+myList[w]+myList[e]
    answer_list.append(o)
    if e == n-1 and w == n-2  and q != n-3:
        q = q+1
        w = q+1
        e = w+1

    elif e == n-1 and w != n-2: 
        w = w+1
        e = w+1

    elif e != n:
        e = e+1  

answer_list.sort()
print(answer_list[k-1])
</code></pre>
<p>How can I make it run faster? And what is the problem in this code, so I can avoid this problem in the future?</p>
</div>
<div class="post-text" itemprop="text">
<h1>What should be written in your question</h1>
<p>To summarize:</p>
<ul>
<li>You have a list of <code>n</code> integers.</li>
<li>You want to calculate every combination of <code>p</code> integers.</li>
<li>You want to calculate the sum of every combination.</li>
<li>You want to sort those sums.</li>
<li>You want the <code>k</code>-th sum.</li>
</ul>
<h1>Code with <code>itertools.combinations</code></h1>
<p>With this description, the code becomes straightforward:</p>
<pre><code>from itertools import combinations

n = 5
p = 3
k = 4

integers = range(1, n + 1)
triples = combinations(integers, p)
# [(1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)]
triple_sums = [sum(t) for t in triples]
# [6, 7, 8, 8, 9, 10, 9, 10, 11, 12]
triple_sums.sort()
# [6, 7, 8, 8, 9, 9, 10, 10, 11, 12]
print(triple_sums[k - 1])
# 8
</code></pre>
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> might speed your code up, especially since you don't need to calculate <code>math.factorial(n)</code> for large <code>n</code>.</p>
<p>Most of all, this code is much more concise and shows your intent much better.</p>
<h1>Performance</h1>
<p>It's unfortunate that <code>triple_sums</code> isn't sorted even if <code>integers</code> are sorted. Every combination needs to be calculated, and the whole list has to be sorted. There might be an alternative way to produce the combinations with which <code>triple_sums</code> would be sorted directly but I cannot think of any.</p>
<p>If your list has 7000 integers, there will be <code>57142169000</code> triples. Using <code>itertools</code> won't help much for performance. You'd need to provide more information about the list and <code>k</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some advice:</p>
<p>1，Using python 2 instead of python 3.</p>
<p>2,When calculating large numbers，
Using "xrange" instead of "range";
Using "ifilter" instead of "filter".</p>
<p>3,If you use iterative algorithms, try to use "yield".</p>
</div>
<span class="comment-copy">1. Assuming this code is working correctly it may belong on <a href="https://codereview.stackexchange.com">CodeReview</a> - but make sure to read the rules and guidelines there first. 2. What is this code even supposed to do? Also please make sure to use <i>sensible</i> variable names, <code>e</code>,<code>w</code> and <code>q</code> don't explain what their purpose is</span>
<span class="comment-copy">One important piece of info is missing : What should your code do?</span>
<span class="comment-copy">First you can use math to simplify all your use of the factorials with <code>n*(n-1)*(n-2)/6</code>. Although, most likely you want that number <code>3</code> there to be variable I guess. Also, <code>for</code> loops in python are slow, as are append operations. go and check <code>numpy</code> for better performance numerical manipulations</span>
<span class="comment-copy">Also, since you use <code>input()</code>, it's impossible to reproduce your problem</span>
<span class="comment-copy">Write all these comments as information in your question and don't litter the comments.</span>
<span class="comment-copy">sorry, but this didn't speed it up at all</span>
<span class="comment-copy">@erikvalkovic: How large is <code>n</code>?</span>
<span class="comment-copy">sometimes up to 7000</span>
<span class="comment-copy">Despite bad description, problem is quite interesting. It's not that simple algorithmic problem as for example, finding k-th triplet sorted in lexicographic order (what I thought at the first time), cause even for ascending natural numbers sum of such triplet isn't always sum that we're looking for. It's probably doable to write in O(nlogn) time complexity using min-heap, but I don't have working implementation yet.</span>
<span class="comment-copy">Which is far more optimistic that worst case in current implementation which is O(min(n^k, n^(n-k)).</span>
<span class="comment-copy">Python 2 isn't going to help anything here.</span>
<span class="comment-copy"><i>"python 3 still not as fast as python 2"</i> - what's your source/proof for this statement?</span>
<span class="comment-copy"><code>import timeit</code> <code>import random</code>   def generate(num): while num: yield random.randrange(10) num -= 1   def create_list(num): numbers = [] while num: numbers.append(random.randrange(10)) num -= 1 return numbers print(timeit.timeit("sum(generate(999))", setup="from <b>main</b> import generate", number=1000)) &gt;&gt;&gt; 0.88098192215 #Python 2.7 &gt;&gt;&gt; 1.416813850402832 #Python 3.2 print(timeit.timeit("sum(create_list(999))", setup="from <b>main</b> import create_list", number=1000)) &gt;&gt;&gt; 0.924163103104 #Python 2.7 &gt;&gt;&gt; 1.5026731491088867 #Python 3.2`</span>
<span class="comment-copy">Rather than show some arbitrary micro-benchmark you created (using a very old version of Python 3) you should check out a proper benchmark, such as: <a href="https://speed.python.org/comparison/" rel="nofollow noreferrer">speed.python.org/comparison</a> which shows that the newest versions of Python 3 are pretty much as fast as Python 2.7 (in some cases even faster)</span>
<span class="comment-copy">@SamL Are you comparing to Python 3.2, which was never widely used?</span>
