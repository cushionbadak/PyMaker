<div class="post-text" itemprop="text">
<p>In Python 2.7 <code>ConfigParser.ConfigParser</code> interpolates pattern <code>%(__name__)s</code> as name of the section.</p>
<p>In Python 3.6 (as well as 3.3) <code>configparser.ConfigParser</code> fails at the same interpolation with <code>InterpolationMissingOptionError</code> exception.</p>
<p>When has the behaviour of the interpolation changed? What is the rationale of the decision (as it is harming backward-compatibility)?</p>
<p>In contrast to <a href="https://stackoverflow.com/questions/36620168/how-to-interpolate-the-section-name-with-configparser">how to interpolate the section-name with configparser</a> I am <strong>not</strong> asking how can I get that interpolation in Python 3.x.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python 3.2 the old <a href="https://docs.python.org/2/library/configparser.html#ConfigParser.ConfigParser" rel="nofollow noreferrer">ConfigParser</a> class (which implemented <code>__name__</code> interpolation) was removed and replaced by what had previously been the <a href="https://docs.python.org/2/library/configparser.html#ConfigParser.SafeConfigParser" rel="nofollow noreferrer">SafeConfigParser</a> class.  From the <a href="https://docs.python.org/3/whatsnew/3.2.html#configparser" rel="nofollow noreferrer">What's New file</a>:</p>
<blockquote>
<p>The configparser module was modified to improve usability and predictability of the default parser and its supported INI syntax. The old ConfigParser class was removed in favor of SafeConfigParser which has in turn been renamed to ConfigParser.</p>
</blockquote>
<p>The detailed motivation seems to be described in <a href="https://bugs.python.org/issue10489" rel="nofollow noreferrer">this bug report</a>:</p>
<blockquote>
<p>I want to sum up all strange things about the behaviour of <code>__name__</code>,
  a special key present in every section of a parser instance.</p>
<ol>
<li>There is a special <code>__name__</code> key in every section.</li>
<li>Except for the DEFAULTSECT.</li>
<li><code>__name__</code> key is set for every section read from a file.</li>
<li>and not when adding by <code>add_section()</code>.</li>
<li>if <code>__name__</code> does exist, it's not visible in <code>parser.options('section')</code></li>
<li>but it is visible here: <code>parser.has_option('section', '__name__') == True</code></li>
<li>and can be obtained by <code>parser.get('section', '__name__')</code></li>
<li>and can be changed by <code>parser.set('section', '__name__', 'ANY VALUE')</code></li>
<li>and can be removed by <code>parser.remove_option('section', '__name__')</code></li>
<li>even if the value is changed by <code>parser.set()</code>, it won't be written back to a file with <code>parser.write()</code></li>
</ol>
<p>All this looks like a feature that was not particularly complete and
  well defined when it was first created. Or possibly, it became rotten
  with time and now nobody is using it anyway. That way or the other, I
  couldn't come up with a valid use case for <code>__name__</code> with the current
  implementation. It doesn't serve any internal purpose and the <em>only</em>
  way you can actually get it is to <code>parser.get('section', '__name__')</code>
  which returns 'section' anyway. About as useless as it gets. Of
  course, one can go and take the internal parser._sections data
  structure of the parser but that's evil.</p>
<p>I want simply remove all mentions of a special <code>__name__</code> key in
  configparser.py. Backwards compatibility is not a concern here because
  in this case we have a concept that is so broken that you can't
  actually use it.</p>
</blockquote>
</div>
<span class="comment-copy">As a comment to the quoted statement rather than to the answer: I find the <code>__name__</code> key useful in the interpolation (combined with pattern in <code>[DEFAULT]</code> section).</span>
