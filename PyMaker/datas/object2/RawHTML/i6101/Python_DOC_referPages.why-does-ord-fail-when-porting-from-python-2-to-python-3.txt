<div class="post-text" itemprop="text">
<p>I am trying to port a Python library called <a href="https://github.com/Blizzard/heroprotocol" rel="nofollow noreferrer">heroprotocol</a> from Python 2 to Python 3. This library is used to parse replay files from an online game called Heroes of the Storm, for the purpose of getting data from the file (i.e. who played against who, when did they die, when did the game end, who won, etc).</p>
<p>It seems that this library was created for Python 2, and since I am using Python 3 (specifically Anaconda, Jupyter notebook) I would like to convert it to Python 3.</p>
<p>The specific issue I am having is that when I run</p>
<pre><code>header = protocol.decode_replay_header(mpq.header['user_data_header']['content'])
</code></pre>
<p>which should get some basic data about the replay file, I get this error:</p>
<pre><code>TypeError: ord() expected string of length 1, but int found
</code></pre>
<p>I googled the <code>ord()</code> function and found a few posts about the usage of <code>ord()</code> in Python 3, but none of them solved the issue I am having. I also tried <a href="https://github.com/Blizzard/heroprotocol/issues/57" rel="nofollow noreferrer">posting</a> in the "Issues" section on Github, but I got no response yet.</p>
<p>Why am I seeing this error?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://github.com/Blizzard/heroprotocol/issues/57" rel="nofollow noreferrer">issue</a> you raised, the exception occurs on <a href="https://github.com/Blizzard/heroprotocol/blob/master/decoders.py#L69" rel="nofollow noreferrer">line 69 of decoders.py</a>:</p>
<pre><code>self._next = ord(self._data[self._used])
</code></pre>
<p>The obvious reason this would succeed in Python 2 but fail in Python 3 is that <code>self._data</code> is a bytestring. In Python 2, bytestrings are the "standard" string objects, so that indexing into one returns the character at that position (itself a string) …</p>
<pre><code># Python 2.7
&gt;&gt;&gt; b'whatever'[3]
't'
</code></pre>
<p>… and calling <a href="https://docs.python.org/2/library/functions.html#ord" rel="nofollow noreferrer"><code>ord()</code></a> on the result behaves as expected:</p>
<pre><code>&gt;&gt;&gt; ord(b'whatever'[3])
116
</code></pre>
<p>However, in Python 3, <a href="https://docs.python.org/3/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit" rel="nofollow noreferrer">everything is different</a>: the standard string object is a Unicode string, and bytestrings are instead sequences of integers. Because of this, indexing into a bytestring returns the relevant integer directly …</p>
<pre><code># Python 3.6
&gt;&gt;&gt; b'whatever'[3]
116
</code></pre>
<p>… so calling <a href="https://docs.python.org/3/library/functions.html#ord" rel="nofollow noreferrer"><code>ord()</code></a> on that integer makes no sense:</p>
<pre><code>&gt;&gt;&gt; ord(b'whatever'[3])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: ord() expected string of length 1, but int found
</code></pre>
<p>So, you ought to be able to prevent the <em>specific</em> exception you're asking about here by simply removing the call to <code>ord()</code> on that and similar lines:</p>
<pre><code>self._next = self._data[self._used]
</code></pre>
<p>… although of course it's likely that further problems (out of scope for this question) will be revealed as a result.</p>
</div>
