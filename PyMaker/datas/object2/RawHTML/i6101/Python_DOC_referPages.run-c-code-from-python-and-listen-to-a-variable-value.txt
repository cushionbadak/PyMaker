<div class="post-text" itemprop="text">
<p>I have a C code (SDK of a sensor) that when I run it it initiate a connection to sensor through USB, then with a callback listens to the sensor outputs and print it (I also write on a text file). Every 50msec a sample is printed in this call back. </p>
<p>Now I want to run this C code from Python (because I need to analyze the data in real time in python) and whenever a callback function in C generated a new output (a 16*1 array of integers) I need to pass them to the python code.</p>
<p>I've seen few methods to run C code such as Swig, but these methods I think are used when you call C code and you get the return values of them.
But in my case, the C code is in a infinite loop and doesn't return anything in main code.  I don't also have this option to read samples one by one from sensor because every time I run the C code I should connect to sensor though USB and then be able to read values, Connecting to sensor takes time and I can not do this all the time.</p>
<p>This is the SDK (C code) I'm using to connect to sensor and read values. 
<a href="https://www.dropbox.com/s/s5rrrdy4mzrv54f/Main.c?dl=0" rel="nofollow noreferrer">https://www.dropbox.com/s/s5rrrdy4mzrv54f/Main.c?dl=0</a></p>
<p>I'm not a software engineer so I might not be good in advance coding.
Can anyone help me with that?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do a "callback" to Python with ctypes or other binding code, but that means your Python code would "get in the way" of your C code - whenever you are running Python code, you are not checking values from the sensor.</p>
<p>Sometimes, simpler is better:  you could just write your values to a file, which you could read lazily from a separate Python process.</p>
<p>If you don't want the file to grow, you could make use of a named Pipe, if you are on Unix. Or maybe just use redis to put the values in a queue. </p>
<p>Otherwise, just add the relevant PythonAPI code to your C program so that you can make use of a Python multiprocessing.Queue object and put your values there, then use multiprocessing to start the process to run your C code.  </p>
<p><a href="https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues</a></p>
<p>This will require your C code to be written so that it is callable from Python, and getting the queue as a parameter. then, your C code can just go along pooling the sensor, while the Python side consumes the values. </p>
<p>(TL;DR: Checking your C sample, it looks like you are on Linux. So my first suggestion is just the simplest thing for you - use a NamedPipe and a separate Python program to process the values. On the C side, you need to thange nothng - just create the Named Pipe where the file it would record the read data is sent to   <a href="http://www.tldp.org/LDP/lpg/node15.html" rel="nofollow noreferrer">http://www.tldp.org/LDP/lpg/node15.html</a> )</p>
</div>
<span class="comment-copy">You might look into developing a <a href="https://docs.python.org/2/extending/extending.html" rel="nofollow noreferrer">custom C module</a></span>
<span class="comment-copy">Take a look at <code>ctypes</code>. IMHO even callbacks are possible with it.</span>
<span class="comment-copy">Look into Cython.</span>
