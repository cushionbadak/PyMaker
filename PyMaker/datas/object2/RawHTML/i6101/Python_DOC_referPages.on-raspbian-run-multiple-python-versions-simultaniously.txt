<div class="post-text" itemprop="text">
<p>I have some old programs from back in the times when python 3.1 came out. 
In the program I often used the <code>Callable()</code> to pass a function and it's parameters like this to my TKinter application:</p>
<pre><code>tvf.mi(datei_bu, text=datei_opt, command=Callable(exec_datei_opts, datei_opt))
</code></pre>
<p>Now I wanted to use my programs again but the <code>callable</code>- Object was gone. In the web I found that this functionality was removed in python 3.2, and none of the alternatives worked for me.</p>
<p>Finally I decided to reinstall python 3.1. However, I have no idea if it is possible to have multiple python 3 versions installed at the same time or how to 'create' a shell command for this version when I want to use this special version.</p>
<p>My questions are:</p>
<ul>
<li>Is there a replacement for the <code>Callable</code>- Object that was removed?</li>
<li>How can I use multiple python versions at the same time?</li>
<li>How can I create a matching shell command?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It does not seem that Python ever had <code>Callable</code> built in. You may have confused it with <a href="https://docs.python.org/3/library/functions.html#callable" rel="nofollow noreferrer"><code>callable</code></a> <em>predicate</em> which indeed was removed and then brought back:</p>
<blockquote>
<p>New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2.</p>
</blockquote>
<p>All references of <code>Callable</code> on the web that I could find point to <a href="https://pypi.python.org/pypi/swampy" rel="nofollow noreferrer">swampy</a> package (a by-product of <a href="http://greenteapress.com/wp/think-python/" rel="nofollow noreferrer">Think Python</a> book), which has <a href="https://github.com/AllenDowney/Swampy/blob/master/python3/Gui.py#L1075" rel="nofollow noreferrer"><code>swampy.Gui.Callable</code></a>:</p>
<pre><code>class Callable(object):
    """Wrap a function and its arguments in a callable object.
    Callables can can be passed as a callback parameter and invoked later.
    This code is adapted from the Python Cookbook 9.1, page 302,
    with one change: if call is invoked with args and kwds, they
    are added to the args and kwds stored in the Callable.
    """
    def __init__(self, func, *args, **kwds):
        self.func = func
        self.args = args
        self.kwds = kwds

    def __call__(self, *args, **kwds):
        d = dict(self.kwds)
        d.update(kwds)
        return self.func(*self.args+args, **d)

    def __str__(self):
        return self.func.__name__
</code></pre>
<p>You can also look at answers to <a href="https://stackoverflow.com/q/36205912/2072035">this question</a>, where OP wanted to reimplement <code>Callable</code> for the same purpose.</p>
<h1>Installing Python 3.1</h1>
<p>If you still want to try to install the old version of Python 3, you can give the following a try. I assume that Raspbian is Debian-based distro and the same commands apply. Here's the <code>Dockerfile</code> that verifies that you can do it on Debian Jessie-compatibe system. You can try the <code>RUN</code> commands from it in your shell:</p>
<pre><code>FROM debian:jessie

ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update &amp;&amp; \
    apt-get install --no-install-recommends --yes software-properties-common &amp;&amp; \
    add-apt-repository ppa:deadsnakes/ppa &amp;&amp; \
    # The PPA is designed for Ubuntu, but the trick makes it work
    # because Debian Jessie is compatible with Ubuntu Trusty #
    # on package-level
    sed -i 's/jessie/trusty/g' \
        /etc/apt/sources.list.d/deadsnakes-ppa-jessie.list &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install --no-install-recommends --yes python3.1

CMD python3.1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Callable looks suspiciously like <code>functools.partial</code>.  </p>
<p>Here's partial at work. when i run:</p>
<pre><code>from functools import partial
from operator import mul

def do_stuff(num, command):
    return num + command()

for y in range(5):
    print(do_stuff(5, partial(mul, y, 2)))
</code></pre>
<p>I get:</p>
<pre><code>5
7
9
11
13
</code></pre>
<p>You should be able to do:</p>
<pre><code>from functools import partial
tvf.mi(datei_bu, text=datei_opt, command=partial(exec_datei_opts, datei_opt))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <code>terminal</code>, run with:</p>
<pre><code>python3.1 your_program.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In terminal , give the path where python 3.1 is installed like this:</p>
<pre><code>/&lt;python3.1 folder&gt;/bin/python  filename.py
</code></pre>
<p>Alternatively you can try to create virtual environment and activate it
then you can run the given script
here is the helper link: <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow noreferrer">http://docs.python-guide.org/en/latest/dev/virtualenvs/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>update-alternatives</code> command. It can help you use python flexibly.</p>
<p>Here's the sample code.</p>
<pre><code>$ sudo update-alternatives --list python3
update-alternatives: error: no alternatives for python

$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.4 1
update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python3 (python3) in auto mode
$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 2
update-alternatives: using /usr/bin/python3.5 to provide /usr/bin/python3 (python3) in auto mode

$ sudo update-alternatives --config python3
There are 2 choices for the alternative python3 (providing /usr/bin/python3).

  Selection    Path                Priority   Status
------------------------------------------------------------
* 0            /usr/bin/python3.5   2         auto mode
  1            /usr/bin/python3.4   1         manual mode
  2            /usr/bin/python3.5   2         manual mode

Press enter to keep the current choice[*], or type selection number:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If python 3.1 is unavailable, as seems to be the case from the comments on @JoeIddon answer, you may have to alter your code base. In this case, you can:</p>
<h3>Monkey patching Callable with functools.partial</h3>
<p>has the advantage of avoiding multiple code modifications.</p>
<pre><code>from functools import partial
Command = partial
tvf.mi(datei_bu, text=datei_opt, command=Command(exec_datei_opts, datei_opt))
</code></pre>
<h3>Alternatively:</h3>
<p><strong>replacing Callable() with lambda</strong> works, but carries the burden of multiple code alterations.</p>
<pre><code>tvf.mi(datei_bu, text=datei_opt, command=Callable(exec_datei_opts, datei_opt))
</code></pre>
<p>replace with:  </p>
<pre><code>tvf.mi(datei_bu, text=datei_opt, command=lambda x=datei_opt: exec_datei_opts(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Finally I got a answer to all of my questions. I used a lot of stuff from the answers here in order to solve all my problems. Here they come:</p>
<p><strong>1) Is there a replacement for the callable object that is gone?</strong></p>
<p>Basically no. At least none that is working in this context. I will explain why this does not affect my solution.</p>
<p>I made the mistake to just rip out the code out of my TKinter-application without watching my <code>include</code>-dependencies. The anwer of saaj made me rethink if had ever used swampy, and indeed I did. I even found the german equivalent ("Programmieren lernen mit python") in my bookshelf. Silly me! X}</p>
<p>I had my GUI components defined in different files, and I just imported them in the <code>main.py</code>, my main application.</p>
<p>I was not very advanced in programming so I didn't know that e.g.:</p>
<p>sub.py: (was written long before main.py)</p>
<pre><code>import THISISTHEFORGOTTENMODULE

def subfoo(temp=0):
    ... #some Code in which Functions from THISISTHEFORGOTTENMODULE were used
</code></pre>
<p>main.py:</p>
<pre><code>import sub

subfoo()
temp = SuperSpecialFunctionFromForgottenModule()
subfoo(temp)
</code></pre>
<p>This constellation lead to the behaviour that when I wrote main.py, I didn't have to say <code>THISISTHEFORGOTTENMODULE.SomeSpeci...</code>. If I would have written this, I would have known instantly what I would have to import in my new program. When I recently saw this code I thought <code>Callable</code> was from the standard library. Unfortunately, there existed a function only different in one character (major C instead of minor c) in python before and was removed. This mislead me to seach for alternatives. Stuff like <code>functools.partial</code> (credits to e.s.), would have worked in some situations, thanks for the knowledge, but it didn't work quite a few times.</p>
<p>When I finally found a <code>from swampy import *</code> in one of the submodules, I was angry at myself for stepping into <a href="https://stackoverflow.com/questions/47479965/is-there-a-point-to-import-two-different-ways-in-a-program/47480030#47480030">this</a> tripwire.(Ironically I was the one that resolved exactly that issue).</p>
<p>Credits in this part to: saaj, e.s., and myself(for the research stuff)</p>
<p><strong>2)+3) How to install multiple python versions at the same time?</strong></p>
<p>Well, I had a look at all suggestions and for me, the <code>update-alternatives</code> worked out best. I managed to install python3.1 with the suggestions of:</p>
<ul>
<li>sanket mokashi (The virtual environement suggestion)</li>
<li>saaj (The dockerfile stuff worked out as it should)</li>
<li>Byeongguk Gong (That was the most comfortable way of doing this!)</li>
</ul>
<p>I just mention this here because it is part of the question, but I didn't need this anymore, I'll just leave the answer here for anyone that passed by and needs it.</p>
<hr/>
<p>At the end of writing all this down in a summary of my results, I want to thank all guys who helped me out with this issue. </p>
</div>
<span class="comment-copy">Btw: I'm on Raspbian with a RPi 3</span>
<span class="comment-copy">Thows an error: <code>bash: python3.1: Command not found.</code></span>
<span class="comment-copy">@monamona Try <code>ls /usr/bin/python*</code> to see what you have installed...</span>
<span class="comment-copy">/usr/bin/python     /usr/bin/python3.4          /usr/bin/python3-config /usr/bin/python2    /usr/bin/python3.4-config   /usr/bin/python3m /usr/bin/python2.7  /usr/bin/python3.4m         /usr/bin/python3m-config /usr/bin/python3    /usr/bin/python3.4m-config</span>
<span class="comment-copy">I see... I will reinstall it using apt-get...</span>
<span class="comment-copy">WOW! I was told that the package python3.1 is retarded and no longer available, I should use python 3.5 X(</span>
