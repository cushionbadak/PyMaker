<div class="post-text" itemprop="text">
<p>I have the following list of letters:</p>
<pre><code>letters = ['t', 'u', 'v', 'w', 'x', 'y', 'z']
</code></pre>
<p>And following list of words:</p>
<pre><code>words = ['apple', 'whisky', 'yutz', 'xray', 'tux', 'zebra']
</code></pre>
<p>How can I search using Python if any of the combination of words exist for the list of letters? Like just looking at it we can observe that two words 'yutz' and 'tux' are the only one which can be built for the list of letters we have.</p>
<p>I'm new to Python and I tried to make different for loops but not able to reach anywhere.</p>
<pre><code>for word in words:
    for i in letters:
        if i in word:
            print(word)
        else:
            print('not in word')
</code></pre>
<p>And the result is disaster as you guys can understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to look at your problem in terms of <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">sets</a>. Any word from your <code>words</code> list that is a subset of your set of letters can be formed by those letters. Put differently, <code>letters</code> needs to be a superset of the word:</p>
<pre><code>letters = {'t', 'u', 'v', 'w', 'x', 'y', 'z'}  # a set, not a list
for word in words:
    if letters.issuperset(word):
        print(word)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.issuperset" rel="nofollow noreferrer"><code>set.issuperset()</code> method</a> returns true if all elements of the iterable argument are in the set.</p>
<p>If you wanted a list, just use a list comprehension:</p>
<pre><code>[word for word in words if letters.issuperset(word)]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; words = ['apple', 'whisky', 'yutz', 'xray', 'tux', 'zebra']
&gt;&gt;&gt; letters = {'t', 'u', 'v', 'w', 'x', 'y', 'z'}  # a set, not a list
&gt;&gt;&gt; [word for word in words if letters.issuperset(word)]
['yutz', 'tux']
</code></pre>
<p>Note that this only looks at <em>unique letters</em>. <code>apple</code> is a subset of the <code>letters</code> set <code>{'a', 'p', 'l', 'e'}</code>. If you need to handle <em>letter counts</em> too, you need to use a <em>multiset</em>; Python has an implementation called <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a>. This keeps track not only of the letters, but also of their counts.</p>
<p>The <code>Counter</code> type doesn't support testing for sub- or supersets, so you have to use subtraction instead; if an empty <code>Counter()</code> is produced, the whole word can be formed from the letter counts:</p>
<pre><code>letters = Counter(['a', 'p', 'l', 'e', 'p', 'i'])
words = ['apple', 'applepie']
for word in words:
    if Counter(word) - letters:
        print(word)
</code></pre>
<p>or as a list comprehension:</p>
<pre><code>[word for word in words if Counter(word) - letters]
</code></pre>
<p>which produces <code>['apple']</code>, as there is only a single <code>'e'</code> in the input letter multi-set, and only 2 <code>'p'</code>s, not 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.difference" rel="nofollow noreferrer"><code>set.difference</code></a> here:</p>
<pre><code>r = [w for w in words if not set(w).difference(letters)]

r
['yutz', 'tux']
</code></pre>
<p>If the result is an empty set, that means every character in <code>w</code> belongs to <code>letters</code>. If that is the case, <code>set.difference</code> returns an empty <code>set</code>, which is <code>False</code>-y, so <code>not ....</code> results in <code>True</code> and the word is printed. This is equivalent to:</p>
<pre><code>for w in words:
    if not set(w).difference(letters):
        print(w)

yutz
tux
</code></pre>
<p>This is similar to testing with <code>set.issuperset</code>, but approaches the problem from a different perspective.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>all</code> function with a generator to determine if all the characters in a word belonging to <code>words</code> exists in <code>letters</code>:</p>
<pre><code>letters = ['t', 'u', 'v', 'w', 'x', 'y', 'z']
words = ['apple', 'whisky', 'yutz', 'xray', 'tux', 'zebra']
final_words = [i for i in words if all(c in letters for c in i)]
</code></pre>
<p>Output:</p>
<pre><code>['yutz', 'tux']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>You can use itertool's permutation method :</p>
</blockquote>
<p>In one line:</p>
<pre><code>print(set(["".join(permutation) for item in words for permutation in itertools.permutations(letters,len(item)) if "".join(permutation) in words ]))
</code></pre>
<p>Detailed solution:</p>
<p>above list comprehension is same as:</p>
<pre><code>words = ['apple', 'whisky', 'yutz', 'xray', 'tux', 'zebra']

letters = ['t', 'u', 'v', 'w', 'x', 'y', 'z']
import itertools

final=[]
for i in words:
    for k in itertools.permutations(letters,len(i)):
        if "".join(k) in words and "".join(k) not in final:
            final.append("".join(k))

print(final)
</code></pre>
<p>output:</p>
<pre><code>['yutz', 'tux']
</code></pre>
</div>
<span class="comment-copy">Split every word in words by letter then sort it and join then compare joined string with sorted and joined letters.</span>
<span class="comment-copy">@SergAnuke There's no need to do sorting here.</span>
<span class="comment-copy">Can you only use each letter once?</span>
<span class="comment-copy">This works if the letter can be re-used. Take apple - it has 2 'p' s if the list only has one p in it - can you make apple from that list ie ['a', 'p', 'l', 'e'] ?</span>
<span class="comment-copy">@SamRedway: already addressed (I was typing up the sample when you commented).</span>
<span class="comment-copy">@MartijnPieters I have been able to solve this problem but now have I another challenge. Scrabble can have blank tiles which we can denote as "<i>" in python. What if in my example instead of 't' we have "</i>". Humanly we know that we can use this blank tile and make words like "ytuz" and "tux". But how will we do it programmatically?</span>
<span class="comment-copy">They don't want to know what letters are missing, only if the word can be formed from the letters. A simple subset / superset test is all that is needed.</span>
<span class="comment-copy">@MartijnPieters The essence of my answer captures exactly that.</span>
<span class="comment-copy">@MartijnPieters My answer is just as valid as yours, I don't see the reason for a downvote here.</span>
<span class="comment-copy">And creating a new set instead of a boolean is inefficient. There is no need to turn each word into a new set object, and <code>set.difference()</code> returns a full set object, which you then only test for containing elements and discard again.</span>
<span class="comment-copy">@MartijnPieters I very explicitly said (in my initial answer) "If the result is an empty set, that means every character in w belongs to letters." If that doesn't explain what I wanted to convey, I don't know what does.</span>
<span class="comment-copy">Lets say a word has two instances of a letter - but the list letters only has one instance of that letter?</span>
<span class="comment-copy">@SamRedway this answers checks for existence. Your statement above would apply to a program using <code>collections.Counter</code> or another system of storing letter frequencies.</span>
<span class="comment-copy">Was a question rather than a statement. I don't think the OP has been clear on this point.</span>
<span class="comment-copy">This is <b>hugely</b> inefficient. You are executing O(N!) different tests for every word, where only O(N) tests are needed.</span>
<span class="comment-copy">@MartijnPieters I just shown that he can try this , i didn't said 'you must' , i know you have answered in good way and i know those methods too so should i repeat your answer ?</span>
<span class="comment-copy">I'm just giving feedback on how useful this approach is, nothing more.</span>
