<div class="post-text" itemprop="text">
<p>How can I pass a <code>str</code> value (containing 3000 {'0', '1'} bytes) obtained using python code as an argument to a python c extended function (extended using SWIG) which requires <code>int *</code> (fixed length int array) as an input argument? My code is such:</p>
<pre><code>int *exposekey(int *bits) {
    int a[1000];
    for (int j=2000; j &lt; 3000; j++) {
        a[j - 2000] = bits[j];
    }
    return a;
}
</code></pre>
<p>What I've tried was to use <code>ctypes</code> (see below code):</p>
<pre><code>import ctypes
ldpc = ctypes.cdll.LoadLibrary('./_ldpc.so')
arr = (ctypes.c_int * 3072)(&lt;mentioned below&gt;)
ldpc.exposekey(arr)
</code></pre>
<p>with 3072 {0, 1} entered in the  position. Python returns syntax error : more than 255  arguments. This still doesn't help me to pass assigned str value instead of the initialized <code>ctypes</code> int array.</p>
<p>Other suggestion included using SWIG typemaps but how would that work for converting a str into <code>int *</code> ? Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Regarding my comment, here are some more details about returning arrays from functions: <a href="https://stackoverflow.com/questions/11656532/returning-an-array-using-c">[SO]: Returning an array using C</a>. In short: ways handle this:</p>
<ol>
<li>Make the returned variable <strong><em>static</em></strong></li>
<li>Dynamically allocate it (using <em>malloc</em> (family) or <em>new</em>)</li>
<li>Turn it into an additional argument for the function</li>
</ol>
<p>Getting that piece of <em>C</em> code to run within the <em>Python</em> interpreter is possible in 2 ways:</p>
<ul>
<li><a href="https://docs.python.org/3/extending/extending.html" rel="nofollow noreferrer">[Python 3]: Extending Python with C or C++</a> - which creates a <em>C</em> written <em>Python</em> module

<ul>
<li>A way of doing that is using <em>swig</em> which offers a simple interface for generating the module (<a href="http://www.swig.org/Doc1.3/SWIG.html" rel="nofollow noreferrer">[swig]: SWIG Basics</a>) saving you the trouble of writing it yourself using <a href="https://docs.python.org/3/c-api/index.html#c-api-index" rel="nofollow noreferrer">[Python 3]: Python/C API Reference Manual</a></li>
</ul></li>
<li>The other way around, leaving the code in a standard <em>dll</em> which can be accessed via <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a></li>
</ul>
<p>Since they both are doing the same thing, mixing them together makes no sense. So, pick the one that best fits your needs.</p>
<p><br/></p>
<h3>1. <em>ctypes</em></h3>
<ul>
<li>This is what you started with</li>
<li>It's <strong>one</strong> of the ways of doing things using <em>ctypes</em></li>
</ul>
<p><em>ctypes_demo.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;

#if defined(_WIN32)
#  define CTYPES_DEMO_EXPORT_API __declspec(dllexport)
#else
#  define CTYPES_DEMO_EXPORT_API
#endif


CTYPES_DEMO_EXPORT_API int exposekey(char *bitsIn, char *bitsOut) {
    int ret = 0;
    printf("Message from C code...\n");
    for (int j = 0; j &lt; 1000; j++)
    {
        bitsOut[j] = bitsIn[j + 2000];
        ret++;
    }
    return ret;
}
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Based on comments, I changed the types in the function from <code>int*</code> to <code>char*</code>, because it's 4 times more compact (although it's still <em>~700%</em> inefficient since 7 bits of each char are ignored versus only one of them being used; that can be fixed, but requires <em>bitwise</em> processing)</li>
<li>I took <em>a</em> and turned into the 2<sup>nd</sup> argument (<em>bitsOut</em>). I think this is best because it's caller responsibility to allocate and deallocate the array (the 3<sup>rd</sup> option from the beginning)</li>
<li>I also modified the index range (without changing functionality), because it makes more sense to work with low index values and add something to them in one place, instead of a high index values and subtract (the same) something in another place</li>
<li>The return value is the number of bits set (obviously, 1000 in this case) but it's just an example</li>
<li><em>printf</em> it's just dummy, to show that the <em>C</em> code gets executed</li>
<li>When dealing with such arrays, it's recommended to pass their dimensions as well, to avoid out of bounds errors. Also, <strong>error handling</strong> is an important aspect</li>
</ul>
<p><em>test_ctypes.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>from ctypes import CDLL, c_char, c_char_p, c_int, create_string_buffer


bits_string = "010011000110101110101110101010010111011101101010101"


def main():
    dll = CDLL("./ctypes_demo.dll")
    exposekey = dll.exposekey

    exposekey.argtypes = [c_char_p, c_char_p]
    exposekey.restype = c_int

    bits_in = create_string_buffer(b"\0" * 2000 + bits_string.encode())
    bits_out = create_string_buffer(1000)
    print("Before: [{}]".format(bits_out.raw[:len(bits_string)].decode()))
    ret = exposekey(bits_in, bits_out)
    print("After: [{}]".format(bits_out.raw[:len(bits_string)].decode()))
    print("Return code: {}".format(ret))


if __name__ == "__main__":
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>1<sup>st</sup>, I want to mention that running your code didn't raise the error you got</li>
<li>Specifying function's <em>argtypes</em> and <em>restype</em> <strong>is</strong> mandatory, and also makes things easier (documented in the <em>ctypes</em> tutorial)</li>
<li>I am printing the <em>bits_out</em> array (only the first - and relevant - part, as the rest are <em>0</em>) in order to prove that the <em>C</em> code did its job</li>
<li>I initialize <em>bits_in</em> array with 2000 dummy <em>0</em> at the beginning, as those values are not relevant here. Also, the input string (<em>bits_string</em>) is not 3000 characters long (for obvious reasons). If your <em>bits_string</em> is 3000 characters long you can simply initialize <em>bits_in</em> like: <code>bits_in = create_string_buffer(bits_string.encode())</code></li>
<li><strong>Do not forget</strong> to initialize <em>bits_out</em> to an array with a size large enough (in our example 1000) for its purpose, otherwise <em>segfault</em> might arise when trying to set its content past the size</li>
<li>For this (simple) function, the <em>ctypes</em> variant was easier (at least for me, since I don't use <em>swig</em> frequently), but for more complex functions / projects it will become an overkill and switching to <em>swig</em> would be the right thing to do</li>
</ul>
<p><strong>Output</strong> (running with <em>Python3.5</em> on <em>Win</em>):</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>c:\Work\Dev\StackOverflow\q47276327&gt;"c:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" test_ctypes.py
Before: [                                                   ]
Message from C code...
After: [010011000110101110101110101010010111011101101010101]
Return code: 1000
</code></pre>
</blockquote>
<p><br/></p>
<h3>2. <em>swig</em></h3>
<ul>
<li><em>Almost</em> everything from the <em>ctypes</em> section, applies here as well</li>
</ul>
<p><em>swig_demo.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;malloc.h&gt;
#include &lt;stdio.h&gt;
#include "swig_demo.h"


char *exposekey(char *bitsIn) {
    char *bitsOut = (char*)malloc(sizeof(char) * 1000);
    printf("Message from C code...\n");
    for (int j = 0; j &lt; 1000; j++) {
        bitsOut[j] = bitsIn[j + 2000];
    }
    return bitsOut;
}
</code></pre>
<p><em>swig_demo.i</em>:</p>
<pre class="lang-c prettyprint-override"><code>%module swig_demo
%{
#include "swig_demo.h"
%}

%newobject exposekey;
%include "swig_demo.h"
</code></pre>
<p><em>swig_demo.h</em>:</p>
<pre class="lang-c prettyprint-override"><code>char *exposekey(char *bitsIn);
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Here I'm allocating the array and return it (the 2<sup>nd</sup> option from the beginning)</li>
<li>The <em>.i</em> file is a standard <em>swig</em> interface file

<ul>
<li>Defines the module, and its exports (via <code>%include</code>)</li>
<li>One thing that is worth mentioning is the <code>%newobject</code> directive that deallocates the pointer returned by <em>exposekey</em> to avoid memory leaks</li>
</ul></li>
<li>The <em>.h</em> file just contains the function declaration, in order to be included by the <em>.i</em> file (it's not mandatory, but things are more elegant this way) </li>
<li>The rest is pretty much the same</li>
</ul>
<p><em>test_swig.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>from swig_demo import exposekey

bits_in = "010011000110101110101110101010010111011101101010101"


def main():
    bits_out = exposekey("\0" * 2000 + bits_in)
    print("C function returned: [{}]".format(bits_out))


if __name__ == "__main__":
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Things make much more sense from <em>Python</em> programmer's  <em>PoV</em></li>
<li>Code is a lot shorter (that is because <em>swig</em> did some "magic" behind the scenes):

<ul>
<li>The wrapper <em>.c</em> wrapper file generated from the <em>.i</em> file has <em>~120K</em></li>
<li>The <em>swig_demo.py</em> generated module has <em>~3K</em></li>
</ul></li>
<li>I used the same technique with 2000 <em>0</em> at the beginning of the string</li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>c:\Work\Dev\StackOverflow\q47276327&gt;"c:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" test_swig.py
Message from C code...
C function returned: [010011000110101110101110101010010111011101101010101]
</code></pre>
</blockquote>
<p><br/></p>
<h3>3. Plain <em>Python C API</em></h3>
<ul>
<li>I added this part as a personal exercise</li>
<li>This is what <em>swig</em> does, but "manually"</li>
</ul>
<p><em>capi_demo.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include "Python.h"
#include "swig_demo.h"

#define MOD_NAME "capi_demo"


static PyObject *PyExposekey(PyObject *self, PyObject *args) {
    PyObject *bitsInArg = NULL, *bitsOutArg = NULL;
    char *bitsIn = NULL, *bitsOut = NULL;
    if (!PyArg_ParseTuple(args, "O", &amp;bitsInArg))
        return NULL;
    bitsIn = PyBytes_AS_STRING(PyUnicode_AsEncodedString(bitsInArg, "ascii", "strict"));
    bitsOut = exposekey(bitsIn);
    bitsOutArg = PyUnicode_FromString(bitsOut);
    free(bitsOut);
    return bitsOutArg;
}


static PyMethodDef moduleMethods[] = {
    {"exposekey", (PyCFunction)PyExposekey, METH_VARARGS, NULL},
    {NULL}
};


static struct PyModuleDef moduleDef = {
    PyModuleDef_HEAD_INIT, MOD_NAME, NULL, -1, moduleMethods
};


PyMODINIT_FUNC PyInit_capi_demo(void) {
    return PyModule_Create(&amp;moduleDef);
}
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>It requires <em>swig_demo.h</em> and <em>swig_demo.c</em> (not going to duplicate their contents here)</li>
<li>It <strong>only</strong> works with <em>Python 3</em> (actually I got quite some headaches making it work, especially because I was used to <em>PyString_AsString</em> which is no longer present)</li>
<li>Error handling is poor</li>
<li><em>test_capi.py</em> is similar to <em>test_swig.py</em> with one (obvious) difference: <code>from swig_demo import exposekey</code> should be replaced by <code>from capi_demo import exposekey</code></li>
<li>The output is also the same to <em>test_swig.py</em> (again, not going to duplicate it here)</li>
</ul>
</div>
<span class="comment-copy">Returning local arrays from functions is a tricky thing since they reside on the stack, and get destroyed when going out of scope, and thus later on when the returned address will be dereferenced, you'll most likely get a <i>segfault</i>. Either make it <code>static</code>, or dynamically allocate it, or add it as a 2nd (output) argument to your function. I'd go with #3.</span>
<span class="comment-copy">Thank you soo much . this works perfectly. But like you said i'am trying to apply thins logic to complex functions/projects , hence the use of SWIG.</span>
<span class="comment-copy">In the above code you are defining the input array to be passed, if have an input string of 0's and 1's (type= python str) how do i pass that as input to this ctypes func?  Thanks  again.</span>
<span class="comment-copy">If you want to pass a string, you need to change the function (so its <code>bits</code> argument is a <code>char*</code>), and also from <i>Python</i>, its <code>argtypes</code>. It's definitely better to store a <b>0/1</b> value (1bit) in a <code>char</code> (8bits) than in an <code>int</code> (32bits), however it's still 700% inefficient from the storage's <i>PoV</i> (as the <code>char</code> 7 other bits aren't used). While on this subject, if changing <code>bits</code> wouldn't it be a good idea to also change <code>out</code> (to <code>char*</code>)? Or you could go the easy way (initialize <code>bits</code> like this): <code>for i, char in enumerate(your_string):</code> <code>bits[2000 + i] = ord(char) - ord("0")</code>.</span>
<span class="comment-copy">Did you give the <i>swig</i> variant a try?</span>
<span class="comment-copy">yes still have to try that</span>
