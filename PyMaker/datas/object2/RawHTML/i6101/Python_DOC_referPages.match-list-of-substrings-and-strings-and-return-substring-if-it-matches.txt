<div class="post-text" itemprop="text">
<p>I've seen may questions on this topic but most are the opposite of mine. I have a list of strings (column of a data frame) and a list of sub strings. I want to compare each string to the list of sub strings If it contains a sub string then return that sub-string else print 'no match'.</p>
<pre><code>    subs = [cat, dog, mouse]

    df

      Name       Number     SubMatch
     dogfood      1           dog
     catfood      3           cat
     dogfood      2           dog
     mousehouse   1           mouse
     birdseed     1           no match
</code></pre>
<p>my current output looks like this though:</p>
<pre><code>     Name       Number     SubMatch
     dogfood      1           dog
     catfood      3           dog
     dogfood      2           dog
     mousehouse   1           dog
     birdseed     1           dog
</code></pre>
<p>I suspect my code is just returning the first thing in the series, how do I change that to the correct thing in the series? Here is the Function:</p>
<pre><code>    def matchy(col, subs):
        for name in col:
            for s in subs:
                if any(s in name for s in subs):
                    return s
                else:
                    return 'No Match'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The pandaic way to solve this would be to not use loops at all. You could do this pretty simply with <code>str.extract</code>:</p>
<pre><code>p = '({})'.format('|'.join(subs))
df['SubMatch'] = df.Name.str.extract(p, expand=False).fillna('no match')

df

         Name  Number  SubMatch
0     dogfood       1       dog
1     catfood       3       cat
2     dogfood       2       dog
3  mousehouse       1     mouse
4    birdseed       1  no match
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>def matchy(col, subs):
    for name in col:
        try:
            return next(x for x in subs if x in name)
        except StopIteration:
            return 'No Match'
</code></pre>
<p>The problem with your code was that you were checking for matches with <code>any</code> but returning the first item of the iteration first (<code>dog</code>).</p>
<hr/>
<p><strong>EDIT</strong> kudos @Coldspeed</p>
<pre><code>def matchy(col, subs):
    for name in col:
        return next(x for x in subs if x in name, 'No match')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you are over complicating things with a nested loop then the <code>any</code> test inside. Would this work better:</p>
<pre><code>def matchy(col, subs):
        for name in col:
            for s in subs:
                if s in name:
                    return s
                else:
                    return 'No Match'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unless there is code missing that accounts for it, it would appear that your code returns the result for the very first comparison, and actually does not look at any of the other items in the <code>col</code> list. If you would rather stick with nested loops, I would suggest modifying your code like so:</p>
<pre><code>def matchy(col, subs):
    subMatch = []
    for name in col:
        subMatch.append('No Match')
        for s in subs:
            if s in name:
                subMatch[-1] = s
                break
    return subMatch
</code></pre>
<p>This assumes that <code>col</code> is a list of strings containing the column information (dogfood, mousehouse, etc) and that <code>subs</code> is a list of strings containing the substrings you wish to search for. <code>subMatch</code> is a list of strings returned by <code>matchy</code> that contains the search results for each item in <code>col</code>.</p>
<p>For each value in <code>col</code> we examine, we append the <code>'No Match'</code> string to subMatch, basically assuming we did not find a match. Then we iterate through <code>subs</code>, checking to see if the substring <code>s</code> is contained within <code>name</code>. If there is a match, then <code>subMatch[-1] = s</code> replaces the most recent <code>'No Match'</code> we appended with the matching substring, then we break to move onto the next item in <code>col</code> since we don't need to search for any more values. Note that <code>subMatch[-1] = s</code> can be replaced with other methods, such as doing <code>subMatch.pop()</code> followed by <code>subMatch.append(s)</code>, though at that point I think it is more personal preference. Once all elements in <code>col</code> have been checked, <code>subMatch</code> is returned, at which point you can then process it however you like.</p>
</div>
<span class="comment-copy">You don't need the <code>any(s in name for s in subs)</code> loop in line 4 as you are already looping over the list of subs in line 3.</span>
<span class="comment-copy">@Vaishali <code>p</code> is a regex pattern ;-) (<code>'(cat|dog|mouse)'</code>)</span>
<span class="comment-copy">This was the only answer that worked out of the top few. Thanks!</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> has a default argument which is returned if nothing else is. You can get rid of the <code>try-except</code> and reduce this to a single line - <code>next( (x for x in subs if x in name), 'No match')</code></span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Thanks a lot for the hint! Didn't know that.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Shouldn't one go with <code>yield</code> here?</span>
