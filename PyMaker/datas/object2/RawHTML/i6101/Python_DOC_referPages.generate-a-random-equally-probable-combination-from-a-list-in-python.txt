<div class="post-text" itemprop="text">
<p>Let's say I have a list like this: <code>['a','b','c']</code>. I need to get a random combination from this list eg <code>['a','c']</code>. However I need all combinations to have equal probability so the chances of getting <code>['a']</code> should be the exact same as the chances of getting <code>['b','c']</code>. My real list is 22 elements long so enumerating every single combination is impossible. My first thought was to use random.sample however that requires you to specify the number of elements, which would have to be randomly chosen but the probability would have to be (number of elements in this combination)/(number of elements in all combinations) which are gigantic numbers. Is there any better way? This will be run thousands of times so efficient solutions are appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a very efficient way to do this. The set of all combinations of a given set is known as the <a href="https://en.wikipedia.org/wiki/Power_set" rel="nofollow noreferrer">power set</a>, the set of all subsets of the given set. If the set S contains m items, then there are <code>2**m</code> possible combinations in total, including the empty set and S itself.</p>
<p>So to randomly select a combination from the power set of S we just need to choose a random number n from <code>range(2**m)</code> as an index into the power set and then generate the combination corresponding to n. </p>
<p>We can convert the index number n into a combination by looking at the binary expansion of n. There are m bits in n. We pair up those bits with the items in S. If a given bit is 1 then that item is selected for our combination, if it's a 0, we reject that item.</p>
<p>Here's a short demo.</p>
<pre><code>from random import seed, randrange

seed(42)

def indexed_combination(seq, n):
    result = []
    for u in seq:
        if n &amp; 1:
            result.append(u)
        n &gt;&gt;= 1
        if not n:
            break
    return result

print('Testing indexed_combination')
seq = 'abc'
for i in range(1 &lt;&lt; len(seq)):
    print(i, ''.join(indexed_combination(seq, i)))
print()

def random_combination(seq):
    n = randrange(1 &lt;&lt; len(seq))
    return indexed_combination(seq, n)

print('Testing random_combination')
seq = 'abcdefghij'
for i in range(20):
    print(i, random_combination(seq))
</code></pre>
<p><strong>output</strong></p>
<pre><code>Testing indexed_combination
0 
1 a
2 b
3 ab
4 c
5 ac
6 bc
7 abc

Testing random_combination
0 ['c', 'f', 'g', 'h']
1 ['a', 'b', 'e', 'f']
2 ['a', 'b', 'e', 'f', 'j']
3 ['a', 'c', 'e', 'f', 'g', 'h', 'i']
4 ['a', 'd', 'g', 'h', 'i']
5 ['a', 'c', 'd', 'e', 'i']
6 ['a', 'e', 'g', 'h']
7 ['b', 'e', 'f', 'h']
8 ['f', 'g', 'i', 'j']
9 ['a', 'g']
10 ['a', 'c', 'd', 'e', 'f']
11 ['a', 'b', 'c', 'd', 'e', 'f', 'h']
12 ['a', 'b', 'c', 'd', 'e', 'f', 'h', 'i']
13 ['c', 'd', 'e', 'g', 'h', 'i']
14 ['b', 'c', 'e', 'f']
15 ['a', 'b', 'c', 'e', 'h', 'i']
16 ['a', 'b', 'd', 'e', 'g', 'i', 'j']
17 ['a', 'b', 'g', 'h', 'i']
18 ['a', 'b', 'c', 'e', 'h', 'i', 'j']
19 ['a', 'd', 'e', 'f', 'j']
</code></pre>
<hr/>
<p>I call the random <code>seed</code> function at the start of the script with a fixed seed number. I find it's convenient to do that when developing code that uses pseudorandom numbers because it makes it easier to test and debug the code when the random numbers are reproducible. In a real application you should seed the radomizer with a system entropy source. You can easily do that by eliminating the <code>seed</code> call, or by doing <code>seed(None)</code>. If you want more randomness than what the standard Mersenee Twister generator offers, you can hook into the system's random source via the <a href="https://docs.python.org/3/library/random.html#random.SystemRandom" rel="nofollow noreferrer"><code>random.SystemRandom</code></a> class.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll use <code>combination</code> to create an iterable for n choose i, then use <code>chain</code> to combine all such combinations for i equals 1 to n.  The total number of combinations will be <code>2 ** n - 1</code> so I'll pick a random integer from 0 to 2 ** n - 2.  Finally, use <code>islice</code> to pluck that one from the iterable.</p>
<pre><code>from itertools import islice, combinations, chain
from string import ascii_uppercase

def pickcomb(i):
    n = len(i)
    allcomb = chain(*(combinations(i, j) for j in range(1, n + 1)))
    k = random.randint(0, 2 ** n - 2)
    return list(islice(allcomb, k, k + 1))[0]

pickcomb(ascii_uppercase[:22])

('A', 'E', 'F', 'H', 'I', 'K', 'L', 'M', 'O', 'Q', 'S', 'T')
</code></pre>
<hr/>
<p><strong>Let's test it</strong></p>
<p>I suspect that over large numbers, we should see a fairly uniform distribution.  I'll use <code>pandas.value_counts</code>.  You can see that we have the correct number of observation types and of fairly uniform distribution.</p>
<pre><code>import pandas as pd

s = pd.value_counts([pickcomb(ascii_uppercase[:5]) for _ in range(100000)])
print(len(s), 2 ** 5 - 1, s, sep='\n\n')

31

31

(A, B, C, D, E)    3329
(A, D)             3320
(C, D)             3301
(A, D, E)          3277
(D, E)             3276
(B, C, D)          3270
(A, E)             3268
(A, B)             3258
(C, E)             3251
(A, B, C)          3250
(A, B, C, E)       3248
(C, D, E)          3245
(A, C)             3245
(D,)               3241
(C,)               3234
(A, B, D)          3227
(A, C, E)          3220
(B, D, E)          3215
(A, B, E)          3213
(B, C, E)          3213
(B, C, D, E)       3213
(A, C, D)          3211
(B, E)             3194
(B, C)             3193
(A, B, D, E)       3185
(A, B, C, D)       3174
(A, C, D, E)       3158
(E,)               3151
(B,)               3150
(B, D)             3148
(A,)               3122
dtype: int64
</code></pre>
</div>
<span class="comment-copy">I think do you need to run two random functions, one for the number of elements (n) that you will pick you, and another to run n random to pickups those elements.</span>
<span class="comment-copy">Is <code>['a', 'c']</code> the same as <code>['c', 'a']</code> or different?</span>
<span class="comment-copy">@piRSquared  He said combinations, not permutations.</span>
<span class="comment-copy">22 elements? I guess you're working with the proteogenic amino acids.</span>
<span class="comment-copy">Please consider upvoting and accepting @PM2Ring 's answer.  That answer is an order of magnitude more efficient than mine and much more elegant.  If you don't understand it.  I'd recommend taking the time to figure it out.  It's a great lesson in python.  If you choose to keep my answer as the accepted answer due to ease of comprehension, then let this comment be a testament to others that PM 2Ring's answer is the answer to use.</span>
<span class="comment-copy">It is my opinion that this is the superior answer and should be accepted.  <a href="https://stackoverflow.com/questions/47234958/generate-a-random-equally-probable-combination-from-a-list-in-python#comment81443547_47234958">See comment on question</a></span>
<span class="comment-copy">I believe this is a methodology that provides the most efficient "close enough" solution to your problem.  Based on this data, you have a coefficient of variation of 1.5%, which is statistically significant, however without running the results multiple times (which drastically reduces your efficiency) this is the most "random" that you're going to get out of the box.</span>
<span class="comment-copy">@piRsquared yea I read his solution over and it makes sense too so I'll switch it over. Admirable of you.</span>
