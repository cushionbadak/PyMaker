<div class="post-text" itemprop="text">
<p>As a follow up on <a href="https://stackoverflow.com/questions/47275734/using-threading-rlock-correctly">this question</a>, I have a trivial script which starts a <code>threadpoolexecutor</code> to read in a <code>json</code> file. While doing that I want to it count from 1 to 9 using a <code>for</code> loop. For some reason even though I used <code>executor.shutdown(wait=False)</code> it still blocks and waits for the <code>read_employees</code> method to execute. </p>
<p>According to the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.shutdown" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>If wait is False then this method will return immediately and the resources associated with the executor will be freed when all pending futures are done executing</p>
</blockquote>
<pre><code>import concurrent.futures
import json
import time


def read_employees(read_file):
    with open(read_file) as f_obj:
        employees = json.load(f_obj)

    for emp in employees:
        print(emp)
        time.sleep(3)


def start_thread():
    filename = 'employee.json'
    with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
        executor.submit(read_employees, filename)
        executor.shutdown(wait=False)

def print_number():
    for num in range(1,10):
        time.sleep(2)
        print(num)


start_thread()
print_number()
</code></pre>
<p>If I were to do this:</p>
<pre><code>def read_employees(read_file):
    with open(read_file) as f_obj:
        employees = json.load(f_obj)

    for emp in employees:
        time.sleep(5)
        print(emp)


def print_number():
    for num in range(1,10):
        print(num)


filename = 'employee.json'
empThread = threading.Thread(target=read_employees, args=(filename,))
empThread.start()

print_number()
</code></pre>
<p>It counts from 1 to 9 first and then prints out the employees, the delay is because of sleep while reading the employees. Like so:</p>
<pre><code>1
2
3
4
5
6
7
8
9
ams@yourcompanyname.com
bcs@yourcompanyname.com
</code></pre>
<p>How do I achieve the same output using the <code>threadpoolexecutor</code> without blocking? </p>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend that you don't use a <code>with</code> statement. A <code>with</code> statement closes by calling the <code>__exit__</code> method of a <a href="https://docs.python.org/3/reference/compound_stmts.html#with" rel="nofollow noreferrer">context manager</a>. A context manager is any class that implements an <code>__enter__</code> and <code>__exit__</code> method. So after everything is run within a <code>with</code> statement, it calls <code>__exit__</code> on the context manager that was passed in.</p>
<p>In this case, <code>ThreadPoolExecutor</code> is a context manager. <code>ThreadPoolExecutor</code> is a subclass of <code>Executor</code>. So by referencing <a href="https://github.com/python/cpython/blob/7eb3f8226ea7b79dae4e4e8b05730cfe0d9af7c1/Lib/concurrent/futures/_base.py#L610" rel="nofollow noreferrer"><code>Executor</code>'s class definition</a>, we see that in its <code>__exit__</code> method it calls <code>self.shutdown(wait=True)</code>.</p>
<p>That call to <code>self.shutdown(wait=True)</code> is the problem. If you follow the how the context manager works, since <code>self.shutdown(wait=False)</code> is the last thing in your <code>with</code> statement, <code>__exit__</code> is going to be called directly after. And that means that <code>self.shutdown(wait=True)</code> will be called. So that's what is blocking you.</p>
<p>You have two options to fix this. The first one is to subclass <code>ThreadPoolExecutor</code> and rewrite the <code>__exit__</code> method.</p>
<p>The second option is to do something like this:</p>
<pre><code>def start_thread():
    filename = 'employee.json'
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=2)
    executor.submit(read_employees, filename)
    executor.shutdown(wait=False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Probably due to this little snippet: </p>
<p>"You can avoid having to call this method explicitly if you use the <code>with</code> statement, which will shutdown the <code>Executor</code> (waiting as if <code>Executor.shutdown()</code> were called with <code>wait</code> set to <code>True</code>)"</p>
<p><a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">https://docs.python.org/3/library/concurrent.futures.html</a></p>
</div>
<span class="comment-copy">This is why I set the <code>wait</code> to <code>False</code>, but it still outputs as if it's blocking.</span>
