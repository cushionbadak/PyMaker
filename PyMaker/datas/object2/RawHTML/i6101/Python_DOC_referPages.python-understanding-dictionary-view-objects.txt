<div class="post-text" itemprop="text">
<p>I've been trying to understand built-in view objects return by <code>.items()</code>, <code>.values()</code>, <code>.keys()</code> in Python 3 or similarly by <code>.viewitems()</code>, <code>.viewvalues()</code>, <code>.viewkeys()</code>. There are other threads on that subject but none (even the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">doc</a>) seems to described how they work internally. </p>
<p>The main gain here seems to be efficienty compared to the copy of type <code>list</code> returned in Python 2. There are often compared to a <strong><em>window</em></strong> to the dictionnary items (like in this <a href="https://stackoverflow.com/questions/8957750/what-are-python-dictionary-view-objects">thread</a>).</p>
<p>But what is that <strong><em>window</em></strong> and why is it more efficient ?</p>
<p>The only thing I can see is that the view objects seems to be  <em>set-like</em> objects, which are generally faster for membership testing. But is this the only factor ?</p>
<p><strong>Code sample</strong></p>
<pre><code>&gt;&gt;&gt; example_dict = {'test':'test'}
&gt;&gt;&gt; example_dict.items()
dict_items([('test', 'test')])
&gt;&gt;&gt; type(example_dict.items())
&lt;class 'dict_items'&gt;
</code></pre>
<p>So, my question is regarding this <code>dict_items</code> class. How does that work internally?</p>
</div>
<div class="post-text" itemprop="text">
<p>Dict views store a reference to their parent dict, and they translate operations on the view to corresponding operations on the dict.</p>
<p>Iteration over a dict view is more efficient than building a list and iterating over that, because building a list takes time and memory that you don't have to spend with the view. The old way, Python would iterate over the dict's underlying storage to build a new list, and then you would iterate over the list. A dict view gives you an iterator that walks through the dict's underlying storage directly, skipping the unnecessary list step.</p>
<p>Dict views also support efficient containment tests and setlike intersection/difference/etc. operations, because they get to perform direct hash lookups on the underlying dict instead of iterating through a list and checking equality element by element.</p>
<p>If you want to see the concrete implementation used by CPython, you can take a look in the <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c" rel="nofollow noreferrer">official repository</a>, but this implementation is subject to change. It has changed, repeatedly.</p>
</div>
<div class="post-text" itemprop="text">
<p>One of the main advantages is that views are dynamic:</p>
<pre><code>&gt;&gt;&gt; di={1:'one',2:'two',3:'three'}
&gt;&gt;&gt; view=di.viewitems()
&gt;&gt;&gt; view
dict_items([(1, 'one'), (2, 'two'), (3, 'three')])
&gt;&gt;&gt; di[2]='new two'
&gt;&gt;&gt; view
dict_items([(1, 'one'), (2, 'new two'), (3, 'three')])
</code></pre>
<p>Therefore you do not need to regenerate the item, key or value list (as you would with <code>dict.items()</code>) if the dictionary changes. </p>
<p>Think of the Python 2 <code>dict.items()</code> as a type of copy of the dict -- the way it was when the copy was made. </p>
<p>Think of Python 3 <code>dict.items()</code> or the Python 2 equivalent of <code>dict.viewitems()</code> as an up-to-date copy of the way the dict is now. (Same with .viewkeys(), .viewvalues() obviously.) </p>
<p>The Python <a href="https://docs.python.org/3/library/stdtypes.html?highlight=dict#dictionary-view-objects" rel="nofollow noreferrer">3.6 documents</a> have good examples of why and when you would use one. </p>
<p>Value views are not set-like, since dicts can have duplicate values. Key views are set-like, and items views are set-like for dicts with hashable values.</p>
<p>Note: With Python 3, the view replaces what Python 2 had with <code>.keys()</code> <code>.values()</code> or <code>.items()</code> Some may relying on <code>dict.keys()</code> or <code>dict.values()</code> being a static representation of a dict's previous state may have a surprise. </p>
</div>
<span class="comment-copy">Have you read this: <a href="https://stackoverflow.com/questions/8957750/what-are-python-dictionary-view-objects" title="what are python dictionary view objects">stackoverflow.com/questions/8957750/…</a></span>
<span class="comment-copy">I did read it, but as I said in my question it uses the window analogy which i can't get my head around in Python internal part.</span>
<span class="comment-copy">@vaultah I really don't think it is a duplicate since it did not described what his <i>window</i> represents which is exactly what I am asking. If you still think it is, can you explain what is this magic window ?</span>
<span class="comment-copy">The last paragraph of the top voted answer says <i>"To summarize, views are simply… views (windows) on your dictionary, which show the contents of the dictionary even after it changes"</i>. Does this not answer your question?</span>
<span class="comment-copy">@vaultah: My answer explains what the view actually does. It doesn't use the word "window" because I didn't think the word would help explain what views actually do.</span>
<span class="comment-copy">I like this answer. Just a minor linguistic quibble: "... and they translate operations on the view to corresponding operations on the dict." This suggests that you can make changes to the dict through a view which is not really true, is it?</span>
<span class="comment-copy">Don't want to get out of context, but what do you mean by <i>Dict views store a reference to their parent dict</i> ?</span>
<span class="comment-copy">@scharette: Imagine the dict view's <code>__init__</code> consisted of <code>self._secret_inaccessible_attribute = the_dict_youre_making_a_view_of</code>. It's like that, but in C.</span>
<span class="comment-copy">This is exactly the kind of answer I was looking for. Thank you !</span>
<span class="comment-copy">"Therefore you do not need to regenerate the item, key or value list if the dictionary changes" - but the standard idiom is still to make a new view every time you use one, because making a view is cheap. It's rare to see anyone bother to store one.</span>
<span class="comment-copy">@user2357112: "It's rare to see anyone bother to store one" If you look at the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=dict#dictionary-view-objects" rel="nofollow noreferrer">documentation</a> the examples show storing the views by name. Do you have an example of it being somewhat better to regenerate rather than refer to a named object?</span>
<span class="comment-copy">Most use of dict views in practice is stuff like <code>for key, val in d.items()</code> or <code>for v in d.values()</code>. I've never seen anyone bother to save a reference to the view for that.</span>
<span class="comment-copy">Grabbing a few arbitrary Github repos (Django, Scikit-learn, and CPython) and searching them for the keyword <code>items</code>, the only place I saw anyone storing a dict view was in the dict view test cases.</span>
<span class="comment-copy">If you do not name the view, however, the dynamic nature of the view is less than obvious. It would be rare for a dict to be changing at the same time you are iterating over the view with something like <code>for k, v in d.viewitems()</code>. Can you thing of an example where that would be true?</span>
