<div class="post-text" itemprop="text">
<p>Title, for example I want to make 'A3G3A' into 'AAAGGGA'.
I have this so far:</p>
<pre><code>if any(i.isdigit() for i in string):
    for i in range(0, len(string)):
        if string[i].isdigit():
             (i am lost after this)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simplistic approach:</p>
<pre><code>string = 'A3G3A'

expanded = ''

for character in string:
    if character.isdigit():
        expanded += expanded[-1] * (int(character) - 1)
    else:
        expanded += character

print(expanded)
</code></pre>
<p>OUTPUT: AAAGGGA</p>
<p>It assumes valid input.  It's limitation is that the repetition factor has to be a single digit, e.g. 2 - 9.  If we want repetition factors greater than 9, we have to do slightly more parsing of the string:</p>
<pre><code>from itertools import groupby

groups = groupby('DA10G3ABC', str.isdigit)

expanded = []

for is_numeric, characters in groups:

    if is_numeric:
        expanded.append(expanded[-1] * (int(''.join(characters)) - 1))
    else:
        expanded.extend(characters)

print(''.join(expanded))
</code></pre>
<p>OUTPUT: DAAAAAAAAAAGGGABC</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that the format is always a letter followed by an integer, with the last integer possibly missing:</p>
<pre><code>&gt;&gt;&gt; from itertools import izip_longest
&gt;&gt;&gt; s = 'A3G3A'
&gt;&gt;&gt; ''.join(c*int(i) for c, i in izip_longest(*[iter(s)]*2, fillvalue=1))
'AAAGGGA'
</code></pre>
<p>Assuming that the format can be any substring followed by an integer, with the integer possibly longer than one digit and the last integer possibly missing:</p>
<pre><code>&gt;&gt;&gt; from itertools import izip_longest
&gt;&gt;&gt; import re
&gt;&gt;&gt; s = 'AB10GY3ABC'
&gt;&gt;&gt; sp = re.split('(\d+)', s)
&gt;&gt;&gt; ''.join(c*int(i) for c, i in izip_longest(*[iter(sp)]*2, fillvalue=1))
'ABABABABABABABABABABGYGYGYABC'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A minimal pure python code which manage all cases.</p>
<pre><code>output = ''
n = ''
c = ''
for x in input + 'a':
    if x.isdigit():
        n += x
    else:
        if n == '': 
            n = '1'
        output = output + c*int(n)
        n = ''
        c = x
</code></pre>
<p>with <code>input="WA5OUH2!10"</code>,   <code>output</code> is <code>WAAAAAOUHH!!!!!!!!!!</code>.
<code>+'a'</code> is to enforce the good behaviour at the end, because output is delayed.   </p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach could be -</p>
<pre class="lang-py prettyprint-override"><code>import re
input_string = 'A3G3A'
alphabets = re.findall('[A-Z]', input_string) # List of all alphabets - ['A', 'G', 'A']
digits = re.findall('[0-9]+', input_string) # List of all numbers - ['3', '3']
final_output = "".join([alphabets[i]*int(digits[i]) for i in range(0, len(alphabets)-1)]) + alphabets[-1] 
#  This expression repeats each letter by the number next to it ( Except for the last letter ), joins the list of strings into a single string, and appends the last character
#  final_output - 'AAAGGGA'
</code></pre>
<p>Explanation - </p>
<pre><code>In [31]: alphabets # List of alphabets in the string
Out[31]: ['A', 'G', 'A']

In [32]: digits  # List of numbers in the string ( Including numbers more than one digit)
Out[32]: ['3', '3']

In [33]: list_of_strings = [alphabets[i]*int(digits[i]) for i in range(0, len(alphabets)-1)]  # List of strings after repetition

In [34]: list_of_strings
Out[34]: ['AAA', 'GGG']

In [35]: joined_string = "".join(list_of_strings) # Joined list of strings

In [36]: joined_string
Out[36]: 'AAAGGG'

In [38]: final_output = joined_string + input_string[-1] # Append last character of the string

In [39]: final_output
Out[39]: 'AAAGGGA'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>using the * to repeat the characters: </p>

assumption repeater range between [1,9]

<pre><code>q = 'A3G3A'
try:
    int(q[-1]) # check if it ends with digit
except:
    q = q+'1' # repeat only once
"".join([list(q)[i]*int(list(q)[i+1]) for i in range(0,len(q),2)])
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a> - it will generate iterators containing {A,10,G,3,ABC} ? based on true/false flip of isdigit?</span>
<span class="comment-copy">@PatrickArtner, yes but it will also include the result of <code>isdigit()</code> along with the iterators so you also know what you're looking at!  Conceptually, something like: <code>[(False, ['A']), (True, ['1', '0']), (False, ['G']), (True, ['3']), (False, ['A', 'B', 'C'])]</code></span>
<span class="comment-copy">neat, thx for explanation</span>
<span class="comment-copy">It is "better" to create an empty list where you add text and then glue it together with join, as your solution keeps creating new variables (+= with strings). I took the liberty and made edits +1.</span>
<span class="comment-copy">@AntonvBR, no, I've an alternative fix.</span>
<span class="comment-copy">Nice one, but I'd also use list [] for output, append and glue with join. And declaring variables on same row and not using row break for if statements creates lower readability in my opinion.</span>
<span class="comment-copy">input is a builtin function, you should avoid using it as a variable name</span>
