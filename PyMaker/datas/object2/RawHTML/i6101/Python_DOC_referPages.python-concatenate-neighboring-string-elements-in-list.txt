<div class="post-text" itemprop="text">
<p>Is there an elegant way (most likely using a list comprehension) to concatenate all neighboring string elements in an list?</p>
<p>I have a list where there is no functional difference between multiple strings in a row and all of those strings concatenated into a single string, but both for readability and for equivalence testing, I would like to concatenate these together. There can be other non-string elements in the list that can break up the strings. These need to remain between the concatenated groups of strings.</p>
<p>For example, I could have </p>
<pre><code>rule = ["a", "b", C(), "d", "ef", "g"]
</code></pre>
<p>and instead, I want</p>
<pre><code>rule = ["ab", C(), "defg"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> is the usual answer for combining elements based on a common characteristic. In this case, we group on the type of the element, and when the type is <code>str</code>, we collapse it, otherwise we produce results from the group directly. As a "one-liner", you could do:</p>
<pre><code>rule = ["a", "b", C(), "d", "ef", "g"]
rule = [x for cls, grp in itertools.groupby(rule, type)
          for x in ((''.join(grp),) if cls is str else grp)]
</code></pre>
<p>Assuming <code>C</code> is a class with a default <code>__repr__</code>, you'd get output that looks like this:</p>
<pre><code>['ab', &lt;__main__.C at 0x1d572c98588&gt;, 'defg']
</code></pre>
<p>In this case, the "outer" loop of the listcomp is producing the shared type and an iterator of the elements with that type. When the type is <code>str</code>, we make a one-element <code>tuple</code> of the combined string to "iterate" (it's only one element, so we only iterate once); when it's not <code>str</code>, we produce the elements of the group one by one without further processing.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can accomplish this using <code>itertools.groupby</code> and <code>chain</code>.</p>
<pre><code>from itertools import groupby, chain
isstr = lambda x: isinstance(x, basestring)
# on Python 3: lambda x: isinstance(x, str)

rule = ["a", "b", C(), "d", "ef", "g"]
list(chain.from_iterable(
    # join string groups into single-element sequence,
    # otherwise just chain the group itself
    (''.join(group), ) if group_isstr else group
    for group_isstr, group in groupby(rule, isstr)
))
</code></pre>
<pre class="lang-none prettyprint-override"><code>['ab', &lt;__main__.C object at 0x108dfdad0&gt;, 'defg']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code>:</p>
<pre><code>import itertools
class C:
   pass
rule = ["a", "b", C(), "d", "ef", "g"]
s = [(a, list(b)) for a, b in itertools.groupby(rule, type)]
new_s = [''.join(b) if all(isinstance(c, str) for c in b) else b[0] for a, b in s]
</code></pre>
<p>Output:</p>
<pre><code>['ab', &lt;__main__.C instance at 0x101419998&gt;, 'defg']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In a basic way you can use this function:</p>
<pre><code>def concat_str(lst):
    newlst = []
    newstr = ""
    length = len(lst)
    for index, elem in enumerate(lst):
        if(type(elem) is str):
            newstr = newstr + elem
            if(index == length -1):
                newlst.append(newstr)
        else:
            if(newstr):
                newlst.append(newstr)
            newlst.append(elem)
            newstr = ""
    return newlst
</code></pre>
</div>
<span class="comment-copy">I was going to add an alternative approach with <code>chain.from_iterable</code>, but <a href="https://stackoverflow.com/a/47168943/364696">Igor has that covered, so I'll just refer you to his answer</a>. Perf-wise, the listcomp is <i>probably</i> a little faster (if the inner genexpr could be expressed as a C level built-in, the <code>chain</code> approach would win by avoiding all byte code execution), but this is going to vary from version to version and between different Python interpreter lines.</span>
<span class="comment-copy">Minor fix: <code>t == str</code> should be <code>t is str</code> (or if you want to accept <code>str</code> subclasses, <code>issubclass(t, str)</code>). Classes are singletons (like <code>None</code>), so identity testing with <code>is</code>/<code>is not</code> is correct when you don't accept subclasses. Admittedly unlikely to encounter a type that violates the rule, but it's slightly more correct (and faster) to avoid invoking the rich comparison operations.</span>
<span class="comment-copy">@ShadowRanger, good call, thanks! I edited with a slightly different approach (using <code>isinstance</code> in the key function, which also has the effect of joining <code>str</code> subclasses).</span>
<span class="comment-copy">Ah. Note: On Py2, you can use <code>basestring</code> to test for both <code>str</code> and <code>unicode</code> at once (on Py3, there is only <code>str</code>). But good call on handling both on Py2 in the <code>key</code> function, where it would be weird not to collapse <code>str</code> and neighboring <code>unicode</code> instances; on Py3, using <code>type</code> as the <code>key</code> function works fine.</span>
<span class="comment-copy">Why are you not taking advantage of your <code>a</code> (the result of using <code>type</code> as the <code>key</code> function)? Checking all the group members individually with <code>all</code>/<code>isinstance</code> when you <i>know</i> they have the same type is wasteful. And a bug: Using <code>b[0]</code> as your <code>else</code> case means you're going to drop data when you have two non-<code>str</code> in a row with the same type.</span>
<span class="comment-copy">Naming quibble: Don't name a variable <code>empty_str</code> when it's not actually intended to be empty much of the time...</span>
<span class="comment-copy">Just started to coding then forgot to change. Thanks :)</span>
<span class="comment-copy">That's nicer. Though on rereading, you've got a bug here. Try it with an input with a pair of non-<code>str</code> items back-to-back in your input.</span>
<span class="comment-copy">Editted again :) thx</span>
