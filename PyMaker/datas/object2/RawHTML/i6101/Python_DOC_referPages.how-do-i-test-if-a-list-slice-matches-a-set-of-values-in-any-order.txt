<div class="post-text" itemprop="text">
<p>For example, if I have a list like [a,b,c,d], and I needed to check if the elements at index 1,2 were b or c, then it would be true. For example, in [a,b,c,d], at index 1 there's a 'b' and at index 2 there's a 'c' which returns true. However, if the elements in those indexes were not a combination of b and c then false. So there has to be a 'b' or 'c' in index 1 and 2, cannot be (b and b) or (c and c). I'm not sure how to compare this.. Any hints?</p>
<p>[a,b,c,d] is True because elements in index 1 and 2 contain a combination of b or c</p>
</div>
<div class="post-text" itemprop="text">
<p>A general solution to this is to use set membership.  So you could so:</p>
<pre><code>s = set(vals[1:3])
if s == set(["b", "c"]):
    ...
</code></pre>
<p>This will create a set from <code>vals[1]</code> and <code>vals[2]</code>, and check if that set contains exactly the elements <code>"b"</code> and <code>"c"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> for this, assuming the types you're interested in are hashable.</p>
<pre><code>from collections import Counter

def check_counts(l, compare_to):
    return Counter(l) == Counter(compare_to)

l = ['a', 'b', 'c', 'd']
print(check_counts(l[1:3], ['c', 'b']))
</code></pre>
<p>This is similar to a solution using <code>set</code>, but allows for cases where you care about the number of a certain element</p>
</div>
<div class="post-text" itemprop="text">
<p>Given a list of items and a slice to match:</p>
<pre><code>items = ['a', 'b', 'c', 'd']
match = ['b', 'c']
</code></pre>
<p>all you need is:</p>
<pre><code>matches = items[1:3] in (match, match[::-1])
</code></pre>
<p>Note: <code>match[::-1]</code> returns a reversed version of <code>match</code>.</p>
<p>Alternative set-based version:</p>
<pre><code>match = set(('b', 'c'))

# Version 1
matches = match.intersection(items[1:3]) == match

# Version 2
matches = not match.difference(items[1:3])
</code></pre>
</div>
<span class="comment-copy"><code>['True' for e in l if l[1]=='b' and l[2]=='c']</code></span>
<span class="comment-copy">What have you tried so far?  Please post your code</span>
<span class="comment-copy">Can you please correct your formatting and add code ?</span>
<span class="comment-copy">@sharatpc but it has to be interchangable. l[1] can be c while l[2] is b</span>
<span class="comment-copy"><code>lookup = ['b','c'] ['True' for e in l if l[1] in lookup and l[2] in lookup]</code></span>
<span class="comment-copy">Great minds think alike haha. I am aware of this method, but is there another way that doesn't use sets?</span>
<span class="comment-copy">The other way to so it would be to create a list slice, sort it, and compare it to a sorted reference list.  It's slower for large lists, but it will work.</span>
<span class="comment-copy">Could you clarify? What do you mean by comparing a sorted reference list?</span>
<span class="comment-copy"><code>if sorted_list == ["b", "c"]</code>, where <code>["b", "c"]</code> is the sorted reference list.  You just need to guarantee it's sorted so you can compare for equality.  But why would you prefer this over using sets?  With sets, you have an O(n) solution.  With sorting, that increases to O(n*log(n)).</span>
