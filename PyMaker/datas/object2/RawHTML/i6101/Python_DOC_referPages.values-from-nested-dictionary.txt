<div class="post-text" itemprop="text">
<p><strong>UPDATE</strong>:  How to access values in a nested dictionary, where one need two keys, the first to find the inner dict, the second to find the value at that key2.</p>
<p>How does python access values from a nested dictionary, with two keys?  Or must I restructure the dictionary / create separate dictionaries?</p>
<p>For example, I want to access</p>
<ul>
<li>values for <code>['d5']['raw_file']</code></li>
<li>values for  <code>['append_dir_to_filename']</code> for all "fist keys" such as <code>g7, d5, a9</code></li>
</ul>
<p>List item</p>
<pre><code>config = {
    'g7': {},
    'd5': {},
    'a9': {},
}    
config['g7']['append_dir_to_filename'] = 1,
config['g7']['raw_file'] = ('cr2', 'jpg', 'mp4'),

config['d5']['append_dir_to_filename'] = 1,
config['d5']['raw_file'] = ('nef', 'jpg', 'avi'),

config['a9']['append_dir_to_filename'] = 1,
config['a9']['raw_file'] = ('mp4', 'jpg', 'avi')
</code></pre>
<p>In respect of structuring nested dictionaries, this would be the complexity per one (1) camera. There are 10 camera types in total and the goal is to rename, sort, extract info, etc. from mediafiles from these cameras in one bulk swipe:</p>
<pre><code>config['d5']['append_dir_to_filename'] = 1
config['d5']['device_name'] = 'Nikon-D5'
config['d5']['raw_file'] = ('nef', 'jpg', 'avi')
config['d5']['sup_file'] = ('jpg', 'wav')
config['d5']['to_else_file'] = ('avi')
config['d5']['timestamp'] = ('lwt')
config['d5']['md5'] = 1
config['d5']['code1'] = 'FAR'
config['d5']['gps'] = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have <em>nested</em> dictionaries. Your outer dictionary keys all refer to another dictionary, which then has keys too. Python lets you chain the expressions there.</p>
<p>So to access a specific inner value, you first access the outer dictionary:</p>
<pre><code>config['d5']
</code></pre>
<p>This produces another dictionary object, and you just apply another <code>[...]</code> key access expression to that result:</p>
<pre><code>config['d5']['raw_file']
</code></pre>
<p>If you need to access the same key on all nested dictionaries, you need to loop:</p>
<pre><code>for nested in config.values():
    print(nested['append_dir_to_filename'])
</code></pre>
<p>Here <code>nested</code> is a reference to each of the nested dictionaries in the <code>config</code> dictionary.</p>
<p>A more complex example could be printing out all outer keys for which a condition on the values in the inner dictionary holds true. Like printing all keys for which <code>'append_dir_to_filename'</code> is <code>1</code>:</p>
<pre><code>for name, nested in config.items():
    if nested['append_dir_to_filename'] == 1:
        print(name)
</code></pre>
<p><code>dict.items()</code> lets you iterate over all (key, nested dictionary) pairs, then simply treat that nested value as another dictionary object again to test the values.</p>
<p>If all you are trying to do is track information on a <em>homogenous set of properties</em> (all the same values for multiple entries), consider using a custom class (where you can add methods) or a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple()</code> generated class</a> to track those fields:</p>
<pre><code>from collections import namedtuple

ConfigEntry = namedtuple('ConfigEntry', 'append_dir_to_filename raw_file')

config = {
    'g7': ConfigEntry(1, ('cr2', 'jpg', 'mp4')),
    'd5': ConfigEntry(1, ('nef', 'jpg', 'avi')),
    'a9': ConfigEntry(1, ('mp4', 'jpg', 'avi')),
}    

# printing a specific value
print(config['d5'].raw_file)

# printing the same value for each entry
for entry in config.values():
    print(entry.append_dir_to_filename)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You access the values the same way you assigned them:</p>
<pre><code>print(config['g7']['append_dir_to_filename'])
print(config['d5']['append_dir_to_filename'])
print(config['a9']['raw_file'])
...
</code></pre>
<p>To access the values residing inside a nested dictionary, you need two keys: the first <code>key1</code> to find the inner dict, and the second to find the value at <code>key2</code>.</p>
<p>To access the values for the key <code>['append_dir_to_filename']</code> for all "fist keys" such as <code>g7</code>, <code>d5</code>, <code>a9</code>, you must iterate over <code>config</code>, which gets you <code>key1</code>, and read the values at the desired location:</p>
<pre><code>for key1 in config:
    print(config[key1]['append_dir_to_filename'])
</code></pre>
<h3>Edit:</h3>
<p>(thanks to Suggestions from @MartijnPieters in the comments)
if all you are going to do is look at the values, it is preferable to loop over dict.values() instead and save the repeated config[key1]:</p>
<pre><code>for inner in config.values():
    print(inner['append_dir_to_filename'])
</code></pre>
</div>
<span class="comment-copy"><i>Values with double keys</i> is wrong because there is no such thing in python. I assume that you mean key <b>value</b> as dictionary.</span>
<span class="comment-copy">I think what the OP means, is how to access values in a nested dictionary, where you need two keys, the first to find the inner dict, the second to find the value at that key2</span>
<span class="comment-copy">That's what he meant, yes, the auhor should familiarise himself with some basic concepts</span>
<span class="comment-copy">Thank you for the clarification. I am wondering if the dictionary structure is valid at all or I need to re-organize?</span>
<span class="comment-copy">@HakariDo: using a structured object like a namedtuple will make it much easier to detect when you forgot to enter a field; dictionaries are arbitrary structures and a typo in the key name would be easy to miss.</span>
<span class="comment-copy">Thank you, very useful stuff!  Re "homogenous set of properties", pls see the bottom of OP, those are the keys and values I need to work with.</span>
<span class="comment-copy">@HakariDo: just expand the second argument of <code>namedtuple()</code>, that defines the fields of the resulting class (and order). Note that <code>('stringvalue')</code> results in just <code>'stringvalue'</code>, that's not a one-value tuple. If <code>to_else_file</code> and <code>lwt</code> are meant to be tuples, you'll need a comma: <code>('stringvalue',)</code>; the parentheses are just there to help group.</span>
<span class="comment-copy">Great suggestion @martijnPieters to use namedtuples, or a class to track the fields of data, &amp; tks for the assist.</span>
<span class="comment-copy">Thank you. Re my 2nd question in OP (getting  "values for  <code>['append_dir_to_filename']</code> for all "fist keys" such as <code>g7, d5, a9</code>"): How would you call <code>append_dir_to_filename</code> for <b>all</b> keys? For example, when wanting to append directory name to image filename for only a subset of  cameras, based on the <code>0</code> or <code>1</code> value in the <code>append_dir_to_filename</code>?</span>
<span class="comment-copy">I think I was replying to this second part while you were posting your comment. Pls let me know if it is clear.</span>
<span class="comment-copy">You do not need to use <code>dict.keys()</code> when looping. <code>for key1 in config</code> gives you exactly the same result without having to make an extra method call and object creation.</span>
<span class="comment-copy">However, if all you are going to do is look at the <i>values</i>, why loop over the keys at all? Just loop over <code>dict.values()</code> instead and save yourself the repeated <code>config[key1]</code> lookup.</span>
<span class="comment-copy">@reblochon-masque: Thank you! Very clear and to the point. You rule!</span>
