<div class="post-text" itemprop="text">
<p>Mapping a bytes type with the following lambda</p>
<pre><code>unpack = lambda val: struct.unpack("!b", val)[0]

list(map(unpack, b'\xb1\xbb\n\x0f'))
</code></pre>
<p>gives the error</p>
<pre><code>TypeError: a bytes-like object is required, not 'int'
</code></pre>
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview" rel="nofollow noreferrer">documentation</a> says</p>
<blockquote>
<p>Since bytes objects are sequences of integers (akin to a tuple), for a bytes object b, b[0] will be an integer, while b[0:1] will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1)</p>
</blockquote>
<p>which explains why an int is passed. So if i would manually loop over the bytes object, i could access the elements with <code>[x:x+1]</code> instead of with <code>[x]</code>.</p>
<p>My question now would be if there is a way to make map produce bytes object of length 1, so that the unpack function gets what it expects.</p>
<p>I found that this works</p>
<pre><code>unpack = lambda val: struct.unpack("!b", bytes(bytearray([val])))[0]
</code></pre>
<p>but it seems like an ugly workaround to me. Is there a better, more concise way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>A more concise way doesn't exist yet from what I'm aware. <a href="https://www.python.org/dev/peps/pep-0467/#abstract" rel="nofollow noreferrer">A proposition</a> has been made but it's still a draft.</p>
<p>You still have some other options in order to make it appear more friendly, though. For example, a little generator that produces bytes:</p>
<pre><code>def iterbytes(b):
    for n in range(len(b)):
        yield b[n:n+1]   
</code></pre>
<p>or, similarly but probably slower:</p>
<pre><code>def iterbytes(b):
    for i in b:
        yield bytes([i])
</code></pre>
<p>Then wrap the bytes object in this <code>iterbytes</code> generator:</p>
<pre><code>list(map(unpack, iterbytes(b'\xb1\xbb\n\x0f')))
</code></pre>
<hr/>
<p>Since you wrap <code>map</code> in <code>list</code>, i.e you're after a list, I'd probably go with a comprehension instead of a <code>map</code>:</p>
<pre><code>&gt;&gt;&gt; b = b'\xb1\xbb\n\x0f' 
&gt;&gt;&gt; [unpack(b[i:i+1]) for i in range(len(b))]
[-79, -69, 10, 15]
</code></pre>
</div>
