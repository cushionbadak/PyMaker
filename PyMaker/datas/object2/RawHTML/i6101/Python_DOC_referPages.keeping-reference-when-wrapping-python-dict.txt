<div class="post-text" itemprop="text">
<p>I'd like to write a dict subclass in python3, that wraps some of the dict methods and returns instances of the same class instead of dict on <code>__getitem__</code>, if requested value happens to be a dict. Otherwise, I'd like to have behavior that is exactly identical to that of the dict. This is what I've came up with:</p>
<pre><code>class WrappedDict(dict):
    def __init__(self, stuff, *args, **kwargs):
        super(WrappedDict, self).__init__(*args, **kwargs)
        self.stuff = stuff

    def update_stuff(self):
        pass  # Do things with stuff

    def update(self, *args, **kwargs):
        self.update_stuff(*args, **kwargs)
        super(WrappedDict, self).update(*args, **kwargs)

    def __getitem__(self, item):
        obj = super(WrappedDict, self).__getitem__(item)
        if isinstance(obj, dict):
            return WrappedDict(self.stuff + str(item), obj)
        else:
            return obj
</code></pre>
<p>This however, is not identical to dict in that it doesn't return a reference to a dict value, but a new object created from that dict. To illustrate what I mean:</p>
<pre><code>d1 = {'a': 1, 'b': 2, 'c': {'d': 4}}
d1.update(a=10)
d2 = d1['c']
d2.update(d=40)
print(d1)
</code></pre>
<p>would give:</p>
<pre><code>{'a': 10, 'b': 2, 'c': {'d': 40}}
</code></pre>
<p>but doing the same with <code>WrappedDict</code>:</p>
<pre><code>wd1 = WrappedDict("stuff", {'a': 1, 'b': 2, 'c': {'d': 4}})
wd1.update(a=10)
wd2 = wd1['c']
wd2.update(d=40)
print(wd1)
</code></pre>
<p>gives:</p>
<pre><code>{'a': 10, 'b': 2, 'c': {'d': 4}}
</code></pre>
<p>Note 4 in the inner dict instead of expected 40. Is there a way to replicate former behavior without too much of black magic?</p>
</div>
<div class="post-text" itemprop="text">
<p>Set your newly created <code>WrappedDict</code> back to your object with <code>__setitem__</code>:</p>
<pre><code>def __getitem__(self, item):
    obj = super(WrappedDict, self).__getitem__(item)
    if isinstance(obj, dict):
        wrapped = WrappedDict(self.stuff + str(item), obj)
        super(WrappedDict, self).__setitem__(item, wrapped)
        return wrapped
    else:
        return obj
</code></pre>
<p>Full code:</p>
<pre><code>class WrappedDict(dict):
    def __init__(self, stuff, *args, **kwargs):
        super(WrappedDict, self).__init__(*args, **kwargs)
        self.stuff = stuff

    def update_stuff(self, *args, **kwargs):
        pass  # Do things with stuff

    def update(self, *args, **kwargs):
        self.update_stuff(*args, **kwargs)
        super(WrappedDict, self).update(*args, **kwargs)

    def __getitem__(self, item):
        obj = super(WrappedDict, self).__getitem__(item)
        if isinstance(obj, dict):
            wrapped = WrappedDict(self.stuff + str(item), obj)
            super(WrappedDict, self).__setitem__(item, wrapped)
            return wrapped
        else:
            return obj

d1 = {'a': 1, 'b': 2, 'c': {'d': 4}}
d1.update(a=10)
d2 = d1['c']
d2.update(d=40)
print(d1)

wd1 = WrappedDict("stuff", {'a': 1, 'b': 2, 'c': {'d': 4}})
wd1.update(a=10)
wd2 = wd1['c']
wd2.update(d=40)
print(wd1)
</code></pre>
<p>Output:</p>
<pre><code>{'a': 10, 'b': 2, 'c': {'d': 40}}
{'a': 10, 'b': 2, 'c': {'d': 40}}
</code></pre>
</div>
<span class="comment-copy">FWIW, sub-classing the built-in types can be a little painful. You may find it easier to work with the Abstract Base Classes, eg <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="nofollow noreferrer">Mapping</a></span>
<span class="comment-copy">Unfortunately, isinstance(wrapped_instance, dict) must be True, so that won't work for me. But thank you for your input anyway.</span>
<span class="comment-copy">Yep, that works perfectly. Thank you.</span>
<span class="comment-copy">Great that it helped. BTW, you can <a href="http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work">accept</a> an answer if it solves your problem.</span>
<span class="comment-copy">Accepted. Thanks for the hint. :)</span>
