<div class="post-text" itemprop="text">
<p>I am trying to load a pickled dictionary but keep getting attribute error such as this </p>
<pre><code>TypeError: a bytes-like object is required, not '_io.BufferedReader'
</code></pre>
<p>Below is the code to read and write pickle object. I am dumping pickled object on a linux workstation with python 2.7.12. The data is transferred to Mac with python 3.6.4, where readTrueData() is executed resulting in the above error. </p>
<pre><code>def readTrueData(name):
    fName = str('trueData/'+name+'.pkl')
    f = open(fName,'rb')
    #    print(f)
    #    print(type(f))
    pC = pickle.loads(f)
    return pC

def storeTrueData(atomicConfigs, name):
    import quippy
    storeDic = {}
    #rangeKeys = len(atomicConfigs)
    #print(rangeKeys)
    qTrain = quippy.AtomsList(atomicConfigs)
    print(len(qTrain))
    rangeKeys = len(qTrain)
    print(rangeKeys)
    for i in range(rangeKeys):
        #configConsidered = atomicConfigs[i]
        trueForce = np.array(qTrain[i].force).T
        storeDic[i] = trueForce
    f = open("trueData/"+ name + ".pkl", "wb")
    pickle.dump(storeDic, f)
    f.close()    
    return None
</code></pre>
<h1>UPDATE</h1>
<p>Working on the suggestions mentioned in the comments, I changed my code as below
a.)<code>pC = pickle.load(f)</code>
b.) <code>pC = pickle.loads(f.read())</code>
In both the case I got the following error</p>
<pre><code>UnicodeDecodeError: 'ascii' codec can't decode byte 0x87 in position 1: ordinal not in range(128)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your first problem is caused by a mismatch between the argument type and the chosen <code>load*</code> method; <code>loads</code> expects <code>bytes</code> objects, <code>load</code> expects the file object itself. Passing the file object to <code>loads</code> is what caused your error.</p>
<p>Your other problem is due to the cross-version compatibility issue with <code>numpy</code> and <code>datetime</code> types; Python 2 pickles <code>str</code>s with no specified encoding, but Python 3 must unpickle them with a known encoding (or <code>'bytes'</code>, to get raw <code>bytes</code> rather than <code>str</code>). For <code>numpy</code> and <code>datetime</code> types, <a href="https://docs.python.org/3/library/pickle.html#pickle.load" rel="nofollow noreferrer">you're required to pass <code>encoding='latin-1'</code></a>:</p>
<blockquote>
<p>Optional keyword arguments are fix_imports, encoding and errors, which are used to control compatibility support for pickle stream generated by Python 2. If fix_imports is true, pickle will try to map the old Python 2 names to the new names used in Python 3. The encoding and errors tell pickle how to decode 8-bit string instances pickled by Python 2; these default to ‘ASCII’ and ‘strict’, respectively. The encoding can be ‘bytes’ to read these 8-bit string instances as bytes objects. Using encoding='latin1' is required for unpickling NumPy arrays and instances of datetime, date and time pickled by Python 2.</p>
</blockquote>
<p>In any event, the fix is to change:</p>
<pre><code>def readTrueData(name):
    fName = str('trueData/'+name+'.pkl')
    f = open(fName,'rb')
    #    print(f)
    #    print(type(f))
    pC = pickle.loads(f)
    return pC
</code></pre>
<p>to:</p>
<pre><code>def readTrueData(name):
    fName = str('trueData/'+name+'.pkl')
    with open(fName, 'rb') as f:  # with statement avoids file leak
        # Match load with file object, and provide encoding for Py2 str
        return pickle.load(f, encoding='latin-1')
</code></pre>
<p>For correctness and performance reasons, I'd also recommend changing <code>pickle.dump(storeDic, f)</code> to <code>pickle.dump(storeDic, f, protocol=2)</code> on the Python 2 machine, so the stream is generated with a more modern pickle protocol, one which can efficiently pickle <code>numpy</code> arrays among other things. Protocol 0, the Python 2 default, can't use the top bit of each byte (it's ASCII compatible), which means raw binary data bloats dramatically in protocol 0, requiring a ton of bit twiddling, where protocol 2 can dump it raw. Protocol 2 is also the only Py2 protocol that efficiently pickles new style classes, and the only one that can properly pickle certain types of instances (stuff using <code>__slots__</code>/<code>__new__</code> and the like) at all.</p>
<p>I'd also recommend the script begin with:</p>
<pre><code>try:
    import cPickle as pickle
except ImportError:
    import pickle
</code></pre>
<p>as on Python 2, <code>pickle</code> is implemented in pure Python, and is both slow and unable to use some of the more efficient pickle codes. On Python 3, <code>cPickle</code> is gone, but <code>pickle</code> is automatically accelerated. Between that and using protocol 2, pickling on the Python 2 machine should run <em>much</em> faster, and produce <em>much</em> smaller pickles.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>pC = pickle.loads(f.read())</code> is what you're looking for, but you should really be using the <a href="https://docs.python.org/3/reference/compound_stmts.html#with" rel="nofollow noreferrer"><code>with</code> context</a>:</p>
<pre><code>with open(fName, 'rb') as f: 
    pC = pickle.loads(f.read())
</code></pre>
<p>This would ensure your file is closed properly, especially because your code doesn't have a <code>f.close()</code> in the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to be using <code>pickle.load(...)</code> to read if using <code>open</code> in that manner.</p>
<p>Source: <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">https://docs.python.org/3/library/pickle.html</a></p>
</div>
<span class="comment-copy">chaged my code as per your suggestion. got the following error UnicodeDecodeError: 'ascii' codec can't decode byte 0x87 in position 1: ordinal not in range(128)</span>
<span class="comment-copy">More efficiently, just do <code>pC = pickle.load(f)</code>, which avoids a large temporary buffer (<code>loads</code> is implemented by shoving the argument into <code>io.BytesIO</code> and then using <code>load</code> anyway, so using <code>load</code> directly reduces memory and CPU requirements).</span>
<span class="comment-copy">@user1443613: Are you <i>sure</i> you matched their code? That error looks like what you'd get from opening a binary file for read in text mode (<code>'r'</code>/<code>'rt'</code>) when pickle files should always be opened in binary mode (<code>'rb'</code>). The alternative is that you are unpickling data from Python 2, and you need to pass the <code>encoding</code> argument to <code>load</code>/<code>loads</code> to specify what the assumed encoding of Python 2 <code>str</code>s should be (if you have no idea, <code>latin-1</code> is a decent default, and, per the docs, necessary for unpickling <code>numpy</code> and <code>datetime</code> types pickled on Python 2).</span>
<span class="comment-copy">Thanks... it was encoding causing the problems. Inputting encoding = 'latin-1' solved it</span>
<span class="comment-copy">It's not about matching <code>load</code> with <code>dump</code> and <code>loads</code> with <code>dumps</code>. It's about matching <code>load</code>/<code>dump</code> with open files, and <code>loads/</code>dumps` with in-memory use of <code>bytes</code> objects.</span>
<span class="comment-copy">changed the code to pickle.load(f). Got the following error  UnicodeDecodeError: 'ascii' codec can't decode byte 0x87 in position 1: ordinal not in range(128)</span>
