<div class="post-text" itemprop="text">
<p>Working on replacing my implementation of a server query tool that uses <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor" rel="noreferrer"><code>ThreadPoolExecutors</code></a> with all asynchronous calls using <code>asyncio</code> and <code>aiohttp</code>. Most of the transition is straight forward since network calls are non-blocking IO, it's the saving of the responses that has me in a conundrum.</p>
<p>All the examples I am using, even the docs for both libraries, use <code>asyncio.gather()</code> which collects all the awaitable results. In my case, these results can be files in the many GB range, and I don't want to store them in memory. </p>
<p>Whats an appropriate way to solve this? Is it to use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed" rel="noreferrer"><code>asyncio.as_completed()</code></a> and then:</p>
<pre><code>for f in as_completed(aws):
    earliest_result = await f
    # Assumes `loop` defined under `if __name__` block outside coroutine
    loop = get_event_loop()
    # Run the blocking IO in an exectuor and write to file
    _ = await loop.run_in_executor(None, save_result, earliest_result)
</code></pre>
<p>Doesn't this introduce a thread (assuming I use a <code>ThreadPoolExecutor</code> by default) thus making this an asynchronous, multi-threaded program vice an asynchronous, single-threaded program?</p>
<p>Futher, does this ensure only 1 <code>earliest_result</code> is being written to file at any time? I dont want the call to <code>await loop.run_in_executor(...)</code> to be running, then another result comes in and I try to run to the same file; I could limit with a semaphor I suppose.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>In my case, these results can be files in the many GB range, and I don't want to store them in memory. </p>
</blockquote>
<p>If I'm correct and in your code single <code>aws</code> means a downloading of a single file, you may face a following problem: while <code>as_completed</code> allows to swap data from RAM to HDD asap, all your <code>aws</code> running parallely storing each their data (buffer with partly downloaded file) in RAM simultaneously.</p>
<p>To avoid this you'll need to use semaphore to ensure not to much files are downloading parallely in the first place thus to prevent RAM overuse.</p>
<p>Here's example of using <a href="https://stackoverflow.com/a/48486557/1113207">semaphore</a>.</p>
<blockquote>
<p>Doesn't this introduce a thread (assuming I use a ThreadPoolExecutor
  by default) thus making this an asynchronous, multi-threaded program
  vice an asynchronous, single-threaded program?</p>
</blockquote>
<p>I'm not sure, I understand your question, but yes, your code will use threads, but only <code>save_result</code> will be executed inside those threads. All other code still runs in single main thread. Nothing bad here.</p>
<blockquote>
<p>Futher, does this ensure only 1 earliest_result is being written to
  file at any time?</p>
</blockquote>
<p>Yes, it is[*]. To be precisely keyword <code>await</code> at last line of your snippet will ensure it:</p>
<pre><code>_ = await loop.run_in_executor(None, save_result, earliest_result)
</code></pre>
<p>You can read it as: "Start executing <code>run_in_executor</code> asynchronously and suspend execution flow at this line until <code>run_in_executor</code> is done and returned result".</p>
<hr/>
<p>[*] Yes, if you don't run multiple for <code>f in as_completed(aws)</code> loops parallely in the first place.</p>
</div>
