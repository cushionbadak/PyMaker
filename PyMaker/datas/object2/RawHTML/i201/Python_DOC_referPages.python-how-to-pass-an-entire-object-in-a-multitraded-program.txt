<div class="post-text" itemprop="text">
<p>I'm started a concurrent program using Python. I have a simple question:
I'm using the class Thread to create several concurrent processes.
I would like these threads to pass objects to each other (so I would like that a thread not only notice a certain event, but takes an object from this event (when it happens)!).
How can I do this? Thanks a lot!</p>
<p>Example of code:</p>
<pre><code>class Process(Thread):
def __init__(self):
    super(Processo, self).__init__()

def run(self):
    myObject = SomeObject(param1, param2, param3)
    # Code to pass myObject to all the threads

    # Code waiting for the object to use it

def main():
   process1 = Process()
   process2 = Process()
   process3 = Process()

   process1.start()
   process2.start()
   process3.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>queue.Queue</code> to communicate between threads. There is simple example of two threads. One thread puts items on the one side of the <code>queue</code> and the other take them. The <code>queue</code> can be also used for multi-producer multi-consumer application (but before implementing plan how it should work).</p>
<pre><code>from queue import Queue
from random import randint
import threading 
import time

class Producer(threading.Thread):
    def __init__(self, queue):
        super(Producer, self).__init__()
        self.queue = queue

    def run(self):
        while True:
            thread_name = self.name

            if not self.queue.full():
                print('Will send "{}"'.format(thread_name))
                self.queue.put(thread_name)

            time.sleep(randint(1, 3))

class Consumer(threading.Thread):
    def __init__(self, queue):
        super(Consumer, self).__init__()
        self.queue = queue

    def run(self):
        while True:
            if not self.queue.empty():
                received = self.queue.get()
                print('Received "{}"'.format(received))

            time.sleep(randint(1, 3))

if __name__ == '__main__':
    q = Queue()

    a = Producer(queue=q)
    b = Consumer(queue=q)

    a.start()
    b.start()

    a.join()
    b.join()
</code></pre>
<p>The <code>sleeps</code> are only to slow it down for demonstration. There is documentation for <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">Queue</a></p>
<p><em>Note: Thread is not the same as a Process. Be careful with terminology you can be miss-understood.</em></p>
</div>
<span class="comment-copy">Please provide some code and then I might be able to help you with this.</span>
<span class="comment-copy">Code added to the answer....</span>
<span class="comment-copy">Add <code>global myObject</code> and all your <code>Thread</code>'s can access this object. You have to use <a href="https://docs.python.org/3/library/threading.html#lock-objects" rel="nofollow noreferrer">lock-objects</a> if concurent <code>read/write</code> could be the case. BTW, a <code>Thread</code> <b>is not</b> a <code>Process</code>,  read <a href="https://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python">Multiprocessing vs Threading Python</a></span>
<span class="comment-copy">Use <code>queue.Queue</code> <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">Queue docs</a></span>
