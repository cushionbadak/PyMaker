<div class="post-text" itemprop="text">
<p>I found some <code>del</code> behavior I don't understand and hope you can give me some insight. I'm trying to implement OpenGL's hello_triangle using PyOpenGL and glfw. After closing the OpenGL window my program is supposed to clean up, but <code>glDeleteBuffers</code> raises a TypeError, BUT ONLY if it is called inside a <code>__del__</code> function:</p>
<pre><code>class Scene:
    def __init__ (self):
        # ...
        self.buffer = glGenBuffers(1)
        # ...
    def __del__ (self):
        # ...
        glDeleteBuffers(1, [self.buffer]) # TypeError: ('No array-type handler for type builtins.type (value: [1]) registered', &lt;OpenGL.converters.CallFuncPyConverter object at ...&gt;)
        # ...

# ...
scene = Scene()
while not glfwWindowShouldClose(window):
    scene.render()
    glfwSwapBuffers(window)
    glfwPollEvents()

del scene
</code></pre>
<p>If instead I implement it like this</p>
<pre><code>class Scene:
    def __init__ (self):
        # ...
        self.buffer = glGenBuffers(1)
        # ...
    def delete (self): # Renamed __del__ to delete
        # ...
        glDeleteBuffers(1, [self.buffer]) # No error
        # ...

# ...
scene = Scene()
while not glfwWindowShouldClose(window):
    scene.render()
    glfwSwapBuffers(window)
    glfwPollEvents()

scene.delete() # Swapped del scene for scene.delete()
</code></pre>
<p><code>glDeleteBuffers</code> suddenly works and throws no errors. <strong>Why is this?</strong> In case you wanna try it yourself, here's the full code:</p>
<pre><code>import ctypes
import sys

# OpenGL + GLFW
import glfw
from glfw.GLFW import *
from OpenGL.GL import *


glfw.ERROR_REPORTING = False # Catch errors by return values

class obj: pass # Object to assign arbitrary properties to



def main (args):
    # Initialize GLFW + create window
    if glfwInit() == GL_TRUE:
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4)
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5)
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)

        window = glfwCreateWindow(800, 600, "Title", None, None)
        if window:
            glfwMakeContextCurrent(window)

            window_size_callback(window, 800, 600)
            glfwSetWindowSizeCallback(window, window_size_callback)

            # Render stuff
            scene = Scene()

            while not glfwWindowShouldClose(window):
                scene.render()
                glfwSwapBuffers(window)

                glfwPollEvents()

            # Clean up
            del scene # TypeError
            # scene.delete() # no TypeError

        else:
            print("Failed to create GLFW window!")

        glfwTerminate()
    else:
        print("Failed to initialize GLFW!")



def window_size_callback (window, width, height):
    glViewport(0, 0, width, height)



class Scene:
    _instances = []

    class vertex (ctypes.Structure):
        _fields_ = [
            ("x", GLfloat),
            ("y", GLfloat)
        ]

    def __static_init__ ():
        # Create rendering pipeline program
        vertex_shader = glCreateShader(GL_VERTEX_SHADER)
        glShaderSource(vertex_shader, """#version 450 core
        in vec4 pos;

        void main () {
            gl_Position = vec4(pos.xy, 0.0, 1.0);
        }""")
        glCompileShader(vertex_shader)

        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER)
        glShaderSource(fragment_shader, """#version 450 core
        out vec4 frag_color;

        void main () {
            frag_color = vec4(1.0, 1.0, 1.0, 1.0);
        }""")
        glCompileShader(fragment_shader)

        Scene._program = glCreateProgram()
        glAttachShader(Scene._program, vertex_shader)
        glAttachShader(Scene._program, fragment_shader)
        glLinkProgram(Scene._program)

        glDeleteShader(vertex_shader)
        glDeleteShader(fragment_shader)

        # Create VAO
        Scene._vertex_array = glGenVertexArrays(1)
        glBindVertexArray(Scene._vertex_array)

        Scene._attrib_pos = glGetAttribLocation(Scene._program, "pos")
        glVertexAttribFormat(Scene._attrib_pos, 2, GL_FLOAT, GL_FALSE, 0)
        glEnableVertexAttribArray(Scene._attrib_pos)
        glVertexAttribBinding(Scene._attrib_pos, Scene._attrib_pos)

    def __static_del__ ():
        glDeleteVertexArrays(1, [Scene._vertex_array]) # Alsa raises a TypeError, if glDeleteBuffers' error is catched before
        glDeleteProgram(Scene._program)

    def __init__ (self):
        if len(Scene._instances) == 0:
            Scene.__static_init__()

        Scene._instances.append(self)

        # Create VBO
        vertex_buffer_data = (Scene.vertex * 3)(
            Scene.vertex(-0.5, 0.5),
            Scene.vertex(0.5, 0.5),
            Scene.vertex(0.5, -0.5)
        )

        self._vertex_buffer = obj()
        self._vertex_buffer.buffer = glGenBuffers(1)
        self._vertex_buffer.length = len(vertex_buffer_data)
        self._vertex_buffer.offset = Scene.vertex.x.offset
        self._vertex_buffer.stride = ctypes.sizeof(Scene.vertex)

        glBindBuffer(GL_ARRAY_BUFFER, self._vertex_buffer.buffer)
        glBufferData(GL_ARRAY_BUFFER, vertex_buffer_data, GL_STATIC_DRAW)

    def __del__ (self): # Rename to delete
        glDeleteBuffers(1, [self._vertex_buffer.buffer]) # TypeError, if executed in __del__(), but not when executeed in delete()

        Scene._instances.remove(self)
        if len(Scene._instances) == 0:
            Scene.__static_del__()

    def render (self):
        glClearColor(0.0, 0.1, 0.2, 1.0)
        glClear(GL_COLOR_BUFFER_BIT)

        # Draw
        glUseProgram(Scene._program)
        glBindVertexArray(Scene._vertex_array)

        glBindVertexBuffer(Scene._attrib_pos, self._vertex_buffer.buffer, self._vertex_buffer.offset, self._vertex_buffer.stride)

        glDrawArrays(GL_TRIANGLES, 0, self._vertex_buffer.length)



if __name__ == "__main__":
    main(sys.argv[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><code>glDeleteBuffers</code> raises a TypeError, BUT ONLY if it is called inside a <code>__del__</code> function:</p>
</blockquote>
<p>The error is caused, because the OpenGL context is destroyed, before the destructor is called.<br/>
As for any other OpenGL instruction, for <code>glDeleteBuffers</code> a valid and current OpenGL context is needed.</p>
<p>If </p>
<blockquote>
<pre><code>scene.delete()
</code></pre>
</blockquote>
<p>is called, then <code>delete()</code> and by that <code>glDeleteBuffers</code> is called immediately. At this point the OpenGL context is current and the Operation will succeed in any case. </p>
<p>But when you do</p>
<blockquote>
<pre><code>del scene
</code></pre>
</blockquote>
<p>then there is not guarantee that the destructor is called immediately.</p>
<p>See <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">Python- 3.3.1. Data model - Basic customization</a></p>
<blockquote>
<p>Note <code>del</code> x doesn’t directly call <code>x.__del__()</code> — the former decrements the reference count for x by one, and the latter is only called when x’s reference count reaches zero.</p>
</blockquote>
<p>When the destructor is called depends on the garbage collection. Python doesn't give any guarantee, about when the destructor is called it happens after all references have been deleted, so it might not necessary happen right after.</p>
<p>This causes that the destructoris called, after the OpenGL contest was destroyed (after <code>glfwTerminate()</code>) and the operation fails.</p>
<p>A safe method would be to call the destructor directly:</p>
<p>e.g.</p>
<pre class="lang-py prettyprint-override"><code>Scene.__del__(scene)
</code></pre>
</div>
<span class="comment-copy">Now that you told me this, it's blindingly obvious and I don't know why I didn't see this... I already suspected something being deleted/deinitialized before my destructor is called, but I thought it must be one of the functions prior to <code>del scene</code> (e.g. <code>glfwShouldWindowClose</code>). Thanks for your great answer :)</span>
<span class="comment-copy">@Cubinator73 You're welcome.</span>
