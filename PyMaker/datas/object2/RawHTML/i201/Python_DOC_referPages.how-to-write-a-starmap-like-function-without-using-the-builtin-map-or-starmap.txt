<div class="post-text" itemprop="text">
<p>This is the task:</p>
<blockquote>
<p>Make a function <code>my_map_k</code> that as arguments takes a function f and k
  lists L<sub>1</sub>,...,L<sub>k</sub>, for an arbitrary k ≥ 1, and returns the list
  [f(L<sub>1</sub>[0],...,L<sub>k</sub>[0]),...,f(L<sub>1</sub>[n-1],...,L<sub>k</sub>[n-1])], where n is the length
  of the shortest L<sub>i</sub> list.</p>
<p>Hint. Use Python's <code>*</code> notation to handle an arbitrary number of lists as arguments. </p>
<p>Example:  </p>
<pre><code>my_map_k(lambda x, y, z: x*y*z, [3, 2, 5], [2, 7, 9], [1, 2])
</code></pre>
<p>should return <code>[6, 28]</code>.</p>
</blockquote>
<p>This is how far I've gotten, but I'm stuck.</p>
<pre><code>def my_map_k(f, *L):
    n = len(min(*L, key=len))
    x=0
    while x &lt; n:
        return [f(*L[x],) for x in L]

my_map_k(lambda x, y, z: x*y*z, [3, 2, 5], [2, 7, 9], [1, 2])
</code></pre>
<p>The problem is, I cannot just say that there are 3 lists, because there could be more. Furthermore I cannot see how to take the first element out of all three lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> to take the <strong><em>n</em></strong>th element from each list in turn, and a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> to call the supplied function with each group of arguments so generated:</p>
<pre><code>def my_map_k(f, *lists):
    return [f(*args) for args in zip(*lists)]
</code></pre>
<p>Here it is in action:</p>
<pre><code>&gt;&gt;&gt; my_map_k(lambda x, y, z: x*y*z, [3, 2, 5], [2, 7, 9], [1, 2])
[6, 28]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I figured it out:</p>
<pre><code>def my_map_k(f, *L):
    z = zip(*L)
    l = list(z)
    return ([f(*x) for x in l])

my_map_k(lambda x, y, z: x*y*z, [3, 2, 5], [2, 7, 9], [1, 2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution which does not use builtin map function:</p>
<pre><code>from itertools import starmap

def my_map_k(f, *L):
    return list(starmap(f, zip(*L)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Solution with no helper functions:</p>
<pre><code>from operator import add

def my_map_k(f, *L):
    ind = 0
    while True:
        try:
            yield f(*[l[ind] for l in L])
        except IndexError:
            break
        else:
            ind += 1

result = my_map_k(add, range(5), range(5))
print(list(result))
# [0, 2, 4, 6, 8]
</code></pre>
</div>
<span class="comment-copy">It’s the <code>map</code> function.  Not <code>starmap</code>.</span>
<span class="comment-copy">I don't think I'm alloved to use starmap neither. I think the point is to make a recursive function or something like that.</span>
