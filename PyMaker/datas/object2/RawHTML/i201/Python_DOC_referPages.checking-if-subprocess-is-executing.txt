<div class="post-text" itemprop="text">
<p>I am trying to use subprocess.popen to execute another python script that creates a listening socket. I want to pass it a default number for the port to bind on. I also want to catch if the port is already in use and the bind fails. If it fails then I want to call subprocess.popen again and pass it another number to try and bind to.</p>
<p>first.py</p>
<pre><code>import subprocess

p = subprocess.Popen(["python3.7", "test.py", "4444"], shell=False)

#If p is success (bind succeeded) then I want to continue processing code. 
#Else I want to increment the port and try again.
</code></pre>
<p>start.py</p>
<pre><code>import socket, sys

HOST = '127.0.0.1'  # Standard loopback interface address (localhost)
PORT = int(sys.argv[1])        # Port to listen on (non-privileged ports are &gt; 1023)

def stuff():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.bind((HOST, PORT))
        except:
            print("failed to bind")
            return 1
        s.listen()
        print("Listening")
        conn, addr = s.accept()

        with conn:
            print('Connected by', addr)
            while True:
                data = conn.recv(1024)
                if not data:
                    break
                conn.sendall(data)

stuff()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A couple of things:</p>
<ul>
<li><p>Just returning <code>1</code> from a function called won't make your process's exit code <code>1</code>.
Either do <code>sys.exit(stuff())</code> or just call <code>sys.exit(1)</code> in <code>stuff()</code>.</p></li>
<li><p>You can wait for a subprocess to succeed or fail with <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait" rel="nofollow noreferrer"><code>p.wait()</code></a>, after which you can look at <code>p.returncode</code>.</p></li>
</ul>
<p>In your case, you'll probably want to do something like</p>
<pre class="lang-py prettyprint-override"><code>import subprocess

p = subprocess.Popen(["python3.7", "test.py", "4444"], shell=False)
try:
    p.wait(2)
except subprocess.TimeoutExpired:
    pass  # it was probably successful and is now listening
else:
    if p.returncode == 1:
        pass  # nope
</code></pre>
<p>And, of course, you could do this with just threads instead of subprocesses.</p>
</div>
<span class="comment-copy">I suggest you do that logic inside the script :)</span>
<span class="comment-copy">I would, but then I need to let the main script know which server it eventually bound to.</span>
<span class="comment-copy">I want subprocess so it runs on its own. If I used a thread and closed my window, then the thread dies. With subprocess it is running until I kill it.</span>
<span class="comment-copy">Okie. Then you would really want a (detached) subprocess. :)</span>
