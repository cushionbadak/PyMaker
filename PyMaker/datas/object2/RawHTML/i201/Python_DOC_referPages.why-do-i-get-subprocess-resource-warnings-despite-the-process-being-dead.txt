<div class="post-text" itemprop="text">
<p>I've been trying to figure out how to spin up different subprocess instances and then killing them and then creating new ones. The parent python process never does, it just kills the subprocesses. I followed a lot of links on SO but I keep getting the following message once the parent python process ends:</p>
<pre><code>F/Users/Lucifer/miniconda3/envs/rltp/lib/python3.6/subprocess.py:761: ResourceWarning: subprocess 40909 is still running ResourceWarning, source=self)
</code></pre>
<p>it seems interesting because I did <code>ps</code> but I get nothing:</p>
<pre><code>  PID TTY           TIME CMD
 7070 ttys001    0:00.06 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp Lucifer
 7072 ttys001    0:00.61 -bash
17723 ttys002    0:00.06 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp Lucifer
17725 ttys002    0:00.06 -bash
38586 ttys002    0:00.16 sertop --no_init
</code></pre>
<p>I simply want to start a process:</p>
<pre><code>self.serapi = subprocess.Popen(['sertop','--no_init'],
    stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE,
    preexec_fn=os.setsid,shell=True
    ,)
</code></pre>
<p>and kill it:</p>
<pre><code>    os.killpg(os.getpgid(self.serapi.pid), signal.SIGTERM)
</code></pre>
<p>the above code is essentially copied from the top answer:</p>
<p><a href="https://stackoverflow.com/questions/4789837/how-to-terminate-a-python-subprocess-launched-with-shell-true">How to terminate a python subprocess launched with shell=True</a></p>
<p>but I am unsure why I get this message. Am I killing the child process successfully? I plan to start and kill many of them. </p>
<hr/>
<p>Note I don't know or need <code>shell=True</code>. I just copied that cuz thats how the answer/question I posted has it. I'd prefer to not have that parameter.</p>
<hr/>
<p>according to the answer I tried:</p>
<pre><code>def kill(self):
    self.serapi.wait()
    #self.serapi.kill()
    self.serapi.terminate()
    #os.killpg(os.getpgid(self.serapi.pid), signal.SIGTERM)
    #self.serapi.wait()
</code></pre>
<p>and different permutations of the above but nothing really seemed to work. Any advice?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>ResourceWarning: subprocess N is still running</code> warning comes from the <code>__del__</code> method of the <code>subprocess.Popen</code> class.</p>
<p>If you look at the <a href="https://github.com/python/cpython/blob/master/Lib/subprocess.py#L918" rel="nofollow noreferrer">source for that method</a>, you'll see this comment:</p>
<pre><code>        # Not reading subprocess exit status creates a zombie process which
        # is only destroyed at the parent python process exit
        _warn("subprocess %s is still running" % self.pid,
              ResourceWarning, source=self)
</code></pre>
<p>The solution is to ensure you call <code>wait()</code> on the child process.</p>
<p>See the <a href="http://man7.org/linux/man-pages/man2/wait.2.html#NOTES" rel="nofollow noreferrer">NOTES section of the man page for <code>wait(2)</code></a> for more background information.</p>
<p>In Python, the easiest way to handle this situation is to keep track of all the <code>Popen</code> objects you have created, and ensure that something calls <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait" rel="nofollow noreferrer"><code>wait()</code></a> on them, either directly or indirectly.</p>
<p>Alternatively, you can install a <code>SIGCHLD</code> handler that ignores <code>SIGCHLD</code> events; then your child processes will disappear immediately, but you will now be <em>unable</em> to call <code>wait()</code> on them. See also <a href="https://stackoverflow.com/questions/17015830/how-can-i-prevent-zombie-child-processes">How can I prevent zombie child processes?</a> and <a href="https://stackoverflow.com/questions/7171722/how-can-i-handle-sigchld">How can I handle SIGCHLD?</a></p>
</div>
<span class="comment-copy">Did you <code>wait()</code> on the subprocess? Even after a child process exits, it remains a zombie until its parent calls <code>wait()</code> and retrieves its exit status.</span>
<span class="comment-copy">@DanielPryden I did not call <code>wait()</code> I did not know that call existed until you mentioned it.</span>
<span class="comment-copy">Great! I figured as much, which is why I wrote the answer below. If you found it useful, please feel free to upvote and/or accept it. Glad I could help!</span>
<span class="comment-copy">@DanielPryden looking at the docks calling <code>wait()</code> seems to deadlock if both are <code>stdout,stderr = PIPE</code>, besides my process never ends until I tell it to end.</span>
<span class="comment-copy">I tried different variations of the following  <code>self.serapi.wait();#self.serapi.kill();#self.serapi.terminate();</code>  but it didn't work. So I guess calling <code>wait()</code> and then terminating/killing the process doesn't work? Or am I missing something?</span>
<span class="comment-copy">but is the process still running? I don't understand what is going on because when I do a <code>ps</code> I don't see it... :/</span>
<span class="comment-copy">You should kill the process first, and then wait on it. At the kernel level, <code>wait</code> doesn't literally mean "wait", it means "receive postmortem information". The process may in fact not be a zombie, depending on how you fork it. But the <code>Popen</code> class <i>thinks</i> the subprocess must still be running (or must be a zombie), because you haven't received any postmortem information yet. Does that make sense?</span>
<span class="comment-copy">Ok so I call <code>wait</code> (really badly named name for what its suppose to be for) after <code>kill</code>. How do I know if everything was successful? I am sure I tried this but it wasn't clear if it worked. What I am trying to do is running a new subprocess for each of my unit tests. I'd like to create a new subprocess.</span>
