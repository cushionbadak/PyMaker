<div class="post-text" itemprop="text">
<p>I'm learning Python await / async syntax and wondering how coroutine can be implemented without async, await or yield. For example, I made this simple three seconds timer with async def syntax:</p>
<pre class="lang-py prettyprint-override"><code>import asyncio

async def coroutine():
    count = 0
    while count &lt; 3:
        count += 1
        print(count)
        await asyncio.sleep(1)

loop = asyncio.get_event_loop()
loop.run_until_complete(coroutine())
loop.close()
</code></pre>
<p>The result:</p>
<pre class="lang-sh prettyprint-override"><code>1
2
3
</code></pre>
<p>I noticed that we can implement a Coroutine object by implementing <code>__await__</code> (<a href="https://docs.python.org/3.6/reference/datamodel.html#awaitable-objects" rel="nofollow noreferrer">https://docs.python.org/3.6/reference/datamodel.html#awaitable-objects</a>). So I can successfully remove <code>await</code>.</p>
<pre class="lang-py prettyprint-override"><code>import asyncio

class Generator():
    def __await__(self):
        count = 0
        while count &lt; 3:
            count += 1
            print(count)
            yield from asyncio.sleep(1)

loop = asyncio.get_event_loop()
loop.run_until_complete(Generator())
loop.close()
</code></pre>
<p>Finally, I want to implement the iterator without yield like that:</p>
<pre class="lang-py prettyprint-override"><code>import asyncio

class Iterator():

    def __init__(self):
        self.count = 0

    def __iter__(self): return self

    def __await__(self): return self

    def __next__(self):
        if self.count &lt; 3:
            self.count += 1
            print(self.count)
            return next(asyncio.sleep(1))
        else:
            raise StopIteration()

loop = asyncio.get_event_loop()
result = loop.run_until_complete(Iterator())
loop.close()
</code></pre>
<p>But it didn't work. It stops after it shows '1'.</p>
<p>I know this doesn't have any practical value, but I want to know it to understand asyncio correctly. Can I implement a Coroutine without await or yield? If so how to do it? I tested it by Python 3.6.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>While coroutines are implemented <strong>using</strong> generators, coroutines <strong>are not</strong> generators:</p>
<pre><code>import asyncio
from typing import Generator


def gen():
    yield 1


async def coro():
    pass


print(isinstance(gen(), Generator))   # True
print(isinstance(coro(), Generator))  # False
</code></pre>
<p>And it is intentional since generator is nothing more than a detail of implementation towards coroutine. Same true for iterators: coroutines <strong>are not</strong> iterators.</p>
<p><code>loop.run_until_complete</code> expects to recieve something awaitable like <code>asyncio</code> coroutine or future. You're trying to pass iterator - a different object with a different behavior.</p>
<hr/>
<p>Long story short, if you want to implement coroutine compatible with <code>asyncio</code>:</p>
<ul>
<li>define functions with <code>async def</code></li>
<li>or implement <code>__await__</code> magic method</li>
</ul>
<p>And read <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio doc</a> for examples.</p>
<p>If you want to understand general idea behind how coroutines work on very low-level you can follow this <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4" rel="nofollow noreferrer">excellent video</a> where David Beazley implements coroutine and event loop from scratch.</p>
</div>
<span class="comment-copy">With regards to <code>yield</code>, I think it's required, as it's what allows the interpreter to do a context switch.</span>
<span class="comment-copy">Probably yes, but I swill would like to know what is exactly missing in a hand written iterator compare to yield as a coroutine. If I return None in __next__() instead of asyncio.sleep(1), the loop doesn't complain it and works as I expect.</span>
