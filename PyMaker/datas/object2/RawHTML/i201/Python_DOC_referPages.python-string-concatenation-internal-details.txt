<div class="post-text" itemprop="text">
<p>Assume that we have a list of strings and we want to create a string by concatenating all element in this list. Something like this: </p>
<pre><code>def foo(str_lst):
    result = ''
    for element in str_lst:
        result += element
    return result
</code></pre>
<p>Since strings are immutable objects, I expect that python creates a new str object and copy contents of result and element at each iteration. It makes <code>O(M * N^2)</code> time complexity, M is the length of each element and N is the size of the list.</p>
<p>However, my experiment shows that it runs in linear time. </p>
<pre><code>N = 1000000 # 1 million
str_lst = ['a' for _ in range(N)]

foo(str_lst) # It takes around 0.5 seconds

N = 2000000 # 2 million
str_lst = ['a' for _ in range(N)]

foo(str_lst) # It takes around 1.0 seconds

N = 10000000 # 10 million
str_lst = ['a' for _ in range(N)]

foo(str_lst) # It takes around 5.3 seconds
</code></pre>
<p>I suspect that python uses something like stringbuffer under the hood. So, it doesn't create new object at each iteration.</p>
<p>Now consider a slightly different implementation. The only difference is one extra assignment.</p>
<pre><code>def foo2(str_lst):
    result = ''
    for element in str_lst:
        result += element
        temp = result # new added line
    return result
</code></pre>
<p>I know that <code>temp = result</code> line does not create a new object. <code>temp</code> just points to the same object. So, this little change shouldn't affect the performance much.</p>
<pre><code>N = 1000000 # 1 million
str_lst = ['a' for _ in range(N)]
foo(str_lst) # It takes around 0.5 seconds
foo2(str_lst) # It takes around 30 seconds

N = 2000000 # 2 million
str_lst = ['a' for _ in range(N)]
foo(str_lst) # It takes around 1 seconds
foo2(str_lst) # It takes around 129 seconds
</code></pre>
<p>However, there is a huge difference. And it looks like foo2 function is O(N^2) while foo is O(N).</p>
<p>My question is how does python achieve linear time in string concatenation without breaking other language components like immutable object assignment? and how does that extra line affect the performance that much? I searched a bit in the cpython implementation but couldn't find exact location. </p>
<p><strong>Update</strong></p>
<p>Here is the line profiling results.</p>
<p>result for foo function</p>
<pre><code>Total time: 0.545577 s
File: &lt;ipython-input-38-b9bb169e8fe0&gt;
Function: foo at line 1

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
 1                                           def foo(str_lst):
 2         1          2.0      2.0      0.0      result = ''
 3   1000001     238820.0      0.2     43.8      for element in str_lst:
 4   1000000     306755.0      0.3     56.2          result += element
 5         1          0.0      0.0      0.0      return result
</code></pre>
<p>result for foo2 function</p>
<pre><code>Total time: 30.6663 s
File: &lt;ipython-input-40-34dd53670dd9&gt;
Function: foo2 at line 1
Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
 1                                           def foo2(str_lst):
 2         1          2.0      2.0      0.0      result = ''
 3   1000001     299122.0      0.3      1.0      for element in str_lst:
 4   1000000   30033127.0     30.0     97.7          result += element
 5   1000000     413283.0      0.4      1.3          temp = result
 6         1          0.0      0.0      0.0      return result
</code></pre>
<p>Somehow <code>temp = result</code> line affects the performance of <code>result += element</code> line.</p>
</div>
<div class="post-text" itemprop="text">
<p>Having another name pointing to the same object kills the optimisation. The optimisation basically works by <a href="https://github.com/python/cpython/blob/8a1bab92915dd5c88832706c56af2f5611181d50/Objects/unicodeobject.c#L11371" rel="nofollow noreferrer">resizing the string object</a> and appending in place. If you have more than one references to that object, you can't resize without affecting the other reference. With strings being immutable, allowing this would be a serious flaw of the implementation.</p>
<pre><code>temp = result
</code></pre>
<p>increased the reference count for the string object named by <code>result</code> thereby prohibiting the optimisation.</p>
<p>The full list of checks performed in the case of <code>+=</code> (which eventually translates to <a href="https://github.com/python/cpython/blob/8a1bab92915dd5c88832706c56af2f5611181d50/Objects/unicodeobject.c#L11318" rel="nofollow noreferrer"><code>PyUnicode_Append</code></a>) can be seen in the <a href="https://github.com/python/cpython/blob/8a1bab92915dd5c88832706c56af2f5611181d50/Objects/unicodeobject.c#L1855" rel="nofollow noreferrer"><code>unicode_modifiable</code></a> function. Among other things, it checks that the reference count of the object is equal to one, that it isn't interned and that it isn't a string subclass.</p>
<p>There's a couple more checks in <a href="https://github.com/python/cpython/blob/8a1bab92915dd5c88832706c56af2f5611181d50/Objects/unicodeobject.c#L11361" rel="nofollow noreferrer">the <code>if</code> statement</a> guarding this optimisation, if you want a more thorough list.</p>
<hr/>
<p>Though not the basic issue of your question, future readers might be curious about how to efficiently perform string concatenations. Besides similar questions on S.O, the <a href="https://docs.python.org/3/faq/programming.html#what-is-the-most-efficient-way-to-concatenate-many-strings-together" rel="nofollow noreferrer">Python FAQ also has an entry</a> on this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, the behavior you are observing is determined by the behavior of the memory-allocator of the C-runtime on your OS.</p>
<p>CPython has an optimization, that if the unicode-object has only one reference, it can be changed in-place - nobody would register that the unicode-object loss its immutability for a moment. See my answer <a href="https://stackoverflow.com/q/54006987/5769463">to this SO-question</a> for more details.</p>
<p>In <code>foo2</code>, there is another reference to the unicode object (<code>temp</code>), which prevents the in-place-optimization: Changing it in-place would break the immutability, because it could be observed through <code>temp</code>.</p>
<p>However, even with the inplace optimization, it is not obvious, why <code>O(n^2)</code> behavior can be avoided, as unicode object doesn't overallocate and thus has to exend the underlying buffer at every addition, which naively would mean a copy of the whole content (i.e. <code>O(n)</code>) in every step.</p>
<p>However, most of the time <a href="https://en.cppreference.com/w/c/memory/realloc" rel="nofollow noreferrer"><code>realloc</code></a> (differently than <code>malloc</code>+copy) can be done in <code>O(1)</code>, because if the memory directly behind the the allocated buffer is free, it can be used to extend the original without copying.</p>
<hr/>
<p>An interesting detail is that there is no guarantee, that <code>foo</code> will run in <code>O(n)</code>: If the memory is fragemented (e.g. in a long running process). <code>realloc</code> wont be able to extend the buffer without copying the data and thus the running time will become <code>O(n^2)</code>. </p>
<p>Thus one should not rely on this optimization to avoid quadratic running time.</p>
</div>
<span class="comment-copy">You do not have nested for loops so it is not O(N^2)</span>
<span class="comment-copy">@naivepredictor See <a href="https://www.joelonsoftware.com/2001/12/11/back-to-basics/" rel="nofollow noreferrer">Back to Basics</a> by Joel Spolsky for how string concatenation is a good example of hidden quadratic behavior.</span>
<span class="comment-copy">There are apparently some optimizations when concatenating with <code>+=</code>, see <a href="https://github.com/satwikkansal/wtfpython#-lets-make-a-giant-string" rel="nofollow noreferrer">this example at wtfpython</a>.</span>
<span class="comment-copy">I seem to recall that the string concatenation optimisations are a CPython implementation detail, but I can't find any docs to confirm.</span>
<span class="comment-copy">Thank you for the explanation. I wish I can accept more than one answer. About the last part, you said there is no guarantee. Is it specific to string concatenation? I mean, can i use <code>io.StringIO</code> to get guarenteed amortized linear time or that problem applies to any buffer like thing in python. Thank you.</span>
<span class="comment-copy">@SeljukGÃ¼lcan The above is only for unicode-object. I would expect <code>io.StringIO</code> to guarantee <code>O(n)</code>, but to my shame I don't know it for sure.</span>
