<div class="post-text" itemprop="text">
<p>I'm parsing a XML String into CSV string but it's going very slow:</p>
<pre><code>INDEX_COLUMN = "{urn:schemas-microsoft-com:office:spreadsheet}Index"
CELL_ELEMENT = "Cell"
DATA_ELEMENT = "Data"

def parse_to_csv_string(xml):
    print('parse_to_csv_string')
    csv = []
    parsed_data = serialize_xml(xml)
    rows = list(parsed_data[1][0])
    header = get_cells_text(rows[0])
    rows.pop(0)
    csv.append(join(",", header))
    for row in rows:
        values = get_cells_text(row)
        csv.append(join(",", values))
    return join("\n", csv)

def serialize_xml(xml):
    return ET.fromstring(xml)

def get_cells_text(row):
    keys = []
    cells = normalize_row_cells(row)
    for elm in cells:
        keys.append(elm[0].text or "")
    while len(keys) &lt; 92:
        keys.append("")
    return keys


def normalize_row_cells(row):
    cells = list(row)
    updated_cells = copy.deepcopy(cells)
    pos = 1
    for elm in cells:
        strIndexAttr = elm.get(INDEX_COLUMN)
        index = int(strIndexAttr) if strIndexAttr else pos
        while index &gt; pos:
            empty_elm = ET.Element(CELL_ELEMENT)
            child = ET.SubElement(empty_elm, DATA_ELEMENT)
            child.text = ""
            updated_cells.insert(pos - 1, empty_elm)
            pos += 1
        pos += 1
    return updated_cells
</code></pre>
<p>The XML String sometimes miss a few columns  and I need to iterate it to fill missing columns - every row must have 92 columns. That's why I have some helper functions to manipulate XML.</p>
<p>Right now I'm running my function with 4GB as Lambda and still getting timeout :(</p>
<p>Any idea on how to improve performance?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>normalize_row_cells</code> constructs ElementTree Element instances but <code>get_cells_text</code> is only interested in each instance's child's text attribute, so I would consider changing <code>normalize_row_cells</code> to just return the text.  Also, it's performing copies and calling <code>list.insert</code>: inserting elements into the middle of lists can be expensive, because each element after the insertion point must be moved.</p>
<p>Something like this (untested code) avoids making copies and insertions and returns only the required text, making <code>get_cells_text</code> redundant.</p>
<pre><code>def normalize_row_cells(row):
    cells = list(row)
    updated_cells = []
    pos = 1
    for _ in range(0, 92):
        elm = cells[pos - 1]
        strIndexAttr = elm.get(INDEX_COLUMN)
        index = int(strIndexAttr) if strIndexAttr else pos
        if index == pos:
            updated_cells.append(elm[0].text)
            pos += 1
        else:
            update_cells.append("")        
    return updated_cells
</code></pre>
<p>If you can match your cells to their header names then using <a href="https://docs.python.org/3/library/csv.html#csv.DictWriter" rel="nofollow noreferrer">csv.DictWriter</a> from the standard library might be even better (you need to profile to be sure).</p>
<pre><code>import csv
import io


def parse_to_csv_string(xml):
    print('parse_to_csv_string')
    csv = []
    parsed_data = serialize_xml(xml)
    rows = list(parsed_data[1][0])
    header = get_cells_text(rows[0])
    with io.StringIO() as f:
        writer = csv.DictWriter(f, fieldnames=header)
        for row in rows:
            row = get_cells_text(row)
            writer.writerow(row)
        f.seek(0)
        data = f.read()
    return data

def get_cells_text(row):
    row_dict = {}
    for cell in row:
        column_name = get_column_name(cell)  # &lt;- can this be done?
        row_dict[column_name] = elm[0].text or ""
    return row_dict
</code></pre>
</div>
<span class="comment-copy">Are you using built-in <code>xml</code> or <code>lxml</code>? I'm not sure if you can use <code>lxml</code> in your function environment, but if you can, it will improve it a lot.</span>
