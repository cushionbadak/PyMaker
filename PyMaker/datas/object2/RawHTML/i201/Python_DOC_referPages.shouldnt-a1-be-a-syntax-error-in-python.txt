<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/48323493/what-is-this-odd-colon-behavior-doing">What is this odd colon behavior doing?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I made a typo in my code that went completely silent syntactically.</p>
<pre><code>dict_args : {"arg1":1,"arg2":2,"arg3":3}
# .... Some more code
some_function(**dict_args)
# .... Some more code
</code></pre>
<p>If you haven't noticed it, it's the use of <code>:</code> instead of <code>=</code> when declaring the variable <code>dict_args</code>.</p>
<p>So my question is, does the python syntax : <code>a:1</code>, <strong>by itself</strong>, hold any meaning ? Or should it hypothetically be considered a syntax error?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://www.python.org/dev/peps/pep-0526/" rel="nofollow noreferrer">PEP-526</a> introduced variable annotations, which provide programmers a way to add type information to variables.  This allows, among other things, statements like</p>
<pre><code>x: int
</code></pre>
<p>to indicate that there is a local variable of type <code>int</code>, without initializing it.  In <a href="https://www.python.org/dev/peps/pep-0484/#acceptable-type-hints" rel="nofollow noreferrer">PEP-484 - Acceptable Type Hints</a>, we can see that annotations "must be valid expressions that evaluate without raising exceptions", which your dictionary literal is.</p>
<p>If you look at the <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">Python grammar itself</a> you can see that the <code>expr_stmt</code> and <code>annassign</code> rules make the example you show legal.  </p>
<p>If you're using an IDE/other type hinting tools, they should definitely complain about this, but it doesn't break the rules that Python has set up.</p>
</div>
<span class="comment-copy">It's being interpreted as a type hint.</span>
<span class="comment-copy">When in doubt, you can do <code>import dis; dis.dis('a : 1')</code> to get an idea of what is happening. As mentioned, the code sets an annotation for the left-hand side.</span>
<span class="comment-copy">To follow up with @PatrickHaugh's comment, take a look at the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type hint documentation</a></span>
<span class="comment-copy">That said, it <i>is</i> a bit weird that you can do e.g. <code>a : 1</code> even if <code>a</code> does not exist, and will still not exist after that line is run.</span>
<span class="comment-copy">It's a <i>variable annotation</i>, one <i>use</i> of which is as a type hint.</span>
<span class="comment-copy">Although I understand your answer, I don't actually agree that it should be acceptable. Why annotate something that doesn't exist yet? it should at least be limited to the scope of parameters or to variable assignment. E.g: <code>x: int = 1</code> would absolutely make sense. Annotating before defining a value is like me trying to tell you, without any context that <code>Victor works as a vendor</code>.. Yeah okay, but who is Victor and why would I care?</span>
<span class="comment-copy">I'm inclined to agree with you, though this is the syntax that makes dataclasses possible in their current form.  Guiod's reasoning <a href="https://github.com/python/typing/issues/258" rel="nofollow noreferrer">here</a> is that it makes cases where assignment could happen in  multiple places easier, but I'm not sure that excuses how error-prone it is</span>
<span class="comment-copy">@Aetos Since only values, not names, have types, think of <code>a: int</code> as a hint that <i>when</i> a value is assigned to <code>a</code>, it has to be an <code>int</code>. There's no reason an <code>int</code> has to be assigned <i>immediately</i> for the hint to be valid.</span>
<span class="comment-copy">Such annotations were not originally, and continue to not be, intended to be limited to type hints. Function annotations were originally left open to see what uses people could find for them. For example, you could simply provide a short doc string describing the purpose of the variable. In Python 4, I believe, the annotations will no longer even be evaluated as expressions, but stored as literal strings in the appropriate <code>__annotations__</code> attribute.</span>
<span class="comment-copy">(See <a href="https://www.python.org/dev/peps/pep-0563/" rel="nofollow noreferrer">python.org/dev/peps/pep-0563</a>, regarding the delayed evaluation of annotations. I notice, though, that it does deprecate non-type-hint usage of annotations. In the future, it's possible that such uses could formally be banned, although since the parser simply at that time will treat an annotation effectively as a string literal, there doesn't seem to be much reason to go to the trouble to do so.)</span>
