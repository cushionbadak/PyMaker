<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow noreferrer">documentation for asyncio.gather</a> says that</p>
<blockquote>
<p>If return_exceptions is <code>False</code> (default), the first raised exception is
  immediately propagated to the task that awaits on <code>gather()</code>. Other
  awaitables in the aws sequence <strong>wonâ€™t be cancelled</strong> and will continue to
  run.</p>
</blockquote>
<p>However, from a simple test it seems that if one of the tasks raises an exception when return_exceptions is <code>False</code>, all other awaitable are cancelled (or to be more precise, in case the terminology is not clear to me, the other awaitables do not finish their job):</p>
<pre><code>import asyncio

async def factorial(name, number, raise_exception=False):
    # If raise_exception is True, will raise an exception when
    # the loop counter &gt; 3
    f = 1
    for i in range(2, number + 1):
        print(f'  Task {name}: Compute factorial({i})...')

        if raise_exception and i &gt; 3:
            print(f'  Task {name}: raising Exception')
            raise Exception(f'Bad Task {name}')

        await asyncio.sleep(1)
        f *= i
    print(f'==&gt;&gt; Task {name} DONE: factorial({number}) = {f}')
    return f

async def main():
    tasks = [factorial('A', 5),  # this will not be finished
             factorial('B', 10, raise_exception=True),
             factorial('C', 2)]

    try:
        results = await asyncio.gather(*tasks)
        print('Results:', results)
    except Exception as e:
        print('Got an exception:', e)

asyncio.run(main())
</code></pre>
<p>What this piece of code is doing, just to make it simpler, it defines 3 tasks and call <code>asyncio.gather()</code> on them. One of the tasks raises an exception before one of the others is done, and this other task is not finished.</p>
<p>Actually, I cannot even make sense with what the documentations says - if an exception is raised and caught by the task awaiting on <code>gather</code>, I would not even be able to get the returned results (even if the other task would, somehow, get done).</p>
<p>Am I missing anything, or is there a problem with the documentation?</p>
<p>This was tested with Python 3.7.2.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've run your code and got the following output, as expected from documentation.</p>
<pre><code>  Task C: Compute factorial(2)...
  Task A: Compute factorial(2)...
  Task B: Compute factorial(2)...
==&gt;&gt; Task C DONE: factorial(2) = 2
  Task A: Compute factorial(3)...
  Task B: Compute factorial(3)...
  Task A: Compute factorial(4)...
  Task B: Compute factorial(4)...
  Task B: raising Exception
Got an exception: Bad Task B
  Task A: Compute factorial(5)...
==&gt;&gt; Task A DONE: factorial(5) = 120
</code></pre>
<h1>What's going on</h1>
<ol>
<li>Tasks A,B and C are submitted to the queue;</li>
<li>All tasks are running while C finishes earliest.</li>
<li>Task B raises and exception.</li>
<li>The <code>await asyncio.gater()</code> returns immediately and <code>print('Got an exception:', e)</code> to the screen.</li>
<li>Task A continues to run and print "==&gt;&gt; Task A DONE ..."</li>
</ol>
<h1>What's wrong with your test</h1>
<p>As @deceze commented, 
your program exited immediately after the exception was caught and <code>main()</code> returns. Thus, the tasks A and C are terminated because the entire process dies, not because of cancellation.</p>
<p>To fix it, add <code>await asyncio.sleep(20)</code> to the end of the <code>main()</code> function.</p>
</div>
<span class="comment-copy">What you may be missing here is that the other tasks have not been canceled, you're just not seeing their result, since the asyncio loop has stopped running, since you've only executed the loop as far as the exception so far and are then not continuing.</span>
<span class="comment-copy">Thanks! I see what you mean, but it raises a few questions: so if I use <code>raise_exception=True</code>, then there is no point in getting the returned value of <code>gather</code>? Since then I cannot guarantee that I'll get it. In other words, either I use <code>raise_exception=False</code> (the default) and then I can wait for the returned value of <code>gather</code> and process it, or I use <code>raise_exception=True</code> without trying to use the returned value. Also, in the latest case, How should I wait, in case one of the tasks had raised an exception, for the other tasks? Shall I use callbacks in that case?</span>
<span class="comment-copy">Do you mean <code>return_exceptions</code>?</span>
<span class="comment-copy">If you set <code>return_exceptions=True</code> the exception object will be returned and put in the <code>results</code> of <code>gather()</code>. For your example, it will print out <code>Results: [120, Exception('Bad Task B',), 2]</code>. In short, you can trust the returned value of <code>gather()</code>.</span>
<span class="comment-copy">Yes, I meant <code>return_exceptions</code>, of course. I know that when it is <code>True</code> I can trust the returned value of <code>gather()</code>. The other case, when it is <code>False</code>, is less clear to me - how should I handle the other tasks, those that were not done when an exceptions was raised, but I guess I'll be able to figure that out now.</span>
