<div class="post-text" itemprop="text">
<p>My list, for example, is</p>
<pre><code>my_list = [1,2,3,4,5,  9,10,11,12,13,14,  20,21,22,23,24,25,26,27]
</code></pre>
<p>I would like to save the first and last boundary of two elements in consecutive values. So what I need to get is:</p>
<pre><code>output = [1,2,4,5,  9,10,13,14,  20,21,26,27]
</code></pre>
<p>How can I simply or efficiently get this result?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>more_itertools.consecutive_groups</code></p>
<pre><code>import more_itertools as mit

my_list = [1,2,3,4,5,9,10,11,12,13,14,15]

x = [list(group) for group in mit.consecutive_groups(my_list)]

oputput = []
for i in x:
    temp = [i[0],i[1],i[-2],i[-1]]
    output.extend(temp)    
</code></pre>
<p>Output:</p>
<pre><code>[1,2,4,5,9,10,14,15]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> and <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter</code></a>:</p>
<pre><code>from operator import itemgetter
from itertools import groupby

my_list = [1,2,3,4,5,9,10,11,12,13,14,20,21,22,23,24,25,26,27]

output = []
for k, g in groupby(enumerate(my_list), lambda x: x[0]-x[1]):
    lst = list(map(itemgetter(1), g))
    output.extend([lst[0], lst[1], lst[-2], lst[-1]])

print(output)
# [1, 2, 4, 5, 9, 10, 13, 14, 20, 21, 26, 27]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using only the standard <code>itertools</code> module, you can do:</p>
<pre><code>from itertools import count, groupby

def remove_middle_of_seq(lst):
    out = []
    index = count()
    for _, sequence in groupby(lst, lambda value: value - next(index)):
        seq = list(sequence)
        out.extend([seq[0], seq[1], seq[-2], seq[-1]])
    return out

my_list = [1,2,3,4,5,  9,10,11,12,13,14,  20,21,22,23,24,25,26,27]
print(remove_middle_of_seq(my_list))
# [1, 2, 4, 5, 9, 10, 13, 14, 20, 21, 26, 27]
</code></pre>
<p>In groups of consecutive values, the difference between the values and their index is constant, so <code>groupby</code> can group them using this difference as key.</p>
</div>
<div class="post-text" itemprop="text">
<p>There isn't really a function that does this kind of thing in the standard library, so you have to write most of it manually. It's easiest to first group all ascending numbers, and then delete the middle of each group:</p>
<pre><code>import itertools

def group_consecutive(sequence):
    """
    Aggregates consecutive integers into groups.

    &gt;&gt;&gt; group_consecutive([8, 9, 1, 3, 4, 5])
    [[8, 9], [1], [3, 4, 5]]
    """
    result = []
    prev_num = None

    for num in sequence:
        if prev_num is None or num != prev_num + 1:
            group = [num]
            result.append(group)
        else:
            group.append(num)

        prev_num = num

    return result

def drop_consecutive(sequence, keep_left=2, keep_right=2):
    """
    Groups consecutive integers and then keeps only the 2 first and last numbers
    in each group. The result is then flattened.

    &gt;&gt;&gt; drop_consecutive([1, 2, 3, 4, 5, 8, 9])
    [1, 2, 4, 5, 8, 9]
    """
    grouped_seq = group_consecutive(sequence)

    for group in grouped_seq:
        del group[keep_left:-keep_right]

    return list(itertools.chain.from_iterable(grouped_seq))
</code></pre>
<pre><code>&gt;&gt;&gt; my_list = [1,2,3,4,5,  9,10,11,12,13,14,  20,21,22,23,24,25,26,27]
&gt;&gt;&gt; drop_consecutive(my_list)
[1, 2, 4, 5, 9, 10, 13, 14, 20, 21, 26, 27]
</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can pair adjacent list items by zipping the list with itself with an offset of 1, but pad the shifted list with a non-consecutive value, so that you can iterate through the pairings and determine that there is a separate group when the difference of a pair is not 1:</p>
<pre><code>def consecutive_groups(l):
    o = []
    for a, b in zip([l[0] - 2] + l, l):
        if b - a != 1:
            o.append([])
        o[-1].append(b)
    return [s[:2] + s[-2:] for s in o]
</code></pre>
<p>Given your sample input, <code>consecutive_groups(my_list)</code> returns:</p>
<pre><code>[[1, 2, 4, 5], [9, 10, 13, 14], [20, 21, 26, 27]]
</code></pre>
</div>
<span class="comment-copy">Can you explain it in a bit more clear manner</span>
<span class="comment-copy">Really sorry for that, I just edited it. I just want to extract first two, and last two items of consecutive integers in my list!</span>
<span class="comment-copy">Is the list always sorted? Please also share what you have tried so far.</span>
<span class="comment-copy">For simple explaining, I really simplified my situation and if I share what I've tried, I'm worried about what if you don't understand it. If you really need it, I can explain about my code but it may take a little more time.</span>
