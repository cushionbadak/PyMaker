<div class="post-text" itemprop="text">
<p>I want to achieve a pseudo-db-like transaction using context manager.</p>
<p>Take for example:</p>
<pre><code>class Transactor:
    def a(): pass
    def b(d, b): pass
    def c(i): pass

    @contextmanager
    def get_session(self):
        txs = []
        yield self  # accumulate method calls
        for tx in tx:
            tx() # somehow pass the arguments

def main():
    t = Transactor()
    with t.get_session() as session:
        session.a() # inserts `a` into `txs`
        ... more code ...
        session.c(value) # inserts `c` and `(value)` into `txs`
        session.b(value1, value2) # inserts `b` and `(value1, value2)` into `txs`
        ... more code ...
        # non-transator related code
        f = open('file.txt') # If this throws an exception,
                             # break out of the context manager, 
                             # and discard previous transactor calls.
        ... more code ...
        session.a() # inserts `a` into `txs`
        session.b(x, y) # inserts `b` and `(x, y)` into `txs`

    # Now is outside of context manager.
    # The following calls should execute immediately
    t.a()
    t.b(x, y)
    t.c(k)
</code></pre>
<p>If something goes wrong such as an exception, discard <code>txs</code> (rollback). If  it makes it to the end of the context, execute each instruction in order of insertion and pass in the appropriate arguments.</p>
<p>How can to trap the method call for later execution?</p>
<p>And one extra caveat:
If <code>get_session</code> is not called, I want to execute the instructions immediately.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not pretty, but to follow the structure you're looking for you'd have to build a temporary transaction class that holds your function queues and execute it after the context manager exits.  You'll need to use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>, but there are some restrictions though:</p>
<ol>
<li>All the queued up calls must be methods based on your "session" instance.  Anything else gets executed right away.  </li>
<li>I don't know how you want to handle non-callable session attributes, so for now I assume it'll just retrieve the value.</li>
</ol>
<p>Having said that, here's my take on it:</p>
<pre><code>from functools import partial

class TempTrans:

    # pass in the object instance to mimic
    def __init__(self, obj):
        self._queue = []

        # iterate through the attributes and methods within the object and its class
        for attr, val in type(obj).__dict__.items() ^ obj.__dict__.items():
            if not attr.startswith('_'):
                if callable(val):
                    setattr(self, attr, partial(self._add, getattr(obj, attr)))
                else:
                    # placeholder to handle non-callable attributes
                    setattr(self, attr, val)

    # function to add to queue
    def _add(self, func, *args, **kwargs):
        self._queue.append(partial(func, *args, **kwargs))

    # function to execute the queue
    def _execute(self):
        _remove = []

        # iterate through the queue to call the functions.  
        # I suggest catching errors here in case your functions falls through
        for func in self._queue:
            try:
                func()
                _remove.append(func)
            except Exception as e:
                print('some error occured')
                break

        # remove the functions that were successfully ran
        for func in _remove:
            self._queue.remove(func)
</code></pre>
<hr/>
<p>Now onto the context manager (it will be outside your class, you can place it in as a class method if you wish):</p>
<pre><code>@contextmanager
def temp_session(obj):
    t = TempTrans(obj)
    try:
        yield t
        t._execute()
        print('Transactions successfully ran')
    except:
        print('Encountered errors, queue was not executed')
    finally:
        print(t._queue)  # debug to see what's left of the queue
</code></pre>
<hr/>
<p><strong>Usage:</strong></p>
<pre><code>f = Foo()

with temp_session(f) as session:
    session.a('hello')
    session.b(1, 2, 3)

# a hello
# b 1 2 3
# Transactions successfully ran
# []

with temp_session(f) as session:
    session.a('hello')
    session.b(1, 2, 3)
    session.attrdoesnotexist  # expect an error

# Encountered errors, queue was not executed
# [
#   functools.partial(&lt;bound method Foo.a of &lt;__main__.Foo object at 0x0417D3B0&gt;&gt;, 'hello'), 
#   functools.partial(&lt;bound method Foo.b of &lt;__main__.Foo object at 0x0417D3B0&gt;&gt;, 1, 2, 3)
# ]
</code></pre>
<p>This solution was a bit contrived because of the way you wanted it structured, but if you didn't <em>need</em> a context manager and doesn't <em>need</em> the session to look like a direct function call, it's trivial to just use <code>partial</code>:</p>
<pre><code>my_queue = []

# some session
my_queue.append(partial(f, a))
my_queue.append(partial(f, b))
for func in my_queue:
    func()
</code></pre>
</div>
<span class="comment-copy">Is there an underlying transaction mechanism or are you making your own?</span>
<span class="comment-copy">@yorodm Making my own bc it's not database related.</span>
<span class="comment-copy">I'm going to write this as a comment since your question has some gray areas to me. You should implement an Unit Of Work over your <code>Transactor</code> object and return that instead of <code>self</code> in the context manager. In an ideal world, your <code>Transactor</code> should be the UoW over something like a database context</span>
<span class="comment-copy">Rollback is not just "throwing away the <code>txs</code> list"... if one of those operations fails you have to undo them (or retrieve a snapshot before doing any of those).</span>
<span class="comment-copy">Can you provide a more concrete sample of what you are trying to do, including a rollback scenario? It's not quite clear to me how you expect the roll backs to work.</span>
