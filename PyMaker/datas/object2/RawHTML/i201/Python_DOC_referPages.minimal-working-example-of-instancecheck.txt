<div class="post-text" itemprop="text">
<p>I'm trying to make my class appear as a different object to circumvent lazy type checking in a package I'm using. More specifically, I'm trying to make my object appear as an instance of another object (<code>tuple</code> in my case) when in reality it is not even a derivation of that.</p>
<p>In order to achieve this, I plan to overwrite the <code>__isinstance__</code> method which, according to the <a href="https://docs.python.org/3/reference/datamodel.html#class.__instancecheck__" rel="nofollow noreferrer">docs</a>, should do exactly what I desire. However, it appears that I didn't understand how do to do that exactly, because my attempts have been unsuccessful.</p>
<p>Here's an SSCCE that <em>should</em> make <code>isinstance</code> return <code>False</code> in all cases but doesn't.</p>
<pre><code>class FalseInstance(type):
    def __instancecheck__(self, instance):
        return False

class Foo(metaclass=FalseInstance):
    pass

g = Foo()
isinstance(g, Foo)
&gt; True
</code></pre>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>Aside from the issues with <code>__metaclass__</code> and the fast-path for an exact type match, <code>__instancecheck__</code> works in the opposite direction from what you're trying to do. A class's <code>__instancecheck__</code> checks whether other objects are considered virtual instances of that class, not whether instances of that class are considered virtual instances of other classes.</p>
<p>If you want your objects to lie about their type in <code>isinstance</code> checks (you really shouldn't), then the way to do that is to lie about <code>__class__</code>, not implement <code>__instancecheck__</code>.</p>
<pre><code>class BadIdea(object):
    @property
    def __class__(self):
        return tuple

print(isinstance(BadIdea(), tuple)) # prints True
</code></pre>
<p>Incidentally, if you want to get the actual type of an object, use <code>type</code> rather than checking <code>__class__</code> or <code>isinstance</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you add a print inside <code>FalseInstance.__instancecheck__</code> you will see that it is not even invoked. However, if you call <code>isinstance('str', Foo)</code> then you'll see that <code>FalseInstance.__instancecheck__</code> does get invoked. </p>
<p>This is due to an optimization in <code>isinstance</code>'s implementation that immediately returns <code>True</code> if <code>type(obj) == given_class</code>:</p>
<pre class="lang-c prettyprint-override"><code>int
PyObject_IsInstance(PyObject *inst, PyObject *cls)
{
    _Py_IDENTIFIER(__instancecheck__);
    PyObject *checker;

    /* Quick test for an exact match */
    if (Py_TYPE(inst) == (PyTypeObject *)cls)
        return 1;
    .
    .
    .
}
</code></pre>
<p><a href="https://github.com/python/cpython/blob/b57b4ac042b977e0b42a2f5ddb30ca7edffacfa9/Objects/abstract.c#L2404" rel="nofollow noreferrer">From Python's source code</a></p>
</div>
<span class="comment-copy">You've tagged this python-3.x but are using the python-2.x way of using metaclasses. Did you tag this wrongly or was this a mistake?</span>
<span class="comment-copy">I guess it was a mistake, I'm using 3.x. What should I do differently?</span>
<span class="comment-copy">Use <code>class Foo(metaclass=FalseInstance):</code>. But that still doesn't cause this example to work (because of the answer already posted). It would work for a <code>TrueInstance</code> metaclass though.</span>
<span class="comment-copy">What does the your non-tuple class look like? And does it implement all tuple methods that your package requires? The only real solution I can think of to your problem is subclass tuple, but override all its methods.</span>
<span class="comment-copy">@Dunes Thanks, I adjusted the question. I now also understand why the code I provided doesn't work. However, if I now flip the example and change it so that <code>__isinstance__</code> always returns <i>True</i>, it still doesn't work the way I'd expect it to: <code>isinstance(g, int)</code> still returns <code>False</code>. What is the problem here?</span>
<span class="comment-copy">Eeeek. This is indeed horrible. I wonder if it is an implementation detail that <code>isinstance</code> is fooled by this.</span>
<span class="comment-copy">@jsbueno: I'm not sure. The standard library relies on it, notably in <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.__class__" rel="nofollow noreferrer">unittest.mock</a>, but the docs for <code>isinstance</code> and <code>__class__</code> don't mention it. The <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_IsInstance" rel="nofollow noreferrer">C API docs</a> mention it, but the C API is an implementation detail.</span>
<span class="comment-copy">This goes directly against the PEP description, so perhaps a bug. But yes, a fast path checks for direct types first before <code>__instancecheck__</code> is called.</span>
<span class="comment-copy">See <a href="https://bugs.python.org/issue35083" rel="nofollow noreferrer">this bug report</a>, there currently doesn't appear to be a consensus on whether this is a bug or documentation problem.</span>
<span class="comment-copy">Really? What's the point of even providing <b>isinstance</b> if not to change exactly this behaviour?</span>
<span class="comment-copy">it looks like in python 2.7 it did work... : <a href="https://stackoverflow.com/a/13135792/8179099">stackoverflow.com/a/13135792/8179099</a></span>
<span class="comment-copy">@Nearoo: <code>__instancecheck__</code> is primarily intended to make more <code>isinstance</code> checks pass, not less. Also, there's no <code>__isinstance__</code>.</span>
<span class="comment-copy">@user2357112 That explains it, thank you!</span>
<span class="comment-copy">@Nearoo: <i>There is no <code>__isinstance__</code>.</i> There is only <code>__instancecheck__</code>, which works in the opposite direction from what you're trying to do.</span>
