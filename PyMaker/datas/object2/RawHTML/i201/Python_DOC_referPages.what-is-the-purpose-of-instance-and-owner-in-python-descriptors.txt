<div class="post-text" itemprop="text">
<p>I am trying to understand descriptors in Python. What I can't seem to get my head around is what is the instance and owner in the descriptor method:</p>
<pre><code>object.__get__(self, instance, owner)
</code></pre>
<p>Now I have read the <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer">documentation</a> saying that:</p>
<blockquote>
<p>owner is always the owner class, while instance is the instance that the attribute was accessed through, or None when the attribute is accessed through the owner.</p>
</blockquote>
<p>Unfortuanately I am having trouble understanding what that means. Does owner refer to the class itself? The class object? Then what is the purpose of instance being passed to it?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Does owner refer to the class itself? </p>
</blockquote>
<p>Yes.</p>
<blockquote>
<p>The class object?</p>
</blockquote>
<p>This is the exact same thing. </p>
<blockquote>
<p>Then what is the purpose of instance being passed to it?</p>
</blockquote>
<p>How would the descriptor access the instance it's been looked up on else ? If you take the builtin <code>property</code> type for example, it works by storing accessor functions and calling back on those functions. Those functions expect the current instance as first argument (canonically named "self"). If the descriptor doesn't get the current instance, it obviously cannot pass it to the accessor. </p>
</div>
<div class="post-text" itemprop="text">
<p>The relationships can be illustrated by this code:</p>
<pre><code>class DescriptorClass:
    def __get__(self, instance, owner):
        return self, instance, owner

class OwnerClass:
    descr = DescriptorClass()

ownerinstance = OwnerClass()

self, instance, owner = ownerinstance.descr

assert self is OwnerClass.__dict__['descr']
assert instance is ownerinstance
assert owner is OwnerClass

self, instance, owner = OwnerClass.descr
assert instance is None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Consider this</p>
<pre><code> __get__(self, instance, owner):
</code></pre>
<p><code>owner</code> - this refers to the class where the descriptor object was created, remember descriptor objects are defined at class level.</p>
<p><code>instance</code> - this refers to the object of the class <code>owner</code> where you defined the descriptor object.</p>
<p>The purpose of passing the <code>instance</code> to the <code>__get__</code> method of the descriptor is to make sure we know and identify from which object of the <code>owner</code> class you are accessing the descriptor instance.</p>
<p>Since descriptor objects are  created at the class level, so a naive implementation of the descriptor class itself can result in having multiple objects of the <code>owner</code> class overriding the value of descriptor instance. Here is an example of such code</p>
<pre><code>def __get__(self, instance, owner):
    return self.data

def __set__(self, instance, data):
    if value &lt; 1:
        raise Exception("Negative or zero is not allowed")
    else:
        self.data = value
</code></pre>
<p>So in the above example the value of <code>data</code> is stored inside the descriptor instance only and this code will have serious side effects, if you are creating multiple objects of the <code>owner</code> class and let's say these objects are setting the value of <code>data</code>.</p>
<p>So in order to solve such a problem you would need to store the value of <code>data</code> in  <code>__dict__</code> of <code>instance</code> but how would you that if you don't have access to <code>instance</code> in the descriptor class itself ?? So as per my experience this is the primary purpose of having <code>instance</code> in the descriptor class. As a reference for solving the above mentioned problem and putting the <code>instance</code> in use, here is the code</p>
<pre><code>class DataDescriptor(object):
    def __init__(self, attribute):
        self.default = 100
        self.attribute = attribute

    def __get__(self, instance, owner):
        print('Getting the value of', self.attribute,
              '__get__ of Data descriptor invoked')
        return instance.__dict__.get(self.attribute, self.default)

    def __set__(self, instance, value=200):
        if value &gt; 0:
            print('__set__ of Data descriptor invoked')
            instance.__dict__[self.attribute] = value
        else:
            sys.exit('Negative value not allowed')
</code></pre>
</div>
<span class="comment-copy">Um, when you say "The class object", what do you mean exactly? Do you mean the class itself (<code>object</code>) or an <i>instance</i> of it?</span>
<span class="comment-copy">Then why pass both instance and class? Why not just pass one or the other?</span>
<span class="comment-copy">When the descriptor is looked up on a class, it only gets the class (it gets <code>None</code> as instance). This allow the descriptor to know it's been looked up on the class and take appropriate action.</span>
<span class="comment-copy">NB : some descriptors (the <code>function</code> type at least) also use it to check that the instance and class match.</span>
<span class="comment-copy">Why pass both class and instance? Why not just pass the instance?</span>
<span class="comment-copy">How would you access the descriptor instance if you have not instantiated your owner class?</span>
<span class="comment-copy">@ng.newbie Just checking does that answer your query ?</span>
