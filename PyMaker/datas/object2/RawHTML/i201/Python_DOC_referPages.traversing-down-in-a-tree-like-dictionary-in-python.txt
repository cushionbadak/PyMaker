<div class="post-text" itemprop="text">
<p>I have a dictionary something like this:</p>
<pre><code>{'A': [12343,
  2342349,
  {'B': [3423,
    342349283,
    73,
    {'C': [-23,
      -2342342,
      36],
     'D': [-2,
      -2520206,
      63]}],
   'E': [-1.5119711426000446,
    -1405627.5262916991,
    26.110728689275614,
    {'F': [-1.7211282679440503,
      -1601770.8149339128,
      113.9541439658396],
     'G': [0.21282003105839883,
      196143.28864221353,
      -13.954143965839597,
      {'H': [0.43384581412426826,
        399408,
        203],
       'I': [-0.22,
        -203265,
        -103]}]}]}]}
</code></pre>
<p>I want a function using which I can get values.
example, <code>traverse(dictionary,'F')</code> and it should give me the output. Couldn't found any solution. I am able to traverse 1 or two level, but not more. Either the code will break or it will not stop.</p>
<p>My Current solution which is not working is:</p>
<pre><code>def traverse(dictionary,search):
    print "Traversing"
    if isinstance(dictionary,dict):
        keys = dictionary.keys()
        print keys
        if search in keys:
            print "Found",search,"in",keys
            print "Printing found dict",dictionary
            print
            print "Check this out",dictionary.get(search)
            print "Trying to return"
            val=dictionary.get(search)
            return val
        else:
            for key in keys:
                print 'Key &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;',dictionary.get(key)
                print
                temp=dictionary.get(key)[-1]
                print "Temp &gt;&gt;&gt;&gt;&gt;&gt;&gt;",temp
                traverse(temp,search)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming there's going to be only one matching key in any of your given data structure, you can use a function that recursively traverses the dictionary looking for the key and returning its value if found, and if not found it will raise an exception, so that the calling frame can catch it and move on to the next candidate key:</p>
<pre><code>def traverse(dictionary, search):
    for k, v in dictionary.items():
        if k == search:
            return v
        if isinstance(v[-1], dict):
            try:
                return traverse(v[-1], search)
            except ValueError:
                pass
    raise ValueError("Key '%s' not found" % search)
</code></pre>
<p>so that <code>traverse(d, 'F')</code> returns (assuming your dict is stored as variable <code>d</code>):</p>
<pre><code>[-1.7211282679440503, -1601770.8149339128, 113.9541439658396]
</code></pre>
<p>On the other hand, if there can be multiple matches in the given data, you can make the function yield the value of a matching key instead so that the function becomes a generator that generates sub-lists of 0 to many matching keys:</p>
<pre><code>def traverse(dictionary, search):
    for k, v in dictionary.items():
        if k == search:
            yield v
        if isinstance(v[-1], dict):
            yield from traverse(v[-1], search)
</code></pre>
<p>so that <code>list(traverse(d, 'F'))</code> returns:</p>
<pre><code>[[-1.7211282679440503, -1601770.8149339128, 113.9541439658396]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to handle both dictionaries <em>and lists</em> to traverse your structure entirely. You currently only handle  dictionaries, but the dictionary with the <code>'F'</code> key in it is an element of a list object, so you can't find it with your method.</p>
<p>While you <em>can</em> use recursion to make use of the function call stack to track the different levels of your structure, I'd do it iteratively and use a list or <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque()</code></a> (faster for this job) to do track the objects still to process. That's more efficient and won't run into recursion depth errors for larger structures.</p>
<p>For example, walking all the elements with a generator function, then yielding each element visited, could be:</p>
<pre><code>from collections import deque

def walk(d):
    queue = deque([d])
    while queue:
        elem = queue.popleft()
        if isinstance(elem, dict):
            queue.extend(elem.values())
        elif isinstance(elem, list):
            queue.extend(elem)
        yield elem
</code></pre>
<p>The above uses a queue to process elements breath first; to use it as a stack, just replace <code>queue.popleft()</code> with <code>queue.pop()</code>.</p>
<p>You can then use the above walker to find your elements:</p>
<pre><code>def search_key(obj, key):
    for elem in walk(obj):
        if isinstance(elem, dict) and key in elem:
            return elem
</code></pre>
<p>For your dictionary, the above returns the first dictionary that contains the looked-for key:</p>
<pre><code>&gt;&gt;&gt; search_key(dictionary, 'F')
{'F': [-1.7211282679440503, -1601770.8149339128, 113.9541439658396], 'G': [0.21282003105839883, 196143.28864221353, -13.954143965839597, {'H': [0.43384581412426826, 399408, 203], 'I': [-0.22, -203265, -103]}]}
&gt;&gt;&gt; _['F']
[-1.7211282679440503, -1601770.8149339128, 113.9541439658396]
</code></pre>
<p>If you are only ever interested in the value for the given key, just return that, of course:</p>
<pre><code>def search_key(obj, key):
    for elem in walk(obj):
        if isinstance(elem, dict) and key in elem:
            return elem[key]
</code></pre>
</div>
<span class="comment-copy">Why only handle the last element in each value? What if there are more dictionaries in the lists?</span>
<span class="comment-copy">I find it reasonably apparent that the data structure that the OP is dealing with has the sub-dicts only as the last item of any sub-lists. Perhaps the OP can clarify this, but I don't want to make the code unnecessarily call <code>ifinstance</code> on every list item when the OP apparently doesn't need it.</span>
<span class="comment-copy">It's a use case actually, it is working like a tree structure where each node can have its own fixed values and/or a child node and so on. However, its structure is fixed as of now.</span>
<span class="comment-copy">I need to look into <code>deque</code> more... would have jumped straight to recursion for this question as well but a breath first approach is always good.  Thanks for the insight.</span>
