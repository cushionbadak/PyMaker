<div class="post-text" itemprop="text">
<p>In principle it is easy enough to write a wrapper for iterators, that allows arbitrary look-ahead, and some questions have been dedicated to that (e.g. <a href="https://stackoverflow.com/questions/1517862/using-lookahead-with-generators">Using lookahead with generators</a>). </p>
<p>However, given that pretty much every non-trivial file-parsing would profit from such a facility, it seems like too obvious an oversight for the standard library; Is there really no <strong><em>builtin or standard-library</em></strong> mechanism, that would allow peeking? </p>
<p>Specifically, I usually need peeking that works across function calls: A subfunction should be able to inspect an arbitrary number of upcoming elements, without removing them from the iterator â€“ essentially a queue data type, where the elements are taken lazily from an iterator. </p>
<p>In some cases, <code>collections.deque</code> or <code>itertools.tee</code> can be used to construct workarounds. For the sake of code-readability, they are however unfavorable.</p>
</div>
<div class="post-text" itemprop="text">
<p>No.</p>
<hr/>
<p>I often find myself using the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>pairwise</code> Recipe</a> to lookahead...</p>
<pre class="lang-py prettyprint-override"><code>def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

for item, peek in pairwise(iterable):
    ...
</code></pre>
<p>Or simply turn your iterable into a Sequence (if it's not already) and use indexed lookups.</p>
<pre class="lang-py prettyprint-override"><code>for index, item in enumerate(sequence):
    try:
        peek = sequence[index+1]
    except IndexError:
        peek = None
</code></pre>
</div>
<span class="comment-copy">How about no...</span>
