<div class="post-text" itemprop="text">
<p>Using Python, I would like to do the following... build a tuple of sets. However, I only want to add a set to the tuple if the set does not already exist in the tuple. Each set is a pair. I am using sets because the order of the pairs do not matter. I am using a tuple because I have over 1.5 lines of data to process and a tuple is faster to search than a list. I believe I still will need to do some list comprehension, but that is one of my questions. My first question is my code is broken, how might I fix it? My second question is, how might I improve the efficiency of the code?</p>
<p>I have simplified this example to give just the basics. Each new set will be received from the data source and processed through.</p>
<pre><code>my_tuple = ({"a", "b"}, {"c", "d"}, {"c", "e"})  # Existing tuple

new_set = {"b", "c"} # Get a set from data source

set_exists = any(new_set in a_set for a_set in my_tuple)
if not set_exists:
    my_tuple += (new_set,)

print(my_tuple)

({'a', 'b'}, {'c', 'd'}, {'c', 'e'}, {'b', 'c'})
</code></pre>
<p>That is good. The set was not in the tuple.</p>
<pre><code>new_set = {"b", "a"} # Get a set from data source

set_exists = any(new_set in a_set for a_set in my_tuple)
if not set_exists:
    my_tuple += (new_set,)

print(my_tuple)

({'a', 'b'}, {'c', 'd'}, {'c', 'e'}, {'b', 'c'}, {'a', 'b'})
</code></pre>
<p>Not good. The set already existed in the tuple. It should not have been added.</p>
<p>Thank you so much for your help.</p>
</div>
<div class="post-text" itemprop="text">
<p>The condition you should be checking is far easier than you think:</p>
<pre><code>set_exists = new_set in my_tuple
</code></pre>
<p>Your code should work with this.</p>
<p>Anyway, appending to a <code>tuple</code> is <em>slow</em>; if you are looking for performance, your approach is definitely not the best. An improvement is to use a <code>list</code>, which has very fast append operations, but like <code>tuple</code>, membership tests are also slow. In fact, contrary to your belief, <code>list</code> and <code>tuple</code> are practically equally slow when it comes to searching.</p>
<p>The solution is to use a <code>set</code> of <code>frozensets</code>:</p>
<pre><code>my_tuple = ({"a", "b"}, {"c", "d"}, {"c", "e"})

# convert to set, it's way faster!
# (this is a one-time operation, if possible, have your data in this format beforehand)
my_set = set(frozenset(s) for s in my_tuple)

# Again, if possible, get your data in the form of a frozenset so conversion is not needed
new_set = frozenset(("b", "c"))

if new_set not in my_set: # very fast!
    my_set.add(new_set)

new_set = frozenset(("a", "b"))

my_set.add(new_set) # the check is actually unneeded for sets

print(my_set)
</code></pre>
<p>Demo of speeds:</p>
<pre><code>l = list(range(10 ** 6))
t = tuple(range(10 ** 6))
s = set(range(10 ** 6))

# Appending to tuple is slow!
%timeit global t; t += (1,)
11.4 ms ± 107 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

# Appending to list is fast!
%timeit l.append(1)
107 ns ± 6.43 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

# List and tuple membership tests are slow!
%timeit 500000 in l
5.9 ms ± 83.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
%timeit 500000 in t
6.62 ms ± 281 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

# These operations are trivial for sets...
%timeit 500000 in s
73 ns ± 6.91 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should just use a set of sets, well <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer">frozenset</a> to be exact since set is not a hashable type:</p>
<pre><code>my_set = {frozenset(["a", "b"]), frozenset(["c", "d"]), frozenset(["c", "e"])}
my_set.add(frozenset(["b", "a"]))
print(my_set)
# &gt;&gt;&gt; set([frozenset(['c', 'e']), frozenset(['a', 'b']), frozenset(['c', 'd'])])
my_set.add(frozenset(["b", "z"]))
print(my_set)
# &gt;&gt;&gt; set([frozenset(['c', 'e']), frozenset(['a', 'b']), frozenset(['b', 'z']), frozenset(['c', 'd'])])
</code></pre>
</div>
<span class="comment-copy"><i>"a tuple is faster to search than a list"</i> - Just barely. Not enough to notice a performance difference. If you want fast searching, us a hash-table like structure, like a <code>set</code> or <code>dict</code> (probably <code>set</code>).</span>
<span class="comment-copy">how is the second example a problem? {"b", "a"}  is not {"a", "b"}</span>
<span class="comment-copy">I'm not an expert in performance, but you are recreating your tuple every time you add an item, this is probably slowing your code more than you gain in speed by other things</span>
<span class="comment-copy">Why don't use a set of sets instead?</span>
<span class="comment-copy">@gregory In terms of a set they are the same.</span>
<span class="comment-copy">Thank you very much. You answered both questions.However, I would not have to check to see if the new set was in the existing set, I could just add. It would not add the new set if it was already there.</span>
<span class="comment-copy">@jawik That's true, but in some cases, it can negatively affect performance. However, in other cases, it is faster. Use whichever method you choose.</span>
<span class="comment-copy">How did you run your timeit snippets? Do you mind to share? <code>%timeit</code> is invalid syntax.</span>
<span class="comment-copy">I'm not able to measure the speedup that you report using the <code>timeit</code> module from python.  I get 1.6 usec/loop for <code>if new_set not in my_tuple: my_tuple += (new_set, )</code> and 1.44 usec/loop for <code>if new_set_frozen not in my_set_frozen: my_set_frozen.add(new_set_frozen)</code>. So the speedup is there but it's not that significant.</span>
<span class="comment-copy">@darksky It's an IPython/Jupyter thing (very useful, I might add!). As for the timings, it depends on the length and exact values you are using. If the item you're looking for happens to be the first item in the tuple, well, it's going be really fast! On the other hand, checking for, say, a nonexistent item is going to be extremely slow. Contrary to tuples, sets offer all-around O(1) performance. Also, adding to a set is waaay faster than rebuilding a tuple (which is what needs to be done here), but I'm assuming the values you are using make it so that the body if the <code>if</code> is never executed.</span>
<span class="comment-copy">Thank you very much. This is actually the solution that I will use, but you did not answer both questions.</span>
<span class="comment-copy">Since we are using a set though and know that we cannot add duplicates to it, it naturally removes the complexity from this problem. Figured it answered both questions implicitly in the fewest lines possible, but as it says in The Zen of Python <code>Explicit is better than implicit.</code> Glad I could help!</span>
