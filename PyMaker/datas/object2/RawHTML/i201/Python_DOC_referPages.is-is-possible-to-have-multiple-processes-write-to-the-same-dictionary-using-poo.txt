<div class="post-text" itemprop="text">
<p>I'm using python3.6 and am trying to execute the something similar to the following code. However, after execution the variable <code>mydict</code> remains <code>{}</code></p>
<p>I've tried this with <code>global mydict</code> and without. I thought that dicts were global by default, but neither seems to work.</p>
<pre><code>mydict = {}
def TEST(hello, integer):
    global mydict
    mydict[integer] = hello
    print(integer)
with closing(Pool(processes=4)) as pool:
    pool.starmap(TEST, [['Hello World', i] for i in range(200)])
</code></pre>
<p>Is is possible to have multiple processes write to the same dictionary in python?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><em>Is is possible to have multiple processes write to the same dictionary in python?</em></p>
</blockquote>
<p>No, it's not to share dictionaries between processes because each one runs in a separate memory-space with the Python code involved being interpreted by different copies of the interpreter—although that can be done via shared memory for some other data-types. </p>
<p>However, it can be simulated by using a <a href="https://docs.python.org/3/library/multiprocessing.html#managers" rel="nofollow noreferrer"><code>multiprocessing.Manager()</code></a> to coordinate updates to certain kinds of shared objects—and one of the supported types is <code>dict</code>. </p>
<p>This is discussed in the <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">Sharing state between processes</a> section of the online documentation. Using a <code>Manager</code> involves a lot of overhead because they're run as a separate server process in parallel with any other processes your code creates.</p>
<p>Anyway, here's a working example based on the code in your question that uses one to manage concurrent updates to a shared dictionary. Since what the <code>TEST()</code> function does is so trivial, it is quite possible that doing it this way is slower than it would be <em>not</em> using <code>multiprocessing</code>, due to all the extra overhead it entails—however something like this would likely be appropriate for much more computationally-intensive tasks.</p>
<pre><code>from contextlib import closing
from multiprocessing import Pool, Manager

def TEST(mydict, hello, integer):
    mydict[integer] = hello
    print(integer)

if __name__ == '__main__':

    with Manager() as manager:
        my_dict = manager.dict()

        with closing(Pool(processes=4)) as pool:
            pool.starmap(TEST, ((my_dict, 'Hello World', i) for i in range(200)))
</code></pre>
</div>
<span class="comment-copy"><code>MultiProcessing</code> pickles to separate processes. When it does that I'm not sure it pickles the globals. It might be possible to just return the <code>integer, hello</code> values and pass those along to another starmap for processing. update see: <a href="https://stackoverflow.com/a/11056415/2026508">stackoverflow.com/a/11056415/2026508</a></span>
