<div class="post-text" itemprop="text">
<pre><code>table = [[1, 11, 111], [2, 22, 222], [3, 33, 333]]
[cell for cell in row for row in table] # Error
[cell for row in table for cell in row] # [1, 11, 111, 2, 22, 222, 3, 33, 333]
</code></pre>
<p>Intuitively, the first list comprehension makes more sense. It's moving from specific to less specific, i.e. cell -&gt; row -&gt; table. (I find this really weird about Python list comprehensions, it should be table -&gt; row -&gt; cell, but I digress.)</p>
<p>What's the logic behind cell -&gt; table -&gt; row? How does the parser see this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The for loops are meant to be the same as if you wrote them out the "normal" way:</p>
<pre class="lang-py prettyprint-override"><code>for row in table:
    for cell in row:
        print(cell)
</code></pre>
<p>So when you pull this into a list comprehension, you leave the loops as is (except for removing the ":") and just pull the final expression to the start:</p>
<pre class="lang-py prettyprint-override"><code># you can actually "abuse" list comprehensions to have short
# loops like this, even if you don't care about the list being
# generated. It's generally not a great practice though
[print(cell) for row in table for cell in row]
</code></pre>
<p>I admit it is a bit confusing when you just read the code left to right. You just have to remember to read the loops first, then the beginning statement goes at the end. I suppose it could have been implemented as </p>
<pre class="lang-py prettyprint-override"><code>[for row in table for cell in row cell]
</code></pre>
<p>but I think that looks even more confusing; it's harder to tell where the second loop ends and the statement within it starts. In the end, it's a design decision, though I'm sure some people would find the one approach or the other more intuitive.</p>
</div>
<div class="post-text" itemprop="text">
<p>I agree that your first attempt is overall more intuitive, as it more closely mimics how I and probably most people think about iterating over things from more specific to less specific.</p>
<p>The nested python list comprehension is adapted from a nested <code>for</code> loop:</p>
<pre><code>for row in table:
    for cell in row:
        cell
</code></pre>
<p>Concatenate the lines:</p>
<pre><code>for row in table: for cell in row: cell
</code></pre>
<p>Wrap it in list brackets, delete <code>:</code>, and move the repeating expression to the front:</p>
<pre><code>[cell for row in table for cell in row]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>How does the parser see this?</h1>
<p>The syntax rules for such expressions in python are called "displays". You can find the definition <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow noreferrer">here</a>.</p>
<pre><code>comprehension ::=  expression comp_for
comp_for      ::=  ["async"] "for" target_list "in" or_test [comp_iter]
comp_iter     ::=  comp_for | comp_if
comp_if       ::=  "if" expression_nocond [comp_iter]
</code></pre>
<blockquote>
<p>the elements of the new container are those that would be produced by considering each of the for or if clauses a block, <em>nesting from left to right</em>, and evaluating the expression to produce an element each time the innermost block is reached.</p>
<p>The iterable expression in the <em>leftmost</em> for clause is evaluated directly in the enclosing scope and then passed as an argument to the implictly nested scope. Subsequent for clauses and any filter condition in the leftmost for clause cannot be evaluated in the enclosing scope as they may depend on the values obtained from the leftmost iterable.</p>
</blockquote>
<p>Taking your example:</p>
<pre><code>[cell for row in table for cell in row]
</code></pre>
<p>The interpreter will break it down like this:</p>
<pre><code>expression = "cell"
comp_for1  = "for row in table" + comp_for2
comp_for2  = "for cell in row"
</code></pre>
<p>Then the interpreter will reconstruct the nested loop in heirachy</p>
<pre><code>comp_for1:
    comp_for2:
        expression
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would think that the comprehension is inside-out version of the for loop. At least I did at first. But the easiest way for me to make sense of it is to notice that you'd call a variable <strong>before it is defined</strong> in your first attempt. <code>row</code> is called before it is defined. So logically you'd get an error.</p>
<pre><code>[cell for cell in row ...]
</code></pre>
<p><em><code>row</code> is undefined</em></p>
<pre><code>[cell for row in table for cell in row]
</code></pre>
<p><em>No issues here</em></p>
</div>
<span class="comment-copy">If you take that <code>cell</code> away and read it from left to right, I think it is clear enough. I believe you treat it as <code>[(cell for cell in row) for row in table]</code> (<code>()</code> only represents execution order), but actually it works as <code>[cell ((for cell in row) for row in table)]</code>.</span>
<span class="comment-copy">This explanation sort of helps but then <code>cell</code> is also called before it is defined.</span>
<span class="comment-copy">Yes that's the only thing thing that you'd have to realize. Otherwise, it would be exactly the same as a for loop--other than the list creation.</span>
