<div class="post-text" itemprop="text">
<p>I find I am accessing Python dicts using static strings very frequently and in nested loops. I'm guessing that Python needs to hash the strings for every access, which could be impacting performance.</p>
<p>For example:</p>
<pre><code>for d in large_list_of_dicts:
    for d2 in d['trees']:
        v = d2['leaves']
</code></pre>
<p>Does Cython hash these static string keys to hash values (only once) and reuse these hashes? If so, might this significantly improve performance of such loops?</p>
</div>
<div class="post-text" itemprop="text">
<p>Cython will not perform any magic here: it will just <a href="https://github.com/cython/cython/blob/691eabf900677990b4b3b23353630b65f179ddf1/Cython/Utility/ObjectHandling.c#L333-L356" rel="nofollow noreferrer">delegate</a> the calls to <a href="https://docs.python.org/3/c-api/dict.html#c.PyDict_GetItemWithError" rel="nofollow noreferrer"><code>PyDict_GetItemWithError</code></a> - basically the same thing the Python interpreter will do (but probably slightly faster).</p>
<p>However, an unicode-object (I assume we are speaking about Python3-strings) caches its  hash-value (in <a href="https://github.com/python/cpython/blob/75e4699b31d1d88abad097ad13466c5c07711324/Include/cpython/unicodeobject.h#L164" rel="nofollow noreferrer"><code>PyUnicodeObject.hash</code>-member field</a>), so this needs to be calculated only once - which makes sense because an unicode-object is immutable, that means the hash cannot change.</p>
<p>Here is <a href="https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Objects/unicodeobject.c#L11561-L11586" rel="nofollow noreferrer">the CPython code</a> responsible for the hash calculation/caching:</p>
<pre class="lang-c prettyprint-override"><code>#define _PyUnicode_HASH(op)                             \
(((PyASCIIObject *)(op))-&gt;hash)
...

static Py_hash_t
unicode_hash(PyObject *self)
{
    ...
    // if hash already calculated, return cached value
    if (_PyUnicode_HASH(self) != -1)
        return _PyUnicode_HASH(self);
    ...
    // else caclculate hash, cache value, return it
    x = _Py_HashBytes(PyUnicode_DATA(self),
                      PyUnicode_GET_LENGTH(self) * PyUnicode_KIND(self));
    _PyUnicode_HASH(self) = x;
    return x;
}
</code></pre>
<p>So as you can see, there is no need for Cython to avoid the hash-recalculation - this optimization is already done by CPython. </p>
<p>By using Cython here, one could win up to 10-30% because it would eliminate the interpreter for this part of the code  (see for example this <a href="https://stackoverflow.com/q/46654304/5769463">SO-post</a>) - not really much, but better than nothing.</p>
</div>
<span class="comment-copy">I'm not familiar with Cython, but even in regular Python a hash will be computed for a given string object at most once - it gets cached in the object.  I can't imagine that Cython would have thrown away such a basic optimization.</span>
<span class="comment-copy">@jasonharper Thanks, I didn't realise that. So it sounds like there'd be little to gain in using Cython here.</span>
