<div class="post-text" itemprop="text">
<p>I have a long string. Of this string I have created a large set of substrings where each element may be a sub-substring of some other substring within the set. I am attempting to create a set of only the shortest substrings from my original set. Here is my attempt at a solution so far.</p>
<pre><code>string = 'ABAAABAAB'
setA = {'ABAAAB', 'BAAAB', 'AAAB', 'AAB'}
setB = setA.copy()
setC = setA.copy()
for s1 in setA:
    len1 = len(s1)
    for s2 in setB:
        len2 = len(s2)
        if s1 in s2 and len2 &gt; len1:
            setC.discard(s2)
</code></pre>
<p>I am creating a copy of my original set and iterating through the elements of <code>setA</code> then <code>setB</code>.  If one of those elements is a substring of the other element, I discard the longer element. The runtime of my solution increases greatly as the elements of <code>setA</code> increase due to use of nested loops. Is there a solution with lower time complexity?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate through <code>setA</code> from the shortest string to the longest, and add a given string to <code>setC</code> only if none of the possible substrings of the string is already in <code>setC</code>. You can generate all possible substrings from a string by iterating a starting index through the length of the string, and iterating the size of the substring from 1 to the remaining length of the string from the current starting index, and then using the starting index and the substring length to slice the string:</p>
<pre><code>setC = set()
for s in sorted(setA, key=len):
    if not any(s[i: i + n + 1] in setC for i in range(len(s)) for n in range(len(s) - i)):
        setC.add(s)
</code></pre>
<p><code>setC</code> becomes:</p>
<pre><code>{'AAB'}
</code></pre>
<p>This improves the overall time complexity from <em>O(n^2)</em> of your solution to <em>O(n log n)</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To make the substring searching algorithm @blhsing posted a little easier to read, you can just separate out the steps into their own loops. This is the same logic just not inside one line.</p>
<pre><code>setC = set()
sortedList = sorted(setA, key=len)
for substring in sortedList:
    if not substring_in_set(substring, set3):
        setC.add(substring)


# Checks whether the subtrings is in the set 
# and returns True or False
def substring_in_set(substring, set):
    for i in range(len(substring)):
        for n in range(len(substring) - i):
            if substring[i: i + n + 1] in set:
                return True
    return False
</code></pre>
</div>
<span class="comment-copy">Can you show for this example what you would like to be in <code>setC</code> at the end?   My initial thought of how to make it more efficient is to use a sorted version (maybe by length of the strings?) of <code>setA</code> stored in a list instead of keeping it as a set (unsorted).</span>
<span class="comment-copy">Sure, <code>setC</code> would be <code>{'AAB'}</code>. I'm unsure creating a list would work however, as I first created <code>setA</code> from a union of two other sets.</span>
<span class="comment-copy">From the anwer @blhsing posted you can use the <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer"><code>sorted()</code></a> function to sort a set and convert it into a list.</span>
<span class="comment-copy">Thanks so much for this answer. Do you think you could elaborate a little bit on how your code determines that none of the substrings of the string are in <code>setC</code>?</span>
<span class="comment-copy">Glad to be of help. I've added explanations to how all possible substrings are generated. Hope this helps.</span>
<span class="comment-copy">Thanks for the clarification and I appreciate the solution without using a generator function. I think the if statement should say <code>if substring[i: i + n + 1] in set:</code> instead of  <code>if substring[i: i + n + 1] in setC:</code> though.</span>
<span class="comment-copy">Ah yes thanks for pointing that out, I fixed the typo</span>
