<div class="post-text" itemprop="text">
<p>If I have a list:</p>
<pre><code>["a1", "b1", "c1", "a2", "b2", "c2", "a3", "b3", "c3"]
</code></pre>
<p>and I want to make a new list like:</p>
<pre><code>["a1", "a2", "a3", "b1", "b2", "b3", "c1", "c2", "c3"]
</code></pre>
<p>I am trying to do this in a for loop so that I'm appending to a new list in sequence:</p>
<pre><code>newlist = []
for i in oldlist:
    newlist.append(oldlist[i])
    newlist.append(oldlist[2*i])
    newlist.append(oldlist[3*i])
    i+3
</code></pre>
<p>The problem with my code is that it will append all values of <code>i</code> or <code>i*3</code> first in one go, rather than letting each <code>n</code>th version of i have a chance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could stride though the sequence with desired offsets, the use <code>itertools</code> to flatten back into a 1D list.</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; d =  ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'a3', 'b3', 'c3']
&gt;&gt;&gt; list(itertools.chain.from_iterable([d[::3], d[1::3], d[2::3]]))
['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3']
</code></pre>
<p>You could also do something similar using <code>numpy</code> by reshaping the array, transposing, then flattening again</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; d =  np.array(['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'a3', 'b3', 'c3'])
&gt;&gt;&gt; np.reshape(d, (d.size//3, 3)).T.flatten()
array(['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3'], dtype='&lt;U2')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lets say you want the interval to be n=3</p>
<pre><code>&gt;&gt;&gt; a=[1,2,3,11,22,33,111,222,333]
&gt;&gt;&gt; res=[]
&gt;&gt;&gt; n=3
&gt;&gt;&gt; for i in range(0,n):
...     for z in a[i::n]:
...         res.append(z)
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; res
[1, 11, 111, 2, 22, 222, 3, 33, 333]
</code></pre>
<p>More pythonic </p>
<pre><code>&gt;&gt;&gt; a=['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'a3', 'b3', 'c3']
&gt;&gt;&gt; res = [val for i in range(3) for val in a[i::3]]
&gt;&gt;&gt; res
['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3']
</code></pre>
<p>where <code>a[i::3]</code> just traverses the list starting from ith index in steps of 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>An interesting feature of <code>zip</code> is it's ability to group an input into groups of fixed length without explicit slicing. <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">The <code>grouper</code> recipe</a> lets you convert to groups of fixed length, which you can then unpack for another round of <code>zip</code>ing such that you pair up the first elements of each group:</p>
<pre><code>&gt;&gt;&gt; lst = ["a1", "b1", "c1", "a2", "b2", "c2", "a3", "b3", "c3", 'a4', 'b4', 'c4']  # Added three more elements so it's clear it's three groups of four, three of three being harder to see
&gt;&gt;&gt; list(zip(*[iter(lst)]*3))  # Grouped sequentially so a is first element of each group
[('a1', 'b1', 'c1'),
 ('a2', 'b2', 'c2'),
 ('a3', 'b3', 'c3'),
 ('a4', 'b4', 'c4')]

&gt;&gt;&gt; list(zip(*zip(*[iter(lst)]*3))) # Unpack and zip again to group a's with a's, b's with b's, etc.
[('a1', 'a2', 'a3', 'a4'), ('b1', 'b2', 'b3', 'b4'), ('c1', 'c2', 'c3', 'c4')]

&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; list(chain.from_iterable(zip(*zip(*[iter(lst)]*3))))  # Flatten out to single list
['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
<p>You can achieve the same result with:</p>
<pre><code>&gt;&gt;&gt; list(chain.from_iterable(lst[i::3] for i in range(3)))
['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
<p>multi-<code>zip</code> just pushes all the work to built-ins (no Python level looping at all). Plus the latter is two whole characters longer, and seems too similar to CoryKramer's answer. :-) That said, the latter is superior if your input is not of even length; <code>zip</code> stops iterating when the shortest iterable is exhausted, while <code>itertools.zip_longest</code> has to use filler values. Actual slicing and flattening avoids that issue.</p>
</div>
<span class="comment-copy">You can use <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer"><code>sorted</code></a> function to sort your list if that's your end goal.</span>
<span class="comment-copy">I never understand why something so simple deserves these atrocious looking codes thatâ€™s just a headache to look at, let alone understand.</span>
<span class="comment-copy">@darksky: :-D I'm not really recommending this approach. The code near the end (<code>chain</code>ing a generator expression producing slices) is fine, but the rest is mostly just for fun. If I were to use the earlier code, I'd use it solely after defining the <code>grouper</code> recipe, so it would look like <code>list(zip(*grouper(lst, 3))</code>, which still isn't great, but is clearly less ugly.</span>
