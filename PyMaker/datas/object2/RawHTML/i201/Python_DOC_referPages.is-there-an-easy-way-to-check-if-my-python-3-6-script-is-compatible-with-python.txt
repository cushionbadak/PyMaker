<div class="post-text" itemprop="text">
<p>I am looking for a way to test whether code developed in Python 3.6 will be compatible with Python 2.7. Ideally - if not I would like to have the invalid syntax pointed out in some way. Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes. Execute your code with <code>python2.7 yourScript.py</code>. If some modules need python3.*, you could write a second script only for python2.7? Hacky but it's the quick and lazy solution.</p>
<p>You should definitely check the version on startup. This snippet restartes the script automatically with the right version:</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# pythonVersionCheck.py

import sys
import os

# Color codes for output
CRED = '\033[91m'
CGREEN = '\033[92m'
CEND = '\033[0m'

# Desired python version number
scriptVersion = "3.6"

# Check if script is executed with root. Get rid of this block if you don't need it
if os.geteuid() != 0:
    print(CRED + "\nRestart the script with root privileges: 'sudo python" 
    + scriptVersion + " " + sys.argv[0] + "'\n" + CEND)
    sys.exit(0)

# Check if the script is running with the desired python version
if sys.version[:3] == scriptVersion:
    print(CGREEN + "Script running with Python " + scriptVersion + CEND)
else:
    print(CRED + "Script not running with Python " + scriptVersion + ". Restarting." + CEND)
    try:
         os.execv(sys.executable, ['python' + scriptVersion] + sys.argv)
    except OSError as error:
        print(CRED + "An error occured: " + str(error) + CEND)

# YOUR CODE HERE
</code></pre>
<p>Read up on portability between Python2.* and Python3.* <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">here</a>.</p>
<p><strong>EDIT:</strong> As suggested by @MisterMiyagi, here some changes.</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# pythonVersionCheck.py

import sys
import subprocess
import platform

# Desired python version number
scriptVersion = "2.7"
usedVersion = "{0}.{1}".format(sys.version_info.major,sys.version_info.minor)
opSys = platform.system()

# Check if the script is running with the desired python version
if usedVersion == scriptVersion:
    print("Script running with Python " + scriptVersion)
else:
    print("Script not running with Python " + scriptVersion + ". Restarting.")
    if opSys == 'Linux' or opSys == 'Darwin':
        subprocess.call('python' + scriptVersion + ' ' + sys.path[0] + '/' +
        sys.argv[0], shell=True)
    elif opSys is 'Windows':
        print("py -" + scriptVersion + ' ' + sys.argv[0])
        subprocess.call("py -" + scriptVersion + ' ' + sys.argv[0], shell=True)
    else:
        print("Can't detect os.")

# YOUR CODE HERE
</code></pre>
<p>It now uses <code>subprocess</code> instead of <code>os.execv</code>.
It now uses <code>sys.version_info</code> instead of <code>sys.version</code>.
It now checks what platform the user runs so now it is portable to Linux, Windows and Appletoshwin.</p>
</div>
<span class="comment-copy">There’s no way to provide a guarantee. The hard parts aren’t syntax.</span>
<span class="comment-copy">If <code>3to2</code> produces an identical script, chances are.</span>
<span class="comment-copy">aside from syntax or features that 2 vs 3 may have different or missing, testing is what you should involve in your development cycle. Then you will know. Also  static analysis would help.</span>
<span class="comment-copy">In how far is the obvious "just run it with 2.7" not sufficient for your use case? Do you care only about syntax, or the standard library as well?</span>
<span class="comment-copy">Asking just out of curiosity, is there a reason why you write <code>str("3.6")</code> instead of just <code>"3.6"</code>? Does it help anything, is it a convention of any kind, or just a personal habit?</span>
<span class="comment-copy">Thanks for pointing it out. It doesn't matter in this case, you're absolutely right! <code>&gt;&gt;&gt; scriptVersion = str("3.6") &gt;&gt;&gt; type(scriptVersion) &lt;class 'str'&gt; &gt;&gt;&gt; scriptVersion = "3.6" &gt;&gt;&gt; type(scriptVersion) &lt;class 'str'&gt;</code></span>
<span class="comment-copy">Please don't handle portability like this! 1) It is UNIX only, not a chance on Windows. 2) It works for PATH lookups only, without taking into account virtual environments and the like. 3) Missing privileges is an error, exit code 0 is inappropriate. 4) It does not (and cannot) check whether the user explicitly requested a different Python version. 5) It will refuse to run on compatible versions, such as 3.7, 3.8, .... 6). 6) Using <code>sys.version</code> and <code>os.execv</code> is archaic for this problem. Use <code>sys.version_info</code> and <code>subprocess</code>. Do not do custom error handling that swallows details.</span>
<span class="comment-copy">@MisterMiyagi Thanks for the criticism. I don't know how to take virtual envs into account and for #4, I think the goal was to set a version number that should be used for the script so the user will automatically run the right one. I will post the edit with <code>sys.version_info</code> and <code>subprocess</code> in a minute. Do you mind to explain why using those is better?</span>
<span class="comment-copy">@anonjnr sys.version_info provides a namedtuple, so you can actually do a numerical major/minor/patch comparison. sys.version_info[:3] &gt;= (3,6,0) would support 3.6, 3.7, and so on, even a hypothetical 3.10 and beyond. subprocess does proper creation, teardown and error handling.</span>
