<div class="post-text" itemprop="text">
<p>I'm developing an ABtest framework using django. I want to assign variant number based on bucket_id from cookies' request.</p>
<p>bucket_id is set by the front end with a range integer from 0-99.</p>
<p>So far, I have created the function name get_bucket_name:</p>
<pre><code>def get_bucket_range(data):

    range_bucket = []
    first_val = 0
    next_val = 0

    for i, v in enumerate(data.split(",")):
        v = int(v)
        if i == 0:
            first_val = v
            range_bucket.append([0, first_val])
        elif i == 1:
            range_bucket.append([first_val, first_val + v])
            next_val = first_val + v
        else:
            range_bucket.append([next_val, next_val + v])
            next_val = next_val + v

    return range_bucket
</code></pre>
<p>Data input for get_bucket_range is a comma delineated string which means we have 3 variants where each variant has its own weight e.g.  data = "25,25,50" with first variant's weight being 25 etc.</p>
<p>I then created a function to assign the variant named, </p>
<pre><code>def assign_variant(range_bucket, num):
    for i in range(len(range_bucket)):
        if num in range(range_bucket[i][0], range_bucket[i][1]):
            return i
</code></pre>
<p>This function should have 2 parameters, range_bucket -&gt; from get_bucket_range function, and num -&gt; bucket_id from cookies.</p>
<p>With this function I can return which bucket_id belongs to the variant id.</p>
<p>For example, we have 25 as bucket_id, with data = "25,25,50". This means our bucket_id should belong to variant id 1. Or in the case that we have 25 as bucket_id,  with data = "10,10,10,70". This should mean that our bucket_id will belong to variant id 2.</p>
<p>However, it feels like neither of my functions are pythonic or optimised. Does anyone here have any suggestions as to how I could improve my code?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your functions could look like this for example:</p>
<pre><code>def get_bucket_range(data):
    last = 0
    range_bucket = []
    for v in map(int, data.split(',')):
        range_bucket.append([last, last+v])
        last += v
    return range_bucket

def assign_variant(range_bucket, num):
    for i, (low, high) in enumerate(range_bucket):
        if low &lt;= num &lt; high:
            return i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can greatly reduce the lengths of your functions with the <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">itertools.accumulate</a> and <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect" rel="nofollow noreferrer">bisect.bisect</a> functions. The first function accumulates all the weights into sums (<code>10,10,10,70</code> becomes <code>10,20,30,100</code>), and the second function gives you the index of where that element would belong, which in your case is equivalent to the index of the group it belongs to.</p>
<pre class="lang-py prettyprint-override"><code>from itertools import accumulate
from bisect import bisect

def get_bucket_range(data):
    return list(accumulate(map(int, data.split(',')))

def assign_variant(range_bucket, num):
    return bisect(range_bucket, num)
</code></pre>
</div>
