<div class="post-text" itemprop="text">
<p>I have found that comparing the results of the <code>keys()</code> and <code>values()</code> methods of the <code>dict</code> built-in to themselves results in inconsistent results:</p>
<pre><code>instance = {'one': 1}

instance.values() == instance.values() # Returns False
instance.keys() == instance.keys()     # Returns True
</code></pre>
<p>Running the above code in Python 2.7 will return True for both calls, leading me to believe that there is some implementation detail in Python 3's <code>dict_values</code> that causes this strange behaviour.</p>
<p>Is there a reason for this behaviour or have i stumbled upon some obscure bug?</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer: <code>class dict_values</code> doesn't have a <code>__eq__</code> method implemented, but <code>class dict_keys</code> does:</p>
<pre><code>&gt;&gt;&gt; d.values().__eq__(d.values())
NotImplemented
&gt;&gt;&gt; d.keys().__eq__(d.keys())
True
</code></pre>
<p>Therefore, the <code>d.values()</code>'s <code>==</code> comparison evaluates to <code>False</code>.</p>
<p>The longer answer of <em>why</em> it wasn't implemented is a different one and can be seen with a little more digging on <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">the documentation of dict-view objects</a>.  This part seems especially relevant (emphasis mine):</p>
<blockquote>
<p><strong>Keys views are set-like since their entries are unique and hashable</strong>.
  If all values are hashable, so that (key, value) pairs are unique and
  hashable, then the items view is also set-like. (Values views are not
  treated as set-like since the entries are generally not unique.) For
  set-like views, all of the operations defined for the abstract base
  class <code>collections.abc.Set</code> are available <strong>(for example, <code>==</code>, <code>&lt;</code>, or <code>^</code>)</strong>.</p>
</blockquote>
<p>Since keys must be unique, it makes sense that they are set-like and are supported with the class operations of <code>collections.Set</code>.  Values are not set-like due to non-uniqueness.</p>
<p>In Python 2.7 however, <code>d.keys()</code> and <code>d.values()</code> <em>both</em> return a <a href="https://docs.python.org/2/library/stdtypes.html#dict.items" rel="noreferrer"><code>list</code> per the documentation</a> therefore this restriction does not apply.  Since they are both the same type of object, it makes sense the same operation will work on both.  If you used <code>viewkeys</code> and <code>viewvalues</code> <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">as mentioned in the documentation of dict-view objects in Python2.7</a>, then you can expect similar behaviour:</p>
<pre><code># Python 2.7
from collections import Set
# in Python 3.x this would be from collections.abc import Set

d = {"one": 1}

print isinstance(d.viewkeys(), Set)
# True

print isinstance(d.viewvalues(), Set)
# False

print d.viewkeys() == d.viewkeys()
# True

print d.viewvalues() == d.viewvalues()
# False
</code></pre>
</div>
<span class="comment-copy">This seems to be interesting as I just checked <code>id</code> of two values and they are same as well still <code>==</code> is returning <code>False</code>. I believe one has to dig a bit more in the source code to find the reason for it.</span>
<span class="comment-copy">Don't know the answer, but it can be simplified to <code>d.values() == d.values()</code> is false.</span>
<span class="comment-copy">Good catch, I'll edit my question to be more general.</span>
<span class="comment-copy">OP: I updated the answer with more info on why Python2.7 behaves differently since you accepted.  Please check back if you have time.</span>
<span class="comment-copy">I suppose it's possible that on Python 2 two different dict objects with the same keys might return them in a different order, whereas the documentation implies that on Python 3 the order of keys is ignored during comparisons.</span>
