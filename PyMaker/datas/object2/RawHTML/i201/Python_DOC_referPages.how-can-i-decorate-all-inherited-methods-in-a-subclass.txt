<div class="post-text" itemprop="text">
<pre><code>class Reader:
    def __init__(self):
        pass

    def fetch_page(self):
        with open('/dev/blockingdevice/mypage.txt') as f:
            return f.read()

    def fetch_another_page(self):
        with open('/dev/blockingdevice/another_mypage.txt') as f:
            return f.read()   

class Wrapper(Reader):
    def __init__(self):
        super().__init__()

    def sanity_check(func):
        def wrapper():
            txt = func()
            if 'banned_word' in txt:
                raise Exception('Device has banned word on it!')
        return wrapper

    @sanity_check
    &lt;how to automatically put this decorator on each function of base class? &gt;

w = Wrapper()
w.fetch_page()
w.fetch_another_page()
</code></pre>
<p>How can I make sure that <code>sanity_check</code>'s <code>wrapper</code> was run automatically when calling <code>fetch_page</code> and <code>fetch_another_page</code> on an instance of the <code>Wrapper</code> class?</p>
</div>
<div class="post-text" itemprop="text">
<p>If using python3.6 or above, you can accomplish this using <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer"><code>__init_subclass__</code></a></p>
<p>Simple implementation: (for the real thing you probably want a registry and <a href="https://docs.python.org/3.6/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a>, etc):</p>
<pre><code>class Reader:
    def __init_subclass__(cls):
        cls.fetch_page = cls.sanity_check(cls.fetch_page)
        cls.fetch_another_page = cls.sanity_check(cls.fetch_another_page)

    def fetch_page(self):
        return 'banned_word'

    def fetch_another_page(self):
        return 'not a banned word'

class Wrapper(Reader):
    def sanity_check(func):
        def wrapper(*args, **kw):
            txt = func(*args, **kw)
            if 'banned_word' in txt:
                raise Exception('Device has banned word on it!')
            return txt
        return wrapper


</code></pre>
<p>Demo:</p>
<pre><code>In [55]: w = Wrapper()

In [56]: w.fetch_another_page()
Out[56]: 'not a banned word'

In [57]: w.fetch_page()
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
&lt;ipython-input-57-4bb80bcb068e&gt; in &lt;module&gt;()
----&gt; 1 w.fetch_page()
...

Exception: Device has banned word on it!
</code></pre>
<p>Edit:In case you can't change the baseclass, you can subclass and create an Adapter class:</p>
<pre><code>class Reader:

    def fetch_page(self):
        return 'banned_word'

    def fetch_another_page(self):
        return 'not a banned word'

class ReadAdapter(Reader):
    def __init_subclass__(cls):
        cls.fetch_page = cls.sanity_check(cls.fetch_page)
        cls.fetch_another_page = cls.sanity_check(cls.fetch_another_page)

class Wrapper(ReadAdapter):
    def sanity_check(func):
        def wrapper(*args, **kw):
            txt = func(*args, **kw)
            if 'banned_word' in txt:
                raise Exception('Device has banned word on it!')
            return txt
        return wrapper

</code></pre>
<p>Should provide the same result. </p>
</div>
<div class="post-text" itemprop="text">
<p>There's no easy way to do what you want from within the <code>Wrapper</code> subclass. You either need to name each method of the base class that you want to wrap with a decorator, modify the <code>Wrapper</code> class after you create it (perhaps with a class decorator), or you need to redesign the base class to help you out.</p>
<p>One relatively simple redesign would be for the base class methods to be decorated with a decorator that makes them always call a "validator" method. In the base class the validator can be a no-op, but a child class could override it to do whatever you want:</p>
<pre><code>class Base:
    def sanity_check(func):
        def wrapper(self, *args, **kwargs):
            return self.validator(func(self, *args, **kwargs))
        return wrapper

    def validator(self, results):   # this validator accepts everything
        return results

    @sanity_check
    def foo(self):
        return "foo"

    @sanity_check
    def bar(self):
        return "bar"

class Derived(Base):
    def validator(self, results):   # this one doesn't like "bar"
        if results == "bar":
            raise Exception("I don't like bar")
        return results

obj = Derived()
obj.foo() # works
obj.bar() # fails to validate
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution for this:</p>
<pre><code>class SubClass(Base):
    def __init__(self, *args, **argv):
        super().__init__(*args, **argv)

        for attr_name in Base.__dict__:
            attr = getattr(self, attr_name)
            if callable(attr):
                setattr(self, attr_name, functools.partial(__class__.sanity_check, attr))

    @classmethod
    def sanity_check(func):
        txt = func()
        if 'banned_word' in txt:
            raise Exception('Device has banned word on it!')
        return txt
</code></pre>
<p>This will only work if you want to process each function in your Base with sanity_check.</p>
</div>
<span class="comment-copy">I just edited the question to use more meaningful terminology for what you're asking about. Context managers had nothing to do with your question, except in a minor way (you're using files as context managers in <code>Reader</code>). I think you wanted the term <code>decorator</code> instead. If I've changed too much and the question doesn't match what you want to know, please <a href="https://stackoverflow.com/posts/55013817/edit">edit</a> the question yourself to correct my misunderstandings.</span>
<span class="comment-copy">Looks like a great solution. The only problem is, it requires that we can edit the base class. It will be hard if base class is in some external library.</span>
<span class="comment-copy">@hasanatkazmi you can subclass into an adapter class. Added another example.</span>
