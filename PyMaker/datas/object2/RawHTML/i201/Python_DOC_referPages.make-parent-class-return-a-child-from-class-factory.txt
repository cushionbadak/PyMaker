<div class="post-text" itemprop="text">
<p>I have a parent class, and I want to make it so that I can return its children from a class factory, here's some code:</p>
<pre class="lang-py prettyprint-override"><code>class Super:
    def __new__(cls, t):
        return class_factory(t)

# Because I need a Super class with some custom state
def class_factory(t):
    class Sub(Super):
        t = t

        def __init__(self):
            pass

    return Sub

assert isinstance(Super(1)(), Super)
</code></pre>
<p>I get the following error:</p>
<pre><code>TypeError: __new__() missing 1 required positional argument: 't'
</code></pre>
<p>I get that its trying to call <code>Super</code>'s <code>__new__</code> method. Is there a way to skip that, or at least preserve the type signature in a way that doesn't cause infinite recursion? (I <em>need</em> to preserve the type signature of both classes).</p>
</div>
<div class="post-text" itemprop="text">
<p>When I run your code I get a different error, namely:</p>
<p>    <code>NameError: name 't' is not defined</code> </p>
<p>on the <code>t = t</code> line.</p>
<p>This is because the body of a <code>class</code> statement is executed in its own namespace, so the <code>t</code> in the enclosing namespace isn't in scope as it usually is. Another issue is that your <code>__new__()</code> doesn't call its base class' <code>__new__()</code>.</p>
<p>Lastly, the call to <code>Super(1)()</code> is wrong. Calling a class returns an instance of the class (or in this case, an instance of a subclass).</p>
<p>To fix all of these problems and get your code to work, you could need to do it like this:</p>
<pre><code>class Super:
    def __new__(cls, t):
        subclass = class_factory(t)   # Create subclass.
        return super().__new__(subclass)  # Using base class method to avoid recursion.


def class_factory(t_arg):
    class Sub(Super):
        t = t_arg

        def __init__(self, t):
            pass

    return Sub

# Note Super(1) returns an instance of the subclass.
assert isinstance(Super(1), Super)
</code></pre>
<p><strong>Update:</strong></p>
<p>Based on your comments, I would suggest using a class decorator instead. 
— something like this:</p>
<pre><code>def inject(name, value):

    def decorator(cls):
        setattr(cls, name, value)
        return cls

    return decorator


@inject('t', 42)
class Test:
    def __init__(self):
        print(self.t)


assert isinstance(Test(), Test)  # -&gt; 42
</code></pre>
<p>This doesn't create subclasses, however you could change the name of the decorated class if you wished.</p>
</div>
<div class="post-text" itemprop="text">
<p>This may work:</p>
<pre><code>class Super:
    def __new__(cls, t):
        return class_factory(t)

def class_factory(t):
    class Sub(Super):
        _tp = t
        def __new__(cls, *args, **kwargs):
            instance = object.__new__(cls)
            return instance

        def __init__(self, *args, **kwargs):
            pass

    return Sub
</code></pre>
<p>To avoid the error you need to define your custom <code>__new__()</code> method in <code>Sub</code>, so you can avoid to recursively call <code>Super</code>'s <code>__ new__()</code> method.<br/>
The type is preserverd in the <code>_tp</code> class attribute of <code>Sub</code>.</p>
<p>With this code, the <code>assert isinstance(Super(1)(), Super)</code> does not raise any error.</p>
<h3>EDIT after comment</h3>
<p>Fixed <code>*args</code> and <code>**kwargs</code>. The rule is that whatever argument signature you have in <code>Sub.__init__()</code> must be used also by <code>Sub.__new__()</code>. For example, if you need <code>Sub.__init__(self, a, b)</code> then you should have <code>Sub.__new__(cls, a, b)</code>.</p>
</div>
<span class="comment-copy">If <code>Super</code> is supposed to be a class factory, it should be a <a href="https://docs.python.org/3/glossary.html#term-metaclass" rel="nofollow noreferrer">metaclass</a>. Not a parent class.</span>
<span class="comment-copy">Calling a class should return an instance of that class. Not another class. Why do you think you have to break this fundamental expectation of OOP? Do you have a <i>very</i> good reason?</span>
<span class="comment-copy">Basically, for a metaclass, I'd have to do <code>isinstance(type(x), metaclass)</code> instead of <code>isinstance(x, superclass)</code>.</span>
<span class="comment-copy">How about something like <code>isinstance(Meta(1)(), Super)</code>? Any problems with that?</span>
<span class="comment-copy">I can't instantiate using <code>Super</code> that way, I already have that working. I prefer <code>Super(1)</code> to be <code>Meta(1)()</code>, and <code>Super in type(Meta(1)()).__bases__</code>.</span>
<span class="comment-copy">Excellent explanation! One minor comment, could you change <code>object</code> to <code>super()</code>?</span>
<span class="comment-copy">Is there a way to do this while keeping the <code>Sub</code> signature the same?</span>
<span class="comment-copy">Thanks. I think generally <code>__new__</code> and the class constructor need to have the same signature, but there may be a workaround. I'll look into it.</span>
<span class="comment-copy">I can't think of a way to avoiding it using this approach. It could be done by defining a custom metaclass (instead of using the default one, <code>type</code>) which is what happens here.</span>
<span class="comment-copy">I currently just resorted to checking and subsequently discarding the <code>t</code> argument.</span>
<span class="comment-copy">This doesn't work: <code>object.__new__() takes no arguments</code>, and if I change it to <code>object.__new__(cls)</code> then <code>__init__</code> signature has to change, which I don't want to do.</span>
<span class="comment-copy">I fixed my answer. But I have to say, the class decorator in @martineau 's answer is the most elegant solution in my opinion.</span>
