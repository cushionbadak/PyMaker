<div class="post-text" itemprop="text">
<p>I've got this basic python3 server but can't figure out how to serve a directory.</p>
<pre><code>class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            print(self.path)
            if self.path == '/up':
                self.send_response(200)
                self.end_headers()
                self.wfile.write(b'Going Up')
            if self.path == '/down':
                self.send_response(200)
                self.end_headers()
                self.wfile.write(B'Going Down')

httpd = socketserver.TCPServer(("", PORT), SimpleHTTPRequestHandler)
print("Server started on ", PORT)
httpd.serve_forever()
</code></pre>
<p>If Instead of the custom class above, I simply pass <code>Handler = http.server.SimpleHTTPRequestHandler</code> into TCPServer():, the default functionality is to serve a directory, but I want to serve that directory and have functionality on my two GETs above.</p>
<p>As an example, if someone were to go to localhost:8080/index.html, I'd want that file to be served to them</p>
</div>
<div class="post-text" itemprop="text">
<p>if you are using 3.7, you can simply serve up a directory where your html files, eg. index.html is still</p>
<pre><code>python -m http.server 8080 --bind 127.0.0.1 --directory \your_directory\
</code></pre>
<p>for the <a href="https://docs.python.org/3/library/http.server.html" rel="nofollow noreferrer">docs</a></p>
</div>
<div class="post-text" itemprop="text">
<h2>The simple way</h2>
<p>You want to <em>extend</em> the functionality of <code>SimpleHTTPRequestHandler</code>, so you <strong>subclass</strong> it! Check for your special condition(s), if none of them apply, call <code>super().do_GET()</code> and let it do the rest.</p>
<p>Example:</p>
<pre><code>class MyHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/up':
            self.send_response(200)
            self.end_headers()
            self.wfile.write(b'up')
        else:
            super().do_GET()
</code></pre>
<h2>The long way</h2>
<p>To serve files, you basically just have to open them, read the contents and send it.
To serve directories (indexes), use <code>os.listdir()</code>. (If you want, you can when receiving directories first check for an index.html and then, if that fails, serve an index listing).</p>
<p>Putting this into your code will give you:</p>
<pre><code>class MyHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        print(self.path)
        if self.path == '/up':
            self.send_response(200)
            self.end_headers()
            self.wfile.write(b'Going up')
        elif os.path.isdir(self.path):
            try:
                self.send_response(200)
                self.end_headers()
                self.wfile.write(str(os.listdir(self.path)).encode())
            except Exception:
                self.send_response(500)
                self.end_headers()
                self.wfile.write(b'error')
        else:
            try:
                with open(self.path, 'rb') as f:
                    data = f.read()
                self.send_response(200)
                self.end_headers()
                self.wfile.write(data)
            except FileNotFoundError:
                self.send_response(404)
                self.end_headers()
                self.wfile.write(b'not found')
            except PermissionError:
                self.send_response(403)
                self.end_headers()
                self.wfile.write(b'no permission')
            except Exception:
                self.send_response(500)
                self.end_headers()
                self.wfile.write(b'error')
</code></pre>
<p>This example has a lot of error handling. You might want to move it somewhere else.
The problem is <strong>this serves from <em>your root</em> directory</strong>. To stop this, you'll have to (easy way) just add the serving directory to the beginning of <code>self.path</code>. Also check if <code>..</code> cause you to land higher than you want. A way to do this is <code>os.path.abspath(serve_from+self.path).startswith(serve_from)</code></p>
<p>Putting this inside (after the check for /up):</p>
<pre><code>class MyHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        print(self.path)
        path = serve_from + self.path
        if self.path == '/up':
            self.send_response(200)
            self.end_headers()
            self.wfile.write(b'Going up')
        elif not os.path.abspath(path).startswith(serve_from):
            self.send_response(403)
            self.end_headers()
            self.wfile.write(b'Private!')
        elif os.path.isdir(path):
            try:
                self.send_response(200)
                self.end_headers()
                self.wfile.write(str(os.listdir(path)).encode())
            except Exception:
                self.send_response(500)
                self.end_headers()
                self.wfile.write(b'error')
        else:
            try:
                with open(path, 'rb') as f:
                    data = f.read()
                self.send_response(200)
                self.end_headers()
                self.wfile.write(data)
            # error handling skipped
            except Exception:
                self.send_response(500)
                self.end_headers()
                self.wfile.write(b'error')
</code></pre>
<p>Note you define <code>path</code> and use it subsequently, otherwise you will still serve from /</p>
</div>
<span class="comment-copy">Please <i>always</i> use a generic [python] tag for any Python question. Use a version-specific tag if your question is version specific. Generally, on the python tag, it is assumed you are using Python 3.</span>
