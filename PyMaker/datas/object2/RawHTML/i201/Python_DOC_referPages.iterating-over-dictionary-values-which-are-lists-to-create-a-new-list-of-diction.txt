<div class="post-text" itemprop="text">
<p>I have a dictionary with keys 'Title', 'Author', 'Publication Year', with values that are lists:</p>
<pre><code>book_dict= {'Titles': ['Double Play', 'Slow Burn', 'Altman Code'], 'Authors': ['Brown, Dan', 'Hannah, Kristin', 'Neri, Penelope'], 
'Publication Year': [2004, 2003, 2006]}
</code></pre>
<p>The position of each entry in the list correspond to each other, such that <code>book_dict['Titles'][0]</code> and <code>book_dict['Authors'][0]</code> are information about the same book. (note: these are actual names of books and authors, but in reality do not correspond to each other)</p>
<p>I would like to create a list containing dictionaries like this:</p>
<pre><code>[{"Title":"Double Play","Author":"Brown, Dan", "Publication Year":2004}, 
{"Title":"Slow Burn","Author":"Hannah, Kristin", "Publication Year":2003},
{"Title":"Altman Code","Author":"Neri, Penelope'", "Publication Year":2006}]
</code></pre>
<p>So far I have tried this:</p>
<pre><code>for i in range(30):
    for k,v in book_dict.items():
        print({k[i]:v[i]})
</code></pre>
<p>But I get this instead:</p>
<pre><code>{"Title":"Double Play"}
{"Author":"Brown, Dan"}
{"Publication Year":2004}
{"Title":"Slow Burn"}
{"Author":"Hannah, Kristin"}
{"Publication Year":2003}
{"Title":"Altman Code"}
{"Author":"Neri, Penelope"} 
{"Publication Year":2006}
</code></pre>
<p>Plus an <code>IndexError: list index out of range</code></p>
</div>
<div class="post-text" itemprop="text">
<p>A generic approach without needing to hard-code the keys is to iterate over zipped values of the dict and zip the dict keys with the zipped values to build sub-dicts with the dict constructor:</p>
<pre><code>[dict(zip(book_dict, t)) for t in zip(*book_dict.values())]
</code></pre>
<p>This returns:</p>
<pre><code>[{'Titles': 'Double Play', 'Authors': 'Brown, Dan', 'Publication Year': 2004},
 {'Titles': 'Slow Burn', 'Authors': 'Hannah, Kristin', 'Publication Year': 2003},
 {'Titles': 'Altman Code', 'Authors': 'Neri, Penelope', 'Publication Year': 2006}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You will have to use some variant of <code>zip</code> on the values of the original  dict:</p>
<pre><code>&gt;&gt;&gt; [{'Title': t, 'Author': a, 'Publication Year': y} for t, a, y in zip(book_dict['Titles'], book_dict['Authors'], book_dict['Publication Year'])]
[{'Title': 'Double Play', 'Author': 'Brown, Dan', 'Publication Year': 2004}, 
 {'Title': 'Slow Burn', 'Author': 'Hannah, Kristin', 'Publication Year': 2003}, 
 {'Title': 'Altman Code', 'Author': 'Neri, Penelope', 'P
ublication Year': 2006}]
</code></pre>
<p>You might use some utils to make it more readable:</p>
<pre><code>from  operator import itemgetter

items = itemgetter('Titles', 'Authors', 'Publication Year')
[
    {'Title': t, 'Author': a, 'Publication Year': y} 
    for t, a, y in zip(*items(book_dict))
]
# [{'Title': 'Double Play', 'Author': 'Brown, Dan', 'Publication Year': 2004}, 
#  {'Title': 'Slow Burn', 'Author': 'Hannah, Kristin', 'Publication Year': 2003}, 
#  {'Title': 'Altman Code', 'Author': 'Neri, Penelope', 'Publication Year': 2006}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this :</p>
<pre><code>[{k : book_dict[k][j] for k in book_dict} for j in range(len(book_dict['Titles']))]
</code></pre>
<p><strong>OUTPUT</strong> :</p>
<pre><code>[{'Titles': 'Double Play', 'Authors': 'Brown, Dan', 'Publication Year': 2004}, {'Titles': 'Slow Burn', 'Authors': 'Hannah, Kristin', 'Publication Year': 2003}, {'Titles': 'Altman Code', 'Authors': 'Neri, Penelope', 'Publication Year': 2006}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>zip()</code> to iterate over multiple lists in lockstep, such as in </p>
<pre><code>result = []
for title, author, year in zip(book_dict['Titles'], book_dict['Authors'],     
book_dict['Publication Year']):
    result.append({'Title': title, 'Author': author, 'Year': year})

print result
</code></pre>
</div>
<span class="comment-copy">Will it work in Python 3.6 and below?</span>
<span class="comment-copy">Yes it will, because even though the key order of dicts is not guaranteed in earlier versions of Python, the values always follow the same order as the keys, so zipping the key list and value list will always produce consistently correct pairings.</span>
<span class="comment-copy">@blhsing any idea why <code>dict(zip(book_dict, t))</code> suffices to get the dict keys? <code>dict(zip(book_dict.keys(), t))</code> seems to yield the same result.</span>
<span class="comment-copy">@MarielleDado This is because a dict object, when used as an iterable, yields its keys from the generator, so a call to the <code>keys()</code> method is unnecessary. Please refer to the <code>iter(d)</code> section of the <a href="https://docs.python.org/3/library/stdtypes.html#typesmapping" rel="nofollow noreferrer">dict's documentation</a>.</span>
<span class="comment-copy">@MarielleDado <code>t</code>'s value comes from the output of <code>zip(*book_dict.values())</code>, which with your sample input pairs each item in <code>['Double Play', 'Slow Burn', 'Altman Code']</code> and in <code>['Brown, Dan', 'Hannah, Kristin', 'Neri, Penelope']</code> to form a sequence of <code>(('Double Play', 'Brown, Dan'), ('Slow Burn', 'Hannah, Kristin'), ('Altman Code', 'Neri, Penelope'))</code>. The unpack operator <code>*</code> is needed to make the items in <code>book_dict.values()</code> separate arguments for <code>zip</code> since <code>zip</code> expects to take several iterables for zipping.</span>
