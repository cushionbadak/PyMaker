<div class="post-text" itemprop="text">
<p>I'm trying to write a function in python that is like:</p>
<pre><code>def repeated(f, n):
    ...
</code></pre>
<p>where <code>f</code> is a function that takes one argument and <code>n</code> is a positive integer.</p>
<p>For example if I defined square as:</p>
<pre><code>def square(x):
    return x * x
</code></pre>
<p>and I called</p>
<pre><code>repeated(square, 2)(3)
</code></pre>
<p>this would square 3, 2 times.</p>
</div>
<div class="post-text" itemprop="text">
<p>That should do it:</p>
<pre><code> def repeated(f, n):
     def rfun(p):
         return reduce(lambda x, _: f(x), xrange(n), p)
     return rfun

 def square(x):
     print "square(%d)" % x
     return x * x

 print repeated(square, 5)(3)
</code></pre>
<p>output:</p>
<pre><code> square(3)
 square(9)
 square(81)
 square(6561)
 square(43046721)
 1853020188851841
</code></pre>
<p>or <code>lambda</code>-less?</p>
<pre><code>def repeated(f, n):
    def rfun(p):
        acc = p
        for _ in xrange(n):
            acc = f(acc)
        return acc
    return rfun
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>reduce</code> and lamba.
Build a tuple starting with your parameter, followed by all functions you want to call:</p>
<pre><code>&gt;&gt;&gt; path = "/a/b/c/d/e/f"
&gt;&gt;&gt; reduce(lambda val,func: func(val), (path,) + (os.path.dirname,) * 3)
"/a/b/c"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like this?</p>
<pre><code>def repeat(f, n):
     if n==0:
             return (lambda x: x)
     return (lambda x: f (repeat(f, n-1)(x)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you want function composition:</p>
<pre><code>def compose(f, x, n):
  if n == 0:
    return x
  return compose(f, f(x), n - 1)

def square(x):
  return pow(x, 2)

y = compose(square, 3, 2)
print y
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a recipe using <code>reduce</code>:</p>
<pre><code>def power(f, p, myapply = lambda init, g:g(init)):
    ff = (f,)*p # tuple of length p containing only f in each slot
    return lambda x:reduce(myapply, ff, x)

def square(x):
    return x * x

power(square, 2)(3)
#=&gt; 81
</code></pre>
<p>I call this <code>power</code>, because this is literally what the power function does, with composition replacing multiplication.</p>
<p><code>(f,)*p</code> creates a tuple of length <code>p</code> filled with <code>f</code> in every index. If you wanted to get fancy, you would use a generator to generate such a sequence (see <code>itertools</code>) - but note it would have to be created inside the lambda.  </p>
<p><code>myapply</code> is defined in the parameter list so that it is only created once. </p>
</div>
<div class="post-text" itemprop="text">
<p>Using reduce and itertools.repeat (as Marcin suggested):</p>
<pre><code>from itertools import repeat
from functools import reduce # necessary for python3

def repeated(func, n):
    def apply(x, f):
        return f(x)
    def ret(x):
        return reduce(apply, repeat(func, n), x)
    return ret
</code></pre>
<p>You can use it as follows:</p>
<pre><code>&gt;&gt;&gt; repeated(os.path.dirname, 3)('/a/b/c/d/e/f')
'/a/b/c'

&gt;&gt;&gt; repeated(square, 5)(3)
1853020188851841
</code></pre>
<p>(after importing <code>os</code> or defining <code>square</code> respectively)</p>
</div>
<div class="post-text" itemprop="text">
<p>There is an itertools recipe called <code>repeatfunc</code> that performs this operation.</p>
<p>From <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>:</p>
<pre><code>def repeatfunc(func, times=None, *args):
    """Repeat calls to func with specified arguments.

    Example:  repeatfunc(random.random)
    """
    if times is None:
        return starmap(func, repeat(args))
    return starmap(func, repeat(args, times))
</code></pre>
<p>I use a third-party library, <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a>, that conveniently implements these recipes (optional):</p>
<pre><code>import more_itertools as mit

list(mit.repeatfunc(square, 2, 3))
# [9, 9]
</code></pre>
</div>
<span class="comment-copy">Where is your problem?</span>
<span class="comment-copy">+1 for lambda-less version.</span>
<span class="comment-copy">that will lead to stack overflows in python...</span>
<span class="comment-copy">It probably does, but I think it shows what the OP wants to construct.</span>
<span class="comment-copy">that's true :-)</span>
<span class="comment-copy">If you change the check to <code>n == 0</code> and return <code>lambda x: x</code> in that case you make your approach work for zero, too.</span>
<span class="comment-copy">@UweKleine-König Good point. Thanks.</span>
<span class="comment-copy">Note that OP is asking for a higher-order function. You have create a recursive function that repeatedly applies the same function. Not quite the same.</span>
<span class="comment-copy">For big p this has the downside to explicitly construct a tuple of length n.</span>
<span class="comment-copy">@UweKleine-König Yes, that's why 5 years ago I mentioned using itertools generators as an alternative.</span>
<span class="comment-copy">ah right, sorry, only looked at the code ...</span>
