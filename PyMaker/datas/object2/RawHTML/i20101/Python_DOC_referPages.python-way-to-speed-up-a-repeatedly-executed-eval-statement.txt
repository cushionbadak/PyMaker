<div class="post-text" itemprop="text">
<p>In my code, I'm using <code>eval</code> to evaluate a string expression given by the user.  Is there a way to compile or otherwise speed up this statement?</p>
<pre><code>import math
import random

result_count = 100000
expression = "math.sin(v['x']) * v['y']"

variable = dict()
variable['x'] = [random.random() for _ in xrange(result_count)]
variable['y'] = [random.random() for _ in xrange(result_count)]

# optimize anything below this line

result = [0] * result_count

print 'Evaluating %d instances of the given expression:' % result_count
print expression

v = dict()
for index in xrange(result_count):
    for name in variable.keys():
        v[name] = variable[name][index]
    result[index] = eval(expression) # &lt;-- option ONE
    #result[index] = math.sin(v['x']) * v['y'] # &lt;-- option TWO
</code></pre>
<p>For a quick comparison option ONE takes 2.019 seconds on my machine, while option TWO takes only 0.218 seconds.  Surely Python has a way of doing this without hard-coding the expression.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also trick python:</p>
<pre><code>expression = "math.sin(v['x']) * v['y']"
exp_as_func = eval('lambda: ' + expression)
</code></pre>
<p>And then use it like so:</p>
<pre><code>exp_as_func()
</code></pre>
<p>Speed test:</p>
<pre><code>In [17]: %timeit eval(expression)
10000 loops, best of 3: 25.8 us per loop

In [18]: %timeit exp_as_func()
1000000 loops, best of 3: 541 ns per loop
</code></pre>
<hr/>
<p>As a side note, if <code>v</code> is not a global, you can create the lambda like this:</p>
<pre><code>exp_as_func = eval('lambda v: ' + expression)
</code></pre>
<p>and call it:</p>
<pre><code>exp_as_func(my_v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid the overhead by compiling the expression in advance using <a href="https://docs.python.org/2.7/library/compiler.html" rel="nofollow noreferrer"><code>compiler.compile()</code></a> for Python 2 or <a href="https://docs.python.org/3/library/functions.html?highlight=compile#compile" rel="nofollow noreferrer"><code>compile()</code></a> for Python 3 :</p>
<pre><code>In [1]: import math, compiler

In [2]: v = {'x': 2, 'y': 4}

In [3]: expression = "math.sin(v['x']) * v['y']"

In [4]: %timeit eval(expression)
10000 loops, best of 3: 19.5 us per loop

In [5]: compiled = compiler.compile(expression, '&lt;string&gt;', 'eval')

In [6]: %timeit eval(compiled)
1000000 loops, best of 3: 823 ns per loop
</code></pre>
<p>Just make sure you do the compiling only once (outside of the loop).  As mentioned in comments, when using <code>eval</code> on user submitted strings make sure you are very careful about what you accept.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are optimising the wrong end. If you want to perform the same operation for a lot of numbers you should consider using numpy:</p>
<pre><code>import numpy
import time
import math
import random

result_count = 100000
expression = "sin(x) * y"

namespace = dict(
    x=numpy.array(
        [random.random() for _ in xrange(result_count)]),
    y=numpy.array(
        [random.random() for _ in xrange(result_count)]),
    sin=numpy.sin,
)
print ('Evaluating %d instances '
       'of the given expression:') % result_count
print expression

start = time.time()
result = eval(expression, namespace)
numpy_time = time.time() - start
print "With numpy:", numpy_time


assert len(result) == result_count
assert all(math.sin(a) * b == c for a, b, c in
           zip(namespace["x"], namespace["y"], result))
</code></pre>
<p>To give you an idea about the possible gain I've added a variant using generic python and the lambda trick:</p>
<pre><code>from math import sin
from itertools import izip

start = time.time()
f = eval("lambda: " + expression)
result = [f() for x, y in izip(namespace["x"], namespace["y"])]
generic_time = time.time() - start
print "Generic python:", generic_time
print "Ratio:", (generic_time / numpy_time)
</code></pre>
<p>Here are the results on my aging machine:</p>
<pre><code>$ python speedup_eval.py 
Evaluating 100000 instances of the given expression:
sin(x) * y
With numpy: 0.006098985672
Generic python: 0.270224094391
Ratio: 44.3063992807
</code></pre>
<p>The speed-up is not as high as I expected, but still significant.</p>
</div>
<span class="comment-copy">Check out some alternatives to eval in this post <a href="http://stackoverflow.com/questions/1832940">stackoverflow.com/questions/1832940</a> as well as some good reasons to stay away from it.</span>
<span class="comment-copy">what if the user types <code>import os;os.system("rm -rf /")</code>? You need to write a parser to interpret the input string, and only recognise what you expect: <code>sin</code>, <code>cos</code>, <code>log</code>, etc. Throw an error if what they enter doesn't work. It could be bad if you don't do that.</span>
<span class="comment-copy">If the user wants to "rm -rf /" or ":(){ :|: &amp; };:" he can do it in a shell instead of within Python.</span>
<span class="comment-copy">This is a noticeable speed improvement over F.J.'s response, which was already a big speed improvement.</span>
<span class="comment-copy">I guess this trick is equivalent to use <code>compile</code> before eval because when you run it you get <code>The slowest run took 17.90 times longer than the fastest. This could mean that an intermediate result is being cached</code>.</span>
<span class="comment-copy">thats a pretty significant gain ...</span>
<span class="comment-copy">compiler.compile is compile in python3</span>
<span class="comment-copy">I don't have access to <code>numpy</code> here.  But I agree, it might speed things up.  I'm generally against relying on a third party library if I can get by without it.</span>
