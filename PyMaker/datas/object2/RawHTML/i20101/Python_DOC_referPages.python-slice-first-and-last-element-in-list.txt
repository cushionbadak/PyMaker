<div class="post-text" itemprop="text">
<p>Is there a way to slice only the first and last item in a list?</p>
<p>For example; If this is my list:</p>
<pre><code>&gt;&gt;&gt; some_list
['1', 'B', '3', 'D', '5', 'F']
</code></pre>
<p>I <em>want</em> to do this (obviously <code>[0,-1]</code> is not valid syntax):</p>
<pre><code>&gt;&gt;&gt; first_item, last_item = some_list[0,-1]
&gt;&gt;&gt; print first_item
'1'
&gt;&gt;&gt; print last_item
'F'
</code></pre>
<p>Some things I have tried:</p>
<pre><code>In [3]: some_list[::-1]
Out[3]: ['F', '5', 'D', '3', 'B', '1']

In [4]: some_list[-1:1:-1]
Out[4]: ['F', '5', 'D', '3']

In [5]: some_list[0:-1:-1]
Out[5]: []
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way:</p>
<pre><code>some_list[::len(some_list)-1]
</code></pre>
<p>A better way (Doesn't use slicing, but is easier to read):</p>
<pre><code>[some_list[0], some_list[-1]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just thought I'd show how to do this with numpy's fancy indexing:</p>
<pre><code>&gt;&gt;&gt; import numpy
&gt;&gt;&gt; some_list = ['1', 'B', '3', 'D', '5', 'F']
&gt;&gt;&gt; numpy.array(some_list)[[0,-1]]
array(['1', 'F'], 
      dtype='|S1')
</code></pre>
<p>Note that it also supports arbitrary index locations, which the <code>[::len(some_list)-1]</code> method would not work for:</p>
<pre><code>&gt;&gt;&gt; numpy.array(some_list)[[0,2,-1]]
array(['1', '3', 'F'], 
      dtype='|S1')
</code></pre>
<p>As DSM points out, you can do something similar with <a href="http://docs.python.org/library/operator.html#operator.itemgetter" rel="noreferrer">itemgetter</a>:</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; operator.itemgetter(0, 2, -1)(some_list)
('1', '3', 'F')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>first, last = some_list[0], some_list[-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it like this:</p>
<pre><code>some_list[0::len(some_list)-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some people are answering the wrong question, it seems.  You said you want to do:</p>
<pre><code>&gt;&gt;&gt; first_item, last_item = some_list[0,-1]
&gt;&gt;&gt; print first_item
'1'
&gt;&gt;&gt; print last_item
'F'
</code></pre>
<p>Ie., you want to extract the first and last elements each into separate variables.</p>
<p>In this case, the answers by Matthew Adams, pemistahl, and katrielalex are valid.  This is just a compound assignment:</p>
<pre><code>first_item, last_item = some_list[0], some_list[-1]
</code></pre>
<p>But later you state a complication: "I am splitting it in the same line, and that would have to spend time splitting it twice:"</p>
<pre><code>x, y = a.split("-")[0], a.split("-")[-1]
</code></pre>
<p>So in order to avoid two split() calls, you must only operate on the list which results from splitting once.</p>
<p>In this case, attempting to do too much in one line is a detriment to clarity and simplicity.  Use a variable to hold the split result:</p>
<pre><code>lst = a.split("-")
first_item, last_item = lst[0], lst[-1]
</code></pre>
<p>Other responses answered the question of "how to get a new list, consisting of the first and last elements of a list?"  They were probably inspired by your title, which mentions slicing, which you actually don't want, according to a careful reading of your question.</p>
<p>AFAIK are 3 ways to get a new list with the 0th and last elements of a list:</p>
<pre><code>&gt;&gt;&gt; s = 'Python ver. 3.4'
&gt;&gt;&gt; a = s.split()
&gt;&gt;&gt; a
['Python', 'ver.', '3.4']

&gt;&gt;&gt; [ a[0], a[-1] ]        # mentioned above
['Python', '3.4']

&gt;&gt;&gt; a[::len(a)-1]          # also mentioned above
['Python', '3.4']

&gt;&gt;&gt; [ a[e] for e in (0,-1) ] # list comprehension, nobody mentioned?
['Python', '3.4']

# Or, if you insist on doing it in one line:
&gt;&gt;&gt; [ s.split()[e] for e in (0,-1) ]
['Python', '3.4']
</code></pre>
<p>The advantage of the list comprehension approach, is that the set of indices in the tuple can be arbitrary and programmatically generated.</p>
</div>
<div class="post-text" itemprop="text">
<p>What about this?</p>
<pre><code>&gt;&gt;&gt; first_element, last_element = some_list[0], some_list[-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually, I just figured it out:</p>
<pre><code>In [20]: some_list[::len(some_list) - 1]
Out[20]: ['1', 'F']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 only answer (that doesn't use slicing or throw away the rest of the <code>list</code>, but might be good enough anyway) is use unpacking generalizations to get <code>first</code> and <code>last</code> separate from the middle:</p>
<pre><code>first, *_, last = some_list
</code></pre>
<p>The choice of <code>_</code> as the catchall for the "rest" of the arguments is arbitrary; they'll be stored in the name <code>_</code> which is often used as a stand-in for "stuff I don't care about".</p>
<p>Unlike many other solutions, this one will ensure there are at least two elements in the sequence; if there is only one (so <code>first</code> and <code>last</code> would be identical), it will raise an exception (<code>ValueError</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>More General Case: Return N points from each end of list</strong></p>
<p>The answers work for the specific first and last, but some, like myself, may be looking for a solution that can be applied to a more general case in which you can return the top N points from either side of the list (say you have a sorted list and only want the 5 highest or lowest), i came up with the following solution:</p>
<pre><code>In [1]
def GetWings(inlist,winglen):
    if len(inlist)&lt;=winglen*2:
        outlist=inlist
    else:
        outlist=list(inlist[:winglen])
        outlist.extend(list(inlist[-winglen:]))
    return outlist
</code></pre>
<p>and an example to return bottom and top 3 numbers from list 1-10:</p>
<pre><code>In [2]
GetWings([1,2,3,4,5,6,7,8,9,10],3)

#Out[2]
#[1, 2, 3, 8, 9, 10]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use something like </p>
<pre><code>y[::max(1, len(y)-1)]
</code></pre>
<p>if you really want to use slicing. The advantage of this is that it cannot give index errors and works with length 1 or 0 lists as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>This isn't a "slice", but it is a general solution that doesn't use explicit indexing, and works for the scenario where the sequence in question is anonymous (so you can create and "slice" on the same line, without creating twice and indexing twice): <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a></p>
<pre><code>import operator

# Done once and reused
first_and_last = operator.itemgetter(0, -1)

...

first, last = first_and_last(some_list)
</code></pre>
<p>You could just inline it as (after <code>from operator import itemgetter</code> for brevity at time of use):</p>
<pre><code>first, last = itemgetter(0, -1)(some_list)
</code></pre>
<p>but if you'll be reusing the getter a lot, you can save the work of recreating it (and give it a useful, self-documenting name) by creating it once ahead of time.</p>
<p>Thus, for your specific use case, you can replace:</p>
<pre><code>x, y = a.split("-")[0], a.split("-")[-1]
</code></pre>
<p>with:</p>
<pre><code>x, y = itemgetter(0, -1)(a.split("-"))
</code></pre>
<p>and <code>split</code> only once without storing the complete <code>list</code> in a persistent name for <code>len</code> checking or double-indexing or the like.</p>
<p>Note that <code>itemgetter</code> for multiple items returns a <code>tuple</code>, not a <code>list</code>, so if you're not just unpacking it to specific names, and need a true <code>list</code>, you'd have to wrap the call in the <code>list</code> constructor.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another python3 solution uses tuple unpacking with the "*" character:</p>
<pre><code>first, *_, last = range(1, 10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>These are all interesting but what if you have a version number and you don't know the size of any one segment in string from and you want to drop the last segment.  Something like 20.0.1.300 and I want to end up with 20.0.1 without the 300 on the end.  I have this so far:</p>
<pre><code>str('20.0.1.300'.split('.')[:3])
</code></pre>
<p>which returns in list form as:</p>
<pre><code>['20', '0', '1']
</code></pre>
<p>How do I get it back to into a single string separated by periods</p>
<pre><code>20.0.1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this might do this:</p>
<pre><code>list[[0,-1]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def recall(x): 
    num1 = x[-4:]
    num2 = x[::-1]
    num3 = num2[-4:]
    num4 = [num3, num1]
    return num4
</code></pre>
<p>Now just make an variable outside the function and recall the function : like this:</p>
<pre><code>avg = recall("idreesjaneqand") 
print(avg)
</code></pre>
</div>
<span class="comment-copy">Haha 3 answers, identical, in the space of 2 seconds, and one was yours. Classic.</span>
<span class="comment-copy">What's bad about <code>first, last = some_list[0], some_list[-1]</code>?</span>
<span class="comment-copy">@MatthewAdams Because I am splitting it in the same line, and that would have to spend time splitting it twice: <code>x, y = a.split("-")[0], a.split("-")[-1]</code>.</span>
<span class="comment-copy">FWIW, I would reject <code>some_list[0::len(some_list)-1]</code> in a code review.  Too clever by half.</span>
<span class="comment-copy">@chown: but then, with your solution of the step set to len-1 you'd have to split twice again for getting the length anyway!</span>
<span class="comment-copy">The second form is <i>much</i> more readable. Explicit is better than implicit again.</span>
<span class="comment-copy">Hence the "possibly a better way".  the only reason I didn't put it first is because the question explicitly asks for a "slice" and the second form isn't technically a slice ...</span>
<span class="comment-copy">It's never too late to educate the OP about the folly of his ways. :-P</span>
<span class="comment-copy">@Martijn I did end up using <code>[0]</code> &amp; <code>[-1]</code> since I was splitting a string into the list and I would have had to split it again to get the length.  The Zen of Python wins again (<i>Simple is better than complex.</i>) ;).</span>
<span class="comment-copy">if there is only one item in some_list, the slice form fails with "ValueError: slice step cannot be zero"</span>
<span class="comment-copy">Numpy is just way too awesome ...</span>
<span class="comment-copy">numpy usually makes me smile!</span>
<span class="comment-copy">You can get a variant of this to work using <code>itemgetter</code> without <code>numpy</code>: <code>itemgetter(0, -1)(some_list)</code>.</span>
<span class="comment-copy">@DSM Make an answer</span>
<span class="comment-copy">@DSM did not know that, that's cool. updated answer</span>
