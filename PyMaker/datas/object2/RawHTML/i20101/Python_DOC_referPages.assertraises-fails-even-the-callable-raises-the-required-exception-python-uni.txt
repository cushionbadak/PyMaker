<div class="post-text" itemprop="text">
<p>I have the following test-code checking for an exception raising in a function. I expect the test to pass, but a failure is indicated instead. Here is the test code:</p>
<pre><code>import unittest

# define a user-defined exception
class MyException(Exception):
    def __str__(self):
        return repr("ERROR: Just raised my exception!")

# this is my main class with a method raising this exception
class MyMainObject(object):

    def func(self):
        raise MyException()

# the test class
class TestConfig(unittest.TestCase):

    def test_1(self):

        other = MyMainObject()
        self.assertRaises(MyException, other.func())

# calling the test
if __name__ == '__main__':    
    unittest.main()
</code></pre>
<p>When <code>other.func()</code> is called in the assert statement, <code>MyException</code> is raised (can be checked easily). So, the <code>assertRaises</code> test should pass the test, as <code>other.func()</code> failes with <code>MyException</code>, BUT:</p>
<pre><code>....
MyException: 'ERROR: Just raised my exception!'

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
</code></pre>
<p>I do not see something wrong, so I would appreciate some input on this problem.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>assertRaises</code> calls the function for you. By calling it yourself, the exception is raised <em>before</em> <code>assertRaises</code> can test it.</p>
<p>Change your code to:</p>
<pre><code>self.assertRaises(MyException, other.func)
</code></pre>
<p>and it'll work correctly. Alternatively, you can use <code>assertRaises</code> as a context manager (python 2.7 and up):</p>
<pre><code>with self.assertRaises(MyException):
    other.func()
</code></pre>
<p>Using <code>assertRaises</code> as a context manager has the added advantage that you can now retrieve the exception instance and perform further tests on it:</p>
<pre><code>with self.assertRaises(MyException) as raises_cm:
    other.func()

exception = raises_cm.exception
self.assertEqual(exception.args, ('foo', 'bar'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Due to the rules of the languages, the arguments are evaluated before the code of the called function is entered (and that's generally a good thing). Therefore, <code>assertRaises</code> can't catch exceptions occuring during evaluation of arguments. The workaround (in more than one API) is that you <em>pass a callable</em> to methods like <code>assertRaises</code>, so they can evaluate it in a place they can control and where they can catch exceptions. If the entire argument is a method call, the magic of bound methods allows you to state this quite elegantly, without <code>lambda</code> or such silliness:</p>
<pre><code>self.assertRaises(MyException, other.func) # &lt;- note, no parentheses after func
</code></pre>
</div>
<span class="comment-copy">You should notice it's an error, not a failure ! your exception was not even caught.</span>
<span class="comment-copy">I knew it was something rather simple. Maybe I should have looked at it another day... (2 minutes to wait until I can click the hook)</span>
<span class="comment-copy">@Alex Don't feel too bad - I think this is more of a matter of unittest being unintuitive  - other testing frameworks work how you expected.</span>
<span class="comment-copy">I am using python 3.3 interpreter in pycharm IDE. What if I want to pass arguments to the function under test and also include a message in case the desired error is not raised ? Example - <code>self.assertRaises(ValueError, person.set_age_method, -10, "Error: Person's age cannot be negative.")</code> With this, I get an exception: <code>set_age_method takes 2 positional arguments but 3 were given</code>. How do I fix this ? Btw, the docs for this assertion don't clearly tell you how to do it. <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" rel="nofollow noreferrer">docs.python.org/3/library/…</a> . What is **kwds ?</span>
<span class="comment-copy">@testerjoe2 you can only set a message when using the context manager option.</span>
<span class="comment-copy">@testerjoe2 exactly; so as <code>with self.assertRaises(ValueError, msg="..."):</code> then call <code>person.set_age_method(-10)</code> in the block.</span>
<span class="comment-copy">I am using python 3.3 interpreter in pycharm IDE. What if I want to pass arguments to the function under test and also include a message in case the desired error is not raised ? Example - <code>self.assertRaises(ValueError, person.set_age_method, -10, "Error: Person's age cannot be negative.")</code> With this, I get an exception: <code>set_age_method takes 2 positional arguments but 3 were given</code>. How do I fix this ? Btw, the docs for this assertion don't clearly tell you how to do it. <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" rel="nofollow noreferrer">docs.python.org/3/library/…</a> . What is **kwds ?</span>
<span class="comment-copy">@testerjoe2 Everything that goes after the function, including keyword arguments like <code>age=-10</code> (this is what the <code>**kwds</code> stands for), is passed to the callable. You should create the <code>ValueError</code> object directly, since its construction doesn't need to be delayed like the function call (exception objects are harmless if you don't <code>raise</code> them), so you want: <code>self.assertRaises(ValueError("Error: Person's age cannot be negative."), person.set_age_ethod, -10)</code>.</span>
