<div class="post-text" itemprop="text">
<p>Two sections of Python 2.7's doc mentioned adding <em>cyclic garbage collection</em> (CGC) support for container objects defined in extension modules.</p>
<p>The <a href="http://docs.python.org/c-api/gcsupport.html?highlight=pyobject_gc_newvar" rel="nofollow">Python/C API Reference Manual</a> gives two rules, i.e.,</p>
<blockquote>
<ol>
<li>The memory for the object must be allocated using <code>PyObject_GC_New()</code> or <code>PyObject_GC_NewVar()</code>.</li>
<li>Once all the fields which may contain references to other containers are initialized, it must call <code>PyObject_GC_Track()</code>.</li>
</ol>
</blockquote>
<p>Whereas in <a href="http://docs.python.org/extending/newtypes.html?highlight=noddy_traverse#supporting-cyclic-garbage-collection" rel="nofollow">Extending and Embedding the Python Interpreter</a>, for the <code>Noddy</code> example, it seems that adding the <code>Py_TPFLAGS_HAVE_GC</code> flag and filling <code>tp_traverse</code> and <code>tp_clear</code> slots would be sufficient to enable CGC support. And the two rules above are NOT practiced at all.</p>
<p>When I modified the <code>Noddy</code> example to actually follow the rules of <code>PyObject_GC_New()</code>/<code>PyObject_GC_Del()</code> and <code>PyObject_Track()</code>/<code>PyObject_GC_UnTrack()</code>, it surprisingly raised assertion error saying,</p>
<blockquote>
<p>Modules/gcmodule.c:348: visit_decref: Assertion "gc-&gt;gc.gc_refs != 0" failed. refcount was too small</p>
</blockquote>
<p>This leads to my confusion about the correct / safe way to implement CGC. Could anyone give advices or, preferably, a <em>neat</em> example of a container object with CGC support?</p>
</div>
<div class="post-text" itemprop="text">
<p>Under most normal circumstances you shouldn't need to do do the tracking/untracking yourself. This is described in the documentation, however it isn't made specifically clear. In the case of the <a href="https://docs.python.org/3/extending/newtypes.html" rel="nofollow noreferrer"><code>Noddy</code> example</a> you definitely don't.</p>
<p>The short version is that a TypeObject contains two function pointers: <code>tp_alloc</code> and <code>tp_free</code>. By default <code>tp_alloc</code> calls all the right functions on creation of a class (if <code>Py_TPFLAGS_HAVE_GC</code> is set) and <code>tp_free</code> untracks the class on destruction.</p>
<p>The <a href="https://docs.python.org/3/extending/newtypes.html#supporting-cyclic-garbage-collection" rel="nofollow noreferrer">Noddy documentation says</a> (at the end of the section):</p>
<blockquote>
<p>That’s pretty much it. If we had written custom <code>tp_alloc</code> or <code>tp_free</code> slots, we’d need to modify them for cyclic-garbage collection. Most extensions will use the versions automatically provided.</p>
</blockquote>
<p>Unfortunately, the one place that doesn't make it clear that you don't need to do this yourself is the <a href="https://docs.python.org/3/c-api/gcsupport.html" rel="nofollow noreferrer">Supporting Cyclic Garbage Collection documentation</a>.</p>
<hr/>
<p><strong>Detail:</strong></p>
<p>Noddy's are allocated using a function called <code>Noddy_new</code> put in the <code>tp_new</code> slots of the <code>TypeObject</code>. According to <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new" rel="nofollow noreferrer">the documentation</a>, the main thing the "new" function should do is call the <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_alloc" rel="nofollow noreferrer"><code>tp_alloc</code> slot</a>. You typically don't write <code>tp_alloc</code> yourself, and it just defaults to <code>PyType_GenericAlloc()</code>.</p>
<p>Looking at <a href="https://github.com/python/cpython/blob/a4f15bc3d0bdba6474d73ee0dbd2ccd2c34d6bd5/Objects/typeobject.c#L929" rel="nofollow noreferrer"><code>PyType_GenericAlloc()</code> in the Python source</a> shows a number of sections where it changes based on <code>PyType_IS_GC(type)</code>. First it calls <code>_PyObject_GC_Malloc</code> instead of <code>PyObject_Malloc</code>, and second it calls <code>_PyObject_GC_TRACK(obj)</code>. [Note that all that <code>PyObject_New</code> really does is call <code>PyObject_Malloc</code> and then <code>tp_init</code>.]</p>
<p>Similarly, on deallocation you call the <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_free" rel="nofollow noreferrer"><code>tp_free</code> slot</a>, which is automatically set to <a href="https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Modules/gcmodule.c#L1787" rel="nofollow noreferrer"><code>PyObject_GC_Del</code></a> for classes with <code>Py_TPFLAGS_HAVE_GC</code>. <code>PyObject_GC_Del</code> includes code that does the same as <code>PyObject_GC_UnTrack</code> so a call to untrack is unnecessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not experienced enough in the C API myself to give you any advice, but there are plenty of <em>examples</em> in the Python container implementations themselves.</p>
<p>Personally, I'd start with the tuple implementation first, since it's immutable: <a href="http://hg.python.org/cpython/file/tip/Objects/tupleobject.c" rel="nofollow">Objects/tupleobject.c</a>. Then move on to the <code>dict</code>, <code>list</code> and <code>set</code> implementations for further notes on mutable containers:</p>
<ul>
<li><a href="http://hg.python.org/cpython/file/tip/Objects/dictobject.c" rel="nofollow">Objects/dictobject.c</a></li>
<li><a href="http://hg.python.org/cpython/file/tip/Objects/listobject.c" rel="nofollow">Objects/listobject.c</a></li>
<li><a href="http://hg.python.org/cpython/file/tip/Objects/setobject.c" rel="nofollow">Objects/setobject.c</a></li>
</ul>
<p>I can't help but notice that there are calls to <code>PyObject_GC_New()</code>, <code>PyObject_GC_NewVar()</code> and <code>PyObject_GC_Track()</code> throughout, as well as having <code>Py_TPFLAGS_HAVE_GC</code> set.</p>
</div>
<span class="comment-copy">Thanks for the reply. I am investigating the possibility that some versions of the <code>PyObject_GC_New()</code> API cannot correctly handle subtypes, which is the cause of the AssertionError.</span>
