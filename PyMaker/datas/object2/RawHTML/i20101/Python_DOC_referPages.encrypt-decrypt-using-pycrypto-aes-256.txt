<div class="post-text" itemprop="text">
<p>I'm trying to build two functions using PyCrypto that accept two parameters: the message and the key, and then encrypt/decrypt the message.</p>
<p>I found several links on the web to help me out, but each one of them has flaws:</p>
<p><a href="http://www.codekoala.com/blog/2009/aes-encryption-python-using-pycrypto/" rel="noreferrer">This one at codekoala</a> uses os.urandom, which is discouraged by PyCrypto.</p>
<p>Moreover, the key I give to the function is not guaranteed to have the exact length expected. What can I do to make that happen ?</p>
<p>Also, there are several modes, which one is recommended? I don't know what to use :/</p>
<p>Finally, what exactly is the IV? Can I provide a different IV for encrypting and decrypting, or will this return in a different result?</p>
<p>Here's what I've done so far:</p>
<pre><code>from Crypto import Random
from Crypto.Cipher import AES
import base64

BLOCK_SIZE=32

def encrypt(message, passphrase):
    # passphrase MUST be 16, 24 or 32 bytes long, how can I do that ?
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return base64.b64encode(aes.encrypt(message))

def decrypt(encrypted, passphrase):
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return aes.decrypt(base64.b64decode(encrypted))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my implementation and works for me with some fixes and enhances the alignment of the key and secret phrase with 32 bytes and iv to 16 bytes:</p>
<pre><code>import base64
import hashlib
from Crypto import Random
from Crypto.Cipher import AES

class AESCipher(object):

    def __init__(self, key): 
        self.bs = 32
        self.key = hashlib.sha256(key.encode()).digest()

    def encrypt(self, raw):
        raw = self._pad(raw)
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return base64.b64encode(iv + cipher.encrypt(raw))

    def decrypt(self, enc):
        enc = base64.b64decode(enc)
        iv = enc[:AES.block_size]
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')

    def _pad(self, s):
        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)

    @staticmethod
    def _unpad(s):
        return s[:-ord(s[len(s)-1:])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may need the following two functions to pad(when do encryption) and unpad(when do decryption) when the length of input is not a multiple of BLOCK_SIZE.</p>
<pre><code>BS = 16
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS) 
unpad = lambda s : s[:-ord(s[len(s)-1:])]
</code></pre>
<p>So you're asking the length of key? You can use the md5sum of the key rather than use it directly.</p>
<p>More, according to my little experience of using PyCrypto, the IV is used to mix up the output of a encryption when input is same, so the IV is chosen as a random string, and use it as part of the encryption output, and then use it to decrypt the message.</p>
<p>And here's my implementation, hope it will be useful for you:</p>
<pre><code>import base64
from Crypto.Cipher import AES
from Crypto import Random

class AESCipher:
    def __init__( self, key ):
        self.key = key

    def encrypt( self, raw ):
        raw = pad(raw)
        iv = Random.new().read( AES.block_size )
        cipher = AES.new( self.key, AES.MODE_CBC, iv )
        return base64.b64encode( iv + cipher.encrypt( raw ) ) 

    def decrypt( self, enc ):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        cipher = AES.new(self.key, AES.MODE_CBC, iv )
        return unpad(cipher.decrypt( enc[16:] ))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let me address your question about "modes." AES256 is a kind of <strong>block cipher</strong>. It takes as input a 32-byte <strong>key</strong> and a 16-byte string, called the <strong>block</strong> and outputs a block. We use AES in a <strong>mode of operation</strong> in order to encrypt. The solutions above suggest using CBC, which is one example. Another is called CTR, and it's somewhat easier to use:</p>
<pre><code>from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto import Random

# AES supports multiple key sizes: 16 (AES128), 24 (AES192), or 32 (AES256).
key_bytes = 32

# Takes as input a 32-byte key and an arbitrary-length plaintext and returns a
# pair (iv, ciphtertext). "iv" stands for initialization vector.
def encrypt(key, plaintext):
    assert len(key) == key_bytes

    # Choose a random, 16-byte IV.
    iv = Random.new().read(AES.block_size)

    # Convert the IV to a Python integer.
    iv_int = int(binascii.hexlify(iv), 16) 

    # Create a new Counter object with IV = iv_int.
    ctr = Counter.new(AES.block_size * 8, initial_value=iv_int)

    # Create AES-CTR cipher.
    aes = AES.new(key, AES.MODE_CTR, counter=ctr)

    # Encrypt and return IV and ciphertext.
    ciphertext = aes.encrypt(plaintext)
    return (iv, ciphertext)

# Takes as input a 32-byte key, a 16-byte IV, and a ciphertext, and outputs the
# corresponding plaintext.
def decrypt(key, iv, ciphertext):
    assert len(key) == key_bytes

    # Initialize counter for decryption. iv should be the same as the output of
    # encrypt().
    iv_int = int(iv.encode('hex'), 16) 
    ctr = Counter.new(AES.block_size * 8, initial_value=iv_int)

    # Create AES-CTR cipher.
    aes = AES.new(key, AES.MODE_CTR, counter=ctr)

    # Decrypt and return the plaintext.
    plaintext = aes.decrypt(ciphertext)
    return plaintext

(iv, ciphertext) = encrypt(key, 'hella')
print decrypt(key, iv, ciphertext)
</code></pre>
<p>This is often referred to as AES-CTR. <strong>I would advise caution in using AES-CBC with PyCrypto</strong>. The reason is that it requires you to specify the <strong>padding scheme</strong>, as exemplified by the other solutions given. In general, if you're not <strong>very</strong> careful about the padding, <strong>there are <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack" rel="noreferrer">attacks</a> that completely break encryption!</strong> </p>
<p>Now, it's important to note that the key must be a <strong>random, 32-byte string</strong>; a password <strong>does not</strong> suffice. Normally, the key is generated like so:</p>
<pre><code># Nominal way to generate a fresh key. This calls the system's random number
# generator (RNG).
key1 = Random.new().read(key_bytes)
</code></pre>
<p>A key may be <strong>derived from a password</strong>, too:</p>
<pre><code># It's also possible to derive a key from a password, but it's important that
# the password have high entropy, meaning difficult to predict.
password = "This is a rather weak password."

# For added # security, we add a "salt", which increases the entropy.
#
# In this example, we use the same RNG to produce the salt that we used to
# produce key1.
salt_bytes = 8 
salt = Random.new().read(salt_bytes)

# Stands for "Password-based key derivation function 2"
key2 = PBKDF2(password, salt, key_bytes)
</code></pre>
<p>Some solutions above suggest using SHA256 for deriving the key, but this is generally considered <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function#Password_verification" rel="noreferrer">bad cryptographic practice</a>.
Check out <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" rel="noreferrer">wikipedia</a> for more on modes of operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get a passphrase out of an arbitrary password by using a cryptographic hash function (<em>NOT</em> Python's builtin <code>hash</code>) like SHA-1 or SHA-256. Python includes support for both in its standard library:</p>
<pre><code>import hashlib

hashlib.sha1("this is my awesome password").digest() # =&gt; a 20 byte string
hashlib.sha256("another awesome password").digest() # =&gt; a 32 byte string
</code></pre>
<p>You can truncate a cryptographic hash value just by using <code>[:16]</code> or <code>[:24]</code> and it will retain its security up to the length you specify.</p>
</div>
<div class="post-text" itemprop="text">
<p>For someone who would like to use urlsafe_b64encode and urlsafe_b64decode, here are the version that're working for me (after spending some time with the unicode issue)</p>
<pre><code>BS = 16
key = hashlib.md5(settings.SECRET_KEY).hexdigest()[:BS]
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)
unpad = lambda s : s[:-ord(s[len(s)-1:])]

class AESCipher:
    def __init__(self, key):
        self.key = key

    def encrypt(self, raw):
        raw = pad(raw)
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return base64.urlsafe_b64encode(iv + cipher.encrypt(raw)) 

    def decrypt(self, enc):
        enc = base64.urlsafe_b64decode(enc.encode('utf-8'))
        iv = enc[:BS]
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return unpad(cipher.decrypt(enc[BS:]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the benefit of others, here is my decryption implementation which I got to by combining the answers of @Cyril and @Marcus.  This assumes that this coming in via HTTP Request with the encryptedText quoted and base64 encoded.</p>
<pre><code>import base64
import urllib2
from Crypto.Cipher import AES


def decrypt(quotedEncodedEncrypted):
    key = 'SecretKey'

    encodedEncrypted = urllib2.unquote(quotedEncodedEncrypted)

    cipher = AES.new(key)
    decrypted = cipher.decrypt(base64.b64decode(encodedEncrypted))[:16]

    for i in range(1, len(base64.b64decode(encodedEncrypted))/16):
        cipher = AES.new(key, AES.MODE_CBC, base64.b64decode(encodedEncrypted)[(i-1)*16:i*16])
        decrypted += cipher.decrypt(base64.b64decode(encodedEncrypted)[i*16:])[:16]

    return decrypted.strip()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's little late but i think this will be very helpful. No one mention about use  scheme like PKCS#7 padding. You can use it instead the previous functions to pad(when do encryption) and unpad(when do decryption).i will provide the full Source Code below.</p>
<pre><code>import base64
import hashlib
from Crypto import Random
from Crypto.Cipher import AES
import pkcs7
class Encryption:

    def __init__(self):
        pass

    def Encrypt(self, PlainText, SecurePassword):
        pw_encode = SecurePassword.encode('utf-8')
        text_encode = PlainText.encode('utf-8')

        key = hashlib.sha256(pw_encode).digest()
        iv = Random.new().read(AES.block_size)

        cipher = AES.new(key, AES.MODE_CBC, iv)
        pad_text = pkcs7.encode(text_encode)
        msg = iv + cipher.encrypt(pad_text)

        EncodeMsg = base64.b64encode(msg)
        return EncodeMsg

    def Decrypt(self, Encrypted, SecurePassword):
        decodbase64 = base64.b64decode(Encrypted.decode("utf-8"))
        pw_encode = SecurePassword.decode('utf-8')

        iv = decodbase64[:AES.block_size]
        key = hashlib.sha256(pw_encode).digest()

        cipher = AES.new(key, AES.MODE_CBC, iv)
        msg = cipher.decrypt(decodbase64[AES.block_size:])
        pad_text = pkcs7.decode(msg)

        decryptedString = pad_text.decode('utf-8')
        return decryptedString
</code></pre>
<p></p>
<pre><code>import StringIO
import binascii


def decode(text, k=16):
    nl = len(text)
    val = int(binascii.hexlify(text[-1]), 16)
    if val &gt; k:
        raise ValueError('Input is not padded or padding is corrupt')

    l = nl - val
    return text[:l]


def encode(text, k=16):
    l = len(text)
    output = StringIO.StringIO()
    val = k - (l % k)
    for _ in xrange(val):
        output.write('%02x' % val)
    return text + binascii.unhexlify(output.getvalue())
</code></pre>
<p></p>
</div>
<div class="post-text" itemprop="text">
<p>Another take on this (heavily derived from solutions above) but</p>
<ul>
<li>uses null for padding </li>
<li>does not use lambda (never been a fan)</li>
<li><p>tested with python 2.7 and 3.6.5</p>
<pre><code>#!/usr/bin/python2.7
# you'll have to adjust for your setup, e.g., #!/usr/bin/python3


import base64, re
from Crypto.Cipher import AES
from Crypto import Random
from django.conf import settings

class AESCipher:
    """
      Usage:
      aes = AESCipher( settings.SECRET_KEY[:16], 32)
      encryp_msg = aes.encrypt( 'ppppppppppppppppppppppppppppppppppppppppppppppppppppppp' )
      msg = aes.decrypt( encryp_msg )
      print("'{}'".format(msg))
    """
    def __init__(self, key, blk_sz):
        self.key = key
        self.blk_sz = blk_sz

    def encrypt( self, raw ):
        if raw is None or len(raw) == 0:
            raise NameError("No value given to encrypt")
        raw = raw + '\0' * (self.blk_sz - len(raw) % self.blk_sz)
        raw = raw.encode('utf-8')
        iv = Random.new().read( AES.block_size )
        cipher = AES.new( self.key.encode('utf-8'), AES.MODE_CBC, iv )
        return base64.b64encode( iv + cipher.encrypt( raw ) ).decode('utf-8')

    def decrypt( self, enc ):
        if enc is None or len(enc) == 0:
            raise NameError("No value given to decrypt")
        enc = base64.b64decode(enc)
        iv = enc[:16]
        cipher = AES.new(self.key.encode('utf-8'), AES.MODE_CBC, iv )
        return re.sub(b'\x00*$', b'', cipher.decrypt( enc[16:])).decode('utf-8')
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Grateful for the other answers which inspired but didn't work for me. <br/><br/> After spending hours trying to figure out how it works, I came up with the implementation below with the newest <strong>PyCryptodomex</strong> library (it is another story how I managed to set it up behind proxy, on Windows, in a virtualenv.. phew) <br/><br/> Working on your implementation, remember to write down padding, encoding, encrypting steps (and vice versa). You have to pack and unpack keeping in mind the order.</p>
<pre>
import base64
import hashlib
from Cryptodome.Cipher import AES
from Cryptodome.Random import get_random_bytes

__key__ = hashlib.sha256(b'16-character key').digest()

def encrypt(raw):
    BS = AES.block_size
    pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)

    raw = base64.b64encode(pad(raw).encode('utf8'))
    iv = get_random_bytes(AES.block_size)
    cipher = AES.new(key= __key__, mode= AES.MODE_CFB,iv= iv)
    return base64.b64encode(iv + cipher.encrypt(raw))

def decrypt(enc):
    unpad = lambda s: s[:-ord(s[-1:])]

    enc = base64.b64decode(enc)
    iv = enc[:AES.block_size]
    cipher = AES.new(__key__, AES.MODE_CFB, iv)
    return unpad(base64.b64decode(cipher.decrypt(enc[AES.block_size:])).decode('utf8'))
</pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from Crypto import Random
from Crypto.Cipher import AES
import base64

BLOCK_SIZE=16
def trans(key):
     return md5.new(key).digest()

def encrypt(message, passphrase):
    passphrase = trans(passphrase)
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return base64.b64encode(IV + aes.encrypt(message))

def decrypt(encrypted, passphrase):
    passphrase = trans(passphrase)
    encrypted = base64.b64decode(encrypted)
    IV = encrypted[:BLOCK_SIZE]
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return aes.decrypt(encrypted[BLOCK_SIZE:])
</code></pre>
</div>
<span class="comment-copy"><a href="http://docs.python.org/3/library/os.html" rel="nofollow noreferrer">os.urandom</a> is <i>encouraged</i> on the <a href="https://www.dlitz.net/software/pycrypto/" rel="nofollow noreferrer">PyCrypto</a> website. It uses Microsoft's <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa379942(v=vs.85).aspx" rel="nofollow noreferrer">CryptGenRandom</a> function which is a <a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" rel="nofollow noreferrer">CSPRNG</a></span>
<span class="comment-copy">or <code>/dev/urandom</code> on Unix</span>
<span class="comment-copy">Just to clarify, in this example <b>passphrase</b> is the <i>key</i> which can be 128, 192, or 256 bits (16, 24, or 32 bytes)</span>
<span class="comment-copy">@Totem the manpage has since been updated. See <a href="https://bugzilla.kernel.org/show_bug.cgi?id=71211" rel="nofollow noreferrer">bugzilla.kernel.org/show_bug.cgi?id=71211</a> for background, and <a href="http://man7.org/linux/man-pages/man7/random.7.html" rel="nofollow noreferrer">random(7)</a> as well as <a href="http://man7.org/linux/man-pages/man4/random.4.html" rel="nofollow noreferrer">random(4)</a>. You should be using <code>/dev/urandom</code>.</span>
<span class="comment-copy">It might be worth to mention that PyCrypto is a <a href="https://github.com/dlitz/pycrypto/issues/173" rel="nofollow noreferrer">dead project</a>. Last commit is from 2014. <a href="https://github.com/Legrandin/pycryptodome" rel="nofollow noreferrer">PyCryptodome</a> looks like a good drop-in replacement</span>
<span class="comment-copy">I know this has been up for a while but I think this response may spread some confusion. This function uses a block_size of 32 byte (256 byte) to pad input data but AES uses 128 bit block size. In AES256 the <i>key</i> is 256 bit, but not the block size.</span>
<span class="comment-copy">to put it another way, "self.bs" should be removed and replaced by "AES.block_size"</span>
<span class="comment-copy">Why are you hashing the key? If you're expecting that this is something like a password, then you shouldn't be using SHA256; better to use a key derivation function, like PBKDF2, which PyCrypto provides.</span>
<span class="comment-copy">@Chris - SHA256 gives out a 32-byte hash - a perfect-sized key for AES256. Generation/derivation of a key is assumed to be random/secure and should be out of the encryption/decryption code's scope - hashing is just a guarantee that the key is usable with the selected cipher.</span>
<span class="comment-copy">in _pad self.bs access is needed and in _unpad doesn't need</span>
<span class="comment-copy">What happens if you have an input that is exactly a multiple of BLOCK_SIZE? I think that the unpad function would get a little confused...</span>
<span class="comment-copy">@Kjir, then a sequence of value chr(BS) in length BLOCK_SIZE will be appended to the origin data.</span>
<span class="comment-copy">@Marcus the <code>pad</code> function is broken (at least in Py3), replace with <code>s[:-ord(s[len(s)-1:])]</code> for it to work across versions.</span>
<span class="comment-copy">@Torxed pad function is avail in CryptoUtil.Padding.pad() with pycryptodome (pycrypto followup)</span>
<span class="comment-copy">Why not just have a character constant as the padding char?</span>
<span class="comment-copy">You should not use a SHA-family hash function for generating a key from a password – see <a href="http://codahale.com/how-to-safely-store-a-password/" rel="nofollow noreferrer">Coda Hale’s essay on the topic</a>.  Consider using a real <a href="https://en.wikipedia.org/wiki/Key_derivation_function" rel="nofollow noreferrer">key derivation function</a> like <a href="https://pypi.python.org/pypi/scrypt/" rel="nofollow noreferrer">scrypt</a> instead.  (Coda Hale’s essay was written before scrypt’s publication.)</span>
<span class="comment-copy">For future readers, if you're looking to derive a key from a passphrase, look for PBKDF2. It's fairly easy to use in python (<a href="https://pypi.python.org/pypi/pbkdf2" rel="nofollow noreferrer">pypi.python.org/pypi/pbkdf2</a>). If you're looking to hash passwords, however, bcrypt is a better option.</span>
<span class="comment-copy">This code will break if <code>BS=32</code></span>
<span class="comment-copy">I don't know who downvoted the answer but I'd be curious to know why. Maybe this method is not secure? An explanation would be great.</span>
<span class="comment-copy">at least i'm not the one who downvote it :)</span>
<span class="comment-copy">@CyrilN. This answer suggests that hashing the password with a single invocation of SHA-256 is enough. It isn't. You really should use PBKDF2 or similar for key derivation from a password using a large iteration count.</span>
<span class="comment-copy">Thank you for the detail @ArtjomB.!</span>
<span class="comment-copy">I have a key and also iv key with 44 length. How can i use your functions ?! all of algorithms in the internet that i found, has problem with length of my vector key</span>
<span class="comment-copy">This will not work if the input byte[] has trailing nulls because in the decrypt() function you will eat your padding nulls PLUS any trailing nulls.</span>
<span class="comment-copy">Yes, as I state above, this logic pads with nulls. If the items you want encode/decode might have trailing nulls, better use one of the other solutions here</span>
<span class="comment-copy">Please provide not only code but also explain what you are doing and why this is better / what is the difference to existing answers.</span>
<span class="comment-copy">Replace the md5.new(key).digest() by md5(key).digest(), and it work like a charm !</span>
