<div class="post-text" itemprop="text">
<p>I have this string: <code>Hello world !!</code> and I want to print it using Python as <code>48:65:6c:6c:6f:20:77:6f:72:6c:64:20:21:21</code>.</p>
<p><code>hex()</code> works only for integers. </p>
<p>How can it be done?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your can transform your string to a int generator, apply hex formatting for each element and intercalate with separator:</p>
<pre><code>&gt;&gt;&gt; s = "Hello world !!"
&gt;&gt;&gt; ":".join("{:02x}".format(ord(c)) for c in s)
'48:65:6c:6c:6f:20:77:6f:72:6c:64:20:21:21
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>':'.join(x.encode('hex') for x in 'Hello World!')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python 2.x:</p>
<pre><code>':'.join(x.encode('hex') for x in 'Hello World!')
</code></pre>
<p>The code above will <strong>not work with Python 3.x</strong>, for 3.x, the code below will work:</p>
<pre><code>':'.join(hex(ord(x))[2:] for x in 'Hello World!')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another answer in two lines that some might find easier to read, and helps with debugging line breaks or other odd characters in a string:</p>
<pre><code>for character in string:
  print character, character.encode('hex')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some complements to Fedor Gogolev answer:</p>
<p>First, if the string contains characters whose 'ASCII code' is below 10, they will not be displayed as required. In that case, the correct format should be <code>{:02x}</code>:</p>
<pre><code>&gt;&gt;&gt; s = "Hello unicode \u0005 !!"
&gt;&gt;&gt; ":".join("{0:x}".format(ord(c)) for c in s)
'48:65:6c:6c:6f:20:75:6e:69:63:6f:64:65:20:5:20:21:21'
                                           ^

&gt;&gt;&gt; ":".join("{:02x}".format(ord(c)) for c in s)
'48:65:6c:6c:6f:20:75:6e:69:63:6f:64:65:20:05:20:21:21'
                                           ^^
</code></pre>
<p>Second, if your "string" is in reality a "byte string" -- and since the difference matters in Python 3 -- you might prefer the following:</p>
<pre><code>&gt;&gt;&gt; s = b"Hello bytes \x05 !!"
&gt;&gt;&gt; ":".join("{:02x}".format(c) for c in s)
'48:65:6c:6c:6f:20:62:79:74:65:73:20:05:20:21:21'
</code></pre>
<p>Please note there is no need for conversion in the above code as <a href="https://docs.python.org/3/library/functions.html#bytes" rel="noreferrer">a bytes objects is defined</a> as <em>"an immutable sequence of integers in the range 0 &lt;= x &lt; 256"</em>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Print a string as hex bytes?</h1>
</blockquote>
<p>The accepted answer gives:</p>
<pre><code>s = "Hello world !!"
":".join("{:02x}".format(ord(c)) for c in s)
</code></pre>
<p>returns: </p>
<pre><code>'48:65:6c:6c:6f:20:77:6f:72:6c:64:20:21:21'
</code></pre>
<p>The accepted answer works only so long as you use bytes (mostly ascii characters). But if you use unicode, e.g.:</p>
<pre><code>a_string = u"Привет мир!!" # "Prevyet mir, or "Hello World" in Russian.
</code></pre>
<p>You need to convert to bytes somehow.</p>
<p>If your terminal doesn't accept these characters, you can decode from utf-8 or use the names (so you can paste and run the code along with me):</p>
<pre><code>a_string = (
    "\N{CYRILLIC CAPITAL LETTER PE}"
    "\N{CYRILLIC SMALL LETTER ER}"
    "\N{CYRILLIC SMALL LETTER I}"
    "\N{CYRILLIC SMALL LETTER VE}"
    "\N{CYRILLIC SMALL LETTER IE}"
    "\N{CYRILLIC SMALL LETTER TE}"
    "\N{SPACE}"
    "\N{CYRILLIC SMALL LETTER EM}"
    "\N{CYRILLIC SMALL LETTER I}"
    "\N{CYRILLIC SMALL LETTER ER}"
    "\N{EXCLAMATION MARK}"
    "\N{EXCLAMATION MARK}"
)
</code></pre>
<p>So we see that: </p>
<pre><code>":".join("{:02x}".format(ord(c)) for c in a_string)
</code></pre>
<p>returns</p>
<pre><code>'41f:440:438:432:435:442:20:43c:438:440:21:21'
</code></pre>
<p>a poor/unexpected result - these are the <strong>code points</strong> that combine to make the <strong>graphemes</strong> we see in unicode, from the unicode consortium - representing languages all over the world. This is <em>not</em> how we actually store this information so it can be interpreted by other sources, though.</p>
<p>To allow another source to use this data, we would usually need to convert to utf-8 encoding, for example, to save this string in bytes to disk or to publish to html. So we need that encoding to convert the code points to the <strong>code units</strong> of utf-8 - in Python 3, <code>ord</code> is not needed because <code>bytes</code> are iterables of integers:</p>
<pre><code>&gt;&gt;&gt; ":".join("{:02x}".format(c) for c in a_string.encode('utf-8'))
'd0:9f:d1:80:d0:b8:d0:b2:d0:b5:d1:82:20:d0:bc:d0:b8:d1:80:21:21'
</code></pre>
<p>Or perhaps more elegantly, using the new f-strings (only available in Python 3):</p>
<pre><code>&gt;&gt;&gt; ":".join(f'{c:02x}' for c in a_string.encode('utf-8'))
'd0:9f:d1:80:d0:b8:d0:b2:d0:b5:d1:82:20:d0:bc:d0:b8:d1:80:21:21'
</code></pre>
<p>In Python 2, pass <code>c</code> to <code>ord</code> first, i.e. <code>ord(c)</code> - more examples:</p>
<pre><code>&gt;&gt;&gt; ":".join("{:02x}".format(ord(c)) for c in a_string.encode('utf-8'))
'd0:9f:d1:80:d0:b8:d0:b2:d0:b5:d1:82:20:d0:bc:d0:b8:d1:80:21:21'
&gt;&gt;&gt; ":".join(format(ord(c), '02x') for c in a_string.encode('utf-8'))
'd0:9f:d1:80:d0:b8:d0:b2:d0:b5:d1:82:20:d0:bc:d0:b8:d1:80:21:21'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://pypi.python.org/pypi/hexdump" rel="noreferrer"><code>hexdump</code></a>'s</p>
<pre><code>import hexdump
hexdump.dump("Hello World", sep=":")
</code></pre>
<p>(append <code>.lower()</code> if you require lower-case). This works for both Python 2 &amp; 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using map and lambda function can produce a list of hex values, which can be printed (or used for other purposes)</p>
<pre><code>&gt;&gt;&gt; s = 'Hello 1 2 3 \x01\x02\x03 :)'

&gt;&gt;&gt; map(lambda c: hex(ord(c)), s)
['0x48', '0x65', '0x6c', '0x6c', '0x6f', '0x20', '0x31', '0x20', '0x32', '0x20', '0x33', '0x20', '0x1', '0x2', '0x3', '0x20', '0x3a', '0x29']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done in following ways:</p>
<pre><code>from __future__ import print_function
str = "Hello World !!"
for char in str:
    mm = int(char.encode('hex'), 16)
    print(hex(mm), sep=':', end=' ' )
</code></pre>
<p>The output of this will be in hex as follows:</p>
<blockquote>
<blockquote>
<p>0x48 0x65 0x6c 0x6c 0x6f 0x20 0x57 0x6f 0x72 0x6c 0x64 0x20 0x21 0x21</p>
</blockquote>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Just for convenience, very simple. </p>
<pre><code>def hexlify_byteString(byteString, delim="%"):
    ''' very simple way to hexlify a bytestring using delimiters '''
    retval = ""
    for intval in byteString:
        retval += ( '0123456789ABCDEF'[int(intval / 16)])
        retval += ( '0123456789ABCDEF'[int(intval % 16)])
        retval += delim
    return( retval[:-1])

hexlify_byteString(b'Hello World!', ":")
# Out[439]: '48:65:6C:6C:6F:20:57:6F:72:6C:64:21'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3:</p>
<pre><code>":".join(c.encode().hex() for c in "Hello world !!")
# 48:65:6c:6c:6f:20:77:6f:72:6c:64:20:21:21
</code></pre>
<p>This is similar to @Aesthete's answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>base64.b16encode</code> in <strong>python2</strong> (its built-in)</p>
<pre><code>&gt;&gt;&gt; s = 'Hello world !!'
&gt;&gt;&gt; h = base64.b16encode(s)
&gt;&gt;&gt; ':'.join([h[i:i+2] for i in xrange(0, len(h), 2)]
'48:65:6C:6C:6F:20:77:6F:72:6C:64:20:21:21'
</code></pre>
</div>
<span class="comment-copy">Great, it works in python3 while Aesthete's answer don't.</span>
<span class="comment-copy">Note that in python3, the concept of printing a <code>str</code> as hex doesn't really make sense; you'll want to print <code>bytes</code> object as hex (convert <code>str</code> to <code>bytes</code> by calling <code>.encode()</code>).</span>
<span class="comment-copy">In fact, this produces invalid output in python3: <code>":".join("{:02x}".format(ord(c)) for c in 'løl')</code> returns <code>'6c:f8:6c'</code>, while <code>":".join("{:02x}".format(c) for c in 'løl'.encode())</code> produces the correct utf-8 representation <code>'6c:c3:b8:6c'</code>.</span>
<span class="comment-copy">How to do this in python3?</span>
<span class="comment-copy">@hyh: <code>h = binascii.hexlify(b"Hello world !!") to get hex string. b":".join(h[i:i+2] for i in range(0, len(h), 2))</code> to insert <code>':'</code> after every two hex digits in it.</span>
<span class="comment-copy">it should also be noted, that the later will ALSO work with python2.x AND it will also work for non-ascii characters</span>
<span class="comment-copy">But also note that the latter does not pad leading zeros: hex(ord("\x00"))[2:] is "0" and "\x00".encode("hex") == "00"</span>
<span class="comment-copy">Why did you decide to post this as a new answer, months after both of these solutions had been offered by other users? If the point was to clarify version compatibility, it would have made more sense to suggest edits to the existing answers.</span>
<span class="comment-copy">As noted elsewhere, this answer is not even correct once one moves beyond ascii and considers unicode. ':'.join(hex(ord(x))[2:] for x in 'løl') incorrectly prints '6c:f8:6c' while the correct output is '6c:c3:b8:6c'.</span>
<span class="comment-copy">I get <code>TypeError: ord() expected string of length 1, but int found</code> with this...</span>
<span class="comment-copy">@not2qubit please try these examples again - I took a little time to address the differences between Python 2 and 3, and apparently I originally only wrote these for Python 2. And thanks for QA'ing my answer!</span>
<span class="comment-copy">Yes, that did it. Thank you!</span>
<span class="comment-copy">Also a problem I ran into, if you have problems installing hexdump or any other package it is usualy because of the proxy settings try run pip with the proxy option  <code>pip install -U hexdump --proxy http://proxy.address:port</code></span>
<span class="comment-copy">Actually I made the mistake of using <code>sudo</code> with <code>pip</code>, which messed up <code>pacman</code>...</span>
<span class="comment-copy">where do i find the <b>future</b></span>
<span class="comment-copy">never mind, figured it out</span>
<span class="comment-copy">This doesn't work. What are you using for import and why not use <code>.decode()</code>?</span>
