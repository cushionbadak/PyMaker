<div class="post-text" itemprop="text">
<p>I'm assigning all my MongoDB documents a GUID using uuid.uuid1(). I want a way I can derive an 11 character, unique, case-sensitive YouTube-like ID, such as </p>
<pre><code>1_XmY09uRJ4 
</code></pre>
<p>from uuid's resulting hex string which looks like</p>
<pre><code>ae0a0c98-f1e5-11e1-9t2b-1231381dac60
</code></pre>
<p>I want to be able to match the shortened ID to the hex and vice-versa, dynamically without having to store another string in the database. Does anyone have some sample code or can point me in the direction of the module or formula that can do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Convert the underlying bytes to a base64 value, stripping the <code>=</code> padding and the newline.</p>
<p>You probably want to use the <a href="https://docs.python.org/3/library/base64.html#base64.urlsafe_b64encode" rel="nofollow noreferrer"><code>base64.urlsafe_b64encode()</code> function</a> to avoid using <code>/</code> and <code>+</code> (<code>_</code> and <code>-</code> are used instead), so the resulting string can be used as a URL path element:</p>
<pre><code>&gt;&gt;&gt; import uuid, base64
&gt;&gt;&gt; base64.urlsafe_b64encode(uuid.uuid1().bytes).rstrip(b'=').decode('ascii')
'81CMD_bOEeGbPwAjMtYnhg'
</code></pre>
<p>The reverse:</p>
<pre><code>&gt;&gt;&gt; uuid.UUID(bytes=base64.urlsafe_b64decode('81CMD_bOEeGbPwAjMtYnhg' + '=='))
UUID('f3508c0f-f6ce-11e1-9b3f-002332d62786')
</code></pre>
<p>To turn that into generic functions:</p>
<pre><code>from base64 import urlsafe_b64decode, urlsafe_b64encode
from uuid import UUID

def uuid2slug(uuidstring):
    return urlsafe_b64encode(UUID(uuidstring).bytes).rstrip(b'=').decode('ascii')

def slug2uuid(slug):
    return str(uuid.UUID(bytes=urlsafe_b64decode(slug + '==')))
</code></pre>
<p>This gives you a method to represent the 16-byte UUID in a more compact form. Compress any further and you loose information, which means you cannot decompress it again to the full UUID.</p>
<p>YouTube's unique string is thus not based on a full 16-byte UUID, their 11 character ids are probably stored in the database for easy lookup and based on a smaller value.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could look into Python's <code>base64</code> model. A GUID is essentially a base-16 representation of a number, and you could trim out the hyphens, decode from base 16, and encode into base 64. Going in reverse requires decoding from base 64, encoding in base 16, and inserting the hyphens in the appropriate places.</p>
</div>
<div class="post-text" itemprop="text">
<p>For those looking specifically for a way to shorten uuids in a url safe way, the really useful answer from <a href="https://stackoverflow.com/users/100297/martijn-pieters">@MartijnPieters</a> can be simplified some using the <a href="https://docs.python.org/3/library/base64.html" rel="nofollow noreferrer"><code>base64</code></a> module to handle the characters that are not url safe similar to the comment on that answer from <a href="https://stackoverflow.com/users/3689902/okoboko">@okoboko</a> (without a few unnecessary bits).</p>
<pre><code>import base64
import uuid

# uuid to b64 string and back
uuid_to_b64str = base64.urlsafe_b64encode(uuid.uuid1().bytes).decode('utf8').rstrip('=\n')
b64str_to_uuid = uuid.UUID(bytes=base64.urlsafe_b64decode(f'{uuid_to_b64str}=='))

# uuid string to b64 string and back
uuidstr_to_b64str = base64.urlsafe_b64encode(uuid.UUID(str(uuid.uuid1())).bytes).decode('utf8').rstrip('=\n')
b64str_to_uuidstr = str(uuid.UUID(bytes=base64.urlsafe_b64decode(f'{uuidstr_to_b64str}==')))
</code></pre>
</div>
<span class="comment-copy">Is the "t" a typo?</span>
<span class="comment-copy">what "t"? I'm not sure what you're referring to</span>
<span class="comment-copy">@yourfriendzak: your UUID contains a 't', making it invalid.</span>
<span class="comment-copy"><code>9t2b</code> That's not hex.</span>
<span class="comment-copy">AFAIR, UUIDs have a time component. It's possible your string uses the 't' as a delimiter.</span>
