<div class="post-text" itemprop="text">
<p>In Python, ssl.wrap_socket can read certificates from files, ssl.wrap_socket require the certificate as a file path.</p>
<p>How can I start an SSL connection using a certificate read from string variables? </p>
<p>My host environment does not allow write to files, and tempfile module is not functional<br/>
I'm using Python 2.7.<br/>
I store the certificate inside MySQL and read as a string.</p>
<p>Edit:
I gave up, this is basically require implement ssl by pure python code, this is beyond my current knowledge.</p>
</div>
<div class="post-text" itemprop="text">
<p>Looking at the source, ssl.wrap_socket calls directly into the native code (openssl) function  SSL_CTX_use_cert_chain_file which requires a path to a file, so what you are trying to do is not possible.</p>
<p>For reference:</p>
<p>In ssl/<strong>init</strong>.py we see:</p>
<pre><code>def wrap_socket(sock, keyfile=None, certfile=None,
                server_side=False, cert_reqs=CERT_NONE,
                ssl_version=PROTOCOL_SSLv23, ca_certs=None,
                do_handshake_on_connect=True):

    return SSLSocket(sock, keyfile=keyfile, certfile=certfile,
                   server_side=server_side, cert_reqs=cert_reqs,
                   ssl_version=ssl_version, ca_certs=ca_certs,
                   do_handshake_on_connect=do_handshake_on_connect)
</code></pre>
<p>Points us to the SSLSocket constructor (which is in the same file) and we see the following happen:</p>
<pre><code>self._sslobj = _ssl2.sslwrap(self._sock, server_side,
                                     keyfile, certfile,
                                     cert_reqs, ssl_version, ca_certs)
</code></pre>
<p>_ssl2 is implemented in C (_ssl2.c)</p>
<p>Looking at the sslwrap function, we see it's creating a new object:</p>
<pre><code>    return (PyObject *) newPySSLObject(Sock, key_file, cert_file,
                                       server_side, verification_mode,
                                       protocol, cacerts_file);
</code></pre>
<p>Looking at the constructor for that object, we eventually see:</p>
<pre><code>            ret = SSL_CTX_use_certificate_chain_file(self-&gt;ctx,
                                                     cert_file);
</code></pre>
<p>That function is defined in openssl, so now we need to switch to that codebase.</p>
<p>In ssl/ssl_rsa.c we eventually find in the function:</p>
<pre><code>BIO_read_filename(in,file) 
</code></pre>
<p>If you dig far enough into the BIO code (part of openssl) you'll eventually come to a normal fopen():</p>
<pre><code>fp=fopen(ptr,p);
</code></pre>
<p>So it looks like as it's currently written. It must be in a file openable by C's fopen().  </p>
<p>Also, since python's ssl library so quickly jumps into C, I don't see a immediately obvious place to monkeypatch in a workaround either.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quick look though the ssl module source confirms what you want is not supported by the API:
<a href="http://code.google.com/codesearch#2T6lfGELm_A/trunk/Modules/_ssl.c&amp;q=sslwrap&amp;type=cs" rel="nofollow noreferrer">http://code.google.com/codesearch#2T6lfGELm_A/trunk/Modules/_ssl.c&amp;q=sslwrap&amp;type=cs</a></p>
<p>Which is not to say it is impossible, you could create a named pipe, feed one end from Python and give the filename to the ssl module.</p>
<p>For simpler, less secure use, dump cert from memory to mkstemp()'d file.</p>
<p>You could even mount FUSE volume and intercept file callback.</p>
<p>Finally, use ctypes to hack at ssl context at runtime and load cert/ket from a buffer following the C recipe <a href="https://stackoverflow.com/questions/3810058/read-certificate-files-from-memory-instead-of-file-openssl">Read certificate files from memory instead of a file using OpenSSL</a> Things like these have been done before, but it's not for the faintest of heart.</p>
<p>It looks like you are trying to get out of e.g. app engine "jail," perhaps it is just not possible?</p>
<p>If you are not picky on ssl implementation, you can use M2Crypto, TLS Lite, pyOpenSSL or something else. The earlier is pure python, you can definitely hack it to use in-memory certificates/keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>From Python 3.4, you can use SSLContext#load_verify_locations:</p>
<pre><code>context = ssl.SSLContext()
context.load_verify_locations(cadata=cert)  # Where cert is str.
</code></pre>
<p>From <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_verify_locations" rel="nofollow noreferrer">https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_verify_locations</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can treat strings like files with <a href="http://docs.python.org/library/stringio.html" rel="nofollow">StringIO</a>.</p>
</div>
<span class="comment-copy">Surely your host environment allows you to store SSL certificates, somehow? even if they want to supply them themselves.</span>
<span class="comment-copy">I saved the certificate data in mysql. my code need a ssl socket to another host to retrieve data. I read the certificate from database, but don't know how to create the ssl wrap.</span>
<span class="comment-copy">Looking at the source, ssl.wrap_socket calls directly into the native code (openssl) function  SSL_CTX_use_cert_chain_file which requires a path to a file, so what you are trying to do is not possible.  You need to write the cert to a file for this to work.</span>
<span class="comment-copy">Perhaps it is practical to enter all possible CA certificates to a static file, direct SSL to use that file and check what CA was verified against after the connection is established?</span>
<span class="comment-copy">I have similar issue when I was developing backend for ios application. I didn't try yet - but maybe you can switch to pyOpenSSL instead of native ssl. For my case I would try this library <a href="https://pypi.python.org/pypi/apns-client/0.2.1" rel="nofollow noreferrer">pypi.python.org/pypi/apns-client/0.2.1</a> instead of this <a href="https://pypi.python.org/pypi/apns/2.0.1" rel="nofollow noreferrer">pypi.python.org/pypi/apns/2.0.1</a></span>
<span class="comment-copy">Pretty much hoped for a dirty hack...</span>
<span class="comment-copy">I have java client and python server. I prepared java keystore, extracted keys and certificate from it as pem files and specified them for <code>wrap_socket()</code> in python server. Now I am able to read key and certificate strings directly from keystore using <code>pyjks</code> as a string. Cant I use those key and certificate strings for preparing ssl socket in some way?</span>
<span class="comment-copy">@domenukk Can you please confirm if it is not really possible to do what I have explained in above comment?</span>
<span class="comment-copy">Yes I can confirm it's not possible. You will need to store them to disk or some sort of tmpfs or pseudo filesystem.</span>
<span class="comment-copy">dima's suggestion below about using a pure-python crypto library like M2 is probably the best solution to this issue.</span>
<span class="comment-copy">The named pipe is basically a temp file, isn't it? Very good ideas though. I think using M2Crypto or something similar will be the best approach then.</span>
<span class="comment-copy">yes creating named pipe requires write permission on filesystem</span>
<span class="comment-copy">Even after having hooked into <code>load_verify_locations</code> of <code>ssl._ssl._SSLContext</code> using ctypes hackery, all that function gets is a <code>ssl.SSLContext</code> object  and it's a mystery to me how to use that to access the right memory location that was allocated for the underlying <code>PySSLContext</code> parent class, so that I can retrieve the pointer to its <code>ctx</code> member of type <code>SL_CTX *</code>. Does anybody have any (literal) pointers?</span>
<span class="comment-copy">In case anybody else is interested in how to pull this off, I made this problem into a separate question: <a href="https://stackoverflow.com/questions/46762019">stackoverflow.com/questions/46762019</a></span>
<span class="comment-copy">This also appears to work in Python 2.7: <a href="https://docs.python.org/2/library/ssl.html#ssl.create_default_context" rel="nofollow noreferrer">docs.python.org/2/library/ssl.html#ssl.create_default_context</a></span>
<span class="comment-copy">StringIO is not working under ssl.wrap_socket, that require a string as file path.  Exception: TypeError('must be string or None, not instance',) Traceback: Traceback (most recent call last):   File "/data1/www/htdocs/705/pty/1/pty.py", line 23, in connect     self.push.connect(self.gateway)   File "/usr/local/sae/python/lib/python2.7/ssl.py", line 331, in connect     self._real_connect(addr, False)   File "/usr/local/sae/python/lib/python2.7/ssl.py", line 314, in _real_connect     self.ca_certs, self.ciphers) TypeError: must be string or None, not instance</span>
<span class="comment-copy">So it takes a file path and not a file object</span>
