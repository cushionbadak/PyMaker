<div class="post-text" itemprop="text">
<p>I'm writing a script that checks multiple sources for weather data, then parses them for an some scripts on Scripting Layer for Android. The google API stopped working, so this is a hacked together replacement for the old weather module. </p>
<p>I made a class called "weatherdata", and I want to have all instances of the class add themselves to a list called "weatherobjects", for shenanigans like this:</p>
<pre><code>    for source in weatherobjects:
        source.check()
</code></pre>
<p>Here's the catch: each time the function that fetches the weather is called, it causes the objects to run their <code>__init__</code> method (I think this is technically called a constructor method?) without destroying the objects, or clearing the list. This is intentional. The problem comes when the function is called more than once in the lifetime of the module, and and the objects get redundantly added to the list. This seems like a potential source of a memory leak.</p>
<p>Here's the <code>__init__</code> method:</p>
<pre><code>class weatherdata():
    def __init__(self, url, unit = 'f'):
        self.url = url
        self.unit = unit
        print(self) #debug statement, please ignore
        if self not in weatherobjects:
            weatherobjects.append(self)
        if self.url.count("yahoo"):
            self.yahoo = True
        else:
            self.yahoo = False
        self.check()
</code></pre>
<p>And the troublesome function:</p>
<pre><code>def fetch_weather(location=98661, hl='', weatherobjects= []):
    yahoo = weatherdata(yahoo_url, 'f')
    wunderground = weatherdata(wunderground_url, 'f')
    data = {}
    data['city'] = 'Vancouver'
    data['temperature'] = wunderground.temp
    data['conditions'] = 'foo'
    return data
</code></pre>
<p>Here's some shell output for context:</p>
<pre><code>&gt;&gt;&gt; weatherobjects
[&lt;__main__.weatherdata object at 0x01F8BDF0&gt;, &lt;__main__.weatherdata object at 0x02035B70&gt;]
&gt;&gt;&gt; for i in range(3):
...     fetch_weather()
...
{'city': 'Vancouver', 'conditions': 'foo', 'temperature': '66.7'}
{'city': 'Vancouver', 'conditions': 'foo', 'temperature': '66.7'}
{'city': 'Vancouver', 'conditions': 'foo', 'temperature': '66.7'}
&gt;&gt;&gt; weatherobjects
[&lt;__main__.weatherdata object at 0x01F8BDF0&gt;, &lt;__main__.weatherdata object at 0x02035B70&gt;, &lt;__main__.weatherdata object at 0x01FA2E10&gt;, &lt;__main__.weatherdata object at 0x01FA2FB0&gt;, &lt;__main__.weatherdata object at 0x02035C30&gt;, &lt;__main__.weatherdata object at 0x02035E10&gt;, &lt;__main__.weatherdata object at 0x02035DF0&gt;, &lt;__main__.weatherdata object at 0x02035D10&gt;]
&gt;&gt;&gt; len(weatherobjects)
8
</code></pre>
<p>As you can see, there's a lot of redundancy in the list. Is it possible to do this in the <code>__init__</code> method? Or do I need to have a main function do something like <code>weatherobjects.append(foo)</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your custom classes do not define what it means to be equal. If you were to add a <a href="http://docs.python.org/py3k/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code></a> method that tells python how to compare two instances, the <code>in</code> test would be able to find duplicates:</p>
<pre><code>def __eq__(self, other):
    if not isinstance(other, self.__class__):
        return NotImplemented
    return self.url == other.url and self.unit == other.unit
</code></pre>
<p>To complement the method, you should add a <code>__ne__</code> method as well:</p>
<pre><code>def __ne__(self, other):
    return not self.__eq__(other)
</code></pre>
<p>If your weatherdata objects don't change (are not mutable) after creation, you can add a <a href="http://docs.python.org/reference/datamodel.html#object.__hash__" rel="nofollow"><code>__hash__</code> method</a> and store your instances in a set instead of a list. Using a set would speed up the <code>in</code> test. An example <code>__hash__</code> method would be:</p>
<pre><code>def __hash__(self):
    return hash((self.url, self.unit))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of adding the sources to a list, you could consider a dictionary.</p>
<p>If the weatherdata class could then identify itself (<code>def __repr__():</code> perhaps) uniquely, you can add the it to a dictionary..</p>
<pre><code>weatherobjects[str(self)] = self
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So two years later, I have found the answer while working on something else, and come back to this. Putting aside other issues with my code, I think I should have defined the list in the class (before instantiation), rather than as a global.</p>
<p>My desired behavior was like this example, <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow">taken from the Python Docs</a>:</p>
<pre><code> class Dog:

    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

    &gt;&gt;&gt; d = Dog('Fido')
    &gt;&gt;&gt; e = Dog('Buddy')
    &gt;&gt;&gt; d.add_trick('roll over')
    &gt;&gt;&gt; e.add_trick('play dead')
    &gt;&gt;&gt; d.tricks                
    ['roll over', 'play dead']
</code></pre>
<p>This is inappropriate because dogs don't have a hivemind, but the behavior is not explicitly disapproved of in the docs, so I'm going to roll with it. I WANT my weatherobjects to have a hivemind. </p>
<p>So instead of something like this,</p>
<pre><code>global weatherobjectslist
class weathersource():
    def __init__(self, weatherobjectlist):
        weatherobjectlist.append(self)
</code></pre>
<p>My desired behavior is produced by this:</p>
<pre><code>class weathersource():
    weathersourcelist = []

    def __init__(self, name):
        self.weathersourcelist.append(self)
        self.name = name
</code></pre>
<p>Now, I can check weathersource.weathersourcelist for a list of all my objects. </p>
<p>To put this more generically, here's an example with the same behavior, and some output:</p>
<pre><code>&gt;&gt;&gt; class person():
    people= []
    def __init__(self, name):
        self.people.append(self)
        self.name = name


&gt;&gt;&gt; a,b,c = person('bob'), person('joe'), person('steve')

&gt;&gt;&gt; for individual in person.people:
    print(individual.name)


bob
joe
steve
</code></pre>
</div>
<span class="comment-copy">You need to pass your <code>fetch_weather()</code> function a <code>weatherobjects</code> list so it doesn't use (and modify) the initially empty default argument list each time it's called. BTW, you generally shouldn't using mutable default arguments like that. Make the default value <code>None</code> and check for it and use <code>[]</code> conditionally in the function.</span>
<span class="comment-copy">For future posts, detailed code formatting help is available at: <a href="http://meta.stackexchange.com/q/22186">How do I format my code blocks?</a></span>
<span class="comment-copy">@martineau, It actually works just fine, but that's because I made the list global-- probably an even worse practice than the mutable default arguments.</span>
<span class="comment-copy">@user1695366: I see now that you don't even reference <code>weatherobjects</code> in <code>fetch_weather()</code>. In fact, you couldn't reference the global list by that name in the function even if you wanted to since the unused argument hides global list by the same name.</span>
<span class="comment-copy">Even better, define <code>__hash__</code>, and use a <code>set</code>.</span>
<span class="comment-copy">@DanielRoseman: indeed, added an example.</span>
<span class="comment-copy">Thanks for the help!</span>
<span class="comment-copy">@user1695366: Glad I could have been of service! Did you know you can mark an answer as helpful? That way future visitors can see that an answer solved your problem. See <a href="http://meta.stackexchange.com/q/5234">How does accepting an answer work?</a></span>
<span class="comment-copy">I just wrote the <code>__eq__</code> method. After writing the method, I went back and looked at your method. I'm now rewriting mine. I didn't think to return the test &lt;code&gt;self.url==other.url&lt;/code&gt;. Mind blown.</span>
