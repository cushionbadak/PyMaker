<div class="post-text" itemprop="text">
<p>I am in need of a Python (2.7) object that functions like a set (fast insertion, deletion, and membership checking) but has the ability to return a random value. Previous questions asked on stackoverflow have answers that are things like:</p>
<pre><code>import random
random.sample(mySet, 1)
</code></pre>
<p>But this is quite slow for large sets (it runs in O(n) time). </p>
<p>Other solutions aren't random enough (they depend on the internal representation of python sets, which produces some results which are very non-random):</p>
<pre><code>for e in mySet:
    break
# e is now an element from mySet
</code></pre>
<p>I coded my own rudimentary class which has constant time lookup, deletion, and random values.</p>
<pre><code>class randomSet:
    def __init__(self):
        self.dict = {}
        self.list = []

    def add(self, item):
        if item not in self.dict:
            self.dict[item] = len(self.list)
            self.list.append(item)

    def addIterable(self, item):
        for a in item:
            self.add(a)

    def delete(self, item):
        if item in self.dict:
            index = self.dict[item]
            if index == len(self.list)-1:
                del self.dict[self.list[index]]
                del self.list[index]
            else:
                self.list[index] = self.list.pop()
                self.dict[self.list[index]] = index
                del self.dict[item]

    def getRandom(self):
        if self.list:
            return self.list[random.randomint(0,len(self.list)-1)]

    def popRandom(self):
        if self.list:
            index = random.randint(0,len(self.list)-1)
            if index == len(self.list)-1:
                del self.dict[self.list[index]]
                return self.list.pop()
            returnValue = self.list[index]
            self.list[index] = self.list.pop()
            self.dict[self.list[index]] = index
            del self.dict[returnValue]
            return returnValue
</code></pre>
<p>Are there any better implementations for this, or any big improvements to be made to this code?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the best way to do this would be to use the <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="noreferrer"><code>MutableSet</code></a> abstract base class in <code>collections</code>. Inherit from <code>MutableSet</code>, and then define <code>add</code>, <code>discard</code>, <code>__len__,</code> <code>__iter__</code>, and <code>__contains__</code>; also rewrite <code>__init__</code> to optionally accept a sequence, just like the <code>set</code> constructor does. <code>MutableSet</code> provides built-in definitions of all other <code>set</code> methods based on those methods. That way you get the full <code>set</code> interface cheaply. (And if you do this, <code>addIterable</code> is defined for you, under the name <code>extend</code>.) </p>
<p><code>discard</code> in the standard <code>set</code> interface appears to be what you have called <code>delete</code> here. So rename <code>delete</code> to <code>discard</code>. Also, instead of having a separate <code>popRandom</code> method, you could just define <code>popRandom</code> like so:</p>
<pre><code>def popRandom(self):
    item = self.getRandom()
    self.discard(item)
    return item
</code></pre>
<p>That way you don't have to maintain two separate item removal methods. </p>
<p>Finally, in your item removal method (<code>delete</code> now, <code>discard</code> according to the standard set interface), you don't need an if statement. Instead of testing whether <code>index == len(self.list) - 1</code>, simply swap the final item in the list with the item at the index of the list to be popped, and make the necessary change to the reverse-indexing dictionary. Then pop the last item from the list and remove it from the dictionary. This works whether <code>index == len(self.list) - 1</code> or not:</p>
<pre><code>def discard(self, item):
    if item in self.dict:
        index = self.dict[item]
        self.list[index], self.list[-1] = self.list[-1], self.list[index]
        self.dict[self.list[index]] = index
        del self.list[-1]                    # or in one line:
        del self.dict[item]                  # del self.dict[self.list.pop()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach you could take is to derive a new class from <code>set</code> which salts itself with random objects of a type derived from <code>int</code>. </p>
<p>You can then use <code>pop</code> to select a random element, and if it is not of the salt type, reinsert and return it, but if it is of the salt type, insert a new, randomly-generated salt object (and pop to select a new object). </p>
<p>This will tend to alter the order in which objects are selected. On average, the number of attempts will depend on the proportion of salting elements, i.e. amortised O(k) performance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Can't we implement a new class inheriting from <code>set</code> with some (hackish) modifications that enable us to retrieve a random element from the list with O(1) lookup time? Btw, on Python 2.x you should inherit from <code>object</code>, i.e. use <code>class randomSet(object)</code>. Also <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP8</a> is something to consider for you :-)</p>
<p>Edit:
For getting some ideas of what hackish solutions might be capable of, this thread is worth reading:
<a href="http://python.6.n6.nabble.com/Get-item-from-set-td1530758.html" rel="nofollow">http://python.6.n6.nabble.com/Get-item-from-set-td1530758.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, I'd implement an "ordered set" in much the same way you did - and use a list as an internal data structure.</p>
<p>However, I'd inherit straight from "set" and just keep track of the added items in an 
internal list (as you did) - and leave the methods I don't use alone.</p>
<p>Maybe add a "sync" method to update the internal list whenever the set is updated
by set-specific operations, like the *_update methods.</p>
<p>That if using an "ordered dict" does not cover your use cases. (I just found that trying to cast ordered_dict keys to a regular set is not optmized, so if you need set operations on your data that is not an option)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't mind only supporting comparable elements, then you could use <code>blist.sortedset</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution from scratch, which adds and pops in constant time. I also included some extra set functions for demonstrative purposes.</p>
<pre><code>from random import randint


class RandomSet(object):
  """
  Implements a set in which elements can be
  added and drawn uniformly and randomly in
  constant time.
  """

  def __init__(self, seq=None):
    self.dict = {}
    self.list = []
    if seq is not None:
      for x in seq:
        self.add(x)

  def add(self, x):
    if x not in self.dict:
      self.dict[x] = len(self.list)
      self.list.append(x)

  def pop(self, x=None):
    if x is None:
      i = randint(0,len(self.list)-1)
      x = self.list[i]
    else:
      i = self.dict[x]
    self.list[i] = self.list[-1]
    self.dict[self.list[-1]] = i
    self.list.pop()
    self.dict.pop(x)
    return x

  def __contains__(self, x):
    return x in self.dict

  def __iter__(self):
    return iter(self.list)

  def __repr__(self):
    return "{" + ", ".join(str(x) for x in self.list) + "}"

  def __len__(self):
    return len(self.list)
</code></pre>
</div>
<span class="comment-copy">why would you not just use a list and cast it  as a set when you needed set operation stuff? ...</span>
<span class="comment-copy">This allows you to interleve adding elements with selecting elements without a performance penalty.  Does you real life scenario really follow this pattern?  If you can do all your adding of elements up front, you could start with a set, then cast to a list before grabbing random elements.</span>
<span class="comment-copy">Because that is very very slow (runs in O(n) time) for large lists.</span>
<span class="comment-copy">@GrantS:  Do you mean that the list creation is slow?  That would only need to be done once.  It's no slower than creating a list and a dictionary as you do in your class.</span>
<span class="comment-copy">@GrantS: If you are ysing Python 2.x, for the Greater Good of all: inherit from "object", or other new style base. Do not use old style classes (by not declaring a superclass) - you can get seriously hurt with a hard to debug problem</span>
<span class="comment-copy">+2 if I could.  It's nice to get a set interface for so little.  And excellent advice on streamlining the implementation.</span>
<span class="comment-copy">If this is the solution that the thread opener uses, I would be highly interested in a seeing the <code>T(setsize)</code> graph for both this solution and a O(N) lookup solution on a default set, with <code>T</code> being the time required for a lookup.</span>
<span class="comment-copy">+1, for the idea but I'd like to know if did test some form of this. I am not shure if salting sets would be that effective.</span>
<span class="comment-copy">@jsbueno Order of insertion is known to affect the order of iteration in sets, but yes, I guess this also depends on the fine details of the hashing scheme used.</span>
<span class="comment-copy">You should always explicitly inherit from object if your class has no other base classes and you're not using python3 :)</span>
<span class="comment-copy">Why would I inherit from set? The only way this works is with a dict which points to the index of a value in a list. It doesn't use sets at all, so I don't see how inheriting from set would help.  EDIT: Wait, I might see what you're saying. Is my use of a dict here entirely unnecessary?</span>
<span class="comment-copy">No.  Inheriting from <code>set</code> would be inefficient because <code>random.sample</code> would need to iterate over the entire set making it O(n).</span>
<span class="comment-copy">@GrantS: I did not mean that you should just make your <code>randomSet</code> inherit from <code>set</code>. I was thinking of an entirely different solution that bases on <code>set</code>, but somehow hacks <code>set</code> in order to access a random item. Now, I see that there is no obvious way to do so without iterating over the set.</span>
<span class="comment-copy">@Jan-Philip Gehrcke Indeed. I could do it with just <code>set</code> and <code>list</code> but that makes deletion run in O(n) time (which is why the <code>dict</code> is necessary).</span>
<span class="comment-copy">There's an error in the pop method: if x != None, i is not defined</span>
