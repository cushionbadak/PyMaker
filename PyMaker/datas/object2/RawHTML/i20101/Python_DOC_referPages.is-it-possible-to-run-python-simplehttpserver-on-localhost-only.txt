<div class="post-text" itemprop="text">
<p>I have a vpn connection and when I'm running python -m SimpleHTTPServer, it serves on 0.0.0.0:8000, which means it can be accessed via localhost <strong>and</strong> via my real ip.
I don't want robots to scan me and interested that the server will be accessed only via localhost.</p>
<p>Is it possible? </p>
<pre><code>python -m SimpleHTTPServer 127.0.0.1:8000  # doesn't work.
</code></pre>
<p>Any other simple http server which can be executed instantly using the command line is also welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you read the source you will see that only the port can be overridden on the command line.  If you want to change the host it is served on, you will need to implement the <code>test()</code> method of the <code>SimpleHTTPServer</code> and <code>BaseHTTPServer</code> yourself.  But that should be really easy.</p>
<p>Here is how you can do it, pretty easily:</p>
<pre><code>import sys
from SimpleHTTPServer import SimpleHTTPRequestHandler
import BaseHTTPServer


def test(HandlerClass=SimpleHTTPRequestHandler,
         ServerClass=BaseHTTPServer.HTTPServer):

    protocol = "HTTP/1.0"
    host = ''
    port = 8000
    if len(sys.argv) &gt; 1:
        arg = sys.argv[1]
        if ':' in arg:
            host, port = arg.split(':')
            port = int(port)
        else:
            try:
                port = int(sys.argv[1])
            except:
                host = sys.argv[1]

    server_address = (host, port)

    HandlerClass.protocol_version = protocol
    httpd = ServerClass(server_address, HandlerClass)

    sa = httpd.socket.getsockname()
    print "Serving HTTP on", sa[0], "port", sa[1], "..."
    httpd.serve_forever()


if __name__ == "__main__":
    test()
</code></pre>
<p>And to use it:  </p>
<pre><code>&gt; python server.py 127.0.0.1     
Serving HTTP on 127.0.0.1 port 8000 ...

&gt; python server.py 127.0.0.1:9000
Serving HTTP on 127.0.0.1 port 9000 ...

&gt; python server.py 8080          
Serving HTTP on 0.0.0.0 port 8080 ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As <em>@sberry</em> explained, simply doing it by using the nice <code>python -m ...</code> method won't be possible, because the IP address is hardcoded in the implementation of the <code>BaseHttpServer.test</code> function.</p>
<p>A way of doing it from the command line without writing code to a file first would be</p>
<pre><code>python -c 'import BaseHTTPServer as bhs, SimpleHTTPServer as shs; bhs.HTTPServer(("127.0.0.1", 8888), shs.SimpleHTTPRequestHandler).serve_forever()'
</code></pre>
<p>If that still counts as a one liner depends on your terminal width ;-) It's certainly not very easy to remember.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python versions 3.4 and higher, the <code>http.server</code> module accepts a <code>bind</code> parameter.</p>
<p>According <a href="https://docs.python.org/3/library/http.server.html" rel="noreferrer">to the docs</a>:</p>
<blockquote>
<p><code>python -m http.server 8000</code></p>
<p>By default, server binds itself to all interfaces. The option
  -b/--bind specifies a specific address to which it should bind. For example, the following command causes the server to bind to localhost
  only:</p>
<p><code>python -m http.server 8000 --bind 127.0.0.1</code></p>
<p>New in version 3.4: --bind argument was introduced.</p>
</blockquote>
</div>
<span class="comment-copy">You could simply block outside connections on that port from your firewall/router.</span>
<span class="comment-copy">While a good question for python2, it may be noted here that in python3 the replacement <code>http.server</code> allows binding right away, e.g <code>python3 -m http.server --bind 127.0.0.1 8000</code> would suffice</span>
<span class="comment-copy"><i>Sidenote</i>: <code>SimpleHTTPServer</code> is single-threading and blocking, meaning you won't be able to do another request until the previous request is over. And it has no range support e.g. for streaming/seeking a media file from a specific position. A better alternative is <code>twisted</code> (<code>pip install twisted</code>) which you can run with <code>twistd -n web --path /</code>. It can also do anonymous FTP with <code>twistd -n ftp -p 2121 -r /</code>. More http server one-liners: <a href="https://gist.github.com/willurd/5720255" rel="nofollow noreferrer">gist.github.com/willurd/5720255</a>.</span>
<span class="comment-copy">Adding this to .bash_profile.  Yum.  Now I can just type <code>H</code>.  Thanks! -- <a href="https://gist.github.com/cmawhorter/f2a09bcf63c68b0cff10" rel="nofollow noreferrer">gist.github.com/cmawhorter/f2a09bcf63c68b0cff10</a></span>
<span class="comment-copy">This should be the accepted answer.</span>
<span class="comment-copy">To have this work as a simple http server on windows 10 using Python 3.5.1 I had to change it as follows: <code>python -c "import http.server as hs; hs.HTTPServer(('127.0.0.1', 8888), hs.SimpleHTTPRequestHandler).serve_forever()"</code>  Note the change in quotation and the fact that Base and Simple HTTP Server are now in http.server.</span>
<span class="comment-copy">+1 on using profile alias, I called mine 'servelocal' -- there is a bit of a dance changing and escaping quotation marks to make bash syntax happy, but result is nice.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/http.server.html" rel="nofollow noreferrer">docs.python.org/3/library/http.server.html</a></span>
<span class="comment-copy">@Andrew: Thanks for the link. I edited it into the answer :-).</span>
<span class="comment-copy">Most simple one. Thanks!</span>
