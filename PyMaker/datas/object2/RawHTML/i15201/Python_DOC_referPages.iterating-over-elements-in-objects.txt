<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/25150955/python-iterating-through-object-attributes">Python iterating through object attributes</a></p>
<p>I found this question when trying to understand iteration over Objects, and found this response from Eric Leschinski:</p>
<pre><code>class C:
    a = 5
    b = [1,2,3]
    def foobar():
        b = "hi"   

c = C

for attr, value in c.__dict__.iteritems():
    print "Attribute: " + str(attr or "")
    print "Value: " + str(value or "")
</code></pre>
<p>Which produced text that listed all attributes in class <code>C</code>, including functions and hidden attributes (surrounded by underscores) as seen below:</p>
<pre><code>python test.py
Attribute: a
Value: 5
Attribute: foobar
Value: &lt;function foobar at 0x7fe74f8bfc08&gt;
Attribute: __module__
Value: __main__
Attribute: b
Value: [1, 2, 3]
Attribute: __doc__
Value:
</code></pre>
<p>Now, I understand how to filter out the 'hidden' attributes from my iteration, but is there a way to filter out all functions as well? Effectively, I'm looking for, in class <code>C</code>, only attributes <code>a</code> and <code>b</code>, listed sequentially, without the <code>__module__</code> and <code>__doc__</code> information and without any and all functions that happen to be in <code>C</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll have to filter on type; <code>function</code> objects are attributes just like the rest. You could use the <a href="https://docs.python.org/2/library/inspect.html#inspect.isfunction" rel="nofollow"><code>inspect.isfunction()</code> predicate function</a> here:</p>
<pre><code>import inspect

for name, value in vars(C).iteritems():
   if inspect.isfunction(value):
       continue
   if name[:2] + name[-2:] == '____':
       continue
</code></pre>
<p>You could use the <a href="https://docs.python.org/3/library/inspect.html#inspect.getmembers" rel="nofollow"><code>inspect.getmembers()</code> function</a> with a custom predicate:</p>
<pre><code>isnotfunction = lambda o: not inspect.isfunction(o)
for name, value in inspect.getmembers(C, isnotfunction):
   if name[:2] + name[-2:] == '____':
       continue
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/2/library/functions.html#callable" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#callable</a></span>
<span class="comment-copy">if callable(attribute)</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/9058305/getting-attributes-of-a-class">Getting attributes of a class</a></span>
<span class="comment-copy">@Kasra AD The difference in this case is that I'm looking for the values of the attributes, rather than the names of the attributes, though that might not have been conveyed clearly.</span>
<span class="comment-copy">Thanks for the response! I'm not familiar with custom predicates, but couldn't the custom predicate also be used to filter out the hidden attributes as well? Something along the lines of <code>isnotfunctionorhidden = lambda o: not inspect.isfunction(o) and o.name[:2] + o.name[-2:] != '____'</code></span>
<span class="comment-copy">@Humus: the name is not passed to the predicate function, only the value.</span>
<span class="comment-copy">Ok, so the <code>o</code> passed into the lambda function isn't a pointer to the element being inspected?</span>
<span class="comment-copy">@Humus: it is, but that doesn't give you the attribute name on the class. The <code>__doc__</code> attribute has the value <code>''</code> (empty string), so <code>''</code> is passed to the predicate. You cannot go from there to <code>'__doc__'</code>.</span>
<span class="comment-copy">Ok, thanks again. I didn't understand that the value, not the attribute, was being passed into the predicate.</span>
