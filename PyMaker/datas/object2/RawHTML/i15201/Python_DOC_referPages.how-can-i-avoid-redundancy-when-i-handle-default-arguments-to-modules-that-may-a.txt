<div class="post-text" itemprop="text">
<p>I'm trying to find a good way to avoid redundancy (that could possibly inject a risk for divergence) to my python module that can be executed from the command line.</p>
<p>Consider a python module like this:</p>
<pre><code>#!/usr/bin/env python2.7
from argparse import ArgumentParser

DEFAULT_A_ARG='alpha'

def funky(a=DEFAULT_A_ARG, b=False):
    pass

if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument('-a', default=DEFAULT_A_ARG)
    parser.add_argument('-b', action='store_true', default=False)
    args = parser.parse_args()
    funky(a=args.a, b=args.b)
</code></pre>
<p>So, someone using this module could either import it into their own code or call it from the command line. I don't like that there is a redundancy in specifying the default value for the 'a' argument between the function definition and the command line parser. Aside from the aesthetic annoyance, I tend to fret that, in larger modules that might be edited via version control by many devs, one of the defaults could be changed but not the other.</p>
<p>Is there a good way to eliminate the redundancy of specifying the default in two different places?</p>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively, if you are using <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentDefaultsHelpFormatter" rel="nofollow">ArgumentDefaultsHelpFormatter</a> to display the default values trough the usage message, you could do something like this:</p>
<pre><code>#!/usr/bin/env python2.7
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter

parser = ArgumentParser(prog='my_program',
                        formatter_class=ArgumentDefaultsHelpFormatter)
parser.add_argument('-a', default='alpha', help='your favorite greek letter')
parser.add_argument('-b', action='store_true', help='print numbers in binary format')

def funky(a=parser.get_default('a'), b=parser.get_default('b')):
    pass

if __name__ == '__main__':
    args = parser.parse_args()
    funky(**args.__dict__)
</code></pre>
<p>On terminal:</p>
<pre><code>$ my_program.py --help
usage: my_program [-h] [-a A] [-b]

optional arguments:
  -h, --help  show this help message and exit
  -a A        your favorite Greek letter (default: alpha)
  -b          print number in binary format (default: False)
</code></pre>
<p>You define it once and get it in three different places, without constants or poluting the function's body...</p>
<hr/>
<h2>EDIT</h2>
<p>I didn't know that much about recovering function metadata. So, <em>reading the docs</em> was pretty helpful in order to answer this question. If you can, take a look at the <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow">inspect</a> module of the Standard Library...</p>
<p>Here, another possibility, assigning the parameter defaults inside the function definition:</p>
<pre><code>#!/usr/bin/env python2.7
from argparse import ArgumentParser

def funky(x, a='alpha', b=False):
    pass

if __name__ == '__main__':
    import argparse
    import inspect

    funky_spec = inspect.getargspec(funky)
    defaults = funky_spec.defaults
    defaults = dict(zip(funky_spec.args[-len(defaults):], defaults))
    # effect: ['x', 'a', 'b'] + ('alpha', False) -&gt; {'a': 'alpha', 'b': False}

    parser = argparse.ArgumentParser()
    parser.add_argument('x', help='input number')
    parser.add_argument('-a', default=defaults['a'])
    parser.add_argument('-b', action='store_true', default=defaults['b'])
    args = parser.parse_args()

    funky(x=args.x, a=args.a, b=args.b)
</code></pre>
<p>In Python 3, the "inspect" block would be a little bit more legible:</p>
<pre><code>[...]

    funky_params = inspect.signature(funky).parameters.values()
    defaults = {p.name: p.default for p in funky_params if p.default is not p.empty}

[...]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, define <code>funky</code> to use <code>None</code> as default arguments instead:</p>
<pre><code>def funky(a=None, b=None):
    if a is None:
        a = DEFAULT_A_ARG
    if b is None:
        b = False
</code></pre>
<p>Then, let <code>None</code> be the default value for each command-line argument as well:</p>
<pre><code>if __name__ == '__main__':
    parser = ArgumentParser()
    # You probably don't have to specify a default of None explicitly
    parser.add_argument('-a', default=None)
    parser.add_argument('-b', action='store_true', default=None)
    args = parser.parse_args()
    funky(a=args.a, b=args.b)
</code></pre>
<p>If the actual default values were to change, you only need to change them in one place (inside the body of <code>funky</code>) rather than two places (in the definition of <code>-a</code>/<code>-b</code> and in the argument list to <code>funky</code>).</p>
</div>
<span class="comment-copy">You seem to have already come up with a solution - define the default in a constant. There is nothing you can do to stop some other dev changing the default value in the <code>ArgumentParser</code> or the <code>funky</code> definition, but having both refer to the same constant at least suggests that they should be the same.</span>
<span class="comment-copy">A 'store_true' argument has a <code>False</code> default by default.</span>
<span class="comment-copy">This looks pretty much like exactly what I was going for. Thanks!</span>
<span class="comment-copy">This helps with the display of the default value, but what does it do about setting a default value in <code>funky</code>?</span>
<span class="comment-copy">@hpaulj, I think it's more complete now. Thanks for pointing out that...</span>
