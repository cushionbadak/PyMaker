<div class="post-text" itemprop="text">
<p>I think I've read that exceptions inside a <code>with</code> do not allow <code>__exit__</code> to be call correctly. If I am wrong on this note, pardon my ignorance.</p>
<p>So I have some pseudo code here, my goal is to use a lock context that upon <code>__enter__</code> logs a start datetime and returns a lock id, and upon <code>__exit__</code> records an end datetime and releases the lock:</p>
<pre><code>def main():
    raise Exception

with cron.lock() as lockid:
    print('Got lock: %i' % lockid)
    main()
</code></pre>
<p>How can I still raise errors in addition to existing the context safely?</p>
<p><em>Note: I intentionally raise the base exception in this pseudo-code as I want to exit safely upon any exception, not just expected exceptions.</em></p>
<p><em>Note: Alternative/standard concurrency prevention methods are irrelevant, I want to apply this knowledge to any general context management.</em> I do not know if different contexts have different quirks.</p>
<p>PS. Is the <code>finally</code> block relevant?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__exit__</code> method <strong>is called as normal</strong> if the context manager is broken by an exception. In fact, the parameters passed to <code>__exit__</code> all have to do with handling this case! From <a href="https://docs.python.org/3/reference/datamodel.html#object.__exit__" rel="noreferrer">the docs</a>:</p>
<blockquote>
<p><code>object.__exit__(self, exc_type, exc_value, traceback)</code></p>
<p>Exit the runtime context related to this object. The parameters describe the exception that caused the context to be exited. If the context was exited without an exception, all three arguments will be None.</p>
<p>If an exception is supplied, and the method wishes to suppress the exception (i.e., prevent it from being propagated), it should return a true value. Otherwise, the exception will be processed normally upon exit from this method.</p>
<p>Note that <code>__exit__()</code> methods should not reraise the passed-in exception; this is the callerâ€™s responsibility.</p>
</blockquote>
<p>So you can see that the <code>__exit__</code> method will be executed and then, by default, any exception will be re-raised <em>after</em> exiting the context manager. You can test this yourself by creating a simple context manager and breaking it with an exception: </p>
<pre><code>DummyContextManager(object):
    def __enter__(self):
        print('Entering...')
    def __exit__(self, exc_type, exc_value, traceback):
        print('Exiting...')  
        # If we returned True here, any exception would be suppressed!

with DummyContextManager() as foo:
    raise Exception()
</code></pre>
<p>When you run this code, you should see everything you want (might be out of order since <code>print</code> tends to end up in the middle of tracebacks):</p>
<pre><code>Entering...
Exiting...
Traceback (most recent call last):
  File "C:\foo.py", line 8, in &lt;module&gt;
    raise Exception()
Exception
</code></pre>
</div>
<span class="comment-copy">Where are you getting this information? It is my understanding that <code>with</code> contexts are <i>designed for</i> dealing with cleanup if any unhandled exceptions occur.</span>
<span class="comment-copy">@JoelCornett I think I got the information from SO pages dealing specifically with nested contexts.</span>
<span class="comment-copy">Note: for generators with <code>@contextlib.contextmanager</code> one <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer">has to</a> use  <code>try ... finally</code> statement to make sure resources are properly freed because exceptions raised inside <code>with</code> block are captured by <code>contextmanager</code> and re-raised <i>inside</i> generator body. I.e. code after the <code>yield</code> statement will not be called if exception is raised inside such a <code>with</code> block.</span>
