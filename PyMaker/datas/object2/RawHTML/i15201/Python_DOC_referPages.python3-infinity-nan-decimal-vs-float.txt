<div class="post-text" itemprop="text">
<h3>Given (Python3):</h3>
<pre><code>&gt;&gt;&gt; float('inf') == Decimal('inf')
True 

&gt;&gt;&gt; float('-inf') &lt;= float('nan') &lt;= float('inf')
False

&gt;&gt;&gt; float('-inf') &lt;= Decimal(1) &lt;= float('inf')
True
</code></pre>
<p>Why are the following invalid? I have read <a href="https://docs.python.org/3.4/library/decimal.html#special-values" rel="nofollow">Special values</a>.</p>
<h3>Invalid</h3>
<pre><code>&gt;&gt;&gt; Decimal('-inf') &lt;= Decimal('nan') &lt;= Decimal('inf')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
decimal.InvalidOperation: [&lt;class 'decimal.InvalidOperation'&gt;]

&gt;&gt;&gt; Decimal('-inf') &lt;= float('nan') &lt;= Decimal('inf')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
decimal.InvalidOperation: [&lt;class 'decimal.InvalidOperation'&gt;]

&gt;&gt;&gt; float('-inf') &lt;= Decimal('nan') &lt;= float('inf')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
decimal.InvalidOperation: [&lt;class 'decimal.InvalidOperation'&gt;]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://hg.python.org/cpython/file/7a82b1539401/Lib/decimal.py#l899" rel="nofollow"><code>decimal.py</code> source code</a>:</p>
<pre><code># Note: The Decimal standard doesn't cover rich comparisons for
# Decimals.  In particular, the specification is silent on the
# subject of what should happen for a comparison involving a NaN.
# We take the following approach:
#
#   == comparisons involving a quiet NaN always return False
#   != comparisons involving a quiet NaN always return True
#   == or != comparisons involving a signaling NaN signal
#      InvalidOperation, and return False or True as above if the
#      InvalidOperation is not trapped.
#   &lt;, &gt;, &lt;= and &gt;= comparisons involving a (quiet or signaling)
#      NaN signal InvalidOperation, and return False if the
#      InvalidOperation is not trapped.
#
# This behavior is designed to conform as closely as possible to
# that specified by IEEE 754.
</code></pre>
<p>And from the <a href="https://docs.python.org/3/library/decimal.html#special-values" rel="nofollow"><em>Special values</em> section</a> you say you read:</p>
<blockquote>
<p>An attempt to compare two Decimals using any of the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> or <code>&gt;=</code> operators will raise the <code>InvalidOperation</code> signal if either operand is a <code>NaN</code>, and return <code>False</code> if this signal is not trapped.</p>
</blockquote>
<p>Note that IEEE 754 uses NaN as a floating point <em>exception value</em>; e.g. you did something that cannot be computed and you got an exception instead. It is a signal value and should be seen as an error, not something to compare other floats against, which is why in the IEEE 754 standard it is unequal to anything else.</p>
<p>Moreover, the <em>Special values</em> section mentions:</p>
<blockquote>
<p>Note that the General Decimal Arithmetic specification does not specify the behavior of direct comparisons; these rules for comparisons involving a <code>NaN</code> were taken from the IEEE 854 standard (see Table 3 in section 5.7). </p>
</blockquote>
<p>and <a href="ftp://ftp.heanet.ie/disk1/openwatcom/devel/docs/ieee-854.pdf" rel="nofollow">looking at IEEE 854 section 5.7</a> we find:</p>
<blockquote>
<p>In addition to the true/false response, an invalid operation exception (see 7.1) shall be signaled
  when, as indicated in the last column of Table 3, “unordered” operands are compared using one of the predicates
  involving “&lt;” or “&gt;” but not “?.” (Here the symbol “?” signifies “unordered.” )</p>
</blockquote>
<p>with comparisons with NaN classified as unordered.</p>
<p>By default <code>InvalidOperation</code> is trapped, so a Python exception is raised when using <code>&lt;=</code> and <code>&gt;=</code> against <code>Decimal('NaN')</code>. This is a logical extension; Python has <em>actual</em> exceptions so if you compare against the NaN exception value, you can expect an exception being raised.</p>
<p>You could disable trapping by using a <a href="https://docs.python.org/3/library/decimal.html#decimal.localcontext" rel="nofollow"><code>Decimal.localcontext()</code></a>:</p>
<pre><code>&gt;&gt;&gt; from decimal import localcontext, Decimal, InvalidOperation
&gt;&gt;&gt; with localcontext() as ctx:
...     ctx.traps[InvalidOperation] = 0
...     Decimal('-inf') &lt;= Decimal('nan') &lt;= Decimal('inf')
... 
False
</code></pre>
</div>
<span class="comment-copy">Have you read e.g. <a href="https://docs.python.org/3/library/decimal.html#special-values" rel="nofollow noreferrer">docs.python.org/3/library/decimal.html#special-values</a></span>
<span class="comment-copy">Yes; but not the referenced IEEE 854 standard (see Table 3 in section 5.7).</span>
<span class="comment-copy">@Martjin, typo!</span>
<span class="comment-copy">How would one "untrap" <code>InvalidOperation</code> in this instance?</span>
<span class="comment-copy">@ddenhartog: by using a local context, for example.</span>
<span class="comment-copy">Thanks :) There is no reason I cannot just use float('nan') on either side; I was just curious for learning purposes!</span>
