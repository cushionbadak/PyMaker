<div class="post-text" itemprop="text">
<p>in ruby, You can do this to collect importent values from a hash:</p>
<pre><code>        hash = {'a'=&gt; {'consider_this' =&gt; 1, 'dont_consider_this' =&gt; 4}, 
'b' =&gt; {'consider_this' =&gt; 4, 'dont_consider_this' =&gt;  4}}
        hash.collect{|key, value| value['consider_this']}=&gt; [1, 4]
    =&gt; [1, 4]
</code></pre>
<p>trying to do the same in python (new to the language) but didn't managed to . </p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a> over the values of a dictionary:</p>
<pre><code>nested = {
    'a': {'consider_this': 1, 'dont_consider_this': 4}, 
    'b': {'consider_this': 1, 'dont_consider_this': 4}
}
[v['consider_this'] for v in nested.values()]
</code></pre>
<p>The keys in the outer dictionary don't matter here. The output is <code>[1, 1]</code>, all values of the <code>consider_this</code> key, in arbitrary order. Also see the <a href="https://docs.python.org/3/library/stdtypes.html#dict.values" rel="noreferrer"><code>dict.values()</code> method</a>. If the <code>consider_this</code> key is missing it is considered an error.</p>
<p>You could use filtering to only consider dictionaries with the specific key:</p>
<pre><code>nested = {
    'a': {'consider_this': 1, 'dont_consider_this': 4}, 
    'b': {'consider_this': 2, 'dont_consider_this': 4},
    'c': {'dont_consider_this': 4},
}
[v['consider_this'] for v in nested.values() if 'consider_this' in v]
# outputs [1, 2] or [2, 1]
</code></pre>
<p>or provide a default value:</p>
<pre><code>nested = {
    'a': {'consider_this': 1, 'dont_consider_this': 4}, 
    'b': {'consider_this': 2, 'dont_consider_this': 4},
    'c': {'dont_consider_this': 4},
}
[v.get('consider_this', 0) for v in nested.values()]
# [1, 2, 0], or alternative orders
</code></pre>
<p>The latter uses the <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="noreferrer"><code>dict.get()</code> method</a>.</p>
<p>Consider using <code>{...}</code> (a set comprehension) rather than a list to reflect that ordering doesn't matter here; the result will only hold <em>unique</em> values, so <code>{1}</code> if all <code>consider_this</code> keys only ever have the value <code>1</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<blockquote>
<p>python (new to the language)<br/>
    In ruby, you can do this to collect values from a hash</p>
</blockquote>
<pre><code>hash.collect{|key, value| value['consider_this']}
</code></pre>
<blockquote>
<p>what is python's equivalent to ruby's collect</p>
</blockquote>
</blockquote>
<p>The equivalent in python would be:</p>
<pre><code>d = {
    'a': {'consider_this': 1, 'dont_consider_this': 'a'}, 
    'b': {'consider_this': 4, 'dont_consider_this': 'b'},
    'c': {'hello': 2}
}

results = []

for key, val in d.items():
    x = val.get('consider_this', False)
    results.append(x)

print results

--output:--
[1, False, 4]
</code></pre>
<p>When you get a little more experience, you can learn how to create lists from loops more efficiently using what are called <code>list comprehensions</code>:</p>
<pre><code>results = [
    val.get('consider_this', False) 
    for key, val in d.items()
]

print results

--output:--
[1, False, 4]
</code></pre>
<p>Note that in python you could use <code>d.values()</code> instead of <code>d.items()</code> because you don't use the keys:</p>
<pre><code>results = [
    val.get('consider_this', False) 
    for val in d.values()
]

print results

--output:--
[1, False, 4]
</code></pre>
<p>In ruby 1.9+, Hashes are ordered, but in python dictionaries are not ordered, so if the order of the results is important to you, you can use python's OrderedDict:</p>
<pre><code>import collections as coll

d = coll.OrderedDict(
    [
        ('a', coll.OrderedDict([('consider_this', 1), ('dont_consider_this', 'a')])), 
        ('b', coll.OrderedDict([('consider_this', 4), ('dont_consider_this', 'b')])),
        ('c', coll.OrderedDict([('hello', 2)]))
    ]
)

results = [
    val.get('consider_this', False) 
    for key, val in d.items()
]

print results

--output:--
[1, 4, False]
</code></pre>
</div>
<span class="comment-copy">Do you even have an equivalent data structure constructed in Python?</span>
<span class="comment-copy">Your code result in <code>[1, 1]</code>, not <code>[1, 4]</code>.</span>
<span class="comment-copy">sure, it's a plain <a href="https://docs.python.org/2/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dict</a></span>
<span class="comment-copy">@OhadPartuck Please include the dictionary you constructed in the question. As it is, the question looks as if you have no clue what you are doing.</span>
