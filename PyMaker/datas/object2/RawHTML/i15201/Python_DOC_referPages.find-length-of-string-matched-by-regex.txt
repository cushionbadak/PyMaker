<div class="post-text" itemprop="text">
<p>I am trying to write a script to parse a map file generated by a compiler/linker, that looks like this:</p>
<pre><code>%SEGMENT_SECTION
                                                      Start Address  End Address
--------------------------------------------------------------------------------
Segment Name: S1_1, Segment Type: .bss                0A000000       0A050F23
--------------------------------------------------------------------------------
area1_start.o (.bss)                                  0A000000       0A000003
...

                                                      Start Address  End Address
--------------------------------------------------------------------------------
Segment Name: S2_1, Segment Type: .bss                0A050F24       0A060000
--------------------------------------------------------------------------------
area2_start.o (.bss)                                  0A000000       0A000003

...

%NEXT_SECTION
</code></pre>
<p>I am currently writing several regular expressions (python's re module) to parse this, but I want to write them in a very easy-to-read way, such that it's very simple to parse.  Essentially:</p>
<pre><code>with open('blah.map') as f:
    text = f.read()

# ... Parse the file to update text to be after the %SEGMENT_SECTION

match = segment_header_re.match(text)
seg_name, seg_type, start_addr, end_addr = match.groups()
# ... (Do more with matched values)

text = text[len(match.matched_str):]

# Parse the remainder of text
</code></pre>
<p>However, I don't know how to get the length of the matched string, as in my <code>match.matched_str</code> pseudo code.  I don't see anything in python's documentation of re.  Is there a better way to do this type of parsing?</p>
</div>
<div class="post-text" itemprop="text">
<p>For what you are trying to achieve, use the <code>match.span</code> method.</p>
<pre><code>&gt;&gt;&gt; 
&gt;&gt;&gt; s = 'The quick brown fox jumps over the lazy dog'
&gt;&gt;&gt; m = re.search('brown', s)
&gt;&gt;&gt; m.span()
(10, 15)
&gt;&gt;&gt; start, end = m.span()
&gt;&gt;&gt; s[end:]
' fox jumps over the lazy dog'
&gt;&gt;&gt; 
</code></pre>
<p>Or just the <code>match.end</code> method.</p>
<pre><code>&gt;&gt;&gt; s[m.end():]
' fox jumps over the lazy dog'
&gt;&gt;&gt; 
</code></pre>
<p>Another option is to use <a href="https://docs.python.org/2/library/re.html#regular-expression-objects" rel="nofollow">regular expression objects</a> which can take <code>pos</code> and <code>endpos</code> arguments to limit the search to a portion of the string.</p>
<pre><code>&gt;&gt;&gt; s = 'The quick brown fox jumps over the lazy dog'
&gt;&gt;&gt; over = re.compile('over')
&gt;&gt;&gt; brown = re.compile('brown')
&gt;&gt;&gt; m_brown = brown.search(s)
&gt;&gt;&gt; m_brown.span()
(10, 15)
&gt;&gt;&gt; m_over = over.search(s)
&gt;&gt;&gt; m_over.span()
(26, 30)
</code></pre>
<p>Begin the search for <code>over</code> at the end of the match for <code>brown</code>.</p>
<pre><code>&gt;&gt;&gt; match = over.search(s, pos = m_brown.end())
&gt;&gt;&gt; match.group()
'over'
&gt;&gt;&gt; match.span()
(26, 30)
</code></pre>
<p>Searching for <code>brown</code> starting at the end of the match for <code>over</code>, will not produce a match.</p>
<pre><code>&gt;&gt;&gt; match = brown.search(s, m_over.end())
&gt;&gt;&gt; match.group()

Traceback (most recent call last):
  File "&lt;pyshell#71&gt;", line 1, in &lt;module&gt;
    match.group()
AttributeError: 'NoneType' object has no attribute 'group'
&gt;&gt;&gt; print(match)
None
&gt;&gt;&gt; 
</code></pre>
<p>For long strings and multiple searches, using a regular expression object with a start position argument will definitely speed things up.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/re.html#re.match.group" rel="nofollow"><code>.group()</code></a> method.  The entire matched string can be retrieved by <code>match.group(0)</code>:</p>
<pre><code>text = text[len(match.group(0)):]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match('(a)bc(d)', 'abcde').group(0)  # 'e' is excluded since it wasn't matched
'abcd'
&gt;&gt;&gt;
&gt;&gt;&gt; # You can also get individual capture groups by number (starting at 1)
&gt;&gt;&gt; re.match('(a)bc(d)', 'abcde').group(1)
'a'
&gt;&gt;&gt; re.match('(a)bc(d)', 'abcde').group(2)
'd'
&gt;&gt;&gt;
</code></pre>
<p>Note however that this will raise an <code>AttributeError</code> if there was no match:</p>
<pre><code>&gt;&gt;&gt; re.match('xyz', 'abcde').group(0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'group'
&gt;&gt;&gt;
</code></pre>
<p>You may wish to implement a check that makes sure the match was successful before you go calling methods on the match object.</p>
</div>
<span class="comment-copy">The OP wants the length of the matched string, not its position in the full string.  In this case, he would want <code>s[5:]</code>, since <code>'brown'</code> is 5 in length.  You should do <code>s[end - start:]</code>.</span>
<span class="comment-copy">@iCodez .. I could be wrong but regardless of the text in the question it looks like the code is attempting to shorten the <code>text</code> being searched by removing what has already been found.  That is what I am addressing in this answer.</span>
<span class="comment-copy">Seems I misunderstood the definition of a group in the regex page, and thought I couldn't get the whole string.  Thanks!</span>
