<div class="post-text" itemprop="text">
<p>If I have 3 bytes <code>b'\x00\x0c\x00'</code>, which can be represented with the bits <code>00000000 00001100 00000000</code>, how do I then parse the 11th and 12th bit <code>11</code> most efficiently?</p>
<p>Here positions:</p>
<pre><code>             **
00000000 11111110 22222111 tens
87654321 65432109 43210987 ones
|||||||| |||||||| ||||||||
00000000 00001100 00000000
             **
</code></pre>
<p>I have the following code:</p>
<pre><code>bytes_input = b'\x00\x0c\x00'
for byte in bytes_input:
    print(byte, '{:08b}'.format(byte), bin(byte))
bit_position = 11-1
bits_per_byte = 8
floor = bit_position//bits_per_byte
print('floor', floor)
byte = bytes_input[floor]
print('byte', byte, type(byte))
modulo = bit_position%bits_per_byte
print('modulo', modulo)
bits = bin(byte &gt;&gt; modulo &amp; 3)
print('bits', bits, type(bits))
</code></pre>
<p>Which returns:</p>
<pre><code>0 00000000 0b0
12 00001100 0b1100
0 00000000 0b0
floor 1
byte 12 &lt;class 'int'&gt;
modulo 2
bits 0b11 &lt;class 'str'&gt;
</code></pre>
<p>Is there a computationally faster way for me to get the information that doesn't require me to calculate floor and modulo?</p>
<p>To put things into context I am parsing this file format:
<a href="http://pngu.mgh.harvard.edu/~purcell/plink/binary.shtml" rel="nofollow">http://pngu.mgh.harvard.edu/~purcell/plink/binary.shtml</a></p>
<p>Update 01feb2015:</p>
<p>Thanks to @Dunes I read the <a href="https://docs.python.org/3/library/stdtypes.html#additional-methods-on-integer-types" rel="nofollow">documentation on from_bytes</a> and found out that I can avoid doing <code>divmod</code> by just doing <code>int.from_bytes</code> with <code>byteorder=small</code>. The final function I adapted into <a href="https://github.com/team149/tc9/blob/e5040b51a467bd35b7c68f6fa92064ea3b57464e/conversion/bed2vcf.py" rel="nofollow">my code</a> is <code>fsmall</code>. I can't get <code>timeit</code> to work, so I'm not sure about the relative speeds of functions.</p>
<pre><code>bytes_input = b'\x00\x0c\x00'
bit_position = 11-1
bpb = bits_per_byte = 8

def foriginal(bytes_input, bit_position):
    floor = bit_position//bpb
    byte = bytes_input[floor]
    modulo = bit_position%bpb
    return byte &gt;&gt; modulo &amp; 0b11

def fdivmod(bytes_input, bit_position):
    div, mod = divmod(bit_position, bpb)
    return bytes_input[div] &gt;&gt; mod &amp; 0b11

def fsmall(bytes_input, bit_position):
    int_bytes = int.from_bytes(bytes_input, byteorder='little')
    shift = bit_position
    bits = int_bytes &gt;&gt; shift &amp; 0b11
    return bits
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try:</p>
<pre><code>(int.from_bytes(bytes_input, 'big') &gt;&gt; bit_position) &amp; 0b11
</code></pre>
<p>It doesn't appear to be any quicker though, just terser.</p>
<p>However, <code>int.from_bytes(bytes_input, 'big')</code> is the most time consuming part of that code snippet by a factor 2 to 1. If you can convert your data from <code>bytes</code> to <code>int</code> once, at the beginning of the program, then you will see quicker bit masking operations.</p>
<pre><code>In [52]: %timeit n = int.from_bytes(bytes_input, 'big')
1000000 loops, best of 3: 237 ns per loop

In [53]: %timeit n &gt;&gt; bit_position &amp; 0b11
10000000 loops, best of 3: 107 ns per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a computationally faster way for me to get the information that doesn't require me to calculate floor and modulo?</p>
</blockquote>
<p>Not really. But there is <code>divmod()</code>.</p>
<pre><code>&gt;&gt;&gt; divmod(10, 8)
(1, 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The fastest way is to convert your byte string into a numeric type that can be checked using a bitmask:</p>
<pre><code>def check(b, checkbits):
    # python2 use ord(bb)
    bits = sum([bb &lt;&lt; (8 * (len(b) - i)) for i, bb in enumerate(b,1)])
    mask = sum([2 ** (b-1) for b in checkbits])
    return bits, bits &amp; mask == mask

bytes_input = b'\x00\x0c\x00'
checkbits = (11, 12)
bits, is_set = check(bytes_input, checkbits)
print bits, bin(bits), is_set
3072 0b110000000000 True
%timeit check(bytes_input, checkbits)
100000 loops, best of 3: 3.24 µs per loop
</code></pre>
<p>I'm not sure about the timing of your code, because I couldn't get it to work.</p>
<p>Update: Turns out there is a faster check() implementation:</p>
<pre><code> def check2(b, mask):
    bits = 0
    i = 0
    for bb in b[::-1]:
        # python2 use ord(bb)
        bits |= bb &lt;&lt; i
        i += 8
    return bits, bits &amp; mask == mask
# we now build the mask directly
# note this is the same as 2**10 | 2**11
mask = (2**11 | 2**12) &gt;&gt; 1
%timeit check2(bytes_input, mask)
1000000 loops, best of 3: 1.82 µs per loop
</code></pre>
<p>Update 2: adopting Dunes' <a href="https://stackoverflow.com/a/28257988/890242">nicely terse solution</a> the whole thing becomes a two-liner (note my test runs in Python 2, apparently much slower than Dune's Python3):</p>
<pre><code>#python2 from_bytes = lambda str: int(str.encode('hex'), 16)
mask = (2**11 | 2**12) &gt;&gt; 1
check = lambda b, mask: int.from_bytes(b) &amp; mask
%timeit check(bytes_input, mask)
100000 loops, best of 3: 2.1 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do binary operations in Python:</p>
<p>Convert the byte[s] you care about to an integer - in this case you only care about the middle byte, so we will just parse that:</p>
<pre><code>&gt;&gt;&gt; bytes_input = b'\x00\x0c\x00'
&gt;&gt;&gt; middle_byte = bytes_input[1]
&gt;&gt;&gt; middle_byte
12
</code></pre>
<p>Now you can do binary AND with the &amp; operator:</p>
<pre><code>&gt;&gt;&gt; middle_int &amp; 0x0C
12
</code></pre>
<p>To expand on this more generally, you can convert any arbitrary binary [string] to it's integer value with something like:</p>
<pre><code>&gt;&gt;&gt; int.from_bytes(b'\x00\x0c\x00')
3072
</code></pre>
<p>And now you can apply the bitmask again:</p>
<pre><code>&gt;&gt;&gt; string_to_int(b'\x00\x0c\x00') &amp; 0x000C00
3072
</code></pre>
</div>
<span class="comment-copy">Typically, bit-field parsing is done using <a href="http://en.wikipedia.org/wiki/Mask_%28computing%29" rel="nofollow noreferrer">bit masks</a>. Is there a reason you can't use a mask that I'm not seeing?</span>
<span class="comment-copy"><code>n // 8 == n &gt;&gt; 3</code> and <code>n % 8 == n &amp; 7</code> for any n, but honestly, what are you even doing?</span>
<span class="comment-copy">Thanks @aruisdante I didn't know about bit masks. I will read up on that and see if I can somehow put it to use.</span>
<span class="comment-copy">@cairnarvon I am parsing a binary file format.</span>
<span class="comment-copy">kudos for using from_bytes. here's the python 2 version of that <code>int_from_bytes = lambda str: int(str.encode('hex'), 16)</code></span>
<span class="comment-copy">I can indeed convert a large chunk of the data from bytes to int once at the beginning of the program. Also see my update regarding doing byte_order='small' instead of byte_order='big'. Thanks @Dunes and the rest of you!</span>
<span class="comment-copy">Thanks I think this is what I am after. You probably had problems with my code, because it's written in Python3?</span>
<span class="comment-copy">The result of indexing a <code>bytes</code> object is a number.</span>
<span class="comment-copy">The question is tagged [python-3.x], which means doing <code>ord(middle_byte)</code> is unnecessary - indexing a bytes object gives you an int, not a length one byte string. Also, your <code>string_to_int</code> function already exists as a builtin called <code>int.from_bytes</code>.</span>
<span class="comment-copy">The more you know! Thanks, I'll edit accordingly.</span>
