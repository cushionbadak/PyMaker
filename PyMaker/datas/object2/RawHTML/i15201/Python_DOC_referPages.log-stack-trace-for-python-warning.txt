<div class="post-text" itemprop="text">
<p>A package that I'm using in my python program is throwing a warning that I'd like to understand the exact cause of.  I've set <code>logging.captureWarning(True)</code> and am capturing the warning in my logging, but still have no idea where it is coming from.  How do I also log the stack trace so I can see where in my code the warning is coming from?  Do I use <code>traceback</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a little hackish, but you can monkeypatch the <code>warnings.warn</code> method to this:</p>
<pre><code>import traceback
import warnings

def g():
    warnings.warn("foo", Warning)

def f():
    g()
    warnings.warn("bar", Warning)

_old_warn = warnings.warn
def warn(*args, **kwargs):
    tb = traceback.extract_stack()
    _old_warn(*args, **kwargs)
    print("".join(traceback.format_list(tb)[:-1]))
warnings.warn = warn

f()
print("DONE")
</code></pre>
<p>This is the output:</p>
<pre><code>/tmp/test.py:14: Warning: foo
  _old_warn(*args, **kwargs)
  File "/tmp/test.py", line 17, in &lt;module&gt;
    f()
  File "/tmp/test.py", line 8, in f
    g()
  File "/tmp/test.py", line 5, in g
    warnings.warn("foo", Warning)

/tmp/test.py:14: Warning: bar
  _old_warn(*args, **kwargs)
  File "/tmp/test.py", line 17, in &lt;module&gt;
    f()
  File "/tmp/test.py", line 9, in f
    warnings.warn("bar", Warning)

DONE
</code></pre>
<p>See that calling the original <code>warnings.warn</code> function does not report the line you'd want, bu the stack trace is indeed correct (you could print the warning message yourself).</p>
</div>
<div class="post-text" itemprop="text">
<p>I've ended up going with the below:</p>
<pre><code>import warnings
import traceback

_formatwarning = warnings.formatwarning

def formatwarning_tb(*args, **kwargs):
    s = _formatwarning(*args, **kwargs)
    tb = traceback.format_stack()
    s += ''.join(tb[:-1])
    return s

warnings.formatwarning = formatwarning_tb
logging.captureWarnings(True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you do not know what data/instruction is causing the warning throw, you can use tools like the standard <a href="https://docs.python.org/2/library/pdb.html" rel="nofollow noreferrer">Python Debugger</a>.</p>
<p>The documentation is really good and detailed, but some quickly examples that may help should be:</p>
<ul>
<li><p><strong>Without</strong> modifying source code: invoking the debbugger as script:</p>
<blockquote>
<p>$ python <strong>-m pdb</strong> <em>myscript.py</em></p>
</blockquote></li>
<li><p>Modifying source code: you can make use of calls to <code>pdb.set_trace()</code>, that work like breakpoints; For example, consider I have the following <strong>example</strong> code:</p>
<pre><code>x = 2
x = x * 10 * 100
y = x + 3 + y
return y</code></pre>
<p>And I would like to know what value does <em>x</em> and <em>y</em> have before the return, or what does the stack contains, I would add the following line between those statements:</p>
<p><code>pdb.set_trace()</code></p>
<p>And I will be promted to the <strong>(Pdb)</strong> prompt, that will allow you to go through the code line by line. Useful commands for the <strong>(Pdb)</strong> prompt are:</p>
<ul>
<li><strong>n</strong>: executes the next statement.</li>
<li><strong>q</strong>: quits the whole program.</li>
<li><strong>c</strong>: quits the <strong>(Pdb)</strong> prompt and stops debugging.</li>
<li><strong>p</strong> <em>varname</em>: prints the value of <em>varname</em></li>
</ul></li>
</ul>
<p>As you do not provide more information, I do not know if that should be enough, but I think that at least, it may be a good start.</p>
<p><strong>BONUS EDIT</strong></p>
<p>Based on <a href="https://stackoverflow.com/a/6418428/3501291">this answer</a>, I have found there is a nice and friendly GUI debugging tool, that you can simply install by:</p>
<blockquote>
<p>$ <strong>pip</strong> install pudb</p>
</blockquote>
<p>And run the debugger with your script with:</p>
<blockquote>
<p>$ python <strong>-m pudb.run</strong> <em>myscript.py</em></p>
</blockquote>
<p><strong>EDIT: Adding the postmortem debugging</strong></p>
<p>If we do not even know if the code is going to crash or not, we can enter in <strong>postmortem</strong> debugging if there has been a crash. From the Pbd documentation:</p>
<blockquote>
<p>The typical usage to inspect a crashed program is:</p>
<pre><code>&gt;&gt;&gt; import pdb
&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; mymodule.test()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "./mymodule.py", line 4, in test
    test2()
  File "./mymodule.py", line 3, in test2
    print spam
NameError: spam
&gt;&gt;&gt; pdb.pm()
&gt; ./mymodule.py(3)test2()
-&gt; print spam
(Pdb)
</code></pre>
</blockquote>
<p>As <em>postmortem</em> looks at <code>sys.last_traceback</code>, to enter only if there is a traceback (and so on, a warning or crash):</p>
<pre><code>if sys.last_traceback:
     pdb.pm()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can turn warnings into exceptions, which means you will get a stack trace automatically:</p>
<pre><code>warnings.filterwarnings("error")
</code></pre>
<p>See <a href="https://docs.python.org/3.4/library/warnings.html#the-warnings-filter" rel="nofollow">https://docs.python.org/3.4/library/warnings.html#the-warnings-filter</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If it was me, I'd go with @Llu√≠s Vilanova's quick &amp; dirty hack, just to find something. But if that's not an option...</p>
<p>If you really want a "logging" solution, you could try something like <a href="http://pastebin.com/7066Bfgq" rel="nofollow">this</a> (fully working source).</p>
<p>Basic steps are:</p>
<ul>
<li>Create a custom logging.Formatter subclass that includes the current stack where the logging record is formatted</li>
<li>Use that formatter on the class of the warning</li>
</ul>
<p>The meat of the code is the custom formatter:</p>
<pre><code>class Formatter(logging.Formatter):
    def format(self, record):
        record.stack_info = ''.join(traceback.format_stack())
        return super().format(record)
</code></pre>
<p>Per the <a href="https://docs.python.org/3/library/logging.html#logging.Logger.debug" rel="nofollow">docs</a>:</p>
<pre><code>New in version 3.2: The stack_info parameter was added.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For python 3.2 and above, using the optional <a href="https://docs.python.org/3.5/library/logging.html#logging.debug" rel="nofollow noreferrer">stack_info</a> keyword argument is the easiest way to get stack trace info along with the log message.
In the example below, "Server.py" is using "lib2.py", which is in turn using "lib.py".
On enabling the stack_info argument the complete trace back is logged along with every logging.log() call. This works the same with logging.info() and other convenience methods as well.</p>
<p>Usage :-</p>
<pre><code>logging.log(DEBUG, "RWL [{}] : acquire_read()".format(self._ownerName), stack_info=True)
</code></pre>
<p>Output :-</p>
<pre><code>2018-10-06 10:59:55,726|DEBUG|MainThread|lib.py|acquire_read|RWL [Cache] : acquire_read()
Stack (most recent call last):
  File "./Server.py", line 41, in &lt;module&gt;
    logging.info("Found {} requests for simulation".format(simdata.count()))
  File "&lt;Path&gt;\lib2.py", line 199, in count
    with basics.ReadRWLock(self.cacheLock):
  File "&lt;Path&gt;\lib.py", line 89, in __enter__
    self.rwLock.acquire_read()
  File "&lt;Path&gt;\lib.py", line 34, in acquire_read
    logging.log(DEBUG, "RWL [{}] : acquire_read()".format(self._ownerName), stack_info=True)
</code></pre>
</div>
<span class="comment-copy">From the message that is sent, can you perhaps look in the code base for it?</span>
<span class="comment-copy">Yeah, I've looked there, but still can't figure out exactly what data/code in my codebase is causing it unfortunately</span>
<span class="comment-copy">Unfortunately debugging won't help identify the problem.  It only happens sporadically and I'm very unlikely to catch it when debugging.  Hence my need for logging to identify exactly what situation causes it.</span>
<span class="comment-copy">Sure you can. You can use the Python Debugger <i>post-mortem</i>. I have updated my answer with an example.</span>
