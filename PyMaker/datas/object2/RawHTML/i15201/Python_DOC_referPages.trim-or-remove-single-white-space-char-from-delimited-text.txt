<div class="post-text" itemprop="text">
<p>I have an issue where I am getting a # delimited file, however, in between the hashes, there is a single white space character signifying an empty value. This is causing me problems when I try to query the file later on. Is there a way I can remove all instances in a delimited line where just a single white space char exists?</p>
<p>Here's a sample line from my file.</p>
<pre><code>40001#World Music#Mike Oldfield#Tubular Bells#   53# # #
</code></pre>
<p>I would want the string to be...</p>
<pre><code>40001#World Music#Mike Oldfield#Tubular Bells#   53###
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using ternary conditionals and list comprehensions, you can do:</p>
<pre><code>s = "40001#World Music#Mike Oldfield#Tubular Bells#   53# # #"
s2 = "#".join([i if i != " " else "" for i in s.split("#")])
print s2
</code></pre>
<p>prints</p>
<pre><code>40001#World Music#Mike Oldfield#Tubular Bells#   53###
</code></pre>
<p>No need for imports (e.g. RE)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/re.html" rel="nofollow">regular expressions</a>. </p>
<pre><code>import re

my_str = "40001#World Music#Mike Oldfield#Tubular Bells# 53# # #"
pattern = re.compile(r'(#)\s(#)\s(#)')

new_str = re.sub(pattern, r'\1\2\3', my_str)

print(new_str)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>re.sub</code> function.</p>
<pre><code>re.sub(r'(?&lt;=#) (?=#)', r'', string)
</code></pre>
<p><em>OR</em></p>
<pre><code>re.sub(r'(?&lt;=#)\s(?=#)', r'', string)
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>&gt;&gt;&gt; s = "40001#World Music#Mike Oldfield#Tubular Bells#   53# # #"
&gt;&gt;&gt; re.sub(r'(?&lt;=#) (?=#)', r'', s)
'40001#World Music#Mike Oldfield#Tubular Bells#   53###'
</code></pre>
<ul>
<li><code>(?&lt;=#)</code> Positive lookbehind asserts that the match must be preceded by a <code>#</code></li>
<li><code>\s</code> Matches a space character.</li>
<li><code>(?=#)</code> Positive lookahead which asserts that the match must be followed by a <code>#</code> character.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can use something like:-</p>
<pre><code>orig_str="40001#World Music#Mike Oldfield#Tubular Bells#   53# # #"
splitted_str = orig_str.split("#")[:-1]
new_str = ''
for item in splitted_str:
  if item.strip():
    new_str+=item
  new_str+="#"
print new_str  
</code></pre>
<p>This would print <code>40001#World Music#Mike Oldfield#Tubular Bells#   53###</code></p>
</div>
<div class="post-text" itemprop="text">
<p>This regex seems to do what you want, using a positive lookahead: <a href="http://regexr.com/3abqs" rel="nofollow">http://regexr.com/3abqs</a></p>
<pre><code>import re
str = "40001#World Music#Mike Oldfield#Tubular Bells#   53# # #"
strf = re.sub(r'#\s+(?=#)', r'#', str)
print(strf)
</code></pre>
</div>
<span class="comment-copy">What about the "53" value, wouldn't you want that white space gone too?  40001#World Music#Mike Oldfield#Tubular Bells#53###  Wouldn't that be an easy replace of "# " with "#"? I may be overlooking something.</span>
<span class="comment-copy">No, I don't actually want that value trimmed, I need to have context of the number of characters for that field - spaces and all.</span>
<span class="comment-copy">use <code>re.sub(r'(?&lt;=#)\s+(?=#)', r'', string)</code> if you want to remove one or more inbetween spaces.</span>
