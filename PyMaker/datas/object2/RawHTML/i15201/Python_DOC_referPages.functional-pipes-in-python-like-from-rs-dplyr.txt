<div class="post-text" itemprop="text">
<p>In R (thanks to <code>dplyr</code>) you can now perform operations with a more functional piping syntax via <code>%&gt;%</code>. This means that instead of coding this: </p>
<pre><code>&gt; as.Date("2014-01-01")
&gt; as.character((sqrt(12)^2)
</code></pre>
<p>You could also do this: </p>
<pre><code>&gt; "2014-01-01" %&gt;% as.Date 
&gt; 12 %&gt;% sqrt %&gt;% .^2 %&gt;% as.character
</code></pre>
<p>To me this is more readable and this extends to use cases beyond the dataframe. Does the python language have support for something similar? </p>
</div>
<div class="post-text" itemprop="text">
<p>One possible way of doing this is by using a module called <a href="https://github.com/lihaoyi/macropy"><code>macropy</code></a>. Macropy allows you to apply transformations to the code that you have written. Thus <code>a | b</code> can be transformed to <code>b(a)</code>. This has a number of advantages and disadvantages.</p>
<p>In comparison to the solution mentioned by Sylvain Leroux, The main advantage is that you do not need to create infix objects for the functions you are interested in using -- just mark the areas of code that you intend to use the transformation. Secondly, since the transformation is applied at compile time, rather than runtime, the transformed code suffers no overhead during runtime -- all the work is done when the byte code is first produced from the source code.</p>
<p>The main disadvantages are that macropy requires a certain way to be activated for it to work (mentioned later). In contrast to a faster runtime, the parsing of the source code is more computationally complex and so the program will take longer to start. Finally, it adds a syntactic style that means programmers who are not familiar with macropy may find your code harder to understand.</p>
<h1>Example Code:</h1>
<p><strong>run.py</strong></p>
<pre><code>import macropy.activate 
# Activates macropy, modules using macropy cannot be imported before this statement
# in the program.
import target
# import the module using macropy
</code></pre>
<p><strong>target.py</strong></p>
<pre><code>from fpipe import macros, fpipe
from macropy.quick_lambda import macros, f
# The `from module import macros, ...` must be used for macropy to know which 
# macros it should apply to your code.
# Here two macros have been imported `fpipe`, which does what you want
# and `f` which provides a quicker way to write lambdas.

from math import sqrt

# Using the fpipe macro in a single expression.
# The code between the square braces is interpreted as - str(sqrt(12))
print fpipe[12 | sqrt | str] # prints 3.46410161514

# using a decorator
# All code within the function is examined for `x | y` constructs.
x = 1 # global variable
@fpipe
def sum_range_then_square():
    "expected value (1 + 2 + 3)**2 -&gt; 36"
    y = 4 # local variable
    return range(x, y) | sum | f[_**2]
    # `f[_**2]` is macropy syntax for -- `lambda x: x**2`, which would also work here

print sum_range_then_square() # prints 36

# using a with block.
# same as a decorator, but for limited blocks.
with fpipe:
    print range(4) | sum # prints 6
    print 'a b c' | f[_.split()] # prints ['a', 'b', 'c']
</code></pre>
<p>And finally the module that does the hard work. I've called it fpipe for functional pipe as its emulating shell syntax for passing output from one process to another.</p>
<p><strong>fpipe.py</strong></p>
<pre><code>from macropy.core.macros import *
from macropy.core.quotes import macros, q, ast

macros = Macros()

@macros.decorator
@macros.block
@macros.expr
def fpipe(tree, **kw):

    @Walker
    def pipe_search(tree, stop, **kw):
        """Search code for bitwise or operators and transform `a | b` to `b(a)`."""
        if isinstance(tree, BinOp) and isinstance(tree.op, BitOr):
            operand = tree.left
            function = tree.right
            newtree = q[ast[function](ast[operand])]
            return newtree

    return pipe_search.recurse(tree)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Pipes are a new feature in <a href="http://pandas.pydata.org/pandas-docs/stable/whatsnew.html#pipe" rel="noreferrer">Pandas 0.16.2</a>.</p>
<p>Example:</p>
<pre><code>import pandas as pd
from sklearn.datasets import load_iris

x = load_iris()
x = pd.DataFrame(x.data, columns=x.feature_names)

def remove_units(df):
    df.columns = pd.Index(map(lambda x: x.replace(" (cm)", ""), df.columns))
    return df

def length_times_width(df):
    df['sepal length*width'] = df['sepal length'] * df['sepal width']
    df['petal length*width'] = df['petal length'] * df['petal width']

x.pipe(remove_units).pipe(length_times_width)
x
</code></pre>
<p>NB: The Pandas version retains Python's reference semantics. That's why <code>length_times_width</code> doesn't need a return value; it modifies <code>x</code> in place.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Does the python language have support for something similar? </p>
</blockquote>
<p><em>"more functional piping syntax"</em> is this really a more "functional" syntax ? I would say it adds an "infix" syntax to R instead.</p>
<p>That being said, the <a href="https://docs.python.org/3/reference/grammar.html">Python's grammar</a> does not have direct support for infix notation beyond the standard operators.</p>
<hr/>
<p>If you really need something like that, you should take <a href="http://tomerfiliba.com/blog/Infix-Operators/">that code from Tomer Filiba</a> as  a starting point to implement your own infix notation:</p>
<blockquote>
<p><sup>Code sample and comments by Tomer Filiba (<a href="http://tomerfiliba.com/blog/Infix-Operators/">http://tomerfiliba.com/blog/Infix-Operators/</a>) :</sup></p>
<pre><code>from functools import partial

class Infix(object):
    def __init__(self, func):
        self.func = func
    def __or__(self, other):
        return self.func(other)
    def __ror__(self, other):
        return Infix(partial(self.func, other))
    def __call__(self, v1, v2):
        return self.func(v1, v2)
</code></pre>
<p>Using instances of this peculiar class, we can now use a new "syntax"
  for calling functions as infix operators:</p>
<pre><code>&gt;&gt;&gt; @Infix
... def add(x, y):
...     return x + y
...
&gt;&gt;&gt; 5 |add| 6
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://github.com/pytoolz/toolz" rel="nofollow noreferrer">PyToolz</a> <a href="https://toolz.readthedocs.io/en/latest/" rel="nofollow noreferrer">[doc]</a> allows arbitrarily composable pipes, just they aren't defined with that pipe-operator syntax.</p>
<p>Follow the above link for the quickstart. And here's a video tutorial: 
 <a href="http://pyvideo.org/video/2858/functional-programming-in-python-with-pytoolz" rel="nofollow noreferrer">http://pyvideo.org/video/2858/functional-programming-in-python-with-pytoolz</a></p>
<pre><code>In [1]: from toolz import pipe

In [2]: from math import sqrt

In [3]: pipe(12, sqrt, str)
Out[3]: '3.4641016151377544'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want this for personal scripting, you might want to consider using <a href="http://coconut-lang.org/" rel="noreferrer">Coconut</a> instead of Python.</p>
<p>Coconut is a superset of Python. You could therefore use Coconut's pipe operator <code>|&gt;</code>, while completely ignoring the rest of the Coconut language.</p>
<p>For example:</p>
<pre><code>def addone(x):
    x + 1

3 |&gt; addone
</code></pre>
<p>compiles to</p>
<pre><code># lots of auto-generated header junk

# Compiled Coconut: -----------------------------------------------------------

def addone(x):
    return x + 1

(addone)(3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Building <code>pipe</code> with <code>Infix</code></strong></p>
<p>As hinted at by <a href="https://stackoverflow.com/a/28252765/2347296">Sylvain Leroux</a>, we can use the <code>Infix</code> operator to construct a infix <code>pipe</code>.  Let's see how this is accomplished.</p>
<p>First, here is the code from <a href="http://tomerfiliba.com/blog/Infix-Operators/" rel="noreferrer">Tomer Filiba</a></p>
<blockquote>
<p><sup>Code sample and comments by Tomer Filiba (<a href="http://tomerfiliba.com/blog/Infix-Operators/" rel="noreferrer">http://tomerfiliba.com/blog/Infix-Operators/</a>) :</sup></p>
<pre><code>from functools import partial

class Infix(object):
    def __init__(self, func):
        self.func = func
    def __or__(self, other):
        return self.func(other)
    def __ror__(self, other):
        return Infix(partial(self.func, other))
    def __call__(self, v1, v2):
        return self.func(v1, v2)
</code></pre>
<p>Using instances of this peculiar class, we can now use a new "syntax"
  for calling functions as infix operators:</p>
<pre><code>&gt;&gt;&gt; @Infix
... def add(x, y):
...     return x + y
...
&gt;&gt;&gt; 5 |add| 6
</code></pre>
</blockquote>
<p>The pipe operator passes the preceding object as an argument to the object that follows the pipe, so <code>x %&gt;% f</code> can be transformed into <code>f(x)</code>.  Consequently, the <code>pipe</code> operator can be defined using <code>Infix</code> as follows:</p>
<pre><code>In [1]: @Infix
   ...: def pipe(x, f):
   ...:     return f(x)
   ...:
   ...:

In [2]: from math import sqrt

In [3]: 12 |pipe| sqrt |pipe| str
Out[3]: '3.4641016151377544'
</code></pre>
<p><strong>A note on partial application</strong></p>
<p>The <code>%&gt;%</code> operator from <code>dpylr</code> pushes arguments through the first argument in a function, so </p>
<pre><code>df %&gt;% 
filter(x &gt;= 2) %&gt;%
mutate(y = 2*x)
</code></pre>
<p>corresponds to </p>
<pre><code>df1 &lt;- filter(df, x &gt;= 2)
df2 &lt;- mutate(df1, y = 2*x)
</code></pre>
<p>The easiest way to achieve something similar in Python is to use <a href="https://en.wikipedia.org/wiki/Currying" rel="noreferrer">currying</a>.  The <code>toolz</code> library provides a <code>curry</code> decorator function that makes constructing curried functions easy.</p>
<pre><code>In [2]: from toolz import curry

In [3]: from datetime import datetime

In [4]: @curry
    def asDate(format, date_string):
        return datetime.strptime(date_string, format)
    ...:
    ...:

In [5]: "2014-01-01" |pipe| asDate("%Y-%m-%d")
Out[5]: datetime.datetime(2014, 1, 1, 0, 0)
</code></pre>
<p><em>Notice that <code>|pipe|</code> pushes the arguments into the <strong>last argument position</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>I missed the <code>|&gt;</code> pipe operator from Elixir so I created a simple function decorator (~ 50 lines of code) that reinterprets the <code>&gt;&gt;</code> Python right shift operator as a very Elixir-like pipe at compile time using the ast library and compile/exec:</p>
<pre><code>from pipeop import pipes

def add3(a, b, c):
    return a + b + c

def times(a, b):
    return a * b

@pipes
def calc()
    print 1 &gt;&gt; add3(2, 3) &gt;&gt; times(4)  # prints 24
</code></pre>
<p>All it's doing is rewriting <code>a &gt;&gt; b(...)</code> as <code>b(a, ...)</code>.</p>
<p><a href="https://pypi.org/project/pipeop/" rel="noreferrer">https://pypi.org/project/pipeop/</a></p>
<p><a href="https://github.com/robinhilliard/pipes" rel="noreferrer">https://github.com/robinhilliard/pipes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Adding my 2c. I personally use package <a href="https://github.com/kachayev/fn.py" rel="nofollow noreferrer">fn</a> for functional style programming. Your example translates into</p>
<pre><code>from fn import F, _
from math import sqrt

(F(sqrt) &gt;&gt; _**2 &gt;&gt; str)(12)
</code></pre>
<p><code>F</code> is a wrapper class with functional-style syntactic sugar for partial application and composition. <code>_</code> is a Scala-style constructor for anonymous functions (similar to Python's <code>lambda</code>); it represents a variable, hence you can combine several <code>_</code> objects in one expression to get a function with more arguments (e.g. <code>_ + _</code> is equivalent to <code>lambda a, b: a + b</code>). <code>F(sqrt) &gt;&gt; _**2 &gt;&gt; str</code> results in a <code>Callable</code> object that can be used as many times as you want. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://github.com/sspipe/sspipe" rel="nofollow noreferrer">sspipe</a> library. It exposes two objects <code>p</code> and <code>px</code>. Similar to <code>x %&gt;% f(y,z)</code>, you can write <code>x | p(f, y, z)</code> and similar to <code>x %&gt;% .^2</code> you can write <code>x | px**2</code>.</p>
<pre><code>from sspipe import p, px
from math import sqrt

12 | p(sqrt) | px ** 2 | p(str)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One alternative solution would be to use the workflow tool dask. Though it's not as syntactically fun as...</p>
<pre><code>var
| do this
| then do that
</code></pre>
<p>...it still allows your variable to flow down the chain and using dask gives the added benefit of parallelization where possible.</p>
<p>Here's how I use dask to accomplish a pipe-chain pattern:</p>
<pre><code>import dask

def a(foo):
    return foo + 1
def b(foo):
    return foo / 2
def c(foo,bar):
    return foo + bar

# pattern = 'name_of_behavior': (method_to_call, variables_to_pass_in, variables_can_be_task_names)
workflow = {'a_task':(a,1),
            'b_task':(b,'a_task',),
            'c_task':(c,99,'b_task'),}

#dask.visualize(workflow) #visualization available. 

dask.get(workflow,'c_task')

# returns 100
</code></pre>
<p>After having worked with elixir I wanted to use the piping pattern in Python. This isn't exactly the same pattern, but it's similar and like I said, comes with added benefits of parallelization; if you tell dask to get a task in your workflow which isn't dependant upon others to run first, they'll run in parallel.</p>
<p>If you wanted easier syntax you could wrap it in something that would take care of the naming of the tasks for you. Of course in this situation you'd need all functions to take the pipe as the first argument, and you'd lose any benefit of parallization. But if you're ok with that you could do something like this:</p>
<pre><code>def dask_pipe(initial_var, functions_args):
    '''
    call the dask_pipe with an init_var, and a list of functions
    workflow, last_task = dask_pipe(initial_var, {function_1:[], function_2:[arg1, arg2]})
    workflow, last_task = dask_pipe(initial_var, [function_1, function_2])
    dask.get(workflow, last_task)
    '''
    workflow = {}
    if isinstance(functions_args, list):
        for ix, function in enumerate(functions_args):
            if ix == 0:
                workflow['task_' + str(ix)] = (function, initial_var)
            else:
                workflow['task_' + str(ix)] = (function, 'task_' + str(ix - 1))
        return workflow, 'task_' + str(ix)
    elif isinstance(functions_args, dict):
        for ix, (function, args) in enumerate(functions_args.items()):
            if ix == 0:
                workflow['task_' + str(ix)] = (function, initial_var)
            else:
                workflow['task_' + str(ix)] = (function, 'task_' + str(ix - 1), *args )
        return workflow, 'task_' + str(ix)

# piped functions
def foo(df):
    return df[['a','b']]
def bar(df, s1, s2):
    return df.columns.tolist() + [s1, s2]
def baz(df):
    return df.columns.tolist()

# setup 
import dask
import pandas as pd
df = pd.DataFrame({'a':[1,2,3],'b':[1,2,3],'c':[1,2,3]})
</code></pre>
<p>Now, with this wrapper, you can make a pipe following either of these syntactical patterns:</p>
<pre><code># wf, lt = dask_pipe(initial_var, [function_1, function_2])
# wf, lt = dask_pipe(initial_var, {function_1:[], function_2:[arg1, arg2]})
</code></pre>
<p>like this:</p>
<pre><code># test 1 - lists for functions only:
workflow, last_task =  dask_pipe(df, [foo, baz])
print(dask.get(workflow, last_task)) # returns ['a','b']

# test 2 - dictionary for args:
workflow, last_task = dask_pipe(df, {foo:[], bar:['string1', 'string2']})
print(dask.get(workflow, last_task)) # returns ['a','b','string1','string2']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is <code>dfply</code> module. You can find more information at</p>
<p><a href="https://github.com/kieferk/dfply" rel="nofollow noreferrer">https://github.com/kieferk/dfply</a></p>
<p>Some examples are:</p>
<pre><code>from dfply import *
diamonds &gt;&gt; group_by('cut') &gt;&gt; row_slice(5)
diamonds &gt;&gt; distinct(X.color)
diamonds &gt;&gt; filter_by(X.cut == 'Ideal', X.color == 'E', X.table &lt; 55, X.price &lt; 500)
diamonds &gt;&gt; mutate(x_plus_y=X.x + X.y, y_div_z=(X.y / X.z)) &gt;&gt; select(columns_from('x')) &gt;&gt; head(3)
</code></pre>
</div>
<span class="comment-copy">Great question. I am especially interested in case, where functions have more arguments. As in <code>crime_by_state %&gt;%            filter(State=="New York", Year==2005) ...</code> from the end of <a href="http://www.onthelambda.com/2014/02/10/how-dplyr-replaced-my-most-common-r-idioms/" rel="nofollow noreferrer">How dplyr replaced my most common R idioms</a>.</span>
<span class="comment-copy">Of course, one can do it with a lot of lambdas, maps and reduces (and it is straightforward to do so), but brevity and readability are the main points.</span>
<span class="comment-copy">The package in question is magrittr.</span>
<span class="comment-copy">Yes, for the same reason every R package ever written was authored by Hadley. He is more known. (poorly disguised envy alert here)</span>
<span class="comment-copy">See answers to <a href="http://stackoverflow.com/questions/33658355/piping-output-from-one-function-to-another-using-python-infix-syntax" title="piping output from one function to another using python infix syntax">stackoverflow.com/questions/33658355/…</a> that are solving this problem.</span>
<span class="comment-copy">Sounds great, but as I see it only works on Python 2.7 (and not Python 3.4).</span>
<span class="comment-copy">I've created a smaller library with no dependencies that does the same thing as the @fpipe decorator but redefining right shift (&gt;&gt;) instead of or (|): <a href="https://pypi.org/project/pipeop/" rel="nofollow noreferrer">pypi.org/project/pipeop</a></span>
<span class="comment-copy">unfortunately this only works for dataframes, therefor i cannot assign this to be the correct answer. but good to mention here as the main use case i had in mind was to apply this to dataframes.</span>
<span class="comment-copy">PyToolz is a great pointer. Having said that one link is dead and the other one is dying soon</span>
<span class="comment-copy">His base URLs seem to be: <a href="http://http://matthewrocklin.com/blog/" rel="nofollow noreferrer">http://matthewrocklin.com/blog</a> and PyToolz <a href="http://toolz.readthedocs.io/en/latest/" rel="nofollow noreferrer">toolz.readthedocs.io/en/latest</a> . Ah, the ephemerality of the internetz...</span>
<span class="comment-copy"><code>print(1 |&gt; isinstance(int))</code>... TypeError: isinstance expected 2 arguments, got 1</span>
<span class="comment-copy">@jimbo1qaz If you still have this problem, try <code>print(1 |&gt; isinstance$(int))</code>, or preferably, <code>1 |&gt; isinstance$(int) |&gt; print</code>.</span>
<span class="comment-copy">Just what i'm looking for - even mentioned scala as an illustration. Trying it out now</span>
<span class="comment-copy">@javadba I'm glad you've found this useful. Take note, that <code>_</code> is not 100% flexible: it doesn't not support all Python operators. Additionaly, if you plan on using <code>_</code> in an interactive session, you should import it under another name (e.g. <code>from fn import _ as var</code>), because most (if not all) interactive Python shells use <code>_</code> to represent the last unassigned returned value, thus shadowing the imported object.</span>
<span class="comment-copy">one problem with this is that you can't pass functions in as arguments :(</span>
