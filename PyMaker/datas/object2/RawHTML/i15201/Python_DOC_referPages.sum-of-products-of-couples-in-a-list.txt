<div class="post-text" itemprop="text">
<p>I want to find out the sum of products of couples in a list.
For example a list is given <code>[1, 2, 3, 4]</code>. What I want to get is answer = <code>1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4</code>.</p>
<p>I do it using brute-force, it gives me the time-out error for very large lists. 
I want an efficient way to do this. Kindly tell me, how can I do this?</p>
<p>Here is my code, this is working but i need more efficient one: </p>
<pre><code>def proSum(list):
    count  = 0
    for i in range(len(list)- 1):
        for j in range(i + 1, len(list)):
            count +=  list[i] * list[j]
    return count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here it is:</p>
<pre><code>In [1]: def prodsum(xs):
   ...:     return (sum(xs)**2 - sum(x*x for x in xs)) / 2
   ...: 

In [2]: prodsum([1, 2, 3, 4]) == 1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4
Out[2]: True
</code></pre>
<p>Let <code>xs = a1, a2, .., an</code>, then</p>
<p>　　　　<code>(a1+a2+...+an)^2 = 2(a1a2+a1a3+...+an-1an) + (a1^2+...+an^2)</code></p>
<p>So we have</p>
<p>　　　<code>a1a2+...+an-1an = {(a1+a2+...+an)^2 - (a1^2+...+an^2)}/2</code></p>
<hr/>
<p><strong>Compare the performance of @georg's method and mine</strong></p>
<p>The result and the test codes as following(The less time used is better):
<img alt="enter image description here" src="https://i.stack.imgur.com/eqWtR.png"/></p>
<pre><code>In [1]: import timeit

In [2]: import matplotlib.pyplot as plt

In [3]: def eastsunMethod(xs):
   ...:     return (sum(xs)**2 - sum(x*x for x in xs)) / 2
   ...: 

In [4]: def georgMethod(given):
   ...:     sum = 0
   ...:     res = 0
   ...:     cur = len(given) - 1
   ...: 
   ...:     while cur &gt;= 0:
   ...:         res += given[cur] * sum
   ...:         sum += given[cur]
   ...:         cur -= 1
   ...:     return res
   ...: 

In [5]: sizes = range(24)

In [6]: esTimes, ggTimes = [], []

In [7]: for s in sizes:
   ...:     t1 = timeit.Timer('eastsunMethod(xs)', 'from __main__ import eastsunMethod;xs=range(2**%d)' % s)
   ...:     t2 = timeit.Timer('georgMethod(xs)', 'from __main__ import georgMethod;xs=range(2**%d)' % s)
   ...:     esTimes.append(t1.timeit(8))
   ...:     ggTimes.append(t2.timeit(8))

In [8]: fig, ax = plt.subplots(figsize=(18, 6));lines = ax.plot(sizes, esTimes, 'r', sizes, ggTimes);ax.legend(lines, ['Eastsun', 'georg'], loc='center');ax.set_xlabel('size');ax.set_ylabel('time');ax.set_xlim([0, 23])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/2/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> to generate unique pairs:</p>
<pre><code># gives [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]
unique_pairs = list(itertools.combinations([1, 2, 3, 4], 2))
</code></pre>
<p>Then use a <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> to get the product of each pair:</p>
<pre><code>products = [x*y for x, y in unique_pairs] # =&gt; [2, 3, 4, 6, 8, 12]
</code></pre>
<p>Then use <a href="https://docs.python.org/2/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a> to add up your products:</p>
<pre><code>answer = sum(products) # =&gt; 35
</code></pre>
<p>This can be all wrapped up in a one-liner like so:</p>
<pre><code>answer = sum(x*y for x,y in itertools.combinations([1, 2, 3, 4], 2))
</code></pre>
<p>In making it a one-liner the result of <code>combinations</code> is used without casting to a <code>list</code>.  Also, the brackets around the list comprehension are discarded, transforming it <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow noreferrer">generator expression</a>.</p>
<p><strong>Note</strong>:  <a href="https://stackoverflow.com/a/28146877/1322401">Eastsun's answer</a> and <a href="https://stackoverflow.com/a/28146557/1322401">georg's answer</a> use much better algorithms and will easily outpreform my answer for large lists.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Note</strong>: actually <a href="https://stackoverflow.com/a/28146877/989121">@Eastsun's answer</a> is better.</p>
<p>Here's another, more "algorithmical" way to deal with that. Observe that given</p>
<blockquote>
<p>a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n</sub></p>
</blockquote>
<p>the desired sum is (due to the distributive law)</p>
<blockquote>
<p>a<sub>0</sub> (a<sub>1</sub> +  a<sub>2</sub> + ... + a<sub>n</sub>) 
  + a<sub>1</sub> (a<sub>2</sub> +  a<sub>3</sub> + ... + a<sub>n</sub>) 
  + ...
  + a<sub>n-2</sub> (a<sub>n-1</sub> +  a<sub>n</sub>) 
  + a<sub>n-1</sub> a<sub>n</sub></p>
</blockquote>
<p>which leads to the following algorithm:</p>
<ul>
<li>let <code>sum</code> be 0 and <code>current</code> be the last element</li>
<li>on each step

<ul>
<li>multiply <code>sum</code> and <code>current</code> and add to the result</li>
<li>add <code>current</code> to <code>sum</code></li>
<li>let <code>current</code> be the previous of <code>current</code></li>
</ul></li>
</ul>
<p>In python:</p>
<pre><code>sum = 0
res = 0
cur = len(given) - 1

while cur &gt;= 0:
    res += given[cur] * sum
    sum += given[cur]
    cur -= 1

print res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>def sumOfProductsOfCouples(l):
  return sum(l[i-1] * l[i] for i, n in enumerate(l))</p>
</div>
<div class="post-text" itemprop="text">
<p>With no external library, you can use <code>map</code> and <code>lambda</code> to calculate <code>*</code> pairwise, and then <code>sum</code> everything up</p>
<pre><code>l=[1, 2, 3, 4]
sum(map(lambda x,y:x*y, l, l[1:]+[l[0]]))
</code></pre>
<p>But since you are dealing with big data, I suggest you use numpy.</p>
<pre><code>import numpy as np

l = np.array([1, 2, 3, 4])

print sum(l*np.roll(l, 1))
# 24
</code></pre>
<p>EDIT: to keep up with the updated question of OP</p>
<pre><code>import numpy as np

l = [1, 2, 3, 4]
sums = 0
while l:
    sums+=sum(l.pop(0)*np.array(l))

print sums
#35
</code></pre>
<p>So what it does is taking out the first element of list and <code>*</code> with the rest. Repeating until there is nothing to take out from the list.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import combinations
l=[1, 2, 3, 4]
cnt=0
for x in combinations(l,2):
    cnt+=x[0]*x[1]
print (cnt)
</code></pre>
<p>Output;</p>
<pre><code>&gt;&gt;&gt; 
35
&gt;&gt;&gt; 
</code></pre>
<p><code>combinations()</code> will give your pairs like you want. Then do your calculates. </p>
<p><strong>Debug it like</strong>;</p>
<pre><code>l=[1, 2, 3, 4]
for x in combinations(l,2):
    print (x)

&gt;&gt;&gt; 
(1, 2)
(1, 3)
(1, 4)
(2, 3)
(2, 4)
(3, 4)
&gt;&gt;&gt; 
</code></pre>
<p>See that your pairs are here. Actually you will find the sum of this <code>combinations pairs.</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>permutations</code> method from the <code>itertools</code> module:</p>
<pre><code>from itertools import *

p = permutations([1, 2, 3, 4], 2) # generate permutations of two
p = [frozenset(sorted(i)) for i in p] # sort items and cast 
p = [list(i) for i in set(p)] # remove duplicates, back to lists

total = sum([i[0] * i[1] for i in p]) # 35 your final answer
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use map, sum functions.</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; sum(map(sum, [map(lambda e: e*k, l) for k, l in zip(a, (a[start:] for start, _ in enumerate(a, start=1) if start &lt; len(a)))]))
35
</code></pre>
<p>Dividing above expression in parts,</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; c = (a[start:] for start, _ in enumerate(a, start=1) if start &lt; len(a))
&gt;&gt;&gt; sum(map(sum, [map(lambda e: e*k, l) for k, l in zip(a, c)]))
35
</code></pre>
</div>
<span class="comment-copy">You want product of adjacent pairs (with wrapparound for last)?</span>
<span class="comment-copy">Please add your current code to the question</span>
<span class="comment-copy">@lavee_singh, if you edit or change your question with fundamental differences, it'd be great if you put <b>EDITED/UPDATED</b> keywords and leave the original requirements intact.</span>
<span class="comment-copy">@Anzel legitimate doesn't mean here ! i think its an insult , when some body edit his question completely after that many people gave him an answer .</span>
<span class="comment-copy">@KasraAD, you're right, we're here intended to help, not being insulted.</span>
<span class="comment-copy">Good maths, but since since OP's talking about "very large" lists, I guess the iterative approach will perform better. But nice...</span>
<span class="comment-copy">@georg  It is easy to prove, as I edited.</span>
<span class="comment-copy">Good job, too bad I can't upvote twice!</span>
<span class="comment-copy">For very large lists, you can probably benefit from numpy, and use <code>(np.sum(xs)**2 - np.sum(x**2)) / 2</code></span>
<span class="comment-copy">This is sufficient, thanks</span>
<span class="comment-copy">Downvoter, I would appreciate an explanatory comment.  Thanks!</span>
<span class="comment-copy">I think all of us got a -ve out of the blue just like how OP changed his question. Honestly I think your answer is the most thoroughly explained +1 to you.</span>
<span class="comment-copy">Apologize for the sudden change, I'd not think it could create clash!</span>
<span class="comment-copy">Nice, I didn't know there was a <code>combinations</code> method so I used <code>permutations</code> below instead.</span>
<span class="comment-copy">This is a really great answer, but please please please consider not using the name <code>sum</code> as it hides the built-in function.</span>
<span class="comment-copy">@StevenRumbalski: to play the devil's advocate for a moment, there's a bit too much hype about this "don't shadow builtins" issue. First, the code is supposed to be inside a small, standalone function, so it doesn't affect other <code>sum</code>s in the program in any way. Second, IMO, python's usage of globals is one of the faults of the language. GvR somehow managed to reserve all "cool" names for his own use! Especially I do hate how my IDE highlights <code>id</code> each time (which is essential in any DB-related code), and I have never used python's <code>id()</code> a single time in my life!</span>
<span class="comment-copy">This meets my requirements, thanks!</span>
<span class="comment-copy">This seems pretty nice idea, thanks!</span>
<span class="comment-copy">The result should not be 24, it should be 35.</span>
<span class="comment-copy">this is really good, but doesn't meet my needs, please review the question and what if i am given an integer instead of the list and I've to do the same process with range(1, integer+1). Should I use a list = range(1, Integer + 1) or I can do something more efficient</span>
<span class="comment-copy">@howaboutNO, The OP has just changed the question! Look around you!</span>
<span class="comment-copy">@lavee_singh, I edited to your new requirement. You can check if it working. If you were given an <code>interger</code>, put it in a list.</span>
<span class="comment-copy">@lavee_singh, like this <code>if type(input)==int: input=[input]</code></span>
