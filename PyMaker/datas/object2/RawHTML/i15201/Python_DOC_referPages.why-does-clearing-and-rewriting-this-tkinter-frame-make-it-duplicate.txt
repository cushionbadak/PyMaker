<div class="post-text" itemprop="text">
<p>I'm working on an RPG-style game using the <code>tkinter</code> module in Python and I have a character creation screen with randomly-generated stats. The 6 stats are generated by using the <code>random</code> module.</p>
<p>The problem that I'm having is when I clear the screen to repack the numbers into the frame dedicated to them it works the first time, the numbers clear and a new set of numbers appears, however the second and third time (and so on) I press the button it just generates a new set of numbers inside the frame whilst the previous numbers remain, duplicating the amount of numbers.</p>
<p>I've tried running various different methods seen from this site such as <code>.pack_forget</code> and deleting from the screen, I even set the variables used to store the Labels to <code>None</code> but nothing I try seems to work.</p>
<p>I'll post the code below, the program is several hundred lines so forgive me if I missed anything related to the problem.</p>
<pre><code>def CharManage2Option3Command(StrengthValue, DexterityValue, ConstitutionValue, WisdomValue, IntelligenceValue, CharismaValue, statframebottomleftright, statframebottomrightright):
    StrengthValue.destroy()
    DexterityValue.destroy()
    ConstitutionValue.destroy()
    WisdomValue.destroy()
    IntelligenceValue.destroy()
    CharismaValue.destroy()
    StrNumber = randrange(3, 18)
    DexNumber = randrange(3, 18)
    ConNumber = randrange(3, 18)
    WisNumber = randrange(3, 18)
    IntNumber = randrange(3, 18)
    ChaNumber = randrange(3, 18)
    StrengthValue = Label(statframebottomleftright, text=StrNumber, fg=DefaultColour, bg=WhiteBackgroundColour, font=DefaultFont)
    DexterityValue = Label(statframebottomleftright, text=DexNumber, fg=DefaultColour, bg=WhiteBackgroundColour, font=DefaultFont)
    ConstitutionValue = Label(statframebottomleftright, text=ConNumber, fg=DefaultColour, bg=WhiteBackgroundColour, font=DefaultFont)
    WisdomValue = Label(statframebottomrightright, text=WisNumber, fg=DefaultColour, bg=WhiteBackgroundColour, font=DefaultFont)
    IntelligenceValue = Label(statframebottomrightright, text=IntNumber, fg=DefaultColour, bg=WhiteBackgroundColour, font=DefaultFont)
    CharismaValue = Label(statframebottomrightright, text=ChaNumber, fg=DefaultColour, bg=WhiteBackgroundColour, font=DefaultFont)
    StrengthValue.pack(fill="both", expand=True)
    DexterityValue.pack(fill="both", expand=True)
    ConstitutionValue.pack(fill="both", expand=True)
    WisdomValue.pack(fill="both", expand=True)
    IntelligenceValue.pack(fill="both", expand=True)
    CharismaValue.pack(fill="both", expand=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem you're having is that the assignment e.g. <code>StrengthValue = Label(...)</code> inside the function <em>does not</em> affect the object that was passed in, it just assigns a new object to that name <em>inside the function</em>. Therefore the first time you call the function the original objects are <code>destroy</code>ed as expected, but you don't retain a reference to the new objects (as they aren't <code>return</code>ed from the function) so subsequent calls appear to behave incorrectly.</p>
<p>One solution is to pass mutable arguments, e.g. lists containing the relevant objects:</p>
<pre><code>def CharManage2Option3Command(label_lists, stat_frames):
    for label_list, stat_frame in zip(label_lists, stat_frames):
        for index, label in enumerate(label_list):
            number = randrange(3, 18)
            label.destroy()
            label_list[index] = Label(stat_frame, text=number, ...)
            label_list[index].pack(...)
</code></pre>
<p><em>(see the docs on <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> and <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a>.)</em>. This would then be called e.g.:</p>
<pre><code>CharManage2Option3Command([[StrengthValue, DexterityValue, ConstitutionValue], 
                           [WisdomValue, IntelligenceValue, CharismaValue]],
                          [statframebottomleftright, statframebottomrightright]):
</code></pre>
<p>Note this has the handy side-effect of reducing duplication in your function. You could also keep the <code>Label</code> instances in a list from the start, rather than keeping a separate reference to each one.</p>
<hr/>
<p>Other solutions include explicitly <code>return</code>ing the new labels from the function and assigning back to the original names:</p>
<pre><code>def CharManage2Option3Command(StrengthValue, DexterityValue, ConstitutionValue, WisdomValue, IntelligenceValue, CharismaValue, statframebottomleftright, statframebottomrightright):
    ...
    return StrengthValue, DexterityValue, ConstitutionValue, WisdomValue, IntelligenceValue, CharismaValue
</code></pre>
<p>then calling it:</p>
<pre><code>StrengthValue, DexterityValue, ConstitutionValue, WisdomValue, IntelligenceValue, CharismaValue = CharManage2Option3Command(StrengthValue, DexterityValue, ConstitutionValue, WisdomValue, IntelligenceValue, CharismaValue, statframebottomleftright, statframebottomrightright)
</code></pre>
<p>(which is obviously pretty awkward), using an <code>IntVar</code> as the <code>textvariable</code> for the <code>Label</code> and updating that or doing something class-based, such that you access e.g. <code>self.StrengthValue</code> everywhere.</p>
<hr/>
<p>I also suggest you have a look at the <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow">style guide</a>, which provides conventions for things like function and variable names.</p>
</div>
<span class="comment-copy">I may have missed something here, but why is it necessary to recreate the different labels each time the value changes? You can call <code>.config(text="New Text")</code> on the variable holding the label object and just change the text in it.</span>
<span class="comment-copy">Thanks so much, got this working with my code on your first method.</span>
