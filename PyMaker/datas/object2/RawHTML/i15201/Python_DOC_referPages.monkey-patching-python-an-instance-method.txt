<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/972/adding-a-method-to-an-existing-object-instance">Adding a Method to an Existing Object Instance</a>
<span class="question-originals-answer-count">
                    17 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/5036920/mocking-out-methods-on-any-instance-of-a-python-class">Mocking out methods on any instance of a python class</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I'm trying to monkey-patch a class instance, but don't quite see how I can patch a class method no problem.</p>
<pre><code>&gt;&gt;&gt; class Simple(object): 
...     def make(self, arg):
...         return arg * 2
... 
&gt;&gt;&gt; s = Simple()
&gt;&gt;&gt; def times_four(self, arg):
...   return arg * 4
... 
&gt;&gt;&gt; Simple.make = times_four
&gt;&gt;&gt; s.make(10)
40
</code></pre>
<p>But say I only wanted to replace <code>make</code> in the instance, what's the easiest way to do that?</p>
<pre><code>&gt;&gt;&gt; def times_eight(self, arg):
...   return arg * 8
&gt;&gt;&gt; s.make = ???
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a new instance method out of <code>times_eight</code> by using its <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="noreferrer"><code>__get__</code> special method</a>:</p>
<pre><code>&gt;&gt;&gt; class Simple(object):
...     def make(self, arg):
...         return arg * 2
...
&gt;&gt;&gt; s = Simple()
&gt;&gt;&gt; def times_eight(self, arg):
...     return arg * 8
...
&gt;&gt;&gt; s.make = times_eight.__get__(s, Simple)
&gt;&gt;&gt; s.make(10)
80
&gt;&gt;&gt; type(s.make)
&lt;type 'instancemethod'&gt;
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Doh!</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; s.make = types.MethodType(times_eight, s, Simple)
&gt;&gt;&gt; s.make(10)
80
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Methods only get the <code>self</code> arg passed automatically when received from the class (not from the instance dict), so you'll need to pass an 1-arg function there:</p>
<pre><code>s.make = lambda arg: times_eight(s, arg)
</code></pre>
<p>(You can simplify that with <code>functools.partial</code>.)</p>
</div>
<span class="comment-copy">possibly...  I don't really understand what's going on in that code.</span>
<span class="comment-copy">is my question "mocking" or "monkey-patching"?</span>
<span class="comment-copy">Can you explain the difference, please?</span>
<span class="comment-copy">Technically these terms are somewhat synonymous. The difference is in intentions - mocking is usually monkey-patching for the purpose of testing, whereas the latter, in its origins is more general.</span>
<span class="comment-copy">Oh, that's cool.</span>
<span class="comment-copy">Your solution also works well.  I was just showing how to do it without importing <code>types.MethodType</code>. :)</span>
<span class="comment-copy">Does using <code>super()</code> inside <code>times_eight()</code> work?</span>
<span class="comment-copy">I think better to add object to closure <code>lambda arg, s=s: time_eight(s, arg)</code></span>
<span class="comment-copy">This isn't really making an instance method, however. Right?  It's a lambda or a partial, so I don't think this really works.</span>
