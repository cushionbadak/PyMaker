<div class="post-text" itemprop="text">
<p>I'm using Flask in Python3 as a webserver, and am using the upload function of Flask. Uploading a file to the server results in a <code>werkzeug.datastructures.FileStorage</code> object.</p>
<p>One of the functions I need this file in, also needs to be able to open files from path objects, so at the moment, I'm using <code>open(file_to_open)</code>. If possible, I would like to avoid writing the uploaded file to a temporary file, just to read it in again. So my question consists of two parts:</p>
<p>1: Would it be possible to "translate" this FileStorage object to a file object?</p>
<p>2: If so, would this also work on the current code (<code>open(file_to_open)</code>)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Incoming file uploads are indeed presented as <code>FileStorage</code> objects. However, this does <em>not</em> necessarily mean that an actual physical file is involved.</p>
<p>When parsing file objects, Werkzeug uses the <code>stream_factory()</code> callable to produce a file object. The default implementation only creates an actual physical file for file sizes of 500kb and over, to avoid eating up memory.</p>
<p>For <em>smaller</em> files an in-memory file object is used instead.</p>
<p>I'd not tamper with this arrangement; as it works right now the issue is handled transparently and your harddisk is only involved when the file uploads would otherwise tax your memory too much.</p>
<p>Rather, I'd alter that function to not require a filename and / or accept a file object.</p>
<p>If your function can only take a path <em>or</em> the contained data as a string, you can see if you need to read the file by introspecting the underlying <code>.stream</code> attribute:</p>
<pre><code>from werkzeug._compat import BytesIO

filename = data = None
if file_upload.filename is None:
    data = file_upload.read()  # in-memory stream, so read it out.
else:
    filename = file_upload.filename
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can store uploaded files to <a href="https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt" rel="nofollow">tmpfs</a>. This way they will still be regular files than can be opened with <code>open()</code>.</p>
</div>
<span class="comment-copy">Do you really need <code>open(file_to_open)</code>? Because the <code>FileStorage</code> object itself provides the file API, so you can just use it directly. If you need to read the file again, just call <code>uploaded_file.seek(0)</code>.</span>
<span class="comment-copy">I need one function that is capable of reading a file from disk, using a path, as well as from a memory object. If that means replacing <code>open(file_to_open)</code>, that is fine, as long as the function <code>readfile(file)</code> can take file both as path and file/anything <code>FileStorage</code> can translate to</span>
<span class="comment-copy">Why not a function that reads just from file object? Then you can give a <code>FileStorage</code> object (<code>readfile(uploaded_file)</code>) to it and it will work. If you need to use that function with file on disk, call it with <code>readfile(open(filename))</code>. Function interpreting one parameter with two ways based on its type (so <code>readfile(filename)</code> and <code>readfile(open(filename))</code> has the same effect) is not designed very well.</span>
<span class="comment-copy">In the end, I used a similar method. I changed the function so it would not do the <code>open(file_to_open)</code> within the method. Instead, now I can pass it either <code>StringIO((file.stream.read()).decode("utf-8"))</code> or <code>open(file_to_open)</code> instead of just <code>file_to_open</code>. In this case I'm lucky it's a string, but i guess as you said, with BytesIO, you could make it whatever you like. I'll mark this one as the accepted answer, but would it be okay to add an "alternatively" section?</span>
<span class="comment-copy">@pidgey: You could create subclass of the <code>Request</code> factory with your own <code>_get_file_stream</code> implementation to swap out the <code>default_stream_factory</code> for your own, then set that as the <a href="http://flask.pocoo.org/docs/0.10/api/#flask.Flask.request_class" rel="nofollow noreferrer"><code>Flask.request_class</code> attribute</a>. Perhaps.</span>
<span class="comment-copy">@pidgey: your 'similar' method however, is mentioned in my answer already. :-) <i>Rather, I'd alter that function to not require a filename and / or accept a file object.</i>.</span>
<span class="comment-copy">That might be a good idea for "harder" problems, when I stumble upon those in the future. Thanks for the tip. For now, the <code>StringIO</code> does the trick, as it will always be strings, but if I ever need it in the context of an image, i'll think about your remark</span>
<span class="comment-copy">@pidgey: Is this Python 3? Because you can wrap <code>BytesIO</code> with a <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow noreferrer"><code>TextIOWrapper()</code> object</a> to provide decoded data from the binary "file".</span>
<span class="comment-copy">I am aware of that, but that would not work cross platform (windows), right? Plus, it's not really a python specific solution (you have to create a file system and point to it, so any change in that would have to result in a change in the code)</span>
<span class="comment-copy">Yes, this solution is not "pythonic" and can be problematic to port to other platforms.</span>
