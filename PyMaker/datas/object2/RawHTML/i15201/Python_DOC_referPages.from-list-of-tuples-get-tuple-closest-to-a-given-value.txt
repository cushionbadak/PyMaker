<div class="post-text" itemprop="text">
<p>Given a list of tuples containing coordinates, I want to find which coordinate is the closest to a coordinate I give in input:</p>
<pre><code>cooList = [(11.6702634, 72.313323), (31.67342698, 78.465323)]
coordinate = (11.6702698, 78.113323)
takenearest(myList, myNumber)
...
(11.6702634, 72.313323)
</code></pre>
<p>Please let me know...</p>
</div>
<div class="post-text" itemprop="text">
<p>For your data</p>
<pre><code>cooList = [(11.6702634, 72.313323), (31.67342698, 78.465323)]
coordinate = (11.6702698, 78.113323)
</code></pre>
<p>the shortest Pythonic answer is:</p>
<pre><code>nearest = min(cooList, key=lambda x: distance(x, coordinate))
</code></pre>
<p>with a function <code>distance(a, b)</code> returning the distance between the points <code>a</code> and <code>b</code> as a float, which you have to define yourself.</p>
<p>Now you have to decide how you calculate the distance: using simple <code>a² + b² = c²</code>, some geographical formula or a dedicated library.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand you right, you want the coordinate from the list that has the least distance to the given coordinate. That means you can just loop through the list like that:</p>
<pre><code>def closest_coord(list, coord):
    closest = list[0]
    for c in list:
        if distance(c, coord) &lt; distance(closest, coord):
            closest = c
    return closest
</code></pre>
<p>To calculate the distance between two variables, just use Pythagoras.</p>
<pre><code>def distance(co1, co2):
    return sqrt(pow(abs(co1[0] - co2[0]), 2) + pow(abs(co1[1] - co2[2]), 2))
</code></pre>
<p>I hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; min(cooList, key=lambda c: (c[0]- coordinate[0])**2 + (c[1]-coordinate[1])**2)
(11.6702634, 72.313323)
</code></pre>
</div>
<span class="comment-copy">show your attempts..</span>
<span class="comment-copy">It will help us give you a better answer if you show us what you've already tried. This way you won't say "Oh, thanks for trying to help, but I already tried that. "</span>
<span class="comment-copy">How do you define distance?</span>
<span class="comment-copy">There is an error:NameError: global name 'distance' is not defined</span>
<span class="comment-copy">@Jothimani You have to implement it yourself.</span>
<span class="comment-copy">Please let me know clearly!!!</span>
<span class="comment-copy">@Jothimani Please don't tell me you can't google <code>python points distance</code></span>
<span class="comment-copy">@Jothimani: You could use the <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow noreferrer"><code>math.hypot()</code></a> function to calculate the Euclidean distance. Note however that you don't really need the actual distance to find the <code>d1 &lt; d2</code> closest—a common speed-up when doing distance comparisons is to use the distances <i>squared</i> which avoids the need to take a computationally-expensive square-root to obtain an actual distance. This is because for positive numbers, if <code>d1 &lt; d2</code> then <code>d1² &lt; d2²</code> will also be true.</span>
<span class="comment-copy">You can skip the <code>sqrt</code> for speed.</span>
<span class="comment-copy">I know, for this case that will work, however, the returned value wouldn't be the distance between the two points anymore. If @Jothimani needs special speed because their list is kinda huge (e.g.) they can just modify the code to make it fit their needs.</span>
<span class="comment-copy">Ugh. Why not use some pythonic functions like <code>min</code> or <code>math.hypot</code>? No need to reinvent the wheel....</span>
<span class="comment-copy">@sloth here it is. ;-)</span>
<span class="comment-copy">You could also use <code>key=lambda c: math.hypot(c[0]- coordinate[0], c[1]-coordinate[1])</code>. Note that you also have a typo: <code>coordinate[0]</code> instead of <code>coordinate[1]</code></span>
<span class="comment-copy">Thanks for correction. I agree that math.hypot is better in some sense but sometimes I thought the math lib is really over-designed.</span>
<span class="comment-copy">The Euclidean distance is not very useful with latitude &amp; longitude. It's ok for small distances, but it doesn't work so well for larger distances &amp;/or in regions near the poles.</span>
