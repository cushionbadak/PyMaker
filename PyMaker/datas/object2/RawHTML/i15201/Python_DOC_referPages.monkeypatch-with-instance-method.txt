<div class="post-text" itemprop="text">
<p>I'm trying to monkeypatch how <code>pandas</code> Panel's slicing (<code>__getitem__</code>).  This is straightforward to do with a basic function, foo.</p>
<pre><code>from pandas import Panel
Panel.__getitem__ = ORIGINAL_getitem


def newgetitem(panel, *args, **kwargs):
    """ Append a string to return of panel.__getitem__"""
    out = super(Panel, panel).__getitem__(*args, **kwargs)
    return out+'custom stuff added'

Panel.__getitem__ = newgetitem
</code></pre>
<p>Where<code>ORIGINAL_getitem</code> is storing the original Panel method.  I'm trying to extend to the case where <code>foo()</code> is not a function, but an instance method of an object, <code>Foo</code>.  For example:</p>
<pre><code>class Foo:

    name = 'some name'

    def newgetitem(self, panel, *args, **kwargs):
        """ Append a string to return of panel.__getitem__,
        but take attributes from self, like self.name
        """
        out = super(Panel, panel).__getitem__(*args, **kwargs)
        return out+'custom stuff added including name' + self.name
</code></pre>
<p><code>Foo.foo()</code> must access the attribute <code>self.name</code>.  Therefore, the monkeypatched function would need a reference to the Foo instance somehow, in addition to the Panel.  How can I monkepatch panel with <code>Foo.foo()</code> and make self.name accessible?  </p>
<p>The switching between the monkey patched function happens in another method, <code>Foo.set_backend()</code></p>
<pre><code>class Foo:

    name = 'some name'

    def foo(self):
        return 'bar, called by %s' % self.name

    def set_backend(self, backend):
        """ Swap between new or original slicing."""
        if backend != 'pandas':
            Panel.__getitem__ = newgetitem            
        else:
            Panel.__getitem__ = ORIGINAL_getitem
</code></pre>
<p>What I really need is for <code>newgetitem</code> to maintain a reference to <code>self</code>.  </p>
<h2>Solution Attempts</h2>
<p>So far I've tried taking making <code>newgetitem()</code> a pure function, and using partial functions to pass a reference to self in.  This doesn't work.  Something like:</p>
<pre><code>import functools

def newgetitem(foo_instance, panel, *args, **kwargs):
    ....

class Foo:

    ...
    def set_backend(self, backend):
        """ Swap between new or original slicing."""
        if backend != 'pandas':
            partialfcn = functools.partial(newgetitem, self)
            Panel.__getitem__ = partialfcn            
        else:
            Panel.__getitem__ = ORIGINAL_getitem
</code></pre>
<p>But this doesn't work.  A reference to self is passed, but no access from the calling Panel possible. That is:</p>
<pre><code> panel['50']  
</code></pre>
<p>Passes a reference to <code>Foo</code>, not to <code>Panel</code>.</p>
<p><strong>Yes, I know this is bad practice, but it's just a workaround for the time-being.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>The basics of monkey patching are straightforward but it can quickly become tricky and subtle, especially if you're aiming at finding a solution that would work for both Python 2 and Python 3.</p>
<p>Furthermore, quickly hacked solutions are usually not very readable/maintenable, unless you manage to wrap the monkey patching logic nicely.</p>
<p>That's why I invite you to have a look at a library that I wrote especially for this purpose. It is named Gorilla and you can find it on <a href="https://github.com/christophercrouzet/gorilla" rel="nofollow">GitHub</a>.</p>
<p>In short, it provides a cool set of features, it has a wide range of unit tests, and it comes with <a href="http://gorilla.readthedocs.org/" rel="nofollow">a fancy doc</a> that should cover everything you need to get started. Make sure to also check the FAQ!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow"><code>patch</code> from mock framework</a> to handle your case. Even it is designed for testing, its primary work is monkey patching in defined contex.</p>
<p>Your <code>set_backend()</code> method could be:</p>
<pre><code>def set_backend(self, backend):
    if backend != 'pandas' and self._patched_get_item is None:
        self._patched_get_item = patch("pandas.Panel.__getitem__", autospec=True, side_effect=self._getitem)
        self._patched_get_item.start()
    elif backend == 'pandas' and self._patched_get_item is not None:
        self._patched_get_item.stop()
        self._patched_get_item = None
</code></pre>
<p>That will work either when <code>self._getitem</code> is a method or a reference to a function.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this is to create a closure (a function with reference to names other than locals or globals). A simple closure:</p>
<pre><code>def g(x):
    def f():
        """f has no global or local reference to x, but can refer to the locals of the 
        context it was created in (also known as nonlocals)."""
        return x
    return f

func = g(1)
assert func() == 1
</code></pre>
<p>I don't have pandas on my system, but it works much the same with a <code>dict</code>.</p>
<pre><code>class MyDict(dict):
    pass

d = MyDict(a=1, b=2)
assert d['a'] == 1

class Foo:

    name = 'name'

    def create_getitem(fooself, cls):
        def getitem(self, *args, **kwargs):
            out = super(cls, self).__getitem__(*args, **kwargs)
            return out, 'custom', fooself.name 
            # Above references fooself, a name that is not defined locally in the 
            # function, but as part of the scope the function was created in.
        return getitem

MyDict.__getitem__ = Foo().create_getitem(MyDict)
assert d['a'] == (1, 'custom', Foo.name)

print(d['a'])
</code></pre>
</div>
<span class="comment-copy">good idea, thanks</span>
