<div class="post-text" itemprop="text">
<p>I'm trying to get the first char of a byte-string in python 3.4, but when I index it, I get an <code>int</code>:</p>
<pre><code>&gt;&gt;&gt; my_bytes = b'just a byte string'
b'just a byte string'
&gt;&gt;&gt; my_bytes[0]
106
&gt;&gt;&gt; type(my_bytes[0])
&lt;class 'int'&gt;
</code></pre>
<p>This seems unintuitive to me, as I was expecting to get <code>b'j'</code>.</p>
<p>I have discovered that I can get the value I expect, but it feels like a hack to me.</p>
<pre><code>&gt;&gt;&gt; my_bytes[0:1]
b'j'
</code></pre>
<p>Can someone please explain why this happens?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>bytes</code> type is a <a href="https://docs.python.org/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview">Binary Sequence type</a>, and is explicitly documented as containing a sequence of integers in the range 0 to 255.</p>
<p>From the documentation:</p>
<blockquote>
<p>Bytes objects are immutable sequences of single bytes.</p>
<p>[...]</p>
<p>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that <code>0 &lt;= x &lt; 256</code>[.]</p>
<p>[...]</p>
<p>Since bytes objects are sequences of integers (akin to a tuple), for a bytes object <code>b</code>, <strong><code>b[0]</code> will be an integer</strong>, while <code>b[0:1]</code> will be a <code>bytes</code> object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1).</p>
</blockquote>
<p>Bold emphasis mine. Note than indexing a string is a bit of an exception among the sequence types; <code>'abc'[0]</code> gives you a <code>str</code> object of length one; <code>str</code> is the only sequence type that contains elements of its own type, always.</p>
<p>This echoes how other languages treat string data; in C the <a href="http://en.wikipedia.org/wiki/C_data_types#Basic_types"><code>unsigned char</code> type</a> is also effectively an integer in the range 0-255. Many C compilers default to <code>unsigned</code> if you use an unqualified <code>char</code> type, and text is modelled as a <code>char[]</code> array.</p>
</div>
<span class="comment-copy">The hack of using a range like <code>my_bytes[0:1]</code> really helped me write Python2/Python3 compatible code. I'd love to see an answer that covers the best practice for compatible code addressing this issue. For example: <code>ord(my_bytes[0])</code> gives an int in Python2, yet <code>my_bytes[0]</code> gives an int in Python3. To work in both, I'm using <code>ord(my_bytes[0:1])</code> which seems really ugly for Python3.</span>
<span class="comment-copy">"while b[0:1] will be a bytes object of length 1(This contrasts with text strings, where both indexing and slicing will produce a string of length 1)"can you please explain this sentence i didn't get it?</span>
<span class="comment-copy">@CY5: sorry, what part did you get? If you create a (Unicode) string, <code>'abc'[0]'</code> produces another string object <code>'a'</code>. If you use the same slice as the example used for the <code>bytes</code> object, <code>'abc'[0:1]</code> also produces a string object of length one, <code>'a'</code>.</span>
<span class="comment-copy">@CY5: but for a <code>bytes</code> object, <code>b'abc'[0]</code> produces an integer (<code>97</code>), and slicing produces a <code>bytes</code> object of length one (<code>b'abc'[0:1]</code> produces <code>b'a'</code>).</span>
