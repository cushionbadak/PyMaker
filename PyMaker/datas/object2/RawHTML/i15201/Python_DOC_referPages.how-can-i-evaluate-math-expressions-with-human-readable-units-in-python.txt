<div class="post-text" itemprop="text">
<p>Is there a way to evaluate expressions from strings that include human readable number units?</p>
<p>For example:</p>
<pre><code>myformula='1u+1e-6'
result = eval(myformula)
</code></pre>
<p>... should be equivalent to <code>1e-6+1e-6</code> (where u=micro).</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer expands somewhat on Joran's to replace all <a href="http://en.wikipedia.org/wiki/Metric_prefix" rel="nofollow">SI affices</a> with the appropriate exponents:</p>
<pre><code>import re

SI = {
    "T": 12,
    "G": 9,
    "M": 6,
    "k": 3,
    "h": 2,
    "da": 1,
    "d": -1,
    "c": -2,
    "m": -3,
    "u": -6,
    "n": -9,
    "p": -12,
}

SI_REGEX = re.compile(r"(?&lt;=\d)(%s)\b" % "|".join(SI))

def repl_si(match):
    return "e%d" % SI[match.group()]

def defix(formula):
    return re.sub(SI_REGEX, repl_si, formula)
</code></pre>
<p>Using the dictionary <code>SI</code>, we create a regular expression that will match any of the keys in <code>SI</code> as long as they're <a href="http://www.regular-expressions.info/lookaround.html" rel="nofollow">preceded</a> by a digit and followed by a word boundary:</p>
<pre><code>(?&lt;=\d)(T|G|M|k|h|da|d|c|m|u|n|p)\b
</code></pre>
<p>Next, we define a <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow">substitution function</a> <code>repl_si()</code> that looks up the match in <code>SI</code> and replaces it with <code>"e"</code> concatenated with the exponent.</p>
<p>Then, all we have to do is write a function that calls <code>re.sub()</code> appropriately with the regex, substitution function and formula, and <em>voilà</em>:</p>
<pre><code>&gt;&gt;&gt; defix("1T + 2G + 3M + 4k + 5h + 6da + 7d + 8c + 9m + 1u + 2n + 3p")
'1e12 + 2e9 + 3e6 + 4e3 + 5e2 + 6e1 + 7e-1 + 8e-2 + 9e-3 + 1e-6 + 2e-9 + 3e-12'
</code></pre>
<p>Now all you need to do is call <code>eval()</code> on the result, which of course you should <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow">absolutely never do</a> with user-supplied input.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>myformula='1u+1e-6'
result = eval(re.sub("(\d+)u","\\1e-6",myformula))
</code></pre>
<p>should work... by just replacing any digits followed immediatly by u with e-6 before evaluating</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding an answer, mostly inspired by Joran, it probably isn't as elegant as Zero's but I think it does the job
one thing I made sure that the unit MUST be preceded by a numeric figure (\d+)</p>
<p>I fixed the units by processing a series of substitutes over different units</p>
<pre><code>myformula = '1E+3P+0.5T-7G-6M+2.5k-1m+3.7u+4n+13p-59f-73a+0.5e-5'
tmp_exp = re.sub('(\d+)E', r'\1e18', myformula)
tmp_exp = re.sub('(\d+)P', r'\1e15', tmp_exp)
tmp_exp = re.sub('(\d+)T', r'\1e12', tmp_exp)
tmp_exp = re.sub('(\d+)G', r'\1e9', tmp_exp)
tmp_exp = re.sub('(\d+)M', r'\1e6', tmp_exp)
tmp_exp = re.sub('(\d+)k', r'\1e3', tmp_exp)
tmp_exp = re.sub('(\d+)m', r'\1e-3', tmp_exp)
tmp_exp = re.sub('(\d+)u', r'\1e-6', tmp_exp)
tmp_exp = re.sub('(\d+)n', r'\1e-9', tmp_exp)
tmp_exp = re.sub('(\d+)p', r'\1e-12', tmp_exp)
tmp_exp = re.sub('(\d+)f', r'\1e-15', tmp_exp)
tmp_exp = re.sub('(\d+)a', r'\1e-18', tmp_exp)
</code></pre>
<p>tmp_exp will come out as
1e18+3e15+0.5e12-7e9-6e6+2.5e3-1e-3+3.7e-6+4e-9+13e-12-59e-15-73e-18+0.5e-5</p>
</div>
<span class="comment-copy">how is <code>1u</code> more readable than <code>1e-6</code> ... which humans are you refering too ?</span>
<span class="comment-copy">Probably a nice learning exercise to create this kind of parser on your own. (surely not required in real life!)</span>
<span class="comment-copy">@JoranBeasley: From the choice of notation, it sounds that would be scientists and engineers - who, are very much human as are we. ;)</span>
<span class="comment-copy">speaking as a scientist, I would never just give a 'micro' or 'nano' or whatever unless the units were attached - 'microliter', 'kilogram', etc. I've never seen anyone just using the prefix...</span>
<span class="comment-copy">Why 1u and and not 1µ? :)</span>
<span class="comment-copy">thanks, how can I force conversion only if the unit trails a number directly [0-9], I feel that the difference can be in the SI_REGEX expression</span>
<span class="comment-copy">Here's a safe approach to processing user input math expressions in python. <a href="http://stackoverflow.com/questions/26505420/evaluate-math-equations-from-unsafe-user-input-in-python" title="evaluate math equations from unsafe user input in python">stackoverflow.com/questions/26505420/…</a></span>
<span class="comment-copy">@sam.freeman: Yes, that is possible, using a lookbehind assertion in the regular expression. Something like this should work: <code>SI_REGEX = re.compile(r"(?&lt;=\d)(%s)" % "|".join(SI))</code></span>
<span class="comment-copy">@sam.freeman I've incorporated Håken's suggestion so that substitutions are only made when the affix is preceded by a digit.</span>
<span class="comment-copy">Thanks @HåkenLid :-)</span>
<span class="comment-copy">why -1? I feel this answers OP question ... if it doesnt please explain why not</span>
<span class="comment-copy">The main difference between your solution and mine is that it has to process the formula multiple times, rather than just once. Unless performance is an issue, that's not a problem, but yes, it does feel somewhat inelegant to write nearly the same line of code a dozen times. There's nothing to stop you iterating over a dict instead, though ...</span>
