<div class="post-text" itemprop="text">
<p>So I've spent the last 5 hours googling DFS, BFS, A*, Bellman-ford and others.  </p>
<p>I have <code>roads=[('a', [('b', 5.0), ('c', 8.0)]), ('b', [('a', 5.0), ('d', 6.0)]), ('c', [('a', 8.0), ('d', 2.0)]), ('d', [('b', 6.0), ('c', 2.0), ('e', 12.0), ('f', 2.0)]), ('e', [('d', 12.0), 
('g', 3.0)]), ('f', [('d', 2.0), ('g', 7.0)]), ('g', [('e', 3.0), ('f', 7.0)])]</code></p>
<p>weighted dictionary. I found this code: </p>
<pre><code>def find_all_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    if not start in graph:
        return []
    paths = []
    for node in graph[start]:
        if node not in path:
            newpaths = find_all_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths
</code></pre>
<p>It never finds start in the roads and returns <code>[]</code>. </p>
<p>I'm so lost. I get what these algorithms do but have no idea how to code them. I just want to find the shortest path. </p>
</div>
<div class="post-text" itemprop="text">
<p>The code you've copied won't solve your problem.  Note, for starters, that its name tells you that it does something else.  Also, it doesn't even look at the edge weights.</p>
<p>Finally, it isn't designed to work on your graph representation <em>at</em> <em>all</em>.  Note that the <code>start</code> parameter is used as a key in what I assume is a dictionary, and it expects the value to be an iterable of reachable nodes.  But you're not feeding it a dictionary, you're feeding it a list.</p>
<p>As for the empty-list return value, if you're calling the function like this:</p>
<pre><code>path = find_all_paths(graph, 'a', 'f')
</code></pre>
<p>...then it is correct.  <code>'a'</code> is <em>not</em> a node in your graph at all.  <em>Your</em> nodes are tuples, starting with an identifier like <code>'a'</code>, but also containing a list of 2-tuples.  You'd have to type <em>this</em> mess every time:</p>
<pre><code>path = find_all_paths(
  graph,
  start=('a', [('b', 5.0), ('c', 8.0)]),
  end=('f', [('d', 2.0), ('g', 7.0)]),
  )
</code></pre>
<p>Yuck.</p>
<p>As a final insult, those 2-tuples like <code>('d', 2.0)</code> are <em>also</em> not nodes.  Even if you fixed the rest of it, these would still fail the <code>if start not in graph:</code> test once one of them got passed as the new <code>start</code> argument into the recursive function call.  And if you fixed <em>that</em>, they wouldn't match the designated <code>end</code> node.  This code <em>can't</em> do what you want.</p>
<p>My suggestions:</p>
<ol>
<li><p>Don't plug random data into functions you found lying around the Internet.  Start simple:  <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow noreferrer">Dijkstra's Algorithm</a> will return the shortest path, which is what you want.  It's A* without the heuristic function (you said you've already read up on A*).  Code <em>that</em>, and then worry about getting complex.  (Note that you will probably need an adjustable priority queue --- you can build one using the <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code> module</a>.)</p></li>
<li><p>You need to access arbitrary nodes by an immutable ID, so your graph should be a dictionary, not a list.  The keys are your one-letter strings, and the values are lists (or tuples) of edges.  You can then iterate through all of a node's edges with something like: <code>for edge in graph['a']:</code>.</p></li>
<li><p>Your life will probably be much easier if you create a <a href="https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer"><code>collections.namedtuple</code></a> called <code>Edge</code> with two fields: <code>dest</code> and <code>weight</code>.  (You could do 3 fields if you find you also need the origin:  <code>orig</code>, <code>dest</code>, and <code>weight</code>.)</p></li>
<li><p>Look for other chunks of data that go together, and consider writing another <code>namedtuple</code> or a class for them, too.  (First contender: <code>Path</code>, with a <code>weight</code> method.)</p></li>
<li><p>Consider using the <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer"><code>pprint.pprint</code> function</a> for displaying large, nested structures like your graph.  It will make print-to-console debugging much easier.</p></li>
</ol>
<p>PS:  I found that the first couple chapters of Stuart Russell's and Peter Norvig's <a href="https://rads.stackoverflow.com/amzn/click/com/0136042597" rel="nofollow noreferrer">Artificial Intelligence: A Modern Approach, 3rd Ed</a> were an excellent introduction to graph search algorithms like this...  Unfortunately, the majority of the book would probably be off-topic for you.</p>
</div>
