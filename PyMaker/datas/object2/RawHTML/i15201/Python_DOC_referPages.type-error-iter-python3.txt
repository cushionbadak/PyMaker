<div class="post-text" itemprop="text">
<p>Can someone please explain why the following code is giving </p>
<pre><code>TypeError: iter() returned non-iterator of type 'counter'  in python 3
</code></pre>
<p>This is working in python 2.7.3 without any error.</p>
<pre><code>#!/usr/bin/python3

class counter(object):

    def __init__(self,size):
        self.size=size
        self.start=0

    def __iter__(self):
        print("called __iter__",self.size)
        return self

    def next(self):
        if self.start &lt; self.size:
            self.start=self.start+1
            return self.start
        raise StopIteration

c=counter(10)
for x in c:
    print(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python3.x you need to use  <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="noreferrer"><code>__next__()</code></a> instead of <code>next()</code> .</p>
<p>from <a href="https://docs.python.org/3.0/whatsnew/3.0.html" rel="noreferrer">Whatâ€™s New In Python 3.0</a>:</p>
<blockquote>
<p><a href="https://www.python.org/dev/peps/pep-3114/" rel="noreferrer">PEP 3114</a>: the standard next() method has been renamed to __next__().</p>
</blockquote>
<p>However, if you want your object to be iterable both in python 2.X and 3.X you can assign your <code>next</code> function to the name <code>__next__</code>. </p>
<pre><code>class counter(object):

    def __init__(self,size):
        self.size=size
        self.start=0

    def __iter__(self):
        print("called __iter__",self.size)
        return self

    def next(self):
        if self.start &lt; self.size:
            self.start=self.start+1
            return self.start
        raise StopIteration

    __next__ = next # Python 3.X compatibility
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need the <code>__next__(self)</code> not  next:</p>
<pre><code>def __next__(self): 
</code></pre>
</div>
