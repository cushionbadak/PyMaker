<div class="post-text" itemprop="text">
<p>I spent some time investigating the <a href="https://hg.python.org/cpython/file/3b920a778484/Lib/collections/__init__.py#l265"><code>collections.namedtuple</code> module</a> a few weeks ago. The module uses a factory function which populates the dynamic data (the name of the new <code>namedtuple</code> class, and the class attribute names) into a very large string. Then <code>exec</code> is executed with the string (which represents the code) as the argument, and the new class is returned. </p>
<p>Does anyone know why it was done this way, when there is a specific tool for this kind of thing readily available, i.e. the metaclass? I haven't tried to do it myself, but it seems like everything that is happening in the <code>namedtuple</code> module could have been easily accomplished using a <code>namedtuple</code> metaclass, like so: </p>
<pre><code>class namedtuple(type):
</code></pre>
<p>etc etc.  </p>
</div>
<div class="post-text" itemprop="text">
<p>There are some hints in the <a href="http://bugs.python.org/issue3974">issue 3974</a>. The author proposed a new way to create named tuples, which was rejected with the following comments:</p>
<blockquote>
<p><em>It seems the benefit of the original version is that it's faster,
  thanks to hardcoding critical methods.</em>
  - Antoine Pitrou</p>
</blockquote>
<blockquote>
<p><em>There is nothing unholy about using exec.  Earlier versions used other
  approaches and they proved unnecessarily complex and had unexpected
  problems.  It is a key feature for named tuples that they are exactly
  equivalent to a hand-written class.</em> - Raymond Hettinger</p>
</blockquote>
<p>Additionally, here is the part of the description of <a href="http://code.activestate.com/recipes/500261-named-tuples/">the original <code>namedtuple</code> recipe</a>:</p>
<blockquote>
<p>... the recipe has evolved to its current exec-style where we get all
  of Python's high-speed builtin argument checking for free. The new
  style of building and exec-ing a template made both the __new__ and
  __repr__ functions faster and cleaner than in previous versions of this recipe.</p>
</blockquote>
<p>If you're looking for some alternative implementations:</p>
<ul>
<li><p><a href="http://code.activestate.com/recipes/577629-namedtupleabc-abstract-base-class-mix-in-for-named/">abstract base class + mix-in for named tuples</a> recipe by Jan Kaliszewski</p></li>
<li><p><a href="https://gist.github.com/aliles/1160525">metaclass-based implementation</a> by Aaron Iles (see his <a href="http://aliles.tumblr.com/post/9205886103/replacing-exec-with-metaclass-for-namedtuple">blog post</a>)</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>As a sidenote: The other objection I see most often against using <code>exec</code> is that some locations (read companies) disable it for security reasons.</p>
<p>Besides an advanced <code>Enum</code> and <code>NamedConstant</code>, <a href="https://pypi.python.org/pypi/aenum" rel="nofollow">the aenum library</a>* also has <code>NamedTuple</code> which is <code>metaclass</code>-based.</p>
<hr/>
<p>* <code>aenum</code> is written by the author of <a href="https://docs.python.org/3/library/enum.html" rel="nofollow"><code>enum</code></a> and the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow"><code>enum34</code></a> backport.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another approach.</p>
<pre><code>""" Subclass of tuple with named fields """
from operator import itemgetter
from inspect import signature

class MetaTuple(type):
    """ metaclass for NamedTuple """

    def __new__(mcs, name, bases, namespace):
        cls = type.__new__(mcs, name, bases, namespace)
        names = signature(cls._signature).parameters.keys()
        for i, key in enumerate(names):
            setattr(cls, key, property(itemgetter(i)))
        return cls

class NamedTuple(tuple, metaclass=MetaTuple):
    """ Subclass of tuple with named fields """

    @staticmethod
    def _signature():
        " Override in subclass "

    def __new__(cls, *args):
        new = super().__new__(cls, *args)
        if len(new) == len(signature(cls._signature).parameters):
            return new
        return new._signature(*new)

if __name__ == '__main__':
    class Point(NamedTuple):
        " Simple test "
        @staticmethod
        def _signature(x, y, z): # pylint: disable=arguments-differ
            " Three coordinates "
    print(Point((1, 2, 4)))
</code></pre>
<p>If this approach has any virtue at all, it's the simplicity. It would be simpler yet without <code>NamedTuple.__new__</code>, which serves only the purpose of enforcing the element count. Without that, it happily allows additional anonymous elements past the named ones, and the primary effect of omitting elements is the <code>IndexError</code> on omitted elements when accessing them by name (with a little work that could be translated to an <code>AttributeError</code>). The error message for an incorrect element count is a bit strange, but it gets the point across. I wouldn't expect this to work with Python 2.</p>
<p>There is room for further complication, such as a <code>__repr__</code> method. I have no idea how the performance compares to other implementations (caching the signature length might help), but I much prefer the calling convention as compared to the native <code>namedtuple</code> implementation.</p>
</div>
<span class="comment-copy">hmmm. this certainly answers the question in general, but i'd be curious to know what these unexpected problems where. depending on what they were, the problems might be with metaclasses themselves, in which case maybe they should be fixed. it also seems the reply to that comment 2.5 years later brings up some real issues some people may have. in any case, thanks for the link - a lot of information there.</span>
<span class="comment-copy">I've never really bought this.  It's always seemed to me that the answer is "because Raymond Hettinger is okay with using weird hacks".</span>
<span class="comment-copy">@Rick Yes, it's possible, but you'll need to put <code>__slots__ = ()</code> into your class definition.</span>
<span class="comment-copy">@RickTeachey docs also link to <a href="http://code.activestate.com/recipes/577629-namedtupleabc-abstract-base-class-mix-in-for-named/" rel="nofollow noreferrer">another recipe</a>, which is <code>namedtuple</code> implemented using metaclasses. And I would expect it to be as fast as the current implementation...</span>
<span class="comment-copy">The stdlib is <i>not</i> the place to look for "good code" -- especially as the language evolves.  Updating the stdlib to follow new practices or take advantage of new modules is rife with opportunities to introduce new bugs, so it is rarely done.</span>
