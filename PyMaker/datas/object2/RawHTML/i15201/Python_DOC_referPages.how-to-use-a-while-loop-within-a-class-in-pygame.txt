<div class="post-text" itemprop="text">
<p>I'm trying to make an instance class (Block) spawn when the mouse is clicked and fade out slowly, and i want to be able to spawn an infinite number of blocks that fade out provided that the mouse is clicked fast enough. </p>
<p>To do this, I want to initiate the fade() function when the instance is first spawned and set ticks to 255 and set the alpha to ticks.</p>
<p>However, when using a while loop, the function completes itself without updating the display because the program gets constrained to the while loop in the fade() function.</p>
<p>Can someone help me with calling the fade function 255 times per instance?</p>
<pre><code>import pygame,sys,time,Blockm
from pygame.locals import *
black,white=(0,0,0),(255,255,255)
size=w,h=1400,800
screen=pygame.display.set_mode(size)
pygame.init()

class Block(object):

    sprite = None

    def __init__(self, x, y):
        if not Block.sprite:
            Block.sprite = pygame.image.load("Block.png").convert_alpha()
        self.rect = Block.sprite.get_rect(top=y, left=x)
        self.fade()

    def fade(self):
        ticks=255
        Block.sprite.set_alpha(ticks)
        while ticks!=0:
            ticks-=1
            print(ticks)



while True:
    blocks = []
    mmraw=pygame.mouse.get_pos()
    mmx,mmy=mmraw[0]-(pygame.image.load("Block.png").get_width())/2,mmraw[1]-(pygame.image.load("Block.png").get_width())/2
    for event in pygame.event.get():
        if event.type== pygame.QUIT:
            pygame.quit()
            sys.exit()
        if event.type == pygame.MOUSEBUTTONDOWN:
            print('click')
            blocks.append(Block(mmx,mmy))

    for block in blocks:
        screen.blit(block.sprite, block.rect)
        print('trying to blit')
        print(Block.sprite.get_offset())
    pygame.display.update()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have one solution for you that ought to accomplish what you want it to, but I concede that it <em>does not answer the question exactly as asked.</em></p>
<p>The first and most hindering problems you may be having are that you need to use <code>pygame.image.load("Block.png").convert()</code> and not <code>pygame.image.load("Block").convert_alpha()</code>, since <code>.convert_alpha()</code> doesn't work with <code>.set_alpha(..)</code>.
It's also possible that you aren't noticing when blocks fade in any solution because <code>screen</code> isn't being refreshed prior to <code>update</code>. New, faded blocks are being drawn over 'brighter' ones, producing no difference (overlapping blocks notwithstanding). I've added a stopgap to my solution code below that fills the screen with blue, but I imagine you'll want something different. It's marked with a comment.</p>
<p>What I would suggest is having each <code>Block</code> process its alpha locally during a call from the main loop in your <code>for block in blocks:</code> block before you blit it. This version of your code should give you the result you want, although it does it using just the main loop, rather than parallel loops like you were asking about...</p>
<pre><code>import pygame,sys,time,Blockm
from pygame.locals import *
black,white=(0,0,0),(255,255,255)
size=w,h=1400,800
screen=pygame.display.set_mode(size)
pygame.init()

class Block(object):

    sprite = None

    def __init__(self, x, y):
        if not Block.sprite:
            Block.sprite = pygame.image.load("Block.png").convert()
            # ^  MODIFIED: .convert_alpha() won't recognize the effects of .set_alpha(), so use regular .convert() instead.
        self.rect = Block.sprite.get_rect(top=y, left=x)
        self.ticks = 255 # NEW: Set a local tick count.
        # REMOVED `self.fade()`: This runs on main now.

    def fade(self):
        ## REPURPOSED METHOD: Runs each frame that the Block is active. Called on main loop.
        # MODIFIED BLOCK: Update local tick count before setting the class's sprite alpha.
        self.ticks -= 1
        Block.sprite.set_alpha(self.ticks) # MOVED, MODIFIED: uses local tick count for alpha.
        print(self.ticks) # UPDATED: Using local ticks.


blocks = [] # MOVED: Make a list for the Blocks, but don't clear it on frame.
while True:    
    mmraw=pygame.mouse.get_pos()
    mmx,mmy=mmraw[0]-(pygame.image.load("Block.png").get_width())/2,mmraw[1]-(pygame.image.load("Block.png").get_width())/2
    # ^  There may be a tidier way of doing this. Described in solution body...
    for event in pygame.event.get():
        if event.type== pygame.QUIT:
            pygame.quit()
            sys.exit()
        if event.type == pygame.MOUSEBUTTONDOWN:
            print('click')
            blocks.append(Block(mmx,mmy))

    screen.fill((22,22,222))
    # ^  NEW: Fill the screen with some backdrop so that the erasure is obvious!
    #         If you don't do this, you'll be blitting faded images over brighter ones and there will be no real change!!
    for block in blocks:
        block.fade()    # NEW: Update this block.
        if block.ticks &lt; 1: # NEW BLOCK: If the block has become invisible...
            blocks.remove(block) # NEW: Expunge this invisible block.
            continue # NEW: Immediately move on to the next block.
        screen.blit(Block.sprite, block.rect)
        print('trying to blit')
        print(Block.sprite.get_offset())
    pygame.display.update()
</code></pre>
<p>There's a small problem with it, which is that vanishing Blocks trigger a 'flicker' in other remaining Blocks (or at least the next one in <code>blocks</code>) and I'm not sure why or how.</p>
<hr/>
<p>While I was looking, I found a few other things you might want to consider:</p>
<p>...in <code>class Block:</code>:</p>
<p>-Consider using <code>sprite = pygame.image.load("Block.png").convert()</code> instead of <code>sprite = None</code>. This way, you can use something like <code>mmx,mmy = mmraw[0] - Block.sprite.get_rect.centerx, mmraw[1] - Block.sprite.get_rect().centery</code> instead of loading the image for a moment, just to know its size. Since all <code>Block</code>s use the same graphic, it shouldn't make a difference, and this way, you won't have to reacquire the offset if you change <code>Block.sprite</code> during runtime!</p>
<p>-Consider assigning a <em>copy</em> of <code>Block</code>'s sprite to each instance instead of using the class's Surface. This will take up more processing power, but only momentarily if you use it as a <code>return</code> instead. For instance:</p>
<pre><code>class Block(object):
      ...
    def fade(self):
        sprite = Block.sprite.copy()
        sprite.set_alpha(self.ticks)
        self.ticks -= 1
        return sprite

  ...

while True: # main loop
      ...
    for block in blocks:
        screen.blit(block.fade(), block.rect) # Although there are more Pythonic ways of writing this.
</code></pre>
<p>Alternatively, you could use <code>screen.blit(sprite, self.rect)</code> in <code>Block.fade()</code> rather than on main and forego the return entirely. Because the alpha is set locally, it won't have to be <em>reset</em> every time <code>fade</code> runs, and <code>Block</code>'s unbound <code>sprite</code> can stay fresh!</p>
<p>Anyway, I hope this solves your problem, even if it does not (exactly) answer your question!</p>
</div>
<div class="post-text" itemprop="text">
<p>You probably want to use <a href="https://docs.python.org/3/library/threading.html" rel="nofollow">threads</a>. These allow you to run multiple things at once. For your code, change it like this:</p>
<pre><code>from threading import Thread
import pygame, sys, time, Blockm
from pygame.locals import *
black = (0,) * 3
white = (255,) * 3
size = w, h = 1400, 800
screen = pygame.display.set_mode(size)
pygame.init()

class Block(object):

    sprite = None

    def __init__(self, x, y):
        if not Block.sprite:
            Block.sprite = pygame.image.load("Block.png").convert_alpha()
        self.rect = Block.sprite.get_rect(top=y, left=x)
        Thread(target=self.fade) # Made this a Thread so it runs separately.

    def fade(self):
        for tick in range(255, 0, -1):
            Block.sprite.set_alpha(tick)
            print(tick)


def game():
    while True:
        # The contents of that while True loop at the end


def main():
    Thread(target=Main)


if __name__ == "__main__":
    main()
</code></pre>
<p>This also adds an entry point to your program, which was lacking. Also, <code>Block.fade</code> wouldn't actually do what you want, as you only <code>set_alpha</code> once. I fixed that with a <code>for</code> loop instead. Also, note that you can now just <code>return</code> to break out of the whole game.</p>
</div>
<span class="comment-copy">There are a couple of small problems which may be getting underfoot: You're probably going to want <code>pygame.image.load(..).convert()</code> and not <code>.convert_alpha()</code> if you're using <code>.set_alpha(..)</code> later. Also, I don't think your <code>screen</code> is being refreshed, erasing old <code>Blocks</code> from the last frame. Other than than, have you considered using some function in <code>Block</code> that the main loop calls, instead of running parallel loops? That's the solution I've posted, but there may well be a good reason why you'd want to use several concurrent loops instead of one central one.</span>
<span class="comment-copy">This looks great! Thanks so much!</span>
<span class="comment-copy">@coder Happy it's of use!</span>
<span class="comment-copy">I feel like using multiple parallel loops is something that should be avoided as much as possible, although there are certainly reasons why you might go this route. In general, if you can do something on a main loop, do it there (as an <code>update</code> call, or by applying a value directly to the object) instead, so that you can keep better control of your processes.</span>
<span class="comment-copy">Thanks for your help! I tried this but it just does the same thing, the screen goes black and the game stops looping after clicking until the ticks reach 0 and then the block appears</span>
