<div class="post-text" itemprop="text">
<p>Is it possible to do something like the following:</p>
<pre><code>class foo():
    def bar():  # a method that doesn't take any args
        # slow calculation
        return somefloat

    b = bar  # bar is a function but b just gives you the float attribute

f = foo()
f.b  # returns somefloat but doesn't require the empty parentheses
</code></pre>
<p>I hope the example is clear since I'm not super clear on what the terminology is for what I want to do. My basic goal is to remove a bunch of parentheses for methods that don't have arguments to make the code cleaner to read. </p>
<p>The function is slow and rarely used so it would be easiest to calculate it real time rather than calculate it once ahead of time and store the variable.</p>
<p>Is this possible? Is it good practice? Is there a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p>The standard way to achieve this is to use <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow"><code>property</code></a>, which is a <a href="https://docs.python.org/3/glossary.html#term-decorator" rel="nofollow">decorator</a>:</p>
<pre><code>class Foo():

    @property
    def bar(self):
        # slow calculation
        return somefloat


f = Foo()

f.bar  # returns somefloat but doesn't require the empty parentheses
</code></pre>
<p>A couple of things to notice:</p>
<ol>
<li><p>You still need <code>self</code> in the method signature as usual, because sometimes you're going to need to refer to e.g. <code>self.some_attribute</code> inside the method. As you can see, that doesn't affect the <em>use</em> of the property at all.</p></li>
<li><p>There's no need to clutter your API with both a <code>f.bar()</code> method and a <code>f.b</code> property - it's better to decide what makes most sense for your class than offer a heap of different ways to do the same thing.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><code>b = bar</code> obviously wouldn't work.  However a <strong>property</strong> would for the simplest "doesn't require the empty parentheses" ask of yours:</p>
<pre><code>b = property(bar)
</code></pre>
<p>Now every access to <code>f.b</code> will call <code>f.bar()</code> "behind the curtains".</p>
<p>However this means that if you access <code>f.b</code> twice, <code>f.bar()</code> gets called twice, repeating the computation.  If the repetition is irrelevant (i.e if the result doesn't change for repeated computations on the same object) you can do better ("caching" the result in <code>f.b</code> forever once it's first been computed) -- something like:</p>
<pre><code>class foo(object):
    def bar(self):  # a method that doesn't take any args
        # slow calculation
        return somefloat

    def _cache_bar(self):
        result = self.bar()
        setattr(self, 'b', result)
        return result

    b = property(_cache_bar)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By static method, but need to call by parentheses. </p>
<pre><code>class foo(object):
    @staticmethod
    def bar():  # a method that doesn't take any args
        # slow calculation
        return "abc"

    b = bar  # bar is a function but b just gives you the float attribute

f = foo()
print f.b()
</code></pre>
<p>output:</p>
<pre><code>$ python test.py 
abc
</code></pre>
</div>
