<div class="post-text" itemprop="text">
<p>I created a class by using the abstract class in Python(2.7) and now I want to test this class by Nose. How to implement it technically?</p>
<p>Here I give an example code:</p>
<pre><code># -*- coding: utf-8 -*-
from abc import ABCMeta, abstractmethod, abstractproperty


class A(object):

    __metaclass__ = ABCMeta

    @abstractproperty
    def a(self):
        pass

    @abstractmethod
    def do(self, obj):
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can make a subclass of the abstract class and test the subclass. Also, instead of <code>pass</code>, you could raise a <code>NotImplementedError</code> when the abstract methods are called:</p>
<pre><code>@abstractproperty
def a(self):
    raise NotImplementedError("Not implemented")

@abstractmethod
def do(self, obj):
    raise NotImplementedError("Not implemented")
</code></pre>
<p>As stated in the <a href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" rel="nofollow">Python exceptions documentation</a>:</p>
<blockquote>
<p>exception NotImplementedError</p>
<p>This exception is derived from RuntimeError. In user defined base classes, abstract methods should raise this exception when they require derived classes to override the method.</p>
</blockquote>
<p>Then you implement a subclass:</p>
<pre><code>class B(A):
    def a(self):
        super(B, self).a()

    def do(self, obj):
        super(B, self).do(obj)
</code></pre>
<p>And you test that like this:</p>
<pre><code>@raises(NotImplementedError)
def abstractPropertyAShouldNotRun():
    B().a()

@raises(NotImplementedError)
def abstractMethodDoShouldNotRun():
    obj = []
    B().do(obj)
</code></pre>
</div>
<span class="comment-copy">It still raises the error: TypeError: Can't instantiate abstract class A with abstract methods a, do. Does the ABCMeta cause the error?</span>
<span class="comment-copy">Yes, you should create a subclass and then test it instead of the abstract class directly. I will update my answer.</span>
<span class="comment-copy">Thanks a lot! It works ^^, btw will this way make the abstract class a little bit complex(It adds a raise statement)? And in the practical application, should I use the abstract class or is that meaningful of testing a abstract class?</span>
<span class="comment-copy">Glad to help! Raising the NotImplementedError in the abstract methods is more important when you are not using ABCMeta, as it will raise an exception if the subclass tries to call a method that was not overriden. Since ABCMeta will prevent the subclass from being instantiated if it does not override all abstract methods from the superclass, you can safely remove the NotImplementedError. I believe it is better to focus your test efforts on the concrete classes, where the actual behavior is coded.</span>
<span class="comment-copy">Thank for your explanation. It helps me understand the mechanism of ABCMeta. The abstract class is just one piece of my code that confuses me when testing it, cause i never thought to test a abstract class before accessing the test.^^</span>
