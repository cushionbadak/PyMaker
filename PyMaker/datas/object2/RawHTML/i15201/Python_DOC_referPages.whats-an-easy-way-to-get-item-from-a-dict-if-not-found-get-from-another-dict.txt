<div class="post-text" itemprop="text">
<p>I would like to get a value from <code>a</code>. If it can't be found there, then try to get it from <code>b</code>. Throw exception if it can't be found in <code>b</code> either.</p>
<p><code>a.get(key, b[key])</code> doesn't work since it won't lazy evaluate <code>b[key]</code>.</p>
<p>What's the proper way to it?</p>
<p>The following works but seems a bit lengthy.</p>
<pre><code>value = a.get(key, b.get(key, 'not found'))
if value == 'not found':
    raise Exception()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using 3.3+, you can use <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer">ChainMap</a></p>
<pre><code>from collections import ChainMap

a = {'a': 1}
b = {'b': 2}

# Add as many `dict`s as you want in order of priority...
chained = ChainMap(a, b)
print(chained['b'])
</code></pre>
<p>If you're only interested in retrieval and don't have 3.3+ available, then you can roll your own helper function:</p>
<pre><code>def whatever(key, *args):
    for mapping in args:
        try:
            return mapping[key]
        except KeyError:
            pass
    raise KeyError(key)
</code></pre>
<p>Then use that as <code>value = whatever('somekey', a, b)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Use conditional expression, like this</p>
<pre><code>a[key] if key in a else b[key]
</code></pre>
<p>If you want to avoid error, if it is not found in both of them, you can use <code>dict.get</code>, like this</p>
<pre><code>a[key] if key in a else b.get(key, &lt;default_value&gt;)
</code></pre>
<p><em>There is an ugly hack</em>, which uses a tuple of dictionaries to pick the best one</p>
<pre><code>(b, a)[key in a].get(key)
</code></pre>
<p>if you want to get the key error, you can make it even more weirder,</p>
<pre><code>(b, a)[key in a][key]
</code></pre>
<p>This will pick <code>a</code>, if <code>key</code> is really in <code>a</code>, because boolean expressions are equivalent to 1 (<code>True</code>) and 0 (<code>False</code>). So, <code>(b, a)[True]</code> will pick <code>a</code> and <code>False</code> would pick <code>a</code>.</p>
</div>
<span class="comment-copy">If later you decide that you don't want the <code>KeyError</code>, you can still do <code>chained.get('c', 3)</code>.</span>
<span class="comment-copy">Downvoter, if you are still around, please explain how I can improve this answer.</span>
