<div class="post-text" itemprop="text">
<p>I have some code like the following in Python:</p>
<p><em>library.py</em>:</p>
<pre><code>class HasSideEffects(object):

    def __init__(self, kittens):
        print 'kittens cry'  # &lt;- side effect

    def launch_nukes(self):
        print 'launching nukes'  # &lt;- side effect
</code></pre>
<p><em>my_code.py</em>:</p>
<pre><code>from library import HasSideEffects


class UtilitySubclass(HasSideEffects):

    def party(self):
        self.launch_nukes()
        return 'confetti'  # I want to test that my confetti cannon will work


if __name__ == '__main__':
    x = UtilitySubclass(1)  # oh no! crying kittens :(
    x.party()  # oh no! nukes!
</code></pre>
<p>I want to unit test that when I call <code>party</code> I will get <code>confetti</code>. However, I want to avoid all the side effects that are part of the library class I am subclassing. More specifically, I want to avoid these side effects in the unit tests, but the side effects are needed in the production code.</p>
<p>I cannot change the code in <code>library.py</code> because it's a library, and I did not write the code. Obviously I wouldn't want to maintained a forked version of a library just to facilitate a unit test.</p>
<p>I've been trying to mock the <code>HasSideEffects</code> superclass. I need to mock <code>__init__</code> and <code>launch_nukes</code> in the superclass so they no longer perform side effects. I've been having some trouble mocking the <code>__init__</code> method, apparently the Python <code>mock</code> library does not support it?</p>
<p>What's the best way to test that <code>party</code> return <code>confetti</code>, while avoiding side effects?</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you was quite close to a solution:</p>
<blockquote>
<p>I've been trying to mock the HasSideEffects superclass. I need to mock <strong>init</strong> and launch_nukes in the superclass so they no longer perform side effects. I've been having some trouble mocking the <strong>init</strong> method, apparently the Python mock library does not support it?</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><code>unittest.mock</code> and legacy <code>mock</code></a> are designed exactly to do this kind of work. When you need to remove dependencies from library or resources mock it and replace by <code>patch</code> is powerful especially when you should play with legacy code that you cannot change.</p>
<p>In your case you need to patch either <code>__init__</code> method: to do it you must take in account two things </p>
<ol>
<li>If the class is subclassed and you need patch it when build a subclass object you must patch <code>__init__</code> directly instead of class definition.</li>
<li><code>__init__</code> method MUST return <code>None</code> and your mock too.</li>
</ol>
<p>Now come back to your simple example: I changed it a little bit to make tests more explicit.</p>
<p><strong>library.py</strong></p>
<pre><code>class HasSideEffects(object):

    def __init__(self, kittens):
        raise Exception('kittens cry')  # &lt;- side effect


    def launch_nukes(self):
        raise Exception('launching nukes')  # &lt;- side effect
</code></pre>
<p><strong>my_code.py</strong></p>
<pre><code>from library import HasSideEffects

class UtilitySubclass(HasSideEffects):

    def party(self):
        self.launch_nukes()
        return 'confetti'  # I want to test that my confetti cannon will work
</code></pre>
<p><strong>test_my_code.py</strong></p>
<pre><code>import unittest
from unittest.mock import patch, ANY
from my_code import UtilitySubclass


class MyTestCase(unittest.TestCase):
    def test_step_by_step(self):
        self.assertRaises(Exception, UtilitySubclass) #Normal implementation raise Exception
        #Pay attention to return_value MUST be None for all __init__ methods
        with patch("library.HasSideEffects.__init__", autospec=True, return_value=None) as mock_init:
            self.assertRaises(TypeError, UtilitySubclass) #Wrong argument: autospec=True let as to catch it
            us = UtilitySubclass("my kittens") #Ok now it works
            #Sanity check: __init__ call?
            mock_init.assert_called_with(ANY, "my kittens") #Use autospec=True inject self as first argument -&gt; use Any to discard it
            #But launch_nukes() was still the original one and it will raise
            self.assertRaises(Exception, us.party)
            with patch("library.HasSideEffects.launch_nukes") as mock_launch_nukes:
                self.assertEqual("confetti",us.party())
                # Sanity check: launch_nukes() call?
                mock_launch_nukes.assert_called_with()

    @patch("library.HasSideEffects.launch_nukes")
    @patch("library.HasSideEffects.__init__", autospec=True, return_value=None)
    def test_all_in_one_by_decorator(self, mock_init, mock_launch_nukes):
        self.assertEqual("confetti",UtilitySubclass("again my kittens").party())
        mock_init.assert_called_with(ANY, "again my kittens")
        mock_launch_nukes.assert_called_with()


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>Note as the decorator version is neat and simple.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a pretty tricky question to answer in general.  If the library class that you're mocking is simple enough, then you can provide your functionality as a <em>mixin</em>.</p>
<pre><code>class UtilitySubclassMixin(object):
    def party(self):
        self.launch_nukes()
        return 'confetti'

class UtilitySubclass(library.HasSideEffects, UtilityClassMixin):
    """meaningful docstring."""
</code></pre>
<p>Now, for testing you just need to provide a subclass that has the interface that your UtililtySubclassMixin expects (e.g. something with a <code>launch_nukes</code> method).  This isn't ideal, but if you need to mock out a library method that has an <code>__init__</code> with side-effects it's about the best you can do.  If it's all non-magic methods that have side-effects, <code>unittest.mock</code> can be used to patch the methods on <code>library.HasSideEffects</code> directly.</p>
<p>And, FWIW, this is a very good reason why <code>__init__</code> methods should never have side effects :-).</p>
</div>
<span class="comment-copy">Is unittest.mock part of Python 3? I am using Python 2.7.</span>
<span class="comment-copy">In Python 2.7 use <code>mock</code> instead of <code>unitest.mock</code>. You must get it from <code>pip</code> by <code>pip install mock</code></span>
<span class="comment-copy">@Buttons840 Sorry I forgot to tag your name... In Python 2.7 use <code>mock</code> instead of <code>unitest.mock</code>. You must get it from <code>pip</code> by <code>pip install mock</code></span>
