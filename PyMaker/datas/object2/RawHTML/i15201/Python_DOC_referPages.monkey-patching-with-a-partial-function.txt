<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/16626789/functools-partial-on-class-method">functools.partial on class method</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm trying to monkeypatch a method on <code>SomeClass</code> from an imported package:</p>
<pre><code>from somepackage import SomeClass

def newmethod(obj, node, **kwargs):
    """ """

SomeClass.oldmethod = newmethod
</code></pre>
<p>Where <code>obj</code> and <code>node</code> are in the default call signature of <code>SomeClass.oldmethod</code>:</p>
<pre><code>class SomeClass(object):

    def oldmethod(obj, node):
        """ """  
</code></pre>
<p>I'm aware that monkeypatching is not good practice, but we need a workaround while we fix some issues that otherwise can't be tackled.  The above approach works FINE, but we'd like to use partial functions to do this.  For example:</p>
<pre><code>from functools import partial
newmethod_a = partial(newmethod, foo='a')
newmethod_b = partial(newmethod, foo='b')
</code></pre>
<p>The partial function is being called because we need to pass different **kwargs.  But when I try to overload now:</p>
<pre><code>SomeClass.oldmethod = newmethod_a
</code></pre>
<p>I get an error related to the number of arguments passed, but it's very specific to my problem so pasting it might not be helpful...  The error I think is related to the call signature of <code>oldmethod</code> taking two positional arguments (<code>obj, node</code>), and my partial functions aren't passing a reference to the <code>obj</code> and <code>node</code> correctly.  I've tried different constructions like:</p>
<pre><code>newmethod_a = partial(SomeClass.newmethod, foo='a')
</code></pre>
<p>I'm sorry that I can't produce a minimal working example.  I hoped maybe an expert would just recognize this issue from experience and tell me if what I'm attempting is even possible within the scope of <code>partial</code>.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a quick example:</p>
<pre><code>from functools import partial

class foo(object):
    def bar(self, pos1, **kwargs):
        print("bar got self=%r, pos1=%r, kwargs=%r" % (self, pos1, kwargs))

foo.bar = partial(foo.bar, qux=1)
baz = foo()
baz.bar(1) # Fails...
</code></pre>
<p>This fails with a <code>TypeError</code>. The reason for this is that <code>baz.bar</code> is a bound method which expects its first argument to be a <code>foo</code> instance, but that the <code>partial</code> object is not, and hence Python will not add <code>self</code> for you when you call <code>baz.bar</code>. (This is not entirely correct, but the true reason is quite technical. See the Descriptor How-To linked below.)  Calling <code>baz.bar(baz, 1)</code> would work. To work around this, you'll have to make <code>foo.bar</code> a method again:</p>
<pre><code>import types

# In Python 2:
foo.bar = types.MethodType(partial(foo.bar.__func__, qux=1), None, foo)
# Method that is compatible with both Python 2 and 3:
foo.bar = types.MethodType(partial(foo.bar, qux=1), foo)
# Python 3 only:
from functools import partialmethod
foo.bar = partialmethod(foo.bar, qux=1)

baz = foo()
baz.bar(1) # Works!
</code></pre>
<p>See also:</p>
<ul>
<li>Closely related: <a href="https://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object">Adding a Method to an Existing Object</a>, <a href="https://stackoverflow.com/questions/16626789/functools-partial-on-class-method">functools.partial on class method</a></li>
<li><p>Loosely related, on functions vs. methods and when/how methods are bound:</p>
<ul>
<li><a href="https://docs.python.org/2/tutorial/classes.html#method-objects" rel="nofollow noreferrer">Documentation on Method Objects</a></li>
<li><a href="http://users.rcn.com/python/download/Descriptor.htm" rel="nofollow noreferrer">How-To guide for descriptors</a></li>
<li><a href="https://stackoverflow.com/questions/1015307/python-bind-an-unbound-method">Bind an unbound method</a></li>
</ul></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Replace:</p>
<pre><code>newmethod_a = functools.partial(newmethod, foo='a')
</code></pre>
<p>with:</p>
<pre><code>def newmethod_a(obj, node, **kwargs):
    kwargs.update({"foo": "a"})
    return newmethod(obj, node, **kwargs)
</code></pre>
</div>
<span class="comment-copy">please state at least the text of the error you are getting, then will be clear whether @Philips answer points in the right direction, or there is something else to it. The possibilities are endless...</span>
<span class="comment-copy">Your question is really a duplicate of <a href="http://stackoverflow.com/q/16626789">functools.partial on class method</a>; I'll let you pay out the bounty for now.</span>
<span class="comment-copy">I asked this question 4 months ago, I don't really have the environment anymore to test the solution.  The answer provided seems nice though.  I didn't put the bounty up though</span>
<span class="comment-copy">@MartijnPieters It was my bounty. I didn't find the functools.partial on a classmethod question but it looks relevant, too.</span>
<span class="comment-copy">@MartijnPieters Also, funnily enough, this question is actually older than that question, though it didn't have any answers until today!</span>
<span class="comment-copy">Awesome, thanks</span>
<span class="comment-copy">In Python 3, use <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow noreferrer"><code>functools.partialmethod()</code></a>; it is specifically designed for this usecase.</span>
<span class="comment-copy">Thanks, I added that and a link to the other question.</span>
