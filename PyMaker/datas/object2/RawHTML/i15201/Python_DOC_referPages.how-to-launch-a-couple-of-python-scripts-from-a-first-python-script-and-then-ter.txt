<div class="post-text" itemprop="text">
<p>I have a function in a python script which should launch another python script multiple times, I am assuming this can be done like this(Script is just my imagination of how this would work.)</p>
<pre><code>iterations = input("Enter the number of processes to run")
for x in range(0, iterations):
    subprocess.call("python3 /path/to/the/script.py", shell=True)
</code></pre>
<p>but, I also need to pass over some defined variables into the other script, for example, if </p>
<pre><code>x = 1
</code></pre>
<p>in the first script, then, I need x to have the same value in the second script without defining it there, I have NO idea how to do that. </p>
<p>And then also killing them, I have read about some method using PIDs, but don't those change every time? </p>
<p>Most of the methods I found on Google looked overly complex and what I want to do is really simple. Can anyone guide me in the right direction as to what to use and how I should go at accomplishing it? </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>I have a function in a python script which should launch another python script multiple times, I am assuming this can be done like this(Script is just my imagination of how this would work.)</strong></p>
<p>**
Here is the subprocess manual page which contains everything I will be talking about 
<a href="https://docs.python.org/2/library/subprocess.html" rel="nofollow">https://docs.python.org/2/library/subprocess.html</a></p>
<p>One of the way to call one script from other is using subprocess.Popen
something on the lines</p>
<pre><code>   import subprocess
   for i in range(0,100):
       ret = subprocess.Popen("python3 /path/to/the/script.py",stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
</code></pre>
<p>you can use the return value from Open to make the call synchronous using the communicate method.</p>
<pre><code>  out,err = ret.communicate()
</code></pre>
<p>This would block the calling script until the subprocess finishes.</p>
<p><strong>I also need to pass over some defined variables into the other script??</strong></p>
<p>There are multiple ways to do this.
 1. Pass parameters to the called script and parse it using OptionPraser or <code>sys.args</code>
 in the called script have something like</p>
<pre><code>     from optparse import OptionParser
     parser = OptionParser()
     parser.add_option("-x","--variable",action="store_true",dest="xvalue",default=False)
     (options,args) = parser.parse_args()

     if options.xvalue == True:
          ###do something
</code></pre>
<p>in the callee script use subprocess as</p>
<pre><code>     ret = subprocess.Popen("python3 /path/to/the/script.py -x",stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
</code></pre>
<p>Note the addition of -x parameter</p>
<ol start="2">
<li><p>You can use args parse</p>
<p><a href="https://docs.python.org/2/library/argparse.html#module-argparse" rel="nofollow">https://docs.python.org/2/library/argparse.html#module-argparse</a></p></li>
<li><p>Pass the subprocess a environment variable which can be used to configure the subprocess. This is fast but this only works one way, i.e. from parent process to child process.
in called script</p>
<pre><code> import os
 x = int(os.enviorn('xvalue'))
</code></pre></li>
</ol>
<p>in callee script set the environment variable</p>
<pre><code>    import os
    int x = 1
    os.environ['xvalue'] = str(x)
</code></pre>
<ol start="4">
<li>Use sockets or pipes or some other IPC method</li>
</ol>
<p><strong>And then also killing them, I have read about some method using PIDs, but don't those change every time?</strong></p>
<p>again you can use subprocess to hold the process id and terminate it
this will give you the process id</p>
<pre><code>ret.pid
</code></pre>
<p>you can then use .terminate to terminate the process if it is running </p>
<pre><code>ret.terminate()
</code></pre>
<p>to check if the process is running you can use the poll method from subprocess Popen. I would suggest you to check before you terminate the process</p>
<pre><code>ret.poll()
</code></pre>
<p>poll will return a None if the process is running</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just need to pass some values to second script, and you need to run that
by means of subprocess module, then you may simply pass the variables as command line arguments:</p>
<pre><code>for x in range(0, iterations):
    subprocess.call('python3 /path/to/second_script.py -x=%s'%x, shell=True)
</code></pre>
<p>And recieve the -x=1 via sys.argv list inside second_script.py (using <a href="https://docs.python.org/3/howto/argparse.html" rel="nofollow">argparse</a> module) </p>
<p>On the other hand, If you need to exchange something between the two scripts dynamically (while both are running), You can use the pipe mechanism or even better, use the <a href="https://docs.python.org/3.4/library/multiprocessing.html" rel="nofollow">multiprocessing</a> (wich requires some changes in your current code), it would make communication with and controlling it (terminating it) much cleaner.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can pass variables to subprocesses via the command line, environment variables or passing data in on stdin. Command line is easy for simple strings that aren't too long and don't themselves have shell meta characters in them. The target script would pull them from <code>sys.argv</code>.</p>
<p>script.py:</p>
<pre><code>import sys
import os
import time

x = sys.argv[1]
print(os.getpid(), "processing", x)
time.sleep(240)
</code></pre>
<p><code>subprocess.Popen</code> starts child processes but doesn't wait for them to complete. You could start all of the children, put their popen objects in a list and finish with them later.</p>
<pre><code>iterations = input("Enter the number of processes to run")
processes = []
for x in range(0, iterations):
    processes.append(subprocess.Popen([sys.executable, "/path/to/the/script.py", str(x)])
time.sleep(10)
for proc in processes:
    if proc.poll() is not None:
        proc.terminate()

for proc in processes:
    returncode = proc.wait()
</code></pre>
</div>
<span class="comment-copy">How about using <code>multiprocessing.Pool</code>? You can then use <code>map_async</code> to pass arguments, or <code>terminate</code> to finish them.</span>
<span class="comment-copy">But the script that is called contains an infinite while loop, I need a way to terminate that, and I don't really understand how I would pass variables onto the other script using that, can you elaborate on how I'd do that?</span>
<span class="comment-copy">updated the answer. You can always check the manual pages for more information</span>
<span class="comment-copy">Ok, using your post, I did exactly what I wanted, minus one thing, say, I execute 5 processes (all under the ret variable), and then I do ret.terminate(), only the last opened process is closed, with 4 that I cannot close, how can I close the remaining 4 with just one command?</span>
<span class="comment-copy">I think one answer explains it. Store the returned object in a list or a dictionary whenever you call pOpen at different indexes. Now because u have objects for all created processes you can terminate whichever you want. There is one answer in this post that does that already</span>
