<div class="post-text" itemprop="text">
<p><strong>Problem description:</strong> I have a class <code>C</code> inheriting from mixins <code>A</code> and <code>B</code>.
I want a new class, <code>C_</code>, having all the methods/attributes defined in the class <code>C</code> but with <code>B</code> swapped with <code>B_</code> (same API) in the inheritance scheme (one possible use of this is easy mocking). <strong>All classes are new style classes.</strong></p>
<p>I got what I wanted by messing with the inheritance order, therefore the MRO:</p>
<pre><code>A   B   B_    B_  A   B
 \ /   /       \   \ /
  C   /         \   C
   \ /           \ /
    C1            C2
C1(C,B_)       C2(B_,C)

C1.__mro__ = (C1, C , A, B, B_, object)
C2.__mro__ = (C2, B_, C, A, B , object)
</code></pre>
<p>The <code>C2</code> method (inheriting the modified mixin before the <code>C</code> class) works without much surprise and if I call a method defined in the <code>B</code> mixin, the <code>B_</code>'s definition is chosen.</p>
<p>For the moment it works, but I feel like: "fingers crossed, I hope a special case does not arise and break the system !"</p>
<p><strong>The question is</strong>: is it a finally-not-so-wrong way to solve the problem or is there a better way to do it ?</p>
<p>PS: I think I could take my bazooka and create a metaclass to redefine the mro (<a href="https://docs.python.org/3/library/stdtypes.html#class.mro">as said in the official doc</a>), but my instinct says it's not going to be necessarily prettier.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your approach should work just fine.  It is legitimate to use a subclass to control the MRO and to shadow one class with another.</p>
<p>This blog post gives several examples:  <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow">https://rhettinger.wordpress.com/2011/05/26/super-considered-super/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You already know this is messy.  If A and B (and hence B') were to have attributes in common, then C would get those attributes from A while C_ would get them from B_.</p>
<p>Assuming that you are not using super() in any new methods defined in C, I would make C a simple class (no bases) and then write</p>
<pre><code>class D(C, A, B): pass
class D_(C, A, B_): pass
</code></pre>
</div>
<span class="comment-copy">I don't see anything wrong with it. The algorithm used to build the MRO is documented, and, as such, you can rely on the order you are seeing.</span>
<span class="comment-copy">Note: if B_ inherits from B, it will precede B in the MRO whatever the order in the class definition. This is not your use case, but it might be the case for someone searching about this, so I thought it might be worth mentioning. I can understand why B_ would not inherit from B but note that you don't exactly replace B with B_: methods defined in B and not in B_ are still taken from B.</span>
