<div class="post-text" itemprop="text">
<p>I have been using Python 2.7 since very soon after it was released. I just recently had problems with 2.7 not doing everything I needed, so I updated (finally). However, after a few days, I am noticing some problems with multiplication. But is it something I'm doing or a problem with Python itself?</p>
<pre><code>&gt;&gt;&gt; 12*0.1
1.2000000000000002
</code></pre>
<p>If I run a loop like this:</p>
<pre><code>&gt;&gt;&gt; for i in range ( -20, 20 ):
...     print ( i, i*.1 )
...
</code></pre>
<p>The output is:</p>
<pre><code>-20 -2.0
-19 -1.9000000000000001
-18 -1.8
-17 -1.7000000000000002
-16 -1.6
-15 -1.5
-14 -1.4000000000000001
-13 -1.3
-12 -1.2000000000000002
-11 -1.1
-10 -1.0
-9 -0.9
-8 -0.8
-7 -0.7000000000000001
-6 -0.6000000000000001
-5 -0.5
-4 -0.4
-3 -0.30000000000000004
-2 -0.2
-1 -0.1
0 0.0
1 0.1
2 0.2
3 0.30000000000000004
4 0.4
5 0.5
6 0.60000000000000001
7 0.70000000000000001
8 0.8
9 0.9
10 0.10
11 0.11
12 0.120000000000000002
13 0.13
14 0.140000000000000001
15 0.15
16 0.16
17 0.170000000000000002
18 0.18
19 0.190000000000000002
</code></pre>
<p>When I do a loop like this, however:</p>
<pre><code>&gt;&gt;&gt; for i in range ( -20, 20 ):
...     print ( i, i/10 )
...
</code></pre>
<p>It prints out the correct numbers. I have even run the first loop with a range of +/- 1,000,000, and about 40% of the numbers end up this way. Why is this happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason for the difference is that integers can be represented accurately in binary, whereas many decimal numbers cannot (given finite memory).</p>
<p>The float <code>0.1</code> is an example of this:</p>
<pre><code>&gt;&gt;&gt; "%.32f" % 0.1
'0.10000000000000000555111512312578'
</code></pre>
<p>It's not <em>exactly</em> <code>0.1</code>. So multiplying by the float <code>0.1</code> is not quite the same as dividing by <code>10</code>. It gives a different result, as you observe:</p>
<pre><code>&gt;&gt;&gt; 14 / 10
1.4
&gt;&gt;&gt; 14 * 0.1
1.4000000000000001
</code></pre>
<p>Of course, neither result here is exactly <code>1.4</code>, it's just that the multiplication by the float <code>0.1</code> has a slightly greater margin of error than dividing by the integer <code>10</code>. The difference between the two is just enough that the division gets rounded to one decimal place, but the multiplication does not.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is the <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow">floating point</a> in python. As you can read on that link, python uses to round numbers, because they actually have a lot of digits. But when you multipli by .1 python asumes that you spect to see a point floating number, thats why the issue doesn't happen when you divide by 10.</p>
<p>However, you can format your numbers if you want</p>
<pre><code>&gt;&gt;&gt; format(math.pi, '.12g')  # give 12 significant digits
'3.14159265359'

&gt;&gt;&gt; format(math.pi, '.2f')   # give 2 digits after the point
'3.14'
</code></pre>
<p>Hope that helps.</p>
</div>
<span class="comment-copy">Floats are inherently inaccurate. If you want exact results, consider the <code>fractions</code> module.</span>
<span class="comment-copy">This isn't specific to 3.x, btw. I get <code>1.2000000000000002</code> when I try your code in 2.7.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a></span>
<span class="comment-copy">You should make it clear that the problem does not lie in <i>python</i> but that that is how floating points work, as used by all modern processors.</span>
