<div class="post-text" itemprop="text">
<p>I have a process with which I can communicate on the command line like this:</p>
<pre><code>% process -
input
^D^D
output
</code></pre>
<p>So: I start the process, type some input and after hitting Ctrl-D twice, I get the output. 
I want to make a Python wrapper around this process. I created this:</p>
<pre><code>from subprocess import Popen, PIPE

p = Popen('process -', stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True)
while True:
        input = raw_input('Enter input: ')
        p.stdin.write(input)
        p.stdin.close()
        p.wait()
        output = p.stdout.read()
        print output
</code></pre>
<p>This works the first time, but after that I get:</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 7, in &lt;module&gt;
    p.stdin.write(input)
ValueError: I/O operation on closed file
</code></pre>
<p>Is there another way to interact with this process without closing the file?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.wait" rel="nofollow"><code>p.wait()</code></a> will wait until the subprocess has exited prior to returning, so on the second iteration in your script, <code>p</code> has exited already (and has therefore closed <code>p.stdin</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>If the proccess you're wrapping ends after the first ouput, the comunication will fail to the second. Due all pipes (stdin and stdout) will be closed. Hence the error:</p>
<p><code>ValueError: I/O operation on closed file</code>.</p>
<p>Each time you try to send input to the wrapped process, this must be expecting that input and pipes must be opened. </p>
<p>On the other hand is what Thomas said in his answer, <code>p.wait()</code> is not the way to go for repetitive input/output strategy. </p>
<p>You can't use <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow">subprocess.Popen.communicate()</a> neither, due it calls <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.wait" rel="nofollow">subprocess.Popen.wait()</a> internally.</p>
<p>You can try use <code>p.stdin.write</code> and <code>p.stdout.read</code> here you have a good article about the subject: <a href="https://gist.github.com/waylan/2353749" rel="nofollow">Writing to a python subprocess pipe</a></p>
</div>
<div class="post-text" itemprop="text">
<p>To emulate the shell session:</p>
<pre><code>$ process -
input
^D^D
output
</code></pre>
<p>In Python, using <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>check_output()</code></a>:</p>
<pre><code>#!/usr/bin/env python3
from subprocess import check_output

out = check_output(['process', '-'], input='input\n', universal_newlines=True)
print(out, end='')
</code></pre>
<hr/>
<p><kbd>Ctrl+D</kbd> is recognized as EOF (terminate the input) by a Unix terminal (<code>$ stty -a</code> -- look for <code>eof = ^D</code> and <code>icanon</code> in the output). If you need to type <kbd>Ctrl+D</kbd> twice (<a href="https://stackoverflow.com/a/21261742/4279">at the beginning of a line</a>); it might indicate a bug in the <code>process</code> program such as <a href="http://bugs.python.org/issue1633941" rel="nofollow noreferrer">"<code>for line in sys.stdin:</code> doesn't notice <code>EOF</code> the first time" Python bug</a>.</p>
</div>
<span class="comment-copy">The problem is a bit more complicated. As I see it now you have to remove those closing lines, add <code>p.stdin.flush()</code> and catch the SIGINT signal. And when it occures you have to pass it to the subprocess and <b>then</b> <code>p.wait()</code> (or better <code>p.communicate()</code>), print the output and close the process.</span>
