<div class="post-text" itemprop="text">
<p>I have problem with boost python, base object destructor.
When object boost::python::dict is created and destroyed in py_init scope then everything is fine.
But in py_smth scope dict is only created success, after constructor executrion when local dict descructor is 
called then I have segmentation fault.</p>
<pre><code>    class py_init
    {
    public:
        py_init::py_init()
        {
              Py_Initialize();
              object main_module = import("__main__");
              main_namespace = main_module.attr("__dict__");
              main_namespace["sys"] = import("sys');
              exec("sys.path.insert(0, "/foo/boo"), main_namespace, main_namespace);
        }
    object main_namespace;
    };


    class py_smth
    {
    public:
       py_smth(std::shared_ptr&lt;py_init&gt; py)
       {
             dict local;
       }

};

Backtrace:
Program terminated with signal SIGSEGV, Segmentation fault
#0  0x00007f501ddf9a38 in ?? () from /usr/lib/x86_64-linux-gnu/libpython3.4m.so.1.0
(gdb) bt
#0  0x00002b9545827a38 in ?? () from /usr/lib/x86_64-linux-gnu/libpython3.4m.so.1.0
#1  0x00002b95450ff12f in boost::python::api::object_base::~object_base() () from libplugin.so
#2  0x00002b95450ff060 in boost::python::api::object::~object() () from libplugin.so
#3  0x00002b9545101198 in boost::python::detail::dict_base::~dict_base() libplugin.so
#4  0x00002b9545101230 in boost::python::dict::~dict() libplugin.so
</code></pre>
<p>Libs version:
-boost version 1.54
-python 3.4.2</p>
<p>And I don't know why...</p>
<p>Ok. this is sample code which is not working</p>
<p>main.cpp file:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;memory&gt;
#include "smth.h"

using namespace boost::python;

class py_init
{
public:
    py_init()
    {
             Py_Initialize();
             object main_module = import("__main__");
             main_namespace = main_module.attr("__dict__");
             main_namespace["sys"] = import("sys");
         main_namespace["time"] = import("time");
         main_namespace["threading"] = import("threading");
             exec("sys.path.insert(0, \"/foo/boo\")", main_namespace, main_namespace);

         exec("def foo():print (\"bla\"); time.sleep(1);" , main_namespace, main_namespace);
         exec("thread = threading.Thread(target=foo)" , main_namespace, main_namespace);
         exec("thread.start()" , main_namespace, main_namespace);
         state = PyEval_SaveThread();
    }
    ~py_init()
    {
          PyEval_RestoreThread(state);
          PyGILState_STATE gstate;
          gstate = PyGILState_Ensure();
          exec("thread.join()" , main_namespace, main_namespace);
          PyGILState_Release(gstate);
         std::cout&lt;&lt;"Py_init dest"&lt;&lt;std::endl;
    }

    object main_namespace;
    PyThreadState* state;
};

int main()
{
    std::shared_ptr&lt;py_init&gt; py(new py_init());
    smth s(py);
    s.print_foo();
    return 0;
}
</code></pre>
<p>smth.h</p>
<pre><code>#ifndef SMTH_H_
#define SMTH_H_

#include &lt;boost/python.hpp&gt;
#include &lt;memory&gt;
using namespace boost::python;
class py_init;

class smth
{
public:
    smth(std::shared_ptr&lt;py_init&gt; py)
    {
        dict local;
    }
    void print_foo()
    {
        std::cout&lt;&lt;"FOO"&lt;&lt;std::endl;
    }
    ~smth()
    {
        std::cout&lt;&lt;"smth dest"&lt;&lt;std::endl;
    }
};

#endif 
</code></pre>
<p>Backtrace:</p>
<pre><code>&gt; Program terminated with signal SIGSEGV, Segmentation fault.
&gt; #0  0x00007f9c5d787a38 in ?? () from /usr/lib/x86_64-linux-gnu/libpython3.4m.so.1.0 (gdb) bt
&gt; #0  0x00007f9c5d787a38 in ?? () from /usr/lib/x86_64-linux-gnu/libpython3.4m.so.1.0
&gt; #1  0x0000000000401a9d in boost::python::api::object_base::~object_base() ()
&gt; #2  0x0000000000401922 in boost::python::api::object::~object() ()
&gt; #3  0x0000000000401b50 in boost::python::detail::dict_base::~dict_base() ()
&gt; #4  0x0000000000401bde in boost::python::dict::~dict() ()
&gt; #5  0x0000000000401c08 in smth::smth(std::shared_ptr&lt;py_init&gt;) ()
&gt; #6  0x0000000000401727 in main ()
</code></pre>
<p>Compilation:</p>
<blockquote>
<p>g++ -std=c++0x -fPIC -I/usr/include/python3.4m -c main.cpp -o app.o
  g++ -std=c++0x app.o -lboost_python3 -lpython3.4m</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The program is invoking undefined behavior as the <code>boost::python::dict</code> object is being created and destroyed by a thread that does not hold the <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="nofollow">Global Interpreter Lock</a> (GIL).  If a thread is doing anything that affects reference counting of python managed object, then it needs to have acquired the GIL.  To resolve this, acquire and release the GIL within the <code>smth</code> constructor.</p>
<pre class="lang-cpp prettyprint-override"><code>smth::smth(std::shared_ptr&lt;py_init&gt; py)
{
  PyGILState_STATE gstate;
  gstate = PyGILState_Ensure(); // Acquire GIL.
  // Use scope to force destruction while GIL is held.
  {
    boost::python::dict local;
  } 
  PyGILState_Release(gstate); // Release GIL.
}
</code></pre>
<p>It may be worth considering using <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" rel="nofollow">RAII</a> classes to help manage the GIL.  For example, with the following <code>gil_lock</code> class, when a <code>gil_lock</code> object is created, the calling thread will acquire the GIL.  When the <code>gil_lock</code> object is destructed, it releases the GIL.</p>
<pre class="lang-cpp prettyprint-override"><code>/// @brief RAII class used to lock and unlock the GIL.
class gil_lock
{
public:
  gil_lock()  { state_ = PyGILState_Ensure(); }
  ~gil_lock() { PyGILState_Release(state_);   }
private:
  PyGILState_STATE state_;
};
</code></pre>
<p>The <code>smth</code> constructor could then be written as:</p>
<pre class="lang-cpp prettyprint-override"><code>smth::smth(std::shared_ptr&lt;py_init&gt; py)
{
  gil_lock lock;
  boost::python::dict local;
}
</code></pre>
<hr/>
<p>Here is an annotated version of the minimal original code.  It accentuates that the caller does not hold the GIL once <code>py_init</code>'s constructor returns.  Thus, both the creation and destruction of the <code>boost::python::dict</code> results in undefined behavior.</p>
<pre class="lang-cpp prettyprint-override"><code>class py_init
{
public:
  py_init()
  {
    Py_Initialize(); // Acquires GIL (1).
    // ... spawn Python thread that will compete for GIL.
    state = PyEval_SaveThread(); // Release GIL (0).
  }

  ~py_init()
  {
    PyEval_RestoreThread(state); // Acquire GIL (1). 
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure(); // Acquire GIL (2).
    // ...
    PyGILState_Release(gstate); // Release GIL (1).
  }

  PyThreadState* state;
};    

int main()
{
  std::shared_ptr&lt;py_init&gt; py(new py_init());
  // GIL not held.
  {
    // Modifying object without GIL; other thread may hold it.
    boost::python::dict local;
  }
} // ~py_init() acquires GIL.
</code></pre>
<p>In Python 3.4, one can also use <a href="https://docs.python.org/3/c-api/init.html?highlight=pygilstate_check#c.PyGILState_Check" rel="nofollow"><code>PyGILState_Check()</code></a> function to check if the calling thread holds the GIL.  Per the documentation, it is mainly a helper/diagnostic function.  For earlier versions, one can perform a similar check by directly accessing one of the Python globals:</p>
<pre class="lang-cpp prettyprint-override"><code>_PyThreadState_Current == PyGILState_GetThisThreadState();
</code></pre>
<p>The <a href="https://docs.python.org/2/c-api/init.html#c.PyThreadState_Get" rel="nofollow"><code>PyThreadState_Get()</code></a> function cannot be used for this type of diagnostics, as it issues a fatal error if no threads are holding the GIL, which is a valid state.</p>
</div>
<span class="comment-copy">Watch SO's syntax highlighting in action, it shows clearly that the code you present there is very misleading. I wonder if that even compiles...</span>
<span class="comment-copy">it's  pseudo code which captures the situations</span>
<span class="comment-copy">That's not even pseudo code and it shouldn't be. And even if it was, do you really think that pseudo code is useful when trying to diagnose a segfault? I don't know about you, but at least <i>my</i> pseudocode rarely segfaults.</span>
<span class="comment-copy">I added compiling code. Maybe now you can tell me more :)</span>
<span class="comment-copy">Can you reproduce this if you use <code>-std=c++11</code>? Can you reduce this to a single file? Is it necessary to create the <code>py_init</code> instance dynamically and pass a <code>shared_ptr</code> to the ctor of <code>smth</code>? What if you don't create a Python thread?</span>
