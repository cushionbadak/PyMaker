<div class="post-text" itemprop="text">
<p>If I currently have a file that is importing:</p>
<pre><code>from foo import f0
from foo.bar import f1
</code></pre>
<p>I can create a file <code>foo.py</code> with a function <code>f0</code> in it to satisfy the first import.</p>
<p>Is there any way to satisfy the second import from within that same file <code>foo.py</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>I just wanted to do that same thing. I only found this question, without an actual answer. So, here's what I came up with as a solution:</p>
<pre><code>import sys

def add_submodule(submod):
    name = submod.__name__
    sys.modules[__name__ + "." + name] = submod(name)


from types import ModuleType

class submod1(ModuleType):
    class foo:
        pass

class submod2(ModuleType):
    class bar:
        pass


add_submodule(submod1)
add_submodule(submod2)
</code></pre>
<p>In essence, you subclass <code>types.ModuleType</code> to define a module. You then add it manually to <code>sys.modules</code> below the namespace of the current module, as given by <code>__name__</code>.</p>
<hr/>
<p>This is a minimal solution. If one would want to move <code>add_submodule()</code> to a separate stand-alone module for re-usability, it would have to be expanded a bit:
One could not simply use <code>__name__</code> as this would be the namespace where <code>add_submodule()</code> was defined in. This should work instead:</p>
<p>In the separate module:</p>
<pre><code>def add_submodule(submod, parentname):
    name = submod.__name__
    sys.modules[parentname + "." + name] = submod(name)
</code></pre>
<p>In the actual module:</p>
<pre><code>add_submodule(submod1, __name__)
add_submodule(submod2, __name__)
</code></pre>
<p>I fear there's no nicer way of getting the parent's name into the function, though.</p>
<hr/>
<p>Both cases can now be used like so:</p>
<blockquote>
<p>In [1]: import submodtest.submod1 as sm1</p>
<p>In [2]: import submodtest.submod2 as sm2</p>
<p>In [3]: sm1. [TAB]</p>
<p>sm1.foo  sm1.mro  </p>
<p>In [3]: sm2. [TAB]</p>
<p>sm2.bar  sm2.mro</p>
</blockquote>
<hr/>
<p>EDIT: Pushed the above full example to <a href="https://github.com/NichtJens/aSuMo" rel="nofollow">my Github</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Create a directory called foo</p>
<ul>
<li>Within this directory, have a file called <code>__init__.py</code></li>
<li>This effectively creates a module called foo </li>
<li>In this file, store the functions you want bundled with foo</li>
</ul>
<p>Create a subdirectory of foo, called bar.</p>
<ul>
<li>Within this directory, have a file called <code>__init__.py</code></li>
<li>This effectively creates a sub module foo.bar </li>
<li>In this file, store the functions you want bundled with foo.bar</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>No, you should create a directory named foo as a package.</p>
<p>Click <a href="https://docs.python.org/3/reference/import.html#regular-packages" rel="nofollow">here</a> to read official documentation about <code>The import system</code></p>
</div>
<span class="comment-copy">This does not answer the question; my question is for a solution solely using a file called <code>foo.py</code>. A less restricted version of the problem requires using `foo.py, but allows that file to import from other files</span>
<span class="comment-copy">Maybe it's worth pointing out, why I wanted to do this: I'm using a given library (actually compiled C++ code) that talks with hardware that I don't always have access to. Therefore, I wanted to mock up some drop-in replacement for working on the code. However, I wanted this to be a single file so I don't pollute my working directory too much. I don't know though if this is anything like what @Alex had in mind...</span>
