<div class="post-text" itemprop="text">
<p>Let's say that I've got a situation like this in Python:</p>
<pre><code>_avg = {'total':0.0, 'count':0}    # HACK: side-effects stored here

def procedure(n):
  _avg['count'] += 1
  _avg['total'] += n
  return n

def get_average():
  return _avg['total'] / _avg['count']

my_dict = {
  'key0': procedure(0),
  'key2': procedure(2),
  'key1': get_average()
}
assert(my_dict['key1'] == 1.0)
</code></pre>
<p>I know that the order of <code>my_dict.keys()</code> is undefined, but what I'm wondering is whether the <em>initialization</em> via a literal like this is guaranteed to happen in a particular order. Will the value of <code>my_dict['key1']</code> always be <code>1.0</code> as asserted?</p>
</div>
<div class="post-text" itemprop="text">
<p>Dictionary evaluation order <strong>should</strong> be the same as written, but there is a <a href="http://bugs.python.org/issue11205" rel="nofollow noreferrer">outstanding bug</a> where <em>values</em> are evaluated before the <em>keys</em>. (The bug was finally fixed in Python 3.5).</p>
<p>Quoting from the <a href="http://docs.python.org/2/reference/expressions.html#evaluation-order" rel="nofollow noreferrer">reference documentation</a>:</p>
<blockquote>
<p>Python evaluates expressions from left to right.</p>
</blockquote>
<p>and from the bug report:</p>
<blockquote>
<p>Running the following code shows <code>"2 1 4 3"</code>, but in reference manual
  <a href="http://docs.python.org/reference/expressions.html#expression-lists" rel="nofollow noreferrer">http://docs.python.org/reference/expressions.html#expression-lists</a> the
  evaluation order described as <code>{expr1: expr2, expr3: expr4}</code></p>
<pre><code>def f(i):
    print i
    return i

{f(1):f(2), f(3):f(4)}
</code></pre>
</blockquote>
<p>and Guido stated:</p>
<blockquote>
<p>I am sticking with my opinion from before: the code should be fixed.  It doesn't look like assignment to me.</p>
</blockquote>
<p>This bug is fixed in Python 3.5, so on Python 3.4 and earlier the values are still evaluated before the keys:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version_info
sys.version_info(major=3, minor=4, micro=2, releaselevel='final', serial=0)
&gt;&gt;&gt; def f(i):
...     print(i)
...     return i
... 
&gt;&gt;&gt; {f(1):f(2), f(3):f(4)}
2
1
4
3
{1: 2, 3: 4}
</code></pre>
<p>Since your code doesn't require the keys to be evaluated first, your code is guaranteed to work correctly; key-value pairs are still evaluated in order even if the keys are evaluated after each corresponding value. </p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/2/reference/expressions.html#evaluation-order" rel="noreferrer">Python docs regarding evaluation order</a>, this should have well-defined behavior:</p>
<blockquote>
<p>In the following lines, expressions will be evaluated in the arithmetic order of their suffixes:</p>
<pre><code>…
{expr1: expr2, expr3: expr4}
…
</code></pre>
</blockquote>
<p>So, regardless of what order the items in a <code>dict</code> end up being <em>iterated</em>, the values (and keys!) of a literal dictionary expression will always be <em>evaluated</em> in the same order as they appear in my Python source code.</p>
</div>
<div class="post-text" itemprop="text">
<p>The current behaviour on Python 3.4.2 can be very clearly seen in the disassembled bytecode: the values are evaluated before keys, not left-to-right.</p>
<pre><code>&gt;&gt;&gt; dis.dis(lambda: {f('1'): f('2'), f('3'): f('4')})
  1           0 BUILD_MAP                2
              3 LOAD_GLOBAL              0 (f)
              6 LOAD_CONST               1 ('2')
              9 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             12 LOAD_GLOBAL              0 (f)
             15 LOAD_CONST               2 ('1')
             18 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             21 STORE_MAP
             22 LOAD_GLOBAL              0 (f)
             25 LOAD_CONST               3 ('4')
             28 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             31 LOAD_GLOBAL              0 (f)
             34 LOAD_CONST               4 ('3')
             37 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             40 STORE_MAP
             41 RETURN_VALUE
</code></pre>
<p>However this also shows the reason why this is also not so straightforward to fix: the values and keys are expected by <a href="https://docs.python.org/3/library/dis.html#opcode-STORE_MAP" rel="nofollow"><code>STORE_MAP</code></a> in this order; changing the order would either require adding a <a href="https://docs.python.org/3/library/dis.html#opcode-ROT_TWO" rel="nofollow"><code>ROT_TWO</code></a> opcode after each pair, or 
<code>STORE_MAP_EX</code> opcode which would expect the pairs to be reversed; the first one would be a performance drop, whereas the second would mean yet another opcode to handle in every piece of code that deals with bytecode.</p>
</div>
<span class="comment-copy">Good call. Although if this really matters to your code, you should probably unit test this, particularly for portability reasons.</span>
<span class="comment-copy">Except for <a href="http://bugs.python.org/issue11205" rel="nofollow noreferrer">bugs.python.org/issue11205</a>, which shows that there is a bug in the Python implementation with that rule.</span>
