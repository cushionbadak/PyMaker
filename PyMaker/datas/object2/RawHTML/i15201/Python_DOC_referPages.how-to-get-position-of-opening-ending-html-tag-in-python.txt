<div class="post-text" itemprop="text">
<p>How to solve this on Python3, using what lib, and using what sample code?</p>
<p>I have html file, at position Line:Col I have middle of html tag 
<code>&lt;table ......&gt;</code>; how to get position of <code>&lt;table&gt;</code> tag edges (brackets <code>&lt; &gt;</code>) and position of its <code>&lt;/table&gt;</code> tag edges?</p>
<p>(note: several table tags may be one inside another).</p>
</div>
<div class="post-text" itemprop="text">
<p>Like said in <a href="https://stackoverflow.com/a/2009351/3673">this SO answer</a>, you should not use regex to parse an HTML file as the standard is highly irregular. You should instead use an HTML parsing library like <code>html.parser</code> : This library offers you <a href="https://docs.python.org/3.4/library/html.parser.html#html.parser.HTMLParser.getpos" rel="nofollow noreferrer"><code>HTMLParser.getpos()</code></a> which returns you the line number and offset of the tag.</p>
</div>
<div class="post-text" itemprop="text">
<p>This gets you the coordinates of each tag with <a href="https://docs.python.org/3/library/html.parser.html" rel="nofollow noreferrer">html.parser</a>, where I monkeypatch the <strong>goahead</strong> function with a simple modification, calling the custom method <strong>get_endpos</strong>:</p>
<pre><code>from html.parser import HTMLParser, starttagopen
from html import unescape

class MyHTMLParser(HTMLParser):

    def __init__(self):
        HTMLParser.__init__(self)

        self.start_tags = []
        self.end_tags = []

        self.last_append = []

    def handle_starttag(self, tag, attrs):
        self.start_tags.append((tag, (self.getpos()[0], self.getpos()[1]),))

        self.last_append = self.start_tags

    def handle_endtag(self, tag):
        self.end_tags.append((tag, (self.getpos()[0], self.getpos()[1]),))

        self.last_append = self.end_tags

    def get_endpos(self):
        self.last_append[-1] = self.last_append[-1] + ((self.getpos()[0], self.getpos()[1]),)

    def get_tags(self):
        return self.start_tags, self.end_tags

    def _reset(self):
        HTMLParser.reset(self)

        self.start_tags = []
        self.end_tags = []

parser = MyHTMLParser()

# Internal -- handle data as far as reasonable.  May leave state
# and data to be processed by a subsequent call.  If 'end' is
# true, force handling all data as if followed by EOF marker.
def goahead(self, end):
    rawdata = self.rawdata
    i = 0
    n = len(rawdata)
    while i &lt; n:
        if self.convert_charrefs and not self.cdata_elem:
            j = rawdata.find('&lt;', i)
            if j &lt; 0:
                # if we can't find the next &lt;, either we are at the end
                # or there's more text incoming.  If the latter is True,
                # we can't pass the text to handle_data in case we have
                # a charref cut in half at end.  Try to determine if
                # this is the case before proceeding by looking for an
                # &amp; near the end and see if it's followed by a space or ;.
                amppos = rawdata.rfind('&amp;', max(i, n-34))
                if (amppos &gt;= 0 and
                    not re.compile(r'[\s;]').search(rawdata, amppos)):
                    break  # wait till we get all the text
                j = n
        else:
            match = self.interesting.search(rawdata, i)  # &lt; or &amp;
            if match:
                j = match.start()
            else:
                if self.cdata_elem:
                    break
                j = n
        if i &lt; j:
            if self.convert_charrefs and not self.cdata_elem:
                self.handle_data(unescape(rawdata[i:j]))
            else:
                self.handle_data(rawdata[i:j])
        i = self.updatepos(i, j)
        if i == n: break
        startswith = rawdata.startswith
        if startswith('&lt;', i):
            if starttagopen.match(rawdata, i): # &lt; + letter
                k = self.parse_starttag(i)
            elif startswith("&lt;/", i):
                k = self.parse_endtag(i)
            elif startswith("&lt;!--", i):
                k = self.parse_comment(i)
            elif startswith("&lt;?", i):
                k = self.parse_pi(i)
            elif startswith("&lt;!", i):
                k = self.parse_html_declaration(i)
            elif (i + 1) &lt; n:
                self.handle_data("&lt;")
                k = i + 1
            else:
                break
            if k &lt; 0:
                if not end:
                    break
                k = rawdata.find('&gt;', i + 1)
                if k &lt; 0:
                    k = rawdata.find('&lt;', i + 1)
                    if k &lt; 0:
                        k = i + 1
                else:
                    k += 1
                if self.convert_charrefs and not self.cdata_elem:
                    self.handle_data(unescape(rawdata[i:k]))
                else:
                    self.handle_data(rawdata[i:k])
            i = self.updatepos(i, k)
            self.get_endpos() # only modification: gets end position of tags
        elif startswith("&amp;#", i):
            match = charref.match(rawdata, i)
            if match:
                name = match.group()[2:-1]
                self.handle_charref(name)
                k = match.end()
                if not startswith(';', k-1):
                    k = k - 1
                i = self.updatepos(i, k)
                continue
            else:
                if ";" in rawdata[i:]:  # bail by consuming &amp;#
                    self.handle_data(rawdata[i:i+2])
                    i = self.updatepos(i, i+2)
                break
        elif startswith('&amp;', i):
            match = entityref.match(rawdata, i)
            if match:
                name = match.group(1)
                self.handle_entityref(name)
                k = match.end()
                if not startswith(';', k-1):
                    k = k - 1
                i = self.updatepos(i, k)
                continue
            match = incomplete.match(rawdata, i)
            if match:
                # match.group() will contain at least 2 chars
                if end and match.group() == rawdata[i:]:
                    k = match.end()
                    if k &lt;= i:
                        k = n
                    i = self.updatepos(i, i + 1)
                # incomplete
                break
            elif (i + 1) &lt; n:
                # not the end of the buffer, and can't be confused
                # with some other construct
                self.handle_data("&amp;")
                i = self.updatepos(i, i + 1)
            else:
                break
        else:
            assert 0, "interesting.search() lied"
    # end while
    if end and i &lt; n and not self.cdata_elem:
        if self.convert_charrefs and not self.cdata_elem:
            self.handle_data(unescape(rawdata[i:n]))
        else:
            self.handle_data(rawdata[i:n])
        i = self.updatepos(i, n)
    self.rawdata = rawdata[i:]

MyHTMLParser.goahead = goahead

parser.feed(your_html_file_as_a_string)
print(parser.get_tags())
</code></pre>
</div>
<span class="comment-copy">This question smells like having the XY problem for me. Why do you want the beginning and the end positions, are you trying to parse the table? If so, there are better methods.</span>
<span class="comment-copy">trying to make Editor plugin which selects tag's inside position. (for any tag, tag under caret)</span>
<span class="comment-copy">Ok, I tip my hat to you, sir. This is a tough problem because inside an editor you may have code that is not valid <code>XML</code>. You may want to clarify your problem so this question will not be tagged as "duplicate" or "too broad".</span>
<span class="comment-copy">I have ok HTML, not XML, in editor (maybe some html tags not correct, in rare case). If html tags correct, how to do it. It's a question.</span>
<span class="comment-copy">Good,but any example how to get tag bounds from X:Y pos?</span>
