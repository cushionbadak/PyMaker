<div class="post-text" itemprop="text">
<p>I have an association <code>list</code> with repeated keys:</p>
<pre><code>l = [(1, 2), (2, 3), (1, 3), (2, 4)]
</code></pre>
<p>and I want a <code>dict</code> with <code>list</code> values:</p>
<pre><code>d = {1: [2, 3], 2: [3, 4]}
</code></pre>
<p>Can I do better than:</p>
<pre><code>for (x,y) in l:
  try:
    z = d[x]
  except KeyError:
    z = d[x] = list()
  z.append(y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault"><code>dict.setdefault()</code> method</a> to provide a default empty list for missing keys:</p>
<pre><code>for x, y in l:
    d.setdefault(x, []).append(y)
</code></pre>
<p>or you could use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict"><code>defaultdict()</code> object</a> to create empty lists for missing keys:</p>
<pre><code>from collections import defaultdict

d = defaultdict(list)
for x, y in l:
    d[x].append(y)
</code></pre>
<p>but to switch off the auto-vivication behaviour you'd have to set the <code>default_factory</code> attribute to <code>None</code>:</p>
<pre><code>d.default_factory = None  # switch off creating new lists
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2.7/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a>:</p>
<pre><code>d = collections.defaultdict(list)
for k, v in l:
    d[k].append(v)
</code></pre>
</div>
<span class="comment-copy">how do you manage to see my questions <i>seconds</i> after it is posted? :-)</span>
<span class="comment-copy">@sds It is called <i>Ninja</i> vision</span>
<span class="comment-copy">@sds: I wrote up my approach in <a href="http://meta.stackoverflow.com/a/254603">How do active answerers find questions to answer?</a></span>
<span class="comment-copy">is there a faster way to do it using comprehensions?</span>
<span class="comment-copy">@srcolinas: no, because a list comprehension can't group based on keys, not without sorting first (at which point you can use <code>itertools.groupby()</code>). Sorting will make it slower (moving from O(N) to O(NlogN)). List comprehensions are not a magic speed bullet, by the way.</span>
