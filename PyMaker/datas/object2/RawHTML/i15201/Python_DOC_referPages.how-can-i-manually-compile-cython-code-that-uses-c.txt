<div class="post-text" itemprop="text">
<p>I have exactly copied the example code given in the <a href="http://docs.cython.org/src/userguide/wrapping_CPlusPlus.html">Cython documentation for wrapping C++ classes</a>. I can successfully build and import the <code>rect.so</code> extension using <code>distutils</code> and the <code>cythonize()</code> method, i.e. by:</p>
<ol>
<li><p>Putting the following directives at the top of <code>rect.pyx</code>:</p>
<pre><code># distutils: language = c++
# distutils: sources = Rectangle.cpp
</code></pre></li>
<li><p>Writing a <code>setup.py</code> file that contains this:</p>
<pre><code>from distutils.core import setup
from Cython.Build import cythonize

setup(
    name = "rectangleapp",
    ext_modules = cythonize('*.pyx'),
)
</code></pre></li>
<li><p>Calling</p>
<pre><code>$ python setup.py build_ext --inplace
</code></pre></li>
</ol>
<p>However, when I'm wrapping C code in Cython I often find it more convenient to compile individual extensions manually from the command line, i.e.:</p>
<ol>
<li><p>Generate the <code>.c</code> code using the command line Cython compiler</p>
<pre><code>$ cython foo.pyx
</code></pre></li>
<li><p>Manually compile it using <code>gcc</code>:</p>
<pre><code>$ gcc -shared -fPIC -O3 -I /usr/lib/python2.7 -L /usr/lib/python2.7 \
       foo.c -lpython2.7 -o foo.so
</code></pre></li>
</ol>
<p>I've tried applying the same process to build the <code>rect.so</code> example above:</p>
<pre><code>$ cython --cplus rect.pyx
$ g++ -shared -fPIC -O3 -I /usr/lib/python2.7 -L /usr/lib/python2.7 \
      rect.cpp -lpython2.7 -o rect.so
</code></pre>
<p>Both the Cython and g++ compilation steps seem to succeed - I don't get any command line output, and at the end I have a <code>rect.so</code>  built. However, when I then try to import the module I get an <code>undefined symbol</code> error:</p>
<pre><code>In [1]: import rect
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
&lt;ipython-input-1-ba16f97c2145&gt; in &lt;module&gt;()
----&gt; 1 import rect

ImportError: ./rect.so: undefined symbol: _ZN6shapes9Rectangle9getLengthEv
</code></pre>
<p>What's the correct procedure for manually compiling Cython code that wraps C++ classes?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that you said that somewhere you will provide the definition of a class called Rectangle -- where the example code states </p>
<pre><code>cdef extern from "Rectangle.h" namespace "shapes":
    cdef cppclass Rectangle:
        ...
</code></pre>
<p>However, when you compiled the library you didn't provide the code for Rectangle, or a library that contained it, so <code>rect.so</code> has no idea where to find this Rectangle class.</p>
<p>To run your code you must first create the Rectangle object file.</p>
<pre><code>gcc -c Rectangle.cpp # creates a file called Rectangle.o
</code></pre>
<p>Now you can either create a library to dynamically link against, or statically link the object file into <code>rect.so</code>. I'll cover statically linking first as it's simplest.</p>
<pre><code>gcc -shared -fPIC -I /usr/include/python2.7 rect.cpp Rectangle.o -o rect.so
</code></pre>
<p>Note that I haven't included the library for python. This is because you expect your library to be loaded by the python interpreter, thus the python libraries will already be loaded by the process when your library is loaded. In addition to providing <code>rect.cpp</code> as a source I also provide <code>Rectangle.o</code>. So lets try running a program using your module.</p>
<p><strong>run.py</strong></p>
<pre><code>import rect
print(rect.PyRectangle(0, 0, 1, 2).getLength())
</code></pre>
<p>Unfortunately, this produces another error:</p>
<pre><code>ImportError: /home/user/rectangle/rect.so undefined symbol: _ZTINSt8ios_base7failureE
</code></pre>
<p>This is because cython needs the c++ standard library, but python hasn't loaded it. You can fix this by adding the c++ standard library to the required libraries for <code>rect.so</code></p>
<pre><code>gcc -shared -fPIC -I/usr/include/python2.7 rect.cpp Rectangle.o -lstdc++ \
     -o rect.so
</code></pre>
<p>Run <code>run.py</code> again and all should work. However, the code for <code>rect.so</code> is larger than it needs to be, especially if you produce multiple libraries that depend on the same code. You can dynamically link the Rectangle code, by making it a library as well.</p>
<pre><code>gcc -shared -fPIC Rectangle.o -o libRectangle.so
gcc -shared -fPIC -I/usr/include/python2.7 -L. rect.cpp -lRectangle -lstdc++ \
     -o rect.so
</code></pre>
<p>We compile the Rectangle code into a shared library in the current directory and provide <code>-L.</code> so gcc knows to look for libraries in the current directory and <code>-lRectangle</code> so gcc knows to look for the Rectangle library. Finally, to be able to run your code you must tell python where the Rectangle library lives. Before running python enter</p>
<pre><code>export LD_LIBRARY_PATH="/home/user/rectangle" # where libRectangle.so lives
</code></pre>
<p>You can use a shell script to make sure this is done every time before you run your program, but it makes things messier. Best to just stick with statically linking Rectangle. </p>
</div>
<span class="comment-copy">I'm trying to reproduce the steps on windows, but I can't get it to work. Here are my steps: 1. cython --cplus rect.pyx -&gt; rect.cpp 2. gcc -c Rectangle.cpp -&gt; Rectangle.o 3. gcc -shared -fPIC -IC:\Users\python37\include rect.cpp Rectangle.o -lstdc++ -o -rect.so</span>
<span class="comment-copy">But step 3 fails with a lot of messages of the type "undefined reference to" such as "undefined reference to `__imp_PyDict_Size'". Any idea?</span>
<span class="comment-copy">I believe Windows DLLs and Unix so files are created differently. As such you should add the flags <code>-L C:\Users\python37\libs -l python3</code> See <a href="https://docs.python.org/3/extending/windows.html#differences-between-unix-and-windows" rel="nofollow noreferrer">docs.python.org/3/extending/â€¦</a> Don't quote me on this, I rarely work with C/C++ on Windows.</span>
<span class="comment-copy">I got it to compile without errors by adding your suggestion with <code>gcc -shared -fPIC -IC:\Users\python37\include -LC:\Users\python37\libs  rect.cpp Rectangle.o -lstdc++ -o rect.pyd -lpython37</code> but now I get <code>ImportError: DLL load failed: The specified procedure could not be found.</code> when I do <code>import rect</code> in my python. Any idea?</span>
<span class="comment-copy">Not sure why, if I deactivate my python env before compiling then everything works, but if I stay in my python env then I get the error message <code>ImportError: DLL load failed: The specified procedure could not be found.</code> when importing. At least the command above works.</span>
