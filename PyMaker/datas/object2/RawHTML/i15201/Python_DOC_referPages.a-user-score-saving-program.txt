<div class="post-text" itemprop="text">
<p>I am trying to make a program where the it will ask the user's name and then a series of questions. With a point added for every time the question is correct. I am trying to make it store the score along with the user's name onto a text file so it will look like so on the text file:</p>
<pre><code>Name    Score 
</code></pre>
<p>so let's use John as an example, if he were to score 4 points, in the text file it would write:</p>
<pre><code>John    4
</code></pre>
<p>But I want it so that if John were to take the test again instead of having John twice:</p>
<pre><code>John    4
John    6
</code></pre>
<p>I want it to read:</p>
<pre><code>John    4   6
</code></pre>
<p>Instead of rewriting the name and score, it would write tab and then the score onto the same line as the one with the name John in.</p>
<p>Here is my code so far:</p>
<pre><code>import random
name = input("Hello user, what is your name?")
count = (0)
score = (0)
while count != (8):
    count = count + (1)
    symbols = ['+', '-', '*']
    valueF = random.randint(1,10)
    valueS = random.randint(1,10)
    chosensymb = random.choice (symbols)
    question = input("What is %d %s %d ? :"%(valueF, chosensymb, valueS))
    answer = eval(str(valueF) + chosensymb + str(valueS))
    if question == str(answer):            
        score = score + (1)
        print ("Correct")
    else:
        print ("Incorrect")

print("%s, you have scored %d points"%(name,score))
filewrite = open("ScoreSheet.txt","a")
filewrite.write("\n%s\t%d"%(name,score))
filewrite.close()
</code></pre>
<p>I have no idea how to do this, I am new to python so sorry if I made any mistakes, thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, for a start, you could store everybody's scores in a dictionary.
Let's introduce a <code>scores</code> object:</p>
<pre><code>scores = {}
</code></pre>
<p>It will have the names as the keys and the scores as the values. Like that:</p>
<pre><code>scores = {'John': 2,
          'Mary': 5}
</code></pre>
<p>If you introduce a new player, we'll create a new element inside the said dictionary, let's call it <code>'John'</code>, with a score <code>0</code>:</p>
<pre><code>scores['John'] = 0
</code></pre>
<p>Then if the player guesses correctly, we increment the player's score:</p>
<pre><code>scores['John'] += 1
</code></pre>
<p>(You can use the <code>+=</code> operator if you'd like to just add something to the object. It's a shorter way of saying <code>scores['John'] = scores['John'] + 1</code>.</p>
<p>Then the magic kicks in!<br/>
There's a builtin module in Python called <code>pickle</code>, which can store the objects (like the dictionary we've made - <code>scores</code>) in files and then just pop them out of files and they're being restored!</p>
<p>There's <a href="https://wiki.python.org/moin/UsingPickle" rel="nofollow">a quick manual</a> on how to work with <code>pickle</code>. In short, you save the scores into the file like that:</p>
<pre><code>import pickle
pickle.dump(scores, open("scores.p", "wb"))
</code></pre>
<p>and then load it like that:</p>
<pre><code>scores = pickle.load(open("scores.p", "rb"))
</code></pre>
<p>It's not really the greatest way to store stuff - there are more things like <a href="https://docs.python.org/2/library/json.html" rel="nofollow">json</a>, <a href="https://docs.python.org/2/library/csv.html" rel="nofollow">csv</a>, <a href="https://docs.python.org/2/library/sqlite3.html" rel="nofollow">sqlite</a> and even manual read/writing, but you'll be OK for now :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Just <a href="http://en.wikipedia.org/wiki/Serialization" rel="nofollow">serialize</a> your data using <a href="https://docs.python.org/3/library/pickle.html#pickle-python-object-serialization" rel="nofollow"><code>pickle</code></a> or <a href="https://docs.python.org/2/library/json.html#module-json" rel="nofollow"><code>json</code></a>. Here is an example using <code>json</code> to serialize the scores (storing scores in a <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow"><code>dict</code></a> - a mapping between a name and a score):</p>
<pre><code># import the serializing library
import json as serializer
</code></pre>
<p>Now we'll make a function to write a score to a given file:</p>
<pre><code>def write_score(score_file_name, name, score):
    scores = read_scores(score_file_name)
    # add score
    scores[name] = score
    with open(score_file_name, 'w') as f:
        serializer.dump(scores, f)
</code></pre>
<p>What it does is:</p>
<ol>
<li>Load the serialized results object from the score file (<code>dict</code>)</li>
<li>update the score <code>dict</code> (add key / update value of key)</li>
<li>write the updated <code>dict</code> to the file (using <a href="https://docs.python.org/2/library/json.html#json.dump" rel="nofollow"><code>json.dump</code></a>)</li>
</ol>
<p>When writing the <code>write_score</code> function, we were missing a <code>read_scores</code> function, that enables us to see what the current scores are. So let's write this <code>read_scores</code>:</p>
<pre><code>def read_scores(score_file_name):
    try:
        with open(score_file_name, 'r') as f:
            scores = serializer.load(f)
        return scores
    except IOError:
        # if file does not exist - we have no scores
        return {}
</code></pre>
<p>What <code>read_scores</code> does is:</p>
<ol>
<li>Read the serialized <code>dict</code> (using <a href="https://docs.python.org/2/library/json.html#json.load" rel="nofollow"><code>json.load</code></a>)</li>
</ol>
<p>Now we can test if it actually works. Here is a small example:</p>
<pre><code># set the score file name
SCORES_FILE_NAME = 'scores.txt'

write_score(SCORES_FILE_NAME, 'john', 10)    
print(read_scores(SCORES_FILE_NAME))

write_score(SCORES_FILE_NAME, 'jim', 11)    
print(read_scores(SCORES_FILE_NAME))

# overwrite john's score
write_score(SCORES_FILE_NAME, 'john', 12)
print(read_scores(SCORES_FILE_NAME))
</code></pre>
<p><strong>Tip 1:</strong> You may want to use <a href="https://docs.python.org/2/library/stdtypes.html#str.lower" rel="nofollow"><code>name.lower()</code></a> when writing a score so that <code>john</code> and <code>John</code> are considered the same user.</p>
<p><strong>Tip 2:</strong> Because we referenced the <code>json</code> library as <code>serializer</code>, and it has the same API as <code>pickle</code>, you can choose between the two simply by replacing <code>import json as serializer</code> to <code>import pickle as serializer</code>. <strong>Just make sure you delete the scores file since they don't serialize data the same way</strong>.</p>
<p><strong>The whole code together:</strong></p>
<pre><code># import the serializing library
import json as serializer

def write_score(score_file_name, name, score):
    scores = read_scores(score_file_name)
    # add score
    scores[name] = score
    with open(score_file_name, 'w') as f:
        serializer.dump(scores, f)


def read_scores(score_file_name):
    try:
        with open(score_file_name, 'r') as f:
            scores = serializer.load(f)
        return scores
    except IOError:
        # if file does not exist - we have no scores
        return {}

# TESTS

# set the score file name
SCORES_FILE_NAME = 'scores.txt'

write_score(SCORES_FILE_NAME, 'john', 10)
print(read_scores(SCORES_FILE_NAME))

write_score(SCORES_FILE_NAME, 'jim', 11)
print(read_scores(SCORES_FILE_NAME))

# overwrite john's score
write_score(SCORES_FILE_NAME, 'john', 12)
print(read_scores(SCORES_FILE_NAME))
</code></pre>
<p>Output:</p>
<pre><code>{u'john': 10}
{u'john': 10, u'jim': 11}
{u'jim': 11, u'john': 12}
</code></pre>
<p>To read a specific score you can use the existing method <code>read_scores</code>:</p>
<pre><code>def read_score(score_file_name, name):
    return read_scores(score_file_name)[name]
</code></pre>
<h2><strong>Bonus - <a href="http://en.wikipedia.org/wiki/Closure_%28computer_programming%29" rel="nofollow">Closures</a>:</strong></h2>
<p>You can make the functions specific to a file if you understand closures, the following way:</p>
<pre><code>def write_score(score_file_name):
    # create closure specific to 'score_file_name'
    def write_score_specific(name, score):
        scores = read_scores(score_file_name)
        # we're going to make a 'read_scores' with closures as well!
        # so use that one...
        scores_reader = read_scores(score_file_name)
        scores = scores_reader()


        # add score
        scores[name] = score
        with open(score_file_name, 'w') as f:
            serializer.dump(scores, f)

    # return file-specific function
    return write_score_specific
</code></pre>
<p>Now, we only have to call the function with the file name argument <strong>once</strong>, and from that moment we can use the result ot write scores:</p>
<pre><code># create specific 'write_score' for our file
score_txt_writer = write_score('scores.txt')

# update john's score to 10 without specifying the file
score_txt_writer('john', 10)
</code></pre>
<p>The same done with <code>read_score</code>:</p>
<pre><code>def read_scores(score_file_name):
    # create closure function
    def read_scores_specific():
        try:
            with open(score_file_name, 'r') as f:
                scores = serializer.load(f)
            return scores
        except IOError:
            # if file does not exist - we have no scores
            return {}
    return read_scores_specific
</code></pre>
<p><strong>The whole code with closures together:</strong></p>
<pre><code># import the library
import serializer

# CLOSURES

SCORES_FILE = 'scores.txt'
def read_scores(score_file_name):
    # create closure function
    def read_scores_specific():
        try:
            with open(score_file_name, 'r') as f:
                scores = serializer.load(f)
            return scores
        except IOError:
            # if file does not exist - we have no scores
            return {}
    return read_scores_specific

def write_score(score_file_name):
    # create closure specific to 'score_file_name'
    def write_score_specific(name, score):
        scores_reader = read_scores(score_file_name)
        scores = scores_reader()
        # add score
        scores[name] = score
        with open(score_file_name, 'w') as f:
            serializer.dump(scores, f)

    # return file-specific function
    return write_score_specific

# create specific 'write_score' for our file
score_txt_writer = write_score(SCORES_FILE)

# update john's score to 10 without specifying the file
score_txt_writer('john', 10)


score_txt_reader = read_scores(SCORES_FILE)

print score_txt_reader()
</code></pre>
<p>Output:</p>
<pre><code>{u'john': 10}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's not how file access works: In a file, you can't just "insert" new values somewhere, shifting the rest of the file backwards; you can only overwrite characters or rewrite the whole file.</p>
<p>Generally, as long as your file is rather short, you won't notice any performance effect if rewriting the whole file.</p>
</div>
<span class="comment-copy">just a comment: why do you put integers in parentheses? That's not necessary.</span>
<span class="comment-copy">How about using a light database like <code>SQLite</code> instead of a text file. You can manage things more easily.</span>
<span class="comment-copy">I don't know really, I guess I just felt it looked somewhat neater. And is there a way to do it on text file? I will see into SQLite thanks.</span>
<span class="comment-copy">SQLite may be an overkill. Just serialize a python object (probably a <code>dict</code>) using <code>pickle</code> or <code>json</code>.</span>
<span class="comment-copy">Alright i'll try thanks for help</span>
<span class="comment-copy">That's the beautiful thing about python: trying is so easy. Accepting this answer might help others in the future (you don't have to, though).</span>
<span class="comment-copy">You actually <i>can</i> rewrite parts of the file.</span>
<span class="comment-copy">@user3467349: exactly! <i>rewrite</i> means replacing parts of a file with the same amount of bytes; so you can <i>replace</i> things, you can truncate your file, but you can't magically insert a byte between existing files.</span>
