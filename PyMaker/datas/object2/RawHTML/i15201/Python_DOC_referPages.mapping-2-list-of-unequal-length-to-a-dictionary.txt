<div class="post-text" itemprop="text">
<p>I am trying to create a dictionary of colors where an integer maps to a color.
In my first list l1, it has 177 items but only 5 unique integers (0 to 4).
In the second list, it has 5 html colors.
I am trying to create a dictionary where each color will map to a unique integer.</p>
<pre><code> l1=[3 2 3 3 0 2 4 4 2 3 2 2 4 0 3 2 2 2 1 3 2 3 2 2 2 0 3 1 0 2 2 2 4 2 4 2 0
     2 0 4 0 4 2 0 2 2 2 4 1 3 2 2 2 1 0 3 3 2 0 2 3 4 1 0 0 1 3 1 3 1 4 3 4 1
     4 0 2 3 2 0 4 1 3 0 0 4 0 4 0 2 2 1 2 2 1 0 4 4 3 1 3 2 2 2 4 4 2 0 3 4 4
     0 3 4 3 4 2 2 2 3 3 1 0 2 3 1 1 4 0 1 2 0 0 2 0 0 0 0 2 3 1 0 3 3 3 2 2 3
     3 0 0 0 2 0 3 2 0 0 0 2 2 0 4 3 3 0 2 2 3 2 3 3 0 2 0 4 3]

 l2=['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF']
</code></pre>
<p>Here is my code:</p>
<pre><code>    color_map=dict(zip(l1,l2))
    print color_map
</code></pre>
<p>However, I get an incocomplete dictionary:</p>
<pre><code>{0: '#0000FF', 2: '#FFFFFF', 3: '#00FF00'}
</code></pre>
<p>How do i fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need a set so you get all unique numbers from <code>l</code>:</p>
<pre><code>print(dict(zip(set(l)),l2))
{0: '#000000', 1: '#FFFFFF', 2: '#FF0000', 3: '#00FF00', 4: '#0000FF'}
</code></pre>
<p>If you always want the numbers sorted:</p>
<pre><code> print(dict(zip(sorted(set(l)),l2)))
</code></pre>
<p>You will always need to have only 5 unique values in <code>l</code> if you only have five values in <code>l2</code> or again you will lose data. </p>
</div>
<div class="post-text" itemprop="text">
<p>If the unique integers are consecutive, you can use <code>enumerate()</code>:</p>
<pre><code>&gt;&gt;&gt; dict(enumerate(l2))
{0: '#000000', 1: '#FFFFFF', 2: '#FF0000', 3: '#00FF00', 4: '#0000FF'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may try to use <code>set()</code> to get all the unique integer of l1:</p>
<pre><code>l1_list=list(set([3,2,3,3,0,2,4,4,2,3,2,2,4,0,3,2,2,2,1,3,2,3,2,2,2,0,3,1,0,2,2,2,4,2,4,2,0,2,0,4,0,4,2,0,2,2,2,4,1,3,2,2,2,1,0,3,3,2,0,2,3,4,1,0,0,1,3,1,3,1,4,3,4,1,4,0,2,3,2,0,4,1,3,0,0,4,0,4,0,2,2,1,2,2,1,0,4,4,3,1,3,2,2,2,4,4,2,0,3,4,4,0,3,4,3,4,2,2,2,3,3,1,0,2,3,1,1,4,0,1,2,0,0,2,0,0,0,0,2,3,1,0,3,3,3,2,2,3,3,0,0,0,2,0,3,2,0,0,0,2,2,0,4,3,3,0,2,2,3,2,3,3,0,2,0,4,3]))
l2=['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF']

color_map=dict(zip(l1_list,l2))
print color_map
</code></pre>
<p>Output:</p>
<pre><code>{0: '#000000', 1: '#FFFFFF', 2: '#FF0000', 3: '#00FF00', 4: '#0000FF'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on the code you've presented, I would suggest considering an <a href="https://stackoverflow.com/a/1695250/2437514"><code>enum.Enum</code> or <code>enum.IntEnum</code> object</a> instead of a dictionary (<a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">docs</a>). It's hard to say for sure, but <code>IntEnum</code> may work better for you here. </p>
<p>You can create your <code>IntEnum</code> this way:</p>
<pre><code>l2=['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF']
from enum import IntEnum
Color = IntEnum('Color', ' '.join(l2))
</code></pre>
<p>Now all of your colors have been automatically mapped to an integer value (beginning with 1; the reason for starting with 1 instead of zero is so that all members of an <code>Enum</code> evaluate to <code>True</code>). </p>
<p>You can iterate over <code>Color</code> and access member names and member values, similar to how you would with a dictionary: </p>
<pre><code>for color in Color:
    print(color.name, color.value)
</code></pre>
<p>Notice that when you access the member by key like in a dictionary, the <code>IntEnum</code> member object itself is returned, <em>not</em> the integer it's mapped to: </p>
<pre><code>print(Color['#000000'])
</code></pre>
<p>...however, this probably won't matter to you, because since it's an <code>IntEnum</code> the member objects act like integers, including for the purposes of comparison, etc:</p>
<pre><code>for color in Color:
    if color == 1:
        print(color.name, ' is 1!')

print(Color['#000000'] == 1) # will print either True or False 
c = Color(1)
print(c) # will print the Color member c, which is mapped to 1 
</code></pre>
<p>The above is the key reason I am thinking this may be a better alternative. Your <code>l1</code> list is full of integers that represent colors. The ideal thing would be to fill it with <code>Color</code> members instead of integers: </p>
<pre><code>for index, number in enumerate(l1):
    l1[index] = Color(number)
</code></pre>
<p>However, if you can't/don't want to do that, you can still compare the integers to the <code>Color</code> members (I assume you don't have any interest in "adding", "multiplying", etc, colors together). </p>
<p>So, you could maybe do things like this: </p>
<pre><code>print(any(number == Color['#000000'] for number in l1))
</code></pre>
<p>The <code>Color</code> enum also comes with a built-in dictionary object (<code>Color.__members__</code>) that will return a dictionary with the member names as the keys and the member itself as the value. </p>
</div>
<div class="post-text" itemprop="text">
<p>@Simeon Visser's answer is the most concise one for the specific example you provided (using integers from 0 to 4). But, if what you wanted is to have a sequence of #s like <code>{0: '#0000FF', 2: '#FFFFFF', 3: '#00FF00'}</code> where all the items show up from the original list (even repeated), this won't work.</p>
<p>It seems your intention, however, was to actually grab the colors for all the corresponding items of the list. If that's the case, what you <em>can</em> do is use Simeon's answer and combine it with your original list like in the following way:</p>
<pre><code>colorDict = dict(enumerate(l2))
colors = [colorDict[colorIndex] for colorIndex in l1]
</code></pre>
<p>This will map all the colors to a new list based on the integer sequence from <code>l1</code>. Hope that helps.</p>
</div>
<span class="comment-copy">in order to use <code>zip</code> and get a perfect match, you need two lists/sets of the same length.</span>
<span class="comment-copy">this will always get <code>0,1,2,3,4</code> not necessarily the five unique values from l</span>
<span class="comment-copy">@PadraicCunningham: yes, but potentially the values in the first list are always such numbers and then this is the easiest solution. If not, use one of the other solutions.</span>
<span class="comment-copy">yes but  <code>5,6,7,8,9 </code> are also consecutive numbers.</span>
<span class="comment-copy">Well yeah, consecutive and starting at <code>0</code> - that's what I meant based on what we happen to see in the given <code>l1</code> list.</span>
