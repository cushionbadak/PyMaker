<div class="post-text" itemprop="text">
<p>I have a list that I need to convert to floats. As the data is not inputted by me, there are elements that have an accidental extra period, for example <code>39.04.1450</code>. I need to be able to <strong>automatically</strong> remove all of the periods except for the first one that appears so that I don't get an error when I say <code>list=float(list)</code>.</p>
<p>Sample list:</p>
<pre><code>latitude= [' -86.57', ' 39.04.1450', ' 37.819' ,' 45.82', ' 54.42', ' 0.' ,' 53.330444',
  ' +45.75' ,' 52.36', ' 43.2167', ' -36.75', ' 6.8N' ,' 40.833' ,' -97.981',
  ' 41.720', ' 41.720', ' 37.41' ,' 37.41' ,' 37.41', ' 37.41']
</code></pre>
<p>As you can see, <code>latitude[1]</code> has an extra decimal point. Of course, I will also need to strip the N in <code>6.8N</code> but that is a separate problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do it like this:</p>
<pre><code>def fix_float(s):
    return s.replace('.', '[DOT]', 1).replace('.', '').replace('[DOT]', '.')
</code></pre>
<p>The function replaces the first occurrence of <code>'.'</code> with <code>'[DOT]'</code>. Then, it removes all the ocurrences of <code>'.'</code>. Finally, it replaces <code>'[DOT]'</code> back to <code>'.'</code>.</p>
<p>To apply it to all the elements of your list, write:</p>
<pre><code>fixed_latitudes = [fix_float(s) for s in latitude]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def my_float(s):
    s=s.split(".")
    return float(".".join([s[0],"".join(s[1:]))])
</code></pre>
<p>will split on . and rejoin only adding the first period ... it does not however do anything about <code>-6.8N</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/re.html" rel="nofollow">regular expressions</a>: </p>
<pre><code>import re  

pattern = re.compile(r'(\d+\.\d+)\.')
new_lst = [re.sub(pattern, r'\1', i).replace('N', '') for i in latitude]
</code></pre>
<p><code>\d</code> means any digit, <code>+</code> means one or more, <code>\.</code> matches the dot character. The parenthesis is capturing that part of the match, and later on in the <code>sub()</code> is used as <code>\1</code> (meaning first capturing group). </p>
</div>
<div class="post-text" itemprop="text">
<p>A small hack if your corrupted data contains only <code>N</code> at the end and more than one <code>.</code> ... Else you've gotta add more except clauses</p>
<pre><code>latitude = [' -86.57', ' 39.04.1450', ' 37.819', ' 45.82', ' 54.42', ' 0.', ' 53.330444', ' +45.75', ' 52.36', ' 43.2167', ' -36.75', ' 6.8N', ' 40.833', ' -97.981', ' 41.720', ' 41.720', ' 37.41', ' 37.41', ' 37.41', ' 37.41']
flist = []
for i in latitude:
    try:
        flist.append(float(i))
    except ValueError:
        if (i[-1] == 'N'):
            flist.append(float(i[:-1]))
        else:
            flist.append(float("{}.{}".format(i.split(".")[0],''.join(i.split(".")[1:]))))

print (flist)
</code></pre>
<p>Output</p>
<pre><code>[-86.57, 39.04145, 37.819, 45.82, 54.42, 0.0, 53.330444, 45.75, 52.36, 43.2167, -36.75, 6.8, 40.833, -97.981, 41.72, 41.72, 37.41, 37.41, 37.41, 37.41]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use regular expression to extract the numbers out of the list and convert them to floats right away.</p>
<pre><code>import re
lat = lambda l: float(re.search('[+-]*\d*\.\d*',l).group(0))
print map(lat,latitude)
</code></pre>
<p>edit:<br/>
Sorry, I haven't noticed, the digits following second decimal point are also valid. 
A new solution still expects the first dot is OK and all the rest are to be removed.</p>
<p>One of the values contain N, so I suppose there might be also S which means it's southern, i.e. negative latitude. Therefore I implemented this assumption into code.</p>
<p><code>def valid_lat(s):
    a = re.findall('\s*[+-]*\d*\.\d*',s)[0]
    b = s.lstrip(a)
    d = b.replace('.','')
    c = re.sub('[nNsS]$','',d)
    sign = 1.
    if re.match('[sS]$',d):sign = -1.
    return (float(a + c))*sign</code></p>
<p>Then just <code>map</code> it:<br/>
<code>map(valid_lat,latitude)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can remove any letters using <code>str.rstrip</code>:</p>
<pre><code>from string import ascii_letters

out = []
for x in latitude:
    x = x.rstrip(ascii_letters)
    spl = x.split(".")
    if len(spl) &gt; 2:
        out.append(float("{}.{}".format(spl[0],"".join(spl[1:]))))
    else:
        out.append(float(x)))
print(out)

[-86.57, 39041450.0, 37.819, 45.82, 54.42, 0.0, 53.330444, 45.75, 52.36, 43.2167, -36.75, 6.8, 40.833, -97.981, 41.72, 41.72, 37.41, 37.41, 37.41, 37.41]
</code></pre>
<p>You can do it in a single list comp but less efficiently:</p>
<pre><code>print([float(x[::-1].rstrip(ascii_letters).replace(".","")[::-1]) if x.count(".") &gt; 1 else float(x.rstrip(ascii_letters)) for x in latitude ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about this one?</p>
<pre><code>def lol_float(_str):
    # check where decimal point is (starting from right) '3.45' -&gt; 2
    dpi = (len(_str) - _str.count('.') - _str.index('.')) if '.' in _str else 0
    # '3.45' -&gt; 345.0
    float_as_int = float(filter(lambda x: x.isdigit(), _str))
    # dpi = 2, float_as_int = 34.0 -&gt; 3.45
    return float_as_int / (10 ** dpi)
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; lol_float('3.34')
3.34
&gt;&gt;&gt; lol_float('3.45')
3.45
&gt;&gt;&gt; lol_float('345')
345.0
&gt;&gt;&gt; lol_float('34.5')
34.5
&gt;&gt;&gt; lol_float('3.4.5')
3.45
&gt;&gt;&gt; lol_float('3.45')
3.45
&gt;&gt;&gt; lol_float('345')
345.0
&gt;&gt;&gt; lol_float('3.4..5')
3.45
&gt;&gt;&gt; lol_float('3.4..5.4')
3.454
</code></pre>
<p>Just being original... :)</p>
</div>
<span class="comment-copy">What about the leading spaces?</span>
<span class="comment-copy">what about <code>' 6.8N'</code></span>
<span class="comment-copy">@JoranBeasley, they don't ignore <code>N's</code> though ;)</span>
<span class="comment-copy">@Solr, no matter what you do <code>float(list)</code> is not going to work</span>
<span class="comment-copy">This kind of automatic error correction seems problematic. When the user types "1.2.3", how do you know whether they meant "1.23" or "12.3"? I recognize that "39.04.1450" can't be 3904.1450, because latitude doesn't go that high, but other ambiguous inputs might exist.</span>
<span class="comment-copy">interesting solution ... probably not great from a performance standpoint but it would certainly do the job</span>
<span class="comment-copy">That works if there is 1 extra period, but not multiple. <code>'39.04.1450.77.77'</code> becomes <code>'39.041450.7777'</code>.</span>
<span class="comment-copy">@tdelaney Now it removes up to two extra dots. I doubt he needs more than that since he didnt mention it, and since latitude has degrees, minutes and seconds (2 dots max in between).</span>
<span class="comment-copy">The latest still isn't handling <code>'39.04.1450'</code>. I think this problem is hard to solve w/ a single pass regular exception and I favor @JoranBeasley's solution. But you bring up a great point - simply removing dots in a degrees.minutes.seconds format doesn't give you the number you want. And suppose its UTM?!</span>
<span class="comment-copy">@tdelaney True, only handles 1 extra dot. But given its latitude i wont try to include other dots, after all. You are correct about his possible problem with conversion from minutes-seconds to degrees.</span>
<span class="comment-copy">Why press â†² so many times?</span>
