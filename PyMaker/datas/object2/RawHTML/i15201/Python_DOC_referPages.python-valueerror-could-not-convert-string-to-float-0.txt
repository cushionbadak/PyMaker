<div class="post-text" itemprop="text">
<p>For some school assignments I've been trying to get pyplot to plot some scientific graphs based on data from Logger Pro for me. I'm met with the error</p>
<pre><code>ValueError: could not convert string to float: '0'
</code></pre>
<p>This is the program:</p>
<pre><code>plot.py
-------------------------------
import matplotlib.pyplot as plt 
import numpy as np

infile = open('text', 'r')

xs = []
ys = []

for line in infile:
    print (type(line))
    x, y = line.split()
    # print (x, y)
    # print (type(line), type(x), type(y))

    xs.append(float(x))
    ys.append(float(y))

xs.sort()
ys.sort()

plt.plot(xs, ys, 'bo')
plt.grid(True)

# print (xs, ys)

plt.show()

infile.close()
</code></pre>
<p>And the input file is containing this:</p>
<pre><code>text
-------------------------------
0 1.33
1 1.37
2 1.43
3 1.51
4 1.59
5 1.67
6 1.77
7 1.86
8 1.98
9 2.1
</code></pre>
<p>This is the error message I recieve when I'm running the program:</p>
<pre><code>Traceback (most recent call last):
  File "\route\to\the\file\plot01.py", line 36, in &lt;module&gt;
    xs.append(float(x))
ValueError: could not convert string to float: '0'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have a UTF-8 BOM in your data file; this is what my Python 2 interactive session states is being converted to a float:</p>
<pre><code>&gt;&gt;&gt; '0'
'\xef\xbb\xbf0'
</code></pre>
<p>The <code>\xef\xbb\xbf</code> bytes is a UTF-8 encoded <a href="http://codepoints.net/U+FEFF" rel="nofollow">U+FEFF ZERO WIDTH NO-BREAK SPACE</a>, commonly used as a byte-order mark, especially by Microsoft products. UTF-8 has no byte order issues, the mark isn't required to record the byte ordering like you have to for UTF-16 or UTF-32; instead Microsoft uses it as an aid to detect encodings.</p>
<p>On Python 3, you could open the file using the <code>utf-8-sig</code> codec; this codec expects the BOM at the start and will remove it:</p>
<pre><code>infile = open('text', 'r', encoding='utf-8-sig')
</code></pre>
<p>On Python 2, you could use the <a href="https://docs.python.org/2/library/codecs.html#codecs.BOM_UTF8" rel="nofollow"><code>codecs.BOM_UTF8</code> constant</a> to detect and strip;</p>
<pre><code>for line in infile:
    if line.startswith(codecs.BOM_UTF8):
        line = line[len(codecs.BOM_UTF8):]
    x, y = line.split()
</code></pre>
<p>As the <a href="https://docs.python.org/3/library/codecs.html#encodings-and-unicode" rel="nofollow"><code>codecs</code> documentation explains it</a>:</p>
<blockquote>
<p>As UTF-8 is an 8-bit encoding no BOM is required and any <code>U+FEFF</code> character in the decoded string (even if it’s the first character) is treated as a <code>ZERO WIDTH NO-BREAK SPACE</code>.</p>
<p>Without external information it’s impossible to reliably determine which encoding was used for encoding a string. Each charmap encoding can decode any random byte sequence. However that’s not possible with UTF-8, as UTF-8 byte sequences have a structure that doesn’t allow arbitrary byte sequences. To increase the reliability with which a UTF-8 encoding can be detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls <code>"utf-8-sig"</code>) for its Notepad program: Before any of the Unicode characters is written to the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code>) is written. As it’s rather improbable that any charmap encoded file starts with these byte values (which would e.g. map to</p>
<pre><code>LATIN SMALL LETTER I WITH DIAERESIS
RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
INVERTED QUESTION MARK
</code></pre>
<p>in iso-8859-1), this increases the probability that a <code>utf-8-sig</code> encoding can be correctly guessed from the byte sequence. So here the BOM is not used to be able to determine the byte order used for generating the byte sequence, but as a signature that helps in guessing the encoding. On encoding the <code>utf-8-sig</code> codec will write <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code> as the first three bytes to the file. On decoding <code>utf-8-sig</code> will skip those three bytes if they appear as the first three bytes in the file. In UTF-8, the use of the BOM is discouraged and should generally be avoided.</p>
</blockquote>
</div>
<span class="comment-copy">In editing, I appear to have destroyed the evidence. The BOM bytes no longer appear in the post, not even in the original revision. Thanks, Stack!.. (ahem).</span>
<span class="comment-copy">That's nice, I suppose...</span>
<span class="comment-copy">How do I do that?</span>
<span class="comment-copy">@EmilLykkeDiget: are you using Python 3?</span>
<span class="comment-copy">I forgot to write that; yes I'm using Python 3.</span>
<span class="comment-copy">Simple but effictive; that worked! Thank you very much!</span>
