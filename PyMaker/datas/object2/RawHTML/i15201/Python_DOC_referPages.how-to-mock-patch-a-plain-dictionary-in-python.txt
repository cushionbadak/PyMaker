<div class="post-text" itemprop="text">
<p>How do I mock.patch a plain dictionary {} ?</p>
<p>I would like to check if the  headers is set to {'Content-Type': 'application/jsonâ€™}.</p>
<pre><code>def get(self):
    result = Spider.get_news_urls()
    for k, v in result.iteritems():
        response = requests.get(v)
        xml = response.text()
        headers = {'Content-Type': 'application/json'}
        data = ''
        taskqueue.Task(url='/v1/worker', headers=headers, payload=json.dumps(data)).add(queue_name='itagnewstasks')
    return 'success', 200
</code></pre>
<p>The following unit test seems to successfully patch dict. But I have a {}, which I need to patch.</p>
<pre><code>@mock.patch('__builtin__.dict')
@mock.patch('requests.get')
def test_header_is_set_to_json(self, req_get, x):
    gen = Generator()
    gen.get()
    x.assert_called_with()
</code></pre>
<p>I suppose an alternative way would be to mock patch <code>taskqueue.Task()</code> and compare if it was called with <code>headers= {'Content-Type': 'application/json'}</code> as a parameter.</p>
</div>
<div class="post-text" itemprop="text">
<p>The headers you seek to mock are constructed within the method you are testing, so mocking the <code>taskqueue.Task</code> call would be much easier. If you were passing the header dict into the method then you could just hold onto a copy and check that it has been updated as you expect.</p>
<p>You can use <a href="https://docs.python.org/3/library/unittest.mock.html#patch-dict" rel="nofollow">patch.dict</a> to mock a dictionary:</p>
<pre><code>&gt;&gt;&gt; foo = {}
&gt;&gt;&gt; with patch.dict(foo, {'newkey': 'newvalue'}):
...     assert foo == {'newkey': 'newvalue'}
...
&gt;&gt;&gt; assert foo == {}
</code></pre>
</div>
