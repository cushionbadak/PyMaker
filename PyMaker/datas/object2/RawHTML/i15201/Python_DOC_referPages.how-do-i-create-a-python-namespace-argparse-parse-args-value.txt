<div class="post-text" itemprop="text">
<p>To interactively test my python script, I would like to create a <code>Namespace</code> object, similar to what would be returned by <code>argparse.parse_args()</code>.
The obvious way,</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.parse_args()
Namespace()
&gt;&gt;&gt; parser.parse_args("-a")
usage: [-h]
: error: unrecognized arguments: - a

Process Python exited abnormally with code 2
</code></pre>
<p>may result in Python repl exiting (as above) on a silly error.</p>
<p>So, <strong>what is the easiest way to create a Python namespace with a given set of attributes?</strong></p>
<p>E.g., I can create a <code>dict</code> on the fly (<code>dict([("a",1),("b","c")])</code>) but I cannot use it as a <code>Namespace</code>:</p>
<pre><code>AttributeError: 'dict' object has no attribute 'a'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a simple class:</p>
<pre><code>class Namespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
</code></pre>
<p>and it'll work the exact same way as the <code>argparse</code> <code>Namespace</code> class when it comes to attributes:</p>
<pre><code>&gt;&gt;&gt; args = Namespace(a=1, b='c')
&gt;&gt;&gt; args.a
1
&gt;&gt;&gt; args.b
'c'
</code></pre>
<p>Alternatively, just <em>import the class</em>; it is available from the <code>argparse</code> module:</p>
<pre><code>from argparse import Namespace

args = Namespace(a=1, b='c')
</code></pre>
<p>As of Python 3.3, there is also <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer"><code>types.SimpleNamespace</code></a>, which essentially does the same thing:</p>
<pre><code>&gt;&gt;&gt; from types import SimpleNamespace
&gt;&gt;&gt; args = SimpleNamespace(a=1, b='c')
&gt;&gt;&gt; args.a
1
&gt;&gt;&gt; args.b
'c'
</code></pre>
<p>The two types are distinct; <code>SimpleNamespace</code> is primarily used for the <code>sys.implementation</code> attribute and the return value of <code>time.get_clock_info()</code>.</p>
<p>Further comparisons:</p>
<ul>
<li>Both classes support equality testing; for two instances of the same class, <code>instance_a == instance_b</code> is true if they have the same attributes with the same values.</li>
<li>Both classes have a helpful <code>__repr__</code> to show what attributes they have.</li>
<li><code>Namespace()</code> objects support containment testing; <code>'attrname' in instance</code> is true if the namespace instance has an attribute namend <code>attrname</code>. <code>SimpleNamespace</code> does not.</li>
<li><code>Namespace()</code> objects have an undocumented <code>._get_kwargs()</code> method that returns a sorted list of <code>(name, value)</code> attributes for that instance. You can get the same for either class using <code>sorted(vars(instance).items())</code>.</li>
<li>While <code>SimpleNamespace()</code> is implemented in C and <code>Namespace()</code> is implemented in Python, attribute access is no faster because both use the same <code>__dict__</code> storage for the attributes. Equality testing and producing the representation are a little faster for <code>SimpleNamespace()</code> instances.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It is now recommended to use SimpleNamespace from the types module. It does the same thing as the accepted answer except for it will be faster and have a few more builtins such as equals and repr.</p>
<pre><code>from types import SimpleNamespace

sn = SimpleNamespace()
sn.a = 'test'
sn.a

# output
'test'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_args" rel="nofollow">argparse documentation</a> show various examples of what you're trying to do: </p>
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-a")
parser.parse_args(['-a 12'])
&gt;&gt;&gt; Namespace(a=' 12')
</code></pre>
</div>
<span class="comment-copy">The former simple class is actually types.SimpleNamespace: see <a href="https://docs.python.org/dev/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">docs.python.org/dev/library/types.html#types.SimpleNamespace</a>.</span>
<span class="comment-copy">@Ofer: no, <code>SimpleNamespace</code> is not actually used by <code>argparse</code>; <code>argparse.Namespace</code> is a pure-Python class unique to that library, <code>types.SimpleNamespace</code> is the class originally developed for <code>sys.implementation</code> and later used for <code>time.get_clock_info()</code> as well. It's implemented in C.</span>
<span class="comment-copy"><code>argparse.Namespace</code> also implements <code>__repr__</code> and <code>__eq__</code>. <code>SimpleNamespace</code> <i>is</i> implemented in C, but only the equality testing and <code>repr()</code> output will be a bit faster because of that. Attribute access is just as fast because both use the exact same mechanism to store and look up attributes. <code>argparse.Namespace()</code> also implements <code>__contains__</code>, so you can use <code>if something in ns_instance</code>, and there is an undocumented <code>._get_kwargs()</code> method; <code>SimpleNamespace()</code> doesn't have either.</span>
<span class="comment-copy">no good, as I explain in the question: a small error and the repl is <i>dead</i></span>
<span class="comment-copy">This doesn't let you interactively test your code that is using the <code>Namespace</code> instance.</span>
<span class="comment-copy">@sds I may be missing something on the 'repl is dead' part of your question but isn't it because the <code>ArgumentParser</code> you're using is missing the <code>add_argument</code> call ? I do understand that you don't want to recreate the same <code>ArgumentParser</code> in your test but it could be created in a separate method called in the test to be retrieved. @MartijnPieters can't you just do create the <code>ArgumentParser</code> this way and then pass it in you method that's using it ? `my_method_using_arg_parse(fake_namespace)</span>
