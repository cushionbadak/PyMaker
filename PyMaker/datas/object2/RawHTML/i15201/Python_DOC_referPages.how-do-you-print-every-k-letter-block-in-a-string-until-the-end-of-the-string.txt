<div class="post-text" itemprop="text">
<p>Basically, I have a long string, and I want to do something like:</p>
<pre><code>for x in range(3,10):
   #when x = 3, break the string in blocks of 3, when x = 4, break it into blocks of 4, etc.
</code></pre>
<p>So, for example, if the string is equal to "hello_world" and x = 5, then I want to return {hello, _worl, d}.</p>
</div>
<div class="post-text" itemprop="text">
<p>The canonical way of doing this in Python comes from the <a href="https://docs.python.org/3/library/itertools.html#recipes" rel="nofollow"><code>itertools</code> recipes</a> page</p>
<pre><code>from itertools import zip_longest

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)

result = [''.join(group) for group in grouper('hello_world', 5, fillvalue="")]
</code></pre>
<p>results in:</p>
<pre><code>Out[4]: ['hello', '_worl', 'd']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should do the trick, it relies on python elegantly slicing arrays shorter than requested (ie <code>"this_string"[2:400]</code> will return <code>"is_string"</code> without error).</p>
<pre><code>string = "hello_world"
for x in range(3, 10):
    split = [string[(i*x):(i+1)*x] for i in range(1 + len(string) / x)]
    print(split)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like this should work. We're relying on the fact that the <code>while</code> loop will run one last time even if there's only one character left (like <code>"d"</code>), and that we can take a slice that is longer than the actual string, and it will just return whatever is left.</p>
<pre><code>in_string = "hello_world"
sep = 5

chunks = []
i = 0
while (sep * len(chunks) &lt; len(in_string)):
    chunks.append(in_string[sep*i:sep*(i+1)])
    i += 1

print chunks
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a nifty little recursive function to do it:</p>
<pre><code>def splitter(word, n):
    if len(word) &gt; n:
        return [word[:n]] + splitter(word[n:],n)
    else:
        return [word]

&gt;&gt;&gt; splitter("hello_world", 5)
['hello', '_worl', 'd']
</code></pre>
</div>
<span class="comment-copy">This is - by far - the fastest answer proposed so far.</span>
<span class="comment-copy">Though this works, and takes advantage of some of Python's nicest properties, it is significantly slower than other methods proposed. In a quick test with a very large string, this code took 61s to run, as opposed to 13s with my solution using a <code>while</code> loop, and 8s for Adam Smith's even faster <code>itertools</code> answer.</span>
<span class="comment-copy">The more time I spend in Python, the more I feel that any <code>while</code> loop that's not <code>while True</code> is not the best way to approach a problem. Check out my grouper answer from the <code>itertools</code> recipes docs page</span>
<span class="comment-copy">Good call! Your method does appear to be significantly faster, too! I'll keep that in mind.</span>
<span class="comment-copy">Recursion is dangerous here, as large strings will cause a <code>RuntimeError:  maximum recursion depth exceeded</code>. It's also quite slow.</span>
