<div class="post-text" itemprop="text">
<p>I'm trying this:</p>
<pre><code>import pandas as pd
import sqlite3
import datetime, pytz

#nowtime=datetime.datetime.now(pytz.utc)
nowtime=datetime.datetime.now()

print(nowtime)
df = pd.DataFrame(columns=list('ABCD'))
df.loc[0]=(3,0.141,"five-nine",nowtime)
df.loc[1]=(1,0.41,"four-two",nowtime)

print(df)

db = sqlite3.connect(':memory:')
c = db.cursor()
c.execute('create table if not exists ABCD ( A integer, B real, C text, D timestamp );')
c.execute('insert into ABCD (A,B,C, D) values (?,?,?,?);',(1,2.2,'4',nowtime))
c.executemany('insert into ABCD (A,B,C, D) values (?,?,?,?);',df.to_records(index=False))

db.commit()

print(pd.read_sql('select * from ABCD;',db))
</code></pre>
<p>and getting this:</p>
<pre><code> 2018-03-07 19:09:58.584953
   A      B          C                          D
0  3  0.141  five-nine 2018-03-07 19:09:58.584953
1  1  0.410   four-two 2018-03-07 19:09:58.584953
   A      B          C                           D
0  1  2.200          4  2018-03-07 19:09:58.584953
1  3  0.141  five-nine    b'\xa8hx?\t\xb9\x19\x15'
2  1  0.410   four-two    b'\xa8hx?\t\xb9\x19\x15'
</code></pre>
<p>Ideally, I'd like to push some data with timestamps into sqlite3 and recover it back into pandas/python/numpy interoperably.</p>
<p>I've seen <a href="https://stackoverflow.com/questions/23574614/appending-pandas-dataframe-to-sqlite-table-by-primary-key">Appending Pandas dataframe to sqlite table by primary key</a> for appending, but I'm not sure how to work with datetime.datetime, pandas Timestamps or numpy.datetime64 times with sqlite3.</p>
<p>Also, there was <a href="https://stackoverflow.com/questions/1829872/how-to-read-datetime-back-from-sqlite-as-a-datetime-instead-of-string-in-python">How to read datetime back from sqlite as a datetime instead of string in Python?</a> but I couldn't figure out how to do it in pandas.</p>
<p>One thing I spent a lot of time on was <a href="https://stackoverflow.com/a/21916253/1653571">https://stackoverflow.com/a/21916253/1653571</a> and the confusing multiple to_datetime()s.</p>
<p>What's a good way to work with times, sqlite3, and pandas?</p>

####### update:

<p>I tried these changes:</p>
<pre><code>db = sqlite3.connect(':memory:',detect_types=sqlite3.PARSE_DECLTYPES)

#...
for index,row in df.iterrows():
    print(row)
    c.execute('insert into ABCD (A,B,C,D) values (?,?,?,?);',(row.A,row.B,row.C,row.D.to_pydatetime()))


x = pd.read_sql('select *  from ABCD;',db)

print('Type of a pd.read_sql(SQLite3) timestamp  : ',type(x['D'][0]))

x = c.execute('select * from ABCD').fetchall()

print(x)
print('Type of a sqlite.execute(SQLite3) timestamp  : ',type(x[0][3]))
</code></pre>
<p>to use the SQLite3 datatypes and to test the returned values:</p>
<pre><code>Type of a pd.read_sql(SQLite3) timestamp  :  &lt;class 'pandas._libs.tslib.Timestamp'&gt;
[(1, 2.2, '4', datetime.datetime(2018, 3, 8, 14, 46, 2, 520333)), (3, 141.0, 'five-nine', datetime.datetime(2018, 3, 8, 14, 46, 2, 520333)), (1, 41.0, 'four-two', datetime.datetime(2018, 3, 8, 14, 46, 2, 520333))]
Type of a sqlite.execute(SQLite3) timestamp  :  &lt;class 'datetime.datetime'&gt;
</code></pre>
<p>Also, as I tried <code>datetime.datetime.now(pytz.utc)</code> to get UTC-aware times, but it broke lots of stuff.  Using <code>datetime.datetime.utcnow()</code> worked much better by returning a not-timezone-aware object that isn't affected by timezones.</p>
<p>Note also the Python sqlite3 documentation on the <code>sqlite3.connect(detect_types=...)</code> parameter.  Enabling <code>detect_types=PARSE_DECLTYPES|PARSE_COLNAMES</code> cues python to run converters on data passed between the systems.</p>
<ul>
<li><a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_DECLTYPES" rel="nofollow noreferrer">https://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_DECLTYPES</a> for <code>create table ... xyzzy timestamp, ...</code> conversions</li>
<li><a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_COLNAMES" rel="nofollow noreferrer">https://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_COLNAMES</a> for <code>select ... date as "dateparsed [datetime]"...</code> conversions  </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The main issue is that SQLite doesn't have a datetime datatype.</p>
<p><code>PARSE_DECLTYPES</code> can't help when reading out of SQLite because the declared datatypes of columns in SQLite will never be datetimes. </p>
<p>Since you are in control of the Pandas dataframe, you know the types at the point in time you are saving them back to SQLite. </p>
<p>the <code>read_sql</code> method you are using... </p>
<blockquote>
<p>is a convenience wrapper around read_sql_table and read_sql_query (and
  for backward compatibility) and will delegate to the specific function
  depending on the provided input (database table name or SQL query).</p>
</blockquote>
<p>In your example you've provided a query so it is delegating to the <code>read_sql_query</code> method <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html#pandas.read_sql_query" rel="nofollow noreferrer">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html#pandas.read_sql_query</a></p>
<p>This has a parameter <code>parse_dates</code> which can be:</p>
<blockquote>
<p>Dict of {column_name: arg dict}, where the arg dict corresponds to the
  keyword arguments of pandas.to_datetime() <strong>Especially useful with
  databases without native Datetime support, such as SQLite</strong></p>
</blockquote>
<p>Since you know ahead of time which columns are datatypes, you can store those as a dict with a structure that matches what this <code>parse_dates</code> expects, and just pass it into the <code>read_sql</code> method. </p>
<p>In other situations where I've saved a pandas df back to a csv or other file, I've used something like this to save the schema to reintroduce when loading csv back to pandas. The <code>read_csv</code> method has a <code>dbtypes</code> parameter that takes exactly the structure below. </p>
<pre><code>def getPandasSchema(df):
    ''' 
    takes a pandas dataframe and returns the dtype dictionary
    useful for applying types when reloading that dataframe from csv etc
    '''
    return dict(zip(df.columns.tolist(),df.dtypes.tolist()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Issue derives from pandas' <code>to_records()</code> which is converting your datetime field into an ISO timestamp with T separator:</p>
<pre><code>print(df.to_records(index=False))
# [(3, 0.141, 'five-nine', '2018-03-07T20:40:39.808427000')
#  (1, 0.41 , 'four-two', '2018-03-07T20:40:39.808427000')]
</code></pre>
<p>Consider converting datetime column to string and then run cursor <code>executemany()</code>:</p>
<pre><code>df.D = df.D.astype('str')

print(df.to_records(index=False))
# [(3, 0.141, 'five-nine', '2018-03-07 20:40:39.808427')
#  (1, 0.41 , 'four-two', '2018-03-07 20:40:39.808427')]
</code></pre>
<p>Altogether:</p>
<pre><code>db = sqlite3.connect(':memory:')
c = db.cursor()
c.execute('create table if not exists ABCD ( A integer, B real, C text, D timestamp );')
c.execute('insert into ABCD (A,B,C, D) values (?,?,?,?);',(1,2.2,'4',nowtime))

df['D'] = df['D'].astype('str')
c.executemany('insert into ABCD (A,B,C, D) values (?,?,?,?);',df.to_records(index=False))

db.commit()
print(pd.read_sql('select * from ABCD;',db))

#    A      B          C                           D
# 0  1  2.200          4  2018-03-07 20:47:15.031130
# 1  3  0.141  five-nine  2018-03-07 20:47:15.031130
# 2  1  0.410   four-two  2018-03-07 20:47:15.031130
</code></pre>
</div>
<span class="comment-copy">I'm not sure I like <code>str</code> as the datatype.  Won't it be slower and more complicated to re-parse back into <code>pandas.Timestamp</code> or <code>datetime.datetime</code>?</span>
<span class="comment-copy">Did you check the <code>dtypes</code> after <code>read_sql</code> which should derive from SQLite types? The conversion to string was simply to migrate into SQLite. Otherwise do not use <code>to_records()</code>, see into <code>iterrows</code>. Try even <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_sql.html" rel="nofollow noreferrer"><code>to_sql</code></a> method with an SQLAlchemy connection.</span>
<span class="comment-copy">I found that the returned datatypes are <code>str</code> either way unless I add a  <code>detect_types=sqlite3.PARSE_DECLTYPES</code> parameter to the <code>db.connect()</code>. With that param, <code>c.execute(...).fetch...</code> returns <code>datetime.datetime</code> and <code>pd.read_sql</code> returns <code>pandas._libs.tslib.Timestamp</code>.   The SQLite types seem completely ignored unless the parameter is set.</span>
<span class="comment-copy">Being a lightweight, file-level DB, SQLite only has few <a href="https://www.sqlite.org/datatype3.html" rel="nofollow noreferrer">data types</a>: <code>TEXT, NUMERIC, INTEGER, REAL, BLOB.</code> There is no <i>timestamp</i> type and likely is saved into its closest affinity class being text.</span>
<span class="comment-copy">@DaveX It's not only stored internally as <code>TEXT</code>, SQLite has no concept of it being anything else but <code>TEXT</code>. When you see things like <code>datetime.datetime</code> returned from <code>PARSE_DECLTYPES</code> that is because you are reading from Pandas which does have those types. They will always be stored as strings in SQLite as you've found. There is no solution on the SQLite side, your problem exists when reading SQLite back to Pandas, so the datatype conversion needs to happen on the Pandas side.</span>
