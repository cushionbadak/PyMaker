<div class="post-text" itemprop="text">
<p>I'm trying to write code that validates type hints, and in order to do so I have to find out what kind of object the annotation is. For example, consider this snippet that's supposed to tell the user what kind of value is expected:</p>
<pre><code>import typing

typ = typing.Union[int, str]

if issubclass(typ, typing.Union):
    print('value type should be one of', typ.__args__)
elif issubclass(typ, typing.Generic):
    print('value type should be a structure of', typ.__args__[0])
else:
    print('value type should be', typ)
</code></pre>
<p>This should print "value type should be one of (int, str)", but instead it throws an exception:</p>
<pre><code>Traceback (most recent call last):
  File "untitled.py", line 6, in &lt;module&gt;
    if issubclass(typ, typing.Union):
  File "C:\Python34\lib\site-packages\typing.py", line 829, in __subclasscheck__
    raise TypeError("Unions cannot be used with issubclass().")
TypeError: Unions cannot be used with issubclass().
</code></pre>
<p><code>isinstance</code> doesn't work either:</p>
<pre><code>&gt;&gt;&gt; isinstance(typ, typing.Union)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\Python34\lib\site-packages\typing.py", line 826, in __instancecheck__
    raise TypeError("Unions cannot be used with isinstance().")
TypeError: Unions cannot be used with isinstance().
</code></pre>
<hr/>
<p>What's the correct way to check if <code>typ</code> is a <code>typing.Generic</code>?</p>
<p><strong>If possible, I would like to see a solution that's backed by documentation or a PEP or some other resource.</strong> A "solution" that "works" by accessing undocumented, internal attributes is easy to find. But more likely than not, it'll turn out to be an implementation detail and will change in future versions. I'm looking for <em>"the right way"</em> to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may be looking for <a href="https://github.com/python/cpython/blob/e022bbc169ca1428dc3017187012de17ce6e0bc7/Lib/typing.py#L609" rel="noreferrer"><code>__origin__</code></a>:</p>
<blockquote>
<pre><code># * __origin__ keeps a reference to a type that was subscripted,
#   e.g., Union[T, int].__origin__ == Union;`
</code></pre>
</blockquote>
<pre><code>import typing

typ = typing.Union[int, str]

if typ.__origin__ is typing.Union:
    print('value type should be one of', typ.__args__)
elif typ.__origin__ is typing.Generic:
    print('value type should be a structure of', typ.__args__[0])
else:
    print('value type should be', typ)

&gt;&gt;&gt;value type should be one of (&lt;class 'int'&gt;, &lt;class 'str'&gt;)
</code></pre>
<p>The best I could find to advocate the use of this undocumented attribute is this reassuring <a href="https://github.com/python/typing/issues/136" rel="noreferrer">quote</a> from Guido Van Rossum (2 years ago):</p>
<blockquote>
<p>The best I can recommend is using <code>__origin__</code> -- if we were to change this attribute there would still have to be some other way to access the same information, and it would be easy to grep your code for occurrences of <code>__origin__</code>. (I'd be less worried about changes to <code>__origin__</code> than to <code>__extra__</code>.) You may also look at the internal functions <code>_gorg()</code> and <code>_geqv()</code> (these names will not be part of any public API, obviously, but their implementations are very simple and conceptually useful).</p>
</blockquote>
<p>This caveat in the documentation seem to indicate that nothing is set in marble yet:</p>
<blockquote>
<p>New features might be added and API may change even between minor releases if deemed necessary by the core developers.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>There is no official way to obtain this information. The <code>typing</code> module is still in heavy development, and has no public API to speak of. (In fact, it will probably never have one.)</p>
<p>All we can do is to look at the module's internals and find the least gross way to get the information we're after. And because the module is still being worked on, its internals will change. A lot.</p>
<hr/>
<p>In python 3.5 and 3.6, generics had an <code>__origin__</code> attribute that held a reference to the original generic base class (i.e. <code>List[int].__origin__</code> would've been <code>List</code>), but this was changed in 3.7. Now the easiest way to find out if something is a generic is probably to check its <code>__parameters__</code> and <code>__args__</code> attributes.</p>
<p>Here is a set of functions that can be used to detect generics:</p>
<pre><code>import typing


if hasattr(typing, '_GenericAlias'):
    # python 3.7
    def _is_generic(cls):
        if isinstance(cls, typing._GenericAlias):
            return True

        if isinstance(cls, typing._SpecialForm):
            return cls not in {typing.Any}

        return False


    def _is_base_generic(cls):
        if isinstance(cls, typing._GenericAlias):
            if cls.__origin__ in {typing.Generic, typing._Protocol}:
                return False

            if isinstance(cls, typing._VariadicGenericAlias):
                return True

            return len(cls.__parameters__) &gt; 0

        if isinstance(cls, typing._SpecialForm):
            return cls._name in {'ClassVar', 'Union', 'Optional'}

        return False
else:
    # python &lt;3.7
    if hasattr(typing, '_Union'):
        # python 3.6
        def _is_generic(cls):
            if isinstance(cls, (typing.GenericMeta, typing._Union, typing._Optional, typing._ClassVar)):
                return True

            return False


        def _is_base_generic(cls):
            if isinstance(cls, (typing.GenericMeta, typing._Union)):
                return cls.__args__ in {None, ()}

            if isinstance(cls, typing._Optional):
                return True

            return False
    else:
        # python 3.5
        def _is_generic(cls):
            if isinstance(cls, (typing.GenericMeta, typing.UnionMeta, typing.OptionalMeta, typing.CallableMeta, typing.TupleMeta)):
                return True

            return False


        def _is_base_generic(cls):
            if isinstance(cls, typing.GenericMeta):
                return all(isinstance(arg, typing.TypeVar) for arg in cls.__parameters__)

            if isinstance(cls, typing.UnionMeta):
                return cls.__union_params__ is None

            if isinstance(cls, typing.TupleMeta):
                return cls.__tuple_params__ is None

            if isinstance(cls, typing.CallableMeta):
                return cls.__args__ is None

            if isinstance(cls, typing.OptionalMeta):
                return True

            return False


def is_generic(cls):
    """
    Detects any kind of generic, for example `List` or `List[int]`. This includes "special" types like
    Union and Tuple - anything that's subscriptable, basically.
    """
    return _is_generic(cls)


def is_base_generic(cls):
    """
    Detects generic base classes, for example `List` (but not `List[int]`)
    """
    return _is_base_generic(cls)


def is_qualified_generic(cls):
    """
    Detects generics with arguments, for example `List[int]` (but not `List`)
    """
    return is_generic(cls) and not is_base_generic(cls)
</code></pre>
<p>All of these functions should work in all python versions &lt;= 3.7 (including anything &lt;3.5 that uses the <code>typing</code> module backport).</p>
</div>
<div class="post-text" itemprop="text">
<p>The most you could do, I think, is to use your <code>typ</code> on a variable, use <code>typing.get_type_hints</code> on it and extract the info you need from the returned <code>__annotations__</code>-like dictionary.</p>
<p><a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow noreferrer">PEP-484</a> says:</p>
<blockquote>
<p><code>get_type_hints()</code>, a utility function to retrieve the type hints from a function or method. Given a function or method object, it returns a dict with the same format as <code>__annotations__</code>, but evaluating forward references (which are given as string literals) as expressions in the context of the original function or method definition.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/typing.html#classes-functions-and-decorators" rel="nofollow noreferrer">26.1.7. Classes, functions, and decorators</a> says:</p>
<blockquote>
<p>At runtime, <code>isinstance(x, T)</code> will raise <code>TypeError</code>. In general, <code>isinstance()</code> and <code>issubclass()</code> should not be used with types.</p>
</blockquote>
<p>However, <a href="https://www.python.org/dev/peps/pep-0526/" rel="nofollow noreferrer">PEP-526</a> says in 'Non-goals':</p>
<blockquote>
<p>While the proposal is accompanied by an extension of the <code>typing.get_type_hints</code> standard library function for runtime retrieval of annotations, variable annotations are not designed for runtime type checking. Third party packages will have to be developed to implement such functionality.</p>
</blockquote>
</div>
<span class="comment-copy">Looks promising. But it also looks like you found that by sifting through the source code. If at all possible, I'd prefer a solution that's backed by some documentation or a PEP or any other resource that indicates that this isn't just an implementation detail.</span>
<span class="comment-copy">I haven't got any doc or PEP referencing it as <code>typing</code> is fairly recent. Is there anything about <code>__args__</code> anywhere? I will be on the lookout.</span>
<span class="comment-copy">Sadly, this broke in Python 3.7. <code>typing.Tuple[int, str].__origin__</code> is now the class <code>tuple</code>, not the class <code>typing.Tuple</code>.  I have no great alternative yet :( You can do an awful string comparison that works, but...  See <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1598574" rel="nofollow noreferrer">bugzilla.redhat.com/show_bug.cgi?id=1598574</a> (this broke the Fedora / RHEL installer! Whee.)</span>
<span class="comment-copy">I may be misunderstanding, but I don't see how <code>get_type_hints</code> would help me? If I define a variable <code>x: typ</code> and then use <code>get_type_hints</code> on it, I'll just get <code>typing.Union[int, str]</code> as the result.</span>
<span class="comment-copy">Well, you have, at runtime, the 'int' and the 'str' you were looking for.</span>
<span class="comment-copy">Or further inspect the result to craft a more detailed output, like you're code tries with <code>isinstance</code> and <code>issubclass</code>.</span>
