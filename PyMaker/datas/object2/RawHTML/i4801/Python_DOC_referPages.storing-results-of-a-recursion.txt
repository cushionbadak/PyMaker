<div class="post-text" itemprop="text">
<p>I have this code, that will print all the permutations of a list : </p>
<pre><code>def permute(iterable,fixed=0):
    for i in range(fixed,len(iterable)):
        iterable[fixed:] = [iterable[i]] + iterable[fixed:i] + iterable[i+1:]
        if fixed==len(iterable)-1:
            print iterable
        permute(iterable,fixed+1)
        iterable[fixed:] = iterable[fixed+1:i+1] + [iterable[fixed]] + iterable[i+1:]
</code></pre>
<hr/>
<p>Now I want to return this result instead of printing it, and the best way I found to do this is to store what's printed in a file, and then to read the file, extract the data and put it back in a list that I return : </p>
<pre><code>import string
from random import *
import os

def randString(minLen=16,maxLen=32,charset=string.ascii_letters+string.digits):
    if(minLen&gt;=maxLen):
        maxLen=minLen+1
    return "".join(choice(charset) for x in range(randint(minLen, maxLen)))

def permutations(iterable):
    def permute(iterable,f,fixed=0):
        for i in range(fixed,len(iterable)):
            iterable[fixed:] = [iterable[i]] + iterable[fixed:i] + iterable[i+1:]
            if fixed==len(iterable)-1:
                f.write(''.join(iterable)+" ")
            permute(iterable,f,fixed+1)
            iterable[fixed:] = iterable[fixed+1:i+1] + [iterable[fixed]] + iterable[i+1:]

    filename="."+randString()+".txt"
    f=open(filename,"w+")
    permute(list(iterable),f)
    f=open(filename,"r+")
    result=[]
    for i in f.read().split():
        result.append([])
        for j in i:
            result[-1].append(j)
    os.remove(filename)
    return result
</code></pre>
<p><strong>The problem is : this makes the code a lot longer, and at least 3 times slower, since I store all the permutations in the file, and then I have to go again through each permutation to store it back in a list.</strong></p>
<hr/>
<p>I tried to solve this problem by using global variables, or by passing the result list as parameter in the function, but it doesn't work (because of the recursion).</p>
<p><strong>The following codes aren't working :</strong></p>
<p><em>list as parameter</em></p>
<pre><code>def permute2(iterable,fixed=0,permutations=[]):
    for i in range(fixed,len(iterable)):
        iterable[fixed:] = [iterable[i]] + iterable[fixed:i] + iterable[i+1:]
        if fixed==len(iterable)-1:
            return iterable
        permutation = permute2(iterable,fixed+1)
        if permutation:
            permutations.append(permutation)
        iterable[fixed:] = iterable[fixed+1:i+1] + [iterable[fixed]] + iterable[i+1:]
    return permutations
</code></pre>
<p><em>global variables</em></p>
<p><em>First</em></p>
<pre><code>def permute(iterable,fixed=0):
    for i in range(fixed,len(iterable)):
        iterable[fixed:] = [iterable[i]] + iterable[fixed:i] + iterable[i+1:]
        if fixed==len(iterable)-1:
            global perms
            perms.append(iterable)
        permute(iterable,fixed+1)
        iterable[fixed:] = iterable[fixed+1:i+1] + [iterable[fixed]] + iterable[i+1:]

def permutations(iterable):
    global perms
    perms=[]
    permute(list(iterable))
    return perms
</code></pre>
<p><em>Second</em></p>
<pre><code>def permute(iterable,fixed=0):
    for i in range(fixed,len(iterable)):
        iterable[fixed:] = [iterable[i]] + iterable[fixed:i] + iterable[i+1:]
        if fixed==len(iterable)-1:
            addPermutation(iterable)
        permute(iterable,fixed+1)
        iterable[fixed:] = iterable[fixed+1:i+1] + [iterable[fixed]] + iterable[i+1:]

def addPermutation(item):
    addPermutation.perms.append(item)

def permutations(iterable):
    addPermutation.perms=[]
    permute(list(iterable))
    return addPermutation.perms
</code></pre>
<hr/>
<p>These three bad codes pretty much all do the same thing : they returns a list containing n! times the first permutation.</p>
<p><strong>Is there a way to solve this problem, or do I have to go with the code with the file ?</strong></p>
<hr/>
<p><strong>EDIT :</strong> After the comments of @DavidKemp and @uwain12345, I tried using a Class.</p>
<pre><code>def permutations(iterable):
    class Permut:
        def __init__(self, iterable):
            self.iterable = list(iterable)
            self.permutations = []
            self.permute()

        def permute(self,fixed=0):
            for i in range(fixed,len(self.iterable)):
                self.iterable[fixed:] = [self.iterable[i]] + self.iterable[fixed:i] + self.iterable[i+1:]
                if fixed==len(self.iterable)-1:
                    self.permutations.append(self.iterable)
                self.permute(fixed+1)
                self.iterable[fixed:] = self.iterable[fixed+1:i+1] + [self.iterable[fixed]] + self.iterable[i+1:]

    p = Permut(list(iterable))
    return p.permutations
</code></pre>
<p>However I still get the exact same result as the codes above that were not working (n! times the first permutation).</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that mutating the list <code>iterable</code> is a bad strategy.  Changes made to <code>iterbale</code> will always be reflected, because they are all the same object.  If we use tuples instead, we can avoid this.  Here's the recursive permutation code I came up with:</p>
<pre><code>def permute(iterable):
    iterable = tuple(iterable)
    if len(iterable) &lt;= 1:
        yield iterable
        return
    for i, x in enumerate(iterable):
        for sub_permutation in permute(iterable[:i] + iterable[i+1:]):
            yield (x,) +  sub_permutation
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unless this is an exercise, I recommend you follow Patrick Haugh's advice and use <code>itertools.permutations</code>. However, if you still insist on rolling your own then instead of <code>print</code>, use the <code>yield</code> keyword:</p>
<pre><code>def permute(iterable, fixed=0):
    for i in range(fixed,len(iterable)):
        iterable[fixed:] = [iterable[i]] + iterable[fixed:i] + iterable[i+1:]
        if fixed==len(iterable)-1:
            yield iterable
        for e in permute(iterable,fixed+1):
            yield e
        iterable[fixed:] = iterable[fixed+1:i+1] + [iterable[fixed]] + iterable[i+1:]

# Test out
for e in permute(['a', 'b', 'c']):
    print(e)
</code></pre>
<p>Output:</p>
<pre><code>['a', 'b', 'c']
['a', 'c', 'b']
['b', 'a', 'c']
['b', 'c', 'a']
['c', 'a', 'b']
['c', 'b', 'a']
</code></pre>
<h1>Notes</h1>
<ul>
<li>The <code>yield</code> statement will "return" one item at a time, but does not exit the function. This function returns a generator, so please read up on Python generators to learn more about it.</li>
<li><p>Consider the following block:</p>
<pre><code>for element in permute(iterable, fixed + 1):
    yield element
</code></pre>
<p>if you are using Python 3, you can replace that block with </p>
<pre><code>yield from permute(iterable, fixed + 1)
</code></pre></li>
</ul>
</div>
<span class="comment-copy">Does <a href="https://stackoverflow.com/a/1988826/26479">stackoverflow.com/a/1988826/26479</a> solve your problem?</span>
<span class="comment-copy">Am I missing something?  Why not use <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a>?</span>
<span class="comment-copy">I'd try using a class. Then you can store your intermediate results in an instance variable.</span>
<span class="comment-copy">I am still getting the same result when I use a class, the only codes that works as expected are the two first ones.</span>
<span class="comment-copy">@PatrickHaugh Yeah I know about itertools.permutations but I am trying to implement this code using a recursive backtracking algorithm</span>
<span class="comment-copy">This works when printing each permutation, but try <code>list(permute([1, 2, 3]))</code>.  Because we're yielding a mutated version of the same list, we end up with a list of identical permutations.</span>
<span class="comment-copy">You are correct Patrick.</span>
