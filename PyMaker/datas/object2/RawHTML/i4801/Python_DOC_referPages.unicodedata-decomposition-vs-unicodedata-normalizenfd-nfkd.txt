<div class="post-text" itemprop="text">
<p>According to py3 <a href="https://docs.python.org/3/library/unicodedata.html#module-unicodedata" rel="nofollow noreferrer">doc</a>:</p>
<blockquote>
<p><strong>unicodedata.decomposition(<em>chr</em>)</strong></p>
<blockquote>
<p>Returns the character decomposition mapping assigned to the character <em>chr</em> as string. An empty string is
    returned in case no such mapping is defined.</p>
</blockquote>
</blockquote>
<p>Here I don't quite understand how <strong><em>character decomposition mapping</em></strong> is defined and what's the relationship/difference between <code>unicodedata.decomposition()</code> and <code>unicodedata.normalize(NFD/NFKD)</code>?.</p>
<p>See following examples:</p>
<pre><code>$ python3
&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; unicodedata.decomposition('⑴')
'&lt;compat&gt; 0028 0031 0029'              &lt;-- why not just '0028 0031 0029'?
&gt;&gt;&gt; unicodedata.normalize('NFKD', '⑴')
'(1)'
&gt;&gt;&gt; unicodedata.decomposition('①')
'&lt;circle&gt; 0031'                        &lt;-- why not just '0031'?
&gt;&gt;&gt; unicodedata.normalize('NFKD', '①')
'1'
&gt;&gt;&gt; unicodedata.decomposition('è')
'0065 0300'                            &lt;-- like this?
&gt;&gt;&gt; unicodedata.normalize('NFD', 'è') == '\u0065\u0300'
True
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>unicodedata.decomposition</code> returns the decomposition type and mapping of a single code point <a href="https://www.unicode.org/reports/tr44/tr44-20.html#Decomposition_Mapping" rel="nofollow noreferrer">in the format</a> used in the <a href="https://www.unicode.org/Public/UNIDATA/UnicodeData.txt" rel="nofollow noreferrer">Unicode Character Database</a>. From UAX #44:</p>
<blockquote>
<p>Decomposition_Type, Decomposition_Mapping: This field contains both values, with the type in angle brackets.</p>
</blockquote>
<p>If there's no type in angle brackets, the code point has a <em>canonical decomposition</em> used in NFC and NFD. If there's a type in angle brackets, the code point has a <em>compatibility decomposition</em> which are used by NFKC and NFKD in addition to the canonical decompositions.</p>
<p><code>unicodedata.normalize</code> implements the Unicode Normalization algorithms for whole strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>The mappings are defined in Unicode standard.</p>
<p>K is "compatibility". Unicode had to insert some codes into Unicode, in order to be able to do a round trip, without losing information. The "K" conversion will remove such "extra/unwanted" characters (that should not be in Unicode, by other rules).</p>
<p>So subscript numbers, superscript numbers, fractions, and the circled number (in your example) are transformed (they should be standard numbers + markup format (which is outside Unicode, and character).</p>
<p>The problem: with subscript, one get just the number, so changing the meaning, e.g. <code>4²</code> is transformed into <code>42</code>. K will remove some semantic of the text (which should not be there in first place, but just decomposing is not enough good)</p>
<p>So K should not be used, but for specific uses. One of such uses it is for string searches, or to see if one username is too similar (maybe indistinguishable) to other usernames [but just 'K' is not enough].</p>
<p>The D is a normalisation: D will decompose characters into components, so <code>ê</code> is transformed into <code>e</code> and the combining character <code>^</code>.  This was also one target of Unicode: coding all characters into 65366 codes were not realizable, so the character were composed. (This is mostly visible with Chinese characters). Again, for compatibility and round trip, there were added some accented characters and later Unicode expanded to more than 65536 codes.</p>
<p>So we have D for the decomposed characters (base + combination codes), and C with the more compact notation (if available with such combination).  Also these transformation are described in Unicode standards (with few historical special cases and "bugs").</p>
</div>
<span class="comment-copy">i would expect <code>unicodedata.decomposition('⑴')</code> to return <code>0028 0031 0029</code> rather than <code>&lt;compat&gt; 0028 0031 0029</code>. or put it another way, why do we need <code>decomposition()</code> since we already have <code>normalize(NFD/NFKD)</code>? what's the <b><i>diff</i></b>?</span>
<span class="comment-copy">In effect, you are right. <a href="https://unicode.org/charts/normalization/chart_Number-Other.html" rel="nofollow noreferrer">unicode.org/charts/normalization/chart_Number-Other.html</a>  (index in <a href="http://unicode.org/charts/normalization/" rel="nofollow noreferrer">unicode.org/charts/normalization</a>). Now I'm looking where <code>&lt;compact&gt;</code> is added. I overlooked it on explaination.</span>
<span class="comment-copy">See the other answer. Right, "decomposition" add also the description, in order to give programs some hints on how to proceed.  This the list per mapping: <a href="https://www.compart.com/en/unicode/decomposition" rel="nofollow noreferrer">compart.com/en/unicode/decomposition</a></span>
