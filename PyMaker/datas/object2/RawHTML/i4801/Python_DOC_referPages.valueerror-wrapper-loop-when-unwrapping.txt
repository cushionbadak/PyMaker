<div class="post-text" itemprop="text">
<p>Python3 test cases (doctests) are failing with my sample code. But the same is working fine in Python2.</p>
<p><code>test.py</code></p>
<pre><code>class Test(object):
    def __init__(self, a=0):
        self.a = a

    def __getattr__(self, attr):
        return Test(a=str(self.a) + attr)
</code></pre>
<p><code>tst.py</code></p>
<pre><code>from test import Test

t = Test()
</code></pre>
<p>Run test cases: <code>python3 -m doctest -v tst.py</code></p>
<p>Error:</p>
<pre><code>Traceback (most recent call last):
  File "/usr/lib/python3.6/runpy.py", line 193, in _run_module_as_main
    "__main__", mod_spec)
  File "/usr/lib/python3.6/runpy.py", line 85, in _run_code
    exec(code, run_globals)
  File "/usr/lib/python3.6/doctest.py", line 2787, in &lt;module&gt;
    sys.exit(_test())
  File "/usr/lib/python3.6/doctest.py", line 2777, in _test
    failures, _ = testmod(m, verbose=verbose, optionflags=options)
  File "/usr/lib/python3.6/doctest.py", line 1950, in testmod
    for test in finder.find(m, name, globs=globs, extraglobs=extraglobs):
  File "/usr/lib/python3.6/doctest.py", line 933, in find
    self._find(tests, obj, name, module, source_lines, globs, {})
  File "/usr/lib/python3.6/doctest.py", line 992, in _find
    if ((inspect.isroutine(inspect.unwrap(val))
  File "/usr/lib/python3.6/inspect.py", line 513, in unwrap
    raise ValueError('wrapper loop when unwrapping {!r}'.format(f))
ValueError: wrapper loop when unwrapping &lt;test.Test object at 0x7f6e80028550&gt;
</code></pre>
<p>Can anyone please help in how to overcome this error.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is arguably a bug in doctest. What's happening is that doctest is searching for functions/methods/callables with a docstring, and while doing so it's <a href="https://docs.python.org/3/library/inspect.html#inspect.unwrap" rel="nofollow noreferrer">unwrapping</a> any decorators it finds. Why it does this, I have no idea. But anyway, doctest ends up calling <code>inspect.unwrap(t)</code> (where <code>t</code> is a <code>Test</code> instance), which is essentially equivalent to doing this:</p>
<pre><code>while True:
   try:
       t = t.__wrapped__
   except AttributeError:
       break
</code></pre>
<p>Because <code>t</code> is a <code>Test</code> instance, accessing <code>t.__wrapped__</code> calls <code>__getattr__</code> and returns a new <code>Test</code> instance. This would go on forever, but <code>inspect.unwrap</code> is smart enough to notice that it's not getting anywhere, and throws an exception instead of entering an infinite loop.</p>
<hr/>
<p>As a workaround, you can rewrite your <code>__getattr__</code> method to throw an <code>AttributeError</code> when <code>__wrapped__</code> is accessed. Even better, throw an AttributeError when <em>any</em> dunder-attribute is accessed:</p>
<pre><code>def __getattr__(self, attr):
    if attr.startswith('__') and attr.endswith('__'):
        raise AttributeError
    return Test(a=str(self.a) + attr)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For <code>unittest.mock</code> try importing items as</p>
<pre><code>from unittest import mock
</code></pre>
<p>instead of </p>
<pre><code>from unittest.mock import patch
</code></pre>
<p>This worked around the bug for me.</p>
</div>
<span class="comment-copy">@Aran-Fey Code for test.py is already there in the question.</span>
<span class="comment-copy">Never mind. I managed to reproduce it.</span>
<span class="comment-copy">Well, cheers for this one :) Has this bug been somehow filed to <code>doctest</code> now? Still here in 2018.</span>
<span class="comment-copy">@iago-lito No idea. I have neither reported it nor searched for an existing bug report.</span>
