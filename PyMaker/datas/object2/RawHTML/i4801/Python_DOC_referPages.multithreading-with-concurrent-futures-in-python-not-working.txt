<div class="post-text" itemprop="text">
<p>I'm trying to get multithreading to work in my program. But it never executes my worker function <code>functionName</code>. <code>future.done()</code>  is always returning <code>False</code> and the text "function entered" is never printed.  </p>
<pre><code>def functionName(par1, par2, par3):
    print("function entered")

with ThreadPoolExecutor(max_workers=2) as executor: 
    for x in items:      #this loops 8000 times
        future = executor.submit(functionName, parameter1, parameter2, parameter3)
        if future.done():
            print("true")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Concurrency is hard. Luckily, Python's <a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="nofollow noreferrer"><code>concurrent.futures</code></a> module manages to nicely decouple the workers (result producers) from the main program (result consumers) via concept of <a href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="nofollow noreferrer"><em>futures</em></a>. Also, executors (thread pool or process pool) will handle for you all the dirty details of thread/process spawning, synchronizing and joining.</p>
<p>After you submit a job to your executor, the future you receive will hold a handle to the result. Non-blocking checking of status is done with <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.done" rel="nofollow noreferrer"><code>future.done()</code></a> and blocking obtaining of the result with <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.result" rel="nofollow noreferrer"><code>future.result()</code></a>.</p>
<p>The exact order in which futures are resolved and results made available is not deterministic (unless you're running some real-time OS), and depends on operating system's thread/process scheduler. Also, since you check for <code>.done()</code> immediately after you submit a job, it is possible the job will not actually finish by that time. And if your worker function is more complex than in the example, it's highly likely it won't. When I run your example, it finished in ~50% of the time (got <code>true</code> printed couple of times).</p>
<p>However, to wait for and iterate over results, <strong>in order they become available</strong> (not necessarily in order they were submitted), you can use <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed" rel="nofollow noreferrer"><code>concurrent.futures.as_completed</code></a>.</p>
<p>For example:</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed

def function(param):
    return "function result for param: %s" % param

with ThreadPoolExecutor(max_workers=2) as executor:
    futures = [executor.submit(function, x) for x in [1,2,3]]

for future in as_completed(futures):
    print(future.result())
</code></pre>
<p>This outputs:</p>
<pre><code>function result for param: 1
function result for param: 3
function result for param: 2
</code></pre>
<p>The alternative is to submit all tasks, and then iterate over all futures, doing a blocking result fetch on all, <strong>in order they were submitted</strong>:</p>
<pre><code># submit all
...
# read results in order
for future in futures:
    print(future.result())
</code></pre>
<p>but this somewhat defeats the purpose of asynchronous futures. Not entirely, assuming that by the time you enqueue all your 8000 tasks, the first ones are going to finish. But that's a lot of unnecessary assumptions. Use <code>as_completed</code>.</p>
</div>
<span class="comment-copy">Because your <code>future</code> is never waited.</span>
<span class="comment-copy">Do you know how i can fix this problem?</span>
<span class="comment-copy">I indeed simplified my example. In my real code the function that i want to be executed by my workers, is a function that takes like 20 seconds to complete</span>
<span class="comment-copy">Yes, in that case it's clear why you're not seeing the output conditional on done status.</span>
<span class="comment-copy">I also checked the <code>len(future)</code> and that is indeed going up to 8000. So i need to add the <code>for</code>-loop that checks <code>as_completed</code></span>
<span class="comment-copy">Is it required to add the part <code>for x in [1,2,3]</code>?</span>
<span class="comment-copy">In your example that would be “for x in items”. Or instead of list comprehension you can use a standard loop, and append futures to a list.</span>
