<div class="post-text" itemprop="text">
<p>let say I have a list of lists </p>
<pre><code>[[a1, a2, a3], [b1, b2], [c1, c2, c3, c4]]
</code></pre>
<p>The number of lists in the list is not known in advance.</p>
<p>I want to have all combinations of elements from the different list, so </p>
<pre><code>[a1, b1, c1], [a1, b1, c2], ..., [a3, b2, c4] 
</code></pre>
<p>but if there common elements in the different list, all these combinations need to be deleted. So if for example, <code>a1 = c2</code>, then the combinations <code>[a1, b1, c2], [a1, b2, c2]</code> need to be deleted in the resulting list. </p>
<p>To get all possible combinations, you can use the answer on <a href="https://stackoverflow.com/questions/2853212/all-possible-permutations-of-a-set-of-lists-in-python]">All possible permutations of a set of lists in Python</a>, but can you automaticaly delete all combinations with common elements?</p>
</div>
<div class="post-text" itemprop="text">
<p>1) <code>itertools.product</code></p>
<pre><code> all_combinations = itertools.product(elements)
</code></pre>
<p>2) <code>filter</code> with lambda</p>
<pre><code>filtered_combinations = filter(lambda x: len(x) != len(set(x)), all_combinations)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are looking for the <a href="https://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow noreferrer">Cartesian Product</a> of your lists. Use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a>, and filter the elements to make sure none are equal:</p>
<pre><code>from itertools import product

for combo in product(*input_lists):
    if len(set(combo)) != len(combo):  # not all values unique
        continue
    print(*combo)
</code></pre>
<p>I'm assuming that by <em><code>a1 = c2</code></em> you mean that all values in the combination need to be <em>unique</em>, the above tests for this by creating a set from the combination. If the set length is smaller than the combination length, you had repeated values.</p>
<p>You can put this filter into a generator function:</p>
<pre><code>def unique_product(*l, repeat=None):
    for combo in product(*l, repeat=repeat):
        if len(set(combo)) == len(combo):  # all values unique
            yield combo
</code></pre>
<p>then use <code>for unique in unique_product(*input_lists):</code></p>
<p>You can also use the <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter()</code> function</a> to achieve the same, but that incurs a function call for each combination produced.</p>
</div>
