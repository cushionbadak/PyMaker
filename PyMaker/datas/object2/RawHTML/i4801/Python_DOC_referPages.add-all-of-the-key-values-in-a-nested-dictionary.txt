<div class="post-text" itemprop="text">
<p>I am trying to write a function that add all of the the inner key and value pairs of a nested dictionary. </p>
<p>This is what I would pass in </p>
<pre><code>Pets = {'family1':{'dogs':2,'cats':3,'fish':1},
       'family2':{'dogs':3,'cats':2}}
</code></pre>
<p>This is what I would expect as the result</p>
<pre><code>{'dogs': 5, 'cats': 5, 'fish': 1}
</code></pre>
<p>This is the loop I have written so far</p>
<pre><code>def addDict(d):
    d2 = {}
    for outKey, inKey in d.items():
        for inVal in inKey:
            print(inVal, " ", inKey[inVal])
            d2[inVal] = inKey[inVal]
    return d2
</code></pre>
<p>This prints</p>
<pre><code>dogs   2
cats   3
fish   1
dogs   3
cats   2
</code></pre>
<p>and returns </p>
<pre><code>{'dogs': 3, 'cats': 2, 'fish': 1}
</code></pre>
<p>But how can I get the data to be cumulative, because it is just giving me the data from the first dictionary. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like this,</p>
<pre><code>Pets={'family1': {'cats': 3, 'dogs': 2, 'fish': 1},
 'family2': {'cats': 2, 'dogs': 3}}
d={}
for i in Pets:
    for j in Pets[i]:
        if j in d:
            d[j] += Pets[i][j]
        else:
            d[j] = Pets[i][j]

print d

&gt;&gt; Output
{'cats': 5, 'dogs': 5, 'fish': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this:</p>
<pre><code>pets = {'family1':{'dogs':2,'cats':3,'fish':1},
       'family2':{'dogs':3,'cats':2}}

def addDict(d):
    d2 = {}
    for outKey, inKey in d.items():
        for inKey, inVal in inKey.items():
            try:
                d2[inKey] += inVal
            except KeyError:
                d2[inKey] = inVal
    return d2

print(addDict(pets))
</code></pre>
<p>Output:</p>
<pre><code>{'dogs': 5, 'cats': 5, 'fish': 1}
</code></pre>
<p>This is called as <a href="https://stackoverflow.com/questions/11360858/what-is-the-eafp-principle-in-python">EAFP principle in Python</a>. What you simply do, is try to add the value for a key. If the key is not present, it'll throw a <code>KeyError</code>. Catch that error and insert the key.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're so close! Just change the <code>=</code> in the part where you set d2's inval to <code>+=</code> and it should work. Basically, you want to add the value, not override it. But you also want to check if that key exists first before adding to it. So:</p>
<pre><code>if inVal in d2: d2 [inVal] += inKey [inVal]
else: d2 [inVal] = inKey [inVal]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collection.Counter</code></a> to do all the counting for you</p>
<pre><code>from collections import Counter

def addDict(d):
    c = Counter()
    [c.update(a) for a in d.values()]
    return dict(c)

&gt;&gt;&gt; Pets = {
            'family1':{'dogs':2,'cats':3,'fish':1},
            'family2':{'dogs':3,'cats':2}
            }
&gt;&gt;&gt; addDict(Pets)
&gt;&gt;&gt; {'cats': 5, 'fish': 1, 'dogs': 5}
</code></pre>
</div>
<span class="comment-copy">This would work if both the nested dictionaries had the same number of key-value pairs, else it would throw an error.</span>
<span class="comment-copy">Ok, so simple <code>if</code> statement to check first. I'll add it in now</span>
