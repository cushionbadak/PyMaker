<div class="post-text" itemprop="text">
<p>Im trying to make a graph edge list from a dictionary in python, with the following code:</p>
<pre><code>graph= []
for key, value in dic_test.items():
    for x in range (0,len(value)):
        if (x+1) &lt; len(value):
            for y in range (1,len(value)):
                if y != x and y&gt;x:
                    graph.append([value[x],value[y]])
</code></pre>
<p>This gets what I want, for example if I get this test dictionary:</p>
<pre><code>dic_test= {1: ['A', 'E','F','G'], 2: ['B', 'D','X'], 3: ['C',"Y"],4:[],5:['f','h']}
</code></pre>
<p>I get the following output:</p>
<pre><code>[['A', 'E'],
 ['A', 'F'],
 ['A', 'G'],
 ['E', 'F'],
 ['E', 'G'],
 ['F', 'G'],
 ['B', 'D'],
 ['B', 'X'],
 ['D', 'X'],
 ['C', 'Y'],
 ['f', 'h']]
</code></pre>
<p>Problem is when I run a big dictionary it runs until the kernel crashes, any ideas I could make this code more efficient?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/itertools.html#itertools.combinations" rel="nofollow noreferrer" title="itertools - combinations docs">Itertools</a> might help you here, as each edge is just a 2 item combination of the vertexes in each sublist:</p>
<pre><code>import itertools

output = []
for links in dic_test.values():
    output += map(list, itertools.combinations(links, 2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for val in dic_test.values():
     a=itertools.combinations(val,2)
     for c in a:
         print(c)
</code></pre>
<p>gives the output</p>
<pre><code>('A', 'E')
('A', 'F')
('A', 'G')
('E', 'F')
('E', 'G')
('F', 'G')
('B', 'D')
('B', 'X')
('D', 'X')
('C', 'Y')
('f', 'h')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the suggestions offering <code>itertools</code>, it's worth noting that you have sets of disjoint clicks. That means you don't need to do all of these computations at once and certainly don't need to store all the results in memory at the same time. It also means that you could <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">parallelize</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.combinations()</code><br/>
(see <a href="https://stackoverflow.com/questions/464864/how-to-get-all-possible-combinations-of-a-list-s-elements">how to get all combinations of a list's elements</a>):</p>
<pre><code>import itertools
dic_test= {1: ['A', 'E','F','G'], 2: ['B', 'D','X'], 3: ['C',"Y"],4:[],5:['f','h']}

_combinations = []
for _value in dic_test.values():
    _combinations.extend(list(itertools.combinations(_value, 2)))

print(_combinations)

[('A', 'E'),
 ('A', 'F'),
 ('A', 'G'),
 ('E', 'F'),
 ('E', 'G'),
 ('F', 'G'),
 ('B', 'D'),
 ('B', 'X'),
 ('D', 'X'),
 ('C', 'Y'),
 ('f', 'h')]
</code></pre>
<p>Since you have imported <code>itertools</code>, use <code>itertools.chain()</code> it is possible to do the following one liner:</p>
<pre><code>list(itertools.chain(*[list(itertools.combinations(_value, 2)) for _value in dic_test.values()]))
</code></pre>
<hr/>
<p><strong>Note</strong> </p>
<p><em>1. Performances issues:</em><br/>
- with <code>list.extend()</code> : <strong>7.23 µs</strong> per loop<br/>
- with <code>itertools.chain()</code> : <strong>8.15 µs</strong> per loop</p>
<p><em>2. Huge, very huge, very very very huge dictionnary:</em><br/>
As the operation you do on each key is independant one to another you can possibly parallelize your task (<a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing documentation</a> if you require it)</p>
</div>
<span class="comment-copy">How big a dictionary are you talking about? Are there a large number of keys, are the values long, or both? The number of unique pairs of elements in a list is <code>O(n^2)</code> where <code>n</code> is the size of the list.</span>
