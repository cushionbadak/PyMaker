<div class="post-text" itemprop="text">
<p>I have a working file [below], but I would like to know if there is a better solution to the first three lines.</p>
<p>I have several files in a folder, and a script that processes them based on a particular and conserved <code>&lt;string&gt;</code> in each file's name. However, I was told I should not use <code>__contains__</code> (I am not a CS major, and don't fully understand why). Is there a better option? I could not find any other concise solution.</p>
<p>Thanks.</p>
<pre><code>files = os.listdir (work_folder)
for i in files:
    if i.__contains__('FOO'):
        for i in range (number_of_files):
            old_file = 'C:/path/to/file'
            with open(merged_file, 'a+') as outfile:
                with open(old_file) as infile:
                    for line in infile:
                        outfile.write(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generally in Python, double-underscore methods should not be called directly; you should use the global functions or operators that correspond to them. In this case, you would do <code>if 'FOO' in i</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It would be more usual to write</p>
<pre><code>if 'FOO' in i:
</code></pre>
<p>instead of</p>
<pre><code>if i.__contains__('FOO'):
</code></pre>
<p>However, I would go one further than that and suggest your use case is more suited to <code>glob</code></p>
<pre><code>import glob
foo_files = glob.glob(os.path.join(work_folder, '*FOO*'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As Daniel Roseman explains, the double-underscore methods aren't there to be called by you, they're there to be called by the Python interpreter or standard library.</p>
<p>So, that's the main reason you shouldn't call them: It's not idiomatic, so it will confuse readers.</p>
<hr/>
<p>But all you know is that there must be <em>some</em> operation that you <em>are</em> intended to use, which Python will implement by calling the <code>__contains__</code> method. You have no idea what that operation is. How do you find it?</p>
<p>Well, you could just go to Stack Overflow, and someone helpful like Daniel Roseman will tell you, of course. But you can also search for <code>__contains__</code> in the Python documentation. What you'll find is <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">this</a>:</p>
<blockquote>
<p><code>object.__contains__(self, item)</code></p>
<blockquote>
<p>Called to implement membership test operators. Should return <code>true</code> if
    <em>item</em> is <code>in</code> <em>self</em>, <code>false</code> otherwise.</p>
</blockquote>
</blockquote>
<p>So, <code>self.__contains__(item)</code> is there for Python to implement <code>item in self</code>.</p>
<p>And now you know what to write: <code>'FOO' in i</code>.</p>
<hr/>
<p>And if you read on in those linked docs, you'll see that it isn't actually quite true that <code>i.__contains__('FOO')</code> does the same thing as <code>'FOO' in i</code>. That's true for the most common cases (including where <code>i</code> is a string, as it is here), but if <code>i</code> doesn't have a <code>__contains__</code> method, but is an iterable, or an old-style sequence, <code>in</code> will use those instead.</p>
<p>So, that's another reason not to directly call <code>__contains__</code>. If you later add some abstraction on top of strings, maybe a virtual iterable of grapheme clusters or something, it may not implement <code>__contains__</code>, but <code>in</code> will still work.</p>
</div>
<span class="comment-copy"><code>'Foo' in i</code> translates to <code>i.__contains__('FOO')</code> if that method exists.</span>
<span class="comment-copy">I see. So would there be an "appropriate," or even necessary, situation where one would use the double-underscored method, since they all have global functions?</span>
