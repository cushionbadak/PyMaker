<div class="post-text" itemprop="text">
<p>For any possible try-finally block in Python, is it guaranteed that the <code>finally</code> block will always be executed?</p>
<p>For example, let’s say I return while in an <code>except</code> block:</p>
<pre><code>try:
    1/0
except ZeroDivisionError:
    return
finally:
    print("Does this code run?")
</code></pre>
<p>Or maybe I re-raise an <code>Exception</code>:</p>
<pre><code>try:
    1/0
except ZeroDivisionError:
    raise
finally:
    print("What about this code?")
</code></pre>
<p>Testing shows that <code>finally</code> does get executed for the above examples, but I imagine there are other scenarios I haven't thought of.</p>
<p><strong>Are there any scenarios in which a <code>finally</code> block can fail to execute in Python?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>"Guaranteed" is a much stronger word than any implementation of <code>finally</code> deserves. What is guaranteed is that if execution flows out of the whole <code>try</code>-<code>finally</code> construct, it will pass through the <code>finally</code> to do so. What is not guaranteed is that execution will flow out of the <code>try</code>-<code>finally</code>.</p>
<ul>
<li><p><a href="https://ideone.com/eQZzna" rel="noreferrer">A <code>finally</code> in a generator or async coroutine might never run</a>, if the object never executes to conclusion. There are a lot of ways that could happen; here's one:</p>
<pre><code>def gen(text):
    try:
        for line in text:
            try:
                yield int(line)
            except:
                # Ignore blank lines - but catch too much!
                pass
    finally:
        print('Doing important cleanup')

text = ['1', '', '2', '', '3']

if any(n &gt; 1 for n in gen(text)):
    print('Found a number')

print('Oops, no cleanup.')
</code></pre>
<p>Note that this example is a bit tricky: when the generator is garbage collected, Python attempts to run the <code>finally</code> block by throwing in a <code>GeneratorExit</code> exception, but here we catch that exception and then <code>yield</code> again, at which point Python prints a warning ("generator ignored GeneratorExit") and gives up. See <a href="https://www.python.org/dev/peps/pep-0342/" rel="noreferrer">PEP 342 (Coroutines via Enhanced Generators)</a> for details.</p>
<p>Other ways a generator or coroutine might not execute to conclusion include if the object is just never GC'ed (yes, that's possible, even in CPython), or if an <code>async with</code> <code>await</code>s in <code>__aexit__</code>, or if the object <code>await</code>s or <code>yield</code>s in a <code>finally</code> block. This list is not intended to be exhaustive.</p></li>
<li><p><a href="https://ideone.com/T1LBwb" rel="noreferrer">A <code>finally</code> in a daemon thread might never execute</a> if all non-daemon threads exit first.</p></li>
<li><p><a href="https://ideone.com/2IWOp6" rel="noreferrer"><code>os._exit</code> will halt the process immediately</a> without executing <code>finally</code> blocks.</p></li>
<li><p><code>os.fork</code> may cause <code>finally</code> blocks to <a href="https://ideone.com/taVknD" rel="noreferrer">execute <em>twice</em></a>. As well as just the normal problems you'd expect from things happening twice, this could cause concurrent access conflicts (crashes, stalls, ...) if access to shared resources is not <a href="https://docs.python.org/3.5/library/multiprocessing.html#synchronization-between-processes" rel="noreferrer">correctly synchronized</a>.</p>
<p>Since <code>multiprocessing</code> uses fork-without-exec to create worker processes when using the <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="noreferrer"><em>fork</em> start method</a> (the default on Unix), and then calls <code>os._exit</code> in the worker once the worker's job is done, <code>finally</code> and <code>multiprocessing</code> interaction can be problematic (<a href="https://ideone.com/KPMg2s" rel="noreferrer">example</a>).</p></li>
<li>A C-level segmentation fault will prevent <code>finally</code> blocks from running.</li>
<li><code>kill -SIGKILL</code> will prevent <code>finally</code> blocks from running. <code>SIGTERM</code> and <code>SIGHUP</code> will also prevent <code>finally</code> blocks from running unless you install a handler to control the shutdown yourself; by default, Python does not handle <code>SIGTERM</code> or <code>SIGHUP</code>.</li>
<li>An exception in <code>finally</code> can prevent cleanup from completing. One particularly noteworthy case is if the user hits control-C <em>just</em> as we're starting to execute the <code>finally</code> block. Python will raise a <code>KeyboardInterrupt</code> and skip every line of the <code>finally</code> block's contents. (<code>KeyboardInterrupt</code>-safe code is very hard to write).</li>
<li>If the computer loses power, or if it hibernates and doesn't wake up, <code>finally</code> blocks won't run.</li>
</ul>
<p>The <code>finally</code> block is not a transaction system; it doesn't provide atomicity guarantees or anything of the sort. Some of these examples might seem obvious, but it's easy to forget such things can happen and rely on <code>finally</code> for too much.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes.  <strong>Finally always wins.</strong> </p>
<p>The only way to defeat it is to halt execution before <code>finally:</code> gets a chance to execute (e.g. crash the interpreter, turn off your computer, suspend a generator forever).  </p>
<blockquote>
<p>I imagine there are other scenarios I haven't thought of.</p>
</blockquote>
<p>Here are a couple more you may not have thought about:</p>
<pre><code>def foo():
    # finally always wins
    try:
        return 1
    finally:
        return 2

def bar():
    # even if he has to eat an unhandled exception, finally wins
    try:
        raise Exception('boom')
    finally:
        return 'no boom'
</code></pre>
<p>Depending on how you quit the interpreter, sometimes you can "cancel" finally, but not like this:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; try:
...     sys.exit()
... finally:
...     print('finally wins!')
... 
finally wins!
$
</code></pre>
<p>Using the precarious <a href="https://docs.python.org/3/library/os.html#os._exit" rel="noreferrer"><code>os._exit</code></a> (this falls under "crash the interpreter" in my opinion):</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; try:
...     os._exit(1)
... finally:
...     print('finally!')
... 
$
</code></pre>
<p>I'm currently running this code, to test if finally will still execute after the heat death of the universe:</p>
<pre><code>try:
    while True:
       sleep(1)
finally:
    print('done')
</code></pre>
<p>However, I'm still waiting on the result, so check back here later.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/2.5/whatsnew/pep-341.html" rel="noreferrer">Python documentation</a>:</p>
<blockquote>
<p>No matter what happened previously, the final-block is executed once the code block is complete and any raised exceptions handled. Even if there's an error in an exception handler or the else-block and a new exception is raised, the code in the final-block is still run.</p>
</blockquote>
<p>It should also be noted that if there are multiple return statements, including one in the finally block, then the finally block return is the only one that will execute.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, yes and no.</p>
<p>What is guaranteed is that Python will always try to execute the finally block. In the case where you return from the block or raise an uncaught exception, the finally block is executed just before actually returning or raising the exception.</p>
<p>(what you could have controlled yourself by simply running the code in your question)</p>
<p>The only case I can imagine where the finally block will not be executed is when the Python interpretor itself crashes for example inside C code or because of power outage.</p>
</div>
<div class="post-text" itemprop="text">
<p>To really understand how it works, just run these two examples:</p>
<ul>
<li><pre><code>try:
    1
except:
    print 'except'
finally:
    print 'finally'
</code></pre>
<p>will output </p>
<blockquote>
<p>finally</p>
</blockquote></li>
<li><pre><code>try:
    1/0
except:
    print 'except'
finally:
    print 'finally'
</code></pre>
<p>will output </p>
<blockquote>
<p>except<br/>
  finally</p>
</blockquote></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I found this one without using a generator function:</p>
<pre><code>import multiprocessing
import time

def fun(arg):
  try:
    print("tried " + str(arg))
    time.sleep(arg)
  finally:
    print("finally cleaned up " + str(arg))
  return foo

list = [1, 2, 3]
multiprocessing.Pool().map(fun, list)
</code></pre>
<p>The sleep can be any code that might run for inconsistent amounts of time.</p>
<p>What appears to be happening here is that the first parallel process to finish leaves the try block successfully, but then attempts to return from the function a value (foo) that hasn't been defined anywhere, which causes an exception. That exception kills the map without allowing the other processes to reach their finally blocks.</p>
<p>Also, if you add the line <code>bar = bazz</code> just after the sleep() call in the try block. Then the first process to reach that line throws an exception (because bazz isn't defined), which causes its own finally block to be run, but then kills the map, causing the other try blocks to disappear without reaching their finally blocks, and the first process not to reach its return statement, either.</p>
<p>What this means for Python multiprocessing is that you can't trust the exception-handling mechanism to clean up resources in all processes if even one of the processes can have an exception. Additional signal handling or managing the resources outside the multiprocessing map call would be necessary.</p>
</div>
<span class="comment-copy">The only case I can imagine <code>finally</code> fail to execute or "defeat its purpose" is during an infinite loop, <code>sys.exit</code> or a forced interrupt. The <a href="https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions" rel="nofollow noreferrer">documentation</a> states that <code>finally</code> is always executed, so I'd go with that.</span>
<span class="comment-copy">A bit of lateral thinking and sure not what you asked, but I'm pretty sure that if you open Task Manager and kill the process, <code>finally</code> will not run. Or the same if the computer crashes before :D</span>
<span class="comment-copy"><code>finally</code> will not execute if the power cord is ripped from the wall.</span>
<span class="comment-copy">You might be interested in this answer to the same question about C#: <a href="https://stackoverflow.com/a/10260233/88656">stackoverflow.com/a/10260233/88656</a></span>
<span class="comment-copy">Block it on an empty semaphore.  Never signal it.  Done.</span>
<span class="comment-copy">I believe only the first point of your list is really relevant, and there is an easy way to avoid it: 1) never use a bare <code>except</code>, and never catch <code>GeneratorExit</code> inside a generator. The points about threads/killing the process/segfaulting/power off are expected, python can't do magic. Also: exceptions in <code>finally</code> are obviously a problem but this does not change the fact that the control flow <i>was</i> moved to the <code>finally</code> block. Regarding <code>Ctrl+C</code>, you can add a signal handler that ignores it, or simply "schedules" a clean shutdown after the current operation is completed.</span>
<span class="comment-copy">The mentioning of <i>kill -9</i> is technically correct, but a bit unfair. No program written in any language runs any code upon receiving a kill -9. In fact, no program ever <b>receives</b> a kill -9 at all, so even if it wanted to, it couldn't execute anything. That's the whole point of kill -9.</span>
<span class="comment-copy">@Tom: The point about <code>kill -9</code> didn't specify a language. And frankly, it needs repeating, because it sits in a blind spot. Too many people forget, or don't realize, that their program could be stopped dead in its tracks without even being allowed to clean up.</span>
<span class="comment-copy">@GiacomoAlzetta: There are people out there relying on <code>finally</code> blocks as if they provided transactional guarantees. It might seem obvious that they don't, but it's not something everyone realizes. As for the generator case, there are a lot of ways a generator might not be GC'ed at all, and a lot of ways a generator or coroutine might accidentally yield after <code>GeneratorExit</code> even if it doesn't catch the <code>GeneratorExit</code>, for example if an <code>async with</code> suspends a coroutine in <code>__exit__</code>.</span>
<span class="comment-copy">@user2357112 yeah - I've been trying for decades to get devs to clean up temp files etc. on app startup, not exit.  Relying on the so-called 'clean up and graceful termination', is asking for disappointment and tears:)</span>
<span class="comment-copy">or having an i finite loop in try catch</span>
<span class="comment-copy"><a href="https://ideone.com/eQZzna" rel="nofollow noreferrer"><code>finally</code> in a generator or coroutine can quite easily fail to execute</a>, without going anywhere near a "crash the interpreter" condition.</span>
<span class="comment-copy">After the heat death of the universe time ceases to exist, so <code>sleep(1)</code> would definitely result in undefined behaviour. :-D</span>
<span class="comment-copy">You may want to mention _os.exit directly after “the only way to defeat it is to crash the compiler”. Right now it’s mixed inbeteween examples where finally wins.</span>
<span class="comment-copy">@StevenVascellaro  I don't think that's necessary - <code>os._exit</code> is, for all practical purposes, the same as inducing a crash (unclean exit).  The correct way to exit is <code>sys.exit</code>.</span>
<span class="comment-copy">ha ha .. or there is a infinite loop in try catch</span>
<span class="comment-copy">Is it uncatched or uncaught?</span>
<span class="comment-copy">@StanStrum: Fixed. Sorry for the mistake, but English is not my first language...</span>
<span class="comment-copy">@SergeBallesta No biggie. At least here in rural UK plenty of people say "catched". Natives too.</span>
<span class="comment-copy">I think "Well, yes and no" is most correct. <i>Finally: always wins</i> where "always" means the interpreter is able to run and the code for the "finally:" is still available, and "wins" is defined as the interpreter will try to run the finally: block and it will succeed. That's the "Yes" and it is very conditional.   "No" is all the ways the interpreter might stop before "finally:"- power failure, hardware failure, kill -9 aimed at the interpreter, errors in the interpreter or code it depends on, other ways to hang the interpreter.  And ways to hang inside the "finally:".</span>
