<div class="post-text" itemprop="text">
<p>In order to ensure that passwords are always stored, hashed and salted in the database, I decided to use a descriptor which will automatically hash the password when one is provided, e.g user.password = "jinja125".</p>
<p>Here is my code</p>
<pre><code>from random import SystemRandom
from backports.pbkdf2 import pbkdf2_hmac, compare_digest

# ...snip...    

@password.setter
def password(self, value):
    # When a user is first created, give them a salt
    if self._salt is None:
        self._salt = bytes(SystemRandom().getrandbits(128))
    self._password = self._hash_password(value)
</code></pre>
<p>However when I try to run some tests, I get this error.</p>
<pre><code>File "C:\Users\User\flask-python\site-tracker\app\users\models.py", line 34, in password
    self._salt = bytes(random.SystemRandom().getrandbits(simple_bit_counts))
OverflowError: cannot fit 'int' into an index-sized integer
</code></pre>
<p>How can I best fix this error?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/random.html#random.getrandbits" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>random.getrandbits(k)
  Returns a python long int with <strong>k random bits</strong>.</p>
</blockquote>
<p>Here <code>k==128</code> so <code>1&lt;&lt;128</code></p>
<p>check the size value you're trying to create a <code>bytes</code> array from (for instance):</p>
<pre><code>&gt;&gt;&gt; random.SystemRandom().getrandbits(128)
135192632488754159854542557748438253357
</code></pre>
<p>That's way too big for array indexing, not to mention the memory. You may want to reduce drastically your value. I suppose you meant <code>2**7</code> (7-bit random) not <code>1&lt;&lt;128</code></p>
<p>now if you wanted to generate 128 random <em>bytes</em>, you'd do that instead:</p>
<pre><code>&gt;&gt;&gt; bytes(random.randrange(0,255) for _ in range(128))
b'\xc9\x8fC\t\xe0\xc8\x8a5\xe4\xafb\xb5c.\x91\xea\x9aqUL\x11\x8d\xe4\xe3W\x87\xecM\xf8K\xa8\xf8\xbb\xb5 \x14H\xda\x1d]L\x13[n*\x87W\xd8\x90v\xfd\x8cQ\xdcY\xe4^\x95h8\xdc\'\x8e\xcb:\xea\xfbF\xf1zh8\xf63\x18WeV\xc6)\xce\xf9*w&gt;\x83e\x0b#"\xf2\x97\xcf\xc2!\xddj\xb2\xbePl\xa2\r\xa7T\x8f\x14\x13\xa4\x1c\xeax\xacMJ2\x88A,\x11\xdev\xe1\xf8\x9b\x12\xd9c'
</code></pre>
<p>no need to call <code>getrandbits</code> for that. As Amadan noted, maybe you want 128 bits, not bytes, so make that <code>range(16)</code> instead. Well, now that you know, you can adjust to your actual needs.</p>
</div>
<span class="comment-copy">He probably meant <code>128</code>, but misused <code>bytes</code> - I think he wanted b'????????????????', a sixteen-byte string, not a <code>135192632488754159854542557748438253357</code>-length array.</span>
<span class="comment-copy">yes, I don't know what the user wanted exactly, but there's a wrong magnitude order :)...</span>
<span class="comment-copy">This also works, in Python3: <code>SystemRandom().getrandbits(128).to_bytes(16, 'little')</code>, to stay a bit close to OP's initial idea. (Also note, 128 random <i>bits</i> is <i>16</i> random bytes, not 128)</span>
<span class="comment-copy">@Amadan true, and true again. You could post an answer about that, mind. I'm not going to put that in my answer since I wasn't aware of that feature.</span>
