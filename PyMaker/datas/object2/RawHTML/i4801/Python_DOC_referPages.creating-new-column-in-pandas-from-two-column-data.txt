<div class="post-text" itemprop="text">
<p>I have a following <code>DataFrame</code>:</p>
<pre><code>from pandas import *
df = DataFrame({'foo':['a','b','c'], 'bar':[1, 2, 3]})
</code></pre>
<p>It looks like this:</p>
<pre><code>    bar foo
0    1   a
1    2   b
2    3   c
</code></pre>
<p>Now I want to have something like:</p>
<pre><code>     bar
0    1 is a
1    2 is b
2    3 is c
</code></pre>
<p>How can I achieve this?
I tried the following:</p>
<pre><code>df['foo'] = '%s is %s' % (df['bar'], df['foo'])
</code></pre>
<p>but it gives me a wrong result:</p>
<pre><code>&gt;&gt;&gt;print df.ix[0]

bar                                                    a
foo    0    a
1    b
2    c
Name: bar is 0    1
1    2
2
Name: 0
</code></pre>
<p>Sorry for a dumb question, but this one <a href="https://stackoverflow.com/questions/10972410/pandas-combine-two-columns-in-a-dataframe">pandas: combine two columns in a DataFrame</a> wasn't helpful for me.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>df['bar'] = df.bar.map(str) + " is " + df.foo</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem in your code is that you want to apply the operation on every row. The way you've written it though takes the whole 'bar' and 'foo' columns, converts them to strings and gives you back one big string. You can write it like:</p>
<pre><code>df.apply(lambda x:'%s is %s' % (x['bar'],x['foo']),axis=1)
</code></pre>
<p>It's longer than the other answer but is more generic (can be used with values that are not strings).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also use</p>
<pre><code>df['bar'] = df['bar'].str.cat(df['foo'].values.astype(str), sep=' is ')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here are more solutions, in increasing order of performance.</p>
<h3><strong><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.agg.html" rel="nofollow noreferrer"><code>DataFrame.agg</code></a></strong></h3>
<p>This is a simple <a href="https://pyformat.info" rel="nofollow noreferrer"><code>str.format</code></a>-based approach.</p>
<pre><code>df['baz'] = df.agg('{0[bar]} is {0[foo]}'.format, axis=1)
df
  foo  bar     baz
0   a    1  1 is a
1   b    2  2 is b
2   c    3  3 is c
</code></pre>
<p>You can also use f-string formatting here:</p>
<pre><code>df['baz'] = df.agg(lambda x: f"{x['bar']} is {x['foo']}", axis=1)
df
  foo  bar     baz
0   a    1  1 is a
1   b    2  2 is b
2   c    3  3 is c
</code></pre>
<hr/>
<h3><strong><a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.chararray.html" rel="nofollow noreferrer"><code>char.array</code></a>-based Concatenation</strong></h3>
<p>Convert the columns to concatenate as <code>chararrays</code>, then add them together.</p>
<pre><code>a = np.char.array(df['bar'].values)
b = np.char.array(df['foo'].values)

df['baz'] = (a + b' is ' + b).astype(str)
df
  foo  bar     baz
0   a    1  1 is a
1   b    2  2 is b
2   c    3  3 is c
</code></pre>
<hr/>
<h3><strong><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">List Comprehension</a> with <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a></strong></h3>
<p>I cannot overstate how underrated list comprehensions are in pandas.  </p>
<pre><code>df['baz'] = [str(x) + ' is ' + y for x, y in zip(df['bar'], df['foo'])]
</code></pre>
<p></p>
<p>Alternatively, using <code>str.join</code> to concat (will also scale better):</p>
<pre><code>df['baz'] = [
    ' '.join([str(x), 'is', y]) for x, y in zip(df['bar'], df['foo'])]
</code></pre>
<p></p>
<pre><code>df
  foo  bar     baz
0   a    1  1 is a
1   b    2  2 is b
2   c    3  3 is c
</code></pre>
<p>List comprehensions excel in string manipulation, because string operations are inherently hard to vectorize, and most pandas "vectorised" functions are basically wrappers around loops. I have written extensively about this topic in <a href="https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care">For loops with pandas - When should I care?</a>. In general, if you don't have to worry about index alignment, use a list comprehension when dealing with string and regex operations. </p>
<p>The list comp above by default does not handle NaNs. However, you could always write a function wrapping a try-except if you needed to handle it.</p>
<pre><code>def try_concat(x, y):
    try:
        return str(x) + ' is ' + y
    except (ValueError, TypeError):
        return np.nan


df['baz'] = [try_concat(x, y) for x, y in zip(df['bar'], df['foo'])]
</code></pre>
<hr/>
<h3><strong><code>perfplot</code> Performance Measurements - Setup and Timings</strong></h3>
<p>We can time these solutions using <code>perfplot</code>:</p>
<pre><code>data = {'bar': {0: 1, 1: 2, 2: 3}, 'foo': {0: 'a', 1: 'b', 2: 'c'}}
df_ = pd.DataFrame(data)

perfplot.show(
    setup=lambda n: pd.concat([df_] * n, ignore_index=True),
    kernels=[
        brenbarn, danielvelkov, chrimuelle, vladimiryashin, erickfis, 
        cs1_format, cs1_fstrings, cs2, cs3
    ],
    labels=[
        'brenbarn', 'danielvelkov', 'chrimuelle', 'vladimiryashin', 'erickfis', 
        'cs1_format', 'cs1_fstrings', 'cs2', 'cs3'
    ],
    n_range=[2**k for k in range(0, 8)],
    xlabel='N (x len(df_))',    
    logy=True,
    equality_check=lambda x, y: (x == y).values.all()
)
</code></pre>
<p><a href="https://i.stack.imgur.com/skyQe.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/skyQe.png"/></a></p>
<p>The performance is relative; the plot is logarithmic along the Y-axis.</p>
<p><strong>Functions</strong></p>
<pre><code>def brenbarn(df):
    return df.assign(baz=df.bar.map(str) + " is " + df.foo)

def danielvelkov(df):
    return df.assign(baz=df.apply(
        lambda x:'%s is %s' % (x['bar'],x['foo']),axis=1))

def chrimuelle(df):
    return df.assign(
        baz=df['bar'].astype(str).str.cat(df['foo'].values, sep=' is '))

def vladimiryashin(df):
    return df.assign(baz=df.astype(str).apply(lambda x: ' is '.join(x), axis=1))

def erickfis(df):
    return df.assign(
        baz=df.apply(lambda x: f"{x['bar']} is {x['foo']}", axis=1))

def cs1_format(df):
    return df.assign(baz=df.agg('{0[bar]} is {0[foo]}'.format, axis=1))

def cs1_fstrings(df):
    return df.assign(baz=df.agg(lambda x: f"{x['bar']} is {x['foo']}", axis=1))

def cs2(df):
    a = np.char.array(df['bar'].values)
    b = np.char.array(df['foo'].values)

    return df.assign(baz=(a + b' is ' + b).astype(str))

def cs3(df):
    return df.assign(
        baz=[str(x) + ' is ' + y for x, y in zip(df['bar'], df['foo'])])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>df.astype(str).apply(lambda x: ' is '.join(x), axis=1)

0    1 is a
1    2 is b
2    3 is c
dtype: object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@DanielVelkov answer is the proper one BUT
using string literals is 10 times faster</p>
<pre><code># Daniel's
%timeit df.apply(lambda x:'%s is %s' % (x['bar'],x['foo']),axis=1)

# String literals - python 3
%timeit df.apply(lambda x: f"{x['bar']} is {x['foo']}", axis=1)
</code></pre>
</div>
<span class="comment-copy">For more performant options on string column concatenation, including a performance comparison of all the answers here, see <a href="https://stackoverflow.com/a/54298586/4909087">this answer</a>.</span>
<span class="comment-copy">This doesn't work since df['bar'] is not a string column. The correct assignment is <code>df['bar'] = df['bar'].astype(str).str.cat(df['foo'], sep=' is ')</code>.</span>
<span class="comment-copy">That's all I always wanted to know about string concatenation in pandas, but was too afraid too ask!</span>
