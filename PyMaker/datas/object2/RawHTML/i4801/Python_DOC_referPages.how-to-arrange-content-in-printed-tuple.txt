<div class="post-text" itemprop="text">
<p>I am trying to arrange content in a tuple to fit a specific column layout.</p>
<p>Example layout:</p>
<pre><code>PETER PAUL            MALE            100000
MARGARET              FEMALE          1000
MICHAEL JORDAN        MALE            1
AGNES                 FEMALE          200
</code></pre>
<p>But when I iterate over the tuple to print the contents, it outputs:</p>
<pre><code>PETER PAUL            MALE            100000
MARGARET             FEMALE            1000
MICHAEL JORDAN            MALE            1
AGNES            FEMALE            200
</code></pre>
<p>Also when I <code>return row</code>, it only returns the first <code>tuple</code> and not all of them. I am returning it because I want to use it in another function.</p>
<p>This is the code below:</p>
<pre><code>def text():
    rows = (("PETER PAUL", "MALE", "100000"), ("MARGARET ", "FEMALE", "1000"), ("MICHAEL JORDAN", "MALE", "1"),("AGNES", "FEMALE", "200"))

    for row in rows:
       # print("          ".join(row))
        print("".join(row[0]), "".join("          "), "".join(row[1]), "".join("          "), "".join(row[2]))
        #return row

text()
</code></pre>
<p>I use the <code>join</code> method, but I couldn't find <code>ljust</code>, which I think is no longer available in <code>python3</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use Python's string <a href="https://docs.python.org/3/library/functions.html?highlight=format#format" rel="nofollow noreferrer"><code>.format()</code></a> to give each of your elements a fixed width:</p>
<pre><code>def text():
    rows = (("PETER PAUL", "MALE", "100000"), ("MARGARET ", "FEMALE", "1000"), ("MICHAEL JORDAN", "MALE", "1"),("AGNES", "FEMALE", "200"))

    for row in rows:
        print('{:20} {:8} {}'.format(*row))

text()   
</code></pre>
<p>Giving you:</p>
<pre><code>PETER PAUL           MALE     100000
MARGARET             FEMALE   1000
MICHAEL JORDAN       MALE     1
AGNES                FEMALE   200
</code></pre>
<p>The <code>format()</code> command works by replacing each <code>{}</code> seen in the string by an argument passed to it, in this case <code>*row</code>. The <code>*</code> has the effect of expanding the three values inside <code>row</code> to be the three arguments required to be expanded.</p>
<hr/>
<p>To return the formatted text, you would need to first create a list of formatted rows, and then use <code>'\n'.join()</code> to join them all together will newlines at the end:</p>
<pre><code>def text():
    rows = (("PETER PAUL", "MALE", "100000"), ("MARGARET ", "FEMALE", "1000"), ("MICHAEL JORDAN", "MALE", "1"),("AGNES", "FEMALE", "200"))

    data = []

    for row in rows:
        data.append('{:20} {:8} {}'.format(*row))

    return '\n'.join(data)

print(text())
</code></pre>
<p>This could also be done very neatly using a Python "list comprehension" as follows:</p>
<pre><code>def text():
    rows = (("PETER PAUL", "MALE", "100000"), ("MARGARET ", "FEMALE", "1000"), ("MICHAEL JORDAN", "MALE", "1"),("AGNES", "FEMALE", "200"))
    return '\n'.join('{:20} {:8} {}'.format(*row) for row in rows)

print(text())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use inline formating:</p>
<pre><code>def text():
    t = []
    rows = (("PETER PAUL", "MALE", "100000"),  ("MARGARET ", "FEMALE", "1000"), 
            ("MICHAEL JORDAN", "MALE", "1"),   ("AGNES", "FEMALE", "200"))

    for row in rows:
        t.append(f'{row[0]:&lt;30}{row[1]:&lt;10}{row[2]:&lt;20}') 

    return t

for n in text():
    print(n) 
</code></pre>
<p>Output:</p>
<pre><code>PETER PAUL                    MALE      100000              
MARGARET                      FEMALE    1000                
MICHAEL JORDAN                MALE      1                   
AGNES                         FEMALE    200    
</code></pre>
<p>Formatting:</p>
<ul>
<li><a href="https://docs.python.org/3.4/library/string.html#formatspec" rel="nofollow noreferrer">formatting language</a></li>
</ul>
<p><code>&lt;20</code> for strings is not needed as left-adjust is the default, if you need to right-adjust use <code>&gt;20</code>. See link for more infos about formatting language constructs.</p>
</div>
<span class="comment-copy">Use <code>.format()</code> or f-strings.</span>
<span class="comment-copy">please can you demonstrate it for me or any link to find the documentation on that</span>
<span class="comment-copy">Don't you know how to look up the documentation of built-in Python functions? Just google "python format".</span>
<span class="comment-copy">When I use return it returns only the first tuple how can make it to return all the content</span>
<span class="comment-copy">Why not use <code>return rows</code> ?</span>
<span class="comment-copy">It doesn't work once i bring return there it returns only the first tuple</span>
<span class="comment-copy">Are you wanting to return all of the formatted text?</span>
<span class="comment-copy">Yes just like the printed one on the terminal</span>
<span class="comment-copy">When I use return it returns only the first tuple how can make it to return all the content</span>
<span class="comment-copy">@LAS Updated to return all strings as list - they do not have \n at end, you you need to add that or print the strings separately</span>
<span class="comment-copy">when i return the the content for another function it output <code>PETER PAUL MALE 100000MARGARET FEMALE 1000MICHAEL JORDAN</code> not like the how it printed to the terminal .how can it be that the second tuple will state from newline</span>
<span class="comment-copy">@Las - you did read my last comment - did you? use <code>'\n'.join(text())+'\n'</code> to have a newline after each line or use <code>'linesWithNewlineAtEnd = [f'{x}\n' for x in test()]</code> to create a list that includes newlines - or modify <code>'t.append(f'{row[0]:&lt;30}{row[1]:&lt;10}{row[2]:&lt;20}')'</code> to <code>'t.append(f'{row[0]:&lt;30}{row[1]:&lt;10}{row[2]:&lt;20}\n')'</code> - try to understand the solution you copy and modify it to your needs...</span>
