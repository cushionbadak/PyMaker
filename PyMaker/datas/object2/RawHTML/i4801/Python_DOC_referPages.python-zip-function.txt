<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3940072/exhausted-iterators-what-to-do-about-them">exhausted iterators - what to do about them?</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/31683959/the-zip-function-in-python-3">The zip() function in Python 3 [duplicate]</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/14637154/performing-len-on-list-of-a-zip-object-clears-zip">Performing len on list of a zip object clears zip [duplicate]</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<pre><code>t1 = ("a", "b", "c", "d")
t2 = (1, 2, 3, 4)
z = zip(t1, t2)
print(list(z))
print(dict(z))
</code></pre>
<p>It seems like we can cast the zip object only once. After <code>z = zip(t1, t2)</code> only the first casting either <code>list(z)</code> or <code>dict(z)</code> works and the other one does not work. Why is it so ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to use the itertools.tee() function to create a second version of your generator:</p>
<pre><code>from itertools import tee
t1 = ("a", "b", "c", "d")
t2 = (1, 2, 3, 4)
z,z_backup = tee(zip(t1, t2))
print(list(z))
print(dict(z_backup))
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip returns a generator in python3</a></span>
<span class="comment-copy">To reiterate @bro-grammer, a generator instance that has been exhausted does not restart. You must redefine the generator, e.g. by feeding directly into <code>list</code>: <code>list(zip(t1, t2))</code>.</span>
<span class="comment-copy">@bro-grammer then vote it as such.</span>
<span class="comment-copy">@jpp please post it as answer, so that I can accept it as the solution</span>
<span class="comment-copy">@AkshayJ, no need - this is a duplicate.</span>
<span class="comment-copy">Beware, for simple tuples as sources this is fine, but if <code>t1</code> and <code>t2</code> are infinite, <code>tee</code>ing them will buffer all data consumed by only one of the tees, which could produce exploding memory consumption if you're not careful.  In your example, after the next-to-last line executes, the entire <code>zip</code>ped data is buffered!</span>
<span class="comment-copy">Note: If you'll end up running out one of the <code>tee</code>d generators to exhaustion before even beginning to iterate the other, you're better off constructing a <code>list</code>/<code>tuple</code> from the original generator and iterating it an arbitrary number of times. <code>tee</code> would have to store the same data as the <code>list</code>/<code>tuple</code>, but imposes additional overhead; the overhead is only worth it if you're advancing the <code>tee</code>-ed generators in parallel (or close to it) where the cache stays small. In this case, just doing <code>z = tuple(zip(t1, t2))</code>, then <code>print(list(z))</code>, <code>print(dict(z))</code> makes more sense.</span>
