<div class="post-text" itemprop="text">
<p>I have a nest-list like bellow:</p>
<pre><code>list = [
    [1, 2, 4, 5],
    [2, 3, 4, 5],
    [1, 3, 4, 5, 6],
    [1, 2, 3],
]
</code></pre>
<p>I want to get a dictionary to show the number display count, the dictionary should like bellow:</p>
<pre><code>{ '1': 3, 
  '2': 3, 
  '3': 3, 
  '4': 3, 
  '5': 3, 
  '6': 1 }
</code></pre>
<p>how to get this? </p>
</div>
<div class="post-text" itemprop="text">
<p>First the list can be flattened by combining all elements (<em>taking inner elements out of list</em>) to single list and then using Counter:</p>
<pre><code>from collections import Counter
dict(Counter(inneritem for item in list for inneritem in item))
</code></pre>
<p>Result:</p>
<pre><code>{1: 3, 2: 3, 3: 3, 4: 3, 5: 3, 6: 1}
</code></pre>
<p>If you want the item as key, may be converting each item to string and passing them to <code>Counter</code>:</p>
<pre><code>dict(Counter(str(inneritem) for item in list for inneritem in item))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First change your variable from <code>list</code> to something else say <code>my_list</code></p>
<p>Your need to first flatten your list and then count the element using counter.</p>
<pre><code>from collections import Counter
from itertools import chain

print(dict(Counter(chain(*my_list))))

out:
{1: 3, 2: 3, 4: 3, 5: 3, 3: 3, 6: 1}
</code></pre>
<p>You can also use list comprehension if you want to change like data type in your case</p>
<pre><code>print(
    dict(
        Counter(
            [
                str(item)
                for sub_list in my_list
                    for item in sub_list
            ]
        )
    )
)# or
#print(dict(Counter([str(item) for sub_list in my_list for item in sub_list])))
out:
{'1': 3, '2': 3, '4': 3, '5': 3, '3': 3, '6': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is very easily to do this, just one line code:</p>
<pre><code>import collections

lst = [
    [1, 2, 4, 5],
    [2, 3, 4, 5],
    [1, 3, 4, 5, 6],
    [1, 2, 3],
]
dict(collections.Counter(sum(lst, [])))
</code></pre>
<p>Please DO NOT use <code>list</code> as your variable name, here i use <code>lst</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>lst = [
    [1, 2, 4, 5],
    [2, 3, 4, 5],
    [1, 3, 4, 5, 6],
    [1, 2, 3],
]

d = {}
def ravel(lst):
    if not isinstance(lst, list):
        if lst not in d: 
            d[lst] = 1
        else: 
            d[lst] += 1
    elif lst:
        for i in lst:
            ravel(i)

ravel(lst)
print d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>list = [
    [1, 2, 4, 5],
    [2, 3, 4, 5],
    [1, 3, 4, 5, 6],
    [1, 2, 3],
]

tmp = {}
for item_list in list:
    for item in item_list:
        if str(item) in tmp.keys():
            tmp[str(item)] += 1
        else:
            tmp[str(item)] = 1

print(tmp)
</code></pre>
<p>the result:</p>
<pre><code>{'1': 3, '2': 3, '3': 3, '4': 3, '5': 3, '6': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just one line for the actual logic (chain your <code>list</code> and apply <code>Counter</code> to it):</p>
<pre><code>from collections import Counter
from itertools import chain


Counter(chain.from_iterable(list))
</code></pre>
<p>PS. Consider renaming your variable name <code>list</code> to something else as it is a Python keyword.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, you have a list of lists, and want to add the sum of the number of times a value appears in the list of lists (1-6), and want to the sum of times the value appears as the value in a dict, and the specific number (1-6) will be the "key" of the dict. Here is some code below that can get you your desired output: </p>
<pre><code> list_ = [
[1, 2, 4, 5],
[2, 3, 4, 5],
[1, 3, 4, 5, 6],
[1, 2, 3],
]
one = []
two = []
three = []
four = []
five = []
six = []

for num in list_[0]:
       if num == 1:
           one.append(num)

       if num == 2:
           two.append(num)

       if num == 3:
           three.append(num)

       if num == 4:
           four.append(num)

       if num == 5:
           five.append(num)

       if num == 6:
           six.append(num)


for num in list_[1]:
       if num == 1:
           one.append(num)

       if num == 2:
           two.append(num)

       if num == 3:
           three.append(num)

       if num == 4:
           four.append(num)

       if num == 5:
           five.append(num)

       if num == 6:
           six.append(num)


for num in list_[2]:
       if num == 1:
           one.append(num)

       if num == 2:
           two.append(num)

       if num == 3:
           three.append(num)

       if num == 4:
           four.append(num)

       if num == 5:
           five.append(num)

       if num == 6:
           six.append(num)

for num in list_[3]:
       if num == 1:
           one.append(num)

       if num == 2:
           two.append(num)

       if num == 3:
           three.append(num)

       if num == 4:
           four.append(num)

       if num == 5:
           five.append(num)

       if num == 6:
           six.append(num)


list_dict = {}

list_dict['1'] = len(one)

list_dict['2'] = len(two)

list_dict['3'] = len(three)

list_dict['4'] = len(four)

list_dict['5'] = len(five)

list_dict['6'] = len(six)

print(list_dict)
</code></pre>
<p>Your output will be the dictionary that you wanted with the keys being the number and the values being the number of times that particular number appeared in your list of lists. Here the output:</p>
<pre><code>{'1': 3, '2': 3, '3': 3, '4': 3, '5': 3, '6': 1}
</code></pre>
<ol>
<li>I created your list of lists (nested-list). </li>
<li>I created empty lists that will store each of the 6 numbers. </li>
<li>I created four for loops (one for each index in your list of lists) that appends each number to its corresponding empty list. </li>
<li>After I did that for each index I created an empty dictionary called list_dict. I made the keys of the dictionary the numbers that you wanted (1-6), and the values are the length of the empty dictionaries that we created earlier that now hold each occurrence of the number from your list of lists. This will get you the output that you are looking for. </li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You can simply do:</p>
<pre><code>list1 = [
    [1, 2, 4, 5],
    [2, 3, 4, 5],
    [1, 3, 4, 5, 6],
    [1, 2, 3],
]

count={}

for i in list1:
  for j in i:
    if j not in count:
      count[j]=1
    else:
      count[j]+=1

print(count)
</code></pre>
<p>output:</p>
<pre><code>{1: 3, 2: 3, 3: 3, 4: 3, 5: 3, 6: 1}
</code></pre>
</div>
<span class="comment-copy">It's hard to tell from your explanation. but are you just looking for <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>?</span>
<span class="comment-copy"><code>list</code> is reserved keyword in python3. please choose other name.</span>
<span class="comment-copy">@Rahul It's not a reserved keyword. If it were, his code would be a <code>SyntaxError</code>. It <i>is</i> a builtin name, however, which is why it's bad to reuse it—if you need to, e.g., make a list out of a tuple, you can't call <code>list(tup)</code> anymore, because <code>list</code> now means the user's list instead of the builtin list type.</span>
<span class="comment-copy">Its built in class. If you use it as variable you will ovwrride builtin and many thing might not work which relies on it like <code>list(iterable)</code> which converts any iterable to list, <code>defaultdict(list)</code> which creates default dict of list etc. So in a way is reserved.</span>
<span class="comment-copy">@abarnert similarly <code>dict, tuple</code> are also reserved.</span>
<span class="comment-copy">The last one does seem to be what he wants, although I have no idea why he wants to stringify his numbers.</span>
<span class="comment-copy">As per the question, keys in the output <code>dict</code> are <code>str</code>. Anyways I like this one +1</span>
<span class="comment-copy">noted. Thanks..</span>
<span class="comment-copy"><code>sum</code> over sequences is a bad idea. A nested comprehension, <code>chain.from_iterable</code>, or any of the alternatives is going to be at least as clear, and not have the quadratic performance problem.</span>
<span class="comment-copy">@abarnert yes！but here just because the question is no efficient require .</span>
<span class="comment-copy">why this much fuss. it's simple. see other's answer.</span>
<span class="comment-copy">I personally typically don't look at other answers, but each user is different. Why? Because in theory, as many answers as many different ways as possible gives the OP more options. When I ask a question, I personally welcome as many answers as possible for that reason. I get to learn more. There are a million ways to do things in Python, which may not be the quickest for one problem, but may be the best for another, so I personally like as many answers as possible, but each poster is different and I respect that. I get your point Rahul.</span>
<span class="comment-copy">@Rahul I was assuming that the list may be multiply nested. Is there a simple way in Python to flatten multiply nested list? Thank you.</span>
<span class="comment-copy">see my answer..</span>
<span class="comment-copy">@Rahul I tried your answer, but it is not correct.  Here is the inpurt list: 	my_list = [ 		[1, 2, 4, 5], 		[2, 3, 4, 5], 		[1, 3, 4, 5, 6], 		[1, [2, 3], 3] 	] Your first solution raises an exception: unhashable type: 'list' Other solutions output: 	{'1': 3, '[2, 3]': 1, '3': 3, '2': 2, '5': 3, '4': 3, '6': 1} The nested list [2, 3] is not flattened.</span>
<span class="comment-copy">list is reserved keyword. Please don't practice this at least while you are answering.</span>
