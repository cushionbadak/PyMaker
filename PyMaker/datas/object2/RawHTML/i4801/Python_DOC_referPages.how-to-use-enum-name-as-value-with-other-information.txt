<div class="post-text" itemprop="text">
<p>I've researched this and found similar answers, but they don't work in this case because <code>auto()</code> is resolved earlier than <code>__new__</code> is called and only if the whole value is <code>_auto_null</code>.</p>
<p>Basically, what I want is the following:</p>
<pre><code>class MyEnum(str, Enum):
    one = '1 data'
    two = '2 data'

    def __new__(cls, data):
        member = str.__new__(cls, &lt;NEED NAME HERE&gt;)
        member.data = data
        member._value_ = &lt;NEED NAME HERE&gt;

assert MyEnum.one == 'one'
assert MyEnum.one.value == 'one'
assert MyEnum.one.data == '1 data'
</code></pre>
<p>However, the name isn't passed into <code>__new__</code> so there's nothing to fill in <code>&lt;NEED NAME HERE&gt;</code> with.</p>
<p>Then, I tried to use <code>auto()</code> in the following way:</p>
<pre><code>class MyEnumBase(Enum):
    def _generate_next_value_(name, start, count, last_values):
        return name

class MyEnum(str, MyEnumBase):
    one = '1 data'
    two = '2 data'

    def __new__(cls, data):
        member = str.__new__(cls, auto())
        member.data = data
        member._value_ = auto()

assert MyEnum.one == 'one'
assert MyEnum.one.value == 'one'
assert MyEnum.one.data == '1 data'
</code></pre>
<p>This doesn't work because <code>auto()</code> is only resolved when used as the sole value when defining a member, as in <code>one = auto()</code>.  So it seems it's not even possible to do <code>one = auto(), '1 data'</code> and then take both of those parameters in the <code>__new__</code> function.  </p>
<pre><code>class MyEnum(str, MyEnumBase):
    one = auto(), '1 data'
    two = auto(), '2 data'

    def __new__(cls, name, data):
        member = str.__new__(cls, name)
        member.data = data
        member._value_ = name
</code></pre>
<p>It seems my only option is to hardcode the name:</p>
<pre><code>one = 'one', '1 data'
</code></pre>
<p>and define the <code>__new__</code> function to take two params:</p>
<pre><code>def __new__(cls, name, data):
    ...
</code></pre>
<p>Am I missing something? Is there a better way to do this? A better way to structure this information? </p>
</div>
<div class="post-text" itemprop="text">
<p>This is definitely advanced behavior, so to use it you'll need the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>aenum</code></a><sup>1</sup> library instead.</p>
<p>That code will look like:</p>
<pre><code>from aenum import Enum, AutoValue

class MyEnum(str, Enum, settings=AutoValue, init='value data'):

    def __new__(cls, name, *args, **kwds):
        obj = str.__new__(cls, name)
        obj._value_ = name
        return obj

    def _generate_next_value_(name, start, count, last_values, *args, **kwds):
        return (name, ) + args

    one = '1 data'
    two = '2 data'
</code></pre>
<p>The <code>init</code> setting says what the given values should be used for; in this case:</p>
<ul>
<li>the <code>value</code> for each member</li>
<li>the <code>data</code> attribute for each member</li>
</ul>
<p><code>AutoValue</code> instructs <code>aenum</code> to create a value if one is missing -- since each member is only being provided with one piece of information, and <code>init</code> says there should be two, <code>AutoValue</code> will attempt to provide the missing piece.</p>
<p><code>_generate_next_value_</code> is (one of) the mechanism(s) used to do so, which in this case adds the <code>name</code> to the given <code>data</code>, which is then passed into <code>__new__</code>.</p>
<p><code>__new__</code> uses the <code>name</code> as it's value and ignores the rest</p>
<p><code>__init__</code> is automatically generated to handle the non-value items, so it sets the <code>data</code> attribute</p>
<hr/>
<p>For those still using Python 2.7, or need their code to work for 2.7 as well 3.x, the above class should look like this (all changes are in the first block):</p>
<pre><code>class MyEnum(str, Enum):
    _order_ = 'one two'          # only if order actually matters
    _settings_ = AutoValue
    _init_ = 'value data'

    def __new__(cls, name, *args, **kwds):
        obj = str.__new__(cls, name)
        obj._value_ = name
        return obj

    def _generate_next_value_(name, start, count, last_values, *args, **kwds):
        return (name, ) + args

    one = '1 data'
    two = '2 data'
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<span class="comment-copy">Multiple inheritance, enum metaclasses, oh my!  I'm sure Ethan Furman will be with you in just a moment.</span>
<span class="comment-copy">@wim:  Well, perhaps several moments -- I had to go look at the many tests to see which answer I wanted to give.  ;-)</span>
<span class="comment-copy">Thank you! This is perfect.  Had some question, but I reread your answer more carefully and I think I understand it now.  Thanks for such a quick reply!</span>
<span class="comment-copy">another question for you in this example. Since I am subclassing str, I want my object to always behave as an str when I want it to, namely I never want the Enum <b>str</b> method to be called. So I wrote <code>__str__ = lambda self: self</code>. Since self is in fact an instance of str. This happened to worked for the above example but ceased to work when I added a second "data" field. After debugging the library, I found Enum.__init__ was getting called with the result of <b>str</b> as its args... Why is this? Returning self.name gets the behavior I want, but why is any <b>init</b> being called.</span>
<span class="comment-copy">@W.B.Reed:  If <code>_init_</code> is specified, then <code>__init__</code> will be called.  I can better answer the first part of the question with an exact example of what you are doing with "a second data field" (as a new question, please).  As for the original issue, the correct way to get the mixed-in class' behavior when Enum has overridden it is to put it back.  I.e. <code>__str__ = str.__str__</code>.</span>
<span class="comment-copy">Thank you @EthanFurman.  I made a new question at <a href="https://stackoverflow.com/questions/49518098/init-being-called-on-str-result-in-aenum-enum" title="init being called on str result in aenum enum">stackoverflow.com/questions/49518098/â€¦</a> .  For anyone who's interested.</span>
