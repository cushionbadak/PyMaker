<div class="post-text" itemprop="text">
<p>I have a rather large project, including a class Foo which recently needed to be updated using the <code>@property</code> decorator to create custom getter and setter methods.</p>
<p>I also stored several instances of <code>Foo</code> on my hard drive that at some point I might need to reload. My problem is, that I cannot access the attributes decoreted with property on these old objects.</p>
<p>Consider the following example:</p>
<pre><code>import pickle

# define Class and create instance
class Foo:
    def __init__(self):
        self.val = 1
foo = Foo()

# dump foo into file
with open("foo.pickle", 'wb') as handle:
    pickle.dump(foo, handle, pickle.HIGHEST_PROTOCOL)

# overwrite and add @property in the class definition
class Foo:
    def __init__(self):
        self._val = "new_foo"

    @property
    def val(self):
        return self._val

    @val.setter
    def val(self, val):
        self._val = val

foo_new = Foo()
print(foo_new.val)

# reload foo
with open("foo.pickle", "rb") as handle:
    foo_old = pickle.load(handle)

# try to access attributes
print(foo_old.val)
</code></pre>
<p>The last line raises:</p>
<blockquote>
<p>NameError: name '_val' is not defined</p>
</blockquote>
<p>What options do I have to still access the attributes of my archived instances?</p>
<p>Edit: Changed <code>self.val</code> to <code>self._val</code> in the constructor of the second Foo-definition.</p>
</div>
<div class="post-text" itemprop="text">
<p>A possibility is to use a custom <a href="https://docs.python.org/3/library/pickle.html#pickle.Unpickler" rel="nofollow noreferrer"><code>Unpickler</code></a>, although you would need to keep the old class around (with a different name, hidden if you want) and define the logic to convert an object of the old class to the new one. Here's a basic example:</p>
<pre><code>import pickle

# define Class and create instance
class Foo:
    def __init__(self):
        self.val = 1
foo = Foo()

# dump foo into file
with open("foo.pickle", 'wb') as handle:
    pickle.dump(foo, handle, pickle.HIGHEST_PROTOCOL)

# Old class is kept with a new name
FooOld = Foo

# overwrite and add @property in the class definition
class Foo:
    def __init__(self):
        self._val = "new_foo"

    @property
    def val(self):
        return self._val

    @val.setter
    def val(self, val):
        self._val = val

foo_new = Foo()
print(foo_new.val)

# Custom Unpickler
class FooOldUnpickler(pickle.Unpickler):
    def __init__(self, *args, **kwargs):
        super(FooOldUnpickler, self).__init__(*args, **kwargs)

    def load(self):
        obj = super(FooOldUnpickler, self).load()
        if type(obj) is FooOld:
            # Object conversion logic
            newObj = Foo()
            newObj.val = obj.val
            obj = newObj
        return obj

    def find_class(self, module, name):
        # Use old class instead of new for loaded objects
        if module == __name__ and name == 'Foo':
            return FooOld
        return super(FooOldUnpickler, self).find_class(module, name)

# reload foo
with open("foo.pickle", "rb") as handle:
    # Use custom unpickler
    foo_old = FooOldUnpickler(handle).load()

# try to access attributes
print(foo_old.val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The pickle <a href="https://docs.python.org/3/library/pickle.html#pickling-class-instances" rel="nofollow noreferrer">documentation</a> says:</p>
<blockquote>
<p>When a class instance is unpickled, its <code>__init__()</code> method is usually <em>not</em> invoked.</p>
</blockquote>
<p>Which is why the <code>_val</code> attribute wasn't defined You can workaround that by defining a <code>__new__</code> method in the replacement <code>Foo</code> class and setting the instance attribute there:</p>
<pre><code>import pickle

# define Class and create instance
class Foo:
    def __init__(self):
        self.val = 1
foo = Foo()

# dump foo into file
with open("foo.pickle", 'wb') as handle:
    pickle.dump(foo, handle, pickle.HIGHEST_PROTOCOL)

# overwrite and add @property in the class definition
class Foo:
    def __new__(cls, val=None):
        inst = super().__new__(cls)
        inst._val = "new_foo"  if val is None else val
        return inst

    @property
    def val(self):
        return self._val

    @val.setter
    def val(self, val):
        self._val = val

foo_new = Foo()
print(foo_new.val)  # -&gt; new_foo

# reload foo
with open("foo.pickle", "rb") as handle:
    foo_old = pickle.load(handle)

print(foo_old.val)  # -&gt; new_foo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may be a total hack -- I'm not certain. However, I was able to reconstruct an object pickled from your first "Foo" class using the following code;</p>
<pre><code>import pickle

class Foo:
    def __init__(self):
        self._val = "new_foo"

    @property
    def val(self):
        try:
            return self._val
        except AttributeError:
            self._val = self.__dict__['val']
            self.__dict__.pop('val')
            return self._val

    @val.setter
    def val(self, val):
        self._val = val


with open("foo.pickle", "rb") as handle:
    foo_old = pickle.load(handle)

print(foo_old.val)
</code></pre>
</div>
<span class="comment-copy"><code>val = 1</code> is a local, rather than a class attribute - it also has the 'wrong' name.  I think you mean <code>self._val = 1</code> and <code>return self._val</code></span>
<span class="comment-copy">Sorry, I was a bit sloppy there. I updated the code to a real working example.</span>
<span class="comment-copy">Your update is still incorrect, it should be self._val = "new_foo"</span>
<span class="comment-copy">Let us <a href="https://chat.stackoverflow.com/rooms/166546/discussion-between-physicsguy-and-stevej">continue this discussion in chat</a>.</span>
<span class="comment-copy">personally, and this is way OT, I have found @property attributes to be nothing but pain in 99% of use cases .... they obfuscate what is actually happening in the code, and because there are no really private variables, they dont actually stop anyone from circumventing them anyway</span>
<span class="comment-copy">Your answer is promising, but it still requires me to keep my class definition. Is there a way to also pickle that?</span>
<span class="comment-copy">@physicsGuy Sorry, I forgot to answer this... I could not find a workaround without keeping the old class, you can in principle pickle a class object too, but I found when I loaded the class with pickle it would overwrite again the new class definition... But I don't know maybe there is some way.</span>
