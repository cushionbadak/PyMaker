<div class="post-text" itemprop="text">
<p>I need to check that certain operations have occurred in a particular order in threaded/asynchronous code. Something along the lines of:</p>
<pre><code>def test_threaded_stuff():
    # I can define the callbacks to the operation
    op = start_operation(callback1, callback2, cbargs...)
    op.checkpoint1.wait()
    # check that callback1 and callback2 have been invoked,
    # in that order
    op.checkpoint2.wait()
    # check that they have been invoked again, in reverse order
</code></pre>
<p>I can provide test callbacks that will be invoked by the operation, but I cannot place <code>py.test</code> assertions inside them because I need to test the overall order of their execution, not the state of any individual callback. Also, some of the callbacks are executed in separate threads which are not under the control of py.test.</p>
<p>To test such code, I came up with the following pattern:</p>
<pre><code>def callback1(log):
    log(1)

def callback2(log):
    log(2)

def test_threaded_stuff():
    events = []
    op = start_operation(cb1, cb2, events.append)
    op.checkpoint1.wait()
    assert events == [1, 2]
    op.checkpoint2.wait()
    assert events == [1, 2, 2, 1]
</code></pre>
<p>Is there an idiomatic way to express this in <code>py.test</code>? For example, a callable fixture that automatically logs its invocations, so that I can query the invocations in my tests.</p>
<p>If concrete examples are needed, <a href="https://github.com/hniksic/corocc/blob/bf62d633390014bac74fe89aa1b03e277b29fb5d/test/test_20_suspending.py" rel="nofollow noreferrer">this file</a> is an example, as are other files in the same directory.</p>
</div>
<div class="post-text" itemprop="text">
<p>It might not be necessary for pytest to have a specific functionality as I think, the standard Python unittest module would suffice.</p>
<p>You can make use of Mock objects that track calls to themselves as well as to methods and attributes, <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.method_calls" rel="nofollow noreferrer">reference</a>. </p>
<p>You can combine it with <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_has_calls" rel="nofollow noreferrer"><code>assert_has_calls()</code></a> by building the list of <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.call" rel="nofollow noreferrer">calls</a> you expect and want to test. It also allows to test for the specific order of the calls by default through the <code>any_order=False</code> param.</p>
<p>So by patching your module adequately and passing Mock objects instead of callbacks in your tests you will mostly be able to create your tests.</p>
</div>
<span class="comment-copy"><code>Mock</code> objects are pretty nice, thanks. In my particular case, where I want to assert that exactly specific calls occurred, using <code>Mock</code> doesn't seem to result in less code. In the example from the question, the assertion would need to be either <code>log.call_args_list == </code>[((1,),), ((2,),), ((2,),), ((1,),)]` or to <code>log.call_args_list == </code>[call(1), call(2), call(3)]`, both being more verbose than what I have now.</span>
