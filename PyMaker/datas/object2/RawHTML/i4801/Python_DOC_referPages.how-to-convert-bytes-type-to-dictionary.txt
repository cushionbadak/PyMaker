<div class="post-text" itemprop="text">
<p>I have a bytes type object like this: </p>
<pre><code>b"{'one': 1, 'two': 2}"
</code></pre>
<p>I need to get the dictionary from that using python code. I am converting it into string and then converting into dictionary as follows.</p>
<pre><code>string = dictn.decode("utf-8")
print(type(string))
&gt;&gt; &lt;class 'str'&gt;
d = dict(toks.split(":") for toks in string.split(",") if toks)
</code></pre>
<p>But I am getting the below error:</p>
<pre><code>------&gt; d = dict(toks.split(":") for toks in string.split(",") if toks)
TypeError: 'bytes' object is not callable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All you need is <code>ast.literal_eval</code>. Nothing fancier than that. No reason to mess with JSON unless you are specifically using non-Python dict syntax in your string.</p>
<pre><code>import ast
ast.literal_eval(b"{'one': 1, 'two': 2}")
print(repr(d))
</code></pre>
<p>See answer <a href="https://stackoverflow.com/questions/988228/convert-a-string-representation-of-a-dictionary-to-a-dictionary">here</a>. It also details how <code>ast.literal_eval</code> is safer than <code>eval</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think a decode is also required to get a proper dict.</p>
<pre><code>a= b"{'one': 1, 'two': 2}"
ast.literal_eval(a.decode('utf-8'))
**Output:** {'one': 1, 'two': 2}
</code></pre>
<p>The accepted answer yields</p>
<pre><code>a= b"{'one': 1, 'two': 2}"
ast.literal_eval(repr(a))
**output:**  b"{'one': 1, 'two': 2}"
</code></pre>
<p>The literal_eval hasn't done that properly with many of my codes so I personally prefer to use json module for this</p>
<pre><code>import json
a= b"{'one': 1, 'two': 2}"
json.loads(a.decode('utf-8'))
**Output:** {'one': 1, 'two': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try like this:</p>
<pre><code>import json
import ast

a= b"{'one': 1, 'two': 2}"
print(json.loads(a.decode("utf-8").replace("'",'"')))

print(ast.literal_eval(a.decode("utf-8")))
</code></pre>
<p>There are the doc of module:</p>
<p>1.<a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">ast doc</a></p>
<p>2.<a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">json doc</a></p>
</div>
<span class="comment-copy">No need to make you own dictionary parser.  Send the string to <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a></span>
<span class="comment-copy">The code you've posted here does not raise that exception. In fact, it does almost what you say you want it to do (modulo some mistakes in dealing with quote charactersâ€”e.g., you're going to end up with a key like <code>" 'two'"</code> instead of <code>"two"</code>).</span>
<span class="comment-copy">Meanwhile, where did this input come from? Taking the <code>repr</code> of a Python dict and <code>encode</code>-ing it to UTF-8 is really not a good way to store data that you want to load back in later. Much better to use something like JSON or Pickle.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/988228/convert-a-string-representation-of-a-dictionary-to-a-dictionary">Convert a String representation of a Dictionary to a dictionary?</a></span>
<span class="comment-copy">I think a decode is required for python3.5.</span>
