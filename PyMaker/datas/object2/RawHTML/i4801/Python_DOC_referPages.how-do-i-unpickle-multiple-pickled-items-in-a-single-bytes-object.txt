<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/28745948/5003848">This answer</a> explains how you would unpickle multiple items in a <em>file</em>.</p>
<p>However, I'm sending pickled objects across the network. If two pickled objects are sent in rapid succession, they could end up read into the same buffer.</p>
<p>How do I replicate the behavior in the linked answer with <code>bytes</code> objects? Is there a well-defined terminator I can split on, or a way to "advance" the <code>bytes</code> object?</p>
<p>Ex:</p>
<pre><code>test = pickle.dumps("hello")
test += pickle.dumps("world")

print(pickle.loads(test)) # Prints "hello" -- how do I get "world"?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Follow the pattern in your linked answer, but <a href="https://docs.python.org/3/library/io.html#io.BytesIO" rel="nofollow noreferrer">use <code>io.BytesIO</code> to make an in-memory file-like object</a>, e.g.:</p>
<pre><code># Changed to receive open file-like object instead of name
def load(fileobj):
    while True:
        try:
            yield pickle.load(fileobj)
        except EOFError:
            break

test = pickle.dumps("hello")
test += pickle.dumps("world")

with io.BytesIO(test) as f:
    for obj in load(f):
        ... do stuff with obj ...
</code></pre>
</div>
<span class="comment-copy">If you don't have anything in place to separate your pickles from each other, you probably don't have anything in place to make sure your pickles stay in one piece, either. Make sure you don't end up trying to load half a pickle, or half of two pickles put together.</span>
<span class="comment-copy">@user2357112: I ultimately ended up fixing the length of messages I'm passing at 8192 bytes -- anything longer raises an exceptions, shorter gets padded. It's a hack, but it solves the problem for now (it's a research prototype, so it's an acceptable hack). That solves the "half a pickle" problem -- as for the "half of two pickle" problems, I avoid that by using a message queue for each network connection.</span>
<span class="comment-copy">@user2357112: If you don't break out of loop, it will load them all. That's the point of the infinite loop in the generator, and the point of the answer the OP linked.</span>
<span class="comment-copy">I reverted the edit because I'm intentionally mimicking <a href="https://stackoverflow.com/a/28745948/5003848">the OP's linked answer</a>; I agree the name <code>load</code> isn't great, but I'd prefer to perform minimal changes to keep the concepts in sync.</span>
<span class="comment-copy">I was actually in the middle of editing the linked answer too, to change the function name and add a bit more explanation.</span>
