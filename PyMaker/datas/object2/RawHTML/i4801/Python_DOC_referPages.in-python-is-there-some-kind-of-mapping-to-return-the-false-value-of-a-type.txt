<div class="post-text" itemprop="text">
<p>I am looking for some kind of a mapping function <code>f()</code> that does something similar to this:</p>
<pre><code>f(str) = ''
f(complex) = 0j
f(list) = []
</code></pre>
<p>Meaning that it returns an object of type that evaluates to <code>False</code> when cast to <code>bool</code>.</p>
<p>Does such a function exist?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, there is no such mapping. Not every type of object has a falsy value, and others have more than one. Since the truth value of a class can be customized with the <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noreferrer"><code>__bool__</code> method</a>, a class could theoretically have an infinite number of (different) falsy instances.</p>
<p>That said, most builtin types return their falsy value when their constructor is called without arguments:</p>
<pre><code>&gt;&gt;&gt; str()
''
&gt;&gt;&gt; complex()
0j
&gt;&gt;&gt; list()
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nope, and in general, there may be no such value. The Python <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noreferrer">data model</a> is pretty loose about how the truth-value of a type may be implemented:</p>
<blockquote>
<p><code>object.__bool__(self)</code></p>
<p>Called to implement truth value testing and the built-in operation
  bool(); should return False or True. When this method is not defined,
  <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code>
  nor <code>__bool__()</code>, all its instances are considered true.</p>
</blockquote>
<p>So consider:</p>
<pre><code>import random
class Wacky:
    def __bool__(self):
        return bool(random.randint(0,1))
</code></pre>
<p>What should <code>f(Wacky)</code> return?</p>
</div>
<div class="post-text" itemprop="text">
<p>Not all types have such a value to begin with. Others may have many such values. The most correct way of doing this would be to create a type-to-value dict, because then you could check if a given type was in the dict at all, and you could chose which value is the correct one if there are multiple options. The drawback is of course that you would have to somehow register every type you were interested in.</p>
<p>Alternatively, you could write a function using some heuristics. If you were very careful about what you passed into the function, it would probably be of some limited use. For example, all the cases you show except <code>complex</code> are containers that generalize with <code>cls()</code>.</p>
<p><code>complex</code> actually works like that too, but I mention it separately because <code>int</code> and <code>float</code> do not. So if your attempt with the empty constructor fails by returning a truthy object or raising a <code>TypeError</code>, you can try <code>cls(0)</code>. And so on and so forth...</p>
<p><strong>Update</strong></p>
<p><a href="https://stackoverflow.com/a/49294330/2988730">@juanpa.arrivillaga's answer</a> actually suggests a clever workaround that will work for most classes. You can extend the class and forcibly create an instance that will be falsy but otherwise identical to the original class. You have to do this by extending because dunder methods like <code>__bool__</code> are only ever looked up on the class, never on an instance. There are also many types where such methods can not be replaced on the instance to begin with. As @Aran-Fey's now-deleted comment points out, you can selectively call <code>object.__new__</code> or <code>t.__new__</code>, depending on whether you are dealing with a very special case (like <code>int</code>) or not:</p>
<pre><code>def f(t):
    class tx(t):
        def __bool__(self):
            return False
    try:
        return object.__new__(tx)
    except TypeError:
        return tx.__new__(tx)
</code></pre>
<p>This will only work for 99.9% of classes you ever encounter. It is possible to create a contrived case that raises a <code>TypeError</code> when passed to <code>object.__new__</code> as <code>int</code> does, and does not allow for a no-arg version of <code>t.__new__</code>, but I doubt you will ever find such a thing in nature. See the <a href="https://gist.github.com/Aran-Fey/d6081ef6aa8d5170d22127fc595c5400" rel="nofollow noreferrer">gist</a> @Aran-Fey made to demonstrate this.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is actually called an <a href="https://en.wikipedia.org/wiki/Identity_element" rel="nofollow noreferrer">identity element</a>, and in programming is most often seen as part of the definition of a <a href="https://en.wikipedia.org/wiki/Monoid" rel="nofollow noreferrer">monoid</a>.  In python, you can get it for a type using the <code>mzero</code> function in the <a href="https://pypi.python.org/pypi/PyMonad" rel="nofollow noreferrer">PyMonad</a> package.  Haskell calls it <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#v:mempty" rel="nofollow noreferrer">mempty</a>.  </p>
</div>
<div class="post-text" itemprop="text">
<p>No such function exists because it's not possible in general. A class may have no falsy value or it may require reversing an arbitrarily complex implementation of <code>__bool__</code>.</p>
<p>What you <em>could</em> do by breaking everything else is to construct a new object of that class and forcibly assign its <code>__bool__</code> function to one that returns <code>False</code>. Though I suspect that you are looking for an object that would otherwise be a valid member of the class.</p>
<p>In any case, this is a Very Bad Idea in classic style.</p>
</div>
<span class="comment-copy">There isn't always such a value</span>
<span class="comment-copy">Why do this though?</span>
<span class="comment-copy">@Veedrac I want to write a smart iff function that its default False value (if not passed explicitly) will be the false object of the type of the True value. So if the signature is something like (cond,t,f), and f is optional and wasn't passed, it will be set to type(t)()</span>
<span class="comment-copy">I think that just pushes the question one level down. That doesn't seem like a fundamental technical problem.</span>
<span class="comment-copy">@Veedrac It seems to me that this is an attempt to implement the Null object pattern: instead of returning <code>None</code>, it can be convenient to return an object which behaves like the expected type, but does nothing. This saves from having to check for <code>None</code> all the time.</span>
<span class="comment-copy">"a class could theoretically have an infinite number of (different) falsy instances" or zero, for that matter.</span>
<span class="comment-copy">This works for surprisingly many of the types in <a href="https://docs.python.org/3/library/stdtypes.html" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html</a> ; <code>type()</code>, <code>range()</code> and <code>memoryview()</code> fail with a <code>TypeError</code> as they expect an argument. And other types like module and class are probably not so relevant. As far as I can see this never returns a truthy value for any builtin type.</span>
<span class="comment-copy">@RemcoGerlich: You forgot to test <code>object()</code>, which is truthy. If you count exceptions, I believe all built-in exception types return a truthy object when called with no arguments, too. Some built-ins that are technically types but usually not treated as types also return truthy values, like <code>property()</code> or <code>zip()</code>.</span>
<span class="comment-copy">Just because you have an infinite amount of (different) falsey instances doesn't mean you can't enumerate them or that there can't exist a mapping :)</span>
<span class="comment-copy">Or <a href="https://docs.python.org/2/reference/datamodel.html#object.__nonzero__" rel="nofollow noreferrer"><b>nonzero</b></a> for python 2</span>
<span class="comment-copy">@juanpa.arrivillaga. I started working on a (cheating) solution in my update, but it only works for classes that allow no-arg constructors. Perhaps you could suggest a workaround?</span>
<span class="comment-copy">You are correct, perhaps it was too much to ask for a general, builtin function. But my usage to such function will be trivial at most times, I was planning to use it for common standard python types without explicitly defining the mapping myself.</span>
