<div class="post-text" itemprop="text">
<p>If I have a list:</p>
<pre><code>list_1 = ["apples", "apricots", "oranges"]
</code></pre>
<p>and I append an new item to the list : "berries"</p>
<pre><code>list_1 = ["apples", "apricots", "oranges", "berries"]
</code></pre>
<p>Under-the-hood (so to speak), I thought I remember reading that Python creates another list (list_2) and points it to the original list (list_1) so that list_1 remains static...if this is true, would it look something like this (under-the-hood)?</p>
<pre><code>list_1 = ["apples", "apricots", ["oranges", "berries"]]
</code></pre>
<p>So in this way, the original list maintains its size.  Is this the correct way of looking at it?  </p>
</div>
<div class="post-text" itemprop="text">
<p>No, Python does <em>not</em> create another list when you call <code>append</code>. It mutates the existing list in-place. You can see this pretty easily:</p>
<pre><code>&gt;&gt;&gt; lst1 = []
&gt;&gt;&gt; lst2 = lst1
&gt;&gt;&gt; lst1.append(0)
&gt;&gt;&gt; lst1
[0]
&gt;&gt;&gt; lst2
[0]
</code></pre>
<p>If you want to create another list, you can do this instead:</p>
<pre><code>&gt;&gt;&gt; lst1 = []
&gt;&gt;&gt; lst2 = lst1
&gt;&gt;&gt; lst1 = lst1 + [0]
&gt;&gt;&gt; lst1
[0]
&gt;&gt;&gt; lst2
[]
</code></pre>
<hr/>
<p>So, how does that in-place appending work? Aren't lists just arrays under the hood? Yes, they are. Python leaves a little space at the end, but if you <code>append</code> enough times, it has to allocate a new array for the list, move over all the elements, and delete the old one. It's still the same list object, but with a different array under the hood.</p>
<p>That growing doesn't just add one new slot each time—that would mean each <code>append</code> has to reallocate the whole list, so appending would take average linear time. Instead, it multiplies the length. Something like this:</p>
<pre><code>new_capacity = max(4, capacity * 8 // 5, new_length)
</code></pre>
<p>(The <code>new_length</code> is there in case you're <code>extend</code>ing the list with a whole bunch of elements at once.)</p>
<p>By expanding geometrically rather than arithmetically, we can guarantee that, while a few <code>append</code>s do take linear time, enough of them are instant that the amortized time is constant. Exactly what factor you use is a tradeoff between speed (high numbers mean fewer reallocations) and space (higher numbers mean more wasted space on the end). I don't know what CPython does, but you can find it in the source code linked below. Most systems use a value between 1.5 and 2.0 (and usually a nice fraction of small numbers so they can do integer multiple and divide).</p>
<hr/>
<p>If you really want to understand this, and you can follow basic C, you can look under the hood at <a href="https://github.com/python/cpython/blob/master/Include/listobject.h" rel="nofollow noreferrer"><code>listobject.h</code></a> and <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="nofollow noreferrer"><code>listobject.c</code></a>. You'll probably want to read the C API docs first, but here's the basics (in Python-like pseudocode, and intentionally using not quite the real function and field names):</p>
<pre><code>if lst.size + 1 &gt; lst.allocated:
    new_capacity = &lt;see above&gt;
    lst.array = PyRealloc(&lt;enough memory for new_capacity pointers&gt;)
    lst.allocated = new_capacity
incref(new_item)
lst.array[lst.size] = new_item
lst.size += 1
</code></pre>
<p>The <code>Realloc</code> function is going to be a thin wrapper around the platform's function, which will try to find more room in-place, but fall back to allocating a totally new pointer and moving over all of the contents.</p>
<hr/>
<p>Since you're using Python, there's a good chance you're the kind of person who likes to learn through interactive experimentation. If you don't know about <a href="https://docs.python.org/3/library/ctypes.html#accessing-values-exported-from-dlls" rel="nofollow noreferrer"><code>ctypes.pythonapi</code></a>. you should definitely start playing with it. You can call almost anything from the <a href="https://docs.python.org/3/c-api/index.html" rel="nofollow noreferrer">C API</a> from inside Python. Unfortunately, you can't call <code>#define</code> macros, or dig into the structs without a bit of extra work—but see <a href="https://github.com/abarnert/superhackyinternals" rel="nofollow noreferrer"><code>superhackyinternals</code></a> for how you can do that bit of extra work. (I don't think I included anything there for lists, but look at how ints work, and you should be able to get it from there—just don't look at strings, because they're a lot more complicated.) Of course playing around with this stuff from inside your interpreter, you're going to segfault a lot, so don't do it in a session where you've got any important history.</p>
<hr/>
<p>And of course that isn't guaranteed to be true for every Python implementation. As long as an implementation can provide the documented interface and performance characteristics, it can build lists however it wants. For example, maybe IronPython uses some vector class in the .NET class library. Of course that class will do similar reallocate-and-move under its own hood, but IronPython won't care how it does that (and you'll care even less).</p>
</div>
<div class="post-text" itemprop="text">
<p>Under the hood, a Python list object uses a C <em>array</em> structure that's larger; it is pre-sized. The length of the Python list is just an integer value, recording how many Python elements are stored in the array. Appending an element to the list just uses the next empty spot in the array, and the size integer is incremented by one.</p>
<p>When there is not enough space any more in the C array, more memory is allocated to grow the array. If you remove elements to the point you only use half of the array, memory is released again.</p>
<p>You can see the implementation in the <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="nofollow noreferrer"><code>Objects/listobject.c</code> file</a> in the Python source code. Resizing takes place in the <a href="https://github.com/python/cpython/blob/v3.6.4/Objects/listobject.c#L12-L74" rel="nofollow noreferrer"><code>list_resize()</code> function</a>, where the following snippet decides how large the new array should be, to strike a balance between memory usage (with a bunch of pointers in an array not being used) and avoiding having to copy across arrays too often:</p>
<pre class="lang-c prettyprint-override"><code>/* This over-allocates proportional to the list size, making room
 * for additional growth.  The over-allocation is mild, but is
 * enough to give linear-time amortized behavior over a long
 * sequence of appends() in the presence of a poorly-performing
 * system realloc().
 * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
 */
new_allocated = (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);
</code></pre>
<p><code>new_allocated</code> is <em>added</em> to the current allocation. So when you need more space, then the new size, divided by 8, plus 3 or 6, dictates how many extra elements to add <em>over on top of the minimal required size</em>. Appending an element to a list of size 1000 adds a buffer of 131 extra slots, while appending an element to a list size 10 only adds an extra 7 slots.</p>
<p>From the view of Python code, the list is just a sequence of indices that'll grow and shrink as needed to fit all the elements. There are no extra lists involved in this, the swapping of arrays when resizing is hidden from view.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, under the hood the list is backed by a (usually) underutilized array.</p>
<pre><code>list1 -&gt; [ x | x |  ]
           |   |
           |   v
           |   "apricots"
           v
           "apples"
</code></pre>
<p>When you append to <code>list1</code>, you simply change the value of the first unused array slot:</p>
<pre><code>list1 -&gt; [ x | x | x ]
           |   |   |
           |   |   v
           |   |   "oranges" 
           |   v   
           |   "apricots"
           v
           "apples"
</code></pre>
<p>On the <em>next</em> append, more memory (and again, more than is needed) is added to the array before adding the new element. [The extra memory may be allocated as soon as the array is detected to be full; I don't recall the exact details.]</p>
<pre><code>list1 -&gt; [ x | x | x |  |  |  |  ]
           |   |   |
           |   |   v
           |   |   "oranges" 
           |   v   
           |   "apricots"
           v
           "apples"

list1 -&gt; [ x | x | x | x |  |  |  ]
           |   |   |   |
           |   |   |   v
           |   |   |   "berries"
           |   |   v
           |   |   "oranges" 
           |   v   
           |   "apricots"
           v
           "apples"
</code></pre>
<p>The amount actually allocated may vary, but the desired effect is that any <em>sequence</em> of <code>appends</code> has the appearance of a constant-time operation, even though each individual <code>append</code> may be either a very small constant-time operation or a linear-time operation. The invariant, though, is that you can never have "too many" linear-time operations over the life of the object, preserving the <em>amortized</em> running time of each <code>append</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A Python implementation can do anything under the hood, provided it has the correct behavior. Good implementations also are as least as fast as <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">the recommended time complexities</a>.</p>
<p>In general, appending to a list modifies the list, if possible. In its <a href="https://github.com/python/cpython/blob/019f5b3e9e4c2a1297580483c3d5a5a10bddb93b/Objects/listobject.c#L280" rel="nofollow noreferrer">append implementation</a>, the widely used cpython <a href="https://github.com/python/cpython/blob/019f5b3e9e4c2a1297580483c3d5a5a10bddb93b/Objects/listobject.c#L34-L76" rel="nofollow noreferrer">resizes the list if necessary to <code>9/8 * old_size + 6</code></a> if there is no more space. Resizing is accomplished by either reserving more memory (if lucky) or allocating new memory and copying over all old elements. This means that resizing is only rarely needed, especially if the list is large. Most of the time, one of the reserve memory spaces can be used.</p>
</div>
<span class="comment-copy">where do you read that the original list maintained its size? no, <code>list_1</code> is just resized to store the reference of the new string.</span>
<span class="comment-copy">How are you appending the new item? Are you calling <code>append</code>? Calling <code>append</code> would behave very differently from performing the assignment <code>list_1 = ["apples", "apricots", "oranges", "berries"]</code>.</span>
<span class="comment-copy">maybe you mean that <code>list_1</code> reference doesn't change, because lists are <i>mutable</i> ?</span>
<span class="comment-copy">I would be appending the item.</span>
<span class="comment-copy">Yes that is what I meant about under the hood with the arrays part. I am still trying to wrap my head around what you are saying.  So what does it mean when you say "allocate a new array for the list"?</span>
<span class="comment-copy">@netrate I'll edit to add more info</span>
<span class="comment-copy">all the responses are great. Thank you for the time, this makes more sense to me now.</span>
<span class="comment-copy">There is no <code>memmove()</code>, it's a <code>realloc()</code> on the original array now.</span>
<span class="comment-copy">@MartijnPieters Well, <code>realloc</code> does an implicit <code>memmove</code> when necessary (although a libmalloc might be able to optimize things a bit more than a general <code>memmove</code> if, e.g., your new array can reuse entire pages?), so I think as pseudocode it still makes sense.</span>
<span class="comment-copy">Yes that makes more sense to me.  Is there a way of telling how many extra "slots" it opens up when it creates a list?  Is it always one extra blank slot?</span>
<span class="comment-copy">See Martijn Pieter's answer for the details of the over-allocation algorithm. The naive approach is to just double the list every time it needs to be resized, but that tends to over allocate memory. (In a very hand wavy sense, each append makes the next append less likely--it has to stop growing <i>sometime</i>--, so later appends are more likely to allocate memory that won't be used. Python makes more smaller allocations to reduce wasted memory.</span>
<span class="comment-copy">One very important fact I left out: the existing array is not just resized, but <i>replaced</i> by a new array into which the contents of the old array are copied. This makes memory management a little slower, but less complex.</span>
<span class="comment-copy">@chepner: the existing array is actually resized, <a href="https://linux.die.net/man/3/realloc" rel="nofollow noreferrer">using <code>realloc()</code></a>.</span>
