<div class="post-text" itemprop="text">
<p>I have a list of lists:</p>
<pre><code>list_of_lists = []
list_1 = [-1, 0.67, 0.23, 0.11]
list_2 = [-1]
list_3 = [0.54, 0.24, -1]
list_4 = [0.2, 0.85, 0.8, 0.1, 0.9]
list_of_lists.append(list_1)
list_of_lists.append(list_2)
list_of_lists.append(list_3)
list_of_lists.append(list_4)
</code></pre>
<p>The position is meaningful. I want to return a list that contains the mean per position, excluding -1. That is, I want:</p>
<pre><code>[(0.54+0.2)/2, (0.67+0.24+0.85)/3, (0.23+0.8)/2, (0.11+0.1)/2, 0.9/1]
</code></pre>
<p>which is actually:</p>
<pre><code>[0.37, 0.5866666666666667, 0.515, 0.10500000000000001, 0.9]
</code></pre>
<p>How can I do this in a pythonic way?</p>
<p>EDIT:</p>
<p>I am working with Python 2.7, and I am not looking for the mean of each list; instead, I'm looking for the mean of 'all list elements at position 0 excluding -1', and the mean of 'all list elements at position 1 excluding -1', etc.</p>
<p>The reason I had:</p>
<pre><code>[(0.54+0.2)/2, (0.67+0.24+0.85)/3, (0.23+0.8)/2, (0.11+0.1)/2, 0.9/1]
</code></pre>
<p>is that values in position 0 are -1, -1, 0.54, and 0.2, and I want to exclude -1; position 1 has 0.67, 0.24, and 0.85; position 3 has 0.23, -1, and 0.8, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a vectorised <code>numpy</code>-based solution.</p>
<pre><code>import numpy as np

a = [[-1, 0.67, 0.23, 0.11],
     [-1],
     [0.54, 0.24, -1],
     [0.2, 0.85, 0.8, 0.1, 0.9]]

# first create non-jagged numpy array
b = -np.ones([len(a), max(map(len, a))])

for i, j in enumerate(a):
    b[i][0:len(j)] = j

# count negatives per column (for use later)
neg_count = [np.sum(b[:, i]==-1) for i in range(b.shape[1])]

# set negatives to 0
b[b==-1] = 0

# calculate means
means = [np.sum(b[:, i])/(b.shape[0]-neg_count[i]) \
         if (b.shape[0]-neg_count[i]) != 0 else 0 \
         for i in range(b.shape[1])]

# [0.37,
#  0.58666666666666667,
#  0.51500000000000001,
#  0.10500000000000001,
#  0.90000000000000002]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution without third-party libraries:</p>
<pre><code>from itertools import zip_longest
from statistics import mean

def f(lst):
    return [mean(x for x in t if x != -1) for t in zip_longest(*lst, fillvalue=-1)]
</code></pre>
<pre><code>&gt;&gt;&gt; f(list_of_lists)
[0.37, 0.5866666666666667, 0.515, 0.10500000000000001, 0.9]
</code></pre>
<p>It uses <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> with <code>fillvalue</code> set to <code>-1</code> to "transpose" the list and set missing values to <code>-1</code> (will be ignored at the next step). Then, a generator expression and <a href="https://docs.python.org/3/library/statistics.html#statistics.mean" rel="nofollow noreferrer"><code>statistics.mean</code></a> are used to filter out <code>-1</code>s and get the average.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use pandas module to process.Code would like this :</p>
<pre><code>import numpy as np
import pandas as pd

list_1 = [-1, 0.67, 0.23, 0.11,np.nan]
list_2 = [-1,np.nan,np.nan,np.nan,np.nan]
list_3 = [0.54, 0.24, -1,np.nan,np.nan]
list_4 = [0.2, 0.85, 0.8, 0.1, 0.9]
df=pd.DataFrame({"list_1":list_1,"list_2":list_2,"list_3":list_3,"list_4":list_4})
df=df.replace(-1,np.nan)
print(list(df.mean(axis=1)))
</code></pre>
</div>
<span class="comment-copy">You should look into list comprehensions. Something like <code>[sum(l)/len(l) for l in list_of_lists]</code> combined with a filter to remove whatever specific things you don't want would be a good start.</span>
<span class="comment-copy">@ap And the magic <code>zip</code> of course.</span>
<span class="comment-copy">@ap Thanks but it's position-wise, not list-wise. <code>sum(l)/len(l) for l in list_of_lists]</code> would give me the mean for each list, which is not what I'm looking for.</span>
<span class="comment-copy">Ah, I misunderstood the 'position' to mean position within the main list. You'd want to use <code>zip</code> as per bipll's suggestion for that.</span>
<span class="comment-copy">One problem with this answer: if <code>b.shape[0]-neg_count[i]</code> is 0, then this returns <code>nan</code> in that space. I'd prefer it to return <code>-1</code> in that case. Here is the revised version:  <code>means = [np.sum(b[:, i])/(b.shape[0]-neg_count[i]) if (b.shape[0]-neg_count[i]) != 0 else -1 for i in range(b.shape[1])]</code></span>
<span class="comment-copy">Will you ever have a column that is all -1 ? Your update, of course works, but it makes it less efficient. [except won't you need <code>else 0</code> instead of <code>else -1</code> ?]</span>
<span class="comment-copy">Yes, it's possible - I got some <code>nan</code>s returned from the answer, so even though this is less efficient I thought it was necessary. I could use <code>else 0</code> but it makes sense in my context to have <code>else -1</code> because that is a numeric representation of an impossibility in my code (I can never have a negative mean).</span>
<span class="comment-copy">I should have mentioned in the question: I'm working with Python 2.7, and <code>zip_longest</code> only works in Python 3 as far as I can tell.</span>
