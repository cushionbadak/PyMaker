<div class="post-text" itemprop="text">
<p>I have a dictionary with missing values (the key is there, but the associated value is empty). For example I want the dictionary below:</p>
<pre><code>dct = {'ID':'', 'gender':'male', 'age':'20', 'weight':'', 'height':'5.7'}
</code></pre>
<p>to be changed to this form:</p>
<pre><code>dct = {'ID':NaN, 'gender':'male', 'age':'20', 'weight':NaN, 'height':'5.7'}
</code></pre>
<p>How can I write that in the most time-efficient way?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary comprehension.  Also as was noted in the comments, naming something <code>dict</code> in Python is not good practice.:</p>
<pre><code>dct = {'ID':'', 'gender':'male', 'age':'20', 'weight':'', 'height':'5.7'}
dct = {k: None if not v else v for k, v in dct.items() }
print(dct)
</code></pre>
<p>Output:</p>
<pre><code>{'ID': None, 'gender': 'male', 'age': '20', 'weight': None, 'height': '5.7'}
</code></pre>
<p>Just replace <code>None</code> with whatever you want it to default to.</p>
<p>In your question, you want to replace with <code>NaN</code>.</p>
<p>You can use any of the following:</p>
<p><code>float('nan')</code> if you are using Python 2.x, or with Python &lt;3.5</p>
<p><code>math.nan</code> for Python 3.5+</p>
<p><code>numpy.nan</code> using <code>numpy</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use implicit syntax with boolean <a href="https://docs.python.org/3/reference/expressions.html#or" rel="nofollow noreferrer"><code>or</code></a> expression:</p>
<pre><code>In [1]: dct = {'ID':'', 'gender':'male', 'age':'20', 'weight':'', 'height':'5.7'}

In [2]: {k: v or None for k, v in dct.items()}
Out[2]: {'ID': None, 'age': '20', 'gender': 'male', 'height': '5.7', 'weight': None}
</code></pre>
<p>But be aware that in <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">The Zen of Python</a> it's said:</p>
<blockquote>
<p>Explicit is better than implicit.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can create a class object to represent <code>NaN</code>:</p>
<pre><code>class NaN:
  def __init__(self, default=None):
    self.val = default
  def __repr__(self):
    return 'NaN'

dct = {'ID':'', 'gender':'male', 'age':'20', 'weight':'', 'height':'5.7'}
new_d = {a:NaN() if not b else b for a, b in dct.items()}
</code></pre>
<p>Output:</p>
<pre><code>{'gender': 'male', 'age': '20', 'ID': NaN, 'weight': NaN, 'height': '5.7'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a for loop to iterate over all of they keys and values in the Dictionary. </p>
<pre><code>dct = {'ID': '', 'gender': 'male', 'age': '20', 'weight': '', 'height': '5.7'}


for key, value in dct.items():
      if value == '':
           dct[key] = 'NaN'
print(dct)
</code></pre>
<ol>
<li>You created your dictionary with a series of key value pairs. </li>
<li>I used a for loop and the .items() method to iterate over each key value pair in your dictionary. </li>
<li>if the value of the key/value pair is an empty string, We change the that particular value to 'NaN' and leave the rest unchanged. </li>
<li><p>When we print the new dictionary we get this output: </p>
<pre><code>{'ID': 'NaN', 'gender': 'male', 'age': '20', 'weight': 'NaN', 'height': '5.7'}
</code></pre></li>
</ol>
<p>This is time efficient because it is a quick loop, so long as you are okay with not 'NaN' values being strings. I am not sure if you are looking for them to be strings, however, you can change the value from 'NaN' to None very simply if that is what you are looking for. The for loop is relatively efficient in terms of time since it will iterate over each value quickly. </p>
</div>
<span class="comment-copy">Strive to avoid naming your variables in a way that shadows other names. i.e. Don't name your variable <code>dict</code> because that shadows that builtin type name <code>dict</code>.</span>
<span class="comment-copy">@ ndmeiri Good point! Thanks!</span>
<span class="comment-copy">Why did you specify "the most time-efficient way"? If it really does turn out to b a few nanoseconds faster to update <code>dct</code> in-place than to build a new <code>dct</code>, or vice-versa, are you going to pick the faster one even if it's harder to reader or doesn't play as well with the rest of you code? What if what's faster for a few massive dicts is slower for a bunch of tiny ones?</span>
<span class="comment-copy"><code>None</code> would probably be more appropriate than <code>NaN</code>, especially since you aren't otherwise storing the value as a <code>float</code>.</span>
<span class="comment-copy">@chepner: Actually, since all of his other values are strings, even the ones obviously intended to be ints (<code>age</code>) and floats (<code>height</code>), just <code>''</code>, or maybe some special string like <code>'N/A'</code>, is probably even better…</span>
<span class="comment-copy">Yes, that's what I'm looking for. But when I replace None with NaN, I get this error: "NameError: name 'NaN' is not defined"</span>
<span class="comment-copy">It worked! Thank you!</span>
<span class="comment-copy">You don't need numpy for <code>NaN</code>; it's built in as <code>math.nan</code>. Or, if you're using an earlier version of Python, <code>float('nan')</code> will work back to the early 2.x days. And if you're not actually using numpy, you probably don't want its <code>nan</code>—it doesn't play with normal Python floats as nicely as the builtin one.</span>
<span class="comment-copy">Notably, this replaces all "falsey" values, so it will work as intended on empty strings, but if some of the dictionary values are actually <code>None</code> or <code>0</code> or <code>False</code> or some other such value, it might not have the desired effect.</span>
<span class="comment-copy">Note that this isn't actually the most time-efficient solution. Mutating the dict in-place (even though that means using a slightly slower <code>for</code> statement instead of a comprehension) is almost certainly going to be faster for most use cases. And writing a C extension that uses the fast-dict-iter API for either version will be even faster. I doubt the tradeoff is even remotely worth it in this case, but he did say "the most time-efficient way", so it may be worth a comment saying that this is not the most time-efficient way but it's probably what he should be doing anyway.</span>
<span class="comment-copy">if I recall math.nan if you import the math module will give you: nan. If you want it formatted the way that your original code was, you can do the string 'NaN'. And if you want something such as None you can just set the value = to None. I'm assuming one of those options will work for you.</span>
