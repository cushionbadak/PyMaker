<div class="post-text" itemprop="text">
<p>From here:
<a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools-recipes</a></p>
<pre><code>def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>I understand the <code>zip_longest</code> call. But I don't get: </p>
<pre><code>args = [iter(iterable)] * n
</code></pre>
<p>If you are gonna be passing an iterable into <code>izip_longest</code> later, why bother wrapping the iterable into an <code>iter()</code> again? Can't I just do:</p>
<pre><code>args = [iterable] * n
</code></pre>
<p>But it seems that without <code>iter()</code>, it just repeats the same iterator n times. But how does putting this in <code>iter()</code> change its behavior? </p>
</div>
<div class="post-text" itemprop="text">
<p>This grouping takes advantage of the single-pass nature of an iterator (as opposed to a mere iterable, which can be iterated multiple time potentially, and using <code>iter</code> on an non-iterator iterable  should return a new, independent iterator. In contrast, calling <code>iter</code> on an iterator <em>returns the iterator itself</em>. </p>
<p>So here is a simplistic implementation of a zip function that takes only two arguments:</p>
<pre><code>In [1]: def myzip(x, y):
   ...:     itx, ity = iter(x), iter(y)
   ...:     while True:
   ...:         try:
   ...:             a, b = next(itx), next(ity)
   ...:         except StopIteration:
   ...:             return
   ...:         yield a, b
   ...:

In [2]: list(zip('abcd','efgh'))
Out[2]: [('a', 'e'), ('b', 'f'), ('c', 'g'), ('d', 'h')]

In [3]: list(myzip('abcd','efgh'))
Out[3]: [('a', 'e'), ('b', 'f'), ('c', 'g'), ('d', 'h')]
</code></pre>
<p>This is pretty much how the built-in <code>zip</code> works. Now, what if we do the above with a list as the iterable?</p>
<pre><code>In [16]: mylist = [1,2,3,4]

In [17]: iterable = mylist

In [18]: itx, ity = iter(iterable), iter(iterable)

In [19]: itx is ity
Out[19]: False

In [20]: next(itx), next(ity)
Out[20]: (1, 1)

In [21]: next(itx), next(ity)
Out[21]: (2, 2)

In [22]: next(itx), next(ity)
Out[22]: (3, 3)

In [23]: next(itx), next(ity)
Out[23]: (4, 4)

In [24]: next(itx), next(ity)
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-24-b6cbb26d280f&gt; in &lt;module&gt;()
----&gt; 1 next(itx), next(ity)

StopIteration:
</code></pre>
<p>However, if <code>iterable</code> is an <em>iterator</em>:</p>
<pre><code>In [25]: iterable = iter(mylist)

In [26]: itx, ity = iter(iterable), iter(iterable)

In [27]: itx is ity
Out[27]: True

In [28]: next(itx), next(ity)
Out[28]: (1, 2)

In [29]: next(itx), next(ity)
Out[29]: (3, 4)

In [30]: next(itx), next(ity)
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-30-b6cbb26d280f&gt; in &lt;module&gt;()
----&gt; 1 next(itx), next(ity)

StopIteration:
</code></pre>
<p>Finally, note that repition on a sequence never copies the elements of a sequence, so doing <code>[iter(x)]*n</code> returns a list with n references to the same iterator, so:</p>
<pre><code>In [32]: args = [iter(mylist)]*3

In [33]: args
Out[33]:
[&lt;list_iterator at 0x1040c9320&gt;,
 &lt;list_iterator at 0x1040c9320&gt;,
 &lt;list_iterator at 0x1040c9320&gt;]
</code></pre>
<p>Note, they are the same <code>list_iterator</code> objects...</p>
</div>
<span class="comment-copy">Because for this to work you have to be zippping the <i>same iterator</i>. If <code>iterable</code> argument <i>is</i> an iterator, then the <code>iter</code> isn't required, but it is if it isn't.</span>
<span class="comment-copy">Why would that behave differently from zipping the same iterable?</span>
<span class="comment-copy"><a href="https://bpaste.net/show/7ce5670a21ca" rel="nofollow noreferrer">bpaste.net/show/7ce5670a21ca</a></span>
<span class="comment-copy">Because grouping like this results from the behavior of iterators where they are single-pass. So, think of zip(x, y) doing something like <code>next(x), next(y)</code> while there are no <code>StopIterations</code>... it isn't the same iterator, say <code>iterable</code> is a <code>list</code> or something like that, then you simply get the exact same elements, but if you pass a <i>list iterator</i>, then it will give you the first two...</span>
<span class="comment-copy">This has been asked multiple times, and I found it hard to give an example that fits into a SO answer, especially one that can serve to explain things to people who may be stuck in different ways or have slightly different questions. So, about 4 years ago, I wrote a blog post about it: <a href="http://stupidpythonideas.blogspot.com/2013/08/how-grouper-works.html" rel="nofollow noreferrer">stupidpythonideas.blogspot.com/2013/08/how-grouper-works.html</a></span>
<span class="comment-copy">Ah this is clear. Although I think this 'clever' use of iterator in Grouper function is really bad programming. it's clever but not very clear code.</span>
<span class="comment-copy">@user1008636 I guess, athough, it relies on clearly documented behavior, I'm not sure why you would consider it bad programming. I think if you are familiar with the iterator protocol and iterators in general it is clear enough.</span>
