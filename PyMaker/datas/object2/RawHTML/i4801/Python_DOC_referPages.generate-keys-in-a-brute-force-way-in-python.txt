<div class="post-text" itemprop="text">
<p>I am trying to generate all possible keys on a known <code>key_length</code> on Python.
Keys are defined as list of integers between 0 and 255.
I am having trouble to generate all the possible keys...</p>
<p>If <code>key_length</code> were a constant number such as 2, I would have known how to handle this - it's just 2 for-loops, you know. However, when it's in a variable then I don't know how many for-loops I need to write. I guess I need a different approach. That's what make it difficult for me.</p>
<p>Thanks for the help!</p>
</div>
<div class="post-text" itemprop="text">
<p>you could use <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools%20product#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>from itertools import product

key_length = 2
for items in product(range(256), repeat=key_length):
    print(items)

# (0, 0)
# (0, 1)
# ...
# (255, 254)
# (255, 255)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this probably fastest with numpy's indices</p>
<pre><code>import numpy as np
max_dim = 3
comb=np.indices(tuple([256 for i in range(max_dim)])).T.reshape(-1,max_dim)
print comb
</code></pre>
<p>You you want to do it by yourself, it is gonna be more complicated</p>
<pre><code>from copy import deepcopy
x = [[i,] for i in range(256)]
max_dim = 4

comb = x
dim = 1

while dim &lt; max_dim:
    new_comb = []
    for c in comb:
        for i in x:
            a = deepcopy(c)
            a.append(i[0])
            new_comb.append(a)
    comb = new_comb
    dim += 1
print comb   
</code></pre>
<p>x is a list wit all combinations of 1 digit</p>
<p>while the dimension is lower than the maximal number you give I add all possible digits to all previous combinations. Note, that you have to copy the previously found combination because of the mutuability of a python list. </p>
</div>
<span class="comment-copy">Can you add your two for-loop approach?</span>
<span class="comment-copy">So you know how to generate all N-length keys if you already have all N-1-length keys?</span>
<span class="comment-copy">sure. it would be somthing like this: <code>key = [0 for i in range(key_length); for i in range(255): for j in range(255): key[0] = i; key[1]=j; attempt(ciphertext,key)</code> [sorry for the mess, i am new to sof]</span>
<span class="comment-copy">that only works for two dimsions</span>
<span class="comment-copy">@Glostas not sure i understand; <code>key_length</code> can be any integer (but the complexity will prevent you from choosing it much bigger than 2...)</span>
<span class="comment-copy">you need to loop over key_length since he does not know the number dimensions</span>
<span class="comment-copy">@Glostas the question mentiones a 'on a known key_length'; without <code>itertools.product</code> this is indeed difficult to do. i think that is what the question is about.</span>
<span class="comment-copy">Oh, okay... I understood it differently. I thought that the number of key_length is variable. After rereading the question I tend to be on your side</span>
