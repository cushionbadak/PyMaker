<div class="post-text" itemprop="text">
<p>I've read many related threads here and gone deep into the doc (Python 3.6), but didn't find why this happens (captured from Python shell):</p>
<pre><code>with open('default_SysEx.syx', 'rb')
 as f:
    x = f.read(1)

x

b'\xf0'

with open('default_SysEx.syx', 'rb') as f:
    y=f.read()

y[0]

240

type(x)
&lt;class 'bytes'&gt;

type(y[0])
&lt;class 'int'&gt;
</code></pre>
<p>What interprets the single-read byte? is it the read(), is it the list? sequence/iterable/generator/yield/...?</p>
</div>
<div class="post-text" itemprop="text">
<p>The clue is in the type of the objects you are printing. While x and y are both <code>bytes</code> objects, you are printing the "whole" one character string <code>x</code>, while you are printing a single byte of it with <code>y[0]</code>.</p>
<p>You will probably find that <code>x[0]</code> similarly evaluates to 240.</p>
<p>In other words, <code>type('\xf0')</code> is <code>bytes</code>, but <code>type('\xf0[0])</code> is <code>int</code>.</p>
</div>
<span class="comment-copy">Both results are exactly the same type, only the length differs.  Look at <code>type(y)</code>, and <code>type(x[0])</code> - you'll see that they are the same for both variables.</span>
<span class="comment-copy">Not sure if this is exactly what you're asking, but from the <a href="https://docs.python.org/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview" rel="nofollow noreferrer">docs</a>: <i>Since bytes objects are sequences of integers (akin to a tuple), for a bytes object b, <code>b[0]</code> will be an integer, while <code>b[0:1]</code> will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1)</i></span>
