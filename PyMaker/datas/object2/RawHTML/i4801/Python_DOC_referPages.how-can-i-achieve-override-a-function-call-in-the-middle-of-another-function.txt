<div class="post-text" itemprop="text">
<p>I am writing a Python3 program, in which I need to be able to override some method on the fly. My folder structure is more like:</p>
<pre><code>./
prog.py
methods/
  add.py
  minus.py
</code></pre>
<p>In <code>prog.py</code> I want to call a <code>calc()</code> function which is defined both in <code>add.py</code> and <code>minus.py</code>. I wish that the code can work as if:</p>
<pre><code>def prog('foo'):
    from method.foo import calc
    calc()
</code></pre>
<p>But importing in the middle of a function seems awful and might slow down the whole program. Is there any workaround that can achieve the same effect?</p>
<p>I am trying to be flexible so that I can add more methods later on, so I avoid if statements and import all the modules at once.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have 2 options:</p>
<ul>
<li>Import the modules, and use the module name with <code>calc</code> attributes.</li>
<li>Import the <code>calc</code> functions under alternate names with <code>from ... import ... as</code></li>
</ul>
<p>Either way, I'd store the function references in a dictionary, rather than use <code>if .. elif</code> to pick one.</p>
<p>The first approach</p>
<pre><code>from method import add
from method import minus

calc_functions = {
    'add': add.calc,
    'minus': minus.calc,
}

def prog(method):
    return calc_functions[method]()   
</code></pre>
<p>or the second:</p>
<pre><code>from method.add import calc as addition
from method.minus import calc as subtraction

calc_functions = {
    'add': addition,
    'minus': subtraction,
}

def prog(method):
    return calc_functions[method]()   
</code></pre>
<p>If you needed to import modules <em>dynamically</em>, then use <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer"><code>importlib.import_module()</code></a>, no need to worry about name clashes:</p>
<pre><code>import importlib

def prog(method):
    try:
        calc_module = importlib.import_module('method.' + method)
    except ModuleNotFoundError:   # or ImportError in Python &lt; 3.6
        raise ValueError('No such method {!r}'.format(method))
    return calc_module.calc()

    return calc_functions[method]()   
</code></pre>
</div>
<span class="comment-copy">Is there something preventing you from just calling the functions in the branches of the if statement, or is it something more complicated than the example shows?</span>
<span class="comment-copy">No, but I am thinking of add different calc() from time to time. In reality I hope to realize that prog(add) imports method.add without using if statements. I will modify my question... @BHustus</span>
<span class="comment-copy">Ohh, so you want to be able to dynamically load a module from some path?</span>
<span class="comment-copy">If you want to <i>dynamically import</i> something, there are some methods to do that at runtime. I'm not going to post this as a formal answer because I haven't tested this and I wouldn't recommend taking my word at face value, but look into <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer"><code>importlib.import_module</code></a> and judicious use of <code>del</code>, see if that gets what you need.</span>
<span class="comment-copy">That is correct... with out causing troubles.:) @BHustus</span>
<span class="comment-copy">This is neat, but in my case I will need to change the code every time I add some new calc() methods. Is it possible to do it dynamically?</span>
<span class="comment-copy">@7O'clock: yes, you can import modules dynamically, see <a href="//stackoverflow.com/q/301134">Dynamic module import in Python</a></span>
