<div class="post-text" itemprop="text">
<p>I get a Keyerror when doing a for loop on a set of int values. </p>
<p>Here is the code: </p>
<pre><code># groupes : dict[str:set[int]]
groupes = {'cinephiles':{802,125,147,153}, \
'travaux manuels':{125,802,153}, \
'cuisine':{153,147,802}, \
'sport':{153,538,802}}

# This first function helps me for the second one

def proximite_groupes(group, hobby_1, hobby_2):
    """ 
       dict[str:set[int]] * str * str -&gt; float
    """

    # intersection_set : set[int]
    intersection_set = set()
    # union_set : set[int]
    union_set = set()

    # cle : int
    for cle in group[hobby_1]:
        if cle in group[hobby_2]:
            intersection_set.add(cle)


    for cle in group[hobby_1]:
        if cle not in union_set:
            union_set.add(cle)

    for cle in group[hobby_2]:
        if cle not in union_set:
            union_set.add(cle)


    return len(intersection_set) / len(union_set)


def fusion_groupes(group):
    """ 
       dict[str:set[int]] -&gt; dict[str:set[int]]
    """

    # similarite_max : int
    similarite_max = 0.0
    # str_1 : str
    # str_2 : str
    # str_1_final : str
    str_1_final = ''
    str_2_final = ''
    # str_1_final : str
    # str_final : str
    str_final = ' '
    # final_dict : dict[str:set[int]]
    final_dict = group
    # intersection_set : set[int]
    intersection_set = set()

    for str_1 in group:
        for str_2 in group:
            if str_1 != str_2:
                if proximite_groupes(group, str_1, str_2) &gt; similarite_max:
                    similarite_max = proximite_groupes(group, str_1, str_2)
                    str_final = str_1 + '_' + str_2
                    str_1_final = str_1
                    str_2_final = str_2

    del final_dict[str_1_final]
    del final_dict[str_2_final]

    # Creation ensemble union
    for cle in group[str_1_final]:
        if cle in group[str_2_final]:
            intersection_set.add(cle)

    final_dict[str_final] = intersection_set

    return final_dict
</code></pre>
<p>The purpose of the function is a little bit hard to difficult, but my problem here is:</p>
<pre><code>File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 261, in fusion_groupes (note that the line would not be the same for you because my program has more lines)
KeyError: 'cuisine' 
</code></pre>
<p>(but one time it's 'cuisine', the other time its 'cinephiles', or 'sport', ...</p>
</div>
<div class="post-text" itemprop="text">
<p>My two cents on these lines being the culprit.<br/>
<code>final_dict = group
 del final_dict[str_1_final]
 del final_dict[str_2_final]</code> .<br/>
This has to do with the fact that python does not deep copy your dictionary named group into final_dict. Instead final_dict is just referencing group. So when you delete the key from final_dict, it gets deleted from group as well. And the code below it:<br/>
<code>for cle in group[str_1_final]:</code> .<br/>
Fails.<br/>
Here's the sample of what happened: <a href="https://trinket.io/python/64f20460d9" rel="nofollow noreferrer">https://trinket.io/python/64f20460d9</a></p>
</div>
<span class="comment-copy">It looks like you cut out the actual code line while editing the traceback.</span>
<span class="comment-copy">I'm sorry but I don't understand what you mean?</span>
<span class="comment-copy">The traceback usually contains code, yours does not. It has some remarks instead. The missing code makes is far less helpful.</span>
<span class="comment-copy">When you add an item to a set you don't need to check whether they are incident, sets arenâ€™t multisets.</span>
<span class="comment-copy">Also, sets support <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.intersection" rel="nofollow noreferrer">intersection</a> and <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.union" rel="nofollow noreferrer">union</a> operations, no need to roll your own. Your whole first function could be written as <code>def proximite_groupes(group, hobby_1, hobby_2): return len(groupes[hobby1] &amp; groupes[hobby2]) / len(groupes[hobby1] | groupes[hobby2])</code> ...</span>
<span class="comment-copy">As a solution, use this: final_dict = dict(group) OR final_dict = group.copy(), And then continue with your code</span>
<span class="comment-copy">Thanks !!! It worked !!</span>
