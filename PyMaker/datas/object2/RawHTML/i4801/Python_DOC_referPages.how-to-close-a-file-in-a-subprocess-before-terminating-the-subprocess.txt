<div class="post-text" itemprop="text">
<p>I want to make a subprocess(writer.py) that keeps adding "test" to a file('20180309.txt') every second and maintain the subprocess with another python process(starter.py). </p>
<p>It works fine, but one thing that bothers me is that <code>the file object</code> is not closed before terminating the subprocess. I'd like to know if there's a way to close the file object when the subprocess recieves terminate() signal, or if there are other ways to handle this problem.</p>
<pre><code>#starter.py
import os
import sys
import subprocess

p1 = subprocess.Popen( ["d:\python36-32\python.exe", r"""writer.py"""], shell=False )
print(p1.pid)

try:
    p1.communicate(timeout=5)
except subprocess.TimeoutExpired:
    p1.terminate()




#writer.py
import time
from datetime import datetime

file = open( datetime.now().strftime('%Y-%m-%d') + '.txt', 'a')

while True:
    file.write('test\n')
    file.flush()
    time.sleep(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, any modern OS will close any (non-shared) files that a process has open when it goes away. You do not have to worry about this.</p>
<p>In a more complex application, you might want to worry about partial writes (or parts of any other "transactions" that can't be done atomically), but for simple cases, there's nothing to worry about at all.</p>
<p>Meanwhile, the <code>terminate</code> method in <code>subprocess</code> is not meant for polite shutdown requests. If you want to shut down the child, there are better ways to send it a message. In fact, since the child and parent are both Python, you may be happier using <code>multiprocessing</code> instead of <code>subprocess</code> in the first place.</p>
<p>That being said, on *nix, <code>terminate</code> happens to send <code>SIGTERM</code>, and <code>SIGTERM</code> <em>is</em> designed for polite shutdown. If you really want to handle this—and don't care about Windows—read the <a href="https://docs.python.org/3/library/signal.html" rel="nofollow noreferrer"><code>signal</code></a> library for how to write a signal handler for <code>SIGTERM</code>. From the signal handler, you can set a global "quit next time through the loop" variable. or call <code>sys.exit</code> (which I think will raise an exception into the top-level code, but don't quote me on that), or whatever else you want.</p>
</div>
<span class="comment-copy">Assuming you're using Windows, *nix, or any other OS made in the last ~25 years, the OS will automatically close any files left open by a process when it goes away (except for files that are shared in some way—e.g., handed in by the parent, or less common cases like being passed over a Unix socket, WIn32 DuplicateHandle, etc.).</span>
<span class="comment-copy">Have you tried using multiprocessing for this instead of a subprocess? It's much cleaner for Python to Python communication and allows better control of the process.</span>
<span class="comment-copy">@Nebbles Thank you for your advice. I thought a subprocess is part of multiprocessing. I will study on it!</span>
<span class="comment-copy">Thank you for your detailed answer! I have learned a lot thanks to you!</span>
