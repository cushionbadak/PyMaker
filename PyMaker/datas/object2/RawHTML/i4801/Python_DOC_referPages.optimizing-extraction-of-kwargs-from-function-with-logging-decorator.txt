<div class="post-text" itemprop="text">
<p>What's the best way NOT to have to extracts the SAME KWARGS <strong>twice</strong>: once in the decorator (wrapper function) and once in the function itself.</p>
<p>Here is the function:</p>
<pre><code>@close_logger
def close(**kwargs):
    """ returns close object"""

    # Get params
    session_attributes = kwargs.get('sessionAttrbiutes', {})
    message = kwargs.get('message', '')
    LID = kwargs.get('LIData', {})
    SANS = kwargs.get('SANS', [])
    FS = kwargs.get('fulfillmentState', 'Fulfilled')

    response = {
        'sessionAttributes': session_attributes,
        'dialogAction': {
            'type': SANS,
            'fulfillmentState': FS,
            'message': {
                'contentType': LID,
                'content': message
            }
        }
    }

    return response
</code></pre>
<p>and here is the decorator (used for logging the close event):</p>
<pre><code>def close_logger(func):

    @functools.wraps(func)
    def wrapper(**kwargs):

        # Get params
        session_attributes = kwargs.get('sessionAttrbiutes', {})
        message = kwargs.get('message', '')
        LID = kwargs.get('LIData', {})
        SANS = kwargs.get('SANS', [])
        FS = kwargs.get('fulfillmentState', 'Fulfilled')

        logger.debug('Logging:\n Function:{} Session Attributes: {}\n \
        Message{}\n: LID: {}\n SANS: {}\n FS: {}'.format(
            func.__name__,
            session_attributes,
            message,
            LID,
            SANS,
            FS
        ))

        return func(**kwargs)

    return wrapper
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Start by making your keyword arguments explicit for the <code>close</code> function.</p>
<pre><code>def close(sessionAttrbiutes=None, message='', LIData=None, SANS=None, fulfillmentState='Fulfilled'):
    if sessionAttrbiutes is None:
        sessionAttrbiutes = {}
    ...
</code></pre>
<p>Note that I used <code>None</code> as default values for the mutable default values to avoid a <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#mutable-default-arguments" rel="nofollow noreferrer">common pitfall</a>.</p>
<p>Then in your decorator use <code>inspect.getfullargspec</code>, similar to <a href="http://%20https://stackoverflow.com/a/12627202/4042267" rel="nofollow noreferrer">this answer</a>:</p>
<pre><code>import inspect
import functools

def get_default_args(func):
    """
    returns a dictionary of arg_name:default_values for the input function
    """
    argspec = inspect.getfullargspec(func)
    return dict(zip(reversed(argspec.args), reversed(argspec.defaults)))


def close_logger(func):
    @functools.wraps(func)
    def wrapper(**kwargs):
        kwargs_local = get_default_args(func)
        kwargs_local.update(kwargs)

        logger.debug("""Logging:
Function: {}
Session Attributes: {sessionAttrbiutes}
Message: {message}
LID: {LIData}
SANS: {SANS}
FS: {fulfillmentState}""".format(func.__name__, **kwargs_local))

        return func(**kwargs)

    return wrapper
</code></pre>
<p>This will raise a <code>KeyError</code> if one of those fields is not defined (either in the signature or the passed keywords). Of course it will show <code>None</code> for those where that is the default in the signature.</p>
<p>The full argspec will also contain positional arguments, so you might be able to figure those out as well.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><code>**</code>-notation can be used within function argument lists to both pack and unpack arguments.</strong></p>
<p><code>**</code>-notation within a <strong>function definition</strong> collects all the values into a dictionary.</p>
<pre><code>&gt;&gt;&gt; def kwargs_in_definition(**kwargs): return kwargs
&gt;&gt;&gt; kwargs_in_definition(arg1 = 1, arg2 = 2, arg3 = 3)
{'arg1': 1, 'arg2': 2, 'arg3': 3}
</code></pre>
<p><code>**</code>-notation within a <strong>function call</strong> unpacks all the values as keyword argumnts.</p>
<pre><code>def kwargs_in_call(arg1 =0, arg2 = 0, arg3 = 0): return arg1, arg2, arg3
</code></pre>
<p>So when you pass kwargs (kwargs := {'arg1': 1, 'arg2': 2, 'arg3': 3}) to <code>kwargs_in_call</code> you get this:</p>
<pre><code>&gt;&gt;&gt; kwargs_in_call(kwargs)
({'arg1': 1, 'arg2': 2, 'arg3': 3}, 0, 0) # kwargs is used as arg1.
</code></pre>
<p>...but if you unpack it first:</p>
<pre><code>&gt;&gt;&gt; kwargs_in_call(**kwargs)
(1, 2, 3) # kwargs unapcks to "arg1 = 1, arg2 = 2, arg3 = 3"
</code></pre>
<p><strong>All of this applies for <code>*</code> as well</strong></p>
<p><strong>Your specific case:</strong></p>
<p><code>**kwargs</code> in a function defintion gives you a regular old <code>dict</code>. You can turn that dictionary into a list -- however you wish to do that --, unpack that list and pass it on to another function. You'll have to account for ordering though, so it's difficult to make this work for all functions.</p>
<p>I'm not sure why you insist on your decorator function taking keyword arguments while your decorated function doesn't. You can, of-course, do whatever you want, but I would argue against such an approach, because you're decorator function is changing how your actual function behaves.</p>
<p>If you manage to sort those keyword arguments in to a valid argument list you'll be good.</p>
<p>Hope this helps.</p>
<p><strong>EDIT:</strong> Oh, I forgot to point out that you're unpacking <code>**kwargs</code> in your decorator function (<code>return func(**kwargs)</code>) and then you're repacking them in your actual function (<code>def close(**kwargs):</code>. I'll be honest, that's a silly thing to do.</p>
<p><strong>EDIT:</strong> You can use <a href="https://docs.python.org/3/library/inspect.html#inspect.getargspec" rel="nofollow noreferrer"><code>inspect.getargspec</code></a> or <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>inspect.signature</code></a> to get a functions argument list. If you just have your decorator take in <code>*args</code>, you can match each value to a corresponding name from the argument list.</p>
</div>
<span class="comment-copy">Note: You have a typo, <code>'sessionAttrbiutes'</code> should probably be <code>'sessionAttributes'</code>.</span>
<span class="comment-copy">Why does your function need to take <code>**kwargs</code> as input, rather than those specific arguments you need?</span>
<span class="comment-copy">because I'm trying to have an all purpose logging decorator for several functions each with a different set of args. Does that make sense?</span>
<span class="comment-copy">@Bas That just means that <code>close_logger</code> needs to take <code>**kwargs</code>. <code>close</code> can have named keyword arguments with defaults.</span>
<span class="comment-copy">Hi @Graipher I guess that's what I'm trying to figure out.... if 'close' has (*args) only, how can they be passed as **kwargs to a decorator? A bit more details would be very helpful.... Tks.</span>
<span class="comment-copy">Thanks....I feel that a good solution is to have all functions WRITTEN with positional arguments (*args) but CALLED using keyword arguments (**kwargs). This will not confuse the wrapper function in the logging decorator but also makes sure we 'extract' the arguments only once (in the wrapper). Is this a good approach?</span>
<span class="comment-copy">Thanks Palivek..... and yes I agree that ideally you shouldn't have a decorator with keyword arguments (**kwargs) and a decorated function with positional arguments (*args). But if that decorator needs to be a multi-purpose logger that logs (arg_name and arg_value) for every arg in the decorated function, is there a better way to do it? off course, each of the decorated functions has a different set of arguments (otherwise this wouldn't be a problem). Thanks.</span>
<span class="comment-copy">@Bas Hmmmm, I guess you could add another level to your logger, which would accept an ordered list of argument names. You're decorator would end up looking like this though: <code>close_logger(...list of agument names...)</code>. You could maybe also create another wrapper that adds an argument names list attribute to your function. Alas, I don't think there's anyway to automatically create such a list.</span>
<span class="comment-copy">@Bas I think I might have figured it out. I added an eddit to my solution.</span>
<span class="comment-copy">thanks..... as my comment on the other posted solution, here is what I'm suggesting: Having all functions WRITTEN with positional arguments (*args) but CALLED using keyword arguments (**kwargs). This will not confuse the wrapper function in the logging decorator but also makes sure we 'extract' the arguments only once (in the wrapper). Is this a good approach?</span>
<span class="comment-copy">@Bas With what I suggested in my last edit, you can have both functions called with positional arguments, because the wrapper function's argument list is the same as your actual function's. Then you can use either <code>inspect.getargspec</code> or <code>inspect.singature</code> to make name and value pairs to print. Your actual function then, shouldn't need to take any number of keyword arguments as input, but rather only the ones it needs.</span>
