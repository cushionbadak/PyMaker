<div class="post-text" itemprop="text">
<p>I want to add multiple values in overlapped(same one, i mean) key by using .get()</p>
<p>I already searched google with these kewords but they were kinda different problems. So, I'm just looking for new method to solve this. </p>
<p>'''
dictionary = {}</p>
<p>dictionary[key] = dictionary.get(key, {}) + {value}
'''
but apparently this code is impossible and there's TypeError  +: 'set' and 'set'
so I tried to make two dictionary and put default is [] and + [value]
but it wasn't work, too...</p>
<p>'''
for example,</p>
<p>key = exercise, study, music, etc...
values = exercise : basketball, football , study : science, history, math , muscic : classic etc</p>
<p>Result that i want is...</p>
<p>{'excercise': {'basketball', 'football'}, 'study': {'science', 'history', 'math'}, 'muscic': {'classic'} ..}
'''</p>
<p>What should I do?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're close, but this isn't quite right:</p>
<pre><code>dictionary[key] = dictionary.get(key, {}) + {value}
</code></pre>
<p>Unfortunately, <code>{}</code> is not the way you write an empty <code>set</code> (because it already means an empty <code>dict</code>, and it would be ambiguous); you need <code>set()</code> instead.</p>
<p>Your <code>{value}</code> is already, correctly, a <code>set</code>.</p>
<p>But to union two sets together (that is, to add all the values from one to the other), you need to use <code>|</code>, not <code>+</code>.</p>
<p>So:</p>
<pre><code>dictionary[key] = dictionary.get(key, set()) | {value}
</code></pre>
<hr/>
<p>You can actually make this easier:</p>
<pre><code>dictionary.setdefault(key, set()).add(value)
</code></pre>
<p>The <code>setdefault</code> does the <code>get</code> and assigning all in one step. And then we mutate the looked-up-or-created set by calling its <code>add</code> method. Which means we don't need to create a one-element set <code>{value}</code> just to union with the old one, we can just pass <code>value</code> directly.</p>
<p>Alternatively, you can make your dictionary a <code>defaultdict(set)</code>, and it will automatically (in effect) turn every <code>dictionary[key]</code> into a <code>dictionary.setdefault(key, set())</code>. Whether this is better or worse depends on whether you have some later code that should look up values and actually fail rather than create empty sets.</p>
</div>
<div class="post-text" itemprop="text">
<p>First things first, what does the error mean? Basically, <code>+</code> isn't defined for sets. </p>
<pre><code>&gt;&gt;&gt; s1 = set([1])
&gt;&gt;&gt; s2 = set([2])
&gt;&gt;&gt; s1 + s2
Traceback (most recent call last):
   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'set' and 'set'
</code></pre>
<p>Instead, you want <code>union</code>: </p>
<pre><code>&gt;&gt;&gt; s1.union(s2)
set([1, 2])
</code></pre>
<p>Switching to <code>union</code> would solve your problem (aside, from as noted by the other answers that <code>{}</code> is a dictionary), but you may be interested in <code>defaultdict</code>. Something like:</p>
<pre><code>from collections import defaultdict
dictionary = defaultdict(set)
dictionary[key].add(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>.get</code> doesn't add the value when it's missing. <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>.setdefault</code> does</a>. Also, <code>{}</code> is the empty <code>dict</code>, not the empty <code>set</code> (<code>set()</code>). So you could just do:</p>
<pre><code>dictionary.setdefault(key, set()).add(value)
</code></pre>
<p>but that's actually rather inefficient, because it needs to construct empty <code>set</code>s whether or not the key already exists. So the best solution is to <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">use <code>collections.defaultdict</code></a> to handle lazily constructing the new <code>set</code> as needed and <em>only</em> as needed (when the <code>key</code> doesn't exist):</p>
<pre><code>from collections import defaultdict

dictionary = defaultdict(set)

...

dictionary[key].add(value)
</code></pre>
</div>
<span class="comment-copy">Do you really need Dictionary of dictionaries  or not like this right?  <code>{'excercise': ['basketball', 'football'], 'study': ['science', 'history', 'math'[, 'muscic': ['classic'] ..} </code>  dictionary with list of values ?</span>
<span class="comment-copy">You can always use <code>mydefaultdict.default_factory = None</code></span>
<span class="comment-copy">@juanpa.arrivillaga Sure, but it's hardly clearer to have a defaultdict that isn't currently defaulting than to have a plain old dict.</span>
<span class="comment-copy">The fact that <code>get</code> doesn't add the value isn't relevant here, because he's explicitly assigning the result back to <code>dictionary[key]</code>. (It's true that <code>setdefault</code> can <i>simplify</i> things, of course.)</span>
<span class="comment-copy">Also, <code>set()</code> isn't all that slow (after all, every time you write <code>[]</code> or <code>{}</code> it also has to create a new list or dict, and that isn't a performance problem), and neither is <code>setdefault</code>. The right reason to choose between <code>setdefault</code> and <code>defaultdict</code> is whether all of your code should automatically create a new value, or whether you have "setup" code that should create a new value and then "lookup" code that should fail.</span>
<span class="comment-copy">@abarnert: <code>set()</code> takes about 4x as long as <code>[]</code> or <code>{}</code>, due to inefficiencies in general constructor lookup and calls (where <code>[]</code> and <code>{}</code> have direct byte code support). Admittedly, the cost is fairly small even so, but that cost (whether for <code>set()</code> or <code>[]</code>) is part of why <code>defaultdict</code> exists at all. I agree that <code>.get</code> can be made to work, but the original scenario proposed is even more ridiculous, since it involves constantly constructing multiple new <code>set</code>s every time (<code>{value}</code>, the default, and the result of combining them), rather than just updating a single <code>set</code> in place.</span>
<span class="comment-copy">Sure, it takes nearly 100ns instead of 30ns, but that's incredibly unlikely to be relevant in the OP's case. Clarity is probably going to be more important, and correct behavior will definitely be more important. If you expect to get <code>KeyError</code> later and instead silently get new values created, you have a bug caused by using <code>defaultdict</code>. If you expected to have defaulting behavior everywhere in your program and forgot a <code>setdefault</code> in one place, you have a bug caused by not using <code>defaultdict</code>.</span>
<span class="comment-copy">As for the original scenario being ridiculousâ€”once you fix the bug, it really isn't. It's certainly less simple than using <code>setdefault</code> or <code>defaultdict</code> and mutating the <code>set</code> in-place, but if it's something the OP can understand (and can very nearly write without help), that's better than something that looks like magic to them. (But of course everyone ought to learn about <code>setdefault</code> and <code>defaultdict</code>, so it's worth teaching them here too.)</span>
