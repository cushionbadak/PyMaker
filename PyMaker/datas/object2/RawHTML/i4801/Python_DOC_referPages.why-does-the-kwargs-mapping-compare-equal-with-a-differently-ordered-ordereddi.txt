<div class="post-text" itemprop="text">
<p>According to <a href="https://www.python.org/dev/peps/pep-0468/" rel="nofollow noreferrer">PEP 468</a>:</p>
<blockquote>
<p>Starting in version 3.6 Python will preserve the order of keyword arguments as passed to a function. To accomplish this the collected <strong>kwargs will now be an ordered mapping</strong>. Note that this does not necessarily mean <code>OrderedDict</code>.</p>
</blockquote>
<p>In that case, why does this ordered mapping fail to respect equality comparison with Python's canonical ordered mapping type, the <code>collections.OrderedDict</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; data = OrderedDict(zip('xy', 'xy'))
&gt;&gt;&gt; def foo(**kwargs):
...     return kwargs == data
... 
&gt;&gt;&gt; foo(x='x', y='y')  # expected result: True
True
&gt;&gt;&gt; foo(y='y', x='x')  # expected result: False
True
</code></pre>
<p>Although iteration order is now preserved, <code>kwargs</code> seems to be behaving just like a normal dict for the comparisons. Python has a C implemented ordered dict <a href="https://bugs.python.org/issue16991" rel="nofollow noreferrer">since 3.5</a>, so it could conceivably have been used directly (or, if performance was still a concern, a faster implementation using a thin subclass of the 3.6 compact dict).</p>
<p><strong>Why doesn't the ordered mapping received by a function respect ordering in equality comparisons?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>The answer to your first 'why' is because this feature is implemented by using a plain <code>dict</code> in CPython. As @Ryan's answer points out, this means that comparisons won't be order-sensitive. </p>
<p>The second 'why' here is why this doesn't use an <code>OrderedDict</code>. </p>
<p>Using an <code>OrderedDict</code> was the initial plan as stated in the <a href="https://github.com/python/peps/commit/c7a4a5842f56fbbc179dae567d225fa6b5038bb9#diff-ad534f0374d5a1f27d0657692ef27d77R180" rel="nofollow noreferrer">first draft</a> of PEP 486. The idea, as stated <a href="https://mail.python.org/pipermail/python-ideas/2014-April/027518.html" rel="nofollow noreferrer">in this reply</a>, was to collect some perf data to show the effect of plugging in the <code>OrderedDict</code> since this was a point of contention when the idea was floated around before. The author of the PEP even alluded to the order preserving dict being another option in the <a href="https://mail.python.org/pipermail/python-ideas/2014-April/027477.html" rel="nofollow noreferrer">final reply</a> on that thread.</p>
<p>After that, the conversation on the topic seems to have died down until Python 3.6 came along. When the new dict came, it had the nice side-effect of just implementing PEP 486 out of the box (as <a href="https://mail.python.org/pipermail/python-dev/2016-September/146327.html" rel="nofollow noreferrer">this Python-dev thread states</a>). The specific message in that thread also states how the author wanted the term <code>OrderedDict</code> to be changed to Ordered Mapping. (This is also when a <a href="https://github.com/python/peps/commit/9cf9ffb58722c6cbed6d2ed297fb173795798773#diff-ad534f0374d5a1f27d0657692ef27d77L180" rel="nofollow noreferrer">new commit on PEP 468</a>, after the initial one, was made)</p>
<p>As far as I can tell, this rewording was done in order to allow other implementations to provide this feature as they see fit. CPython and PyPy already had a dict that easily implemented PEP 468, other implementations might opt for an <code>OrderedDict</code>, others could go for another form of an ordered mapping.</p>
<p>That does open the door for a problem, though. It does mean that, theoretically, in an implementation of Python 3.6 with an <code>OrderedDict</code> as the structure implementing this feature, the comparison would be order-sensitive while in others (CPython) it wouldn't. (In Python 3.7, all <code>dict</code>s are required to be insertion-ordered so this point is probably moot since all implementations would use it for <code>**kwargs</code>)</p>
<p>Though it does seem like an issue, it really isn't. As @user2357112 pointed out, there's no guarantee on <code>==</code>. PEP 468 <em>only</em> guarantees order. As far as I can tell, <code>==</code> is basically implementation defined.</p>
<hr/>
<p>In short, it compares equal <em>in CPython</em> because <code>kwargs</code> in CPython is a <code>dict</code> and it's a <code>dict</code> because after <code>3.6</code> the whole thing just worked.</p>
</div>
<div class="post-text" itemprop="text">
<p>Regardless of what an “ordered mapping” means, as long as it’s not necessarily <code>OrderedDict</code>, <code>OrderedDict</code>’s <code>==</code> won’t take into account its order. <a href="https://docs.python.org/3/library/collections.html#ordereddict-objects" rel="noreferrer">Docs:</a></p>
<blockquote>
<p>Equality tests between <code>OrderedDict</code> objects are order-sensitive and are implemented as <code>list(od1.items())==list(od2.items())</code>. <strong>Equality tests between <code>OrderedDict</code> objects and other <code>Mapping</code> objects are order-insensitive like regular dictionaries.</strong> This allows <code>OrderedDict</code> objects to be substituted anywhere a regular dictionary is used.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>"Ordered mapping" only means the mapping has to preserve order. It doesn't mean that order has to be part of the mapping's <code>==</code> relation.</p>
<p>The purpose of PEP 468 is just to preserve the ordering information. Having order be part of <code>==</code> would produce backward incompatibility without any real benefit to any of the use cases that motivated PEP 468. Using <code>OrderedDict</code> would also be more expensive (since <code>OrderedDict</code> still maintains its own separate linked list to track order, and it can't abandon that linked list without sacrificing big-O efficiency in <code>popitem</code> and <code>move_to_end</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to add, if you do want to make this check (without relying on an implementation detail (which even then, won't be in python 3.7)), just do</p>
<pre><code>from collections import OrderedDict
&gt;&gt;&gt; data = OrderedDict(zip('xy', 'xy'))
&gt;&gt;&gt; def foo(**kwargs):
...     return OrderedDict(kwargs) == data
</code></pre>
<p>since this is guaranteed to be True.</p>
</div>
<span class="comment-copy">What about the part that says "<i>Note that this does not necessarily mean <code>OrderedDict</code></i>"?</span>
<span class="comment-copy">Yes, what about it?</span>
<span class="comment-copy">So you are comparing it to <code>OrderedDict</code>, maybe, that's not what is meant by "ordered mapping"</span>
<span class="comment-copy">Great finds Jim, this seems to be the correct answer (particularly <a href="https://mail.python.org/pipermail/python-dev/2016-September/146327.html" rel="nofollow noreferrer">this</a> part). The **kwargs iteration order was a "happy accident" of other developments in the dict type.  So, they dusted off the PEP 486 and accepted it, but that was more or less a side effect of compact dict impl.  I do think they could have re-worded the PEP more carefully, because any "ordered mapping" worth its salt should likely have the ordering considered by eq comparisons.</span>
<span class="comment-copy">i.e., the 3.6 dict is not an ordered mapping, it's just a mapping that happens to preserve insertion order.</span>
<span class="comment-copy">@wim The PEP is probably not as fleshed out as you would expect since it didn't go through the usual Python-dev iterations other PEPs go through. Also, yes, it isn't ordered in the sense that <code>OrderedDict</code> is defined to be. Using "ordered" is misleading but "marketing" I guess. I'll guess I need to clarify that in a couple of my answers.</span>
<span class="comment-copy">3.6 dict order is implementation detail, but the <code>kwargs</code> object received by a function being an ordered mapping is not an implementation detail.  So it should have correct equality comparisons with other ordered mappings, shouldn't it?</span>
<span class="comment-copy">@wim: Added some parentheses.</span>
<span class="comment-copy">@wim Regarding you equality operator, you cannot do what you want without violating the "transitive" requirement of the equals operator. That is, if <code>dict0 == ordered_dict0</code> and <code>dict0 == ordered_dict1</code>, then it must necessarily be that <code>ordered_dict0 == ordered_dict1</code>. With what you are suggesting this might not always be the case.</span>
<span class="comment-copy">@Dunes  Transitivity is already broken (<code>OrderedDict([(1,2), (3,4)]) == {1:2, 3:4} == OrderedDict([(3,4), (1,2)])</code>), so who cares?</span>
<span class="comment-copy">@wim: It's showing that the behaviour is documented. I don't think you have a strong case for expecting the comparison to take order into account.</span>
<span class="comment-copy">1. I'm not convinced on the idea that changing <code>==</code> here would have to be more expensive (though using <code>OrderedDict</code> itself would be more expensive, yes).  For example, the compact dict impl improved performance along with preserved order.  2. What backwards incompatibility would have been produced, that was not a bug in the first place?  Changing this would not effect comparisons against other dicts, only against other ordered mappings.</span>
<span class="comment-copy">@wim: 1) Changing <code>==</code> for <i>all</i> dicts would break an absurd amount of code for no practical reason, and making a new dict subclass just to have order be part of <code>==</code> would add complexity for no real benefit, as well as introducing interoperability issues with OrderedDict. 2) Any code relying on the old definition of <code>==</code> would break. Relying on the definition of <code>==</code> isn't a bug. Also, C code that uses PyDict_Whatever to access keyword argument dicts would need to be reexamined if keyword arguments come in a dict subclass or other mapping type.</span>
<span class="comment-copy">I'm aware of the workaround, but why is that necessary in the first place since <i>kwargs will now be an ordered mapping</i>?</span>
<span class="comment-copy">This returns <code>False</code> for both <code>foo(y='y', x='x')</code> and <code>foo(x='x', y='y')</code></span>
<span class="comment-copy">@smac89 does it? <code>foo(x='x', y='y')</code> gives me <code>True</code>. Are you not running python 3.6, or is this something whereby <code>OrderedDict</code> doesn't add <code>dict</code> elements in order?</span>
<span class="comment-copy">@FHTMitchell, I think I was running 3.5 when I tested that. I will install 3.6 and check</span>
<span class="comment-copy">I'm not sure of the usefulness of this answer in a "Why" question. Seems more suitable as a comment, really.</span>
