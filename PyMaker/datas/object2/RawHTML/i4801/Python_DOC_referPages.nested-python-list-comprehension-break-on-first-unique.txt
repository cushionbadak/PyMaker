<div class="post-text" itemprop="text">
<p>Looking for a way to put this logic into a list comprehension:</p>
<pre><code>new_bills = []
for bill in bills:
    for gnr in bill["gnrs"]:
        if timestart &lt;= gnr["date"] &lt;= timeend:
            new_bills.append(bill)
            break
return new_bills
</code></pre>
<p>So, these are two nested dictionaries, and I only want the first instance of "bill" that fits the filter.</p>
<p>I used to have this:</p>
<pre><code>return [bill for bill in bills for gnr in bill["gnrs"] if timestart &lt;= gnr["date"] &lt;= timeend]
</code></pre>
<p>However, this duped the bill object for everytime the if clause was met.
Is there a way to get a list comprehension to behave like the for loop above? Keep in mind sets are out, as the bill is a dictionary (unhashable).</p>
<p>Edit for duplicate answer popup thing: The Solution turned out to be entirely different.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your inner loop is part of the filter:</p>
<pre><code>new_bills = [
    bill for bill in bills
    if any(timestart &lt;= gnr["date"] &lt;= timeend for gnr in bill["gnrs"])
]
</code></pre>
</div>
<span class="comment-copy"><i>"Looking for a way to put this logic into a list comprehension"</i> Why? It's far more readable with normal loops.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/9572833/break-list-comprehension">break list comprehension</a></span>
<span class="comment-copy">look into <code>itertools.takewhile</code></span>
<span class="comment-copy">@Aran-Fey The comprehensions can (and usually are) built from a GUI, how readable the python code is, is often irrelevant. Expanding the GUI parser bit would mean some additional exceptions, which would then conflict with "Special cases aren't special enough to break the rules.". And would create more work than finding a solution compatible with the already established workflow.</span>
<span class="comment-copy">If it are complete duplicates you could perhaps try a set comprehension. If you insist on using a comprehension.</span>
<span class="comment-copy">this doesn't really stops the list comprehension. It rather filters it. The only way to stop it is through aux functions passed to <code>for</code> like <code>itertools.takewhile</code></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any</a> shortcircuits.</span>
<span class="comment-copy">if won't shortcircuit <code>bills</code> in <code>for bill in bills</code>. I mean it's not going to stop iterating on it. It's just that <code>any</code> will no longer have a chance to return <code>True</code> after some iteration.</span>
<span class="comment-copy">yes, that's exactly what the original for loops do. it's only breaking from the inner loop.</span>
<span class="comment-copy">This is what I was looking for, thank you.</span>
