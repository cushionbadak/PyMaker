<div class="post-text" itemprop="text">
<p>I'm really confused about how classes work, I've written this code but get the error message </p>
<pre><code>AttributeError: 'str' object has no attribute 'pLatin_converter'
</code></pre>
<p>but surely the object does have that attribute since it is of the class <code>pigLatin_class</code>?</p>
<pre><code>class pigLatin_class (object):
    'class for converting plain text into pig latin'

    vowels = ["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]

    def __init__ (string):
        pig = ""
        movetoend = ""
        index = 0

    def pLatin_converter (string): 
        listeng = string.split()
        for word in listeng:
            length = len(word)
            movetoend = ""
            index = 0
            if word[0] not in vowels:
                for l in word:
                    if l not in vowels:
                        movetoend = movetoend + l
                        index = index + 1
                    else:
                        break
                pig = pig + " " + word[index:length] + movetoend + "ay"

            elif word[0] in vowels:
                pig = pig + " " + word[1:length] + "hay"
        print("pig latin is: " + pig)

    words = pigLatin_class()
    words = "Hi I'm Amy"
    words.pLatin_converter()
</code></pre>
<p>edit: okay i see my initial mistake, now if I input</p>
<pre><code>words = pigLatin_class("Hi I'm Amy")
words.pLatin_converter()
</code></pre>
<p>it says I've given 2 positional arguments?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>surely the object does have that attribute since it is of the class "pigLatin_class"?</p>
</blockquote>
<p>But it's not. You do create an instance of <code>pigLatin_class</code>, but then you immediately replace it with an instance of <code>str</code>:</p>
<pre><code>words = pigLatin_class()
words = "Hi I'm Amy"
</code></pre>
<p>And <code>str</code> isn't <code>pigLatin_class</code>, and doesn't have a <code>pLatin_converter</code> method.</p>
<p>I think you wanted something like this:</p>
<pre><code>words = pigLatin_class("Hi I'm Amy")
words.pLatin_converter()
</code></pre>
<p>But then you need to fix a few more bugs. Most crucially, the <code>__init__</code> method of your class has to take a <code>self</code> parameter, as well as a <code>string</code> parameter, and then it needs to store things—including that string parameter value—on that <code>self</code> to be used later:</p>
<pre><code>def __init__(self, string):
    self.string = string
    self.pig = ""
    self.movetoend = ""
    self.index = 0
</code></pre>
<p>And then, your methods will also take <code>self</code> and can use those attributes:</p>
<pre><code>def pLatin_converter(self): 
    listeng = self.string.split()
    # etc.
</code></pre>
<hr/>
<p>You may have instead wanted something like this:</p>
<pre><code>words = pigLatin_class()
words.pLatin_converter("Hi I'm Amy")
</code></pre>
<p>In that case, you won't be taking <code>string</code> as a second parameter in <code>__init__</code> and storing it in <code>self.string</code>, you'll instead be taking it as a second parameter in <code>pLatin_converter</code>. Hopefully you know enough now to change it to work that way, and to understand the difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are passing the string 'Hi I'm Amy' to the pLatin_converter() method.</p>
<p>Instead, you need to do this:</p>
<pre><code>class pigLatin_class (object):
    'class for converting plain text into pig latin'


    def __init__ (self, string):

        self.string = string
        self.vowels = ["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]

    def pLatin_converter(self):
        pig = ""
        movetoend = ""
        index = 0

        listeng = self.string.split()
        for word in listeng:
            length = len(word)
            movetoend = ""
            index = 0
            if word[0] not in self.vowels:
                for l in word:
                    if l not in self.vowels:
                        movetoend = movetoend + l
                        index = index + 1
                    else:
                        break
                pig = pig + " " + word[index:length] + movetoend + "ay"

            elif word[0] in self.vowels:
                pig = pig + " " + word[1:length] + "hay"
        print("pig latin is: " + pig)

words = pigLatin_class("Hi I'm Amy")

words.pLatin_converter()
</code></pre>
<p>You need to define variables that are class based with self.var_name and then you can access them throughout the class, by passing self as a method argument. In this case you pass the string to <strong>init</strong>() and save it in self.string variable, then you can access it when pLatin_converter() method is called.</p>
</div>
<span class="comment-copy"><i>"surely the object does have that attribute since it is of the class "pigLatin_class"?"</i> - clearly not; as the error message tells you, its a <code>str</code>ing. <code>words = "Hi I'm Amy"</code> has overwritten the instance from the line before. And no, these kinds of question aren't appropriate for this site (note: <b>not</b> forum), so please <i>don't post them</i>.</span>
<span class="comment-copy">You immediately replace your <code>pigLatin_class</code> object with a <code>str</code> object when you do <code>words = "Hi I'm Amy"</code> It <i>looks</i> like you wanted to do something like <code>words = pigLatin_class('Hi I'm Amy')</code>, but then that wouldn't work, because you've written all your methods with a single argument, thus it will be passed the instance. You need to have signature like <code>def __init__(self, string): ...</code></span>
<span class="comment-copy">You're not actually using the class to hold any state or organize any behavior here, so the simplest way to fix this would be to just scrap the class and write a plain old function that takes a <code>str</code> and returns a <code>str</code>. But if you're actually doing this to learn about how classes work… well, then see my answer, because it's too much to explain in a comment.</span>
<span class="comment-copy">in any case- your class doesn't look quite right. For one thing your <code>__init__</code> function tries to take a string but doesn't do anything with it. Read through <a href="https://docs.python.org/2/tutorial/classes.html" rel="nofollow noreferrer">docs.python.org/2/tutorial/classes.html</a> if you haven't already.</span>
<span class="comment-copy">@avigil She seems to be using Python 3 (based on <code>print</code> as a function, etc.), and that's a better default guess in 2018 anyway, so I'd link to <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html</a> instead. But otherwise, great suggestion.</span>
<span class="comment-copy">Can you explain why some of the variables need to be in <b>init</b> and are formatted self.variable but some don't?</span>
<span class="comment-copy">@AmyFawcett The <code>self.spam = …</code> variables are attributes of the object—they're shared by every method of the same object. The plain old <code>eggs = …</code> variables are local variables—they're only available within the current method. So, anything you want to store for another method to use, like the string, goes in <code>self.string</code>, while anything you want to forget about as soon as the method is done, like <code>word</code>, doesn't.</span>
<span class="comment-copy">For this example, the vowels list did not need to be in <b>init</b> and therefore did not need to be formatted with self.vowels. It is just useful if you want to call multiple methods on the variables saved in self.</span>
<span class="comment-copy">For example if you had two methods (pig_latin1 and pig_latin2) and you wanted to get the output for "Hi im Amy" on both of them, you may need to use some variables for both of those methods. Then self. would come in handy because you could define self.vowels in <b>init</b> and then access the variable in both methods</span>
