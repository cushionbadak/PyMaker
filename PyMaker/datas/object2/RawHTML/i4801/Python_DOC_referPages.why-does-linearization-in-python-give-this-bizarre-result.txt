<div class="post-text" itemprop="text">
<p>Consider this simplified situation:</p>
<pre><code>class Decoder:
    def __str__(self):
        return self.__bytes__().decode('ascii')

class Comment(Decoder, bytes):
    def __bytes__(self):
        return b'#' + self
</code></pre>
<p>Usage:</p>
<pre><code>Comment(b'foo')
</code></pre>
<p>Prints:</p>
<pre><code>b'foo'
</code></pre>
<p>Instead of expected:</p>
<pre><code>#foo
</code></pre>
<p>Regardless of the order in <code>Comment.mro()</code> (i.e. I can swap <code>Decoder</code> and <code>bytes</code> in the supeclass list), <code>Decoder.__str__()</code> is never called.</p>
<p>What gives?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>Comment(b'foo')</code> calls <code>Comment.__new__</code>, which, not being defined, resolves to either <code>Decoder.__new__</code> or <code>bytes.__new__</code>, depending on the order in which you list them in the definition of <code>Comment</code>.</p>
<p>The MRO for <code>Comment</code> is <code>Comment</code>, <code>bytes</code>, <code>Decoder</code>, <code>object</code>. However, the functions actually being called are:</p>
<ol>
<li><p><code>Comment.__new__</code>, to create a new object. Since that function isn't defined, we next call <code>bytes.__new__</code>, which is defined. It effectively just calls <code>object.__new__(Comment, b'foo')</code>, giving you your final object.</p></li>
<li><p>To <em>display</em> the return value of <code>Comment</code>, the interpreter tries to call <code>Comment.__repr__</code>, not <code>Comment.__str__</code>. Again, the function isn't defined, so it falls back to <code>bytes.__repr__</code>, giving the observed result.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you use print function you get expected result, but if you look at result from console you see the result of <code>__repr__</code> method. If you need it works in this way you can call <code>self.__str__()</code> from <code>__repr__</code></p>
<pre><code>&gt;&gt;msg = Comment(b'foo')
&gt;&gt;msg
b'foo'
&gt;&gt;print(msg)  # or str(msg)
'#foo'
</code></pre>
<p>There you can read how it works <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer">docs</a></p>
</div>
<span class="comment-copy">That is incorrect. Meaning, you didn't understand the question. When <code>Comment(b'foo')</code> is called, it is called interactively in the interactive shell, which, for the purpose of printing needs to come up with some string represenation of whatever was created. At that point, I expect some <code>__str__()</code> method to be called.</span>
<span class="comment-copy">That expectation is false; <code>__str__</code> never gets called, because you haven't called <code>str</code> explicitly or used <code>print()</code>.</span>
<span class="comment-copy">Linearization isn't the issue here; it's understanding which dunder methods are called and why.</span>
