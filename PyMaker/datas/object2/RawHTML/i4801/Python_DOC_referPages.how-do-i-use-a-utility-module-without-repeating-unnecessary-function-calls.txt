<div class="post-text" itemprop="text">
<p>I have a utility module that I use to provide data to other scripts. I can't get my head around the best way of utilising this whilst minimising the amount of function calls (which are all, for the sake of the argument, slow).</p>
<p>It looks something like this:</p>
<p><code>helper.py</code></p>
<pre><code>dataset1 = slow_process1()
dataset2 = slow_process2()

def get_specific_data1():
    data = #do stuff with dataset1
    return data

def get_specific_data2():
    data = #do stuff with dataset1
    return data

def get_specific_data3():
    data = #do stuff with dataset2
    return data
</code></pre>
<p>Now, say I need to run <code>get_specific_data1</code> in a script. In the setup above, I'm importing the module, which means I call <code>slow_process2</code> on import, unnecessarily. </p>
<p>If I nest the assignment of <code>dataset1</code> and <code>dataset2</code>, but then need to call <code>get_specific_data1</code> and <code>get_specific_data2</code> in the same script, I run <code>slow_process1</code> twice, which again is unnecessary.</p>
<p>If I create a <code>Helper</code> class with methods for the <code>get_specific_data</code> functions, which runs <code>slow_process1</code> or <code>slow_process2</code> if required, stores the data, and then can access as required when methods are called I can get around this. Is that appropriate?</p>
<p>Something like:</p>
<pre><code>class Helper:
    def __init__(self):
        self.dataset1 = None
        self.dataset2 = None

    def run_dataset1():
        self.dataset1 = slow_process1()

    def run_dataset2():
        self.dataset2 = slow_process2()

    def get_specific_data1():
       if dataset1 is None:
           self.rundataset1()
       data = #do stuff with dataset1
       return data

    etc
</code></pre>
<p>Apologies if this is a stupid question, but I have limited experience with OOP and don't want to make mistakes up front.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what I meant about using a class with <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a>, only in this case I've used a custom version of one named <code>lazyproperty</code>. It's considered "lazy" because it only gets computed when when it's accessed, like a regular <code>property</code>, but unlike them, the computed value is effectively cached in a way—changing it into a instance attribute—so it won't be re-computed every time. </p>
<p><strong>Caveat:</strong> Doing this assumes that the value would be the same no matter when it was calculated and any changes made to it after the first access will be visible to other methods of the same instance of the class in which it was used—i.e they won't see a freshly re-computed value.</p>
<p>Once this is done, the methods in the class can just reference <code>self.dataset1</code> or <code>self.dataset2</code> as though they were regular instance attributes, and then, if it's the first time, the data associated with it will be computed, otherwise the value previously created value will simply be returned. You can see this happening in the output produced (shown far below).</p>
<pre><code># From the book "Python Cookbook" 3rd Edition.
class lazyproperty:
    def __init__(self, func):
        self.func = func
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            value = self.func(instance)
            setattr(instance, self.func.__name__, value)
            return value

def slow_process1():
    print('slow_process1() running')
    return 13

def slow_process2():
    print('slow_process2() running')
    return 21

class Helper:
    def __init__(self):
        """ Does nothing - so not really needed. """
        pass

    @lazyproperty
    def dataset1(self):
        return slow_process1()

    @lazyproperty
    def dataset2(self):
        return slow_process2()

    def process_data1(self):
       print('self.dataset1:', self.dataset1)  # doing stuff with dataset1
       return self.dataset1 * 2

    def process_data2(self):
       print('self.dataset2:', self.dataset2)  # doing stuff with dataset2
       return self.dataset2 * 2

    def process_data3(self):
       print('self.dataset2:', self.dataset2)  # also does stuff with dataset2
       return self.dataset2 * 3

if __name__ == '__main__':

    helper = Helper()
    print(helper.process_data1())  # Will cause slow_process1() to be called
    print(helper.process_data2())  # Will cause slow_process2() to be called
    print(helper.process_data3())  # Won't call slow_process2() again
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>slow_process1() running
self.dataset1: 13
26
slow_process2() running
self.dataset2: 21
42
self.dataset2: 21
63
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might be able to solve this with a lazy loading technique:</p>
<pre><code>dataset1 = None
dataset2 = None

def ensureDataset1():
    global dataset1
    if dataset1 is None:
        dataset1 = slow_process1()

def ensureDataset2():
    global dataset2
    if dataset2 is None:
        dataset2 = slow_process2()

def get_specific_data1():
    ensureDataset1()
    data = #do stuff with dataset1
    return data

etc
</code></pre>
<p>The side effect here is that if you never get around to examining either of <code>dataset1</code> or <code>dataset2</code> they never load.</p>
</div>
<span class="comment-copy">This isn't OOP, unless this code is inside a class? Is there more to your code sample? ;) If I understand your question correctly you're asking if you should put <code>dataset1 =...</code> and the other one into <b>init</b> so it doesn't use processing time when imported?</span>
<span class="comment-copy">Sure, but setting this up as the Helper class in the last paragraph would make it so, right? I'll clarify my question now.</span>
<span class="comment-copy">I guess :) I also edited my comment above, can you confirm?</span>
<span class="comment-copy">You could put everything in a class and give it properties that read the whatever data is need when referenced—and even cache it, if that makes sense (can't quite tell from your question).</span>
<span class="comment-copy">Hmm adding the class example showed me that the init isn't just a pass after all. So i guess using a class makes more sense than i first thought...</span>
<span class="comment-copy">Thanks - is this preferable to the class example i've edited into the question? It seems like globals are frowned upon - is this a safe context?</span>
<span class="comment-copy">Yes, globals are frowned upon, but one question at a time. All I have done is to make a slight modification to your original code to provide lazy loading.</span>
