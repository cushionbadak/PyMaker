<div class="post-text" itemprop="text">
<p>I'm trying my hand at asyncio in Python 3.6 and having a hard time figuring out why this piece of code is behaving the way it is. </p>
<p><strong>Example code:</strong></p>
<pre><code>import asyncio

async def compute_sum(x, y):
    print("Compute %s + %s ..." % (x, y))
    await asyncio.sleep(5)
    print("Returning sum")
    return x + y

async def compute_product(x, y):
    print("Compute %s x %s ..." % (x, y))
    print("Returning product")
    return x * y

async def print_computation(x, y):
    result_sum = await compute_sum(x, y)
    result_product = await compute_product(x, y)
    print("%s + %s = %s" % (x, y, result_sum))
    print("%s * %s = %s" % (x, y, result_product))

loop = asyncio.get_event_loop()
loop.run_until_complete(print_computation(1, 2))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Compute 1 + 2 ...
Returning sum
Compute 1 x 2 ...
Returning product
1 + 2 = 3
1 * 2 = 2
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Compute 1 + 2 ...
Compute 1 x 2 ...
Returning product
Returning sum
1 + 2 = 3
1 * 2 = 2
</code></pre>
<p><strong>My reasoning for expected output:</strong></p>
<p>While the compute_sum coroutine is correctly called before the compute_product coroutine, my understanding was that once we hit <code>await asyncio.sleep(5)</code>, the control would be passed back to the event loop which would start the execution of the compute_product coroutine. Why is "Returning sum" being executed before we hit the print statement in the compute_product coroutine?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're right about how the coroutines work; your problem is in how you're <em>calling</em> them. In particular:</p>
<pre><code>result_sum = await compute_sum(x, y)
</code></pre>
<p>This calls the coroutine <code>compute_sum</code> <em>and then waits until it finishes</em>.</p>
<p>So, <code>compute_sum</code> does indeed yield to the scheduler in that <code>await asyncio.sleep(5)</code>, but there's nobody else to wake up. Your <code>print_computation</code> coro is already awaiting <code>compute_sum</code>. And nobody's even started <code>compute_product</code> yet, so it certainly can't run.</p>
<p>If you want to spin up multiple coroutines and have them run concurrently, don't <code>await</code> each one; you need to await the whole lot of them together. For example:</p>
<pre><code>async def print_computation(x, y):
    awaitable_sum = compute_sum(x, y)
    awaitable_product = compute_product(x, y)        
    result_sum, result_product = await asyncio.gather(awaitable_sum, awaitable_product)
    print("%s + %s = %s" % (x, y, result_sum))
    print("%s * %s = %s" % (x, y, result_product))
</code></pre>
<p>(It doesn't matter whether <code>awaitable_sum</code> is a bare coroutine, a <code>Future</code> object, or something else that can be <code>await</code>ed; <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="noreferrer"><code>gather</code></a> works either way.)</p>
<p>Or, maybe more simply:</p>
<pre><code>async def print_computation(x, y):
    result_sum, result_product = await asyncio.gather(
        compute_sum(x, y), compute_product(x, y))
    print("%s + %s = %s" % (x, y, result_sum))
    print("%s * %s = %s" % (x, y, result_product))
</code></pre>
<p>See <a href="https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks" rel="noreferrer">Parallel execution of tasks</a> in the examples section.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's how it works.
Lets use a main thread for primary reference...</p>
<p>The main thread handles events and work from various locations. If there are 3 events fired at once from other threads the main thread can only handle one at a time.  If the main thread is processing your loop it will continue processing it until the method (or function) is returned before handling other work.</p>
<p>This means that 'other work' is placed in a queue to be ran on the main thread.  </p>
<p>When you use 'async await' you write 'async' to let it be known that the method will (or can be) broken into it's own set of queues.  Then when you say 'await' it should be doing work on another thread. When it does the main thread is allowed to process the other events and work that is stored in queue instead of just waiting there.</p>
<p>So when the await work is complete it places the remaining portion of the method in the queue on the main thread as well.</p>
<p>So in these methods it doesn't continue processing but places the remaining work in a queue to be accomplished when the await is complete.  Therefore it's in order.  <code>await compute_sum(x, y)</code> gives control back to the main thread to do other work and when it's complete the rest is added to the queue to be worked. So <code>await compute_product(x, y)</code> is queued after the former is complete.</p>
</div>
<span class="comment-copy">This is a very good question for people looking to understand how to use <code>await</code>, and I think it could be turned into a <i>great</i> question… but I'm not sure how to do that. Anyway, certainly good enough for a +1 as it is, but hopefully someone can suggest something to make it even more searchable/generally-applicable.</span>
<span class="comment-copy">Thanks for the explanation!</span>
<span class="comment-copy">This makes it sound like <code>asycio</code> tasks are implemented with explicit continuation objects rather than simple coroutines. Also, it explains what happens under the covers, but not what that means on the level of the user's actual code—and nobody's going to figure out how to fix their code without looking at that higher level first.</span>
<span class="comment-copy">@abarnert  I was submitting my answer as you were and wasn't trying to trump on yours.  I do believe understand async await is just as if not more important than just solving the problem.  If he understands what and why it's doing it this way then he can learn from it and make better decisions about the results.</span>
<span class="comment-copy">I don’t think he’s actually confused about what coroutines do (and if he is, I don’t know that explaining them in terms of a mechanism that Python could conceivably have used, but doesn’t use, is going to help). But I could be wrong. Let’s wait and see what the OP thinks.</span>
<span class="comment-copy">Thanks for the answer. abarnert's answer definitely answered my question directly and helped me understand where I was going wrong and what I could do to correct it since it came with some basic code. That being said, I don't mean that your answer wasn't right. It's just that I am just starting off with asyncio and don't have enough understanding to make complete sense of it as of today :)</span>
<span class="comment-copy">Another problem with this answer is that it is not correct. "When you use 'async await' you write 'async' to let it be known that the method will (or can be) broken into it's own set of queues" - there is but a single queue entry (task) for each async function, and it holds the running coroutine object. "Then when you say 'await' it should be doing work on another thread" - the whole idea behind asyncio is that everything is done in the same thread.</span>
