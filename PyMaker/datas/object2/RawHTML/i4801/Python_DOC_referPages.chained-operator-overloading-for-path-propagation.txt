<div class="post-text" itemprop="text">
<p>I want to implement in python a simple model for optical propagation. The rule is that if I chain three elements <em>m0 -&gt; m1-&gt; m2</em> what I would get as system is:</p>
<ul>
<li>tau = tau0 * tau1 * tau2</li>
<li>B = B2 + B1*tau2 + B0*tau2*tau1</li>
</ul>
<p>(tau is transmission, B is background).</p>
<p>I wanted to implement overloading the <code>__gt__</code> operator such that I can declare:</p>
<pre><code>m0 = Mirror(0.9, 10)
m1 = Mirror(0.8, 11)
m2 = Mirror(0.7, 12)
x = m0 &gt; m1 &gt; m2
</code></pre>
<p>So far I wrote this:</p>
<pre><code>class OpticalElement:
    def __init__(self, trans, background):
        self.trans = trans
        self.background = background

class Mirror(OpticalElement):       
    def __gt__(self, other):
        if isinstance(other, Mirror):
            tau = self.trans * other.trans
            bkg = other.background + other.trans * self.background
            return Mirror(tau, bkg)
        else:
            return NotImplemented
</code></pre>
<p>However this code seems only to get the transmission and background of the rightmost elements:</p>
<pre><code>x = m0 &gt; m1 &gt; m2
x.trans
</code></pre>
<p>Returns 0.56, while I am expecting 0.504.
Background behaves the same, I am getting 19.7 instead of 25.3 (first element ignored).</p>
<p><strong>Do you guys have any idea on how to implement several chained elements using the operator overloading?</strong> (putting parenthesis works, but I wanted to have cleaner code).</p>
<p>Thanks!</p>
<p>Andreu</p>
</div>
<div class="post-text" itemprop="text">
<p><code>m0 &gt; m1 &gt; m2</code> is equivalent to <code>(m0 &gt; m1) and (m1 &gt; m2)</code>.</p>
<p>As <code>m0 &gt; m1</code> will be considered <code>True</code>, <code>and</code> will test <code>m1 &gt; m2</code> and return its value, which is the 0.56 you get.</p>
<p>You could use the multiplication operator, which will work as expected:</p>
<pre><code>class OpticalElement:
    def __init__(self, trans, background):
        self.trans = trans
        self.background = background

class Mirror(OpticalElement):       
    def __mul__(self, other):
        if isinstance(other, Mirror):
            tau = self.trans * other.trans
            bkg = other.background + other.trans * self.background
            return Mirror(tau, bkg)
        else:
            return NotImplemented

m0 = Mirror(0.9, 10)
m1 = Mirror(0.8, 11)
m2 = Mirror(0.7, 12)
x = m0 *m1 * m2
print(x.trans)
#0.504
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The way chained comparisons work is that <code>m0 &gt; m1 &gt; m2</code> is evaluated as <code>(m0 &gt; m1) and (m1 &gt; m2)</code>, which results in <code>m1 &gt; m2</code>, as <code>x and y</code>returns <code>y</code> if <code>x</code> is truish.
So this is the reason why your code seems only to get the rightmost comparison.</p>
<p>Instead, you can do
<code>x = (m0 &gt; m1) &gt; m2</code>.
which evaluates both <code>&gt;</code> operators in the given order.
This results in </p>
<pre><code>x = (m0 &gt; m1) &gt; m2
print(x.trans) # 0.504
</code></pre>
</div>
<span class="comment-copy">Not an answer to your question, but it would be trivial if you called it with a function <code>def chain(*args: [Mirror]) -&gt; Mirror</code> as opposed to chaining with an operator.</span>
<span class="comment-copy">Probably the right shift operator, <code>&gt;&gt;</code> (<a href="https://docs.python.org/3/reference/datamodel.html#object.__rshift__" rel="nofollow noreferrer"><code>__rshift__</code></a>), would be the closest to the intended syntax: <code>x = m0 &gt;&gt; m1 &gt;&gt; m2</code>.</span>
<span class="comment-copy">Actually the solution from @jdehesa is the most elegant one and closest to what I was looking for. Thanks.</span>
<span class="comment-copy">OP said <code>putting parenthesis works, but I wanted to have cleaner code</code> though</span>
<span class="comment-copy">Exactly, @Arne, I wanted to keep that syntax without parenthesis. Thanks.</span>
<span class="comment-copy">Sorry, I misread that part.</span>
