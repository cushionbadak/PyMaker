<div class="post-text" itemprop="text">
<p>I wish to search a directory, and all contained subdirectories, for files with a substring contained within their name and one of three possible extensions</p>
<p>Please can you help me edit the following code</p>
<pre><code>os.chdir(directory)
files = glob.glob("**/*{}*.pro".format(myStr), recursive = True)
</code></pre>
<p>I wish to find files with the extension .pro, .bd3 and .mysql</p>
<p>I'm running Python 3.5</p>
</div>
<div class="post-text" itemprop="text">
<p>You could create a list and loop over it</p>
<pre><code>exten_to_find = ['.pro','bd3','.mysql']
</code></pre>
<p>you could format like this for iteration</p>
<pre><code>files = glob.glob("**/*{x}*.{y}".format(x = myStr, y = extension_toFind), recursive = True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you could try:</p>
<pre><code>def get_files_with_extension(my_str, exts):
    for f in glob.iglob("**/*{}*.*".format(my_str), recursive = True):
        if any(f.endswith(ext) for ext in exts):
            yield f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actual-glob syntax has no way to do this. The "enhanced glob" syntaxes of most modern shells can, but I'm pretty sure Python's <code>glob</code> module is only very lightly enhanced.</p>
<p>Under the covers, <code>glob</code> is a pretty simple module, and <a href="https://docs.python.org/3/library/glob.html" rel="nofollow noreferrer">the docs</a> link to the source. As you can see, it ultimately defers to <code>fnmatch</code>, which is also a pretty simple module, and while ultimately just builds a regex and defers to that. And of course you can do alternations in a regex.</p>
<p>So, one option is to fork all the code from <code>glob.py</code> and <code>fnmatch.py</code> so you can build a fancier pattern to pass down to <code>re</code>.</p>
<p>But the simplest thing to do is just stop using <code>glob</code> here. It's the wrong tool for the job. Just use <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer"><code>os.walk</code></a> and filter things yourself.</p>
<p>If you understand how to write a regex like <code>r'.*{}.*\.(pro|md3|mysql)'.format(myStr)</code>, use that to filter; if not, just write what you do know how to do; the performance cost will probably be minimal, and you'll be able to extend and maintain it yourself.</p>
<pre><code>files = []
for root, dirnames, filenames in os.walk('.'):
    for file in filenames:
        fname, fext = os.path.splitext(file)
        if fext in {'pro', 'md3', 'mysql'} and myStr in fname:
            files.append(os.path.join(root, file))
</code></pre>
<p>If it turns out that doing a set method and a string method really is so much slower than regex that it makes a difference, and you can't write the regex yourself, come back and ask a new question. (I wouldn't count on the one I used above, if you can't figure out how to debug it.)</p>
<p>Also, if you're using Python before… I think 3.5… <code>os.walk</code> may actually be inherently slower than <code>iglob</code>. In that case, you'll want to look for <code>betterwalk</code> on PyPI, the module that the current implementation is based on.</p>
</div>
<span class="comment-copy">If you're trying to do something with <code>glob</code> and it's too complicated for you to understand how to write the glob, it's time to switch to using <code>os.walk</code> and filter manually.</span>
<span class="comment-copy">search for the 3 separately, store in 3 separate lists, and then combine the lists? that would probably triple your runtime, are you searching through a large directory?</span>
<span class="comment-copy">Yes, there's numerous subdirectories and many levels. Plus I'm searching for around 7000 different files already. Tripling the time is really not an option</span>
<span class="comment-copy">See the comments on the original question.  This would search the directories 3 times.</span>
<span class="comment-copy">Thank you, I will give this a try</span>
