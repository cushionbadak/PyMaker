<div class="post-text" itemprop="text">
<p>I have some code that needs to execute <em>after</em> Flask returns a response. I don't think it's complex enough to set up a task queue like Celery for it. The key requirement is that Flask must return the response to the client before running this function. It can't wait for the function to execute.</p>
<p>There are some existing questions about this, but none of the answers seem to address running a task after the response is sent to the client, they still execute synchronously and then the response is returned.</p>
<ul>
<li><a href="https://stackoverflow.com/questions/18082683/need-to-execute-a-function-after-returning-the-response-in-flask">Need to execute a function after returning the response in Flask</a></li>
<li><a href="https://stackoverflow.com/questions/31063904/python-flask-sending-response-immediately">Python Flask sending response immediately</a></li>
<li><a href="https://stackoverflow.com/questions/18082683/need-to-execute-a-function-after-returning-the-response-in-flask">Need to execute a function after returning the response in Flask</a></li>
<li><a href="https://stackoverflow.com/questions/17293311/flask-end-response-and-continue-processing">Flask end response and continue processing</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The long story short is that Flask does not provide any special capabilities to accomplish this. For simple one-off tasks, consider Python's multithreading as shown below. For more complex configurations, use a task queue like RQ or Celery.</p>
<h2>Why?</h2>
<p>It's important to understand the functions Flask provides and why they <em>do not</em> accomplish the intended goal. All of these are useful in other cases and are good reading, but don't help with background tasks.</p>
<h3>Flask's <code>after_request</code> handler</h3>
<p>Flask's <code>after_request</code> handler, as detailed in <a href="http://flask.pocoo.org/docs/0.12/patterns/deferredcallbacks/" rel="noreferrer">this pattern for deferred request callbacks</a> and <a href="http://flask.pocoo.org/snippets/53/" rel="noreferrer">this snippet on attaching different functions per request</a>, will pass the request to the callback function. The intended use case is to <em>modify the request</em>, such as to attach a cookie.</p>
<p>Thus the request will wait around for these handlers to finish executing because the expectation is that the request itself will change as a result.</p>
<h3>Flask's <code>teardown_request</code> handler</h3>
<p>This is similar to <code>after_request</code>, but <code>teardown_request</code> doesn't receive the <code>request</code> object. So that means it won't wait for the request, right?</p>
<p>This seems like the solution, as <a href="https://stackoverflow.com/a/17313074/123412">this answer to a similar Stack Overflow question</a> suggests. And since Flask's documentation explains that <a href="http://flask.pocoo.org/docs/0.12/reqcontext/#teardown-callbacks" rel="noreferrer">teardown callbacks are independent of the actual request</a> and do not receive the request context, you'd have good reason to believe this.</p>
<p>Unfortunately, <code>teardown_request</code> is still synchronous, it just happens at a later part of Flask's request handling when the request is no longer modifiable. Flask <em>will still wait for teardown functions</em> to complete before returning the response, as <a href="http://flask.pocoo.org/docs/0.12/reqcontext/#callbacks-and-errors" rel="noreferrer">this list of Flask callbacks and errors</a> dictates.</p>
<h3>Flask's streaming responses</h3>
<p>Flask can stream responses by passing a generator to <code>Response()</code>, as <a href="https://stackoverflow.com/questions/18082683/need-to-execute-a-function-after-returning-the-response-in-flask">this Stack Overflow answer to a similar question</a> suggests.</p>
<p>With streaming, the client <em>does</em> begin receiving the response before the request concludes. However, the request still runs synchronously, so the worker handling the request is busy until the stream is finished.</p>
<p><a href="http://flask.pocoo.org/docs/patterns/streaming/" rel="noreferrer">This Flask pattern for streaming</a> includes some documentation on using <code>stream_with_context()</code>, which is necessary to include the request context.</p>
<h2>So what's the solution?</h2>
<p>Flask doesn't offer a solution to run functions in the background because this isn't Flask's responsibility.</p>
<p>In most cases, the best way to solve this problem is to use a task queue such as RQ or Celery. These manage tricky things like configuration, scheduling, and distributing workers for you.This is the most common answer to this type of question because it is the most correct, and forces you to set things up in a way where you consider context, etc. correctly.</p>
<p>If you need to run a function in the background and don't want to set up a queue to manage this, you can use Python's built in <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="noreferrer"><code>threading</code></a> or <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process" rel="noreferrer"><code>multiprocessing</code></a> to spawn a background worker.</p>
<p>You can't access <code>request</code> or others of Flask's thread locals from background tasks, since the request will not be active there. Instead, pass the data you need from the view to the background thread when you create it.</p>
<pre class="lang-py prettyprint-override"><code>@app.route('/start_task')
def start_task():
    def do_work(value):
        # do something that takes a long time
        import time
        time.sleep(20)

    thread = Thread(target=do_work, kwargs={'value': request.args.get('value', 20))
    thread.start()
    return 'started'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Flask is a <a href="https://www.python.org/dev/peps/pep-0333/#the-application-framework-side" rel="noreferrer">WSGI app</a> and as a result it fundamentally cannot handle anything after the response. This is why no such handler exists, the WSGI app itself is responsible only for constructing the response iterator object to the WSGI server. </p>
<p>A <a href="https://www.python.org/dev/peps/pep-0333/#the-server-gateway-side" rel="noreferrer">WSGI server</a> however (like <a href="http://docs.gunicorn.org/en/stable/settings.html#post-request" rel="noreferrer">gunicorn</a>) can very easily provide this functionality, but tying the application to the server is a very bad idea for a number of reasons.</p>
<p>For this exact reason, WSGI provides a spec for <a href="https://www.python.org/dev/peps/pep-0333/#middleware-components-that-play-both-sides" rel="noreferrer">Middleware</a>, and Werkzeug provides a number of helpers to simplify common Middleware functionality. Among them is a <a href="http://werkzeug.pocoo.org/docs/0.14/wsgi/#werkzeug.wsgi.ClosingIterator" rel="noreferrer">ClosingIterator</a> class which allows you to hook methods up to the <code>close</code> method of the response iterator which is executed after the request is closed.</p>
<p>Here's an example of a naive <code>after_response</code> implementation done as a Flask extension:</p>
<pre><code>import traceback
from werkzeug.wsgi import ClosingIterator

class AfterResponse:
    def __init__(self, app=None):
        self.callbacks = []
        if app:
            self.init_app(app)

    def __call__(self, callback):
        self.callbacks.append(callback)
        return callback

    def init_app(self, app):
        # install extension
        app.after_response = self

        # install middleware
        app.wsgi_app = AfterResponseMiddleware(app.wsgi_app, self)

    def flush(self):
        for fn in self.callbacks:
            try:
                fn()
            except Exception:
                traceback.print_exc()

class AfterResponseMiddleware:
    def __init__(self, application, after_response_ext):
        self.application = application
        self.after_response_ext = after_response_ext

    def __call__(self, environ, after_response):
        iterator = self.application(environ, after_response)
        try:
            return ClosingIterator(iterator, [self.after_response_ext.flush])
        except Exception:
            traceback.print_exc()
            return iterator
</code></pre>
<p>You can use this extension like this:</p>
<pre><code>import flask
app = flask.Flask("after_response")
AfterResponse(app)

@app.after_response
def say_hi():
    print("hi")

@app.route("/")
def home():
    return "Success!\n"
</code></pre>
<p>When you curl "/" you'll see the following in your logs:</p>
<pre><code>127.0.0.1 - - [24/Jun/2018 19:30:48] "GET / HTTP/1.1" 200 -
hi
</code></pre>
<p>This solves the issue simply without introducing either threads (GIL??) or having to install and manage a task queue and client software.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this code i have tried it.It works.</p>
<p>this code will print the string "message". after the 3 second ,from the scheduling time. You can change the time your self according to you requirement.</p>
<pre><code>import time, traceback
import threading

def every(delay,message, task):
  next_time = time.time() + delay
  time.sleep(max(0, next_time - time.time()))
  task(message)

def foo(message):
  print(message+"  :foo", time.time())



def main(message):
    threading.Thread(target=lambda: every(3,message, foo)).start()

main("message")
</code></pre>
</div>
<span class="comment-copy">This is a solution but not the complete solution, what happens when the child thread encounters exception? So we have to handle that too, Solution will be to use a custom thread class instead of default Thread class and handle the exception in there.</span>
<span class="comment-copy">Many thanks for this @matthew-story</span>
<span class="comment-copy">how could i use this inside a blueprint?</span>
<span class="comment-copy">How do I use this with an argument in the route("/") that needs to be passed to the after_response function?</span>
<span class="comment-copy">Unfortunately, using a thread works for the simple case of printing a message, but will cause problems when accessing other variables and context.</span>
