<div class="post-text" itemprop="text">
<p>I tried <a href="https://docs.python.org/3/library/heapq.html" rel="noreferrer">"heapq"</a> and arrived at the conclusion that my expectations differ from what I see on the screen. I need somebody to explain how it works and where it can be useful.</p>
<p>From the book <a href="http://pymotw.com/2/articles/data_structures.html#sorting" rel="noreferrer">Python Module of the Week</a> under paragraph <strong>2.2 Sorting</strong> it is written</p>
<blockquote>
<p>If you need to maintain a sorted list as you add and remove values,
  check out heapq. By using the functions in heapq to add or remove
  items from a list, you can maintain the sort order of the list with
  low overhead.</p>
</blockquote>
<p>Here is what I do and get.</p>
<pre><code>import heapq
heap = []

for i in range(10):
    heap.append(i)

heap
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

heapq.heapify(heap)    
heapq.heappush(heap, 10)    
heap
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

heapq.heappop(heap)
0    
heap
[1, 3, 2, 7, 4, 5, 6, 10, 8, 9] &lt;&lt;&lt; Why the list does not remain sorted?

heapq.heappushpop(heap, 11)
1
heap
[2, 3, 5, 7, 4, 11, 6, 10, 8, 9] &lt;&lt;&lt; Why is 11 put between 4 and 6?
</code></pre>
<p>So, as you see the "heap" list is not sorted at all, in fact the more you add and remove the items the more cluttered it becomes. Pushed values take unexplainable positions.
What is going on? </p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>heapq</code> module maintains the <em>heap invariant</em>, which is not the same thing as maintaining the actual list object in sorted order.</p>
<p>Quoting from the <a href="http://docs.python.org/2/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code> documentation</a>:</p>
<blockquote>
<p>Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which <code>heap[k] &lt;= heap[2*k+1]</code> and <code>heap[k] &lt;= heap[2*k+2]</code> for all <code>k</code>, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, <code>heap[0]</code>.</p>
</blockquote>
<p>This means that it is very efficient to find the smallest element (just take <code>heap[0]</code>), which is great for a priority queue. After that, the next 2 values will be larger (or equal) than the 1st, and the next 4 after that are going to be larger than their 'parent' node, then the next 8 are larger, etc.</p>
<p>You can read more about the theory behind the datastructure in the <a href="http://docs.python.org/2/library/heapq.html#theory" rel="nofollow noreferrer">Theory section of the documentation</a>. You can also watch <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" rel="nofollow noreferrer">this lecture from the MIT OpenCourseWare Introduction to Algorithms course</a>, which explains the algorithm in general terms.</p>
<p>A heap can be turned back into a sorted list very efficiently:</p>
<pre><code>def heapsort(heap):
    return [heapq.heappop(heap) for _ in range(len(heap))]
</code></pre>
<p>by just popping the next element from the heap. Using <code>sorted(heap)</code> should be faster still, however, as the TimSort algorithm used by Python’s sort will take advantage of the partial ordering already present in a heap.</p>
<p>You'd use a heap if you are only interested in the smallest value, or the first <code>n</code> smallest values, especially if you are interested in those values on an ongoing basis; adding new items and removing the smallest is very efficient indeed, more so than resorting the list each time you added a value.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Your book is wrong!</strong> As you demonstrate, a heap is not a sorted list (though a sorted list is a heap). What is a heap? To quote Skiena's Algorithm Design Manual</p>
<blockquote>
<p>Heaps are a simple and elegant data structure for efficiently supporting the priority queue operations insert and extract-min. They work by maintaining a partial order on the set of elements which is weaker than the sorted order (so it can be efficient to maintain) yet stronger than random order (so the minimum element can be quickly identified).</p>
</blockquote>
<p>Compared to a sorted list, a heap obeys a weaker condition <em>the heap invariant</em>. Before defining it, first think why relaxing the condition might be useful. The answer is the weaker condition is <em>easier to maintain</em>. You can do less with a heap, but you can do it <em>faster</em>.</p>
<p>A heap has three operations:</p>
<ol>
<li>Find-Minimum is O(1)</li>
<li>Insert O(log n)</li>
<li>Remove-Min O(log n)</li>
</ol>
<p>Crucially Insert is O(log n) which beats O(n) for a sorted list.</p>
<p>What is the heap invariant? "A binary tree where parents dominate their children". That is, "<code>p ≤ c</code> for all children c of p". Skiena illustrates with pictures and goes on to demonstrate the algorithm for inserting elements while maintaining the invariant. If you think a while, you can invent them yourself. (Hint: they are known as bubble up and bubble down)</p>
<p>The good news is that batteries-included Python implements everything for you, in the <a href="https://docs.python.org/3/library/heapq.html" rel="noreferrer">heapq</a> module. It doesn't define a heap type (which I think would be easier to use), but provides them as helper functions on list.</p>
<p>Moral: <strong>If you write an algorithm using a sorted list but only ever inspect and remove from one end, then you can make the algorithm more efficient by using a heap.</strong></p>
<p>For a problem in which a heap data structure is useful, read <a href="https://projecteuler.net/problem=500" rel="noreferrer">https://projecteuler.net/problem=500</a></p>
</div>
<div class="post-text" itemprop="text">
<p>There is some misunderstanding of the heap data structure implementation. The <code>heapq</code> module is actually a variant of the <a href="https://en.wikipedia.org/wiki/Binary_heap" rel="noreferrer">binary heap</a> implementation, where heap elements are stored in a list, as described here: <a href="https://en.wikipedia.org/wiki/Binary_heap#Heap_implementation" rel="noreferrer">https://en.wikipedia.org/wiki/Binary_heap#Heap_implementation</a></p>
<p>Quoting Wikipedia:</p>
<blockquote>
<p>Heaps are commonly implemented with an array. Any binary tree can be stored in an array, but because a binary heap is always a complete binary tree, it can be stored compactly. No space is required for pointers; instead, the parent and children of each node can be found by arithmetic on array indices.</p>
</blockquote>
<p>This image below should help you to feel the difference between tree and list representation of the heap and (<em>note, that this is a max heap, which is the inverse of the usual min-heap!</em>):</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/smtKU.png"/></p>
<p>In general, heap data structure is different from a sorted list in that it sacrifices some information about whether any particular element is bigger or smaller than any other. Heap only can tell, that this particular element is less, than it's parent and bigger, than it's children. The less information a data structure stores, the less time/memory it takes to modify it. Compare the complexity of some operations between a heap and a sorted array:</p>
<pre><code>        Heap                  Sorted array
        Average  Worst case   Average   Worst case

Space   O(n)     O(n)         O(n)      O(n)

Search  O(n)     O(n)         O(log n)  O(log n)

Insert  O(1)     O(log n)     O(n)      O(n)

Delete  O(log n) O(log n)     O(n)      O(n)
</code></pre>
</div>
<span class="comment-copy">read <a href="http://docs.python.org/2/library/heapq.html#theory" rel="nofollow noreferrer"><code>heapq</code> the theory</a></span>
<span class="comment-copy">Start poping out data from the heap and you will understand yourself how data is sorted in a heap tree .</span>
<span class="comment-copy">After tracking down the quote, I see it's just plain misleading. A heap does not maintain a sorted list, but it does maintain a data structure which can be used to create a sorted list. It leaves out the detail that to retrieve the list, you must destroy the heap, which is a crucial detail.</span>
<span class="comment-copy">l4mpi: I read the official python docs and still did not understand, what would be your advice?:)     chepner: it is misleading, that is why I raised this question. Anyone without additional knowledge would expect <code>heapq</code> to maintain a sorted list after reading about it in the book I mentioned.</span>
<span class="comment-copy">@l4mpi: No need to be <i>this</i> harsh; the quote is plainly wrong, understandably generating confusion. Algorithm theory can also be rather dry for many beginners.</span>
<span class="comment-copy">Maybe I misunderstand, but: "After that, the next 2 values will be larger (or equal) than the 1st, and the next 4 after that are going to be larger than the first 3, then the next 8 are larger, etc." – as a counter-example: <code>[1, 5, 9, 7, 15, 10, 11]</code> is a valid binary min-heap, but e.g. <code>7</code> (third level in the hierarchy) is still smaller than <code>9</code> (second level in the hierarchy). The ordered property in a heap is only true for parent–child traversal, not necessarily for "aunt–niece" relations.</span>
<span class="comment-copy">@DanielAndersson: yes, that sentence was oversimplified and through simplification, now basically wrong. Thanks for pointing that out!</span>
<span class="comment-copy">I think your usage is not that proper,  heapsort(range(100, 0 , -1)), the result is like 100, 1, 2, 3 ... 98, 99. To fix it, try to heapify one time before u really pop items:     <code>def heapsort(heap):         heapq.heapify(heap)         return [heapq.heappop(heap) for _ in range(len(heap))]        </code></span>
<span class="comment-copy">@AlbertLee: <code>heap</code> is assumed to be a proper heap. If you need to call <code>heapify()</code> first then it wasn't a proper heap; you didn't keep the heap invariant updated.</span>
<span class="comment-copy">@MartijnPieters， I think you could change ur function name like: generate_sorted_array_from_heap instead of heapysort, u agree w/ me?</span>
<span class="comment-copy">Crisp and clear explanation</span>
<span class="comment-copy">How do you compare the efficiency of hashtable (dictionary in Python) and a heap table for doing insert/remove? I know hash table do O(1) for best case, and O(n) for worst case.  Is the O(log n) for the worst or average case of a Heap??</span>
