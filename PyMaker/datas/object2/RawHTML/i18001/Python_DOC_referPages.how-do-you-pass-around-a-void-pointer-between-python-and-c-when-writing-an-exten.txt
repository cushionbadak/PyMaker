<div class="post-text" itemprop="text">
<p>I started on my first Python extension today and was only creating a very small wrapper around a C library as an exercise. As is typical with C libraries, you start of with an initialization function that yields a handler. You can pass that handler to functions and later you pass it to the cleanup function that frees memory.</p>
<p>When I started writing the wrapper I basically wanted to have a way to call each native C function from python. Quickly I hit the problem that I need to return an arbitrary pointer from C to Python only to give it from there to C again in another function. I doesn't matter how it looks as I don't use it in Python, I just store it and pass it around.</p>
<p>So how do you pass around a void pointer between Python and C?</p>
<p>Please note: I know it is not recommended to write such small wrappers using the extension system but rather ctypes and friends. This is just for practice right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>PyLong_FromVoidPtr() and PyLong_AsVoidPtr() can be abused to inject malicious data into your program. I recommend against them.</p>
<p>Python has PyCapsule for exactly that job. Capsules provide a safe way to exchange void ptr between modules or Python space and C space. The capsules are type-safe, too. If you need some example, the socket / ssl modules and pyexpat / _elementtree modules use capsules to exchange CAPI structs.</p>
<p><a href="http://docs.python.org/3/c-api/capsule.html" rel="nofollow">http://docs.python.org/3/c-api/capsule.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>After some searching I found the functions <a href="http://docs.python.org/2/c-api/long.html?highlight=voidptr#PyLong_AsVoidPtr" rel="nofollow">PyLong_AsVoidPtr</a> and <a href="http://docs.python.org/2/c-api/long.html?highlight=voidptr#PyLong_FromVoidPtr" rel="nofollow">PyLong_FromVoidPtr</a>. This yields a nice way to convert between a <code>void *</code> and a <code>PyObject</code>:</p>
<pre><code># in init function
return PyLong_FromVoidPtr(handle);

# in function using handle
handle = PyLong_AsVoidPtr(python_handle);
</code></pre>
<p>The one problem now might be how to retrieve <code>python_handle</code> from the typical <code>*args</code> given to a function:</p>
<pre><code>PyObject *python_handle;
PyArg_ParseTuple(args, "O", &amp;python_handle);
</code></pre>
<p>Careful here: The argument given for the <code>"O"</code> object must be a pointer to a <code>PyObject</code> pointer: <code>PyObject **</code>. The <code>"O"</code> itself only denotes to pass this <code>PyObject</code> through without any handling and converting. And with this, you can pass around any pointers any way you like.</p>
<p><em>Note</em>: I think this solution is not really pretty, because you now have to variables, one that is only needed for a short time.</p>
</div>
<span class="comment-copy">Related, for those looking for a solution in Cython: <a href="http://stackoverflow.com/questions/24764048/get-the-value-of-a-cython-pointer" title="get the value of a cython pointer">stackoverflow.com/questions/24764048/â€¦</a></span>
<span class="comment-copy">Can you elaborate on the security problem of the mentioned functions? I could not find any details regarding this.</span>
<span class="comment-copy">It is <a href="http://stackoverflow.com/help/self-answer">perfectly acceptable</a> to answer your question at the same time as you ask it. That is why <code>answer your own question</code> is an option when you ask a question!</span>
<span class="comment-copy">And that's what I did. Is there something wrong? I cannot accept it yet, and I don't want to because someone may have a better alternative.</span>
<span class="comment-copy">For importing <code>PyLong_*</code> in Cython, do <code>cdef extern from "Python.h":     void* PyLong_AsVoidPtr(object)</code>, as discussed <a href="http://osdir.com/ml/python-cython-devel/2009-10/msg00197.html" rel="nofollow noreferrer">here</a>.</span>
