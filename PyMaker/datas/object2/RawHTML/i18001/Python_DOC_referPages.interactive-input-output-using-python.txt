<div class="post-text" itemprop="text">
<p>I have a program that interacts with the user (acts like a shell), and I want to run it  using python subprocess module interactively. 
That means, I want the possibility to write to stdin and immediately get the output from stdout. I tried many solutions offered here, but none of them seems to work for my needs.</p>
<p>The code I've written based on <a href="https://stackoverflow.com/questions/11457931/running-an-interactive-command-from-within-python">Running an interactive command from within python</a></p>
<pre><code>import Queue
import threading
import subprocess
def enqueue_output(out, queue):
    for line in iter(out.readline, b''):
        queue.put(line)
    out.close()

def getOutput(outQueue):
    outStr = ''
    try:
        while True: #Adds output from the Queue until it is empty
            outStr+=outQueue.get_nowait()

    except Queue.Empty:
        return outStr

p = subprocess.Popen("./a.out", stdin=subprocess.PIPE, stout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize = 1)
#p = subprocess.Popen("./a.out", stdin=subprocess.PIPE, stout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, universal_newlines=True)

outQueue = Queue()
errQueue = Queue()

outThread = Thread(target=enqueue_output, args=(p.stdout, outQueue))
errThread = Thread(target=enqueue_output, args=(p.stderr, errQueue))

outThread.daemon = True
errThread.daemon = True

outThread.start()
errThread.start()

p.stdin.write("1\n")
p.stdin.flush()
errors = getOutput(errQueue)
output = getOutput(outQueue)

p.stdin.write("5\n")
p.stdin.flush()
erros = getOutput(errQueue)
output = getOutput(outQueue)
</code></pre>
<p>The problem is that the queue remains empty, as if there is no output.
Only if I write to stdin all the input that the program needs to execute and terminate, then I get the output (which is not what I want). For example if I do something like:</p>
<pre><code>p.stdin.write("1\n5\n")
errors = getOutput(errQueue)
output = getOutput(outQueue)
</code></pre>
<p>Is there any way to do what I want to do?</p>
<p><strong>EDIT:</strong>
The script will run on a Linux machine.
I changed my script and deleted the universal_newlines=True + set the bufsize to 1 and flushed stdin immediately after wrtie. Still I get no output.</p>
<p><strong>Second try:</strong>
I tried this solution and it works for me:</p>
<pre><code>from subprocess import Popen, PIPE

fw = open("tmpout", "wb")
fr = open("tmpout", "r")
p = Popen("./a.out", stdin = PIPE, stdout = fw, stderr = fw, bufsize = 1)
p.stdin.write("1\n")
out = fr.read()
p.stdin.write("5\n")
out = fr.read()
fw.close()
fr.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two solutions for this issue on Linux:</p>
<p>First one is to use a file to write the output to, and read from it simultaneously:</p>
<pre><code>from subprocess import Popen, PIPE

fw = open("tmpout", "wb")
fr = open("tmpout", "r")
p = Popen("./a.out", stdin = PIPE, stdout = fw, stderr = fw, bufsize = 1)
p.stdin.write("1\n")
out = fr.read()
p.stdin.write("5\n")
out = fr.read()
fw.close()
fr.close()
</code></pre>
<p>Second, as J.F. Sebastian offered, is to make p.stdout and p.stderr pipes non-blocking using fnctl module:</p>
<pre><code>import os
import fcntl
from subprocess import Popen, PIPE  
def setNonBlocking(fd):
    """
    Set the file description of the given file descriptor to non-blocking.
    """
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    flags = flags | os.O_NONBLOCK
    fcntl.fcntl(fd, fcntl.F_SETFL, flags)

p = Popen("./a.out", stdin = PIPE, stdout = PIPE, stderr = PIPE, bufsize = 1)
setNonBlocking(p.stdout)
setNonBlocking(p.stderr)

p.stdin.write("1\n")
while True:
    try:
        out1 = p.stdout.read()
    except IOError:
        continue
    else:
        break
out1 = p.stdout.read()
p.stdin.write("5\n")
while True:
    try:
        out2 = p.stdout.read()
    except IOError:
        continue
    else:
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>None of the current answers worked for me. At the end, I've got this working:</p>
<pre><code>import subprocess


def start(executable_file):
    return subprocess.Popen(
        executable_file,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )


def read(process):
    return process.stdout.readline().decode("utf-8").strip()


def write(process, message):
    process.stdin.write(f"{message.strip()}\n".encode("utf-8"))
    process.stdin.flush()


def terminate(process):
    process.stdin.close()
    process.terminate()
    process.wait(timeout=0.2)


process = start("./dummy.py")
write(process, "hello dummy")
print(read(process))
terminate(process)
</code></pre>
<p>Tested with this <code>dummy.py</code> script:</p>
<pre><code>#!/usr/bin/env python3.6

import random
import time

while True:
    message = input()
    time.sleep(random.uniform(0.1, 1.0)) # simulates process time
    print(message[::-1])
</code></pre>
<p>The caveats are: input/output always lines with newline, flushing child's stdin after every write, and use <code>readline()</code> from child's stdout (all of that managed in the functions). </p>
<p>It's a pretty simple solution, in my opinion (not mine, I found it here: <a href="https://eli.thegreenplace.net/2017/interacting-with-a-long-running-child-process-in-python/" rel="noreferrer">https://eli.thegreenplace.net/2017/interacting-with-a-long-running-child-process-in-python/</a>). I was using Python 3.6.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an interactive shell. You have to run read() on a separate thread, otherwise it will block the write()</p>
<pre><code>import sys
import os
import subprocess
from subprocess import Popen, PIPE
import threading


class LocalShell(object):
    def __init__(self):
        pass

    def run(self):
        env = os.environ.copy()
        p = Popen('/bin/bash', stdin=PIPE, stdout=PIPE, stderr=subprocess.STDOUT, shell=True, env=env)
        sys.stdout.write("Started Local Terminal...\r\n\r\n")

        def writeall(p):
            while True:
                # print("read data: ")
                data = p.stdout.read(1).decode("utf-8")
                if not data:
                    break
                sys.stdout.write(data)
                sys.stdout.flush()

        writer = threading.Thread(target=writeall, args=(p,))
        writer.start()

        try:
            while True:
                d = sys.stdin.read(1)
                if not d:
                    break
                self._write(p, d.encode())

        except EOFError:
            pass

    def _write(self, process, message):
        process.stdin.write(message)
        process.stdin.flush()


shell = LocalShell()
shell.run()
</code></pre>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/a/4896288/5267751">related</a>.</span>
<span class="comment-copy">ok the code doesn't show in the bounty, so I did a gist for it <a href="https://gist.github.com/brando90/99b10cdc73dc6b604ca661712c1c7b0d" rel="nofollow noreferrer">gist.github.com/brando90/99b10cdc73dc6b604ca661712c1c7b0d</a>  I am just trying to test it with a real python process in the background.</span>
<span class="comment-copy">did you take a look at this: <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio.html</a> ?</span>
<span class="comment-copy">I don't exactly understand what you mean. What I wanted to do at first is to read only partial output (one line)</span>
<span class="comment-copy">I didn't understand your example. What does this line: p = Popen([sys.executable,  "-u", '-c'            'for line in iter(input, ""): print("a"*int(line)*10**6)'],           stdin=PIPE, stdout=PIPE, bufsize=1) mean?</span>
<span class="comment-copy">You're right, I've edited my second solution as I used it. The problem was that when I tried the solution at first, I've tried it on the python interpreter (I haven't written the script, only tested it manually) so it worked (due to human slow response time). When I tried to write the script, I've encountered the problem you've mentioned so I've added the while loop, until the input is ready. I actually get the whole output or nothing at all (IOError exception), will it be helpful if I upload the a.out source code (it's a C program)?</span>
<span class="comment-copy">Unfortunately the script I want to communicate with uses <code>stty -echo</code> which causes it to complain of <code>'standard input': Inappropriate ioctl for device</code> when trying to use the first method. (The second method never seems to read the output properly.. assuming the script is outputting)</span>
<span class="comment-copy">The second solution hangs forever, when calling a simple C program requesting 2 inputs with scanf("%s", buf)</span>
