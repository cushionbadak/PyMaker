<div class="post-text" itemprop="text">
<p><strong>Disclaimer: I am just getting started learning Python</strong></p>
<p>I have a function that counts the number of times a word appears in a text file and sets the word as the key and the count as the value, and stores it in a dictionary "book_index". Here is my code:</p>
<pre><code>alice = open('location of the file', 'r', encoding = "cp1252")

def book_index(alice):
    """Alice is a file reference"""
    """Alice is opened, nothing else is done"""
    worddict = {}
    line = 0

    for ln in alice:
        words = ln.split()
        for wd in words:
            if wd not in worddict:
                worddict[wd] = 1 #if wd is not in worddict, increase the count for that word to 1
            else:
                worddict[wd] = worddict[wd] + 1 #if wd IS in worddict, increase the count for that word BY 1
        line = line + 1
    return(worddict)
</code></pre>
<p>I need to turn that dictionary "inside out" and use the count as the key, and any word that appears x amount of times as the value. For instance: [2, 'hello', 'hi'] where 'hello' and 'hi' appear twice in the text file.</p>
<p>Do I need to loop through my existing dictionary or loop through the text file again?</p>
</div>
<div class="post-text" itemprop="text">
<p>As a dictionary is a key to value mapping, you cannot efficiently filter by the values. So you will have to loop through all elements in the dictionary to get the keys which values have some specific value.</p>
<p>This will print out all keys in the dictionary <code>d</code> where the value is equal to <code>searchValue</code>:</p>
<pre><code>for k, v in d.items():
    if v == searchValue:
        print(k)
</code></pre>
<hr/>
<p>Regarding your <code>book_index</code> function, note that you can use the built-in <a href="http://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter</code></a> for counting things. Counter is essentially a dictionary that works with counts as its values and automatically takes care of nonexistant keys. Using a counter, your code would look like this:</p>
<pre><code>from collections import Counter
def book_index(alice):
    worddict = Counter()
    for ln in alice:
        worddict.update(ln.split())
    return worddict
</code></pre>
<p>Or, as roippi suggested as a comment to another answer, just <code>worddict = Counter(word for line in alice for word in line.split())</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Personally I would suggest the use of a Counter object here, which is specifically made for this kind of application. For instance:</p>
<pre><code>from collections import Counter
counter = Counter()
for ln in alice:
    counter.update(ln.split())
</code></pre>
<p>This will give you the relevant dictionary, and if you then read the <a href="http://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow">Counter docs</a></p>
<p>You can just retrieve the most common results.</p>
<p>This might not work in every case in your proposed problem, but it's slightly nicer than manually iterating through even the first time around.</p>
<p>If you really want to "flip" this dictionary you could do something along these lines:</p>
<pre><code>matching_values = lambda value: (word for word, freq in wordict.items() if freq==value)
{value: matching_values for value in set(worddict.values())}
</code></pre>
<p>The above solution has some advantages over other solutions in that the lazy execution means that for very sparse cases where you're not looking to make a lot of calls to this function, or just discover which value actually have corresponding entries, this will be faster as it won't actually iterate through the dictionary.</p>
<p>That said, this solution will usually be worse than the vanilla iteration solution since it actively iterates through the dictionary every time you need a new number.</p>
<p>Not radically different, but I didn't want to just copy the other answers here.</p>
</div>
<div class="post-text" itemprop="text">
<p>Loop through your existing dictionary, here is an example using <a href="http://docs.python.org/2/library/stdtypes.html#dict.setdefault" rel="nofollow"><code>dict.setdefault()</code></a>:</p>
<pre><code>countdict = {}
for k, v in worddict.items():
    countdict.setdefault(v, []).append(k)
</code></pre>
<p>Or with <a href="http://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a>:</p>
<pre><code>import collections
countdict = collections.defaultdict(list)
for k, v in worddict.items():
    countdict[v].append(k)
</code></pre>
<p>Personally I prefer the <code>setdefault()</code> method because the result is a regular dictionary.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; worddict = {"hello": 2, "hi": 2, "world": 4}
&gt;&gt;&gt; countdict = {}
&gt;&gt;&gt; for k, v in worddict.items():
...     countdict.setdefault(v, []).append(k)
...
&gt;&gt;&gt; countdict
{2: ['hi', 'hello'], 4: ['world']}
</code></pre>
<p>As noted in some of the other answers, you can significantly shorten your <code>book_index</code> function by using <a href="http://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without duplicates:</p>
<pre><code>word_by_count_dict = {value: key for key, value in worddict.iteritems()}
</code></pre>
<p>See PEP 274 to understand dictionary comprehension with Python: <a href="http://www.python.org/dev/peps/pep-0274/" rel="nofollow">http://www.python.org/dev/peps/pep-0274/</a></p>
<p>With duplicates:</p>
<pre><code>import collections

words_by_count_dict = collections.defaultdict(list)
for key, value in worddict.iteritems():
    words_by_count_dict[value].append(key)
</code></pre>
<p>This way:</p>
<pre><code>words_by_count_dict[2] = ["hello", "hi"]
</code></pre>
</div>
<span class="comment-copy">Why don't you build the "reversed" dictionary during file parsing instead?</span>
<span class="comment-copy">This was a wonderful answer. I followed your advice with Counter (though I have never used it before so I had to do some homework first) and it cleaned up my function amazingly well. I am still working on the second part of the problem - turning the dictionary "inside-out", but you've helped a ton. Thank you!</span>
<span class="comment-copy">lots of <code>update</code> calls are slow, feed the Counter a generator: <code>counter = Counter(word for line in alice for word in line.split())</code></span>
<span class="comment-copy">And this doesn't answer the OP's question, you just rewrote his already-functioning counter implementation.</span>
<span class="comment-copy">@roippi Was targeting this specifically at what the OP had already done. It doesn't solve the OPs problem in all cases, but in the case where OP is looking to get words corresponding to higher values (which is a decent subset of this kind of problem) this is a very clear solution. I specifically mention that this doesn't solve every case, but this covers the cases where there's an elegant solution.</span>
<span class="comment-copy">I have never used "collections" or "Counter" but will give this a shot. My main concern is getting it to run at this point but will certainly clean up my function with collections.Counter after. Thank you for your help!</span>
<span class="comment-copy">A problem I am encountering here is that it is telling me worddict is not defined. I returned it in my function "book_index(alice)", though, so shouldn't it be available to all other functions?</span>
<span class="comment-copy">This will get rid of all keys which an identical value (which isnâ€™t unlikely for word counts).</span>
