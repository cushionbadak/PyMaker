<div class="post-text" itemprop="text">
<p>I am trying to memcheck a C python extension I am writing, but I'm having trouble setting up valgrind to work with python. I would really appreciate some advice. Just for context, this is Ubuntu 13.10, python 2.7.5+, and valgrind 3.8.1.</p>
<p>As per recommendation from <a href="http://svn.python.org/projects/python/trunk/Misc/README.valgrind"><code>Readme.valgrind</code></a> I did the following.</p>
<p>1) Downloaded the python source with</p>
<pre><code>sudo apt-get build-dep python2.7
apt-get source python2.7
</code></pre>
<p>2) Applied the code patch, i.e. "Uncomment Py_USING_MEMORY_DEBUGGER in Objects/obmalloc.c".</p>
<p>3) Applied the suppression patch, i.e. "Uncomment the lines in Misc/valgrind-python.supp that suppress the warnings for PyObject_Free and PyObject_Realloc"</p>
<p>4) Compiled python with </p>
<pre><code>./configure --prefix=/home/dejan/workspace/python --without-pymalloc
make -j4 install
</code></pre>
<p>Note that I did both 2 and 3, while README.valgrind says to do 2 or 3... more can't hurt. </p>
<p>Now, let's test this on some sample python code in <code>test.py</code></p>
<pre><code>print "Test"
</code></pre>
<p>Let's run valgrind on python with this script</p>
<pre><code>valgrind --tool=memcheck --leak-check=full --suppressions=python2.7-2.7.5/Misc/valgrind-python.supp bin/python test.py
</code></pre>
<p>Unexpectedly, there is still loads of reports from valgrind, with the first one being (and many more following) </p>
<pre><code>==27944== HEAP SUMMARY:
==27944==     in use at exit: 857,932 bytes in 5,144 blocks  
==27944==   total heap usage: 22,766 allocs, 17,622 frees, 4,276,934 bytes allocated
==27944== 
==27944== 38 bytes in 1 blocks are possibly lost in loss record 24 of 1,343
==27944==    at 0x4C2A2DB: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==27944==    by 0x46B8DD: PyString_FromString (stringobject.c:143)
==27944==    by 0x439631: PyFile_FromFile (fileobject.c:157)
==27944==    by 0x4E9B4A: _PySys_Init (sysmodule.c:1383)
==27944==    by 0x4E29E9: Py_InitializeEx (pythonrun.c:222)
==27944==    by 0x4154B4: Py_Main (main.c:546)
==27944==    by 0x577DDE4: (below main) (libc-start.c:260)
</code></pre>
<p>Am I doing something wrong? Is there a way to valgrind a python script that doesn't leak and get clean valgrind output? </p>
</div>
<div class="post-text" itemprop="text">
<p>I found the answer <a href="http://code.google.com/p/distnumpy/wiki/valgrind">here</a>.</p>
<p>Python also needs to be compiled in debug mode, i.e. </p>
<pre><code>./configure --prefix=/home/dejan/workspace/python --without-pymalloc --with-pydebug --with-valgrind
</code></pre>
<p>In addition, numpy has a <a href="http://code.google.com/p/distnumpy/source/browse/trunk/misc/valgrind.supp?r=257">suppresion file</a> that gets rid of the extra valgrind warnings.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since python 3.6, there's a <code>PYTHONMALLOC</code> environment variable which is available in release builds, without needing to recompile.</p>
<pre><code>PYTHONMALLOC=malloc python3 foobar.py
</code></pre>
<p>This will disable pymalloc and just use the libc malloc directly, making it valgrind-friendly. This is equivalent to <code>--without-pymalloc</code> (and it is just as slow)</p>
<p>If valgrind is too slow, other values can be helpful. <code>PYTHONMALLOC=debug</code> and <code>PYTHONMALLOC=malloc_debug</code> add debug hooks on top of the default and the libc allocators respectively. Their effects, from the docs:</p>
<blockquote>
<ul>
<li>Newly allocated memory is filled with the byte 0xCB</li>
<li>Freed memory is filled with the byte 0xDB</li>
<li>Detect violations of the Python memory allocator API. For example, PyObject_Free() called on a memory block allocated by PyMem_Malloc().</li>
<li>Detect writes before the start of a buffer (buffer underflows)</li>
<li>Detect writes after the end of a buffer (buffer overflows)</li>
<li>Check that the GIL is held when allocator functions of PYMEM_DOMAIN_OBJ (ex: PyObject_Malloc()) and PYMEM_DOMAIN_MEM (ex: PyMem_Malloc()) domains are called.</li>
</ul>
</blockquote>
<p>This will catch some uninitialized reads, some use after free, some buffer under/overflows, etc, but won't report leaks and won't touch memory that isn't allocated through python (When using glibc, the <code>MALLOC_PERTURB_</code> and <code>MALLOC_CHECK_</code> environment variables might help there)</p>
<p>See also:</p>
<ul>
<li><a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONMALLOC" rel="noreferrer">Details of the available values</a></li>
<li><a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pythonmalloc" rel="noreferrer">3.6 release notes</a> with usage notes</li>
<li><a href="https://github.com/python/cpython/blob/master/Misc/README.valgrind" rel="noreferrer">Current location of README.valgrind</a></li>
</ul>
</div>
<span class="comment-copy">Have you seen <a href="http://stackoverflow.com/questions/1519276/is-it-normal-that-running-python-under-valgrind-shows-many-errors-with-memory?rq=1" title="is it normal that running python under valgrind shows many errors with memory">stackoverflow.com/questions/1519276/…</a></span>
<span class="comment-copy">@VooDooNOFX I've searched stackoverflow and beyond and all answers basically say that I should do what I described I did -- compile python or use a supress. This does get rid of the custom allocation problematic reports such as PyObject_Free (this is the one in the question you linked), but the reports I'm getting are not of that sort.</span>
<span class="comment-copy">In order to test my c extension, I compiled debug python with instructions provided in the Answer. And I rebuild my extension with debug version python, and it got failure result. I used setuptools extension build the extension, and it works well under system environment. The build flags are very different.</span>
<span class="comment-copy">Thanks for doing the research for everyone! Do you know if one should recompile python once done using valgrind? And, more importantly - how to do it?</span>
<span class="comment-copy">What works for me is compiling/installing a valgrind-compatible version of python, then basing a virtualenv on that. That gives me the convenient <code>activate</code> script. Even better with <code>virtualenvwrapper</code></span>
<span class="comment-copy">does this make every python command call run with valgrind? I'm noticing a significant slow down installing packages with pip</span>
<span class="comment-copy">@JamesRobertAlbert From the README: Note: configuring python --without-pymalloc makes Python run much slower, especially when running under Valgrind. ... It seems to take about 5 times longer to run --without-pymalloc</span>
<span class="comment-copy">@YairDaon you don't have to recompile Python because you create a new interpreter. Related : <a href="https://stackoverflow.com/questions/36697863/questions-about-compiling-python-in-debug-mode" title="questions about compiling python in debug mode">stackoverflow.com/questions/36697863/…</a>.</span>
<span class="comment-copy">This worked great for me.</span>
