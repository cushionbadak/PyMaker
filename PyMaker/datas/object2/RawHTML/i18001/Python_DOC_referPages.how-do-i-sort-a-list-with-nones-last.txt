<div class="post-text" itemprop="text">
<p>I'm sorting a list of dicts by a key:</p>
<pre><code>groups = sorted(groups, key=lambda a: a['name'])
</code></pre>
<p>some of the dicts have name set to <code>None</code>, and Python 2 places <code>None</code> values before any other, so they're placed at the front of the sorted list. A naive fix would be</p>
<pre><code>groups = sorted(groups, key=lambda a: a['name'] or 'zzzz')
</code></pre>
<p>but, obviously, that would not work for any non-Latin names.</p>
<p>What is a nice and Pythonic way of sorting a list containing <code>None</code> values so that those  values are placed at the end of the list?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this by keying it on a tuple:</p>
<pre><code>groups = sorted(groups, key=lambda a: (a['name'] is None, a['name']))
</code></pre>
<hr/>
<p>This works because Python compares tuples lexicographically (on the first element, then on the second to break ties), and because False gets sorted earlier than True. A list of groups like</p>
<pre><code>[{'name': 0}, {'name': 1}, {'name': 2}, {'name': 3}, {'name': 4}, {'name': None}]
</code></pre>
<p>will become</p>
<pre><code>[(False, 0), (False, 1), (False, 2), (False, 3), (False, 4), (True, None)]
</code></pre>
<p>The tuple that starts with <code>True</code> will necessarily end up at the end, and the rest, since the first value ties, will be sorted by the second value.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create your own "infinity" object:</p>
<pre><code>from functools import total_ordering

@total_ordering
class Infinity:
    def __eq__(self, other):
        return type(other) == Infinity
    def __lt__(self, other):
        return False
</code></pre>
<p>Use it like so:</p>
<pre><code>&gt;&gt;&gt; lis = [{'name': 1}, {'name': None}, {'name': 0}, {'name': 2}]
&gt;&gt;&gt; sorted(lis, key=lambda a: Infinity() if a['name'] is None else a['name'])
[{'name': 0}, {'name': 1}, {'name': 2}, {'name': None}]
</code></pre>
</div>
<span class="comment-copy">FWIW, using a list of a custom class you create, would make this trivial.</span>
<span class="comment-copy">clever, though you may want to explain why it works :)</span>
<span class="comment-copy">I'm pretty sure the <a href="http://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">Sorting HOW TO</a> in the official docs explains this somewhere. Even if it doesn't, this is still the one obvious way to do it, it's just not quite as obvious. :)</span>
<span class="comment-copy">That's very clever indeed, thanks :) Although a 10-character change in the code required 4 lines of comments to explain how the thing works :))</span>
<span class="comment-copy">That's a nice solution too although maybe a bit overkill for my use case</span>
<span class="comment-copy">Potentially a bit more efficient than the tuple solution though: the keys are smaller, and the (probably) common case of comparing two non-None names does an extra comparison with the tuples. Marginal difference though, style is more important. And personally I would call this one of the very few cases where a Singleton is justified.</span>
