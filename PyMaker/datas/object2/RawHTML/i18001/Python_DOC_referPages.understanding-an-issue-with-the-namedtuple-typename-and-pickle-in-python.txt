<div class="post-text" itemprop="text">
<p>Earlier today I was having trouble trying to pickle a <a href="http://docs.python.org/2/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer">namedtuple</a> instance. As a sanity check, I tried running some code that was posted <a href="https://stackoverflow.com/a/16377267/553404">in another answer</a>. Here it is, simplified a little more:</p>
<pre><code>from collections import namedtuple
import pickle

P = namedtuple("P", "one two three four")

def pickle_test():
    abe = P("abraham", "lincoln", "vampire", "hunter")
    f = open('abe.pickle', 'w')
    pickle.dump(abe, f)
    f.close()

pickle_test()
</code></pre>
<p>I then changed two lines of this to use my named tuple:</p>
<pre><code>from collections import namedtuple
import pickle

P = namedtuple("my_typename", "A B C")

def pickle_test():
    abe = P("ONE", "TWO", "THREE")
    f = open('abe.pickle', 'w')
    pickle.dump(abe, f)
    f.close()

pickle_test()
</code></pre>
<p>However this gave me the error</p>
<pre><code>  File "/path/to/anaconda/lib/python2.7/pickle.py", line 748, in save_global
    (obj, module, name))
pickle.PicklingError: Can't pickle &lt;class '__main__.my_typename'&gt;: it's not found as __main__.my_typename
</code></pre>
<p>i.e. the Pickle module is looking for <code>my_typename</code>. I changed the line <code>P = namedtuple("my_typename", "A B C")</code> to <code>P = namedtuple("P", "A B C")</code> and it worked.</p>
<p>I looked at the source of <code>namedtuple.py</code> and at the end we have something that looks relevant, but I don't fully understand what is happening:</p>
<pre><code># For pickling to work, the __module__ variable needs to be set to the frame
# where the named tuple is created.  Bypass this step in enviroments where
# sys._getframe is not defined (Jython for example) or sys._getframe is not
# defined for arguments greater than 0 (IronPython).
try:
    result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')
except (AttributeError, ValueError):
    pass

return result
</code></pre>
<p>So my question is what exactly is going on? Why does the <code>typename</code> argument need to match the name of the factory for this to work?</p>
</div>
<div class="post-text" itemprop="text">
<p>In the section titled <a href="https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled" rel="nofollow noreferrer"><strong><em>What can be pickled and unpickled?</em></strong></a> of the Python documentation it indicates that only "classes that are defined at the top level of a module" can be pickled. However <a href="https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer"><code>namedtuple()</code></a> is a factory <em>function</em> which is effectively defining a class (<code>my_typename(tuple)</code> in your second example), however it's not assigning the manufactured type to a variable named <code>my_typename</code> at the top level of the module.</p>
<p>This is because <code>pickle</code> saves only the “fully qualified” name of such things, not their code, and they must be <code>import</code>able from the module they're in using this name in order to be able to unpickled later (hence the requirement that the module must contain the named object at the top level).</p>
<p>This can be illustrated by seeing one workaround for the problem—which would be to change one line of the code so that the type named <code>my_typename</code> <em>is</em> defined at the top level:</p>
<pre><code>P = my_typename = namedtuple("my_typename", "A B C")
</code></pre>
<p>Alternatively, you could just give the <code>namedtuple</code> the name <code>"P"</code> instead of <code>"my_typename"</code>:</p>
<pre><code>P = namedtuple("P", "A B C")
</code></pre>
<p>As for what that <code>namedtuple.py</code> source code you were looking at does: It's trying to determine the name of module the caller (the creator of the <code>namedtuple</code>) is in because the author knows that <code>pickle</code> might try to use it to <code>import</code> the definition to do unpickling and that folks commonly assign the result to variable with the same name that they passed to the factory function (but you didn't in the second example).</p>
</div>
<span class="comment-copy">thank you for "alternative" way. Works like a charm.</span>
