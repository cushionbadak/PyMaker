<div class="post-text" itemprop="text">
<p>here is a merge sort logic in python : (this is the first part, ignore the function merge()) The point in question is converting the recursive logic to a while loop.
Code courtesy: <a href="http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort#Python" rel="nofollow">Rosettacode Merge Sort</a></p>
<pre><code>def merge_sort(m):
    if len(m) &lt;= 1:
        return m

    middle = len(m) / 2
    left = m[:middle]
    right = m[middle:]

    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))
</code></pre>
<p>Is it possible to make it a sort of dynamically in the while loop while each left and right array breaks into two, a sort of pointer keeps increasing based on the number of left and right arrays and breaking them until only single length sized list remains?
because every time the next split comes while going on both left- and right- side the array keeps breaking down till only single length list remains, so the number of left sided (left-left,left-right) and right sided (right-left,right-right) breaks will increase till it reaches a list of size 1 for all.</p>
</div>
<div class="post-text" itemprop="text">
<p>One possible implementation might be this:</p>
<pre><code>def merge_sort(m):
    l = [[x] for x in m]                  # split each element to its own list
    while len(l) &gt; 1:                     # while there's merging to be done 
        for x in range(len(l) &gt;&gt; 1):      # take the first len/2 lists
            l[x] = merge(l[x], l.pop())   # and merge with the last len/2 lists
    return l[0] if len(l) else []
</code></pre>
<p>Stack frames in the recursive version are used to store progressively smaller lists that need to be merged. You correctly identified that at the bottom of the stack, there's a one-element list for each element in whatever you're sorting. So, by starting from a series of one-element lists, we can iteratively build up larger, merged lists until we have a single, sorted list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Reposted from <a href="https://stackoverflow.com/questions/19903985/alternative-to-recursion-based-merge-sort-logic/19907169#19907169">alternative to recursion based merge sort logic</a> at the request of a reader:</p>
<p>One way to eliminate recursion is to use a <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="nofollow noreferrer">queue</a> to manage the outstanding work. For example, using the built-in <a href="http://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a>:</p>
<pre><code>from collections import deque
from heapq import merge

def merge_sorted(iterable):
    """Return a list consisting of the sorted elements of 'iterable'."""
    queue = deque([i] for i in iterable)
    if not queue:
        return []
    while len(queue) &gt; 1:
        queue.append(list(merge(queue.popleft(), queue.popleft())))
    return queue[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/931762/can-every-recursion-be-converted-into-iteration/933979#comment10514125_933979">It's said</a>, that every recursive function can be written in a non-recursive manner, so the short answer is: yes, it's possible. The only solution I can think of is to use the stack-based approach. When recursive function invokes itself, it puts some context (its arguments and return address) on the inner stack, which isn't available for you. Basically, what you need to do in order to eliminate recursion is to write your own stack and every time when you would make a recursive call, put the arguments onto this stack. </p>
<p>For more information you can read <a href="http://cs.saddleback.edu/rwatkins/CS2B/Lab%20Exercises/Stacks%20and%20Recursion%20Lab.pdf" rel="nofollow noreferrer">this article</a>, or refer to the section named 'Eliminating Recursion' in Robert Lafore's "Data Structures and Algorithms in Java" (although all the examples in this book are given in Java, it's pretty easy to grasp the main idea).</p>
</div>
<div class="post-text" itemprop="text">
<p>Going with Dan's solution above and taking the advice on pop, still I tried eliminating while and other not so pythonic approach. Here is a solution that I have suggested:
PS: l = len</p>
<p>My doubt on Dans solution is what if L.pop() and L[x] are same and a conflict is created, as in the case of an odd range after iterating over half of the length of L?</p>
<pre><code>def merge_sort(m):
    L = [[x] for x in m]  # split each element to its own list
    for x in xrange(l(L)):      
        if x &gt; 0:
            L[x] = merge(L[x-1], L[x])
    return L[-1]
</code></pre>
<p>This can go on for all academic discussions but I got my answer to an alternative to recursive method.</p>
</div>
<span class="comment-copy">ive one doubt here.  merge(l[x], l.pop()); l.pop() pops out the last list element and merge compares the l[x] list element with the last one.shouldnt it be merge(l[x],l[x+1])?</span>
<span class="comment-copy">You need to be reducing the size of <code>l</code> with each pass, hence the <code>pop</code>. If you wanted to be sure you always merged adjacent sublists, you could do <code>merge(l[x], l.pop(x+1))</code>, but the algorithm works either way. It shouldn't matter what merges with what so long as the resulting new sublist is sorted.</span>
<span class="comment-copy">merging <i>adjacent</i> entries gives you a <i>stable</i> sort variant though.</span>
<span class="comment-copy">@WillNess can you explain what do you mean by stable sort variant by doing merging of adjacent entries?</span>
<span class="comment-copy">calling <code>l.pop(x+1)</code> one by one will be slow. To make it stable, better to use <code>for x in range(len(l) &gt;&gt; 1): l[x] = merge(l[2*x], l[2*x+1])</code> and then, after the <code>for</code> loop, remove the <code>l</code>'s second half slice at once (possibly keeping the last element, if len(l) was odd), <code>l[(len(l)&gt;&gt;1):(len(l)&gt;&gt;1)*2]=[]</code>.</span>
<span class="comment-copy">+1. though this too is a non-stable variant of mergesort (when the length of the input list is anything but a power of 2). the case where the coding approach is <i>nice</i>, but ... -- And if we change it to produce new list, twice shorter, on each step, then it is not a queue anymore; more importantly, then the problem appears of dangling non-merged short stubs near the end of the list. Same problem (of dangling short stubs) exists also for <a href="http://stackoverflow.com/questions/19903985/alternative-to-recursion-based-merge-sort-logic/19907169#comment29719469_19905146">this</a> modification.</span>
<span class="comment-copy">(contd.) to deal with that problem (like e.g. for <i>2^n+1</i> initial length), we must alternate the direction at which we sweep the intermediate list of lists, at each step.</span>
<span class="comment-copy">another thing is, we don't actually need to create the list of lists; we can just work on the original array, and one other copy of it, in the alternating fashion, going forth and back by 2x sized chunks each time (which we'll treat as <i>already ordered</i>, by previous steps).</span>
<span class="comment-copy">it is never the same; <code>a &gt;&gt; 1</code> is like <code>a div 2</code> so for odd numbers 1 is left as remainder, i.e. the middle element is not processed - not touched. -- what gives mergsort its efficiency is the (roughly balanced) <i>tree</i> of merges; you introduce great disbalance, your tree is degenerate - making it actualy an insertion sort, an  O(n^2) algorithm (your calls to merge always have a singleton list as its 2nd argment).</span>
<span class="comment-copy">@WillNess any other non recursive implementation,if  you could offer</span>
<span class="comment-copy">there was another answer here with good code in it, using queues; I've contacted a moderator to see if and how this contents can be brought back. It'll take a day or so, probably. In the mean time, see if you can tweak the code into using a queue (pop 2 from the front, append merged result at the back). This will also be unstable; still it's an interesting variation to it. Try <code>from collections import deque</code>, <code>from heapq import merge</code>, ...</span>
<span class="comment-copy">@WillNess will ive tried deque and merge from heapq. the rosetta code is a python try for implementing merge(check the link in the question); I don't know why that answer was taken down but yes thats a better hack.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/20043332/849891">there you go</a>. :)</span>
