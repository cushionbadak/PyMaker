<div class="post-text" itemprop="text">
<p>I often do interactive work in Python that involves some expensive operations that I don't want to repeat often. I'm generally running whatever Python file I'm working on frequently.</p>
<p>If I write:</p>
<pre><code>import functools32

@functools32.lru_cache()
def square(x):
    print "Squaring", x
    return x*x
</code></pre>
<p>I get this behavior:</p>
<pre><code>&gt;&gt;&gt; square(10)
Squaring 10
100
&gt;&gt;&gt; square(10)
100
&gt;&gt;&gt; runfile(...)
&gt;&gt;&gt; square(10)
Squaring 10
100
</code></pre>
<p>That is, rerunning the file clears the cache. This works:</p>
<pre><code>try:
    safe_square
except NameError:
    @functools32.lru_cache()
    def safe_square(x):
        print "Squaring", x
        return x*x
</code></pre>
<p>but when the function is long it feels strange to have its definition inside a <code>try</code> block. I can do this instead:</p>
<pre><code>def _square(x):
    print "Squaring", x
    return x*x

try:
    safe_square_2
except NameError:
    safe_square_2 = functools32.lru_cache()(_square)
</code></pre>
<p>but it feels pretty contrived (for example, in calling the decorator without an '@' sign)</p>
<p>Is there a simple way to handle this, something like:</p>
<pre><code>@non_resetting_lru_cache()
def square(x):
    print "Squaring", x
    return x*x
</code></pre>
<p>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Writing a script to be executed repeatedly in the same session is an odd thing to do.</p>
<p>I can see why you'd want to do it, but it's still odd, and I don't think it's unreasonable for the code to expose that oddness by looking a little odd, and having a comment explaining it.</p>
<p>However, you've made things uglier than necessary.</p>
<p>First, you can just do this:</p>
<pre><code>@functools32.lru_cache()
def _square(x):
    print "Squaring", x
    return x*x

try:
    safe_square_2
except NameError:
    safe_square_2 = _square
</code></pre>
<p>There is no harm in attaching a cache to the new <code>_square</code> definition. It won't waste any time, or more than a few bytes of storage, and, most importantly, it won't affect the cache on the <em>previous</em> <code>_square</code> definition. That's the whole point of closures.</p>
<hr/>
<p>There <em>is</em> a potential problem here with recursive functions. It's already inherent in the way you're working, and the cache doesn't add to it in any way, but you might only <em>notice</em> it because of the cache, so I'll explain it and show how to fix it. Consider this function:</p>
<pre><code>@lru_cache()
def _fact(n):
    if n &lt; 2:
        return 1
    return _fact(n-1) * n
</code></pre>
<p>When you re-exec the script, even if you have a reference to the old <code>_fact</code>, it's going to end up calling the new <code>_fact</code>, because it's accessing <code>_fact</code> as a global name. It has nothing to do with the <code>@lru_cache</code>; remove that, and the old function will <em>still</em> end up calling the new <code>_fact</code>.</p>
<p>But if you're using the renaming trick above, you can just call the renamed version:</p>
<pre><code>@lru_cache()
def _fact(n):
    if n &lt; 2:
        return 1
    return fact(n-1) * n
</code></pre>
<p>Now the old <code>_fact</code> will call <code>fact</code>, which is still the old <code>_fact</code>. Again, this works identically with or without the cache decorator.</p>
<hr/>
<p>Beyond that initial trick, you can factor that whole pattern out into a simple decorator. I'll explain step by step below, or see <a href="http://stupidpythonideas.blogspot.com/2013/11/if-not-exists-definitions.html" rel="nofollow">this blog post</a>.</p>
<hr/>
<p>Anyway, even with the less-ugly version, it's still a bit ugly and verbose. And if you're doing this dozens of times, my "well, it <em>should</em> look a <em>bit</em> ugly" justification will wear thin pretty fast. So, you'll want to handle this the same way you always factor out ugliness: wrap it in a function.</p>
<p>You can't really pass names around as objects in Python. And you don't want to use a hideous frame hack just to deal with this. So you'll have to pass the names around as strings. ike this:</p>
<pre><code>globals().setdefault('fact', _fact)
</code></pre>
<p>The <code>globals</code> function just returns the current scope's global dictionary. Which is a <code>dict</code>, which means it has the <code>setdefault</code> method, which means this will set the global name <code>fact</code> to the value <code>_fact</code> if it didn't already have a value, but do nothing if it did. Which is exactly what you wanted. (You could also use <code>setattr</code> on the current module, but I think this way emphasizes that the script is meant to be (repeatedly) executed in someone else's scope, not used as a module.)</p>
<p>So, here that is wrapped up in a function:</p>
<pre><code>def new_bind(name, value):
    globals().setdefault(name, value)
</code></pre>
<p>… which you can turn that into a decorator almost trivially:</p>
<pre><code>def new_bind(name):
    def wrap(func):
        globals().setdefault(name, func)
        return func
    return wrap
</code></pre>
<p>Which you can use like this:</p>
<pre><code>@new_bind('foo')
def _foo():
    print(1)
</code></pre>
<hr/>
<p>But wait, there's more! The <code>func</code> that <code>new_bind</code> gets is going to have a <code>__name__</code>, right? If you stick to a naming convention, like that the "private" name must be the "public" name with a <code>_</code> prefixed, we can do this:</p>
<pre><code>def new_bind(func):
    assert func.__name__[0] == '_'
    globals().setdefault(func.__name__[1:], func)
    return func
</code></pre>
<p>And you can see where this is going:</p>
<pre><code>@new_bind
@lru_cache()
def _square(x):
    print "Squaring", x
    return x*x
</code></pre>
<p>There is one minor problem: if you use any other decorators that don't wrap the function properly, they will break your naming convention. So… just don't do that. :)</p>
<hr/>
<p>And I think this works exactly the way you want in every edge case. In particular, if you've edited the source and want to force the new definition with a new cache, you just <code>del square</code> before rerunning the file, and it works.</p>
<hr/>
<p>And of course if you want to merge those two decorators into one, it's trivial to do so, and call it <code>non_resetting_lru_cache</code>.</p>
<p>However, I'd keep them separate. I think it's more obvious what they do. And if you ever want to wrap another decorator around <code>@lru_cache</code>, you're probably still going to want <code>@new_bind</code> to be the outermost decorator, right?</p>
<hr/>
<p>What if you want to put <code>new_bind</code> into a module that you can import? Then it's not going to work, because it will be referring to the globals of that module, not the one you're currently writing.</p>
<p>You can fix that by explicitly passing your <code>globals</code> dict, or your module object, or your module name as an argument, like <code>@new_bind(__name__)</code>, so it can find your globals instead of its. But that's ugly and repetitive.</p>
<p>You can also fix it with an ugly frame hack. At least in CPython, <a href="http://docs.python.org/3/library/sys.html#sys._getframe" rel="nofollow"><code>sys._getframe()</code></a> can be used to get your caller's frame, and <a href="http://docs.python.org/3/library/inspect.html#types-and-members" rel="nofollow"><code>frame objects</code></a> have a reference to their globals namespace, so:</p>
<pre><code>def new_bind(func):
    assert func.__name__[0] == '_'
    g = sys._getframe(1).f_globals
    g.setdefault(func.__name__[1:], func)
    return func
</code></pre>
<p>Notice the big box in the docs that tells you this is an "implementation detail" that may only apply to CPython and is "for internal and specialized purposes only". Take this seriously. Whenever someone has a cool idea for the stdlib or builtins that could be implemented in pure Python, but only by using <code>_getframe</code>, it's generally treated almost the same as an idea that can't be implemented in pure Python at all. But if you know what you're doing, and you want to use this, and you only care about present-day versions of CPython, it will work.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no <code>persistent_lru_cache</code> in the stdlib. But you can build one pretty easily.</p>
<p><a href="http://hg.python.org/cpython/file/3.3/Lib/functools.py#l192" rel="nofollow">The <code>functools</code> source</a> is linked directly from <a href="http://docs.python.org/3/library/functools.html" rel="nofollow">the docs</a>, because this is one of those modules that's as useful as sample code as it is for using it directly.</p>
<p>As you can see, the cache is just a <code>dict</code>. If you replace that with, say, a <a href="http://docs.python.org/3/library/shelve.html" rel="nofollow"><code>shelf</code></a>, it will become persistent automatically:</p>
<pre><code>def persistent_lru_cache(filename, maxsize=128, typed=False):
    """new docstring explaining what dbpath does"""
    # same code as before up to here
    def decorating_function(user_function):
        cache = shelve.open(filename)
        # same code as before from here on.
</code></pre>
<p>Of course that only works if your arguments are strings. And it could be a little slow.</p>
<p>So, you might want to instead keep it as an in-memory <code>dict</code>, and just write code that pickles it to a file <code>atexit</code>, and restores it from a file if present at startup:</p>
<pre><code>    def decorating_function(user_function):
        # ...

        try:
            with open(filename, 'rb') as f:
                cache = pickle.load(f)
            except:
                cache = {}
        def cache_save():
            with lock:
                with open(filename, 'wb') as f:
                    pickle.dump(cache, f)
        atexit.register(cache_save)

        # …
        wrapper.cache_save = cache_save
        wrapper.cache_filename = filename
</code></pre>
<p>Or, if you want it to write every N new values (so you don't lose the whole cache on, say, an <code>_exit</code> or a segfault or someone pulling the cord), add this to the second and third versions of <code>wrapper</code>, right after the <code>misses += 1</code>:</p>
<pre><code>            if misses % N == 0:
                cache_save()
</code></pre>
<hr/>
<p>See <a href="https://github.com/abarnert/persistent-lru-cache" rel="nofollow">here</a> for a working version of everything up to this point (using <code>save_every</code> as the "N" argument, and defaulting to <code>1</code>, which you probably don't want in real life).</p>
<p>If you want to be really clever, maybe copy the cache and save that in a background thread.</p>
<p>You might want to extend the <code>cache_info</code> to include something like number of cache writes, number of misses since last cache write, number of entries in the cache at startup, …</p>
<p>And there are probably other ways to improve this.</p>
<p>From a quick test, with <code>save_every=1</code>, this makes the cache on both <code>get_pep</code> and <code>fib</code> (from the <code>functools</code> docs) persistent, with no measurable slowdown to <code>get_pep</code> and a very small slowdown to <code>fib</code> the first time (note that <code>fib(100)</code> has 100097 hits vs. 101 misses…), and of course a large speedup to <code>get_pep</code> (but not <code>fib</code>) when you re-run it. So, just what you'd expect.</p>
</div>
<div class="post-text" itemprop="text">
<p>I can't say I won't just use @abarnert's "ugly frame hack", but here is the version that requires you to pass in the calling module's globals dict. I think it's worth posting given that <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240845" rel="nofollow">decorator functions with arguments are tricky and meaningfully different from those without arguments</a>.</p>
<pre><code>def create_if_not_exists_2(my_globals):
    def wrap(func):
        if "_" != func.__name__[0]:
            raise Exception("Function names used in cine must begin with'_'")
        my_globals.setdefault(func.__name__[1:], func)
        def wrapped(*args):
            func(*args)
        return wrapped
    return wrap
</code></pre>
<p>Which you can then use in a different module like this:</p>
<pre><code>from functools32 import lru_cache
from cine import create_if_not_exists_2

@create_if_not_exists_2(globals())
@lru_cache()
def _square(x):
    print "Squaring", x
    return x*x

assert "_square" in globals()
assert "square" in globals()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've gained enough familiarity with decorators during this process that I was comfortable taking a swing at solving the problem another way:</p>
<pre><code>from functools32 import lru_cache

try:
    my_cine
except NameError:
    class my_cine(object):
        _reg_funcs = {}

        @classmethod
        def func_key (cls, f):
            try:
                name = f.func_name
            except AttributeError:
                name = f.__name__
            return (f.__module__, name)

        def __init__(self, f):
            k = self.func_key(f)
            self._f = self._reg_funcs.setdefault(k, f)

        def __call__(self, *args, **kwargs):
            return self._f(*args, **kwargs)


if __name__ == "__main__":
    @my_cine
    @lru_cache()
    def fact_my_cine(n):
        print "In fact_my_cine for", n
        if n &lt; 2:
            return 1
        return fact_my_cine(n-1) * n

    x = fact_my_cine(10)
    print "The answer is", x
</code></pre>
<p>@abarnert, if you are still watching, I'd be curious to hear your assessment of the downsides of this method. I know of two:</p>
<ol>
<li>You have to know in advance what attributes to look in for a name to associate with the function. My first stab at it only looked at func_name which failed when passed an lru_cache object.</li>
<li>Resetting a function is painful: <code>del my_cine._reg_funcs[('__main__', 'fact_my_cine')]</code>, and the swing I took at adding a __delitem__ was unsuccessful.</li>
</ol>
</div>
<span class="comment-copy">Your change doesn't really "work", unless you're re-running the script in a single Python interpreter session by, e.g., <code>execfile</code>-ing it.</span>
<span class="comment-copy">See below; I removed the word "persistent" to be clearer. Re-running the script in a single Python interpreter session is what I'm shooting for here.</span>
<span class="comment-copy">This is a very odd way to run scripts, but I can see why you'd want to do it. Let me write another answer with some comments.</span>
<span class="comment-copy">Apologies for writing something twice as long as the <code>persistent</code> answer, even though the final result is 6 lines of pretty trivial code (as opposed to 239 lines that were complex enough that I felt the need to git them). But I think it was worth going through all the steps to get there. I could pull all the middle stuff out and turn it into a blog post somewhere and just link to that and summarize it here, if anyone thinks this is just way too much for an answer.</span>
<span class="comment-copy">Clever! I would not have thought of creating the new cache but not using it. To run on my Python (2.7) I had to change "rebind\n" to "rebind()\n".</span>
<span class="comment-copy">@kuzzooroo: Sorry, yeah. The earlier <code>rebind</code> is a function returning a decorator; the later one can just be a decorator itself, so you won't need that, but not without me editing the code. I'll do that; thanks for pointing it out.</span>
<span class="comment-copy">I just realized that <code>rebind</code> was a terrible name for a function that does the exact opposite of that—bind a new name, but never rebind an existing name. So I change it to <code>new_bind</code>. Not beautiful, but at least not completely wrong…</span>
<span class="comment-copy">I believe this doesn't work if the place I'm trying to use the decorator is not in the same module as the decorator's definition. For example, the code below doesn't work for me (second assertion fails). Is there a way to stick create_if_not_exists into a library without running into this issue? from functools32 import lrucache\n from cine import create_if_not_exists\n \n @create_if_not_exists\n @lru_cache()\n def _square(x):\n print "Squaring", x\n return x*x\n \n assert "_square" in globals()\n assert "square" in globals()\n</span>
<span class="comment-copy">I've changed "@persistent..." to "@non_resetting..." to be clearer. Having the cache stay around if I leave Python and restart it isn't the key; the key is that when I rerun my file in the same console window I don't lose all my state. I believe a shelf would work if my keys were all strings, with the side effect that I would get <i>real</i> persistence.</span>
