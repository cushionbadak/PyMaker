<div class="post-text" itemprop="text">
<p>I needed to go through all the tuples and change the value of the second item of the tuple to its 2 first letters after the first "/" (AA/BB/CC would become AA)</p>
<p>For the list</p>
<pre><code>[[("AA","AA/BB/AA"),("QQ","AB/AA")],[("CC","CC/SS/AA"),("QQ","CC/CC")],...]
</code></pre>
<p>would return this:</p>
<pre><code>[[("AA","AA"),("QQ","AB")],[("CC","CC"),("QQ","CC")],...]
</code></pre>
<p>I know how to do it with loops and changing from tupples to lists and to tuples back... but is there a way to do it in a shorter way?</p>
<p>Thanks in advance for nay help!!</p>
</div>
<div class="post-text" itemprop="text">
<p>For doing a single replacement on a string works, you can use <a href="http://docs.python.org/3/library/stdtypes.html#str.rsplit" rel="nofollow"><code>str.split</code></a> to split the string by slashes. <code>str.split</code> will return a list of the substrings it extracted from the string. As you are only interested in the substring before the first slash, you just need to get the first element of the result list. You can further use the <code>maxsplit</code> parameter to restrict <code>str.split</code> from splitting the string more than once (to make it stop processing the string earlier).</p>
<pre><code>&gt;&gt;&gt; 'AA/BB/CC'.split('/')
['AA', 'BB', 'CC']
&gt;&gt;&gt; 'AA/BB/CC'.split('/', 1)
['AA', 'BB/CC']
&gt;&gt;&gt; 'AA/BB/CC'.split('/', 1)[0]
'AA'
</code></pre>
<p>Now to perform the replacement across the list you have two choices: Either you replace the list <em>in place</em>, updating each element if necessary, or you create a new list where you apply the transformation on the fly. Note that you will always have to create new tuples though as they are immutable. As it’s generally a preferred way to solve things, I’m only showing you how to do the second way using list comprehension. But if you wanted to replace the elements in place, you would just have to loop through the list and update the list items.</p>
<pre><code>&gt;&gt;&gt; lst = [[("AA", "AA/BB/AA"), ("QQ", "AB/AA")], [("CC", "CC/SS/AA"), ("QQ", "CC/CC")]]
&gt;&gt;&gt; [[(a, b.split('/', 1)[0]) for a, b in x] for x in lst]
[[('AA', 'AA'), ('QQ', 'AB')], [('CC', 'CC'), ('QQ', 'CC')]]
</code></pre>
<p>A list comprehension in general looks like this:</p>
<pre><code>[t(x) for x in sequence]
</code></pre>
<p>For every element <code>x</code> in the <code>sequence</code> it will apply the transformation <code>t</code> to the element <code>x</code> and put that as an element in the list. So <code>[x for x in lst]</code> would just return an identical list <code>t</code> would be the identify function.</p>
<p>The element <code>x</code> can also be an unpacked tuple. If the elements in the source list are two-element tuples, you can use <code>[t(a, b) for a, b in lst]</code> to unpack the elements from the tuple, apply the transformation and put that into the result list.</p>
<p>In your case, we want to unpack the tuple, so we can work on the second element only. But we also want to keep it a tuple, so we put the result in a tuple again: <code>[(a, t(b)) for a, b in x]</code>. In this case, the transformation <code>t</code> would be the splitting I showed earlier.</p>
<p>Now because your list is actually not a list of tuples, but a <em>list of lists of tuples</em>, we have to nest two list comprehensions. Similar to above <code>[[y for y in x] for x in lst]</code> would reproduce a list of lists. Now as the inner list is a list of tuples, we can perform the transformation on the tuples there and put everything together.</p>
</div>
<span class="comment-copy">Please show us your attempts, you won't get any help until you do.</span>
<span class="comment-copy">However way you'd approach it, keep in mind that tuples are immutable. You'd always end up creating lists of new tuples based on the information in the original tuples.</span>
<span class="comment-copy">Thanks poke! I am new to python and struggling to learn this part... could you give me a hint on how does it work? specially the (a, b.split('/', 1)[0]...</span>
<span class="comment-copy">@user2950162 I’ve modified my answer to give you more details on the list comprehension. For some more information, I recommend you to check out the list comprehension section of the <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">Python tutorial</a>.</span>
<span class="comment-copy">Thanks a lot for the explanation, it was great! In this case you are getting the 2 words before the /. Is it possible to adjust it to get the next pair of words? I tried to change the indice [0] to [1] after the split but did not work...</span>
<span class="comment-copy">Given that we restricted <code>str.split</code> to perform only one split, the second element (index 1) will contain the whole remaining string (which can include further slashes). You can leave out the <code>maxsplit</code> parameter though and get the second element: <code>'AA/BB/CC'.split('/')[1]</code>.</span>
<span class="comment-copy">Thanks a lot for taking the time to explain it! Really appreciated!</span>
