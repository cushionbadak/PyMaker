<div class="post-text" itemprop="text">
<p>Why is it that python sometimes extends numbers and is there a way to stop it? For example 1.7 may turn into 1.70000005.
Specifically I'm encountering this while taking in a list of floats and trying to populate a new list. </p>
<pre><code>newList = []
for value in myList:
    print value
    newList.append(value)
return newList
</code></pre>
<p>The console will print out numbers containing no more than 2 decimal places while the newList being returned will have 17 places and oftentimes include a non-zero in the last digit. It does this even if I attempt to round(value,2) inside the loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's just the representation! Actually, the contents of the list is still the same.</p>
<p>To show it properly, you can format it in a string:</p>
<pre><code>print("{.17f}".format(my_float_value))
</code></pre>
<p>Alternatively, you can use the <code>decimals</code> module:</p>
<pre><code>&gt;&gt;&gt; import decimal
&gt;&gt;&gt; my_float = decimal.Decimal("0.2342134235")
&gt;&gt;&gt; my_float
Decimal('0.2342134235')
</code></pre>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>CPython uses C doubles, and C doubles are typically implemented in hardware for speed.</p>
<p>Hardware floating point is precise to only a limited number of digits.  Also, it's stored base 2, and we think mostly in base 10, and some numbers that have a finite expression in base 10, don't have one in base 2, and vice versa.</p>
<p>So you should:</p>
<ol>
<li>Never compare a floating point value for equality to another. 
Instead, subtract them, take the absolute value, and compare that
result to a small positive number like 1e-8.</li>
<li>Round your floating point values to a palatable number of places
after the decimal point, using string formatting or the
<a href="http://docs.python.org/3/library/functions.html#round" rel="nofollow">http://docs.python.org/3/library/functions.html#round</a> function.</li>
</ol>
<p>You can use the decimal module to get caller-specified precision.  Or if you have rational values, you can use the fractions module.</p>
</div>
<span class="comment-copy"><a href="http://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow noreferrer">docs.python.org/2/tutorial/floatingpoint.html</a></span>
<span class="comment-copy">Floating point arithmetic is a heartless mistress :)</span>
<span class="comment-copy">If you need exact floating point control, use the built in decimal module: <a href="http://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer">docs.python.org/2/library/decimal.html</a></span>
<span class="comment-copy">or fractions! <a href="http://docs.python.org/2/library/fractions.html" rel="nofollow noreferrer">docs.python.org/2/library/fractions.html</a></span>
<span class="comment-copy">This is a fundamental property of binary floating point - not every decimal value can be represented exactly. You just need to learn to live with it, or as suggested use something other than a <code>float</code> to store those values.</span>
<span class="comment-copy">FYI your "vice versa" assertion is wrong. Every base 2 number has a finite representation in base 10, although the number of digits required may be surprisingly large - it is equal to the number of bits.</span>
