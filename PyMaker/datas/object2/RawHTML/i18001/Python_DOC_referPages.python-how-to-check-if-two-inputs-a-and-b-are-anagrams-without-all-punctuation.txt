<div class="post-text" itemprop="text">
<p>The first part of the question is to check if input A and input B are anagrams, which I can do easily enough.</p>
<pre><code>s = input ("Word 1?")
b = sorted(s)
c = ''.join(b)
t = input("Word 2?")
a = sorted(t)
d = ''.join(b)
if d == c:
    print("Anagram!")
else:
    print("Not Anagram!")
</code></pre>
<p>The problem is the second part of the question - I need to check if two words are anagrams if all of the punctuation is removed, the upper case letters turned to lower case, but the question assumes no spaces are used. So, for example, (ACdB;,.Eo,."kl) and (oadcbE,LK) are anagrams. The question also asks for loops to be used. </p>
<pre><code>s = input ("Word 1?")
s = s.lower()
for i in range (0, len(s)):
    if ord(s[i]) &lt; 97 or ord(s[i]) &gt;122:
        s = s.replace(s[i],  '')
b = sorted(s)
c = ''.join(b)
print(c)
</code></pre>
<p>Currently, the above code is saying the string index is out of range.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the loop you need to add, in psuedocode:</p>
<pre><code>s = input ("Word 1?")
s_letters = ''
for letter in s:
    if it's punctuation: skip it
    else if it's uppercase: add the lowercase version to s_letters
    else: add it to s_letters
b = sorted(s_letters)
</code></pre>
<p>Except of course that you need to add the same thing for <code>t</code> as well. If you've learned about functions, you will want to write this as a function, and call it twice, instead of copying and pasting it with minor changes.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are three big problems with your loop. You need to solve all three of these, not just one.</p>
<hr/>
<p>First, <code>s = s.replace(s[i], '')</code> doesn't replace the <code>i</code>th character with a space, it replaces the <code>i</code>th character <em>and every other copy of the same character</em> with a space. That's going to screw up the rest of your loop if there are any duplicates. It's also very slow, because you have to search the entire string over and over again.</p>
<p>The right way to replace the character at a specific index is to use slicing: <code>s = s[:i] + s[i+1:]</code>. </p>
<p>Or, you could make this a lot simpler by turning the string into a list of characters (<code>s = list(s)</code>), you can mutate it in-place (<code>del s[i]</code>).</p>
<hr/>
<p>Next, we're going through the loop 6 times, checking <code>s[0]</code>, <code>s[1]</code>, <code>s[2]</code>, <code>s[3]</code>, <code>s[4]</code>, and <code>s[5]</code>. But somewhere along the way, we're going to remove some of the characters (ideally three of them). So some of those indices will be past the end of the string, which will raise an <code>IndexError</code>. I won't explain how to fix this yet, because it ties directly into the next problem.</p>
<hr/>
<p>Modifying a sequence while you loop over it always breaks your loop.* Imagine starting with <code>s = '123abc'</code>. Let's step through the loop.</p>
<ul>
<li><code>i = 0</code>, so you check <code>s[0]</code>, which is <code>1</code>, so you remove it, leaving <code>s = '23abc'</code>.</li>
<li><code>i = 1</code>, so you check <code>s[1]</code>, which is <code>3</code>, so you remove it, leaving <code>s = '2abc'</code>.</li>
<li><code>i = 2</code>, so you check <code>s[2]</code>, which is <code>b</code>, so you leave it, leaving <code>s = '2abc'</code>.</li>
<li>And so on.</li>
</ul>
<p>The <code>2</code> got moved to <code>s[0]</code> by removing the <code>1</code>. But you're never going to come back to <code>i = 0</code> once you've passed it. So, you're never going to check the <code>2</code>. You can solve this in a few different ways—iterating backward, doing a <code>while</code> instead of an <code>if</code> each time through the <code>for</code>, etc.—but most of those solutions will just exacerbate the previous problem.</p>
<p>The easy way to solve both problems is to just not modify the string while you loop over it. You could do this by, e.g., building up a list of indexes to remove as you go along, then applying that in reverse order.</p>
<p>But a much easier way to do it is to just build up the characters you want to keep as you go along. And that also solves the first problem for your automatically.</p>
<p>So:</p>
<pre><code>new_s = []
for i in range (0, len(s)):
    if ord(s[i]) &lt; 97 or ord(s[i]) &gt;122:
        pass
    else:
        new_s.append(s[i])
b = sorted(new_s)    
</code></pre>
<p>And with that relative minor change, your code works.</p>
<hr/>
<p>While we're at it, there are a few ways you're overcomplicating things.</p>
<p>First, you don't need to do <code>ord(s[i]) &lt; 97</code>; you can just do <code>s[i] &lt; 'a'</code>. This makes things a lot more readable.</p>
<p>But, even more simply, you can just use the <a href="http://docs.python.org/3/library/stdtypes.html#str.isalpha" rel="nofollow"><code>isalpha</code></a> or <a href="http://docs.python.org/3/library/stdtypes.html#str.islower" rel="nofollow"><code>islower</code></a> method. (Since you've already converted to <code>lower</code>, and you're only dealing with one character at a time, it doesn't really matter which.) Besides being more readable, and harder to get wrong, this has the advantage of working with non-ASCII characters, like <code>é</code>.</p>
<p>Finally, you almost never want to write a loop like this:</p>
<pre><code>for i in range(len(s)):
</code></pre>
<p>That forces you to write <code>s[i]</code> all over the place, when you could have just looped over <code>s</code> in the first place:</p>
<pre><code>for ch in s:
</code></pre>
<hr/>
<p>So, putting it all together, here's your code, with the two simple fixes, and the cleanup:</p>
<pre><code>s = input ("Word 1?")
s = s.lower()
new_s = []
for ch in s:
    if ch.isalpha():
        new_s.append(ch)
b = sorted(new_s)
c = ''.join(b)
print(c)
</code></pre>
<hr/>
<p>If you know about comprehensions or higher-order functions, you'll recognize this pattern as exactly what a list comprehension does. So, you can turn the whole 4 lines of code that build <code>new_s</code> into either of these one-liners, which are more readable as well as being shorter:</p>
<pre><code>new_s = (ch for ch in s if ch.isalpha)

new_s = filter(str.isalpha, s)
</code></pre>
<p>And in fact, the whole thing can become a one-liner:</p>
<pre><code>b = sorted(ch for ch in s.lower() if ch.isalpha)
</code></pre>
<p>But your teacher asked you to use a <code>for</code> statement, so you'd better keep it as a <code>for</code> statement.</p>
<hr/>
<p>* This isn't quite true. If you only modify the part of the sequence <em>after</em> the current index, and you make sure the sequence aways has the right length by the time you get to each index even though it may have had a different length before you did (using a <code>while</code> loop instead of a <code>for</code> loop, to reevaluate <code>len(seq)</code> each time, makes this part trivial instead of hard), then it works. But it's easier to just never do it to than learn the rules and carefully analyze your code to see if you're getting away with it this time.</p>
</div>
<span class="comment-copy">I'd use a regular expression to strip those chars and then do the normal anagram check.</span>
<span class="comment-copy">Why not share the question too? Is it a homework?</span>
<span class="comment-copy">How's the attempt at the loop that the question asks for going?</span>
<span class="comment-copy">Not going well, I'm trying to use a for loop to loop through i for each letter of the string, checking for punctuation, etc. And yes Sweeney, this is homework :D</span>
<span class="comment-copy">@alex: Then you'd fail the assignment, because it asks you to use loops. (I'd fail it too, because I would have written the whole thing with either a generator expression or a regexp before finishing the question…)</span>
<span class="comment-copy">A hint about how to check if it is a punctuation: there is a string method: <code>"mystring".isalpha()</code> (returns True if all characters in string are alphabetic)</span>
<span class="comment-copy">@SweeneyTodd: Good hint. If the OP is really clever, that may even lead him to figure out how to handle uppercase, lowercase, and everything else with just an if/else instead of an if/elif/else.</span>
<span class="comment-copy">It might be too advanced for the OP, but I would use this: <code>sorted(filter(lambda x: x in string.ascii_lowercase, word.lower()))</code></span>
<span class="comment-copy">@Matthias: Why <code>lambda x: x in string.ascii_lowercase</code> instead of just <code>str.islower</code>? Why use <code>filter</code> instead of a genexpr if you have to wrap the expression in a <code>lambda</code>? Also, the OP specifically asked not to give him a complete answer, just enough to get him started. And, most importantly, the question says that it has to use a <code>for</code> loop, so an answer that doesn't use a <code>for</code> loop is not a valid answer.</span>
<span class="comment-copy">@abarnert: Looking back at all the code I've written yesterday it seems I was in filter-and-lambda-mode. At least I didn't put it as an answer. The for-loop could have been used on the input of course. :-)</span>
