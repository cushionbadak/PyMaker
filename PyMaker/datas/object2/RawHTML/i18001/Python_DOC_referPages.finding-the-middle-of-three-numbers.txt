<div class="post-text" itemprop="text">
<p>I'm looking for alternative or more concise ways to return the middle of three unique values. What I have right now is a function:</p>
<pre><code>def middle(x, y, z):
    if x &gt; y and x &lt; z:
        return x
    if y &gt; x and y &lt; z:
        return y
    return z
</code></pre>
<p>Anything better?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def middle(x, y, z):
    return sorted([x, y, z])[1]
</code></pre>
<p>This should return the middle number. But if you actually meant maximum number</p>
<pre><code>def maximum(x, y, z):
    return max([x, y, z])
</code></pre>
<p><strong>Edit:</strong> As suggested by abarnert in the comments section, instead of <code>y&gt;x and x&lt;z</code> use <code>x &lt; y &lt; z</code>, which is more readable and pythonic.</p>
</div>
<div class="post-text" itemprop="text">
<p>With Python 3.4, <a href="http://docs.python.org/3.4/library/statistics.html#statistics.median" rel="nofollow"><code>statistics.median</code></a> is in the standard library:</p>
<pre><code>import statistics

def middle(x, y, z):
    return statistics.median((x, y, z))
</code></pre>
<p>With 3.1-3.3, after you <a href="https://pypi.python.org/pypi/stats/" rel="nofollow"><code>pip install stats</code></a>:</p>
<pre><code>import stats

def middle(x, y, z):
    return stats.median((x, y, z))
</code></pre>
<p>I believe a backport for 2.6-2.7 is in the works, but does not yet exist. (For 2.5 or 3.0, just upgrade already.)</p>
<p>Of course if you had 4 values, you'd have to decide what "middle" means; <code>median</code> would use the mean of the two middle values, but you might want something different.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def middle(x, y, z):
    return x + y + z - max(x, y, z) - min(x, y, z)
</code></pre>
<p>Just for the fun of it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun… </p>
<p>We don't really need to sort all three values; we just need to keep track of the 2 largest as we go through the whole list, right?</p>
<p>In general, this can be useful, so the standard library has a way to do exactly that: the <a href="http://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow"><code>heapq.nlargest</code></a> function.</p>
<pre><code>def middle(x, y, z):
    return heapq.nlargest(2, (x, y, z))[-1]
</code></pre>
<p>In practice, a heap is much slower than sorting a list, so unless the list is pretty big (3 is nowhere near big enough) and the number of elements you need to remember pretty small (2/3rds is nowhere near small enough), this will actually slow you down a lot. As a quick test will show:</p>
<pre><code>In [66]: %timeit heapq.nlargest(2, [1,2,3])[1]
100000 loops, best of 3: 2.78 us per loop

In [67]: %timeit sorted([1,2,3])[1]
1000000 loops, best of 3: 770 ns per loop
</code></pre>
<p>So, don't use this here, but keep it in your toolbox for the next time you need the 10 top scores out of 500000.</p>
</div>
<div class="post-text" itemprop="text">
<p>for fun:</p>
<pre><code>def middle(x, y, z):
    if x &lt; y:
        if y &lt; z:
            return y
        elif x &lt; z:
            return z
        else:
            return x
    else:
        if x &lt; z:
            return x
        elif y &gt; z:
            return y
        else:
            return z
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also make some kind of a median function which works not only for 3 values</p>
<pre><code>def median(list): 
    list = sorted(list) 
    if len(list) % 2 == 0: 
        n = len(list)//2 
        return (list[n]+list[n-1])/2 
    else: 
        return list[len(l)//2] 
</code></pre>
</div>
<span class="comment-copy"><code>return sorted((x,y,z))[1]</code></span>
<span class="comment-copy">Your attempt actually returns the <i>highest</i> of the three. If you need to write code like this, consider the "between" forms that Python lets you write: <code>if y &lt; x &lt; z:</code>. It's much easier to read, and harder to get wrong. (In this case, there's an even <i>easier</i> answer, so I've just left this as a comment rather than an answer.)</span>
<span class="comment-copy">Sorry, I'm an idiot-edited.</span>
<span class="comment-copy">@jmu303: We're all idiots when it comes to things like that, which is exactly why <code>x &lt; y &lt; z</code> is better than <code>y&gt;x and x&lt;z</code>—even an idiot like me or you won't get it wrong.</span>
<span class="comment-copy">@abarnert Thanks. I added this suggestion in my answer.</span>
<span class="comment-copy">Clever. But try <code>middle(1, 2, 1e200)</code>. :)</span>
<span class="comment-copy">Why write a median function when there's one already in the stdlib (3.4) or available on PyPI (earlier)?</span>
