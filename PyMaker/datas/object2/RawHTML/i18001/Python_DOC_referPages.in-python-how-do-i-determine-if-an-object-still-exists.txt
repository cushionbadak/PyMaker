<div class="post-text" itemprop="text">
<p>How do I determine if an object that has been created earlier in my Python program still exists? By exists, I mean, is still reachable through some other object for which I still hold a reference.</p>
<p>Background:</p>
<p>I'm trying to use a parser which may be buggy. The parser returns an object with members that have recursive references. The object can't be pickled or dumped with any of the debug dump commands I've found online. When I step through the parser, I can see an object that I will need to access later get created. But it looks to me as if the object does not end up actually getting referenced in the object that is returned from the parser. I would like to determine if the object that I saw getting created in the debugger is available somewhere in the object that the parser returned.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/library/gc.html" rel="noreferrer"><code>gc</code></a> module is the way to debug this kind of information. For example:</p>
<pre><code>import gc

a = [1, 2, 3]
b = [a, a]
gc.collect()
refs = gc.get_referrers(a)
</code></pre>
<p>We know the <code>a</code> variable itself refers to the object. Or, more accurately, the globals of the <code>__main__</code> module have refer to that object, under the value associated with the key <code>a</code>. But are there any other refs?</p>
<pre><code>print(len(refs))
print(refs)
</code></pre>
<p>This prints <code>2</code>. And then, in addition to printing the module's globals, it also prints out <code>[[1, 2, 3], [1, 2, 3]]</code>, the value of <code>b</code>.</p>
<p>So, if you know how many references to the object will exist beside the one you're looking for (much trickier in real life than in a trivial example), or you have some way of identifying the value that you're trying to check, <code>gc.get_referrers</code> can do what you want. If you <em>don't</em> know either of those, there's really know way to figure it out short of by picking through the whole referrers list and trying to figure it out, which gets very hard.</p>
<hr/>
<p>An alternative way to do this, of course, is to provide a function that walks your data structures and searches for the value you were looking for. This can be difficult or even impossible for some structures, but if you <em>can</em> do it, it's often worth doing for all kinds of debugging reasons, not just this one.</p>
<hr/>
<p>Or, of course, if you can add a <code>__del__</code> method to your object, you can prove that it no longer exists (by logging a call to its <code>__del__</code>), but that doesn't help prove that it <em>does</em> exist (it may have no live referents, but not have been collected yet… in fact, just adding a <code>__del__</code> may <em>prevent</em> it from being collected, if it's in a cycle).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is in no way a solution you should use in any sort of a production setting, (largely because it typically ends up throwing a segfault) but for debugging purposes you can use the following snippet of code to access a variable by its id to determine if it still exists.
(Snippet from <a href="https://stackoverflow.com/questions/1396668/python-get-object-by-id">here</a>)</p>
<pre><code>&gt;&gt;&gt; import ctypes, gc
&gt;&gt;&gt; a = "hello world"
&gt;&gt;&gt; id(a)
7696579801024
&gt;&gt;&gt; len(gc.get_referrers(a))
1
&gt;&gt;&gt; li = [a]
&gt;&gt;&gt; len(gc.get_referrers(a))
2
&gt;&gt;&gt; del a
&gt;&gt;&gt; print ctypes.cast(7696579801024, ctypes.py_object).value
hello world
&gt;&gt;&gt; len(gc.get_referrers(ctypes.cast(7696579801024, ctypes.py_object).value))
1
&gt;&gt;&gt; del li
&gt;&gt;&gt; print ctypes.cast(7696579801024, ctypes.py_object).value
Segmentation fault (core dumped)
</code></pre>
<p>Essentially, ctypes inability to return the object after it's last referrer was deleted implies that it no longer exists.</p>
<p><strong>I stress again</strong> though, this is in no way a sure-fire testing method nor suitable for a production setting.  Aside from the segfaults, ctypes could also return some other object (constructed using the garbage that is left in its place).  It is also feasible that it could return the same object <strong>even after</strong>
its garbage collection if the bytes in its memory location haven't changed.  I haven't witnessed this myself, but I don't see why it wouldn't be possible.</p>
</div>
<span class="comment-copy">Have you considered creating a weakref?</span>
<span class="comment-copy">@IgnacioVazquez-Abrams: I think the issue is that his code doesn't create the object at all. The parser creates it and stores it (or creates it and then loses it, which is what he's trying to debug) before ever returning control to him. But that's definitely a good suggestion he should have in his toolbox, even if it doesn't help here.</span>
<span class="comment-copy">Relevant: <a href="https://stackoverflow.com/questions/8179320/python-logging-the-garbage-collector" title="python logging the garbage collector">stackoverflow.com/questions/8179320/…</a></span>
<span class="comment-copy">Thank you. It looks promising to use the <code>gc</code> module, but i'm not sure if <code>get_referrers()</code> is ideal because, at the point where I would call it, after the parser has returned, the first reference to the object (<code>a</code> in your example) is gone. The value I'm looking for is unique, so it looks like I might be able to grep through a list made with <code>gc.get_objects()</code>.</span>
<span class="comment-copy">@RogerDahl: If you can see that the object you need gets created, can't you store it somewhere, so you can look for it? Anyway, it sounds like you may have an answer anyway.</span>
