<div class="post-text" itemprop="text">
<p>I'm trying to perform checks on the first and last elements of an interator. It has several thousand entries, so I need an expeditious method of checking. If found <a href="https://stackoverflow.com/questions/2138873/cleanest-way-to-get-last-item-from-python-iterator">this post</a>, that put me onto this strategy.</p>
<pre><code>first = True
for value in iterator:
   if first:
      do_stuff_to_first_iter
      first = False
   else:
      pass
do_stuff_to_last_iter
</code></pre>
<p>Anyone have any opinions on a quicker method of accomplishing this? Thanks a lot!</p>
</div>
<div class="post-text" itemprop="text">
<p>Get the first value with the <a href="http://docs.python.org/2/library/functions.html#next" rel="noreferrer"><code>next()</code> function</a>:</p>
<pre><code>first = last = next(iterable, defaultvalue)
for last in iterable:
    pass
</code></pre>
<p>This assumes the iterable is finite.</p>
<p>For an empty iterable, <code>first</code> and <code>last</code> are set to <code>defaultvalue</code>. For an iterable with just one element, <code>first</code> and <code>last</code> will both refer to that one element. For any other finite iterable, <code>first</code> will have the first element, <code>last</code> the very last.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on my answer to the linked question:</p>
<p>Probably worth using <code>__reversed__</code> if it is available. If you are providing the iterator, and there is a sensible way to implement <code>__reversed__</code> (ie without iterating from end to end) you should do it</p>
<pre><code>first = last = next(my_iter)
if hasattr(my_iter,'__reversed__'):
    last = next(reversed(my_iter))
else:
    for last in my_iter:
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a deque with a maxlen of 1 to quickly get the last element of a finite iterator:</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; last_getter = deque(maxlen=1)
&gt;&gt;&gt; seq = range(10000)
&gt;&gt;&gt; iseq = iter(seq)
&gt;&gt;&gt;
&gt;&gt;&gt; first = last = next(iseq, None)
&gt;&gt;&gt; last_getter.extend(iseq)
&gt;&gt;&gt; if last_getter: last = last_getter[0]
...
&gt;&gt;&gt; print (first, last)
0 9999
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to my tests, <a href="http://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow">islice</a> is up to 3 times faster than <code>for: pass</code> or <code>deque</code>. This would require you to know how many items there will be, though.</p>
<pre><code>last = next(islice(iterable, length - 1, length))
</code></pre>
<p>Or if you don't know the full length, but do know that it must be <em>at least</em> <code>n</code>, you could still "skip" to <code>n</code> as a shortcut:</p>
<pre><code>rest = islice(iterable, n, None)
last = next(rest)
for last in rest:
    pass
</code></pre>
</div>
<span class="comment-copy">Why should an arbitrary iterator have a last element?</span>
<span class="comment-copy">Your sample code is not valid python; could you at least use <code>for item in iterable:</code> or similar Python syntax?</span>
<span class="comment-copy">Note that <code>else: pass</code> is <i>entirely</i> redundant and can be dropped altogether. In Python, you don't <i>have</i> to have an <code>else</code> clause with the <code>if</code> statement.</span>
<span class="comment-copy">The <code>else: pass</code> was to exit the <code>for</code> loop. I suppose it's not needed. Thanks.</span>
<span class="comment-copy">Hello Martijn, thanks for the answer. This technique is very pythonic and (now that I've worked out all the bugs) seems to work very well. It still takes about 4-minute to loop through my iterator, but it's better than what I had before. Thanks again.</span>
<span class="comment-copy">OK, so I timed this against Paul's <code>deque</code> method. This method took my process 264 seconds. The <code>deque</code> method took 275 seconds. Within the noise so to speak. But I'm going to use this guy! Thanks.</span>
<span class="comment-copy"><code>__reversed__</code> is commonly only found on objects that are not themselves iterators. E.g. <code>list</code> provides it, but not <code>iter(list)</code>.</span>
<span class="comment-copy">In the standard library, only <code>list()</code>, <code>range()</code>, <code>collections.deque()</code>, and <code>collections.OrderedDict()</code> provide a <code>__reversed__</code>, and none are themselves iterators. That means you <b>cannot</b> call <code>next()</code> on them.</span>
<span class="comment-copy">I like the option of reversing the iterator and avoiding unnecessary loops. Unfortunately, my iterator does not have a <code>__reversed__</code> attribute and I'm left entering the loop anyway. Thanks for the suggestion!</span>
<span class="comment-copy">So I tried this method and timed it for my process.  Took 275 seconds. The "loop n' pass" technique took 264 seconds. Either way, both are comparable. Thanks for suggesting! This is an interesting technique I didn't know existed.</span>
