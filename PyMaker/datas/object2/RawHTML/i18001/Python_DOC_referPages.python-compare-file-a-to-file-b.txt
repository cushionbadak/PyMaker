<div class="post-text" itemprop="text">
<p>I'm new to python. I want to create a script that will compare two file and output will contain text that matches.</p>
<p>I want to compare file 1 to file 2. Both files contains email addresses on each line. </p>
</div>
<div class="post-text" itemprop="text">
<p>The key to problems like this is to not think about "files", but about the data. What is a file? It's just an iterable of lines. So you're just asking how to find all values from one iterable that are also in another iterable. That's easy.</p>
<pre><code>with open('file1') as f1, open('file2') as f2:
    matches = set(f1).intersection(f2)
</code></pre>
<p>The <code>set</code> constructor takes any iterable—like a file—and makes a set out of it.</p>
<p>The <code>intersection</code> method takes any iterable—like a file—and gives you all elements that are in both the <code>self</code> set and that iterable. So, in this case, it's all elements that are in both the set of all lines of file1, and the iterable of all lines of file2.</p>
<hr/>
<p>Here's an example to show it working:</p>
<p>file1:</p>
<pre><code>johndoe@example.com
marysmith@example.com
rowdyroddypiper@example.com
</code></pre>
<p>file2:</p>
<pre><code>janesmith@example.com
rowdyroddypiper@example.com
jackjohnson@example.com
marysmith@example.com
</code></pre>
<p>code:</p>
<pre><code>&gt;&gt;&gt; with open('file1') as f1, open('file2') as f2:
...     matches = set(f1).intersection(f2)
&gt;&gt;&gt; matches
{'marysmith@example.com\n', 'rowdyroddypiper@example.com\n'}
</code></pre>
<hr/>
<p>This does of course require reading the entirety of <code>file1</code> into memory. If that's not possible, the most efficient alternative is probably to do an offline sort of both files, and then iterate them both.</p>
<p>But a simpler solution would be to use a <code>dbm</code> (with meaningless values) as an on-disk set. <a href="http://pastebin.com/dWXXyk5S" rel="nofollow">Here's an implementation</a> I slapped together. It requires Python 3.3+, likely has problems on Windows, only handles <code>str</code> elements, and only supports the minimal API of <a href="http://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSet" rel="nofollow"><code>collections.abc.MutableSet</code></a> plus <code>intersection</code>; if you need older versions, portability, different key types, better error handling, etc., it may take more than 3 minutes. Anyway:</p>
<pre><code>&gt;&gt;&gt; import dset
&gt;&gt;&gt; with open('file1') as f1, open('file2') as f2:
...     matches = dset.DiskSet(f1).intersection(f2)
</code></pre>
<p>Any on-disk solution will obviously be significantly slower for mid-sized files, but when you get to giant files that either wouldn't fit in memory or, worse, would fit but only by throwing your whole computer into swap hell, it obviously wins.</p>
</div>
<div class="post-text" itemprop="text">
<p>To find the difference:</p>
<pre><code>&gt;&gt;&gt; from difflib import ndiff
&gt;&gt;&gt; diff = ndiff(file('1').readlines(),file('2').readlines())
&gt;&gt;&gt; print ''.join(diff),
</code></pre>
<p>To show inverted difference just add <code>if</code>:</p>
<pre><code>$ cat /tmp/1 
hello@world.net
goodbye@cruelworld.com
$ cat /tmp/2
hello@world.net
goodbye@cruelworld.com
hello-once-again@example.com

$ python
&gt;&gt;&gt; diff = ndiff(file('/tmp/1').readlines(),file('/tmp/2').readlines())
&gt;&gt;&gt; print ''.join([x for x in diff if x[0] not in '-+']),
  hello@world.net
  goodbye@cruelworld.com
</code></pre>
</div>
<span class="comment-copy">Then try it first.</span>
<span class="comment-copy">can't you use beyond compare ?</span>
<span class="comment-copy">Please post code samples of what you've already tried.</span>
<span class="comment-copy">I totally agree with Tom Swifty. Asking to solve a problem for you is not the idea behind stackoverflow.</span>
<span class="comment-copy">@AnotherTest: No, a file is an iterable of <i>lines</i>, not of <i>characters</i>.</span>
<span class="comment-copy">yep, that's how I'd do it if the files are not too big.</span>
<span class="comment-copy">@cmd: It's how I'd do it if the files <i>are</i> too big, too, just using a disk-based <code>set</code>. An on-disk sort is a lot harder than an on-disk set (although you can punt to <code>subprocess.call(['sort', stdin=file1, stdout=tmpfile]</code> on *nix), and parallel iteration is a lot more complicated than set intersection, and I'm not even sure it would be significantly more efficient when you finally get it working, or that the performance is a problem in the first place.</span>
<span class="comment-copy">That shows the lines that <i>differ</i>, not the ones that <i>match</i>.</span>
<span class="comment-copy">@abanert: Thank you for the good tip! Fixed! Thank you!</span>
<span class="comment-copy">This gives you the <code>'?'</code>-prefixed guide lines as well as the <code>' '</code>-prefixed common lines. Also, this only finds matches that are in the same position in both files, which I doubt is what he's trying to do.</span>
