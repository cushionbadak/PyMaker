<div class="post-text" itemprop="text">
<p>Ok so I've been using python to try create a waveform image and I'm getting the raw data from the <code>.wav</code> file using <code>song = wave.open()</code> and <code>song.readframes(1)</code>, which returns :</p>
<pre><code>b'\x00\x00\x00\x00\x00\x00'
</code></pre>
<p>What I want to know is how I split this into three separate bytes, e.g. <code>b'\x00\x00'</code>,  <code>b'\x00\x00'</code>, <code>b'\x00\x00'</code> because each frame is 3 bytes wide so I need the value of each individual byte to be able to make a wave form. I believe that's how I need to do it anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use slicing on <code>byte</code> objects:</p>
<pre><code>&gt;&gt;&gt; value = b'\x00\x01\x00\x02\x00\x03'
&gt;&gt;&gt; value[:2]
b'\x00\x01'
&gt;&gt;&gt; value[2:4]
b'\x00\x02'
&gt;&gt;&gt; value[-2:]
b'\x00\x03'
</code></pre>
<p>When handling these frames, however, you probably also want to know about <a href="http://docs.python.org/3/library/stdtypes.html#memoryview"><code>memoryview()</code> objects</a>; these let you interpret the bytes as C datatypes without any extra work on your part, simply by casting a 'view' on the underlying bytes:</p>
<pre><code>&gt;&gt;&gt; mv = memoryview(value).cast('H')
&gt;&gt;&gt; mv[0], mv[1], mv[2]
256, 512, 768
</code></pre>
<p>The <code>mv</code> object is now a memory view interpreting every 2 bytes as an unsigned short; so it now has length 3 and each index is an integer value, based on the underlying bytes. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a way that you can split the bytes into a list: </p>
<pre><code>data = b'\x00\x00\x00\x00\x00\x00'
info = [data[i:i+2] for i in range(0, len(data), 2)]
print info
</code></pre>
<p>gives the result:</p>
<pre><code>['\x00\x00', '\x00\x00', '\x00\x00']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are actually asking about serialization/deserialization.  Use struct.pack and struct.unpack (<a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">https://docs.python.org/3/library/struct.html</a>).  This gives you nice primitives to do both unpacking and things like endian swapping.  For example:</p>
<pre><code>import struct
struct.unpack("&lt;H",b"\x00\x01") # unpacks 2 byte little endian unsigned int
struct.unpack("&gt;l",b"\x00\x01\x02\x03") # unpacks 4 byte big endian signed int
</code></pre>
<p>Note that your example splits 2 byte words, not bytes.</p>
<p>Since this question is also coming up in searches about splitting binary strings:</p>
<pre><code>value = b'\x00\x01\x00\x02\x00\x03'
split = [value[i] for i in range (0, len(value))]
# now you can modify, for example:
split[1] = 5
# put it back together
joined = bytes(split)
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/2063565/what-is-returned-by-wave-readframes">What is returned by wave.readframes?</a></span>
<span class="comment-copy">This lookst like the cleanest solution, as it does the work with as less copying and counting as possible. Using <code>struct.iter_unpack</code> you can even loop over large blocks of repeating structures.</span>
