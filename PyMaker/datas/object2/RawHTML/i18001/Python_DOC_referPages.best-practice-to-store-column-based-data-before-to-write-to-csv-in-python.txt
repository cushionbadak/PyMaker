<div class="post-text" itemprop="text">
<p>I have the current code in Python 3:</p>
<pre><code>import csv

if __name__ == '__main__':
    sp500_data = [
        {
            'company': 'GOOGLE',
            'headquarters': 'GOOGLEPLEX',
            'industry': 'ADS',
            'sector': 'TECH',
            'symbol': 'GOOG'
        },
        {
            'company': 'HEWLPA',
            'headquarters': 'WHATEVER',
            'industry': 'HARDWARE',
            'sector': 'TECH',
            'symbol': 'HP'
        }
    ]

    myfile = open("D:/test.csv", 'w', newline='')
    wr = csv.DictWriter(myfile, delimiter='\t', quoting=csv.QUOTE_ALL, fieldnames=sp500_data[0].keys)
    for sp500_company in sp500_data:
        wr.writerow(sp500_company)
</code></pre>
<p>However this gives the following error:</p>
<pre><code>Traceback (most recent call last):
  File "D:\DEV\BlueTS\src\tsRetriever\dataRetriever\test.py", line 24, in &lt;module&gt;
    wr.writerow(sp500_company)
  File "C:\Python33\lib\csv.py", line 153, in writerow
    return self.writer.writerow(self._dict_to_list(rowdict))
  File "C:\Python33\lib\csv.py", line 146, in _dict_to_list
    wrong_fields = [k for k in rowdict if k not in self.fieldnames]
  File "C:\Python33\lib\csv.py", line 146, in &lt;listcomp&gt;
    wrong_fields = [k for k in rowdict if k not in self.fieldnames]
TypeError: argument of type 'builtin_function_or_method' is not iterable
</code></pre>
<p>I would like to understand what I am doing wrong, and in addition to this, I would like to know what is the best way in Python to store column-based data which was originally organised in tables.</p>
</div>
<div class="post-text" itemprop="text">
<p>You forgot to <em>call</em> the <code>.keys()</code> method:</p>
<pre><code>wr = csv.DictWriter(myfile, delimiter='\t', quoting=csv.QUOTE_ALL,
                    fieldnames=sp500_data[0].keys())
</code></pre>
<p>Note the <code>()</code> after <code>sp500_data[0].keys</code>; <code>.keys</code> is not an attribute, it is a method.</p>
<p>Using a <code>csv.DictWriter()</code> is an excellent method to turn data already in dictionary format into CSV data.</p>
</div>
<span class="comment-copy">Try to change this <code>sp500_data[0].keys</code> to this <code>sp500_data[0].keys()</code>. Not sure with Python 3, but with Python 2 <code>keys</code> is a method which returns a list, so you need to call it with <code>()</code>.</span>
<span class="comment-copy">If you're dealing with tabular data, esp. financial data, check out <a href="http://pandas.pydata.org" rel="nofollow noreferrer">pandas</a>.  The <code>DataFrame</code> is a better storage object for multidimensional data than anything Python offers natively.</span>
<span class="comment-copy">if you look at the file produced, it seems to give a strange result: the first row does not contain the header and the following rows contain the headers as well.</span>
<span class="comment-copy">use <a href="http://docs.python.org/3/library/csv.html#csv.DictWriter.writeheader" rel="nofollow noreferrer"><code>wr.writeheader()</code></a> to write a header to the file. The sample code you gave, once fixed, won't write keys, just values.</span>
<span class="comment-copy">Effectively it removed they keys, however instead of having <code>MMM</code> it prints <code>b'MMM'</code>, do you happen to know why ?</span>
<span class="comment-copy">That is byte data, not unicode text. Decode bytes values to unicode first.</span>
<span class="comment-copy">You can use a dict comprehension:  <code>{key: value.decode('utf8') for key, value in row.items()}</code>, where <code>row</code> is the dictionary to decode.</span>
