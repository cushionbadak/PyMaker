<div class="post-text" itemprop="text">
<p>I am implementing the parallel DC3, pDC3 algorithm from this paper: <a href="http://algo2.iti.kit.edu/sanders/papers/KulSan06a.pdf" rel="nofollow">http://algo2.iti.kit.edu/sanders/papers/KulSan06a.pdf</a>.</p>
<p>See line 12:</p>
<pre><code>"""
Sort S0 U S1 U S2 using the comparison function:
    (c, ...) in S1 U S2 &lt;= (d, ...) in S1 U S2 &lt;=&gt; c &lt;= d
    (t, t', c', c'', i) in S0 &lt;= (u, u', d', d'', j) in S0 &lt;=&gt; (t, c') &lt;= (u, d')
    (t, t', c', c'', i) in S0 &lt;= (d, u,      d', j) in S1 &lt;=&gt; (t, c') &lt;= (u, d')
    (t, t', c', c'', i) in S0 &lt;= (d, u, u', d'', j) in S2 &lt;=&gt; (t, t', c'') &lt;= (u, u', d'')
"""
</code></pre>
<p>How will I be implementing such a comparison in Python?</p>
<p>Sorry I haven't given the complete picture here. But let me go back a few steps and show what S0-S2 look like in my implementation:</p>
<p>The last few lines of my code where I compute S0-S2:</p>
<pre><code>s0 = computeS0(indexSortedRankIndexPairs, text, paddedText)
print 'Set0:                          ' + str(s0)

s1 = computeS1(indexSortedRankIndexPairs, text, paddedText)
print 'Set1:                          ' + str(s1)

s2 = computeS2(indexSortedRankIndexPairs, text, paddedText)
print 'Set2:                          ' + str(s2)
</code></pre>
<p>This is the sample output from my program:</p>
<pre><code>Text                           yabbadabbado
Padded Text                    yabbadabbado00
Trituples:                     set([('ada', 4), ('bba', 7), ('abb', 1), ('o00', 11), ('do0', 10), ('bad', 8), ('bba', 2), ('dab', 5)])
Sorted Trituples:              [('abb', 1), ('ada', 4), ('bad', 8), ('bba', 7), ('bba', 2), ('dab', 5), ('do0', 10), ('o00', 11)]
Rank Index Pairs:              [(1, 1), (2, 4), (3, 8), (4, 7), (4, 2), (5, 5), (6, 10), (7, 11)]
Sorted Rank Index Pairs:       [(1, 1), (2, 4), (4, 7), (6, 10), (4, 2), (5, 5), (3, 8), (7, 11)]
Index Sorted Rank Index Pairs: [(1, 1), (4, 2), (2, 4), (5, 5), (4, 7), (3, 8), (6, 10), (7, 11)]
Set0:                          set([('a', 'd', 6, 7, 9), ('y', 'a', 1, 4, 0), ('a', 'b', 4, 3, 6), ('b', 'a', 2, 5, 3)])
Set1:                          set([(2, 'a', 5, 4), (1, 'a', 4, 1), (4, 'b', 3, 7), (6, 'd', 7, 10)])
Set2:                          set([(7, 'o', '0', 0, 11), (3, 'b', 'a', 6, 8), (5, 'd', 'a', 4, 5), (4, 'b', 'b', 2, 2)])
</code></pre>
<p>So, S0, S1 and S2 are basically native Python sets (at least for now).</p>
</div>
<div class="post-text" itemprop="text">
<p>I think I can give you some general idea here. </p>
<p>Assuming you are using python 2.x</p>
<p>It will be my approach to the problem:</p>
<pre><code>    Set0 =  set([('a', 'd', 6, 7, 9), ('y', 'a', 1, 4, 0), ('a', 'b', 4, 3, 6), ('b', 'a', 2, 5, 3)])
    Set1 =  set([(2, 'a', 5, 4), (1, 'a', 4, 1), (4, 'b', 3, 7), (6, 'd', 7, 10)])
    Set2 =  set([(7, 'o', '0', 0, 11), (3, 'b', 'a', 6, 8), (5, 'd', 'a', 4, 5), (4, 'b', 'b', 2, 2)])


    def make_s0(s):
        # add an element to the tuple to 'tag' the set
        return [('s0', a, b, c, d, e) for (a, b, c, d, e) in s]

    def make_s1(s):
        return [('s1', a, b, None, d, e) for (a, b, d, e) in s]

    def make_s2(s):
        return [('s2', a, b, c, d, e) for (a, b, c, d, e) in s]

    def cmp_elem(l, r):
        # you need to complete the implementation here
        # based on the first element of the tag to carry out comparsion
        if l[0] == 's0' and r[0] == 's0':
            (_, t, tdash, cdash, cdashdash, i) = l
            (_, u, udash, ddash, ddash, j) = r
            return cmp((t, cdash), (u, ddash))
        elif (l[0] == 's1' and r[0] == 's2') or (l[0] == 's2' and r[0] == 's1'):
            (_, c, _, _, _, _) = l
            (_, d, _, _, _, _) = r
            return cmp(c, d)
        return 0

    if __name__ == "__main__":
        l = make_s0(Set0) + make_s1(Set1) + make_s2(Set2)
        print sorted(l, cmp=cmp_elem)
</code></pre>
<p>Read this <a href="http://docs.python.org/3.3/howto/sorting.html" rel="nofollow">http://docs.python.org/3.3/howto/sorting.html</a> to convert the above code to run in python 3 </p>
</div>
<div class="post-text" itemprop="text">
<p>Rules like this look easy enough to accomodate in a key function</p>
<pre><code>(c, . . .) ∈ S1 ∪ S2 ≤ (d,. . .) ∈ S1 ∪ S2 ⇔ c ≤ d  
(t, t′ , c′ , c′′, i) ∈ S0 ≤ (u, u′ , d′, d′′, j) ∈ S0 ⇔ (t, c′) ≤ (u, d′)
</code></pre>
<p>But I don't see how these ones can be accomodated so easily</p>
<pre><code>(t, t′, c′, c′′, i) ∈ S0 ≤ (d, u,     d′, j) ∈ S1 ⇔ (t,c′) ≤ (u, d′)
(t, t′, c′, c′′, i) ∈ S0 ≤ (d, u, u′, d′′, j) ∈ S2 ⇔ (t,t′, c′′) ≤ (u, u′, d′′)
</code></pre>
<p>You'll probably have to fall back to use a comparison function for the sort</p>
<p>in Python2, you can still use the deprecated <code>cmp=</code> parameter<br/>
in Python3, use <code>functools.cmp_to_key</code> and pass that to the <code>key=</code> parameter</p>
</div>
<span class="comment-copy">First you'll have to show us how you're representing S0, S1, or S2, or we'll have to come up with our own implementation of all of the preceding code, which (a) is more work than anyone wants to do for you, and (b) will force you to translate from someone else's implementation to yours instead of just using it directly.</span>
<span class="comment-copy">Could you please elaborate more on what is what.</span>
<span class="comment-copy">Also, have you read the <a href="http://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">Sorting HOW TO</a>? You realize that Python sort functions take a <code>key</code> function to transform two values, not a comparison function to compare two values? You <i>can</i> write a comparison function, then wrap it in <code>functools.cmp_to_key</code>, but that usually isn't the best solution.</span>
<span class="comment-copy">@abarnert I have updated with details on S0-S1.  @tMJ For that you really have to read the algorithm. I understand that you probably need to spend more time than usual here but I cannot really dig into this. You can look at the algorithm and understand them in an instant. Furthermore, you really need not understand what the c, t and so on are and how they are calculated.  Few basic information: <code>c</code>: rank/name as defined in the algorithm, <code>t[i]</code>: text at position i, <code>i</code>: index.</span>
<span class="comment-copy">Thanks for the help. The result for this algorithm is:  <code>[('s0', 'b', 'a', 2, 5, 3), ('s0', 'y', 'a', 1, 4, 0), ('s0', 'a', 'b', 4, 3, 6), ('s0', 'a', 'd', 6, 7, 9), ('s1', 2, 'a', None, 5, 4), ('s1', 1, 'a', None, 4, 1), ('s1', 4, 'b', None, 3, 7), ('s1', 6, 'd', None, 7, 10), ('s2', 7, 'o', '0', 0, 11), ('s2', 3, 'b', 'a', 6, 8), ('s2', 5, 'd', 'a', 4, 5), ('s2', 4, 'b', 'b', 2, 2)]</code>  which unfortunately includes s0, s1, s2 that are not supposed to be there.</span>
<span class="comment-copy">Of course, you will need to finish the implementation yourself. It will be very easy to remove the first element in a tuple. Just take a look at how I use list comprehension in funcion make_s0/1/2</span>
<span class="comment-copy">The second case needs to handle both coming from S1, and both coming from S2. So just do <code>elif </code>l[0] != 's0' and r[0] != 's0':` there. Also, I think it would be clearer to write them in the order specified, instead of writing the first two cases out of order.</span>
<span class="comment-copy">Also, I think it would be a bit simpler if you attached the source outside the tuple instead of inside: <code>('s0', value) for value in Set0</code>, etc., so you can pull it apart in two trivial steps, instead of pulling it apart into 5 or 6 parts ignoring all but the first values, then doing it again ignoring the first value, and then doing it a third time to transform it back to the originals.</span>
<span class="comment-copy">@abament SO is a Q&amp;A site. Not 'someone please finish my work for free' site. Besides, I have added a comment '# you need to complete the implementation here' to make it very clear OP needs to complete compare function.</span>
<span class="comment-copy">This doesn't really give much guidance on how to write such a <code>cmp</code> function, which is the actual hard part of this problem. Somehow, you have to know whether the values come from S1, S0, or S2. And if there isn't a way to tell that from the in-band information, that means you have to mark them, as in Anthony Kong's answer. Once you solve that, the rest is (relatively) easy, but you have to solve that or you don't have an answer.</span>
<span class="comment-copy">@abarnert, I'm still trying to see if there isn't a trick to make a key function.</span>
<span class="comment-copy">The obvious "right" way to do this with a key function is to return S0, S1, and S2 objects with appropriate <code>__lt__</code> methods that know how to compare against the other types. In which case you really don't need the <code>key</code> function; better to just decorate the objects and leave them decorated. (Especially if the classes inherit from a <code>namedtuple</code>, because then the decoration won't break any possible existing code.)</span>
