<div class="post-text" itemprop="text">
<p>I am displaying new email with <code>IMAP</code>, and everything looks fine, except for one message subject shows as:</p>
<p><code>=?utf-8?Q?Subject?=</code></p>
<p>How can I fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p>In MIME terminology, those encoded chunks are called encoded-words.  You can decode them like this:</p>
<pre><code>import email.Header
text, encoding = email.Header.decode_header('=?utf-8?Q?Subject?=')[0]
</code></pre>
<p>Check out the docs for <a href="http://docs.python.org/library/email.header.html"><code>email.Header</code></a> for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a MIME <a href="https://tools.ietf.org/html/rfc2047#section-2" rel="noreferrer">encoded-word</a>. You can parse it with <a href="https://docs.python.org/dev/library/email.header.html" rel="noreferrer"><code>email.header</code></a>:</p>
<pre><code>import email.header

def decode_mime_words(s):
    return u''.join(
        word.decode(encoding or 'utf8') if isinstance(word, bytes) else word
        for word, encoding in email.header.decode_header(s))

print(decode_mime_words(u'=?utf-8?Q?Subject=c3=a4?=X=?utf-8?Q?=c3=bc?='))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try <a href="https://github.com/martinrusev/imbox" rel="nofollow noreferrer">Imbox</a> </p>
<p>Because <code>imaplib</code> is a very excessive low level library and returns results which are hard to work with</p>
<p><strong>Installation</strong></p>
<p><code>pip install imbox</code></p>
<p><strong>Usage</strong></p>
<pre><code>from imbox import Imbox

with Imbox('imap.gmail.com',
        username='username',
        password='password',
        ssl=True,
        ssl_context=None,
        starttls=False) as imbox:

    all_inbox_messages = imbox.messages()
    for uid, message in all_inbox_messages:
        message.subject
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3+, the parsing classes and functions in <a href="https://docs.python.org/3/library/email.parser.html" rel="nofollow noreferrer">email.parser</a> automatically decode "encoded words" in headers if their <code>policy</code> argument is set to <code>policy.default</code></p>
<pre><code>&gt;&gt;&gt; import email
&gt;&gt;&gt; from email import policy

&gt;&gt;&gt; msg = email.message_from_file(open('message.txt'), policy=policy.default)
&gt;&gt;&gt; msg['from']
'Pepé Le Pew &lt;pepe@example.com&gt;'
</code></pre>
<p>The parsing classes and functions are:</p>
<ul>
<li><a href="https://docs.python.org/3/library/email.parser.html#email.parser.BytesParser" rel="nofollow noreferrer">email.parser.BytesParser</a></li>
<li><a href="https://docs.python.org/3/library/email.parser.html#email.parser.Parser" rel="nofollow noreferrer">email.parser.Parser</a></li>
<li><a href="https://docs.python.org/3/library/email.parser.html#email.message_from_bytes" rel="nofollow noreferrer">email.message_from_bytes</a></li>
<li><a href="https://docs.python.org/3/library/email.parser.html#email.message_from_binary_file" rel="nofollow noreferrer">email.message_from_binary_file</a></li>
<li><a href="https://docs.python.org/3/library/email.parser.html#email.message_from_string" rel="nofollow noreferrer">email.message_from_string</a></li>
<li><a href="https://docs.python.org/3/library/email.parser.html#email.message_from_file" rel="nofollow noreferrer">email.message_from_file</a></li>
</ul>
<p>Confusingly, up to at least Python 3.7, the default policy for these parsing functions is not <code>policy.default</code>, but <code>policy.compat32</code>, which does <em>not</em> decode "encoded words".</p>
<pre><code>&gt;&gt;&gt; msg = email.message_from_file(open('message.txt'))
&gt;&gt;&gt; msg['from']
'=?utf-8?q?Pep=C3=A9?= Le Pew &lt;pepe@example.com&gt;'
</code></pre>
</div>
<span class="comment-copy"><i>"How can I fix it?"</i> - Why do you assume that it is broken?</span>
<span class="comment-copy">It should show just "Subject" - what's inside the =?utf-8?Q? ... ?</span>
<span class="comment-copy"><a href="http://en.wikipedia.org/wiki/MIME#Difference_between_Q-encoding_and_quoted-printable" rel="nofollow noreferrer">en.wikipedia.org/wiki/…</a></span>
<span class="comment-copy">In both Python 2 and Python 3, <code>email.header.decode_header</code> (with lower-case <code>m</code>) is the generic name. In addition, in your code, <code>text</code> is not actually a text, but instead a bytes variable.</span>
<span class="comment-copy">This works for me but I can't understand the code</span>
<span class="comment-copy">Could you rewrite that in a more Pythonic fashion?</span>
<span class="comment-copy">@wbg What's not Pythonic about this code? What would you change? Looking at it now, it seems rather well-written to me, and a paragon of Python's expressiveness. Maybe the <a href="https://docs.python.org/dev/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> is tripping up @deterjan? If you're just targeting Python 3, you can skip the <code>if isinstance(word, bytes) else word</code> and the <code>u</code> before the <code>'</code>; this code has been engineered to work on both Python 2 and 3.</span>
<span class="comment-copy">+1 truly this is for humans. Indeed imbox was able to decode otherwise base64-encoded (in imaplib and the like) subject and other fields on-the-fly. However, be aware if some field is missing the KeyError will be thrown.</span>
