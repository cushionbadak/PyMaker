<div class="post-text" itemprop="text">
<p>What would be the quickest way to construct a Python binding to a C or C++ library?</p>
<p>(I am using Windows if this matters.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You should have a look at <a href="http://www.boost.org/doc/libs/1_49_0/libs/python/doc/" rel="noreferrer">Boost.Python</a>. Here is the short introduction taken from their website:</p>
<blockquote>
<p>The Boost Python Library is a framework for interfacing Python and
  C++. It allows you to quickly and seamlessly expose C++ classes
  functions and objects to Python, and vice-versa, using no special
  tools -- just your C++ compiler. It is designed to wrap C++ interfaces
  non-intrusively, so that you should not have to change the C++ code at
  all in order to wrap it, making Boost.Python ideal for exposing
  3rd-party libraries to Python. The library's use of advanced
  metaprogramming techniques simplifies its syntax for users, so that
  wrapping code takes on the look of a kind of declarative interface
  definition language (IDL).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/ctypes.html" rel="noreferrer">ctypes</a> is part of the standard library, and therefore is more stable and widely available than <a href="http://www.swig.org/" rel="noreferrer">swig</a>, which always tended to give me <a href="http://groups.google.com/group/comp.lang.python/browse_thread/thread/d94badd9847fe43a?pli=1" rel="noreferrer">problems</a>.</p>
<p>With ctypes, you need to satisfy any compile time dependency on python, and your binding will work on any python that has ctypes, not just the one it was compiled against.</p>
<p>Suppose you have a simple C++ example class you want to talk to in a file called foo.cpp:</p>
<pre><code>#include &lt;iostream&gt;

class Foo{
    public:
        void bar(){
            std::cout &lt;&lt; "Hello" &lt;&lt; std::endl;
        }
};
</code></pre>
<p>Since ctypes can only talk to C functions, you need to provide those declaring them as extern "C"</p>
<pre><code>extern "C" {
    Foo* Foo_new(){ return new Foo(); }
    void Foo_bar(Foo* foo){ foo-&gt;bar(); }
}
</code></pre>
<p>Next you have to compile this to a shared library</p>
<pre><code>g++ -c -fPIC foo.cpp -o foo.o
g++ -shared -Wl,-soname,libfoo.so -o libfoo.so  foo.o
</code></pre>
<p>And finally you have to write your python wrapper (e.g. in fooWrapper.py)</p>
<pre><code>from ctypes import cdll
lib = cdll.LoadLibrary('./libfoo.so')

class Foo(object):
    def __init__(self):
        self.obj = lib.Foo_new()

    def bar(self):
        lib.Foo_bar(self.obj)
</code></pre>
<p>Once you have that you can call it like</p>
<pre><code>f = Foo()
f.bar() #and you will see "Hello" on the screen
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The quickest way to do this is using <a href="http://www.swig.org/" rel="noreferrer">SWIG</a>.</p>
<p>Example from SWIG <a href="http://www.swig.org/tutorial.html" rel="noreferrer">tutorial</a>:</p>
<pre><code>/* File : example.c */
int fact(int n) {
    if (n &lt;= 1) return 1;
    else return n*fact(n-1);
}
</code></pre>
<p>Interface file:</p>
<pre><code>/* example.i */
%module example
%{
/* Put header files here or function declarations like below */
extern int fact(int n);
%}

extern int fact(int n);
</code></pre>
<p>Building a Python module on Unix:</p>
<pre><code>swig -python example.i
gcc -fPIC -c example.c example_wrap.c -I/usr/local/include/python2.7
gcc -shared example.o example_wrap.o -o _example.so
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; import example
&gt;&gt;&gt; example.fact(5)
120
</code></pre>
<p>Note that you have to have python-dev. Also in some systems python header files will be in /usr/include/python2.7 based on the way you have installed it.</p>
<p>From the tutorial:</p>
<blockquote>
<p>SWIG is a fairly complete C++ compiler with support for nearly every language feature. This includes preprocessing, pointers, classes, inheritance, and even C++ templates. SWIG can also be used to package structures and classes into proxy classes in the target language — exposing the underlying functionality in a very natural manner.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I started my journey in the Python &lt;-&gt; C++ binding from this page, with the objective of linking high level data types (multidimensional STL vectors with Python lists) :-)</p>
<p>Having tried the solutions based on both <a href="https://docs.python.org/2/library/ctypes.html" rel="noreferrer">ctypes</a> and <a href="http://www.boost.org/doc/libs/1_55_0/libs/python/doc/tutorial/doc/html/index.html" rel="noreferrer">boost.python</a> (and not being a software engineer) I have found them complex when high level datatypes binding is required, while I have found <a href="http://swig.org" rel="noreferrer">SWIG</a> much more simple for such cases.</p>
<p>This example uses therefore SWIG, and it has been tested in Linux (but SWIG is available and is widely used in Windows too).</p>
<p>The objective is to make a C++ function available to Python that takes a matrix in form of a 2D STL vector and returns an average of each row (as a 1D STL vector).</p>
<p>The code in C++ ("code.cpp") is as follow:</p>
<pre><code>#include &lt;vector&gt;
#include "code.h"

using namespace std;

vector&lt;double&gt; average (vector&lt; vector&lt;double&gt; &gt; i_matrix) {

  // Compute average of each row..
  vector &lt;double&gt; averages;
  for (int r = 0; r &lt; i_matrix.size(); r++){
    double rsum = 0.0;
    double ncols= i_matrix[r].size();
    for (int c = 0; c&lt; i_matrix[r].size(); c++){
      rsum += i_matrix[r][c];
    }
    averages.push_back(rsum/ncols);
  }
  return averages;
}
</code></pre>
<p>The equivalent header ("code.h") is:</p>
<pre><code>#ifndef _code
#define _code

#include &lt;vector&gt;

std::vector&lt;double&gt; average (std::vector&lt; std::vector&lt;double&gt; &gt; i_matrix);

#endif
</code></pre>
<p>We first compile the C++ code to create an object file:</p>
<pre><code>g++ -c -fPIC code.cpp
</code></pre>
<p>We then define a <a href="http://swig.org/Doc3.0/SWIG.html" rel="noreferrer">SWIG interface definition file</a> ("code.i") for our C++ functions.</p>
<pre><code>%module code
%{
#include "code.h"
%}
%include "std_vector.i"
namespace std {

  /* On a side note, the names VecDouble and VecVecdouble can be changed, but the order of first the inner vector matters! */
  %template(VecDouble) vector&lt;double&gt;;
  %template(VecVecdouble) vector&lt; vector&lt;double&gt; &gt;;
}

%include "code.h"
</code></pre>
<p>Using SWIG, we generate a C++ interface source code from the SWIG interface definition file..</p>
<pre><code>swig -c++ -python code.i
</code></pre>
<p>We finally compile the generated C++ interface source file and link everything together to generate a shared library that is directly importable by Python (the "_" matters):</p>
<pre><code>g++ -c -fPIC code_wrap.cxx  -I/usr/include/python2.7 -I/usr/lib/python2.7
g++ -shared -Wl,-soname,_code.so -o _code.so code.o code_wrap.o
</code></pre>
<p>We can now use the function in Python scripts:</p>
<pre><code>#!/usr/bin/env python

import code
a= [[3,5,7],[8,10,12]]
print a
b = code.average(a)
print "Assignment done"
print a
print b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check out <a href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/" rel="noreferrer">pyrex</a> or <a href="http://cython.org/" rel="noreferrer">Cython</a>. They're Python-like languages for interfacing between C/C++ and Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is also <code>pybind11</code>, which is like a lightweight version of <a href="http://www.boost.org/doc/libs/release/libs/python/doc/index.html" rel="noreferrer">Boost.Python</a> and compatible with all modern C++ compilers:</p>
<p><a href="https://pybind11.readthedocs.io/en/latest/" rel="noreferrer">https://pybind11.readthedocs.io/en/latest/</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://openwetware.org/wiki/Julius_B._Lucks/Projects/Python_All_A_Scientist_Needs" rel="noreferrer">This paper, claiming Python to be all a scientist needs</a>, basically says: First prototype everything in Python. Then when you need to speed a part up, use SWIG and translate this part to C.</p>
</div>
<div class="post-text" itemprop="text">
<p>I’ve never used it but I’ve heard good things about <a href="https://docs.python.org/3.6/library/ctypes.html" rel="nofollow noreferrer">ctypes</a>. If you’re trying to use it with C++, be sure to evade name mangling via <a href="https://stackoverflow.com/q/1041866/2157640"><code>extern "C"</code></a>. <em>Thanks for the comment, Florian Bösch.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I think cffi for python can be an option.</p>
<blockquote>
<p>The goal is to call C code from Python. You should be able to do so
  without learning a 3rd language: every alternative requires you to
  learn their own language (Cython, SWIG) or API (ctypes). So we tried
  to assume that you know Python and C and minimize the extra bits of
  API that you need to learn.</p>
</blockquote>
<p><a href="http://cffi.readthedocs.org/en/release-0.7/">http://cffi.readthedocs.org/en/release-0.7/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>For modern C++, use cppyy:
   <a href="http://cppyy.readthedocs.io/en/latest/" rel="noreferrer">http://cppyy.readthedocs.io/en/latest/</a></p>
<p>It's based on Cling, the C++ interpreter for Clang/LLVM. Bindings are at run-time and no additional intermediate language is necessary. Thanks to Clang, it supports C++17.</p>
<p>Install it using pip:</p>
<pre><code>    $ pip install cppyy
</code></pre>
<p>For small projects, simply load the relevant library and the headers that you are interested in. E.g. take the code from the ctypes example is this thread, but split in header and code sections:</p>
<pre><code>    $ cat foo.h
    class Foo {
    public:
        void bar();
    };

    $ cat foo.cpp
    #include "foo.h"
    #include &lt;iostream&gt;

    void Foo::bar() { std::cout &lt;&lt; "Hello" &lt;&lt; std::endl; }
</code></pre>
<p>Compile it:</p>
<pre><code>    $ g++ -c -fPIC foo.cpp -o foo.o
    $ g++ -shared -Wl,-soname,libfoo.so -o libfoo.so  foo.o
</code></pre>
<p>and use it:</p>
<pre><code>    $ python
    &gt;&gt;&gt; import cppyy
    &gt;&gt;&gt; cppyy.include("foo.h")
    &gt;&gt;&gt; cppyy.load_library("foo")
    &gt;&gt;&gt; from cppyy.gbl import Foo
    &gt;&gt;&gt; f = Foo()
    &gt;&gt;&gt; f.bar()
    Hello
    &gt;&gt;&gt;
</code></pre>
<p>Large projects are supported with auto-loading of prepared reflection information and the cmake fragments to create them, so that users of installed packages can simply run:</p>
<pre><code>    $ python
    &gt;&gt;&gt; import cppyy
    &gt;&gt;&gt; f = cppyy.gbl.Foo()
    &gt;&gt;&gt; f.bar()
    Hello
    &gt;&gt;&gt;
</code></pre>
<p>Thanks to LLVM, advanced features are possible, such as automatic template instantiation. To continue the example:</p>
<pre><code>    &gt;&gt;&gt; v = cppyy.gbl.std.vector[cppyy.gbl.Foo]()
    &gt;&gt;&gt; v.push_back(f)
    &gt;&gt;&gt; len(v)
    1
    &gt;&gt;&gt; v[0].bar()
    Hello
    &gt;&gt;&gt;
</code></pre>
<p>Note: I'm the author of cppyy.</p>
</div>
<div class="post-text" itemprop="text">
<p>One of the official Python documents contains details on <a href="https://docs.python.org/3.6/extending/" rel="noreferrer">extending Python using C/C++</a>.
Even without the use of <a href="http://www.swig.org/" rel="noreferrer">SWIG</a>, it’s quite straightforward and works perfectly well on Windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>The question is how to call a C function from Python, if I understood correctly. Then the best bet are Ctypes (BTW portable across all variants of Python).</p>
<pre><code>&gt;&gt;&gt; from ctypes import *
&gt;&gt;&gt; libc = cdll.msvcrt
&gt;&gt;&gt; print libc.time(None)
1438069008
&gt;&gt;&gt; printf = libc.printf
&gt;&gt;&gt; printf("Hello, %s\n", "World!")
Hello, World!
14
&gt;&gt;&gt; printf("%d bottles of beer\n", 42)
42 bottles of beer
19
</code></pre>
<p>For a detailed guide you may want to refer to <a href="http://myunixworld.blogspot.in/2015/07/how-python-can-talk-to-other-language.html" rel="nofollow">my blog article</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Cython is definitely the way to go, unless you anticipate writing Java wrappers, in which case SWIG may be preferable.  </p>
<p>I recommend using the <code>runcython</code> command line utility, it makes the process of using Cython extremely easy.  If you need to pass structured data to C++, take a look at Google's protobuf library, it's very convenient.  </p>
<p>Here is a minimal examples I made that uses both tools: </p>
<p><a href="https://github.com/nicodjimenez/python2cpp" rel="nofollow">https://github.com/nicodjimenez/python2cpp</a></p>
<p>Hope it can be a useful starting point.  </p>
</div>
<div class="post-text" itemprop="text">
<p>First you should decide what is your particular purpose. The official Python documentation on <a href="https://docs.python.org/2/extending/" rel="nofollow">extending and embedding the Python interpreter</a> was mentioned above, I can add a good <a href="https://python-packaging-user-guide.readthedocs.org/en/latest/extensions.html" rel="nofollow">overview of binary extensions</a>. The use cases can be divided into 3 categories:</p>
<ul>
<li><strong>accelerator modules</strong>: to run faster than the equivalent pure Python code runs in CPython.</li>
<li><strong>wrapper modules</strong>: to expose existing C interfaces to Python code.</li>
<li><strong>low level system access</strong>: to access lower level features of the CPython runtime, the operating system, or the underlying hardware.</li>
</ul>
<p>In order to give some broader perspective for other interested and since your initial question is a bit vague ("to a C or C++ library") I think this information might be interesting to you. On the link above you can read on disadvantages of using binary extensions and its alternatives. </p>
<p>Apart from the other answers suggested, if you want an accelerator module, you can try <a href="http://numba.pydata.org/" rel="nofollow">Numba</a>. It works "by generating optimized machine code using the LLVM compiler infrastructure at import time, runtime, or statically (using the included pycc tool)". </p>
</div>
<span class="comment-copy">Boost.Python is one of the more user-friendly libraries in Boost, for a simple function call API it is quite straightforward and provides boilerplate you'd have to write yourself.  It's a bit more complicated if you want to expose an object-oriented API.</span>
<span class="comment-copy">Boost.Python is the worst thing imaginable. For every new machine and with every upgrade it goes with linking problems.</span>
<span class="comment-copy">This is pretty much what boost.python does for you in a single function call.</span>
<span class="comment-copy">ctypes is in the python standard library, swig and boost are not. Swig and boost rely on extension modules and are therefore tied to python minor versions which indepentent shared objects are not. building a swig or boost wrappers can be a pain, ctypes makes no build requirements.</span>
<span class="comment-copy">boost relies on voodoo template magic and an entirely custom build system, ctypes relies on simplicity. ctypes is dynamic, boost is static. ctypes can handle different versions of libraries. boost cannot.</span>
<span class="comment-copy">On Windows I've had to specify __declspec(dllexport) in my function signatures for Python to be able to see them.  From the above example this would correspond to:  <code>extern "C" {     __declspec(dllexport) Foo* Foo_new(){ return new Foo(); }     __declspec(dllexport) void Foo_bar(Foo* foo){ foo-&gt;bar(); } }</code></span>
<span class="comment-copy">Don't forget to delete the pointer afterwards by e.g. providing a <code>Foo_delete</code> function and calling it either from a python destructor or wrapping the object in a <a href="http://stackoverflow.com/questions/865115/how-do-i-correctly-clean-up-a-python-object">resource</a>.</span>
<span class="comment-copy">Running into swig: cannot execute binary file error using the same code. Seems to be an issue on my end, but any pointers would be helpful.</span>
<span class="comment-copy">@iDev sounds like a separate question</span>
<span class="comment-copy">A real case implementation where in the C++ code stl vectors are passed as non const references and hence available by python as output parameters: <a href="http://lobianco.org/antonello/personal:portfolio:portopt" rel="nofollow noreferrer">lobianco.org/antonello/personal:portfolio:portopt</a></span>
<span class="comment-copy">+1 for Cython! I have not tried cffi so I can not say which is better, but I had very good experiences with Cython - you are still writing Python code but you can use C in it. It was somewhat hard for me to set up the build process with Cython, which I later explained in a blog post: <a href="http://martinsosic.com/development/2016/02/08/wrapping-c-library-as-python-module.html" rel="nofollow noreferrer">martinsosic.com/development/2016/02/08/…</a></span>
<span class="comment-copy">You might want to improve the answer to no longer be a link-only answer.</span>
<span class="comment-copy">I think this can only call c (not c++), still +1 (I really like cffi).</span>
<span class="comment-copy">This is very cool, how does this compare to cython?</span>
<span class="comment-copy">It doesn't, really: Cython is a Python-like programming language to write C extension modules for Python (the Cython code gets translated into C, together with the necessary C-API boilerplate). It provides some basic C++ support.  Programming with cppyy only involves Python and C++, no language extensions. It's fully run-time and does not generate offline code (lazy generation scales a lot better). It targets modern C++ (incl. automatic template instantiations, moves, initializer_lists, lambda's, etc., etc.) and PyPy is supported natively (i.e. not through the slow C-API emulation layer).</span>
<span class="comment-copy">Cool, thanks for the explanation.</span>
<span class="comment-copy">Any benchmarking of cppyy available?</span>
<span class="comment-copy">This <a href="https://dl.acm.org/citation.cfm?id=3019087" rel="nofollow noreferrer">PyHPC'16 paper</a> contains a range of benchmark numbers. Since then, there have been definite improvements on the CPython side, though.</span>
<span class="comment-copy">It may be worth noting that while ctypes are portable, your code requires a Windows-specific C library.</span>
