<div class="post-text" itemprop="text">
<p>If I run this on the <em>python3</em> interpreter:</p>
<pre><code>import asyncio

@asyncio.coroutine
def wait(n):
    asyncio.sleep(n)

loop = asyncio.get_event_loop()
fut = asyncio.async(wait(10))
fut.add_done_callback(lambda x: print('Done'))

asyncio.Task.all_tasks()
</code></pre>
<p>I get the following result:</p>
<pre><code>{&lt;Task pending coro=&lt;coro() running at /usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/asyncio/coroutines.py:139&gt; cb=[&lt;lambda&gt;() at &lt;ipython-input-5-c72c2da2ffa4&gt;:1]&gt;}
</code></pre>
<p>Now if I run <code>fut.cancel()</code> I get <code>True</code> returned. But typing <code>fut</code> returns a representation of the task stating it is <em>cancelling</em>:</p>
<pre><code>&lt;Task cancelling coro=&lt;coro() running at /usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/asyncio/coroutines.py:139&gt; cb=[&lt;lambda&gt;() at &lt;ipython-input-5-c72c2da2ffa4&gt;:1]&gt;
</code></pre>
<p>And the task never actually cancels (<code>fut.cancelled()</code> never returns <code>True</code>)</p>
<p>Why won't it cancel?</p>
</div>
<div class="post-text" itemprop="text">
<p>Calling <code>task.cancel()</code> only schedules the task to be cancelled on the next run of the event loop; it doesn't immediately cancel the task, or even guarantee that the task will be actually be cancelled when the event loop runs its next iteration. This is all described <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel" rel="nofollow">in the documentation</a>:</p>
<blockquote>
<p><strong>cancel()</strong> </p>
<p>Request that this task cancel itself.</p>
<p>This arranges for a <code>CancelledError</code> to be thrown into the wrapped
  coroutine on the next cycle through the event loop. The coroutine then
  has a chance to clean up or even deny the request using
  try/except/finally.</p>
<p>Unlike <code>Future.cancel()</code>, this does not guarantee that the task will be
  cancelled: the exception might be caught and acted upon, delaying
  cancellation of the task or preventing cancellation completely. The
  task may also return a value or raise a different exception.</p>
<p><strong>Immediately after this method is called, <code>cancelled()</code> will not return
  <code>True</code></strong> (unless the task was already cancelled). A task will be marked as
  cancelled when the wrapped coroutine terminates with a <code>CancelledError</code>
  exception (even if <code>cancel()</code> was not called).</p>
</blockquote>
<p>In your case, you're never actually starting the event loop, so the task  never gets cancelled. You would need to call <code>loop.run_until_complete(fut)</code> (or <code>loop.run_forever()</code>, though that's not really the best choice for this particular case) for the task to actually end up getting cancelled.</p>
<p>Also, for what it's worth, it's usually easier to test <code>asyncio</code> code using actual scripts, rather than the interpreter, since it tends to get tedious to have to constantly rewrite coroutines and start/stop the event loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>With <em>asyncio</em> testing in the interpreter is tricky, because python needs to keep the event loop constantly polling its tasks.</p>
<p>So a few pieces of advice to test <em>asyncio</em> are:</p>
<ol>
<li>Write and run scripts instead of using the interactive interpreter</li>
<li>Add a <code>loop.run_forever()</code> at the end of the script so all tasks get executed.</li>
<li>An alternative is to run <code>loop.run_until_complete(coro())</code> for each task you want to run.</li>
<li>Have <code>yield from</code> in front of <code>asyncio.sleep(n)</code> so it can actually be run. The current code returns a generator and does nothing.</li>
</ol>
</div>
<span class="comment-copy">You probably actually want <code>yield from asyncio.sleep(n)</code> inside of <code>wait</code>. Otherwise, <code>wait</code> will exit without actually sleeping for <code>n</code> seconds.</span>
<span class="comment-copy">I think the perfect answer would combine mine own with this one. If you combine them on yours I'll accept it.</span>
