<div class="post-text" itemprop="text">
<p>I have a composite dictionary <em>d</em> that is built up from a set of component dictionaries, <em>d1</em> and <em>d2</em>:</p>
<pre><code>d1 = {'key1': 4}
d2 = {'key2': 5}
d = {}
d['altname_key1'] = d1['key1']
d['altname_key2'] = d2['key2']
</code></pre>
<p>The behavior I am trying to accomplish is for changes to the keys of <em>d</em> to automatically propagate to changes in <em>d1</em> and <em>d2</em>. The above code does not behave this way, which can be verified by comparing the ids:</p>
<pre><code>id(d['altname_key1']) == id(d1['key1'])
True 
id(d['altname_key2']) == id(d2['key2'])
True 
d['altname_key1'] = 17
id(d['altname_key1']) == id(d1['key1'])
False 
</code></pre>
<p>The behavior I am looking for can be accomplished if my composite dictionary was only a composite of a single component <strong>and</strong> if I did not change keynames:</p>
<pre><code>d = d1
d['key1'] = 45
id(d['key1']) == id(d1['key1'])
True 
</code></pre>
<p>Does python have a feature that enables a composite dictionary <em>d</em>, including different keynames, such that the keys point to the same point in memory, even if the keys have different names? </p>
</div>
<div class="post-text" itemprop="text">
<p>This class will act like a ChainMap, except it'll respect your alternate key mapping where specified. It works in Python 2.7 and Python 3.3+.</p>
<pre><code>from __future__ import print_function

try:
    from collections import ChainMap  # Python 3
except ImportError:
    from ConfigParser import _Chainmap as ChainMap  # Python 2


class ChainMapWithAltKeys(ChainMap):
    def __init__(self, *maps, **kwargs):
        try:
            super(ChainMapWithAltKeys, self).__init__(*maps)
        except TypeError:  # Python 2
            ChainMap.__init__(self, *maps)  # Python 2
        self.altkeymap = kwargs.get('altkeymap', {})

    def __getitem__(self, key):
        if key in self.altkeymap:
            key = self.altkeymap[key]
        try:
            return super(ChainMapWithAltKeys, self).__getitem__(key)
        except TypeError:  # Python 2
            return ChainMap.__getitem__(self, key)  # Python 2


dict_one = {'a': 1, 'b': 2, 'c': 3, 'samekey': 'diffval_one'}
dict_two = {'x': 24, 'y': 25, 'z': 26, 'samekey': 'diffval_two'}

altkeymap = {'alpha': 'a', 'zulu': 'z'}

cmwak = ChainMapWithAltKeys(dict_one, dict_two, altkeymap=altkeymap)

print(cmwak['a'])  # 1
print(cmwak['alpha'])  # 1
print(cmwak['b'])  # 2
print(cmwak['y'])  # 25
print(cmwak['z'])  # 26
print(cmwak['zulu'])  # 26
print(cmwak['samekey'])  # diffval_one
</code></pre>
<p>Note that when a key is in more than one dict, the value is taken from the dict that was passed in first; specifically, each mapping in cmwak.maps is checked in order until the key is found. Read up on <a href="https://docs.python.org/3/library/collections.html#chainmap-objects" rel="nofollow">ChainMap</a> for the details; everything there applies to <code>ChainMapWithAltKeys</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe something else may have caused the <code>id</code> of the values to change, maybe you did some other assignment to <code>d</code> dictionary before testing <code>id</code> , numbers in python are immutable, so two different numbers would not have the same <code>id</code>.</p>
<p>When you do - <code>d['altname_key1'] = d1['a']</code> - Python is pass by assignment, which means the reference of <code>d1['a']</code>'s reference is passed by value. Example -</p>
<pre><code>&gt;&gt;&gt; d = {'a':[1,2]}
&gt;&gt;&gt; d2 = {'b':[3,4]}
&gt;&gt;&gt; d3 = {}
&gt;&gt;&gt; d3 ['aa'] = d['a']
&gt;&gt;&gt; d3['bb'] = d2['b']
&gt;&gt;&gt; d3
{'bb': [3, 4], 'aa': [1, 2]}

&gt;&gt;&gt; id(d3['aa']) == id(d['a'])
True
&gt;&gt;&gt; d3['aa'].append(5)

&gt;&gt;&gt; d3
{'bb': [3, 4], 'aa': [1, 2, 5]}

&gt;&gt;&gt; d
{'a': [1, 2, 5]}
</code></pre>
<p>So what you are trying to achieve does work.</p>
<hr/>
<p>But this given , I would like to advice against keeping multiple references to same mutable object, as this method can lead mysterious bugs, some code may wrongly update <code>d</code> dictionary, even though you did not want it to and it can cause the same changes to get reflected in d1. And it would be hard to debug the issues.</p>
<p>Also, this method would break if you do an assignment on <code>d</code> , in that case, <code>d</code> dictionary's value would change, but <code>d1</code> or <code>d2</code> would not change. Example -</p>
<pre><code>&gt;&gt;&gt; d3['aa'] = [1]
&gt;&gt;&gt; d3
{'bb': [3, 4], 'aa': [1]}
&gt;&gt;&gt; d
{'a': [1, 2, 5]}
</code></pre>
<p>You may want to reconsider what you are trying to design.</p>
<hr/>
<p>Regarding <em>Why you get the desired behavior when you do the following</em> - </p>
<pre><code>d = d1
d['key1'] = 45
id(d['key1']) == id(d1['key1'])
True 
</code></pre>
<p>It is because in the <code>d</code> is a reference to the <code>d1</code> dictionary object, so they are basically pointing to the same dictionaries. And hence <code>d['key1']</code> would always be <code>d1['key1']</code> . You can do  the following to see that they are the same reference -</p>
<pre><code>id(d) == id(d1)
</code></pre>
<p>And this again would not be recommended due to above said reasons.</p>
</div>
<span class="comment-copy">what is <code>d1['a']</code> ? you seem to be checking wrong keys or setting wrong, either of them.</span>
<span class="comment-copy">This doesn't do quite what you're asking, but you might want to take a look at <a href="https://docs.python.org/3/library/collections.html#chainmap-objects" rel="nofollow noreferrer">ChainMap</a> (ChainMap is in <code>collections</code> in Python 3, and can be obtained in Python 2.7 by doing <code>from ConfigParser import _Chainmap as ChainMap</code>). Maybe if you combine that with another dict that maps alternate key names to their primary names, you could get the result you want (or close enough).</span>
<span class="comment-copy">Apologies, @AnandSKumar. That was a typo, sorry for the confusion. Post is corrected now.</span>
<span class="comment-copy">Unfortunately I'm afraid I don't believe you. :-) Both of those tests should return True.  (Since integers are immutable, this may not lead to the consequences you want, but that's another issue.)</span>
<span class="comment-copy">Can you show in code what you want to be able to do?</span>
<span class="comment-copy">Very clever solution, Cyphase. Having now read up a bit on Chainmap, I see that I was basically asking python dictionaries to perform in a way that they were not intended, hence the gyrations you had to go to in order to get this to work. All the same, props for a solution to the somewhat convoluted problem I had posed.</span>
<span class="comment-copy">I wouldn't call them gyrations; ChainMap is a useful tool in the standard library. I just added a tiny bit of functionality to it for ease of use in your situation, as opposed to having to manually check for alternate keys everywhere in the code that you would use it. The most gyrations were to make the code work in Python 2 and 3, and even that wasn't too bad :).</span>
<span class="comment-copy">Really, when you look closely, I only added about three lines of non-boilerplate code to what <code>ChainMap</code> already does, and the entire implementation of <code>ChainMapWithAltKeys</code> would be only eight source lines if I only targeted Python 3; and it's not much more now, even given a fluke with Python 2.7's <code>ConfigParser._Chainmap</code>. That's the sort of thing that makes me love Python :D.</span>
<span class="comment-copy">Very clear explanation, Anand. Since Cyphase's code ends up providing the functionality that was in my question, I think it's appropriate to mark his answer as the accepted one. However, you have convinced me to actually not implement that behavior in my package, because it will lead to more complications than the conveniences it is worth. Many thanks.</span>
<span class="comment-copy">@aph, not to try to convince you to use it if it's not appropriate, but @Anand might not have the same objections to the <code>ChainMapWithAltKeys</code> method. It doesn't keep multiple references to the same objects, it doesn't break if you do an assignment on one of the 'original' dictionaries, and it doesn't require manual updates. If the access pattern is indeed useful for your particular use case (which you never did explain :P), you might want to consider giving it a try.</span>
