<div class="post-text" itemprop="text">
<p>Expected inputs and outputs:</p>
<pre><code>a                 -&gt; a
a.txt             -&gt; a
archive.tar.gz    -&gt; archive
directory/file    -&gt; file
d.x.y.z/f.a.b.c   -&gt; f
logs/date.log.txt -&gt; date # Mine!
</code></pre>
<p>Here's my implementation that feels dirty to me:</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; example_path = Path("August 08 2015, 01'37'30.log.txt")
&gt;&gt;&gt; example_path.stem
"August 08 2015, 01'37'30.log"
&gt;&gt;&gt; example_path.suffixes
['.log', '.txt']
&gt;&gt;&gt; suffixes_length = sum(map(len, example_path.suffixes))
&gt;&gt;&gt; true_stem = example_path.name[:-suffixes_length]
&gt;&gt;&gt; true_stem
"August 08 2015, 01'37'30"
</code></pre>
<p>Because it breaks on <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" rel="noreferrer"><code>Path</code></a>s without suffixes:</p>
<pre><code>&gt;&gt;&gt; ns_path = Path("no_suffix")
&gt;&gt;&gt; sl = sum(map(len, ns_path.suffixes))
&gt;&gt;&gt; ns_path.name[:-sl]
''
</code></pre>
<p>So I need to check if the <code>Path</code> has a suffix first:</p>
<pre><code>&gt;&gt;&gt; def get_true_stem(path: Path):
...     if path.suffix:
...         sl = sum(map(len, path.suffixes))
...         return path.name[:-sl]
...     else:
...         return path.stem
...
&gt;&gt;&gt;
&gt;&gt;&gt; get_true_stem(example_path)
"August 08, 2015, 01'37'30"
&gt;&gt;&gt; get_true_stem(ns_path)
"no_suffix"
</code></pre>
<p>And this is my current use case:</p>
<pre><code>&gt;&gt;&gt; file_date = datetime.strptime(true_stem, "%B %d %Y, %H'%M'%S")
&gt;&gt;&gt; file_date
datetime.datetime(2015, 8, 8, 1, 37, 30)
&gt;&gt;&gt; new_dest = format(file_date, "%Y-%m-%dT%H:%M:%S%z") + ".log" # ISO-8601
&gt;&gt;&gt; shutil.move(str(example_path), new_dest)
</code></pre>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just <code>.split</code> it:</p>
<pre><code>&gt;&gt;&gt; Path('logs/date.log.txt').stem.split('.')[0]
'date'
</code></pre>
<p><code>os.path</code> works just as well:</p>
<pre><code>&gt;&gt;&gt; os.path.basename('logs/date.log.txt').split('.')[0]
'date'
</code></pre>
<p>It passes all of the tests:</p>
<pre><code>In [11]: all(Path(k).stem.split('.')[0] == v for k, v in {
   ....:     'a': 'a',
   ....:     'a.txt': 'a',
   ....:     'archive.tar.gz': 'archive',
   ....:     'directory/file': 'file',
   ....:     'd.x.y.z/f.a.b.c': 'f',
   ....:     'logs/date.log.txt': 'date'
   ....: }.items())
Out[11]: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about a while loop method, where you keep taking <code>.stem</code> until the path has no suffixes remaining , Example -</p>
<pre><code>from pathlib import Path
example_path = Path("August 08 2015, 01'37'30.log.txt")
example_path_stem = example_path.stem
while example_path.suffixes:
    example_path_stem = example_path.stem
    example_path = Path(example_path_stem)
</code></pre>
<p>Please note, the while loop exits the loop when <code>example_path.suffixes</code> returns an empty list (As empty list are False like in boolean context) .</p>
<hr/>
<p>Example/Demo -</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; example_path = Path("August 08 2015, 01'37'30.log.txt")
&gt;&gt;&gt; example_path_stem = example_path.stem
&gt;&gt;&gt; while example_path.suffixes:
...     example_path_stem = example_path.stem
...     example_path = Path(example_path_stem)
...
&gt;&gt;&gt; example_path_stem
"August 08 2015, 01'37'30"
</code></pre>
<p>For your second input - <code>no_suffix</code> -</p>
<pre><code>&gt;&gt;&gt; example_path = Path("no_suffix")
&gt;&gt;&gt; example_path_stem = example_path.stem
&gt;&gt;&gt; while example_path.suffixes:
...     example_path_stem = example_path.stem
...     example_path = Path(example_path_stem)
...
&gt;&gt;&gt; example_path_stem
'no_suffix'
</code></pre>
</div>
