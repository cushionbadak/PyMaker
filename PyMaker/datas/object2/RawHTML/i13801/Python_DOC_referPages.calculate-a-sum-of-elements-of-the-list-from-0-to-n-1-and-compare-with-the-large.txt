<div class="post-text" itemprop="text">
<p>I'm trying to write a code which will check, if a sum of some combination of elements of a given list is equal to the largest element in this list. I wrote such a code:</p>
<pre><code>def function(argument): 

  max_arg = max(argument)
  argument.remove(max_arg)
  for i in argument:

      if sum(argument[0:i+1]) == max_arg:
          return "true"
      else:
          return "false"

print function([1, 2, 3, 6])
</code></pre>
<p>I get the "false" string (which is an obvious mistake). Could somebody please point out, what's wrong with the above presented code?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are making several mistakes:</p>
<ul>
<li><p>You are confusing values with indices. The <code>for</code> loop gives you the <em>values from the list</em>, not indices into the list. Only because your values are integers does your loop not immediately break.</p>
<p>In other words, <code>i</code> is not set to <code>0</code>, <code>1</code>, <code>2</code>, but to <code>1</code>, <code>2</code> and <code>3</code>.</p></li>
<li><p>You <em>immediately</em> return <code>'false'</code> from the function when you found a combination that doesn't sum to the maximum. The first sum is <code>3</code> (value <code>1</code> then translates to <code>sum(argument[0:2])</code> which produces <code>3</code>), but you don't then let the loop continue.</p></li>
</ul>
<p>To fix these mistakes, use a loop over the results of the <code>range()</code> function and only return <code>'false'</code> when you tried all combinations:</p>
<pre><code>def function(argument): 
    max_arg = max(argument)
    argument.remove(max_arg)

    for i in range(len(argument)):
        if sum(argument[:i + 1]) == max_arg:
            return "true"
    return "false"
</code></pre>
<p>Your 'different combinations' are still pretty primitive. You could try and produce all possible combinations of 3 numbers with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>itertools.combinations()</code></a> and increasing lengths:</p>
<pre><code>from itertools import combinations

def function(argument): 
    max_arg = max(argument)
    argument.remove(max_arg)

    for length in range(1, len(argument) + 1):
        for combo in combinations(argument, length):
            if sum(combo) == max_arg:
                return "true"
    return "false"
</code></pre>
<p>Now the order in which your elements are arranged no longer matters; <code>[1, 4, 3, 2, 6]</code> will return true because <code>1 + 3 + 2</code> produces 6.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; function([1, 2, 3, 6])
'true'
&gt;&gt;&gt; function([1, 4, 3, 2, 6])
'true'
&gt;&gt;&gt; function([1, 4, 3, 6])
'false'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This performs the sum over elements only once:</p>
<pre><code>def function(argument):  
  max_arg = max(argument)
  argument.remove(max_arg)
  s = 0
  for i in argument:
      s += i
      if s == max_arg:
          return "true"
  return "false"
</code></pre>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; function([1, 2, 3, 6])
'true'
&gt;&gt;&gt; function([1, 2, 3, 7])
'false'
&gt;&gt;&gt; function([1, 2, 3, 4, 6])
'true'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are always returning in the first loop itself, if the value is equal (which it wont be unless the first element is the largest element , you return <code>"true"</code> ) , otherwise you return <code>"false"</code>, instead do not return <code>"False"</code> immediately, only return <code>"false"</code> when you do not find any cases.</p>
<p>And you are using the values as indices, instead you want to enumerate over <code>argument</code> and use the index as indices</p>
<p>Example -</p>
<pre><code>def function(argument): 
    max_arg = max(argument)
    argument.remove(max_arg)
    for i in range(len(argument)):
        if sum(argument[0:i+1]) == max_arg:
            return "true"
    return "false"

print function([1, 2, 3, 6])
</code></pre>
<hr/>
<p>Example/Demo -</p>
<pre><code>&gt;&gt;&gt; def function(argument):
...     max_arg = max(argument)
...     argument.remove(max_arg)
...     for i in range(len(argument)):
...         if sum(argument[0:i+1]) == max_arg:
...             return "true"
...     return "false"
...
&gt;&gt;&gt; print(function([1, 2, 3, 6]))
true
&gt;&gt;&gt; print(function([1, 2, 3, 7]))
false
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Keeping in mind that addition is associative and commutative...</p>
<pre><code>from itertools import permutations

def function(argument): 
    max_arg = max(argument)
    argument.remove(max_arg)

    for combo in permutations(argument):
        s = 0
        for element in combo:
            s = s + element
            if s == max_arg:
                return "true"
    return "false"
</code></pre>
<p>We see that we do not need to find all the possible combinations. We can just find all the permutations of size (n-1) and add up elements until we find one that matches the <code>max_arg</code>.</p>
</div>
<span class="comment-copy">Thank you, this solution is perfect!</span>
<span class="comment-copy">what about <code>function([1, 2, 3, 6, 1])</code></span>
<span class="comment-copy">@TheBrofessor That returns <code>True</code> which is as I think it should be because  <code>[1,2,3]</code> adds up to the maximum element of  6.  Did you interpret it differently?</span>
<span class="comment-copy">Sorry that one works. I meant something like this <code>[30, 10, 10, 12, 10]</code>, where s = 10... 20... 32... 42 and returns false</span>
<span class="comment-copy">@TheBrofessor As I understand what the OP asked,  he wanted to sum <i>"from 0 to n-1"</i>  (after removing the max).  If that is what he wants, then returning <code>False</code> for <code>[30, 10, 10, 12, 10]</code> is correct.</span>
<span class="comment-copy">This may work for the given input, but not for, say, <code>[1, 2, 3, 4, 6]</code>; the OP is trying <i>different combinations</i>.</span>
