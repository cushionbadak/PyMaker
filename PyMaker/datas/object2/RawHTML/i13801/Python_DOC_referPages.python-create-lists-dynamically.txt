<div class="post-text" itemprop="text">
<p>I am trying to create a list of 3D indexes in python. One way I can do is iterate over all the ids in nested loops and do as follows:</p>
<pre><code>l = list()

for z in range(0, 2):
    for y in range(1, 5);
        for x in range(1, 10):
            l.append((x, y, z))
</code></pre>
<p>However, I remember there was a one liner way to do this but for the life of me I cannot figure it out. I tried something like:</p>
<pre><code>l.append((x, y, z) for x in range(0, 10), for y in range(0, 10), for z in range(0, 2))
</code></pre>
<p>However, this resulted in a syntax error.</p>
</div>
<div class="post-text" itemprop="text">
<p>You meant to write:</p>
<pre><code>l = [(x, y, z) for x in range(0, 10) for y in range(0, 10) for z in range(0, 2)]
</code></pre>
<p>The commas are not necessary after the <code>range()</code> calls and you can directly assign the result (a list) to the variable <code>l</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are getting SyntaxError, because</p>
<pre><code>(x, y, z) for x in range(0, 10), for y in range(0, 10), for z in range(0, 2)
</code></pre>
<p>you separate the <code>for</code> expressions with commas. But as per the <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow">grammar for list comprehension</a>,</p>
<pre class="lang-none prettyprint-override"><code>comprehension ::=  expression comp_for
comp_for      ::=  "for" target_list "in" or_test [comp_iter]
comp_iter     ::=  comp_for | comp_if
comp_if       ::=  "if" expression_nocond [comp_iter]
</code></pre>
<p>commas should not be there.</p>
<p>Now, even after removing the commas, your program will have a logic error</p>
<pre><code>&gt;&gt;&gt; l = []
&gt;&gt;&gt; l.append((x, y, z) for x in range(10) for y in range(10) for z in range(2))
&gt;&gt;&gt; l
[&lt;generator object &lt;genexpr&gt; at 0x7f5b78302b40&gt;]
</code></pre>
<p>Here, the expression <code>(x, y, z) for x in range(0, 10) for y in range(0, 10) for z in range(0, 2)</code> is treated as a generator expression. So, you need to create a list, with <code>list</code> function, like this</p>
<pre><code>&gt;&gt;&gt; list((x, y, z) for x in range(1) for y in range(2) for z in range(2))
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1)]
</code></pre>
<hr/>
<p>Instead, you can use list comprehension to create a new list, like this</p>
<pre><code>&gt;&gt;&gt; [(x, y, z) for x in range(1) for y in range(2) for z in range(2)]
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1)]
</code></pre>
<p>But, in this case, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a>, as well</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; list(product(range(1), range(2), range(2)))
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1)]
</code></pre>
<p><code>product</code> function returns a generator, to get the actual entire list, we use <code>list</code> function.</p>
<p><strong>PS:</strong> You don't have use the starting value in <code>range</code> function if it is zero, as that is the default value.</p>
<p><strong>Note:</strong> What you are actually trying to do is called generating the cartesian product of three iterables. The result will have huge number of elements. So, unless you need all the elements at once, you can simply iterate the <code>product</code>'s result. This will greatly improve the program's performance as the entire result need not have to computed immediately.</p>
<pre><code>&gt;&gt;&gt; for items in product(range(1), range(2), range(2)):
...     print(items)
...     
... 
(0, 0, 0)
(0, 0, 1)
(0, 1, 0)
(0, 1, 1)
</code></pre>
<p>Now, the values are generated only during their respective iterations.</p>
</div>
<span class="comment-copy">Is there any performance benefit to this over using loops?</span>
<span class="comment-copy">@Luca: if you intend to create a list then this approach is better because it avoids calling <code>append()</code> for every element that you wish to add to the list. This code will immediately create a list with the desired elements without explicitly appending the elements one by one.</span>
<span class="comment-copy">@Luca: I would say readability is more important than performance in writing Python code if months later someone needs to come back to it. In that case, your nested loop looks much clearer. If performance is a concern, you should pick a compiled and strongly typed language.</span>
<span class="comment-copy">@SimeonVisser: The list is still created element by element, but a list comp is a little faster than using explicit <code>for</code> loops because it uses a special LIST_APPEND bytecode which is a bit more efficient than doing a <code>list.append()</code> method call.</span>
<span class="comment-copy">@Luca: If you're concerned about performance then use <code>itertools.product</code>, since it's written in C, and C code runs significantly faster than Python code. And as others have said, it's often better to use a generator that yields the items one by one rather than building a RAM-hogging list, unless you actually need the whole collection of items as a united entity for some reason (eg random access).</span>
