<div class="post-text" itemprop="text">
<p>I have a problem with Unicode surrogates encoding in Python (3.4):</p>
<pre><code>&gt;&gt;&gt; b'\xCC'.decode('utf-16_be', 'surrogateescape').encode('utf-16_be', 'surrogateescape')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeEncodeError: 'utf-16-be' codec can't encode character '\udccc' in position 0: surrogates not allowed
</code></pre>
<p>If I'm not mistaken, according to <a href="https://docs.python.org/3/library/codecs.html#error-handlers" rel="nofollow">Python documentation</a>:</p>
<blockquote>
<p>'surrogateescape': On decoding, replace byte with individual surrogate
  code ranging from U+DC80 to U+DCFF. This code will then be turned back
  into the same byte when the 'surrogateescape' error handler is used
  when encoding the data.</p>
</blockquote>
<p>The code should just produce the source sequence (<code>b'\xCC'</code>). So why is the exception raised instead?</p>
<p>This is possibly related to my second question:</p>
<blockquote>
<p>Changed in version 3.4: The utf-16* and utf-32* encoders no longer allow surrogate code points (U+D800–U+DFFF) to be encoded.</p>
</blockquote>
<p>(From <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" rel="nofollow">https://docs.python.org/3/library/codecs.html#standard-encodings</a>)</p>
<p>From as far as I know, it's impossible to encode some code points to UTF-16 without surrogate pairs. So what's the reason behind this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This change was made because the <em>Unicode standard</em> explicitly disallows such encodings. See <a href="http://bugs.python.org/issue12892" rel="nofollow">issue #12892</a>, but apparently the <code>surrogateescape</code> error handler cannot be made to work with UTF-16 or UTF-32, because these codecs are not ASCII compatible.</p>
<p>Specifically:</p>
<blockquote>
<p>I tested utf_16_32_surrogates_4.patch: surrogateescape with as encoder
  does not work as expected.</p>
<pre><code>&gt;&gt;&gt; b'[\x00\x80\xdc]\x00'.decode('utf-16-le', 'ignore')
'[]'
&gt;&gt;&gt; b'[\x00\x80\xdc]\x00'.decode('utf-16-le', 'replace')
'[�]'
&gt;&gt;&gt; b'[\x00\x80\xdc]\x00'.decode('utf-16-le', 'surrogateescape')
'[\udc80\udcdc\uffff'
</code></pre>
<p>=&gt; I expected <code>'[\udc80\udcdc]'</code>.</p>
</blockquote>
<p>to which came the response:</p>
<blockquote>
<p>Yes, surrogateescape doesn't work with ASCII incompatible encodings and can't. First, it can't represent the result of decoding <code>b'\x00\xd8'</code> from utf-16-le or <code>b'ABCD'</code> from utf-32*. This problem is worth separated issue (or even PEP) and discussion on Python-Dev.</p>
</blockquote>
<p>I believe the <code>surrogateescape</code> handler was more meant for UTF-8 data; that decoding to UTF-16 or UTF-32 works with it too now is a nice extra but it can't work in the other direction, apparently.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use <code>surrogatepass</code> (instead of <code>surrogateescape</code>), things should work on Python 3.</p>
<p>See: <a href="https://docs.python.org/3/library/codecs.html#codec-base-classes" rel="nofollow noreferrer">https://docs.python.org/3/library/codecs.html#codec-base-classes</a> (which says that <code>surrogatepass</code> allows encoding and decoding of surrogate codes (for <code>utf</code> related encoding).</p>
</div>
<span class="comment-copy">Why <code>surrogateescape</code> can't work with ASCII non-compatible encodings? Also, you point "First, it can't represent the result of decoding <code>b'\x00\xd8'</code>" but according to PEP 383 this is not a correct lone surrogate, and in my example the <code>.decode()</code> method produces correct lone surrogate, so <code>.encode()</code> should be able to recreate <code>b'\xCC'</code>.</span>
<span class="comment-copy">@m4tx: to be honest, I don't buy the explanation given in the ticket, I've poked the developers to provide a better explanation. <code>b'\x80'</code> -&gt; <code>'\udc80'</code> -&gt; <code>b'\x80'</code> seems perfectly round-tripable to me, unless the UTF-16 and UTF-32 encoders have trouble with code units that don't fit the normal 2-byte or 4-byte pattern.</span>
<span class="comment-copy">Sorry for the delay and thanks for the answer!</span>
