<div class="post-text" itemprop="text">
<p>I am trying to run a blat search from within my python code. Right now it's written as...</p>
<pre><code>os.system('blat database.fa fastafile pslfile')
</code></pre>
<p>When I run the code, I specify file names for "fastafile" and "pslfile"...</p>
<pre><code>python my_code.py -f new.fasta -p test.psl
</code></pre>
<p>This doesn't work as "fastafile" and "pslfile" are variables for files created and named when I run the code, but if I were to use the actual file names I would have to go back and change my code each time I run it. I'd like to use the command line arguments above to specify the files.</p>
<p>How would I change this so that "fastafile" and "pslfile" will be replaced with my arguments (new.fasta and test.psl) each time?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should make use of argparse to take in command line arguments (it'll give you variables with names f and p that hold the file names), then just form the command string from there.</p>
<pre><code>command_str = "blat database.fa " + f + " " + p
os.system(command_str)
</code></pre>
<p><a href="https://docs.python.org/3.4/library/argparse.html#argparse.ArgumentParser.parse_args" rel="nofollow">https://docs.python.org/3.4/library/argparse.html#argparse.ArgumentParser.parse_args</a></p>
<pre><code>ArgumentParser.parse_args(args=None, namespace=None)
</code></pre>
<p>Convert argument strings to objects and assign them as attributes of the namespace. Return the populated namespace.</p>
<p>Previous calls to add_argument() determine exactly what objects are created and how they are assigned. See the documentation for add_argument() for details.</p>
<p>By default, the argument strings are taken from sys.argv, and a new empty Namespace object is created for the attributes.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os

fastaFile = sys.argv[1]
pslFile = sys.argv[2]

os.system("blat -f {0} -p {1}".format(fastaFile,pslFile))

#example run: python scriptName.py fasta.txt psl.txt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/env python2.7

from sys import argv

def main():
    if len(argv) != 3:
        print "usage: ./my_code.py -f *.fasta -p *.psl"
        raise SystemExit
    os.system('blat database.fa {} {}'.format(*argv[1:]))

if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using <code>os.system</code>, it's considered more pythonic to use <a href="https://docs.python.org/3/library/subprocess.html#using-the-subprocess-module" rel="nofollow"><code>subprocess.call</code></a>, which eliminates the need to sanitize the input from argv:</p>
<pre><code>subprocess.call(['blat', 'database.fa', '-f', 'new.fasta', '-p', 'test.psl'])
</code></pre>
<p>You can also incorporate ApolloFortyNine's answer and use Python's great <code>argparse</code> module to get the arguments and pass them onto <code>subprocess.call</code>.</p>
</div>
<span class="comment-copy">how are you taking args from the command line?  You can pass those to os.system <code>os.system('blat database.fa {}  {}'.format(var1,var2))</code>, I would also use subprocess ahead of os.system</span>
<span class="comment-copy">Cool, worked great. I'll look into subprocess as well. Thanks for the help!</span>
<span class="comment-copy">No worries, <code>subprocess.check_call(["blat","database.fa",var1,var2])</code> will do what you want</span>
