<div class="post-text" itemprop="text">
<p>I run into the case of <strong>using an enumerator on <em>selected</em> elements form an iterable</strong> (i.e. a <em>sequence</em> or an <em>iterator</em> or similar) and want that the <strong><em>original</em> indices were being returned</strong> instead of the default <code>count</code>, starting by <code>0</code> and going up to <code>len(iterable) - 1</code>.</p>
<p>A very naive approach would be the declaration of <strong>a new <em>generator object</em></strong> called <code>_enumerate()</code></p>
<pre><code>&gt;&gt;&gt; def _enumerate(iterable, offset = 0, step = 1):
    index = offset
    for element in iterable:
        yield index, element
        index += step
</code></pre>
<p>... a new <strong>list object <code>months</code></strong>.</p>
<pre><code>&gt;&gt;&gt; months = ["January", "February", "March", "April", "May", "June",
              "July", "August", "September", "October", "November", "December"]
</code></pre>
<p>Using Pythons <strong>build-in <code>enumerate</code> function</strong> would yield this <strong>output</strong> for a <code>[5::2]</code> slice:</p>
<pre><code>&gt;&gt;&gt; for index, element in enumerate(months[5::2]):
    print(index, element)


    0 June
    1 August
    2 October
    3 December
</code></pre>
<p>The <strong><em>expected output</em> of our own enumerator</strong> <code>_enumerate</code> again for a <code>[5::2]</code> slice:</p>
<pre><code>&gt;&gt;&gt; for index, element in _enumerate(months[5::2], offset = 5, step = 2):
    print(index, element)


    5 June
    7 August
    9 October
    11 December
</code></pre>
<p><em>Do you know any better, more pythonic and more readable solutions?</em> :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here my comment as an answer ;)</p>
<pre><code>months = ["January", "February", "March", "April", "May", "June",
          "July", "August", "September", "October", "November", "December"]

offset = 5
step = 2
for index, element in enumerate(months[offset::step]):

    # recalculate original index
    index = offset + index*step

    # actually repetition of the month is trivial,
    # but I put it just to show that the index is right
    print(index, element, months[index])
</code></pre>
<p>Prints:</p>
<pre><code>5 June June
7 August August
9 October October
11 December December
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't like using <code>range(len(...</code>, but maybe it's okay here.</p>
<pre><code>&gt;&gt;&gt; months = ["January", "February", "March", "April", "May", "June",
...           "July", "August", "September", "October", "November", "December"]
&gt;&gt;&gt; print(*('{:&gt;2} {}'.format(i, months[i]) for i in range(len(months))[5::2]), sep='\n')
 5 June
 7 August
 9 October
11 December
</code></pre>
<p>To expand out of the one-liner:</p>
<pre><code>offset = 5
step = 2
r = range(len(months))

for i in r[offset::step]:
    print('{:&gt;2} {}'.format(i, months[i]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools as it

months = [
    "January", "February", "March", "April", "May", "June", "July",
    "August", "September", "October", "November", "December"
]

print list(
    it.islice(it.izip(it.count(1), months), 5, len(months), 2)
)
</code></pre>
<p>To answer the further questions in comment:</p>
<ul>
<li><p>Normal slice won't work on <code>itertools.izip</code>, since it does not support the <code>__getitem__</code> method.</p></li>
<li><p>Yes, <code>itertools.izip</code> was removed from Python 3, and the regular builtin <code>zip</code> works with the same generator semantics.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow"><code>itertools.islice()</code></a> + <code>enumerate()</code>, to select elements with original indices:</p>
<pre><code>&gt;&gt;&gt; import calendar
&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; for i, month in islice(enumerate(calendar.month_abbr), 6, None, 2):
...     print(i, month)
... 
6 Jun
8 Aug
10 Oct
12 Dec
</code></pre>
<p>It does not duplicate the slice information and uses existing functions with familiar behavior.</p>
<p>Or if you know that the original iterable is small; you could call <code>list()</code>:</p>
<pre><code>&gt;&gt;&gt; list(enumerate(calendar.month_abbr))[6::2]
[(6, 'Jun'), (8, 'Aug'), (10, 'Oct'), (12, 'Dec')]
</code></pre>
</div>
<span class="comment-copy">Your answer is pythonic and readable enough.</span>
<span class="comment-copy">How about <code>i*step+offset</code>? Should also give you the desired indices...</span>
<span class="comment-copy">You could avoid repeating yourself by having <code>_enumerate</code> do the slicing as well (ie call it as <code>_enumerate(month, offset=5, step=2</code>), but that would require <code>months</code> to be a list in order to be efficient.</span>
<span class="comment-copy">@swenzel: Where do you  insert <code>index * step + offset</code>?</span>
<span class="comment-copy">Wherever you need your "real" index. E.g. <code>print(index*2+5, element)</code> with the normal enumerate will also give you "5 June", "7 August"... Or you could put <code>index = index*step+offset</code> as first line in your loop.</span>
<span class="comment-copy">Nice solution. Very readable and easy to understand in my opinion :) Thanks :D</span>
<span class="comment-copy">Thanks for your answer :) But it's the question if your solution is more readable than a generator for instance ...</span>
<span class="comment-copy">It would probably be more readable with some assignments and a normal loop instead of being rolled into a one-liner, but I think the basic concept is okay.</span>
<span class="comment-copy">Yes, you're right :) You could add the "normal loop" (loop and print statement separated) to your answer if you feel like it :D</span>
<span class="comment-copy">@elegent - Good idea; added.</span>
<span class="comment-copy">Thanks :) But why should we use <code>islice</code> form <code>itertools</code> instead of a "normal" slice? And as far as I know <code>izip</code> is <code>zip</code> in Python 3.x. You cloud add this information to your answer.</span>
