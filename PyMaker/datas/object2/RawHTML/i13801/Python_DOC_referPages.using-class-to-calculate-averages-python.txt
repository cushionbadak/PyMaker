<div class="post-text" itemprop="text">
<p>I'm reading data from a range of air quality monitors using python. </p>
<p>At the moment I'm doing following to calculate averages. I figured there must be a better way to do this using a class, because most of the code repeats itself, to make this more generally applicable and efficient. </p>
<p>The other problem is I have a number of different types of monitors, which largely operate on the same principle but have slightly different variables. The code given below is a real nightmare to move across to a new monitor because I have to edit every line. </p>
<p>Trouble is when I search about class and averaging, all I seem to get is averaging students grades in a class at school rather than using a software class to calculate averages from multiple variables.</p>
<p>Basically the monitor makes one reading a second, but I only want 1 minute averages, so I churn thru following until minute rolls over. </p>
<p>Any suggestions gratefully received. </p>
<p>Currently I'm doing this:</p>
<pre><code>while minute unchanged:
    ## read serial port

    readData = SER.read()  

    ## Split comma delimited data into dust, flow, temperature, relative humidity, pressure
    ## for example data comes in as 000.007,2.0,+21.7,046,1010.0
    measData = readData[0].split(',')           
    dustReading = measData[0].strip()                       

    flowReading = measData[1]
    flowReading = flowReading.strip()

    tempReading = measData[2]
    tempReading = tempReading.strip()

    rhReading = measData[3]
    rhReading = rhReading.strip()

    pressReading = measData[4]
    pressReading = pressReading.strip()


    ######### Dust #######

    try :   
        nReading = nReading+1   
        dustReading = float(dustReading)
        sumDustReading = sumDustReading + dustReading
        meanDustReading = sumReading/float(nReading)            
    except :
         pass       

    ####### Flow ##########
    try :   
        flowReading = float(flowReading)
        sumFlowReading = sumFlowReading+flowReading
        meanFlowReading = float(sumFlowReading)/float(nReading)
    except :
         pass                       

    ######## Temperature #########
    try:    
        tempReading = float(tempReading)
        sumTempReading = sumTempReading+tempReading
        meanTempReading = float(sumTempReading)/float(nReading)
    except :
         pass

    ######### RH ########
    try :   
        rhReading = float(rhReading)
        sumRhReading = sumRhReading+rhReading
        meanRhReading = float(sumRhReading)/float(nReading)
    except :
         pass       

    ###### Pressure Reading ######
    try :   
        pressReading = float(pressReading)
        sumPressReading = sumPressReading+pressReading
        meanPressReading = float(sumPressReading)/float(nReading)               
    except :
        pass
</code></pre>
<p>Ideally I want to be able to get something like </p>
<pre><code>flow.mean
flow.numberOfReads
flow.sum
</code></pre>
<p>Thanks a million. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your existing code is a bit strange &amp; dangerous with all those <code>try:...except</code> blocks. It's dangerous because it ignores all sorts of errors that really should <strong>not</strong> be ignored. For example: attempting to use the value of an undefined variable, division by zero errors, and outright syntax errors.</p>
<hr/>
<p>You <em>can</em> do what you want with a class, but for something like this I'd be more likely to use a simple <code>dict</code>. I'll post code for both approaches to help you decide (or to add to your confusion :) ). </p>
<p>Obviously I don't have your monitoring hardware connected to my serial port, so in order to test this code I wrote a simple generator function that creates random fake data. Hopefully, it will be easy enough for you to modify my code.</p>
<p>First, the code that uses a class which holds the current total and the number of readings; this class also has a property that calculates the mean on demand. So you can do things like <code>print dust.total, flow.mean</code>, if you want to. </p>
<pre><code>from random import seed, random

#A generator to make simulated data
def fake_data(n):
    for i in range(n):
        d = 0.005 + 0.005 * random()
        f = 1.5 + random()
        t = 20.0 + 5.0 * random()
        h = int(40 + 10.0 * random())
        p = 1005.0 + 10.0 * random()

        s = '%07.3f,%3.1f,%-4.1f,%03d,%6.1f' % (d, f, t, h, p)
        yield [s]


class Data(object):
    def __init__(self, name):
        self.name = name
        self.total = 0
        self.numberOfReads = 0

    def __repr__(self):
        fmt = "Data(name='%s', total=%f, number=%d, mean=%f)"
        return fmt % (self.name, self.total, self.numberOfReads, self.mean)

    def __str__(self):
        fmt = '%s\nmean: %f\nnumber: %d\ntotal: %f\n'
        return fmt % (self.name, self.mean, self.numberOfReads, self.total)

    def add(self, value):
        self.total += value
        self.numberOfReads += 1

    @property
    def mean(self):
        try:
            return float(self.total) / float(self.numberOfReads)
        except ZeroDivisionError:
            return None


#Seed the randomiser
seed(1)

#Initialise the Data instances
dust = Data('Dust')
flow = Data('Flow')
temp = Data('Temperature')
rh = Data('Relative Humidity')
press = Data('Pressure')

for readData in fake_data(10):
    ## Split comma delimited data into dust, flow, temperature, relative humidity, pressure
    ## for example data comes in as 000.007,2.0,+21.7,046,1010.0
    print readData
    measData = readData[0].split(',')

    #Convert data strings to floats
    dustR, flowR, tempR, rhR, pressR = [float(s) for s in measData]

    #Add new data to current totals
    dust.add(dustR)
    flow.add(flowR)
    temp.add(tempR)
    rh.add(rhR)
    press.add(pressR)

print

for a in (dust, flow, temp, rh, press):
    print a
</code></pre>
<p><strong>output</strong></p>
<pre><code>['000.006,2.3,23.8,042,1010.0']
['000.007,2.2,23.9,040,1005.3']
['000.009,1.9,23.8,040,1009.5']
['000.009,1.7,24.7,049,1005.3']
['000.005,2.0,24.7,043,1007.2']
['000.007,1.5,21.1,044,1010.0']
['000.006,1.7,21.1,044,1007.9']
['000.005,2.3,22.8,046,1006.9']
['000.010,2.4,20.6,043,1012.2']
['000.009,2.4,22.1,048,1011.7']

Dust
mean: 0.007300
number: 10
total: 0.073000

Flow
mean: 2.040000
number: 10
total: 20.400000

Temperature
mean: 22.860000
number: 10
total: 228.600000

Relative Humidity
mean: 43.900000
number: 10
total: 439.000000

Pressure
mean: 1008.600000
number: 10
total: 10086.000000
</code></pre>
<hr/>
<p>And here's the version using a <code>dict</code>. I've set the randomiser seed to the same value so that the fake data's the same as in the previous version.</p>
<pre><code>from random import seed, random

#A generator to make simulated data
def fake_data(n):
    for i in range(n):
        d = 0.005 + 0.005 * random()
        f = 1.5 + random()
        t = 20.0 + 5.0 * random()
        h = int(40 + 10.0 * random())
        p = 1005.0 + 10.0 * random()

        s = '%07.3f,%3.1f,%-4.1f,%03d,%6.1f' % (d, f, t, h, p)
        yield [s]


#Seed the randomiser
seed(1)

#data field names
fields = ('Dust', 'Flow', 'Temp', 'rh', 'press')

#initialise the data dictionary 
data = dict.fromkeys(fields, 0.0)

nReading = 0
for readData in fake_data(10):
    nReading += 1

    ## Split comma delimited data into dust, flow, temperature, relative humidity, pressure
    ## for example data comes in as 000.007,2.0,+21.7,046,1010.0
    print nReading, readData
    measData = readData[0].split(',')

    #Convert data strings to floats
    floatData = [float(s) for s in measData]

    #Add new data to current totals
    for key, value in zip(fields, floatData):
        data[key] += value

print '\nNumber of readings = %d\n' % nReading
nReading = float(nReading)
for key in fields:
    total = data[key]
    mean = total / nReading
    print '%s\nmean: %f\ntotal: %f\n' % (key, mean, total)
</code></pre>
<p><strong>output</strong></p>
<pre><code>1 ['000.006,2.3,23.8,042,1010.0']
2 ['000.007,2.2,23.9,040,1005.3']
3 ['000.009,1.9,23.8,040,1009.5']
4 ['000.009,1.7,24.7,049,1005.3']
5 ['000.005,2.0,24.7,043,1007.2']
6 ['000.007,1.5,21.1,044,1010.0']
7 ['000.006,1.7,21.1,044,1007.9']
8 ['000.005,2.3,22.8,046,1006.9']
9 ['000.010,2.4,20.6,043,1012.2']
10 ['000.009,2.4,22.1,048,1011.7']

Number of readings = 10

Dust
mean: 0.007300
total: 0.073000

Flow
mean: 2.040000
total: 20.400000

Temp
mean: 22.860000
total: 228.600000

rh
mean: 43.900000
total: 439.000000

press
mean: 1008.600000
total: 10086.000000
</code></pre>
<hr/>
<p>Here's a simple example of using <code>try:... except</code> to validate input data.</p>
<pre><code>data = [
    '1.1 2.2 3.3',
    '4 5',
    '6 garbage bytes',
    '7 8 9 10',
    '11 12 13',
]

for i, line in enumerate(data):
    print '\nLine %d: %r' % (i, line)
    row = line.split()
    if len(row) != 3:
        print 'Bad row length. Should be 3 not', len(row)
        continue

    try:
        a, b, c = [float(s) for s in row]
    except ValueError as err:
        print 'Conversion error:', err
        continue

    print 'Data %d: a=%f, b=%f, c=%f' % (i, a, b, c)
</code></pre>
<p><strong>output</strong></p>
<pre><code>Line 0: '1.1 2.2 3.3'
Data 0: a=1.100000, b=2.200000, c=3.300000

Line 1: '4 5'
Bad row length. Should be 3 not 2

Line 2: '6 garbage bytes'
Conversion error: invalid literal for float(): garbage

Line 3: '7 8 9 10'
Bad row length. Should be 3 not 4

Line 4: '11 12 13'
Data 4: a=11.000000, b=12.000000, c=13.000000
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you keep the data in <em>lists</em>, it is easier to calculate the average and other statistical properties. And things like the length of the list and the sum are built-ins.</p>
<p>So first make some lists.</p>
<pre><code>dust, flow, temp, rh, pressure = [], [], [], [], []
</code></pre>
<p>I'll use the following data as an example.</p>
<pre><code>readData = '000.007,2.0,+21.7,046,1010.0'
</code></pre>
<p>Let's split that up;</p>
<pre><code>newdust, newflow, newtemp, newrh, newpressure = [float(n) for n in readData.split(',')]
dust.append(newdust)
...
pressure.append(newpressure)
</code></pre>
<p>To calculate the average:</p>
<pre><code>sum(pressure)/len(pressure)
</code></pre>
<p><strong>Update</strong>:</p>
<p>It is hard to give a recommendation for handling different kinds of instruments without seeing the data they generate.</p>
<p>You could for instance write a data translation function for each different kind of sensor, that reads a line from the serial port and returns a <code>tuple</code> or <code>namedtuple</code> of data, with measurements that are not supported by a particular device as <code>None</code>.
Assuming you <em>know</em> which sensor you are connected to you could then pick the right function to call at the beginning of the program;</p>
<pre><code>from collections import namedtuple

Instrumentrecord = namedtuple('Instrumentrecord',
                              ['dust', 'flow', 'temp', 'humidity', 
                               'pressure', 'windspeed', 'winddir'])

def foo_sensor(dataline):
    dust, flow, temp, rh, pressure = [float(n) for n in dataline.split(',')]
    return Instrumentrecord(dust, flow, temp, rh, pressure, None, None)


def main(argv):
    ....
    if sensortype == 'foo':
        current_sensor = foo_sensor
    ...
    data = []
    while keep_going:
        line = SER.read()
        data.append(current_sensor(line))
</code></pre>
</div>
<span class="comment-copy">you might want to consider this module <a href="https://docs.python.org/3/library/statistics.html" rel="nofollow noreferrer">docs.python.org/3/library/statistics.html</a> .</span>
<span class="comment-copy">what are you doing with  <code>sumDustReading</code>,<code>meanDustReading</code> etc..? Where are they first defined?</span>
<span class="comment-copy">@PadraicCunningham: My guess is that the various <code>sumxxxReading</code> fields are initialised before the start of the <code>while</code> loop. I also assume that <code>while minute unchanged:</code> is semi-pseudocode, and there's other stuff in the unposted code that does stuff relating to time measurements. But of course I could be totally wrong. :)</span>
<span class="comment-copy">Thanks hiro - unfortunately I don't have access to statistics. My embedded python hardware only has a few selected modules.</span>
<span class="comment-copy">Thanks Padraic - yes PM 2Ring is right. Defiend before loop - I didn't want to post acres of code.</span>
<span class="comment-copy">Thanks for all this. Much appreciated. I'll try it and see how we go. I put those 'try...' 'except...' things in because monitors are not very reliable in output. About 1 reading in 100 is corrupt or partially corrupt with random garbage coming out, which used to cause all sorts of headaches and data type errors when I converted to float etc.</span>
<span class="comment-copy">@bartman10: No worries. <code>try:.. except</code> can be very useful for validating input, but you should 1) minimize the code in the <code>try:</code> block,  2) use named exceptions because a bare <code>except</code> catches too much. I'll add a small example to my answer.</span>
<span class="comment-copy">Thanks for that Ronald. A good suggestion, but I'm not sure it helps me that much in terms of portability between instruments. (Which have different outputs, but are largely the same).</span>
<span class="comment-copy">@bartman10 See updated answer. Different "translation" functions for each instrument are a possible solution.</span>
