<div class="post-text" itemprop="text">
<p>I wrote a decorator called <code>apply_first</code> that sets the first argument of the decorated function. Unfortunately this decorator has the wrong signature. Any way around this? I usually use <code>decorator</code> to preserve signature, but this time, I'd like to change it.</p>
<pre><code>def apply_first(x):
    def decorate(f):
        def g(*args):
            return f(*((x,) + args))
        return g
    return decorate

@apply_first(5)
def add(x,y):
    return x+y

print(add(3))
# prints 8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A better solution:</p>
<p>I ended up writing a decorator that fixes decorators that decorate away the first argument</p>
<pre><code>import decorator
import sys

def wrapper_string(pre_decor):
    argspec = decorator.getfullargspec(pre_decor)
    if len(argspec.args) == 0:
        raise TypeError("Couldn't find a first argument to decorate away.")
    allargs = list(argspec.args[1:])
    allshortargs = list(argspec.args[1:])

    if argspec.varargs:
        allargs.append('*' + argspec.varargs)
        allshortargs.append('*' + argspec.varargs)
    elif argspec.kwonlyargs:
        allargs.append('*')  # single star syntax
    for a in argspec.kwonlyargs:
        allargs.append('%s=None' % a)
        allshortargs.append('%s=%s' % (a, a))
    if argspec.varkw:
        allargs.append('**' + argspec.varkw)
        allshortargs.append('**' + argspec.varkw)

    head = "def " + pre_decor.__name__ + "(" + ', '.join(allargs) + "):"
    body = "    return _decorator_(_func_)("+ ', '.join(allshortargs) +")"
    return head + "\n" + body

def update_signature(pre_decor, post_decor, **kw):
    "Update the signature of post_decor with the data in pre_decor"
    post_decor.__name__ = pre_decor.__name__
    post_decor.__doc__ = getattr(pre_decor, '__doc__', None)
    post_decor.__dict__ = getattr(pre_decor, '__dict__', {})
    argspec = decorator.getfullargspec(pre_decor)
    if len(argspec.args) == len(argspec.defaults):
        pos = 1
    else:
        pos = 0
    post_decor.__defaults__ = getattr(pre_decor, '__defaults__', ())[pos:]
    post_decor.__kwdefaults__ = getattr(pre_decor, '__kwdefaults__', None)
    #post_decor.__annotations__ = getattr(pre_decor, '__annotations__', None)
    try:
        frame = sys._getframe(3)
    except AttributeError:  # for IronPython and similar implementations
        callermodule = '?'
    else:
        callermodule = frame.f_globals.get('__name__', '?')
    post_decor.__module__ = getattr(pre_decor, '__module__', callermodule)
    post_decor.__dict__.update(kw)

@decorator.decorator
def decorate_first_arg(dec, pre_decor):
    evaldict = pre_decor.__globals__.copy()
    evaldict['_decorator_'] = dec
    evaldict['_func_'] = pre_decor
    wrapper = compile(wrapper_string(pre_decor), "&lt;string&gt;", "single")
    exec(wrapper, evaldict)
    post_decor = evaldict[pre_decor.__name__]
    update(pre_decor, post_decor)
    return post_decor
</code></pre>
<p>Almost all of the code was copied and appropriately modified from Michele Simionato's <code>decorator</code> module (<a href="https://github.com/micheles/decorator/blob/master/src/decorator.py" rel="nofollow">GitHub</a>).</p>
<p>With this, the example above can be fixed as:</p>
<pre><code>@decorate_first_arg
def apply_first(x):
    def decorate(f):
        def g(*args):
            return f(*((x,) + args))
        return g
    return decorate
</code></pre>
</div>
<span class="comment-copy">What do you mean <i>"wrong signature"</i>? What were you <i>expecting</i> the resulting signature to be (if not <code>*args</code>, why not)?</span>
<span class="comment-copy">I wasn't expecting it to be any different to <code>*args</code>, but I would like it to be <code>(y)</code>. As I mention in my post, the <code>decorator</code> module takes care of this for you normally.</span>
<span class="comment-copy">Ah, I'm afraid you can't do that. Note that what you're writing is more-or-less <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>, and <code>functools.wraps</code> preserves signatures from 3.4 onwards.</span>
<span class="comment-copy">Or perhaps you can, although it isn't neat or easy - see e.g. <a href="http://stackoverflow.com/a/1409496/3001761">stackoverflow.com/a/1409496/3001761</a></span>
<span class="comment-copy">Might be able to do it with <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.bind" rel="nofollow noreferrer"><code>inspect.Signature.bind</code></a> in python 3.4.</span>
