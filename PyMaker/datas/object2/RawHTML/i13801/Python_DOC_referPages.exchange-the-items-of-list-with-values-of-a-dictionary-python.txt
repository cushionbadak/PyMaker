<div class="post-text" itemprop="text">
<p>I have a list of dictionaries like this</p>
<pre><code>data = [
    {
        "B3": 0.9500000000000000
    },
    {
        "C3": 0.9000000000000000
    },
    {
        "D3": 0.8900000000000000
    },
    {
        "E3": 0.8800000000000000
    },
    {
        "F3": 0.8700000000000000
    },
    {
        "G3": 0.8600000000000000
    },
    {
        "H3": 0.8500000000000000
    },
    {
        "I3": 0
    },
    {
        "J3": 0
    },
    {
        "K3": 0
    },
    {
        "L3": 0
    },
    {
        "M3": 0
    }
]
</code></pre>
<p>and driver dictionary like this</p>
<pre><code>driver = {
    1: [600.0, 625.0, 700.0, 650.0, 660.0, 800.0, 675.0, 650.0, 600.0, 700.0, 690.0, 750.0],
    2: [580.0, 607.0, 685.0, 626.0, 640.0, 770.0, 665.0, 639.0, 595.0, 665.0, 675.0],
    3: [560.0, 589.0, 670.0, 602.0, 620.0, 740.0, 655.0, 628.0, 590.0, 630.0],
    4: [540.0, 571.0, 655.0, 578.0, 600.0, 710.0, 645.0, 617.0, 585.0],
    5: [520.0, 553.0, 640.0, 554.0, 580.0, 680.0, 635.0, 606.0],
    6: [500.0, 535.0, 625.0, 530.0, 560.0, 650.0, 625.0],
    7: [480.0, 517.0, 610.0, 506.0, 540.0, 620.0],
    8: [460.0, 499.0, 595.0, 482.0, 520.0],
    9: [440.0, 481.0, 580.0, 458.0],
    10: [420.0, 463.0, 565.0],
    11: [400.0, 445.0],
    12: [380.0]
}
</code></pre>
<p>I need to map the keys of each data dictionary inside the list with the value of driver dict. </p>
<p>The sample output would look like this</p>
<pre><code>{
    'B3': [600.0, 625.0, 700.0, 650.0, 660.0, 800.0, 675.0, 650.0, 600.0, 700.0, 690.0, 750.0],
    'C3': [580.0, 607.0, 685.0, 626.0, 640.0, 770.0, 665.0, 639.0, 595.0, 665.0, 675.0]
}
</code></pre>
<p>and so on.</p>
<p>My approach was to first convert the list of dictionaries into list of keys and then iterate thro' each item in driver dict and pop the item and replace it with the key from the new list.</p>
<pre><code>from collections import Iterable

k_list = []
for item in data:
    k_list.append(list(item.keys()))

print(k_list)


def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x


x = list(flatten(k_list))
print(x)

nn = {}
for k, v in driver.items():
    for i in x:
        nn[i] = v

print(nn)
</code></pre>
<p>This gives me the output like this</p>
<pre><code>{'L3': [380.0], 'C3': [380.0], 'D3': [380.0], 'E3': [380.0], 'G3': [380.0], 'M3': [380.0], 'B3': [380.0], 'I3': [380.0], 'F3': [380.0], 'H3': [380.0], 'K3': [380.0], 'J3': [380.0]}
</code></pre>
<p>Where i am doing it wrong?</p>
<p><strong>NOTE:</strong> The ordering is important i.e <code>B3</code> of data dict should match with <code>1</code> of driver dict and so on.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, instead of just using <code>driver.items()</code> you should use <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow"><code>sorted</code></a> to make sure that the items are in the right order (they <em>should</em> be sorted anyways, but there is no guarantee for that). Then, instead of using nested loops, you should <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> the keys and driver data. Finally, to make sure that the resulting dict is ordered (if this is important), use an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>OrderedDict</code></a>.</p>
<pre><code>k_list = [k for item in data for k in item.keys()]
nn = collections.OrderedDict()
for k, (n, v) in zip(k_list, sorted(driver.items())):
    nn[k] = v
</code></pre>
<p>The problem with your nested-loops approach is that you overwrite <em>all the keys</em> with the last value in the final iteration.</p>
</div>
<span class="comment-copy">Are the keys in the drivers dict always numbers from 1 to n and ordered?</span>
<span class="comment-copy"><code>{next(iter(data_item)): driver[driver_key] for data_item, driver_key in zip(data, sorted(driver))}</code></span>
<span class="comment-copy">@tobias_k Yeah, they are always ordered.</span>
<span class="comment-copy"><code>{next(iter(data_item)): driver[i] for i, data_item in enumerate(data, 1)}</code> if <code>drivers</code>'s keys are always <code>1</code> to <code>n</code></span>
