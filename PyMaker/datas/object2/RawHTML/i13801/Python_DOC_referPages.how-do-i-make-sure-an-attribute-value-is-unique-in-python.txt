<div class="post-text" itemprop="text">
<p>I'm scraping a website that contains a list of people. The same person can show up more than once and it's possible for multiple people to share the same name:</p>
<pre><code>Tommy Atkins (id:312)
Tommy Atkins (id:183)
Tommy Atkins (id:312)
</code></pre>
<p>I want to create an object for each person and discard duplicates.</p>
<p>I'm currently using a list comprehension to loop through all class instances and see if <code>key</code> is already in use. Is there a simpler way of doing it?</p>
<pre><code>class Object:
    def __init__(self, key):
        if [object for object in objects if object.key == key]:
            raise Exception('key {} already exists'.format(key))
        else: self.key = key

objects = []
objects.append(Object(1))
objects.append(Object(1)) # Exception: key 1 already exists
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Define <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow"><code>__hash__</code></a> in your class, compare the instances based on the value of <code>key</code> and calculate hash using it as well. And instead of a list use <code>set</code> as it will automatically filter the duplicates for you in an efficient way:</p>
<pre><code>class Object:
    def __init__(self, key):
        self.key = key

    def __eq__(self, other):
        if isinstance(other, type(self)):
            return self.key == other.key 
        return NotImplemented

    def __ne__(self, other):
        return not type(self).__eq__(self, other)

    def __hash__(self):
        return hash(self.key)


objects = set()
o1 = Object(1)
o2 = Object(1)
objects.add(o1)
objects.add(o2)

print (o1, o2)   # &lt;__main__.Object object at 0x105996ba8&gt; &lt;__main__.Object object at 0x105996be0&gt;
print (objects)  # {&lt;__main__.Object object at 0x105996ba8&gt;}
</code></pre>
<p>Don't assign the instances permanently to a variable, otherwise it won't be garbage collected(Note that this is true only for CPython):</p>
<pre><code>objects = set()

for _ in range(5):
    ins = Object(1)
    print(id(ins))
    objects.add(ins)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>4495640448 # First instance and this is now stored in the set
           # hence it is not going to be garbage collected. 
4495640840 # Python is now using new memory space.
4495640896 # Right now 4495640840 is still owned by the 
           # previous instance, hence use new memory address
           # But after this assignment the instance at 4495640840 
           # has no more references, i.e ins now points to 4495640896
4495640840 # Re-use 4495640840
4495640896 # Repeat...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Global storage for your ids is fine, but its better to leverage <code>set</code> instead of <code>list</code> for that, as checking <code>i in {}</code> is O(1) while <code>i in []</code> is O(N)</p>
</div>
<span class="comment-copy">Is there no way to prevent instantiation if the key is already in use? I'm not familiar with memory management in Python, but creating all these objects seems wasteful.</span>
<span class="comment-copy">@fenceop Don't assign the instance to any variable, any object with no reference left will be automatically garbage collected.</span>
