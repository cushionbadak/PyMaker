<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/36932/how-can-i-represent-an-enum-in-python">How can I represent an 'Enum' in Python?</a>
<span class="question-originals-answer-count">
                    43 answers
                </span>
</li>
</ul>
</div>
<p>I would like to create an Enum class in python. I need also some get_str() method, something like:</p>
<pre><code>class Operation (object):
    START = 0
    STOP = 1
    (...)

    def get_str(self):
        operation_dispatcher = {
             Operation.START: "start", 
             Operation.STOP: "stop",
             (...)

             }
    return operation_dispatcher[self]
</code></pre>
<p>But unfortunately that approach doesn't work. The objects are ints and I got error message that 'int' object has no attribute 'get_str'... Do you have any idea how to implement that functionality?</p>
<p>I tried to do something like:</p>
<p><i>Operation.get_str(operation_reference)</i> as well as <i>operation_reference.get_str()</i></p>
<p>UPDATE:</p>
<pre><code>class EnumMeta(type):
    def __getattribute__(self, name):
        return self(super(EnumMeta, self).__getattribute__(name))

class Enum(object):
    __metaclass__ = EnumMeta

    def __init__(self, value):
        super(Enum, self).__init__()

        self.value = value[0]
        self.repr = value[1]

    def __eq__(self, other):
        if isinstance(other, Enum):
            return self.value == other.value
        elif isinstance(other, int):
            return self.value == other
        else:
            return object.__eq__(Enum, other)

    def __repr__(self):
        return str(self.repr)

class Operation(Enum):
    START = (0, "start")
    STOP = (1, "stop")
    (...)

operation_dispatcher = {
             Operation.START: start_method, 
             Operation.STOP: stop_method,
             (...) }

# invoking
operation_dispatcher[Operation.START.value]()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend to achieve you goal using metaclasses, in order to minimise the client code. So first of all checkout the below metaclass:</p>
<pre><code>class EnumMeta(type):
    def __getattribute__(self, name):
        actual_value = super(EnumMeta, self).__getattribute__(name)
        if isinstance(actual_value, self):
            return actual_value
        else:
            new_value = self(actual_value)
            super(EnumMeta, self).__setattr__(name, new_value)
            return new_value
</code></pre>
<p>It simply overrides the <code>__getattribute__</code> and returns an instance of the child class using the attributes value as the constructor argument. Also it updates the original value, in order not to create a new instance every time, and besides to make equality check using the reference of the object</p>
<p>Then define an <code>Enum</code> class like this:</p>
<pre><code>class Enum(object):
    __metaclass__ = EnumMeta

    def __init__(self, value):
        super(Enum, self).__init__()

        self.value = value[0]
        self.repr = value[1]

    def __repr__(self):
        return str(self.repr)
</code></pre>
<p>This base class implements equals (<code>==</code>) operator, to compare using the int value, and <code>__repr__</code> method, to return the string representation of your enum. So here you go:</p>
<pre><code>class Operation(Enum):
    START = (0, "start")
    STOP = (1, "stop")

&gt;&gt;&gt; Operation.START == Operation.START
True
&gt;&gt;&gt; Operation.START is Operation.START
True
&gt;&gt;&gt; Operation.START == Operation.STOP
False
&gt;&gt;&gt; Operation.START
"start"
&gt;&gt;&gt; repr(Operation.STOP)
"stop"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>Enum</code>s in Python are either:</p>
<ul>
<li>built-in as of Python 3.4</li>
<li>available as a <a href="https://pypi.python.org/pypi/enum34" rel="nofollow">backport</a> for Python 3.3 down to Python 2.4</li>
<li>available in an <a href="https://pypi.python.org/pypi/aenum" rel="nofollow">enhanced library</a> which also includes a class-based <code>NamedTuple</code> and a <code>Constant</code> class</li>
</ul>
<p>Using that your code would look like:</p>
<pre><code>from aenum import IntEnum   # or from enum import IntEnum

class Operation(IntEnum):
    START = 0
    STOP = 1

&gt;&gt;&gt; Operation.START
&lt;Operation.START: 0&gt;

&gt;&gt;&gt; Operation['START']
&lt;Operation.START: 0&gt;

&gt;&gt;&gt; Operation(0)
&lt;Operation.START: 0&gt;

&gt;&gt;&gt; Operation.STOP is Operation.STOP
True

&gt;&gt;&gt; list(Operation)
[&lt;Operation.START: 0&gt;, &lt;Operation.STOP: 1&gt;]

&gt;&gt;&gt; Operation.STOP.name
'STOP'

&gt;&gt;&gt; Operation.STOP.value
1
</code></pre>
</div>
<span class="comment-copy">Just to let you know: If you are using Python 3.4, you are reinventing the wheel. <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">docs.python.org/3/library/enum.html</a></span>
<span class="comment-copy">See <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code></a> if using python 2.</span>
<span class="comment-copy">What if I have dictionary with those enums and I would like to get value according to the key? f.g. get = dictionary[Operation.START]. The equals operator is not invoked and python cannot find a key...</span>
<span class="comment-copy">You are right, in that case you can go this way: <code>dictionary[Operation.START.value]</code></span>
<span class="comment-copy">That's what I thought, but I still got a KeyError...</span>
<span class="comment-copy">the <code>value</code> is <code>int</code>, so you should not get the error. Can you post a little more code on that?</span>
<span class="comment-copy">Sure :) I have updated my question with a code</span>
