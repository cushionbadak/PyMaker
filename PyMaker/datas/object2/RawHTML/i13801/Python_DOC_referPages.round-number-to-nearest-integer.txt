<div class="post-text" itemprop="text">
<p>I've been trying to round long float numbers like:</p>
<pre><code>32.268907563;
32.268907563;
31.2396694215;
33.6206896552;
...
</code></pre>
<p>With no success so far. I tried <code>math.ceil(x)</code>, <code>math.floor(x)</code> (although that would round up or down, which is not what I'm looking for) and <code>round(x)</code> which didn't work either (still float numbers).</p>
<p>What could I do?</p>
<p>EDIT: CODE:</p>
<pre><code>for i in widthRange:
    for j in heightRange:
        r, g, b = rgb_im.getpixel((i, j))
        h, s, v = colorsys.rgb_to_hsv(r/255.0, g/255.0, b/255.0)
        h = h * 360
        int(round(h))
        print(h)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>int(round(x))
</code></pre>
<p>Will round it and change it to integer</p>
<p>EDIT:</p>
<p>You are not assigning int(round(h)) to any variable. When you call int(round(h)), it returns the integer number but does nothing else; you have to change that line for:</p>
<pre><code>h = int(round(h))
</code></pre>
<p>To assign the new value to h</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>round(x, y)</code>. It will round up your number up to your desired decimal place.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; round(32.268907563, 3)
32.269
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>round(value,significantDigit)</code> is the ordinary solution, however this does not operate as one would expect from a math perspective when round values ending in <code>5</code>.  If the <code>5</code> is in the digit just after the one you're rounded to, these values are only sometimes rounded up as expected (i.e. <code>8.005</code> rounding to two decimal digits gives <code>8.01</code>).  For certain values due to the quirks of floating point math, they are rounded down instead!</p>
<p>i.e.</p>
<pre><code>&gt;&gt;&gt; round(1.0005,3)
1.0
&gt;&gt;&gt; round(2.0005,3)
2.001
&gt;&gt;&gt; round(3.0005,3)
3.001
&gt;&gt;&gt; round(4.0005,3)
4.0
&gt;&gt;&gt; round(1.005,2)
1.0
&gt;&gt;&gt; round(5.005,2)
5.0
&gt;&gt;&gt; round(6.005,2)
6.0
&gt;&gt;&gt; round(7.005,2)
7.0
&gt;&gt;&gt; round(3.005,2)
3.0
&gt;&gt;&gt; round(8.005,2)
8.01
</code></pre>
<p>Weird.</p>
<p>Assuming your intent is to do the traditional rounding for statistics in the sciences, this is a handy wrapper to get the <code>round</code> function working as expected needing to <code>import</code> extra stuff like <code>Decimal</code>.</p>
<pre><code>&gt;&gt;&gt; round(0.075,2)

0.07

&gt;&gt;&gt; round(0.075+10**(-2*5),2)

0.08
</code></pre>
<p>Aha! So based on this we can make a function...</p>
<pre><code>def roundTraditional(val,digits):
   return round(val+10**(-len(str(val))-1), digits)
</code></pre>
<p>Basically this adds a value guaranteed to be smaller than the least given digit of the string you're trying to use <code>round</code> on. By adding that small quantity it preserve's <code>round</code>'s behavior in most cases, while now ensuring if the digit inferior to the one being rounded to is <code>5</code> it rounds up, and if it is <code>4</code> it rounds down.</p>
<p>The approach of using <code>10**(-len(val)-1)</code> was deliberate, as it the largest small number you can add to force the shift, while also ensuring that the value you add never changes the rounding even if the decimal <code>.</code> is missing.  I could use just <code>10**(-len(val))</code> with a condiditional <code>if (val&gt;1)</code> to subtract <code>1</code> more... but it's simpler to just always subtract the <code>1</code> as that won't change much the applicable range of decimal numbers this workaround can properly handle.  This approach will fail if your values reaches the limits of the type, this will fail, but for nearly the entire range of valid decimal values it should work.</p>
<p>You can also use the <a href="https://docs.python.org/3/library/decimal.html" rel="noreferrer">decimal</a> library to accomplish this, but the wrapper I propose is simpler and may be preferred in some cases.</p>
<hr/>
<p><strong>Edit:</strong> Thanks <a href="https://stackoverflow.com/users/1405065/blckknght">Blckknght</a> for pointing out that the <code>5</code> fringe case occurs only for certain values.  Also an earlier version of this answer wasn't explicit enough that the odd rounding behavior <em>occurs only when the digit immediately inferior to the digit you're rounding to has a <code>5</code></em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For positives, try</p>
<pre><code>int(x + 0.5)
</code></pre>
<p>To make it work for negatives too, try</p>
<pre><code>int(x + (0.5 if x &gt; 0 else -0.5))
</code></pre>
<p><code>int()</code> works like a floor function and hence you can exploit this property. This is definitely the fastest way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Isn't just Python doing <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even" rel="noreferrer">round half to even</a>, as prescribed by <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" rel="noreferrer">IEEE 754</a>?</p>
<p>Be careful redefining, or using "non-standard" roundingâ€¦</p>
<p>(See also <a href="https://stackoverflow.com/a/33019948/109839">https://stackoverflow.com/a/33019948/109839</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use numpy assuming if you are using python3.x here is an example</p>
<pre><code>import numpy as np
x = 2.3
print(np.rint(x))
&gt;&gt;&gt; 2.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need (for example) a two digit approximation for A, then 
<code>int(A*100+0.5)/100.0</code> will do what you are looking for.</p>
<p>If you need three digit approximation multiply and divide by 1000 and so on.</p>
</div>
<div class="post-text" itemprop="text">
<p>For this purpose I would suggest just do the following thing - </p>
<pre><code>int(round(x))
</code></pre>
<p>This will give you nearest integer.</p>
<p>Hope this helps!!</p>
</div>
<span class="comment-copy">I would try <code>int(x)</code></span>
<span class="comment-copy">print("4.5)", int(round(4.5)))   # gave me 4     print("5.5)", int(round(5.5)))   # gave me 6    :,(</span>
<span class="comment-copy">It's related to the Python version. It gives me 5 and 6 using Python 2.7.9 and, as you said, 4 and 6 using Python 3.4.2</span>
<span class="comment-copy">Hmm.... it would be nice if the round function didn't convert ints to floats.</span>
<span class="comment-copy">I'm not sure why you think decimals with <code>5</code> as their last digit will always round down. That's not the case in a quick test I just did with numbers like <code>1.5</code>, <code>2.5</code>, <code>3.5</code> and so on and <code>1.05</code>, <code>1.15</code>, <code>1.25</code>, <code>1.35</code> rounding to one decimal place. The first set (exact halves rounding to small integers) always round to an even integer. The latter set do not round consistently, probably due to inexact binary representations of some of the values. The floats that have exact binary representations like <code>1.25</code> round to have an even least significant digit, but the others appear to round randomly.</span>
<span class="comment-copy">Interesting... you're right.  <code>round(4.0005,3)</code> gives <code>4.0</code> and <code>round(1.0005,3)</code> gives <code>1.0</code>, but <code>round(2.0005,3)</code> gives <code>2.001</code> and  <code>round(3.0005,3)</code> gives <code>3.001</code>.  But that's precisely why my proposed solution is necessary ... you don't know what to expect from the stock round, on this significant case!</span>
<span class="comment-copy">Thanks for this.  Your function will come in handy when this problem comes up.</span>
<span class="comment-copy">Did you mean to have <code>, digits</code> at end of that return statement? No pun intended. (<i>mean</i> I mean)</span>
<span class="comment-copy">Ah correct, indeed that should have been in there.  Good catch... surprised nobody else had noticed!  Will save those who utilize the solution some frustration. :-)</span>
<span class="comment-copy">doesn't work for negatives <code>&gt;&gt;&gt; x=-0.999</code> <code>&gt;&gt;&gt; int(x), round(x), int(x+0.5)</code> <code>(0, -1.0, 0)</code></span>
<span class="comment-copy">If you care about corner cases don't use the "add 0.5 and floor" technique - there are some values that may not round the way you expect! See <a href="https://stackoverflow.com/a/47302585/2732969">stackoverflow.com/a/47302585/2732969</a> for a C++ take and the <a href="https://stackoverflow.com/a/38744026/2732969">stackoverflow.com/a/38744026/2732969</a> answer in this very question.</span>
<span class="comment-copy"><a href="https://github.com/rbgirshick/py-faster-rcnn/issues/481" rel="nofollow noreferrer">github.com/rbgirshick/py-faster-rcnn/issues/481</a></span>
