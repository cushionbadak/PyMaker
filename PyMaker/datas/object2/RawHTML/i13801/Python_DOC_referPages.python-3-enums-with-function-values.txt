<div class="post-text" itemprop="text">
<p>I noticed an oddity in the Python 3 Enums (<a href="https://docs.python.org/3/library/enum.html" rel="noreferrer">link</a>).<br/>
If you set the value of an Enum to a function, it prevents the attribute from being wrapped as an Enum object, which prevents you from being able to use the cool features like <code>EnumCls['AttrName']</code> to dynamically load the attribute. </p>
<p>Is this a bug? Done on purpose?<br/>
I searched for a while but found no mention of restricted values that you can use in an Enum.</p>
<p>Here is sample code that displays the issue:</p>
<pre><code>class Color(Enum):
    Red = lambda: print('In Red')
    Blue = lambda: print('In Blue')

print(Color.Red)    # &lt;function&gt; - should be Color.Red via Docs
print(Color.Blue)   # &lt;function&gt; - should be Color.Bluevia Docs
print(Color['Red']) # throws KeyError - should be Color.Red via Docs
</code></pre>
<p>Also, this is my first time asking, so let me know if there's anything I should be doing differently! And thanks for the help!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/enum.html#allowed-members-and-attributes-of-enumerations" rel="noreferrer">The documentation</a> says:</p>
<blockquote>
<p>The rules for what is allowed are as follows: <code>_sunder_</code> names (starting and ending with a single underscore) are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of <code>__dunder__</code> names and descriptors (methods are also descriptors).</p>
</blockquote>
<p>A "method" is just a function defined inside a class body.  It doesn't matter whether you define it with <code>lambda</code> or <code>def</code>.  So your example is the same as:</p>
<pre><code>class Color(Enum):
    def Red():
        print('In Red')
    def Blue():
        print('In Blue')
</code></pre>
<p>In other words, your purported enum values are actually methods, and so won't become members of the Enum.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can wrap those lambdas in tuples and override the <code>__call__</code> method:</p>
<pre><code>class Color(Enum):
    red = (lambda text: '&lt;font color=red&gt;%s&lt;/font&gt;' % text,)
    blue = (lambda text: '&lt;font color=blue&gt;%s&lt;/font&gt;' % text,)

    def __call__(self, *args, **kwargs):
        return self.value[0](*args, **kwargs)
</code></pre>
<p>Can then be used:</p>
<pre><code>&gt;&gt;&gt; Color.red('flowers')
&lt;font color=red&gt;flowers&lt;/font&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If someone need/want to use Enum with functions as values, its possible to do so by using a callable object as a proxy, something like this:</p>
<pre><code>class FunctionProxy:
    """Allow to mask a function as an Object."""
    def __init__(self, function):
        self.function = function

    def __call__(self, *args, **kwargs):
        return self.function(*args, **kwargs)
</code></pre>
<p>A simple test:</p>
<pre><code>from enum import Enum
class Functions(Enum):
    Print_Function = FunctionProxy(lambda *a: print(*a))
    Split_Function = FunctionProxy(lambda s, d='.': s.split(d))

Functions.Print_Function.value('Hello World!')
# Hello World!
Functions.Split_Function.value('Hello.World.!')
# ['Hello', 'World', '!']
</code></pre>
</div>
<span class="comment-copy">It's annoying as this feels like a nice way to switch on functions, I guess perhaps you could define the enum and @singledispatch on the values, all these alternatives seem verbose...</span>
