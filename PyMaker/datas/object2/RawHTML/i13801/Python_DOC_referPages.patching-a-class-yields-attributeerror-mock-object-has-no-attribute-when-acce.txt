<div class="post-text" itemprop="text">
<p><strong>The Problem</strong><br/>
Using <code>mock.patch</code> with <code>autospec=True</code> to patch a class is not preserving attributes of instances of that class.</p>
<p><strong>The Details</strong><br/>
I am trying to test a class <code>Bar</code> that instantiates an instance of class <code>Foo</code> as a <code>Bar</code> object attribute called <code>foo</code>. The <code>Bar</code> method under test is called <code>bar</code>; it calls method <code>foo</code> of the <code>Foo</code> instance belonging to <code>Bar</code>. In testing this, I am mocking <code>Foo</code>, as I only want to test that <code>Bar</code> is accessing the correct <code>Foo</code> member:</p>
<pre><code>import unittest
from mock import patch

class Foo(object):
    def __init__(self):
        self.foo = 'foo'

class Bar(object):
    def __init__(self):
        self.foo = Foo()

    def bar(self):
        return self.foo.foo

class TestBar(unittest.TestCase):
    @patch('foo.Foo', autospec=True)
    def test_patched(self, mock_Foo):
        Bar().bar()

    def test_unpatched(self):
        assert Bar().bar() == 'foo'
</code></pre>
<p>The classes and methods work just fine (<code>test_unpatched</code> passes), but when I try to Foo in a test case (tested using both nosetests and pytest) using <code>autospec=True</code>, I encounter "AttributeError: Mock object has no attribute 'foo'"</p>
<pre><code>19:39 $ nosetests -sv foo.py
test_patched (foo.TestBar) ... ERROR
test_unpatched (foo.TestBar) ... ok

======================================================================
ERROR: test_patched (foo.TestBar)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/local/lib/python2.7/dist-packages/mock.py", line 1201, in patched
    return func(*args, **keywargs)
  File "/home/vagrant/dev/constellation/test/foo.py", line 19, in test_patched
    Bar().bar()
  File "/home/vagrant/dev/constellation/test/foo.py", line 14, in bar
    return self.foo.foo
  File "/usr/local/lib/python2.7/dist-packages/mock.py", line 658, in __getattr__
    raise AttributeError("Mock object has no attribute %r" % name)
AttributeError: Mock object has no attribute 'foo'
</code></pre>
<p>Indeed, when I print out <code>mock_Foo.return_value.__dict__</code>, I can see that <code>foo</code> is not in the list of children or methods:</p>
<pre><code>{'_mock_call_args': None,
 '_mock_call_args_list': [],
 '_mock_call_count': 0,
 '_mock_called': False,
 '_mock_children': {},
 '_mock_delegate': None,
 '_mock_methods': ['__class__',
                   '__delattr__',
                   '__dict__',
                   '__doc__',
                   '__format__',
                   '__getattribute__',
                   '__hash__',
                   '__init__',
                   '__module__',
                   '__new__',
                   '__reduce__',
                   '__reduce_ex__',
                   '__repr__',
                   '__setattr__',
                   '__sizeof__',
                   '__str__',
                   '__subclasshook__',
                   '__weakref__'],
 '_mock_mock_calls': [],
 '_mock_name': '()',
 '_mock_new_name': '()',
 '_mock_new_parent': &lt;MagicMock name='Foo' spec='Foo' id='38485392'&gt;,
 '_mock_parent': &lt;MagicMock name='Foo' spec='Foo' id='38485392'&gt;,
 '_mock_wraps': None,
 '_spec_class': &lt;class 'foo.Foo'&gt;,
 '_spec_set': None,
 'method_calls': []}
</code></pre>
<p>My understanding of autospec is that, if True, the patch specs should apply recursively. Since foo is indeed an attribute of Foo instances, should it not be patched? If not, how do I get the Foo mock to preserve the attributes of Foo instances?</p>
<p><strong>NOTE:</strong><br/>
This is a trivial example that shows the basic problem. In reality, I am mocking a third party module.Class -- <code>consul.Consul</code> -- whose client I instantiate in a Consul wrapper class that I have. As I don't maintain the consul module, I can't modify the source to suit my tests (I wouldn't really want to do that anyway). For what it's worth, <code>consul.Consul()</code> returns a consul client, which has an attribute <code>kv</code> -- an instance of <code>consul.Consul.KV</code>. <code>kv</code> has a method <code>get</code>, which I am wrapping in an instance method <code>get_key</code> in my Consul class. After patching <code>consul.Consul</code>, the call to get fails because of AttributeError: Mock object has no attribute kv.</p>
<p><strong>Resources Already Checked:</strong> </p>
<p><a href="http://mock.readthedocs.org/en/latest/helpers.html#autospeccing">http://mock.readthedocs.org/en/latest/helpers.html#autospeccing</a>
<a href="http://mock.readthedocs.org/en/latest/patch.html">http://mock.readthedocs.org/en/latest/patch.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>No, autospeccing cannot mock out attributes set in the <code>__init__</code> method of the original class (or in any other method). It can only mock out <em>static attributes</em>, everything that can be found on the class.</p>
<p>Otherwise, the mock would have to create an instance of the class you tried to replace with a mock in the first place, which is not a good idea (think classes that create a lot of real resources when instantiated).</p>
<p>The recursive nature of an auto-specced mock is then limited to those static attributes; if <code>foo</code> is a class attribute, accessing <code>Foo().foo</code> will return an auto-specced mock for that attribute. If you have a class <code>Spam</code> whose <code>eggs</code> attribute is an object of type <code>Ham</code>, then the mock of <code>Spam.eggs</code> will be an auto-specced mock of the <code>Ham</code> class.</p>
<p>The <a href="https://docs.python.org/3/library/unittest.mock.html#autospeccing" rel="noreferrer">documentation you read</a> <em>explicitly</em> covers this:</p>
<blockquote>
<p>A more serious problem is that it is common for instance attributes to be created in the <code>__init__</code> method and not to exist on the class at all. <code>autospec</code> canâ€™t know about any dynamically created attributes and restricts the api to visible attributes.</p>
</blockquote>
<p>You should just <em>set</em> the missing attributes yourself:</p>
<pre><code>@patch('foo.Foo', autospec=TestFoo)
def test_patched(self, mock_Foo):
    mock_Foo.return_value.foo = 'foo'
    Bar().bar()
</code></pre>
<p>or create a subclass of your <code>Foo</code> class for testing purposes that adds the attribute as a class attribute:</p>
<pre><code>class TestFoo(foo.Foo):
    foo = 'foo'  # class attribute

@patch('foo.Foo', autospec=TestFoo)
def test_patched(self, mock_Foo):
    Bar().bar()
</code></pre>
</div>
<span class="comment-copy">That would require the mock to create an instance of the class. That's never a good idea, because that would require it to execute the code you were trying to replace with a mock in the first place.</span>
<span class="comment-copy">Yeah, not sure how I missed that. It was pretty explicit. I guess that's what I will have to do. I was hoping to avoid that so that the test would verify the proper use of the Consul class. I suppose I'll have to rely on heavier-handed integration tests for that.</span>
