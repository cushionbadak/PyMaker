<div class="post-text" itemprop="text">
<p>I have a set of data:</p>
<pre><code>H         W         V
5         1         9.8385465 
10        1         8.2087544 
15        1         7.8788187 
20        1         7.5751283 
5         2         5.1217867 
10        2         4.3865578 
15        2         4.4089918 
20        2         4.0254478 
</code></pre>
<p>This has been read into a list of tuples, call it data.
I would like to create a second list, which contains values of H up until the first repetition i.e. H = [5,10,15,20] when finished. There are two boundary conditions which would work, either when the current H is less than the previous, or when the current W is greater than the previous. </p>
<p>I considered simply using enumerate(data) and checking previous vs. current, but is there a more "pythonic" way of doing it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.takewhile</code>:</p>
<pre><code>data = [
    (5, 1, 9.8385465),
    (10, 1, 8.2087544),
    (15, 1, 7.8788187),
    (20, 1, 7.5751283),
    (5, 2, 5.1217867),
    (10, 2, 4.3865578),
    (15, 2, 4.4089918),
    (20, 2, 4.0254478),
]

from itertools import takewhile, izip

print [data[0][0]] +[
    y[0] for x, y in takewhile(
        lambda _: _[0][0] &lt;= _[1][0] and _[0][1] &gt;= _[1][1],
        izip(data, data[1:])
    )
]
</code></pre>
<p>Result:</p>
<pre><code>[5, 10, 15, 20]
</code></pre>
<p><strong>EDIT</strong></p>
<p>A more readable version:</p>
<pre><code>from itertools import takewhile, izip, tee

data = ...


def criterion(_):
    prev, curr = _
    return prev[0] &lt;= curr[0] and prev[1] &gt;= curr[1]

it1, it2 = tee(iter(data))
print [next(it2)[0]] + [y[0] for x, y in takewhile(criterion, izip(it1, it2))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just store the previous value:</p>
<pre><code>previous = None

for H, W, V in data:
    if previous and previous != W:
        break
    #
    # do something with the values
    #
    previous = W
</code></pre>
<p>or you could track unique <code>H</code> values:</p>
<pre><code>seen = set()

for H, W, V in data:
    if H in seen:
        break
    seen.add(H)
    #
    # do something with the values
    #
</code></pre>
<p>or you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby()</code></a> to group on the second value in the tuples and only use the first group:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

group = next(groupby(data, itemgetter(1)))[1]
for H, W, V in group:
    # do something with the values
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a while loop. Something like this:</p>
<pre><code>w_at_start = data[0][1]
index = 0
while data[index][1] == w_at_start:
    # your actions
    index += 1
</code></pre>
</div>
<span class="comment-copy">It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far, example input (if there is any), the expected output, and the output you actually get (console output, tracebacks, etc.). The more detail you provide, the more answers you are likely to receive. Check the <a href="https://stackoverflow.com/tour">FAQ</a> and <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a>.</span>
<span class="comment-copy">I do not want you to write code for me. I was in the middle of editing ... I'm looking for a language specific implementation rather than what I would normally do in C/Java.</span>
<span class="comment-copy">Sounds like <code>itertools.takewhile</code> or <code>itertools.groupby</code> are good starting points</span>
<span class="comment-copy">I will take a look at those, thanks.</span>
<span class="comment-copy">Good old drive by downvoters. <i>shrug</i> Anyway, groupby looks like what I was after.</span>
<span class="comment-copy">This does accomplish the overall goal, though the result should just be the first index from each of the nested lists, i.e. [5,10,15,20]</span>
<span class="comment-copy">I already updated my answer</span>
<span class="comment-copy">I don't think it should matter for the actual problem, but it should be a list of tuples rather than a list of lists.</span>
<span class="comment-copy">It works with list of tuples also</span>
<span class="comment-copy">I'm sorry Martijn, I just finished editing this ... That's how I would normally do it in languages I'm used to, but I was thinking there might be some fancy python trick. Perhaps not simpler. It looks like you got a downvote for responding so fast too -_-</span>
<span class="comment-copy">@DanielB., I thought the two conditions were about the values be greater than not unique and also considered W and H?</span>
<span class="comment-copy">@PadraicCunningham  W must be unique, but H must be greater than the previous. It depends on which is being used as the condition.</span>
<span class="comment-copy">@DanielB., depending on the data either condition could give different results</span>
<span class="comment-copy">This is true, but I know the data because I generated it myself ;) Those breaks are guaranteed to coincide.</span>
<span class="comment-copy">I think I spent too much time setting up the problem and not enough actually asking my question ... I'm looking for a python specific, "trick," rather than writing my code for me :) It looks like itertools.groupby() would be what I'm after, and your answer doesn't appear to be Python.</span>
<span class="comment-copy">Oops. Yup. Been doing some c code lately and it crept in. Sorry!</span>
