<div class="post-text" itemprop="text">
<p>Example: A simple program that prints the value of a list every 10 seconds         </p>
<pre><code>import argparse
import time
import sys

myList = []

def parseArguments():
    parser = argparse.ArgumentParser(description="example")
    parser.add_argument('-a', '--addElement', help='adds an element to the list')

    args = parser.parse_args()

    if args.addElement:
        myList.append(args.addElement)

def main():
    parseArguments()

    while(True):
        print(myList)
        time.sleep(10)
</code></pre>
<p>The problem is that the program only reads the arguments passed at the start, I want it to read arguments passed at any time while it is running. </p>
<p>I want to run the program in the background like a service, and pass arguments to the program every once in a while.</p>
</div>
<div class="post-text" itemprop="text">
<p>I understand that what you are asking for looks like a service (or daemon process) able to accept asynchonous commands.</p>
<h3>External interface:</h3>
<p>prog foo</p>
<p>=&gt; ok repeatedly prints <code>['foo']</code></p>
<p>later:</p>
<p>prog bar</p>
<p>=&gt; second instance exits and first instance repeatedly prints <code>['foo', 'bar']</code></p>
<h3>Internal design</h3>
<p>That's far from being simple! You need to setup an IPC mechanisme to allow second instance to communicate with first one, with non blocking IO (or multithreading) in first instance. Under Unix, you could use <code>os.mkfifo</code>, but is you want a portable solution, your will have to use IP sockets on localhost</p>
<p>Structure in high level pseudo code</p>
<pre><code>get argument via argparse
bind to a fix port on localhost, in UDP protocol
if success:
    # ok it is the first prog
    initialize list from argument
    loop:
        get command from UDP socket, with timeout = 10s
        if cmd is add param:
            add parameter to list
        elif cmd is exit:   # not asked in question but should exist
            exit
        print list
else:
    # another prog has taken the socket, pass it the arg
    send the arg to the UDP port with proper protocol
</code></pre>
<p>Caveats on this simple design: there is a race condition is there is already a prog waiting on the socket that exits between the first try to bind and the send. To deal with that, you should use TCP protocol, with a <code>select</code> with timeout on listening socket, and a graceful shutdown to ensure that the message was received on the other side. In case of an error, you iterate (a maximum number of time) because the first server could have exited in the while.</p>
<p>Here is an implementation example:</p>
<pre><code>import socket
import select
import argparse
import time
import sys

TIMEOUT=10
IFACE='127.0.0.1'
PORT=4000
DEBUG=False

myList = []
old = ""

def parseArguments():
    parser = argparse.ArgumentParser(description="example")
    parser.add_argument('-a', '--addElement',
                        help='adds an element to the list')
    parser.add_argument('-q', '--quit', action='store_true',
                        help='closes main service')
    parser.add_argument('-d', '--debug', action='store_true',
                        help='display debug information')

    args = parser.parse_args()

    if args.quit:
        senddata("QUIT\n")
        sys.exit(0)

    if args.debug:
        DEBUG=True

    if args.addElement:
        myList.append(args.addElement)

def read(s):
    global old
    data = old
    while True:
        block = s.recv(1024)
        if len(block) == 0: return data
        if b'\n' in block:
            block,o = block.split(b'\n', 1)
            old = o.decode()
            data += block.decode()
            return data
        data += block.decode()

def gracefulclose(s, msg):
    s.send(msg.encode())
    s.shutdown(socket.SHUT_WR)
    try:
        read(s)
    finally:
        s.close()

def server(s):
    if DEBUG:
        print("SERVER")
    s.listen(5)
    while True:
        sl = select.select([s], [], [], TIMEOUT)
        if len(sl[0]) &gt; 0:
            s2, peer = s.accept()
            try:
                data = read(s2)
                print(data)
                gracefulclose(s2, "OK")
            finally:
                s2.close()
            if data.startswith("QUIT"):
                return
            elif data.startswith("DATA:"):
                myList.append(data[5:])
        print(myList)

def senddata(data):
    s = socket.socket(socket.AF_INET)
    try:
        s.connect((IFACE, PORT))
        s.send(data.encode())
        data = read(s)
        if (data.startswith("OK")):
            return True
    except:
        pass
    finally:
        s.close()
    return False

def client():
    return senddata("DATA:" + myList[0] + "\n")

def main():
    end = False
    MAX = 5
    while not end and MAX &gt; 0:
        s = socket.socket(socket.AF_INET)
        try:
            s.bind((IFACE, PORT))
        except Exception:
            s.close()
            s = None
        if s:
            try:
                server(s)
            finally:
                s.close()
                return
        else:
            if DEBUG:
                print("CLIENT", " ", 6 - MAX)
            end = client()
        MAX -= 1
        time.sleep(1)

if __name__ == "__main__":
    parseArguments()
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import argparse
import time
import sys

myList = []

def parseArguments():
    parser = argparse.ArgumentParser(description="example")
    parser.add_argument('-a', '--addElement', help='adds an element to the list')

    args = parser.parse_args()

    if args.addElement:
        myList.append(args.addElement)

def main():
    parseArguments()

    import select
    while(True):
        while select.select([sys.stdin], [], [], 0)[0]:
            myList.append(sys.stdin.readline().strip())
        print(myList)
        time.sleep(10)
</code></pre>
<p>If you are passing more arguments during execution, you must read them from the stdin. Using the select module you can check if there is any new line in stdin and then add them to myList.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically what you're asking is how to do Inter-process communication (IPC). </p>
<p>Why did I say that? Well, answer yourself: how would you like to pass these arguments to your background service? By hand? I don't think so (because that way you'd have a simple interactive program which should just wait for user input). You probably want some other script/program which sends these arguments via some kind of commands <em>on-demand</em>.</p>
<p>Generally there are several several ways to communicate two or more programs, the most popular being:</p>
<p><strong>Shared file</strong> - you could simply check contents of a file on your disk. Advantage of this solution is that you could probably edit this file with your favourite text editor, without the need of writing a client application.</p>
<p><strong>Pipes</strong> - one program reads its input which is the other program's output. You should simply read sys.stdin.</p>
<pre><code># receiver
def read_input():
    for l in sys.stdin:
        yield l
</code></pre>
<p><strong>Sockets</strong> - a data stream sent over a network interface (but it can be sent locally on the same machine). Python docs have very nice <a href="https://docs.python.org/3/howto/sockets.html" rel="nofollow">introduction</a> to sockets programming.</p>
<p><strong>Shared memory</strong> - your programs read/write the same memory block. In Python you can use <a href="https://docs.python.org/3/library/mmap.html" rel="nofollow">mmap</a> module to achieve this.</p>
<p>Whichever way to communicate your processes you choose, you should establish some kind of interface between them. It can be very simple text-based interface like this one:</p>
<pre><code># command syntax
&lt;command&gt; SPACE &lt;parameter&gt; NEWLINE
SPACE := 0x20     # space character
NEWLINE := 0x0A   # '\n' character

# a command adding element to receiver's list
ADD SPACE &lt;element&gt; NEWLINE

# a command removing element from receiver's list:
REMOVE SPACE &lt;element&gt; NEWLINE

# examples:
ADD first element\n
REMOVE first element\n
</code></pre>
<p>So for example if you send a message over a socket (which I recommend), your receiver (server) should read a buffer until a newline character, then check if the first word is "ADD" and then add remaining characters (minus newline) to your list. Of course you should be prepared for some kind of "attacks" - like you should specify that your messages cannot be longer than e.g. 4096 bytes. This way you can discard your current buffer after it reached its limitation, meaning that you won't allocate memory indefinitely while waiting for a newline character. That's one very important rule: don't trust user input.</p>
<p>Good luck! :)</p>
</div>
<span class="comment-copy">But ... In your example, you've started multiple instances of the program...</span>
<span class="comment-copy">Why do you want that? You are running different instances of the same program, do you want to save values between these instances? If so, you should save the required data to file or such.</span>
<span class="comment-copy">Maybe I explained myself bad, It is not supposed to be different instances, just one instance and add elements every once in a while to the instance. @AnandSKumar</span>
<span class="comment-copy">Sounds like you want an <code>input</code> and <code>execute</code> loop in your program, one that repeatedly asks the user from some input that it can pass through the <code>parser</code>.  Roughly: <code>input_line = input('prompt'); args=parser.parse_args(input_line.split()); ...</code>.</span>
<span class="comment-copy">@brunoop can you please update the question with what you are trying to  achieve with examples , if its not different instances.</span>
<span class="comment-copy">Thank you for your time, it helped me a lot understanding how to do it!</span>
<span class="comment-copy">Thank you for your great answer. I was considering writing to a file and reading periodically, but maybe I will try using sockets.</span>
