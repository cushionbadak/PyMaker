<div class="post-text" itemprop="text">
<p>I have some topic to discuss. I have a fragment of code with 24 <code>if</code>s/<code>elif</code>s. <code>Operation</code> is my own class that represents functionality similar to <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer"><code>Enum</code></a>. <br/>Here is a fragment of code:</p>
<pre><code>if operation == Operation.START:
    strategy = strategy_objects.StartObject()
elif operation == Operation.STOP:
    strategy = strategy_objects.StopObject()
elif operation == Operation.STATUS:
    strategy = strategy_objects.StatusObject()
(...)
</code></pre>
<p>I have concerns from readability point of view. Is is better to change it into 24 classes and use <a href="https://stackoverflow.com/a/1031385/8554766">polymorphism</a>? I am not convinced that it will make my code maintainable... From one hand those <code>if</code>s are pretty clear and it shouldn't be hard to follow, on the other hand there are too many <code>if</code>s.</p>
<p>My question is rather general, however I'm writing code in Python so I cannot use constructions like <a href="https://en.wikipedia.org/wiki/Switch_statement" rel="nofollow noreferrer"><code>switch</code></a>.</p>
<p>What do you think?</p>
<hr/>
<p><strong>UPDATE</strong>:</p>
<p>One important thing is that <code>StartObject()</code>, <code>StopObject()</code> and <code>StatusObject()</code> are constructors and I wanted to assign an object to <code>strategy</code> reference.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could possibly use a dictionary. Dictionaries store references, which means functions are perfectly viable to use, like so:</p>
<pre><code>operationFuncs = {
    Operation.START: strategy_objects.StartObject
    Operation.STOP: strategy_objects.StopObject
    Operation.STATUS: strategy_objects.StatusObject
    (...)                  
}
</code></pre>
<p>It's good to have a default operation just in case, so when you run it use a <code>try except</code> and handle the exception (ie. the equivalent of your <code>else</code> clause)</p>
<pre><code>try:
    strategy = operationFuncs[operation]()
except KeyError:
    strategy = strategy_objects.DefaultObject()
</code></pre>
<p>Alternatively use a dictionary's <code>get</code> method, which allows you to specify a default if the key you provide isn't found.</p>
<pre><code>strategy = operationFuncs.get(operation(), DefaultObject())
</code></pre>
<p>Note that you don't include the parentheses when storing them in the dictionary, you just use them when calling your dictionary. Also this requires that <code>Operation.START</code> be hashable, but that should be the case since you described it as a class similar to an ENUM.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's equivalent to a switch statement is to use a dictionary. Essentially you can store the keys like you would the cases and the values are what would be called for that particular case. Because functions are objects in Python you can store those as the dictionary values:</p>
<pre><code>operation_dispatcher = {
    Operation.START: strategy_objects.StartObject,
    Operation.STOP: strategy_objects.StopObject,
}
</code></pre>
<p>Which can then be used as follows:</p>
<pre><code>try:
    strategy = operation_dispatcher[operation] #fetch the strategy
except KeyError:
    strategy = default #this deals with the else-case (if you have one)
strategy() #call if needed
</code></pre>
<p>Or more concisely:</p>
<pre><code>strategy = operation_dispatcher.get(operation, default)
strategy() #call if needed
</code></pre>
<p>This can potentially scale a lot better than having a mess of if-else statements. Note that if you don't have an else case to deal with you can just use the dictionary directly with <code>operation_dispatcher[operation]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try something like <a href="https://stackoverflow.com/questions/60208/replacements-for-switch-statement-in-python">this</a>.</p>
<p>For instance:</p>
<pre><code>def chooseStrategy(op):
    return {
        Operation.START: strategy_objects.StartObject
        Operation.STOP: strategy_objects.StopObject
    }.get(op, strategy_objects.DefaultValue)
</code></pre>
<p>Call it like this</p>
<pre><code>strategy = chooseStrategy(operation)()
</code></pre>
<p>This method has the benefit of providing a default value (like a final else statement). Of course, if you only need to use this decision logic in one place in your code, you can always use strategy = dictionary.get(op, default) without the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use some introspection with <code>getattr</code>:</p>
<pre><code> strategy = getattr(strategy_objects, "%sObject" % operation.capitalize())()
</code></pre>
<p>Let's say the operation is "STATUS", it will be capitalized as "Status", then prepended to "Object", giving "StatusObject". The <code>StatusObject</code> method will then be called on the <code>strategy_objects</code>, failing catastrophically if this attribute doesn't exist, or if it's not callable. :) (I.e. add error handling.)</p>
<p>The dictionary solution is probably more flexible though.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the <code>Operation.START</code>, etc are hashable, you can use dictionary with keys as the condition and the values as the functions to call, example -</p>
<pre><code>d = {Operation.START: strategy_objects.StartObject , 
     Operation.STOP: strategy_objects.StopObject, 
     Operation.STATUS: strategy_objects.StatusObject}
</code></pre>
<p>And then you can do this dictionary lookup and call the function , Example -</p>
<pre><code>d[operation]()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a bastardized switch/case done using dictionaries:</p>
<p>For example:</p>
<pre><code># define the function blocks
def start():
    strategy = strategy_objects.StartObject()

def stop():
    strategy = strategy_objects.StopObject()

def status():
    strategy = strategy_objects.StatusObject()

# map the inputs to the function blocks
options = {"start" : start,
           "stop" : stop,
           "status" : status,

}
</code></pre>
<p>Then the equivalent switch block is invoked:</p>
<pre><code>options["string"]()
</code></pre>
</div>
<span class="comment-copy"><code>case</code> statement, instead? that or have an array of method references to call dynamically, e.g. whatever python's equivalent of <code>array_of_methods[operation]()</code> would be...</span>
<span class="comment-copy">Marc, python does not have switch/case statements. <a href="https://www.python.org/dev/peps/pep-3103/" rel="nofollow noreferrer">python.org/dev/peps/pep-3103</a></span>
<span class="comment-copy">You're missing the call. <code>strategy = chooseStrategy(operation)()</code></span>
<span class="comment-copy">Thanks! I missed that he was calling the chosen strategy. I've edited my post.</span>
<span class="comment-copy">Checking the class exists with hasattr(...) would be the equivalent of the KeyError in the dictionnary solution.</span>
<span class="comment-copy">But <code>strategy</code> will be local to each of those small functions, and won't be visible in the scope where you execute <code>options["string"]()</code>.</span>
