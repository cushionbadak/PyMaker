<div class="post-text" itemprop="text">
<p>Using python3's super in a comprehension seems to always result in <code>TypeError: super(type, obj): obj must be an instance or subtype of type</code> (but using python 2's super does work as expected)</p>
<pre><code>class A(object):
    def __repr__(self):
         return "hi!"  

class B(A):
    def __repr__(self):
         return "".join(super().__repr__() for i in range(2))  

repr(B())
#output: &lt;repr(&lt;__main__.B at 0x7f70cf36fcc0&gt;) failed: TypeError: super(type, obj): obj must be an instance or subtype of type&gt;

class C(A):
    def __repr__(self):
        s = ''
        for i in range(4):
            s += super().__repr__()
        return s     

repr(C())
#output: hi!hi!hi!hi!

class D(A):
    def __repr__(self):
        return "".join(super(D,self).__repr__() for i in range(4))

repr(D())
#output: hi!hi!hi!hi!
</code></pre>
<p>So, why does new <code>super()</code> fail in generator comprehensions?</p>
<p>Addendum:</p>
<pre><code>In [28]: class E(A):
   ....:     def __repr__(self):
   ....:         def inner():
   ....:             print(repr(__class__))
   ....:         inner()
   ....:         return ''
In [29]: repr(E())
&lt;class '__main__.E'&gt;
Out[29]: ''

In [30]: class F(A):
   ....:     def __repr__(self):
   ....:         return "".join([super().__repr__() for i in range(4)])
   ....:     

In [31]: repr(F())

TypeError: super(type, obj): obj must be an instance or subtype of type
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Simple explanation</h3>
<p>Look at the documentation for <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code></a>:</p>
<blockquote>
<p>The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods.</p>
</blockquote>
<p>By <em>inside a class definition</em> they meant <em>inside class method scope</em>. Inside <em>class method scope</em> interpreter is able to complete zero form with same parameters as you would explicitly provide it in Python 2. List comprehension however creates it's own scope. That's the reason why it fails: you call to <code>super()</code> not from the class method scope and interpreter is not able to complete it with all parameters.</p>
<h3>Advanced explanation</h3>
<p>According to Python <a href="https://docs.python.org/3.4/reference/datamodel.html#creating-the-class-object" rel="nofollow noreferrer">data model</a>:</p>
<blockquote>
<p><code>__class__</code> is an implicit closure reference created by the compiler if any methods in a class body refer to either <code>__class__</code> or <code>super</code>. This allows the zero argument form of <code>super()</code> to correctly identify the class being defined based on lexical scoping, while the class or instance that was used to make the current call is identified based on the first argument passed to the method.</p>
</blockquote>
<p>Python is able to collect first parameter for <code>super()</code> from <code>__class__</code> variable even inside list comprehension (since it is available in all child scopes as any usual closure). You can test it using:</p>
<pre><code>class T:
    def test(self):
        print(__class__)
        print([__class__ for _ in range(1)][0])


T().test()
</code></pre>
<p>Will output:</p>
<pre><code>&lt;class '__main__.T'&gt;
&lt;class '__main__.T'&gt;
</code></pre>
<p>But interpreter incorrectly collects second parameter for <code>super()</code>: <code>self</code>. It assumes that call to <code>super()</code> happens inside method scope and tries to get first parameter for the method using following <a href="https://hg.python.org/cpython/file/tip/Objects/typeobject.c" rel="nofollow noreferrer">C code</a> (many lines are omitted for clarity):</p>
<pre><code>PyFrameObject *f = PyThreadState_GET()-&gt;frame;
obj = f-&gt;f_localsplus[0];
if (obj != NULL) {
    obj_type = supercheck(type, obj);
    if (obj_type == NULL)
        return -1;
    Py_INCREF(obj);
}
</code></pre>
<p>It's not possible to access <code>f-&gt;f_localsplus[0]</code> from Python, but it <a href="https://hg.python.org/cpython/file/tip/Include/frameobject.h" rel="nofollow noreferrer">contains</a> "locals+stack" according to comment in code. So we can utilize <code>locals()</code> for a test (unfortunately order is missing). Let's test, what is available in locals inside class method and list comprehension:</p>
<pre><code>class T:
    def test(self):
        print(locals())
        print([locals() for _ in range(1)])


T().test()
</code></pre>
<p>Will print:</p>
<pre><code>{'self': &lt;__main__.T object at 0x100f1f8d0&gt;}
{'_': 0, '.0': &lt;range_iterator object at 0x100fbb2a0&gt;}
</code></pre>
<p>There is a reference to our object in the first case and it will be correctly found by interpreter. Inside list comprehension there is no object inside dictionary so it will get either <code>0</code> or <code>range_iterator</code> (remember, order is missing?). Neither of those is instance of our object. It will fail <code>supercheck()</code> and give you an error <code>obj must be an instance or subtype of type</code> (e.g. <code>T</code>).</p>
<hr/>
<p>Take a look <a href="https://stackoverflow.com/q/13126727/1377864">here</a> for more information on how <code>super()</code> is implemented and <a href="https://stackoverflow.com/q/19608134/1377864">here</a> for more details why it's done like this.</p>
</div>
<span class="comment-copy">You are not using a list comprehension here, but a generator expression. It's possible to pass the expression to a different scope before evaluating it, and since you don't give any explicit arguments to <code>super()</code>, how should the python compiler understand which class is the correct one?</span>
<span class="comment-copy">This behaviour looks quite counter-intuitive</span>
