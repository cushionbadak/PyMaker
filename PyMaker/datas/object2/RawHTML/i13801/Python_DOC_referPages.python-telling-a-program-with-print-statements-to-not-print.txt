<div class="post-text" itemprop="text">
<p>I'm currently learning Python and began a project to create a baseball sim for the 2000-2005 MLB showdown card game. The programs contains events of the baseball game as print statements in the middle of separate pieces of code ("Jeff hits a single", "Bobby hits a fly ball for an out", etc). I often will take out the print statements if I want to run a lot of games at once. My goal, for feasibility reasons, is to tell Python to not print certain statements (say, in a specific span of lines) even though the code says print " ". Is this possible?</p>
<p>example:</p>
<pre><code>while numberofgames &lt; 1000:
  [do not print any statements here]
  ---baseball games---
end of while loop
</code></pre>
<p>THEN: print simulation results</p>
</div>
<div class="post-text" itemprop="text">
<p>Can you create a global variable which you can check to decide how much you want to print ? By doing that you can control the amount of logging as you require.</p>
<pre><code>  if printLevel &gt; 3:
      print("Bobby hits a fly ball for an out")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you could put all the print statements into an <code>if</code> structure eg..</p>
<pre><code>if printStuff:
    print 'I dont like baseball'
    print 'I love it!'
</code></pre>
<p>Then it is just a matter of setting <code>printStuff</code> to <code>True</code> if you want to print or <code>False</code> if you dont.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use Replace All to replace <code>print(</code> with <code>#print(</code>.</p>
<p>When you're ready to print again, you could do the opposite: Replace <code>#print(</code> with <code>print(</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A hack, sure, but why not override the print function for a while?</p>
<pre><code>#the line below needs to be the first in the file
#and is required on Python 2.7
from __future__ import print_function

def to_null(*args, **kwds):
    pass

def test1(x):
    print ("test1(%s)" % (x))


#override the print 
old_print = __builtins__.print
__builtins__.print = to_null

test1("this wont print")

#restore it
__builtins__.print = old_print

test1("this will print")
</code></pre>
<p>output:</p>
<pre><code>test1(this will print)
</code></pre>
<p>see also <a href="https://stackoverflow.com/questions/12998908/is-it-possible-to-mock-pythons-built-in-print-function">Is it possible to mock Python's built in print function?</a></p>
<p>Finally, the suggestion to use the logging module is spot-on.  Though that module can be tricky to use well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the logging module for this:</p>
<p><a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html</a></p>
<p><a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="nofollow noreferrer">https://docs.python.org/3/howto/logging.html#logging-basic-tutorial</a></p>
<p>The logging module has several different levels.</p>
<p>Level   ---------  Numeric value</p>
<p>CRITICAL    ---50</p>
<p>ERROR    -----  40</p>
<p>WARNING --30</p>
<p>INFO    ---------20</p>
<p>DEBUG   -----10</p>
<p>NOTSET  -----0</p>
<p>You assign messages a level. For instance, <code>logging.info("Debug")</code> is an INFO level message which prints <code>"Debug"</code>. If the level of the logger is less than or equal to the level of the message, the message will be printed.</p>
<p>So if you want to turn a bunch of print statements off, you would just make the statements all the same level, and then turn the logger to a higher level. </p>
<pre><code>&gt;&gt;&gt;import logging

&gt;&gt;&gt;T=logging.getLogger()                 #create a new logger object
#Set the logger level to INFO - note basicConfig only works once!!!
#Then you must use setLevel method to change the level
&gt;&gt;&gt;logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)
&gt;&gt;&gt;logging.info("INFO")                 #this prints because the logger is set to INFO
INFO:Info
&gt;&gt;&gt;logging.warning("Warning")
WARNING:Warning

&gt;&gt;&gt;T.setLevel(logging.WARNING)      #set the logger level to WARNING
&gt;&gt;&gt;logging.info("Debug")            #Does not print since logger level WARNING is higher than message level INFO
&gt;&gt;&gt;logging.warning("Warning")
WARNING:Warning
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>print</code> outputs to <code>sys.stdout</code>. You can put your own buffer for STDOUT.</p>
<pre><code># assuming python3
import sys
import io

my_buffer = io.StringIO()
sys.stdout = my_buffer

# print some stuff
stuff_to_print = ['foo', 'word', 'test']
for word in stuff_to_print:
    print(word)

# all the other stuff your script does

# change stdout back to original so print is pointing back to original buffer
sys.stdout = sys.__stdout__

# now print everything out at once
print(my_buffer.get_value())
</code></pre>
</div>
<span class="comment-copy">Can't you just comment out the print lines?</span>
<span class="comment-copy">There's a lot of print lines for all the different events that can occur. I'm wondering if there's a simpler way to just tell it to stop printing lines then individually going through and commenting them out.</span>
<span class="comment-copy">Use the <code>logging</code> module instead of <code>print</code>  statements to control when and where output is produced.</span>
<span class="comment-copy">I think the logging system would be great for messages intended for the developer e.g., but from the message examples it seems like these are supposed to go to the user on the console and I would say some form of print should be more appropriate for that.</span>
<span class="comment-copy">Thank you! I'm going to use this method as it offers the greatest flexibility with which print statements to display. Everyone's comments and answers were helpful, so thank you everyone!</span>
