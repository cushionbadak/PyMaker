<div class="post-text" itemprop="text">
<p>Consider a dictionary of lists of dictionaries, such as the following:</p>
<pre><code>{1: [{'date': 6/31/2015, 'bits': 1},
     {'date': 6/25/2015, 'bits': 5}],
 2: [{'date': 7/31/2013, 'bits': 5},
     {'date': 7/28/2015, 'bits': 0}],
 6: [{'date': 4/23/2010, 'bits': 10},
     {'date': 1/1/2009,  'bits': 1}]}
</code></pre>
<p>What would be the most efficient way (from the perspective of time complexity) to find the entry with the maximum value for a key from the inner dictionary, grouped by key from the main dictionary? In case of a tie, another key from the innermost dictionary determines the winner.</p>
<p>With the above dictionary, finding the max for key <code>'bits'</code>, using key <code>'date'</code> to break ties (favoring the most recent) the result should be the dictionary</p>
<pre><code>{1: {'date': 6/25/2015, 'bits': 5},
 2: {'date': 7/31/2013, 'bits': 5},
 6: {'date': 4/23/2010, 'bits': 10}}`.
</code></pre>
<p>I currently have an implementation using two nested <code>for</code> loops. I'm considering to sort the list by the field <code>bits</code> to get to the entry with the largest value.</p>
<p>The current implementation is like below : </p>
<pre><code>for key in dicts:
   for data in dicts[key]:
      if(data["bits"]&gt;max_bits):
         max_bits= data["bits"]
         date =data["date"]
      elif (data["bits_corrected"]==max_bits):
           if(data["date"] &gt;date):
              date=data["date"]
</code></pre>
<p>But its taking lots of time for large data sets. Please suggest the optimum solution</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's make a framework to answer this empirically. It's always best to test how fast algorithms are actually running, rather than just guessing.</p>
<p>First a way to generate test data:</p>
<pre><code>import datetime
import random

def generate_data(sz_outer, sz_inner):
    res = {}
    for n in range(sz_outer):
        res[n] = []
        for m in range(sz_inner):
            date = datetime.date(
                year=random.sample(range(2010, 2015), 1)[0],
                month=random.sample(range(1, 13), 1)[0],
                day=random.sample(range(1, 29), 1)[0],
                )
            bits = random.sample(range(10), 1)[0]
            res[n].append({'date': date, 'bits': bits})
    return res
</code></pre>
<p>Here's two possible solutions. The first uses the <code>pandas</code> module to convert your list of dictionaries into a more structured data type. The second is a straightforward implementation using pure Python, and a sort key based on a tuple of your keys in order of importance.</p>
<pre><code>def choose_best1(dict_list):
    df = pandas.DataFrame.from_records(dict_list)
    return df.sort(['bits', 'date']).irow(-1).to_dict()

def choose_best2(dict_list):
    srted = sorted(dict_list, key=lambda k: (k['bits'], k['date']))
    return srted[-1]
</code></pre>
<p>A method to run the test:</p>
<pre><code>def run_test(data, method=choose_best1):
    bests = {}
    for key, dict_list in data.items():
        best = method(dict_list)
        bests[key] = best
    return bests
</code></pre>
<p>We get the same results with either method:</p>
<pre><code>data = generate_data(10, 10000)
bests1 = run_test(data, choose_best1)
bests2 = run_test(data, choose_best2)
</code></pre>
<p>Which is faster? Depends entirely on the size of your inner-most dictionary list. For a sufficiently large inner list, it will be worth it to pay the upfront cost of converting to DataFrame, in order to benefit from the more optimized sorting algorithms available in pandas. For a short inner list, it's better to just used <code>sorted</code>.</p>
<p>With 10000 records the pandas method is faster:</p>
<pre><code>data = generate_data(10, 10000)

In [79]: %timeit run_test(data, choose_best1)
10 loops, best of 3: 116 ms per loop

In [80]: %timeit run_test(data, choose_best2)
10 loops, best of 3: 151 ms per loop
</code></pre>
<p>With 100 records the sorted method is much faster:</p>
<pre><code>data = generate_data(10, 10000)

In [82]: %timeit run_test(data, choose_best1)
100 loops, best of 3: 15 ms per loop

In [84]: %timeit run_test(data, choose_best2)
1000 loops, best of 3: 710 Âµs per loop
</code></pre>
<p>Note that the size of the outer dictionary is completely irrelevant since each entry is processed completely independently. So the total time is just the sum of the time needed for each entry in the outer dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the idea:</p>
<hr/>
<pre><code>&gt;&gt;&gt; s = {1: [{'date': 0, 'bits': 1}, {'date': 0, 'bits': 5}], 2: [{'date': 0, 'bits': 5}, {'date': 0, 'bits': 0}], 6: [{'date': 0, 'bits': 10}, {'date': 0, 'bits': 1}]}
&gt;&gt;&gt; for k, vl in s.iteritems():
...     print sorted(vl, key=lambda k: k['bits'], reverse=True)
...
[{'date': 0, 'bits': 5}, {'date': 0, 'bits': 1}]
[{'date': 0, 'bits': 5}, {'date': 0, 'bits': 0}]
[{'date': 0, 'bits': 10}, {'date': 0, 'bits': 1}]
&gt;&gt;&gt;
</code></pre>
<p>Is this helpful ?</p>
<p>Let me know if you don't like this solution, i will remove it.</p>
</div>
<div class="post-text" itemprop="text">
<p>After I worked on it a bit, I don't think you can get around the nested loops or multiple iteration. If you have to account for ties you will need to iterate over the inner dictionaries, worst case you will have to iterate over all of those items to break a tie - So the complexity stays the same.</p>
<hr/>
<pre><code>data = {1: [{'date': datetime.datetime.strptime('6/30/2015', '%m/%d/%Y'), 'bits': 1},
            {'date': datetime.datetime.strptime('6/25/2015', '%m/%d/%Y'), 'bits': 5}],
        2: [{'date': datetime.datetime.strptime('7/31/2013', '%m/%d/%Y'), 'bits': 5},
            {'date': datetime.datetime.strptime('7/28/2015', '%m/%d/%Y'), 'bits': 3}],
        6: [{'date': datetime.datetime.strptime('4/23/2010', '%m/%d/%Y'), 'bits': 10},
            {'date': datetime.datetime.strptime('1/2/2009', '%m/%d/%Y'),  'bits': 1}],
        7: [{'date': datetime.datetime.strptime('4/24/2010', '%m/%d/%Y'), 'bits': 2},
            {'date': datetime.datetime.strptime('1/1/2009', '%m/%d/%Y'),  'bits': 10}]}
</code></pre>
<p>Try to take advantage of the builtins <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow"><code>max</code></a> and <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow"><code>map</code></a>, <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow"><code>operator.itemgetter</code></a>, <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow"><code>functools.partial</code></a>, <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce</code></a> (all part of the standard library).  They may speed things up even though the time-complexity is the same.</p>
<p>We need to write a key function that can be used with <code>max</code>.</p>
<hr/>
<p>While the following may be instructional, it breaks ties based on the <code>bits</code> key.  It uses a key function that returns the sorted <code>bits</code> values from each <em>inner</em> dictionary of each item of the <code>data</code>. Make sure to see the edit at the bottom.  </p>
<p>I'm also using a handy function that lets you string multiple functions together.  I had this in my <em>toolbox</em>, it doesn't have an attribution so I don't know if I wrote it or found it someplace - I probably found it.</p>
<pre><code>import functools, operator
def compose(funcs):
    '''Return a callable composed of successive application of functions

    funcs is an iterable producing callables
    for [f, g, h] returns f(g(h(*args, **kwargs)))

    &gt;&gt;&gt; def f(x):
            return int(x ** .5)

    &gt;&gt;&gt; def g(x):
            return x*x

    &gt;&gt;&gt; def h(x):
            return -x

    &gt;&gt;&gt; foo = compose([f, g, h])
    &gt;&gt;&gt; foo(2)
    2
    &gt;&gt;&gt;
    '''
    def outer(f, g):
        def inner(*args, **kwargs):
            return f(g(*args, **kwargs))
        return inner
    return functools.reduce(outer, funcs)
</code></pre>
<p>We need the value for each (k,v) item in <code>data</code>.</p>
<pre><code>#callable that returns sequence[1]
item1 = operator.itemgetter(1)
</code></pre>
<p>We need a somethng to <em>get</em> the <code>bits</code> value of an <em>inner</em> dictionary</p>
<pre><code>#callable that returns subscriptable['bits']
bits = operator.itemgetter('bits')
</code></pre>
<p>We need to iterate over each inner dictionary and extract the <code>bits</code></p>
<pre><code>#callable that will map the callable bits to a sequence
#this becomes an inner nested loop
get_bits = functools.partial(map, bits)
</code></pre>
<p>We need a reverse sort</p>
<pre><code>reverse_sort = functools.partial(sorted, reverse = True)
</code></pre>
<p>Compose a key function that will return the stuff you are interested in.</p>
<pre><code>funcs = [reverse_sort, get_bits, item1]
key = compose(funcs)
# key is now equivalent to sorted(get_bits(item1(item)), reverse = True)

&gt;&gt;&gt; # iterate over data.items() and find the max
&gt;&gt;&gt; print(max(data.items(), key = key))
(7, [{'date': '4/23/2010', 'bits': 2}, {'date': '1/1/2009', 'bits': 10}])
</code></pre>
<p>Not sure why I like the functional style but you could also write the key function like this (which, I imagine, many people will find way more readable).</p>
<pre><code>def key1(item):
    one = item[1]
    # iterate over the inner dictionaries
    bits = [thing['bits'] for thing in one]
    # sort the bits
    return sorted(bits, reverse = True)

&gt;&gt;&gt; print(max(data.items(), key = key1))
(7, [{'date': '4/23/2010', 'bits': 2}, {'date': '1/1/2009', 'bits': 10}])
</code></pre>
<hr/>
<p><strong>edit</strong></p>
<p>Seems I misread or didn't see that the tiebreaker is the <code>date</code> field.
this makes it a bit easier.</p>
<pre><code>#callable that returns a ('bits', 'date') tuple
bits_date = operator.itemgetter('bits', 'date')

def key3(item):
    '''return the best dictionary from an item
    '''
    one = item[1]
    # max is an inner loop when this is used as a key function
    return max(one, key = bits_date)
# or
item1 = operator.itemgetter(1)
best = functools.partial(max, key = bits_date)
key4 = compose([best, item1])

&gt;&gt;&gt; # max in the next statement(s) is the outer loop
&gt;&gt;&gt; print(max(d.items(), key = key3))
(6, [{'date': datetime.datetime(2010, 4, 23, 0, 0), 'bits': 10}, {'date': datetime.datetime(2009, 1, 2, 0, 0), 'bits': 1}])
&gt;&gt;&gt; print(max(d.items(), key = key4))
(6, [{'date': datetime.datetime(2010, 4, 23, 0, 0), 'bits': 10}, {'date': datetime.datetime(2009, 1, 2, 0, 0), 'bits': 1}])
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">If you have a working solution, you should post it in your answer.  You might even consider posting this in <a href="http://codereview.stackexchange.com/">Code Review</a>  because you have a working solution and are asking for criticism/alternatives.</span>
<span class="comment-copy">As for time-complexity, it seems you will need to iterate over the <i>main</i> dictionary And iterate over the values of each item in the <i>main</i> dictionary - so your nested loop is probably the best you can do for time-complexity. Any strategy that pushes the process <i>down</i> into c may make it realatively faster but seems like the complexity will remain the same.</span>
<span class="comment-copy">@wwii you mean nested for loops is the optimum solution we can achieve in this case ? can't we sort the inner dictionary and get max value of bits and corresponding date ?</span>
<span class="comment-copy">Yea, I <i>spoke</i> without thinking.  Sorting a list is better than O(N) so if you can convert one of the loops to a sort then you get an improvement.</span>
<span class="comment-copy">for <code>'date': 6/31/2015</code> what is the data type of the value <code>6/31/2015</code>?</span>
<span class="comment-copy">nice solution, I have a doubt, in both the methods you are sorting the date as well as bits, or sorting only the bits , date will be displayed along with the corresponding bits ?</span>
<span class="comment-copy">In both methods, we pass both "bits" and "date" as sort keys. So it will sort first by bits and use date to break ties. It will return the full data set with both bits and date fields preserved.</span>
<span class="comment-copy">Is it handling the case to break the tie(if bits values are same for different dates) ?</span>
