<div class="post-text" itemprop="text">
<p>I have multiple threads running the same process that need to be able to to notify each other that something should not be worked on for the next n seconds its not the end of the world if they do however.</p>
<p>My aim is to be able to pass a string and a TTL to the cache and be able to fetch all the strings that are in the cache as a list. The cache can live in memory and the TTL's will be no more than 20 seconds.</p>
<p>Does anyone have a any suggestions for how this can be accomplished?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://pypi.python.org/pypi/expiringdict/" rel="nofollow noreferrer"><code>expiringdict</code></a> module:</p>
<blockquote>
<p>The core of the library is <code>ExpiringDict</code> class which is an ordered dictionary with auto-expiring values for caching purposes.</p>
</blockquote>
<p>In the description they do not talk about multithreading, so in order not to mess up, use a <code>Lock</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The OP is using python 2.7 but if you're using python 3, <code>ExpiringDict</code> mentioned in the accepted answer is currently, well, expired. The last commit to the <a href="https://github.com/mailgun/expiringdict" rel="noreferrer">github repo</a> was June 17, 2017 and there is an open issue that it <a href="https://github.com/mailgun/expiringdict/issues/16" rel="noreferrer">doesn't work with Python 3.5</a></p>
<p>There is a more recently maintained project <a href="https://github.com/tkem/cachetools" rel="noreferrer">cachetools</a> (last commit Jun 14, 2018)</p>
<p><code>pip install cachetools</code></p>
<pre><code>from cachetools import TTLCache

cache = TTLCache(maxsize=10, ttl=360)
cache['apple'] = 'top dog'
...
&gt;&gt;&gt; cache['apple']
'top dog'
... after 360 seconds...
&gt;&gt;&gt; cache['apple']
KeyError exception thrown
</code></pre>
<p><code>ttl</code> is the time to live in seconds.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like that ?</p>
<pre class="lang-python prettyprint-override"><code>from time import time, sleep
import itertools
from threading import Thread, RLock
import signal


class CacheEntry():
  def __init__(self, string, ttl=20):
    self.string = string
    self.expires_at = time() + ttl
    self._expired = False

  def expired(self):
    if self._expired is False:
      return (self.expires_at &lt; time())
    else:
      return self._expired

class CacheList():
  def __init__(self):
    self.entries = []
    self.lock = RLock()

  def add_entry(self, string, ttl=20):
    with self.lock:
        self.entries.append(CacheEntry(string, ttl))

  def read_entries(self):
    with self.lock:
        self.entries = list(itertools.dropwhile(lambda x:x.expired(), self.entries))
        return self.entries

def read_entries(name, slp, cachelist):
  while True:
    print "{}: {}".format(name, ",".join(map(lambda x:x.string, cachelist.read_entries())))
    sleep(slp)

def add_entries(name, ttl, cachelist):
  s = 'A'
  while True:
    cachelist.add_entry(s, ttl)
    print("Added ({}): {}".format(name, s))
    sleep(1)
    s += 'A'



if __name__ == "__main__":
  signal.signal(signal.SIGINT, signal.SIG_DFL)

  cl = CacheList()
  print_threads = []
  print_threads.append(Thread(None, read_entries, args=('t1', 1, cl)))
  # print_threads.append(Thread(None, read_entries, args=('t2', 2, cl)))
  # print_threads.append(Thread(None, read_entries, args=('t3', 3, cl)))

  adder_thread = Thread(None, add_entries, args=('a1', 2, cl))
  adder_thread.start()

  for t in print_threads:
    t.start()

  for t in print_threads:
    t.join()

  adder_thread.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Regarding an expiring in-memory cache, for general purpose use, a common design pattern to typically do this is not via a dictionary, but via a function or method decorator. A cache dictionary is managed behind the scenes. As such, this answer somewhat complements the <a href="https://stackoverflow.com/a/52128389/832230">answer by <em>User</em></a> which uses a dictionary rather than a decorator.</p>
<p>The <a href="https://cachetools.readthedocs.io/en/latest/#cachetools.func.ttl_cache" rel="nofollow noreferrer"><code>ttl_cache</code></a> decorator in <a href="https://pypi.org/project/cachetools" rel="nofollow noreferrer"><code>cachetools==3.1.0</code></a> works a lot like <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>, but with a <a href="https://en.wikipedia.org/wiki/Time_to_live" rel="nofollow noreferrer">time to live</a>.</p>
<pre><code>import cachetools.func

@cachetools.func.ttl_cache(maxsize=128, ttl=10 * 60)
def target(key):
    return get_expensively_computed_value(key)
</code></pre>
</div>
<span class="comment-copy">Regarding threading, in modern Python, <a href="https://docs.python.org/3/library/threading.html#barrier-objects" rel="nofollow noreferrer"><code>threading.Barrier</code></a> should be of strong interest as it has a timeout.</span>
<span class="comment-copy">In fact they use lock on set/get operations inside.</span>
<span class="comment-copy">@alkuzad: Ok, then you can avoid the Lock entirely.</span>
<span class="comment-copy">i gave this module a try but its would require some work for my use case as i only need a list and it seems you cant just loop over a ExpiringDict class as it give duplicates</span>
<span class="comment-copy">@HeDares: I know that you need a list, but if your list does not contain duplicates, you can use the dictionary keys to represent the list values (and set the dictionary values to something like <code>None</code>). Then loop over them with <code>d.keys()</code></span>
<span class="comment-copy">As mentioned in <a href="https://stackoverflow.com/a/52128389/1260237">stackoverflow.com/a/52128389/1260237</a> expiringdict appears to no longer be maintained and cachetools appears to be a good successor.</span>
<span class="comment-copy">Works like a charm i just had to add: def __repr__(self):         return self.string  To class CacheEntry()</span>
