<div class="post-text" itemprop="text">
<p>In python 3.x <code>keys()</code>, <code>values()</code> and <code>items()</code> return <a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow noreferrer">views</a>. Now while views certainly have <a href="https://stackoverflow.com/a/8960727/1622937">advantages</a>, they also seem to cause some compatibility issues. For example with <code>matplotlib</code> (ultimately it's with <code>numpy</code>). As an example <a href="https://stackoverflow.com/a/16014873/1622937">this</a> and <a href="https://stackoverflow.com/a/21832451/1622937">this</a> answers on stackexchange questions work just fine with python 2.x but raise an Exception when executing them in python 3.4.</p>
<p>A minimal example would be:</p>
<pre><code>import matplotlib.pyplot as plt
d = {1: 2, 2: 10}
plt.scatter(d.keys(), d.values())
</code></pre>
<p>Which raises <code>TypeError: float() argument must be a string or a number, not 'dict_values'</code> with python 3.4. </p>
<p>While for the minimal example the Exception is quite clear, <a href="https://stackoverflow.com/questions/31753621/stackplot-using-list-of-dictionary-values-python-3-x">this</a> question arises because of the same problem and here the Exception is a lot less clear: <code>TypeError: ufunc 'isfinite' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''</code></p>
<p>What is the best practice to deal with this issue? Can we hope that in a new release of <code>matplotlib</code> (or ultimately <code>numpy</code>) this issue will be dealt with or should we just start to write things like <code>list(dict.values())</code> when using <code>matplotlib</code> just to be sure not to run into trouble with python 3.x?</p>
</div>
<div class="post-text" itemprop="text">
<p>More of that error:</p>
<pre><code>--&gt; 512     return array(a, dtype, copy=False, order=order, subok=True)
    513 
    514 def ascontiguousarray(a, dtype=None):

TypeError: float() argument must be a string or a number, not 'dict_values'
</code></pre>
<p>So the minimal example is:</p>
<pre><code>np.array(d.keys(),dtype=float)
</code></pre>
<p>Without the dtype specification </p>
<pre><code>In [16]: np.array(d.keys())
Out[16]: array(dict_keys([1, 3]), dtype=object)
</code></pre>
<p>The <code>dict_keys</code> is treated as an <code>object</code>. Usually you have to work at keeping <code>np.array</code> from treating an object as a list of numbers.</p>
<pre><code>In [17]: np.fromiter(d.keys(),dtype=float)
Out[17]: array([ 1.,  3.])
</code></pre>
<p><code>np.fromiter</code> can handle <code>d.keys()</code>, treating it as a iterable.  So there's some detail in how <code>fromiter</code> handles an iterable that is different from <code>np.array</code>.</p>
<p>A generator expression works the same way, e.g. <code>(i for i in range(4))</code>.  <code>fromiter</code> can iterate through it, <code>array</code> either treats it as an object or raises an error.</p>
<p>If all the errors that the SO mentioned boiled down to <code>np.array(...)</code> handling a generator, then it might be possible to fix the behavior with one <code>numpy</code> change.  Developers certainly wouldn't want to tweak every function and method that might accept a list.  But it feels like a fundamental change that would have to be thoroughly tested.  And even then it's likely to produce backward compatibility issues.</p>
<p>The accepted fix, for some time now, has been to pass your code through <code>2to3</code>.</p>
<p><a href="https://docs.python.org/2/library/2to3.html" rel="nofollow">https://docs.python.org/2/library/2to3.html</a></p>
<p>for dictionaries:</p>
<blockquote>
<p>Fixes dictionary iteration methods. dict.iteritems() is converted to dict.items(), dict.iterkeys() to dict.keys(), and dict.itervalues() to dict.values(). Similarly, dict.viewitems(), dict.viewkeys() and dict.viewvalues() are converted respectively to dict.items(), dict.keys() and dict.values(). It also wraps existing usages of dict.items(), dict.keys(), and dict.values() in a call to list.</p>
</blockquote>
</div>
<span class="comment-copy">This is a really interesting point, but the question is almost entirely a matter of opinion. I'd raise it with matplotlib devs / raise an issue on github. I think your workaround looks reasonable (i.e. Make a list from the values), but ultimately a matplotlib/numpy fix would be nice. Unfortunately I don't think the question suits the stack overflow format or rules on opinion based questions.</span>
<span class="comment-copy">@JRichardSnape: You are certainly right in that this question is probably (for most of us) mainly opinion based. When it comes to how to deal with the situation as it looks now, here it is a matter of taste and its not a very pertinent question, however, when it comes to if and how this issue will be addressed by the <code>numpy</code> or <code>matplotlib</code> guys, this has very little to to with ones personal opinion. So I would tend to disagree with you here.</span>
<span class="comment-copy">Sure, but I guess what I'm saying it's that the average SO answerer can't say what the library authors intend to do (if anything). Anyway, I guess we'll see if a dev comes along who can answer that part.</span>
