<div class="post-text" itemprop="text">
<p>I'm writing script in python, and now I have to create pretty big list exactly containing 248956422 integers. The point is, that some of this "0" in this table will be changed for 1,2 or 3, cause I have 8 lists, 4 with beginning positions of genes, and 4 with endings of them. 
The point is i have to iterate "anno" several time cause numbers replacing 0 can change with other iteration.
"Anno" has to be written to the file to create annotation file.
Here's my question, how can I divide, or do it on-the-fly , not to get memoryerror including replacing "0" for others, and 1,2,3s for others.
Mabye rewriting the file? I'm waitin for your advice, please ask me if it is not so clear what i wrote :P .</p>
<pre><code>whole_st_gen = [] #to make these lists more clear for example
whole_end_gen = [] # whole_st_gen has element "177" 
whole_st_ex = [] # and whole_end_gen has "200" so from position 177to200
whole_end_ex = [] # i need to put "1"
whole_st_mr = [] # of course these list can have even 1kk+ elements
whole_end_mr = [] # note that every st/end of same kind have equal length
whole_st_nc = [] 
whole_end_nc = [] #these lists are including some values of course
length = 248956422 
anno = ['0' for i in range(0,length)] # here i get the memoryerror
#then i wanted to do something like..
for j in range(0, len(whole_st_gen)):
    for y in range(whole_st_gen[j],whole_end_gen[j]):
        anno[y]='1'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might be better of by determine the value of each element in <code>anno</code> on the fly:</p>
<pre><code>def anno():
    for idx in xrange(248956422):
        elm = "0"

        for j in range(0, len(whole_st_gen)):
            if whole_st_gen[j] &lt;= idx &lt; whole_end_gen[j]:
                elm = "1"                    

        for j in range(0, len(whole_st_ex)):
            if whole_st_ex[j] &lt;= idx &lt; whole_end_ex[j]:
                elm = "2"                    

        for j in range(0, len(whole_st_mr)):
            if whole_st_mr[j] &lt;= idx &lt; whole_end_mr[j]:
                elm = "3"                    

        for j in range(0, len(whole_st_nc)):
            if whole_st_nc[j] &lt;= idx &lt; whole_end_nc[j]:
                elm = "4"                    

        yield elm
</code></pre>
<p>Then you just iterate using <code>for elm in anno()</code>. </p>
<p>I got an edit proposal from the OP suggesting one function for each of <code>whole_*_gen</code>, <code>whole_st_ex</code> and so on, something like this:</p>
<p>def anno_st():
     for idx in xrange(248956422):
         elm = "0"</p>
<pre><code>     for j in range(0, len(whole_st_gen)):
        if whole_st_ex[j] &lt;= idx &lt;= whole_end_ex[j]:
            elm = "2"                    

     yield elm
</code></pre>
<p>That's of course doable, but it will only result in the changes from <code>whole_*_ex</code> applied and one would need to combine them afterwards when writing to file which may be a bit awkward:</p>
<pre><code>for a, b, c, d in zip(anno_st(), anno_ex(), anno_mr(), anno_nc()):
    if d != "0":
        write_to_file(d)
    elif c != "0":
        write_to_file(c)
    elif b != "0":
        write_to_file(b)
    else:
        write_to_file(a)
</code></pre>
<p>However if you only want to apply some of the change sets you could write a function that takes them as parameters:</p>
<pre><code>def anno(*args):
    for idx in xrange(248956422):
        elm = "0"

        for st, end, tag in args:
             for j in range(0, len(st)):
                 if st &lt;= idx &lt; end[j]:
                      elm = tag

        yield tag
</code></pre>
<p>And then call by supplying the lists (for example with only the two first changes):</p>
<pre><code> for tag in anno((whole_st_gen, whole_end_gen, "1"),
                 (whole_st_ex, whole_end_ex, "2")):
     write_to_file(tag)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <code>bytearray</code> object to have a much more compact memory representation than a list of integers:</p>
<pre><code>anno = bytearray(b'\0' * 248956422)
print(anno[0])  # → 0
anno[0] = 2
print(anno[0])  # → 2
print(anno.__sizeof__())  # → 248956447 (on my computer)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of creating a list using list comprehension I suggest to create an iterator using a <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow"><em>generator-expression</em></a> which produce the numbers on demand instead of saving all of them in memory.Also you don't need to use the <code>i</code> in your loop since it's just a throw away variable which you don't use it.</p>
<pre><code>anno = ('0' for _ in range(0,length)) # In python 2.X use xrange() instead of range() 
</code></pre>
<p>But note that and iterator is a one shot iterable and you can not use it after iterating over it one time.If you want to use it for multiple times you can create <code>N</code> independent iterators from it using <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow"><em>itertools.tee()</em></a>.</p>
<p>Also note that you can not change it in-place if you want to change some elements based on a condition you can create a new iterator by iterating over your iterator and applying the condition using a generator expression.</p>
<p>For example :</p>
<pre><code>new_anno =("""do something with i""" for i in anno if #some condition)
</code></pre>
</div>
<span class="comment-copy">Whats your python version?</span>
<span class="comment-copy">What exactly do you need? Will <code>anno</code> contain anything near 248956422 elements different from <code>"0"</code> for example? How will <code>anno</code> be modified and so on?</span>
<span class="comment-copy">My python version is 2.7.1 @Kasramvd</span>
<span class="comment-copy">@skyking , my point is to iterate once to put "1" from whole_st/end/_gen , then i need to iterate again to change SOME OF "1" for "2" from whole_st/end_ex , same for the _mr and _nc . Then anno list will be written to file</span>
<span class="comment-copy">Yay, bytearrays :^) Note that <code>bytearray(248956422)</code> does the same thing. And if memory is an issue (because this <i>will</i> allocate the memory), OP could use a <a href="https://docs.python.org/2/library/mmap.html" rel="nofollow noreferrer">mmap</a> and treat values as int; this will be slower but not as memory hungry.</span>
<span class="comment-copy">Also you cannot modify the data (as the question indicated) if it's an iterator.</span>
<span class="comment-copy">@skyking Indeed, but It can be done with iterating over the current iterator and creating a new one!</span>
<span class="comment-copy">Yes, but that might be quite inefficient.</span>
<span class="comment-copy">@skyking Why in efficient??? using list comprehension you need to iterate over your list, but using iterators is very optimized in terms of memory use.</span>
<span class="comment-copy">Because everytime you want to change an element you'll have to (eventually) go through the sequence and replacing the element you want to modify. Until you have iterated through the result you will have one iterator for each change - that might become quite memory consuming depending on what changes need to be done.</span>
