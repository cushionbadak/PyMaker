<div class="post-text" itemprop="text">
<p>I'm currently in the process of learn how to use <code>cProfile</code> and I have a few doubts.</p>
<p>I'm currently trying to profile the following script:</p>
<pre><code>import time

def fast():
    print("Fast!")

def slow():
    time.sleep(3)
    print("Slow!")

def medium():
    time.sleep(0.5)
    print("Medium!")

fast()
slow()
medium()
</code></pre>
<p>I execute the command <code>python -m cProfile test_cprofile.py</code> and I have the following result:</p>
<pre class="lang-none prettyprint-override"><code>Fast!
Slow!
Medium!
     7 function calls in 3.504 seconds

Ordered by: standard name

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    1    0.000    0.000    3.504    3.504 test_cprofile.py:1(&lt;module&gt;)
    1    0.000    0.000    0.501    0.501 test_cprofile.py:10(medium)
    1    0.000    0.000    0.000    0.000 test_cprofile.py:3(fast)
    1    0.000    0.000    3.003    3.003 test_cprofile.py:6(slow)
    1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
    2    3.504    1.752    3.504    1.752 {time.sleep}
</code></pre>
<p>However, when I edit the script with a pylab import for example (<code>import pylab</code>) on the top, the output of <code>cProfile</code> is very large. I tried to limit the number of lines using <code>python -m cProfile test_cprofile.py | head -n 10</code> however I receive the following error:</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
File "/home/user/anaconda/lib/python2.7/runpy.py", line 162, in _run_module_as_main
"__main__", fname, loader, pkg_name)
File "/home/user/anaconda/lib/python2.7/runpy.py", line 72, in _run_code
exec code in run_globals
File "/home/user/anaconda/lib/python2.7/cProfile.py", line 199, in &lt;module&gt;
main()
File "/home/user/anaconda/lib/python2.7/cProfile.py", line 192, in main
runctx(code, globs, None, options.outfile, options.sort)
File "/home/user/anaconda/lib/python2.7/cProfile.py", line 56, in runctx
result = prof.print_stats(sort)
File "/home/user/anaconda/lib/python2.7/cProfile.py", line 81, in print_stats
pstats.Stats(self).strip_dirs().sort_stats(sort).print_stats()
File "/home/user/anaconda/lib/python2.7/pstats.py", line 360, in print_stats
self.print_line(func)
File "/home/user/anaconda/lib/python2.7/pstats.py", line 438, in print_line
print &gt;&gt; self.stream, c.rjust(9),
IOError: [Errno 32] Broken pipe
</code></pre>
<p>Can someone help what is the correct procedure to situations similar with this one, where we have an <code>import pylab</code> or another module that generates such high output information on <code>cProfile</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know of any way to do the selective profiling like you want by running the <code>cProfile</code> module directly from the command line like you're doing.</p>
<p>However, you can do it by modifying the your code to explicitly <code>import</code> the module, but you'll have to do everything yourself. Here's how that might be done to your example code:</p>
<p><sup>(Note: The following code is compatible with both Python 2 and 3.)</sup></p>
<pre><code>from cProfile import Profile
from pstats import Stats
prof = Profile()

prof.disable()  # i.e. don't time imports
import time
prof.enable()  # profiling back on

def fast():
    print("Fast!")

def slow():
    time.sleep(3)
    print("Slow!")

def medium():
    time.sleep(0.5)
    print("Medium!")

fast()
slow()
medium()

prof.disable()  # don't profile the generation of stats
prof.dump_stats('mystats.stats')

with open('mystats_output.txt', 'wt') as output:
    stats = Stats('mystats.stats', stream=output)
    stats.sort_stats('cumulative', 'time')
    stats.print_stats()
</code></pre>
<p><code>mystats_output.txt</code> file's contents afterwards:</p>
<pre class="lang-none prettyprint-override"><code>Sun Aug 02 16:55:38 2015    mystats.stats

         6 function calls in 3.522 seconds

   Ordered by: cumulative time, internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        2    3.522    1.761    3.522    1.761 {time.sleep}
        1    0.000    0.000    3.007    3.007 cprofile-with-imports.py:15(slow)
        1    0.000    0.000    0.515    0.515 cprofile-with-imports.py:19(medium)
        1    0.000    0.000    0.000    0.000 cprofile-with-imports.py:12(fast)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
</code></pre>
<p><strong>Update:</strong></p>
<p>You can make enabling the profiling a little easier by deriving your own <code>Profile</code> class with a <a href="https://docs.python.org/3/glossary.html#term-context-manager" rel="nofollow noreferrer">context manager</a> method to automate things. Instead of adding a method with a name like <code>enable_profiling()</code> to do this, I've implemented it so that you can just call the class instance in a <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code></a> statement. Profiling will automatically be turn off whenever the context controlled by the <code>with</code> statement is exited.</p>
<p>Here's the class:</p>
<pre><code>from contextlib import contextmanager
from cProfile import Profile
from pstats import Stats

class Profiler(Profile):
    """ Custom Profile class with a __call__() context manager method to
        enable profiling.
    """
    def __init__(self, *args, **kwargs):
        super(Profile, self).__init__(*args, **kwargs)
        self.disable()  # Profiling initially off.

    @contextmanager
    def __call__(self):
        self.enable()
        yield  # Execute code to be profiled.
        self.disable()
</code></pre>
<p>Using it instead of a stock <code>Profile</code> object would look something like this:</p>
<pre><code>profiler = Profiler()  # Create class instance.

import time  # Import won't be profiled since profiling is initially off.

with profiler():  # Call instance to enable profiling.
    def fast():
        print("Fast!")

    def slow():
        time.sleep(3)
        print("Slow!")

    def medium():
        time.sleep(0.5)
        print("Medium!")

    fast()
    slow()
    medium()

profiler.dump_stats('mystats.stats')  # Stats output generation won't be profiled.

with open('mystats_output.txt', 'wt') as output:
    stats = Stats('mystats.stats', stream=output)
    stats.strip_dirs().sort_stats('cumulative', 'time')
    stats.print_stats()

# etc...
</code></pre>
<p>Since it's a <code>Profile</code> subclass, all the base class' methods, such as <code>dump_stats()</code> are all still available for use as shown.</p>
<p>You could, of course, take it further and add e.g. a method to generate the stats and format them in some customized way.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you change your script slightly, then it'll be much easier to profile the script without also profiling your imports.</p>
<h3>test_cprofiler.py</h3>
<pre><code>import time
import pylab

def fast():
    print("Fast!")

def slow():
    time.sleep(3)
    print("Slow!")

def medium():
    time.sleep(0.5)
    print("Medium!")

def main():
    fast()
    slow()
    medium()

if __name__ == "__main__":
    main()
</code></pre>
<h3>profiler.py</h3>
<pre><code>import cProfile

import test_cprofiler

cProfile.run("test_cprofiler.main()")
</code></pre>
<p>Run as:</p>
<pre><code>python profiler.py
</code></pre>
<p>Which produces the following output:</p>
<pre><code>Fast!
Slow!
Medium!
         8 function calls in 3.498 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    3.498    3.498 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    2.998    2.998 run.py:11(slow)
        1    0.000    0.000    3.498    3.498 run.py:15(main)
        1    0.000    0.000    0.000    0.000 run.py:4(fast)
        1    0.000    0.000    0.500    0.500 run.py:7(medium)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        2    3.498    1.749    3.498    1.749 {time.sleep}
</code></pre>
</div>
<span class="comment-copy">Thanks for your reply. The fact that outputs a text file maybe be an advantage in case I'm try to do some graphical stuff with it.</span>
<span class="comment-copy">You're welcome. Actually the default <code>stream</code> is <code>sys.stdout</code>. My motivation for setting it up to write to a file was for use with gui-based programs. A hands-on approach like this not only allows you to fine-tune what section(s) of your code are profiled, the <code>pstats.Stats</code> instance also has a number of useful methods that provide a fair amount of control over what's output and how â€” check out <a href="https://docs.python.org/2/library/profile.html#module-pstats" rel="nofollow noreferrer">the documentation</a> for details.</span>
<span class="comment-copy">Thanks for your reply. It seems a elegant way to overcome my issue.</span>
