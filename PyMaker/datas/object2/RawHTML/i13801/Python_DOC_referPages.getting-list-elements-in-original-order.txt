<div class="post-text" itemprop="text">
<p>My current code:</p>
<pre><code>&gt;&gt;&gt; sent=['attachment', '(1.', '=', '+EDT)', 'Details']
&gt;&gt;&gt; [w[1:] for w in sent if w.startswith(('(', '+'))]+[w for w in sent if not w.startswith(('(', '+'))]
</code></pre>
<p>output:</p>
<pre><code>['1.', 'EDT)', 'attachment', '=', 'Details']
</code></pre>
<p>I want it like this:</p>
<pre><code>['attachment','1.', '=','EDT)', 'Details']
</code></pre>
<p>maintaining the original order.</p>
<p>I don't want to use <code>re.replace</code>, I just want to use <code>w.startswith()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To use <code>startswith()</code> while maintaining the original order you need to perform the operation inside one list comprehension. We can do that using a <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow">conditional expression</a>:</p>
<pre><code>sent = ['attachment', '(1.', '=', '+EDT)', 'Details']
print([w[1:] if w.startswith(('(', '+')) else w for w in sent])
</code></pre>
<p><strong>output</strong></p>
<pre><code>['attachment', '1.', '=', 'EDT)', 'Details']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code does not work since it is building 2 lists; the first one contains those which start with <code>+</code> or <code>(</code>, and the second one those which don't; these are then catenated in order.</p>
<hr/>
<p>Your code fixed and using a conditional expression properly would read</p>
<pre><code>&gt;&gt;&gt; sent = ['attachment', '(1.', '=', '+EDT)', 'Details']
&gt;&gt;&gt; [ w[1:] if w.startswith(('(', '+')) else w for w in sent ]
['attachment', '1.', '=', 'EDT)', 'Details']
</code></pre>
<hr/>
<p>However a better and more powerful option would be to use <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a> here</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; sent = ['attachment', '(1.', '=', '+EDT)', 'Details']
&gt;&gt;&gt; [ re.sub(r'^[+(]', '', w) for w in sent ]
['attachment', '1.', '=','EDT)', 'Details']
</code></pre>
<p>The <em>regular expression</em> <code>^[+(]</code> matches the beginning of string followed by exactly 1 <code>+</code> or <code>(</code>; whatever is matched is replaced with an empty string <code>''</code>.</p>
<hr/>
<p>On the other hand if you really want removing <em>all</em> leading <code>(</code> and <code>+</code> characters, no matter how many, use the <code>.lstrip</code>:</p>
<pre><code>&gt;&gt;&gt; sent = ['attachment', '(1.', '=', '+EDT)', 'Details']
&gt;&gt;&gt; [ w.lstrip('+(') for w in sent ]
['attachment', '1.', '=', 'EDT)', 'Details']
</code></pre>
<p>This will also replace <code>+(++++((((foo</code> with <code>foo</code> which might or might not be what you wanted.</p>
</div>
<span class="comment-copy">help me please guys</span>
<span class="comment-copy">If you describe in plain language what you want to do, it will be easier to help you. But anyway, <code>str.lstrip()</code> seems to be what you want.</span>
<span class="comment-copy">str.lstrip() can't help me in this situation :'(</span>
<span class="comment-copy">thank you so much DSM. this is great.</span>
<span class="comment-copy">Note that the OP doesn't want to import the <code>re</code> module for this - they want to do it with built-in methods. :)</span>
