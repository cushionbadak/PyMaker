<div class="post-text" itemprop="text">
<p>How can I find a list of all <code>**args</code> of a function?</p>
<p>For example, I know that <code>symbols()</code> take <code>positive=True</code>, <code>real=True</code>, etc. as arguments, and I would like to see a full list of these possible arguments.
However, they're not listed in the Sympy Core <a href="http://docs.sympy.org/latest/modules/core.html#sympy.core.symbol.symbols" rel="nofollow noreferrer">doc page</a>.</p>
<p>And I've dug through the source code itself, but I can't trace and locate what I'm looking for.</p>
</div>
<div class="post-text" itemprop="text">
<h3><code>symbols()</code> function</h3>
<p>As other answers have noted - one use of <code>**args</code> in the <code>symbols</code> is to pass in Assumptions about the <code>Symbol</code> being created.  The list of assumptions you can pass is documented under the <a href="http://docs.sympy.org/dev/modules/assumptions/index.html" rel="nofollow">Assumptions</a> page as <a href="http://docs.sympy.org/dev/modules/assumptions/index.html#supported-predicates" rel="nofollow">supported predicates</a>.</p>
<p><strong><em>However</em></strong>, you should also note that some other special named arguments can be passed in.</p>
<p>These are both documented in the section that you link and are:</p>
<ol>
<li><p><code>cls=&lt;ClassName&gt;</code></p>
<blockquote>
<p>Despite its name, symbols() can create symbol-like objects like instances of Function or Wild classes. To achieve this, set cls keyword argument to the desired type:</p>
</blockquote>
<p>N.B. If not specified, the default <code>Symbol</code> class is used.</p></li>
<li><p><code>seq=&lt;True|False&gt;</code></p>
<p>The docs say:</p>
<blockquote>
<p>If an iterable container is needed for a single symbol, set the <code>seq</code>
  argument to <code>True</code> or terminate the symbol name with a comma</p>
</blockquote></li>
</ol>
<h3>Code walk</h3>
<p>You note that you've looked through the code - so I'll show you where these are implemented in the code.  If you call the <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L86" rel="nofollow"><code>symbols()</code></a> function, it does various checks of its arguments, including <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L86" rel="nofollow"><code>pop</code>-ing <code>cls</code> and <code>seq</code></a> arguments from <code>**args</code> it then performs more checks etc, before finally calling through to instantiate the <code>Symbol</code> <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L476" rel="nofollow">here</a>, <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L513" rel="nofollow">here</a> or <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L515" rel="nofollow">here</a>.  These call the constructor of <code>Symbol</code> (or its subclass passed in via <code>cls</code>) with whatever is left in <code>**args</code> which are all interpreted as <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L91" rel="nofollow"><code>assumptions</code> in the constructor.</a> - they are <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L101" rel="nofollow"><code>sanitized</code> here</a> i.e. non-assumption or non-applicable named arguments are <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L86" rel="nofollow">thrown out</a> at this point!</p>
<p>This shows that Assumptions + <code>cls</code> + <code>seq</code> form the set of named arguments that can be passed in <code>**args</code> to <code>symbols()</code></p>
<hr/>
<h3>Other functions (general case)</h3>
<p>It occurs to me that <code>symbols()</code> may have simply served as a representative example of a more general question.  I hope the above has convinced you that all the values that can be usefully passed into <code>symbols()</code> are documented.  This may give you some confidence that the same is true for other functions within SymPy.</p>
<p>However, in the general case, the answer is that it is rather hard to prove to yourself that all the values that can be passed in as keywordarguments are in the documentation of <strong><em>any</em></strong> library or function.  Indeed, sometimes only a subset are documented deliberately as they are the "public API" for the library whereas the actual code may take other arguments, but for some reason the developer doesn't want to expose them to the public - e.g. because their availability may change, or their functionality is untested.</p>
<p>If you <em>do</em> pass in invalid arguments, the behaviour of the library you are using may differ.  Some libraries or functions will ignore them, while others will throw errors if you pass in invalid keyword arguments.</p>
<p>If you want to find out whether that's the case (and the library is open source, like SymPy), then you can always dive through the code (as I show in the Code Walk above).  If you do that - you need to follow the path of execution, looking for occurences of <code>args.pop()</code>.  If there are other functions in SymPy that you are concerned about let me know in comments - but hopefully this general method will work for you.</p>
<p>I'm assuming in the above that you understand the <code>*args</code> and <code>**args</code> syntax.  If that's not totally clear for you - this section of the <a href="https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments" rel="nofollow">python official tutoria</a>l deals with it.</p>
</div>
<div class="post-text" itemprop="text">
<p>These arguments are named assumptions and can be found in the documentation:
<a href="http://docs.sympy.org/dev/modules/assumptions/index.html" rel="nofollow">Sympy Assumptions</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Classification of assumptions</strong></p>
<ul>
<li>related with symbols for simplification, e.g. <code>Q.positive</code>, <code>Q.even</code>.</li>
<li>related with algebraic fields/rings, e.g. <code>Q.real</code>, <code>Q.complex</code>.</li>
<li>related with some facts, e.g. .<code>is_bounded</code>, <code>is_infinity</code>, <code>is_zero</code> and
so on. They are help us to operate with calculation in core.
Apparently they are derived from the above other classes of
assumptions (while start-upping of the objects) (in this case e.g.
is_zero is means that it is a Zero for the ring). Or they can be
derived from expression's analyze: in this case we can create some
class of assumption that are calculated (in this case is_zero can be
means but it this sort of calculation is a difficult so called "zero
test" problem). In any case we can realize in mind with what we deal
exactly (now in the core somewhere we used is_zero in second sense).</li>
</ul>
<p><strong>Assumptions Examples :</strong></p>
<pre><code>M ... Mathematica
S0 ... SymPy, current approach
S1 .... SymPy, approach 1
S2 .... SymPy, approach 2

M: Simplify[1/Sqrt[x] - Sqrt[1/x], x &gt; 0]
S1: x = Symbol('x', assumptions=IsPositive)
  simplify(1/sqrt(x) - sqrt(1/x))
S2: simplify(1/sqrt(x) - sqrt(1/x), Assumptions(x&gt;0))

M: FunctionExpand[Log[x y], x &gt; 0 &amp;&amp; y &gt; 0]
S1: x, y = Symbol('x', assumptions=IsPositive), Symbol('y', assumptions=IsPositive)
 log(x*y).expand()
S2: log(x*y).expand(Assumptions([x&gt;0, y&gt;0]))

M: Simplify[Sin[n Pi], n \[Element] Integers]
S1: n = Symbol('n', assumptions=IsInteger)
  simplify(sin(n*pi))
S2: simplify(sin(n*pi), Assumptions(Element(n, Integer)))

# we can talk about the syntax of Element(n, Integer)

M: FunctionExpand[EulerPhi[m n], {m, n} \[Element] Integers &amp;&amp; GCD[m, n] == 1]
S1: n = Symbol('n', assumptions=IsInteger)
  m = Symbol('m', assumptions=IsInteger)
  n.assumptions.add(Eq(gcd(m, n) - 1))
  euler_phi(m, n)
S2: euler_phi(m, n).expand(Assumptions([Element(n, Integer), Element(m, Integer), Eq(gcd(m, n) - 1)]))

# again we can talk about the syntax of Element(n, Integer)

M: RealQ[x, x \[Element] Real]
S0: x = Symbol('x',real=True, integer=True)
  assert x.is_real == True
S1:
S2: assert IsElement(x, Real, assumptions=Element(x, Real))

M: Refine[Abs[x], x&gt;0]
   Refine[Abs[x], x0))
  print e.refine(Assumptions(x))
</code></pre>
<p>More References :</p>
<p><a href="https://github.com/sympy/sympy/wiki/Assumptions" rel="nofollow noreferrer"><strong>Wiki Sympi Assumptions</strong></a></p>
<p><a href="http://matthewrocklin.com/blog/work/2013/02/05/Assuming/" rel="nofollow noreferrer"><strong>Assuming</strong></a> </p>
<p><a href="https://stackoverflow.com/questions/16431552/setting-assumptions-on-variables-in-sympy-relative-to-other-variables">Setting Assumptions on Variables in Sympy Relative to Other Variables</a></p>
<p><a href="https://stackoverflow.com/questions/22749270/using-sympys-new-assumptions">Using SymPy's New Assumptions</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can get the argument details from any function using a built-in python library called <code>inspect</code>:</p>
<pre><code>import inspect
inspect.getargspec(funcname)
</code></pre>
<p>It will return an <code>ArgSpec</code> named tuple with some information such as:</p>
<pre><code>ArgSpec(args=['myarg'], varargs=None, keywords=None, defaults=(None,))
</code></pre>
<p>To get the argument names you can simply access the <code>args</code> attribute of that returned object.</p>
</div>
<span class="comment-copy">Just wondered whether the answers here have helped you, or if you need more detail in any particular aspect?</span>
<span class="comment-copy">Yes sir.  Sounds like the Assumptions Module is the place to look.  And I especially appreciate the code walk!   Very instructive.  It's easy for me to say this from my seat on the sidelines, but it would be nice to have this documented in the doc page.</span>
<span class="comment-copy">Excellent - glad it helped.  If you feel an answer has solved the issue, please do <a href="http://stackoverflow.com/help/someone-answers">accept it.</a> I agree the docs could be more explicit in saying "this is a complete list of all the possible arguments you can pass in"</span>
<span class="comment-copy">@Dietrich as you're the one putting up the bounty, I wondered if you were more interested in the specific <code>symbols()</code> function, or whether there is something else you wanted that I might be able to help with?</span>
<span class="comment-copy">Many thanks for the comprehensive answer. The link to the Assumptions page is really helpful. As a casual Sympy user (trying to be less addicted to Mathematica), I have problems remembering those parameters, especially since they are not checked for validity: E.g., <code>symbols('x', pos=True)</code> does not raise a Error (which is not a nice bug to find in one's code).</span>
<span class="comment-copy">Thanks for the comment and bounty.  i agree - those kinds of errors are horrible.  I don't really like the way SymPy ignores unsupported names by just <a href="https://github.com/sympy/sympy/blob/sympy-0.7.6/sympy/core/symbol.py#L86" rel="nofollow noreferrer">popping them and ignoring here</a>.  It's not a bug as such, but it does make the exmple you give really horrible to debug.</span>
<span class="comment-copy">Whilst this would work for named arguments - it is not applicable here where the OP is looking for a list of keyword arguments that are valid when passed in the <code>**args dict</code>.  You can test this by importing <code>sympy</code> and doing <code>inspect.getargspec(sympy.symbols)</code>. You get <code>ArgSpec(args=['names'], varargs=None, keywords='args', defaults=None)</code>, not a list of all values that can be passed in <code>args</code></span>
