<div class="post-text" itemprop="text">
<p>I am working on a script where it will breakdown another python script into blocks and using pycrypto to encrypt the blocks (all of this i have successfully done so far), now i am storing the encrypted blocks to a file so that the decrypter can read it and execute each block. The final result of the encryption is a list of binary outputs (something like <code>blocks=[b'\xa1\r\xa594\x92z\xf8\x16\xaa',b'xfbI\xfdqx|\xcd\xdb\x1b\xb3',etc...]</code>). </p>
<p>When writing the output to a file, they all end up into one giant line, so that when reading the file, all the bytes come back in one giant line, instead of each item from the original list. I also tried converting the bytes into a string, and adding a <code>'\n'</code> at the end of each one, but the problem there is that I still need the bytes, and I can't figure out how to undo the string to get the original byte.</p>
<p>To summarize this, i am looking to either: write each binary item to a separate line in a file so i can easily read the data and use it in the decryption, or i could translate the data to a string and in the decrpytion undo the string to get back the original binary data.</p>
<p>Here is the code for writing to the file:</p>
<pre><code>    new_file = open('C:/Python34/testfile.txt','wb')
    for byte_item in byte_list:
        # This or for the string i just replaced wb with w and
        # byte_item with ascii(byte_item) + '\n'
        new_file.write(byte_item)
    new_file.close()
</code></pre>
<p>and for reading the file:</p>
<pre><code>    # Or 'r' instead of 'rb' if using string method
    byte_list = open('C:/Python34/testfile.txt','rb').readlines()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A file is a stream of bytes without any implied structure. If you want to load a list of binary blobs then you should store some additional metadata to restore the structure e.g., you could <a href="http://cr.yp.to/proto/netstrings.txt" rel="nofollow">use the netstring format</a>:</p>
<pre><code>#!/usr/bin/env python
blocks = [b'\xa1\r\xa594\x92z\xf8\x16\xaa', b'xfbI\xfdqx|\xcd\xdb\x1b\xb3']

# save blocks
with open('blocks.netstring', 'wb') as output_file:
    for blob in blocks:
        # [len]":"[string]","
        output_file.write(str(len(blob)).encode())
        output_file.write(b":")
        output_file.write(blob)
        output_file.write(b",")
</code></pre>
<p>Read them back:</p>
<pre><code>#!/usr/bin/env python3
import re
from mmap import ACCESS_READ, mmap

blocks = []
match_size = re.compile(br'(\d+):').match
with open('blocks.netstring', 'rb') as file, \
     mmap(file.fileno(), 0, access=ACCESS_READ) as mm:
    position = 0
    for m in iter(lambda: match_size(mm, position), None):
        i, size = m.end(), int(m.group(1))
        blocks.append(mm[i:i + size])
        position = i + size + 1 # shift to the next netstring
print(blocks)
</code></pre>
<p>As an alternative, you could <a href="http://bsonspec.org/" rel="nofollow">consider BSON format for your data</a> or <a href="http://tools.ietf.org/html/rfc4880#section-6.2" rel="nofollow">ascii armor format</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you're looking for is <code>byte_list=open('C:/Python34/testfile.txt','rb').read()</code></p>
<p>If you know how many bytes each item is, you can use <code>read(number_of_bytes)</code> to process one item at a time.</p>
<p><code>read()</code> will read the entire file, but then it is up to you to decode that entire list of bytes into their respective items.</p>
</div>
<div class="post-text" itemprop="text">
<p>In general, since you're using Python 3, you will be working with <a href="https://docs.python.org/3/library/functions.html#bytes" rel="nofollow"><code>bytes</code></a> objects (which are immutable) and/or <a href="https://docs.python.org/3/library/functions.html#bytearray" rel="nofollow"><code>bytearray</code></a> objects (which are mutable).</p>
<p>Example:</p>
<pre><code>b1 = bytearray('hello', 'utf-8')
print b1

b1 += bytearray(' goodbye', 'utf-8')
print b1

open('temp.bin', 'wb').write(b1)

#------

b2 = open('temp.bin', 'rb').read()
print b2
</code></pre>
<p>Output:</p>
<pre><code>bytearray(b'hello')
bytearray(b'hello goodbye')
b'hello goodbye'
</code></pre>
</div>
<span class="comment-copy"><i>"list of bytes that I want to store to a txt file"</i> You store <i>text</i> in text files, and you store arbitrary bytes in a <i>binary</i> file.  <code>readlines()</code> is for reading lines of <i>text</i>.</span>
<span class="comment-copy">so what should my code look like instead?</span>
<span class="comment-copy">how exactly does this solve my problem? This will just gives me a giant byte, what i am looking for is on the receiving end to have a list of the bytes that went in (in your case, when i read/readline i would be able to easily derive  <code>[b'hello',b'goodbye']</code>  )</span>
<span class="comment-copy"><i>"a giant byte"</i> - Lol "byte" almost always means "octet" these days, exactly 8 bits.   If you're actually dealing with binary data, it would be incredibly inefficient in Python to have a <code>list</code> of individual byte values, which is why I suggested using <code>bytes</code> and <code>bytearray</code> objects.  You haven't explained what kind of data you're actually trying to store and recover, so it's difficult to give better advice - especially because you refer to both "bytes" (implying binary data) and strings of text.</span>
<span class="comment-copy">ill edit my question and hopefully this will help you understand what i am looking for: what i am trying to acomplish is: i have a python script, i am breaking down the script into blocks and using pycrypto to encrypt the blocks (all of this i have successfully done so far), now i am storing the encrypted blocks to a file so that the decrypter can read it and execute each block. The final result of the encryption is a list of binary outputs</span>
