<div class="post-text" itemprop="text">
<p>In Python, data types (like int, float) both represent a value, but also have some built-in attributes/functions/etc:</p>
<pre><code>In [1]: a = 1.2

In [2]: a
Out[2]: 1.2

In [3]: a.is_integer()
Out[3]: False
</code></pre>
<p>Is it possible to reproduce this behavior within Python, e.g. define a class:</p>
<pre><code>class Scalar:
    def __init__(self, value)
        self.value = value

    # other code ....

s = Scalar(1.2)
</code></pre>
<p>where I could have <code>s</code> return 1.2 (instead of typing <code>s.value</code>), and do things like <code>a = s</code> -&gt; <code>a = 1.2</code>? The closest I can get to this behavior is adding something like:</p>
<pre><code>def __getitem__(self, key=None):
    return self.value
</code></pre>
<p>and using <code>a = s[()]</code>, but that doesn't look very good.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>where I could have s return 1.2 (instead of typing s.value)</p>
</blockquote>
<p>In the console? Then implement the <code>__repr__</code> method.</p>
<blockquote>
<p>a = s -&gt; a = 1.2</p>
</blockquote>
<p>To avoid having to use <code>a = s.value</code>, you can implement <code>__call__</code> and call the object:</p>
<pre><code>&gt;&gt;&gt; class Scalar:
...     def __init__(self, value):
...         self.value = value
...     def __repr__(self):
...         return str(self.value)
...     def __call__(self):
...         return self.value
... 
&gt;&gt;&gt; s = Scalar(1.2)
&gt;&gt;&gt; s
1.2
&gt;&gt;&gt; a = s()
&gt;&gt;&gt; a
1.2
</code></pre>
<p>Check the documentation about the <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow">data model on emulating numeric types</a>.</p>
<p>For example:</p>
<pre><code>class Scalar:
    def __init__(self, value):
        self.value = value
    def __repr__(self):
        return str(self.value)
    def __call__(self):
        return self.value
    def __add__(self, other):
        return Scalar(self.value + other.value)
    def __lt__(self, other):
        return self.value &lt; other.value
    def ___le__(self, other):
        return self.value &lt;= other.value
    def __eq__(self, other):
        return self.value == other.value
    def __ne__(self, other):
        return self.value != other.value
    def __gt__(self, other):
        return self.value &gt; other.value
    def __ge__(self, other):
        return self.value &gt;= other.value
</code></pre>
<p>Can be used like this:</p>
<pre><code>&gt;&gt;&gt; s1 = Scalar(1.2)
&gt;&gt;&gt; s2 = Scalar(2.1)
&gt;&gt;&gt; s1 + s2
3.3
&gt;&gt;&gt; s1 &lt; s2
True
&gt;&gt;&gt; s1 &gt; s2
False
&gt;&gt;&gt; s1 != s2
True
&gt;&gt;&gt; s1 &lt;= s2
True
&gt;&gt;&gt; s1 &gt;= s2
False
</code></pre>
<p>There are also the <a href="https://docs.python.org/3/reference/datamodel.html#object.__int__" rel="nofollow"><code>__int__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__float__" rel="nofollow"><code>__float__</code></a> magic methods, which you can implement and use like this (this is more semantically correct):</p>
<pre><code>&gt;&gt;&gt; a = int(s)
&gt;&gt;&gt; a = float(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know, that's not possible for your <code>a = s</code> example. You would have to change the behavior of <code>=</code>, the assignment operator. The assignment operator doesn't really do anything to the object on the right, it just copies a reference to it (in the case of an object, at least).</p>
<p>In general, it is possible to change the behavior of built in operators for your custom classes using <a href="http://blog.teamtreehouse.com/operator-overloading-python" rel="nofollow">operator overloading</a>, but Python doesn't provide this sort of option for assignment (<code>=</code>) because of how different it is from operators like addition (<code>+</code>) and even equality (<code>==</code>).</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/13029254/python-property-callable">Python property callable</a></span>
<span class="comment-copy">In particular, see the snippet with a <code>WeirdInteger</code> class.</span>
<span class="comment-copy">This isn't a general solution, but you could make your <code>Scalar</code> class in your example work the way you want by simply subclassing float (or int, or whatever other scalar type you wanted to mimic). <code>class Scalar(float): pass; s = Scalar(1.2)</code></span>
<span class="comment-copy">See also: <a href="https://stackoverflow.com/questions/11024646/is-it-possible-to-overload-python-assignment" title="is it possible to overload python assignment">stackoverflow.com/questions/11024646/â€¦</a></span>
<span class="comment-copy">subclassing a type might work, I have to see if it works for my (more complicated..) problem, but I'll give it a try!</span>
<span class="comment-copy">Well, the <code>__call__</code> gets rid of one set of brackets, so that's an improvement ;-) If I can't find another solution and the suggestions from above (using <code>class Scalar(float)</code>) don't work, it might be an acceptable solution</span>
<span class="comment-copy"><code>__repr__</code> is going to complain if you try to return anything but a string: <code>TypeError: __repr__ returned non-string (type float)</code>. This also won't affect assignment statements (<code>a = s</code>) as described in the question.</span>
<span class="comment-copy">Why is this answer getting downvoted when it says essentially the exact same thing as all of the answers <a href="https://stackoverflow.com/questions/11024646/is-it-possible-to-overload-python-assignment">here</a>?</span>
<span class="comment-copy">@Two-BitAlchemist - It says "that's not possible" when basic subclassing makes it possible.</span>
<span class="comment-copy">@TigerhawkT3 Kind of... It doesn't make it possible in the general case, and it doesn't make sense to subclass, say, string if this is the <i>only</i> behavior you want.</span>
<span class="comment-copy">This answer is correct. It only answers part of the question but since <code>=</code> can't be overridden OP can't get the complete behaviour they were after.</span>
