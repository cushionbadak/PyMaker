<div class="post-text" itemprop="text">
<h2>Question</h2>
<p>Using Python's <code>asyncio</code> module, how do I select the first result from multiple coroutines?  </p>
<h2>Example</h2>
<p>I might want to implement a timeout on waiting on a queue:</p>
<pre><code>result = yield from select(asyncio.sleep(1),
                           queue.get())
</code></pre>
<h2>Analagous Operations</h2>
<p>This would be similar to <a href="https://gobyexample.com/non-blocking-channel-operations">Go's <code>select</code></a> or <a href="https://clojuredocs.org/clojure.core.async/alt!">Clojure's <code>core.async.alt!</code></a>.  It is something like the converse of <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><code>asyncio.gather</code></a> (gather is like <code>all</code>, select would be like <code>any</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can implement this using both <code>asyncio.wait</code> and <code>asyncio.as_completed</code>:</p>
<pre><code>import asyncio

@asyncio.coroutine
def ok():
    yield from asyncio.sleep(1)
    return 5

@asyncio.coroutine
def select1(*futures, loop=None):
    if loop is None:
        loop = asyncio.get_event_loop()
    return (yield from next(asyncio.as_completed(futures)))

@asyncio.coroutine
def select2(*futures, loop=None):
    if loop is None:
        loop = asyncio.get_event_loop()
    done, running = yield from asyncio.wait(futures,
                                            return_when=asyncio.FIRST_COMPLETED)
    result = done.pop()
    return result.result()

@asyncio.coroutine
def example():
    queue = asyncio.Queue()
    result = yield from select1(ok(), queue.get())
    print('got {}'.format(result))
    result = yield from select2(queue.get(), ok())
    print('got {}'.format(result))

if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(example())
</code></pre>
<p>Output:</p>
<pre><code>got 5
got 5
Task was destroyed but it is pending!
task: &lt;Task pending coro=&lt;get() done, defined at /usr/lib/python3.4/asyncio/queues.py:170&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[as_completed.&lt;locals&gt;._on_completion() at /usr/lib/python3.4/asyncio/tasks.py:463]&gt;
Task was destroyed but it is pending!
task: &lt;Task pending coro=&lt;get() done, defined at /usr/lib/python3.4/asyncio/queues.py:170&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;
</code></pre>
<p>Both implementations return the value yielded by the first completed <code>Future</code>, but you can easily tweak it to return the <code>Future</code> itself, instead. Note that because the other <code>Future</code> passed to each <code>select</code> implementation is never yielded from, a warning gets raised when the process exits.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple solution, by using <code>asyncio.wait</code> and its <code>FIRST_COMPLETED</code> parameter:</p>
<pre><code>import asyncio

async def something_to_wait():
    await asyncio.sleep(1)
    return "something_to_wait"

async def something_else_to_wait():
    await asyncio.sleep(2)
    return "something_else_to_wait"


async def wait_first():
    done, pending = await asyncio.wait(
        [something_to_wait(), something_else_to_wait()],
        return_when=asyncio.FIRST_COMPLETED)
    print("done", done)
    print("pending", pending)

asyncio.get_event_loop().run_until_complete(wait_first())
</code></pre>
<p>gives:</p>
<pre><code>done {&lt;Task finished coro=&lt;something_to_wait() done, defined at stack.py:3&gt; result='something_to_wait'&gt;}
pending {&lt;Task pending coro=&lt;something_else_to_wait() running at stack.py:8&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;}
Task was destroyed but it is pending!
task: &lt;Task pending coro=&lt;something_else_to_wait() running at stack.py:8&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the case of wanting to apply a timeout to a task, there is a standard library function that does exactly this: <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer"><code>asyncio.wait_for()</code></a>. Your example can be written like this:</p>
<pre><code>try:
  result = await asyncio.wait_for(queue.get(), timeout=1)
except asyncio.TimeoutError:
  # This block will execute if queue.get() takes more than 1s.
  result = ...
</code></pre>
<p>But this only works for the specific case of a timeout. The other two answers here generalize to any arbitrary set of tasks, but neither of those answers shows how to clean up the tasks which don't finish first. This is what causes the "Task was destroyed but it is pending" messages in the output. In practice, you should do something with those pending tasks. Based on your example, I'll assume that you don't care about the other tasks' results. Here's an example of a <code>wait_first()</code> function that returns the value of the first completed task and cancels the remaining tasks.</p>
<pre><code>import asyncio, random

async def foo(x):
    r = random.random()
    print('foo({:d}) sleeping for {:0.3f}'.format(x, r))
    await asyncio.sleep(r)
    print('foo({:d}) done'.format(x))
    return x

async def wait_first(*futures):
    ''' Return the result of the first future to finish. Cancel the remaining
    futures. '''
    done, pending = await asyncio.wait(futures,
        return_when=asyncio.FIRST_COMPLETED)
    gather = asyncio.gather(*pending)
    gather.cancel()
    try:
        await gather
    except asyncio.CancelledError:
        pass
    return done.pop().result()

async def main():
    result = await wait_first(foo(1), foo(2))
    print('the result is {}'.format(result))

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    loop.close()
</code></pre>
<p>Running this example:</p>
<pre><code># export PYTHONASYNCIODEBUG=1
# python3 test.py
foo(1) sleeping for 0.381
foo(2) sleeping for 0.279
foo(2) done
the result is 2
# python3 test.py
foo(1) sleeping for 0.048
foo(2) sleeping for 0.515
foo(1) done
the result is 1
# python3 test.py
foo(1) sleeping for 0.396
foo(2) sleeping for 0.188
foo(2) done
the result is 2
</code></pre>
<p>There are no error messages about pending tasks, because each pending task has been cleaned up correctly.</p>
<p>In practice, you probably want <code>wait_first()</code> to return the future, not the future's result, otherwise it will be really confusing trying to figure out which future finished. But in the example here, I returned the future's result since it looks a little cleaner.</p>
</div>
<span class="comment-copy">This is the better answer.</span>
<span class="comment-copy">@skb I'm curious, what do you like better? Just that it doesn't also include a second way to do it? My answer covers the exact same <code>asyncio.wait</code>/<code>FIRST_COMPLETED</code> approach.</span>
