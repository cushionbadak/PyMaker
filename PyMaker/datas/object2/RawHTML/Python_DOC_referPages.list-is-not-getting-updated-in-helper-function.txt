<div class="post-text" itemprop="text">
<p>I have written below code to find root to leaf paths of binary tree. But this code is not updating <code>op</code> list variable. when I use <code>op.extend(value)</code>
 inside helper function it extend the list but not sure why its not appending the list? I am expecting <code>op</code> as a list of paths and path is itself a list. e.g.:</p>
<p><code>[[1,2,5],[1,3]]</code></p>
<h1>python 2.7 code:</h1>
<pre><code>def treepaths(root):
  op=[]
  currPath=[]

  def _path(root):
    if not root:
      return

    currPath.append(root.val)
    _path(root.left)

    if not root.left and not root.right:
      op.append(currPath)
    _path(root.right)
    currPath.pop()

  _path(root)
  return op
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I see what your problem is.  @J.K. was onto something. The problem is that you're putting a REFERENCE to <strong>currPath</strong> into <strong>op</strong> whenever you reach a leaf.  Since that is a reference, when you later manipulate <strong>currPath</strong> further, that changes all of the referenced objects (that same object) that you've pushed to <strong>op</strong> too.  And since at the end of your traversal of the tree, <strong>currPath</strong> ends up empty, so do all the referenced objects inside <strong>op</strong>.  All you need to do to fix this is COPY the list into 'op' each time.  So:</p>
<pre><code>op.append(currPath)
</code></pre>
<p>should be:</p>
<pre><code>op.append(list(currPath))
</code></pre>
<p>and I think you'll get the result you expect.</p>
<p>Here's a complete example I put together.  In the future, this is the sort of thing we'd like to see posted as a question:</p>
<pre><code>class Node:
    def __init__(self, val, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right

root = Node("A",
    Node("B",
        Node("C",
             Node("D"))),
    Node("F",
         Node("G",
              Node("H")),
         Node("I",
              None,
              Node("J")))
    )


def treepaths(root):
    op = []
    currPath = []

    def _path(root):
        if not root:
            return

        currPath.append(root.val)
        _path(root.left)

        if not root.left and not root.right:
            op.append(list(currPath))
        _path(root.right)
        currPath.pop()

    _path(root)
    return op

print(treepaths(root))
</code></pre>
<p>Which results in:</p>
<pre><code>[['A', 'B', 'C', 'D'], ['A', 'F', 'G', 'H'], ['A', 'F', 'I', 'J']]
</code></pre>
<p>Without the fix, you get:</p>
<pre><code>[[], [], []]
</code></pre>
</div>
<span class="comment-copy">I guess that currPath.pop() is removing the path from op. Try to comment this line?</span>
<span class="comment-copy">I see the logic in your code.  I can see how to make it read a little better and be a bit more efficient, but it seems like it should work.  Can you provide code to build a sample tree and show the output and also give us your expected output?  In other words, can you provide a <a href="https://stackoverflow.com/help/mcve">MCVE</a></span>
<span class="comment-copy">Thanks Steve! Still I wonder how code works fine with op.extend(currPath)</span>
<span class="comment-copy">Glad I could help!  You will get different results with op.extend().  That would add each item in <b>currPath</b> individually to <b>op</b> rather than adding the list itself.  So you would end up in that case with a list of just strings, not a list of lists of strings.  And that "works" because you have to copy the individual elements to add them to <b>ops</b>, so the "copying a reference" thing doesn't apply.</span>
