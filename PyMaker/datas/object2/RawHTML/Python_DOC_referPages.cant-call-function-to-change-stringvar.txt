<div class="post-text" itemprop="text">
<p>I am attempting to create a little clock by changing a <code>tkinter</code> label and using the <code>Time Module</code>. What I can't figure out is how to call the <code>test()</code> function with the while loop because I constantly get an error for <code>timee</code> is not defined or <code>test()</code> is not defined. Is there something I'm missing? </p>
<pre><code>import time
from tkinter import *

def test():
    seconds = time.time()
    local_time = time.ctime(seconds)
    timee.set('The Time Is: ' + local_time)

while 1 &gt; 0:
    test()

root = Tk()
timee = StringVar()

l = Label(root, textvariable=timee)
l.pack(side=TOP)

root.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you imagine your program running from top to bottom, you never reach the part where you create the <code>Tk</code>, <code>StringVar</code> and <code>Label</code> object; since it gets stuck in the infinite <code>while</code> loop. The error you get is because when you are calling <code>test</code>, <code>timee</code> is yet to defined.</p>
<p>Simply put, your program can only do one thing at a time. When it is busy running the clock, it cannot create TKinter windows. OTOH, when it is managing a tkinter window (<code>.mainloop</code> function), it cannot update your clock.</p>
<p>You need to get both to play nice with each other. There is a special method for the Tkinter object to tell it that you want something done: <code>after</code>. (See <a href="https://effbot.org/tkinterbook/widget.htm" rel="nofollow noreferrer">tkinter Widget docs</a>):</p>
<pre><code>import time
from tkinter import *

def test():
    seconds = time.time()
    local_time = time.ctime(seconds)
    timee.set('The Time Is: ' + local_time)
    # after updating, schedule next call in 1 second
    root.after(1000, test)

root = Tk()
timee = StringVar()

l = Label(root, textvariable=timee)
l.pack(side=TOP)

# Before starting up, instruct Tkinter to run test after 1 second
root.after(1000, test)
root.mainloop()
</code></pre>
<p>As you see, there is no explicit call of <code>test()</code> anymore. Instead, in <code>after()</code>, the test function is passed as a variable. You can think of handing <code>after()</code> a list of instructions without already executing them.</p>
<p>Then, when tkinter is running its window (<code>.mainloop()</code> call), it will look at its list of things-to-do and will find the <code>test</code> call that you ordered. At the right time it will call the <code>test</code> function one time; then at the end of the function, the next call is scheduled.</p>
</div>
<div class="post-text" itemprop="text">
<p>timee is not defined because your function is looking for the local var timee but you want to alter the global variable so you need to indicate it to your function</p>
<pre><code>def test():
    global timee
    seconds = time.time()
    local_time = time.ctime(seconds)
    timee.set('The Time Is: ' + local_time)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Tkinter applications are user even-driven which means normal procedural programming techniques often won't work â€” all processing has to occur while <code>mainloop()</code> is running.</p>
<p>In this case you can use the universal widget method <a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/universal.html" rel="nofollow noreferrer"><code>after{}</code></a> to schedule calls to your test function at regular intervals, like every <sup>1</sup>/<sub>4</sub> second (250 ms):</p>
<pre><code>import time
from tkinter import *

def test():
    seconds = time.time()
    local_time = time.ctime(seconds)
    timee.set('The Time Is: ' + local_time)

def poll():
    test()
    root.after(250, poll)  # Schedule another call.

root = Tk()
timee = StringVar()

l = Label(root, textvariable=timee)
l.pack(side=TOP)

poll()  # Start periodic calls to test()
root.mainloop()
</code></pre>
</div>
<span class="comment-copy">Where is <code>StringVar()</code> defined?</span>
<span class="comment-copy">It is because the while loop will block the program from creating the <code>timee</code> widget.</span>
<span class="comment-copy">Ah, I just realized.</span>
<span class="comment-copy">Oh I never knew this existed thank you! Works great!</span>
<span class="comment-copy"><code>global timee</code> is optional if <code>timee</code> is not assigned to new instance.  In OP case, only <code>timee</code> reference is used (i.e. <code>timee.set(...)</code>).</span>
<span class="comment-copy">Ohhhh I didn't realise Thank you!</span>
<span class="comment-copy">Ohh i see so everything has to occur "inside" Mainloop instead of the usual top to bottom method. Thank you!</span>
