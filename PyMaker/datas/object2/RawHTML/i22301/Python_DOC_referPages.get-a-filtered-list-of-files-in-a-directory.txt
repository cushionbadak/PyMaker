<div class="post-text" itemprop="text">
<p>I am trying to get a list of files in a directory using Python, but I do not want a list of ALL the files.</p>
<p>What I essentially want is the ability to do something like the following but using Python and not executing ls.</p>
<pre><code>ls 145592*.jpg
</code></pre>
<p>If there is no built-in method for this, I am currently thinking of writing a for loop to iterate through the results of an <code>os.listdir()</code> and to append all the matching files to a new list.</p>
<p>However, there are a lot of files in that directory and therefore I am hoping there is a more efficient method (or a built-in method).</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/glob.html#glob.glob" rel="noreferrer"><code>glob.glob('145592*.jpg')</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>glob.glob()</code> is definitely the way to do it (as per Ignacio). However, if you do need more complicated matching, you can do it with a list comprehension and <code>re.match()</code>, something like so:</p>
<pre><code>files = [f for f in os.listdir('.') if re.match(r'[0-9]+.*\.jpg', f)]
</code></pre>
<p>More flexible, but as you note, less efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>Keep it simple:</p>
<pre><code>import os
relevant_path = "[path to folder]"
included_extensions = ['jpg','jpeg', 'bmp', 'png', 'gif']
file_names = [fn for fn in os.listdir(relevant_path)
              if any(fn.endswith(ext) for ext in included_extensions)]
</code></pre>
<p>I prefer this form of list comprehensions because it reads well in English.</p>
<p>I read the fourth line as:
  For each fn in os.listdir for my path, give me only the ones that match any one of my included extensions.</p>
<p>It may be hard for novice python programmers to really get used to using list comprehensions for filtering, and it can have some memory overhead for very large data sets, but for listing a directory and other simple string filtering tasks, list comprehensions lead to more clean documentable code.</p>
<p>The only thing about this design is that it doesn't protect you against making the mistake of passing a string instead of a list.  For example if you accidentally convert a string to a list and end up checking against all the characters of a string, you could end up getting a slew of false positives.</p>
<p>But it's better to have a problem that's easy to fix than a solution that's hard to understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import os, fnmatch
&gt;&gt;&gt; fnmatch.filter(os.listdir('.'), '*.py')
['manage.py']
</code></pre>
<p><a href="https://docs.python.org/3/library/fnmatch.html" rel="noreferrer">https://docs.python.org/3/library/fnmatch.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>use os.walk to  recursively list your files</p>
<pre><code>import os
root = "/home"
pattern = "145992"
alist_filter = ['jpg','bmp','png','gif'] 
path=os.path.join(root,"mydir_to_scan")
for r,d,f in os.walk(path):
    for file in f:
        if file[-3:] in alist_filter and pattern in file:
            print os.path.join(root,file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Preliminary code</strong></p>
<pre><code>import glob
import fnmatch
import pathlib
import os

pattern = '*.py'
path = '.'
</code></pre>
<p><strong>Solution 1</strong> - use "glob"</p>
<pre><code># lookup in current dir
glob.glob(pattern)

In [2]: glob.glob(pattern)
Out[2]: ['wsgi.py', 'manage.py', 'tasks.py']
</code></pre>
<p><strong>Solution 2</strong> - use "os" + "fnmatch"</p>
<p><em>Variant 2.1</em> - Lookup in current dir</p>
<pre><code># lookup in current dir
fnmatch.filter(os.listdir(path), pattern)

In [3]: fnmatch.filter(os.listdir(path), pattern)
Out[3]: ['wsgi.py', 'manage.py', 'tasks.py']
</code></pre>
<p><em>Variant 2.2</em> - Lookup recursive</p>
<pre><code># lookup recursive
for dirpath, dirnames, filenames in os.walk(path):

    if not filenames:
        continue

    pythonic_files = fnmatch.filter(filenames, pattern)
    if pythonic_files:
        for file in pythonic_files:
            print('{}/{}'.format(dirpath, file))
</code></pre>
<p><em>Result</em></p>
<pre><code>./wsgi.py
./manage.py
./tasks.py
./temp/temp.py
./apps/diaries/urls.py
./apps/diaries/signals.py
./apps/diaries/actions.py
./apps/diaries/querysets.py
./apps/library/tests/test_forms.py
./apps/library/migrations/0001_initial.py
./apps/polls/views.py
./apps/polls/formsets.py
./apps/polls/reports.py
./apps/polls/admin.py
</code></pre>
<p><strong>Solution 3</strong> - use "pathlib"</p>
<pre><code># lookup in current dir
path_ = pathlib.Path('.')
tuple(path_.glob(pattern))

# lookup recursive
tuple(path_.rglob(pattern))
</code></pre>
<p>Notes:</p>
<ol>
<li>Tested on the Python 3.4</li>
<li>The module "pathlib" was added only in the Python 3.4</li>
<li>The Python 3.5 added a feature for recursive lookup with glob.glob
<a href="https://docs.python.org/3.5/library/glob.html#glob.glob" rel="nofollow noreferrer">https://docs.python.org/3.5/library/glob.html#glob.glob</a>. Since my machine is installed with Python 3.4, I have not tested that.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>you might also like a more high-level approach (I have implemented and packaged as <strong>findtools</strong>):</p>
<pre><code>from findtools.find_files import (find_files, Match)


# Recursively find all *.txt files in **/home/**
txt_files_pattern = Match(filetype='f', name='*.txt')
found_files = find_files(path='/home', match=txt_files_pattern)

for found_file in found_files:
    print found_file
</code></pre>
<p>can be installed with</p>
<pre><code>pip install findtools
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os

dir="/path/to/dir"
[x[0]+"/"+f for x in os.walk(dir) for f in x[2] if f.endswith(".jpg")]
</code></pre>
<p>This will give you a list of jpg files with their full path. You can replace <code>x[0]+"/"+f</code> with <code>f</code> for just filenames. You can also replace <code>f.endswith(".jpg")</code> with whatever string condition you wish.</p>
</div>
<div class="post-text" itemprop="text">
<p>Filenames with "jpg" and "png" extensions in "path/to/images":</p>
<pre><code>import os
accepted_extensions = ["jpg", "png"]
filenames = [fn for fn in os.listdir("path/to/images") if fn.split(".")[-1] in accepted_extensions]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use subprocess.check_ouput() as</p>
<pre><code>import subprocess

list_files = subprocess.check_output("ls 145992*.jpg", shell=True) 
</code></pre>
<p>Of course, the string between quotes can be anything you want to execute in the shell, and store the output.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Filter with <code>glob</code> module:</h1>
<h2>Import glob</h2>
<pre><code>import glob
</code></pre>
<h2>Wild Cards:</h2>
<pre><code>files=glob.glob("data/*")
print(files)

Out:

['data/ks_10000_0', 'data/ks_1000_0', 'data/ks_100_0', 'data/ks_100_1',
'data/ks_100_2', 'data/ks_106_0', 'data/ks_19_0', 'data/ks_200_0', 'data/ks_200_1', 
'data/ks_300_0', 'data/ks_30_0', 'data/ks_400_0', 'data/ks_40_0', 'data/ks_45_0', 
'data/ks_4_0', 'data/ks_500_0', 'data/ks_50_0', 'data/ks_50_1', 'data/ks_60_0', 
'data/ks_82_0', 'data/ks_lecture_dp_1', 'data/ks_lecture_dp_2']
</code></pre>
<h2>Fiter extension <code>.txt</code>:</h2>
<pre><code>files = glob.glob("/home/ach/*/*.txt")
</code></pre>
<h2>A single character</h2>
<pre><code>glob.glob("/home/ach/file?.txt")
</code></pre>
<h2>Number Ranges</h2>
<pre><code>glob.glob("/home/ach/*[0-9]*")
</code></pre>
<h2>Alphabet Ranges</h2>
<pre><code>glob.glob("/home/ach/[a-c]*")
</code></pre>
</div>
<span class="comment-copy">[This link might help you :) Get a filtered list of files in a directory ](<a href="https://codereview.stackexchange.com/a/33642">codereview.stackexchange.com/a/33642</a>)</span>
<span class="comment-copy">Oh, I just noticed that the Python docs say glob() "is done by using the os.listdir() and fnmatch.fnmatch() functions in concert, and not by actually invoking a subshell". In other words, glob() doesn't have the efficiency improvements one might expect.</span>
<span class="comment-copy">There is one main difference: <code>glob.glob('145592*.jpg')</code> prints the whole absolute path of files while <code>ls 145592*.jpg</code> prints only the list of files.</span>
<span class="comment-copy">@Ben Why would invoking a subshell (subprocess) have any efficiency improvements?</span>
<span class="comment-copy">@PauloNeves: true, my comment above doesn't make sense to me 7 years later either. :-) I'm guessing I was referring to the fact that <code>glob()</code> just uses listdir+fnmatch, rather than special operating system calls to do the wildcard filtering. For example, on Windows the <code>FindFirstFile</code> API allows you to specify wildcards so the OS does the filtering directly, and presumably more efficiently (I don't think there's an equivalent on Linux).</span>
<span class="comment-copy">@marsh: As always, the process's current working directory.</span>
<span class="comment-copy">This definitely seems to be more powerful.  For example, having to do something like <code>[0-9]+</code></span>
<span class="comment-copy">Yes, definitely more powerful -- however fnmatch does support <code>[0123456789]</code> sequences (<a href="http://docs.python.org/2/library/fnmatch.html" rel="nofollow noreferrer">see docs</a>), and it also has the <code>fnmatch.filter()</code> function which makes this loop slightly more efficient.</span>
<span class="comment-copy">Not that there is any need for <code>any()</code> here, because <code>str.endswith()</code> takes a <i>sequence</i> of endings. <code>if fn.endswith(included_extentensions)</code> is more than enough.</span>
<span class="comment-copy">Apart from the inefficiency of not using <code>str.endswith(seq)</code> that Martijn pointed out, this is not correct, because a file has to end with <code>.ext</code> for it to have that extension. This code will also find (for example) a file called "myjpg" or a directory named just "png". To fix, just prefix each extension in <code>included_extensions</code> with a <code>.</code>.</span>
<span class="comment-copy">I'm always a bit wary of code in answers which obviously hasn't been run or can't run. The variable <code>included_extensions</code> vs <code>included_extentsions</code>? A pity because otherwise this is my preferred answer.</span>
<span class="comment-copy">This is exactly what <code>glob</code> does on a single line.</span>
<span class="comment-copy">No need to slice; <code>file.endswith(alist_filter)</code> is enough.</span>
<span class="comment-copy">This is very similar to the <a href="https://stackoverflow.com/a/21096293/148680">answer given by @ramsey0</a></span>
<span class="comment-copy">Only one problem. <a href="http://unix.stackexchange.com/questions/128985/why-not-parse-ls"><code>ls</code>'s output should not be parsed</a>.</span>
