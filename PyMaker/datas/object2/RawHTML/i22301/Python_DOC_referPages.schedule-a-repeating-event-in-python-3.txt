<div class="post-text" itemprop="text">
<p>I'm trying to schedule a repeating event to run every minute in Python 3.</p>
<p>I've seen class <code>sched.scheduler</code> but I'm wondering if there's another way to do it. I've heard mentions I could use multiple threads for this, which I wouldn't mind doing.</p>
<p>I'm basically requesting some JSON and then parsing it; its value changes over time.</p>
<p>To use <code>sched.scheduler</code> I have to create a loop to request it to schedule the even to run for one hour:</p>
<pre><code>scheduler = sched.scheduler(time.time, time.sleep)

# Schedule the event. THIS IS UGLY!
for i in range(60):
    scheduler.enter(3600 * i, 1, query_rate_limit, ())

scheduler.run()
</code></pre>
<p>What other ways to do this are there?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="http://docs.python.org/3/library/threading.html#timer-objects" rel="nofollow noreferrer"><code>threading.Timer</code></a>, but that also schedules a one-off event, similarly to the <code>.enter</code> method of scheduler objects.</p>
<p>The normal pattern (in any language) to transform a one-off scheduler into a periodic scheduler is to have each event re-schedule itself at the specified interval.  For example, with <code>sched</code>, I would not use a loop like you're doing, but rather something like:</p>
<pre><code>def periodic(scheduler, interval, action, actionargs=()):
    scheduler.enter(interval, 1, periodic,
                    (scheduler, interval, action, actionargs))
    action(*actionargs)
</code></pre>
<p>and initiate the whole "forever periodic schedule" with a call</p>
<pre><code>periodic(scheduler, 3600, query_rate_limit)
</code></pre>
<p>Or, I could use <code>threading.Timer</code> instead of <code>scheduler.enter</code>, but the pattern's quite similar.</p>
<p>If you need a more refined variation (e.g., stop the periodic rescheduling at a given time or upon certain conditions), that's not too hard to accomodate with a few extra parameters.</p>
</div>
<div class="post-text" itemprop="text">
<p>My humble take on the subject:</p>
<pre><code>from threading import Timer

class RepeatedTimer(object):
    def __init__(self, interval, function, *args, **kwargs):
        self._timer     = None
        self.function   = function
        self.interval   = interval
        self.args       = args
        self.kwargs     = kwargs
        self.is_running = False
        self.start()

    def _run(self):
        self.is_running = False
        self.start()
        self.function(*self.args, **self.kwargs)

    def start(self):
        if not self.is_running:
            self._timer = Timer(self.interval, self._run)
            self._timer.start()
            self.is_running = True

    def stop(self):
        self._timer.cancel()
        self.is_running = False
</code></pre>
<p>Usage:</p>
<pre><code>from time import sleep

def hello(name):
    print "Hello %s!" % name

print "starting..."
rt = RepeatedTimer(1, hello, "World") # it auto-starts, no need of rt.start()
try:
    sleep(5) # your long-running job goes here...
finally:
    rt.stop() # better in a try/finally block to make sure the program ends!
</code></pre>
<p>Features:</p>
<ul>
<li>Standard library only, no external dependencies</li>
<li>Uses the pattern suggested by Alex Martnelli</li>
<li><code>start()</code> and <code>stop()</code> are safe to call multiple times even if the timer has already started/stopped</li>
<li>function to be called can have positional and named arguments</li>
<li>You can change <code>interval</code> anytime, it will be effective after next run. Same for <code>args</code>, <code>kwargs</code> and even <code>function</code>!</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://github.com/dbader/schedule" rel="nofollow noreferrer">schedule</a>. It works on Python 2.7 and 3.3 and is rather lightweight:</p>
<pre><code>import schedule
import time

def job():
   print("I'm working...")

schedule.every(10).minutes.do(job)
schedule.every().hour.do(job)
schedule.every().day.at("10:30").do(job)

while 1:
   schedule.run_pending()
   time.sleep(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="http://packages.python.org/APScheduler/">Advanced Python Scheduler</a>. It even has a cron-like interface.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on MestreLion answer, it solve a little problem with multithreading: </p>
<pre><code>from threading import Timer, Lock


class Periodic(object):
    """
    A periodic task running in threading.Timers
    """

    def __init__(self, interval, function, *args, **kwargs):
        self._lock = Lock()
        self._timer = None
        self.function = function
        self.interval = interval
        self.args = args
        self.kwargs = kwargs
        self._stopped = True
        if kwargs.pop('autostart', True):
            self.start()

    def start(self, from_run=False):
        self._lock.acquire()
        if from_run or self._stopped:
            self._stopped = False
            self._timer = Timer(self.interval, self._run)
            self._timer.start()
            self._lock.release()

    def _run(self):
        self.start(from_run=True)
        self.function(*self.args, **self.kwargs)

    def stop(self):
        self._lock.acquire()
        self._stopped = True
        self._timer.cancel()
        self._lock.release()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://celeryproject.org/" rel="noreferrer">Celery</a>.</p>
<pre><code>from celery.task import PeriodicTask
from datetime import timedelta


class ProcessClicksTask(PeriodicTask):
    run_every = timedelta(minutes=30)

    def run(self, **kwargs):
        #do something
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a quick and dirty non-blocking loop with <code>Thread</code>:</p>
<pre><code>#!/usr/bin/env python3
import threading,time

def worker():
    print(time.time())
    time.sleep(5)
    t = threading.Thread(target=worker)
    t.start()


threads = []
t = threading.Thread(target=worker)
threads.append(t)
t.start()
time.sleep(7)
print("Hello World")
</code></pre>
<p>There's nothing particularly special, the <code>worker</code> creates a new thread of itself with a delay.  Might not be most efficient, but simple enough. <a href="https://stackoverflow.com/a/48758861/3701431">northtree's answer</a> would be the way to go if you need more sophisticated solution.</p>
<p>And based on <a href="https://stackoverflow.com/a/27190867/3701431">this</a>, we can do the same, just with <code>Timer</code>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3
import threading,time

def hello():
    t = threading.Timer(10.0, hello)
    t.start()
    print( "hello, world",time.time() )

t = threading.Timer(10.0, hello)
t.start()
time.sleep(12)
print("Oh,hai",time.time())
time.sleep(4)
print("How's it going?",time.time())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on Alex Martelli's answer, I have implemented <em>decorator</em> version which is more easier to integrated.</p>
<pre><code>import sched
import time
import datetime
from functools import wraps
from threading import Thread


def async(func):
    @wraps(func)
    def async_func(*args, **kwargs):
        func_hl = Thread(target=func, args=args, kwargs=kwargs)
        func_hl.start()
        return func_hl
    return async_func


def schedule(interval):
    def decorator(func):
        def periodic(scheduler, interval, action, actionargs=()):
            scheduler.enter(interval, 1, periodic,
                            (scheduler, interval, action, actionargs))
            action(*actionargs)

        @wraps(func)
        def wrap(*args, **kwargs):
            scheduler = sched.scheduler(time.time, time.sleep)
            periodic(scheduler, interval, func)
            scheduler.run()
        return wrap
    return decorator


@async
@schedule(1)
def periodic_event():
    print(datetime.datetime.now())


if __name__ == '__main__':
    print('start')
    periodic_event()
    print('end')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See my sample</p>
<pre><code>import sched, time

def myTask(m,n):
  print n+' '+m

def periodic_queue(interval,func,args=(),priority=1):
  s = sched.scheduler(time.time, time.sleep)
  periodic_task(s,interval,func,args,priority)
  s.run()

def periodic_task(scheduler,interval,func,args,priority):
  func(*args)
  scheduler.enter(interval,priority,periodic_task,
                   (scheduler,interval,func,args,priority))

periodic_queue(1,myTask,('world','hello'))
</code></pre>
</div>
<span class="comment-copy">Duplicate of all of the "schedule" question for Python 2.  All of these:  <a href="http://stackoverflow.com/search?q=%5Bpython%5D+schedule">stackoverflow.com/search?q=%5Bpython%5D+schedule</a></span>
<span class="comment-copy">Duplicate:  <a href="http://stackoverflow.com/questions/373335/suggestions-for-a-cron-like-scheduler-in-python" title="suggestions for a cron like scheduler in python">stackoverflow.com/questions/373335/â€¦</a></span>
<span class="comment-copy">Also related: <a href="https://stackoverflow.com/q/474528/3701431">stackoverflow.com/q/474528/3701431</a></span>
<span class="comment-copy">Well, in java I have  timer.scheduleAtFixedRate()  And real multithreading. And everybody saying that in python we write less code... Um-hum... Just saying...</span>
<span class="comment-copy">@user1685095 there are <i>always</i> exceptions to any generalized statement like that, sadly.</span>
<span class="comment-copy">@Wallacoloo does that mean there <i>aren't</i> always exceptions? :)</span>
<span class="comment-copy">@user1685095 not so fast! Try coding that without multiple imports, extending TimerTask, providing a <code>run</code> method, and adding a separate class to run the timer as well as creating all those objects.  Probably around 15 lines of code.  (Unless you have a cleaner way to do it; I'm not the greatest at Java.)</span>
<span class="comment-copy">Based on Alex Martelli's answer, I have implemented decorator version which is more easier to integrated. <a href="https://stackoverflow.com/a/48758861/482899">stackoverflow.com/a/48758861/482899</a></span>
<span class="comment-copy">Beautiful class but it has a little problem if start() is executed in a loop. It may pass the is_running check due to the _run function executed in another thread. So the last self._timer is reassigned and it cannot be stopped. Check out my answer for the proper version.</span>
<span class="comment-copy">@fdb: I'm not sure I understood your points. If you execute <code>start()</code> in a loop using the <i>same</i>  class instance, it won't do anything. If you create a <i>new</i> instance, it will trigger a different timer (allowing you to have multiple simultaneous timers). As for multithreading, yes, it's excepted that each <code>start()</code> (or <code>__init__()</code> to be called in the same thread</span>
<span class="comment-copy">It's a my mistake with "loop" word: I mean a fast calling (implemented with a do...loop) to the start() function. Fast enought to be more fast than the setting of "is_running" flag by the _run() function.</span>
<span class="comment-copy">why while loop?, wouldn't it run like cron jobs ?</span>
<span class="comment-copy">@Jaydev the while loop is required if the code is running in the main thread</span>
<span class="comment-copy">Ha I was just putting the lock into the original. It is truly necessary. Thanks this is the correct version of MestreLion</span>
<span class="comment-copy">do you have any idea how to add a check for checking if this thread t is alive? I tried using a try except block and putting t.start() inside the try but it doesnt start the thread!.I just need to run a isAlive() for t to check if its alive</span>
<span class="comment-copy">@toing_toing Frankly, I don't know. I would suggest a global variable to be updated by a thread or a lock-file if you're in Linux environment, but that's an idea from the top of my head and not based in "good practices", only familiarity with Linux. There's an option of using <a href="https://stackoverflow.com/q/14124588/3701431">shared memory</a> for such task as well.  Now, I'm not very knowledgeable in multithreaded programming, so I would suggest asking a question on the site and reference this answer so that people can see which code you're trying to deal with.</span>
<span class="comment-copy">Can you explain why this is better than the other 8 answers already here?</span>
