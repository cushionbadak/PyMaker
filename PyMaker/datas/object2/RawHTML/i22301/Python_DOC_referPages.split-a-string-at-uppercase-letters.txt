<div class="post-text" itemprop="text">
<p>What is the <a href="https://legacy.python.org/dev/peps/pep-0020/" rel="noreferrer">pythonic</a> way to split a string before the occurrences of a given set of characters?</p>
<p>For example, I want to split 
<code>'TheLongAndWindingRoad'</code>
at any occurrence of an uppercase letter (possibly except the first), and obtain
<code>['The', 'Long', 'And', 'Winding', 'Road']</code>.</p>
<p>Edit: It should also split single occurrences, i.e. 
from <code>'ABC'</code> I'd like to obtain
<code>['A', 'B', 'C']</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately it's not possible to <a href="http://bugs.python.org/issue3262" rel="noreferrer">split on a zero-width match</a> in Python. But you can use <code>re.findall</code> instead:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall('[A-Z][^A-Z]*', 'TheLongAndWindingRoad')
['The', 'Long', 'And', 'Winding', 'Road']
&gt;&gt;&gt; re.findall('[A-Z][^A-Z]*', 'ABC')
['A', 'B', 'C']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an alternative regex solution.  The problem can be reprased as "how do I insert a space before each uppercase letter, before doing the split":</p>
<pre><code>&gt;&gt;&gt; s = "TheLongAndWindingRoad ABC A123B45"
&gt;&gt;&gt; re.sub( r"([A-Z])", r" \1", s).split()
['The', 'Long', 'And', 'Winding', 'Road', 'A', 'B', 'C', 'A123', 'B45']
</code></pre>
<p>This has the advantage of preserving all non-whitespace characters, which most other solutions do not.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall('[A-Z][a-z]*', 'TheLongAndWindingRoad')
['The', 'Long', 'And', 'Winding', 'Road']

&gt;&gt;&gt; re.findall('[A-Z][a-z]*', 'SplitAString')
['Split', 'A', 'String']

&gt;&gt;&gt; re.findall('[A-Z][a-z]*', 'ABC')
['A', 'B', 'C']
</code></pre>
<p>If you want <code>"It'sATest"</code> to split to <code>["It's", 'A', 'Test']</code> change the rexeg to <code>"[A-Z][a-z']*"</code></p>
</div>
<div class="post-text" itemprop="text">
<p>A variation on @ChristopheD 's solution</p>
<pre><code>s = 'TheLongAndWindingRoad'

pos = [i for i,e in enumerate(s+'A') if e.isupper()]
parts = [s[pos[j]:pos[j+1]] for j in xrange(len(pos)-1)]

print parts
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
filter(None, re.split("([A-Z][^A-Z]*)", "TheLongAndWindingRoad"))
</code></pre>
<p>or</p>
<pre><code>[s for s in re.split("([A-Z][^A-Z]*)", "TheLongAndWindingRoad") if s]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>src = 'TheLongAndWindingRoad'
glue = ' '

result = ''.join(glue + x if x.isupper() else x for x in src).strip(glue).split(glue)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternative solution (if you dislike explicit regexes):</p>
<pre><code>s = 'TheLongAndWindingRoad'

pos = [i for i,e in enumerate(s) if e.isupper()]

parts = []
for j in xrange(len(pos)):
    try:
        parts.append(s[pos[j]:pos[j+1]])
    except IndexError:
        parts.append(s[pos[j]:])

print parts
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another without regex and the ability to keep contiguous uppercase if wanted</p>
<pre><code>def split_on_uppercase(s, keep_contiguous=False):
    """

    Args:
        s (str): string
        keep_contiguous (bool): flag to indicate we want to 
                                keep contiguous uppercase chars together

    Returns:

    """

    string_length = len(s)
    is_lower_around = (lambda: s[i-1].islower() or 
                       string_length &gt; (i + 1) and s[i + 1].islower())

    start = 0
    parts = []
    for i in range(1, string_length):
        if s[i].isupper() and (not keep_contiguous or is_lower_around()):
            parts.append(s[start: i])
            start = i
    parts.append(s[start:])

    return parts

&gt;&gt;&gt; split_on_uppercase('theLongWindingRoad')
['the', 'Long', 'Winding', 'Road']
&gt;&gt;&gt; split_on_uppercase('TheLongWindingRoad')
['The', 'Long', 'Winding', 'Road']
&gt;&gt;&gt; split_on_uppercase('TheLongWINDINGRoadT', True)
['The', 'Long', 'WINDING', 'Road', 'T']
&gt;&gt;&gt; split_on_uppercase('ABC')
['A', 'B', 'C']
&gt;&gt;&gt; split_on_uppercase('ABCD', True)
['ABCD']
&gt;&gt;&gt; split_on_uppercase('')
['']
&gt;&gt;&gt; split_on_uppercase('hello world')
['hello world']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is possible with the <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.split_before" rel="nofollow noreferrer"><code>more_itertools.split_before</code></a> tool.</p>
<pre><code>import more_itertools as mit


iterable = "TheLongAndWindingRoad"
[ "".join(i) for i in mit.split_before(iterable, pred=lambda s: s.isupper())]
# ['The', 'Long', 'And', 'Winding', 'Road']
</code></pre>
<blockquote>
<p>It should also split single occurrences, i.e. from <code>'ABC'</code> I'd like to obtain <code>['A', 'B', 'C']</code>.</p>
</blockquote>
<pre><code>iterable = "ABC"
[ "".join(i) for i in mit.split_before(iterable, pred=lambda s: s.isupper())]
# ['A', 'B', 'C']
</code></pre>
<p><a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party package with 60+ useful tools including implementations for all of the original <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>, which obviates their manual implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative way without using regex or enumerate:</p>
<pre><code>word = 'TheLongAndWindingRoad'
list = [x for x in word]

for char in list:
    if char != list[0] and char.isupper():
        list[list.index(char)] = ' ' + char

fin_list = ''.join(list).split(' ')
</code></pre>
<p>I think it is clearer and simpler without chaining too many methods or using a long list comprehension that can be difficult to read.</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternate way using <strong><code>enumerate</code></strong> and <strong><code>isupper()</code></strong></p>
<p><strong>Code:</strong></p>
<pre><code>strs = 'TheLongAndWindingRoad'
ind =0
count =0
new_lst=[]
for index, val in enumerate(strs[1:],1):
    if val.isupper():
        new_lst.append(strs[ind:index])
        ind=index
if ind&lt;len(strs):
    new_lst.append(strs[ind:])
print new_lst
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>['The', 'Long', 'And', 'Winding', 'Road']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sharing what came to mind when I read the post. Different from other posts.</p>
<pre><code>strs = 'TheLongAndWindingRoad'

# grab index of uppercase letters in strs
start_idx = [i for i,j in enumerate(strs) if j.isupper()]

# create empty list
strs_list = []

# initiate counter
cnt = 1

for pos in start_idx:
    start_pos = pos

    # use counter to grab next positional element and overlook IndexeError
    try:
        end_pos = start_idx[cnt]
    except IndexError:
        continue

    # append to empty list
    strs_list.append(strs[start_pos:end_pos])

    cnt += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Replace every uppercase letter 'L' in the given with an empty space plus that letter " L". We can do this using list comprehension or we can define a function to do it as follows.</p>
<pre><code>s = 'TheLongANDWindingRoad ABC A123B45'
''.join([char if (char.islower() or not char.isalpha()) else ' '+char for char in list(s)]).strip().split()
&gt;&gt;&gt; ['The', 'Long', 'A', 'N', 'D', 'Winding', 'Road', 'A', 'B', 'C', 'A123', 'B45']
</code></pre>
<p>If you choose to go by a function, here is how.</p>
<pre><code>def splitAtUpperCase(text):
    result = ""
    for char in text:
        if char.isupper():
            result += " " + char
        else:
            result += char
    return result.split()
</code></pre>
<p>In the case of the given example:</p>
<pre><code>print(splitAtUpperCase('TheLongAndWindingRoad')) 
&gt;&gt;&gt;['The', 'Long', 'A', 'N', 'D', 'Winding', 'Road']
</code></pre>
<p>But most of the time that we are splitting a sentence at upper case letters, it is usually the case that we want to maintain abbreviations that are typically a continuous stream of uppercase letters. The code below would help.</p>
<pre><code>def splitAtUpperCase(s):
    for i in range(len(s)-1)[::-1]:
        if s[i].isupper() and s[i+1].islower():
            s = s[:i]+' '+s[i:]
        if s[i].isupper() and s[i-1].islower():
            s = s[:i]+' '+s[i:]
    return s.split()

splitAtUpperCase('TheLongANDWindingRoad')

&gt;&gt;&gt; ['The', 'Long', 'AND', 'Winding', 'Road']
</code></pre>
<p>Thanks.</p>
</div>
<span class="comment-copy">Beware that this will drop any characters before the first capital character. 'theLongAndWindingRoad' would result in ['Long', 'And', 'Winding', 'Road']</span>
<span class="comment-copy">@MarcSchulder: If you need that case, just use <code>'[a-zA-Z][^A-Z]*'</code> as the regex.</span>
<span class="comment-copy">It is possible to do te same without upercase ?</span>
<span class="comment-copy">In order to split lower camel case words <code>print(re.findall('^[a-z]+|[A-Z][^A-Z]*', 'theLongAndWindingRoad'))</code></span>
<span class="comment-copy">Can you please explain why does the space before \1 work? Is it because of the split method or is it anything related to regex?</span>
<span class="comment-copy">+1: For first to get ABC working. I've also updated my answer now.</span>
<span class="comment-copy">&gt;&gt;&gt; re.findall('[A-Z][a-z]*', "It's about 70% of the Economy") -----&gt; ['It', 'Economy']</span>
<span class="comment-copy">@ChristopheD. The OP doesn't say how to non-alpha characters should be treated.</span>
<span class="comment-copy">true, but this current regex way also <code>drops</code> all regular (just plain alpha) words that do not start with an uppercase letter. I doubt that that was the intention of the OP.</span>
<span class="comment-copy">Nice one - this works with non-Latin characters too. The regex solutions shown here do not.</span>
<span class="comment-copy">The filter is totally unnecessary and buys you nothing over a direct regex split with capture group: <code>[s for s in re.compile(r"([A-Z][^A-Z]*)").split( "TheLongAndWindingRoad") if s]</code> giving <code>['The', 'Long', 'And', 'Winding', 'Road']</code></span>
<span class="comment-copy">@smci: This usage of <code>filter</code> is the same as the list comprehension with a condition. Do you have anything against it?</span>
<span class="comment-copy">I know it can be replaced with a list comprehension with a condition, because I just posted that code, then you copied it.  Here are three reasons the list comprehension is preferable:  a) <i>Legible idiom:</i> list comprehensions are a more Pythonic idiom and read clearer left-to-right than <code>filter(lambdaconditionfunc, ...)</code> b) in Python 3, <code>filter()</code> returns an iterator. So they will not be totally equivalent. c) I expect <code>filter()</code> is slower too</span>
<span class="comment-copy">Could you please add explanation to why this is good solution to the problem.</span>
<span class="comment-copy">I'm sorry. I'm forgot last step</span>
<span class="comment-copy">Seems concise, pythonic and self-explanatory, to me.</span>
<span class="comment-copy">@MarkByers I do not know why someone down voted my answer but I would love you to take a look at it for me. I would appreciate your feedback.</span>
