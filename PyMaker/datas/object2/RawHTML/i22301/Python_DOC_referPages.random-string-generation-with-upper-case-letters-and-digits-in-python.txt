<div class="post-text" itemprop="text">
<p>I want to generate a string of size N.</p>
<p>It should be made up of numbers and uppercase English letters such as:</p>
<ul>
<li>6U1S75</li>
<li>4Z4UKK</li>
<li>U911K4</li>
</ul>
<p>How can I achieve this in a <a href="https://en.wikipedia.org/wiki/Python_%28programming_language%29#Features_and_philosophy">pythonic</a> way?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Answer in one line:</strong></p>
<pre><code>''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))
</code></pre>
<p>or even shorter starting with Python 3.6 using <a href="https://docs.python.org/3/library/random.html#random.choices" rel="noreferrer"><code>random.choices()</code></a>:</p>
<pre><code>''.join(random.choices(string.ascii_uppercase + string.digits, k=N))
</code></pre>
<p><strong>A cryptographically more secure version; see <a href="https://stackoverflow.com/a/23728630/2213647">https://stackoverflow.com/a/23728630/2213647</a>:</strong></p>
<pre><code>''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(N))
</code></pre>
<p><strong>In details, with a clean function for further reuse:</strong></p>
<pre><code>&gt;&gt;&gt; import string
&gt;&gt;&gt; import random
&gt;&gt;&gt; def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
...    return ''.join(random.choice(chars) for _ in range(size))
...
&gt;&gt;&gt; id_generator()
'G5G74W'
&gt;&gt;&gt; id_generator(3, "6793YUIO")
'Y3U'
</code></pre>
<p><strong>How does it work ?</strong></p>
<p>We import <code>string</code>, a module that contains sequences of common ASCII characters, and <code>random</code>, a module that deals with random generation.</p>
<p><code>string.ascii_uppercase + string.digits</code> just concatenates the list of characters representing uppercase ASCII chars and digits:</p>
<pre><code>&gt;&gt;&gt; string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
&gt;&gt;&gt; string.digits
'0123456789'
&gt;&gt;&gt; string.ascii_uppercase + string.digits
'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
</code></pre>
<p>Then we use a list comprehension to create a list of 'n' elements:</p>
<pre><code>&gt;&gt;&gt; range(4) # range create a list of 'n' numbers
[0, 1, 2, 3]
&gt;&gt;&gt; ['elem' for _ in range(4)] # we use range to create 4 times 'elem'
['elem', 'elem', 'elem', 'elem']
</code></pre>
<p>In the example above, we use <code>[</code> to create the list, but we don't in the <code>id_generator</code> function so Python doesn't create the list in memory, but generates the elements on the fly, one by one (more about this <a href="https://stackoverflow.com/questions/231767/the-python-yield-keyword-explained/231855#231855">here</a>).</p>
<p>Instead of asking to create 'n' times the string <code>elem</code>, we will ask Python to create 'n' times a random character, picked from a sequence of characters:</p>
<pre><code>&gt;&gt;&gt; random.choice("abcde")
'a'
&gt;&gt;&gt; random.choice("abcde")
'd'
&gt;&gt;&gt; random.choice("abcde")
'b'
</code></pre>
<p>Therefore <code>random.choice(chars) for _ in range(size)</code> really is creating a sequence of <code>size</code> characters. Characters that are randomly picked from <code>chars</code>:</p>
<pre><code>&gt;&gt;&gt; [random.choice('abcde') for _ in range(3)]
['a', 'b', 'b']
&gt;&gt;&gt; [random.choice('abcde') for _ in range(3)]
['e', 'b', 'e']
&gt;&gt;&gt; [random.choice('abcde') for _ in range(3)]
['d', 'a', 'c']
</code></pre>
<p>Then we just join them with an empty string so the sequence becomes a string:</p>
<pre><code>&gt;&gt;&gt; ''.join(['a', 'b', 'b'])
'abb'
&gt;&gt;&gt; [random.choice('abcde') for _ in range(3)]
['d', 'c', 'b']
&gt;&gt;&gt; ''.join(random.choice('abcde') for _ in range(3))
'dac'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This Stack Overflow quesion is the current top Google result for "random string Python". The current top answer is:</p>
<pre><code>''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))
</code></pre>
<p>This is an excellent method, but the <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator" rel="noreferrer">PRNG</a> in random is not cryptographically secure. I assume many people researching this question will want to generate random strings for encryption or passwords. You can do this securely by making a small change in the above code:</p>
<pre><code>''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(N))
</code></pre>
<p>Using <code>random.SystemRandom()</code> instead of just random uses /dev/urandom on *nix machines and <code>CryptGenRandom()</code> in Windows.  These are cryptographically secure PRNGs. Using <code>random.choice</code> instead of <code>random.SystemRandom().choice</code> in an application that requires a secure PRNG could be potentially devastating, and given the popularity of this question, I bet that mistake has been made many times already.</p>
<p>If you're using python3.6 or above, you can use the new <a href="https://docs.python.org/3/library/secrets.html" rel="noreferrer">secrets</a> module.</p>
<pre><code>''.join(secrets.choice(string.ascii_uppercase + string.digits) for _ in range(N))
</code></pre>
<p>The module docs also discuss convenient ways to <a href="https://docs.python.org/3/library/secrets.html#generating-tokens" rel="noreferrer">generate secure tokens</a> and <a href="https://docs.python.org/3/library/secrets.html#recipes-and-best-practices" rel="noreferrer">best practices</a>.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Simply use Python's builtin uuid:</h1>
<p>If UUIDs are okay for your purposes, use the built-in <a href="http://docs.python.org/2/library/uuid.html" rel="noreferrer">uuid</a> package.</p>
<h2>One Line Solution:</h2>
<p><code>import uuid; uuid.uuid4().hex.upper()[0:6]</code></p>
<h2>In Depth Version:</h2>
<p>Example:</p>
<pre><code>import uuid
uuid.uuid4() #uuid4 =&gt; full random uuid
# Outputs something like: UUID('0172fc9a-1dac-4414-b88d-6b9a6feb91ea')
</code></pre>
<p>If you need exactly your format (for example, "6U1S75"), you can do it like this:</p>
<pre><code>import uuid

def my_random_string(string_length=10):
    """Returns a random string of length string_length."""
    random = str(uuid.uuid4()) # Convert UUID format to a Python string.
    random = random.upper() # Make all characters uppercase.
    random = random.replace("-","") # Remove the UUID '-'.
    return random[0:string_length] # Return the random string.

print(my_random_string(6)) # For example, D9E50C
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simpler, faster but slightly less random way is to use <code>random.sample</code> instead of choosing each letter separately, If n-repetitions are allowed, enlarge your random basis by n times e.g.</p>
<pre><code>import random
import string

char_set = string.ascii_uppercase + string.digits
print ''.join(random.sample(char_set*6, 6))
</code></pre>
<p>Note:
random.sample prevents character reuse, multiplying the size of the character set makes multiple repetitions possible, but they are still less likely then they are in a pure random choice. If we go for a string of length 6, and we pick 'X' as the first character, in the choice example, the odds of getting 'X' for the second character are the same as the odds of getting 'X' as the first character. In the random.sample implementation, the odds of getting 'X' as any subsequent character are only 6/7 the chance of getting it as the first character</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import uuid
lowercase_str = uuid.uuid4().hex  
</code></pre>
<p><code>lowercase_str</code> is a random value like <code>'cea8b32e00934aaea8c005a35d85a5c0'</code></p>
<pre><code>uppercase_str = lowercase_str.upper()
</code></pre>
<p><code>uppercase_str</code> is <code>'CEA8B32E00934AAEA8C005A35D85A5C0'</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Taking the answer from Ignacio, this works with Python 2.6:</p>
<pre><code>import random
import string

N=6
print ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))
</code></pre>
<p>Example output:</p>
<blockquote>
<p>JQUBT2</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>A faster, easier and more flexible way to do this is to use the <a href="https://pypi.org/project/StringGenerator/" rel="nofollow noreferrer"><code>strgen</code></a> module (<code>pip install StringGenerator</code>).</p>
<p>Generate a 6-character random string with upper case letters and digits:</p>
<pre><code>&gt;&gt;&gt; from strgen import StringGenerator as SG
&gt;&gt;&gt; SG("[\u\d]{6}").render()
u'YZI2CI'
</code></pre>
<p>Get a unique list:</p>
<pre><code>&gt;&gt;&gt; SG("[\l\d]{10}").render_list(5,unique=True)
[u'xqqtmi1pOk', u'zmkWdUr63O', u'PGaGcPHrX2', u'6RZiUbkk2i', u'j9eIeeWgEF']
</code></pre>
<p><em>Guarantee</em> one "special" character in the string:</p>
<pre><code>&gt;&gt;&gt; SG("[\l\d]{10}&amp;[\p]").render()
u'jaYI0bcPG*0'
</code></pre>
<p>A random HTML color:</p>
<pre><code>&gt;&gt;&gt; SG("#[\h]{6}").render()
u'#CEdFCa'
</code></pre>
<p>etc. </p>
<p>We need to be aware that this:</p>
<pre><code>''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))
</code></pre>
<p>might not have a digit (or uppercase character) in it.</p>
<p><code>strgen</code> is faster in developer-time than any of the above solutions. The solution from Ignacio is the fastest run-time performing and is the right answer using the Python Standard Library. But you will hardly ever use it in that form. You will want to use SystemRandom (or fallback if not available), make sure required character sets are represented, use unicode (or not), make sure successive invocations produce a unique string, use a subset of one of the string module character classes, etc. This all requires lots more code than in the answers provided. The various attempts to generalize a solution all have limitations that strgen solves with greater brevity and expressive power using a simple template language.</p>
<p>It's on PyPI:</p>
<pre><code>pip install StringGenerator
</code></pre>
<p>Disclosure: I'm the author of the strgen module.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need a random string rather than a <strong>pseudo random</strong> one, you should use <a href="http://docs.python.org/2/library/os.html#os.urandom"><code>os.urandom</code></a> as the source</p>
<pre><code>from os import urandom
from itertools import islice, imap, repeat
import string

def rand_string(length=5):
    chars = set(string.ascii_uppercase + string.digits)
    char_gen = (c for c in imap(urandom, repeat(1)) if c in chars)
    return ''.join(islice(char_gen, None, length))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I thought no one had answered this yet lol! But hey, here's my own go at it:</p>
<pre><code>import random

def random_alphanumeric(limit):
    #ascii alphabet of all alphanumerals
    r = (range(48, 58) + range(65, 91) + range(97, 123))
    random.shuffle(r)
    return reduce(lambda i, s: i + chr(s), r[:random.randint(0, len(r))], "")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on another Stack Overflow answer, <em><a href="https://stackoverflow.com/a/2782859/399891">Most lightweight way to create a random string and a random hexadecimal number</a></em>, a better version than the accepted answer would be:</p>
<pre><code>('%06x' % random.randrange(16**6)).upper()
</code></pre>
<p>much faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>This method is slightly faster, and slightly more annoying, than the random.choice() method Ignacio posted.</p>
<p>It takes advantage of the nature of pseudo-random algorithms, and banks on bitwise and and shift being faster than generating a new random number for each character.</p>
<pre><code># must be length 32 -- 5 bits -- the question didn't specify using the full set
# of uppercase letters ;)
_ALPHABET = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'

def generate_with_randbits(size=32):
    def chop(x):
        while x:
            yield x &amp; 31
            x = x &gt;&gt; 5
    return  ''.join(_ALPHABET[x] for x in chop(random.getrandbits(size * 5))).ljust(size, 'A')
</code></pre>
<p>...create a generator that takes out 5 bit numbers at a time 0..31 until none left</p>
<p>...join() the results of the generator on a random number with the right bits</p>
<p>With Timeit, for 32-character strings, the timing was:</p>
<pre><code>[('generate_with_random_choice', 28.92901611328125),
 ('generate_with_randbits', 20.0293550491333)]
</code></pre>
<p>...but for 64 character strings, randbits loses out ;)</p>
<p>I would probably never use this approach in production code unless I really disliked my co-workers.</p>
<p>edit: updated to suit the question (uppercase and digits only), and use bitwise operators &amp; and &gt;&gt; instead of % and //</p>
</div>
<div class="post-text" itemprop="text">
<p>From Python 3.6 on you should use the <code>secrets</code> module <em>if you need it to be cryptographically secure</em> instead of the <code>random</code> module (otherwise this answer is identical to the one of @Ignacio Vazquez-Abrams):</p>
<pre><code>from secrets import choice
import string

''.join([choice(string.ascii_uppercase + string.digits) for _ in range(N)])
</code></pre>
<p>One additional note: a list-comprehension is faster in the case of <code>str.join</code> than using a generator expression!</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd do it this way:</p>
<pre><code>import random
from string import digits, ascii_uppercase

legals = digits + ascii_uppercase

def rand_string(length, char_set=legals):

    output = ''
    for _ in range(length): output += random.choice(char_set)
    return output
</code></pre>
<p>Or just:</p>
<pre><code>def rand_string(length, char_set=legals):

    return ''.join( random.choice(char_set) for _ in range(length) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use Numpy's random.choice() function</p>
<pre><code>import numpy as np
import string        

if __name__ == '__main__':
    length = 16
    a = np.random.choice(list(string.ascii_uppercase + string.digits), length)                
    print(''.join(a))
</code></pre>
<p>Documentation is here <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.random.choice.html" rel="nofollow noreferrer">http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.random.choice.html</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import string 
&gt;&gt;&gt; import random
</code></pre>
<p>the following logic still generates 6 character random sample </p>
<pre><code>&gt;&gt;&gt; print ''.join(random.sample((string.ascii_uppercase+string.digits),6))
JT7K3Q
</code></pre>
<p>No need to multiply by 6</p>
<pre><code>&gt;&gt;&gt; print ''.join(random.sample((string.ascii_uppercase+string.digits)*6,6))

TK82HK
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For those of you who enjoy functional python:</p>
<pre><code>from itertools import imap, starmap, islice, repeat
from functools import partial
from string import letters, digits, join
from random import choice

join_chars = partial(join, sep='')
identity = lambda o: o

def irand_seqs(symbols=join_chars((letters, digits)), length=6, join=join_chars, select=choice, breakup=islice):
    """ Generates an indefinite sequence of joined random symbols each of a specific length
    :param symbols: symbols to select,
        [defaults to string.letters + string.digits, digits 0 - 9, lower and upper case English letters.]
    :param length: the length of each sequence,
        [defaults to 6]
    :param join: method used to join selected symbol, 
        [defaults to ''.join generating a string.]
    :param select: method used to select a random element from the giving population. 
        [defaults to random.choice, which selects a single element randomly]
    :return: indefinite iterator generating random sequences of giving [:param length]
    &gt;&gt;&gt; from tools import irand_seqs
    &gt;&gt;&gt; strings = irand_seqs()
    &gt;&gt;&gt; a = next(strings)
    &gt;&gt;&gt; assert isinstance(a, (str, unicode))
    &gt;&gt;&gt; assert len(a) == 6
    &gt;&gt;&gt; assert next(strings) != next(strings)
    """
    return imap(join, starmap(breakup, repeat((imap(select, repeat(symbols)), None, length))))
</code></pre>
<p>It generates an indefinite [infinite] iterator, of joined random sequences, by first generating an indefinite sequence of randomly selected symbol from the giving pool, then breaking this sequence into length parts which is then joined, it should work with any sequence that supports getitem, by default it simply generates a random sequence of alpha numeric letters, though you can easily modify to generate other things:</p>
<p>for example to generate random tuples of digits:</p>
<pre><code>&gt;&gt;&gt; irand_tuples = irand_seqs(xrange(10), join=tuple)
&gt;&gt;&gt; next(irand_tuples)
(0, 5, 5, 7, 2, 8)
&gt;&gt;&gt; next(irand_tuples)
(3, 2, 2, 0, 3, 1)
</code></pre>
<p>if you don't want to use next for generation you can simply make it callable:</p>
<pre><code>&gt;&gt;&gt; irand_tuples = irand_seqs(xrange(10), join=tuple)
&gt;&gt;&gt; make_rand_tuples = partial(next, irand_tuples) 
&gt;&gt;&gt; make_rand_tuples()
(1, 6, 2, 8, 1, 9)
</code></pre>
<p>if you want to generate the sequence on the fly simply set join to identity.</p>
<pre><code>&gt;&gt;&gt; irand_tuples = irand_seqs(xrange(10), join=identity)
&gt;&gt;&gt; selections = next(irand_tuples)
&gt;&gt;&gt; next(selections)
8
&gt;&gt;&gt; list(selections)
[6, 3, 8, 2, 2]
</code></pre>
<p>As others have mentioned if you need more security then set the appropriate select function:</p>
<pre><code>&gt;&gt;&gt; from random import SystemRandom
&gt;&gt;&gt; rand_strs = irand_seqs(select=SystemRandom().choice)
'QsaDxQ'
</code></pre>
<p>the default selector is <code>choice</code> which may select the same symbol multiple times for each chunk, if instead you'd want the same member selected at most once for each chunk then, one possible usage:</p>
<pre><code>&gt;&gt;&gt; from random import sample
&gt;&gt;&gt; irand_samples = irand_seqs(xrange(10), length=1, join=next, select=lambda pool: sample(pool, 6))
&gt;&gt;&gt; next(irand_samples)
[0, 9, 2, 3, 1, 6]
</code></pre>
<p>we use <code>sample</code> as our selector, to do the complete selection, so the chunks are actually length 1, and to join we simply call <code>next</code> which fetches the next completely generated chunk, granted this example seems a bit cumbersome and it is ...</p>
</div>
<div class="post-text" itemprop="text">
<p>(1) This will give you all caps and numbers:</p>
<pre><code>import string, random
passkey=''
for x in range(8):
    if random.choice([1,2]) == 1:
        passkey += passkey.join(random.choice(string.ascii_uppercase))
    else:
        passkey += passkey.join(random.choice(string.digits))
print passkey 
</code></pre>
<p>(2) If you later want to include lowercase letters in your key, then this will also work:</p>
<pre><code>import string, random
passkey=''
for x in range(8):
    if random.choice([1,2]) == 1:
        passkey += passkey.join(random.choice(string.ascii_letters))
    else:
        passkey += passkey.join(random.choice(string.digits))
print passkey  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is a take on Anurag Uniyal 's response and something that i was working on myself.</p>
<pre><code>import random
import string

oneFile = open('‪Numbers.txt', 'w')
userInput = 0
key_count = 0
value_count = 0
chars = string.ascii_uppercase + string.digits + string.punctuation

for userInput in range(int(input('How many 12 digit keys do you want?'))):
    while key_count &lt;= userInput:
        key_count += 1
        number = random.randint(1, 999)
        key = number

        text = str(key) + ": " + str(''.join(random.sample(chars*6, 12)))
        oneFile.write(text + "\n")
oneFile.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import string
from random import *
characters = string.ascii_letters + string.punctuation  + string.digits
password =  "".join(choice(characters) for x in range(randint(8, 16)))
print password
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random
q=2
o=1
list  =[r'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','s','0','1','2','3','4','5','6','7','8','9','0']
while(q&gt;o):
    print("")

    for i in range(1,128):
        x=random.choice(list)
        print(x,end="")
</code></pre>
<p>Here length of string can be changed in for loop i.e for i in range(1,length) 
It is simple algorithm which is easy to understand. it uses list so you can discard characters that you do not need. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; str = []
&gt;&gt;&gt; chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'
&gt;&gt;&gt; num = int(raw_input('How long do you want the string to be?  '))
How long do you want the string to be?  10
&gt;&gt;&gt; for k in range(1, num+1):
...    str.append(random.choice(chars))
...
&gt;&gt;&gt; str = "".join(str)
&gt;&gt;&gt; str
'tm2JUQ04CK'
</code></pre>
<p>The <code>random.choice</code> function picks a random entry in a list. You also create a list so that you can append the character in the <code>for</code> statement. At the end str is ['t', 'm', '2', 'J', 'U', 'Q', '0', '4', 'C', 'K'], but the <code>str = "".join(str)</code> takes care of that, leaving you with <code>'tm2JUQ04CK'</code>.</p>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple one:</p>
<pre><code>import string
import random
character = string.lowercase + string.uppercase + string.digits + string.punctuation
char_len = len(character)
# you can specify your password length here
pass_len = random.randint(10,20)
password = ''
for x in range(pass_len):
    password = password + character[random.randint(0,char_len-1)]
print password
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would like to suggest you next option:</p>
<pre><code>import crypt
n = 10
crypt.crypt("any sring").replace('/', '').replace('.', '').upper()[-n:-1]
</code></pre>
<p>Paranoic mode:</p>
<pre><code>import uuid
import crypt
n = 10
crypt.crypt(str(uuid.uuid4())).replace('/', '').replace('.', '').upper()[-n:-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Two methods :</strong></p>
<pre><code>import random, math
</code></pre>
<p>
<pre><code>def randStr_1(chars:str, length:int) -&gt; str:
    chars *= math.ceil(length / len(chars))
    chars = letters[0:length]
    chars = list(chars)
    random.shuffle(characters)

    return ''.join(chars)
</code></pre>
<p>
<pre><code>def randStr_2(chars:str, length:int) -&gt; str:
    return ''.join(random.choice(chars) for i in range(chars))
</code></pre>
<p><br/></p>
<blockquote>
<p><strong>Benchmark :</strong></p>
</blockquote>
<pre><code>from timeit import timeit

setup = """
import os, subprocess, time, string, random, math

def randStr_1(letters:str, length:int) -&gt; str:
    letters *= math.ceil(length / len(letters))
    letters = letters[0:length]
    letters = list(letters)
    random.shuffle(letters)
    return ''.join(letters)

def randStr_2(letters:str, length:int) -&gt; str:
    return ''.join(random.choice(letters) for i in range(length))
"""

print('Method 1 vs Method 2', ', run 10 times each.')

for length in [100,1000,10000,50000,100000,500000,1000000]:
    print(length, 'characters:')

    eff1 = timeit("randStr_1(string.ascii_letters, {})".format(length), setup=setup, number=10)
    eff2 = timeit("randStr_2(string.ascii_letters, {})".format(length), setup=setup, number=10)
    print('\t{}s : {}s'.format(round(eff1, 6), round(eff2, 6)))
    print('\tratio = {} : {}\n'.format(eff1/eff1, round(eff2/eff1, 2)))
</code></pre>
<p><strong>Output :</strong></p>
<pre><code>Method 1 vs Method 2 , run 10 times each.

100 characters:
    0.001411s : 0.00179s
    ratio = 1.0 : 1.27

1000 characters:
    0.013857s : 0.017603s
    ratio = 1.0 : 1.27

10000 characters:
    0.13426s : 0.151169s
    ratio = 1.0 : 1.13

50000 characters:
    0.709403s : 0.855136s
    ratio = 1.0 : 1.21

100000 characters:
    1.360735s : 1.674584s
    ratio = 1.0 : 1.23

500000 characters:
    6.754923s : 7.160508s
    ratio = 1.0 : 1.06

1000000 characters:
    11.232965s : 14.223914s
    ratio = 1.0 : 1.27
</code></pre>
<p>The performance of first method is better.  </p>
</p></p></div>
<div class="post-text" itemprop="text">
<p>for python 3
import string, random</p>
<p>''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits) for _ in range(15))</p>
</div>
<div class="post-text" itemprop="text">
<p>I have gone though almost all of the answers but none of them looks easier. I would suggest you to try the <a href="https://pypi.org/project/passgen/" rel="nofollow noreferrer">passgen</a> library which is generally used to create random passwords.</p>
<p>You can generate random strings of your choice of <strong>length, punctuation, digits, letters</strong> and <strong>case.</strong></p>
<p>Here's the code for your case:</p>
<pre><code>from passgen import passgen
string_length = int(input())
random_string = passgen(length=string_length, punctuation=False, digits=True, letters=True, case='upper')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this to be simpler and cleaner.</p>
<pre><code>str_Key           = ""
str_FullKey       = "" 
str_CharacterPool = "01234ABCDEFfghij~&gt;()"
for int_I in range(64): 
    str_Key = random.choice(str_CharacterPool) 
    str_FullKey = str_FullKey + str_Key 
</code></pre>
<p>Just change the 64 to vary the length, vary the CharacterPool to do alpha only alpha numeric or numeric only or strange characters or whatever you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the code </p>
<pre><code>var chars = "ABC123";
        var random = new Random();
        var result = new string(
            Enumerable.Repeat(chars, 7) //Change 7 to any number of characters you want in your outcome
                      .Select(s =&gt; s[random.Next(s.Length)])
                      .ToArray());

        textBox1.Text = result;
</code></pre>
<p>This will random spit out a random 7 alphanumeric pattern, simply change the 7 to any number you wish and it will produce that many numbers and/or letters.</p>
<p>Another way to write this is as follows...</p>
<pre><code>var chars = "ABC123";
var stringChars = new char[7]; //Change 7 to any number of characters you want in your outcome
var random = new Random();

for (int i = 0; i &lt; stringChars.Length; i++)
{

stringChars[i] = chars[random.Next(chars.Length)];

}

var finalString = new String(stringChars);

textBox1.Text = finalstring;`
</code></pre>
<p>I am unsure of how to add restrictions such as making it to where it does not allow certain numbers and/or letters to be next to each other or repeat such as getting "AAA123" if anyone knows how to restrict the outcome to have something like this please comment back</p>
</div>
<span class="comment-copy">This is a very popular question. I wish an expert would add his take on the uniqueness of these random numbers for the top 3 answers i.e. the collision probability for range of string size, say from 6 to 16.</span>
<span class="comment-copy">@buffer It's easy to calculate the number of possible combinations. 10 numbers + 26 letters = 36 possible characters, to the power of 6 (length of string) is equal to about two billion. My rule of thumb for random values is "if I generated values for every human on Earth, how many values could they have each?". In this case that would be less than one value per person, so if this is to identify users or objects, it's too few characters. One alternative would be to add in lower case letters, which lands you at 62^6 = almost 57 billion unique values.</span>
<span class="comment-copy">And while it might seem silly to think of the world's population, that's just because you want a huge buffer for potential collisions. See the birthday problem: <a href="http://en.wikipedia.org/wiki/Birthday_problem" rel="nofollow noreferrer">en.wikipedia.org/wiki/Birthday_problem</a></span>
<span class="comment-copy">@buffer, You would be interested in <a href="http://stackoverflow.com/a/2145551/1383051">this answer</a> then.</span>
<span class="comment-copy">Shouldn't this be renamed <b>"Cryptographically secure random string generation..."</b>?</span>
<span class="comment-copy">How does this work???  I am new to python and love it's extreme high level-ness but this just blew my mind.  Is there anywhere where I can read documentation on this?</span>
<span class="comment-copy">@jorelli: It's not a list comprehension; it's a generator expression.</span>
<span class="comment-copy">@Youarefunny: I edited the answer so you'll have a detail explanation of how this stuff works.</span>
<span class="comment-copy">@joreilli: I added a quick note about this in the answer, and a link to a more detailed answer about iterable, list comprehension, generators and eventually the yield keyword.</span>
<span class="comment-copy">@nurettin: <a href="http://en.wikipedia.org/wiki/Gettext#Operation" rel="nofollow noreferrer">en.wikipedia.org/wiki/Gettext#Operation</a></span>
<span class="comment-copy">Yes, the official standard library for <code>random</code> has warn this: "<b>Warning</b>: The pseudo-random generators of this module should not be used for security purposes. Use os.urandom() or SystemRandom if you require a cryptographically secure pseudo-random number generator." Here is the ref:  <a href="https://docs.python.org/2/library/random.html#random.SystemRandom" rel="nofollow noreferrer">random.SystemRandom</a> and <a href="https://docs.python.org/2/library/os.html#os.urandom" rel="nofollow noreferrer">os.urandom</a></span>
<span class="comment-copy">Great answer. Small note: You changed it to <code>string.uppercase</code> which can lead to unexpected results depending on the locale set. Using <code>string.ascii_uppercase</code> (or <code>string.ascii_letters + string.digits</code> for base62 instead of base36) is safer in cases where encoding is involved.</span>
<span class="comment-copy">small note - better to use <code>xrange</code> instead of <code>range</code> as the latter generates an in-memory list, while the former creates an iterator.</span>
<span class="comment-copy">will the random sting will be alway be unique ?  i wanted to use a primary key.</span>
<span class="comment-copy">@shakthydoss: no. It may return "AAA000", which is a random string, and next "AAA000", which is <i>also</i> a random string. You must explicitly add a check for uniqueness.</span>
<span class="comment-copy">+1 For thinking behind the question. Perhaps you could briefly explain the difference between uuid1 and uuid4.</span>
<span class="comment-copy">If I do uuid1 three times in a row I get: d161fd16-ab0f-11e3-9314-00259073e4a8,  d3535b56-ab0f-11e3-9314-00259073e4a8,  d413be32-ab0f-11e3-9314-00259073e4a8,  which all seem to be suspiciously similar (the first 8 chars differ and the rest are the same). This isn't the case with uuid4</span>
<span class="comment-copy">uui1: Generate a UUID from a host ID, sequence number, and the current time. uuid4: Generate a random UUID.</span>
<span class="comment-copy">If you want to skip the string casting &amp; hyphen replacing, you can just call my_uuid.get_hex() or uuid.uuid4().get_hex() and it will return a string generated from the uuid that does not have hyphens.</span>
<span class="comment-copy">Is it a good idea to truncate a UUID? Depending on how small <code>string_length</code> is, the probability of collision can be a concern.</span>
<span class="comment-copy">This way isn't bad but it's not quite as random as selecting each character separately, as with <code>sample</code> you'll never get the same character listed twice. Also of course it'll fail for <code>N</code> higher than <code>36</code>.</span>
<span class="comment-copy">One of the examples has a repeat, so I doubt he is looking to disallow repeats.</span>
<span class="comment-copy"><code>''.join(random.sample(char_set*6,6))</code> solves the problem.</span>
<span class="comment-copy">If random.sample prevents character reuse, multiplying the size of the character set makes multiple repetitions <i>possible</i>, but they are still less <i>likely</i> then they are in a pure random choice.  If we go for a string of length 6, and we pick 'X' as the first character, in the choice example, the odds of getting 'X' for the second character are the same as the odds of getting 'X' as the first character.  In the random.sample implementation, the odds of getting 'X' as any subsequent character are only 5/6 the chance of getting it as the first character.</span>
<span class="comment-copy">The chance of getting a particular character repeated drops off as you move through the generated string.  Generating a string of 6 characters from the 26 uppercase letters plus 10 digits, randomly choosing each character independently, any particular string occurs with frequency 1/(36^6).  The chance of generating 'FU3WYE' and 'XXXXXX' is the same.  In the sample implementation, the chance of generating 'XXXXXX' is (1/(36^6)) * ((6/6) * (5/6) * (4/6) * (3/6) * (2/6) * (1/6)) due to the non-replacement feature of random.sample. 'XXXXXX' is 324 times less likely in the sample implementation.</span>
<span class="comment-copy">Its good when random value has no length limit</span>
<span class="comment-copy"><code>uppercase_str[:N+1]</code></span>
<span class="comment-copy">@Yajo yeah we can limit using slicing</span>
<span class="comment-copy">@Yajo: no, you don't want to slice the hex value. You remove entropy compared to a full sequence of uppercase letters and digits. Perhaps base32-encode the value instead (slightly reduced entropy, from 36 ** n to 32 ** n, still better than 16 ** n).</span>
<span class="comment-copy">since we are generating random string with <code>string.ascii_uppercase + string.digits</code> ~ <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code>, there will be a possibility that <code>random.choice</code> may pick only <code>letters</code>, I tested it and got <code>NZAUDKM</code>, <code>WBZMKFH</code>,<code>ZUJHHTU</code></span>
<span class="comment-copy">@akashkarothiya: This is true and is what the OP implicitly requires. I also tested it just now and got: <code>L1KBO7</code>, <code>BLSDEB</code>, <code>3RQB59</code>, <code>PFOO20</code>, so anything is possible.</span>
<span class="comment-copy">How is <code>os.urandom</code> not pseudo random? It might be using a better algorithm to generate numbers that are more random, but it is still pseudo random.</span>
<span class="comment-copy">@Tyilo, see here <a href="http://docs.python.org/2/library/os.html#os.urandom" rel="nofollow noreferrer">docs.python.org/2/library/os.html#os.urandom</a></span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/5635277/is-dev-random-considered-truly-random" title="is dev random considered truly random">stackoverflow.com/questions/5635277/…</a></span>
<span class="comment-copy">@Tyilo, I am aware of the difference between <code>/dev/random</code> and <code>/dev/urandom</code>. The problem is that <code>/dev/random</code> blocks when there is not enough entropy which limits it's usefulness. For a <b>one time pad</b> <code>/dev/urandom</code> isn't good enough, but I think it's better than pseudo random here.</span>
<span class="comment-copy">I would say that both <code>/dev/random</code> and <code>/dev/urandom</code> is pseudo random, but it might depend on your definition.</span>
<span class="comment-copy">I won't vote this down, but I think it's far too complicated for such a simple task. The return expression is a monster.  Simple is better than complex.</span>
<span class="comment-copy">@CarlSmith, true my solution seems a bit overkill for the task, but I was aware of the other simpler solutions, and just wished to find an alternative route to a good answer. Without freedom, creativity is in danger, thus I went ahead and posted it.</span>
<span class="comment-copy">This is nice, though it will only use 'A-F' and not 'A-Z'. Also, the code gets a little less nice when parametrize <code>N</code>.</span>
<span class="comment-copy">Why should I use numpy random instead of python stdlib random?</span>
<span class="comment-copy">Because it allows more options in arguments like length, variable probability and selection with replacement.</span>
<span class="comment-copy">But this variant will force all characters to be different. And it will not work if N is larger than len(string.ascii_uppercase + string.digits)</span>
<span class="comment-copy">Although this code may answer the question, providing additional context regarding <i>why</i> and/or <i>how</i> it answers the question would significantly improve its long-term value.  Please <a href="https://stackoverflow.com/posts/37161128/edit">edit</a> your answer to add some explanation.</span>
<span class="comment-copy">Nice, but you could have used <code>range(num)</code> instead, and str could have been a string <code>str += random.choice(chars)</code>.</span>
