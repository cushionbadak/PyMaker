<div class="post-text" itemprop="text">
<p>I want to print out a dictionary, sorted by the key. Sorting the keys is easy in the view, by just putting the keys in a list and then sorting the list. How can I loop through the keys in the template and then get the value from the dictionary.</p>
<pre><code>{% for company in companies %}
    {% for employee, dependents in company_dict.company.items %}
    {% endfor %}
{% endfor %}
</code></pre>
<p>(Just made up the example...)
The part that doesn't work is the "company_dict.company.items" part. I need the "company" to be the value of company. Right now the company prat is looking for a key named "company" not the value of "company" from the loop above.</p>
<p>I'm doing a bit of processing to put the dictionary of dictionaries together. Changing the layout of the data isn't really an option. I figure the right approach is to write up a template tag, just wanted to know if there was a built-in way I missed.</p>
</div>
<div class="post-text" itemprop="text">
<p>try this: <a href="http://www.bhphp.com/blog4.php/2009/08/17/django-templates-and-dictionaries" rel="nofollow noreferrer">http://www.bhphp.com/blog4.php/2009/08/17/django-templates-and-dictionaries</a></p>
<p>a custom template filter will do the trick.</p>
<pre><code>from django import template
register = template.Library()

def dict_get(value, arg):
    #custom template tag used like so:
    #{{dictionary|dict_get:var}}
    #where dictionary is duh a dictionary and var is a variable representing
    #one of it's keys

    return value[arg]

register.filter('dict_get',dict_get)
</code></pre>
<p>more on custom template filters: <a href="http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#howto-custom-template-tags" rel="nofollow noreferrer">http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#howto-custom-template-tags</a></p>
<p>in your example you'd do:</p>
<pre><code>{% for employee, dependents in company_dict|company %}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>create a custom filter, which is like this:</p>
<pre><code>from django import template
from django.utils.datastructures import SortedDict

register = template.Library()

@register.filter(name='sort')
def listsort(value):
    if isinstance(value, dict):
        new_dict = SortedDict()
        key_list = sorted(value.keys())
        for key in key_list:
            new_dict[key] = value[key]
        return new_dict
    elif isinstance(value, list):
        return sorted(value)
    else:
        return value
    listsort.is_safe = True
</code></pre>
<p>then in your template you shall call it using:</p>
<pre><code>{% for key, value in companies.items|sort %}
      {{ key }} {{ value }}
{% endfor %}
</code></pre>
<p>You will be able to get the sorted dict by Key.</p>
</div>
<div class="post-text" itemprop="text">
<p>This last solution was very useful to me too. I'm using Django 1.6.2, and it seems to be converting a dict to a list with the key as the first elemement of that list and the content as the second. So even when I pass in a dict, it treats it as a list. So I tweaked the above to look like this, and it works for me:</p>
<pre><code>@register.filter(name='sort')
def listsort(value):
    if isinstance(value, list):
        return sorted(value, key=lambda k:k[0])
    else:
        return value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>for some reasone Turikumwe's filter not worked for me (python3.4, Django 1.7), so I rewrite it to return list of tuples instead of <code>SertedDict</code> or <code>OrderedDict</code>:</p>
<pre><code>@register.filter(name='sort')
def listsort(value):
    if isinstance(value, dict):
        a = []
        key_list = sorted(value.keys())
        for key in key_list:
            a.append((key, value[key]))
        return a
    elif isinstance(value, list):
        return sorted(value)
    else:
        return value

listsort.is_safe = True
</code></pre>
<p>So in template we don't need to get <code>.items</code></p>
<pre><code>{% for key, value in companies|sort %}
      {{ key }} {{ value }}
{% endfor %}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Turikumwe's answer got me close, but did not work for my environment: python3 and Django 1.10. </p>
<p>I found that invoking the filter with:</p>
<pre><code>{% for key, value in companies.items|sort %}
      {{ key }} {{ value }}
{% endfor %}
</code></pre>
<p>actually results in a ItemsView object, not a dict.  (I suspect this is a python 2 vs 3 issue).  Given the ItemsView, the answer is even easier</p>
<pre><code>from django import template
from django.utils.datastructures import ItemsView

register = template.Library()

@register.filter(name='sort')
def listsort(value):
    if isinstance(value, ItemsView) or isinstance(value, list):
        return sorted(value)
    else:
        return value
</code></pre>
</div>
<span class="comment-copy">Any reason why aren't you doing this in the view?</span>
<span class="comment-copy">It's a bunch of processing. And to set it up so as not to have to do anything in the template, would take a second pass at the data. I guess I could just do that... Figured if it were possible to leave as is, it'd be better.</span>
<span class="comment-copy">Django's built-in filter <a href="https://docs.djangoproject.com/en/dev/ref/templates/builtins/#dictsort" rel="nofollow noreferrer">dictsort</a> sorts values based on a key but it doesn't sort the keys itself.</span>
<span class="comment-copy">Thanks a lot! I had to modify what you did a bit. My filter returns "value[arg].iteritems()" and the template looks like so: {% for employee, dependents in company_dict|get_dict_and_iter:company %}</span>
<span class="comment-copy">hey whatever works. most people using this site could modify what i did to their circumstance as well.</span>
<span class="comment-copy">Maybe nearly exact duplicate, but while the other one didn't, this answer helped me and is dad-gum brilliant, thank you so much!</span>
<span class="comment-copy">It also helped me more than the previous answer !</span>
<span class="comment-copy"><i>"Marking a filter is_safe will coerce the filter’s return value to a string. If your filter should return a boolean or other non-string value, marking it is_safe will probably have unintended consequences (such as converting a boolean False to the string ‘False’)."</i> (<a href="https://docs.djangoproject.com/en/1.6/howto/custom-template-tags/#filters-and-auto-escaping" rel="nofollow noreferrer">django documentation</a>) So, it is probably better to remove that is_safe line.</span>
<span class="comment-copy">Also, <a href="https://code.djangoproject.com/wiki/SortedDict" rel="nofollow noreferrer"><code>SortedDict</code> is deprecated as of Django 1.7 and will be removed in Django 1.9.</a>. Use <code>collections.OrderedDict</code> instead (available <a href="https://docs.python.org/2.7/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">in Python 2.7</a> and <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">in Python 3</a>).</span>
<span class="comment-copy">if this is not work, please try <a href="http://stackoverflow.com/a/37158431/3479125">stackoverflow.com/a/37158431/3479125</a></span>
