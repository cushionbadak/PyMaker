<div class="post-text" itemprop="text">
<p>I have a list of lists:</p>
<pre><code>lists = [[1,4,3,2,4], [4,5]]
</code></pre>
<p>I want to flatten this list and remove all duplicates; or, in other words, apply a set union operation:</p>
<pre><code>desired_result = [1, 2, 3, 4, 5]
</code></pre>
<p>What's the easiest way to do this? (I'm forced to use Python 2.4 for this project)</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#frozenset.union" rel="noreferrer"><code>set.union</code></a> does what you want:</p>
<pre><code>&gt;&gt;&gt; results_list = [[1,2,3], [1,2,4]]
&gt;&gt;&gt; results_union = set().union(*results_list)
&gt;&gt;&gt; print(results_union)
set([1, 2, 3, 4])
</code></pre>
<p>You can also do this with more than two lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you seem to be using Python 2.5 (it <strong>would</strong> be nice to mention in your Q if you need an A for versions != 2.6, the current production one, by the way;-) and want a list rather than a set as the result, I recommend:</p>
<pre><code>   import itertools

   ...

   return list(set(itertools.chain(*result_list)))
</code></pre>
<p><a href="http://docs.python.org/library/itertools.html?highlight=itertools#module-itertools" rel="noreferrer">itertools</a> is generally a great way to work with iterators (and so with many kinds of sequences or collections) and I heartily recommend you become familiar with it.  <code>itertools.chain</code>, in particular, is documented <a href="http://docs.python.org/library/itertools.html?highlight=itertools#itertools.chain" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I  used the following to do intersections, which avoids the need for sets.</p>
<pre><code>a, b= [[1,2,3], [1,2]]
s = filter( lambda x: x in b, a)
</code></pre>
<p>or,</p>
<pre><code>s = [ x for x in b if x in a ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unions are not supported by lists, which are ordered, but are supported by sets. Check out <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">set.union</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also follow this style </p>
<pre><code>In [12]: a = ['Orange and Banana', 'Orange Banana']
In [13]: b = ['Grapes', 'Orange Banana']
In [14]: c = ['Foobanana', 'Orange and Banana']

In [20]: list(set(a) | set(b) | set(c))
Out[20]: ['Orange and Banana', 'Foobanana', 'Orange Banana', 'Grapes']

In [21]: list(set(a) &amp; set(b) | set(c))
Out[21]: ['Orange and Banana', 'Foobanana', 'Orange Banana']    
</code></pre>
</div>
<span class="comment-copy">@sth, thanks for example, but when I run it I get an error:  Traceback (most recent call last):   File "so_example.py", line 33, in ?     results_union=set().union(*result_lists) TypeError: union() takes exactly one argument (3 given)</span>
<span class="comment-copy">@AJ: According to the documentsion (<a href="http://docs.python.org/library/stdtypes.html#set.union" rel="nofollow noreferrer">docs.python.org/library/stdtypes.html#set.union</a>) <code>union()</code> only supports multiple arguments for Python version 2.6 or higher. You seem to use a version before that, so you probably have to use an explicit loop: <code>total = set(); for x in results_list: total.update(x)</code> <i>(s/;/\n/)</i></span>
<span class="comment-copy">You can also save creating an empty set by changing the 2nd line to <code>results_union = set.union(*(set(el) for el in results_list))</code></span>
<span class="comment-copy">In this case it's less neat. But if the inputs on the first line were sets too...</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre <code>TypeError: descriptor 'union' requires a 'set' object but received a 'list'</code> in python 3.6 atleast.</span>
<span class="comment-copy">+1 A perfect example of a good time to dip into the wonderful <code>itertools</code> package.</span>
<span class="comment-copy">@Alex thanks...edited my question to specify version and remove blame from myself for being so behind in versions :)  I'll make it a point to look into itertools, appreciate the suggestion.</span>
<span class="comment-copy">@AJ, no blame, we all can suffer under such constraints after all (but please do remember to specify in future Qs!-); <code>itertools.chain</code> works fine in Python 2.4 as well, by the way.</span>
<span class="comment-copy">This doesn't work for an arbitrary number of lists.</span>
<span class="comment-copy">Why would you even want to "avoid the need for sets"?  They're faster, and clearer, for this purpose.  And your "x in a" does a linear, brute-force search through the list each time you execute it.  Yuck.</span>
<span class="comment-copy">sets require type casting, and linear speed isn't bad unless you are dealing with a large N.</span>
<span class="comment-copy">"Type casting"?  In Python?  Since when?  Sets are basically dicts with only the keys, and they use hash and equality comparisons.  Using "x in a" on a list does an equality comparison too.  What's all this about type casting?</span>
