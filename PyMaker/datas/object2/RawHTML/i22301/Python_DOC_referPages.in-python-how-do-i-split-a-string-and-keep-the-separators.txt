<div class="post-text" itemprop="text">
<p>Here's the simplest way to explain this. Here's what I'm using:</p>
<pre><code>re.split('\W', 'foo/bar spam\neggs')
-&gt; ['foo', 'bar', 'spam', 'eggs']
</code></pre>
<p>Here's what I want:</p>
<pre><code>someMethod('\W', 'foo/bar spam\neggs')
-&gt; ['foo', '/', 'bar', ' ', 'spam', '\n', 'eggs']
</code></pre>
<p>The reason is that I want to split a string into tokens, manipulate it, then put it back together again.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; re.split('(\W)', 'foo/bar spam\neggs')
['foo', '/', 'bar', ' ', 'spam', '\n', 'eggs']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are splitting on newline, use <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="noreferrer"><code>splitlines(True)</code></a>.</p>
<pre><code>&gt;&gt;&gt; 'line 1\nline 2\nline without newline'.splitlines(True)
['line 1\n', 'line 2\n', 'line without newline']
</code></pre>
<p>(Not a general solution, but adding this here in case someone comes here not realizing this method existed.)</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Another no-regex solution that works well on Python 3</strong></p>
<pre><code># Split strings and keep separator
test_strings = ['&lt;Hello&gt;', 'Hi', '&lt;Hi&gt; &lt;Planet&gt;', '&lt;', '']

def split_and_keep(s, sep):
   if not s: return [''] # consistent with string.split()

   # Find replacement character that is not used in string
   # i.e. just use the highest available character plus one
   # Note: This fails if ord(max(s)) = 0x10FFFF (ValueError)
   p=chr(ord(max(s))+1) 

   return s.replace(sep, sep+p).split(p)

for s in test_strings:
   print(split_and_keep(s, '&lt;'))


# If the unicode limit is reached it will fail explicitly
unicode_max_char = chr(1114111)
ridiculous_string = '&lt;Hello&gt;'+unicode_max_char+'&lt;World&gt;'
print(split_and_keep(ridiculous_string, '&lt;'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have only 1 separator, you can employ list comprehensions:</p>
<pre><code>text = 'foo,bar,baz,qux'  
sep = ','
</code></pre>
<p>Appending/prepending separator:</p>
<pre><code>result = [x+sep for x in text.split(sep)]
#['foo,', 'bar,', 'baz,', 'qux,']
# to get rid of trailing
result[-1] = result[-1].strip(sep)
#['foo,', 'bar,', 'baz,', 'qux']

result = [sep+x for x in text.split(sep)]
#[',foo', ',bar', ',baz', ',qux']
# to get rid of trailing
result[0] = result[0].strip(sep)
#['foo', ',bar', ',baz', ',qux']
</code></pre>
<p>Separator as it's own element:</p>
<pre><code>result = [u for x in text.split(sep) for u in (x, sep)]
#['foo', ',', 'bar', ',', 'baz', ',', 'qux', ',']
results = result[:-1]   # to get rid of trailing
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>another example, split on non alpha-numeric and keep the separators</p>
<pre><code>import re
a = "foo,bar@candy*ice%cream"
re.split('([^a-zA-Z0-9])',a)
</code></pre>
<p>output:</p>
<pre><code>['foo', ',', 'bar', '@', 'candy', '*', 'ice', '%', 'cream']
</code></pre>
<p>explanation</p>
<pre><code>re.split('([^a-zA-Z0-9])',a)

() &lt;- keep the separators
[] &lt;- match everything in between
^a-zA-Z0-9 &lt;-except alphabets, upper/lower and numbers.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also split a string with an array of strings instead of a regular expression, like this:</p>
<pre><code>def tokenizeString(aString, separators):
    #separators is an array of strings that are being used to split the the string.
    #sort separators in order of descending length
    separators.sort(key=len)
    listToReturn = []
    i = 0
    while i &lt; len(aString):
        theSeparator = ""
        for current in separators:
            if current == aString[i:i+len(current)]:
                theSeparator = current
        if theSeparator != "":
            listToReturn += [theSeparator]
            i = i + len(theSeparator)
        else:
            if listToReturn == []:
                listToReturn = [""]
            if(listToReturn[-1] in separators):
                listToReturn += [""]
            listToReturn[-1] += aString[i]
            i += 1
    return listToReturn


print(tokenizeString(aString = "\"\"\"hi\"\"\" hello + world += (1*2+3/5) '''hi'''", separators = ["'''", '+=', '+', "/", "*", "\\'", '\\"', "-=", "-", " ", '"""', "(", ")"]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># This keeps all separators  in result 
##########################################################################
import re
st="%%(c+dd+e+f-1523)%%7"
sh=re.compile('[\+\-//\*\&lt;\&gt;\%\(\)]')

def splitStringFull(sh, st):
   ls=sh.split(st)
   lo=[]
   start=0
   for l in ls:
     if not l : continue
     k=st.find(l)
     llen=len(l)
     if k&gt; start:
       tmp= st[start:k]
       lo.append(tmp)
       lo.append(l)
       start = k + llen
     else:
       lo.append(l)
       start =llen
   return lo
  #############################

li= splitStringFull(sh , st)
['%%(', 'c', '+', 'dd', '+', 'e', '+', 'f', '-', '1523', ')%%', '7']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If one wants to split string while keeping separators by regex without capturing group:</p>
<pre><code>def finditer_with_separators(regex, s):
    matches = []
    prev_end = 0
    for match in regex.finditer(s):
        match_start = match.start()
        if (prev_end != 0 or match_start &gt; 0) and match_start != prev_end:
            matches.append(s[prev_end:match.start()])
        matches.append(match.group())
        prev_end = match.end()
    if prev_end &lt; len(s):
        matches.append(s[prev_end:])
    return matches

regex = re.compile(r"[\(\)]")
matches = finditer_with_separators(regex, s)
</code></pre>
<p>If one assumes that regex is wrapped up into capturing group:</p>
<pre><code>def split_with_separators(regex, s):
    matches = list(filter(None, regex.split(s)))
    return matches

regex = re.compile(r"([\(\)])")
matches = split_with_separators(regex, s)
</code></pre>
<p>Both ways also will remove empty groups which are useless and annoying in most of the cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>One Lazy and Simple Solution</p>
<p>Assume your regex pattern is <code>split_pattern = r'(!|\?)'</code></p>
<p>First, you add some same character as the new separator, like '[cut]'</p>
<p><code>new_string = re.sub(split_pattern, '\\1[cut]',  your_string)</code></p>
<p>Then you split the new separator, <code>new_string.split('[cut]')</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I had a similar issue trying to split a file path and struggled to find a simple answer.
This worked for me and didn't involve having to substitute delimiters back into the split text:</p>
<p><code>my_path = 'folder1/folder2/folder3/file1'</code></p>
<p><code>import re</code></p>
<p><code>re.findall('[^/]+/|[^/]+', my_path)</code></p>
<p>returns:</p>
<p><code>['folder1/', 'folder2/', 'folder3/', 'file1']</code></p>
</div>
<span class="comment-copy">what does <code>\W</code> stand for? I failed on google it.</span>
<span class="comment-copy">A <i>non-word</i> character <a href="https://docs.python.org/2/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">see here for details</a></span>
<span class="comment-copy">That's cool. I didn't know re.split did that with capture groups.</span>
<span class="comment-copy">@Laurence: Well, it's documented: <a href="http://docs.python.org/library/re.html#re.split" rel="nofollow noreferrer">docs.python.org/library/re.html#re.split</a>: "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list."</span>
<span class="comment-copy">It's seriously underdocumented. I've been using Python for 14 years and only just found this out.</span>
<span class="comment-copy">It's also possible to <a href="http://stackoverflow.com/questions/280435/escaping-regex-string-in-python">escape the special characters in a string</a>, which makes it easier to generate a regular expression that matches a list of strings.</span>
<span class="comment-copy">Is there an option so that the output of the group match is attached to whatever is on the left (or analogously right) of the split? For example, can this be easily modified so the output is <code>['foo', '/bar', ' spam', '\neggs']</code>?</span>
<span class="comment-copy">Even though, as the <a href="https://docs.python.org/3.7/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">docs</a> say, this is equivalent to the accepted answer, I like this version's readability--even though <code>\W</code> is a more compact way to express it.</span>
