<div class="post-text" itemprop="text">
<p>Given a frame object, I need to get the corresponding module object.  In other words, implement callers_module so this works:</p>
<pre><code>import sys
from some_other_module import callers_module
assert sys.modules[__name__] is callers_module()
</code></pre>
<p>(That would be equivalent because I can generate a stack trace in the function for this test case.  The imports are there simply to make that example complete and testable, and prevent callers_module from taking the shortcut of using __name__, since it's in a different module.)</p>
<p>I've attempted this:</p>
<pre><code>import inspect
def callers_module():
  return inspect.currentframe().f_back
</code></pre>
<p>Which gets a frame object, on which f_code will give me a code object, but I can't find out how to get the corresponding module or its name (to use with sys.modules).  If I could get function objects, those have a __module__ attribute (and also have code objects), but that's not present in the frame.  Indeed, not all code objects belong to function objects, such as the code for my test case (with assert, above).  The same can be said of frame/code objects not having a moduleâ€”but many of them do, and in my case they will, so that doesn't need to be handled; however, a simple None or exception is fine in that case, too.</p>
<p>It feels like I'm missing something simple.  What needs to be done for this to work?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import inspect
def callers_module():
   module = inspect.getmodule(inspect.currentframe().f_back)
   return module
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While inspect.getmodule works great, and I was indeed looking in the wrong place to find it, I found a slightly better solution for me:</p>
<pre><code>def callers_module():
  module_name = inspect.currentframe().f_back.f_globals["__name__"]
  return sys.modules[module_name]
</code></pre>
<p>It still uses inspect.currentframe (which I prefer over the exactly identical sys._getframe), but doesn't invoke inspect's module-filename mapping (in inspect.getmodule).</p>
<p>Additionally, this question inspired an interesting way to <a href="http://bitbucket.org/kniht/scraps/src/tip/python/export.py" rel="noreferrer">manage __all__</a>:</p>
<pre><code>from export import export

@export
class Example: pass

@export
def example: pass

answer = 42
export.name("answer")

assert __all__ == ["Example", "example", "answer"]
</code></pre>
</div>
<span class="comment-copy">Now I wish I could make modules callable and simplify the above example: <a href="http://stackoverflow.com/questions/1060796/callable-modules">stackoverflow.com/questions/1060796/callable-modules</a></span>
<span class="comment-copy">Beware if you're looking for the string with the module name. It won't work as expected if the module is executed as a <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer">top-level script</a>, because then <code>__name__</code> will be always <code>__main__</code>. To cover all cases, it's best to use <code>inspect.getmodule().__spec__.name</code> which will bring the real module's name even it is the top-level script.</span>
