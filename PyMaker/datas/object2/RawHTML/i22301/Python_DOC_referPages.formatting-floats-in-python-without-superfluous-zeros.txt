<div class="post-text" itemprop="text">
<p>How to format a float so it does not containt the remaing zeros? In other words, I want the resulting string to be as short as possible..?</p>
<p>Like:</p>
<pre><code>3 -&gt; "3"
3. -&gt; "3"
3.0 -&gt; "3"
3.1 -&gt; "3.1"
3.14 -&gt; "3.14"
3.140 -&gt; "3.14"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Me, I'd do <code>('%f' % x).rstrip('0').rstrip('.')</code> -- guarantees fixed-point formatting rather than scientific notation, etc etc.  Yeah, not as slick and elegant as <code>%g</code>, but, it works (and I don't know how to force <code>%g</code> to never use scientific notation;-).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>%g</code> to achieve this:</p>
<pre><code>'%g'%(3.140)
</code></pre>
<p>or, for Python 2.6 or better:</p>
<pre><code>'{0:g}'.format(3.140)
</code></pre>
<p>From the <a href="http://docs.python.org/library/string.html#format-specification-mini-language" rel="noreferrer">docs for <code>format</code></a>: <code>g</code> causes (among other things)</p>
<blockquote>
<p>insignificant trailing zeros [to be]
  removed from the significand, and the
  decimal point is also removed if there
  are no remaining digits following it.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>What about trying the easiest and probably most effective approach?
The method <strong>normalize()</strong> removes all the rightmost trailing zeros.</p>
<pre><code>from decimal import Decimal

print (Decimal('0.001000').normalize())
# Result: 0.001
</code></pre>
<p>Works in <strong>Python 2</strong> and <strong>Python 3</strong>.</p>
<p><strong>-- Updated --</strong></p>
<p>The only problem as @BobStein-VisiBone pointed out, is that numbers like 10, 100, 1000... will be displayed in exponential representation. This can be easily fixed using the following function instead:</p>
<pre><code>from decimal import Decimal


def format_float(f):
    d = Decimal(str(f));
    return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After looking over answers to several similar questions, this seems to be the best solution for me:</p>
<pre><code>def floatToString(inputValue):
    return ('%.15f' % inputValue).rstrip('0').rstrip('.')
</code></pre>
<p>My reasoning:</p>
<p><code>%g</code> doesn't get rid of scientific notation.</p>
<pre><code>&gt;&gt;&gt; '%g' % 0.000035
'3.5e-05'
</code></pre>
<p>15 decimal places seems to avoid strange behavior and has plenty of precision for my needs.</p>
<pre><code>&gt;&gt;&gt; ('%.15f' % 1.35).rstrip('0').rstrip('.')
'1.35'
&gt;&gt;&gt; ('%.16f' % 1.35).rstrip('0').rstrip('.')
'1.3500000000000001'
</code></pre>
<p>I could have used <code>format(inputValue, '.15f').</code> instead of <code>'%.15f' % inputValue</code>, but that is a bit slower (~30%).</p>
<p>I could have used <code>Decimal(inputValue).normalize()</code>, but this has a few issues as well. For one, it is A LOT slower (~11x). I also found that although it has pretty great precision, it still suffers from precision loss when using <code>normalize()</code>.</p>
<pre><code>&gt;&gt;&gt; Decimal('0.21000000000000000000000000006').normalize()
Decimal('0.2100000000000000000000000001')
&gt;&gt;&gt; Decimal('0.21000000000000000000000000006')
Decimal('0.21000000000000000000000000006')
</code></pre>
<p>Most importantly, I would still be converting to <code>Decimal</code> from a <code>float</code> which can make you end up with something other than the number you put in there. I think <code>Decimal</code> works best when the arithmetic stays in <code>Decimal</code> and the <code>Decimal</code> is initialized with a string.</p>
<pre><code>&gt;&gt;&gt; Decimal(1.35)
Decimal('1.350000000000000088817841970012523233890533447265625')
&gt;&gt;&gt; Decimal('1.35')
Decimal('1.35')
</code></pre>
<p>I'm sure the precision issue of <code>Decimal.normalize()</code> can be adjusted to what is needed using context settings, but considering the already slow speed and not needing ridiculous precision and the fact that I'd still be converting from a float and losing precision anyway, I didn't think it was worth pursuing.</p>
<p>I'm not concerned with the possible "-0" result since -0.0 is a valid floating point number and it would probably be a rare occurrence anyway, but since you did mention you want to keep the string result as short as possible, you could always use an extra conditional at very little extra speed cost.</p>
<pre><code>def floatToString(inputValue):
    result = ('%.15f' % inputValue).rstrip('0').rstrip('.')
    return '0' if result == '-0' else result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution that worked for me. It's a blend of the <a href="https://stackoverflow.com/a/37736333/1219634">solution</a> by <strong>PolyMesh</strong> and use of the new <code>.format()</code> <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">syntax</a>.</p>
<pre class="lang-python prettyprint-override"><code>for num in 3, 3., 3.0, 3.1, 3.14, 3.140:
    print('{0:.2f}'.format(num).rstrip('0').rstrip('.'))
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>3
3
3
3.1
3.14
3.14
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use format() to achieve this:</p>
<p><code>format(3.140, '.10g')</code> where 10 is the precision you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>While formatting is likely that most Pythonic way, here is an alternate solution using the <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.rstrip" rel="nofollow noreferrer"><code>more_itertools.rstrip</code></a> tool.</p>
<pre><code>import more_itertools as mit


def fmt(num, pred=None):
    iterable = str(num)
    predicate = pred if pred is not None else lambda x: x in {".", "0"}
    return "".join(mit.rstrip(iterable, predicate))

assert fmt(3) == "3"
assert fmt(3.) == "3"
assert fmt(3.0) == "3"
assert fmt(3.1) == "3.1"
assert fmt(3.14) == "3.14"
assert fmt(3.140) == "3.14"
assert fmt(3.14000) == "3.14"
assert fmt("3,0", pred=lambda x: x in set(",0")) == "3"
</code></pre>
<p>The number is converted to a string, which is stripped of trailing characters that satisfy a predicate.  The function definition <code>fmt</code> is not required, but it is used here to test assertions, which all pass. Note: it works on string inputs and accepts optional predicates.</p>
<p>See also details on this third-party library, <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; str(a if a % 1 else int(a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can live with 3. and 3.0 appearing as "3.0", a very simple approach that right-strips zeros from float representations:</p>
<pre><code>print("%s"%3.140)
</code></pre>
<p>(thanks @ellimilial for pointing out the exceptions)</p>
</div>
<div class="post-text" itemprop="text">
<p>OP would like to remove superflouous zeros and make the resulting string as short as possible.</p>
<p>I find the %g exponential formatting shortens the resulting string for very large and very small values. The problem comes for values that don't need exponential notation, like 128.0, which is neither very large or very small.</p>
<p>Here is one way to format numbers as short strings that uses %g exponential notation only when Decimal.normalize creates strings that are too long. This might not be the fastest solution (since it does use Decimal.normalize) </p>
<pre><code>def floatToString (inputValue, precision = 3):
    rc = str(Decimal(inputValue).normalize())
    if 'E' in rc or len(rc) &gt; 5:
        rc = '{0:.{1}g}'.format(inputValue, precision)        
    return rc

inputs = [128.0, 32768.0, 65536, 65536 * 2, 31.5, 1.000, 10.0]

outputs = [floatToString(i) for i in inputs]

print(outputs)

# ['128', '32768', '65536', '1.31e+05', '31.5', '1', '10']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For float you could use this:</p>
<pre><code>def format_float(num):
    return ('%i' if num == int(num) else '%s') % num
</code></pre>
<p>Test it:</p>
<pre><code>&gt;&gt;&gt; format_float(1.00000)
'1'
&gt;&gt;&gt; format_float(1.1234567890000000000)
'1.123456789'
</code></pre>
<p>For Decimal see solution here: <a href="https://stackoverflow.com/a/42668598/5917543">https://stackoverflow.com/a/42668598/5917543</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Handling %f and you should put </p>
<blockquote>
<p>%.2f</p>
</blockquote>
<p>, where:
.2f == .00 floats.</p>
<p>Example:</p>
<p><strong>print "Price: %.2f" % prices[product]</strong></p>
<h1>output:</h1>
<p>Price: 1.50</p>
</div>
<div class="post-text" itemprop="text">
<p>Use %g with big enough width, for example '%.99g'.
It will print in fixed-point notation for any reasonably big number.</p>
<p><strong>EDIT: it doesn't work</strong></p>
<pre><code>&gt;&gt;&gt; '%.99g' % 0.0000001
'9.99999999999999954748111825886258685613938723690807819366455078125e-08'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>max()</code> like this:</p>
<p><code>print(max(int(x), x))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve that in most pythonic way like that:</p>
<p>python3:</p>
<pre><code>"{:0.0f}".format(num)
</code></pre>
</div>
<span class="comment-copy">That example doesn't make any sense at all.  <code>3.14 == 3.140</code> -- They're the <i>same</i> floating point number.  For that matter 3.140000 is the same floating-point number.  The zero doesn't exist in the first place.</span>
<span class="comment-copy">@S.Lott - I think the issue is PRINTING the float number without the trailing zeros, not the actual equivalence of two numbers.</span>
<span class="comment-copy">@pokstad:  In which case, there's no "superfluous" zero.  <code>%0.2f</code> and <code>%0.3f</code> are the two formats required to produce the last numbers on the left.  Use <code>%0.2f</code> to produce the last two numbers on the right.</span>
<span class="comment-copy"><code>3.0 -&gt; "3"</code> is still a valid use case. <code>print( '{:,g}'.format( X )</code> worked for me to output <code>3</code> where <code>X = 6 / 2</code> and when <code>X = 5 / 2</code> I got an output of <code>2.5</code> as expected.</span>
<span class="comment-copy">old question, but.. <code>print("%s"%3.140)</code> gives you what you want. (I added an answer down down below...)</span>
<span class="comment-copy">The only problem with that is <code>'%.2f' % -0.0001</code> will leave you with <code>-0.00</code> and ultimately <code>-0</code>.</span>
<span class="comment-copy">It doesn't work: 0.0000001 is rounded to 0</span>
<span class="comment-copy">@alexanderlukanin13 because the default precision is 6, see <a href="https://docs.python.org/2/library/string.html" rel="nofollow noreferrer">docs.python.org/2/library/string.html</a>: <code>'f' 	Fixed point. Displays the number as a fixed-point number. The default precision is 6.</code> You would have to use '%0.7f' in the above solution.</span>
<span class="comment-copy">@derenio Good point :-) I can only add that raising precision above <code>'%0.15f'</code> is a bad idea, because <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" rel="nofollow noreferrer">weird stuff</a> starts to happen.</span>
<span class="comment-copy">In case you're in a middle of some other string:   <code>print('In the middle {} and something else'.format('{:f}'.format(a).rstrip('0')))</code></span>
<span class="comment-copy">Oh, almost! Sometimes it formats the float in scientific notation ("2.342E+09") - is it possible to turn it off, i.e. always show all significant digits?</span>
<span class="comment-copy">Why use <code>'{0:...}'.format(value)</code> when you could use <code>format(value, '...')</code>? That avoids having to parse out the format specifier from a template string that is otherwise empty.</span>
<span class="comment-copy">It doesn't work with 29000.32</span>
<span class="comment-copy">@MartijnPieters: The miniscule cost of parsing out the format specifier is swamped by other overhead AFAICT; in practice, my local benchmarks on 3.6 (with function scoping of the microbenchmark to accurately model real code) have <code>format(v, '2.5f')</code> take ~10% longer than <code>'{:2.5f}'.format(v)</code>. Even if it didn't, I tend to use the <code>str</code> method form because when I need to tweak it, add additional values to it, etc., there is less to change. Of course, as of 3.6 we have f-strings for most purposes. :-)</span>
<span class="comment-copy">Except <code>Decimal('10.0').normalize()</code> becomes <code>'1E+1'</code></span>
<span class="comment-copy">Unfortunately only works with numbers with fewer than roughly) five or more digits to the left of the decimal place. <code>floatToString(12345.6)</code> returns <code>'12345.600000000000364'</code> for example. Decreasing the 15 in <code>%.15f</code> to a lower number solves it in this example, but that value needs to be decreased more and more as the number gets larger. It could be dynamically calculated based on the log-base-10 of the number, but that quickly becomes very complicated.</span>
<span class="comment-copy">One way to solve that problem might be to limit the length of the whole number (rather than just the digits after the decimal): <code>result = ('%15f' % val).rstrip('0').rstrip('.').lstrip(' ')</code></span>
<span class="comment-copy">@JohnSpeeks I'm not sure this is avoidable. It is a side effect of floating numbers not being able to represent the accuracy if more digits are required on the left side. From what I can tell, the number that comes out as a string is the same number that goes in as a float, or at least the closest representation of it. <code>&gt;&gt;&gt;12345.600000000000364 == 12345.6</code> <code>True</code></span>
<span class="comment-copy">Only thing wrong with this one is that you have to set a sensible number of decimal digits. The higher you set it, the more precise numbers you can represent, but if you do this a lot, it can degrade performance.</span>
<span class="comment-copy">Don't you mean <code>int(a) if a % 1 else a</code>?</span>
<span class="comment-copy">Dear Beruic, your answer  results negative answer. <code>a if a % 1 else int(a)</code> is correct. Question needs output in string , So I just added <code>str</code></span>
<span class="comment-copy">Ah, I get it now. <code>a % 1</code> is truthy because it is non-zero. I implicitly and wrongly perceived it as <code>a % 1 == 0</code>.</span>
<span class="comment-copy">But <code>print("%s"%3.0)</code> does.</span>
<span class="comment-copy"><code>.99</code> is precision, not width; kinda useful but you don't get to set the actual precision this way (other than truncating it yourself).</span>
<span class="comment-copy">This is also very wrong, just try printing 0.51 with that.</span>
<span class="comment-copy">you have to consider the case where <code>x</code> is negative.  <code>if x &lt; 0: print(min(x), x)</code> <code>else : print(max(x), x)</code></span>
<span class="comment-copy"><code>"{:0.0f}".format(3.1)</code> is <code>"3"</code> not <code>"3.1"</code></span>
