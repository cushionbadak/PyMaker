<div class="post-text" itemprop="text">
<p>Python seems to have functions for copying files (e.g. <code>shutil.copy</code>) and functions for copying directories (e.g. <code>shutil.copytree</code>) but I haven't found any function that handles both. Sure, it's trivial to check whether you want to copy a file or a directory, but it seems like a strange omission.</p>
<p>Is there really no standard function that works like the unix <code>cp -r</code> command, i.e. supports both directories and files and copies recursively? What would be the most elegant way to work around this problem in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you first call <a href="https://docs.python.org/3/library/shutil.html#shutil.copytree" rel="noreferrer"><code>shutil.copytree</code></a>, and if an exception is thrown, then retry with <a href="https://docs.python.org/3/library/shutil.html#shutil.copy" rel="noreferrer"><code>shutil.copy</code></a>.</p>
<pre><code>import shutil, errno

def copyanything(src, dst):
    try:
        shutil.copytree(src, dst)
    except OSError as exc: # python &gt;2.5
        if exc.errno == errno.ENOTDIR:
            shutil.copy(src, dst)
        else: raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add on <a href="https://stackoverflow.com/a/1994840/5509598">Tzot's</a> and <a href="https://stackoverflow.com/a/42249637/5509598">gns</a> answers, here's an alternative way of copying files and folders recursively. (Python 3.X)</p>
<pre><code>import os, shutil

root_src_dir = r'C:\MyMusic'    #Path/Location of the source directory
root_dst_dir = 'D:MusicBackUp'  #Path to the destination folder

for src_dir, dirs, files in os.walk(root_src_dir):
    dst_dir = src_dir.replace(root_src_dir, root_dst_dir, 1)
    if not os.path.exists(dst_dir):
        os.makedirs(dst_dir)
    for file_ in files:
        src_file = os.path.join(src_dir, file_)
        dst_file = os.path.join(dst_dir, file_)
        if os.path.exists(dst_file):
            os.remove(dst_file)
        shutil.copy(src_file, dst_dir)
</code></pre>
<p>Should it be your first time and you have no idea how to copy files and folders recursively, I hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unix <code>cp</code> doesn't 'support both directories and files':</p>
<pre><code>betelgeuse:tmp james$ cp source/ dest/
cp: source/ is a directory (not copied).
</code></pre>
<p>To make cp copy a directory, you have to manually tell cp that it's a directory, by using the '-r' flag.</p>
<p>There is some disconnect here though - <code>cp -r</code> when passed a filename as the source will happily copy just the single file; copytree won't.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>shutil.copy</code> and <code>shutil.copy2</code> are copying files.</p>
<p><code>shutil.copytree</code> copies a folder with all the files and all subfolders. <code>shutil.copytree</code> is using <code>shutil.copy2</code> to copy the files.</p>
<p>So the analog to <code>cp -r</code> you are saying is the <code>shutil.copytree</code> because <code>cp -r</code> targets and copies a folder and its files/subfolders like <code>shutil.copytree</code>. Without the <code>-r</code> <code>cp</code> copies files like <code>shutil.copy</code> and <code>shutil.copy2</code> do.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think copy_tree is what you are looking for</p>
</div>
<div class="post-text" itemprop="text">
<p>The python shutil.copytree method its a mess. I've done one that works correctly:</p>
<pre><code>def copydirectorykut(src, dst):
    os.chdir(dst)
    list=os.listdir(src)
    nom= src+'.txt'
    fitx= open(nom, 'w')

    for item in list:
        fitx.write("%s\n" % item)
    fitx.close()

    f = open(nom,'r')
    for line in f.readlines():
        if "." in line:
            shutil.copy(src+'/'+line[:-1],dst+'/'+line[:-1])
        else:
            if not os.path.exists(dst+'/'+line[:-1]):
                os.makedirs(dst+'/'+line[:-1])
                copydirectorykut(src+'/'+line[:-1],dst+'/'+line[:-1])
            copydirectorykut(src+'/'+line[:-1],dst+'/'+line[:-1])
    f.close()
    os.remove(nom)
    os.chdir('..')
</code></pre>
</div>
<span class="comment-copy">Yes, this is a mess. One of the places where, by trying to reflect the underlying system calls, Python makes the visible interface worse. Although it's not difficult to switch between copy-file and copy-tree, it shouldn't have been necessary. Maybe file an enhancement request on the Python bug tracker to allow <code>copytree</code> to copy a single file?</span>
<span class="comment-copy">I think it would be much cleaner to simply check if src is a directory using os.path.isdir(src) instead of catching an exception like this. Or is there some special reason one should use an exception here instead?</span>
<span class="comment-copy">1) Because in the Python world EAFP (it's easier to ask forgiveness than permission) is preferred to LBYL (look before you leap). I can provide you with links about that, if it sounds new to you. 2) The library function already indirectly checks for that, so why replicate the check? 3) nothing stops the <code>shutil.copytree</code> function from improving and managing both cases in the future. 4) Exceptions aren't that exceptional in Python; e.g. an iteration stops by throwing a StopIteration exception.</span>
<span class="comment-copy">Well, in this case handling the exception takes 6 lines, while checking the type takes 4 lines. Not much, but it adds up in the end.  Also, as you say, copytree might someday very well support files as well. But it's impossible to tell what that implementation will be like. Maybe it throws an exception under some circumstance where copy works? In that case my code would suddenly stop working just because of the added functionality.  But you are probably right, exceptions are pretty commong in Python, something which I find very annoying, but it's probably because I never seem to get used to it</span>
<span class="comment-copy">Actually exceptions do have one clear objective advantage in this case: it is entirely possible (although highly unlikely) that the type changes between the check and the call to the correct function.</span>
<span class="comment-copy">in my personal opinion, adding core functionality in an except is bad practice, doesn't matter which language you are using. it puts functionality into a place, where a lot of developers won't search for. further, if you do not write a comment, a less experienced python developer would not really understand what the purpose of this retry is. and if you need to add a comment for such a trivial thing like here, something on your code style is wrong. finally, writing an if / else will result in a much easier to read code.</span>
<span class="comment-copy"><a href="http://docs.python.org/library/shutil.html" rel="nofollow noreferrer">docs.python.org/library/shutil.html</a> includes the code for copytree() which demonstrates handling ordinary files, symlinks, and directories.</span>
<span class="comment-copy">This answer doesn't address the question. It should be a comment, not an answer.</span>
<span class="comment-copy">I don't think you understood the question. Try <code>shutil.copytree('C:\myfile.txt', 'C:\otherfile')</code>. It doesn't work. That's what the OP was asking about... 7 years ago.</span>
<span class="comment-copy">Of course it doesn't work. Like cp doesn't work with folders. You need a special option. copy and copytree are the best way to handle copying. If copytree could target and files it would be easy to make mistakes. You must know what you are targeting both with Linux and Python. That hard. Plus someone else commented it here, but seeing the question and the replies couldn't resist to answer. The elegant way is to know what you want to do and not a universal copy without any control.</span>
<span class="comment-copy">This code is nice for work individual file check (check overwriting issue), but will not work for binary files such as 'zip'. Why not using simple python file copy instead of line by line read/write?</span>
