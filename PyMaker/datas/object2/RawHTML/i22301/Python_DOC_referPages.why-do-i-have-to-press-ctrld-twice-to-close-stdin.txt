<div class="post-text" itemprop="text">
<p>I have the following Python script that reads numbers and outputs an error if the input is not a number.</p>
<pre><code>import fileinput
import sys
for line in (txt.strip() for txt in fileinput.input()):
    if not line.isdigit():
        sys.stderr.write("ERROR: not a number: %s\n" % line)
</code></pre>
<p>If I get the input from stdin, I have to press <kbd>Ctrl</kbd> + <kbd>D</kbd> <strong>twice</strong> to end the program. Why?</p>
<p>I only have to press <kbd>Ctrl</kbd> + <kbd>D</kbd> once when I run the Python interpreter by itself.</p>
<pre><code>bash $ python test.py
1
2
foo
4
5
&lt;Ctrl+D&gt;
ERROR: not a number: foo
&lt;Ctrl+D&gt;
bash $
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, this was due to <a href="http://bugs.python.org/issue5505" rel="nofollow noreferrer">a bug in Python's standard I/O library</a>. The bug was fixed in Python 3.3.</p>
<hr/>
<p>In a Unix terminal, typing Ctrl+D doesn't actually close the process's stdin. But typing either Enter or Ctrl+D does cause the OS <code>read</code> system call to return right away. So:</p>
<pre><code>&gt;&gt;&gt; sys.stdin.read(100)
xyzzy                       (I press Enter here)
                            (I press Ctrl+D once)
'xyzzy\n'
&gt;&gt;&gt;
</code></pre>
<p><code>sys.stdin.read(100)</code> is delegated to <code>sys.stdin.buffer.read</code>, which calls the system read() in a loop until either it accumulates the full requested amount of data; or the system read() returns 0 bytes; or an error occurs. <a href="https://docs.python.org/3/library/io.html#io.BufferedIOBase.read" rel="nofollow noreferrer" title='"...multiple raw reads may be issued to satisfy the byte count (unless EOF is reached first)."'>(docs)</a> <a href="https://hg.python.org/cpython/file/645f3d750be1/Modules/_io/bufferedio.c#l1629" rel="nofollow noreferrer" title="As of Python 3.4.2, the loop is in the function _bufferedreader_read_generic, in Modules/_io/bufferedio.c.">(source)</a></p>
<p>Pressing Enter after the first line caused the system read() to return 6 bytes.  <code>sys.stdin.buffer.read</code> called read() again to try to get more input. Then I pressed Ctrl+D, causing read() to return 0 bytes. At this point, <code>sys.stdin.buffer.read</code> gave up and returned just the 6 bytes it had collected earlier.</p>
<p>Note that the process still has my terminal on stdin, and I can still type stuff.</p>
<pre><code>&gt;&gt;&gt; sys.stdin.read()        (note I can still type stuff to python)
xyzzy                       (I press Enter)
                            (Press Ctrl+D again)
'xyzzy\n'
</code></pre>
<p>OK. This is the part that was busted when this question was originally asked. It works now. But prior to Python 3.3, there was a bug.</p>
<p>The bug was a little complicated --- basically the problem was that two separate layers were doing the same work. <code>BufferedReader.read()</code> was written to call <code>self.raw.read()</code> repeatedly until it returned 0 bytes. However, the raw method, <code>FileIO.read()</code>, performed a loop-until-zero-bytes of its own. So the first time you press Ctrl+D in a Python with this bug, it would cause <code>FileIO.read()</code> to return 6 bytes to <code>BufferedReader.read()</code>, which would then immediately call <code>self.raw.read()</code> again. The second Ctrl+D would cause <em>that</em> to return 0 bytes, and then <code>BufferedReader.read()</code> would finally exit.</p>
<p>This explanation is unfortunately much longer than my previous one, but it has the virtue of being correct. Bugs are like that...</p>
</div>
<div class="post-text" itemprop="text">
<p>Most likely this has to do with Python the following Python issues:</p>
<ul>
<li><a href="http://bugs.python.org/issue5505" rel="noreferrer">5505</a>: <code>sys.stdin.read()</code> doesn't return after first EOF on Windows, and</li>
<li><a href="http://bugs.python.org/issue1633941" rel="noreferrer">1633941</a>: <code>for line in sys.stdin:</code> doesn't notice EOF the first time.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I wrote an explanation about this in my answer to this question.</p>
<p><a href="https://stackoverflow.com/questions/1516122/how-to-capture-controld-signal">How to capture Control+D signal?</a></p>
<p>In short, Control-D at the terminal simply causes the terminal to flush the input. This makes the <code>read</code> system call return. The first time it returns with a non-zero value (if you typed something). The second time, it returns with 0, which is code for "end of file".</p>
</div>
<div class="post-text" itemprop="text">
<p>The first time it considers it to be input, the second time it's for keeps! </p>
<p>This only occurs when the input is from a tty. It is likely because of the terminal settings where characters are buffered until a newline (carriage return) is entered.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the "for line in file:" form of reading lines from a file, Python uses a hidden read-ahead buffer (see <a href="http://docs.python.org/2.7/library/stdtypes.html#file-objects" rel="nofollow">http://docs.python.org/2.7/library/stdtypes.html#file-objects</a> at the file.next function).  First of all, this explains why a program that writes output when each input line is read displays no output until you press CTRL-D.  Secondly, in order to give the user some control over the buffering, pressing CTRL-D flushes the input buffer to the application code.  Pressing CTRL-D when the input buffer is empty is treated as EOF.</p>
<p>Tying this together answers the original question.  After entering some input, the first ctrl-D (on a line by itself) flushes the input to the application code.  Now that the buffer is empty, the second ctrl-D acts as End-of-File (EOF).</p>
<p><code>file.readline()</code> does not exhibit this behavior.</p>
</div>
<span class="comment-copy">I don't get that effect in OSX.  However, if I hit &lt;Ctrl-D&gt; directly after hitting 5, (without an intervening carriage-return) I do, and even <code>cat</code> does that.</span>
<span class="comment-copy">@Kristo: Your example should be formatted to show <code>&lt;ctrl+d&gt;</code> on the same line as <code>5</code>.  If you're seeing the behavior that your example shows as of now, something is wrong.</span>
<span class="comment-copy">@Alok: My example is formatted exactly as I typed it.  If I change the code to use <code>sys.stdin.readlines()</code>, then the first &lt;ctrl+d&gt; ends the program.</span>
<span class="comment-copy">@Kristo Strange indeed. Note when the "not a number" is displayed... is that what you expect, too? Did you try several terminal emulators? What platform are you using? If Linux, could you try the console for instance (you probably can get one by typing Ctrl-Alt-F2)?</span>
<span class="comment-copy">@Pascal Cuoq: Yes I'm on linux.  I get the same results in xterm, GNOME Terminal, Konsole, and the console.  I actually expected to see the error message print immediately after entering 'foo' but it doesn't appear until after the first Ctrl+D, regardless of which way I write the code.</span>
<span class="comment-copy">it is probably a bug: it should be <a href="http://stackoverflow.com/a/21261742/4279">enough to press <code>Ctrl+D</code> once <i>at the begining of a line</i></a>. Though I can't reproduce it (a single <code>Ctrl+D</code> is enough to end <code>sys.stdin.read()</code> if Enter is pressed on both Python 2 and 3 -- you need to press <code>Ctrl+D</code> twice only in the middle of a line (ICANON flag is set)).</span>
<span class="comment-copy">@J.F.Sebastian The weirdness in this case was on the Python side, not in the OS's terminal implementation. Ctrl+D was sending EOF both times it was pressed, just as you say. But the implementation of <code>sys.stdin.read()</code> was a simple loop that kept calling <code>read</code> until it returned zero bytes.</span>
<span class="comment-copy">If it is not clear: I've tested it on both Python 2 and 3: <i>single</i> Ctrl+D is enough (Ubuntu 14.04). <code>read</code> returns zero bytes at the beginning of a line.</span>
<span class="comment-copy">Right. The behavior changed in Python 3.3 according to <a href="http://bugs.python.org/issue5505" rel="nofollow noreferrer">bugs.python.org/issue5505</a>, and it <i>was</i> considered a bug in Python.</span>
<span class="comment-copy">@J.F.Sebastian I'm honestly not totally clear how the commit cited in that issue fixed the problem though.</span>
<span class="comment-copy">That's what I don't understand.  The first &lt;Ctrl+D&gt; in my example is on the first character of a new line, so I would expect it to act as EOF.  If I change the code to use <code>sys.stdin.readlines()</code> instead, then the first &lt;ctrl+d&gt; ends the program.</span>
