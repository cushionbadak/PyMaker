<div class="post-text" itemprop="text">
<p>In python 2.6 under Linux, I can use the following to handle a TERM signal:</p>
<pre><code>import signal
def handleSigTERM():
    shutdown()
signal.signal(signal.SIGTERM, handleSigTERM)    
</code></pre>
<p>Is there any way to setup a handler for all signals received by the process, other than just setting them up one-at-a-time?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just loop through the signals in the signal module and set them up.</p>
<pre><code>for i in [x for x in dir(signal) if x.startswith("SIG")]:
  try:
    signum = getattr(signal,i)
    signal.signal(signum,sighandler)
  except (OSError, RuntimeError) as m: #OSError for Python3, RuntimeError for 2
    print ("Skipping {}".format(i))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.5, the signal constants are <a href="https://docs.python.org/3/library/signal.html#module-contents" rel="noreferrer">defined as an enum</a>, enabling a nicer approach:</p>
<pre><code>import signal

catchable_sigs = set(signal.Signals) - {signal.SIGKILL, signal.SIGSTOP}
for sig in catchable_sigs:
    signal.signal(sig, print)  # Substitute handler of choice for `print`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to get rid of the try, just ignore signals that cannot be caught.</p>
<pre><code>#!/usr/bin/env python
# https://stackoverflow.com/questions/2148888/python-trap-all-signals
import os
import sys
import time
import signal

SIGNALS_TO_NAMES_DICT = dict((getattr(signal, n), n) \
    for n in dir(signal) if n.startswith('SIG') and '_' not in n )


def receive_signal(signum, stack):
    if signum in [1,2,3,15]:
        print 'Caught signal %s (%s), exiting.' % (SIGNALS_TO_NAMES_DICT[signum], str(signum))
        sys.exit()
    else:
        print 'Caught signal %s (%s), ignoring.' % (SIGNALS_TO_NAMES_DICT[signum], str(signum))

def main():
    uncatchable = ['SIG_DFL','SIGSTOP','SIGKILL']
    for i in [x for x in dir(signal) if x.startswith("SIG")]:
        if not i in uncatchable:
            signum = getattr(signal,i)
            signal.signal(signum,receive_signal)
    print('My PID: %s' % os.getpid())
    while True:
        time.sleep(1)
main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a 2/3 compatible way which doesn't have as many pitfalls as the others:</p>
<pre><code>from itertools import count
import signal

def set_all_signal_signals(handler):
    """Set all signals to a particular handler."""
    for signalnum in count(1):
        try:
            signal.signal(signalnum, handler)
            print("set {}".format(signalnum))
        except (OSError, RuntimeError):
            # Invalid argument such as signals that can't be blocked
            pass
        except ValueError:
            # Signal out of range
            break
</code></pre>
<p>Since <code>signalnum</code> is just a number, iterate over 1 to out of range setting the signal to a particular handle.</p>
</div>
<div class="post-text" itemprop="text">
<p>Works on Windows 10 and Python 3.7:</p>
<pre><code>import signal
import time

def sighandler(signal,frame):
    print("signal",sig,frame)
    return

catchable_sigs = set(signal.Signals)
for sig in catchable_sigs:
    try:
        signal.signal(sig, sighandler)
        print("Setting ",sig)
        print ("value {}".format(sig))
    except (ValueError, OSError, RuntimeError) as m:
        print("Skipping ",sig)
        print ("Value {}".format(sig))


# press some keys or issue kill
x = 0
while x &lt; 5:
    time.sleep(4)
    x += 1
</code></pre>
<p>Results:</p>
<pre><code>Skipping  Signals.CTRL_C_EVENT
Value 0
Skipping  Signals.CTRL_BREAK_EVENT
Value 1
Setting  Signals.SIGINT
value 2
Setting  Signals.SIGILL
value 4
Setting  Signals.SIGFPE
value 8
Setting  Signals.SIGSEGV
value 11
Setting  Signals.SIGTERM
value 15
Setting  Signals.SIGBREAK
value 21
Setting  Signals.SIGABRT
value 22
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That code won't work in the current version of python. There are many variables starting with SIG with the same value. For instance, SIGHUP and SIG_UNBLOCK are both 1. The only way I could think of to get a list of <em>actual signals</em> was to just make it myself.</p>
<pre><code>from signal import *    
signals = {
        SIGABRT: 'SIGABRT',
        SIGALRM: 'SIGALRM',
        SIGBUS: 'SIGBUS',
        SIGCHLD: 'SIGCHLD',
        SIGCONT: 'SIGCONT',
        SIGFPE: 'SIGFPE',
        SIGHUP: 'SIGHUP',
        SIGILL: 'SIGILL',
        SIGINT: 'SIGINT',
        SIGPIPE: 'SIGPIPE',
        SIGPOLL: 'SIGPOLL',
        SIGPROF: 'SIGPROF',
        SIGQUIT: 'SIGQUIT',
        SIGSEGV: 'SIGSEGV',
        SIGSYS: 'SIGSYS',
        SIGTERM: 'SIGTERM',
        SIGTRAP: 'SIGTRAP',
        SIGTSTP: 'SIGTSTP',
        SIGTTIN: 'SIGTTIN',
        SIGTTOU: 'SIGTTOU',
        SIGURG: 'SIGURG',
        SIGUSR1: 'SIGUSR1',
        SIGUSR2: 'SIGUSR2',
        SIGVTALRM: 'SIGVTALRM',
        SIGXCPU: 'SIGXCPU',
        SIGXFSZ: 'SIGXFSZ',
        }

for num in signals:
    signal(num, h)
</code></pre>
</div>
<span class="comment-copy">The answer I believe is going to be "no" and certain signal can't even be trapped (SIGKILL).</span>
<span class="comment-copy">Just what I was looking for, thanks!</span>
<span class="comment-copy">You're welcome. Thanks for fixing the error in the program. :)</span>
<span class="comment-copy">That should be RuntimeError, not RunTimeError. couldn't edit, as just one character change.</span>
<span class="comment-copy">Your list comprehension will include <code>SIG_IGN</code>, which is an action not a signal. Since this actions 'value' corresponds to <code>1</code>, which is the value for <code>SIGHUP</code>, you will be setting this signal twice. For this specific case that doesn't matter, however this code may break down for other similar purposes.</span>
<span class="comment-copy">This answer does not apply to Python 3 since trying to set unblockable signals such as <code>SIGKILL</code> for example throw an <code>OSError</code> now instead of a <code>RuntimeError</code>.</span>
<span class="comment-copy">Could the downvoter please leave a comment? Is there something wrong with this answer?</span>
<span class="comment-copy">This is actually quite useful. Thanks! Can you please confirm whether this works on windows?</span>
<span class="comment-copy">I don't know how signals work on Windows, but it looks like the core functionality is available: <a href="https://docs.python.org/3/library/signal.html#signal.signal" rel="nofollow noreferrer">docs.python.org/3/library/signal.html#signal.signal</a>  Note that even though the signal function only accepts certain values, it looks like the Signals enum is constructed with the appropriate signals for the platform: <a href="https://github.com/python/cpython/blob/master/Lib/signal.py#L8-L13" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Lib/signal.py#L8-L13</a>  So I would guess this approach would work, possibly with some minor tweaks. But again, I'm not sure how signals work or even what they mean on Windows, so it might not work at all.</span>
<span class="comment-copy">The code is not properly indented but I cannot edit it because SO don't let me make a change that small. All the for should be indented with one level of indentation less.</span>
<span class="comment-copy">It's not necessary. All the signals still start with <code>SIG</code> but you need to add a double check to make sure that you ignore the <code>SIG_</code> ones.</span>
