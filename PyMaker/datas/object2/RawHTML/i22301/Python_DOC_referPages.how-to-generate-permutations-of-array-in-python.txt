<div class="post-text" itemprop="text">
<p>i have an array of 27 elements,and i don't want to generate all permutations of array (27!)
i need 5000 randomly choosed permutations,any tip will be useful...</p>
</div>
<div class="post-text" itemprop="text">
<p>To generate one permutation use <a href="http://docs.python.org/library/random.html#random.shuffle" rel="noreferrer"><code>random.shuffle</code></a> and store a copy of the result. Repeat this operation in a loop and each time check for duplicates (there probably won't be any though). Once you have 5000 items in your result set, stop.</p>
<p>To address the point in the comment, Python's <a href="http://docs.python.org/library/random.html" rel="noreferrer">random module</a> is based on the <a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="noreferrer">Mersenne Twister</a> and has a period of <code>2**19937-1</code>, which is considerably larger than <code>27!</code> so it should be suitable for your use.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random

perm_list = []

for i in range(5000):
    temp = range(27)
    random.shuffle(temp)
    perm_list.append(temp)

print(perm_list)
</code></pre>
<p><code>10888869450418352160768000000</code>  I love big numbers! :)</p>
<p>AND</p>
<p><strong><code>10888869450418352160768000001</code> is PRIME!!</strong></p>
<p><strong>EDIT:</strong></p>
<pre><code>#with duplicates check as suggested in the comment

perm_list = set()
while len(perm_list)&lt;5000:
    temp = range(27)
    random.shuffle(temp)
    perm_list.add(tuple(temp)) # `tuple` because `list`s are not hashable. right Beni?

print perm_list
</code></pre>
<p>WARNING: This wont ever stop if RNG is bad!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/itertools.html#itertools.permutations" rel="noreferrer"><code>itertools.permutations</code></a>. It's a generator, so it won't create the whole list of permutations. You could skip randomly until you've got 5000.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># apermindex should be a number between 0 and factorial(len(alist))
def perm_given_index(alist, apermindex):
    for i in range(len(alist)-1):
        apermindex, j = divmod(apermindex, len(alist)-i)
        alist[i], alist[i+j] = alist[i+j], alist[i]
    return alist
</code></pre>
<p>Usage: <code>perm_given_index(['a','b','c'], 3)</code></p>
<p>This uses the Lehmer code for the permutation as the values of <code>j</code> match that.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may want the itertools.permutations() function. Gotta love that itertools module!</p>
<p>NOTE: New in 2.6</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try implementing the <code>random_permutation</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>.  For convenience I use a third-party library, <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a>, that implements this recipe for us:</p>
<pre><code>import more_itertools as mit

iterable = range(27)
mit.random_permutation(iterable)
# (24, 3, 18, 21, 17, 22, 14, 15, 20, 8, 4, 7, 13, 6, 25, 5, 12, 1, 9, 19, 23, 11, 16, 0, 26, 2, 10)
</code></pre>
<p>A random permutation is created for every call of the function.  We can make a generator that yields these results for <code>n</code> calls.  We will implement this generator and demonstrate random results with an abridged example:</p>
<pre><code>def random_permute_generator(iterable, n=10):
    """Yield a random permuation of an iterable n times."""
    for _ in range(n):
        yield mit.random_permutation(iterable)

list(random_permute_generator(range(10), n=20))
# [(2, 7, 9, 6, 5, 0, 1, 3, 4, 8),
#  (7, 3, 8, 1, 2, 6, 4, 5, 9, 0),
#  (2, 3, 1, 8, 7, 4, 9, 0, 6, 5),
#  (0, 5, 6, 8, 2, 3, 1, 9, 4, 7),
#  (0, 8, 1, 9, 4, 5, 7, 2, 3, 6),
#  (7, 2, 5, 8, 3, 4, 1, 0, 9, 6),
#  (9, 1, 4, 5, 8, 0, 6, 2, 7, 3),
#  (3, 6, 0, 2, 9, 7, 1, 4, 5, 8),
#  (8, 4, 0, 2, 7, 5, 6, 1, 9, 3),
#  (4, 9, 0, 5, 7, 1, 8, 3, 6, 2)
#  ...]
</code></pre>
<p>For your specific problem, substitute the iterable and number of calls <code>n</code> with the appropriate values, e.g. <code>random_permute_generator(iterable, n=5000)</code>.</p>
<p>See also <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.random_permutation" rel="nofollow noreferrer"><code>more_itertools</code> docs</a> for further information on this tool.</p>
<hr/>
<p><strong>Details</strong></p>
<p>For those interested, here is the actual recipe.</p>
<p>From the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>:</p>
<pre><code>def random_permutation(iterable, r=None):
    "Random selection from itertools.permutations(iterable, r)"
    pool = tuple(iterable)
    r = len(pool) if r is None else r
    return tuple(random.sample(pool, r))
</code></pre>
</div>
<span class="comment-copy">It might be worth mentioning that <code>27!</code> is 10888869450418352160768000000.</span>
<span class="comment-copy">+1, but note that <code>random.shuffle</code> has a serious weakness: the period of most RNGs is smaller than the total number of permutations as <i>n</i> gets larger. That means that almost all of the possible permutations for a large enough <i>n</i> cannot ever be generated, so this isn't truly random.</span>
<span class="comment-copy">Indeed, John. Python's random generator has a period of 2**19937-1 though so it is probably good enough. Another nitpick is that for true random numbers you would need a true random source (e.g. from radioactive decay), Python's random module provides only pseudo-random numbers. But in common usage when people say 'random' what they really mean is 'pseudo-random', and I assume this is what the poster here means.</span>
<span class="comment-copy">+1 Cool! It's a big die with 10888869450418352160768000000 faces probability of any one of them turning up is 1/10888869450418352160768000000. Duplicates NO WAY!!</span>
<span class="comment-copy">thanks guys,it helped me a lot!!!</span>
<span class="comment-copy">@PratikDeoghare It's a big die with a 6002-digit number of faces, but it rotates in a specific, known pattern and loads of the faces have the same number on. Duplicates yes way.</span>
<span class="comment-copy">To also check for duplicates as Mark suggests, use a <code>perms = set()</code>, <code>perms.add(tuple(temp))</code>, and <code>while len(perms) &lt; 5000</code> instead of the for loop.</span>
<span class="comment-copy">@Beni I didn't follow your <code>tuple(temp)</code> suggestion at first but then I understood that I was a fool!! Thanks man!</span>
<span class="comment-copy">Might take a long time to do using this method....</span>
<span class="comment-copy">That's not really "random", since <code>itertools</code> creates them in a defined order, and there are a finite number of permutations. What would be better is to do the following: (1) determine <b>how many</b> permutations there are (call this number <code>N</code>), (2) then generate 5,000 distinct random indices in the range <code>0..N-1</code>, (3) pick the permutations from the itertools.permutations generator which correspond to these indices.</span>
<span class="comment-copy">Yeah, I know it's not the best. First time I read the question I somehow didn't notice that 'randomly chosen' part. I won't delete it, maybe someone searching for "how to generate permutations of array in python?" will find it useful.</span>
<span class="comment-copy">@Cat Plus Plus That would be me :D</span>
<span class="comment-copy">This may be very nice i.e. for compression if you need to store a lot of permutations to use integer representation instead. Got inspired to write <a href="https://gist.github.com/lukmdo/7049748" rel="nofollow noreferrer">gist.github.com/lukmdo/7049748</a></span>
<span class="comment-copy">Lehmer coding (and decoding) deserves to be ensconced somewhere within core python - at the very least, as a part of itertools. Anything where working with permutations is common needs a way to translate to and from the associated Lehmer index.</span>
<span class="comment-copy">This will be too slow - he said he has 27 elements.</span>
