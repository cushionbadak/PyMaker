<div class="post-text" itemprop="text">
<p>As part of answering another question, I wrote the following code whose behaviour seems bizarre at first glance:</p>
<pre><code>print True                    # outputs true
True = False;    print True   # outputs false
True = True;     print True   # outputs false
True = not True; print True   # outputs true
</code></pre>
<p>Can anyone explain this strange behaviour? I think it has something to do with Python's object model but I'm not sure.</p>
<p>It's version 2.5.2 under Cygwin.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has these two (among others) builtin objects. They are just objects; in the beginning, they don't have any names yet, but to know what we refer to, let's call them <code>0x600D</code> and <code>0xBAD</code>.</p>
<p>Before starting to execute a Python (2.x) script, the name <code>True</code> gets bound to the object <code>0x600D</code>, and the name <code>False</code> gets bound to the object <code>0xBAD</code>, so when the program refers to <code>True</code>, it looks at <code>0x600D</code>.</p>
<p>Because <code>0x600D</code> and <code>0xBAD</code> know that they are usually used by the names <code>True</code> and <code>False</code>, that's what they output when they get printed, i.e. the <code>__str__</code> method of <code>0x600D</code> returns <code>'True'</code> and so on.</p>
<pre><code>True = False
</code></pre>
<p>now binds the name <code>True</code> to a different object. From now on, both names <code>True</code> and <code>False</code> refer to the same object <code>0xBAD</code>, which, when printed, outputs <code>False</code>.</p>
<pre><code>True = True
</code></pre>
<p>doesn't really do anything: It takes the object referred to by the name <code>True</code>, and binds  the new (and old) name <code>True</code> to this object. Since (because of the previous step) <code>True</code> refers to <code>0xBAD</code> before this, it still refers to <code>0xBAD</code> after this. Hence, printing still outputs <code>False</code>.</p>
<pre><code>True = not True
</code></pre>
<p>first takes the object that the name <code>True</code> is bound to, which is <code>0xBAD</code>. It gives this object to the <code>not</code> operator. <code>not</code> doesn't care (or know) what name is used here to refer to <code>0xBAD</code>, it just knows that when given <code>0xBAD</code> it should return <code>0x600D</code>. This return value is then given to the assignment operator <code>=</code>, binding the name <code>True</code> to this object.</p>
<p>Since the name <code>True</code> now once more refers to the object <code>0x600D</code>, calling <code>print True</code> outputs <code>True</code>, and the world is good again.</p>
</div>
<div class="post-text" itemprop="text">
<p>Imagine this instead:</p>
<pre><code>A = True
B = False

print A           # true
A = B;  print A   # false
A = A;  print A   # false, because A is still false from before
A = not A; print A # true, because A was false, so not A is true
</code></pre>
<p>The exact same thing is going on, but in your version it's confusing, because you don't expect that you can redefine True and False.</p>
</div>
<div class="post-text" itemprop="text">
<p>In 2.x, True and False are not keywords so it's possible to shadow the built-ins in this manner.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check whether True/False is a keyword:</p>
<pre><code>&gt;&gt;&gt; import keyword
&gt;&gt;&gt; keyword.iskeyword('True')
False
</code></pre>
<p>Since it's not (in my version), assigning True=False just means "True" is another "variable" name.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could easily restore the original values using simple Boolean comparisons:</p>
<pre><code>True = 1==1
False = 1==0
</code></pre>
<p>Or by converting integer literals to bools:</p>
<pre><code>True = bool(1)  # actually every number except 0 works
False = bool(0)
</code></pre>
</div>
<span class="comment-copy">Isn't that good old joke <code>#define true false</code> in action here?</span>
<span class="comment-copy">In version 3 the assigment True = False raises a sintax error, so i suppose that your question refers to version 2</span>
<span class="comment-copy">what is strange about it? care to elaborate?</span>
<span class="comment-copy">@Paul, how much do you know about BCPL? Or RCA1802 assembly? Or object-oriented COBOL? Or F# or Haskell or Forth? A high rep on SO is little indication of how knowledgeable someone is in a particular area. My Python knowledge is nowhere near as comprehensive as other areas and it's irrelevant, since SO is meant for <i>all</i> skill levels. On top of that, I'm not entirely certain where the difference between '=' and '==' even comes into it. Perhaps you could elucidate?</span>
<span class="comment-copy">@SLott, the question was more or less along the lines of: why is it even possible to assign to a constant? But @Balpha and @Ignacio cleared that up for me in that True and False aren't keywords (at least in Python 2), rather just names pointing to underlying objects (and the pointers can be changed).</span>
<span class="comment-copy">Just a note that you should probably use <code>keyword.iskeyword('True')</code> as an example instead, since most actual keywords will give a SyntaxError if used there.</span>
<span class="comment-copy">@Ig, sure.thanks</span>
<span class="comment-copy">Note: this is fixed in python 3, True is a <a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords" rel="nofollow noreferrer">keyword</a>.</span>
<span class="comment-copy">Very interesting indeed, though slightly off topic :)</span>
