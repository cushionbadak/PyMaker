<div class="post-text" itemprop="text">
<p>I've recently changed my program's directory layout: before, I had all my modules inside the "main" folder. Now, I've moved them into a directory named after the program, and placed an <code>__init__.py</code> there to make a package.</p>
<p>Now I have a single .py file in my main directory that is used to launch my program, which is much neater.</p>
<p>Anyway, trying to load in pickled files from previous versions of my program is failing. I'm getting, "ImportError: No module named tools" - which I guess is because my module was previously in the main folder, and now it's in whyteboard.tools, not simply plain tools. However, the code that is importing in the tools module lives in the same directory as it, so I doubt there's a need to specify a package.  </p>
<p>So, my program directory looks something like this:</p>
<p><code>whyteboard-0.39.4</code></p>
<p><code>--&gt;whyteboard.py</code></p>
<p><code>--&gt;README.txt</code></p>
<p><code>--&gt;CHANGELOG.txt</code></p>
<p><code>----&gt;whyteboard/</code></p>
<p><code>----&gt;whyteboard/__init__.py</code></p>
<p><code>----&gt;whyteboard/gui.py</code></p>
<p><code>----&gt;whyteboard/tools.py</code></p>
<p>whyteboard.py launches a block of code from whyteboard/gui.py, that fires up the GUI. This pickling problem definitely wasn't happening before the directory re-organizing.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="http://docs.python.org/library/pickle.html?highlight=pickle#relationship-to-other-python-modules" rel="noreferrer">pickle's docs</a> say, in order to save and restore a class instance (actually a function, too), you must respect certain constraints:</p>
<blockquote>
<p>pickle can save and restore class
  instances transparently, however the
  class definition must be importable
  and live in the same module as when
  the object was stored</p>
</blockquote>
<p><code>whyteboard.tools</code> is <strong>not</strong> the "the same module as" <code>tools</code> (even though it can be imported by <code>import tools</code> by other modules in the same package, it ends up in <code>sys.modules</code> as <code>sys.modules['whyteboard.tools']</code>: this is absolutely crucial, otherwise the same module imported by one in the same package vs one in another package would end up with multiple and possibly conflicting entries!).</p>
<p>If your pickle files are in a good/advanced format (as opposed to the old ascii format that's the default only for compatibility reasons), migrating them once you perform such changes may in fact <strong>not</strong> be quite as trivial as "editing the file" (which is binary &amp;c...!), despite what another answer suggests.  I suggest that, instead, you make a little "pickle-migrating script": let it patch <code>sys.modules</code> like this...:</p>
<pre><code>import sys
from whyteboard import tools

sys.modules['tools'] = tools
</code></pre>
<p>and then <code>cPickle.load</code> each file, <code>del sys.modules['tools']</code>, and <code>cPickle.dump</code> each loaded object back to file: that temporary extra entry in <code>sys.modules</code> should let the pickles load successfully, then dumping them again should be using the right module-name for the instances' classes (removing that extra entry should make sure of that).</p>
</div>
<div class="post-text" itemprop="text">
<p>Happened to me, solved it by adding the new location of the module to sys.path before loading pickle:</p>
<pre><code>import sys
sys.path.append('path/to/whiteboard')
f = open("pickled_file", "rb")
pickle.load(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the normal behavior of pickle, unpickled objects need to have their <a href="http://docs.python.org/library/pickle.html#what-can-be-pickled-and-unpickled" rel="noreferrer">defining module importable</a>.</p>
<p>You should be able to change the modules path (i.e. from <code>tools</code> to <code>whyteboard.tools</code>) by editing the pickled files, as they are normally simple text files.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>pickle</code> serializes classes by reference, so if you change were the class lives, it will not unpickle because the class will not be found.  If you use <code>dill</code> instead of <code>pickle</code>, then you can serialize classes by reference or directly (by directly serializing the class instead of it's import path).  You simulate this pretty easily by just changing the class definition after a <code>dump</code> and before a <code>load</code>.</p>
<pre><code>Python 2.7.8 (default, Jul 13 2014, 02:29:54) 
[GCC 4.2.1 Compatible Apple Clang 4.1 ((tags/Apple/clang-421.11.66))] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import dill
&gt;&gt;&gt; 
&gt;&gt;&gt; class Foo(object):
...   def bar(self):
...     return 5
... 
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; 
&gt;&gt;&gt; _f = dill.dumps(f)
&gt;&gt;&gt; 
&gt;&gt;&gt; class Foo(object):
...   def bar(self, x):
...     return x
... 
&gt;&gt;&gt; g = Foo()
&gt;&gt;&gt; f_ = dill.loads(_f)
&gt;&gt;&gt; f_.bar()
5
&gt;&gt;&gt; g.bar(4)
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with a custom "unpickler" that uses <a href="https://docs.python.org/3/library/pickle.html#pickle.Unpickler.find_class" rel="nofollow noreferrer"><code>find_class()</code></a>:</p>
<pre class="lang-py prettyprint-override"><code>import io
import pickle


class RenameUnpickler(pickle.Unpickler):
    def find_class(self, module, name):
        renamed_module = module
        if module == "tools":
            renamed_module = "whyteboard.tools"

        return super(RenameUnpickler, self).find_class(renamed_module, name)


def renamed_load(file_obj):
    return RenameUnpickler(file_obj).load()


def renamed_loads(pickled_bytes):
    file_obj = io.BytesIO(pickled_bytes)
    return renamed_load(file_obj)
</code></pre>
<p>Then you'd need to use <code>renamed_load()</code> instead of <code>pickle.load()</code> and <code>renamed_loads()</code> instead of <code>pickle.loads()</code>.</p>
</div>
<span class="comment-copy">perhaps you can add your module to pythonpath (<code>sys.path.append(path_to_your_module)</code>) before pickle load?</span>
<span class="comment-copy">I've tried that but <a href="http://stackoverflow.com/questions/39944487/pickle-load-importerror-no-module-named-doc2vec-ext">why is it not working</a> for me? :/</span>
<span class="comment-copy">Dumping after deleting the the sys.modules entry doesn't work. It gives the error of <code>Can't pickle</code> because the module is missing. Is there something I'm missing?</span>
<span class="comment-copy">what is the value of <code>f</code> ?</span>
<span class="comment-copy">Maybe old, but thanks for this. I had a real headscratcher when I had a similar issue.</span>
<span class="comment-copy">Thank you for posting this solution. Works with Python 3.7.x. This saved a lot of work. While the solution posted by Ranch works well enough to read classes of "misplaced" modules, this solution allows for programmatic control AND conversion of such,</span>
