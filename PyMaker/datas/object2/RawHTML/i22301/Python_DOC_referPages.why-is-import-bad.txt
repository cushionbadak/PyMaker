<div class="post-text" itemprop="text">
<p>It is recommended to not to use <code>import *</code> in Python. </p>
<p>Can anyone please share the reason for that, so that I can avoid it doing next time?</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><p>Because it puts a lot of stuff into your namespace (might shadow some other object from previous import and you won't know about it). </p></li>
<li><p>Because you don't know exactly what is imported and can't easily find from which module a certain thing was imported (readability). </p></li>
<li><p>Because you can't use cool tools like <code>pyflakes</code> to statically detect errors in your code.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="http://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Zen of Python</a>:</p>
<blockquote>
<p>Explicit is better than implicit.</p>
</blockquote>
<p>... can't argue with that, surely?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't pass <code>**locals()</code> to functions, do you?</p>
<p>Since Python lacks an "include" statement, <em>and</em> the <code>self</code> parameter is explicit, <em>and</em> scoping rules are quite simple, it's usually very easy to point a finger at a variable and tell where that object comes from -- without reading other modules and without any kind of IDE (which are limited in the way of introspection anyway, by the fact the language is very dynamic).</p>
<p>The <code>import *</code> breaks all that.</p>
<p>Also, it has a concrete possibility of hiding bugs.</p>
<pre><code>import os, sys, foo, sqlalchemy, mystuff
from bar import *
</code></pre>
<p>Now, if the bar module has any of the "<code>os</code>", "<code>mystuff</code>", etc... attributes, they will override the explicitly imported ones, and possibly point to very different things. Defining <code>__all__</code> in bar is often wise -- this states what will implicitly be imported - but still it's hard to trace where objects come from, without reading and parsing the bar module and following <em>its</em> imports. A network of <code>import *</code> is the first thing I fix when I take ownership of a project.</p>
<p>Don't misunderstand me: if the <code>import *</code> were missing, I would cry to have it. But it has to be used carefully. A good use case is to provide a facade interface over another module.
Likewise, the use of conditional import statements, or imports inside function/class namespaces, requires a bit of discipline.</p>
<p>I think in medium-to-big projects, or small ones with several contributors, a minimum of hygiene is needed in terms of statical analysis -- running at least pyflakes or even better a properly configured pylint -- to catch several kind of bugs before they happen.</p>
<p>Of course since this is python -- feel free to break rules, and to explore -- but be wary of projects that could grow tenfold, if the source code is missing discipline it will be a problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>That is because you are polluting the namespace. You will import all the functions and classes in your own namespace, which may clash with the functions you define yourself.</p>
<p>Furthermore, I think using a qualified name is more clear for the maintenance task; you see on the code line itself where a function comes from, so you can check out the docs much more easily.</p>
<p>In module foo:</p>
<pre><code>def myFunc():
    print 1
</code></pre>
<p>In your code:</p>
<pre><code>from foo import *

def doThis():
    myFunc() # Which myFunc is called?

def myFunc():
    print 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is OK to do <code>from ... import *</code> in an interactive session.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/tutorial/modules.html" rel="noreferrer">http://docs.python.org/tutorial/modules.html</a></p>
<blockquote>
<p>Note that in general the practice of importing <code>*</code> from a module or package is frowned upon, since it often causes <strong>poorly readable code</strong>. </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Say you have the following code in a module called foo:</p>
<pre><code>import ElementTree as etree
</code></pre>
<p>and then in your own module you have:</p>
<pre><code>from lxml import etree
from foo import *
</code></pre>
<p>You now have a difficult-to-debug module that <em>looks like</em> it has lxml's etree in it, but really has ElementTree instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>These are all good answers. I'm going to add that when teaching new people to code in Python, dealing with <code>import *</code> is very difficult. Even if you or they didn't write the code, it's still a stumbling block.</p>
<p>I teach children (about 8 years old) to program in Python to manipulate Minecraft. I like to give them a helpful coding environment to work with (<a href="http://atom.io" rel="noreferrer">Atom Editor</a>) and teach REPL-driven development (via <a href="http://bpython-interpreter.org/" rel="noreferrer">bpython</a>). In Atom I find that the hints/completion works just as effectively as bpython. Luckily, unlike some other statistical analysis tools, Atom is not fooled by <code>import *</code>.</p>
<p>However, lets take this example... In <a href="https://github.com/arpruss/raspberryjammod/blob/74e8738f5d607d7417e0bb5feaeb9a22b098ca42/python3-scripts/mcpipy/mc.py" rel="noreferrer">this wrapper</a> they <code>from local_module import *</code> a bunch modules including <a href="https://github.com/arpruss/raspberryjammod/blob/74e8738f5d607d7417e0bb5feaeb9a22b098ca42/python3-scripts/mcpipy/mcpi/block.py#L112-L119" rel="noreferrer">this list of blocks</a>. Let's ignore the risk of namespace collisions. By doing <code>from mcpi.block import *</code> they make this entire list of obscure types of blocks something that you have to go look at to know what is available. If they had instead used <code>from mcpi import block</code>, then you could type <code>walls = block.</code> and then an autocomplete list would pop up.
<a href="https://i.stack.imgur.com/kORzR.png" rel="noreferrer"><img alt="Atom.io screenshot" src="https://i.stack.imgur.com/kORzR.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Understood the valid points people put here. However, I do have one argument that, sometimes, "star import" may not always be a bad practice:</p>
<ul>
<li>When I want to structure my code in such a way that all the constants go to a module called <code>const.py</code>:

<ul>
<li>If I do <code>import const</code>, then for every constant, I have to refer it as <code>const.SOMETHING</code>, which is probably not the most convenient way.</li>
<li>If I do <code>from const import SOMETHING_A, SOMETHING_B ...</code>, then obviously it's way too verbose and defeats the purpose of the structuring.</li>
<li>Thus I feel in this case, doing a <code>from const import *</code> may be a better choice.</li>
</ul></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It is a <strong>very BAD</strong> practice for two reasons:</p>
<ol>
<li>Code Readability</li>
<li>Risk of overriding the variables/functions etc</li>
</ol>
<hr/>
<p>For <strong>point 1</strong>:
Let's see an example of this:</p>
<pre><code>from module1 import *
from module2 import *
from module3 import *

a = b + c - d
</code></pre>
<p>Here, on seeing the code no one will get idea regarding from which module <code>b</code>, <code>c</code> and <code>d</code> actually belongs. </p>
<p>On the other way, if you do it like:</p>
<pre><code>#                   v  v  will know that these are from module1
from module1 import b, c   # way 1
import module2             # way 2

a = b + c - module2.d
#            ^ will know it is from module2
</code></pre>
<p>It is much cleaner for you, and also the new person joining your team will have better idea.</p>
<p>For <strong>point 2</strong>: Let say both <code>module1</code> and <code>module2</code> have variable as <code>b</code>. When I do:</p>
<pre><code>from module1 import *
from module2 import *

print b  # will print the value from module2
</code></pre>
<p>Here the value from <code>module1</code> is lost. It will be hard to debug why the code is not working even if <code>b</code> is declared in <code>module1</code> and I have written the code expecting my code to use <code>module1.b</code></p>
<p>If you have same variables in different modules, and you do not want to import entire module, you may even do:</p>
<pre><code>from module1 import b as mod1b
from module2 import b as mod2b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a test, I created a module test.py with 2 functions A and B, which respectively print "A 1" and "B 1". After importing test.py with:</p>
<pre><code>import test
</code></pre>
<p>. . . I can run the 2 functions as test.A() and test.B(), and "test" shows up as a <strong>module</strong> in the namespace, so if I edit test.py I can reload it with:</p>
<pre><code>import importlib
importlib.reload(test)
</code></pre>
<p>But if I do the following:</p>
<pre><code>from test import *
</code></pre>
<p>there is no reference to "test" in the namespace, so there is no way to reload it after an edit (as far as I can tell), which is a problem in an interactive session. Whereas either of the following:</p>
<pre><code>import test
import test as tt
</code></pre>
<p>will add "test" or "tt" (respectively) as module names in the namespace, which will allow re-loading.</p>
<p>If I do:</p>
<pre><code>from test import *
</code></pre>
<p>the names "A" and "B" show up in the namespace as <strong>functions</strong>. If I edit test.py, and repeat the above command, the modified versions of the functions do not get reloaded.</p>
<p>And the following command elicits an error message.</p>
<pre><code>importlib.reload(test)    # Error - name 'test' is not defined
</code></pre>
<p>If someone knows how to reload a module loaded with "from module import *", please post. Otherwise, this would be another reason to avoid the form:</p>
<pre><code>from module import *
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As suggested in the docs, you should never use <code>import *</code> in production code.</p>
<p>One more reason to avoid it is that <a href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package" rel="nofollow noreferrer">importing * from a <em>package</em></a> works differently than <code>import *</code> from a <em>module</em>, which can lead to bugs. Basically, <code>from package import *</code> imports whatever names are defined  by <code>__init__.py</code>, but it also includes any submodules of the package that were explicitly loaded by previous import statements. Consider this code:</p>
<pre><code># anywhere in the code before import *
import sound.effects.echo
import sound.effects.surround

# in your module
from sound.effects import *
</code></pre>
<p>In this example, the <code>echo</code> and <code>surround</code> modules are imported in the current namespace (possibly overriding previous definitions) because they are defined in the <code>sound.effects</code> package when the <code>from sound.effects import *</code> statement is executed.</p>
</div>
<span class="comment-copy">Duplicate: <a href="http://stackoverflow.com/questions/2360724/in-python-what-exactly-does-import-import" title="in python what exactly does import import">stackoverflow.com/questions/2360724/…</a></span>
<span class="comment-copy">it depends if you are scripting or writing code you need to reuse. it sometimes pays to ignore code standards. "import *" can also be fine if you have a naming convention that makes it clear where stuff came from. e.g. "from Cats import *; TabbyCat; MaineCoonCat; CalicoCat;"</span>
<span class="comment-copy"><code>import *</code> doesn't work for me in the first place in Python 2 or 3.</span>
<span class="comment-copy">+1 because you were faster than me and also added the pyflakes argument. Should have been +2 but I can't give that :)</span>
<span class="comment-copy">Yeah, I really hate at my job when someone uses * import, because then I can't just run pyflakes and be happy, but have to repair those imports. It's nice though, that with that pyflakes helps me to :-)</span>
<span class="comment-copy">As a concrete example, many users of NumPy have been bitten by <code>numpy.any</code> shadowing <code>any</code> when they do <code>from numpy import *</code> or a "helpful" tool does it for them.</span>
<span class="comment-copy">Should I avoid using the --pylab switch for IPython for the same reasons?</span>
<span class="comment-copy">To highlight a risk I'd never thought of before reading this ("might shadow some other object from previous import"): <code>import *</code> makes the <i>order</i> of the <code>import</code> statements significant... even for standard library modules that don't normally care about import order.  Something as innocent as alphabetizing your <code>import</code> statements could break your script when a former casualty of the import war becomes the sole survivor.  (Even if your script works now and never changes, it could suddenly fail sometime later if the imported module introduces a new name that replaces one you were relying on.)</span>
<span class="comment-copy">Actually, you <i>can</i> argue with that. It’s also totally inconsistent, given that you don’t declare variables explicitly in Python, they just pop into existence once you assign to them.</span>
<span class="comment-copy">@gruszczy: declaring variables is redundant to <i>what</i>? Assigning? No, that’s two separate concept and declaring something conveys a very distinct and important information. Anyway, explicitness is always somewhat linked to redundancy, they’re two faces of the same coin.</span>
<span class="comment-copy">@kriss right, but that wasn't my point. My point was that failure to explicitly declare a variable leads to errors. You say that "assignment without [declaration] is impossible". But that's wrong, my whole point is that Python unfortunately makes exactly that possible.</span>
<span class="comment-copy">@kriss <i>Another</i> piece of information given to the compiler by the declaration is the fact that you indeed intend to declare a new variable. That’s a <i>crucial</i> piece of information for the type system. You say that modern IDEs solve the mistyping problem but that’s simply wrong, and in fact this is a <i>substantial</i> problem in non statically compiled languages, which is why Perl added <code>use strict</code> (JavaScript <code>var</code>). As an aside, of course Python is <i>not</i> typeless (it’s in fact strongly typed). Anyway, even <i>if</i> you were right, this would still contradict the Zen of Python, cited in this answer.</span>
<span class="comment-copy">@kriss You have it wrong: reusing the same variable <i>name</i> is not a problem – reusing the same <i>variable</i> is (i.e. the same name in the same scope). Explicit declarations would prevent exactly this mistake (and others, based on simple mistyping, which, as I’ve said, is actually an extremely common and time-consuming problem, even though you’re right that the problem is bigger in Perl-like languages). And the contradiction I allude to is the Zen’s requirement for explicitness, which is bodily thrown out of the window here.</span>
<span class="comment-copy">I like your attitude.</span>
<span class="comment-copy">Python 2.x <i>does</i> have an "include" statement.  It's called <code>execfile()</code>.  Luckily, it's rarely used and gone in 3.x.</span>
<span class="comment-copy">How about <code>**vars()</code> to include globals if the called function is in another file? :P</span>
<span class="comment-copy">+1 for mentioning namespace pollution</span>
