<div class="post-text" itemprop="text">
<p>In Python, and in general - does a <code>close()</code> operation on a file object imply a <code>flush()</code> operation?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes. It uses the underlying <code>close()</code> function which does that for you (<a href="https://hg.python.org/cpython/file/default/Modules/_io/fileio.c" rel="noreferrer">source</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>NB: <code>close()</code> and <code>flush()</code> won't ensure that the data is actually secure on the disk. It just ensures that the OS has the data == that it isn't buffered inside the process.</p>
<p>You can try sync or fsync to get the data written to the disk.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, in Python 3 this is finally <a href="https://docs.python.org/3/library/io.html#io.IOBase.close" rel="nofollow noreferrer">in the official documentation</a>, but is was already the case in Python 2 (see <a href="https://stackoverflow.com/a/2447160/3753684">Martin's answer</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>filehandle.close does not necessarily flush. Surprisingly, filehandle.flush doesn't help either---it still can get stuck in the OS buffers when Python is running. Observe this session where I wrote to a file, closed it and Ctrl-Z to the shell command prompt and examined the file:</p>
<pre><code>$  cat xyz
ghi
$ fg
python

&gt;&gt;&gt; x=open("xyz","a")
&gt;&gt;&gt; x.write("morestuff\n")
&gt;&gt;&gt; x.write("morestuff\n")
&gt;&gt;&gt; x.write("morestuff\n")
&gt;&gt;&gt; x.flush
&lt;built-in method flush of file object at 0x7f58e0044660&gt;
&gt;&gt;&gt; x.close
&lt;built-in method close of file object at 0x7f58e0044660&gt;
&gt;&gt;&gt; 
[1]+  Stopped                 python
$ cat xyz
ghi
</code></pre>
<p>Subsequently I can reopen the file, and that necessarily syncs the file (because, in this case, I open it in the append mode). As the others have said, the sync syscall (available from the os package) should flush all buffers to disk but it has possible system-wide performance implications (it syncs all files on the system).</p>
</div>
<span class="comment-copy">(In other words: That file I/O is buffered is large abstracted and hidden away from you. Doing an <code>open</code>, <code>write</code>, <code>close</code> shouldn't leave stuff unwritten as that's what you already intended with <code>write</code>. A buffer that routinely eats what gets thrown at it would be quite a bad design [or a hungry buffer].)</span>
<span class="comment-copy">Thanks, that was my guess too. But is this true cross-platform, cross-OS, and cross-languages?</span>
<span class="comment-copy">@Adam Matan: That's why Python sits on top of the C libraries.  To assure that "this true cross-platform, cross-OS".  I don't know what "cross-languages" means.</span>
<span class="comment-copy">+1 Thanks. By "cross-language" I meant to ask whether this behavior is similar in the vast majority of modern programming languages.</span>
<span class="comment-copy">While this answer is strictly speaking correct, the comments here suggest that <code>flush</code> has something to do with the OS buffering. Such interpretation is incorrect, and so I think perhaps this answer might benefit from a clarification or a <a href="https://stackoverflow.com/a/2447205/336527">reference to the Douglas Leeder's answer</a>.</span>
<span class="comment-copy">True, but doesn't modern OS write the data to the disk upon process termination?</span>
<span class="comment-copy">Depends on the time scales you are talking about. e.g. some versions of ext4 might wait whole seconds before committing your data to the disc.</span>
<span class="comment-copy">+1 If the order of magnitude is seconds, I'm quite safe. Thanks!</span>
<span class="comment-copy">Hm - I suspect your problem there is that you didn't actually <b>call</b> <code>flush()</code> or <code>close()</code> - you just ended up displaying their representation! You need parens to call those methods.</span>
