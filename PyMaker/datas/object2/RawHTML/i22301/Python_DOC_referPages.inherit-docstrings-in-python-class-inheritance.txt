<div class="post-text" itemprop="text">
<p>I'm trying to do some class inheritance in Python. I'd like each class and inherited class to have good docstrings. So I think for the inherited class, I'd like it to:</p>
<ul>
<li>inherit the base class docstring</li>
<li>maybe append relevant extra documentation to the docstring</li>
</ul>
<p>Is there any (possibly elegant or pythonic) way of doing this sort of docstring manipulation in a class inheritance situation? How about for multiple inheritance?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're not the only one! There was a discussion on <code>comp.lang.python</code> about this a while ago, and a recipe was created. Check it out <strong><a href="http://code.activestate.com/recipes/576862/" rel="noreferrer">here</a></strong>.</p>
<pre><code>"""
doc_inherit decorator

Usage:

class Foo(object):
    def foo(self):
        "Frobber"
        pass

class Bar(Foo):
    @doc_inherit
    def foo(self):
        pass 

Now, Bar.foo.__doc__ == Bar().foo.__doc__ == Foo.foo.__doc__ == "Frobber"
"""

from functools import wraps

class DocInherit(object):
    """
    Docstring inheriting method descriptor

    The class itself is also used as a decorator
    """

    def __init__(self, mthd):
        self.mthd = mthd
        self.name = mthd.__name__

    def __get__(self, obj, cls):
        if obj:
            return self.get_with_inst(obj, cls)
        else:
            return self.get_no_inst(cls)

    def get_with_inst(self, obj, cls):

        overridden = getattr(super(cls, obj), self.name, None)

        @wraps(self.mthd, assigned=('__name__','__module__'))
        def f(*args, **kwargs):
            return self.mthd(obj, *args, **kwargs)

        return self.use_parent_doc(f, overridden)

    def get_no_inst(self, cls):

        for parent in cls.__mro__[1:]:
            overridden = getattr(parent, self.name, None)
            if overridden: break

        @wraps(self.mthd, assigned=('__name__','__module__'))
        def f(*args, **kwargs):
            return self.mthd(*args, **kwargs)

        return self.use_parent_doc(f, overridden)

    def use_parent_doc(self, func, source):
        if source is None:
            raise NameError, ("Can't find '%s' in parents"%self.name)
        func.__doc__ = source.__doc__
        return func

doc_inherit = DocInherit 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can concatenate the docstrings easily:</p>
<pre><code>class Foo(object):
    """
    Foo Class.
    This class foos around.
    """
    pass

class Bar(Foo):
    """
    Bar class, children of Foo
    Use this when you want to Bar around.
    parent:
    """ 
    __doc__ += Foo.__doc__
    pass
</code></pre>
<p>However, that is useless. Most documentation generation tool (<a href="http://sphinx.pocoo.org/" rel="noreferrer">Sphinx</a> and <a href="http://epydoc.sourceforge.net/" rel="noreferrer">Epydoc</a> included) will already pull parent docstring, including for methods. So you don't have to do anything.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not particularly elegant, but simple and direct:</p>
<pre><code>class X(object):
  """This class has a method foo()."""
  def foo(): pass

class Y(X):
  __doc__ = X.__doc__ + ' Also bar().'
  def bar(): pass
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; print Y.__doc__
This class has a method foo(). Also bar().
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A mixed stile that can preserve both the inherited docstring syntax and the preferred ordering can be:</p>
<pre><code>class X(object):
  """This class has a method foo()."""
  def foo(): pass

class Y(X):
  """ Also bar()."""
  __doc__ = X.__doc__ + __doc__
  def bar(): pass
</code></pre>
<p>With the same output as Alex's one:</p>
<pre><code>&gt;&gt;&gt; print Y.__doc__
This class has a method foo(). Also bar().
</code></pre>
<p><strong>Thin ice:</strong> playing with docstring can make your module unusable with <code>python -OO</code>, expect some:</p>
<pre><code>TypeError: cannot concatenate 'str' and 'NoneType' objects
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wrote <a href="https://github.com/meowklaski/custom_inherit" rel="nofollow noreferrer">custom_inherit</a> to provide some simple, light weight tools for handling docstring inheritance. </p>
<p>It also comes with some nice default styles for merging different types of docstrings (e.g. Numpy, Google, and reST formatted docstrings). You can also provide your own style very easily.</p>
<p>Overlapping docstring sections will defer to the child's section, otherwise they are merged together with nice formatting.</p>
</div>
<span class="comment-copy">I can't answer because the question was unfortunately closed, but as of Python 3.5, <a href="https://docs.python.org/3/library/inspect.html#inspect.getdoc" rel="nofollow noreferrer"><code>inspect.getdoc</code></a> will search the inheritance tree until it finds a docstring.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/a/38414303/974555">this answer</a>.</span>
<span class="comment-copy">That's neat for a method to inherit the parent class' method's docstring. That would be useful in many cases I think. I was thinking more about the docstring for the whole class, where I'd like to inherit and append.</span>
<span class="comment-copy">Ah, gotcha. In that case, most of the doc-generation already do that for you.</span>
<span class="comment-copy">Indeed, most documentation tools do that. But the built-in help() function doesn't.</span>
<span class="comment-copy">@MarioVilas: perhaps that's a bug that should be reported?</span>
<span class="comment-copy">Sphinx doesn't seem to be doing that for me, perhaps because my parent is "private" aka name starts with an underscore.</span>
<span class="comment-copy">If you want to do this for the <code>Init docstring</code> as well, is there a way to do it in the definition of <code>Y</code>? The only way I have been able to do it is using <code>__init__.__doc__ = X.__init__.__doc__ + " Also another param"</code> following the <code>__init__</code> definition in <code>Y</code> but this seems to mess with the formatting, causing extra added spaces.</span>
