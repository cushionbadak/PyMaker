<div class="post-text" itemprop="text">
<p>Hi I have something roughly like the following.  Basically I need to access the class of an instance method from a decorator used upon the instance method in its definition.</p>
<pre><code>def decorator(view):
    # do something that requires view's class
    print view.im_class
    return view

class ModelA(object):
    @decorator
    def a_method(self):
        # do some stuff
        pass
</code></pre>
<p>The code as-is gives</p>
<p><code>
AttributeError: 'function' object has no attribute 'im_class'
</code></p>
<p>I found similar question/answers - <a href="https://stackoverflow.com/questions/306130/">Python decorator makes function forget that it belongs to a class</a> and <a href="https://stackoverflow.com/questions/2309124">Get class in Python decorator</a> - but these rely upon a workaround that grabs the instance at run-time by snatching the first parameter.  In my case I will be calling the method based upon the information gleaned from its class, so I can't wait for a call to come in.</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python 2.6 or later you could use a class decorator, perhaps something like this (warning: untested code).</p>
<pre><code>def class_decorator(cls):
   for name, method in cls.__dict__.iteritems():
        if hasattr(method, "use_class"):
            # do something with the method and class
            print name, cls
   return cls

def method_decorator(view):
    # mark the method as something that requires view's class
    view.use_class = True
    return view

@class_decorator
class ModelA(object):
    @method_decorator
    def a_method(self):
        # do some stuff
        pass
</code></pre>
<p>The method decorator marks the method as one that is of interest by adding a "use_class" attribute - functions and methods are also objects, so you can attach additional metadata to them.</p>
<p>After the class has been created the class decorator then goes through all the methods and does whatever is needed on the methods that have been marked.</p>
<p>If you want all the methods to be affected then you could leave out the method decorator and just use the class decorator.</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have pointed out, the class hasn't been created at the time the decorator is called. <strong>However</strong>, it's possible to annotate the function object with the decorator parameters, then re-decorate the function in the metaclass's <code>__new__</code> method. You'll need to access the function's <code>__dict__</code> attribute directly, as at least for me, <code>func.foo = 1</code> resulted in an AttributeError.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Ants indicated, you can't get a reference to the class from within the class.  However, if you're interested in distinguishing between different classes ( not manipulating the actual class type object), you can pass a string for each class. You can also pass whatever other parameters you like to the decorator using class-style decorators.</p>
<pre><code>class Decorator(object):
    def __init__(self,decoratee_enclosing_class):
        self.decoratee_enclosing_class = decoratee_enclosing_class
    def __call__(self,original_func):
        def new_function(*args,**kwargs):
            print 'decorating function in ',self.decoratee_enclosing_class
            original_func(*args,**kwargs)
        return new_function


class Bar(object):
    @Decorator('Bar')
    def foo(self):
        print 'in foo'

class Baz(object):
    @Decorator('Baz')
    def foo(self):
        print 'in foo'

print 'before instantiating Bar()'
b = Bar()
print 'calling b.foo()'
b.foo()
</code></pre>
<p>Prints:</p>
<pre><code>before instantiating Bar()
calling b.foo()
decorating function in  Bar
in foo
</code></pre>
<p>Also, <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808#function-decorators" rel="nofollow noreferrer">see Bruce Eckel's page on decorators.</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that when the decorator is called the class doesn't exist yet. Try this:</p>
<pre><code>def loud_decorator(func):
    print("Now decorating %s" % func)
    def decorated(*args, **kwargs):
        print("Now calling %s with %s,%s" % (func, args, kwargs))
        return func(*args, **kwargs)
    return decorated

class Foo(object):
    class __metaclass__(type):
        def __new__(cls, name, bases, dict_):
            print("Creating class %s%s with attributes %s" % (name, bases, dict_))
            return type.__new__(cls, name, bases, dict_)

    @loud_decorator
    def hello(self, msg):
        print("Hello %s" % msg)

Foo().hello()
</code></pre>
<p>This program will output:</p>
<pre><code>Now decorating &lt;function hello at 0xb74d35dc&gt;
Creating class Foo(&lt;type 'object'&gt;,) with attributes {'__module__': '__main__', '__metaclass__': &lt;class '__main__.__metaclass__'&gt;, 'hello': &lt;function decorated at 0xb74d356c&gt;}
Now calling &lt;function hello at 0xb74d35dc&gt; with (&lt;__main__.Foo object at 0xb74ea1ac&gt;, 'World'),{}
Hello World
</code></pre>
<p>As you see, you are going to have to figure out a different way to do what you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple example: </p>
<pre><code>def mod_bar(cls):
    # returns modified class

    def decorate(fcn):
        # returns decorated function

        def new_fcn(self):
            print self.start_str
            print fcn(self)
            print self.end_str

        return new_fcn

    cls.bar = decorate(cls.bar)
    return cls

@mod_bar
class Test(object):
    def __init__(self):
        self.start_str = "starting dec"
        self.end_str = "ending dec" 

    def bar(self):
        return "bar"
</code></pre>
<p>The output is: </p>
<pre><code>&gt;&gt;&gt; import Test
&gt;&gt;&gt; a = Test()
&gt;&gt;&gt; a.bar()
starting dec
bar
ending dec
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What <a href="http://pythonhosted.org/Flask-Classy/" rel="nofollow">flask-classy</a> does is create a temporary cache that it stores on the method, then it uses something else (the fact that Flask will register the classes using a <code>register</code> class method) to actually wraps the method.</p>
<p>You can reuse this pattern, this time using a metaclass so that you can wrap the method at import time.</p>
<pre><code>def route(rule, **options):
    """A decorator that is used to define custom routes for methods in
    FlaskView subclasses. The format is exactly the same as Flask's
    `@app.route` decorator.
    """

    def decorator(f):
        # Put the rule cache on the method itself instead of globally
        if not hasattr(f, '_rule_cache') or f._rule_cache is None:
            f._rule_cache = {f.__name__: [(rule, options)]}
        elif not f.__name__ in f._rule_cache:
            f._rule_cache[f.__name__] = [(rule, options)]
        else:
            f._rule_cache[f.__name__].append((rule, options))

        return f

    return decorator
</code></pre>
<p>On the actual class (you could do the same using a metaclass):</p>
<pre><code>@classmethod
def register(cls, app, route_base=None, subdomain=None, route_prefix=None,
             trailing_slash=None):

    for name, value in members:
        proxy = cls.make_proxy_method(name)
        route_name = cls.build_route_name(name)
        try:
            if hasattr(value, "_rule_cache") and name in value._rule_cache:
                for idx, cached_rule in enumerate(value._rule_cache[name]):
                    # wrap the method here
</code></pre>
<p>Source: <a href="https://github.com/apiguy/flask-classy/blob/master/flask_classy.py" rel="nofollow">https://github.com/apiguy/flask-classy/blob/master/flask_classy.py</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As Mark suggests:</p>
<ol>
<li>Any decorator is called BEFORE class is built, so is unknown to the decorator.</li>
<li>We can <em>tag</em> these methods and make any necessary post-process later.</li>
<li>We have two options for post-processing: automatically at the end of the class definition or somewhere before the application will run. I prefer the 1st option using a base class, but you can follow the 2nd approach as well.</li>
</ol>
<p>This code shows how this may works using automatic post-processing:</p>
<pre><code>def expose(**kw):
    "Note that using **kw you can tag the function with any parameters"
    def wrap(func):
        name = func.func_name
        assert not name.startswith('_'), "Only public methods can be exposed"

        meta = func.__meta__ = kw
        meta['exposed'] = True
        return func

    return wrap

class Exposable(object):
    "Base class to expose instance methods"
    _exposable_ = None  # Not necessary, just for pylint

    class __metaclass__(type):
        def __new__(cls, name, bases, state):
            methods = state['_exposed_'] = dict()

            # inherit bases exposed methods
            for base in bases:
                methods.update(getattr(base, '_exposed_', {}))

            for name, member in state.items():
                meta = getattr(member, '__meta__', None)
                if meta is not None:
                    print "Found", name, meta
                    methods[name] = member
            return type.__new__(cls, name, bases, state)

class Foo(Exposable):
    @expose(any='parameter will go', inside='__meta__ func attribute')
    def foo(self):
        pass

class Bar(Exposable):
    @expose(hide=True, help='the great bar function')
    def bar(self):
        pass

class Buzz(Bar):
    @expose(hello=False, msg='overriding bar function')
    def bar(self):
        pass

class Fizz(Foo):
    @expose(msg='adding a bar function')
    def bar(self):
        pass

print('-' * 20)
print("showing exposed methods")
print("Foo: %s" % Foo._exposed_)
print("Bar: %s" % Bar._exposed_)
print("Buzz: %s" % Buzz._exposed_)
print("Fizz: %s" % Fizz._exposed_)

print('-' * 20)
print('examine bar functions')
print("Bar.bar: %s" % Bar.bar.__meta__)
print("Buzz.bar: %s" % Buzz.bar.__meta__)
print("Fizz.bar: %s" % Fizz.bar.__meta__)
</code></pre>
<p>The output yields:</p>
<pre><code>Found foo {'inside': '__meta__ func attribute', 'any': 'parameter will go', 'exposed': True}
Found bar {'hide': True, 'help': 'the great bar function', 'exposed': True}
Found bar {'msg': 'overriding bar function', 'hello': False, 'exposed': True}
Found bar {'msg': 'adding a bar function', 'exposed': True}
--------------------
showing exposed methods
Foo: {'foo': &lt;function foo at 0x7f7da3abb398&gt;}
Bar: {'bar': &lt;function bar at 0x7f7da3abb140&gt;}
Buzz: {'bar': &lt;function bar at 0x7f7da3abb0c8&gt;}
Fizz: {'foo': &lt;function foo at 0x7f7da3abb398&gt;, 'bar': &lt;function bar at 0x7f7da3abb488&gt;}
--------------------
examine bar functions
Bar.bar: {'hide': True, 'help': 'the great bar function', 'exposed': True}
Buzz.bar: {'msg': 'overriding bar function', 'hello': False, 'exposed': True}
Fizz.bar: {'msg': 'adding a bar function', 'exposed': True}
</code></pre>
<p>Note that in this example:</p>
<ol>
<li>We can annotate any function with any arbitrary parameters.</li>
<li>Each class has its own exposed methods.</li>
<li>We can inherit exposed methods as well.</li>
<li>methods can be overriding as exposing feature is updated.</li>
</ol>
<p>Hope this helps</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an old question but came across venusian.  <a href="http://venusian.readthedocs.org/en/latest/" rel="nofollow">http://venusian.readthedocs.org/en/latest/</a></p>
<p>It seems to have the ability to decorate methods and give you access to both the class and the method while doing so.
Note tht calling <code>setattr(ob, wrapped.__name__, decorated)</code> is not the typical way of using venusian and somewhat defeats the purpose.</p>
<p>Either way... the example below is complete and should run.</p>
<pre><code>import sys
from functools import wraps
import venusian

def logged(wrapped):
    def callback(scanner, name, ob):
        @wraps(wrapped)
        def decorated(self, *args, **kwargs):
            print 'you called method', wrapped.__name__, 'on class', ob.__name__
            return wrapped(self, *args, **kwargs)
        print 'decorating', '%s.%s' % (ob.__name__, wrapped.__name__)
        setattr(ob, wrapped.__name__, decorated)
    venusian.attach(wrapped, callback)
    return wrapped

class Foo(object):
    @logged
    def bar(self):
        print 'bar'

scanner = venusian.Scanner()
scanner.scan(sys.modules[__name__])

if __name__ == '__main__':
    t = Foo()
    t.bar()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since python 3.6 you can use <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" rel="nofollow noreferrer"><code>object.__set_name__</code></a> to accomplish this in a very simple way. The doc states that <code>__set_name__</code> is "called at the time the owning class <em>owner</em> is created".
Here is an example:</p>
<pre class="lang-py prettyprint-override"><code>class class_decorator:
    def __init__(self, fn):
        self.fn = fn

    def __set_name__(self, owner, name):
        # do something with owner, i.e.
        print(f"decorating {self.fn} and using {owner}")
        self.fn.class_name = owner.__name__

        # then replace ourself with the original method
        setattr(owner, name, self.fn)
</code></pre>
<p>Notice that it gets called at class creation time:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; class A:
...     @class_decorator
...     def hello(self, x=42):
...         return x
...
decorating &lt;function A.hello at 0x7f9bedf66bf8&gt; and using &lt;class '__main__.A'&gt;
&gt;&gt;&gt; A.hello
&lt;function __main__.A.hello(self, x=42)&gt;
&gt;&gt;&gt; A.hello.class_name
'A'
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.hello()
42
</code></pre>
<p>If you want to know more about how classes are created and in particular exactly when <code>__set_name__</code> is called, you can refer to the <a href="https://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="nofollow noreferrer">documentation on "Creating the class object"</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You will have access to the class of the object on which the method is being called in the decorated method that your decorator should return.  Like so:</p>
<pre><code>def decorator(method):
    # do something that requires view's class
    def decorated(self, *args, **kwargs):
        print 'My class is %s' % self.__class__
        method(self, *args, **kwargs)
    return decorated
</code></pre>
<p>Using your ModelA class, here is what this does:</p>
<pre><code>&gt;&gt;&gt; obj = ModelA()
&gt;&gt;&gt; obj.a_method()
My class is &lt;class '__main__.ModelA'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Function doesn't know whether it's a method at definition point, when the decorator code runs. Only when it's accessed via class/instance identifier it may know its class/instance. To overcome this limitation, you may decorate by descriptor object to delay actual decorating code until access/call time:</p>
<pre><code>class decorated(object):
    def __init__(self, func, type_=None):
        self.func = func
        self.type = type_

    def __get__(self, obj, type_=None):
        func = self.func.__get__(obj, type_)
        print('accessed %s.%s' % (type_.__name__, func.__name__))
        return self.__class__(func, type_)

    def __call__(self, *args, **kwargs):
        name = '%s.%s' % (self.type.__name__, self.func.__name__)
        print('called %s with args=%s kwargs=%s' % (name, args, kwargs))
        return self.func(*args, **kwargs)
</code></pre>
<p>This allows you to decorate individual (static|class) methods:</p>
<pre><code>class Foo(object):
    @decorated
    def foo(self, a, b):
        pass

    @decorated
    @staticmethod
    def bar(a, b):
        pass

    @decorated
    @classmethod
    def baz(cls, a, b):
        pass

class Bar(Foo):
    pass
</code></pre>
<p>Now you can use decorator code for introspection...</p>
<pre><code>&gt;&gt;&gt; Foo.foo
accessed Foo.foo
&gt;&gt;&gt; Foo.bar
accessed Foo.bar
&gt;&gt;&gt; Foo.baz
accessed Foo.baz
&gt;&gt;&gt; Bar.foo
accessed Bar.foo
&gt;&gt;&gt; Bar.bar
accessed Bar.bar
&gt;&gt;&gt; Bar.baz
accessed Bar.baz
</code></pre>
<p>...and for changing function behavior:</p>
<pre><code>&gt;&gt;&gt; Foo().foo(1, 2)
accessed Foo.foo
called Foo.foo with args=(1, 2) kwargs={}
&gt;&gt;&gt; Foo.bar(1, b='bcd')
accessed Foo.bar
called Foo.bar with args=(1,) kwargs={'b': 'bcd'}
&gt;&gt;&gt; Bar.baz(a='abc', b='bcd')
accessed Bar.baz
called Bar.baz with args=() kwargs={'a': 'abc', 'b': 'bcd'}
</code></pre>
</div>
<span class="comment-copy">Thanks I think this is the route with which to go.  Just one extra line of code for any class I'd want to use this decorator.  Maybe I could use a custom metaclass and perform this same check during <b>new</b>...?</span>
<span class="comment-copy">Anyone trying to use this with staticmethod or classmethod will want to read this PEP: <a href="http://www.python.org/dev/peps/pep-0232/" rel="nofollow noreferrer">python.org/dev/peps/pep-0232</a>  Not sure it's possible because you can't set an attribute on a class/static method and I think they gobble up any custom function attributes when they are applied to a function.</span>
<span class="comment-copy">Just what I was looking for, for my DBM based ORM... Thanks, dude.</span>
<span class="comment-copy">You should use <code>inspect.getmro(cls)</code> to process all base classes in the class decorator to support inheritance.</span>
<span class="comment-copy">oh, actually it looks like <code>inspect</code> to the rescue <a href="http://stackoverflow.com/a/1911287/202168">stackoverflow.com/a/1911287/202168</a></span>
<span class="comment-copy"><code>setattr</code> should be used instead of accessing <code>__dict__</code></span>
<span class="comment-copy">Thanks for confirming my depressing conclusion that this isn't possible.  I could also use a string that fully qualified the module/class ('module.Class'), store the string(s) until the classes have all fully loaded, then retrieve the classes myself with import.  That seems like a woefully un-DRY way to accomplish my task.</span>
<span class="comment-copy">You don't need to use a class for this sort of decorator: the idiomatic approach is to use one extra level of nested functions inside the decorator function. However, if you do go with classes, it might be nicer to not use capitalisation in the class name to make the decoration itself look "standard", i.e. <code>@decorator('Bar')</code> as opposed to <code>@Decorator('Bar')</code>.</span>
<span class="comment-copy">when one defines a function the function doesn't exist yet, but one is able to recursively call the function from within itself.  I guess this is a language feature specific to functions and not available to classes.</span>
<span class="comment-copy">DGGenuine: The function is only called, and the function thus accesses itself, only after it was created completely. In this case, the class can not be complete when the decorator is called, since the class must wait for the decorator's result, which will be stored as one of the attributes of the class.</span>
<span class="comment-copy">that's a useful pattern, but this doesn't address the problem of a method decorator being able to refer to the parent class of the method it's applied to</span>
<span class="comment-copy">I updated my answer to be more explicit how this can be useful to get access to the class at import time (i.e. using a metaclass + caching the decorator param on the method).</span>
<span class="comment-copy">Thanks but this is exactly the solution I referenced in my question that doesn't work for me.  I am trying to implement an observer pattern using decorators and I will never be able to call the method in the correct context from my observation dispatcher if I don't have the class at some point while adding the method to the observation dispatcher.  Getting the class upon method call doesn't help me correctly call the method in the first place.</span>
<span class="comment-copy">Whoa, sorry for my laziness in not reading your entire question.</span>
<span class="comment-copy">Sadly, this approach is functionally equivalent to <a href="https://stackoverflow.com/users/151221/will-mccutchen">Will McCutchen</a>'s <a href="https://stackoverflow.com/a/2366777/2809027">equally inapplicable answer</a>. Both this and that answer obtain the desired class at method <i>call</i> time rather than method <i>decoration</i> time, as required by the original question. The only reasonable means of obtaining this class at a sufficiently early time is to introspect over all methods at class definition time (e.g., via a class decorator or metaclass). <code>&lt;/sigh&gt;</code></span>
