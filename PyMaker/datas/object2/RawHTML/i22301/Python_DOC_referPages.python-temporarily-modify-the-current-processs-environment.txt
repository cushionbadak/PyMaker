<div class="post-text" itemprop="text">
<p>I use the following code to temporarily modify environment variables. </p>
<pre><code>@contextmanager
def _setenv(**mapping):
    """``with`` context to temporarily modify the environment variables"""
    backup_values = {}
    backup_remove = set()
    for key, value in mapping.items():
        if key in os.environ:
            backup_values[key] = os.environ[key]
        else:
            backup_remove.add(key)
        os.environ[key] = value

    try:
        yield
    finally:
        # restore old environment
        for k, v in backup_values.items():
            os.environ[k] = v
        for k in backup_remove:
            del os.environ[k]
</code></pre>
<p>This <code>with</code> context is mainly used in test cases. For example,</p>
<pre><code>def test_myapp_respects_this_envvar():
    with _setenv(MYAPP_PLUGINS_DIR='testsandbox/plugins'):
        myapp.plugins.register()
        [...]
</code></pre>
<p>My question: is there a simple/elegant way to write <code>_setenv</code>? I thought about actually doing <code>backup = os.environ.copy()</code> and then <code>os.environ = backup</code> .. but I am not sure if that would affect the program behavior (eg: if <code>os.environ</code> is <em>referenced</em> elsewhere in the Python interpreter).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>_environ = dict(os.environ)  # or os.environ.copy()
try:

    ...

finally:
    os.environ.clear()
    os.environ.update(_environ)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you the following implementation:</p>
<pre><code>import contextlib
import os


@contextlib.contextmanager
def set_env(**environ):
    """
    Temporarily set the process environment variables.

    &gt;&gt;&gt; with set_env(PLUGINS_DIR=u'test/plugins'):
    ...   "PLUGINS_DIR" in os.environ
    True

    &gt;&gt;&gt; "PLUGINS_DIR" in os.environ
    False

    :type environ: dict[str, unicode]
    :param environ: Environment variables to set
    """
    old_environ = dict(os.environ)
    os.environ.update(environ)
    try:
        yield
    finally:
        os.environ.clear()
        os.environ.update(old_environ)
</code></pre>
<p><strong>EDIT: more advanced implementation</strong></p>
<p>The context manager below can be used to add/remove/update your environment variables:</p>
<pre><code>import contextlib
import os


@contextlib.contextmanager
def modified_environ(*remove, **update):
    """
    Temporarily updates the ``os.environ`` dictionary in-place.

    The ``os.environ`` dictionary is updated in-place so that the modification
    is sure to work in all situations.

    :param remove: Environment variables to remove.
    :param update: Dictionary of environment variables and values to add/update.
    """
    env = os.environ
    update = update or {}
    remove = remove or []

    # List of environment variables being updated or removed.
    stomped = (set(update.keys()) | set(remove)) &amp; set(env.keys())
    # Environment variables and values to restore on exit.
    update_after = {k: env[k] for k in stomped}
    # Environment variables and values to remove on exit.
    remove_after = frozenset(k for k in update if k not in env)

    try:
        env.update(update)
        [env.pop(k, None) for k in remove]
        yield
    finally:
        env.update(update_after)
        [env.pop(k) for k in remove_after]
</code></pre>
<p>Usage examples:</p>
<pre><code>&gt;&gt;&gt; with modified_environ('HOME', LD_LIBRARY_PATH='/my/path/to/lib'):
...     home = os.environ.get('HOME')
...     path = os.environ.get("LD_LIBRARY_PATH")
&gt;&gt;&gt; home is None
True
&gt;&gt;&gt; path
'/my/path/to/lib'

&gt;&gt;&gt; home = os.environ.get('HOME')
&gt;&gt;&gt; path = os.environ.get("LD_LIBRARY_PATH")
&gt;&gt;&gt; home is None
False
&gt;&gt;&gt; path is None
True
</code></pre>
<p><strong>EDIT2</strong></p>
<p>A demonstration of this context manager is available on <a href="https://github.com/laurent-laporte-pro/stackoverflow-q2059482" rel="nofollow noreferrer">GitHub</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was looking to do the same thing but for unit testing, here is how I have done it using the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock.patch</code></a> function:</p>
<pre class="lang-py prettyprint-override"><code>def test_function_with_different_env_variable():
    with mock.patch.dict('os.environ', {'hello': 'world'}, clear=True):
        self.assertEqual(os.environ.get('hello'), 'world')
        self.assertEqual(len(os.environ), 1)
</code></pre>
<p>Basically using <a href="https://docs.python.org/3/library/unittest.mock.html#patch-dict" rel="nofollow noreferrer"><code>unittest.mock.patch.dict</code></a> with <code>clear=True</code>, we are making <code>os.environ</code> as a dictionnary containing solely <code>{'hello': 'world'}</code>.</p>
<ul>
<li><p>Removing the <code>clear=True</code> will let the original os.environ and add/replace the specified key/value pair inside <code>{'hello': 'world'}</code>.</p></li>
<li><p>Removing <code>{'hello': 'world'}</code> will just create an empty dictionary, <code>os.envrion</code> will thus be empty within the <code>with</code>.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>For unit testing I prefer using a decorator function with optional parameters. This way I can use the modified environment values for a whole test function. The decorator below also restores the original environment values in case the function raises an Exception:</p>
<pre><code>import os

def patch_environ(new_environ=None, clear_orig=False):
    if not new_environ:
        new_environ = dict()

    def actual_decorator(func):
        from functools import wraps

        @wraps(func)
        def wrapper(*args, **kwargs):
            original_env = dict(os.environ)

            if clear_orig:
                os.environ.clear()

            os.environ.update(new_environ)
            try:
                result = func(*args, **kwargs)
            except:
                raise
            finally: # restore even if Exception was raised
                os.environ = original_env

            return result

        return wrapper

    return actual_decorator
</code></pre>
<p>Usage in unit tests:</p>
<pre><code>class Something:
    @staticmethod
    def print_home():
        home = os.environ.get('HOME', 'unknown')
        print("HOME = {0}".format(home))


class SomethingTest(unittest.TestCase):
    @patch_environ({'HOME': '/tmp/test'})
    def test_environ_based_something(self):
        Something.print_home() # prints: HOME = /tmp/test

unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the gist here, you can save/restore local, global scope variable and environment variables:
<a href="https://gist.github.com/earonesty/ac0617a5672ae1a41be1eaf316dd63e4" rel="nofollow noreferrer">https://gist.github.com/earonesty/ac0617a5672ae1a41be1eaf316dd63e4</a></p>
<pre><code>import os
from varlib import vartemp, envtemp

x = 3
y = 4

with vartemp({'x':93,'y':94}):
   print(x)
   print(y)
print(x)
print(y)

with envtemp({'foo':'bar'}):
    print(os.getenv('foo'))

print(os.getenv('foo'))
</code></pre>
<p>This outputs:</p>
<pre><code>93
94
3
4
bar
None
</code></pre>
</div>
<span class="comment-copy">Good. I am using <code>.copy()</code> instead of <code>dict()</code> though.</span>
<span class="comment-copy">just wanted i needed, thanks!</span>
<span class="comment-copy">Ok, but in case of failure (exception) during [...], environment variables are not restored: a <code>try ... finally ...</code> is required for that.</span>
<span class="comment-copy">For visitors to this old question, I don't see any obvious flaws in this answer and it is more complete and useful than the original.</span>
<span class="comment-copy">This should be part of python - or something. Messing with the environment for testing is nasty - but sometimes necessary - stuff and can severely break, invalidate or otherwise fnord tests lying downstream of env-messing test-functions :(</span>
<span class="comment-copy">This is the better answer :)</span>
<span class="comment-copy">In which scenarios, would the first method not work?</span>
