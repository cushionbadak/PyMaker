<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/492519/timeout-on-a-function-call">Timeout on a function call</a>
<span class="question-originals-answer-count">
                    13 answers
                </span>
</li>
</ul>
</div>
<p>I have a shell script that loops through a text file containing URL:s that I want to visit and take screenshots of.</p>
<p>All this is done and simple. The script initializes a class that when run creates a screenshot of each site in the list. Some sites take a very, very long time to load, and some might not be loaded at all. So I want to wrap the screengrabber-function in a timeout script, making the function return <code>False</code> if it couldn't finish within 10 seconds.</p>
<p>I'm content with the simplest solution possible, maybe setting a asynchronous timer that will return False after 10 seconds no matter what actually happens inside the function?</p>
</div>
<div class="post-text" itemprop="text">
<p>The process for timing out an operations is described in the documentation for <a href="http://docs.python.org/library/signal#example" rel="noreferrer">signal</a>.</p>
<p>The basic idea is to use signal handlers to set an alarm for some time interval and raise an exception once that timer expires.</p>
<p>Note that this will only work on UNIX.</p>
<p>Here's an implementation that creates a decorator (save the following code as <code>timeout.py</code>).</p>
<pre><code>from functools import wraps
import errno
import os
import signal

class TimeoutError(Exception):
    pass

def timeout(seconds=10, error_message=os.strerror(errno.ETIME)):
    def decorator(func):
        def _handle_timeout(signum, frame):
            raise TimeoutError(error_message)

        def wrapper(*args, **kwargs):
            signal.signal(signal.SIGALRM, _handle_timeout)
            signal.alarm(seconds)
            try:
                result = func(*args, **kwargs)
            finally:
                signal.alarm(0)
            return result

        return wraps(func)(wrapper)

    return decorator
</code></pre>
<p>This creates a decorator called <code>@timeout</code> that can be applied to any long running functions.</p>
<p>So, in your application code, you can use the decorator like so:</p>
<pre><code>from timeout import timeout

# Timeout a long running function with the default expiry of 10 seconds.
@timeout
def long_running_function1():
    ...

# Timeout after 5 seconds
@timeout(5)
def long_running_function2():
    ...

# Timeout after 30 seconds, with the error "Connection timed out"
@timeout(30, os.strerror(errno.ETIMEDOUT))
def long_running_function3():
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I rewrote David's answer using the <code>with</code> statement, it allows you do do this:</p>
<pre><code>with timeout(seconds=3):
    time.sleep(4)
</code></pre>
<p>Which will raise a TimeoutError.</p>
<p>The code is still using <code>signal</code> and thus UNIX only:</p>
<pre><code>import signal

class timeout:
    def __init__(self, seconds=1, error_message='Timeout'):
        self.seconds = seconds
        self.error_message = error_message
    def handle_timeout(self, signum, frame):
        raise TimeoutError(self.error_message)
    def __enter__(self):
        signal.signal(signal.SIGALRM, self.handle_timeout)
        signal.alarm(self.seconds)
    def __exit__(self, type, value, traceback):
        signal.alarm(0)
</code></pre>
</div>
<span class="comment-copy">For all lazy people, who love to use libraries instead of copy+pasting code snippets from StackOverflow: <a href="https://pypi.python.org/pypi/timeout-decorator" rel="nofollow noreferrer">pypi.python.org/pypi/timeout-decorator</a></span>
<span class="comment-copy">Beware that this is not thread-safe: if you're using multithreading, the signal will get caught by a random thread. For single-threaded programs though, this is the easiest solution.</span>
<span class="comment-copy">Nice. Also, it is recommended to decorate the function <code>wrapper</code> with <code>@functools.wraps(func)</code></span>
<span class="comment-copy">FYI, there are missing parens after the first "@timeout".  It should read <code>@timeout() def ...</code>.</span>
<span class="comment-copy">@wim I think it can only be used in main thread, because if you use it in worker thread, it will raise 'ValueError: signal only works in main thread'.</span>
<span class="comment-copy">Could also use <a href="https://docs.python.org/3/library/signal.html#signal.setitimer" rel="nofollow noreferrer">docs.python.org/3/library/signal.html#signal.setitimer</a> to allow half second timeouts.</span>
<span class="comment-copy">Python &lt; v3 does not have a TimeoutError. But one can very easily write one own class with like explained here: <a href="http://stackoverflow.com/a/1319675/380038">stackoverflow.com/a/1319675/380038</a></span>
<span class="comment-copy">You could easily add in a decorator <code>@timeout.timeout</code> as a static method to this. Then, you could easily choose between a decorator or a <code>with</code> statement.</span>
<span class="comment-copy">Interesting to note that if inside the <code>with Timeout(t)</code> context any error is raised, the <code>__exit__</code> is still called, avoiding, thus, any complication caused by <code>TimeOutError</code> being raised instead of the real error. This is a very lovable solution.</span>
<span class="comment-copy">Can someone recommend a viable solution that, like this, that works in threads?</span>
<span class="comment-copy">@Nick Some time ago I created version of timeout decorator, that works with floats - <a href="http://stackoverflow.com/questions/11901328/how-to-timeout-function-in-python-timeout-less-than-a-second/11901541#11901541" title="how to timeout function in python timeout less than a second">stackoverflow.com/questions/11901328/â€¦</a></span>
