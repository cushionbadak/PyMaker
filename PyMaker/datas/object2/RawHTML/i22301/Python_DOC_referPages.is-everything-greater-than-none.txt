<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/45449718/a-number-smaller-than-negative-infinity-in-python">A number smaller than negative infinity in python?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>Is there a Python built-in datatype, <strong>besides <code>None</code></strong>, for which:</p>
<pre><code>&gt;&gt;&gt; not foo &gt; None
True
</code></pre>
<p>where <code>foo</code> is a value of that type? How about Python 3?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>None</code> is always less than any datatype in Python 2 (see <a href="http://hg.python.org/cpython/file/ab05e7dd2788/Objects/object.c#l778" rel="noreferrer"><code>object.c</code></a>).</p>
<p>In Python 3, this was changed; now doing comparisons on things without a sensible natural ordering results in a <code>TypeError</code>. From the <strong><a href="https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="noreferrer">3.0 "what's new" updates</a></strong>:</p>
<blockquote>
<p>Python 3.0 has simplified the rules for ordering comparisons:</p>
<p>The ordering comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>) raise a <code>TypeError</code> exception when the operands don’t have a meaningful natural ordering. Thus, expressions like: <code>1 &lt; ''</code>, <code>0 &gt; None</code> or <code>len &lt;= len</code> are no longer valid, and e.g. <code>None &lt; None</code> raises <code>TypeError</code> instead of returning <code>False</code>. A corollary is that sorting a heterogeneous list no longer makes sense – all the elements must be comparable to each other. Note that this does not apply to the <code>==</code> and <code>!=</code> operators: objects of different incomparable types always compare unequal to each other.</p>
</blockquote>
<p>This upset some people since it was often handy to do things like sort a list that had some <code>None</code> values in it, and have the <code>None</code> values appear clustered together at the beginning or end. <strong><a href="http://markmail.org/message/qztbun75kcsewzuk#query:none%20comparability%20python+page:1+mid:tmxfw326w3efme7w+state:results" rel="noreferrer">There was a thread on the mailing list about this</a></strong> a while back, but the ultimate point is that Python 3 tries to avoid making arbitrary decisions about ordering (which is what happened a lot in Python 2).</p>
</div>
<div class="post-text" itemprop="text">
<p>From the Python <strong>2.7.5</strong> source (<a href="http://hg.python.org/cpython/file/ab05e7dd2788/Objects/object.c#l778" rel="noreferrer"><code>object.c</code></a>):</p>
<pre><code>static int
default_3way_compare(PyObject *v, PyObject *w)
{
    ...
    /* None is smaller than anything */
    if (v == Py_None)
            return -1;
    if (w == Py_None)
            return 1;
    ...
}
</code></pre>
<p><strong>EDIT</strong>: Added version number.</p>
</div>
<span class="comment-copy">Thanks for clarifying the state of Python 3. I remember reading the "what's new" page but I don't remember this one. Very interesting, but it makes sense indeed...</span>
<span class="comment-copy">Of course, there's nothing arbitrary about ordering None, as long as it's clearly defined.  This sort of gratuitous incompatibility is why Python 3 adoption is taking so long.</span>
<span class="comment-copy">"Well-defined" (clear, explicit definition of behavior) is distinct from "arbitrary" (a choice made based on discretion). For example, one could just as easily have said "None compares greater than everything". That's equally well-defined, but still quite arbitrary.</span>
<span class="comment-copy">Indeed it was extremely handy (e.g. input sanity checks) to allow comparisons between incomparable types, and to me it would seem logical to have such comparisons always return False - like when comparing numericals to NaN's. Unfortunately, this was not the case (e.g., <code>None&lt;0</code> returning <code>True</code>), and apparently in Python 3 this is handled by forbidding such comparisons altogether - a huge 'improvement' indeed ...! ;-)</span>
<span class="comment-copy">Having None compare less than everything feels much less arbitrary than having it compare greater than everything. Empty strings come before any other string, 'zero' comes before any positive integer, so intuitively, the None type comes before any other type.</span>
<span class="comment-copy">This is for Python 2.x I assume?</span>
<span class="comment-copy">the link is 2.6</span>
<span class="comment-copy">Thanks, this is a very clear answer!</span>
