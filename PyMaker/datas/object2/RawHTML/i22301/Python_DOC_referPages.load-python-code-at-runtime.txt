<div class="post-text" itemprop="text">
<p>I would like to load a <code>.py</code> file at runtime.  This <code>.py</code> file is basically a config file with the following format:</p>
<pre><code>var1=value  
var2=value  
predicate_function=func line : &lt;return true or false&gt;  
</code></pre>
<p>Once this file is loaded, I would like to be able to access <code>var1</code>, <code>var2</code> and <code>predicate_function</code>. For each line, I'll pass it to the predicate function, and if it returns false, I'll ignore it.</p>
<p>In any case, I'm not sure how to load a python file at runtime and access its variables.</p>
<p>Clarification: there may be any number of these config files that I need to pass to the main program and I won't know their names until runtime.  Google tells me I should use <code>__import__</code>.  I'm not sure how to correctly use that method and then access the variables of the imported file.</p>
</div>
<div class="post-text" itemprop="text">
<p>You just need to be able to dynamically specify the imports and then dynamically get at the variables.</p>
<p>Let's say your config file is bar.py and looks like this:</p>
<pre><code>x = 3
y = 4
def f(x): return (x&lt;4)
</code></pre>
<p>Then your code should look like this:</p>
<pre><code>import sys

# somehow modnames should be a list of strings that are the names of config files
#
# you can do this more dynamically depending on what you're doing                                                                                                     
modnames = ['bar']

for modname in modnames:
  exec('import %s' % modname)

for modname in modnames:
  mod = sys.modules[modname]
  for k in mod.__dict__:
    if k[:2] != '__':
      print modname, k, mod.__dict__[k]
</code></pre>
<p>I get this output:</p>
<pre><code>bar f &lt;function f at 0x7f2354eb4cf8&gt;
bar x 3
bar y 4
</code></pre>
<p>Then you at least have all the variables and functions. I didn't quite get what you wanted from the predicate functions, but maybe you can get that on your own now.</p>
</div>
<div class="post-text" itemprop="text">
<p>As written in the <a href="http://docs.python.org/library/functions.html#__import__" rel="noreferrer">python official documentation</a>, if you just want to import a module by name, you can look it up in the <code>sys.modules</code> dictionary after using <code>__import__</code>.</p>
<p>Supposing your configuration is in <code>myproject.mymodule</code>, you would do like that :</p>
<pre><code>module_name = 'myproject.mymodule'

import sys
__import__(module_name)
mymodule = sys.modules[module_name]

# Then you can just access your variables and functions
print mymodule.var1
print mymodule.var2
# etc...
</code></pre>
<p>You can also use the return value of <code>__import__</code> statement but you will have to understand fully <a href="http://docs.python.org/reference/executionmodel.html" rel="noreferrer">how python works with namespaces and scopes</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To access another Python module, you <em>import it</em>. <code>execfile</code> has been mentioned by a couple people, but it is messy and dangerous. <code>execfile</code> clutters your namespace, possibly even messing up the code you are running. When you want to access another Python source file, use the <code>import</code> statement.</p>
<p>Even better would be not to use a Python file for configuration at all, but rather to use the builtin module <code>ConfigParser</code> or a serialization format like JSON. This way your configuration files don't allow execution of arbitrary (possibly malicious) code, doesn't require people to know Python to configure your program, and can easily be altered programatically.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the imported module is on the regular search path, you can use <a href="http://docs.python.org/library/functions.html?highlight=__import__#__import__" rel="noreferrer"><code>__import__</code></a>.</p>
<p>If you need to load the module from an arbitrary path in the filesystem, use <a href="http://docs.python.org/library/imp.html?highlight=__import__#imp.load_module" rel="noreferrer"><code>imp.load_module</code></a>.</p>
<p>Be sure to consider the security implications of loading arbitrary user-specified code.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python <code>2.*</code>, <a href="http://docs.python.org/library/functions.html?highlight=execfile#execfile" rel="nofollow noreferrer">execfile</a> works (I recommend passing a specific dictionary and accessing the variables from there -- as the note in the docs says, <code>execfile</code> can't affect the calling function's <code>locals()</code> dictionary).</p>
<p>In Python <code>3.*</code>, execfile has been removed, so do, instead:</p>
<pre><code>with open('thefile.py') as f:
  exec(f.read(), somedict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm kinda late to the party, but I want to present an alternative answer nonetheless.</p>
<p>If you want to import code without affecting the global module namespace, you can create an anonymous module (using <code>types.ModuleType</code>) and load arbitrary code in it (using <code>compile</code> and <code>exec</code>). For instance, like this:</p>
<pre><code>import types

filename = "/path/to/your/file.py"
with open(filename) as fp:
    code = compile(fp.read(), filename, "exec")
config_module = types.ModuleType("&lt;config&gt;")
exec code in config_module.__dict__
</code></pre>
<p>You can then access the variables as <code>config_module.var1</code>, &amp;c.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to have a configuration file that will only be edited by the user when the program isn't running, just import it as a normal python file</p>
<p>ie.</p>
<p>main.py:</p>
<pre><code>import config
print config.var1
</code></pre>
<p>config.py:</p>
<pre><code>var="var12"
var2 = 100.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try the imp module : <a href="http://docs.python.org/library/imp.html" rel="nofollow">http://docs.python.org/library/imp.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Since the Python version hasn't been clearly mentioned, it is worth pointing out that the <strong>imp</strong> module has been deprecated in newer Python versions in favor of the <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow"><strong>importlib</strong></a> module. <a href="https://thomassileo.name/blog/2012/12/21/dynamically-load-python-modules-or-classes/" rel="nofollow">Example here.</a></p>
</div>
<span class="comment-copy">Worked perfectly, thanks forefinger!</span>
<span class="comment-copy">mmh, nope, in my example, it would return <code>myproject</code> module and not <code>myproject.mymodule</code>. Straight from the doc :  <i>When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name.</i></span>
<span class="comment-copy">Actually the reason I am making my config a python file is because I want the config file to contain a couple of (predicate) functions.  Otherwise I would simple read in a text file, split the strings and read into a dict.</span>
<span class="comment-copy">+1 Concise and simple (= pythonic)</span>
<span class="comment-copy">I may have any number of such config files, so I can't just do an "import configFile."  Otherwise this would be the simplest solution :)</span>
