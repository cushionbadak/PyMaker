<div class="post-text" itemprop="text">
<p>I am trying to use <code>str.encode()</code> but I get</p>
<pre><code>&gt;&gt;&gt; "hello".encode(hex)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: must be string, not builtin_function_or_method
</code></pre>
<p>I have tried a bunch of variations and they seem to all work in Python 2.5.2, so what do I need to do to get them to work in Python 3.1?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>hex</code> codec has been chucked in 3.x. Use <a href="http://docs.python.org/3.1/library/binascii.html#binascii.b2a_hex" rel="noreferrer"><code>binascii</code></a> instead:</p>
<pre><code>&gt;&gt;&gt; binascii.hexlify(b'hello')
b'68656c6c6f'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You've already got some good answers, but I thought you might be interested in a bit of the background too.</p>
<p>Firstly you're missing the quotes. It should be:</p>
<pre><code>"hello".encode("hex")
</code></pre>
<p>Secondly this codec hasn't been ported to Python 3.1. See <a href="http://bugs.python.org/issue7475" rel="noreferrer">here</a>. It seems that they haven't yet decided whether or not these codecs should be included in Python 3 or implemented in a different way.</p>
<p>If you look at the <a href="http://bugs.python.org/file15526/issue7475_missing_codecs_py3k.diff" rel="noreferrer">diff file</a> attached to that bug you can see the proposed method of implementing it:</p>
<pre><code>import binascii
output = binascii.b2a_hex(input)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>binascii methodes are easier by the way</p>
<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; x=b'test'
&gt;&gt;&gt; x=binascii.hexlify(x)
&gt;&gt;&gt; x
b'74657374'
&gt;&gt;&gt; y=str(x,'ascii')
&gt;&gt;&gt; y
'74657374'
&gt;&gt;&gt; x=binascii.unhexlify(x)
&gt;&gt;&gt; x
b'test'
&gt;&gt;&gt; y=str(x,'ascii')
&gt;&gt;&gt; y
'test'
</code></pre>
<p>Hope it helps. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, encode the string to bytes and use the <code>hex()</code> method, returning a string.</p>
<pre><code>s = "hello".encode("utf-8").hex()
s
# '68656c6c6f'
</code></pre>
<p>Optionally convert the string back to bytes:</p>
<pre><code>b = bytes(s, "utf-8")
b
# b'68656c6c6f'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, all strings are unicode. Usually, if you encode an unicode object to a string, you use <code>.encode('TEXT_ENCODING')</code>, since <code>hex</code> is not a text encoding, you should use <code>codecs.encode()</code> to handle arbitrary codecs. For example:</p>
<pre><code>&gt;&gt;&gt;&gt; "hello".encode('hex')
LookupError: 'hex' is not a text encoding; use codecs.encode() to handle arbitrary codecs
&gt;&gt;&gt;&gt; import codecs
&gt;&gt;&gt;&gt; codecs.encode(b"hello", 'hex')
b'68656c6c6f'
</code></pre>
<p>Again, since "hello" is unicode, you need to indicate it as a byte string before encoding to hexadecimal. This may be more inline with what your original approach of using the <code>encode</code> method.</p>
<p>The differences between <strong><code>binascii.hexlify</code></strong> and <strong><code>codecs.encode</code></strong> are as follow:</p>
<ul>
<li><p><strong>binascii.hexlify</strong></p>
<p>Hexadecimal representation of binary data.</p>
<p>The return value is a bytes object.</p>
<p>Type:      builtin_function_or_method</p></li>
<li><p><strong>codecs.encode</strong></p>
<p>encode(obj, [encoding[,errors]]) -&gt; object</p>
<p>Encodes obj using the codec registered for encoding. encoding defaults
to the default encoding. errors may be given to set a different error
handling scheme. Default is 'strict' meaning that encoding errors raise
a ValueError. Other possible values are 'ignore', 'replace' and
'xmlcharrefreplace' as well as any other name registered with
codecs.register_error that can handle ValueErrors.</p>
<p>Type:      builtin_function_or_method</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/dev/library/base64.html#base64.b16encode" rel="nofollow noreferrer"><code>base64.b16encode</code></a> and <a href="http://docs.python.org/dev/library/base64.html#base64.b16decode" rel="nofollow noreferrer"><code>base64.b16decode</code></a> convert bytes to and from hex and work across all Python versions.  The <a href="https://stackoverflow.com/a/16033232/">codecs approach</a> also works, but is less straightforward in Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use hexlify - <a href="http://epydoc.sourceforge.net/stdlib/binascii-module.html" rel="nofollow noreferrer">http://epydoc.sourceforge.net/stdlib/binascii-module.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another method:</p>
<pre><code>s = 'hello'

h = ''.join([hex(ord(i)) for i in s]);

# outputs: '0x680x650x6c0x6c0x6f'
</code></pre>
<p>This basically splits the string into chars, does the conversion through <code>hex(ord(char))</code>, and joins the chars back together. In case you want the result without the prefix <code>0x</code> then do:</p>
<pre><code>h = ''.join([str(hex(ord(i)))[2:4] for i in s]);

# outputs: '68656c6c6f'
</code></pre>
<p>Tested with Python 3.5.3.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>The easiest way to do it in Python 3.x is:</strong></p>
<pre><code>&gt;&gt;&gt; 'halo'.encode().hex()
'68616c6f'
</code></pre>
<p><strong>If you manually enter a string into a Python Interpreter</strong> using the <code>utf-8</code> characters, you can do it even faster by typing <code>b</code> before the string:</p>
<pre><code>&gt;&gt;&gt; b'halo'.hex()
'68616c6f'
</code></pre>
<p><strong>Equivalent in Python 2.x:</strong></p>
<pre><code>&gt;&gt;&gt; 'halo'.encode('hex')
'68616c6f'
</code></pre>
</div>
<span class="comment-copy">@S.Lott: <a href="http://en.wiktionary.org/wiki/shuck#Verb" rel="nofollow noreferrer">en.wiktionary.org/wiki/shuck#Verb</a> sense 2</span>
<span class="comment-copy">thank you, just what I was looking for</span>
<span class="comment-copy">BTW, binary codes made a comeback in version 3.2, <a href="https://docs.python.org/3/library/codecs.html#binary-transforms" rel="nofollow noreferrer">see docs</a></span>
<span class="comment-copy">What if my string is stored in a variable?</span>
<span class="comment-copy">That gives an error, because the argument has to be a bytes-like object.</span>
<span class="comment-copy">Code worked in Python 3.3.2</span>
<span class="comment-copy">Thanks a lot! Saved me a lot of time and some code!!!</span>
<span class="comment-copy">binascii is also faster than the other methods. Just tested with timeit.</span>
<span class="comment-copy">How do you do string to hex conversion, if the string is a regular Python 3 string, not binary or a constant?</span>
<span class="comment-copy">This the way to do it for a Python 3 string variable. Lot of the answers here are regarding constants. A practical code is rarely that.</span>
<span class="comment-copy">This is exactly what I needed! A cross-python version way of hex encoding &amp; decoding. Thanks ^_^  <code>&gt;&gt;&gt; import base64 &gt;&gt;&gt; key = base64.b16encode(b'0123456789abcdef') &gt;&gt;&gt; base64.b16decode(key) '0123456789abcdef'</code></span>
<span class="comment-copy">I wonder why it's called "hexlify"</span>
<span class="comment-copy">It was shorter than "hexlificationize" :^)</span>
