<div class="post-text" itemprop="text">
<p>How can I raise an exception in Python so that it can later be caught via an <code>except</code> block?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>How do I manually throw/raise an exception in Python?</h2>
</blockquote>
<p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="noreferrer">Use the most specific Exception constructor that semantically fits your issue</a>.  </p>
<p>Be specific in your message, e.g.:</p>
<pre><code>raise ValueError('A very specific bad thing happened.')
</code></pre>
<h2>Don't raise generic exceptions</h2>
<p>Avoid raising a generic Exception. To catch it, you'll have to catch all other more specific exceptions that subclass it.</p>
<h3>Problem 1: Hiding bugs</h3>
<pre><code>raise Exception('I know Python!') # Don't! If you catch, likely to hide bugs.
</code></pre>
<p>For example:</p>
<pre><code>def demo_bad_catch():
    try:
        raise ValueError('Represents a hidden bug, do not catch this')
        raise Exception('This is the exception you expect to handle')
    except Exception as error:
        print('Caught this error: ' + repr(error))

&gt;&gt;&gt; demo_bad_catch()
Caught this error: ValueError('Represents a hidden bug, do not catch this',)
</code></pre>
<h3>Problem 2: Won't catch</h3>
<p>and more specific catches won't catch the general exception:</p>
<pre><code>def demo_no_catch():
    try:
        raise Exception('general exceptions not caught by specific handling')
    except ValueError as e:
        print('we will not catch exception: Exception')


&gt;&gt;&gt; demo_no_catch()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in demo_no_catch
Exception: general exceptions not caught by specific handling
</code></pre>
<h2>Best Practices: <code>raise</code> statement</h2>
<p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="noreferrer">Instead, use the most specific Exception constructor that semantically fits your issue</a>.</p>
<pre><code>raise ValueError('A very specific bad thing happened')
</code></pre>
<p>which also handily allows an arbitrary number of arguments to be passed to the constructor:</p>
<pre><code>raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz') 
</code></pre>
<p>These arguments are accessed by the <code>args</code> attribute on the Exception object. For example:</p>
<pre><code>try:
    some_code_that_may_raise_our_value_error()
except ValueError as err:
    print(err.args)
</code></pre>
<p>prints </p>
<pre><code>('message', 'foo', 'bar', 'baz')    
</code></pre>
<p>In Python 2.5, an actual <code>message</code> attribute was added to BaseException in favor of encouraging users to subclass Exceptions and stop using <code>args</code>, but <a href="http://www.python.org/dev/peps/pep-0352/#retracted-ideas" rel="noreferrer">the introduction of <code>message</code> and the original deprecation of args has been retracted</a>.</p>
<h2>Best Practices: <code>except</code> clause</h2>
<p>When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example:</p>
<pre><code>logger = logging.getLogger(__name__)

try:
    do_something_in_app_that_breaks_easily()
except AppError as error:
    logger.error(error)
    raise                 # just this!
    # raise AppError      # Don't do this, you'll lose the stack trace!
</code></pre>
<h3>Don't modify your errors... but if you insist.</h3>
<p>You can preserve the stacktrace (and error value) with <code>sys.exc_info()</code>, but <strong>this is way more error prone</strong> and <strong>has compatibility problems between Python 2 and 3</strong>, prefer to use a bare <code>raise</code> to re-raise. </p>
<p>To explain - the <code>sys.exc_info()</code> returns the type, value, and traceback. </p>
<pre><code>type, value, traceback = sys.exc_info()
</code></pre>
<p>This is the syntax in Python 2 - note this is not compatible with Python 3:</p>
<pre><code>    raise AppError, error, sys.exc_info()[2] # avoid this.
    # Equivalently, as error *is* the second object:
    raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]
</code></pre>
<p>If you want to, you can modify what happens with your new raise - e.g. setting new args for the instance:</p>
<pre><code>def error():
    raise ValueError('oops!')

def catch_error_modify_message():
    try:
        error()
    except ValueError:
        error_type, error_instance, traceback = sys.exc_info()
        error_instance.args = (error_instance.args[0] + ' &lt;modification&gt;',)
        raise error_type, error_instance, traceback
</code></pre>
<p>And we have preserved the whole traceback while modifying the args. Note that this is <strong>not a best practice</strong> and it is <strong>invalid syntax</strong> in Python 3 (making keeping compatibility much harder to work around).</p>
<pre><code>&gt;&gt;&gt; catch_error_modify_message()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in catch_error_modify_message
  File "&lt;stdin&gt;", line 2, in error
ValueError: oops! &lt;modification&gt;
</code></pre>
<p>In <a href="https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement" rel="noreferrer">Python 3</a>:</p>
<pre><code>    raise error.with_traceback(sys.exc_info()[2])
</code></pre>
<p>Again: avoid manually manipulating tracebacks. It's <a href="https://docs.python.org/2/reference/simple_stmts.html#the-raise-statement" rel="noreferrer">less efficient</a> and more error prone. And if you're using threading and <code>sys.exc_info</code> you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.)</p>
<h3>Python 3, Exception chaining</h3>
<p>In Python 3, you can chain Exceptions, which preserve tracebacks:</p>
<pre><code>    raise RuntimeError('specific message') from error
</code></pre>
<p>Be aware:</p>
<ul>
<li>this <em>does</em> allow changing the error type raised, and</li>
<li>this is <em>not</em> compatible with Python 2.</li>
</ul>
<h3>Deprecated Methods:</h3>
<p>These can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, <strong>but not the one intended!</strong></p>
<p><a href="http://www.python.org/dev/peps/pep-3109/" rel="noreferrer">Valid in Python 2, but not in Python 3</a> is the following:</p>
<pre><code>raise ValueError, 'message' # Don't do this, it's deprecated!
</code></pre>
<p>Only <a href="https://docs.python.org/2/whatsnew/2.5.html#pep-352-exceptions-as-new-style-classes" rel="noreferrer">valid in much older versions of Python</a> (2.4 and lower), you may still see people raising strings:</p>
<pre><code>raise 'message' # really really wrong. don't do this.
</code></pre>
<p>In all modern versions, this will actually raise a TypeError, because you're not raising a BaseException type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production.</p>
<h2>Example Usage</h2>
<p>I raise Exceptions to warn consumers of my API if they're using it incorrectly:</p>
<pre><code>def api_func(foo):
    '''foo should be either 'baz' or 'bar'. returns something very useful.'''
    if foo not in _ALLOWED_ARGS:
        raise ValueError('{foo} wrong, use "baz" or "bar"'.format(foo=repr(foo)))
</code></pre>
<h2>Create your own error types when apropos</h2>
<blockquote>
<p><strong>"I want to make an error on purpose, so that it would go into the except"</strong></p>
</blockquote>
<p>You can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy:</p>
<pre><code>class MyAppLookupError(LookupError):
    '''raise this when there's a lookup error for my app'''
</code></pre>
<p>and usage:</p>
<pre><code>if important_key not in resource_dict and not ok_to_be_missing:
    raise MyAppLookupError('resource is missing, and that is not ok.')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>DON'T DO THIS</strong>. Raising a bare <code>Exception</code> is absolutely <strong>not</strong> the right thing to do; see <a href="https://stackoverflow.com/a/24065533">Aaron Hall's excellent answer</a> instead.</p>
</blockquote>
<p>Can't get much more pythonic than this:</p>
<pre><code>raise Exception("I know python!")
</code></pre>
<p>See <a href="http://docs.python.org/reference/simple_stmts.html#the-raise-statement" rel="nofollow noreferrer">the raise statement docs</a> for python if you'd like more info.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the common case where you need to throw an exception in response to some unexpected conditions, and that you never intend to catch, but simply to fail fast to enable you to debug from there if it ever happens â€” the most logical one seems to be <code>AssertionError</code>:</p>
<pre><code>if 0 &lt; distance &lt;= RADIUS:
    #Do something.
elif RADIUS &lt; distance:
    #Do something.
else:
    raise AssertionError("Unexpected value of 'distance'!", distance)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python3 there are 4 different syntaxes for rasing exceptions: </p>
<pre><code>1. raise exception 
2. raise exception (args) 
3. raise
4. raise exception (args) from original_exception
</code></pre>
<blockquote>
<p><strong>1. raise exception vs. 2. raise exception (args)</strong></p>
</blockquote>
<p>If you use <code>raise exception (args)</code>  to raise an exception then the   <code>args</code> will be printed when you print the exception object - as shown in the example below. </p>
<pre><code>  #raise exception (args)
    try:
        raise ValueError("I have raised an Exception")
    except ValueError as exp:
        print ("Error", exp)     # Output -&gt; Error I have raised an Exception 



  #raise execption 
    try:
        raise ValueError
    except ValueError as exp:
        print ("Error", exp)     # Output -&gt; Error 
</code></pre>
<blockquote>
<p><strong>3.raise</strong></p>
</blockquote>
<p><code>raise</code> statement without any arguments re-raises the last exception. 
This is useful if you need to perform some actions after catching the exception and  then want to re-raise it. But if there was no exception before, <code>raise</code> statement raises  <code>TypeError</code> Exception. </p>
<pre><code>def somefunction():
    print("some cleaning")

a=10
b=0 
result=None

try:
    result=a/b
    print(result)

except Exception:            #Output -&gt;
    somefunction()           #some cleaning
    raise                    #Traceback (most recent call last):
                             #File "python", line 8, in &lt;module&gt;
                             #ZeroDivisionError: division by zero
</code></pre>
<blockquote>
<p><strong>4. raise exception (args) from original_exception</strong></p>
</blockquote>
<p>This statement is used to create exception chaining in which an exception that is raised in response to another exception can contain the details of the original exception - as shown in the example below.</p>
<pre><code>class MyCustomException(Exception):
pass

a=10
b=0 
reuslt=None
try:
    try:
        result=a/b

    except ZeroDivisionError as exp:
        print("ZeroDivisionError -- ",exp)
        raise MyCustomException("Zero Division ") from exp

except MyCustomException as exp:
        print("MyException",exp)
        print(exp.__cause__)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>ZeroDivisionError --  division by zero
MyException Zero Division 
division by zero
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Read the existing answers first, this is just an addendum.</em></p>
<p>Notice that you can raise exceptions with or without arguments.</p>
<p>Example:</p>
<pre><code>raise SystemExit
</code></pre>
<p>exits the program but you might want to know what happened.So you can use this.</p>
<pre><code>raise SystemExit("program exited")
</code></pre>
<p>this will print "program exited" to stderr before closing the program.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way to throw an exceptions is <a href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="nofollow noreferrer"><code>assert</code></a>. You can use assert to verify a condition is being fulfilled if not then it will raise <code>AssertionError</code>. For more details have a look <a href="https://www.programiz.com/python-programming/assert-statement" rel="nofollow noreferrer">here</a>.</p>
<pre><code>def avg(marks):
    assert len(marks) != 0,"List is empty."
    return sum(marks)/len(marks)

mark2 = [55,88,78,90,79]
print("Average of mark2:",avg(mark2))

mark1 = []
print("Average of mark1:",avg(mark1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just to note: there are times when you DO want to handle generic exceptions. If you're processing a bunch of files and logging your errors, you might want to catch any error that occurs for a file, log it, and continue processing the rest of the files. In that case, a <code>try except Exception:</code> block a good way to do it. You'll still want to <code>raise</code> specific exceptions so you know what they mean, though.</p>
</div>
<span class="comment-copy">Thanks for this, it's exactly what I needed. The bare <code>raise</code> is what I needed to be able to perform custom error debugging at multiple levels of code execution without breaking the stack trace.</span>
<span class="comment-copy">This is a great answer. But I still work with a lot of 2.7 code, and I often find myself wanting to add information to an unexpected exception, like an input file position or the values of some variables, but keep the original stack and exception. I can log it, but sometimes I don't want it logged, e.g. if parent code ultimately handles it. <code>raise sys.exc_info()[0], (sys.exc_info()[1], my_extra_info), sys.exc_info()[2]</code> seems to do what I want, and I've never run into problems with it. But it feels hacky, and not an accepted practice. Is there a better way?</span>
<span class="comment-copy">Thanks for the compliment - but sadly enough, there is not a better way - not on Python 2.</span>
<span class="comment-copy">@brennanyoung In that context I think it could be confusing to raise a SyntaxError - probably you should raise a custom exception. I explain how to here: <a href="https://stackoverflow.com/a/26938914/541136">stackoverflow.com/a/26938914/541136</a></span>
<span class="comment-copy">Note that the full quote is "All built-in, non-system-exiting exceptions are derived from this class. All user-defined exceptions should also be derived from this class." - That mostly means that you shouldn't use one of the 4 exceptions that don't derive from <code>Exception</code> as your parent class - you can subclass something more specific, and should do so if it makes sense.</span>
<span class="comment-copy">No please!  This removes the potential to be specific about what you catch.  It is ENTIRELY the wrong way to do it.  Take a look at Aaron Hall's excellent answer instead of this one.  It's times like this I wish I could give more than one downvote per answer.</span>
<span class="comment-copy">@DavidWallace it's terrible that this has so many upvotes :(</span>
<span class="comment-copy">@PeterR It's equally terrible that it has so few downvotes.  To ANYBODY reading this answer, DO NOT DO THIS EVER!  The correct answer is Aaron Hall's one.</span>
<span class="comment-copy">I think there should be a more detailed explanation on why this is wrong or so bad.</span>
<span class="comment-copy">@CharlieParker There is. It's the first part of <a href="http://stackoverflow.com/a/24065533">Aaron Hall's answer</a>.</span>
<span class="comment-copy">This is a better case for <code>ValueError</code> than <code>AssertionError</code> because there's no problem with an assertion (because none is being made here) -- the problem is with a value. If you really want an <code>AssertionError</code> in this case, write <code>assert distance &gt; 0, 'Distance must be positive'</code>. But you shouldn't error check that way because assertions can be turned off (<code>python -O</code>).</span>
<span class="comment-copy">@Two-BitAlchemist Good point. The idea was lost in simplification, when I wrote the simple example above. In many similar cases it's a condition that isn't associated with a particular value. Rather, the meaning is "control flow should never get here".</span>
<span class="comment-copy">@Two-BitAlchemist Assertions can be turned off, yes, but then you shouldn't use them to error check at all?</span>
<span class="comment-copy">Well it depends. I wouldn't let that be my only error checking in a program I intended to distribute. On the other hand, I could make a program just for my co-workers and tell them they use it at their own risk if they run it with <code>-O</code>.</span>
<span class="comment-copy">@Two-BitAlchemist For me the role of assertions isn't error-checking per se (which is what testing is for), but they set up fences within the code that certain bugs can't get through. So it becomes easier to track down and isolate the bugs, which will inevitably occur. This is just good habits that take little effort, while testing takes a lot of effort and a lot of time.</span>
