<div class="post-text" itemprop="text">
<p>I've been trying to find a way to get the time since 1970-01-01 00:00:00 UTC in seconds and nanoseconds in python and I cannot find anything that will give me the proper precision.</p>
<p>I have tried using time module, but that precision is only to microseconds, so the code I tried was:</p>
<pre><code>import time

print time.time()
</code></pre>
<p>which gave me a result like this:</p>
<pre><code>1267918039.01
</code></pre>
<p>However, I need a result that looks like this:</p>
<pre><code>1267918039.331291406
</code></pre>
<p>Does anyone know a possible way to express UNIX time in seconds and nanoseconds?  I cannot find a way to set the proper precision or get a result in the correct format.  Thank you for any help</p>
</div>
<div class="post-text" itemprop="text">
<p>Your precision is just being lost due to string formatting:</p>
<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; print "%.20f" % time.time()
1267919090.35663390159606933594
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is probably related to your OS, not Python. See the documentation of the <code>time</code> module: <a href="http://docs.python.org/library/time.html" rel="noreferrer">http://docs.python.org/library/time.html</a></p>
<blockquote>
<p><code>time.</code><strong><code>time()</code></strong></p>
<p>Return the time as a floating point
  number expressed in seconds since the
  epoch, in UTC. Note that even though
  the time is always returned as a
  floating point number, <strong>not all
  systems provide time with a better
  precision than 1 second</strong>. While this
  function normally returns
  non-decreasing values, it can return a
  lower value than a previous call if
  the system clock has been set back
  between the two calls.</p>
</blockquote>
<p>In other words: if your OS can't do it, Python can't do it. You can multiply the return value by the appropriate order of magnitude in order to get the nanosecond value, though, imprecise as it may be.</p>
<p>EDIT: The return is a float variable, so the number of digits after the comma will vary, whether your OS has that level of precision or not. You can format it with <code>"%.nf"</code> where <code>n</code> is the number of digits you want, though, if you want a fixed point string representation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <em>Python 3.7</em> it's easy to achieve with <a href="https://docs.python.org/3.7/library/time.html#time.time_ns" rel="noreferrer"><code>time.time_ns()</code></a></p>
<blockquote>
<p>Similar to <code>time()</code> but returns time as an integer number of nanoseconds since the epoch.</p>
</blockquote>
<p>All new features that includes nanoseconds in Python 3.7 release:
<a href="https://docs.python.org/3.7/whatsnew/3.7.html#pep-564-add-new-time-functions-with-nanosecond-resolution" rel="noreferrer">PEP 564: Add new time functions with nanosecond resolution</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on the type of clock and your OS and hardware wether or not you can even get nanosecond precision <em>at all</em>. From the <a href="https://docs.python.org/3/library/time.html#time.get_clock_info" rel="noreferrer"><code>time</code> module documentation</a>:</p>
<blockquote>
<p>The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock “ticks” only 50 or 100 times a second.</p>
</blockquote>
<p>On Python 3, the <code>time</code> module gives you access to 5 different types of clock, each with different properties; some of these <strong>may</strong> offer you nanosecond precision timing. Use the <a href="https://docs.python.org/3/library/time.html#time.get_clock_info" rel="noreferrer"><code>time.get_clock_info()</code> function</a> to see what features each clock offers and what precision time is reported in.</p>
<p>On my OS X 10.11 laptop, the features available are:</p>
<pre><code>&gt;&gt;&gt; for name in ('clock', 'monotonic', 'perf_counter', 'process_time', 'time'):
...     print(name, time.get_clock_info(name), sep=': ')
...
clock: namespace(adjustable=False, implementation='clock()', monotonic=True, resolution=1e-06)
monotonic: namespace(adjustable=False, implementation='mach_absolute_time()', monotonic=True, resolution=1e-09)
perf_counter: namespace(adjustable=False, implementation='mach_absolute_time()', monotonic=True, resolution=1e-09)
process_time: namespace(adjustable=False, implementation='getrusage(RUSAGE_SELF)', monotonic=True, resolution=1e-06)
time: namespace(adjustable=True, implementation='gettimeofday()', monotonic=False, resolution=1e-06)
</code></pre>
<p>so using the <a href="https://docs.python.org/3/library/time.html#time.monotonic" rel="noreferrer"><code>time.monotonic()</code></a> or <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer"><code>time.perf_counter()</code></a> functions would theoretically give me nanosecond resolution. Neither clock gives me <em>wall time</em>, only elapsed time; the values are otherwise arbitrary. They are however useful for measuring <em>how long</em> something took.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is unlikely that you will actually get nanosecond precision from any current machine.</p>
<p>The machine can't create precision, and displaying significant digits where not appropriate is not The Right Thing To Do.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there's a platform-independent way (maybe some third party has coded one, but I can't find it) to get time in nanoseconds; you need to do it in a platform-specific way.  For example, <a href="https://stackoverflow.com/questions/1205722/how-do-i-get-monotonic-time-durations-in-python">this SO question</a>'s answer shows how to do it on platform that supply a <code>librt.so</code> system library for "realtime" operations.</p>
</div>
<span class="comment-copy">@GregS: persistence comes with age :)</span>
<span class="comment-copy">Actually I can imagine that it is accurate to so many decimal places, but there is precision! :)</span>
<span class="comment-copy">you mean that it is <i>not</i> accurate to so many decimal places. <a href="http://stackoverflow.com/a/28574340/4279"><code>time.time()</code> on recent CPython uses the <code>clock_gettime(2)</code>, <code>GetSystemTimeAsFileTime()</code> depening on OS (you can call them on earlier Python versions too</a>) -- though probably the system time is not accurate enough even for old microseconds-based interfaces.</span>
<span class="comment-copy">It's impossible to get nanosecond precision since 1970-04-15 from time.time no mater what formatting you are using, because time.time return float and it only have 53 bits significand precision which can only represent roughly 104 days in nanoseconds precision(9007199254740992 nanoseconds).</span>
<span class="comment-copy">I think the problem may be neither with the OS nor python... the problem is that there should be a way to get metadata on which is the greatest precision of time currently supported and a way to get time in that, and that we do not know it. :)</span>
