<div class="post-text" itemprop="text">
<p>I receive a 'HTTP Error 500: Internal Server Error' response, but I still want to read the data inside the error HTML.</p>
<p>With Python 2.6, I normally fetch a page using:</p>
<pre><code>import urllib2
url = "http://google.com"
data = urllib2.urlopen(url)
data = data.read()
</code></pre>
<p>When attempting to use this on the failing URL, I get the exception <code>urllib2.HTTPError</code>:</p>
<pre><code>urllib2.HTTPError: HTTP Error 500: Internal Server Error
</code></pre>
<p>How can I fetch such error pages (with or without <code>urllib2</code>), all while they are returning Internal Server Errors?</p>
<p>Note that with Python 3, the corresponding exception is <code>urllib.error.HTTPError</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>HTTPError</code> <a href="https://docs.python.org/3/library/urllib.error.html#urllib.error.HTTPError" rel="nofollow noreferrer">is a file-like object</a>.  You can catch it and then <code>read</code> its contents.</p>
<pre><code>try:
    resp = urllib2.urlopen(url)
    contents = resp.read()
except urllib2.HTTPError, error:
    contents = error.read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you mean you want to read the body of the 500:</p>
<pre><code>request = urllib2.Request(url, data, headers)
try:
        resp = urllib2.urlopen(request)
        print resp.read()
except urllib2.HTTPError, error:
        print "ERROR: ", error.read()
</code></pre>
<p>In your case, you don't need to build up the request.  Just do</p>
<pre><code>try:
        resp = urllib2.urlopen(url)
        print resp.read()
except urllib2.HTTPError, error:
        print "ERROR: ", error.read()
</code></pre>
<p>so, you don't override urllib2.HTTPError, you just handle the exception.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>alist=['http://someurl.com']

def testUrl():
    errList=[]
    for URL in alist:
        try:
            urllib2.urlopen(URL)
        except urllib2.URLError, err:
            (err.reason != 200)
            errList.append(URL+" "+str(err.reason))
            return URL+" "+str(err.reason)
    return "".join(errList)

testUrl()
</code></pre>
</div>
<span class="comment-copy">Once we have done error.read(), error.read() subsequently returns empty string. Sometimes this messes up code elsewhere. How can we politely put the contents of the error back for others?</span>
<span class="comment-copy">@Matt I've never tried this, but since it's a file-like object, you might be able to do a <code>error.seek(0)</code> to reset the "file pointer" to the beginning of the stream.  Not every file-like object is required to implement the random access portion of the I/O interface, so not sure if it works. If it doesn't, you might consider asking this in its own question so you'll tap a bigger audience.</span>
<span class="comment-copy">Note that in degenerate cases HTTPError may not behave as a file-like object. Verify that read() is available with hasattr.</span>
<span class="comment-copy">Since the underlying stream is an http response, it is non-seekable, meaning that you cannot call <code>seek()</code> on it.</span>
<span class="comment-copy">but the error is being returned as binary</span>
<span class="comment-copy">No, I want to read the HTML the server would send to the user's browser if they accidentally went to one of the 500 internal error pages.  Just like, if urllib broke on any 404 page (I'm not sure if it does, I haven't tried), I want to read the html the 404 page provides (E.G. if the site does a custom 404 page).</span>
<span class="comment-copy">you should add descriptive text to your answer</span>
<span class="comment-copy"><code>err.reason</code> does not actually provide the same info that <code>err.read()</code> provides. The later can be more specifically useful.</span>
