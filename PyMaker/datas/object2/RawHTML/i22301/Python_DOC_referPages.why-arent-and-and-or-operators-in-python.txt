<div class="post-text" itemprop="text">
<p>I wasn't aware of this, but apparently the <code>and</code> and <code>or</code> keywords aren't operators.  They don't appear in the <a href="http://docs.python.org/reference/lexical_analysis.html#operators" rel="noreferrer">list of python operators</a>.  Just out of sheer curiosity, why is this?  And if they aren't operators, what exactly are they?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because they're control flow constructs. Specifically:</p>
<ul>
<li>if the left argument to <code>and</code> evaluates to False, the right argument doesn't get evaluated at all</li>
<li>if the left argument to <code>or</code> evaluates to True, the right argument doesn't get evaluated at all</li>
</ul>
<p>Thus, it is not simply a matter of being reserved words. They don't behave like operators, since operators always evaluate all of their arguments.</p>
<p>You can contrast this with bitwise binary operators which, as the name implies, <em>are</em> operators:</p>
<pre><code>&gt;&gt;&gt; 1 | (1/0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero
&gt;&gt;&gt; 1 or (1/0)
1
</code></pre>
<p>As you see, the bitwise OR (<code>|</code>) evaluates both its arguments. The <code>or</code> keyword, however, doesn't evaluate its right argument at all when the left argument evaluates to True; that's why no <code>ZeroDivisionError</code> is raised in the second statement.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Python does not currently provide any '<strong>xxx</strong>' special methods corresponding to the 'and', 'or' and 'not' boolean operators. In the case of 'and' and 'or', the most likely reason is that these operators have short-circuiting semantics, i.e. the second operand is not evaluated if the result can be determined from the first operand. The usual technique of providing special methods for these operators therefore would not work.</p>
</blockquote>
<p>Source: <a href="http://www.python.org/dev/peps/pep-0335/" rel="nofollow noreferrer">PEP 335</a></p>
<p>PEP 335 talks about adding the ability to have overloadable operators, and discusses this issue a bit. </p>
</div>
<div class="post-text" itemprop="text">
<p>They're classifying them as keywords earlier in the document.</p>
</div>
<div class="post-text" itemprop="text">
<p>They're <a href="http://docs.python.org/reference/lexical_analysis.html#keywords" rel="nofollow noreferrer">keywords</a>, because they're reserved identifiers, not special tokens of symbols.</p>
</div>
<div class="post-text" itemprop="text">
<p>They can't be redefined to support type-specific operations, so they don't fall under the scope of the other operators.</p>
</div>
<div class="post-text" itemprop="text">
<p>The list you're looking at is in the section of the docs describing Python's <em>lexical</em> structure: what kinds of tokens Python code is composed of. In terms of the lexical structure, all tokens with the structure of an identifier are classified as <em>identifiers</em> or <em>keywords</em>, regardless of their semantic role. That includes all tokens made of letters.</p>
<p><code>and</code> and <code>or</code> appear in the <a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords" rel="nofollow noreferrer">list of keyword tokens</a> rather than the list of operator tokens because they are composed of letters:</p>
<pre><code>False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
</code></pre>
<p>If they were spelled <code>&amp;&amp;</code> and <code>||</code> instead of <code>and</code> and <code>or</code>, they would have appeared in the list of operator tokens.</p>
<p>In sections of the docs that aren't talking about the lexical structure, <code>and</code> and <code>or</code> are considered operators. For example, they're listed under the Operator column in the <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">operator precedence table</a>.</p>
</div>
<span class="comment-copy">Note, in C, <code>&amp;&amp;</code> and <code>||</code> are called "operators" even though they're short-circuiting (don't evaluate the right-hand side depending on the left-hand side's value). Similarly for some other languages.</span>
<span class="comment-copy">Yes, I agree the terminology can be varying. The main point though is that they have fundamentally different characteristics than what Python generally calls operators.</span>
<span class="comment-copy">This is not the reason. If this were the reason, then operators like <code>in</code> would be in the list. <code>and</code>, <code>or</code>, and all other operators composed of letters aren't in the list of operators because that list is about token classification in Python's lexical structure, and tokens made of letters are all classified as identifiers or keywords, regardless of their semantic role.</span>
<span class="comment-copy">In parts of the docs that <i>aren't</i> talking about token structure, such as the <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">operator precedence table</a>, <code>and</code> and <code>or</code> are classified as operators.</span>
<span class="comment-copy">It's not about overloading. <code>in</code> is overloadable, but <code>in</code> isn't in the list. Also, your PEP quote even refers to <code>and</code> and <code>or</code> as operators.</span>
<span class="comment-copy">True, but that doesn't really mean anything other than that they can't be used as variable names.</span>
<span class="comment-copy">The URL the OP linked to has to do with lexical analysis, and lexically, they're keywords, not operators.  If the question was phrased as one of syntax, then the down-vote would make sense.</span>
<span class="comment-copy">I suspect your causation is wrong.  They can't be redefined to support type-specific operations because they're not operators.</span>
<span class="comment-copy"><code>in</code> is overloadable, but <code>in</code> isn't on the list.</span>
