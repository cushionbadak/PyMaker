<div class="post-text" itemprop="text">
<p>I'd like to get from this:</p>
<pre><code>keys = [1,2,3]
</code></pre>
<p>to this:</p>
<pre><code>{1: None, 2: None, 3: None}
</code></pre>
<p>Is there a pythonic way of doing it?</p>
<p>This is an ugly way to do it:</p>
<pre><code>&gt;&gt;&gt; keys = [1,2,3]
&gt;&gt;&gt; dict([(1,2)])
{1: 2}
&gt;&gt;&gt; dict(zip(keys, [None]*len(keys)))
{1: None, 2: None, 3: None}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dict.fromkeys([1, 2, 3, 4])</code></p>
<p>This is actually a classmethod, so it works for dict-subclasses (like <code>collections.defaultdict</code>) as well. The optional second argument specifies the value to use for the keys (defaults to <code>None</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>nobody cared to give a dict-comprehension solution ?</p>
<pre><code>&gt;&gt;&gt; keys = [1,2,3,5,6,7]
&gt;&gt;&gt; {key: None for key in keys}
{1: None, 2: None, 3: None, 5: None, 6: None, 7: None}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>dict.fromkeys(keys, None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; keyDict = {"a","b","c","d"}

&gt;&gt;&gt; dict([(key, []) for key in keyDict])
</code></pre>
<p>Output:</p>
<pre><code>{'a': [], 'c': [], 'b': [], 'd': []}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d = {}
for i in keys:
    d[i] = None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In <em>many</em> workflows where you want to attach a default / initial value for arbitrary keys, you don't <em>need</em> to hash each key individually ahead of time. You can use <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>. For example:</p>
<pre><code>from collections import defaultdict

d = defaultdict(lambda: None)

print(d[1])  # None
print(d[2])  # None
print(d[3])  # None
</code></pre>
<p>This is more efficient, it saves having to hash all your keys at instantiation. Moreover, <code>defaultdict</code> is a subclass of <code>dict</code>, so there's usually no need to convert back to a regular dictionary.</p>
<p>For workflows where you <em>require</em> controls on permissible keys, you can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.fromkeys" rel="nofollow noreferrer"><code>dict.fromkeys</code></a> as per the accepted answer:</p>
<pre><code>d = dict.fromkeys([1, 2, 3, 4])
</code></pre>
</div>
<span class="comment-copy">Be careful with initializing to something mutable:  If you call, e.g., <code>dict.fromkeys([1, 2, 3], [])</code>, all of the keys are mapped to the same list, and modifying one will modify them all.</span>
<span class="comment-copy">This only works in Python 3.x</span>
<span class="comment-copy">I believe it was backported to 2.7</span>
<span class="comment-copy">This is nice and doesn't suffer from the reference issue that the accepted answer does.</span>
<span class="comment-copy">This also allows you to assign a default value (e.g. <code>False</code>).</span>
<span class="comment-copy">Using a dict-comp also allows the value to be the result of calling a function (which could be passed the key as an argument, if desired) â€” so is a very powerful mechanism.</span>
<span class="comment-copy">awesome, i wanted empty lists, <code>dict.fromkeys(keys, [])</code></span>
<span class="comment-copy">@muon That is almost certainly not what you want, see <a href="http://stackoverflow.com/questions/2241891/how-to-initialize-a-dict-with-keys-from-a-list-and-empty-value-in-python#comment25131847_2241904">charleslparker comment</a>.</span>
<span class="comment-copy">@gerrit whats the right way then, you know?</span>
<span class="comment-copy">Works in Python version 2.6.6.</span>
<span class="comment-copy">While this code may answer the question, providing additional context regarding <i>how</i> and/or <i>why</i> it solves the problem would improve the answer's long-term value.</span>
<span class="comment-copy">the name <code>keyDict</code> is misleading, as the first line of code returns a <code>set</code>, not a <code>dict</code>.</span>
<span class="comment-copy">Why does Python throw out an error like: <code>TypeError: 'type' object is not iterable</code>?</span>
<span class="comment-copy">@FrancescoCastellani Because <code>list</code> is a type. Unless you have something like <code>list = []</code>, the above method will always give you the same error</span>
