<div class="post-text" itemprop="text">
<p>Recently, a correspondent mentioned <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-long-complex" rel="nofollow noreferrer"><code>float.as_integer_ratio()</code></a>, new in Python 2.6, noting that typical floating point implementations are essentially rational approximations of real numbers. Intrigued, I had to try π:</p>
<pre><code>&gt;&gt;&gt; float.as_integer_ratio(math.pi);
(884279719003555L, 281474976710656L)
</code></pre>
<p>I was mildly surprised not to see the more <a href="https://en.wikipedia.org/wiki/Pi" rel="nofollow noreferrer">accurate</a> result due to <a href="https://en.wikipedia.org/wiki/Arima_Yoriyuki" rel="nofollow noreferrer">Arima</a>,:</p>
<pre><code>(428224593349304L, 136308121570117L)
</code></pre>
<p>For example, this code:</p>
<pre><code>#! /usr/bin/env python
from decimal import *
getcontext().prec = 36
print "python: ",Decimal(884279719003555) / Decimal(281474976710656)
print "Arima:  ",Decimal(428224593349304) / Decimal(136308121570117)
print "Wiki:    3.14159265358979323846264338327950288"
</code></pre>
<p>produces this output:    </p>
<pre>
python:  3.14159265358979311599796346854418516
Arima:   3.14159265358979323846264338327569743
Wiki:    3.14159265358979323846264338327950288
</pre>
<p>Certainly, the result is correct given the precision afforded by 64-bit floating-point numbers, but it leads me to ask: How can I find out more about the implementation limitations of <code>as_integer_ratio()</code>? Thanks for any guidance.</p>
<p>Additional links: <a href="https://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree" rel="nofollow noreferrer">Stern-Brocot tree</a> and <a href="https://github.com/python/cpython/blob/master/Objects/floatobject.c#L1516" rel="nofollow noreferrer">Python source</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The algorithm used by <code>as_integer_ratio</code> only <a href="https://github.com/python/cpython/blob/v3.7.1/Objects/floatobject.c#L1534L1604" rel="nofollow noreferrer">considers powers of 2 in the denominator</a>. Here is a (probably) <a href="https://groups.google.com/d/msg/sci.math/8nqj1x7xmWg/umKDlL4N8xgJ" rel="nofollow noreferrer">better algorithm</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>May I recommend <a href="http://code.google.com/p/gmpy/" rel="nofollow noreferrer"><code>gmpy</code></a>'s implementation of the <a href="http://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree" rel="nofollow noreferrer">Stern-Brocot tree</a>:</p>
<pre><code>&gt;&gt;&gt; import gmpy
&gt;&gt;&gt; import math
&gt;&gt;&gt; gmpy.mpq(math.pi)
mpq(245850922,78256779)
&gt;&gt;&gt; x=_
&gt;&gt;&gt; float(x)
3.1415926535897931
&gt;&gt;&gt; 
</code></pre>
<p>again, the result is "correct within the precision of 64-bit floats" (53-bit "so-called" mantissas;-), but:</p>
<pre><code>&gt;&gt;&gt; 245850922 + 78256779
324107701
&gt;&gt;&gt; 884279719003555 + 281474976710656
1165754695714211L
&gt;&gt;&gt; 428224593349304L + 136308121570117
564532714919421L
</code></pre>
<p>...gmpy's precision is obtained so much <strong>cheaper</strong> (in terms of sum of numerator and denominator values) than Arima's, much less Python 2.6's!-)</p>
</div>
<div class="post-text" itemprop="text">
<p>You get better approximations using</p>
<pre><code>fractions.Fraction.from_float(math.pi).limit_denominator()
</code></pre>
<p>Fractions are included since maybe version 3.0.
However, math.pi doesn't have enough accuracy to return a 30 digit approximation.</p>
</div>
<span class="comment-copy">The accepted answer is misleading. The <code>as_integer_ratio</code> method returns the numerator and denominator of a fraction whose value <i>exactly</i> matches the value of the floating-point number passed to it. If you want a perfectly accurate representation of your float as a fraction, use <code>as_integer_ratio</code>. If you want a simplified <i>approximation</i> with smaller denominator and numerator, look into <code>fractions.Fraction.limit_denominator</code>. IOW, <code>math.pi</code> is an approximation to π. But <code>884279719003555/281474976710656</code> is <i>not</i> an approximation to <code>math.pi</code>; it's <i>exactly</i> equal to it.</span>
<span class="comment-copy">@MarkDickinson: Your point is well-taken; it clarifies this <a href="https://stackoverflow.com/a/2076903/230513">related answer</a>. Although the <a href="https://stackoverflow.com/a/2076296/230513">accepted answer</a> could use some maintenance, it helped me see where my thinking had gone awry.</span>
<span class="comment-copy">Aha, <code>281474976710656 = 2^48</code>. Now I see where the values came from. Interesting to compare implementations: <a href="http://svn.python.org/view/python/trunk/Objects/floatobject.c?revision=77139&amp;view=markup" rel="nofollow noreferrer">svn.python.org/view/python/trunk/Objects/…</a></span>
<span class="comment-copy">Saying the algorithm is not accurate is a flawed explanation.  <code>float.as_integer_ratio()</code> simply returns you a (numerator, denominator) pair which is <i>rigorously equal</i> to the floating-point number in question (that's why the denominator is a power of two, since standard floating-point numbers have a base-2 exponent). The loss in accuracy comes from the floating-point representation itself, <i>not</i> from float.as_integer_ratio() which is actually lossless.</span>
<span class="comment-copy">IIUC, the algorithm is sufficiently accurate for a given floating-point precision. The genesis of the denominator is what puzzled me. The algorithm would never produce Arima's unique result, and there would be no point given the required precision.</span>
<span class="comment-copy">This really illustrates why link only (or near link only) answers are discouraged, both links are now broken</span>
<span class="comment-copy">I see the benefit. I've used GMP from Ada before, so <code>gmpy</code> will be handy. <a href="http://code.google.com/p/adabindinggmpmpfr/" rel="nofollow noreferrer">code.google.com/p/adabindinggmpmpfr</a></span>
