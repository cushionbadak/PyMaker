<div class="post-text" itemprop="text">
<p>Hey, I just started wondering about this as I came upon a code that expected an object with a certain set of attributes (but with no specification of what type this object should be).</p>
<p>One solution would be to create a new class that has the attributes the code expects, but as I call other code that also needs objects with (other) attributes, I'd have to create more and more classes.</p>
<p>A shorter solution is to create a generic class, and then set the attributes on instances of it (for those who thought of using an instance of <code>object</code> instead of creating a new class, that won't work since <code>object</code> instances don't allow new attributes).</p>
<p>The last, shortest solution I came up with was to create a class with a constructor that takes keyword arguments, just like the <code>dict</code> constructor, and then sets them as attributes:</p>
<pre><code>class data:
    def __init__(self, **kw):
        for name in kw:
            setattr(self, name, kw[name])

options = data(do_good_stuff=True, do_bad_stuff=False)
</code></pre>
<p>But I can't help feeling like I've missed something obvious... Isn't there a built-in way to do this (preferably supported in Python 2.5)?</p>
</div>
<div class="post-text" itemprop="text">
<p>The original code can be streamlined a little by using <code>__dict__</code>:</p>
<pre><code>In [1]: class data:
   ...:     def __init__(self, **kwargs):
   ...:         self.__dict__.update(kwargs)
   ...: 

In [2]: d = data(foo=1, bar=2)

In [3]: d.foo
Out[3]: 1

In [4]: d.bar
Out[4]: 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>type('', (), {})()</code> will create an object that can have arbitrary attributes.</p>
<p>Example:</p>
<pre><code>obj = type('', (), {})()
obj.hello = "hello"
obj.world = "world"
print obj.hello, obj.world #will print "hello world"
</code></pre>
<p><code>type()</code> with three arguments creates a new type.</p>
<p>The first argument <code>''</code> is the name of the new type. We don't care about the name, so we leave it empty.</p>
<p>The second argument <code>()</code> is a tuple of base types, here <code>object</code> (implicit).</p>
<p>The third argument is a dictionary of attributes of the new object - again we don't care to it's an empty dictionary <code>{}</code></p>
<p>And in the end we instantiate a new instance of this new type with <code>()</code> at the end.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>collections.namedtuple</code>.</p>
<p>It works well.</p>
<pre><code>from collections import namedtuple
Data = namedtuple( 'Data', [ 'do_good_stuff', 'do_bad_stuff' ] )
options = Data( True, False )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works in 2.5, 2.6, and 3.1:</p>
<pre><code>class Struct(object):
    pass

something = Struct()
something.awesome = abs

result = something.awesome(-42)
</code></pre>
<p>EDIT:
I thought maybe giving the source would help out as well.
<a href="http://docs.python.org/tutorial/classes.html#odds-and-ends" rel="noreferrer">http://docs.python.org/tutorial/classes.html#odds-and-ends</a></p>
<p>EDIT:
Added assignment to result, as I was using the interactive interpreters to verify, and you might not be.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the shortest way I know</p>
<pre><code>&gt;&gt;&gt; obj = type("myobj",(object,),dict(foo=1,bar=2))
&gt;&gt;&gt; obj.foo
1
&gt;&gt;&gt; obj.bar
2
&gt;&gt;&gt; 
</code></pre>
<p>using dict instead of {} insures your attribute names are valid</p>
<pre><code>&gt;&gt;&gt; obj = type("myobj",(object,),{"foo-attr":1,"bar-attr":2})
&gt;&gt;&gt; obj.foo-attr
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: type object 'myobj' has no attribute 'foo'
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a combination between lambda and type build-in, I think is the smallest way to do that:</p>
<pre><code>obj = lambda **kwargs: type('obj', (object,), kwargs)()

options = obj(do_good_stuff=True, do_bad_stuff=False)

print options.do_good_stuff
print options.do_bad_stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A function is an object. So you could assign attributes to a function. 
Or make one. This is the simplest way in terms of lines of code, I think.</p>
<pre><code>def hello():
    pass


hello.chook = 123
</code></pre>
<p>but the easiest &amp; most elegant way (but python &gt;3.3) is to use Standard Libary's simpleNamespace
<a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer">https://docs.python.org/3/library/types.html#types.SimpleNamespace</a></p>
<pre><code>&gt;&gt;&gt; from types import SimpleNamespace
&gt;&gt;&gt; foo = SimpleNamespace()
&gt;&gt;&gt; foo.hello = "world"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't need to pass values in the constructor, you can do this:</p>
<pre><code>class data: pass

data.foo = 1
data.bar = 2
</code></pre>
<p>You use the class static member variables to hold your data.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your question correctly, you need records. Python classes may be used this way, which is what you do. </p>
<p>I believe the most pythonic way of dealing with "records" is simply... <strong>dictionaries</strong>! A class is a sort of dictionary on steroids.</p>
<p>Your class example <code>data</code> is essentially a way of converting a dictionary into a class.</p>
<p>(On a side note, I would rather use <code>self.__setattr__(name, kw[name])</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>This is typically something you would use a dict for, not making a class at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>You might be interested in the "Struct", which is part of the IPython package. It does what you want to do, with lots of useful methods.</p>
<p><a href="http://ipython.org/ipython-doc/rel-0.13/api/generated/IPython.utils.ipstruct.html" rel="nofollow noreferrer">http://ipython.org/ipython-doc/rel-0.13/api/generated/IPython.utils.ipstruct.html</a></p>
</div>
<span class="comment-copy">Everyone using Python (except for some goofballs writing the stdlib) names their classes with capitalized words, which helps people recognize what names represent. Also, it's a good habit to always inherit from <code>object</code> so you are using <i>new-style classes</i>.</span>
<span class="comment-copy">Yeah, I wanted the class to look like a data type since it has no class functionality (which is also the reason I'm intentionally not using new-style classes since I have no use for method resolution order etc.) But the class should probably have a capitalized name, you're right.</span>
<span class="comment-copy">I think this solution might solve the concerns Blixt had with S.Lott's answer.</span>
<span class="comment-copy">Nice, even though that adds a lot of unneeded functionality in my case. Unfortunately, most code I write is limited to Python 2.5, and <code>namedtuple</code> was added in 2.6. +1 though =)</span>
<span class="comment-copy">I just meant that I could go with a simpler solution, this solution has extra tuple functionality that I don't really need (plus it creates a whole new class; I was just interested in creating a single instance with the specified attributes which I can then throw away). I can't consider upgrading because this is for a project at work, which has strict rules on what software is used.</span>
<span class="comment-copy">Your example created a whole new class, <code>data</code>.  It's -- essentially -- a named tuple and nothing more.  Your class has lots of functionality, all.  I don't know what you can possibly mean by "extra" tuple functionality, since tuples do so little and your demo class does so much.  Really.  Check the methods you get for free.  Regarding the upgrade: It's time to lobby for change.</span>
<span class="comment-copy"><code>namedtuple</code> creates a new class every time it is called. I only need one single instance with the set of attributes. That's why my code will be more efficient since it does not need to create a new class to then create an instance of every time I want an instance with specific attributes. As for upgrading, the company I work for takes stability seriously, and we use what is available in the current stable Linux distribution we're using. Which is Python 2.5. There is no way we can upgrade until a new distribution is available.</span>
<span class="comment-copy">I think I understand the concern. Blixt is saying that since using namedtuple you have to specify the attributes, he will have to call it multiple times for every different set of data to use it for.  In his example, the empty class can be assigned any attributes with a single class definition.</span>
<span class="comment-copy">Interesting solution! But what it actually does is to create a new type (which can be instantiated, i.e., <code>o = obj()</code>). As for your second example, you <i>could</i> do <code>getattr(obj, 'foo-attr')</code>, but I agree that you should avoid those kinds of names for attributes.</span>
<span class="comment-copy">yes, the fact that you can instantiate is definitely a weird side effect. I've also run into problems with using dicts that were deserialized from json having unicode strings as keys sometimes messing up the getattr machinery. It's not bulletproof, and I wouldn't use it everywhere, but it can be very handy in certain situations.</span>
<span class="comment-copy">Nevertheless You cannot use <code>d = {'field' : 123 }</code> as <code>d.field</code> what, I think, is his intention.</span>
<span class="comment-copy">Exactly what Dejw said. I would also have preferred to use <code>dict</code> in this particular case. I think using the <code>__setattr__</code> method in this case is pointless, because it's equivalent to <code>setattr</code>, but longer, and doesn't add any clarity to what is happening.</span>
<span class="comment-copy">Olivier, Using `__setattr_ in this case does not work, nor would it be better if it did.</span>
<span class="comment-copy">It does work. It just that the class must inherit from <code>object</code>, which I cannot recommend enough. I prefer it for, arguably debatable, taste reasons, because I think it makes clearer that you are calling an object method. It certainly did not claim it would work better than <code>setattr</code>.</span>
<span class="comment-copy">Dictionaries don't work the the dot notation to access object attributes!</span>
<span class="comment-copy">I agree. I'm working with code out of my control though.</span>
