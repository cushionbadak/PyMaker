<div class="post-text" itemprop="text">
<p>Let's say I am using a <code>signal</code> handler for handling an interval timer.</p>
<pre><code>def _aHandler(signum, _):
  global SomeGlobalVariable
  SomeGlobalVariable=True
</code></pre>
<p>Can I set <code>SomeGlobalVariable</code> without worrying that, in an unlikely scenario that whilst setting <code>SomeGlobalVariable</code> (i.e. the Python VM was executing bytecode to set the variable), that the assignment within the signal handler will break something? (i.e. <em>meta-stable</em> state)</p>
<p><strong>Update</strong>: I am specifically interested in the case where a "compound assignment" is made outside of the handler.</p>
<p>(maybe I am thinking too "low level" and this is all taken care of in Python... coming from an Embedded Systems background, I have these sorts of impulses from time to time)</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple assignment to simple variables is "atomic" AKA threadsafe (compound assignments such as <code>+=</code> or assignments to items or attributes of objects need not be, but your example is a simple assignment to a simple, albeit global, variable, thus safe).</p>
</div>
<div class="post-text" itemprop="text">
<p>Compound assignment involves three steps: read-update-write. This is a race condition if another thread is run and writes a new value to the location after the read happens, but before the write. In this case a stale value is being updated and written back, which will clobber whatever new value was written by the other thread. In Python anything that involves the execution of a single byte code SHOULD be atomic, but compound assignment does not fit this criteria. Use a lock.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Google's Style Guide advises against it</strong></p>
<p>I'm not claiming that Google styleguides are the ultimate truth, but the <a href="https://github.com/google/styleguide/blob/91d6e367e384b0d8aaaf7ce95029514fcdf38651/pyguide.md#218-threading" rel="nofollow noreferrer">rationale in the "Threading" section</a> gives some insight (highlight is mine):</p>
<blockquote>
<p>Do not rely on the atomicity of built-in types.</p>
<p>While Python’s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren’t atomic (e.g. if <code>__hash__</code> or <code>__eq__</code> are implemented as Python methods) and their atomicity should not be relied upon. <strong>Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).</strong></p>
<p>Use the <code>Queue</code> module's Queue data type as the preferred way to communicate data between threads. Otherwise, use the threading module and its locking primitives. Learn about the proper use of condition variables so you can use <code>threading.Condition</code> instead of using lower-level locks.</p>
</blockquote>
<p>So my interpretation is that in Python everything is dict-like and when you do <code>a = b</code> in the backend somewhere <code>globals['a'] = b</code> is happening, which is bad since dicts are not necessarily thread safe.</p>
<p>For a single variable, <code>Queue</code> is not ideal however since we want it to hold just one element, and I could not find a perfect pre-existing container in the stdlib that automatically synchronizes a <code>.set()</code> method. So for now I'm doing just:</p>
<pre><code>import threading

myvar = 0
myvar_lock = threading.Lock()
with myvar_lock:
    myvar = 1
with myvar_lock:
    myvar = 2
</code></pre>
<p>It is interesting that <a href="https://stackoverflow.com/a/2291137/895245">Martelli does not seem to mind</a> that Google style guide recommendation :-) (he works at Google)</p>
<p>I wonder if the CPython GIL has implications to this question: <a href="https://stackoverflow.com/questions/1294382/what-is-the-global-interpreter-lock-gil-in-cpython/55309364#55309364">What is the global interpreter lock (GIL) in CPython?</a></p>
<p>This thread also suggests that CPython dicts are thread safe, including the following glossary quote that explicitly mentions it <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="nofollow noreferrer">https://docs.python.org/3/glossary.html#term-global-interpreter-lock</a></p>
<blockquote>
<p>This simplifies the CPython implementation by making the object model (including critical built-in types such as dict) implicitly safe against concurrent access.</p>
</blockquote>
</div>
<span class="comment-copy">If the handler does (e.g.) <code>gvar = 3</code>, <code>gvar</code> is initially 7, and the code outside the handler does (e.g.) <code>gvar += 2</code>, then <code>gvar</code> could end up as being either 3, 5, or 9, depending on how the operations end up interleaved. That's technically "safe" (meaning, the process won't crash;-) but unlikely to be semantically OK.</span>
<span class="comment-copy">Where is this specified? -1 for lack of authoritative reference.</span>
<span class="comment-copy">Official documentation would count as authoritative, I'd say. If this is not documented, then it is implementation-dependent, no?</span>
<span class="comment-copy">@R.MartinhoFernandes, definitely implementation dependent -- in the real world, of course, the CPython reference implementation is SO dominant that all others mostly try to stick to its (documented or not) behavior, making the issue one of only theoretic and pedantic relevance. Given this, I think that answering the question with "what actually happens" in the real world of the dominant implementation still has positive value compared to waffling or refusing to help, even if no "authoritative reference" exists (nor is likely to appear any time soon).</span>
<span class="comment-copy">If the standard doesn't explicitly state that simple assignments are atomic, then the answer should mention that the behavior is up to the implementation.  Right now the answer is making a strong claim without citing any authoritative source, so -1.</span>
<span class="comment-copy">In the situation depicted above, I have only a single thread of execution. Furthermore, it is not like I can "delay" the execution of the signal handler.  Of course I can have recourse to a thread-safe queue if the opinion of the brain trust of SO prescribes so.</span>
<span class="comment-copy">If you have a single thread, where does the handler run? If it's on the same thread, then nothing can alter state while it's running in the first place.</span>
<span class="comment-copy">@Max S. : you sure? Look at @Alex Martelli 's answer.</span>
<span class="comment-copy">jldupont, Pretty sure. Alex's answer is excellent, but it applies only when you have multiple threads of control; there's no race conditions when there's only one racer.</span>
<span class="comment-copy">@Max S.: but in this case I believe we have another racer: the "signal dispatching agent".... I don't see any polling for signals. Of course, I might be totally out-for-lunch: I'd like to see the relevant documentation to support your case, please.</span>
