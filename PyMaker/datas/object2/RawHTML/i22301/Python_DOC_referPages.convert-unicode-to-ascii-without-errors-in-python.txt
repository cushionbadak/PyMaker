<div class="post-text" itemprop="text">
<p>My code just scrapes a web page, then converts it to Unicode.</p>
<pre><code>html = urllib.urlopen(link).read()
html.encode("utf8","ignore")
self.response.out.write(html)
</code></pre>
<p>But I get a <code>UnicodeDecodeError</code>:</p>
<hr/>
<pre><code>Traceback (most recent call last):
  File "/Applications/GoogleAppEngineLauncher.app/Contents/Resources/GoogleAppEngine-default.bundle/Contents/Resources/google_appengine/google/appengine/ext/webapp/__init__.py", line 507, in __call__
    handler.get(*groups)
  File "/Users/greg/clounce/main.py", line 55, in get
    html.encode("utf8","ignore")
UnicodeDecodeError: 'ascii' codec can't decode byte 0xa0 in position 2818: ordinal not in range(128)
</code></pre>
<p>I assume that means the HTML contains some wrongly-formed attempt at Unicode somewhere. <strong>Can I just drop whatever code bytes are causing the problem instead of getting an error?</strong></p>
</div>
<div class="post-text" itemprop="text">
<h3>2018 Update:</h3>
<p>As of February 2018, using compressions like <code>gzip</code> has become <a href="https://w3techs.com/technologies/details/ce-gzipcompression/all/all" rel="noreferrer">quite popular</a> (around 73% of all websites use it, including large sites like Google, YouTube, Yahoo, Wikipedia, Reddit, Stack Overflow and Stack Exchange Network sites).<br/>
If you do a simple decode like in the original answer with a gzipped response, you'll get an error like or similar to this:</p>
<blockquote>
<p>UnicodeDecodeError: 'utf8' codec can't decode byte 0x8b in position 1: unexpected code byte</p>
</blockquote>
<p>In order to decode a gzpipped response you need to add the following modules (in Python 3):</p>
<pre><code>import gzip
import io
</code></pre>
<p><strong>Note:</strong> <a href="https://stackoverflow.com/a/18284900">In Python 2 you'd use <code>StringIO</code> instead of <code>io</code></a></p>
<p>Then you can parse the content out like this:</p>
<pre><code>response = urlopen("https://example.com/gzipped-ressource")
buffer = io.BytesIO(response.read()) # Use StringIO.StringIO(response.read()) in Python 2
gzipped_file = gzip.GzipFile(fileobj=buffer)
decoded = gzipped_file.read()
content = decoded.decode("utf-8") # Replace utf-8 with the source encoding of your requested resource
</code></pre>
<p>This code reads the response, and places the bytes in a buffer. The <code>gzip</code> module then reads the buffer using the <code>GZipFile</code> function. After that, the gzipped file can be read into bytes again and decoded to normally readable text in the end.</p>
<h3>Original Answer from 2010:</h3>
<p>Can we get the actual value used for <code>link</code>?</p>
<p>In addition, we usually encounter this problem here when we are trying to <code>.encode()</code> an already encoded byte string. So you might try to decode it first as in</p>
<pre><code>html = urllib.urlopen(link).read()
unicode_str = html.decode(&lt;source encoding&gt;)
encoded_str = unicode_str.encode("utf8")
</code></pre>
<p>As an example:</p>
<pre><code>html = '\xa0'
encoded_str = html.encode("utf8")
</code></pre>
<p>Fails with</p>
<pre><code>UnicodeDecodeError: 'ascii' codec can't decode byte 0xa0 in position 0: ordinal not in range(128)
</code></pre>
<p>While:</p>
<pre><code>html = '\xa0'
decoded_str = html.decode("windows-1252")
encoded_str = decoded_str.encode("utf8")
</code></pre>
<p>Succeeds without error. Do note that "windows-1252" is something I used as an <em>example</em>. I got this from <a href="https://chardet.readthedocs.io/en/latest/" rel="noreferrer">chardet</a> and it had 0.5 confidence that it is right! (well, as given with a 1-character-length string, what do you expect) You should change that to the encoding of the byte string returned from <code>.urlopen().read()</code> to what applies to the content you retrieved.</p>
<p>Another problem I see there is that the <code>.encode()</code> string method returns the modified string and does not modify the source in place. So it's kind of useless to have <code>self.response.out.write(html)</code> as html is not the encoded string from html.encode (if that is what you were originally aiming for).</p>
<p>As Ignacio suggested, check the source webpage for the actual encoding of the returned string from <code>read()</code>. It's either in one of the Meta tags or in the ContentType header in the response. Use that then as the parameter for <code>.decode()</code>.</p>
<p>Do note however that it should not be assumed that other developers are responsible enough to make sure the header and/or meta character set declarations match the actual content. (Which is a PITA, yeah, I should know, I <em>was</em> one of those before).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; u'aあä'.encode('ascii', 'ignore')
'a'
</code></pre>
<p><strong>EDIT:</strong></p>
<p>Decode the string you get back, using either the charset in the the appropriate <code>meta</code> tag in the response or in the <code>Content-Type</code> header, then encode.</p>
<p>The method <code>encode()</code> accepts other values as "ignore". For example: 'replace', 'xmlcharrefreplace', 'backslashreplace'. See <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="noreferrer">https://docs.python.org/3/library/stdtypes.html#str.encode</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As an extension to Ignacio Vazquez-Abrams' answer</p>
<pre><code>&gt;&gt;&gt; u'aあä'.encode('ascii', 'ignore')
'a'
</code></pre>
<p>It is sometimes desirable to remove accents from characters and print the base form. This can be accomplished with</p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; unicodedata.normalize('NFKD', u'aあä').encode('ascii', 'ignore')
'aa'
</code></pre>
<p>You may also want to translate other characters (such as punctuation) to their nearest equivalents, for instance the RIGHT SINGLE QUOTATION MARK unicode character does not get converted to an ascii APOSTROPHE when encoding.</p>
<pre><code>&gt;&gt;&gt; print u'\u2019'
’
&gt;&gt;&gt; unicodedata.name(u'\u2019')
'RIGHT SINGLE QUOTATION MARK'
&gt;&gt;&gt; u'\u2019'.encode('ascii', 'ignore')
''
# Note we get an empty string back
&gt;&gt;&gt; u'\u2019'.replace(u'\u2019', u'\'').encode('ascii', 'ignore')
"'"
</code></pre>
<p>Although there are more efficient ways to accomplish this. See this question for more details <a href="https://stackoverflow.com/questions/816285/where-is-pythons-best-ascii-for-this-unicode-database">Where is Python's "best ASCII for this Unicode" database?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Use <strong><a href="https://pypi.python.org/pypi/Unidecode">unidecode</a></strong> - it even converts weird characters to ascii instantly, and even converts Chinese to phonetic ascii.</p>
<pre><code>$ pip install unidecode
</code></pre>
<p>then:</p>
<pre><code>&gt;&gt;&gt; from unidecode import unidecode
&gt;&gt;&gt; unidecode(u'北京')
'Bei Jing'
&gt;&gt;&gt; unidecode(u'Škoda')
'Skoda'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use this helper function throughout all of my projects. If it can't convert the unicode, it ignores it. This ties into a django library, but with a little research you could bypass it.</p>
<pre><code>from django.utils import encoding

def convert_unicode_to_string(x):
    """
    &gt;&gt;&gt; convert_unicode_to_string(u'ni\xf1era')
    'niera'
    """
    return encoding.smart_str(x, encoding='ascii', errors='ignore')
</code></pre>
<p>I no longer get any unicode errors after using this.</p>
</div>
<div class="post-text" itemprop="text">
<p>For broken consoles like <code>cmd.exe</code> and HTML output you can always use:</p>
<pre><code>my_unicode_string.encode('ascii','xmlcharrefreplace')
</code></pre>
<p>This will preserve all the non-ascii chars while making them printable in pure ASCII <em>and</em> in HTML.</p>
<p><strong>WARNING</strong>: <em>If you use this in production code to avoid errors then most likely there is something wrong in your code</em>. The only valid use case for this is printing to a non-unicode console or easy conversion to HTML entities in an HTML context. </p>
<p>And finally, if you are on windows and use cmd.exe then you can type <code>chcp 65001</code> to enable utf-8 output (works with Lucida Console font). You might need to add <code>myUnicodeString.encode('utf8')</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You wrote """I assume that means the HTML contains some wrongly-formed attempt at unicode somewhere."""</p>
<p>The HTML is NOT expected to contain any kind of "attempt at unicode", well-formed or not. It must of necessity contain Unicode characters encoded in some encoding, which is usually supplied up front ... look for "charset". </p>
<p>You appear to be assuming that the charset is UTF-8 ... on what grounds? The "\xA0" byte that is shown in your error message indicates that you may have a single-byte charset e.g. cp1252.</p>
<p>If you can't get any sense out of the declaration at the start of the HTML, try using <a href="http://chardet.feedparser.org/" rel="nofollow noreferrer">chardet</a> to find out what the likely encoding is.</p>
<p>Why have you tagged your question with "regex"?</p>
<p><strong>Update</strong> after you replaced your whole question with a non-question:</p>
<pre><code>html = urllib.urlopen(link).read()
# html refers to a str object. To get unicode, you need to find out
# how it is encoded, and decode it.

html.encode("utf8","ignore")
# problem 1: will fail because html is a str object;
# encode works on unicode objects so Python tries to decode it using 
# 'ascii' and fails
# problem 2: even if it worked, the result will be ignored; it doesn't 
# update html in situ, it returns a function result.
# problem 3: "ignore" with UTF-n: any valid unicode object 
# should be encodable in UTF-n; error implies end of the world,
# don't try to ignore it. Don't just whack in "ignore" willy-nilly,
# put it in only with a comment explaining your very cogent reasons for doing so.
# "ignore" with most other encodings: error implies that you are mistaken
# in your choice of encoding -- same advice as for UTF-n :-)
# "ignore" with decode latin1 aka iso-8859-1: error implies end of the world.
# Irrespective of error or not, you are probably mistaken
# (needing e.g. cp1252 or even cp850 instead) ;-)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have a string <code>line</code>, you can use the <code>.encode([encoding], [errors='strict'])</code> method for strings to convert encoding types.</p>
<p><code>line = 'my big string'</code></p>
<p><code>line.encode('ascii', 'ignore')</code></p>
<p>For more information about handling ASCII and unicode in Python, this is a really useful site: <a href="https://docs.python.org/2/howto/unicode.html" rel="nofollow noreferrer">https://docs.python.org/2/howto/unicode.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think the answer is there but only in bits and pieces, which makes it difficult to quickly fix the problem such as </p>
<pre><code>UnicodeDecodeError: 'ascii' codec can't decode byte 0xa0 in position 2818: ordinal not in range(128)
</code></pre>
<p>Let's take an example, Suppose I have file which has some data in the following form ( containing ascii and non-ascii chars )</p>
<p>1/10/17, 21:36 - Land : Welcome ï¿½ï¿½</p>
<p>and we want to ignore and preserve only ascii characters. </p>
<p>This code will do:</p>
<pre><code>import unicodedata
fp  = open(&lt;FILENAME&gt;)
for line in fp:
    rline = line.strip()
    rline = unicode(rline, "utf-8")
    rline = unicodedata.normalize('NFKD', rline).encode('ascii','ignore')
    if len(rline) != 0:
        print rline
</code></pre>
<p>and type(rline) will give you </p>
<pre><code>&gt;type(rline) 
&lt;type 'str'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>unicodestring = '\xa0'

decoded_str = unicodestring.decode("windows-1252")
encoded_str = decoded_str.encode('ascii', 'ignore')
</code></pre>
<p>Works for me</p>
</div>
<div class="post-text" itemprop="text">
<p>Looks like you are using python 2.x. 
Python 2.x defaults to ascii and it doesn’t know about Unicode. Hence the exception.</p>
<p>Just paste the below line after shebang, it will work</p>
<pre><code># -*- coding: utf-8 -*-
</code></pre>
</div>
<span class="comment-copy">I consider it to be an error if important characters are discarded!  (Also, where's the question?)</span>
<span class="comment-copy">Seems like you may have encountered a "no break space" in the web page? would need to be preceded by a <code>c2</code> byte or you'd probably get a decode error: <a href="http://hexutf8.com/?q=C2A0" rel="nofollow noreferrer">hexutf8.com/?q=C2A0</a></span>
<span class="comment-copy">In your example I think you meant for the last line to be  <code>encoded_str = decoded_str.encode("utf8")</code></span>
<span class="comment-copy">@Ajith Antony, nice catch. corrected.</span>
<span class="comment-copy">A bytestring (<code>str</code>). <a href="http://farmdev.com/talks/unicode/" rel="nofollow noreferrer">farmdev.com/talks/unicode</a></span>
<span class="comment-copy"><a href="http://unicode.org/reports/tr15/" rel="nofollow noreferrer">unicode.org/reports/tr15</a>  if someone wonders about NFKD</span>
<span class="comment-copy">Both helpful in addressing the question that was asked, and practical for addressing issues that might be underlying the asked question.  This is a model answer for this kind of question.</span>
<span class="comment-copy">halle-freakin-lujah - its about time i found an answer that worked for me</span>
<span class="comment-copy"><code>unidecode</code> is exactly what I needed, thanks</span>
<span class="comment-copy">Upvoted for fun value. Note that this mangles words in all accentuated languages. Škoda is not Skoda. Skoda most probably means something gross with eels and hovercrafts.</span>
<span class="comment-copy">I've been scouring the internet for days until now.... thank you, thank you so much</span>
<span class="comment-copy">That is SUPPRESSING the problem, not diagnosing and fixing. It's like saying "After I cut my feet off, I no longer have problems with corns and bunions".</span>
<span class="comment-copy">I agree it's suppressing the problem. It seems like that is what the question is after though. Look at his note: "Can I just drop whatever code bytes are causing the problem instead of getting an error?"</span>
<span class="comment-copy">this is exactly the same as simply calling "some-string".encode('ascii', 'ignore')</span>
<span class="comment-copy">I cannot tell you how tired I am of someone asking a question on SO, and getting all these preachy responses.  "My car won't start."  "Why do you want to start your car?  You should walk instead."  Stop it!</span>
<span class="comment-copy">@JohnMachin No one cares. I don't care what retarded crap people put in RSS feeds, if it's some character not in ascii it can be truncated. Their problem. I just want python to actually choke it down and deal with it, not give me errors everytime I specify 'ignore'. Who the hell came up with that shit?!</span>
<span class="comment-copy">This worked for me. Thanks a bunch.</span>
<span class="comment-copy">Broken link... :)</span>
<span class="comment-copy">This does not work when you have a non ascii character like ü in the string.</span>
<span class="comment-copy">This also works for the (unstandardized) "extended ascii" cases</span>
