<div class="post-text" itemprop="text">
<p>A'm beginner at Django. Sry for my bad english)</p>
<p>There are 2 models: 1.<code>RelationType</code>; 2. <code>RequestRelation</code>. The second model is connected with the first through <code>MTM field</code>.</p>
<p>There is a multiple select form based on a list of “relationship types”. Need to create few models of when <code>RequestRelation</code> submitting, depending on the selected items of the <code>multi-select</code>?</p>
<p>F.e., <em>if "husband / wife / son" is chosen, need to create 3 models accordingly</em>. Distinctive in them are only the types of relationships.</p>
<p>The <code>form.is_valid()</code>, the correct values ​​come.</p>
<p>But so far, only one model is created, with lists of all selected relationship types.</p>
<p>Also in my code there is a bug. The model is created immediately when the page is loaded, not when it is submitted.</p>
<p>Thank you in advance.</p>
<p><strong>models.py</strong></p>
<pre><code>class RelationType(models.Model):
    title = models.CharField(max_length=40)

    def __unicode__(self):
        return self.title

class RelationRequest(models.Model):
    creator = models.ForeignKey(User, related_name='creator')
    relation = models.ForeignKey(User, related_name='relation')
    type_of_relation = models.ManyToManyField(RelationType, related_name='type_relation',
        verbose_name=_('type_relation'))
    status = models.BooleanField(_('status'), default=False)

    created = models.DateTimeField(_('created'), auto_now_add=True)
    updated = models.DateTimeField(_('updated'), auto_now=True)
</code></pre>
<p><strong>html</strong></p>
<pre><code>&lt;form action="" method="POST" multiple="multiple"&gt;
    {% csrf_token %}
    {{ relation_form.type_of_relation }}
    &lt;input type='submit' value='ok'&gt;
&lt;/form&gt;
</code></pre>
<p><strong>forms.py</strong></p>
<pre><code>class RelationRequestForm(forms.ModelForm):
    class Meta:
        model = RelationRequest
        fields = ('type_of_relation',)
        widgets = {
            'type_of_relation': forms.SelectMultiple(
                attrs={
                    'class': 'select2',
                    'style': 'width: 235px',
                }
            ),
        }

    def __init__(self, *args, **kwargs):
        super(RelationRequestForm, self).__init__(*args, **kwargs)
        self.fields['type_of_relation'].empty_label = None
        self.fields['type_of_relation'] = forms.ModelMultipleChoiceField(queryset=RelationType.objects.all())

    def clean(self):
        type_of_relation = self.cleaned_data.get('type_of_relation')
</code></pre>
<p><strong>views.py</strong></p>
<pre><code>def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        relation_form = RelationRequestForm(request.POST)
        if relation_form.is_valid():
            req_rel = relation_form.save(commit=False)
            req_rel.creator = request.user
            relation_user_id = int(filter(lambda x: x.isdigit(), request.path))
            req_rel.relation = User.objects.get(id = relation_user_id)
            req_rel.save()
            relation_form.save_m2m()
        context = self.get_context_data(relation_form = relation_form)
        return self.render_to_response(context)
</code></pre>
<p><strong>upd. of views.py</strong></p>
<pre><code>@method_decorator(login_required, name='dispatch')
class ProfileView(DetailView):
    model = User
    queryset = User.objects.filter(is_active=True)

    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        content_type = ContentType.objects.get_for_model(User)
        content_type_post = ContentType.objects.get_for_model(Post)
        posts = Post.objects.filter(
            enabled=True,
            for_content_type=content_type,
            for_object_id=self.object.id,
        )
        comments = Comment.objects.filter(
            content_type=content_type_post, object_id__in=posts.values_list('id')
        ).order_by('-id')
        posts = posts.prefetch_related(
            'from_content_type', 'for_content_type',
            'from_object', 'for_object',
            Prefetch('comments', queryset=comments),
        )
        if request.GET.get('page'):
            posts = posts.filter(
                created_at__lte=datetime.strptime(
                    request.GET.get('time'), '%Y%m%d%H%M%S'
                )
            )

        posts = paginator_factory(request, posts, 20)
        post_list = []
        for post in posts.object_list:
            comments = post.comments.all()[:3]
            comment_form = CommentForm(prefix=post.id)
            post_list.append({
                'post': post,
                'comment_form': comment_form,
                'comments': comments
            })
        form_set = formset_factory(PostImageForm, extra=1)
        form = PostForm()
        popup_search_form = PeoplePopupSearchForm()
        user_confirmeds = UserConfirm.objects.filter(
            sender=request.user, is_real=True
        ).count()
        accept_request_all = UserConfirm.objects.filter(
            recipient=request.user,
            sender__slug=kwargs.get('slug')
        )
        accept_request = accept_request_all.filter(is_real=True)
        not_accept_request = accept_request_all.filter(is_real=False)
        circle = UserCircle.objects.get_or_create(user=request.user)[0]
        circle_users = circle.users.all()
        post_next = posts.has_next()


        context = self.get_context_data(
            form=form,
            post_list=post_list,
            form_set=form_set,
            circle_users=circle_users,
            post_next=post_next,
            time=now(),
            popup_search_form=popup_search_form,
            user_confirmeds=user_confirmeds,
            accept_request=accept_request,
            not_accept_request=not_accept_request,
        )
        if request.is_ajax():
            template_ajax = render_to_string(
                template_name='communication/post_list.html',
                context={
                    'post_list': post_list,
                    'request': request
                }
            )
            return JsonResponse({
                'success': True,
                'template': template_ajax,
                'next': post_next,
            })
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        relation_form = RelationRequestForm(request.POST or None)
        if relation_form.is_valid():
            for rt in relation_form.cleaned_data['type_of_relation']:
                relation_user_id = int(filter(lambda x: x.isdigit(), request.path))
                rq = RelationRequest.objects.create(
                    creator = request.user,
                    relation = User.objects.get(id = relation_user_id),
                )
                rq.type_of_relation.add(rt)
        context = self.get_context_data(relation_form = relation_form)
        return self.render_to_response(context)
</code></pre>
<p><strong>html rendered</strong></p>
<pre><code>&lt;tr&gt;&lt;th&gt;&lt;label for="id_type_of_relation"&gt;Type of relation:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;select name="type_of_relation" required multiple="multiple" id="id_type_of_relation"&gt;
  &lt;option value="1" selected&gt;Familliar&lt;/option&gt;

  &lt;option value="2"&gt;Mate&lt;/option&gt;

  &lt;option value="3" selected&gt;Friend&lt;/option&gt;

  &lt;option value="4"&gt;Husband&lt;/option&gt;

  &lt;option value="5"&gt;Wife&lt;/option&gt;

  &lt;option value="6"&gt;Son&lt;/option&gt;

  &lt;option value="7"&gt;Daughter&lt;/option&gt;

  &lt;option value="8"&gt;Mother&lt;/option&gt;

  &lt;option value="9"&gt;Father&lt;/option&gt;

  &lt;option value="10"&gt;Sister&lt;/option&gt;

  &lt;option value="11"&gt;Brother&lt;/option&gt;

  &lt;option value="12"&gt;Grandmother&lt;/option&gt;

  &lt;option value="13"&gt;Grandfather&lt;/option&gt;

  &lt;option value="14"&gt;Granddaughter&lt;/option&gt;

  &lt;option value="15"&gt;Grandson&lt;/option&gt;

  &lt;option value="16"&gt;Relative&lt;/option&gt;

  &lt;option value="17"&gt;Colleague&lt;/option&gt;

  &lt;option value="18"&gt;Partner&lt;/option&gt;

  &lt;option value="19"&gt;Mentor&lt;/option&gt;

  &lt;option value="20"&gt;Pupil&lt;/option&gt;

  &lt;option value="21"&gt;Provider&lt;/option&gt;

  &lt;option value="22"&gt;Customer&lt;/option&gt;

&lt;/select&gt;&lt;/td&gt;&lt;/tr&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>ModelForm is linked to an instance of Model you specify in it's Meta class. <code>form.save_m2m()</code> allows to create m2m connections but in your case it will be creating <code>RelationType</code>, and as I understand you want to create <code>RelationRequest</code> instances.</p>
<p>I'd recommend writing a regular <code>Form</code> with a <code>forms.ModelMultipleChoiceField(queryset=RelationType.objects.all())</code> field and iterating over user input to create all <code>RelationRequest</code> you need under <code>form.is_valid()</code>.</p>
</div>
<span class="comment-copy">Thnx. I'm doing it now. The corresponding number of models is created, but the values not stored in them. Updated code. <i>(Я сейчас так и делаю. Создаётся соответствующее количество моделей, но никак не удаётся сохранить в них выбранное значение из мкльтиселекта значения. Обновил код.)</i></span>
<span class="comment-copy">you should continue using form there. <code>relation_form.cleaned_data[NAME_OF_FORM_FIELD_HERE]</code> (assuming it's <code>type_of_relation</code>) has all picked RelationTypes. Just do <code>for rt in relation_form.cleaned_data['type_of_relation']: RelationRequest.objects.create(relation=rt.id, ...</code>.</span>
<span class="comment-copy">If I write <code>type_of_relation = rt</code> (inside a <code>RelationRequest.objects.create</code>), an error appears: <code>ValueError at /id3 "&lt;RelationRequest: RelationRequest object&gt;" needs to have a value for field "id" before this many-to-many relationship can be used.</code></span>
<span class="comment-copy">If I write <code>RelationRequest.type_of_relation = RelationType.objects.get (id = int (i))</code> outside the method, an error does not occur. But the data from the multiple select is not saved. Need to somehow update the created model.</span>
<span class="comment-copy">ah, sry. <code>rq= RelationRequest.objects.create(creator=request.user) rq.type_of_relation.add(rt)</code>. You should name your m2m fields plural btw - <code>types_of_relation</code>.</span>
