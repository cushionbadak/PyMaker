<div class="post-text" itemprop="text">
<p>I have csv file of the following format,</p>
<pre><code>,col1,col2,col3
row1,23,42,77
row2,25,39,87
row3,48,67,53
row4,14,48,66
</code></pre>
<p>I need to read this into a dictionary of two keys such that</p>
<pre><code>dict1['row1']['col2'] = 42
dict1['row4']['col3'] = 66
</code></pre>
<p>If I try to use <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow">csv.DictReader</a> with default options</p>
<pre><code>with open(filePath, "rb" ) as theFile:
    reader = csv.DictReader(theFile, delimiter=',')
    for line in reader:
    print line
</code></pre>
<p>I get the following output</p>
<pre><code>{'': 'row1', 'col2': '42', 'col3': '77', 'col1': '23'}
{'': 'row2', 'col2': '39', 'col3': '87', 'col1': '25'}
{'': 'row3', 'col2': '67', 'col3': '53', 'col1': '48'}
{'': 'row4', 'col2': '48', 'col3': '66', 'col1': '14'}
</code></pre>
<p>I'm not sure of how to process this output to create the type of dictionary that I'm interested in.</p>
<p>For sake of completeness, it would also help if you can address how to write back the dictionary into a csv file with the above format </p>
</div>
<div class="post-text" itemprop="text">
<p>Using the CSV module:</p>
<pre><code>import csv
dict1 = {}

with open("test.csv", "rb") as infile:
    reader = csv.reader(infile)
    headers = next(reader)[1:]
    for row in reader:
        dict1[row[0]] = {key: int(value) for key, value in zip(headers, row[1:])}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://pandas.pydata.org" rel="noreferrer">pandas</a> for that even if it is a bit an overkill. The pro is that there is almost nothing to code to obtain the expected result.</p>
<pre><code># Reading the file
df = pd.read_csv('tmp.csv', index_col=0)

# Creating the dict
d = df.transpose().to_dict(orient='series')

print(d['row1']['col2'])
42
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The format of the input file is not exactly convenient to parse with <code>csv</code> module. I'd parse headers separately, then parse the rest line by line, splitting by <code>,</code>, stripping and making dictionaries along the way. The working code:</p>
<pre><code>from pprint import pprint

d = {}
with open("myfile.csv") as f:
    headers = [header.strip() for header in next(f).split(",")[1:]]

    for line in f:
        values = [value.strip() for value in line.split(",")]
        d[values[0]] = dict(zip(headers, values[1:]))

pprint(d)
</code></pre>
<p>Prints:</p>
<pre><code>{'row1': {'col1': '23', 'col2': '42', 'col3': '77'},
 'row2': {'col1': '25', 'col2': '39', 'col3': '87'},
 'row3': {'col1': '48', 'col2': '67', 'col3': '53'},
 'row4': {'col1': '14', 'col2': '48', 'col3': '66'}}
</code></pre>
</div>
<span class="comment-copy">That works and looks elegant</span>
<span class="comment-copy">I have one issue, the values in the dict are strings and not integers. How can I ensure that the values in the dictionary are integers</span>
<span class="comment-copy">See my edit - just call <code>int()</code> on each value; however, this will fail if even a single value can't be converted to an integer.</span>
<span class="comment-copy">For the sake of completeness can you also describe how to write back the dictionary into a csv file in the above format. I have edited my question that would warrant such a response.</span>
<span class="comment-copy">This answer is elegant. Unfortunately I'm working on server where Pandas is not present. I prefer not to modify any python setting at moment, since it could break the other packages of interest.</span>
