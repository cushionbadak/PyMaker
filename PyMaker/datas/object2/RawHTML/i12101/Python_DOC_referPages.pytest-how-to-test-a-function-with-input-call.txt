<div class="post-text" itemprop="text">
<p>I have a console program written in Python. It asks the user questions using the command:</p>
<pre><code>some_input = input('Answer the question:', ...)
</code></pre>
<p>How would I test a function containing a call to <code>input</code> using <a href="http://pytest.org/latest/"><code>pytest</code></a>? 
I wouldn't want to force a tester to input text many many times only to finish one test run.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should probably mock the built-in <a href="https://docs.python.org/2/library/functions.html#input" rel="nofollow noreferrer"><code>input</code></a> function, you can use the <a href="http://pytest.org/latest/xunit_setup.html?highlight=teardown_method#method-and-function-level-setup-teardown" rel="nofollow noreferrer"><code>teardown</code></a> functionality provided by <a href="http://pytest.org/latest/contents.html" rel="nofollow noreferrer"><code>pytest</code></a> to revert back to the original <code>input</code> function after each test.</p>
<pre><code>import module  # The module which contains the call to input

class TestClass:

    def test_function_1(self):
        # Override the Python built-in input method 
        module.input = lambda: 'some_input'
        # Call the function you would like to test (which uses input)
        output = module.function()  
        assert output == 'expected_output'

    def test_function_2(self):
        module.input = lambda: 'some_other_input'
        output = module.function()  
        assert output == 'another_expected_output'        

    def teardown_method(self, method):
        # This method is being called after each test case, and it will revert input back to original function
        module.input = input  
</code></pre>
<p>A more elegant solution would be to use the <a href="https://pypi.python.org/pypi/mock" rel="nofollow noreferrer"><code>mock</code></a> module together with a <a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with statement</code></a>. This way you don't need to use teardown and the patched method will only live within the <code>with</code> scope.</p>
<pre><code>import mock
import module

def test_function():
    with mock.patch.object(__builtins__, 'input', lambda: 'some_input'):
        assert module.function() == 'expected_output'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As The Compiler suggested, pytest has a new monkeypatch fixture for this.  A <a href="http://pytest.org/latest/monkeypatch.html" rel="noreferrer">monkeypatch</a> object can alter an attribute in a class or a value in a dictionary, and then restore its original value at the end of the test.</p>
<p>In this case, the built-in <code>input</code> function is a value of python's <code>__builtins__</code> dictionary, so we can alter it like so:</p>
<pre><code>def test_something_that_involves_user_input(monkeypatch):

    # monkeypatch the "input" function, so that it returns "Mark".
    # This simulates the user entering "Mark" in the terminal:
    monkeypatch.setattr('builtins.input', lambda x: "Mark")

    # go about using input() like you normally would:
    i = input("What is your name?")
    assert i == "Mark"
</code></pre>
<p>Edit: Changed <code>lambda: "Mark"</code> to <code>lambda x: "Mark"</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can replace <a href="https://docs.python.org/3/library/sys.html?highlight=stdin#sys.stdin" rel="noreferrer"><code>sys.stdin</code></a> with some custom <a href="https://docs.python.org/3.5/library/io.html?highlight=stringio#text-i-o" rel="noreferrer">Text IO</a>, like input from a file or an in-memory StringIO buffer:</p>
<pre><code>import sys

class Test:
    def test_function(self):
        sys.stdin = open("preprogrammed_inputs.txt")
        module.call_function()

    def setup_method(self):
        self.orig_stdin = sys.stdin

    def teardown_method(self):
        sys.stdin = self.orig_stdin
</code></pre>
<p>this is more robust than only patching <code>input()</code>, as that won't be sufficient if the module uses any other methods of consuming text from stdin.</p>
<p>This can also be done quite elegantly with a custom context manager</p>
<pre><code>import sys
from contextlib import contextmanager

@contextmanager
def replace_stdin(target):
    orig = sys.stdin
    sys.stdin = target
    yield
    sys.stdin = orig
</code></pre>
<p>And then just use it like this for example:</p>
<pre><code>with replace_stdin(StringIO("some preprogrammed input")):
    module.call_function()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with <code>mock.patch</code> as follows.</p>
<p>First, in your code, create a dummy function for the calls to <code>input</code>:</p>
<pre><code>def __get_input(text):
    return input(text)
</code></pre>
<p>In your test functions:</p>
<pre><code>import my_module
from mock import patch

@patch('my_module.__get_input', return_value='y')
def test_what_happens_when_answering_yes(self, mock):
    """
    Test what happens when user input is 'y'
    """
    # whatever your test function does
</code></pre>
<p>For example if you have a loop checking that the only valid answers are in ['y', 'Y', 'n', 'N'] you can test that nothing happens when entering a different value instead.</p>
<blockquote>
<p>In this case we assume a <code>SystemExit</code> is raised when answering 'N':</p>
</blockquote>
<pre><code>@patch('my_module.__get_input')
def test_invalid_answer_remains_in_loop(self, mock):
    """
    Test nothing's broken when answer is not ['Y', 'y', 'N', 'n']
    """
    with self.assertRaises(SystemExit):
        mock.side_effect = ['k', 'l', 'yeah', 'N']
        # call to our function asking for input
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with <code>mock.patch</code> and <code>with</code> blocks in python3.</p>
<pre><code>import pytest
import mock
import builtins

"""
The function to test (would usually be loaded
from a module outside this file).
"""
def user_prompt():
    ans = input('Enter a number: ')
    try:
        float(ans)
    except:
        import sys
        sys.exit('NaN')
    return 'Your number is {}'.format(ans)

"""
This test will mock input of '19'
"""    
def test_user_prompt_ok():
    with mock.patch.object(builtins, 'input', lambda _: '19'):
        assert user_prompt() == 'Your number is 19'
</code></pre>
<p>The line to note is <code>mock.patch.object(builtins, 'input', lambda _: '19'):</code>, which overrides the <code>input</code> with the lambda function. Our lambda function takes in a throw-away variable <code>_</code> because <code>input</code> takes in an argument.</p>
<p>Here's how you could test the fail case, where user_input calls <code>sys.exit</code>. The trick here is to get pytest to look for that exception with <code>pytest.raises(SystemExit)</code>.</p>
<pre><code>"""
This test will mock input of 'nineteen'
"""    
def test_user_prompt_exit():
    with mock.patch.object(builtins, 'input', lambda _: 'nineteen'):
        with pytest.raises(SystemExit):
            user_prompt()
</code></pre>
<p>You should be able to get this test running by copy and pasting the above code into a file <code>tests/test_.py</code> and running <code>pytest</code> from the parent dir.</p>
</div>
<span class="comment-copy">Did you look through tutorials on how to use <code>pytest</code> to see what you can try? This is a fairly broad question to ask.</span>
<span class="comment-copy">@idjaw Not recently. I used pytest before, but this came to my mind when thinking about doing TDD for my project here and I have no idea how to solve it. I'll take a look at those tuts again.</span>
<span class="comment-copy">In your test function, you could reassign the <code>input()</code> function to something else (also known as "monkey patching" or "shadowing").</span>
<span class="comment-copy">@JohnGordon Not a bad idea, that might be the way.</span>
<span class="comment-copy">Related (non duplicate):  <a href="http://stackoverflow.com/questions/6271947/how-can-i-simulate-input-to-stdin-for-pyunit" title="how can i simulate input to stdin for pyunit">stackoverflow.com/questions/6271947/â€¦</a></span>
<span class="comment-copy">Would this change the function behind <code>input</code> for the whole test session, or only for this one test?</span>
<span class="comment-copy">No, this would also patch <code>input</code> for anything running after that test. You should instead use pytest's <a href="http://pytest.org/latest/monkeypatch.html" rel="nofollow noreferrer">monkeypatch fixture</a> to automatically reverse the patching at the end of the test.</span>
<span class="comment-copy">Thanks @TheCompiler, I've edited my question.</span>
<span class="comment-copy">"my question" ? ^^</span>
<span class="comment-copy">@Forge Ah sorry, I was only wondering what question you were referring to as your question. Maybe you posted a similar question or related question somewhere but didn't link it or something.</span>
<span class="comment-copy">This should be <code>setattr</code>, not <code>setitem</code>.</span>
