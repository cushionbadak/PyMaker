<div class="post-text" itemprop="text">
<p>If I have two files with the following contents:</p>
<p><code>test_helper.py</code>:</p>
<pre><code>class Installer:
    def __init__(self, foo, bar, version):
        # Init stuff
        raise Exception('If we're here, mock didn't work')

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        # cleanup
        pass

    def install(self):
        # Install stuff
        raise Exception('If we're here, mock didn't work')
</code></pre>
<p>And 
<code>test.py</code>:</p>
<pre><code>import unittest
from mock import patch
from test_helper import Installer

class Deployer:
    def deploy(self):
        with Installer('foo', 'bar', 1) as installer:
            installer.install()

class DeployerTest(unittest.TestCase):
    @patch('tests.test_helper.Installer', autospec=True)
    def testInstaller(self, mock_installer):
        deployer = Deployer()
        deployer.deploy()
        mock_installer.assert_called_once_with('foo', 'bar', 1)
</code></pre>
<p>The code above doesn't test correctly. The mock is not applied properly:</p>
<pre><code>  File "/Library/Python/2.7/site-packages/mock-1.3.0-py2.7.egg/mock/mock.py", line 947, in assert_called_once_with
    raise AssertionError(msg)
AssertionError: Expected 'Installer' to be called once. Called 0 times.
</code></pre>
<p>If I make the following changes in <code>test.py</code>:</p>
<ol>
<li>Change <code>from test_helper import Installer</code> to <code>import test_helper</code>, and </li>
<li>Change <code>with Installer('foo', 'bar', 1) as installer:</code> to <code>with test_helper.Installer('foo', 'bar', 1) as installer:</code></li>
</ol>
<p>The code then works. Why does the mock only apply when I use the fully qualified name? Is it supposed to work in the partially-qualified case?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are testing your <code>Deployer</code> class inside <code>test.py</code>, which is calling <code>Installer</code>. This installer is what you want to mock. So, your decorator should be with respect to that.</p>
<p>I don't know where you are testing from exactly. But as an example, if you are running your test from the same level as <code>test.py</code>, then you can simply do this to your decorator and it should work: </p>
<pre><code>import unittest

from dower import Installer
from mock import patch

class Deployer:
    def deploy(self):
        with Installer('foo', 'bar', 1) as installer:
            installer.install()

class DeployerTest(unittest.TestCase):
    @patch('test.Installer', autospec=True)
    def testInstaller(self, mock_installer):
        deployer = Deployer()
        deployer.deploy()
        mock_installer.assert_called_once_with('foo', 'bar', 1)


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>Note: You should not be mocking within the Installer module. You don't <em>care</em> about Installer in this case. Just that it returns your <code>Mock</code>, so you can continue testing the behaviour of your <code>Deployer</code>. Think of it that way, and you will realize why you have to mock with respect to what you are testing.  </p>
</div>
<span class="comment-copy">I guess this was a mix of issues. However, it was mainly to do with <a href="http://stackoverflow.com/questions/16060724/patch-why-wont-the-relative-patch-target-name-work" title="patch why wont the relative patch target name work">stackoverflow.com/questions/16060724/â€¦</a> That was what I was looking for. Thanks for the answer, though!</span>
<span class="comment-copy">@Srikanth Read deeply <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#where-to-patch</a> (3 or 4 times if you need) then accept this answer because is the correct one.</span>
