<div class="post-text" itemprop="text">
<p>Let's say that I want to test this oh-so-complex function:</p>
<pre><code>def func(hostname, username, password):
    ftp = FTP(hostname, username, password)
    ftp.retrbinary('RETR README', open('README', 'wb').write)
</code></pre>
<p>One of the tests would be:</p>
<pre><code>@patch('FTP')
def test_func_happy_path():
    mock_ftp = Mock()
    mock_ftp.retrbinary = Mock()
    MockFTP.return_value = mock_ftp()
    func('localhost', 'fred', 's3Kr3t')
    assert mock_ftp.retrbinary.called
</code></pre>
<p>However, this will create a local file called README which I clearly do not want.  </p>
<p><em>Is there a way to mock/patch <code>open</code> so that no files are created?</em></p>
<p>Clearly as a work around, I can make sure that the file is written to a <a href="https://docs.python.org/2/library/tempfile.html" rel="nofollow">temporary directory</a> which I can either pass as an argument to <code>func</code> or create within <code>func</code> and return.</p>
<p>Note that using the decorator <code>@patch('__builtin__.open')</code>, the following expectation is raised:</p>
<pre><code>self = &lt;Mock name=u'open()' spec='FTP' id='51439824'&gt;, name = 'write'
    def __getattr__(self, name):
        if name in ('_mock_methods', '_mock_unsafe'):
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
AttributeError: Mock object has no attribute 'write'
</code></pre>
<p>I am passing a callback to <code>ftp.retrbinary</code> and not a function call.</p>
</div>
<div class="post-text" itemprop="text">
<p>So, considering that you do not care about what happens with your open, you can straight out mock it so it stops writing. To do this you can follow the similar approach you did with mocking your <code>FTP</code>. So, with that in mind, you can set up your test code like this: </p>
<pre><code>import unittest
from mock import patch, Mock
from my_code import func

class SirTestsAlot(unittest.TestCase):

    @patch('my_code.open')
    @patch('my_code.FTP')
    def test_func_happy_path(self, MockFTP, m_open):
        MockFTP.return_value = Mock()
        mock_ftp_obj = MockFTP()

        m_open.return_value = Mock()

        func('localhost', 'fred', 's3Kr3t')

        assert mock_ftp_obj.retrbinary.called
        assert m_open.called
        # To leverage off of the other solution proposed, you can also
        # check assert called with here too
        m_open.assert_called_once_with('README', 'wb')


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>As you can see, what we are doing here is that we are mocking with respect to where we are testing. So, with that in mind, we are mocking out <code>open</code> and <code>FTP</code> with respect to <code>my_code</code>. </p>
<p>Now within <code>my_code</code>, nothing was changed: </p>
<pre><code>from ftplib import FTP


def func(hostname, username, password):
    ftp = FTP(hostname, username, password)

    ftp.retrbinary('RETR README', open('README', 'wb').write)
</code></pre>
<p>Running this test suite comes back successfully. </p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach involves using <a href="https://docs.python.org/3/library/unittest.mock.html#mock-open" rel="nofollow">mock_open</a>:</p>
<pre><code>from unittest.mock import patch, mock_open
import ftplib


def func(hostname, username, password):
    ftp = ftplib.FTP(hostname, username, password)
    ftp.retrbinary('RETR README', open('README', 'wb').write)


@patch('ftplib.FTP')
def test_func_happy_path(MockFTP):
    mock_ftp = MockFTP.return_value  # returns another `MagicMock`
    with patch('__main__.open', mock_open(), create=True) as m:
        func('localhost', 'fred', 's3Kr3t')

    assert mock_ftp.retrbinary.called
    m.assert_called_once_with('README', 'wb')


test_func_happy_path()
</code></pre>
</div>
<span class="comment-copy">Alternatively instead of writing to a temporary directory you can use <a href="https://docs.python.org/2/library/stringio.html" rel="nofollow noreferrer">StringIO</a>. Avoid writing to disk and keep it all in memory instead. I think that is your goal, correct?</span>
<span class="comment-copy">Yes, I was actually referring to your test using <code>StringIO</code> in place of the open. That way you avoid writing to disk for your unit tests.</span>
<span class="comment-copy">I was working my way to see which solution you were looking for! :) <i>To the coding machine</i>...</span>
<span class="comment-copy">@idjaw: There is a need of a theme song/music for that...</span>
<span class="comment-copy">@Sardathrion: For now, just imagine the old Batman theme, but replace the instruments with 8-bit musical beeps. (Beep-beep beep-beep beep-beep beep-beep, CODING!)</span>
<span class="comment-copy">That does work fine! Super. I'll wait for a bit to accept it just in case someone else comes up with some black voodoo magic... ^_~</span>
<span class="comment-copy">@Sardathrion Awesome! Glad it worked out for you. Good luck with your work.</span>
<span class="comment-copy">@Sardathrion Is there anything in particular you are looking to do? I can give it a shot. :P</span>
<span class="comment-copy">No, nothing at all. I just like to leave at least 24 hours before marking something as accepted as it gives others some incentive to come up with their own answers.</span>
<span class="comment-copy">@Sardathrion Totally agree. I'm actually curious too to see other solutions.</span>
