<div class="post-text" itemprop="text">
<p>I am currently facing a problem to make my cvs data into dictionary.</p>
<p>I have 3 columns that I'd like to use in the file:</p>
<pre><code>userID, placeID, rating
U1000,  12222,   3
U1000,  13333,   2
U1001,  13333,   4
</code></pre>
<p>I would like to make the result look like this:</p>
<pre><code>{'U1000': {'12222': 3, '13333': 2}, 
'U1001': {'13333': 4}}
</code></pre>
<p>That is to say,
I would like to make my data structure look like:</p>
<pre><code>sample = {}
sample["U1000"] = {}
sample["U1001"] = {}
sample["U1000"]["12222"] = 3
sample["U1000"]["13333"] = 2
sample["U1001"]["13333"] = 4
</code></pre>
<p>but I have a lot of data to be processed.
I'd like to get the result with loop, but i have tried for 2 hours and failed..</p>
<p>---the following codes may confuse you---</p>
<p>My result look like this now:</p>
<pre><code>{'U1000': ['12222', 3],  
'U1001': ['13333', 4]}
</code></pre>
<ol>
<li>the value of the dict is a list rather a dictionary</li>
<li>the user "U1000" appears multiple times but in my result theres only one time</li>
</ol>
<p>I think my code has many mistakes.. if you don't mind please take a look:</p>
<pre><code>reader = np.array(pd.read_csv("rating_final.csv"))
included_cols = [0, 1, 2]

sample= {}
target=[]
target1 =[]
for row in reader:
        content = list(row[i] for i in included_cols)
        target.append(content[0])
        target1.append(content[1:3])

sample = dict(zip(target, target1))
</code></pre>
<p>how can I improve the codes?
I have looked through stackoverflow but due to personal lacking in ability,
can anyone please kindly help me with this? </p>
<p>Many thanks!!</p>
</div>
<div class="post-text" itemprop="text">
<p>This should do what you want:</p>
<pre><code>import collections

reader = ...
sample = collections.defaultdict(dict)

for user_id, place_id, rating in reader:
    rating = int(rating)
    sample[user_id][place_id] = rating

print(sample)
# -&gt; {'U1000': {'12222': 3, '1333': 2}, 'U1001': {'13333': 4}}
</code></pre>
<p><a href="https://docs.python.org/3/library/collections.html#defaultdict-objects" rel="nofollow"><code>defaultdict</code></a> is a convenience utility that provides default values whenever you try to access a key that is not in the dictionary. If you don't like it (for example because you want <code>sample['non-existent-user-id]</code> to fail with <code>KeyError</code>), use this:</p>
<pre><code>reader = ...
sample = {}

for user_id, place_id, rating in reader:
    rating = int(rating)
    if user_id not in sample:
        sample[user_id] = {}
    sample[user_id][place_id] = rating
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The expected output in the example is impossible, since <code>{'1333': 2}</code> would not be associated with a key. You could get <code>{'U1000': {'12222': 3, '1333': 2}, 'U1001': {'13333': 4}}</code> though, with a <code>dict</code> of <code>dict</code>s:</p>
<pre><code>sample = {}
for row in reader:
    userID, placeID, rating = row[:3]
    sample.setdefault(userID, {})[placeID] = rating  # Possibly int(rating)?
</code></pre>
<p>Alternatively, using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict(dict)</code></a> to avoid the need for <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow"><code>setdefault</code></a> (or alternate approaches that involve a <code>try</code>/<code>except KeyError</code> or <code>if userID in sample:</code> that sacrifice the atomicity of <code>setdefault</code> in exchange for not creating empty <code>dict</code>s unnecessarily):</p>
<pre><code>import collections

sample = collections.defaultdict(dict)
for row in reader:
    userID, placeID, rating = row[:3]
    sample[userID][placeID] = rating

# Optional conversion back to plain dict
sample = dict(sample)
</code></pre>
<p>The conversion back to plain <code>dict</code> ensures future lookups don't auto-vivify keys, raising <code>KeyError</code> as normal, and it looks like a normal <code>dict</code> if you <code>print</code> it.</p>
<p>If the <code>included_cols</code> is important (because names or column indices might change), you can use <code>operator.itemgetter</code> to speed up and simplify extracting all the desired columns at once:</p>
<pre><code>from collections import defaultdict
from operator import itemgetter

included_cols = (0, 1, 2)
# If columns in data were actually:
# rating, foo, bar, userID, placeID
# we'd do this instead, itemgetter will handle all the rest:
# included_cols = (3, 4, 0)
get_cols = itemgetter(*included_cols)  # Create function to get needed indices at once

sample = defaultdict(dict)
# map(get_cols, ...) efficiently converts each row to a tuple of just 
# the three desired values as it goes, which also lets us unpack directly
# in the for loop, simplifying code even more by naming all variables directly
for userID, placeID, rating in map(get_cols, reader):
    sample[userID][placeID] = rating  # Possibly int(rating)?
</code></pre>
</div>
<span class="comment-copy">This seems like you want dictionaries as <i>values</i>, not as <i>keys</i>. Perhaps correct the title to match?</span>
<span class="comment-copy">Thanks for the kind reminder. Have corrected the title as well as the content!</span>
<span class="comment-copy">Also, your example has <code>{'U1000': {'12222': 3}, {'1333': 2}, 'U1001': {'13333': 4}}</code>, but that's mapping <code>U1000</code> and <code>U1001</code>, but there is no key (or no value) associated with <code>{'1333': 2}</code>. You could have <code>{'U1000': {'12222': 3, '1333': 2}, 'U1001': {'13333': 4}}</code>, or <code>{'U1000': [{'12222': 3}, {'1333': 2}], 'U1001': [{'13333': 4}]}</code>, but not what you provided.</span>
<span class="comment-copy">I see what you mean. Thanks for the clarification. Have corrected the body in advance. Thanks!</span>
<span class="comment-copy">Thanks for the clarification, this really helps!</span>
<span class="comment-copy">Thanks for the answer, this really helps!</span>
