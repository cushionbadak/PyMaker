<div class="post-text" itemprop="text">
<p>I am trying to understand one observation.
I have an application that loads various <code>Canvas</code> classes which a user can later work with. These classes are located in several files.
For example.</p>
<pre><code>canvas/
    bw.py
    colored.py
    oil.py
</code></pre>
<p>I import, instantiate and copy these objects like this:</p>
<pre><code>canvas_files = os.listdir('images')
imported_canvs = []
    for canv in canvas_files:
        canv = __import__(canv.split('.')[0], fromlist=['Canvas'])
        try:
            new_canv = canv.Canvas()
            new_canv_copy = copy.copy(new_canv)
            imported_canvs.append(new_canv_copy)
        except AttributeError as ex:
             pass
</code></pre>
<p>Afterwards, a user works with each <code>Canvas</code> object from <code>imported_canvs</code> list. However, when I import and instantiate these objects twice (run the <code>for</code> loop again) I can see <code>id(new_canv_copy)</code> is the same as previously imported and instantiated ones.
This would not be a problem unless that each <code>Canvas</code> has settings which should be unique for each instance and this is not currently happening. Whenever a user changes the settings in one <code>Canvas</code> they are automatically changed in the copied one.</p>
<p>Why is this happening and what am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using just <code>copy.copy()</code> creates a shallow copy. You probably want to use deep copy when copying objects using <a href="https://docs.python.org/2/library/copy.html#copy.deepcopy" rel="nofollow"><code>copy.deepcopy()</code></a>.</p>
<p>You can read in detail what's the difference here: <a href="https://docs.python.org/2/library/copy.html" rel="nofollow">https://docs.python.org/2/library/copy.html</a></p>
<p>I don't know what <code>canv.Canvas()</code> does inside so it's hard to tell what's going on when you run the same code twice when I can't try it by myself.</p>
</div>
<div class="post-text" itemprop="text">
<p>Regarding your note on running the <code>for</code> loop several times ad getting the same <code>id</code>'s... It might not be the problem with <code>copy.copy</code>, as it copies top-level object and <code>id</code>'s for top-level mutable objects should differ, but <code>id</code>'s for inner mutable objects will stay the same, unlike <code>copy.deepcopy</code> where all mutable objects <code>id</code>'s should differ. </p>
<p>Probably it's the issue with the <code>__import__</code> itself...</p>
<p>When you import a module in Python, it's imported only once. So when you issue the first import of the module 'some_module_a.py' it is imported, and then, when you issue a second import of the same module 'some_module_a.py' it's not imported again, but the reference to the already imported module is reused/returned.</p>
<p>So if you need to re-import the same module more than once, import it for the first time and then use <a href="https://docs.python.org/3.5/library/importlib.html#importlib.reload" rel="nofollow"><code>importlib.reload</code></a> to have it trully imported again.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>copy.copy</code> performs a shallow copy, meaning any objects will point to existing objects. If you want the objects inside it also to be cloned, you need to use <a href="https://docs.python.org/3/library/copy.html" rel="nofollow"><code>copy.deepcopy</code></a>. </p>
</div>
<span class="comment-copy">Can you provide a self-contained example showing the duplicated object?</span>
<span class="comment-copy">I just wanted to know if my logic is correct.</span>
<span class="comment-copy">Yeah, I know the difference, just could not understand why the ids are the same. Well, with <code>deepcopy</code> it kinda works, why kinda, this is a topic for a more comprehensive question.</span>
