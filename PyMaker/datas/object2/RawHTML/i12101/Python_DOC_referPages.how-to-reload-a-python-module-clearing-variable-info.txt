<div class="post-text" itemprop="text">
<p>I've been storing variable information inside the builtins module and I want to clear all the variable information that is stored inside of it. I can't figure out how to do it though.</p>
<pre><code>import importlib
import builtins
print("add" in dir(builtins))
builtins.add = "x"
print("add" in dir(builtins))
importlib.reload(builtins)
print("add" in dir(builtins))
</code></pre>
<p>This doesn't seem to work.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>reload</code> does not clear a module's <code>__dict__</code> before reloading it, so reloading a module doesn't affect any names you add to it that weren't originally part of the module.</p>
<p>It is essentially always better to avoid messing with the <code>builtins</code> module than to try to restore it after messing with it. That said, if you really want to do this, save a copy of <code>builtins.__dict__</code> before messing with it so you can restore from the backup later:</p>
<pre><code># Before screwing with builtins:
builtins_backup = builtins.__dict__.copy()

# After screwing with builtins:
builtins.__dict__.clear()
builtins.__dict__.update(builtins_backup)
</code></pre>
<p>That's not going to be threadsafe if another thread comes in between the <code>clear</code> and the <code>update</code>, but trying to reload <code>builtins</code> is hardly in safe territory anyway.</p>
</div>
<span class="comment-copy">"I've been storing variable information inside the builtins module" - jesus crap, <b><i>why</i></b>?</span>
<span class="comment-copy"><code>builtins</code> is not a normal module. It's loaded as part of the core interpreter; I doubt <code>reload</code> actually does anything meaningful for it.</span>
<span class="comment-copy">BTW, per <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer">the docs</a>: "It is generally not very useful to reload built-in or dynamically loaded modules. Reloading <code>sys</code>, <code>__main__</code>, <code>builtins</code> and other key modules is not recommended. In many cases extension modules are not designed to be initialized more than once, and may fail in arbitrary ways when reloaded."</span>
<span class="comment-copy">@user2357112 Yea, I realize what I am doing is not conventional. I am supplying a builtins module to a dictionary that is being passed into the global_env parameter of an exec function. Code from the exec function stores its global variables inside of builtins module naturally and I want a clean copy of the builtins module.</span>
<span class="comment-copy">@btomtom5: Okay, you're not making this seem any more sane. <code>exec</code>-ed code that stores to <code>builtins</code> on purpose? WTF?!? If it's just assigning values to its own globals, just create a new <code>dict</code> and then pass a reference to it to <code>exec</code> to populate, don't pollute the namespace of every Python module to do something terrible.</span>
<span class="comment-copy">aah this makes sense. I appreciate this a lot! That being said, this does seem incredibly unstable and seems like bad practice as you suggested. I will use this to front functionality for now before I come up with a more stable solution.</span>
