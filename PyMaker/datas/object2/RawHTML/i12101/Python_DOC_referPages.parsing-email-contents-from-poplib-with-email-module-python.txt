<div class="post-text" itemprop="text">
<p><strong>PYTHON VERSION == 3.5</strong></p>
<p>code:</p>
<pre><code>import getpass, poplib, email
Mailbox = poplib.POP3_SSL('pop.googlemail.com', '995')
Mailbox.user("email_here@gmail.com")
Mailbox.pass_('password_here')
numMessages = len(Mailbox.list()[1])
for i in range(numMessages):
    info  = b" ".join(Mailbox.retr(i+1)[1])
    msg = email.message_from_bytes(info)
    print(msg.keys())
</code></pre>
<p>output:</p>
<pre><code>['MIME-Version']
['MIME-Version']
['MIME-Version']
['Delivered-To']
['Delivered-To']
['Delivered-To']
['Delivered-To']
['Delivered-To']
['Delivered-To']
['Delivered-To']
['Delivered-To']
</code></pre>
<p>the output isn't correct because there should be more fields from the 
<code>msg</code> other than <code>"MIME-Version"</code> and <code>"Delivered-To"</code> I thought </p>
<p><code>email.message_from_bytes()</code> parses the contents of a byte string</p>
<p>is <code>msg</code> not a byte string?</p>
<p>the <a href="https://docs.python.org/3/library/poplib.html#pop3-example" rel="nofollow">docs</a> recommend this:</p>
<pre><code>M = poplib.POP3('localhost')
M.user(getpass.getuser())
M.pass_(getpass.getpass())
numMessages = len(M.list()[1])
for i in range(numMessages):
    for j in M.retr(i+1)[1]:
        print(j)
</code></pre>
<p>Is there a way to parse the returned message using the email module?
so we can store the email details. like sender, body, header etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>the answer turned out to be fairly easy</p>
<pre><code>import getpass, poplib, email
Mailbox = poplib.POP3_SSL('pop.googlemail.com', '995')
Mailbox.user("email_here@gmail.com")
Mailbox.pass_('password_here')
numMessages = len(Mailbox.list()[1])
for i in range(numMessages):
    raw_email  = b"\n".join(Mailbox.retr(i+1)[1])
    parsed_email = email.message_from_bytes(raw_email)
    print(parsed_email.keys())
</code></pre>
<p>instead of joining  <code>raw_email</code> with a space just join it by a <code>\n</code> and the <code>email</code> module can parse the fields correctly:</p>
<p>also an a awesome thing about using the <code>email</code> module
is when you call <code>email.message_from_bytes()</code> the output returned is 
a <code>dict</code></p>
<p>so you access the fields like this:</p>
<pre><code>raw_email  = b"\n".join(Mailbox.retr(i+1)[1])
parsed_email = email.message_from_bytes(raw_email)
print(parsed_email["header"])
</code></pre>
<p>but what if the field doesn't exist?:</p>
<pre><code>raw_email  = b"\n".join(Mailbox.retr(i+1)[1])
parsed_email = email.message_from_bytes(raw_email)
print(parsed_email["non-existent field"])
</code></pre>
<p>the above code will return <code>None</code> and not throw a <code>KeyError</code> </p>
</div>
