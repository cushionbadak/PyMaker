<div class="post-text" itemprop="text">
<p>I have a file containing a text like this:</p>
<pre><code>loadbalancer {
upstream application1 {
server 127.0.0.1:8082;
server 127.0.0.1:8083;
server 127.0.0.1:8084;
}
upstream application2 {
server 127.0.0.1:8092;
server 127.0.0.1:8093;
server 127.0.0.1:8094;
}
}
</code></pre>
<p>Does anyone know, how could I extract variables like below:</p>
<pre><code>appList=["application1","application2"]
ServerOfapp1=["127.0.0.1:8082","127.0.0.1:8083","127.0.0.1:8084"]
ServerOfapp2=["127.0.0.1:8092","127.0.0.1:8093","127.0.0.1:8094"]
</code></pre>
<p>.<br/>
.<br/>
.  </p>
<p>and so on</p>
</div>
<div class="post-text" itemprop="text">
<p>If the lines you want always start with upstream and server this should work:</p>
<pre><code>app_dic = {}
with open('file.txt','r') as f:
    for line in f:
        if line.startswith('upstream'):
            app_i = line.split()[1]
            server_of_app_i = []
            for line in f:
                if not line.startswith('server'):
                    break
                server_of_app_i.append(line.split()[1][:-1])
            app_dic[app_i] = server_of_app_i
</code></pre>
<p>app_dic should then be a dictionary of lists:</p>
<pre><code>{'application1': ['127.0.0.1:8082', '127.0.0.1:8083', '127.0.0.1:8084'],
'application2': ['127.0.0.1:8092', '127.0.0.1:8093', '127.0.0.1:8094']}
</code></pre>
<p><strong>EDIT</strong> </p>
<p>If the input file does not contain any newline character, as long as the file is not too large you could write it to a list and iterate over it:</p>
<pre><code>app_dic = {}
with open('file.txt','r') as f:
   txt_iter = iter(f.read().split()) #iterator of list
for word in txt_iter:
    if word == 'upstream':
        app_i = next(txt_iter)
        server_of_app_i=[]
        for word in txt_iter:
            if word == 'server':
                server_of_app_i.append(next(txt_iter)[:-1])
            elif word == '}':
                break
        app_dic[app_i] = server_of_app_i
</code></pre>
<p>This is more ugly as one has to search for the closing curly bracket to break. If it gets any more complicated, regex should be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are able to use the <a href="https://pypi.python.org/pypi/regex" rel="nofollow">newer regex module</a> by <em>Matthew Barnett</em>, you can use the following solution, see an <a href="https://regex101.com/r/aU5jW2/2" rel="nofollow">additional demo on regex101.com</a>:</p>
<pre><code>import regex as re

rx = re.compile(r"""
    (?:(?P&lt;application&gt;application\d)\s{\n| # "application" + digit + { + newline
    (?!\A)\G\n)                             # assert that the next match starts here
    server\s                                # match "server"
    (?P&lt;server&gt;[\d.:]+);                    # followed by digits, . and :
    """, re.VERBOSE)

string = """
loadbalancer {
upstream application1 {
server 127.0.0.1:8082;
server 127.0.0.1:8083;
server 127.0.0.1:8084;
}
upstream application2 {
server 127.0.0.1:8092;
server 127.0.0.1:8093;
server 127.0.0.1:8094;
}
}
"""

result = {}
for match in rx.finditer(string):
    if match.group('application'):
        current = match.group('application')
        result[current] = list()
    if current:
        result[current].append(match.group('server'))

print result
# {'application2': ['127.0.0.1:8092', '127.0.0.1:8093', '127.0.0.1:8094'], 'application1': ['127.0.0.1:8082', '127.0.0.1:8083', '127.0.0.1:8084']}
</code></pre>
<p>This makes use of the <code>\G</code> modifier, named capture groups and some programming logic.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the basic method:</p>
<pre><code># each of your objects here
objText = "xyz xcyz 244.233.233.2:123"
listOfAll = re.findall(r"/\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?):[0-9]{1,5}/g", objText)

for eachMatch in listOfAll:
    print "Here's one!" % eachMatch
</code></pre>
<p>Obviously that's a bit rough around the edges, but it will perform a full-scale regex search of whatever string it's given. Probably a better solution would be to pass it the objects themselves, but for now I'm not sure what you would have as raw input. I'll try to improve on the regex, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe this as well can be solved with <code>re</code>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt;
&gt;&gt;&gt; APP = r'\b(?P&lt;APP&gt;application\d+)\b'
&gt;&gt;&gt; IP = r'server\s+(?P&lt;IP&gt;[\d\.:]+);' 
&gt;&gt;&gt; 
&gt;&gt;&gt; pat = re.compile('|'.join([APP, IP]))
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; scan = pat.scanner(s)
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; 
&gt;&gt;&gt; for m in iter(scan.search, None):
        group = m.lastgroup
        if group == 'APP':
            keygroup = m.group(group)
            continue
        else:
            d[keygroup].append(m.group(group))


&gt;&gt;&gt; d
defaultdict(&lt;class 'list'&gt;, {'application1': ['127.0.0.1:8082', '127.0.0.1:8083', '127.0.0.1:8084'], 'application2': ['127.0.0.1:8092', '127.0.0.1:8093', '127.0.0.1:8094']})
</code></pre>
<p>Or similarly with <a href="https://docs.python.org/3/library/re.html?highlight=re#re.finditer" rel="nofollow"><code>re.finditer</code></a> method and without <code>pat.scanner</code>:</p>
<pre><code>&gt;&gt;&gt; for m in re.finditer(pat, s):
        group = m.lastgroup
        if group == 'APP':
            keygroup = m.group(group)
            continue
        else:
            d[keygroup].append(m.group(group))


&gt;&gt;&gt; d
defaultdict(&lt;class 'list'&gt;, {'application1': ['127.0.0.1:8082', '127.0.0.1:8083', '127.0.0.1:8084'], 'application2': ['127.0.0.1:8092', '127.0.0.1:8093', '127.0.0.1:8094']})
</code></pre>
</div>
<span class="comment-copy">Post what did you try so far...</span>
<span class="comment-copy">I think you probably want a dictionary of lists, too.  <code>servers['application1'] = ["127.0.0.1:8082","127.0.0.1:8083","127.0.0.1:8084"]</code> also lets you index which set of servers from the keys of <code>appList</code></span>
<span class="comment-copy">@IronFist ,i  tried to handle that with regex but i couldnt find any efficient form</span>
<span class="comment-copy">I think this is a valid form, but slightly inelegant: /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?):[0-9]{1,5}/g</span>
<span class="comment-copy">I thin file contains configuration in <code>json</code> format. Is it? Is it allowed to change the format of configuration in the file?</span>
<span class="comment-copy">You have <code>;</code> included in your final output!</span>
<span class="comment-copy">@M.T your code work well for a config file that has "\n" at end of each line, but when i try it for my own config file , it doesn't work ...</span>
<span class="comment-copy">@LordST If it is all on one line, my example needs to be modified a bit...</span>
<span class="comment-copy">@M.T could you tell me which part?</span>
<span class="comment-copy">@M.T, you should excuse me,when i open my file with notepad, it has just one line,but when open it in pyCharm or notepad++ it has some line, now i realize that why your code, doesn't work for my file, the reason was in my config file, just the first line start with character, the others have tab and space.</span>
