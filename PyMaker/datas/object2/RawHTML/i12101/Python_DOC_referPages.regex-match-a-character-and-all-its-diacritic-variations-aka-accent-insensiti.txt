<div class="post-text" itemprop="text">
<p>I am trying to match a character and all its possible diacritic variations (aka accent-insensitive) with a regular expression. What I could do of course is:</p>
<pre><code>re.match(r"^[eēéěèȅêęëėẹẽĕȇȩę̋ḕḗḙḛḝė̄]$", "é")
</code></pre>
<p>but that is not a general solution. If I use unicode categories like <code>\pL</code> I can't reduce the match to a specific character, in this case <code>e</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A workaround to achieve the desired goal would be to use <a href="https://pypi.python.org/pypi/Unidecode" rel="nofollow noreferrer">unidecode</a> to get rid of all diacritics first, and then just match agains the regular <code>e</code></p>
<pre><code>re.match(r"^e$", unidecode("é"))
</code></pre>
<p>Or in this simplified case</p>
<pre><code>unidecode("é") == "e"
</code></pre>
<hr/>
<p>Another solution which doesn't depend on the unidecode-library, preserves unicode and gives more control is manually removing the diacritics as follows:</p>
<p>Use <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize" rel="nofollow noreferrer">unicodedata.normalize()</a> to turn your input string into normal form D (for decomposed), making sure composite characters like <code>é</code> get turned into the decomposite form <code>e\u301</code> (e + COMBINING ACUTE ACCENT)</p>
<pre><code>&gt;&gt;&gt; input = "Héllô"
&gt;&gt;&gt; input
'Héllô'
&gt;&gt;&gt; normalized = unicodedata.normalize("NFKD", input)
&gt;&gt;&gt; normalized
'He\u0301llo\u0302'
</code></pre>
<p>Then, remove all codepoints which fall into the category <a href="http://www.fileformat.info/info/unicode/category/Mn/list.htm" rel="nofollow noreferrer">Mark, Nonspacing</a> (short <code>Mn</code>). Those are all characters that have no width themselves and just decorate the previous character.
Use <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.category" rel="nofollow noreferrer">unicodedata.category()</a> to determine the category. </p>
<pre><code>&gt;&gt;&gt; stripped = "".join(c for c in normalized if unicodedata.category(c) != "Mn")
&gt;&gt;&gt; stripped
'Hello'
</code></pre>
<p>The result can be used as a source for regex-matching, just as in the unidecode-example above.
Here's the whole thing as a function:</p>
<pre><code>def remove_diacritics(text):
    """
    Returns a string with all diacritics (aka non-spacing marks) removed.
    For example "Héllô" will become "Hello".
    Useful for comparing strings in an accent-insensitive fashion.
    """
    normalized = unicodedata.normalize("NFKD", text)
    return "".join(c for c in normalized if unicodedata.category(c) != "Mn")
</code></pre>
</div>
<span class="comment-copy">Does Python regex support the <i>POSIX character equivalence</i> match? This is as simple as <code>[=e=]</code> – but it also matches its capitalized equivalences, which may be too much in your case. This could be worked around using <code>(?!\u)</code>, although this in turn needs your regex to support Uppercase for all Unicode characters as well.</span>
