<div class="post-text" itemprop="text">
<p>Say I have list of tuples: </p>
<pre><code>list = [(1,5), (1,7), (2,3)]
</code></pre>
<p>Is there a way in Python to write something like</p>
<pre><code>if (1, *) in list: do things
</code></pre>
<p>where <code>*</code> means "<em>I don’t care about this value</em>"? So we are checking if there is a tuple with <code>1</code> at the first position and with whatever value on the second one.</p>
<p>As far as I know there are special mechanisms in other languages, but I just don’t know the name of this particular problem. So is there similar behavior in Python?</p>
<p><em>P.S.:</em> I know that I can use list comprehensions here. I am just interested in this particular mechanism.</p>
</div>
<div class="post-text" itemprop="text">
<p>A placeholder object like you're asking for isn't supported natively, but you can make something like that yourself:</p>
<pre><code>class Any(object):
    def __eq__(self, other):
        return True
ANYTHING = Any()

lst = [(1,5), (1,7), (2,3)]
</code></pre>
<p>The <code>__eq__</code> method defines how two objects test for equality. (See <a href="https://docs.python.org/3/reference/datamodel.html" rel="noreferrer">https://docs.python.org/3/reference/datamodel.html</a> for details.) Here, <code>ANYTHING</code> will always test positive for equality with any object. (Unless that object also overrode <code>__eq__</code> in a way to return False.)</p>
<p>The <code>in</code> operator merely calls <code>__eq__</code> for each element in your list. I.e. <code>a in b</code> does something like:</p>
<pre><code>for elem in b:
    if elem == a:
        return True
</code></pre>
<p>This means that, if you say <code>(1, ANYTHING) in lst</code>, Python will first compare <code>(1, ANYTHING)</code> to the first element in <code>lst</code>. (Tuples, in turn, define <code>__eq__</code> to return True if all its elements' <code>__eq__</code> return True. I.e. <code>(x, y) == (a, b)</code> is equivalent to <code>x==a and y==b</code>, or <code>x.__eq__(a) and y.__eq__(b)</code>.)</p>
<p>Hence, <code>(1, ANYTHING) in lst</code> will return True, while <code>(3, ANYTHING) in lst</code> will return False.</p>
<p>Also, note that I renamed your list <code>lst</code> instead of <code>list</code> to prevent name clashes with the Python built-in <code>list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/2/library/functions.html#any"><code>any()</code> function</a>:</p>
<pre><code>if any(t[0] == 1 for t in yourlist):
</code></pre>
<p>This efficiently tests and exits early if <code>1</code> is found in the first position of a tuple.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Not all of my solution methods provided below will be necessarily efficient. My goal is to demonstrate every possible solution method I can think of - at the end of my answer I provide "benchmark" results to show why or why not you should use one certain method over another. I believe that is a good way of learning, and I will shamelessly encourage such learning in my answers.</em></p>
<hr/>
<h3>Subset + hash <code>set</code>s</h3>
<pre><code>&gt;&gt;&gt; a_list = [(1,5), (1,7), (2,3)]
&gt;&gt;&gt;
&gt;&gt;&gt; set([l[0] for l in a_list])
{1, 2}
&gt;&gt;&gt;
&gt;&gt;&gt; 1 in set([l[0] for l in a_list])
True
</code></pre>
<hr/>
<h3><code>map()</code>, and anonymous functions</h3>
<pre><code>&gt;&gt;&gt; a_list = [(1,5), (1,7), (2,3)]
&gt;&gt;&gt;
&gt;&gt;&gt; map(lambda x: x[0] == 1, a_list)
[True, True, False]
&gt;&gt;&gt;
&gt;&gt;&gt; True in set(map(lambda x: x[0] == 1, a_list))
True
</code></pre>
<hr/>
<h3><code>filter</code> and anonymous functions</h3>
<pre><code>&gt;&gt;&gt; a_list = [(1,5), (1,7), (2,3)]
&gt;&gt;&gt;
&gt;&gt;&gt; filter(lambda x: x[0] == 1, a_list)
[(1,5), (1,7)]
&gt;&gt;&gt;
&gt;&gt;&gt; len(filter(lambda x: x[0] == 1, a_list)) &gt; 0  # non-empty list
True
</code></pre>
<hr/>
<h2>MICROBENCHMARKS</h2>
<h3>Conditions</h3>
<ul>
<li>1000 items</li>
<li>100K repetition</li>
<li>0-100 random range</li>
<li>Python 2.7.10, IPython 2.3.0</li>
</ul>
<h3>Script</h3>
<pre><code>from pprint import pprint
from random import randint
from timeit import timeit

N_ITEMS = 1000
N_SIM = 1 * (10 ** 5)  # 100K = 100000

a_list = [(randint(0, 100), randint(0, 100)) for _ in range(N_ITEMS)]

set_membership_list_comprehension_time = timeit(
    "1 in set([l[0] for l in a_list])",
    number = N_SIM,
    setup="from __main__ import a_list"
)

bool_membership_map_time = timeit(
    "True in set(map(lambda x: x[0] == 1, a_list))",
    number = N_SIM,
    setup="from __main__ import a_list"
)

nonzero_length_filter_time = timeit(
    "len(filter(lambda x: x[0] == 1, a_list)) &gt; 0",
    number = N_SIM,
    setup="from __main__ import a_list"
)

any_list_comprehension_time = timeit(
    "any(t[0] == 1 for t in a_list)",
    number = N_SIM,
    setup="from __main__ import a_list"
)

results = {
    "any(t[0] == 1 for t in a_list)": any_list_comprehension_time,
    "len(filter(lambda x: x[0] == 1, a_list)) &gt; 0": nonzero_length_filter_time,
    "True in set(map(lambda x: x[0] == 1, a_list))": bool_membership_map_time,
    "1 in set([l[0] for l in a_list])": set_membership_list_comprehension_time
}

pprint(
    sorted(results.items(), key = lambda x: x[1])
)
</code></pre>
<h3>Results (in seconds)</h3>
<pre><code>[('any(t[0] == 1 for t in a_list)', 2.6685791015625),     # winner - Martijn
 ('1 in set([l[0] for l in a_list])', 4.85234808921814),
 ('len(filter(lambda x: x[0] == 1, a_list)) &gt; 0', 7.11224889755249),
 ('True in set(map(lambda x: x[0] == 1, a_list))', 10.343087911605835)]
</code></pre>
<p><em>Who's got the last laugh now? ... Martijn (at least I tried)</em></p>
<p><em>MORAL OF THE STORY: Don't spend more than 10 minutes "proving" your inferior solution is faster and more efficient on a small test data, when another user's answer is the de-facto correct one</em></p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done in Python using list comprehension.
ex:</p>
<pre><code>a= [(1, 2), (3, 4), (4, 5), (1, 4)]
[i for i in a if i[0] == 1]
</code></pre>
<p>Will give you:</p>
<pre><code>[(1, 2), (1, 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Indexing is the simplest but if you wanted to use syntax similar to your example where you wanted to  assign the first value to a variable and ignore the rest you could use  python3's <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow">extended iterable unpacking</a>.</p>
<pre><code>In [3]: [a for a,*_ in l]
Out[3]: [1, 1, 2]
</code></pre>
<p>Or with the any logic:</p>
<pre><code>In [4]: l = [(1,5), (1,7), (2,3)]

In [5]: any(a == 1 for a,*_ in l)
Out[5]: True
</code></pre>
<p>Or mimicking any without the function call:</p>
<pre><code>In [23]: l = [(1,5), (1,7), (2,3)]
In [24]: g = (a  for a,*_ in l)

In [25]: 1 in g
Out[25]: True

In [26]: list(g)
Out[26]: [1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>number of element in tuple could be handled also.</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; mylist = [(1,2), (1,5), (4,5,8)]
&gt;&gt;&gt; any(i==1 for i  in map(operator.itemgetter(0), mylist))
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you actually want <code>filter()</code>, not <code>any()</code>:</p>
<pre><code>tuple_list = [(1,5), (1,7), (2,3)]
for pair in filter(lambda pair: (pair[0] == 1), tuple_list):
    print "Second value {pair[1]} found from {pair}".format(pair=pair)
...
Second value 5 found from (1, 5)
Second value 7 found from (1, 7)
</code></pre>
<p>The <a href="https://docs.python.org/2/library/functions.html#filter" rel="nofollow">filter()</a> method is great because you can provide a function directly to it. This lets you specify a certain key to filter on, etc. To simplify it further, use a lambda expression to make the entire thing into a one-liner.</p>
</div>
<span class="comment-copy">Side note: don't name your variable <code>list</code>. This will clash with the <code>list</code> function and data type from the Python standard library.</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/q/19389490">How Python's any and all functions work?</a></span>
<span class="comment-copy">You have selected the wrong answer. -1</span>
<span class="comment-copy">@Justin: sure, but then wrap that SELECT in a <code>WHERE EXISTS</code> clause.</span>
<span class="comment-copy">The name of the language feature is QbE (query by example), unification (Prolog), or simply "pattern matching".</span>
<span class="comment-copy">Pre-empting other comments: technically when doing trickery that involves redefining <code>__eq__</code>, one should also redefine <code>__ne__</code>, but that's not needed in this case. Also note that <code>ANYTHING==x</code> will return True regardless of <code>x</code>'s value, but the same is not necessarily true of <code>x==ANYTHING</code>.</span>
<span class="comment-copy">There are other answers which talk about built in 'any' , Why do you think this isn't supported natively?</span>
<span class="comment-copy">@AlokThakur: There's two different functionalities here that sound very similar. It is indeed natively supported to check if any element of an iterable is True, but the OP didn't sound like that's what he wanted to know. The second issue, which is far more interesting, is having an object (<code>*</code> in OP's post, <code>ANYTHING</code> in mine) which is a placeholder for "any value", which is unrelated to the functionality provided by the <code>any</code> built-in. (That said, I edited my answer to clarify what isn't natively supported.)</span>
<span class="comment-copy">Be VERY CAREFUL using solutions like this... the given solution will work for a list, but will NOT work for something like a dictionary: <code>d = { (1,1): 'A' }; (1, ANYTHING) in d</code> return <code>False</code>. This is because in this case, it's actually computing the hash of the source and looking up directly. Basically, anytime the object's lookup is O(1), it won't work without explicitly converting it to an O(n) lookup (e.g. <code>(1, ANYTHING) in d.keys()</code> does return <code>True</code>...). Just make sure you don't blindly use this...</span>
<span class="comment-copy">If I saw code like this in a review I would kill it with fire and insist it be done as Martijn suggested.</span>
<span class="comment-copy">For what it's worth, I down-voted this answer, despite the fact that this is how I would solve OP's posted problem. However, considering the title of the thread, I don't think this answer (or any other current ones apart from my own) actually say what the OP wants to know (namely how to get a variable with "any" value).</span>
<span class="comment-copy">@acdr: that's a different interpretation of the question. I'm sorry you don't find my answer helpful or enlightening, but this is a correct way to solve the underlying problem.</span>
<span class="comment-copy">It's a good solution, thanks, but a question was a slightly different.</span>
<span class="comment-copy">The difference between this and OP is that this approach will iterate over <code>yourlist</code>. This is okay when <code>yourlist</code> is actually a <code>list</code> but when it is for example a 2d-tree, things will be more expensive.</span>
<span class="comment-copy">@WorldSEnder: alternative data structures are entirely out of scope here; the OP did post a list in their question.</span>
<span class="comment-copy">The <code>map()</code> defeats the purpose of <code>any()</code>; you now created a list with all boolean outcomes, up front. That's why you normally use a <i>generator expression</i> with <code>any()</code>.</span>
<span class="comment-copy">You created a set from a list; you can create the set directly, again with a generator expression rather than a list comprehension.</span>
<span class="comment-copy">Perhaps ask someone else to read <i>[..] it taught me not to be cocky and that we can all learn a thing or two from each other. Except maybe you. Maybe you're already a know it all. I don't know. Thanks anyways</i> and ask them how that comes over? That comment does not come over as appreciative. :-)</span>
<span class="comment-copy">@MartijnPieters: HAHAHAHA I'm sorry - I was actually trying to make it sound like I respect your expertise and knowledge, like you already know everything and that you're the teacher more often than you are the student. But in hindsight man I DO sound like an incredible asshole (pardon my language)! But no, that was my bad, it was not my intention to voice it that way. I've seen you helping others elsewhere and I appreciate what you're doing for the community. Man, I feel sort of bad right now. Apologies my good man!</span>
<span class="comment-copy">Kudos for this reaction. We all need to <a href="http://blog.codinghorror.com/the-ten-commandments-of-egoless-programming/" rel="nofollow noreferrer">relearn this</a> from time to time.</span>
<span class="comment-copy">Use a list comprehension in this case. Its more readable.</span>
<span class="comment-copy">The purpose of my answer is to show the Python 2 filter() method specifically as a correction to the any() method; not to necessarily show the cleanest way. Also, according to post OP is already aware of list comprehensions.</span>
