<div class="post-text" itemprop="text">
<p>How do you combine two lists whilst ommitting items in the second list that have the same first tuple value as the first tuple value in the first list?</p>
<p>e.g 
If I have two lists:</p>
<pre><code>a=[(1, 1), (2, 45), (7, 56), (32, 89)]
b=[(1, 34), (6, 89), (32, 75)]
</code></pre>
<p>The new list should be:</p>
<pre><code>c=[(1, 1), (2, 45), (7, 56), (32, 89), (6, 89)] 
</code></pre>
<p>without (1,34) or (32,75) since 1 and 32 are in the first list. The lists can be of any size.</p>
</div>
<div class="post-text" itemprop="text">
<p>Construct a set whith the first element of each tuple in <code>a</code> and use a list comprehension on the elements of <code>b</code>, discarding the tuples whose 1st element is contained in the set</p>
<pre><code>&gt;&gt;&gt; a=[(1, 1), (2, 45), (7, 56), (32, 89)]
&gt;&gt;&gt; b=[(1, 34), (6, 89), (32, 75)]
&gt;&gt;&gt; a+[j for j in b if j[0] not in {i[0] for i in a}]
[(1, 1), (2, 45), (7, 56), (32, 89), (6, 89)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>itertools.chain</code></a> to join you  list <code>a</code> to one for checking, then use list comprehension:</p>
<pre><code>import itertools as it

full_a_list = list(it.chain(*a))
list_to_add = [i for i in b if i[0] not in full_a_list]
result = a + list_to_add

print(full_a_list)
[1, 1, 2, 45, 7, 56, 32, 89]

print(list_to_add)
[(6, 89)]

print(result)
[(1, 1), (2, 45), (7, 56), (32, 89), (6, 89)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>Combine the lists: comb = a + b</li>
<li>Sort them using a stable sort: comb.sort() (Luckily the sort in Python is stable)</li>
<li>Walk through the sorted list and remove duplicates</li>
</ul>
</div>
<span class="comment-copy">Your attempt please?</span>
<span class="comment-copy">@AntonProtopopov -- true but OP is only concerned about the first value if the tuple.</span>
<span class="comment-copy">@FredrikPihl ok, missed that</span>
<span class="comment-copy">@Ahsanul Haque - I was trying this code or similar to isolate the unique values in b without success: <code>[x for x,y in zip(b,a) if x[0]!=y[0]]</code></span>
<span class="comment-copy">Whoa that's efficient, I like this.</span>
<span class="comment-copy">Actually, I'll make a suggestion. Checking for membership in a list is inefficient with O(n) run time. However, if you use a hash <code>set()</code> it'll be much quicker: <code>list_to_add = [i for i in b if i[0] not in set(full_a_list)]</code></span>
<span class="comment-copy">@AhsanulHaque the sort is stable</span>
