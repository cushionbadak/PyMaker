<div class="post-text" itemprop="text">
<p>I have a config file with some options defined.  Sometimes, if the requested option is not found, I want to ignore the error and return <code>None</code>. </p>
<p><code>setting.cfg</code>:</p>
<pre><code>[Set]
ip=some_ip
verify=yes     #if verify does not exist here --&gt; verify=None
</code></pre>
<p><code>test.py</code>:</p>
<pre><code>import sys
import ConfigParser

file="setting.cfg"

class ReadFile:
   def read_cfg_file(self):
      configParser = ConfigParser.RawConfigParser(allow_no_value=True)
      if os.path.isfile(file):
          configParser.read(file)
      else:
          sys.exit(1)
      try:
          verify = configParser.get('Set', 'verify')
      except ConfigParser.NoOptionError:
          pass

      return verify,and,lots,of,other,values
</code></pre>
<p>If I handle it like this, I can't return values, as it simply passes if the <code>'verify'</code> option is not found.</p>
<p>Is there any way I can ignore errors if an option is not found, and instead return <code>None</code>?</p>
<p>For example, something like this:   </p>
<pre><code>verify = configParser.get('Set', 'verify')
if not verify:
    verify=False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If it were me, I'd derive a new config parser class from <code>RawConfigParser</code>, adding in only the new special behavior, like so:</p>
<pre><code>from ConfigParser import RawConfigParser, NoOptionError
from StringIO import StringIO
from collections import defaultdict

class MyConfigParser(RawConfigParser):
    def get(self, section, option):
        try:
            return RawConfigParser.get(self, section, option)
        except NoOptionError:
            return None


settings=StringIO('''
[Set]
ip=192.0.2.76
verify=yes
[Set2]
ip=192.0.2.74
''')

cfg=MyConfigParser(allow_no_value=True)
cfg.readfp(settings)

assert cfg.get('Set', 'verify') ==  'yes'
assert cfg.get('Set2', 'verify') == None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3's <code>configparser</code> module is <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer">much-improved</a> and provides a <code>get(option, default)</code> method.</p>
<p>Python 2's <code>ConfigParser</code>s allow for a <code>DEFAULT</code> section (<a href="https://docs.python.org/2/library/configparser.html#ConfigParser.RawConfigParser" rel="nofollow noreferrer">supplied at construction time</a>) although in that case you would have to know the defaults for each option ahead of time.</p>
<p>If you are on Python 2 and need to provide a default at the call site, sub-classing per Rob's answer seems like the way to go.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 2.7.12</strong></p>
<p>You can take advantage of the <code>ConfigParser()</code> class
<a href="https://docs.python.org/2/library/configparser.html#ConfigParser.ConfigParser.get" rel="nofollow noreferrer">get()</a> method, which allows you to specify a defaults dictionary when called:</p>
<pre><code>$ cat myconf.txt
[files]
path1 = /tmp
path2 = /usr/bin
path3 =

$ ipython
...
In [1]: import ConfigParser
   ...: 
   ...: cp = ConfigParser.ConfigParser(allow_no_value=True)
   ...: cp.read('myconf.txt')
   ...: defaults = { 'path4' : '/opt/include'}
   ...: print 'path1:', cp.get('files', 'path1', 0, defaults)
   ...: print 'path3:', cp.get('files', 'path3', 0, defaults)
   ...: print 'path4:', cp.get('files', 'path4', 0, defaults)
   ...: 
path1: /tmp
path3: 
path4: /opt/include
</code></pre>
</div>
