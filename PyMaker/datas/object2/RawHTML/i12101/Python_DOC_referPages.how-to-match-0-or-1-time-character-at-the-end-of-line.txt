<div class="post-text" itemprop="text">
<p>I am trying to normalize a URL, to extract the content after <code>://</code> and before the last <code>/</code> at the end of line if it exists.</p>
<p>Here is my script:</p>
<pre><code>url = "https://example.com/25194425/"
matchUrl = re.findall(r'://(.*)/?$', url)
print matchUrl
</code></pre>
<p>What I want is <code>example.com/25194425</code>, but I get <code>example.com/25194425/</code>. How to deal with the last <code>/</code>?
Why doesn't <code>/?</code> work?</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative way to do it without using regex is using <code>urlparse</code></p>
<pre><code>&gt;&gt;&gt; from urlparse import urlparse
&gt;&gt;&gt; url = 'https://example.com/25194425/'
&gt;&gt;&gt; '{url.netloc}{url.path}'.format(url=urlparse(url)).rstrip('/')
'example.com/25194425'
</code></pre>
<p>Later on, if you want to include the protocol, port, params, ... parts into the normalized url. It can be done easier (than updating the regex)</p>
<pre><code>&gt;&gt;&gt; '{url.scheme}://{url.netloc}{url.path}'.format(url=urlparse(url)).rstrip('/')
'https://example.com/25194425'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As one of the commenters <a href="https://stackoverflow.com/questions/35737938/how-to-match-0-or-1-time-character-at-the-end-of-line#comment59149920_35737938">said</a>, you just need to make the quantifier non-greedy:</p>
<pre><code>://(.*?)/?$
</code></pre>
<p>However, the result of <code>findall()</code> is a list, not a string.  In this case it's list with only one entry, but it's still a list.  To get the actual string, you need to provide the index:</p>
<pre><code>url = "https://example.com/25194425/"
match = re.findall(r'://(.*?)/?$', url)
print match[0]
</code></pre>
<p>But that seems like an inappropriate use of <code>findall()</code> to me.  I would have gone with <code>search()</code>:</p>
<pre><code>url = "https://example.com/25194425/"
match = re.search(r'://(.*?)/?$', url)
if match:
    print match.group(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The default is possible because the regular match more characters. So '(.*) /' will match to the last slash.<br/>
You can use it:</p>
<pre><code>matchUrl = re.findall(r'://(.*)/[^/]?$', url)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDIT</strong> Please try the following pattern (python 2.7x):</p>
<pre><code>import re
url1 = 'https://example.com/25194425?/'
url2 = 'https://example.com/25194425?'
print re.findall('https?://([\S]+)(?&lt;!/)[/]?', url1)
print re.findall('https?://([\S]+)(?&lt;!/)[/]?', url2)
</code></pre>
<p>Output:</p>
<pre><code>['example.com/25194425?']
['example.com/25194425?']
</code></pre>
<p>Thanks @Alan Moore for pointing out the word boundary issue. Now it should work for both scenarios.</p>
</div>
<span class="comment-copy"><a href="https://regex101.com/r/rX6eS8/1" rel="nofollow noreferrer"><code>://(.*?)\/?$</code></a> Extract first captured group.</span>
<span class="comment-copy"><code>/?</code> is not working because <code>/</code> needs to be <b>escaped</b> like this <code>\/</code>.</span>
<span class="comment-copy">@noob. No it doesn't - <code>/</code> is not a special character, so escaping it will make no difference to the OPs original example. Maybe you're thinking of javascript, or something?</span>
<span class="comment-copy">For url like <code>https://example.com/25194425</code>, what do you want to match?</span>
<span class="comment-copy">in fact one should resist <code>re</code> for URL parsing because this makes code non-portable to Windows. Also your snipplet should use at least <code>os.path.sep</code>, or even better <a href="https://docs.python.org/3/library/os.path.html#os.path.normpath" rel="nofollow noreferrer">docs.python.org/3/library/os.path.html#os.path.normpath</a> right away. Nevertheless, this is the best answer-</span>
<span class="comment-copy">great, I understand better the greedy search now, thanks!</span>
<span class="comment-copy">Fails if there's no trailing "/".</span>
<span class="comment-copy">This works for the OP's example because the last character (or last before the trailing slash) happens to be a word character.  You can't count on that being true in general.</span>
<span class="comment-copy">@AlanMoore: Thanks for that!</span>
