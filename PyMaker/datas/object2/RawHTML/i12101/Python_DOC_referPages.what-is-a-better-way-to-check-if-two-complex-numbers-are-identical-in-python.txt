<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>
<span class="question-originals-answer-count">
                    28 answers
                </span>
</li>
</ul>
</div>
<p>While testing mpi4py's <code>comm.reduce()</code> and <code>comm.Reduce()</code> methods in python 2.7.3 I encountered the following behaviour:</p>
<ul>
<li><p>sometimes subtracting two complex numbers (type 'numpy.complex128', which are the output of some parallel calculation) that appear identical when printed on the screen produces a non-zero result</p></li>
<li><p>comparing them with <code>==</code> occasionally yields <code>False</code>.</p></li>
</ul>
<p>Example:</p>
<pre><code>print z1, z2, z1-z2
(0.268870295763-0.268490433604j) (0.268870295763-0.268490433604j) 0j
print z1 == z2
True
</code></pre>
<p>but then</p>
<pre><code>print z1, z2, z1-z2
(0.226804302192-0.242683516175j) (0.226804302192-0.242683516175j) (-2.77555756156e-17+5.55111512313e-17j)
print z1 == z2
False
</code></pre>
<p>I figured this had something to do with the finite precision of floats, so I resorted to just checking whether the difference <code>abs(z1-z2)</code> is bigger than 1e-16 (it never was - which is what one would expect if <code>reduce()</code> and <code>Reduce()</code> are equivalent). (EDIT: this is actually not a good way to check for equality. See here: <a href="https://stackoverflow.com/questions/5595425/what-is-the-best-way-to-compare-floats-for-almost-equality-in-python">What is the best way to compare floats for almost-equality in Python?</a>)</p>
<p>I was wondering if there's a more straightforward way to compare complex numbers in python.</p>
<p>Also, why does this behaviour arise? After all, a float (and as far as I know a complex is basically a tuple of two floats) is stored on the machine in binary, as a sequence of bits. Isn't it true that if the two numbers are represented by the same sequence in binary, the difference should be zero and the comparison with <code>==</code> should yield <code>True</code>?</p>
<p>EDIT: OK, I found this <a href="https://stackoverflow.com/questions/5595425/what-is-the-best-way-to-compare-floats-for-almost-equality-in-python">What is the best way to compare floats for almost-equality in Python?</a>, which basically boils down to the same thing.</p>
<p>But then the last part of the question remains: Why do floats work like that if in binary they are all basically represented by integers?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>float</code> values derived in a way that produces the same logical result won't always have the same representation in binary, because <code>float</code> is not infinite precision, and there are limitations to its representation. The same logically equivalent steps in different orders will sometimes have precision errors that leave you with slightly different results.</p>
<p>Usually, the way to check for "close" equality with <code>float</code>s when you know the values are small or in a narrow range is to do something like:</p>
<pre><code>if abs(a - b) &lt; 1e-9:  # Substitute your own threshold for equality
</code></pre>
<p>Whether that's appropriate for your <code>complex</code> values is problem specific; you may need to check for closeness of the real and imaginary components independently.</p>
<p>If you could use Python 3.5, it provides <a href="https://docs.python.org/3/library/cmath.html#cmath.isclose" rel="nofollow"><code>cmath.isclose</code></a> to simplify this (and allow for scaled "closeness", not just absolute closeness), but on 2.7, it's probably easier to fudge it as I demonstrated above, or you can borrow the "equivalent" code given by the <code>cmath.isclose</code> docs:</p>
<pre><code> abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)
</code></pre>
<p>That equivalent code scales based on a relative tolerance, so if your values can span the whole range of <code>complex</code> types, you'll want to use something like that (where <code>rel_tol</code> and <code>abs_tol</code> are chosen by you appropriate to your problem set).</p>
</div>
<span class="comment-copy">Just because they are close enough to look the same for 12 decimal places doesn't make them the same number. You are not looking at the "sequence of bits"; only a decimal approximation.</span>
<span class="comment-copy">@khelwood, good point. I also realised that just now. See the edit.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1089018/why-cant-decimal-numbers-be-represented-exactly-in-binary" title="why cant decimal numbers be represented exactly in binary">stackoverflow.com/questions/1089018/â€¦</a> has a very nice discussion about floating point issues.</span>
<span class="comment-copy">I think using something like abs(a-b) &lt; 1e-9 is quite dangerous. Imagine subtracting 3.9e-100 and 2.7e-100. They are quite different, but according to the above they would be considered equal. The second method you suggest is much better.</span>
<span class="comment-copy">@the.real.gruycho: Agreed. It's problem space dependent; if you know the numbers are smallish, then an absolute threshold is fine, but if the numbers could be anywhere in the representable range, you need a relative threshold. I've updated the answer to make that a bit more clear.</span>
