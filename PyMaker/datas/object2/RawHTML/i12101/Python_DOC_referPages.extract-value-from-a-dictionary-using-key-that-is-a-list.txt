<div class="post-text" itemprop="text">
<p>I have a the following programme:</p>
<pre><code>import QuantLib as ql

deposits = {ql.Period(1,ql.Weeks): 0.0023, 
            ql.Period(1,ql.Months): 0.0032,
            ql.Period(3,ql.Months): 0.0045,
            ql.Period(6,ql.Months): 0.0056}

for n, unit in [(1,ql.Weeks),(1,ql.Months),(3,ql.Months),(6,ql.Months)]:
    print deposits([n,unit])
</code></pre>
<p>What I expect this programme to do is: it loops through the dictionary keys, which comprises an embedded list of a 'number' (i.e. 1,1,3,6) and 'unit' (i.e. weeks and months), and extracts the correct value (or rate). Currently I get an error with the line <code>print deposits([n,unit])</code>.</p>
<p>Here is the error I get:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\Anaconda2\lib\site-packages\spyderlib\widgets\externalshell\sitecustomize.py", line 699, in runfile
    execfile(filename, namespace)
  File "C:\Anaconda2\lib\site-packages\spyderlib\widgets\externalshell\sitecustomize.py", line 74, in execfile
    exec(compile(scripttext, filename, 'exec'), glob, loc)
  File "TestFunction.py", line 16, in &lt;module&gt;
    print deposits([n,unit])   
TypeError: 'dict' object is not callable
</code></pre>
<p>The name of my file is <code>TestFunction.py</code></p>
<p>I know a way round this issue, which is where I convert the dictionary into two lists as follows:</p>
<pre><code>depoMaturities = [ql.Period(1,ql.Weeks), 
                  ql.Period(1,ql.Months),
                  ql.Period(3,ql.Months),
                  ql.Period(6,ql.Months)]

depoRates = [0.0023, 
             0.0032,
             0.0045,
             0.0056]
</code></pre>
<p>But then it does not look as tidy or as sophisticated. I'd be really grateful for your advice.</p>
</div>
<div class="post-text" itemprop="text">
<p>deposits is a dictionary with keys and values. The reference of a dictionary is</p>
<pre><code> value = mydict[key]
</code></pre>
<p>Thus given n and unit you get that ql.Period(n, unit) returns a type of <code>&lt;class 'QuantLib.QuantLib.Period'&gt;</code>. The result of <code>ql.period(1, ql.Weekly)</code> for example would be 1W.</p>
<p>It would appear that if it is converted to a string, then it would be usable as a key.</p>
<pre><code>deposits = {str(ql.Period(1,ql.Weeks)): 0.0023, 
            str(ql.Period(1,ql.Months)): 0.0032,
            str(ql.Period(3,ql.Months)): 0.0045,
            str(ql.Period(6,ql.Months)): 0.0056}

value = deposits[str(ql.Period(n, unit))]
print value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update</strong> per <a href="https://stackoverflow.com/questions/35849963/extract-value-from-a-dictionary-using-key-that-is-a-list/35850132?noredirect=1#comment59369808_35850132">comments</a>: It looks like the <code>Period</code> class implemented <code>__hash__</code> incorrectly, so it doesn't obey <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__hash__#object.__hash__" rel="nofollow">the hash invariant required by Python</a> (specifically, objects that compare equal should hash to the same value). Per your comment, when you run:</p>
<pre><code>p1 = ql.Period(1,ql.Weeks)
p2 = ql.Period(1,ql.Weeks)
if (p1 == p2): k = 5*2
else: k = 0
</code></pre>
<p>you get 10, so <code>p1==p2</code> is <code>True</code>.</p>
<p>When you run:</p>
<pre><code>if (hash(p1) == hash(p2)): b = 5*2
else: b = 0
</code></pre>
<p>you get 0, so <code>hash(p1) == hash(p2)</code> is <code>False</code>. This is a clear violation of the Python rules, which makes the type <em>appear</em> to be a legal key for a <code>dict</code> (or value in a <code>set</code>), but <em>behave</em> incorrectly. Basically, you can't use <code>Period</code>s as keys without having the QuantLib folks fix this, or doing terrible things to work around it (and really terrible things if <code>Period</code> is a C extension type, which seems likely since QuantLib is apparently a SWIG wrapper).</p>
<p>If the <code>Period</code> units behave properly, I'd recommend working with <code>tuple</code>s of the paired counts and units most of the time, and only converting to <code>Period</code>s when you have need of a particular <code>Period</code> feature. So your <code>dict</code> would be:</p>
<pre><code>deposits = {(1,ql.Weeks): 0.0023, 
            (1,ql.Months): 0.0032,
            (3,ql.Months): 0.0045,
            (6,ql.Months): 0.0056}
</code></pre>
<p>and your loop would be:</p>
<pre><code>for n, unit in [(1,ql.Weeks),(1,ql.Months),(3,ql.Months),(6,ql.Months)]:
    print deposits[n, unit]
</code></pre>
<p>If that still fails, then even the basic unit types are broken, and you just can't use them at all.</p>
<hr/>
<p><s>If the keys are <code>ql.Period</code>s, you need to look up using <code>ql.Period</code>s (unless <code>Period</code> is <code>tuple</code> subclass). You also need to use brackets for <code>dict</code> lookup, not parentheses.</s></p>
<p>If <code>ql.Period</code> is a <code>namedtuple</code> or the like, you can just do <code>tuple</code> lookup (<code>list</code>s can't be <code>dict</code> keys, because they're mutable):</p>
<pre><code>for n, unit in [(1,ql.Weeks),(1,ql.Months),(3,ql.Months),(6,ql.Months)]:
    print deposits[n, unit]
</code></pre>
<p>If <code>ql.Period</code> isn't a <code>tuple</code> subclass, you can do:</p>
<pre><code>for n, unit in [(1,ql.Weeks),(1,ql.Months),(3,ql.Months),(6,ql.Months)]:
    print deposits[ql.Period(n, unit)]
</code></pre>
<p>or to make the periods in the loop,</p>
<pre><code>import itertools

for period in itertools.starmap(ql.Period, [(1,ql.Weeks),(1,ql.Months),(3,ql.Months),(6,ql.Months)]):
    print deposits[period]
</code></pre>
<p></p></div>
<div class="post-text" itemprop="text">
<p>In addition to the syntax problems others have identified, my guess is that your <code>ql.Period</code> object is not hashable; the keys for dictionaries need to be hashable objects.  Here's a direct copy-and-past from <a href="https://stackoverflow.com/a/114831/1194883">this answer</a>, which explains the situation nicely.</p>
<pre><code>&gt;&gt;&gt; a = {}
&gt;&gt;&gt; b = ['some', 'list']
&gt;&gt;&gt; hash(b)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: list objects are unhashable
&gt;&gt;&gt; a[b] = 'some'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: list objects are unhashable
</code></pre>
<p>What happens when you try <code>hash(ql.Period(1,ql.Weeks))</code>?  A similar <code>TypeError</code>?  If you had control over <code>QuantLib</code>, you could possibly add a <a href="https://docs.python.org/2/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code> method</a>, so that they could be used in dictionaries.  But I see that such a module exists on pypi, so I guess you're just using it rather than writing it.</p>
<p>You may still be able to <a href="https://stackoverflow.com/questions/5626193/what-is-a-monkey-patch">monkey patch</a> these objects to give them a <code>__hash__</code> method:</p>
<pre><code># First define a function to add on as a method
def hash_method(period):
    hash_value = # some code that produces a unique hash, based on
                 # the data contained in the `period` object
    return hash_value

# Now, monkey patch the ql.Period object by giving it this method
ql.Period.__hash__ = hash_method
</code></pre>
</div>
<span class="comment-copy">You should edit your question to include the exact and complete error that you get.  As a first guess, the error is that you can't call a dict.  If that is a typo in your question, then the next error is that lists are not hashable.  If that weren't a problem, then finally, you would get a KeyError because the object you are using as the key to get a value for printing is not the same type (or value) of object that you used when you created the dictionary.</span>
<span class="comment-copy">I've included the error I get. Given the dictionary 'deposits' that I have, can you advise me on how to extract the values?</span>
<span class="comment-copy">Indeed: dicts are not callable. That is a typo: use <code>[]</code>, not <code>()</code>, to access elements of a dict. Next, as given in the answers, you need to create a <code>ql.Period</code> object from the quantity and units since your dict has <code>ql.Period</code> objects as keys.</span>
<span class="comment-copy">Thank you for your response. I just ran your suggestion but get the error <code>print deposits[ql.Period(n, unit)]KeyError: Period("1W")</code></span>
<span class="comment-copy">@MacMavin do a print of n and unit and also print ql.Weeks to ensure that the two match. Also check that your code has the comma for the two arguments in period  ql.Period(1,'W')</span>
<span class="comment-copy">I've done a print of the statement; here are the results:  Command: <code>print n, unit, ql.Months</code>  Results:   <code>1 1 2;  1 2 2;  3 2 2;  6 2 2</code>  I'd explain this result: within the quantlib library, the ql.Months has an index of 2, while ql.Weeks has an index of 1. The result produced is as expected. The first line represents 1 week, the second 1 month, the third 3 months and the fourth 6 months. I cannot anything wrong from the print statement.</span>
<span class="comment-copy">@MacMavin I do not have the QuantLib module available on the computer that I can get do. I will try to install it at home and look at it tonight, but I do not know if I will be able to get to it. Try to explicitly look at <code>deposits[ql.Period[(1,1)]</code> and see if that works. if it does, then verify that you typed <code>deposits[n, unit]</code> correctly.</span>
<span class="comment-copy">I have tried your suggestion but I still get an error  <code>Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt;   File "C:\Anaconda2\lib\site-packages\spyderlib\widgets\externalshell\sitecustomize.py", line 699, in runfile     execfile(filename, namespace)   File "C:\Anaconda2\lib\site-packages\spyderlib\widgets\externalshell\sitecustomize.py", line 74, in execfile     exec(compile(scripttext, filename, 'exec'), glob, loc)   File "TestFunction.py", line 16, in &lt;module&gt;     deposits[ql.Period[(1,1)]] TypeError: 'type' object has no attribute '__getitem__' &gt;&gt;&gt;</code></span>
<span class="comment-copy">Period is a class member function of quantlib. In my case, ql.Period takes in a number (to represent the time) and its unit (weeks, months, etc). So <code>ql.Period (1,ql.Weeks)</code> will yield "1W". From your response, I gather that you may not have come across quantlib. Sorry I failed to describe the quantlib portion clearer. I still get errors having implemented your suggestions</span>
<span class="comment-copy">@MacMavin: Can you be more specific about the new errors? Your original code was wrong in a way that masks other issues (trying to call the <code>dict</code> as if it were a function with <code>()</code> instead of doing key lookup with <code>[]</code>). Since <code>ql.Period</code> isn't a <code>tuple</code> subclass, you probably want to use the second code block from my answer (where you do <code>print deposits[ql.Period(n, unit)]</code> on each loop); it should work by definition if the construction of <code>deposits</code> succeeded in the first place.</span>
<span class="comment-copy">@MacMavin: Read your other comment. Is it possible <code>ql.Period</code> doesn't support equality or hashing, and just uses Python's default implementation based on identity? Or worse, implements equality and hashing, but doesn't obey the rules for hashing? Try doing the following in an interactive terminal on separate lines: <code>p1 = ql.Period(1,ql.Weeks)</code>, <code>p2 = ql.Period(1,ql.Weeks)</code>, <code>p1 == p2</code>, <code>hash(p1) == hash(p2)</code>. If the last two lines don't both return <code>True</code>, then you can't use <code>Period</code>s for lookups in a <code>dict</code> unless you store one canonical copy of each <code>Period</code> and reuse it.</span>
<span class="comment-copy">Here are the errors (for your second suggestion):   <code>Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt;   File "C:\Anaconda2\lib\site-packages\spyderlib\widgets\externalshell\sitecustomize.py", line 699, in runfile     execfile(filename, namespace)   File "C:\Anaconda2\lib\site-packages\spyderlib\widgets\externalshell\sitecustomize.py", line 74, in execfile     exec(compile(scripttext, filename, 'exec'), glob, loc)   File "TestFunction.py", line 29, in &lt;module&gt;     print deposits[ql.Period(n, unit)] KeyError: Period("1W") &gt;&gt;&gt;</code></span>
<span class="comment-copy">Right. Like you said, <code>ql.Period</code> isn't a <code>tuple</code> subclass, so that won't work. The second suggestion is the one that would work (the third suggestion is identical to the second, just moving the work around, so if the second doesn't work, neither will the third). Can you try the minimal test I provided in my last comment?</span>
<span class="comment-copy">It's definitely hashable (you'd get a <code>TypeError</code> if <code>Period</code> wasn't hashable, not a <code>KeyError</code> as the OP describes in the comments). Currently trying to suss out whether it's using the default Python equality and hashing checks (which are based on identity, not value), or whether they actually implemented equality and hashing, but did it wrong.</span>
<span class="comment-copy">Oh, fair enough.  :)  I'll just leave this here in case others stumble across it due to the title.</span>
