<div class="post-text" itemprop="text">
<p>I have this example code to explain my problem:</p>
<pre><code>import threading
import time

class thread1(threading.Thread):

    def __init__(self, lock):
        threading.Thread.__init__(self)
        self.daemon = True
        self.start()        
        self.lock = lock

    def run(self):
        while True:
            self.lock.acquire(True)
            print ('write done by t1')
            self.lock.release()

class thread2(threading.Thread):

    def __init__(self, lock):
        threading.Thread.__init__(self)
        self.daemon = True
        self.start()        
        self.lock = lock

    def run(self):
        while True:
            self.lock.acquire(True)
            print ('write done by t2')
            self.lock.release()

if __name__ == '__main__':
    lock = threading.Lock()
    t1 = thread1(lock)
    t2 = thread2(lock)

    lock.acquire(True)

    counter = 0

    while True:
        print("main...")
        counter = counter + 1
        if(counter==5 or counter==10):
            lock.release() # Here I want to unlock both threads to run just one time and then wait until I release again
        time.sleep(1)

    t1.join()
    t2.join()
</code></pre>
<p>What I'm having some issues is the following:</p>
<p>I want to have two threads (thread1 and thread2) that are launched at the beginning of the program, but they should wait until the <code>main()</code> <code>counter</code> reaches 5 or 10.</p>
<p>When the <code>main()</code> <code>counter</code> reaches 5 or 10, it should signal/trigger/unlock the threads, and both <code>threads</code> should run just once and then wait until a new <code>unlock</code>.</p>
<p>I was expecting the code to have the following output (Each line is 1 second running):</p>
<pre><code>main...
main...
main...
main...
main...
write done by t1
write done by t2
main...
main...
main...
main...
main...
write done by t1
write done by t2
</code></pre>
<p>Instead I have a different behaviour, such as starting with:</p>
<pre><code>write done by t1
write done by t1
write done by t1
write done by t1
</code></pre>
<p>(etc)</p>
<p>And after 5 seconds the </p>
<pre><code>write done by t2
</code></pre>
<p>A lot of times...</p>
<p>Can someone help me explaining what is wrong and how can I improve this?</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>In __init__() of thread1 and thread2, start() is invoked before self.lock is assigned.</li>
<li>t1 and t2 are created before the main thread acquires the lock. That makes these two threads start printing before the main thread locks them. It is the reason your code print the first several lines of "write done by x".</li>
<li>After the counter reaches 5, the main thread releases the lock, but it never locks it again. That makes t1 and t2 keep running.</li>
<li>It never quits unless you kill it...</li>
</ol>
<p>I suggest you to use <em><a href="https://docs.python.org/3/library/threading.html#condition-objects" rel="nofollow">Condition Object</a></em> instead of Lock.</p>
<p>Here is an example based on your code.</p>
<pre><code>import threading
import time


class Thread1(threading.Thread):
    def __init__(self, condition_obj):
        super().__init__()
        self.daemon = True
        self.condition_obj = condition_obj
        self.start()

    def run(self):
        with self.condition_obj:
            while True:
                self.condition_obj.wait()
                print('write done by t1')


class Thread2(threading.Thread):
    def __init__(self, condition_obj):
        super().__init__()
        self.daemon = True
        self.condition_obj = condition_obj
        self.start()

    def run(self):
        with self.condition_obj:
            while True:
                self.condition_obj.wait()
                print('write done by t2')


if __name__ == '__main__':
    condition = threading.Condition()
    t1 = Thread1(condition)
    t2 = Thread2(condition)

    counter = 0

    while True:
        print("main...")
        counter += 1
        if counter == 5 or counter == 10:
            with condition:
                condition.notify_all()
        time.sleep(1)

    t1.join()
    t2.join()
</code></pre>
</div>
<span class="comment-copy">awesome!! thank you for the explanation!!</span>
