<div class="post-text" itemprop="text">
<p>I have a list of lists that need to be merged based on strings in the list to fit a structure. In this case, it would be 'date' and 'id' trying to fit the 'fields' structure. </p>
<p>Fields: <code>['date', 'id', 'impressions', 'clicks']</code></p>
<p>Before:</p>
<pre><code>[('2015-11-01', 'id123', 'impressions', '8'), ('2015-11-01', 'id123', 
'clicks', '4'), ('2015-11-01', 'id456', 'impressions', '14'), 
('2015-11-01', 'id456', 'clicks', '9')]
</code></pre>
<p>After:</p>
<pre><code>[('2015-11-01', 'id123', '8', '4'), ('2015-11-01', 'id456', '14', '9')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; L  = [('2015-11-01', 'id123', 'impressions', '8'), ('2015-11-01', 'id123', 
... 'clicks', '4'), ('2015-11-01', 'id456', 'impressions', '14'), 
... ('2015-11-01', 'id456', 'clicks', '9')]
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; D = defaultdict(list)
&gt;&gt;&gt; for a, b, c, d in L:
...     D[a, b].append(d)
... 
&gt;&gt;&gt; [k + tuple(D[k]) for k in D]
[('2015-11-01', 'id456', '14', '9'), ('2015-11-01', 'id123', '8', '4')]
</code></pre>
<p>In the case that impressions and clicks are not in a consistent order</p>
<pre><code>&gt;&gt;&gt; L = [('2015-11-01', 'id123', 'impressions', '8'), ('2015-11-01', 'id123', 'clicks', '4'), ('2015-11-01', 'id456', 'clicks', '9'), ('2015-11-01', 'id456', 'impressions', '14')]
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; D = defaultdict(lambda: [None, None])
&gt;&gt;&gt; for a, b, c, d in L:
...     D[a, b][c == 'clicks'] = d
... 
&gt;&gt;&gt; [k + tuple(D[k]) for k in D]
[('2015-11-01', 'id456', '14', '9'), ('2015-11-01', 'id123', '8', '4')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> can work well here, particularly if the real data matches the sample data (already sorted so date/id pairs are all adjacent):</p>
<pre><code>import itertools
from operator import itemgetter

outlist = []
for (date, ID), grp in itertools.groupby(inlist, key=itemgetter(0, 1)):
    grp = list(grp)  # Iterating twice, so convert to sequence
    impressioncnt = sum(int(cnt) for _, _, typ, cnt in grp if typ == 'impressions')
    clickcnt = sum(int(cnt) for _, _, typ, cnt in grp if typ == 'clicks')
    outlist.append((date, ID, str(impressioncnt), str(clickcnt)))
</code></pre>
<p>If the data isn't already sorted by <code>date</code> and <code>ID</code>, you'd need to sort the <code>inlist</code> first, <code>inlist.sort(key=itemgetter(0, 1))</code>. That could be expensive if the <code>list</code> is huge, in which case you might consider using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a> instead:</p>
<pre><code>import collections

dateID_cnts = collections.defaultdict({'impressions': 0, 'clicks': 0}.copy)
for date, ID, typ, cnt in inlist:
    dateID_cnts[date, ID][typ] += int(cnt)

# Convert from defaultdict to desired list of tuples
outlist = [(date, ID, str(v['impressions']), str(v['counts'])) for (date, ID), v in dateID_cnts.items()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way:</p>
<pre><code>data=[('2015-11-01', 'id123', 'impressions', '8'), 
      ('2015-11-01', 'id123','clicks', '4'), 
      ('2015-11-01', 'id456', 'impressions', '14'), 
      ('2015-11-01', 'id456', 'clicks', '9')]

ddict={}
for t in data:
    key=(t[0], t[1])
    ddict.setdefault(key, []).append(t[2:])

LoT=[]    
for d, id in ddict:
    impressions, clicks=max(ddict[(d, id)])[1], min(ddict[(d, id)])[1]
    LoT.append(tuple([d, id, impressions, clicks]))

&gt;&gt;&gt; LoT
[('2015-11-01', 'id123', '8', '4'), ('2015-11-01', 'id456', '14', '9')]
</code></pre>
<p>If you can assume that <code>impressions</code> and <code>clicks</code> are already in order, you can eliminate <code>max</code> and <code>min</code> and replace that line with:</p>
<pre><code>impressions, clicks=ddict[(d, id)][0][1], ddict[(d, id)][1][1]
</code></pre>
</div>
<span class="comment-copy">I couldnt understand the result, could you put that in another words?</span>
<span class="comment-copy">The result lists need to follow the 'fields' structure. Matched by 'date' and 'id'. The words 'impressions' and 'clicks' are omitted because it's in order, and it can be assumed that '8' is 'impressions' and '4' is clicks.</span>
<span class="comment-copy">This works perfectly for instances where the "L" will always have the 'impressions' and 'clicks' following it. How would you revise this in the event that "L" looks like: [('2015-11-01', 'id123', 'impressions', '8'), ('2015-11-01', 'id123', 'clicks', '4'), ('2015-11-01', 'id456', 'clicks', '9'), ('2015-11-01', 'id456', 'impressions', '14')] but still follow the 'fields' order mentioned above?</span>
<span class="comment-copy">@PieCharmed, I've added a way to cope with that to my answer</span>
<span class="comment-copy">Looks like there might only be one each of impressions and clicks for each date/id combo. If that's the case you can simplify this quite a lot</span>
<span class="comment-copy">@JohnLaRooy: Yeah, missed that there were only one each, and they were strings, not integers. This is my "general case" solution? :-)</span>
<span class="comment-copy"><code>outlist = [k + (next(grp)[-1], next(grp)[-1]) for k, grp in itertools.groupby(L, key=itemgetter(0, 1))] </code></span>
