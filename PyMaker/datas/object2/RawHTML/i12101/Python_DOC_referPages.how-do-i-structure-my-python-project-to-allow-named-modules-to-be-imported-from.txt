<div class="post-text" itemprop="text">
<p>This is my directory structure:</p>
<pre><code>Projects
    + Project_1
    + Project_2
    - Project_3
        - Lib1
            __init__.py # empty
            moduleA.py
        - Tests
            __init__.py # empty
            foo_tests.py
            bar_tests.py
            setpath.py
        __init__.py     # empty
        foo.py
        bar.py
</code></pre>
<p>Goals:</p>
<ol>
<li>Have an organized project structure</li>
<li>Be able to independently run each .py file when necessary</li>
<li>Be able to reference/import both sibling and <strong>cousin</strong> modules</li>
<li>Keep all import/from statements at the beginning of each file.</li>
</ol>
<p>I Achieved #1 by using the above structure</p>
<p>I've mostly achieved 2, 3, and 4 by doing the following (as recommended by <a href="http://docs.python-guide.org/en/latest/writing/structure/">this excellent guide</a>)</p>
<p>In any package that needs to access parent or cousin modules (such as the Tests directory above) I include a file called setpath.py which has the following code:</p>
<pre><code>import os
import sys
sys.path.insert(0, os.path.abspath('..'))

sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('...'))
</code></pre>
<p>Then, in each module that needs parent/cousin access, such as foo_tests.py, I can write a nice clean list of imports like so:</p>
<pre><code>import setpath      # Annoyingly, PyCharm warns me that this is an unused import statement
import foo.py
</code></pre>
<p>Inside setpath.py, the second and third inserts are not strictly necessary for this example, but are included as a troubleshooting step.</p>
<p>My problem is that this only works for imports that reference the module name directly, and not for imports that reference the package.  For example, inside bar_tests.py, neither of the two statements below work when running bar_tests.py <strong>directly</strong>.</p>
<pre><code>import setpath

import Project_3.foo.py  # Error
from Project_3 import foo  # Error
</code></pre>
<p>I receive the error "ImportError: No module named 'Project_3'".  </p>
<p>What is odd is that I can run the file directly from within PyCharm and it works fine. I know that PyCharm is doing some behind the scenes magic with the <code>Python Path</code> variable to make everything work, but I can't figure out what it is.  As PyCharm simply runs python.exe and sets some environmental variables, it should be possible to clone this behavior from within a Python script itself. </p>
<p>For reasons not really germane to this question, I have to reference <code>bar</code> using the <code>Project_3</code> qualifier.</p>
<p>I'm open to any solution that accomplishes the above while still meeting my earlier goals. I'm also open to an alternate directory structure if there is one that works better. I've read the <a href="https://docs.python.org/3/reference/import.html">Python doc on imports</a> and packages but am still at a loss. I think one possible avenue might be manually setting the <code>__path__</code> variable, but I'm not sure which one needs to be changed or what to set it to.</p>
</div>
<div class="post-text" itemprop="text">
<p>Those types of questions qualify as "primarily opinion based", so let me share my opinion how I would do it.</p>
<p>First "be able to independently run each .py file when necessary": either the file is an module, so it should not be called directly, or it is standalone executable, then it should import its dependencies starting from top level (you may avoid it in code or rather move it to common place, by using setup.py entry_points, but then your former executable effectively converts to a module). And yes, it is one of weak points of Python modules model, that causes misunderstandings.</p>
<p>Second, use virtualenv (or venv in Python3) and put each of your Project_x into separate one. This way project's name won't be part of Python module's path.</p>
<p>Third, link you've provided mentions setup.py â€“ you may make use of it. Put your custom code into Project_x/src/mylib1, create src/mylib1/setup.py and finally your modules into src/mylib1/mylib1/module.py. Then you may install your code by pip as any other package (or pip -e so you may work on the code directly without reinstalling it, though it unfortunately has some limitations).</p>
<p>And finally, as you've confirmed in comment already ;). Problem with your current model was that in <code>sys.path.insert(0, os.path.abspath('...'))</code> you'd mistakenly used Python module's notation, which in incorrect for system paths and should be replaced with <code>'../..'</code> to work as expected. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think your goals are not reasonable. Specifically, goal number 2 is a problem:</p>
<ol start="2">
<li>Be able to independently run each .py file when neccessary</li>
</ol>
<p>This doesn't work well for modules in a package. At least, not if you're running the <code>.py</code> files naively (e.g. with <code>python foo_tests.py</code> on the command line). When you run the files that way, Python can't tell where the package hierarchy should start.</p>
<p>There are two alternatives that can work. The first option is to run your scripts from the top level folder (e.g. <code>projects</code>) using the <code>-m</code> flag to the interpreter to give it a dotted path to the main module, and using explicit relative imports to get the sibling and cousin modules. So rather than running <code>python foo_tests.py</code> directly, run <code>python -m project_3.tests.foo_tests</code> from the <code>projects</code> folder (or <code>python -m tests.foo_tests</code> from within <code>project_3</code> perhaps), and have have <code>foo_tests.py</code> use <code>from .. import foo</code>.</p>
<p>The other (less good) option is to add a top-level folder to your Python installation's module search path on a system wide basis (e.g. add the <code>projects</code> folder to the <code>PYTHON_PATH</code> environment variable), and then use absolute imports for all your modules (e.g. <code>import project3.foo</code>). This is effectively what your <code>setpath</code> module does, but doing it system wide as part of your system's configuration, rather than at run time, it's much cleaner. It also avoids the multiple names that <code>setpath</code> will allow to you use to import a module (e.g. try <code>import foo_tests, tests.foo_tests</code> and you'll get two <em>separate</em> copies of the same module).</p>
</div>
<span class="comment-copy">Though I completely agree with @Blckknght answer (and before he published, even started writing similar in the same tone). It's maybe worth mention, that unless it's another typo, your current model may not work due to sys.path.insert(0, os.path.abspath('...')), as '...' is not a valid parent path selector. Here you should use regular '../..' filesystem notation not Python's parent modules one.</span>
<span class="comment-copy">@RobertT Unbelievable! So simple, but it corrects the problem and it seems that this is allowing me to set relative roots for both packages and modules. I still think something more robust could be implemented using the Import libraries, but this does answer my questio, achieving the above goals. Make it an answer please and I'll consider it for the bounty award.</span>
<span class="comment-copy">Thanks for the response, but both solutions require steps be taken outside of the python scripts themselves. In other words there's no way to programmatically implement either solution from within a Python script, and it seems like there should be. You state that "When you run the files that way, Python can't tell where the package hierarchy should start." But it should be possible to do exactly this, to tell Python where a package starts from within a script. I think that this is exactly what the import modules are for , I just can't figure out how to use them to get the desired behavior.</span>
