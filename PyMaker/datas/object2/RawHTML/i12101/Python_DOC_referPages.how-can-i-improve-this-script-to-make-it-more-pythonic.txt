<div class="post-text" itemprop="text">
<p>I'm fairly new to Python programming, and have thus far been reverse engineering code that previous developers have made, or have cobbled together some functions on my own. </p>
<p>The script itself works; to cut a long story short, its designed to parse a CSV and to (a) create and or update the contacts found in the CSV, and (b) to correctly assign the contact to their associated company. All using the <a href="http://developers.hubspot.com/docs/overview" rel="nofollow">HubSpot API</a>. To achieve this i've also imported <a href="https://github.com/kennethreitz/requests" rel="nofollow">requests</a> and <a href="https://github.com/samarjeet27/CSV-Mapper" rel="nofollow">csvmapper</a>.</p>
<p>I had the following questions:</p>
<ol>
<li>How can I improve this script to make it more pythonic?</li>
<li>What is the best way to make this script run on a remote server,
keeping in mind that Requests and CSVMapper probably aren't
installed on that server, and that I most likely won't have
permission to install them - what is the best way to "package" this
script, or to upload Requests and CSVMapper to the server?</li>
</ol>
<p>Any advice much appreciated.</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import sys, os.path, requests, json, csv, csvmapper, glob, shutil
from time import sleep
major, minor, micro, release_level, serial =  sys.version_info

# Client Portal ID
portal = "XXXXXX"

# Client API Key

hapikey = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"

# This attempts to find any file in the directory that starts with "note" and ends with ".CSV"
# Server Version
# findCSV = glob.glob('/home/accountName/public_html/clientFolder/contact*.CSV')

# Local Testing Version
findCSV = glob.glob('contact*.CSV')

for i in findCSV:

    theCSV = i

    csvfileexists = os.path.isfile(theCSV)

    # Prints a confirmation if file exists, prints instructions if it doesn't.

    if csvfileexists:
        print ("\nThe \"{csvPath}\" file was found ({csvSize} bytes); proceeding with sync ...\n".format(csvSize=os.path.getsize(theCSV), csvPath=os.path.basename(theCSV)))
    else:
        print ("File not found; check the file name to make sure it is in the same directory as this script. Exiting ...")
        sys.exit()

    # Begin the CSVmapper mapping... This creates a virtual "header" row - the CSV therefore does not need a header row.

    mapper = csvmapper.DictMapper([
      [
        {'name':'account'}, #"Org. Code"
        {'name':'id'}, #"Hubspot Ref"
        {'name':'company'}, #"Company Name"
        {'name':'firstname'}, #"Contact First Name"
        {'name':'lastname'}, #"Contact Last Name"
        {'name':'job_title'}, #"Job Title"
        {'name':'address'}, #"Address"
        {'name':'city'}, #"City"
        {'name':'phone'}, #"Phone"
        {'name':'email'}, #"Email"
        {'name':'date_added'} #"Last Update"
      ]
    ])

    # Parse the CSV using the mapper
    parser = csvmapper.CSVParser(os.path.basename(theCSV), mapper)

    # Build the parsed object
    obj = parser.buildObject()

    def contactCompanyUpdate():

        # Open the CSV, use commas as delimiters, store it in a list called "data", then find the length of that list.
        with open(os.path.basename(theCSV),"r") as f:
            reader = csv.reader(f, delimiter = ",", quotechar="\"")
            data = list(reader)

            # For every row in the CSV ...
            for row in range(0, len(data)):
                # Set up the JSON payload ...

                payload = {
                            "properties": [
                                {
                                    "name": "account",
                                    "value": obj[row].account
                                },
                                {
                                    "name": "id",
                                    "value": obj[row].id
                                },
                                {
                                    "name": "company",
                                    "value": obj[row].company
                                },
                                {
                                    "property": "firstname",
                                    "value": obj[row].firstname
                                },
                                {
                                    "property": "lastname",
                                    "value": obj[row].lastname
                                },
                                {
                                    "property": "job_title",
                                    "value": obj[row].job_title
                                },
                                {
                                    "property": "address",
                                    "value": obj[row].address
                                },
                                {
                                    "property": "city",
                                    "value": obj[row].city
                                },
                                {
                                    "property": "phone",
                                    "value": obj[row].phone
                                },
                                {
                                    "property": "email",
                                    "value": obj[row].email
                                },
                                {
                                    "property": "date_added",
                                    "value": obj[row].date_added
                                }
                            ]
                        }

                nameQuery = "{first} {last}".format(first=obj[row].firstname, last=obj[row].lastname)

                # Get a list of all contacts for a certain company.
                contactCheck = "https://api.hubapi.com/contacts/v1/search/query?q={query}&amp;hapikey={hapikey}".format(hapikey=hapikey, query=nameQuery)

                # Convert the payload to JSON and assign it to a variable called "data"
                data = json.dumps(payload)

                # Defined the headers content-type as 'application/json'
                headers = {'content-type': 'application/json'}

                contactExistCheck = requests.get(contactCheck, headers=headers)

                for i in contactExistCheck.json()[u'contacts']:

                    # ... Get the canonical VIDs
                    canonicalVid = i[u'canonical-vid']

                    if canonicalVid:
                        print ("{theContact} exists! Their VID is \"{vid}\"".format(theContact=obj[row].firstname, vid=canonicalVid))
                        print ("Attempting to update their company...")
                        contactCompanyUpdate = "https://api.hubapi.com/companies/v2/companies/{companyID}/contacts/{vid}?hapikey={hapikey}".format(hapikey=hapikey, vid=canonicalVid, companyID=obj[row].id)
                        doTheUpdate = requests.put(contactCompanyUpdate, headers=headers)
                        if doTheUpdate.status_code == 200:
                            print ("Attempt Successful! {theContact}'s has an updated company.\n".format(theContact=obj[row].firstname))
                            break
                        else:
                            print ("Attempt Failed. Status Code: {status}. Company or Contact not found.\n".format(status=doTheUpdate.status_code))

    def createOrUpdateClient():

        # Open the CSV, use commas as delimiters, store it in a list called "data", then find the length of that list.
        with open(os.path.basename(theCSV),"r") as f:
            reader = csv.reader(f, delimiter = ",", quotechar="\"")
            data = list(reader)

            # For every row in the CSV ...
            for row in range(0, len(data)):
                # Set up the JSON payload ...

                payloadTest = {
                            "properties": [
                                {
                                    "property": "email",
                                    "value": obj[row].email
                                },
                                {
                                    "property": "firstname",
                                    "value": obj[row].firstname
                                },
                                {
                                    "property": "lastname",
                                    "value": obj[row].lastname
                                },
                                {
                                    "property": "website",
                                    "value": None
                                },
                                {
                                    "property": "company",
                                    "value": obj[row].company
                                },
                                {
                                    "property": "phone",
                                    "value": obj[row].phone
                                },
                                {
                                    "property": "address",
                                    "value": obj[row].address
                                },
                                {
                                    "property": "city",
                                    "value": obj[row].city
                                },
                                {
                                    "property": "state",
                                    "value": None
                                },
                                {
                                    "property": "zip",
                                    "value": None
                                }
                            ]
                        }

                # Convert the payload to JSON and assign it to a variable called "data"
                dataTest = json.dumps(payloadTest)

                # Defined the headers content-type as 'application/json'
                headers = {'content-type': 'application/json'}

                #print ("{theContact} does not exist!".format(theContact=obj[row].firstname))
                print ("Attempting to add {theContact} as a contact...".format(theContact=obj[row].firstname))
                createOrUpdateURL = 'http://api.hubapi.com/contacts/v1/contact/createOrUpdate/email/{email}/?hapikey={hapikey}'.format(email=obj[row].email,hapikey=hapikey)

                r = requests.post(createOrUpdateURL, data=dataTest, headers=headers)

                if r.status_code == 409:
                    print ("This contact already exists.\n")
                elif (r.status_code == 200) or (r.status_code == 202):
                    print ("Success! {firstName} {lastName} has been added.\n".format(firstName=obj[row].firstname,lastName=obj[row].lastname, response=r.status_code))
                elif r.status_code == 204:
                    print ("Success! {firstName} {lastName} has been updated.\n".format(firstName=obj[row].firstname,lastName=obj[row].lastname, response=r.status_code))
                elif r.status_code == 400:
                    print ("Bad request. You might get this response if you pass an invalid email address, if a property in your request doesn't exist, or if you pass an invalid property value.\n")
                else:
                    print ("Contact Marko for assistance.\n")

    if __name__ == "__main__":
        # Run the Create or Update function
        createOrUpdateClient()

        # Give the previous function 5 seconds to take effect.
        sleep(5.0)

        # Run the Company Update function
        contactCompanyUpdate()
        print("Sync complete.")

        print("Moving \"{something}\" to the archive folder...".format(something=theCSV))

        # Cron version
        #shutil.move( i, "/home/accountName/public_html/clientFolder/archive/" + os.path.basename(i))

        # Local version
        movePath = "archive/{thefile}".format(thefile=theCSV)
        shutil.move( i, movePath )

        print("Move successful! Exiting...\n")

sys.exit()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'll just go from top to bottom. The first rule is, do what's in <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP 8.</a> It's not the ultimate style guide, but it's certainly a reference baseline for Python coders, and that's more important, especially when you're getting started. The second rule is, make it maintainable. A couple of years from now, when some other new kid comes through, it should be easy for her to figure out what you were doing. Sometimes that means doing things the long way, to reduce errors. Sometimes it means doing things the short way, to reduce errors. :-)</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
</code></pre>
<p>Two things: you got the encoding right, per PEP 8. And </p>
<blockquote>
<p>Conventions for writing good documentation strings (a.k.a. "docstrings") are immortalized in <a href="https://www.python.org/dev/peps/pep-0257/" rel="nofollow">PEP 257.</a></p>
</blockquote>
<p>You've got a program that does something. But you don't document what.</p>
<pre><code>from __future__ import print_function
import sys, os.path, requests, json, csv, csvmapper, glob, shutil
from time import sleep
major, minor, micro, release_level, serial =  sys.version_info
</code></pre>
<p>Per PEP 8: put your <code>import module</code> statements one per line.</p>
<p>Per Austin: make your paragraphs have separate subjects. You've got some imports right next to some version info stuff. Insert a blank line. Also, DO SOMETHING with the data! Or you didn't need it to be right here, did you?</p>
<pre><code># Client Portal ID
portal = "XXXXXX"

# Client API Key

hapikey = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
</code></pre>
<p>You've obscured these in more ways than one. WTF is a hapikey? I think you mean <code>Hubspot_API_key</code>. And what does <code>portal</code> do?</p>
<p>One piece of advice: the more "global" a thing is, the more "formal" it should be. If you have a for loop, it's okay to call one of the variables <code>i</code>. If you have a piece of data that is used throughout a function, call it <code>obj</code> or <code>portal</code>. But if you have a piece of data that is used globally, or is a class variable, make it put on a tie and a jacket so everyone can recognize it: make it <code>Hubspot_api_key</code> instead of <code>client_api_key</code>. Maybe even <code>Hubspot_client_api_key</code> if there are more than one API. Do the same with <code>portal</code>.</p>
<pre><code># This attempts to find any file in the directory that starts with "note" and ends with ".CSV"
# Server Version
# findCSV = glob.glob('/home/accountName/public_html/clientFolder/contact*.CSV')
</code></pre>
<p>It didn't take long for the comments to become lies. Just delete them if they aren't true.</p>
<pre><code># Local Testing Version
findCSV = glob.glob('contact*.CSV')
</code></pre>
<p>This is the kind of thing that you should create a function for. Just create a simple function called "get_csv_files" or whatever, and have it return a list of filenames. That decouples you from glob, and it means you can make your test code data driven (pass a list of filenames into a function, or pass a single file into a function, instead of asking it to search for them). Also, those glob patterns are exactly the kind of thing that go in a config file, or a global variable, or get passed as command line arguments.</p>
<pre><code>for i in findCSV:
</code></pre>
<p>I'll bet typing CSV in upper case all the time is a pain. And what does <code>findCSV</code> mean? Read that line, and figure out what that variable should be called. Maybe <code>csv_files</code>? Or <code>new_contact_files</code>? Something that demonstrates that there is a collection of things. </p>
<pre><code>    theCSV = i
    csvfileexists = os.path.isfile(theCSV)
</code></pre>
<p>Now what does <code>i</code> do? You had this nice small variable name, in a BiiiiiiG loop. That was a mistake, since if you can't see a variable's entire scope all on one page, it probably needs a somewhat longer name. But then you created an alias for it. Both <code>i</code> and <code>theCSV</code> refer to the same thing. And ... I don't see you using <code>i</code> again. So maybe your loop variable should be <code>theCSV</code>. Or maybe it should be <code>the_csv</code> to make it easier to type. Or just <code>csvname</code>. </p>
<pre><code>    # Prints a confirmation if file exists, prints instructions if it doesn't.
</code></pre>
<p>This seems a little needless. If you're using <code>glob</code> to get filenames, they pretty much are going to exist. (If they don't, it's because they were deleted between the time you called <code>glob</code> and the time you tried to open them. That's possible, but rare. Just <code>continue</code> or raise an exception, depending.)</p>
<pre><code>    if csvfileexists:
        print ("\nThe \"{csvPath}\" file was found ({csvSize} bytes); proceeding with sync ...\n".format(csvSize=os.path.getsize(theCSV), csvPath=os.path.basename(theCSV)))
</code></pre>
<p>In this code, you use the value of <code>csvfileexists</code>. But that's the only place you use it. In this case, you can probably move the call to <code>os.path.isfile()</code> into the if statement and get rid of the variable.</p>
<pre><code>    else:
        print ("File not found; check the file name to make sure it is in the same directory as this script. Exiting ...")
        sys.exit()
</code></pre>
<p>Notice that in this case, when there is an <strong>actual problem,</strong> you didn't print the file name? How helpful was that?</p>
<p>Also, remember the part where you're on a remote server? You should consider using Python's <a href="https://docs.python.org/3/library/logging.html" rel="nofollow"><code>logging</code> module</a> to record these messages in a useful manner.</p>
<pre><code># Begin the CSVmapper mapping... This creates a virtual "header" row - the CSV therefore does not need a header row.

mapper = csvmapper.DictMapper([
  [
    {'name':'account'}, #"Org. Code"
    {'name':'id'}, #"Hubspot Ref"
    {'name':'company'}, #"Company Name"
    {'name':'firstname'}, #"Contact First Name"
    {'name':'lastname'}, #"Contact Last Name"
    {'name':'job_title'}, #"Job Title"
    {'name':'address'}, #"Address"
    {'name':'city'}, #"City"
    {'name':'phone'}, #"Phone"
    {'name':'email'}, #"Email"
    {'name':'date_added'} #"Last Update"
  ]
])
</code></pre>
<p>You're creating an object with a bunch of data. This would be a good place for a function. Define a <code>make_csvmapper()</code> function to do all this for you, and move it out of line. </p>
<p>Also, note that the standard <a href="https://docs.python.org/3/library/csv.html" rel="nofollow"><code>csv</code> module</a> has most of the functionality you are using. I don't think you actually need <code>csvmapper</code>.</p>
<pre><code># Parse the CSV using the mapper
parser = csvmapper.CSVParser(os.path.basename(theCSV), mapper)

# Build the parsed object
obj = parser.buildObject()
</code></pre>
<p>Here's another chance for a function. Maybe instead of making a csv mapper, you could just return the <code>obj</code>? </p>
<pre><code>def contactCompanyUpdate():
</code></pre>
<p>At this point, things get fishy. You have these function definitions indented, but I don't think you need them. Is that a stackoverflow problem, or does your code really look like this?</p>
<pre><code>    # Open the CSV, use commas as delimiters, store it in a list called "data", then find the length of that list.

    with open(os.path.basename(theCSV),"r") as f:
</code></pre>
<p>No, apparently it really looks like this. Because you're using <code>theCSV</code> inside this function when you don't really need to. Please consider using formal function parameters instead of just grabbing outer-scope objects. Also, why are you using <code>basename</code> on the csv file? If you obtained it using <code>glob</code>, doesn't it already have the path you want?</p>
<pre><code>        reader = csv.reader(f, delimiter = ",", quotechar="\"")
        data = list(reader)

        # For every row in the CSV ...
        for row in range(0, len(data)):
</code></pre>
<p>Here you forced <code>data</code> to be a list of rows obtained from <code>reader</code>, and then started iterating over them. Just iterate over <code>reader</code> directly, like: <code>for row in reader:</code> <strong>BUT WAIT!</strong> You're actually iterating over a CSV file that you have already opened, in your <code>obj</code> variable. Just pick one, and iterate over it. You don't need to open the file twice for this.</p>
<pre><code>            # Set up the JSON payload ...
            payload = {
                        "properties": [
                            {
                                "name": "account",
                                "value": obj[row].account
                            },
                            {
                                "name": "id",
                                "value": obj[row].id
                            },
                            {
                                "name": "company",
                                "value": obj[row].company
                            },
                            {
                                "property": "firstname",
                                "value": obj[row].firstname
                            },
                            {
                                "property": "lastname",
                                "value": obj[row].lastname
                            },
                            {
                                "property": "job_title",
                                "value": obj[row].job_title
                            },
                            {
                                "property": "address",
                                "value": obj[row].address
                            },
                            {
                                "property": "city",
                                "value": obj[row].city
                            },
                            {
                                "property": "phone",
                                "value": obj[row].phone
                            },
                            {
                                "property": "email",
                                "value": obj[row].email
                            },
                            {
                                "property": "date_added",
                                "value": obj[row].date_added
                            }
                        ]
                    }
</code></pre>
<p>Okay, that was a LOOOONG span of code that didn't do much. At the least, tighten those inner <code>dicts</code> up to one line each. But better still, write a function to create your dictionary in the format you want. You can use <code>getattr</code> to pull the data by name from <code>obj</code>. </p>
<pre><code>            nameQuery = "{first} {last}".format(first=obj[row].firstname, last=obj[row].lastname)

            # Get a list of all contacts for a certain company.
            contactCheck = "https://api.hubapi.com/contacts/v1/search/query?q={query}&amp;hapikey={hapikey}".format(hapikey=hapikey, query=nameQuery)
            # Convert the payload to JSON and assign it to a variable called "data"
            data = json.dumps(payload)

            # Defined the headers content-type as 'application/json'
            headers = {'content-type': 'application/json'}

            contactExistCheck = requests.get(contactCheck, headers=headers)
</code></pre>
<p>Here you're encoding details of the API into your code. Consider pulling them out into functions. (That way, you can come back later and build a module of them, to re-use in your next program.) Also, beware of comments that don't actually tell you anything. And feel free to pull that together as a single paragraph, since it's all in service of the same key thing - making an API call.</p>
<pre><code>            for i in contactExistCheck.json()[u'contacts']:

                # ... Get the canonical VIDs
                canonicalVid = i[u'canonical-vid']

                if canonicalVid:
                    print ("{theContact} exists! Their VID is \"{vid}\"".format(theContact=obj[row].firstname, vid=canonicalVid))
                    print ("Attempting to update their company...")
                    contactCompanyUpdate = "https://api.hubapi.com/companies/v2/companies/{companyID}/contacts/{vid}?hapikey={hapikey}".format(hapikey=hapikey, vid=canonicalVid, companyID=obj[row].id)
                    doTheUpdate = requests.put(contactCompanyUpdate, headers=headers)
                    if doTheUpdate.status_code == 200:
                        print ("Attempt Successful! {theContact}'s has an updated company.\n".format(theContact=obj[row].firstname))
                        break
                    else:
                        print ("Attempt Failed. Status Code: {status}. Company or Contact not found.\n".format(status=doTheUpdate.status_code))
</code></pre>
<p>I'm not sure if this last bit should be an exception or not. Is an "Attempt Failed" normal behavior, or does it mean that something is broken?</p>
<p>At any rate, please look into the API you are using. I'd bet there is some more information available for minor failures. (Major failures would be the internet is broken or their server is offline.) They might provide an "errors" or "error" field in their return JSON, for example. Those should be logged or printed with your failure message.</p>
<pre><code>def createOrUpdateClient():
</code></pre>
<p>Mostly this function has the same issues as the previous one.</p>
<pre><code>            else:
                print ("Contact Marko for assistance.\n")
</code></pre>
<p>Except here. <em>Never</em> put your name in someplace like this. Or you'll still be getting calls on this code 10 years from now. Put your department name ("IT Operations") or a support number. The people who need to know will already know. And the people who don't need to know can just notify the people that already know. </p>
<pre><code>if __name__ == "__main__":
    # Run the Create or Update function
    createOrUpdateClient()

    # Give the previous function 5 seconds to take effect.
    sleep(5.0)

    # Run the Company Update function
    contactCompanyUpdate()
    print("Sync complete.")

    print("Moving \"{something}\" to the archive folder...".format(something=theCSV))

    # Cron version
    #shutil.move( i, "/home/accountName/public_html/clientFolder/archive/" + os.path.basename(i))

    # Local version
    movePath = "archive/{thefile}".format(thefile=theCSV)
    shutil.move( i, movePath )

    print("Move successful! Exiting...\n")
</code></pre>
<p>This was awkward. You might consider taking some command line arguments and using them to determine your behavior.</p>
<pre><code>sys.exit()
</code></pre>
<p>And don't do this. Never put an <code>exit()</code> at module scope, because it means you can't possibly import this code. Maybe someone wants to import it to parse the docstrings. Or maybe they want to borrow some of those API functions you wrote. Too bad! <code>sys.exit()</code> means always having to say "Oh, sorry, I'll <strong>have to do that for you.</strong>" Put it at the bottom of your actual <code>__name__ == "__main__"</code> code. Or, since you aren't actually passing a value, just remove it entirely.</p>
</div>
<span class="comment-copy">You don't need to import <code>print_function</code> from <code>__future__</code>.  It should work fine as a statement.</span>
<span class="comment-copy">You should move this to Code Review.</span>
<span class="comment-copy">Thanks @zondo - and good call Austin, I wasn't aware that Code Review was a thing :)</span>
<span class="comment-copy">Do please read <a href="http://meta.codereview.stackexchange.com/questions/5777/a-guide-to-code-review-for-stack-overflow-users">Guide to Code Review for Stack Overflow users</a> to verify that your post is on-topic before moving to Code Review.</span>
<span class="comment-copy">Thanks guys - when I've earned enough points in Code Review i'll transfer this question there - in the meantime, the second question still stands :)</span>
<span class="comment-copy">Austin thank you so much for taking the time to absolutely tear that script apart, I really appreciate it - extremely valid and useful points. I've clearly got a long way to go - I'll be pouring over this response for the next week! :)</span>
<span class="comment-copy">Happy to help. Be sure and edit your question when you get it fixed. ;-)</span>
