<div class="post-text" itemprop="text">
<p>Presumably dict_keys are supposed to behave as a set-like object, but they are lacking the <code>difference</code> method and the subtraction behaviour seems to diverge.</p>
<pre><code>&gt;&gt;&gt; d = {0: 'zero', 1: 'one', 2: 'two', 3: 'three'}
&gt;&gt;&gt; d.keys() - [0, 2]
{1, 3}
&gt;&gt;&gt; d.keys() - (0, 2)
TypeError: 'int' object is not iterable
</code></pre>
<p>Why does dict_keys class try to iterate an integer here?  Doesn't that violate duck-typing? </p>
<hr/>
<pre><code>&gt;&gt;&gt; dict.fromkeys(['0', '1', '01']).keys() - ('01',)
{'01'}
&gt;&gt;&gt; dict.fromkeys(['0', '1', '01']).keys() - ['01',]
{'1', '0'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This looks to be a bug. <a href="https://hg.python.org/cpython/file/v3.5.1/Objects/dictobject.c#l3437" rel="noreferrer">The implementation is to convert the <code>dict_keys</code> to a <code>set</code>, then call <code>.difference_update(arg)</code> on it.</a></p>
<p>It looks like they misused <code>_PyObject_CallMethodId</code> (an optimized variant of <code>PyObject_CallMethod</code>), by passing a format string of just <code>"O"</code>. <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_CallMethod" rel="noreferrer">Thing is, <code>PyObject_CallMethod</code> and friends are documented to require a <code>Py_BuildValue</code> format string that "should produce a <code>tuple</code>"</a>. With more than one format code, it wraps the values in a <code>tuple</code> automatically, but with only one format code, it doesn't <code>tuple</code>, it just creates the value (in this case, because it's already <code>PyObject*</code>, all it does is increment the reference count).</p>
<p>While I haven't tracked down where it might be doing this, I suspect somewhere in the internals it's identifying <code>CallMethod</code> calls that don't produce a <code>tuple</code> and wrapping them to make a one element <code>tuple</code> so the called function can actually receive the arguments in the expected format. When subtracting a <code>tuple</code>, it's already a <code>tuple</code>, and this fix up code never activates; when passing a <code>list</code>, it does, becoming a one element <code>tuple</code> containing the <code>list</code>.</p>
<p><code>difference_update</code> takes varargs (as if it were declared <code>def difference_update(self, *args)</code>). So when it receives the unwrapped <code>tuple</code>, it thinks it's supposed to subtract away the elements from each entry in the <code>tuple</code>, not treat said entries as values to subtract away themselves. To illustrate, when you do:</p>
<pre><code>mydict.keys() - (1, 2)
</code></pre>
<p>the bug is causing it to do (roughly):</p>
<pre><code>result = set(mydict)
# We've got a tuple to pass, so all's well...
result.difference_update(*(1, 2)) # Unpack behaves like difference_update(1, 2)
# OH NO!
</code></pre>
<p>While:</p>
<pre><code>mydict.keys() - [1, 2]
</code></pre>
<p>does:</p>
<pre><code>result = set(mydict)
# [1, 2] isn't a tuple, so wrap
result.difference_update(*([1, 2],)) # Behaves like difference_update([1, 2])
# All's well
</code></pre>
<p>That's why a <code>tuple</code> of <code>str</code> works (incorrectly), <code>- ('abc', '123')</code> is performing a call equivalent to:</p>
<pre><code>result.difference_update(*('abc', '123'))
# or without unpacking:
result.difference_update('abc', '123')
</code></pre>
<p>and since <code>str</code>s are iterables of their characters, it just blithely removes entries for <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, etc. instead of <code>'abc'</code> and <code>'123'</code> like you expected.</p>
<p>Basically, this is a bug and (when I get a chance), I'll file it against the CPython folks.</p>
<p>The correct behavior probably should have been to call (assuming this <code>Id</code> variant exists for this API):</p>
<pre><code>_PyObject_CallMethodObjArgsId(result, &amp;PyId_difference_update, other, NULL);
</code></pre>
<p>which wouldn't have the packing issues at all, and would run faster to boot; the smallest change would be to change the format string to <code>"(O)"</code> to force <code>tuple</code> creation even for a single item, but since the format string gains nothing, <code>_PyObject_CallMethodObjArgsId</code> is better.</p>
</div>
<span class="comment-copy">Tuples are immutable, and could therefore be keys of the dictionary themselves, in which case this would be ambiguous â€” if not syntactically then at least in the mind of a programmer.</span>
<span class="comment-copy">@L3viathan I'm not convinced, because <code>dict.fromkeys('0123').keys() - '02'</code> still works</span>
<span class="comment-copy">Yeah, good point.</span>
<span class="comment-copy">Are only <code>tuple</code>s of <code>int</code>s special? <code>dict.fromkeys('0123').keys() - ('0', '2')</code> gives <code>{'1', '3'}</code>.</span>
<span class="comment-copy">Interestingly, dictionary view-mappings are supposed to be 'set'-like, but sets do not support this: <code>set((0,1,2,3)) - [0,2]</code> results in <i>unsupported operand for 'set' and 'str'</i>.</span>
<span class="comment-copy"><a href="https://bugs.python.org/issue26478" rel="nofollow noreferrer">Issue #26478 opened</a>.</span>
<span class="comment-copy">And now it's fixed (though you'll have to wait for the next minor release of 3.4/3.5 or for 3.6.0 for the fix to be incorporated into the main builds).</span>
