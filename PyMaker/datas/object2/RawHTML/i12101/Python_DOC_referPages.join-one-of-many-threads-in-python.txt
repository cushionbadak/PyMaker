<div class="post-text" itemprop="text">
<p>I have a python program with one main thread and let's say 2 other threads (or maybe even more, probably doesn't matter). I would like to let the main thread sleep until ONE of the other threads is finished. It's easy to do with polling (by calling t.join(1) and waiting for one second for every thread t). </p>
<p>Is it possible to do it without polling, just by</p>
<pre><code>SOMETHING_LIKE_JOIN(1, [t1, t2])
</code></pre>
<p>where t1 and t2 are threading.Thread objects? The call must do the following: sleep 1 second, but wake up as soon as one of t1,t2 is finished. Quite similar to POSIX select(2) call with two file descriptors.</p>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to use a <code>multiprocessing.dummy.Pool</code>; <code>multiprocessing.dummy</code> provides an API almost identical to <code>multiprocessing</code>, but backed by threads, so it gets you a thread pool for free.</p>
<p>For example, you can do:</p>
<pre><code>from multiprocessing.dummy import Pool as ThreadPool

pool = ThreadPool(2)  # Two workers
for res in pool.imap_unordered(some_func, list_of_func_args):
    # res is whatever some_func returned
</code></pre>
<p><a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered" rel="nofollow"><code>multiprocessing.Pool.imap_unordered</code></a> returns results as they become available, regardless of which task finishes first.</p>
<p>If you can use Python 3.2 or higher (or install the <code>concurrent.futures</code> PyPI module for older Python) you can generalize to disparate task functions by creating one or more <code>Future</code>s from a <code>ThreadPoolExecutor</code>, then using <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.wait" rel="nofollow"><code>concurrent.futures.wait</code></a> with <code>return_when=FIRST_COMPLETED</code>, or using <code>concurrent.futures.as_completed</code> for similar effect.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example of using condition object. </p>
<pre><code>from threading import Thread, Condition, Lock
from time import sleep
from random import random


_lock = Lock()


def run(idx, condition):
    sleep(random() * 3)
    print('thread_%d is waiting for notifying main thread.' % idx)
    _lock.acquire()
    with condition:
        print('thread_%d notifies main thread.' % idx)
        condition.notify()


def is_working(thread_list):
    for t in thread_list:
        if t.is_alive():
            return True
    return False


def main():
    condition = Condition(Lock())
    thread_list = [Thread(target=run, kwargs={'idx': i, 'condition': condition}) for i in range(10)]

    with condition:
        with _lock:
            for t in thread_list:
                t.start()

            while is_working(thread_list):
                _lock.release()
                if condition.wait(timeout=1):
                    print('do something')
                    sleep(1)  # &lt;-- Main thread is doing something.
                else:
                    print('timeout')

    for t in thread_list:
        t.join()


if __name__ == '__main__':
    main()
</code></pre>
<p>I don't think there is race condition as you described in comment. The condition object contains a Lock. When the main thread is working(sleep(1) in the example), it holds the lock and no thread can notify it until it finishes its work and release the lock.</p>
<hr/>
<p>I just realize that there is a race condition in the previous example. I added a global _lock to ensure the condition never notifies the main thread until the main thread starts waiting. I don't like how it works, but I haven't figured out a better solution...</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a Thread Class and the main thread keeps a reference to it. So you can check whether the thread has finished and make your main thread continue again easily.</p>
<p>If that doesn't helped you, I suggest you to look at the <strong>Queue</strong> library!</p>
<pre><code>import threading
import time, random


#THREAD CLASS#
class Thread(threading.Thread):

    def __init__(self):
        threading.Thread.__init__(self)

        self.daemon = True
        self.state = False

        #START THREAD (THE RUN METHODE)#
        self.start()

    #THAT IS WHAT THE THREAD ACTUALLY DOES#
    def run(self):

        #THREAD SLEEPS FOR A RANDOM TIME RANGE# 
        time.sleep(random.randrange(5, 10))

        #AFTERWARDS IS HAS FINISHED (STORE IN VARIABLE)#
        self.state = True


    #RETURNS THE STATE#
    def getState(self):

        return self.state


#10 SEPERATE THREADS#
threads = []

for i in range(10):
    threads.append(Thread())

#MAIN THREAD#
while True:

    #RUN THROUGH ALL THREADS AND CHECK FOR ITS STATE#
    for i in range(len(threads)):
        if threads[i].getState():
            print "WAITING IS OVER: THREAD ", i 

    #SLEEPS ONE SECOND#
    time.sleep(1)
</code></pre>
</div>
<span class="comment-copy">Maybe Condition Object? The main thread waits for the condition object. t1 and t2 invokes condition_obj.notify() before they return. The thread which returns first wakes up the main thread. Here is the document of Condition Object: <a href="https://docs.python.org/3/library/threading.html#condition-objects" rel="nofollow noreferrer">link</a></span>
<span class="comment-copy">I see a race condition here: imagine t1 finished and called "notify", main thread wakes up, does some stuff and wants to go to sleep again (waiting for t2, t3, t4 etc). It can happen that during the main thread is "doing some stuff", some or even all of t2,....t4 threads will finish their work and call "notify". Then the main thread will call "wait" and sleep forever, because there is no one to wake it up anymore.</span>
<span class="comment-copy">there is no race condition. The condition object contains an RLock. I'll post an example later.</span>
<span class="comment-copy">Please use <code>with</code> statements with locks, conditions, etc. Avoids the risk of forgetting a <code>release</code>, and prevents exceptions from bypassing the <code>release</code>.Plus, it's shorter, the last four lines of <code>run</code> become: <code>with condition:</code>, <code>condition.notify()</code>, <code>print('thread_%d' % idx)</code></span>
<span class="comment-copy">Thank you for advising. I have edited run() and also the while block in main()</span>
<span class="comment-copy">Thanks. Up-voted.</span>
<span class="comment-copy">No, it will not do: the question was about a "no polling" solution, i.e. "sleep(1)" can't be called.</span>
