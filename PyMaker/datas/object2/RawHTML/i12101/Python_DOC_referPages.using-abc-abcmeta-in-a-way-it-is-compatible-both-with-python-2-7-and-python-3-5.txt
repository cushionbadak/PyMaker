<div class="post-text" itemprop="text">
<p>I'd like to create a class which has <code>abc.ABCMeta</code> as a metaclass and is compatible both with Python 2.7 and Python 3.5. Until now, I only succeeded doing this either on 2.7 or on 3.5 - but never on both versions simultaneously. Could someone give me a hand?</p>
<p>Python 2.7:</p>
<pre><code>import abc
class SomeAbstractClass(object):
    __metaclass__ = abc.ABCMeta
    @abc.abstractmethod
    def do_something(self):
        pass
</code></pre>
<p>Python 3.5:</p>
<pre><code>import abc
class SomeAbstractClass(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def do_something(self):
        pass
</code></pre>
<h2>Testing</h2>
<p>If we run the following test using the suitable version of the Python interpreter (Python 2.7 -&gt; Example 1, Python 3.5 -&gt; Example 2), it succeeds in both scenarios:</p>
<pre><code>import unittest
class SomeAbstractClassTestCase(unittest.TestCase):
    def test_do_something_raises_exception(self):
        with self.assertRaises(TypeError) as error:
            processor = SomeAbstractClass()
        msg = str(error.exception)
        expected_msg = "Can't instantiate abstract class SomeAbstractClass with abstract methods do_something"
        self.assertEqual(msg, expected_msg)
</code></pre>
<h2>Problem</h2>
<p>While running the test using Python 3.5, the expected behavior doesn't happen (<code>TypeError</code> is not raised while instantiating <code>SomeAbstractClass</code>):</p>
<pre><code>======================================================================
FAIL: test_do_something_raises_exception (__main__.SomeAbstractClassTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/tati/sample_abc.py", line 22, in test_do_something_raises_exception
    processor = SomeAbstractClass()
AssertionError: TypeError not raised

----------------------------------------------------------------------
</code></pre>
<p>Whereas running the test using Python 2.7 raises a <code>SyntaxError</code>:</p>
<pre><code> Python 2.7 incompatible
 Raises exception:
  File "/home/tati/sample_abc.py", line 24
    class SomeAbstractClass(metaclass=abc.ABCMeta):
                                     ^
 SyntaxError: invalid syntax
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://pythonhosted.org/six/#six.add_metaclass" rel="noreferrer"><code>six.add_metaclass</code></a> or <a href="https://pythonhosted.org/six/#six.with_metaclass" rel="noreferrer"><code>six.with_metaclass</code></a>:</p>
<pre><code>import abc, six

@six.add_metaclass(abc.ABCMeta)
class SomeAbstractClass():
    @abc.abstractmethod
    def do_something(self):
        pass
</code></pre>
<p><code>six</code> is a <a href="https://github.com/benjaminp/six" rel="noreferrer"><em>Python 2 and 3 compatibility library</em></a>. You can install it by running <code>pip install six</code> or by downloading the latest version of <code>six.py</code> to your project directory.</p>
<p>For those of you who prefer <code>future</code> over <code>six</code>, the relevant function is <a href="http://python-future.org/reference.html#future.utils.with_metaclass" rel="noreferrer"><code>future.utils.with_metaclass</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Using abc.ABCMeta in a way it is compatible both with Python 2.7 and Python 3.5</h1>
</blockquote>
<p>If we were only using Python 3 (this is <a href="https://docs.python.org/3/library/abc.html#abc.ABC" rel="noreferrer">new in 3.4</a>) we could do:</p>
<pre><code>from abc import ABC
</code></pre>
<p>and inherit from <code>ABC</code> instead of <code>object</code>. That is:</p>
<pre><code>class SomeAbstractClass(ABC):
    ...etc
</code></pre>
<p>You still don't need an extra dependence (the six module) - you can use the metaclass to create a parent (this is essentially what the six module does in with_metaclass):</p>
<pre><code>import abc

# compatible with Python 2 *and* 3:
ABC = abc.ABCMeta('ABC', (object,), {'__slots__': ()}) 

class SomeAbstractClass(ABC):

    @abc.abstractmethod
    def do_something(self):
        pass
</code></pre>
<p>Or you could just do it in-place (but this is more messy, and doesn't contribute as much to reuse):</p>
<pre><code># use ABCMeta compatible with Python 2 *and* 3 
class SomeAbstractClass(abc.ABCMeta('ABC', (object,), {'__slots__': ()})):

    @abc.abstractmethod
    def do_something(self):
        pass
</code></pre>
<p>Note that the signature looks a little messier than <a href="https://pythonhosted.org/six/#six.with_metaclass" rel="noreferrer"><code>six.with_metaclass</code></a> but it is substantially the same semantics, without the extra dependence.</p>
<h2>Either solution</h2>
<p>and now, when we try to instantiate without implementing the abstraction, we get precisely what we expect:</p>
<pre><code>&gt;&gt;&gt; SomeAbstractClass()
Traceback (most recent call last):
  File "&lt;pyshell#31&gt;", line 1, in &lt;module&gt;
    SomeAbstractClass()
TypeError: Can't instantiate abstract class SomeAbstractClass with abstract methods do_something
</code></pre>
<h2>Note on <code>__slots__ = ()</code></h2>
<p>We <a href="http://bugs.python.org/issue30463" rel="noreferrer">just added empty <code>__slots__</code></a> to the ABC convenience class in Python 3's standard library, and my answer is updated to include it.</p>
<p>Not having <code>__dict__</code> and <code>__weakref__</code> available in the <code>ABC</code> parent allows users to deny their creation for child classes and save memory - there are no downsides, unless you were using <code>__slots__</code> in child classes already and relying on implicit <code>__dict__</code> or <code>__weakref__</code> creation from the <code>ABC</code> parent. </p>
<p>The fast fix would be to declare <code>__dict__</code> or <code>__weakref__</code> in your child class as appropriate. Better (for <code>__dict__</code>) might be to declare all your members explicitly.</p>
</div>
<div class="post-text" itemprop="text">
<p>I prefer <a href="https://stackoverflow.com/a/38668373/2437514">Aaron Hall's answer</a>, but it's important to note that in this case the comment that is part of the line: </p>
<pre><code>ABC = abc.ABCMeta('ABC', (object,), {}) # compatible with Python 2 *and* 3 
</code></pre>
<p>...is every bit as important as the code itself. Without the comment, there is nothing to prevent some future cowboy down the road deleting the line and changing the class inheritance to: </p>
<pre><code>class SomeAbstractClass(abc.ABC):
</code></pre>
<p>...thus breaking everything pre Python 3.4. </p>
<p>One tweak that may be a little more explicit/clear to someone else- in that it is self documenting- regarding what it is you are trying to accomplish: </p>
<pre><code>import sys
import abc

if sys.version_info &gt;= (3, 4):
    ABC = abc.ABC
else:
    ABC = abc.ABCMeta('ABC', (), {})

class SomeAbstractClass(ABC):
    @abc.abstractmethod
    def do_something(self):
        pass
</code></pre>
<p>Strictly speaking, this isn't necessary to do, but it is absolutely clear, even without commentary, what is going on. </p>
</div>
<div class="post-text" itemprop="text">
<p>Just to say that you must explicitly pass <code>str('ABC')</code> to <code>abc.ABCMeta</code> in Python 2 if you use <code>from __future__ import unicode_literals</code>.</p>
<p>Otherwise Python raises <code>TypeError: type() argument 1 must be string, not unicode</code>.</p>
<p>See corrected code below.</p>
<pre><code>import sys
import abc
from __future__ import unicode_literals

if sys.version_info &gt;= (3, 4):
    ABC = abc.ABC
else:
    ABC = abc.ABCMeta(str('ABC'), (), {})
</code></pre>
<p>This would not require a separate answer but sadly I cannot comment yours (need more rep).</p>
</div>
<span class="comment-copy">fyi, the future.utils syntax is <code>class Test(with_metaclass(abc.ABCMeta, object)):</code></span>
<span class="comment-copy">I just wonder how difficult would be to clean this mess of six/future once the project gets fully migrated to python3.</span>
<span class="comment-copy">You can compare the version more concisely: <code>sys.version_info &gt;= (3, 4)</code>.</span>
<span class="comment-copy">I like the explicit version check since it's all too easy to miss/ignore comments.</span>
<span class="comment-copy">You should definitely go with the version from @zondo's comment and compare the version_info to a tuple. Comparing <code>version_info[0]</code> and <code>version_info[1]</code> independently will break on python 4.1</span>
<span class="comment-copy">@TheEspinosa I left it as-is out of laziness before, but I have changed it now because you are correct: the original code was broken for e.g. a future 4.1 version of Python.</span>
<span class="comment-copy">Or just use <code>b'ABC'</code></span>
