<div class="post-text" itemprop="text">
<p>I have written a code for design optimization using the Inspyred library and its implementation of Genetic Algorithms. In essence, the optimization process creates a large number of variations on a single data structure, which is a nested dictionary in my case.</p>
<p>In order to reduce the amount of memory used in the process, I have been trying to create some kind of differential dictionary type, which only stores items which are different from the base dictionary. The reason for this is that in a typical case, 95% of the data in the data structure will not be modified in any of the variations, but any part of the data structure can contain variations. So for flexibility reasons, I would like to have a data type that behaves more or less like a dictionary, but only stores the changes.</p>
<p>This is the result of my attempt to create this: </p>
<pre><code>#!/usr/bin/python

import unittest
import copy

global_base={}

class DifferentialDict(object):
    """
    dictionary with differential storage of changes
    all DifferentialDict objects have the same base dictionary
    """

    def __init__(self,base=None):
        global global_base

        self.changes={}

        if not base==None:
            self.set_base(base)

    def set_base(self,base):
        global global_base
        global_base=copy.deepcopy(base)

    def __copy__(self):
        return self

    def __deepcopy__(self):
        new=DifferentialDict()
        new.changes=copy.deepcopy(self.changes)
        return new

    def get(self):
        global global_base
        outdict=copy.deepcopy(global_base)
        for key in self.changes:
            outdict[key]=self.changes[key]
        return outdict

    def __setitem__(self,key,value):
        self.changes[key]=value

    def __getitem__(self,key):
        global global_base
        if key in self.changes:
            return self.changes[key]
        else:
            return global_base[key]

class TestDifferentialDict(unittest.TestCase):
    def test1(self):
        ldict={'a':{1:2,3:4},'b':{'c':[1,2,3],'d':'abc'}}
        ddict=DifferentialDict(base=ldict)

        self.assertEqual(ddict['a'],{1:2,3:4})
        ddict['a']=5
        self.assertEqual(ddict['a'],5)

    def test2(self):
        ldict={'a':{1:2,3:4},'b':{'c':[1,2,3],'d':'abc'}}
        ddict1=DifferentialDict(base=ldict)
        ddict2=DifferentialDict(base=ldict)

        ddict1['a'][3]=5
        ddict2['a'][3]=7
        self.assertEqual(ddict1['a'][3],5)
        self.assertEqual(ddict2['a'][3],7)

    def test3(self):
        ldict={'a':{1:2,3:4},'b':{'c':[1,2,3],'d':'abc'}}
        ddict1=DifferentialDict(base=ldict)
        ddict2=ddict1.__deepcopy__()

        ddict1['a'][3]=5
        ddict2['a'][3]=7
        self.assertEqual(ddict1['a'][3],5)
        self.assertEqual(ddict2['a'][3],7)



if __name__ == "__main__":
    unittest.main()
</code></pre>
<p>It works fine for a simple dictionary, but breaks down when new dictionaries are nested within the main dictionary. I understand that this happens because these second level dictionaries are real Python dictionaries instead of instantiations of my DifferentialDict, resulting in an overwriting of entries in global_base rather than changes in self.changes. However, they have to be because of the premise that all DifferentialDict instantiations share the same base dictionary. I could add an 'entry level' key to each DifferentialDict instantiation, but my feeling is that there is a more elegant solution which eludes me.</p>
<p>I would really appreciate any suggestions on how to get my differential dictionary working when nested. Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't have the time to try this right now (maybe a bit later), but here are two observations:</p>
<h1>combined indexes</h1>
<p>If you would use tuples as indexes, for example like this <code>dict[(5,3,2)]</code> you would not have this problem. If you base either your base dict or also the differential dicts on this, you could circumvent the problem.</p>
<p>Maybe you could even write some classes that rewrite <code>dict[a][b][c]</code>to <code>dict[(a,b,c)]</code> to make this internal change transparent.</p>
<h1>global base</h1>
<p>I don't understand why you use a global base. From my point of view this makes the code more complicated without adding anything. Why don't you just store the base as in:</p>
<pre><code>def MyDict(collections.abc.MutableSequence):
    def __init__(self, base):
        self._base = base

my_global_base = dict()
d = MyDict(my_global_base)

d[2] = 'abc' # modifies self._base inside of the instance too, because it is the
             # same object
</code></pre>
<p>If you want to change all the content of the base, just delete all items using <code>popitem()</code> and then add new ones using <code>update()</code>. This way your code is more flexible and does not have any surprising behavior because of the global variables.</p>
<h1>abstract base classes</h1>
<p>When reimplementing classes like sequences, dictionaries etc. it might come in handy to use the <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow">abstract base classes</a> provided by Python, they do some of the implementation work for you.</p>
</div>
<span class="comment-copy">Which tests are passing and which ones are failing?</span>
<span class="comment-copy">Tests 2 and 3 fail, 1 passes.</span>
<span class="comment-copy">I just found this library: <a href="https://github.com/inveniosoftware/dictdiffer" rel="nofollow noreferrer">dictdiffer</a> which might already implement it. On Hacker News there is a discussion about it where raymondh shows how to do this with non-nested dictionaries <a href="https://news.ycombinator.com/item?id=5771696" rel="nofollow noreferrer">in pure Python</a>.</span>
<span class="comment-copy">Thanks, Georg. As far as combining the keys in a tuple is concerned, I have considered this, but this results in a long key sequence for any element stored in the dictionary, which seems inefficient w.r.t. to the original aim of reducing the memory footprint.</span>
<span class="comment-copy">As far as the global base is concerned, the purpose of this is that it is shared by all instances of the DifferentialDict. From your suggestion I understand that a reference to the base object is passed upon instantiation of a new MyDict object, rather than that a local copy within the MyDict object is created. Is this correct? (yes, my knowledge/understanding of this is incomplete).</span>
<span class="comment-copy">And I will have a look at the abstract base classes, thanks for the suggestion.</span>
<span class="comment-copy">(1) I don't think I understand. Having a dictionary with tuples as keys should be <a href="http://stackoverflow.com/questions/7147785/">about the same as using nested dictionaries</a>. If you're concerned about the memory the dictionary implementation uses, I don't think Python is the right language. Every object (even an integer) has a substantial overhead.</span>
<span class="comment-copy">(2) Correct, everything gets <a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">passed by assignment</a> into functions in Python If you do: <code>a = {'key': 'frog'} ; b = a ; b['key'] = 'cat'</code>, then also `a['key'] == 'cat'. That works the same if you pass a dict into a function.</span>
