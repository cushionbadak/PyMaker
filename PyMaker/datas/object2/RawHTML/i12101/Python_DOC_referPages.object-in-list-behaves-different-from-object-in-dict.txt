<div class="post-text" itemprop="text">
<p>I've got an iterator with some objects in it and I wanted to create a collection of uniqueUsers in which I only list every user once. So playing around a bit I tried it with both a list and a dict:</p>
<pre><code>&gt;&gt;&gt; for m in ms: print m.to_user  # let's first look what's inside ms
...
Pete Kramer
Pete Kramer
Pete Kramer
&gt;&gt;&gt; 
&gt;&gt;&gt; uniqueUsers = []  # Create an empty list
&gt;&gt;&gt; for m in ms:
...     if m.to_user not in uniqueUsers:
...         uniqueUsers.append(m.to_user)
...
&gt;&gt;&gt; uniqueUsers
[Pete Kramer]  # This is what I would expect
&gt;&gt;&gt; 
&gt;&gt;&gt; uniqueUsers = {}  # Now let's create a dict
&gt;&gt;&gt; for m in ms:
...     if m.to_user not in uniqueUsers:
...         uniqueUsers[m.to_user] = 1
...
&gt;&gt;&gt; uniqueUsers
{Pete Kramer: 1, Pete Kramer: 1, Pete Kramer: 1}
</code></pre>
<p>So I tested it by converting the dict to a list when doing the if statement, and that works as I would expect it to:</p>
<pre><code>&gt;&gt;&gt; uniqueUsers = {}
&gt;&gt;&gt; for m in ms:
...     if m.to_user not in list(uniqueUsers):
...         uniqueUsers[m.to_user] = 1
...
&gt;&gt;&gt; uniqueUsers
{Pete Kramer: 1}
</code></pre>
<p>and I can get a similar result by testing against <code>uniqueUsers.keys()</code>. </p>
<p>The thing is that I don't understand why this difference occurs. I always thought that if you do <code>if object in dict</code>, it simply creates a list of the dicts keys and tests agains that, but that's obviously not the case.</p>
<p>Can anybody explain how <code>object in dict</code> internally works and why it doesn't behave similar to <code>object in list</code> (as I would expect it to)?</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to understand what’s going on, you have to understand how the <code>in</code> operator, the <a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow noreferrer">membership test</a>, behaves for the different types.</p>
<p>For lists, this is pretty simple due to what lists fundamentally are: Ordered arrays that do not care about duplicates. The only possible way to peform a membership test here is to iterate over the list and check every item on <em>equality</em>. Something like this:</p>
<pre><code># x in lst
for item in lst:
    if x == item:
        return True
return False
</code></pre>
<p>Dictionaries are a bit different: They are hash tables were keys are meant to be unique. Hash tables require the keys to be <em>hashable</em> which essentially means that there needs to be an explicit function that converts the object into an integer. This hash value is then used to put the key/value mapping somewhere into the hash table.</p>
<p>Since the hash value determines where in the hash table an item is placed, it’s critical that objects which are meant to be identical produce the same hash value. So the following implication has to be true: <code>x == y =&gt; hash(x) == hash(y)</code>. The reverse does not need to be true though; it’s perfectly valid to have different objects produce the same hash value.</p>
<p>When a membership test on a dictionary is performed, then the dictionary will first look for the hash value. If it can find it, then it will perform an equality check on all items it found; if it didn’t find the hash value, then it assumes that it’s a different object:</p>
<pre><code># x in dct
h = hash(x)
items = getItemsForHash(dct, h)
for item in items:
    if x == item:
        return True
# items is empty, or no match inside the loop
return False
</code></pre>
<p>Since you get the desired result when using a membership test against a list, that means that your object implements the equality comparison (<a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code></a>) correctly. But since you do not get the correct result when using a dictionary, there seems to be a <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code></a> implementation that is out of sync with the equality comparison implementation:</p>
<pre><code>&gt;&gt;&gt; class SomeType:
        def __init__ (self, x):
            self.x = x
        def __eq__ (self, other):
            return self.x == other.x
        def __hash__ (self):
            # bad hash implementation
            return hash(id(self))

&gt;&gt;&gt; l = [SomeType(1)]
&gt;&gt;&gt; d = { SomeType(1): 'x' }
&gt;&gt;&gt; x = SomeType(1)
&gt;&gt;&gt; x in l
True
&gt;&gt;&gt; x in d
False
</code></pre>
<p>Note that for new-style classes in Python 2 (classes that inherit from <code>object</code>), this “bad hash implementation” (which is based on the object id) is the default. So when you do not implement your own <code>__hash__</code> function, it still uses that one. This ultimately means that unless your <code>__eq__</code> only performs an identity check (the default), the hash function <em>will</em> be out of sync.</p>
<p>So the solution is to implement <code>__hash__</code> in a way that it aligns with the rules used in <code>__eq__</code>. For example, if you compare two members <code>self.x</code> and <code>self.y</code>, then you should use a compound hash over those two members. The easiest way to do that is to return the hash value of a tuple of those values:</p>
<pre><code>class SomeType (object):
    def __init__ (self, x, y):
        self.x = x
        self.y = y

    def __eq__ (self, other):
        return self.x == other.x and self.y == other.y

    def __hash__ (self):
        return hash((self.x, self.y))
</code></pre>
<p>Note that you should not make an object hashable if it is mutable:</p>
<blockquote>
<p>If a class defines mutable objects and implements an <code>__eq__()</code> method, it should not implement <code>__hash__()</code>, since the implementation of hashable collections requires that a key’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>TL;DR: The <code>in</code> test calls <code>__eq__</code> for lists. For dicts, it first calls <code>__hash__</code> and if the hash matches, then calls <code>__eq__</code>.</p>
<ol>
<li>The <code>in</code> test only calls <code>__eq__</code> for lists.

<ul>
<li>Without an <code>__eq__</code>, the <em>in-ness</em> comparison is always <code>False</code>.</li>
</ul></li>
<li><p>For dicts, you need a correctly implemented <code>__hash__</code> <em>and</em> <code>__eq__</code> to be able to compare objects in it <em>correctly</em>:</p>
<ul>
<li><p>First gets the object's hash from <code>__hash__</code></p>
<ul>
<li>Without <code>__hash__</code>, for new-style classes, it uses <code>id()</code> which is unique for all objects created and hence never matches an existing one unless it's <em>the same</em> object.</li>
<li>And as @poke pointed out in a comment:

<blockquote>
<p>In Python 2, new style classes (inheriting from <code>object</code>) inherit object’s <code>__hash__</code> implementation which is based on <code>id()</code>, so that’s where that comes from.</p>
</blockquote></li>
</ul></li>
<li><p>If the hash matches, <em>then</em> <code>__eq__</code> is called for that object with the <em><code>other</code></em>.</p>
<ul>
<li>The result then depends on what <code>__eq__</code> returns.</li>
</ul></li>
<li>If the hash <em>does not</em> match, then <code>__eq__</code> is <em>not called</em>.</li>
</ul></li>
</ol>
<p><strong>So the <code>in</code> test calls <code>__eq__</code> for lists and for dicts...<em>but for dicts, only after <code>__hash__</code></em> returns a matching hash.</strong> And not having a <code>__hash__</code> doesn't return <code>None</code>, doesn't throw an error and doesn't make it "unhashable". ...in Python 2. To use your <code>to_user</code> class correctly as dict keys, you do need to have a <a href="https://docs.python.org/2/glossary.html#term-hashable" rel="nofollow noreferrer"><code>__hash__</code> method</a> which is implemented correctly, in sync with <code>__eq__</code>.</p>
<p>Details:</p>
<p>The check for <code>m.to_user not in uniqueUsers</code> "object in list" worked correctly because you have probably implemented an <code>__eq__</code> method, as @poke pointed out. (And it appears <code>to_user</code> returns an object, not a string.)</p>
<p>The same check doesn't work for "object in dict" either because:<br/>
(a) <code>__hash__</code> in that class is badly implemented, as @poke also pointed out.<br/>
(b) <strong>Or</strong> you have not implemented <code>__hash__</code> at all. This doesn't raise an error in Python2 new-style classes.</p>
<p>Using <a href="https://stackoverflow.com/a/17445665/1431750">the class in this answer</a> as a starting point:</p>
<pre><code>&gt;&gt;&gt; class Test2(object):
...     def __init__(self, name):
...         self.name = name
...
...     def __eq__(self, other):
...         return self.name == other.name
...
&gt;&gt;&gt; test_Dict = {}
&gt;&gt;&gt; test_List = []
&gt;&gt;&gt;
&gt;&gt;&gt; obj1 = Test2('a')
&gt;&gt;&gt; obj2 = Test2('a')
&gt;&gt;&gt;
&gt;&gt;&gt; test_Dict[obj1] = 'x'
&gt;&gt;&gt; test_Dict[obj2] = 'y'
&gt;&gt;&gt;
&gt;&gt;&gt; test_List.append(obj1)
&gt;&gt;&gt; test_List.append(obj2)
&gt;&gt;&gt;
&gt;&gt;&gt; test_Dict
{&lt;__main__.Test2 object at 0x0000000002EFC518&gt;: 'x', &lt;__main__.Test2 object at 0x0000000002EFC940&gt;: 'y'}
&gt;&gt;&gt; test_List
[&lt;__main__.Test2 object at 0x0000000002EFC518&gt;, &lt;__main__.Test2 object at 0x0000000002EFC940&gt;]
&gt;&gt;&gt;
&gt;&gt;&gt; Test2('a') in test_Dict
False
&gt;&gt;&gt; Test2('a') in test_List
True
</code></pre>
</div>
<span class="comment-copy">@vaultah It has to (otherwise you would get a unhashable TypeError), but the implementation is likely not aligned with the implementation of <code>__eq__</code>.</span>
<span class="comment-copy">How did you implemented the <code>to_user</code> and main class? Python dictionaries doesn't preserve duplicate objects because thy have same <code>__hash__</code> value, but if you create multiple instance from one class each time you'll get a new object with different hash value. (with due to this point that they have same representation), but the result in your dictionary wont be the representation because they are same strings and hence have same hash value.</span>
<span class="comment-copy">@poke You've posted a great answer below +1. However, your comment about unhashable TypeError isn't correct, <a href="http://stackoverflow.com/a/17445665/1431750">as shown in this answer</a>.</span>
<span class="comment-copy">@aneroid OP’s code suggests that there is a custom <code>__eq__</code> implementation. That means if it wasn’t implemented as well, <code>__hash__</code> would return <code>None</code>, making the object unhashable.</span>
<span class="comment-copy">@poke Agreed on the OP's implementation of <code>to_user</code> details determining the cause of the issue. I also suspect it's returning an object and not a string, since the output of <code>uniqueUsers</code> is not the standard <code>repr</code> of a string/string keys. <b>But...</b> I just tried it <a href="http://pastebin.com/XLuHLAA1" rel="nofollow noreferrer">without implementing <code>__hash__</code> and no Error is raised</a> and the behaviour is identical to his issue. So it's either a badly implemented hash as you've said in your answer or a non-existent one, which doesn't raise an error.</span>
<span class="comment-copy">"and technically required too since there are only so many numbers" - in Python, there are not only so many numbers.</span>
<span class="comment-copy">Evaluate something like <code>9**100000</code> in Python, and then tell me Python has a limited amount of numbers. (Ignoring memory limits, because objects are also limited by memory)</span>
<span class="comment-copy">In the reference interpreter at least, every Python object can be assigned a unique number called a memory address.</span>
<span class="comment-copy">Actually, that part—and this discussion—is irrelevant to the question and my answer, so I’ve removed the part now from my answer (I didn’t think a side note in parentheses would have been this controversial). Since this comment thread will then lose its context, I’ll also delete my comments, so you may want to do the same.</span>
<span class="comment-copy">Thanks for your elaborate answer. The model was coming from the Peewee ORM, so I listed an issue on github, and the developer immediately added a commit to solve it (<a href="https://github.com/coleifer/peewee/commit/4de894aeebf7245d4fb6c4f412c7a09a2c039d8a" rel="nofollow noreferrer">github.com/coleifer/peewee/commit/…</a>). Thanks again for the explanation!</span>
<span class="comment-copy">Your tl;dr has a small mistake: The <code>__eq__</code> is indeed called for finding elements in a dictionary, but only after evaluating the object’s hash and finding a hash match.</span>
<span class="comment-copy">Suspected that. And also, if <code>__eq__</code> is not defined but <code>__hash__</code> is, then the <code>in</code> tests still fails for dicts. It needs both. Of course, List  uses only <code>__eq__</code> so without it, it always false.</span>
<span class="comment-copy">Yeah, the hash value is only used as a first step in dictionaries to find the place where the element would go in the hash table. The dictionary will still use an equality check on all elements it finds to make sure. And if not overriden, <code>__eq__</code> will fall back to an identity check.</span>
<span class="comment-copy">Wrote some test classes to show the different combos. I'll post a pastebin link instead of very long code.</span>
