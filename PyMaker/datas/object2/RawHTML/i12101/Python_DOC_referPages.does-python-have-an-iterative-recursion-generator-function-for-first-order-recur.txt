<div class="post-text" itemprop="text">
<p>Is there a built in function or standard library function roughly equivalent to</p>
<pre><code>def recur_until(start, step_fu, stop_predicate=lambda _: False):
    current = start
    while not stop_predicate(current):
        yield current
        current = step_fu(current)
</code></pre>
<p>or</p>
<pre><code>def recur_while(start, step_fu, predicate=lambda _: True):
    current = start
    while predicate(current):
        yield current
        current = step_fu(current)
</code></pre>
<p>or even just</p>
<pre><code>def recur(start, step_fu):
    current = start
    while True:
        yield current
        current = step_fu(current)
</code></pre>
<p>in any version of Python? (The latter is as good as the other two when combined with <a href="https://docs.python.org/library/itertools.html#itertools.takewhile" rel="nofollow"><code>itertools.takewhile</code></a>.)</p>
<p>A generator function like these would allow to compute certain recursively defined sequences iteratively, namely first-order recurrence relations.</p>
<p>While these aren't too hard to implement when needed, I feel like something like them should be part of <a href="https://docs.python.org/3/library/functional.html" rel="nofollow"><code>itertools</code> or maybe <code>functools</code></a>, but if it is, I haven't been able to spot it in the documentation, yet.</p>
<hr/>
<h3>Usage examples:</h3>
<pre><code>list(recur_until(2, lambda x: x**2 - 1, lambda x: x &gt; 1e4))
# [2, 3, 8, 63, 3968]
</code></pre>
<p>Should also work with non-number elements:</p>
<pre><code>list(recur_until('', lambda x: '[{}]({})'.format(x, len(x)), lambda x: len(x) &gt; 30))
# ['',
#  '[](0)',
#  '[[](0)](5)',
#  '[[[](0)](5)](10)',
#  '[[[[](0)](5)](10)](16)',
#  '[[[[[](0)](5)](10)](16)](22)']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The missing link is that you need something to convert your recursive stepping function into a generator.  Once you have that, then you can use any of the itertools methods.</p>
<pre><code>def recur_to_gen(step_fu, current, sentinel=None):
    while current != sentinel:
        yield current
        current = step_fu(current)


matches = itertools.takewhile(predicate, recur_to_gen(step_fu, start))
</code></pre>
<p><code>recur_to_gen</code> is probably a reasonable thing to propose adding to <code>itertools</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3+, the new <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>itertools.accumulate</code></a> can be used to this purpose in combination with the other itertools</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; from itertools import accumulate, repeat, takewhile
&gt;&gt;&gt; fun = accumulate(range(2, 10), lambda x, _: x**2 - 1)
&gt;&gt;&gt; list(fun)
[2, 3, 8, 63, 3968, 15745023, 247905749270528, 61457260521381894004129398783]
&gt;&gt;&gt; fun = takewhile(lambda y: y &lt; 1e4, accumulate(repeat(2), lambda x, _: x**2 - 1))
&gt;&gt;&gt; list(fun)
[2, 3, 8, 63, 3968]
</code></pre>
<p><code>accumulate</code> takes a sequence and a function with 2 arguments: The first is the accumulate value and the second is the next value in the sequence. In this case, we only need the first argument, which will be the first element of the sequence passed to <code>accumulate</code> for the first call of the passed function and the return value of that function for subsequent calls.</p>
<p>Thus, we only need the start of the passed sequence to be our initial value â€” <code>2</code> in this case. The content of the rest of the sequence is irrelevant, but we can use it's length to control how many elements we want (as in the first example) or to create an infinite generator (like the second example).</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://pypi.python.org/pypi/functional" rel="nofollow">functional</a> package provides the pieces to simulate this.</p>
<pre><code>from functional import dropWhile, iterate    
recur = dropWhile(predicate, iterate(step_func, start))
</code></pre>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; next(dropWhile(lambda x : x &lt; 10, iterate(lambda x: x + 1, 2)))
10
</code></pre>
<p>(<code>dropWhile</code> isn't really any different from <code>itertools.dropwhile</code>.)</p>
</div>
<span class="comment-copy">I.e., an equivalent to Haskell's <code>iterate</code> function. <code>iterate (\x -&gt; x + 1) 0 = 0, 1, 2, 3, 4, 5, ...</code></span>
<span class="comment-copy">@chepner <code>iterate</code> in combination with <code>takeWhile</code>.</span>
<span class="comment-copy">I never know what to do with questions which are just "does X exist?" and I'm confident the answer is "No".  There's nothing I can do to justify that answer other than link to the documentation you've already linked.</span>
<span class="comment-copy">@SvenMarnach True. I was focusing on the part missing from itertools, but you do need the combination of <code>iterate</code> and <code>{take,drop}while</code>.</span>
<span class="comment-copy">@DSM, yeah, I know existence questions have the problem that negative answers are essentially unprovable. But as I'm particularly interested in what the standard library has to offer here, I didn't know how to put my question differently.</span>
<span class="comment-copy">It's usually called <code>iterate</code>, e.g. in Haskell or in this <a href="https://github.com/kachayev/fn.py/blob/master/fn/iters.py#L81" rel="nofollow noreferrer">functional Python library</a>.</span>
<span class="comment-copy">Unfortunately, I think "iterate" in Python is pretty closely tied to <code>iter</code>, which  is more about stepping thru a sequence, rather than recursively applying a stepping function to an item to get the next item. But by whatever name, I think <code>itertools</code> would be a good home for something like this.</span>
<span class="comment-copy">@StefanPochmann The function <code>recur_to_gen()</code> is a generator function (since it <code>yield</code>s).  There is no generator expression here.</span>
<span class="comment-copy">@SvenMarnach: I think SP was drawing attention to PM's first sentence-- the OP's original function (though called <code>recur</code>) is non-recursive, and already a genfunc.</span>
<span class="comment-copy">@DSM - not recursive in the sense that it calls itself, but in that it iterates through a not-necessarily-contiguous chain of items by calling a stepping function on the current item in order to get the next.</span>
<span class="comment-copy">Heh, I had just started my other computer which has Python 3.4 to test something similar to this shortly before I saw your answer.</span>
<span class="comment-copy">The latest available build is for Python 2.5.  A newer functional package for Python: <a href="https://github.com/kachayev/fn.py" rel="nofollow noreferrer">github.com/kachayev/fn.py</a></span>
<span class="comment-copy">It still works (installed via <code>pip</code>, but I didn't test it extensively) but yes, I think <code>functional</code> was a one-off proof-of-concept that was never really supported.</span>
