<div class="post-text" itemprop="text">
<p>The code I'm running is:</p>
<pre><code>&gt;&gt;&gt; from collections import abc
&gt;&gt;&gt; mydict = {'test_key': 'test_value'}
&gt;&gt;&gt; isinstance(mydict, abc.Mapping)
True
</code></pre>
<p>I understand what <code>isinstance</code> does, but I'm not sure what <code>abc.Mapping</code> does from <code>collections</code>? </p>
<p>It seems like the line <code>isinstance(mydict, abc.Mapping)</code> is being used to check that <code>mydict</code> is a dictionary? </p>
<p>Wouldn't it just be easier to do
<code>isinstance(mydict, dict)</code>?</p>
<p>I did some searching and found related comments in this thread: <a href="https://stackoverflow.com/questions/378927/what-is-the-best-idiomatic-way-to-check-the-type-of-a-python-variable">What is the best (idiomatic) way to check the type of a Python variable?</a>, but I'm still having trouble figuring out why using <code>abc.Mapping</code> is preferable here than just using <code>dict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/collections.abc.html" rel="noreferrer">collections.abc</a> provide a serie of Abstract Base Classes for container</p>
<blockquote>
<p>This module provides abstract base classes that can be used to test whether a class provides a particular interface; for example, whether it is hashable or whether it is a mapping.</p>
</blockquote>
<p>they allow you to check if a certain object have a behavior similar to that of the ABC you are checking without care for the actual implementation.</p>
<p>For example, say that you have a function F that do something according to the type of the argument, you can check if is a instance of list or tuple or dict or etc directly, and do your job, but that limit you to only have to use those, if you then make your own class that have a similar behavior to say a list, in some case you care about, and want to use it with F, you find it don't work, then you have to modify F to accept your class, but if instead you check against an ABC such modification is unneeded </p>
<p>Now a working example: say that you want a function that give all the elements in even position from a list, then you can do</p>
<pre><code>def even_pos(data):
    if isinstance(data,list):
        return [data[i] for i in range(0,len(data),2)]
    else:
        raise ValueError("only a list")
</code></pre>
<p>and use as</p>
<pre><code>&gt;&gt;&gt; test = list(range(20))
&gt;&gt;&gt; even_pos(test)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
&gt;&gt;&gt;
</code></pre>
<p>no problem there, but then you realize that a tuple is the same that a list in what a this function concern, you can add that check to the function too, and everything is fine, but then your friend told you he want to use your function but he is using a <code>collections.deque</code> and then your other friend told... see the pattern here? all the object that I mention (list, tuple, deque) have in common the same thing, and can be used in the same way by that example function, and all that behavior is compress in the ABC, so instead of <code>isinstance(data,(list,tuple,collections.deque,...)</code> you only need <code>isinstance(data,abc.Sequence)</code> and the function looks like</p>
<pre><code>from collections import abc
def even_pos(data):
    if isinstance(data,abc.Sequence):
        return [data[i] for i in range(0,len(data),2)]
    else:
        raise ValueError("only a Sequence")

&gt;&gt;&gt; even_pos( list(range(10)) )
[0, 2, 4, 6, 8]
&gt;&gt;&gt; even_pos( tuple(range(10)) )
[0, 2, 4, 6, 8]
&gt;&gt;&gt; even_pos( range(10) )  # in python 3 range don't return a list, but a range object
[0, 2, 4, 6, 8]
&gt;&gt;&gt; even_pos( "asdfghjh" )
['a', 'd', 'g', 'j']
&gt;&gt;&gt; 
</code></pre>
<p>Now you don't need to know the actual implementation that is in use, only that it have the behavior that you want</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>collections.abc</code> module provides several abstract base classes that can be used to generically describe the various kinds of data structures in Python. In your example, you test if an object is an instance of the <code>Mapping</code> abstract class, which will be true for many classes that "work like a dictionary" (e.g. they have a <code>__getitem__</code> method that takes hashable keys and return values, have <code>keys</code>, <code>values</code> and <code>items</code> methods, etc.). Such <code>dict</code>-like objects might inherit from <code>dict</code> but they don't need to.</p>
<p>The abstract types in <code>collections.abc</code> are implemented using <a href="https://docs.python.org/3/library/abc.html" rel="nofollow">the top level <code>abc</code> module</a>. <code>dict</code> is <code>register</code>ed as a <code>MutableMapping</code> (which is a subclass of <code>Mapping</code>) and so the <code>isinstance</code> check will accept a dictionary as a <code>Mapping</code> even though <code>Mapping</code> isn't an actual base class for <code>dict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>collections.abc.Mapping</code> is preferred because <strong>it defines abstract api for this type of containers</strong>, since <code>dict</code> is only an implementation of such a container. Is a bit oversimplified, but this is the key - <code>dict</code> is not an interface/abstract/api/... </p>
<p>The example of objects that are not a dict instances are <a href="https://github.com/KeepSafe/aiohttp/blob/master/aiohttp/multidict.py" rel="nofollow">MultiDict</a>, widely used in web frameworks (e.g. aiohttp).</p>
</div>
