<div class="post-text" itemprop="text">
<p>I wanted to do a kind of dictionary class, for sparse data. The idea is that if the key is not in the dictionary find the closest key with a lower value (the keys of my dictionary are always positive integers, with the lowest being always zero)</p>
<p>Here is my prototype</p>
<pre><code>class specialdict(dict):
    def __getitem__(self, beg):
        try:
            return self[beg - 1]
        except:
            return dict.__getitem__(self, beg)

a = specialdict([(10, True)])

print a[137]

print a[500]
</code></pre>
<p>And this works, but only up to 338</p>
<p>I guess it has to do with the recursion, but I though the number of recursion in python was higher. I also need the lookups to be very fast...</p>
<p>Am I doning something wrong, is there a better way to do this?</p>
<p>thanks</p>
<p>EDIT:</p>
<p>an example:</p>
<p>if I only have the keys "0", "10" and "15", and search for the key "13", I want the <strong>getitem</strong> function to give me the value corresponding to <strong>getitem</strong>(10)</p>
<p>And if I want the key "100" should get the value of <strong>getitem</strong>(15)).</p>
<p>EDIT 2</p>
<p>There is no particular reason why I need it to be a dictionary, or the <strong>getitem</strong> function to be recursive. But I had the feeling that this would be the fastest way. </p>
<p>EDIT 3</p>
<p>I tried all the 3 solutions proposed by @gilland @thomas-lotze:</p>
<pre><code>import bisect

class SparseData(object):

    def __init__(self, pairs=()):
        if pairs:
            indexes, values = zip(*pairs)
            self.indexes = list(indexes)
            self.values = list(values)
        else:
            self.indexes = []
            self.values = []


    def __setitem__(self, index, value):
        i = bisect.bisect(self.indexes, index)
        self.indexes.insert(i, index)
        self.values.insert(i, value)

    def __getitem__(self, index):
        i = bisect.bisect(self.indexes, index)
        if not i:
            raise IndexError(i)
        return self.values[i-1]

class specialdict_rec(dict):
    def __getitem__(self, beg):
        try:
            return dict.__getitem__(self, beg)
        except KeyError:
            return self[beg - 1]

class specialdict_non_rec(dict):
    def __getitem__(self, beg):
        while beg &gt;= 0:
            try:
                return dict.__getitem__(self, beg)
            except KeyError:
                beg -= 1
</code></pre>
<p>and here the result of the benchmark:</p>
<pre><code>In [1]: a = [(1, '1'), (7, '7'), (100, '100')]

In [2]: a1 = SparseData(a)

In [3]: a2 = specialdict_rec(a)

In [4]: a3 = specialdict_non_rec(a)

In [5]: %timeit -n10000 a1[200]
10000 loops, best of 3: 1.12 µs per loop

In [6]: %timeit -n10000 a2[200]
10000 loops, best of 3: 96 µs per loop

In [7]: %timeit -n10000 a3[200]
10000 loops, best of 3: 58.6 µs per loop
</code></pre>
<p>so it's true that the recursion does not improve anything, and as @gill said, it's dangerous.</p>
<p>But at the end the solution I am going to use is the one from @thomas-lotze . 
thanks a lot for the answers!</p>
</div>
<div class="post-text" itemprop="text">
<p>For speed, use <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow">the <code>bisect</code> module</a> to work on a list of (key, value) pairs instead of a dict:</p>
<pre><code>import bisect

class SparseData(object):

    def __init__(self, pairs=()):
        if pairs:
            indexes, values = zip(*pairs)
            self.indexes = list(indexes)
            self.values = list(values)
        else:
            self.indexes = []
            self.values = []

    def __setitem__(self, index, value):
        i = bisect.bisect(self.indexes, index)
        if self.indexes[i-1] == index:
            self.values[i-1] = value
        else:
            self.indexes.insert(i, index)
            self.values.insert(i, value)

    def __getitem__(self, index):
        i = bisect.bisect(self.indexes, index)
        if not i:
            raise IndexError(i)
        return self.values[i-1]

&gt;&gt;&gt; x = SparseData([(1, '1'), (2, '2'), (4, '4')])

&gt;&gt;&gt; x[0]
Traceback (most recent call last):
...
IndexError: 0

&gt;&gt;&gt; x[3]
'2'
&gt;&gt;&gt; x[4]
'4'

&gt;&gt;&gt; x[27] = '27'
&gt;&gt;&gt; x[25]
'4'
&gt;&gt;&gt; x[27]
'27'
&gt;&gt;&gt; x[29]
'27'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will achieve your narrow goal (given that keys are <code>int</code>s and will not be smaller than <code>0</code>), but like @JustinR said in comments, there may be a better solution to the larger problem.</p>
<pre><code>class specialdict(dict):
    def __getitem__(self, beg):
        while beg &gt;= 0:
            try:
                return dict.__getitem__(self, beg)
            except KeyError:
                beg -= 1
</code></pre>
<hr/>
<p>EDIT</p>
<p>Just to show how to do the same thing recursively (since OP asked), but it's highly unrecommended. There is the recursion limit. And as others said, binary search is more efficient.</p>
<pre><code>class specialdict(dict):
    def __getitem__(self, beg):
        try:
            return dict.__getitem__(self, beg)
        except KeyError:
            return self[beg - 1]
</code></pre>
<hr/>
<p>EDIT 2</p>
<p>Improving on @ThomasLotze's answer, here is how to wrap <code>bisect</code> while maintaining the <code>dict</code> interface:</p>
<pre><code>import bisect

class SpecialDict(dict):

    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self._keys = sorted(self.keys())  # maintain a sorted list of keys

    def __setitem__(self, key, value):
        if key not in self:
            bisect.insort(self._keys, key)
        dict.__setitem__(self, key, value)

    def __getitem__(self, key):
        if key not in self:
            try:
                key = self._keys[bisect.bisect(self._keys, key) - 1]
            except IndexError:
                raise KeyError(key)
        return dict.__getitem__(self, key)
</code></pre>
</div>
<span class="comment-copy">Is there a lower bound for what a key can be, or is that not known?</span>
<span class="comment-copy">So, you are looking for something like Java's <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html" rel="nofollow noreferrer"><code>TreeMap</code></a> in Python, particularly like its <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html#lowerEntry%28K%29" rel="nofollow noreferrer"><code>lowerEntry</code></a> method?</span>
<span class="comment-copy">@fransua, could you please define "closest key upstream"? What exactly do you want to do? Can you provide some input and expected output data, too?</span>
<span class="comment-copy">@gill the lower bond, iszero.. in my data there is always a zero key</span>
<span class="comment-copy">Why do you want to do this recursively? And why with a dictionary? I feel like you're fixating on the means here, and your solution might be with a different data structure and algorithm. Please describe your goal.</span>
<span class="comment-copy">your solution implies that I know the "end" of the list, and I don't. However it is true that this is the fastest. thanks!</span>
<span class="comment-copy">Well, I found a flaw in my solution and I also took your comment as an opportuinity to improve error handling. See the updated answer for a fuller example. Indexes and values need to be stored separately in order to avoid comparison between values and not allow them to influence the index computation. As for the "end" of the list, the algorithm does know the end while computing as the list is bound to be finite at any one time. If you mean the error when trying to access too low values, that appears to follow from your requirements since you only mention looking left but not handling that end.</span>
<span class="comment-copy">Nice wrapper. One minor suggestion though: calling <code>__setitem__()</code> with the same index again should overwrite the original value. As is, the two underlying lists just grow...</span>
<span class="comment-copy">That's easy, see the updated solution.</span>
<span class="comment-copy">I've added a check for empty initialisation. A nice string representation and lots of other stuff is also still missing until this is really usable, but that would be beyond the scope of this question (which I take to be explaining the indexing) :-)</span>
<span class="comment-copy">Your solution avoids recursion and is nice, however it is almost 2 times slower than mine...</span>
<span class="comment-copy">@fransua If you mean your solution in OP, it's in fact incorrect. Try: <code>a = specialdict([(9, False), (10, True)]); print(a[10])</code>. You will get <code>False</code>. If you fix it and it still runs faster, I'd like to know!</span>
<span class="comment-copy">@fransua The reason your current code runs fast is because it always tries a smaller key than the one it should try, and so you will never hit the <code>except</code> clause even if you try say <code>a[300]</code> and the dict only has <code>10</code>. Whereas in the correct code, you should first try <code>300</code>, get <code>KeyError</code>, step back and try <code>299</code>, get <code>KeyError</code>, step back ... and so on. And we know that exception handling is costly.</span>
<span class="comment-copy">you are right, but I can not make the recursion work... @gill</span>
<span class="comment-copy">@fransua I've shown the recursive version. It has the same limit problem, but you can compare performance within the limit.</span>
