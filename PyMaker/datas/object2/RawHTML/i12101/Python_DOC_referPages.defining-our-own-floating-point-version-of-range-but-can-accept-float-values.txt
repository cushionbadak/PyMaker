<div class="post-text" itemprop="text">
<p>Is there a way to step between 0 and 1 by 0.1? </p>
<p>I thought I could do it like the following, but it failed:</p>
<pre><code>for i in range(0, 1, 0.1):
    print i
</code></pre>
<p>Instead, it says that the step argument cannot be zero, which I did not expect.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than using a decimal step directly, it's much safer to express this in terms of how many points you want. Otherwise, floating-point rounding error is likely to give you a wrong result.</p>
<p>You can use the <code>linspace</code> function from the <a href="http://en.wikipedia.org/wiki/NumPy" rel="noreferrer">NumPy</a> library (which isn't part of the standard library but is relatively easy to obtain). <code>linspace</code> takes a number of points to return, and also lets you specify whether or not to include the right endpoint:</p>
<pre><code>&gt;&gt;&gt; np.linspace(0,1,11)
array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ])
&gt;&gt;&gt; np.linspace(0,1,10,endpoint=False)
array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])
</code></pre>
<p>If you really want to use a floating-point step value, you can, with <code>numpy.arange</code>.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.arange(0.0, 1.0, 0.1)
array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])
</code></pre>
<p>Floating-point rounding error <em>will</em> cause problems, though. Here's a simple case where rounding error causes <code>arange</code> to produce a length-4 array when it should only produce 3 numbers:</p>
<pre><code>&gt;&gt;&gt; numpy.arange(1, 1.3, 0.1)
array([1. , 1.1, 1.2, 1.3])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's range() can only do integers, not floating point. In your specific case, you can use a list comprehension instead:</p>
<pre><code>[x * 0.1 for x in range(0, 10)]
</code></pre>
<p>(Replace the call to range with that expression.) </p>
<p>For the more general case, you may want to write a custom function or generator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Building on <a href="http://docs.python.org/library/functions.html#xrange" rel="noreferrer">'xrange([start], stop[, step])'</a>, you can define a generator that accepts and produces any type you choose (stick to types supporting <code>+</code> and <code>&lt;</code>):</p>
<pre><code>&gt;&gt;&gt; def drange(start, stop, step):
...     r = start
...     while r &lt; stop:
...         yield r
...         r += step
...         
&gt;&gt;&gt; i0=drange(0.0, 1.0, 0.1)
&gt;&gt;&gt; ["%g" % x for x in i0]
['0', '0.1', '0.2', '0.3', '0.4', '0.5', '0.6', '0.7', '0.8', '0.9', '1']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Increase the magnitude of <code>i</code> for the loop and then reduce it when you need it.</p>
<pre><code>for i * 100 in range(0, 100, 10):
    print i / 100.0
</code></pre>
<p><strong>EDIT: I honestly cannot remember why I thought that would work syntactically</strong></p>
<pre><code>for i in range(0, 11, 1):
    print i / 10.0
</code></pre>
<p>That should have the desired output. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>scipy</code> has a built in function <code>arange</code> which generalizes Python's <code>range()</code> constructor to satisfy your requirement of float handling. </p>
<p><code>from scipy import arange</code></p>
</div>
<div class="post-text" itemprop="text">
<p>NumPy is a bit overkill, I think.</p>
<pre><code>[p/10 for p in range(0, 10)]
[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
</code></pre>
<p>Generally speaking, to do a step-by-<code>1/x</code> up to <code>y</code> you would do</p>
<pre><code>x=100
y=2
[p/x for p in range(0, int(x*y))]
[0.0, 0.01, 0.02, 0.03, ..., 1.97, 1.98, 1.99]
</code></pre>
<p>(<code>1/x</code> produced less rounding noise when I tested).</p>
</div>
<div class="post-text" itemprop="text">
<p>Similar to <a href="http://en.wikipedia.org/wiki/R_%28programming_language%29" rel="nofollow noreferrer">R's</a> <code>seq</code> function, this one returns a sequence in any order given the correct step value. The last value is equal to the stop value. </p>
<pre><code>def seq(start, stop, step=1):
    n = int(round((stop - start)/float(step)))
    if n &gt; 1:
        return([start + step*i for i in range(n+1)])
    elif n == 1:
        return([start])
    else:
        return([])
</code></pre>
<h3>Results</h3>
<pre><code>seq(1, 5, 0.5)
</code></pre>
<blockquote>
<p>[1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0]</p>
</blockquote>
<pre><code>seq(10, 0, -1)
</code></pre>
<blockquote>
<p>[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</p>
</blockquote>
<pre><code>seq(10, 0, -2)
</code></pre>
<blockquote>
<p>[10, 8, 6, 4, 2, 0]</p>
</blockquote>
<pre><code>seq(1, 1)
</code></pre>
<blockquote>
<p>[ 1 ]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The range() built-in function returns a sequence of integer values, I'm afraid, so you can't use it to do a decimal step.  </p>
<p>I'd say just use a while loop:</p>
<pre><code>i = 0.0
while i &lt;= 1.0:
    print i
    i += 0.1
</code></pre>
<p>If you're curious, Python is converting your 0.1 to 0, which is why it's telling you the argument can't be zero.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution using <a href="http://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a>:</p>
<pre><code>import itertools

def seq(start, end, step):
    if step == 0:
        raise ValueError("step must not be 0")
    sample_count = int(abs(end - start) / step)
    return itertools.islice(itertools.count(start, step), sample_count)
</code></pre>
<p><strong>Usage Example:</strong></p>
<pre><code>for i in seq(0, 1, 0.1):
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>[x * 0.1 for x in range(0, 10)] 
</code></pre>
<p>in Python 2.7x gives you the result of:</p>
<blockquote>
<p>[0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]</p>
</blockquote>
<p>but if you use:</p>
<pre><code>[ round(x * 0.1, 1) for x in range(0, 10)]
</code></pre>
<p>gives you the desired:</p>
<blockquote>
<p>[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np
for i in np.arange(0, 1, 0.1): 
    print i 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>And if you do this often, you might want to save the generated list <code>r</code></p>
<pre><code>r=map(lambda x: x/10.0,range(0,10))
for i in r:
    print i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My versions use the original range function to create multiplicative indices for the shift. This allows same syntax to the original range function.
I have made two versions, one using float, and one using Decimal, because I found that in some cases I wanted to avoid the roundoff drift introduced by the floating point arithmetic.</p>
<p>It is consistent with empty set results as in range/xrange.</p>
<p>Passing only a single numeric value to either function will return the standard range output to the integer ceiling value of the input parameter (so if you gave it 5.5, it would return range(6).)</p>
<p><strong>Edit: the code below is now available as package on pypi: <a href="http://pypi.python.org/pypi/Franges" rel="nofollow">Franges</a></strong></p>
<pre><code>## frange.py
from math import ceil
# find best range function available to version (2.7.x / 3.x.x)
try:
    _xrange = xrange
except NameError:
    _xrange = range

def frange(start, stop = None, step = 1):
    """frange generates a set of floating point values over the 
    range [start, stop) with step size step

    frange([start,] stop [, step ])"""

    if stop is None:
        for x in _xrange(int(ceil(start))):
            yield x
    else:
        # create a generator expression for the index values
        indices = (i for i in _xrange(0, int((stop-start)/step)))  
        # yield results
        for i in indices:
            yield start + step*i

## drange.py
import decimal
from math import ceil
# find best range function available to version (2.7.x / 3.x.x)
try:
    _xrange = xrange
except NameError:
    _xrange = range

def drange(start, stop = None, step = 1, precision = None):
    """drange generates a set of Decimal values over the
    range [start, stop) with step size step

    drange([start,] stop, [step [,precision]])"""

    if stop is None:
        for x in _xrange(int(ceil(start))):
            yield x
    else:
        # find precision
        if precision is not None:
            decimal.getcontext().prec = precision
        # convert values to decimals
        start = decimal.Decimal(start)
        stop = decimal.Decimal(stop)
        step = decimal.Decimal(step)
        # create a generator expression for the index values
        indices = (
            i for i in _xrange(
                0, 
                ((stop-start)/step).to_integral_value()
            )
        )  
        # yield results
        for i in indices:
            yield float(start + step*i)

## testranges.py
import frange
import drange
list(frange.frange(0, 2, 0.5)) # [0.0, 0.5, 1.0, 1.5]
list(drange.drange(0, 2, 0.5, precision = 6)) # [0.0, 0.5, 1.0, 1.5]
list(frange.frange(3)) # [0, 1, 2]
list(frange.frange(3.5)) # [0, 1, 2, 3]
list(frange.frange(0,10, -1)) # []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is my solution to get ranges with float steps.
<br/>Using this function it's not necessary to import numpy, nor install it.
<br/>I'm pretty sure that it could be improved and optimized. Feel free to do it and post it here.</p>
<pre><code>from __future__ import division
from math import log

def xfrange(start, stop, step):

    old_start = start #backup this value

    digits = int(round(log(10000, 10)))+1 #get number of digits
    magnitude = 10**digits
    stop = int(magnitude * stop) #convert from 
    step = int(magnitude * step) #0.1 to 10 (e.g.)

    if start == 0:
        start = 10**(digits-1)
    else:
        start = 10**(digits)*start

    data = []   #create array

    #calc number of iterations
    end_loop = int((stop-start)//step)
    if old_start == 0:
        end_loop += 1

    acc = start

    for i in xrange(0, end_loop):
        data.append(acc/magnitude)
        acc += step

    return data

print xfrange(1, 2.1, 0.1)
print xfrange(0, 1.1, 0.1)
print xfrange(-1, 0.1, 0.1)
</code></pre>
<p>The output is:</p>
<pre><code>[1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]
[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1]
[-1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party library that implements a <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.numeric_range" rel="nofollow noreferrer"><code>numeric_range</code></a> tool:</p>
<pre><code>import more_itertools as mit


for x in mit.numeric_range(0, 1, 0.1):
    print("{:.1f}".format(x))
</code></pre>
<p>Output</p>
<pre><code>0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
</code></pre>
<p>This tool also works for <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer"><code>Decimal</code></a> and <a href="https://docs.python.org/2/library/fractions.html" rel="nofollow noreferrer"><code>Fraction</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this function:</p>
<pre><code>def frange(start,end,step):
    return map(lambda x: x*step, range(int(start*1./step),int(end*1./step)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The trick to avoid <em>round-off problem</em> is to use a separate number to move through the range, that starts and <em>half</em> the <em>step</em> ahead of <em>start</em>.</p>
<pre><code># floating point range
def frange(a, b, stp=1.0):
  i = a+stp/2.0
  while i&lt;b:
    yield a
    a += stp
    i += stp
</code></pre>
<p>Alternatively, <code>numpy.arange</code> can be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>For completeness of boutique, a functional solution:</p>
<pre><code>def frange(a,b,s):
  return [] if s &gt; 0 and a &gt; b or s &lt; 0 and a &lt; b or s==0 else [a]+frange(a+s,b,s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It can be done using Numpy library. arange() function allows steps in float. But, it returns a numpy array which can be converted to list using tolist() for our convenience.</p>
<pre><code>for i in np.arange(0, 1, 0.1).tolist():
   print i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My answer is similar to others using map(), without need of NumPy, and without using lambda (though you could).    To get a list of float values from 0.0 to t_max in steps of dt:</p>
<pre><code>def xdt(n):
    return dt*float(n)
tlist  = map(xdt, range(int(t_max/dt)+1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Add auto-correction for the possibility of an incorrect sign on step:</p>
<pre><code>def frange(start,step,stop):
    step *= 2*((stop&gt;start)^(step&lt;0))-1
    return [start+i*step for i in range(int((stop-start)/step))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution:</p>
<pre><code>def seq(start, stop, step=1, digit=0):
    x = float(start)
    v = []
    while x &lt;= stop:
        v.append(round(x,digit))
        x += step
    return v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Best Solution: <strong>no rounding error</strong><br>
<strong>_________________________________________________________________________________</strong></br></p>
<pre><code>&gt;&gt;&gt; step = .1
&gt;&gt;&gt; N = 10     # number of data points
&gt;&gt;&gt; [ x / pow(step, -1) for x in range(0, N + 1) ]

[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
</code></pre>
<p><strong>_________________________________________________________________________________</strong><br><br/>
Or, for a set range instead of set data points (e.g. continuous function), use:</br></p>
<pre><code>&gt;&gt;&gt; step = .1
&gt;&gt;&gt; rnge = 1     # NOTE range = 1, i.e. span of data points
&gt;&gt;&gt; N = int(rnge / step
&gt;&gt;&gt; [ x / pow(step,-1) for x in range(0, N + 1) ]

[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
</code></pre>
<p>To implement a function: replace <code>x / pow(step, -1)</code> with <code>f( x / pow(step, -1) )</code>, and define <code>f</code>.<br/>
For example:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; def f(x):
        return math.sin(x)

&gt;&gt;&gt; step = .1
&gt;&gt;&gt; rnge = 1     # NOTE range = 1, i.e. span of data points
&gt;&gt;&gt; N = int(rnge / step)
&gt;&gt;&gt; [ f( x / pow(step,-1) ) for x in range(0, N + 1) ]

[0.0, 0.09983341664682815, 0.19866933079506122, 0.29552020666133955, 0.3894183423086505, 
 0.479425538604203, 0.5646424733950354, 0.644217687237691, 0.7173560908995228,
 0.7833269096274834, 0.8414709848078965]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>start and stop are inclusive rather than one or the other (usually stop is excluded) and without imports, and using generators</p>
<pre><code>def rangef(start, stop, step, fround=5):
    """
    Yields sequence of numbers from start (inclusive) to stop (inclusive)
    by step (increment) with rounding set to n digits.

    :param start: start of sequence
    :param stop: end of sequence
    :param step: int or float increment (e.g. 1 or 0.001)
    :param fround: float rounding, n decimal places
    :return:
    """
    try:
        i = 0
        while stop &gt;= start and step &gt; 0:
            if i==0:
                yield start
            elif start &gt;= stop:
                yield stop
            elif start &lt; stop:
                if start == 0:
                    yield 0
                if start != 0:
                    yield start
            i += 1
            start += step
            start = round(start, fround)
        else:
            pass
    except TypeError as e:
        yield "type-error({})".format(e)
    else:
        pass


# passing
print(list(rangef(-100.0,10.0,1)))
print(list(rangef(-100,0,0.5)))
print(list(rangef(-1,1,0.2)))
print(list(rangef(-1,1,0.1)))
print(list(rangef(-1,1,0.05)))
print(list(rangef(-1,1,0.02)))
print(list(rangef(-1,1,0.01)))
print(list(rangef(-1,1,0.005)))
# failing: type-error:
print(list(rangef("1","10","1")))
print(list(rangef(1,10,"1")))
</code></pre>
<blockquote>
<p>Python 3.6.2 (v3.6.2:5fd33b5, Jul  8 2017, 04:57:36) [MSC v.1900 64
  bit (AMD64)]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Suprised no-one has yet mentioned the recommended solution <a href="https://docs.python.org/3/library/stdtypes.html#ranges" rel="nofollow noreferrer">in the Python 3 docs</a>:</p>
<blockquote>
<p>See also:</p>
<ul>
<li>The <a href="http://code.activestate.com/recipes/579000/" rel="nofollow noreferrer">linspace recipe</a> shows how to implement a lazy version of range    that suitable for floating point applications.</li>
</ul>
</blockquote>
<p>Once defined, the recipe is easy to use and does not require <code>numpy</code> or any other external libraries, but functions like <code>numpy.linspace()</code>. Note that rather than a <code>step</code> argument, the third <code>num</code> argument specifies the number of desired values, for example:</p>
<pre><code>print(linspace(0, 10, 5))
# linspace(0, 10, 5)
print(list(linspace(0, 10, 5)))
# [0.0, 2.5, 5.0, 7.5, 10]
</code></pre>
<p>I quote a modified version of the full Python 3 recipe from  Andrew Barnert below:</p>
<pre><code>import collections.abc
import numbers

class linspace(collections.abc.Sequence):
    """linspace(start, stop, num) -&gt; linspace object

    Return a virtual sequence of num numbers from start to stop (inclusive).

    If you need a half-open range, use linspace(start, stop, num+1)[:-1].
    """
    def __init__(self, start, stop, num):
        if not isinstance(num, numbers.Integral) or num &lt;= 1:
            raise ValueError('num must be an integer &gt; 1')
        self.start, self.stop, self.num = start, stop, num
        self.step = (stop-start)/(num-1)
    def __len__(self):
        return self.num
    def __getitem__(self, i):
        if isinstance(i, slice):
            return [self[x] for x in range(*i.indices(len(self)))]
        if i &lt; 0:
            i = self.num + i
        if i &gt;= self.num:
            raise IndexError('linspace object index out of range')
        if i == self.num-1:
            return self.stop
        return self.start + i*self.step
    def __repr__(self):
        return '{}({}, {}, {})'.format(type(self).__name__,
                                       self.start, self.stop, self.num)
    def __eq__(self, other):
        if not isinstance(other, linspace):
            return False
        return ((self.start, self.stop, self.num) ==
                (other.start, other.stop, other.num))
    def __ne__(self, other):
        return not self==other
    def __hash__(self):
        return hash((type(self), self.start, self.stop, self.num))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To counter the float precision issues, you could use the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer"><code>Decimal</code> module</a>.</p>
<p>This demands an extra effort of converting to <code>Decimal</code> from <code>int</code> or <code>float</code> while writing the code, but you can instead pass <code>str</code> and modify the function if that sort of convenience is indeed necessary.</p>
<pre><code>from decimal import Decimal
from decimal import Decimal as D


def decimal_range(*args):

    zero, one = Decimal('0'), Decimal('1')

    if len(args) == 1:
        start, stop, step = zero, args[0], one
    elif len(args) == 2:
        start, stop, step = args + (one,)
    elif len(args) == 3:
        start, stop, step = args
    else:
        raise ValueError('Expected 1 or 2 arguments, got %s' % len(args))

    if not all([type(arg) == Decimal for arg in (start, stop, step)]):
        raise ValueError('Arguments must be passed as &lt;type: Decimal&gt;')

    # neglect bad cases
    if (start == stop) or (start &gt; stop and step &gt;= zero) or \
                          (start &lt; stop and step &lt;= zero):
        return []

    current = start
    while abs(current) &lt; abs(stop):
        yield current
        current += step
</code></pre>
<p>Sample outputs -</p>
<pre><code>list(decimal_range(D('2')))
# [Decimal('0'), Decimal('1')]
list(decimal_range(D('2'), D('4.5')))
# [Decimal('2'), Decimal('3'), Decimal('4')]
list(decimal_range(D('2'), D('4.5'), D('0.5')))
# [Decimal('2'), Decimal('2.5'), Decimal('3.0'), Decimal('3.5'), Decimal('4.0')]
list(decimal_range(D('2'), D('4.5'), D('-0.5')))
# []
list(decimal_range(D('2'), D('-4.5'), D('-0.5')))
# [Decimal('2'),
#  Decimal('1.5'),
#  Decimal('1.0'),
#  Decimal('0.5'),
#  Decimal('0.0'),
#  Decimal('-0.5'),
#  Decimal('-1.0'),
#  Decimal('-1.5'),
#  Decimal('-2.0'),
#  Decimal('-2.5'),
#  Decimal('-3.0'),
#  Decimal('-3.5'),
#  Decimal('-4.0')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution which works fine with float_range(-1, 0, 0.01) and works without floating point representation errors. It is not very fast, but works fine:    </p>
<pre><code>from decimal import Decimal

def get_multiplier(_from, _to, step):
    digits = []
    for number in [_from, _to, step]:
        pre = Decimal(str(number)) % 1
        digit = len(str(pre)) - 2
        digits.append(digit)
    max_digits = max(digits)
    return float(10 ** (max_digits))


def float_range(_from, _to, step, include=False):
    """Generates a range list of floating point values over the Range [start, stop]
       with step size step
       include=True - allows to include right value to if possible
       !! Works fine with floating point representation !!
    """
    mult = get_multiplier(_from, _to, step)
    # print mult
    int_from = int(round(_from * mult))
    int_to = int(round(_to * mult))
    int_step = int(round(step * mult))
    # print int_from,int_to,int_step
    if include:
        result = range(int_from, int_to + int_step, int_step)
        result = [r for r in result if r &lt;= int_to]
    else:
        result = range(int_from, int_to, int_step)
    # print result
    float_result = [r / mult for r in result]
    return float_result


print float_range(-1, 0, 0.01,include=False)

assert float_range(1.01, 2.06, 5.05 % 1, True) ==\
[1.01, 1.06, 1.11, 1.16, 1.21, 1.26, 1.31, 1.36, 1.41, 1.46, 1.51, 1.56, 1.61, 1.66, 1.71, 1.76, 1.81, 1.86, 1.91, 1.96, 2.01, 2.06]

assert float_range(1.01, 2.06, 5.05 % 1, False)==\
[1.01, 1.06, 1.11, 1.16, 1.21, 1.26, 1.31, 1.36, 1.41, 1.46, 1.51, 1.56, 1.61, 1.66, 1.71, 1.76, 1.81, 1.86, 1.91, 1.96, 2.01]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am only a beginner, but I had the same problem, when simulating some calculations. Here is how I attempted to work this out, which seems to be working with decimal steps.</p>
<p>I am also quite lazy and so I found it hard to write my own range function.</p>
<p>Basically what I did is changed my <code>xrange(0.0, 1.0, 0.01)</code> to <code>xrange(0, 100, 1)</code> and used the division by <code>100.0</code> inside the loop.
I was also concerned, if there will be rounding mistakes. So I decided to test, whether there are any. Now I heard, that if for example <code>0.01</code> from a calculation isn't exactly the float <code>0.01</code> comparing them should return False (if I am wrong, please let me know).</p>
<p>So I decided to test if my solution will work for my range by running a short test:</p>
<pre><code>for d100 in xrange(0, 100, 1):
    d = d100 / 100.0
    fl = float("0.00"[:4 - len(str(d100))] + str(d100))
    print d, "=", fl , d == fl
</code></pre>
<p>And it printed True for each.</p>
<p>Now, if I'm getting it totally wrong, please let me know.</p>
</div>
<div class="post-text" itemprop="text">
<p>This one liner will not clutter your code. The sign of the <strong>step</strong> parameter is important.</p>
<pre><code>def frange(start, stop, step):
    return [x*step+start for x in range(0,round(abs((stop-start)/step)+0.5001),
        int((stop-start)/step&lt;0)*-2+1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>frange(start, stop, precision)</p>
<pre><code>def frange(a,b,i):
    p = 10**i
    sr = a*p
    er = (b*p) + 1
    p = float(p)
    return map(lambda x: x/p, xrange(sr,er))

In &gt;frange(-1,1,1)

Out&gt;[-1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
</code></pre>
</div>
<span class="comment-copy">int(0.1) == 0, so the step actually is zero.  It may be unexpected, but it is zero.  You might want to restate your question to reflect that fact that it's you didn't expect this.  Saying "it's not" is false and misleading.</span>
<span class="comment-copy">BTW A short one-liner can be rolled up using <code>itertools.takewhile</code> and <code>itertools.count</code>. It isn't better than <code>drange</code> performance-wise, though.</span>
<span class="comment-copy">It's embarrassing that python's range dosen't allow this, given how easy it is to implement a generator that does this even without accumulating rounding errors. Heck, even the <code>seq</code> tool in GNU coreutils allows one to do <code>seq 0 0.1 1</code> without rounding errors!</span>
<span class="comment-copy">@josch: <code>seq</code> uses the C <code>long double</code> type internally, and <i>is</i> subject to rounding errors. For example on my machine, <code>seq 0 0.1 1</code> gives <code>1</code> as its last output (as expected), but <code>seq 1 0.1 2</code> gives <code>1.9</code> as the last output (rather than the expected <code>2</code>).</span>
<span class="comment-copy">numpy is such an ubiquitous component of python that I consider this answer to be the most 'pythonic' of all.</span>
<span class="comment-copy">@AndreTerra The problem is that @numpy@ is a third party package and adds a lot of overhead in terms of dependency-management, storage (for the package itself) etc. Depending on what the developer is doing, it may be impossible to use it.</span>
<span class="comment-copy">The first example is wrong, it should be <code>np.arange(0, 1.0, 0.1)</code>.  <code>0</code> is the first parameter, not <code>0.1</code></span>
<span class="comment-copy">@DiegoJancic Agreed: not sure why someone edited it, but I've reverted it.</span>
<span class="comment-copy">@deadcode The reason is that <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html" rel="nofollow noreferrer">np.arange</a> is defined to produce a range <code>[start,stop)</code> (i.e. excluding <code>stop</code>), so one would not expect 1.3 to be included in the list. See <a href="https://stackoverflow.com/questions/48755701/how-to-prevent-float-imprecision-from-affecting-numpy-arange">this question</a> for why it is still included and what to do against it.</span>
<span class="comment-copy">Even better, you could just use a generator comprehension if you're working with Python 2.4+. <code>(x * 0.1 for x in range(0, 10))</code>.</span>
<span class="comment-copy"><i>Even</i> better, put <code>x/10</code> instead of  <code>x * 0.1</code> :D  Nothing special actually, but some numbers in there will be more precise, e.g. for <code>3*0.1</code> you get <code>0.30000000000000004</code>, while for 3/10 you get <code>0.3</code> :)</span>
<span class="comment-copy">3/10 gives me 0, not 0.3. 3/10.0 gives 0.29999999999999999. Python 2.6.</span>
<span class="comment-copy">@LarsWirzenius: in Python 2.2+, <code>from __future__ import division; 3/10</code> returns 0.3. This behaviour is the default in Python 3.x.</span>
<span class="comment-copy">round function can also be used lst = [round(x* 0.10,2) for x in range(0,10)]</span>
<span class="comment-copy">This has roundoff problems. Please look here: <a href="http://code.activestate.com/recipes/66472/" rel="nofollow noreferrer">code.activestate.com/recipes/66472</a></span>
<span class="comment-copy">I would extend it a bit for the other direction with a (while r &gt; stop) and a corresponding r -= step for giving the opposite direction.</span>
<span class="comment-copy"><code>drange</code>? Such subtle irony :)</span>
<span class="comment-copy">yours for: <code>l=frange(0,1,0.1) print l</code> returns: <code>[0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]</code>  while numpy: <code>[ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9]</code></span>
<span class="comment-copy">I did a xfrange function without the float precision problems referred above. Check it out ;) <a href="http://stackoverflow.com/questions/477486/python-decimal-range-step-value/20549652#20549652" title="python decimal range step value">stackoverflow.com/questions/477486/â€¦</a></span>
<span class="comment-copy">I think you'll find that range() works off integers, in which case this would be the only solution, using the same function atleast.</span>
<span class="comment-copy">@cmsjr creative :D  Just one little thing: divide by 100.0 to keep Python from truncating the result if you're using Python 2.x.  I think in 3.0, it'll work as you've coded it.</span>
<span class="comment-copy">Nice, thanks alot, I'll make the edit.</span>
<span class="comment-copy"><code>for i * 100 in range(0, 100, 10)</code>: SyntaxError: can't assign to operator</span>
<span class="comment-copy">@cmsjr you were channeling python from the far far future.</span>
<span class="comment-copy">oh that's good! love <code>arange</code></span>
<span class="comment-copy">This is actually the exact same <code>arange</code> you can find in numpy: <code>&gt;&gt;&gt; import scipy &gt;&gt;&gt; import numpy &gt;&gt;&gt; numpy.arange is scipy.arange</code> will return <code>True</code>.</span>
<span class="comment-copy">This is a great answer for someone who wants to get it one without getting too much into python.</span>
<span class="comment-copy">That was <i>almost</i> what I was looking for - note that <code>seq(0.5, 3.0)</code> returns <code>[0.5, 1.5, 2.5, 3.5]</code>. To avoid last entries being out-of-range, replace <code>n = int(round(...</code> with <code>n = int(floor(...</code> with the line <code>from math import floor</code> at the top (above <code>def seq(...</code>).</span>
<span class="comment-copy">@FriendFX Don't do this! If <code>floor</code> is used, <code>seq(0.2, 0.9, 0.1)</code> will fail to reach right endpoint and will return <code>[0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7, 0.8]</code></span>
<span class="comment-copy">@user502144: Nice catch, thanks. I guess I have to settle for one of the more complex solutions in order to keep it general.</span>
<span class="comment-copy">Don't do this! Adding <code>.1</code> 10 times is not the same as adding <code>1</code>! <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="nofollow noreferrer">docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a></span>
<span class="comment-copy">For the sake of completeness, you should calculate the absolute value for the sample_count variable, that way your function will also work for a negative start (i.e from -10 to 10)</span>
<span class="comment-copy">@Deleteman done, thanks!</span>
<span class="comment-copy">If you use <code>[x/10 for x in range(10)]</code> you don't get the rounding errors...</span>
<span class="comment-copy">this has the rounding issue, quote: "When using a non-integer step, such as 0.1, the results will often not be consistent." -- <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html" rel="nofollow noreferrer">docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html</a></span>
<span class="comment-copy">How can <code>frange</code> work if stop is <code>None</code>? That part of the code doesn't even consider the step size anymore.</span>
<span class="comment-copy">@josch <code>range</code> has two signatures: <code>range(stop)</code>, which assumes a default <code>start=0, step=1</code>, and <code>range(start, stop, step)</code>, where no assumptions are made. <code>frange</code> reflects that. When using the <code>range(stop)</code> signature, both <code>frange</code> and <code>drange</code> start at 0 and increment by 1, so their behaviour is identical to regular <code>range(stop)</code> behaviour with stop rounded up to the nearest integer.</span>
<span class="comment-copy">There is an error with missing the last value if it is within 1 step of the stop value. i.e. xfrange(1,10,2) only does 1,3,5,7, missing 9</span>
<span class="comment-copy">For reference and other readers, please compare this implementation to this <a href="http://stackoverflow.com/a/477610/54964">stackoverflow.com/a/477610/54964</a>. This does not seem to have big float problems.</span>
<span class="comment-copy">@carlosvega Can you confirm why Lobe gets his result?</span>
<span class="comment-copy">Doesn't seem to work correctly, e.g. <code>list(frange(99.8, 100.1, 0.1)) =&gt; [99.7, 99.80000000000001, 99.9]</code></span>
<span class="comment-copy">WIth similar <code>Decimal</code> inputs, <code>np.arange</code> works the same: <code>np.arange(Decimal('-2.0'), Decimal('2.0'), Decimal('0.1'))</code></span>
<span class="comment-copy">Yep, thanks. Although, that would need an external (numpy) lib.</span>
