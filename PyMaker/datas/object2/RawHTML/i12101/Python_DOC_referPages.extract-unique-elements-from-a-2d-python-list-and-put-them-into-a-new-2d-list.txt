<div class="post-text" itemprop="text">
<p>Right now I have a 2D list with three columns and numerous rows, each column contains a unique type of stuff. The first column is UserID, the second column is timestamp, the third column is URL. The list looks like this:</p>
<pre><code>[[304070, 2015:01:01, 'http:something1'],
[304070, 2015:01:02, 'http:something2'],
[304070, 2015:01:03, 'http:something2'],
[304070, 2015:01:03, 'http:something2'],
[304071, 2015:01:04, 'http:something2'],
[304071, 2015:01:05, 'http:something3'],
[304071, 2015:01:06, 'http:something3']]
</code></pre>
<p>As you can see, there are some duplicate URLs, regardless of userID and timestamp. </p>
<p>I need to extract those rows which contain unique URLs and put them into a new 2D list. </p>
<p>For example, the second row, third row, forth row and fifth row all have the same URL regardless of userID and timestamp. I only need the second row (first one appears) and put it into my new 2D list. That being said, the first row has a unique URL and I will also put it into my new list. The last two rows ( sixth and seventh ) have the same URL, and I only need the sixth row. </p>
<p>Therefore, my new list should look like this:</p>
<pre><code>[304070, 2015:01:01, 'http:something1'],
[304070, 2015:01:02, 'http:something2'],
[304071, 2015:01:05, 'http:something3']]
</code></pre>
<p>I thought about using something like this:</p>
<pre><code>for i in range(len(oldList):
    if oldList[i][2] not in newList:
        newList.append(oldList[i])
</code></pre>
<p>but obviously this one does not work, becuase <code>oldList[i][2]</code> is an element, <code>not in newList</code> is checking the entire 2D list, ie, checking every row. Codes like this will just create an exact copy of <code>oldList</code>. </p>
<p>OR, I could just eliminate those rows having duplicate URLs, because using a for loop plus append operator on a 2D list with one million rows really would take a while.  </p>
</div>
<div class="post-text" itemprop="text">
<p>A good way of going about this would be to use a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow">set</a>. Go through your list of lists one at a time, adding the URL to the set if it's not already there, and adding the full list containing that URL to your new list. If a URL is already in the set, discard the current list and move to the next one. </p>
<pre><code>old_list = [[304070, "2015:01:01", 'http:something1'],
            [304070, "2015:01:02", 'http:something2'],
            [304070, "2015:01:03", 'http:something2'],
            [304070, "2015:01:03", 'http:something2'],
            [304071, "2015:01:04", 'http:something2'],
            [304071, "2015:01:05", 'http:something3'],
            [304071, "2015:01:06", 'http:something3']]
new_list = []
url_set = set()

for item in old_list:
    if item[2] not in url_set:
        url_set.add(item[2])
        new_list.append(item)
    else:
        pass

&gt;&gt;&gt; print(new_list)
[[304070, '2015:01:01', 'http:something1'], [304070, '2015:01:02', 'http:something2'], [304071, '2015:01:05', 'http:something3']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; old_list = [[304070, "2015:01:01", 'http:something1'],
...            [304070, "2015:01:02", 'http:something2'],
...            [304070, "2015:01:03", 'http:something2'],
...            [304070, "2015:01:03", 'http:something2'],
...            [304071, "2015:01:04", 'http:something2'],
...            [304071, "2015:01:05", 'http:something3'],
...            [304071, "2015:01:06", 'http:something3']]
&gt;&gt;&gt; temp_dict = {}
&gt;&gt;&gt; for element in old_list:
...     if element[2] not in temp_dict:
...         temp_dict[element[2]] = [element[0], element[1], element[2]]
... 
&gt;&gt;&gt; temp_dict.values()
[[304070, '2015:01:01', [304070, '2015:01:02', 'http:something2'], 'http:something1'], [304071, '2015:01:05', 'http:something3']]
</code></pre>
<p><strong>Note</strong>: I am assuming that the order of different URLs in the list doesn't matter. In case it does matter, use <code>OrderedDict</code> instead of default <code>dict</code>. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_list = [[304070, '2015:01:01', 'http:something1'],
           [304070, '2015:01:02', 'http:something2'],
           [304070, '2015:01:03', 'http:something2'],
           [304070, '2015:01:03', 'http:something2'],
           [304071, '2015:01:04', 'http:something2'],
           [304071, '2015:01:05', 'http:something3'],
           [304071, '2015:01:06', 'http:something3']]
</code></pre>
<p>Pull out all of the urls from the original list.  Create a set from this list to generate unique values for the urls.  Use a list comprehension to iterate through this set and use <code>index</code> on the url list generated (<code>urls</code>) to locate the first occurrence of that url.</p>
<p>Lastly, use another list comprehension together with <code>enumerate</code> to select rows that have matching index values.</p>
<pre><code>urls = [row[2] for row in my_list]
urls_unique = set(urls)
idx = [urls.index(url) for url in urls_unique]
my_shorter_list = [row for n, row in enumerate(my_list) if n in idx]

&gt;&gt;&gt; my_shorter_list
[[304070, '2015:01:01', 'http:something1'],
 [304070, '2015:01:02', 'http:something2'],
 [304071, '2015:01:05', 'http:something3']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to create a function which searches the list for item with the url.</p>
<pre><code>def hasUrl(list, url):
    for item in list:
        if item[1] == url:
            return True
    return False
</code></pre>
<p>Then your new list creation algorithm should look like this.</p>
<pre><code>for i in range(len(oldList)):
    if not hasUrl(newList, oldList[i][2]): # check if url is in list
        newList.append(oldList[i])
</code></pre>
<p>Also, there is no need to create a range. Python <code>for</code> loop iterates by values, so you can write just</p>
<pre><code>for item in oldList:
    if not hasUrl(newList, item[2]): # check if url is not in list
        newList.append(item)
</code></pre>
</div>
<span class="comment-copy">That seems like an unnecessary use of space to me. It may be faster, but with normal urls, it takes almost twice as much space as it could.</span>
<span class="comment-copy">What do you mean by that? What space are you talking about?</span>
<span class="comment-copy">I mean physical memory. You save all your urls in url_set, which allocates more memory than necessary. Or does Python somehow make references out of it?</span>
<span class="comment-copy">Depending on the size of the original list, memory consumption is trivial. And yes, references are made.</span>
<span class="comment-copy">I just tried, it didn't run because "unsupported operand type(s) for +=: 'set' and 'str' "      Does that mean there is no += operator for set? I've never used set before, python is not my expertise, so excuse my 'stupidity'</span>
<span class="comment-copy">if item[1] == url1: return True.   Is that essentially adding the duplicate items over and over again? Sorry, lol.  Did not see ' if NOT' .  My bad</span>
<span class="comment-copy">The <code>not</code> was not there originally, I added it after I realized it was wrong with the edit.</span>
