<div class="post-text" itemprop="text">
<p>I have a python function that returns multiples values. My function:</p>
<pre><code>def myExampleFunction(a,b)
    # here is my code
    return name, number1, number2


def FunctionIWantToTest(self):
    # here is my code
    myName, myNumber1, myNumber2 = self.myExampleFunction(a,b)
</code></pre>
<p>I want to give my own values to the returned values from FunctionIWantToTest. So, I'm trying to test the 2nd function with nosetest, but I don't know how to mock the return of myExampleFunction.</p>
<p>I tried this:</p>
<pre><code>def test_mytest(self):
    [...]
    c.myExampleFunction = Mock()
    c.myExampleFunction.side_effect = ["myName", 100, 200]
    [...]
</code></pre>
<p>But it doesn't work. When I launch nosetests I read this message:</p>
<pre><code>ValueError: too many values to unpack
</code></pre>
<p>Any idea? I use python 2.7.3</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to set the <code>return_value</code> of the mock, not <code>side_effect</code>.</p>
<p>You can do this when you instantiate it:</p>
<pre><code>c.myExampleFunction = Mock(return_value=["myName", 100, 200])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just wanted to share how to get this to work with <code>side_effect</code>. I put together a simplified version to showcase how to use <code>side_effect</code> for your use case.</p>
<p><code>side_effect</code> behaves differently than return_value, where when you provide a <code>side_effect</code> with a list with entries, what you are stating actually is that, each time your mocked method is called it will return each item in the list as its return value. This is actually why you are getting <em>ValueError: too many values to unpack (expected 3)</em>, because by doing this: </p>
<pre><code>[1, 2, 3]
</code></pre>
<p>You are saying, for each call to my mocked method, return 1, then the next time I call the method, return 2, then return 3. </p>
<p>With that in mind, if you set up your <code>side_effect</code>, like this: </p>
<pre><code>[('stuff1', 'stuff2', 'stuff3')]
</code></pre>
<p>What you are now saying, is that, for when you call side_effect, the first item in the list is what will be returned. Which, in effect is: </p>
<pre><code>('stuff1', 'stuff2', 'stuff3')
</code></pre>
<p>Alternatively, you can do this: </p>
<pre><code>my_test_foo.side_effect = lambda x, y: (1, 2, 3)
</code></pre>
<p>Which mimics out the method you are testing by taking two args and returning the three values it should return. </p>
<p>So, with this in mind, your test can be structured as: </p>
<pre><code>import unittest
from unittest.mock import Mock

from mock import patch
from stuff import FunctionIWantToTest


class MyTest(unittest.TestCase):

    @patch('stuff.myExampleFunction', return_value=Mock())
    def test_mytest(self, m_example_function):
        m_example_function.side_effect = [("stuff1", 100, 200)]
        # m_example_function.side_effect = lambda x, y: ("stuff1", 100, 200)

        a, b, c = FunctionIWantToTest()

if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="nofollow noreferrer">Documentation</a>: If side_effect is an iterable then each call to the mock will return the next value from the iterable.</span>
<span class="comment-copy">I response myself: The code that woks for me: c.myExampleFunction.return_value = "myName", 100, 200</span>
<span class="comment-copy">This is the same as Daniel's answer so please accept it. This makes it easier for users with a similar problem to recognize, that this answer worked. Answers in comments are hard to find.</span>
<span class="comment-copy">It works! thanks Daniel and DreyFax!</span>
