<div class="post-text" itemprop="text">
<p>I have written the following sample code to demonstrate my issue.</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-v', '--version', action='version',
                    version='%(prog)s 1.0')
parser.parse_args()
</code></pre>
<p>This produces the following help message.</p>
<pre><code>$ python foo.py --help
usage: foo.py [-h] [-v]

optional arguments:
  -h, --help     show this help message and exit
  -v, --version  show program's version number and exit
</code></pre>
<p>I want to customize this help output such that it capitalizes all phrases and sentences, and puts period after sentences. In other words, I want the help message to be generated like this.</p>
<pre><code>$ python foo.py --help
Usage: foo.py [-h] [-v]

Optional arguments:
  -h, --help     Show this help message and exit.
  -v, --version  Show program's version number and exit.
</code></pre>
<p>Is this something that I can control using the argparse API. If so, how? Could you please provide a small example that shows how this can be done?</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all: capitalising those phrases flies in the face of convention, and <code>argparse</code> isn't really tooled to help you change these strings easily. You have three different classes of strings here: boilerplate text from the help formatter, section titles, and help text per specific option. All these strings are localisable; you <em>could</em> just provide a 'capitalised' translation for all of these strings via the <a href="https://docs.python.org/3/library/gettext.html" rel="noreferrer"><code>gettext()</code> module support</a>. That said, you can reach in and replace all these strings if you are determined enough and <a href="https://hg.python.org/cpython/file/3.5/Lib/argparse.py" rel="noreferrer">read the source code a little</a>. </p>
<p>The <code>version</code> action includes a default <code>help</code> text, but you can supply your own by setting the <code>help</code> argument. The same applies to the <code>help</code> action; if you set the <a href="https://docs.python.org/3/library/argparse.html#add-help" rel="noreferrer"><code>add_help</code> argument</a> to <code>False</code> you can add that action manually:</p>
<pre><code>parser = argparse.ArgumentParser(add_help=False)

parser.add_argument('-v', '--version', action='version',
                    version='%(prog)s 1.0', help="Show program's version number and exit.")
parser.add_argument('-h', '--help', action='help', default=argparse.SUPPRESS,
                    help='Show this help message and exit.')
</code></pre>
<p>Next, the <code>optional arguments</code> message is a <em>group title</em>; each parser has two default groups, one for positional arguments, the other for optional. You can reach these by the attributes <code>_positionals</code> and <code>_optionals</code>, both of which have a <code>title</code> attribute:</p>
<pre><code>parser._positionals.title = 'Positional arguments'
parser._optionals.title = 'Optional arguments'
</code></pre>
<p><em>Be warned</em>, by accessing names starting with an underscore you are venturing into the undocumented private API of the module, and your code may break in future updates.</p>
<p>Finally, to change the <code>usage</code> string, you'll have to subclass the help formatter; pass the subclass in as the <a href="https://docs.python.org/3/library/argparse.html#formatter-class" rel="noreferrer"><code>formatter_class</code> argument</a>:</p>
<pre><code>class CapitalisedHelpFormatter(argparse.HelpFormatter):
    def add_usage(self, usage, actions, groups, prefix=None):
        if prefix is None:
            prefix = 'Usage: '
        return super(CapitalisedHelpFormatter, self).add_usage(
            usage, actions, groups, prefix)

parser = argparse.ArgumentParser(formatter_class=CapitalisedHelpFormatter)
</code></pre>
<p>Demo, putting these all together:</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; class CapitalisedHelpFormatter(argparse.HelpFormatter):
...     def add_usage(self, usage, actions, groups, prefix=None):
...         if prefix is None:
...             prefix = 'Usage: '
...         return super(CapitalisedHelpFormatter, self).add_usage(
...             usage, actions, groups, prefix)
...
&gt;&gt;&gt; parser = argparse.ArgumentParser(add_help=False, formatter_class=CapitalisedHelpFormatter)
&gt;&gt;&gt; parser._positionals.title = 'Positional arguments'
&gt;&gt;&gt; parser._optionals.title = 'Optional arguments'
&gt;&gt;&gt; parser.add_argument('-v', '--version', action='version',
...                     version='%(prog)s 1.0', help="Show program's version number and exit.")
_VersionAction(option_strings=['-v', '--version'], dest='version', nargs=0, const=None, default='==SUPPRESS==', type=None, choices=None, help="Show program's version number and exit.", metavar=None)
&gt;&gt;&gt; parser.add_argument('-h', '--help', action='help', default=argparse.SUPPRESS,
...                     help='Show this help message and exit.')
_HelpAction(option_strings=['-h', '--help'], dest='help', nargs=0, const=None, default='==SUPPRESS==', type=None, choices=None, help='Show this help message and exit.', metavar=None)
&gt;&gt;&gt; print(parser.format_help())
Usage: [-v] [-h]

Optional arguments:
  -v, --version  Show program's version number and exit.
  -h, --help     Show this help message and exit.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Martijn has give a couple of the fixes that came to mind - the providing the <code>help</code> parameter, and a custom Formatter class.</p>
<p>One other partial fix is to modify the help string after the argument is created.  <code>add_argument</code> creates and returns an <code>Action</code> object that contains the parameters and defaults.  You can save a link to this, and modify the <code>Action</code>.  You can also get a list of those actions, and act on that.  </p>
<p>Let me illustrate, for a simple parser with the default help and one other argument, the action list is:</p>
<pre><code>In [1064]: parser._actions
Out[1064]: 
[_HelpAction(option_strings=['-h', '--help'], dest='help', nargs=0, const=None, default='==SUPPRESS==', type=None, choices=None, help='show this help message and exit', metavar=None),
 _StoreAction(option_strings=['-f', '--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)]
</code></pre>
<p>I can view and modify the <code>help</code> attribute of any of these:</p>
<pre><code>In [1065]: parser._actions[0].help
Out[1065]: 'show this help message and exit'
In [1066]: parser._actions[0].help='Show this help message and exit.'
</code></pre>
<p>producing this help:</p>
<pre><code>In [1067]: parser.parse_args(['-h'])
usage: ipython3 [-h] [-f FOO]    
optional arguments:
  -h, --help         Show this help message and exit.
  -f FOO, --foo FOO
</code></pre>
<p>Using the <code>parser._actions</code> list uses a 'private' attribute, which some people consider unwise.  But in Python that public/private distinction is not tight, and can be broken with care.  Martijn is doing that by accessing the <code>parser._positionals.title</code>.</p>
<p>Another way to change that group title is with custom argument groups</p>
<pre><code>ogroup=parser.add_argument_group('Correct Optionals Title')
ogroup.add_argument('-v',...)
ogroup.add_argument('-h',...)
</code></pre>
</div>
<span class="comment-copy">Have you tried setting <a href="https://docs.python.org/3/library/argparse.html#help" rel="nofollow noreferrer"><code>help</code></a>?</span>
<span class="comment-copy">Oh, I see - then you could set <code>add_help</code> to <code>False</code> and do it manually. But lowercase is the convention for these things.</span>
<span class="comment-copy">I think that even the non-underscore methods of  <code>argparse.HelpFormatter</code> are private API: <a href="https://github.com/python/cpython/blob/v3.6.5/Lib/argparse.py#L58" rel="nofollow noreferrer">github.com/python/cpython/blob/v3.6.5/Lib/argparse.py#L58</a> "Also note that HelpFormatter and RawDescriptionHelpFormatter are only considered public as object names -- the API of the formatter objects is still considered an implementation detail."</span>
