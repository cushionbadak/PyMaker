<div class="post-text" itemprop="text">
<p>I have written this algorithm that finds all factors of a given number and puts them into a list:</p>
<pre><code>def find_all_factors(n):
    factors = []
    for i in range(1, floor(sqrt(n))+1):
        if n % i == 0:
            factors.append(i)
            cofactor = n // i
            if i != cofactor: factors.append(cofactor)
    return factors
</code></pre>
<p>Inside the list cofactors will be placed next to eachother, but I would like them to appear in sorted order instead. Example of output from algorithm above: for <code>n = 36</code> it outputs <code>[1, 36, 2, 18, 3, 12, 4, 9, 6]</code>. I'm doing this as an exercise and I would like to know what the most efficient way of getting them in sorted order would be, any ideas?</p>
<p>You can see one of my solutions below. It works, but I don't think it's optimal.</p>
<pre><code>def find_all_factors(n):
    lower_factors = []
    higher_factors = []
    for i in range(1, floor(sqrt(n))+1):
        if n % i == 0:
            lower_factors.append(i)
            cofactor = n // i
            if i != cofactor: higher_factors.append(cofactor)
    return lower_factors + [higher_factors[-i] for i in range(1, len(higher_factors)+1)]  #Reverses higher_factors.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just simply return the sorted list:</p>
<pre><code>return sorted(factors)
</code></pre>
<p>how ever if you dont like using <code>sorted</code> function simply change for loop range to (1,n+1) :</p>
<pre><code>def find_all_factors(n):
    factors = []
    for i in range(1, n+1):
        if n % i == 0:
            factors.append(i)
    return factors

find_all_factors(12) # [1, 2, 3, 4, 6, 12]
</code></pre>
<p>another way is using <code>bisect</code>(most efficient way):</p>
<pre><code>import bisect
def find_all_factors(n):
    factors = []
    for i in range(1, math.floor(math.sqrt(n))+1):
        if n % i == 0:
            bisect.insort(factors,i)
            cofactor = n // i
            if i != cofactor: bisect.insort(factors, cofactor)
    return factors

find_all_factors(12) # [1, 2, 3, 4, 6, 12]
</code></pre>
<p>Insert in this module is <code>O(n)</code> however search is <code>O(log(n))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The one thing you are missing is simpler and easier operations on your lists. There is a Python built-in for reversing a sequence: <a href="https://docs.python.org/3/library/functions.html?highlight=reversed#reversed" rel="nofollow"><code>reversed</code>.</a></p>
<p>So you can do:</p>
<pre><code>return lower_factors + list(reversed(higher_factors))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from math import floor, sqrt


def find_all_factors(n):
    factors = []
    for i in xrange(1, int(floor(sqrt(n)))+1):
        quotient, remainder = divmod(n, i)
        if remainder == 0:
            factors.append(i)
            if quotient not in factors:
                factors.append(quotient)
    return sorted(factors)

print find_all_factors(36)
</code></pre>
<p>output:<code>[1, 2, 3, 4, 6, 9, 12, 18, 36]</code></p>
</div>
<span class="comment-copy">Since it's an exercise I would like to have the sorting as part of the algorithm and not rely on running a separate sorting algorithm.</span>
<span class="comment-copy">I asked for the most efficient way of getting the factors in sorted order, and adding a O(nlog(n)) sorting algorithm to the end of it is certainly not the most efficient way.</span>
<span class="comment-copy">I think it's near optimal ( O sqrt(n) complexity )  with basic python tools.</span>
<span class="comment-copy">That will result in a runtime error since you are trying to concatenate a list with an iterator. You would have to convert the iterator to a list, like so: list(reversed(higher_factors)).</span>
