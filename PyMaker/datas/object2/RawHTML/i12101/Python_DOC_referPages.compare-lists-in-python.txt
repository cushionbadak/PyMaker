<div class="post-text" itemprop="text">
<p>I have a text file, which looks like:</p>
<pre><code>0010000110
1111010111
0000110111
</code></pre>
<p>I want to import them in python as list and then compare each element of the list to corresponding element in other list and do it for all combination of lists. If both of elements are 1, increase counter by 1 and in the end divide by the length of the list. I tried to write code, but it does not work as it should:</p>
<pre><code>with open("D:/test/Vector.txt", "r") as f1:
   for a in f1:
      with open("D:/test/Vector.txt", "r") as f2:
         for b in f2:
            for i in range(10):
                result = 0;
                counter = 0;
                if int(a[i]) == int(b[i]) == 1:
                    counter = counter+1
            result = counter / 10;
            print(a, b, result)
</code></pre>
<p>Edit: When creating text file with python, it moved every entry with \n on a new line, but I have no idea how to delete it.</p>
<p>Expected output:</p>
<pre><code>0010000110 0010000110 1
0010000110 1111010111 0.3
0010000110 0000110111 0.2
1111010111 0010000110 0.3
1111010111 1111010111 1
1111010111 0000110111 0.4
0000110111 0010000110 0.2
0000110111 1111010111 0.4
0000110111 0010000110 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just make sure that the two strings are not equals before proceeding. Here is a basic solution for your problem in order to get the expected output :</p>
<pre><code>f = open("Vector.txt", 'r')

l1 = [s.strip('\n') for s in f]
l2 = [s for s in l1]

f.close()

for a in l1:
    for b in l2:
        result = 0
        if (a == b):
            result = 1
        else:
            counter = 0
            for i in range(len(a)):
                if (int(a[i]) == int(b[i]) == 1):
                    counter += 1
            result = counter / len(a)
        print(a, b, result)
</code></pre>
<p>This works fine with Python 3 and here is the result :</p>
<pre><code>0010000110 0010000110 1
0010000110 1111010111 0.3
0010000110 0000110111 0.2
1111010111 0010000110 0.3
1111010111 1111010111 1
1111010111 0000110111 0.4
0000110111 0010000110 0.2
0000110111 1111010111 0.4
0000110111 0000110111 1
</code></pre>
<p>Edit : You are not obliged to use two lists. You can just use the l1 list and iterate over it two times. If you want to use index, you can avoid iteration and move through the list with indexes by using :</p>
<pre><code>for a in range(0, len(l)):
   for b in range(0, len(l)):
</code></pre>
<p>If you want to access one string element with indexes you can then do :</p>
<pre><code>for i in range(len(l[a]):
    if (int(l[a][i]) == int(l[b][i]) == 1):
        counter += 1
</code></pre>
<p>The final instruction would then be :</p>
<pre><code>print((a + 1), (b + 1), result)
</code></pre>
<p>To get rid of annoying string process, you can then visit <a href="https://docs.python.org/3.1/library/string.html" rel="nofollow">this page</a></p>
<hr/>
<p>EDIT :</p>
<p>To answer your efficiency problem asked in the comments, here is a solution involving threading and less complexity while we faced pure quadratic complexity before. This solution assumes that all strings contained in a file have the same length and that the files are not going to be compared to each other. If this is not the case, I'm sure you will be able to find a solution with this basic approach.</p>
<p>Each comparison is then stored into a file named like <em>sourcefile_compared.txt</em> and each word in a row is comma separated. Because we use the files and launch several thread, the algorithm uses exceptions intensively. Cause I don't know your server, I would suggest that you try this on your own machine and set up yourself the files path.</p>
<p>If you want something approaching linear complexity, you have to make a choice cause you actually want a computation for each string against each other.</p>
<pre><code>import os
import threading


class ListComparator(threading.Thread):

    def __init__(self, file):

        threading.Thread.__init__(self)
        self.file = file
        self._stopevent = threading.Event()

    def run(self):
        name, extension = os.path.splitext(self.file)

        if (extension == '.txt'):

            print('comparing strings in file ' + name)

            try :
                f = open(file, 'r')

                l = [s.strip('\n') for s in f]

                f.close()

            except:
                print('unable to open file' + file)
                l = None

            if (l != None):

                try :

                    target = open(name + '_compared.txt', 'w')

                except Exception as e:
                    print(e)
                    target = None

                if (target != None):
                    for i in range(0, len(l) - 1):
                        for j in range(i + 1, len(l)):
                            result = 0
                            counter = 0

                            for k in range(len(l[i])):
                                if (int(l[i][k]) == int(l[j][k]) == 1):
                                    counter += 1

                            result = counter / len(l[i])
                            s = l[i] + ', ' + l[j] + ', ' + str(result) + '\n'

                            target.write(s)

                    target.close()

                    print(name + ' compared')
                else:
                    print(name + ' not compared')

        def stop(self):
            self._stopevent.set()


current_dir = os.getcwd()

for subdir, dirs, files in os.walk(current_dir):

    for file in files:

        try :
            comp = ListComparator(file)
            comp.start()

        except Exception as e:
            print(e)
</code></pre>
<p>Here is the output coming out from the console :</p>
<pre><code>comparing strings in file v
comparing strings in file Vector
Vector compared
v compared
</code></pre>
<p>Here are the datas written into vector_compared.txt:</p>
<pre><code>0010000110, 1111010111, 0.3
0010000110, 0000110111, 0.2
1111010111, 0000110111, 0.4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/stdtypes.html#str.strip" rel="nofollow"><code>str.strip</code></a> method to remove whitespace from a string.</p>
<hr/>
<p>If you have multiple sequences and you want to do something with the corresponding elements of each sequence you can use <code>zip</code> to <em>aggregate</em> those elements together. (note <code>zip</code> returns an iterator so in the example <code>list</code> is used to show its result)</p>
<pre><code>&gt;&gt;&gt; list(zip('0010000110', '1111010111'))
[('0', '1'), ('0', '1'), ('1', '1'), ('0', '1'), ('0', '0'), ('0', '1'), ('0', '0'), ('1', '1'), ('1', '1'), ('0', '1')]
&gt;&gt;&gt;
</code></pre>
<p>If the sequences are <em>in</em> a container, you need to unpack them for use with <code>zip</code>:</p>
<pre><code>&gt;&gt;&gt; a
['0010000110', '1111010111']
&gt;&gt;&gt; list(zip(*a))
[('0', '1'), ('0', '1'), ('1', '1'), ('0', '1'), ('0', '0'), ('0', '1'), ('0', '0'), ('1', '1'), ('1', '1'), ('0', '1')]
&gt;&gt;&gt;
</code></pre>
<p>Once you have the <em>arguments</em> all grouped together, it makes it easy to do <em>stuff</em> with them - you can pass them to a function or in your case just compare them:</p>
<pre><code>&gt;&gt;&gt; [x == y for x,y in zip(*a)]
[False, False, True, False, True, False, True, True, True, False]
&gt;&gt;&gt; 
</code></pre>
<p><code>sum</code> will consume an iterator/iterable and <em>count</em> all the <code>True</code>'s - <code>True</code> has a value of one and <code>False</code> has a value of zero.</p>
<pre><code>&gt;&gt;&gt; sum(x == y for x,y in zip(*a))
5
&gt;&gt;&gt;
</code></pre>
<p>As an aside: you can assign the result of <code>zip</code> to a name and use it.  It could make things easier to read:</p>
<pre><code>&gt;&gt;&gt; my_groups = zip(*a)
&gt;&gt;&gt; my_groups
&lt;zip object at 0x000000000308A9C8&gt;
&gt;&gt;&gt; sum(x == y for x,y in my_groups)
5
&gt;&gt;&gt;
</code></pre>
<p>If you have a few things and you want to compare each with the other, <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> can make it easy to <em>get</em> the combinations/permutations.</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; data
['0010000110', '1111010111', '0000110111']

&gt;&gt;&gt; for permutation in itertools.permutations(data, 2):
    print(permutation)

('0010000110', '1111010111')
('0010000110', '0000110111')
('1111010111', '0010000110')
('1111010111', '0000110111')
('0000110111', '0010000110')
('0000110111', '1111010111')
&gt;&gt;&gt; 
</code></pre>
<p>Using <code>zip</code>, <code>sum</code>, and <code>itertools</code> you can write something that does what you want</p>
<pre><code>&gt;&gt;&gt; for combination in itertools.combinations_with_replacement(data, 2):
    print(combination, sum(x == y for x,y in zip(*combination)))


('0010000110', '0010000110') 10
('0010000110', '1111010111') 5
('0010000110', '0000110111') 6
('1111010111', '1111010111') 10
('1111010111', '0000110111') 5
('0000110111', '0000110111') 10
&gt;&gt;&gt; 

&gt;&gt;&gt; for a,b in itertools.combinations_with_replacement(data, 2):
    total = sum(x == y for x,y in zip(a, b))
    ratio = total / len(a)
    print(a, b, total, ratio)


0010000110 0010000110 10 1.0
0010000110 1111010111 5 0.5
0010000110 0000110111 6 0.6
1111010111 1111010111 10 1.0
1111010111 0000110111 5 0.5
0000110111 0000110111 10 1.0
&gt;&gt;&gt;
</code></pre>
<p>I like to use <a href="https://docs.python.org/3/library/string.html#format-examples" rel="nofollow">format strings</a> to format my print statements:</p>
<pre><code>&gt;&gt;&gt; s = 'combination: {} {}\ttotal: {}\tratio: {}'
&gt;&gt;&gt; for a,b in itertools.combinations_with_replacement(data, 2):
    total = sum(x == y for x,y in zip(a, b))
    ratio = total / len(a)
    print(s.format(a, b, total, ratio))


combination: 0010000110 0010000110  total: 10   ratio: 1.0
combination: 0010000110 1111010111  total: 5    ratio: 0.5
combination: 0010000110 0000110111  total: 6    ratio: 0.6
combination: 1111010111 1111010111  total: 10   ratio: 1.0
combination: 1111010111 0000110111  total: 5    ratio: 0.5
combination: 0000110111 0000110111  total: 10   ratio: 1.0
&gt;&gt;&gt;
</code></pre>
<hr/>
<p>I have been using <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow">list comprehensions and generator expressions</a> which are a compact way of writing a <code>for</code> loop - many people prefer them once they get used to them (as long as they are not too complicated):</p>
<pre><code>&gt;&gt;&gt; data = [1,2,3]
&gt;&gt;&gt; for x in data:
    print(x+2)

3
4
5
</code></pre>
<p>This can be written in the <em>shorthand</em> format as a list comprehension:</p>
<pre><code>&gt;&gt;&gt; [x + 2 for x in data]
[3, 4, 5]
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">Expected output for your sample file, please.</span>
<span class="comment-copy">You can iterate with <code>zip(a, b)</code> and say <code>for suba, subb in zip(a, b)</code>.  That way, you don't have to deal with <code>a[i]</code>; you can just use <code>suba</code>.  Also, you don't need semicolons at the end of your lines.  In Python, a newline or a semicolon means "next command".  Using both is redundant.</span>
<span class="comment-copy">How did you end up with <code>1</code> in the first example?...you said if both are <code>1</code> then increment by <code>1</code>?..Shouldn't be <code>0.3</code> ?</span>
<span class="comment-copy">You reset <code>counter</code> to zero before you actually do anything with <code>counter</code>. The line <code>counter = 0</code> is inside your inner loop, the line <code>result = counter / 10</code> outside. I suspect you want <code>counter = 0</code> outside the <code>for i in range(10)</code>.</span>
<span class="comment-copy">To get rid of the unwanted newlines in the output, use <code>print(a.rstrip('\n'), b.rstrip('\n'), result)</code>. (Or strip them away at any earlier point, as the rest of your logic doesn't require them, either.) Note that <code>some_string.rstrip(...)</code> does <b>not</b> modify <code>some_string</code>. (<code>str</code> is immutable.) Instead it <b>returns</b> the stripped string.</span>
<span class="comment-copy">Thanks a lot, it is exactly what I need.</span>
<span class="comment-copy">is there possibility to optimize calculation? I have 4723 lists with 10,000 entires each. It will take forever to calculate result, maybe another approach will be better?  If I save directly to text file without printing instead of printing, maybe this speeds up ?</span>
<span class="comment-copy">Do you need to compare each string even if it is the same ? If not, you can build a queue in order to avoid that and end up with something that has the complexity of the sum of an algebric suite : n - 1 + n - 2 + ... + 1. If you don't need to compare each file against each other, maybe you could use multi threading. It is possible otherwise but you will have to protect the files while you are opening and closing them. Then, you are right, printing a result costs but it might be slower to save the data to you hard drive (SSD, PCI bus, central memory, etc.). This is an interesting problem :)</span>
<span class="comment-copy">Edit : for now the complexity is quadratic...</span>
<span class="comment-copy">The server I am running tests is using SSD. Server has 24 cores, but only one is performing calculations. What I can not understand is that, if file is 45mb, after importing it to python and comparing each element with other, it should grow radically and be stored in memory while calculating, but Ram is not growing. Just not so experienced, sorry If I am totally wrong.</span>
