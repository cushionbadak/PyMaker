<div class="post-text" itemprop="text">
<p>I've been using concurrent.futures as it has a simple interface and let user easily control the max number of threads/processes. However, it seems like concurrent.futures hides failed tasks and continue the main thread after all tasks finished/failed.</p>
<pre><code>import concurrent.futures

def f(i):
    return (i + 's')

with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
    fs = [executor.submit(f, i ) for i in range(10)]
    concurrent.futures.wait(fs)
</code></pre>
<p>Calling f on any integer leads an TypeError. However, the whole script runs just fine and exits with code 0. Is there any way to make it throw an exception/error when any thread failed?</p>
<p>Or, is there a better way to limit number of threads/processes without using concurrent.futures?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>concurrent.futures.wait</code> will ensure all the tasks completed, but it doesn't check success (something <code>return</code>-ed) vs. failure (exception raised and not caught in worker function). To do that, you need to call <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.result" rel="noreferrer"><code>.result()</code></a> on each <code>Future</code> (which will cause it to either re-<code>raise</code> the exception from the task, or produce the <code>return</code>-ed value). There are other methods to check without actually raising in the main thread (e.g. <code>.exception()</code>), but <code>.result()</code> is the most straightforward method.</p>
<p>If you want to make it re-<code>raise</code>, the simplest approach is just to replace the <code>wait()</code> call with:</p>
<pre><code>for fut in concurrent.futures.as_completed(fs):
    fut.result()
</code></pre>
<p>which will process results as <code>Future</code>s complete, and promptly <code>raise</code> an <code>Exception</code> if one occurred. Alternatively, you continue to use <code>wait</code> so all tasks finish before you check for exceptions on any of them, then iterate over <code>fs</code> directly and call <code>.result()</code> on each.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is another way to do the same with multiprocessing.Pool (for processes) or multiprocessing.pool.ThreadPool (for threads). As far as I know it rethrows any caught exceptions.</p>
</div>
<span class="comment-copy">related: <a href="https://stackoverflow.com/questions/33448329/how-to-detect-exceptions-in-concurrent-futures-in-python3" title="how to detect exceptions in concurrent futures in python3">stackoverflow.com/questions/33448329/â€¦</a></span>
<span class="comment-copy">The <code>.result()</code> approach works---thank you.</span>
<span class="comment-copy">This question is about <code>concurrent.futures</code> AFAIK this is the more modern implementation of the multiprocessing module. For me it makes no sense to suggest to use the old library.</span>
<span class="comment-copy">@guettli, this old library is still actively used by many parallel libraries, e.g. Joblib and Dask. And futures are just functionally not equivalent to Pool with its <code>map</code> function - which is potentially more efficient than waiting on multiple future objects.</span>
<span class="comment-copy">Yes, multiprocessing is actively used by many libraries. But the heading of this question is: "Detect failed tasks in concurrent.futures"</span>
<span class="comment-copy">Yes. But does it mean we cannot suggest any alternatives to the way OP thinks? Sometimes there is no other way to anwer the question but redirect to something else.</span>
<span class="comment-copy">AFAIK concurrent.futures is more modern. I know multiprocessing is not deprecated, but I would not suggest to go back. Of course redirecting to something else is very helpful sometimes.</span>
