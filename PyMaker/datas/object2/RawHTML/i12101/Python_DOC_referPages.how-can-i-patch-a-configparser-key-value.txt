<div class="post-text" itemprop="text">
<p>When I use the following code:</p>
<pre><code>from unittest import mock
import configparser

configtext = '''
[SECTION]
whatever=True
'''

config = configparser.ConfigParser()
config.read_string(configtext)


def test_fails():
    expected_value = 'fnord'
    with mock.patch.dict(config, {'db': expected_value}):
        assert config['db'] is expected_value
</code></pre>
<p>My test fails because <code>AttributeError: 'str' object has no attribute 'items'</code>.</p>
<p>This is not at all what I expected. Obviously I would expect it to set the value like I want... but apparently config is only dict-ish, unfortunately.</p>
<p>How can I patch this so <code>config['db']</code> is the value I want, just for the lifetime of my test?</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that the problem is that I had a slight misunderstanding. Although <code>ConfigParser</code> <em>looks</em> dict-like, it isn't actually. The stack trace holds evidence of this:</p>
<pre><code>    def test_fails():
        expected_value = 'whatever'
&gt;       with mock.patch.dict(config, {'db': expected_value}):

test.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/lib/python3.5/unittest/mock.py:1593: in __enter__
    self._patch_dict()
/usr/lib/python3.5/unittest/mock.py:1619: in _patch_dict
    in_dict[key] = values[key]
/usr/lib/python3.5/configparser.py:969: in __setitem__
    self.read_dict({key: value})
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;configparser.ConfigParser object at 0x7f1be6d20f98&gt;, dictionary = {'db': 'whatever'}
source = '&lt;dict&gt;'
</code></pre>
<p>Note that it's trying to do a <code>read_dict</code> here. That's because it's expecting to have a <a href="https://docs.python.org/3/library/configparser.html#customizing-parser-behaviour" rel="nofollow">section-ish</a> format:</p>
<pre><code>&gt;&gt;&gt; parser = configparser.ConfigParser()
&gt;&gt;&gt; parser.read_dict({'section1': {'key1': 'value1',
...                                'key2': 'value2',
...                                'key3': 'value3'},
...                   'section2': {'keyA': 'valueA',
...                                'keyB': 'valueB',
...                                'keyC': 'valueC'},
...                   'section3': {'foo': 'x',
...                                'bar': 'y',
...                                'baz': 'z'}
... })
</code></pre>
<p><sup><sub>From the docs</sub></sup></p>
<p>Having a single-key access is not possible. To get this example to work, you have to do the following:</p>
<pre><code>with mock.patch.dict(config, {'db': {'db': expected_value}}):
    # rest of code
</code></pre>
<p>Note: Values will be converted to their stringish counterparts. So if you are trying to store an actual database connection (or similar) here, it won't work.</p>
</div>
<span class="comment-copy">What are you actually trying to test, here?</span>
<span class="comment-copy">@jonrsharpe I'm actually doing something else, but this is the most MVCE ;)</span>
<span class="comment-copy">Well then it's not a terribly helpful example! Please give a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> of the code under test, too.</span>
<span class="comment-copy">The code under test is not failing - the <code>mock.patch.dict</code> call is failing.</span>
<span class="comment-copy">You're calling <code>mock.patch.dict</code>, but <code>config</code> is not a dictionary (and it's barely dictionary-like).  If you would stop being cagey about what you're actually trying to test we might be able to provide suggestions about better ways to go about it.  In this situation, it's not clear why you're even using mock (just set the option in the config object!).</span>
