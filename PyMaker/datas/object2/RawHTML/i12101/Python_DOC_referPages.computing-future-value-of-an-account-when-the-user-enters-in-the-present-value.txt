<div class="post-text" itemprop="text">
<p>Whenever I run this it just continues to get the <code>p</code> value, not the computed future value of the account?!</p>
<pre><code>def main():
    p=eval(input("Enter in the present value of the account: "))
    i=eval(input("Enter in the monthly interest rate(%): "))
    I=eval(str(i//100))
    t=eval(input("Enter the number of months that that the money will be in the account: "))

    print(futureValue(p, I, t),"Is the future value of your account!")

def futureValue(p, I, t):
    return p*((1 + I) ** t)

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is because you use <code>//</code> in your <code>i//100</code> rather than <code>/</code>. This will cause the result of <code>i/100</code> be rounding-down and hence always result in <code>0.0</code> as long as <code>i &lt; 100</code> (which will be the case). That is why your future value is always the same as your present, since you put money with <em>no interest</em>.</p>
<p>Simply change:</p>
<pre><code>I=eval(str(i//100))
</code></pre>
<p>into:</p>
<pre><code>I=eval(str(i/100))
</code></pre>
<p>Also, since you never really need to eval <code>I</code> (it is just <code>i/100</code> where you have already <code>eval</code> <code>i</code> from the user input), try to simply put <code>I=i/100</code> like this:</p>
<pre><code>def main():
    p=eval(input("Enter in the present value of the account: "))
    i=eval(input("Enter in the monthly interest rate(%): "))
    I=i/100 #simply put this
    t=eval(input("Enter the number of months that that the money will be in the account: "))

    print(futureValue(p, I, t),"Is the future value of your account!")

def futureValue(p, I, t):
    return p*((1 + I) ** t)

main()
</code></pre>
<p>You should get your future value</p>
</div>
<span class="comment-copy">For the love of all this is holy, <b><i>do not <code>eval</code> raw user input</i></b>. Even if we ignore the whole "definition of a security issue" thing, it means that small typos by the user can do completely unexpected things, in ways you can't begin to predict or handle. If the goal is to convert to <code>int</code> or <code>float</code> or <code>decimal.Decimal</code>, use their constructors. If the goal is to accept <code>int</code> or <code>float</code> or any other Python literal, use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a>, which accepts Python literals, but not arbitrary code.</span>
<span class="comment-copy">The important change here is not removing the <code>eval</code>, but using true division (<code>/</code>) instead of floor division (<code>//</code>); when the input is in the 0-99 range, the latter will always produce 0 when dividing by 100, the former will produce 0.0-0.99 as you'd expect. <code>eval</code> is <i>evil</i>, but it's not the culprit here.</span>
<span class="comment-copy">Yes, I was typing an update when you just post your comment. :)</span>
<span class="comment-copy">Excellent. Upvoted.</span>
