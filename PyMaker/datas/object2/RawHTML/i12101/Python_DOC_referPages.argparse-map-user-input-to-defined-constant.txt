<div class="post-text" itemprop="text">
<p>I'd like to build a <code>parser.add_argument(...)</code> to map given argument with constant defined in my code.</p>
<p>Suppose I have the following</p>
<pre><code>import argparse

# Both are the same type
CONST_A = &lt;something&gt;
CONST_B = &lt;otherthing&gt;

parser = argparse.ArgumentParser()
parser.add_argument(...)

# I'd like the following to be true:
parser.parse_args("--foo A".split()).foo == CONST_A
parser.parse_args("--foo B".split()).foo == CONST_B
</code></pre>
<p>What can I put in lieu of <code>...</code>?</p>
<hr/>
<p>The best I could do with <code>const</code> was:</p>
<pre><code>import argparse

# Both are the same type
CONST_A = 10
CONST_B = 20

parser = argparse.ArgumentParser()
status_group = parser.add_mutually_exclusive_group(required=True)
status_group.add_argument("-a", const=CONST_A, action='store_const')
status_group.add_argument("-b", const=CONST_B, action='store_const')

# I'd like the following to be true:
print parser.parse_args("-a".split()).a == CONST_A # True
print parser.parse_args("-b".split()).b == CONST_B # True
</code></pre>
<p>Note that the constants are saved into tw odifferent attributes <code>a</code> and <code>b</code>, witch suits me not :(</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way is to take advantage of the <code>type=</code> option in <code>add_argument</code> like <a href="https://stackoverflow.com/questions/35648071/argparse-map-user-input-to-defined-constant/35658444#35658444">@hpaulj</a> did although it can be generalized with a factory function:</p>
<pre><code>def argconv(**convs):
    def parse_argument(arg):
        if arg in convs:
            return convs[arg]
        else:
            msg = "invalid choice: {!r} (choose from {})"
            choices = ", ".join(sorted(repr(choice) for choice in convs.keys()))
            raise argparse.ArgumentTypeError(msg.format(arg,choices))
    return parse_argument
</code></pre>
<p>then in lieu of <code>...</code> just use <code>type=argconv(A=CONST_A, B=CONST_B)</code>:</p>
<pre><code>parser.add_argument("--foo", type=argconv(A=CONST_A, B=CONST_B))
</code></pre>
<p>And then everything will work as you want it to in your example.</p>
<hr/>
<p>The following is the first answer I posted, it is still valid but isn't nearly as simple as the above solution.</p>
<p>An alternate method is to make a class that inherits from <code>argparse.ArgumentParser</code> and override <code>parse_args</code> to modify the result as it is generated:</p>
<pre><code>import argparse

class MappedParser(argparse.ArgumentParser):
    mapping = {} #backup if you don't use def_mapping

    def def_mapping(self,**options):
        self.mapping = options

    def parse_args(self,args=None,namespace=None):
        result = argparse.ArgumentParser.parse_args(self,args,namespace)
        for name,options in self.mapping.items(): #by default this is is empty so the loop is skipped
            if name in result:
                key = getattr(result,name)
                if key in options:
                    replace_with = options[key]
                    setattr(result,name,replace_with)
                else:
                    self.error("option {name!r} got invalid value: {key!r}\n must be one of {valid}".format(name=name,key=key,valid=tuple(options.keys())))
                    return #error should exit program but I'll leave this just to be safe.
        return result
</code></pre>
<p>this way the rest of your (example) program would look like this:</p>
<pre><code># There is nothing restricting their type.
CONST_A = "&lt;something&gt;"
CONST_B = ["other value", "type is irrelevent"]

parser = MappedParser() #constructor is same

parser.def_mapping(foo={"A":CONST_A, "B":CONST_B})

parser.add_argument("--foo") # and this is unchanged

# the following is now true:
print(parser.parse_args("--foo A".split()).foo is CONST_A)
print(parser.parse_args("--foo B".split()).foo is CONST_B)
#note that 'is' operator works so it is even the same reference

#this gives decent error message
parser.parse_args("--foo INVALID".split())

print("when parser.error() is called the program ends so this never is printed")
</code></pre>
<p>Add extra options like this:</p>
<pre><code>parser.def_mapping(foo={"A":CONST_A, "B":CONST_B,"C":"third option"})
</code></pre>
<p>or extra arguments like this:</p>
<pre><code>parser.def_mapping(foo={"A":CONST_A, "B":CONST_B},
                   conv={"int":int,"float":float})
</code></pre>
<p>as well any added arguments that are not specified in <code>def_mapping</code> are left alone so it is very easy to implement.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an interesting question. To the best of my knowledge, <code>argparse</code> does not support this directly.</p>
<p>If you find this pattern occurs often, you can write a small utility class that does this for you, by <a href="https://stackoverflow.com/questions/16878315/what-is-the-right-way-to-treat-python-argparse-namespace-as-a-dictionary">transforming <code>args</code> into a dictionary via <code>vars</code></a>:</p>
<pre><code>class Switcher(object):
    def __init__(self, d):
        self._d = d

    def __call__(self, args):
        args_ = vars(args)

        for k, v in self._d.items():
            if args_[k]:
                return v
</code></pre>
<p>You can use it as follows. Say your parser is defined by:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
g = parser.add_mutually_exclusive_group()
g.add_argument('-a', action='store_true', default=False)
g.add_argument('-b', action='store_true', default=False)
</code></pre>
<p>Then you can define a <code>Switcher</code> via:</p>
<pre><code>s = Switcher({'a': 10, 'b': 20})
</code></pre>
<p>and use it like so:</p>
<pre><code>&gt;&gt;&gt; print s(parser.parse_args(['-a']))
10 

&gt;&gt;&gt; print s(parser.parse_args(['-b']))
20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This would be a good case for a custom <code>type</code> parameter:</p>
<pre><code>CONST_A='&lt;A&gt;'
CONST_B='&lt;B&gt;'
def footype(astring):
    dd = {'A':CONST_A, 'B':CONST_B}
    try:
        return dd[astring]
    except KeyError:
        raise argparse.ArgumentTypeError('enter A or B')

parser = argparse.ArgumentParser()
parser.add_argument('--foo', type=footype)
</code></pre>
<p>It will produce a namespace like</p>
<pre><code>Namespace(foo='&lt;A&gt;')
</code></pre>
<p>and error message (if given <code>--foo C</code>) like:</p>
<pre><code>usage: stack35648071.py [-h] [--foo FOO]
stack35648071.py: error: argument --foo: enter A or B
</code></pre>
<p>I tried adding <code>choices</code> but the help message isn't right.  Use <code>metavar</code> and <code>help</code> to instruct your users.</p>
</div>
<div class="post-text" itemprop="text">
<p>I wouldn't create a new action or object: just use a <code>dict</code> to store the constants, limit the values of <code>--foo</code> with <code>choices</code> and use <code>parsed_args.foo</code> to index the <code>dict</code>:</p>
<pre><code>import argparse

CONST = {'A': 'something',
         'B': 'otherthing'}

parser = argparse.ArgumentParser()
parser.add_argument('--foo', choices=('A', 'B'))

assert CONST[parser.parse_args("--foo A".split()).foo] == 'something'
assert CONST[parser.parse_args("--foo B".split()).foo] == 'otherthing'
</code></pre>
<p>The combination of <code>choices</code> and the keys to the <code>dict</code> essentially fixes your results of <code>foo</code>.</p>
<p><hr/>
And if you like to make things a bit clearer or easier, you can do reassign <code>foo</code> to your <code>dict</code> value after you parse the arguments:</p>
<pre><code>args = parser.parse_args("--foo A".split())
args.foo = CONST[args.foo]
</code></pre>
<p>and now <code>args.foo</code> equates directly to <code>'something'</code>.</p>
</div>
<span class="comment-copy">have you executed <code>help(argparse)</code> or checked out the documentation? (<a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">docs.python.org/3/library/argparse.html</a>) I am looking into it for the first time now.</span>
<span class="comment-copy">I have, but it's a bit hairy for a beginner. BTW, I'm writing python2 code.</span>
<span class="comment-copy">There are <code>const</code> and <code>default</code> parameters to <code>add_argument</code>. Experiment with those.</span>
<span class="comment-copy">@Evert the best I could do with <code>const</code> and <code>action="store_const"</code> was to map my constants into two different attribute of returned namespace.</span>
<span class="comment-copy">This is gold! I hope you'll get the rep you deserve for it.</span>
<span class="comment-copy"><code>MappedParser</code> was ok, <b><code>argconv</code> is gold.</b></span>
<span class="comment-copy">This is a good alternative. If no one challenge you and points out a feature of <code>argparse</code> that <i>does</i> support it directly, you'll get the green check!</span>
<span class="comment-copy">sorry for stealing your accepted answer flag, I hope the credit for <code>argconv</code> is sufficient compensation :)</span>
<span class="comment-copy">:-) Don't worry about it. Your answer is excellent - I'm upvoting it myself.</span>
<span class="comment-copy">Thank you so much for posting this, I wouldn't have thought of <code>argconv</code> without you!</span>
<span class="comment-copy">This is by far the best tactic although it does work better with a nested function then to hard code in the dictionary.</span>
<span class="comment-copy">That's what I've ended up doing. Thanks.</span>
