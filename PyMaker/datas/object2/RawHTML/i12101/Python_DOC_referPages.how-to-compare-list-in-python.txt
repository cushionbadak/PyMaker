<div class="post-text" itemprop="text">
<p>I have one list </p>
<pre><code>a = [1.0, 2.0, 2.1, 3.0, 3.1, 4.2, 5.1, 7.2, 9.2]
</code></pre>
<p>I want to compare this list with other list but also I want to extract the information regarding the list content in numeric order.All other list have the elements that are same as <code>a</code>.</p>
<p>So I have tried this</p>
<pre><code>a = [1.0, 2.0, 2.1, 3.0, 3.1, 4.2, 5.1, 7.2, 9.2]
b = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print dict(zip(a,b))

a1=[2.1, 3.1, 4.2, 7.2]
</code></pre>
<p>I want to compare a1 with a and extract dict values <code>[3, 5, 6, 8]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just loop through <code>a1</code> and see if there is a matching key in the dictionary you created:</p>
<pre><code>mapping = dict(zip(a, b))
matches = [mapping[value] for value in a1 if value in mapping]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; a = [1.0, 2.0, 2.1, 3.0, 3.1, 4.2, 5.1, 7.2, 9.2]
&gt;&gt;&gt; b = [1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; a1 = [2.1, 3.1, 4.2, 7.2]
&gt;&gt;&gt; mapping = dict(zip(a, b))
&gt;&gt;&gt; [mapping[value] for value in a1 if value in mapping]
[3, 5, 6, 8]
</code></pre>
<p>However, take into account that you are using <em>floating point</em> numbers. You may not be able to match values exactly, since floating point numbers are binary approximations to decimal values; the value <code>2.999999999999999</code> (15 nines) for example, may be presented by the Python <code>str()</code> function as <code>3.0</code>, but is <em>not equal</em> to <code>3.0</code>:</p>
<pre><code>&gt;&gt;&gt; 2.999999999999999
2.999999999999999
&gt;&gt;&gt; str(2.999999999999999)
'3.0'
&gt;&gt;&gt; 2.999999999999999 == 3.0
False
&gt;&gt;&gt; 2.999999999999999 in mapping
False
</code></pre>
<p>If your input lists <code>a</code> is sorted, you could use the <a href="https://docs.python.org/3/library/math.html#math.isclose" rel="nofollow"><code>math.isclose()</code> function</a> (or a backport of it), together with the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow"><code>bisect</code> module</a> to keep matching efficient:</p>
<pre><code>import bisect
try:
    from math import isclose
except ImportError:
    def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
        # simplified backport, doesn't handle NaN or infinity.
        if a == b: return True
        return abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)

result = []
for value in a1:
    index = bisect.bisect(a, value)
    if index and isclose(a[index - 1], value):
        result.append(b[index - 1])
    elif index &lt; len(a) and isclose(a[index], value):
        result.append(b[index])
</code></pre>
<p>This tests up to two values from <code>a</code> per input value; one that is guaranteed to equal or lower (at <code>index - 1</code>) and the next, higher value. For your sample <code>a</code>, the value <code>2.999999999999999</code> is bisected to index <code>3</code>, between <code>2.1</code> and <code>3.0</code>. Since <code>isclose(3.0, 2.999999999999999)</code> is true, that would still let you map that value to <code>4</code> in <code>b</code>.</p>
</div>
<span class="comment-copy">Peters Thanks.The numbers in the list are result of the execution of the FORTRAN code,formated with f11.5.So I think the simple version would suffice!</span>
<span class="comment-copy">Right, if you have <i>strings</i>, then you skirt around the issue quite nicely.</span>
