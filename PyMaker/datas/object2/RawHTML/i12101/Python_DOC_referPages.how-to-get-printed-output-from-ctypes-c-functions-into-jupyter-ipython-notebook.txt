<div class="post-text" itemprop="text">
<h2>Introduction</h2>
<p>Suppose I have this C code:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;

// Of course, these functions are simplified for the purposes of this question.
// The actual functions are more complex and may receive additional arguments.

void printout() {
    puts("Hello");
}
void printhere(FILE* f) {
    fputs("Hello\n", f);
}
</code></pre>
<p>That I'm compiling as a shared object (DLL): <code>gcc -Wall -std=c99 -fPIC -shared example.c -o example.so</code></p>
<p>And then I'm importing it <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow">into Python 3.x</a> running inside <a href="http://jupyter.org/" rel="nofollow">Jupyter</a> or <a href="https://ipython.org/notebook.html" rel="nofollow">IPython notebook</a>:</p>
<pre class="lang-python prettyprint-override"><code>import ctypes
example = ctypes.cdll.LoadLibrary('./example.so')

printout = example.printout
printout.argtypes = ()
printout.restype = None

printhere = example.printhere
printhere.argtypes = (ctypes.c_void_p)  # Should have been FILE* instead
printhere.restype = None
</code></pre>
<h2>Question</h2>
<p>How can I execute both <code>printout()</code> and <code>printhere()</code> C functions (through <code>ctypes</code>) and get the output printed inside the Jupyter/IPython notebook?</p>
<p>If possible, I want to avoid writing more C code. I would prefer a pure-Python solution.</p>
<p>I also would prefer to avoid writing to a temporary file. Writing to a pipe/socket might be reasonable, though.</p>
<h2>The the expected state, the current state</h2>
<p>If I type the following code in one Notebook cell:</p>
<pre class="lang-python prettyprint-override"><code>print("Hi")           # Python-style print
printout()            # C-style print
printhere(something)  # C-style print
print("Bye")          # Python-style print
</code></pre>
<p>I want to get this output:</p>
<pre class="lang-none prettyprint-override"><code>Hi
Hello
Hello
Bye
</code></pre>
<p>But, instead, I only get the Python-style output results inside the notebook. The C-style output gets printed to the terminal that started the notebook process.</p>
<h2>Research</h2>
<p>As far as I know, inside Jupyter/IPython notebook, the <code>sys.stdout</code> is not a wrapper to any file:</p>
<pre class="lang-python prettyprint-override"><code>import sys

sys.stdout

# Output in command-line Python/IPython shell:
&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;
# Output in IPython Notebook:
&lt;IPython.kernel.zmq.iostream.OutStream at 0x7f39c6930438&gt;
# Output in Jupyter:
&lt;ipykernel.iostream.OutStream at 0x7f6dc8f2de80&gt;

sys.stdout.fileno()

# Output in command-line Python/IPython shell:
1
# Output in command-line Jupyter and IPython notebook:
UnsupportedOperation: IOStream has no fileno.
</code></pre>
<p>Related questions and links:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/3794309/python-ctypes-python-file-object-c-file">Python ctypes: Python file object &lt;-&gt; C FILE *</a></li>
<li><a href="https://stackoverflow.com/questions/16130268/python-3-replacement-for-pyfile-asfile">Python 3 replacement for PyFile_AsFile</a></li>
<li><a href="https://stackoverflow.com/questions/17257137/using-python-ctypes-and-libc-to-write-void-pointer-to-binary-file">Using fopen, fwrite and fclose through ctypes</a></li>
<li><a href="https://stackoverflow.com/questions/23350008/python-ctypes-dll-stdout">Python ctypes DLL stdout</a></li>
<li><a href="https://stackoverflow.com/questions/20568107/python-stringio-for-popen">Python: StringIO for Popen</a> - Workaround for the lack of <code>fileno()</code> in <code>StringIO</code>, but only applies to <code>subprocess.Popen</code>.</li>
</ul>
<p>The following two links use similar solutions that involve creating a temporary file. However, care must be taken when implementing such solution to make sure both Python-style output and C-style output gets printed in the correct order.</p>
<ul>
<li><a href="https://stackoverflow.com/questions/5081657/how-do-i-prevent-a-c-shared-library-to-print-on-stdout-in-python">How do I prevent a C shared library to print on stdout in python?</a></li>
<li><a href="http://eli.thegreenplace.net/2015/redirecting-all-kinds-of-stdout-in-python/" rel="nofollow">Redirecting all kinds of stdout in Python</a></li>
</ul>
<h2>Is it possible to avoid a temporary file?</h2>
<p>I tried finding a solution using C <a href="http://man7.org/linux/man-pages/man3/open_memstream.3.html" rel="nofollow"><code>open_memstream()</code></a> and assigning the returned <code>FILE*</code> to <code>stdout</code>, but it did not work <a href="http://c-faq.com/stdio/undofreopen.html" rel="nofollow">because <code>stdout</code> cannot be assigned</a>.</p>
<p>Then I tried getting the <code>fileno()</code> of the stream returned by <code>open_memstream()</code>, but I can't <a href="http://fixunix.com/unix/351987-glibc-open_memstream-gcc-extension-fileno-returns-1-a.html" rel="nofollow">because it has no file descriptor</a>.</p>
<p>Then I looked at <a href="https://stackoverflow.com/questions/584868/rerouting-stdin-and-stdout-from-c"><code>freopen()</code></a>, but its <a href="http://man7.org/linux/man-pages/man3/freopen.3.html" rel="nofollow">API requires passing a filename</a>.</p>
<p>Then I looked at Python's standard library and found <a href="https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile" rel="nofollow"><code>tempfile.SpooledTemporaryFile()</code></a>, which is a temporary file-like object in memory. However, it gets written to the disk as soon as <code>fileno()</code> is called.</p>
<p>So far, I couldn't find any memory-only solution. Most likely, we will need to use a temporary file anyway. (Which is not a big deal, but just some extra overhead and extra cleanup that I'd prefer to avoid.)</p>
<p>It may be possible to use <a href="https://docs.python.org/3/library/os.html?#os.pipe" rel="nofollow"><code>os.pipe()</code></a>, but that seems difficult to do without forking.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've finally developed a solution. It requires wrapping the entire cell inside a context manager (or wrapping only the C code). It also uses a temporary file, since I couldn't find any solution without using one.</p>
<p>The full notebook is available as a GitHub Gist: <a href="https://gist.github.com/denilsonsa/9c8f5c44bf2038fd000f" rel="nofollow">https://gist.github.com/denilsonsa/9c8f5c44bf2038fd000f</a></p>
<hr/>
<h2>Part 1: Preparing the C library in Python</h2>
<pre class="lang-python prettyprint-override"><code>import ctypes

# use_errno parameter is optional, because I'm not checking errno anyway.
libc = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)

class FILE(ctypes.Structure):
    pass

FILE_p = ctypes.POINTER(FILE)

# Alternatively, we can just use:
# FILE_p = ctypes.c_void_p

# These variables, defined inside the C library, are readonly.
cstdin = FILE_p.in_dll(libc, 'stdin')
cstdout = FILE_p.in_dll(libc, 'stdout')
cstderr = FILE_p.in_dll(libc, 'stderr')

# C function to disable buffering.
csetbuf = libc.setbuf
csetbuf.argtypes = (FILE_p, ctypes.c_char_p)
csetbuf.restype = None

# C function to flush the C library buffer.
cfflush = libc.fflush
cfflush.argtypes = (FILE_p,)
cfflush.restype = ctypes.c_int
</code></pre>
<h2>Part 2: Building our own context manager to capture stdout</h2>
<pre class="lang-python prettyprint-override"><code>import io
import os
import sys
import tempfile
from contextlib import contextmanager

@contextmanager
def capture_c_stdout(encoding='utf8'):
    # Flushing, it's a good practice.
    sys.stdout.flush()
    cfflush(cstdout)

    # We need to use a actual file because we need the file descriptor number.
    with tempfile.TemporaryFile(buffering=0) as temp:
        # Saving a copy of the original stdout.
        prev_sys_stdout = sys.stdout
        prev_stdout_fd = os.dup(1)
        os.close(1)

        # Duplicating the temporary file fd into the stdout fd.
        # In other words, replacing the stdout.
        os.dup2(temp.fileno(), 1)

        # Replacing sys.stdout for Python code.
        #
        # IPython Notebook version of sys.stdout is actually an
        # in-memory OutStream, so it does not have a file descriptor.
        # We need to replace sys.stdout so that interleaved Python
        # and C output gets captured in the correct order.
        #
        # We enable line_buffering to force a flush after each line.
        # And write_through to force all data to be passed through the
        # wrapper directly into the binary temporary file.
        temp_wrapper = io.TextIOWrapper(
            temp, encoding=encoding, line_buffering=True, write_through=True)
        sys.stdout = temp_wrapper

        # Disabling buffering of C stdout.
        csetbuf(cstdout, None)

        yield

        # Must flush to clear the C library buffer.
        cfflush(cstdout)

        # Restoring stdout.
        os.dup2(prev_stdout_fd, 1)
        os.close(prev_stdout_fd)
        sys.stdout = prev_sys_stdout

        # Printing the captured output.
        temp_wrapper.seek(0)
        print(temp_wrapper.read(), end='')
</code></pre>
<hr/>
<h2>Part Fun: Using it!</h2>
<pre class="lang-python prettyprint-override"><code>libfoo = ctypes.CDLL('./foo.so')

printout = libfoo.printout
printout.argtypes = ()
printout.restype = None

printhere = libfoo.printhere
printhere.argtypes = (FILE_p,)
printhere.restype = None


print('Python Before capturing')
printout()  # Not captured, goes to the terminal

with capture_c_stdout():
    print('Python First')
    printout()
    print('Python Second')
    printhere(cstdout)
    print('Python Third')

print('Python After capturing')
printout()  # Not captured, goes to the terminal
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Python Before capturing
Python First
C printout puts
Python Second
C printhere fputs
Python Third
Python After capturing
</code></pre>
<h2>Credits and further work</h2>
<p>This solution is fruit of reading all the links I linked at the question, plus a lot of trial and error.</p>
<p>This solution only redirects <code>stdout</code>, it could be interesting to redirect both <code>stdout</code> and <code>stderr</code>. For now, I'm leaving this as an exercise to the reader. ;)</p>
<p>Also, there is no exception handling in this solution (at least not yet).</p>
</div>
<span class="comment-copy">You can do something similar to the temporary file approach but making the stdout fd the write end of a pipe instead. Then a separate Python thread can pull data of the read end of the pipe, and send it to the redirected sys.stdout. For most practical cases, this will get the ordering close enough to be useful. If you need it to be more precise, you should set <code>sys.stdout</code> and <code>sys.stderr</code> back to the originals so that Python output goes through the pipe as well.</span>
<span class="comment-copy">For reading <code>stdout</code>, the suggestion from @ThomasK should work. <code>os.dup2</code> the write end of the pipe to file 1. For <code>printhere</code>, you can call <code>libc.fdopen(1, b'wb')</code> to get a new <code>FILE</code> for fd 1. Set <code>restype</code> to an opaque <code>FILE</code> pointer, e.g. <code>class FILE(ctypes.Structure): pass;</code> <code>PFILE = ctypes.POINTER(FILE);</code> <code>libc.fdopen.restype = PFILE</code>. For the C lib, use <code>libc = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)</code>. If the call fails (i.e. the result is boolean <code>False</code>), use <code>err = ctypes.get_errno();</code> <code>raise OSError(err, os.strerror(err))</code> to raise a formatted exception.</span>
<span class="comment-copy">For jupyter/ipython, I guess a solution is to let <code>sys.stdout, sys.stderr = sys.__stdout__, sys.__stderr__</code> first, then it becomes the normal case. Finally set them back to stored <code>ipykernel.iostream.OutStream</code>s.</span>
<span class="comment-copy">You can also look 'python.boost' to combine C++ with python.</span>
<span class="comment-copy"><code>cstdin = FILE_p.in_dll(libc, 'stdin')</code>: this is non-portable, so I hope you're only planning to support your development (and similar) platforms. You can't use this on Windows.</span>
<span class="comment-copy">You should be able to use the write end of a pipe from <code>os.pipe</code> instead of a temp file. But a pipe needs a worker thread to read it into the capture buffer, else it blocks when full.</span>
<span class="comment-copy">@eryksun: Indeed, this code works on Linux and maybe other POSIX systems. Please, feel free to suggest alternatives to make it more portable. To be honest, I don't even know what makes it not working on Windows. Also, if you can find a way to use <code>os.pipe</code> and a worker thread, please, submit another answer! I tried using <code>os.pipe</code> and <code>os.fork</code>, but the results were disastrous (but I may have done something wrong; and I don't have that non-working code anymore).</span>
<span class="comment-copy">It's not just a matter of Windows. The C standard doesn't specify that <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> are symbols that can be accessed via <code>dlsym</code>, <code>GetProcAddress</code>, and so on. So each platform's C runtime is free to implement this as it sees fit. For Windows, prior to the Universal CRT (used by 3.5+) you had to know the layout of a <code>FILE</code>, or at least its size. With the new universal CRT it's done via an <code>__acrt_iob_func</code> function that takes the file number 0, 1, or 2 and returns the <code>FILE</code> pointer.</span>
