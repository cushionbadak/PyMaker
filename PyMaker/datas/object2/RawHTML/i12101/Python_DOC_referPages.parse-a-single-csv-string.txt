<div class="post-text" itemprop="text">
<p>Is there a way that I can parse a single comma delimited string without using anything fancy like a csv.reader(..) ? I can use the <code>split(',')</code> function but that doesn't work when a valid column value contains a comma itself. The csv library has readers for parsing CSV files which correctly handle the aforementioned special case, but I can't use those because I need to parse just a single string. However if the Python CSV allows parsing a single string itself then that's news to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Take a closer look at the documentation for the <code>csv</code> module, which
says:</p>
<pre><code>reader(...)
    csv_reader = reader(iterable [, dialect='excel']
                            [optional keyword args])
        for row in csv_reader:
            process(row)

    The "iterable" argument can be any object that returns a line
    of input for each iteration, such as a file object or a list.  The
    optional "dialect" parameter is discussed below.  The function
    also accepts optional keyword arguments which override settings
    provided by the dialect.
</code></pre>
<p>So if you have string:</p>
<pre><code>&gt;&gt;&gt; s = '"this is", "a test", "of the csv", "parser"'
</code></pre>
<p>And you want "an object that returns a line of input for each
iteration", you can just wrap your string in a list:</p>
<pre><code>&gt;&gt;&gt; r = csv.reader([s])
&gt;&gt;&gt; list(r)
[['this is', 'a test', 'of the csv parser']]
</code></pre>
<p>And that's how you parse a string with the <code>csv</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can still parse a single string with <code>csv</code>. Use StringIO to write a string <a href="https://docs.python.org/2/library/stringio.html#module-StringIO" rel="noreferrer">buffer</a> (also known as <em>memory files</em>):</p>
<pre><code>import csv
from StringIO import StringIO

s = "your string"
buff = StringIO(s)

reader = csv.reader(buff)
for line in reader:
    print(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import csv
&gt;&gt;&gt; s = '"Yes, this line",can be, parsed as csv'
&gt;&gt;&gt; list(csv.reader([s]))[0]
['Yes, this line', 'can be', ' parsed as csv']
&gt;&gt;&gt;
</code></pre>
<p>Basically just @larsks answer above but more brief and demonstrating that it works on csv values that have commas inside quotes.</p>
<p>If you upvote me, upvote the other answer too. <a href="https://stackoverflow.com/a/35822856/1196339">https://stackoverflow.com/a/35822856/1196339</a></p>
</div>
<span class="comment-copy">I guess it would be more elegant to use <code>iter(s)</code> as to a general iterator instead of <code>[s]</code> (specifying a list). But you have my +1</span>
<span class="comment-copy">This probably won't work if the string has quoted linefeeds inside of the values; @alecxe's answer makes more sense</span>
<span class="comment-copy"><code>list(csv.reader(['"this is", "a test", "of the csv", "parser"']))[0]</code> Boom!</span>
<span class="comment-copy">For Python 3 use <code>from io import StringIO</code> see <a href="https://docs.python.org/3/library/io.html#text-i-o" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">But be careful with non-ASCII strings! <i>'If [Unicode and 8-bit strings] are used, 8-bit strings that cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause a UnicodeError to be raised when getvalue() is called.'</i></span>
