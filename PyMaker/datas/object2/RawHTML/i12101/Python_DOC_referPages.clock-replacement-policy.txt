<div class="post-text" itemprop="text">
<p>My clock cache is not working. What I'm doing:</p>
<p>if key in self.items_to_index: set bit to 1, return the value from self.buffers.</p>
<p>if not:</p>
<p>call function on input to get newval.</p>
<p>call self._increment() until we see an entry in self.buffers with bit set to 0.</p>
<p>self.buffers[self._p] is now equal to [newval, 1]</p>
<p>Remove the dictionary entry with _p equal to that entry. </p>
<p>Then do self.items_to_index[k] = _p.</p>
<p>increment p.</p>
<p>My code for what's described above is: [not working] </p>
<pre><code>def __getitem__(self, k):
    """
    Returns func(k) using the buffer to cache limited results.

    :param k: Value to be evaluated

    &gt;&gt;&gt; clock = ClockMap(4, lambda x: x ** 2)
    &gt;&gt;&gt; clock[4]
    16
    &gt;&gt;&gt; clock[3]
    9
    &gt;&gt;&gt; clock._p
    2
    """
    #when clock[index] is queried, this _getitem__ function is called
    if k in self.items_to_index:
        #hit
        index = self.items_to_index[k]
        entry = self.buffers[index]
        entry[1] = 1
        return entry[0]
    else:
        val = self.fn(k)
        while self.buffers[self._p][1] == 1:
            self.buffers[self._p][1] = 0
            self._increment()
        self.buffers[self._p] = [val, 1]

        for inputx, bufflocation in self.items_to_index.iteritems():
            if bufflocation == self._p:
                self.items_to_index.pop(inputx)
                self.items_to_index[k] = bufflocation
                break

        self._increment()
        return val
</code></pre>
<p>The entire class is attached her for reference:</p>
<pre><code>class ClockMap:

def __init__(self, cacheSize, func):
    """
    Do not change existing variables.
    [Optional] You are free to add additional items and methods.
    """
    self.cacheSize = cacheSize #number of buffers
    self.fn = func #function whose results that you will be caching
    self._p = 0 # pointer
    self._increments = 0
    self._miss_count = 0
    self.buffers = [[None, 0] for x in range(cacheSize)] #actual output vals of the func passed in
    #hit: retrieve the value from the cache. Miss: reevaluate func with input, write to cache
    self.items_to_index = {} # dict,  input to buffer location, self.items_to_index[x] = buffer_index

def _increment(self):
    """
    Do not change this method.
    Updates the clock pointer. The modulo maintains the clock nature.
    """
    self._increments += 1
    self._p = (self._p + 1) % self.cacheSize
</code></pre>
<p>How I'm testing this and my test results:</p>
<pre><code>def test3ClockMap(ClockMap):
check_dir()
clock = ClockMap(4, lambda x: x ** 2)
requests = [1, 2, 3, 4, 1, 6, 1, 4, 7, 4, 7, 5, 4, 6]
with open(your_output + "task3ClockMap.txt", "wb") as f:
    writer = csv.writer(f)
    writer.writerow(["Request", "Result", "Pointer", "Increments"])
    for r in requests:
        writer.writerow([r, clock[r], clock._p, clock._increments])
diff_against_reference("task3ClockMap.txt", 3)
</code></pre>
<p>Diff file:</p>
<pre><code>6,15c6,15
&lt; 1,1,1,9
&lt; 6,36,2,10
&lt; 1,1,3,11
&lt; 4,16,0,12
&lt; 7,49,1,17
&lt; 4,16,2,18
&lt; 7,49,3,19
&lt; 5,25,0,20
&lt; 4,16,1,25
&lt; 6,36,2,26
---
&gt; 1,1,0,4
&gt; 6,36,1,9
&gt; 1,1,2,10
&gt; 4,16,2,10
&gt; 7,49,3,11
&gt; 4,16,3,11
&gt; 7,49,3,11
&gt; 5,25,0,16
&gt; 4,16,1,17
&gt; 6,36,2,18
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Values are never added to the <code>self.items_to_index</code> dictionary, so values are never returned from cache. You can fix that by changing <code>ClockMap.__getitem__()</code> to handle the case that the current pointer is not in the index:</p>
<pre><code>        for inputx, bufflocation in self.items_to_index.iteritems():
            if bufflocation == self._p:
                self.items_to_index.pop(inputx)
                self.items_to_index[k] = bufflocation
                break
        else:
            self.items_to_index[k] = self._p
</code></pre>
<p>Note the <code>else</code> block added to the <code>for</code> loop. This handles the case that the current pointer is not already in the index and adds it if so.</p>
<hr/>
<p>Your cache resembles a LRU cache. If you are using Python 3 you might want to check out the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow"><code>functools.lru_cache</code></a> decorator, e.g.</p>
<pre><code>from functools import lru_cache

@lru_cache()
def f(x):
    return x**3

&gt;&gt;&gt; f.cache_info()
CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)
&gt;&gt;&gt; f(2)
8
&gt;&gt;&gt; f.cache_info()
CacheInfo(hits=0, misses=1, maxsize=128, currsize=1)
&gt;&gt;&gt; f(2)
8
&gt;&gt;&gt; f.cache_info()
CacheInfo(hits=1, misses=1, maxsize=128, currsize=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe its because of the line</p>
<pre><code>for inputx, bufflocation in self.items_to_index.iteritems():
</code></pre>
<p>self.items_to_index is initialized to be empty and isn't updated outside of the above loop, so any code inside the loop would never run.</p>
</div>
<span class="comment-copy">This fixed my problem! Thanks. Can you explain how for....else works? I've never seen else used without if.</span>
<span class="comment-copy">I see  : else suite is executed after the for, but only if the for terminates normally (not by a break)</span>
<span class="comment-copy">@Jobs: That's right. basically the <code>else</code> clause is triggered if the loop terminates "naturally", i.e. it does not break. This is true if <code>items_to_index</code> is empty, or if the buffer pointer has not been used. See <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a>.</span>
<span class="comment-copy">if not self.items_to_index:                 self.items_to_index[k] = self._p             else:                 for inputx, bufflocation in self.items_to_index.iteritems():</span>
<span class="comment-copy">I added the above and it still doesn't work.</span>
<span class="comment-copy">Thanks. That was indeed the problem.</span>
