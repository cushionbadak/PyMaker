<div class="post-text" itemprop="text">
<p>From the uwsgi documentation:</p>
<pre><code>def application(env, start_response):
    start_response('200 OK', [('Content-Type','text/html')])
    return [b"Hello World"]
</code></pre>
<p>Is it possible to respond to http request(close http connection) and continue execution flow(without any usage of threads/queues/external services etc)?
like this:</p>
<pre><code>def application(env, start_response):
    start_response('200 OK', [('Content-Type','text/html')])
    end_response(b"Hello World")
    #HTTP connection is closed
    #continue execution..
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, there is no way to continue the code execution after you have returned the response. It would be much easier if you use multithreading but if not you can workaround it in Flask by adding an AJAX call to your HTML response which will send a POST request to one of the server extra route whose handler function will be the execution code you want after returning the response. Here's one of the possible approach using Flask:</p>
<p><strong>myflaskapp.py</strong></p>
<pre><code>from flask import Flask, render_template_string
import time

app = Flask(__name__)

@app.route('/run', methods=['POST'])
def run():
    # this is where you put your "continue execution..." code
    # below code is used to test if it runs after HTTP connection close
    time.sleep(8)
    print('Do something')
    return ''

@app.route('/')
def index():
    return render_template_string('''
            Hello World!
            &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
            &lt;script&gt;
            $(function() {
                $.ajax({
                    type: "POST",
                    url: "{{ url_for('run') }}"
                });
            })
            &lt;/script&gt;
            ''')

if __name__ == "__main__":
    app.run(host='0.0.0.0')
</code></pre>
<p>You can run the server on port 9091 with the command:</p>
<pre><code>uwsgi --http 127.0.0.1:9091 --wsgi-file myflaskapp.py --callable app
</code></pre>
<p>To test if it is working or not, you can go to the address <code>localhost:9091</code>. If everything works well, you should see that the page is loaded immediately while the terminal will only print out <code>Do something</code> after <code>8 seconds have passed</code>, indicating the function <code>run</code> executes after the HTTP connection is closed.</p>
</div>
<span class="comment-copy">You can use uWSGI in async mode and run code after yielding, but it will most probably require a complete rewrite of the app in an asychronous manner. What do you want to achieve anyway? Looks like an XY problem to me atm.</span>
<span class="comment-copy">now its simple application, with not lots of requests, so I don`t want to over complicate the solution. php-fpm for example provides this method <a href="http://php.net/manual/en/function.fastcgi-finish-request.php" rel="nofollow noreferrer">php.net/manual/en/function.fastcgi-finish-request.php</a>. I am asking if there is something similar in uwsgi</span>
