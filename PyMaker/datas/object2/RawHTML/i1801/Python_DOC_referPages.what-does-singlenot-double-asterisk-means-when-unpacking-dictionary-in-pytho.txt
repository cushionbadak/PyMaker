<div class="post-text" itemprop="text">
<p>Can anyone explain the difference when unpacking the dictionary using single or double asterisk? You can mention their difference when used in function parameters, only if it is relevant here, which I don't think so.</p>
<p>However, there may be some relevance, because they share the same asterisk syntax.</p>
<pre><code>def foo(a,b)
    return a+b

tmp = {1:2,3:4}
foo(*tmp)        #you get 4
foo(**tmp)       #typeError: keyword should be string. Why it bothers to check the type of keyword? 
</code></pre>
<p>Besides, why the key of dictionary is not allowed to be non-string when passed as function arguments in THIS situation? Are there any exceptions? Why they design Python in this way, is it because the compiler can't deduce the types in here or something?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>When dictionaries are iterated as lists the iteration takes the keys of it, for example</p>
<pre><code>for key in tmp:
    print(key)
</code></pre>
<p>is the same as</p>
<pre><code>for key in tmp.keys():
    print(key)
</code></pre>
<p>in this case, unpacking as <code>*tmp</code> is equivalent to <code>*tmp.keys()</code>, ignoring the values. If you want to use the values you can use <code>*tmp.values()</code>.</p>
<p>Double asterisk is used for when you define a function with keyword parameters such as</p>
<pre><code>def foo(a, b):
</code></pre>
<p>or</p>
<pre><code>def foo(**kwargs):
</code></pre>
<p>here you can store the parameters in a dictionary and pass it as <code>**tmp</code>. In the first case keys must be strings with the names of the parameter defined in the function firm. And in the second case you can work with <code>kwargs</code> as a dictionary inside the function.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def foo(a,b)
   return a+b

tmp = {1:2,3:4}
foo(*tmp)        #you get 4
foo(**tmp) 
</code></pre>
<p>In this case:<br/>
<code>foo(*tmp)</code> mean <code>foo(1, 3)</code><br/>
<code>foo(**tmp)</code> mean <code>foo(1=2, 3=4)</code>, which will raise an error since <code>1</code> can't be an argument. Arg must be strings and (thanks @ Alexander Reynolds  for pointing this out) must start with underscore or alphabetical character. An argument must be a valid Python identifier. This mean you can't even do something like this:  </p>
<pre><code>def foo(1=2, 3=4):
   &lt;your code&gt;
</code></pre>
<p>or</p>
<pre><code>def foo('1'=2, '3'=4):
   &lt;your code&gt;
</code></pre>
<p>See <a href="https://www.tutorialspoint.com/python/python_basic_syntax.htm" rel="nofollow noreferrer">python_basic_syntax</a> for more details. </p>
</div>
<div class="post-text" itemprop="text">
<p>It is a <strong>Extended Iterable Unpacking</strong>.</p>
<pre><code>&gt;&gt;&gt; def add(a=0, b=0):
...     return a + b
...
&gt;&gt;&gt; d = {'a': 2, 'b': 3}
&gt;&gt;&gt; add(**d)#corresponding to add(a=2,b=3)
5
</code></pre>
<p>For single *,</p>
<pre><code>def add(a=0, b=0):
    ...     return a + b
    ...
    &gt;&gt;&gt; d = {'a': 2, 'b': 3}
    &gt;&gt;&gt; add(*d)#corresponding to add(a='a',b='b')
    ab
</code></pre>
<p>Learn more <a href="https://python-reference.readthedocs.io/en/latest/docs/operators/dict_unpack.html" rel="nofollow noreferrer">here</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think the ** double asterisk in function parameter and unpacking dictionary means intuitively in this way:</p>
<pre><code>#suppose you have this function
def foo(a,**b):
    print(a)
    for x in b:
        print(x,"...",b[x])
#suppose you call this function in the following form
foo(whatever,m=1,n=2)   
#the m=1 syntax actually means assign parameter by name, like foo(a = whatever, m = 1, n = 2)
#so you can also do foo(whatever,**{"m":1,"n":2})
#the reason for this syntax is you actually do
**b is m=1,n=2 #something like pattern matching mechanism
so b is {"m":1,"n":2}, note "m" and "n" are now in string form
#the function is actually this:
def foo(a,**b):  # b = {"m":1,"n":2}
    print(a)
    for x in b:  #for x in b.keys(), thanks to @vlizana answer
        print(x,"...",b[x])
</code></pre>
<p>All the syntax make sense now. And it is the same for single asterisk. It is only worth noting that if you use single asterisk to unpack dictionary, you are actually trying to unpack it in a list way, and only key of dictionary are unpacked.</p>
</div>
<span class="comment-copy">Single * unpacking grabs the keys, so it's adding 1 and 3. With double ** it's trying to call <code>foo(1=2, 3=4)</code> which doesn't make any sense. Keyword arguments must be a valid <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="nofollow noreferrer">identifier</a>.</span>
<span class="comment-copy">Responding to "Why it bothers to check the type of keyword?", named arguments to functions can only be strings, so trying to use non-string names guarantees the names can't match. CPython takes advantage of this by using special purpose lookup functions for <code>dict</code>s guaranteed to be composed exclusively of strings (which a lot of implementation internals happen to be), so the rejecting non-strings ensures strings can go through the fastest code paths (speeding up all Python code).</span>
<span class="comment-copy">It would probably be helpful to link to the docs on <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">expressions</a> where both of these are formally explained.   ("If the syntax *expression appears in the function call, expression must evaluate to an iterable.")</span>
<span class="comment-copy">Not a bad response but I want to poke to improve your answer (esp. since this topic is actually annoyingly complex). You can require keyword arguments without setting defaults, called <a href="https://www.python.org/dev/peps/pep-3102/" rel="nofollow noreferrer">keyword-only args</a>. Also collecting keyword arguments with <code>**kwargs</code> is a little bit different than they would be with kw-only args or kwargs with default values---in particular, you can send in strings that are not valid python identifiers.</span>
<span class="comment-copy">"Double asterisk is used for when you define a function with keyword parameters (with a default value)" is somewhat not precise. If I do <code>def add(a,b): return a+b</code> and <code>tmp = {'a':1,'b':2}</code> and call 'add(**tmp)', I can still get the value of three. So the function parameters does not need default values?</span>
<span class="comment-copy">You can improve your answer by linking to documentation; as it stands right now it is not quite correct (e.g., '2' is a string but is not a valid python identifier).</span>
<span class="comment-copy">Thanks for your comment, I've just made an edit</span>
<span class="comment-copy">Extended iterable unpacking is different from *args, **kwargs unpacking.</span>
