<div class="post-text" itemprop="text">
<p>I have a question about change dictionary format. </p>
<p>The dictionary is :</p>
<pre><code>{'index': 'cfs_nucleus_bespoke_88260', 'host': 'iaasn00018224.svr.us.jpmchase.net', 'source': '/logs/tomcat7inst0/localhost_tomcat7inst0_access_log2018-11-02.txt', '_time': '2018-11-02 19:46:50.000 EDT', 'count': '1'}
</code></pre>
<p>I want to ask is there a way for me to change the format like below:</p>
<pre><code>{"column1":{'index': 'cfs_nucleus_', 'host': 'iaasn00018224.net'}, "column2":{'source': '/logs/tomcat7inst0/localhost_tomcat7inst0_access_log2018-11-02.txt'}, "column3":{'_time': '2018-11-02, 'count': '1'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do the following:</p>
<pre><code>dict1 = {'index': 'cfs_nucleus_bespoke_88260', 'host': 'iaasn00018224.svr.us.jpmchase.net', 'source': '/logs/tomcat7inst0/localhost_tomcat7inst0_access_log2018-11-02.txt', '_time': '2018-11-02 19:46:50.000 EDT', 'count': '1'}
d1_items = list(dict1.items())
col_width = 2
dict2 = {f'column{col_num // col_width + 1}': {k: v for k, v in d1_items[col_num:col_num + col_width]} for col_num in range(0, len(dict1), col_width)}
</code></pre>
<p><a href="https://tio.run/##TZBRT8MgFIXf@yt465p1FFDnbOKb/gPfjCFI2Yqj0PTCnFn62yt0LvWN3POdw7m3//Gts3fT1GjpKXpGl1zbRp3zGuVyD9wGaVQA/qmgd0fFdzu2JXmJ8taBT5AWAiwhhO4Yu8dwGnAA/NV3shWgsFU@weDCIFXCK@MOUHnXSeEftQVP4kQKk@L4/zEXUioAHnkWwzeUbgjD/jznca@7OW6REH2q77f1A8GxDHp9eUucdMHOLWk@Zg3l2qsO4pJGg1/NG@N5tCqKTDrDv3Xj26izLIksnWMfQ0zo7CXpNnSoqtCCrhEdY/7lWKMT2rsBHcv40BbdPnv/s9U3@3pxf4yz5aZE1yDsQa1IiYyy135FufDFmPWDttfmrJimXw" rel="nofollow noreferrer" title="Python 3 â€“ Try It Online">Try it online!</a></p>
<p>There are a few moving parts that interact to create this solution:</p>
<h2><a href="https://www.python.org/dev/peps/pep-0274/" rel="nofollow noreferrer">Dict comprehensions</a></h2>
<p>Python has a neat trick where it allows you to embed <code>for in</code> loops in iterable and dict declarations to efficiently cycle and modify a set of elements. Here, the outer iterator is <code>range(0, len(dict1), col_width)</code>: this goes through a sequence of integers starting from 0, and progressively increases by <code>col_width</code> until it is greater than or equal to the size of the list, which functions to choose the start index of each <code>col_width</code>-sized dict segment. </p>
<h2>Tuple unpacking</h2>
<p><code>dict1.items()</code> is convenient because it returns a <a href="https://docs.python.org/3/library/stdtypes.html?highlight=dict#dictionary-view-objects" rel="nofollow noreferrer">dict view</a> of 2-tuples of each dictionary key and its value. Later, we utilize tuple unpacking <code>k: v for k, v in d1_items[ ... ]</code>, where a tuple of variables is flattened into two variables that can then easily form a key-value pair of the currrent dictionary comprehension. (This is only in newer versions of Python.)</p>
<h2><a href="https://stackoverflow.com/a/509295/8117067">List slicing</a></h2>
<p><code>d1_items[col_num:col_num + col_width]</code> is basically a way of getting a sublist. The syntax in relatively straightforward: starting from position <code>col_num</code>, get a sublist up to and excluding the element <code>col_num + col_width</code> (i.e. a sublist of size <code>col_width</code>).</p>
<h2><a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings" rel="nofollow noreferrer">Formatted string literals</a></h2>
<p>Preceding a string with <code>f</code> makes it a formatted string literal. Anything within <code>{</code> <code>}</code> is interpreted as literal Python syntax (with the exception of <code>'</code>, <code>{</code>, and <code>}</code>, which may vary behavior by context.) Here, in <code>f'column{col_num // col_width + 1}'</code>, it allows us to label each column with a bit of division and a +1 offset to start counting from 1 instead of 0. (This is new to Python 3.6)</p>
</div>
<span class="comment-copy">There probably is a way. What have you tried so far?</span>
