<div class="post-text" itemprop="text">
<p>I have class <strong>Animal</strong> and two <strong>Child</strong> classes <strong>Fish</strong> and <strong>Bear</strong></p>
<pre><code>class Fish(Animal):

    def __init__(self, x, y, parent_engine):
        self.parent = parent_engine
        self.x = x
        self.y = y
        self.type = 2
        self.image = 'üêü'
        self.life = 1


class Bear(Animal):

    def __init__(self, x, y, parent_engine):
        self.parent = parent_engine
        self.x = x
        self.y = y
        self.type = 3
        self.image = 'üêª'
        self.life = 1
</code></pre>
<p>In code i have array of <strong>Animal type</strong> objects named <strong>Field</strong></p>
<pre><code>class Engine:

    def __init__(self, size):
        self.field = []
        self.field_size = size
</code></pre>
<p>I have function <strong>create_actor_child</strong> with input <strong>actor (Animal object)</strong>. This function should creates new <strong>Animal</strong> with <strong>same child class</strong>. I am using if - watching is Parent Bear - spawn Bear, else spawn Fish. But if i will have 10 child it will be hard. I think there should be solution to create new copy of parent class. </p>
<pre><code>def create_actors_child(self, actors):  # returns parents back

    sample = actors[0]

    x = sample.x
    y = sample.y

    for actor in actors:
        actor.go_back_event()

    if sample.type == 2:
        self.field.append(bp.Fish(x, y, self))
    else:
        self.field.append(bp.Bear(x, y, self))
</code></pre>
<p>I need something like <code>self.field.append(parent_class(actor))</code>.</p>
<p><strong>Is there an easy way to do so in Python or do I need to create my own method?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>from a semantical POV, inheritance describes a "is a" relationship, so (as long as your child classes respect liskov's substitution principle) a fish or bear IS an animal already. Also, creating "new copy of parent class" will actually create new distinct objects which is certainly not what you want.</p>
<p>A better solution is to keep a registery (dict) of child classes (using  <code>type</code> as key) and provide a factory function or method, ie:</p>
<pre><code>class Animal(object):
    # your code here


    # XXX : Q&amp;D code, missing sanity checks and error handling
    __registry = {}

    @classmethod
    def register(cls, subcls): 
        cls.__registry[subcls.type] = subcls

    @classmethod
    def create(cls, type, x, y, engine):
        return cls.__registry[type](x, y, engine)



class Engine(object):

    def create_actors_child(self, actors):  # returns parents back

        sample = actors[0]

        x = sample.x
        y = sample.y

        for actor in actors:
            actor.go_back_event()

        self.field.append(Animal.create(sample.type, x, y, self))
</code></pre>
<p>Note that at this point if don't have any other use for <code>Animal.type</code> you could as well just use the child class itself directly (and get rid of the registry):</p>
<pre><code>    def create_actors_child(self, actors):  # returns parents back

        sample = actors[0]

        x = sample.x
        y = sample.y

        for actor in actors:
            actor.go_back_event()

        samplecls = type(sample)
        self.field.append(samplecls(x, y, self))
</code></pre>
<p>You may also want to check <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">the abc module</a> for some more evolved features wrt/ subclasses etc.</p>
</div>
