<div class="post-text" itemprop="text">
<p>I know that python has a concept of small integers which are numbers from <code>-5</code> to <code>256</code>, and if two variables assign to same numbers between this range, they both will use the same underlying object.</p>
<p><strong>From Python documentation,</strong></p>
<pre><code>#ifndef NSMALLPOSINTS
#define NSMALLPOSINTS           257
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS           5
#endif
</code></pre>
<blockquote>
<p>/* Small integers are preallocated in this array so that they    can
  be shared.    The integers that are preallocated are those in the
  range    -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).
  */</p>
</blockquote>
<p>Also <a href="https://docs.python.org/3/c-api/long.html" rel="nofollow noreferrer">explained here,</a></p>
<blockquote>
<p>The current implementation keeps an array of integer objects for all
  integers between -5 and 256, when you create an int in that range you
  actually just get back a reference to the existing object. So it
  should be possible to change the value of 1. I suspect the behaviour
  of Python in this case is undefined. :-)</p>
</blockquote>
<p>Example,</p>
<pre><code>a = 255
b = 255
print(id(a))
print(id(b))
</code></pre>
<p>gives the same id,</p>
<pre><code>1561854394096
1561854394096
</code></pre>
<p>Which makes sense and also explained on this answer, <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">"is" operator behaves unexpectedly with integers</a></p>
<p>If two numbers are less than <code>-5</code>, they should also have different IDs as follows,</p>
<pre><code>a = -6
b = -6
print(id(a))
print(id(b))
</code></pre>
<p>gives,</p>
<pre><code>2827426032208
2827426032272
</code></pre>
<p>this makes sense so far,</p>
<p>But any number greater than <code>256</code> should have different <code>id</code>,</p>
<p>This should return different IDs,</p>
<pre><code>a = 257
b = 257
print(id(a))
print(id(b))
</code></pre>
<p>But it doesn't</p>
<pre><code>2177675280112
2177675280112
</code></pre>
<p>Even when I am using very large integer, the IDs are same,</p>
<pre><code>a = 2571299123876321621378
b = 2571299123876321621378
print(id(a))
print(id(b))
</code></pre>
<p>gives me,</p>
<pre><code>1956826139184
1956826139184
</code></pre>
<p>Can someone tell me why number greater than 256 have same IDs even though in the Python code the range is <code>-5</code> to <code>257</code> (not inclusive)</p>
<p><strong>EDIT:</strong></p>
<p>I have tried using PyCharm with both Python 2.7 and 3.6. Also tried on PythonTutor.com</p>
</div>
<div class="post-text" itemprop="text">
<p>On mint Python 3.6.3 (2 as well) I cannot reproduce. My guess is <code>PyCharm</code> or pythontutor are wrapping the run in something before interpreting - since those are not open code we cannot see the internals so I cannot verify. The reason I think this is true, is while (everything below is mint Python 3):</p>
<pre><code>&gt;&gt;&gt; x=2571299123876321621378
&gt;&gt;&gt; y=2571299123876321621378
&gt;&gt;&gt; print(id(x),id(y))
140671727739528 140671727739808
</code></pre>
<p>You can have this:</p>
<pre><code>&gt;&gt;&gt; def bla():
...  x=2571299123876321621378
...  y=2571299123876321621378
...  id(x)
...  print(id(x),id(y))
...
&gt;&gt;&gt; bla()
140671727742528 140671727742528
</code></pre>
<p>so wrapping the two integers in something the interpreter can compile allows for these extra optimizations - like using the same constant for both definitions. Note this is limited as well:</p>
<pre><code>&gt;&gt;&gt; def bla():
...  x=2571299123876321621378
...  y=2571299123876321621378
...  print(id(x),id(y))
...  x+=1
...  y+=1
...  print(id(x),id(y))
...
&gt;&gt;&gt; bla()
140671727755592 140671727755592
140671728111088 140671728108808
</code></pre>
<p>I would not have code that depends on this on any way - the guarantee is only on -5 to 256.</p>
</div>
<span class="comment-copy">From a logical point of view, the information that numbers between -5 and 256 have the same ids don't tell you anything about the ids of integers outside of this range.</span>
<span class="comment-copy">it used to, if you check answers on this question, <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers" title="is operator behaves unexpectedly with integers">stackoverflow.com/questions/306313/â€¦</a> any number greater than <code>256</code> used to had different <code>id</code></span>
<span class="comment-copy">@EricDuminil, does that mean python now cache every possible integer <code>&gt;= -5</code></span>
<span class="comment-copy">Cannot reproduce on Python 3.6.3 (I get different ids on the last two examples). Same for Python2. Are you sure this is exactly how you are testing this?</span>
<span class="comment-copy">I ran it on PyCharm using Python 3.6, also tested it on <a href="http://pythontutor.com/" rel="nofollow noreferrer">pythontutor.com</a></span>
