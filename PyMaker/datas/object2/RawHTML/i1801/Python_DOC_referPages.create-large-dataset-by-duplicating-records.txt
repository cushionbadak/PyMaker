<div class="post-text" itemprop="text">
<p>I have an example dataset in a csv. It only has ~50K rows. I want to test performance of SQL queries against this dataset but 50K rows is too small for this purpose. What is the best way to take the existing csv and create a new one that is N times larger than the original one and each row is duplicated N times?</p>
<p>For example if N = 5</p>
<p>And the input csv is:</p>
<pre><code>col1, col2, col3
1, 'some string', '1999-01-01'
2, 'another string', '2001-01-01'
</code></pre>
<p>The desired output csv would be:</p>
<pre><code>col1, col2, col3
1, 'some string', '1999-01-01'
2, 'another string', '2001-01-01'
1, 'some string', '1999-01-01'
2, 'another string', '2001-01-01'
1, 'some string', '1999-01-01'
2, 'another string', '2001-01-01'
1, 'some string', '1999-01-01'
2, 'another string', '2001-01-01'
1, 'some string', '1999-01-01'
2, 'another string', '2001-01-01'
</code></pre>
<p>bash, python, or SQL solutions welcomed </p>
<p>bash or python solution preferred because I am testing across multiple database platforms</p>
</div>
<div class="post-text" itemprop="text">
<p>Using bash:</p>
<pre><code>n=5
(head -n1 file; for i in $(seq 1 $n); do tail -n+2 file; done) &gt; output.csv
</code></pre>
<p>The <code>head</code> command displays the header.</p>
<p>The <code>for</code> runs 5 times the command <code>tail</code> that displays the content of <code>file</code> except the first line (<code>-n+2</code> sets the offset to the second line).</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you have not specified against which RDBMS you are planning to execute your SQL, I will give you a solution for PostgreSQL.</p>
<p>First, you can copy your CSV data into PostgreSQL using the <a href="https://www.postgresql.org/docs/current/static/sql-copy.html" rel="nofollow noreferrer">COPY</a> command.</p>
<p>Then you can use the generate_series function to expand your data like this (CTE csv is just for testing purposes):</p>
<pre><code>with srs as (
    select a
    from generate_series(0,99) a
),
csv as (
    select *
    from mycsv
)
select *
from csv
join srs on true
</code></pre>
<p>Adjust according to your needs. This one generates 99 times what's in CTE csv.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have made small python script for the purpose:</p>
<pre><code># mulcsv.py 
import sys

def main(fname_in, fname_out, N):
    header = None
    content = []
    with open(fname_in, "r") as fin:
        for linenr, line in enumerate(fin,1):
            # remove NL? line = line.strip()
            if linenr==1:
                header = line
            else:
                content.append(line)

    with open(fname_out, "w") as fout:
        fout.write(header)
        for nr in range(N):
            fout.write("".join(content))
    print("Output in %s" % fname_out)

if __name__=="__main__":
    if len(sys.argv)!=4:
        print("Usage: %s &lt;fname-in&gt;.csv &lt;fname-out&gt;.csv N" % (sys.argv[0],))
        sys.exit(0)
    # TODO: check and parse arguments (in file existing, N is positive integer) - use argsparse?
    main(fname_in = sys.argv[1], fname_out = sys.argv[2], N = int(sys.argv[3]))
    # TESTING: main(fname_in = "r.csv", fname_out = "r2.csv", N = 5)
</code></pre>
<p>And call it: </p>
<pre><code>python mulcsv.py input.csv output.csv 5
</code></pre>
<p>For better arguments validation/parsing use <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">argsparse</a>. </p>
</div>
<span class="comment-copy">You can download large csv files for test purposes online: <a href="http://eforexcel.com/wp/downloads-18-sample-csv-files-data-sets-for-testing-sales/" rel="nofollow noreferrer">eforexcel.com/wp/â€¦</a></span>
<span class="comment-copy">@ErayBalkanli The queries I am testing are specific to the data model that I am using so this is not an acceptable alternative.</span>
<span class="comment-copy">PostgreSQL is fine. Let's assume I have a table "mycsv" already copied into PostgreSQL. Can you generalize this answer so that the column names and values do not have to be specified and the resulting table is still called "mycsv"?</span>
<span class="comment-copy">see updated answer</span>
