<div class="post-text" itemprop="text">
<p>I have a list (<code>lst1</code>) of numerical IDs (roughly 300K IDs) that I am passing into a API, and appending api results into another list (<code>lst</code>), like so:</p>
<pre><code>lst = []
lst1 = [1,2,3,4,5,6]

print(len(lst1))
counter = 0
for i in lst1:
    url = 'url.com/Id={}'.format(i)
    while True:
        try:
            xml_data1 = requests.get(url).text
            counter = counter+ 1
            print(counter)
            #print(xml_data1)
            break
        except requests.exceptions.RequestException as e:
            print(e)
    lst.append(xml_data1)
</code></pre>
<p>When I apply the future.concurrent library the code keeps looping over the same IDs. I can tell this because the counter number keeps repeating, how do I prevent this? </p>
<p>Code to how I am applying the futures.concurrent library:</p>
<pre><code>def get_data(xml):
    print(len(lst1))
    #counter = 0
    for i in lst1:
        url = 'url.com/Id={}'.format(i)
        while True:
            try:
                xml_data1 = requests.get(url).text
                counter = counter+ 1
                print(counter)
                #print(xml_data1)
                break
            except requests.exceptions.RequestException as e:
                print(e)
        lst.append(xml_data1)

with futures.ThreadPoolExecutor() as executor:  
    df_list = executor.map(get_data, lst1)
</code></pre>
<p>edit:</p>
<pre><code>def get_data(xml):
    #counter = 0
    for i in lst1:
        url = 'url.com/Id={}'.format(i)
        while True:
            try:
                xml_data1 = requests.get(url).text
                counter = next(counter_object)
                print(counter)
                #print(xml_data1)
                break
            except requests.exceptions.RequestException as e:
                print(e)
        lst.append(xml_data1)
    return lst
with futures.ThreadPoolExecutor() as executor:  
    lst = executor.map(get_data, lst1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Integers are immutable. So you could make your counter global using</p>
<pre><code>global counter
</code></pre>
<p>you could also define a global <code>counter</code> object (not integer) using <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a></p>
<p>This is my preferred method, because it avoids the use of <code>global</code> on an immutable object like integer, which always leads to mistakes and misunderstandings.</p>
<pre><code>import itertools
counter_object = itertools.count()  # default: starts at 0
</code></pre>
<p>now:</p>
<pre><code>counter = counter+ 1
</code></pre>
<p>becomes:</p>
<pre><code>counter = next(counter_object)
</code></pre>
<p>And the values won't be the same between worker threads.</p>
<p>This relies on the fact that CPython has a global interpreter lock which makes the operation safe. If you're not using CPython, you have to use threading lock mechanisms to protect the object from concurrent modifications.</p>
<p>the other issue is that <code>get_data</code> should not return a list but an item. Let <code>executor.map</code> create the list (and your loop is useless/harmful since it multiplies the number of computations)</p>
<p>so to sum it up:</p>
<pre><code>def get_data(xml):
    url = 'url.com/Id={}'.format(xml)
    while True:
        try:
            xml_data1 = requests.get(url).text
            counter = next(counter_object)
            print(counter)
            break
        except requests.exceptions.RequestException as e:
            print(e)
    return xml_data1
</code></pre>
<p>finally, <code>executor.map</code> is made to be iterated upon. To create a list, you have to <em>force</em> iteration on it:</p>
<pre><code>with futures.ThreadPoolExecutor() as executor:  
    df_list = list(executor.map(get_data, lst1))
</code></pre>
</div>
<span class="comment-copy">so this definitely fixes the counter issue, but the last line where I have it set to <code>df_list</code> is not working. When i change <code>df_list</code> to <code>lst</code>, the concurrent.futures library stops at the right number of records, if not it keeps running. In either case nothing gets appended into <code>lst</code>. Do you know what maybe causing this?</span>
<span class="comment-copy">oh, your <code>get_data</code> function should return something: <code>lst.append(xml_data1)</code> should be replaced by <code>return xml_data1</code>: no side effect, just let <code>execute</code> run. Tell me if it works, I overlooked that part trying to fix the counter issue</span>
<span class="comment-copy">If I remove the <code>lst.append(xml_data1)</code>  and replace with <code>return xml_data1</code>, nothing is getting appended to anywhere even when I have the <code>df_list</code> set to <code>lst</code>. How should I handle the appending?</span>
<span class="comment-copy">the <code>xml_data1</code> is where the results I want are. But how should I handle appending into list?</span>
<span class="comment-copy">thank you very much</span>
