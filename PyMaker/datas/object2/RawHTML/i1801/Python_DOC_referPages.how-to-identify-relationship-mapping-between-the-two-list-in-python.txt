<div class="post-text" itemprop="text">
<p>I have created two list.</p>
<pre><code>list1= [a,b,c,a,d]
list2=[1,2,3,4,5]
</code></pre>
<p>I want to find relationship between this two list based on index position  i.e </p>
<p>In list1 <code>a</code> is repeated 2 times index <code>0,3</code> .in list2  index <code>0,3</code>  values are <code>1 ,4</code>  the relation is a one  to many is a:<code>{1,4}</code></p>
<p>next <code>b</code>  not repeated  in list <code>1</code> and it index is <code>1</code> and list2 index <code>1</code> value is <code>2</code> ,the relation is one to one <code>b:{2}</code></p>
<p>my expected output will be <code>{a:{1,4},b:{2},c:{3},d:{5}}</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>I'd use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a>:</p>
<pre><code>from collections import defaultdict
list1 = ['a', 'b', 'c', 'a', 'd']
list2 = [1, 2, 3, 4, 5]
result = defaultdict(set)
for value1, value2, in zip(list1, list2):
    result[value1].add(value2)

print(dict(result))
</code></pre>
<p>outputs</p>
<pre><code> {'a': {1, 4}, 'b': {2}, 'c': {3}, 'd': {5}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a combination of dictionary and list comprehension to do this:</p>
<p><code>{x: [list2[i] for i, j in enumerate(list1) if j == x] for x in list1}</code></p>
<p>output:</p>
<p><code>{'a': [1, 4], 'b': [2], 'c': [3], 'd': [5]}</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = ['a', 'b', 'c', 'a', 'd']
b = [1, 2, 3, 4, 5]
ret = {}
for idx, _a in enumerate(a):
    value = ret.get(_a, ret.setdefault(_a, []))
    value.append(b[idx])
</code></pre>
<p>And ret will be the output</p>
</div>
<div class="post-text" itemprop="text">
<p>Option is to zip the two lists:</p>
<pre><code>L = list(zip(list1, list2))
</code></pre>
<p>Result:</p>
<pre><code> [('a', 1), ('b', 2), ('c', 3), ('a', 4), ('d', 5)]
</code></pre>
<p>Use it to create a dictionary with sets as values:</p>
<pre><code>D ={}
for key in L:
    if key[0] not in D:
        D[key[0]] = {key[1]}
    else:
        D[key[0]].add(key[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would not do it this way in real code, but this approach is mildly entertaining and perhaps educational.</p>
<pre><code>from collections import defaultdict
from itertools import groupby
from operator import itemgetter

xs = ['a', 'b', 'c', 'a', 'd']
ys = [1, 2, 3, 4, 5]

d = {
    x : set(y for _, y in group)
    for x, group in groupby(sorted(zip(xs, ys)), key = itemgetter(0))
}

print(d) # {'a': {1, 4}, 'b': {2}, 'c': {3}, 'd': {5}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not from pure python, as this question tagged with <code>pandas</code> I tried this way.</p>
<p>Option-1</p>
<pre><code>df=pd.DataFrame({'l1':list1,'l2':list2})
res1=df.groupby('l1').apply(lambda x:x.l2.values.tolist()).to_dict()
</code></pre>
<p>Option-2 </p>
<pre><code>print df.groupby('l1')['l2'].unique().to_dict()
</code></pre>
<p>Output:</p>
<pre><code>{'a': [1, 4], 'c': [3], 'b': [2], 'd': [5]}
</code></pre>
</div>
<span class="comment-copy">Good answer. Can be simplified further with <code>zip()</code>.</span>
<span class="comment-copy">defaultdict is a good choice actually, and indeed O(n) here</span>
<span class="comment-copy">@FMc oh yeah zip is much cleaner -- edited</span>
<span class="comment-copy">That's a pythonic way of  doing it.</span>
<span class="comment-copy">Although this is <code>O(n^2)</code> whereas the other answers are <code>O(n)</code></span>
