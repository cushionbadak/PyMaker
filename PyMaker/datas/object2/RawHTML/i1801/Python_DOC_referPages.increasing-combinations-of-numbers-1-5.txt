<div class="post-text" itemprop="text">
<p>I'm trying to generate a list of all possible increasing combinations of the digits 1-5.  For example, for N=3, there is [123],[125],[134], etc.  There are 32 combinations, and I could generate them by hand, but this seems like a reasonable way to learn the algorithm for when I have to do it again for larger numbers.  However, I'm pretty much at a loss for where to start.</p>
</div>
<div class="post-text" itemprop="text">
<p>As simple as:</p>
<pre><code>&gt;&gt;&gt;from itertools import combinations_with_replacement
&gt;&gt;&gt; list(combinations_with_replacement(range(1,6),3)
... )
[(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4), (1, 1, 5), (1, 2, 2), (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 3), (1, 3, 4), (1, 3, 5), (1, 4, 4), (1, 4, 5), (1, 5, 5), (2, 2, 2), (2, 2, 3), (2, 2, 4), (2, 2, 5), (2, 3, 3), (2, 3, 4), (2, 3, 5), (2, 4, 4), (2, 4, 5), (2, 5, 5), (3, 3, 3), (3, 3, 4), (3, 3, 5), (3, 4, 4), (3, 4, 5), (3, 5, 5), (4, 4, 4), (4, 4, 5), (4, 5, 5), (5, 5, 5)]
</code></pre>
<p>Counted 35, not 32. I converted to list just to print the result - you can just leave it as an iterate the result of the function call. If you do not want repeating elements, use <code>combinations</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this one which is with <strong>itertools product</strong> just in one line:</p>
<pre><code>from itertools import product

list(map(lambda k: [''.join(k)], list(map(lambda j: [str(i) for i in j],list(product(list(map(int,input().split())), repeat=3))))))
</code></pre>
<p><strong>input:</strong></p>
<pre><code>1 2 3
</code></pre>
<p><strong>output:</strong></p>
<pre><code>[['111'], ['112'], ['113'], ['121'], ['122'], ['123'], ['131'], ['132'], ['133'], ['211'], ['212'], ['213'], ['221'], ['222'], ['223'], ['231'], ['232'], ['233'], ['311'], ['312'], ['313'], ['321'], ['322'], ['323'], ['331'], ['332'], ['333']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's a simple "one-liner" if you always have 3-item sequences:</p>
<pre><code>[
    [a, b, c] 
    for a in range(1, 6) for b in range(1, 6) for c in range(1, 6) 
    if a &lt; b &lt; c
]
</code></pre>
<p>Note that in Python, <code>range(m, n + 1)</code> actually gives you values from <code>m</code> to <code>n</code> inclusive. </p>
<p>Here's an algorithm if you don't know how long the sequences will be: Allow the first digit to range from the lowest to the highest value. Then allow each additional digit to range from just above the previous digit up to the highest allowed value. Repeat this till you have enough digits. You can implement that with code like this:</p>
<pre><code>max_val = 5
n_digits = 3

for n in range(1, n_digits + 1):   # 1 to 3
    if n == 1:
        # create initial entries
        results = [[x] for x in range(1, max_val + 1)]
    else:
        old_results = results
        results = []
        for old_entry in old_results:
            last_digit = old_entry[-1]
            # create new entries with one more digit
            for x in range(last_digit + 1, max_val + 1):
                entry = old_entry + [x]
                results.append(entry)

results
# [[1, 2, 3],
# [1, 2, 4],
# [1, 2, 5],
# [1, 3, 4],
# [1, 3, 5],
# [1, 4, 5],
# [2, 3, 4],
# [2, 3, 5],
# [2, 4, 5],
# [3, 4, 5]]
</code></pre>
<p>Also note, the solutions using <code>itertools</code> don't produce strictly increasing combinations as you requested. And there appear to be 10 valid answers for your test case, not 32, unless I've missed something.</p>
</div>
<span class="comment-copy">can you provide better examples? I'm finding it difficult to figure out what needs to be solved here</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.combinations</a></span>
<span class="comment-copy">Have N indices.  Increase the right most one.  If it goes over the limit (5 in your case) then increase Index N-1 and set index N to point right after index N-1.  Following this pattern, you should be able to figure out an algorithm.  Outer most loop is a while loop (while not done)</span>
