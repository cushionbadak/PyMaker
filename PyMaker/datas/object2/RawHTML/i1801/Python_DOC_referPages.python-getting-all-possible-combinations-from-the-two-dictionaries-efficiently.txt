<div class="post-text" itemprop="text">
<pre><code>ra_position_preferences = {"yoder3":["J","E","T","S","M","R","B","SS"],
                           "yoder4":["J","E","S","T","M","R","SS","B"],
                           "kratz3":["M","J","S","E","T","R","B","SS"],
                           "miller3":["S","M","J","E","T","R","B","SS"],
                           "nofloor":["SS","B","R","T","S","M","E","J"]}

applicants_floor_prefernce ={"J":["yoder3","yoder4","kratz3","miller3","nofloor"],
                             "E":["yoder3","yoder4","kratz3","miller3","nofloor"],
                             "S":["kratz3","miller3","yoder3","yoder4","nofloor"],
                             "M":["kratz3","miller3","nofloor","yoder3","yoder4"],
                             "T":["nofloor","yoder4","yoder3","kratz3","miller3",],
                             'SS':["yoder3","yoder4","kratz3","miller3","nofloor"],
                             'R':["kratz3","miller3","yoder3","yoder4","nofloor"],
                             'B':["yoder4","yoder3","kratz3","miller3","nofloor"]}
</code></pre>
<p>In the above dictionaries all the values are the preferences for the key. Just like in matching problem <a href="https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/01StableMatching.pdf" rel="nofollow noreferrer">https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/01StableMatching.pdf</a>. I am trying to get all the possible combinations of preferences here without getting a memory error. Also I am putting every combination I get into gale-shapley algorithm to get all the possible matching. My code is below:</p>
<pre><code>def sensitivity_analysis(dic1,dic2): #gives all the possible combinations of the preferences 
    a=copy.deepcopy(dic1)
    b=copy.deepcopy(dic2)
    length_a=len(a.keys())
    length_b=len(b.keys())
    items_a=list(a.keys())
    items_b=list(b.keys())
    a_variants = [dict(zip(items_a, values)) 
                 for values in product(permutations(items_b), repeat=length_a)]
    b_variants = [dict(zip(items_b, values)) 
                 for values in product(permutations(items_a), repeat=length_b)]

    all_variants = product(a_variants, b_variants)
    contains_a=[]
    contains_b=[]
    for i,j in all_variants:
        contains_a.append(i)
        contains_b.append(j)
    return contains_a,contains_b
</code></pre>
<p>From the above code I am getting the memory error. Is there any other way to do it? My suggestion is to get one combination at a time and plug it into the gale-shapley function and get the matching. Then append the matching in a dictionary. If the new matching is same as the last one we can delete the new matching to save the memory in the array. But it is still will be 278 million calculations. Do you guys have any efficient way to do it so i can run it on my computer with 16 GB of RAM?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Given</strong></p>
<pre><code>import itertools as it
import collections as ct


floors = ["yoder3", "yoder6", "kratz3", "miller3", "nofloor"]
applicants = ["SS", "M", "J", "T", "R", "B", "E", "S"]

preferences = {
    "J": ["yoder3", "yoder6", "kratz3", "miller3", "nofloor"],
    "E": ["yoder3", "yoder6", "kratz3", "miller3", "nofloor"],
    "S": ["kratz3", "miller3", "yoder3", "yoder6", "nofloor"],
    "M": ["kratz3", "miller3", "nofloor", "yoder3", "yoder6"],
    "T": ["nofloor", "yoder6", "yoder3", "kratz3", "miller3"],
    "SS": ["yoder3", "yoder6", "kratz3", "miller3", "nofloor"], 
    "R": ["kratz3", "miller3", "yoder3", "yoder6", "nofloor"],
    "B": ["yoder6", "yoder3", "kratz3", "miller3", "nofloor"]
}
</code></pre>
<p>A helper function</p>
<pre><code>def fill_missing(iterable, fillvalues):
    """Yield combinations replacing empty strings in iterable with fillvalues."""
    iter_fillvalues = map(iter, fillvalues)
    for x in iter_fillvalues:
        comb = []
        for item in iterable:
            if item == "":
                comb.append(next(x))
            else:
                comb.append(item)
        yield comb
</code></pre>
<p><strong>Code</strong></p>
<pre><code>def ranked_preferences(floors, preferences):
    """Return a dict of preferences."""
    ranked = ct.defaultdict(list)
    for floor in floors:
        for i in range(len(floors)):
            idx_prefs = [
                name for name, lst in preferences.items() 
                     for j, v in enumerate(lst) if (j == i and v == floor)
            ]
            if not idx_prefs:
                idx_prefs = [""]
            ranked[floor].append(idx_prefs)
    return dict(ranked)


def preferred_assignments(ranked, applicants, top=None):
    """Yield combinations of preferred assignments."""
    if top is None:
        top = len(ranked)

    applicants = set(applicants)
    ranks = zip(ranked.values())
    for i, rank in enumerate(ranks):
        if i &gt;= top:
            continue
        for a in it.product(*rank[0]):
            missing = a.count("")
            b = applicants - set(a)
            c = list(it.combinations(b, missing))
            d = list(it.chain.from_iterable([list(it.permutations(x, missing)) for x in c]))
            e = list(fill_missing(a, d))
            yield tuple(tuple(zip(*x)) for x in zip(it.repeat(list(ranked.keys())), e))
</code></pre>
<p><strong>Demos</strong></p>
<p>Yield all combinations based on preferences:</p>
<pre><code>ranked = ranked_preferences(floors, preferences)
combos = set(it.chain.from_iterable(preferred_assignments(ranked, applicants)))
print("Number of preferred combinations:", len(combos))
# Number of preferred combinations: 668
</code></pre>
<p>Specify <code>top</code> preferred picks:</p>
<pre><code>combos = set(it.chain.from_iterable(preferred_assignments(ranked, applicants, top=1)))
print("Number of preferred combinations:", len(combos))
combos

# Number of preferred combinations: 36
# {(('yoder3', 'E'),
#   ('yoder6', 'B'),
#   ('kratz3', 'R'),
#   ('miller3', 'M'),
#   ('nofloor', 'J')),
#  (('yoder3', 'E'),
#   ('yoder6', 'B'),
#   ('kratz3', 'R'),
#   ('miller3', 'M'),
#   ('nofloor', 'S')),
#  (('yoder3', 'E'),
#  ...)}
</code></pre>
<p>Here only combinations of the number 1 choices are given.  You could select the top 2 choices by setting <code>top=2</code>.</p>
<hr/>
<p><strong>Details</strong></p>
<p>Naive approach (without preferences) using the itertools <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>grouper</code></a> recipe:</p>
<pre><code>def all_assignments(chunks):
    """Yield all combinations of floors assigned to applicants."""
    combs = it.product(*chunks)
    for comb in combs:
        names = {c[1] for c in comb}
        if len(names) != len(floors):
            continue
        yield comb

chunks_by_floor = list(grouper(len(applicants), it.product(floors, applicants)))
chunks_by_floor[:2]
result = list(all_assignments(chunks_by_floor))
print("Number of combinations:", len(result))
# Number of combinations: 6720
</code></pre>
<p>Thus, the combinations with preferences is some subset of these combinations.  To select this subset, let's look at the preferences per floor grouped by top 1-5 choices:</p>
<pre><code>ranked
{'yoder3': [['J', 'E', 'SS'], ['B'], ['S', 'T', 'R'], ['M'], ['']],
 'yoder6': [['B'], ['J', 'E', 'T', 'SS'], [''], ['S', 'R'], ['M']],
 'kratz3': [['S', 'M', 'R'], [''], ['J', 'E', 'SS', 'B'], ['T'], ['']],
 'miller3': [[''], ['S', 'M', 'R'], [''], ['J', 'E', 'SS', 'B'], ['T']],
 'nofloor': [['T'], [''], ['M'], [''], ['J', 'E', 'S', 'SS', 'R', 'B']]}
</code></pre>
<p>The top choices per floor are ordered from left to right, e.g. index 0 of each value in the dict indicates applicants that select that floor as their number 1 preference. Index 2 indicates their number 2 preference, etc.  Some floors have applicants with tied preferences (<code>yoder3</code> and <code>kartz3</code>, at index <code>[0]</code>).  Some floors have no preferences (<code>miller3</code> at <code>[0]</code>).  The rest of the logic in <code>preferred_assignments()</code>, i.e. variables <code>a-e</code>, make combinations of applicants based on preferences (think vertical columns).  Missing values are randomly substituted from the remaining pool of applicants.</p>
<p>In the demo, since these combinations are grouped based on preferences, we flatten the combinations with <code>itertools.chain.from_iterable()</code> and cast to a set to remove any duplicates.</p>
</div>
<span class="comment-copy">Sorry, what is each combination supposed to include? It seems each key contains all of the available options, so it's not clear what combinations are supposed to provide here. I'm not sure what you're trying to achieve...</span>
<span class="comment-copy">@duhaime the dictionary above is in a particular order as all the values are preferences here. So in the first dictionary Yoder 3 has 8 preferences. Yoder 3 's first preference is J, than E, than T and so on. I am trying to get all the combinations with different preferences. For example in the next combination Yoder 3's first and second preferences can swipe places and the rest will remain the same and all the other preferences will remain the same in all other keys of both dictionaries. So for the above case there will be 8^5 * 5^8 different combinations.</span>
<span class="comment-copy">Give an example of expected "combinations of preferences".  Please illustrate as output to your code in your question (not as a comment).</span>
