<div class="post-text" itemprop="text">
<p>I have the following two dictionaries:</p>
<pre><code>a={"ad":["tau","guru"],
"bigd":["tau","guru"],
"lugd":["tau","guru"]}

b={"tau":["ad","bigd","lugd"],
"guru":["bigd","ad","lugd"]}
</code></pre>
<p>Every value of key is a preference order by the key. I am trying to accomplish with python is that how to get all the possible combinations of preference order.
So one preference order will be that when you only flip the values of the key "ad" and the rest will be the same. It is listed below</p>
<pre><code>a={"ad":["guru", "tau"],
"bigd":["tau","guru"],
"lugd":["tau","guru"]}

b={"tau":["ad","bigd","lugd"],
"guru":["bigd","ad","lugd"]}
</code></pre>
<p>Other can be when the "ad" preferences will remain the same and "bigd" preference will be different. We have to iterate through all the list in both dictionaries and find all 2^3 * 3*2 possibilities. Can someone please help me with that? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can get them using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a>:</p>
<pre><code>from itertools import permutations, product

a_variants = [dict(zip(["ad", "bigd", "lugd"], values)) 
                 for values in product(permutations(["tau","guru"]), repeat=3)]
b_variants = [dict(zip(["tau", "guru"], values)) 
                 for values in product(permutations(["ad", "bigd", "lugd"]), repeat=2)]

all_variants = product(a_variants, b_variants)

for va, vb in all_variants:
    print("a:", va, "\nb:", vb, "\n")
</code></pre>
<p>Output:</p>
<pre><code>a: {'ad': ('tau', 'guru'), 'bigd': ('tau', 'guru'), 'lugd': ('tau', 'guru')} 
b: {'tau': ('ad', 'bigd', 'lugd'), 'guru': ('ad', 'bigd', 'lugd')} 

a: {'ad': ('tau', 'guru'), 'bigd': ('tau', 'guru'), 'lugd': ('tau', 'guru')} 
b: {'tau': ('ad', 'bigd', 'lugd'), 'guru': ('ad', 'lugd', 'bigd')} 

...

a: {'ad': ('guru', 'tau'), 'bigd': ('guru', 'tau'), 'lugd': ('guru', 'tau')} 
b: {'tau': ('lugd', 'bigd', 'ad'), 'guru': ('lugd', 'ad', 'bigd')} 

a: {'ad': ('guru', 'tau'), 'bigd': ('guru', 'tau'), 'lugd': ('guru', 'tau')} 
b: {'tau': ('lugd', 'bigd', 'ad'), 'guru': ('lugd', 'bigd', 'ad')} 
</code></pre>
<p>Note that you have 2**3 * (3*2)**2 = 288 different outputs. </p>
</div>
<span class="comment-copy">Can you post some code showing what you have tried so far? That will help us give you a better answer.</span>
<span class="comment-copy">thank you for the answer but I got 288 instead of 324 when I did len(list(all_variants)) . Can you pls help?</span>
<span class="comment-copy">@kumar  <code>print(len(list(all_variants)))</code> for this does get <code>288</code></span>
<span class="comment-copy">@kumar the same code runs here gets your expected <code>288</code> possibilities: <a href="https://repl.it/@downshift/SmugLonelyDevicedriver" rel="nofollow noreferrer">repl.it/@downshift/SmugLonelyDevicedriver</a></span>
<span class="comment-copy">@kumar Yes, of course, I mixed up when typing it, it's 2^3, not 3^2 for <code>a</code>, so 288 in total, as the code correctly outputs. I had added this comment because the ^2 was missing for (3*2) in your question.</span>
<span class="comment-copy">@ThierryLathuille is it also possible to get all the combination by only changing the first two preferences for every key in both the dictionary? So for example in dictionary a there is only two preferences for all the keys but in dictionary b there are three for both the keys so we only want to change the first two and not including 'lugd'. One time it can be for b['guru'] -- ['ad, 'bigd', 'lugd']. only the first two indexes participate in the permutation for all the keys in both dictionaries.</span>
