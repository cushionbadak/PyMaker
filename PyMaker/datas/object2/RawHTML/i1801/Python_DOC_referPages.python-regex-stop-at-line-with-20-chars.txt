<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/53169493/python-regex-extract-text-between-multiple-expressions-in-a-textfile">Python Regex - Extract text between (multiple) expressions in a textfile</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I have a letter in which I need to extract a certain part. The beginning and the ending is marked by clear beginning / ending expressions (<code>letter_beg</code> / <code>letter_end</code>). My problem is that the "recording" of the text needs to end before the first line with more than 20 chars just after the "match" of <code>letter_end</code>. In my code it does after 2 new lines. Here is my sample text and my code so far:</p>
<pre><code>sample_text = """Some random text right here 
.........
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards 
Douglas - Director
Other random text with more than 20 chars in this line    """

letter_begin = ["dear", "to our", "fellow investors"] # All expressions for "beginning" of Letter to the Shareholders (LttS)
openings = "|".join(letter_begin)
letter_end = ["sincerely", "best regards", "cordially,"] # All expressions for "ending" of Letter to the Shareholders (LttS)
closings = "|".join(letter_end)
regex = r"(?:" + openings + r")[\s\S]*?" + r"(?:" + closings + r").*(?:\n.*){0,2}"
output = re.findall(regex, text, re.IGNORECASE) # record all text between Regex (beginning and end expressions)
print(output)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am not entirely sure what is your expected output, but it is quite simple to do this without regular expressions (an thus get rid of one problem).</p>
<p>The solution below assumes <code>sample_text</code> contains <code>\n</code> (line breakes) and will not work if <code>sample_text</code> is a one long line (i.e. without any <code>\n</code>).</p>
<pre><code>sample_text = """Some random text right here
.........
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
Other random text with more than 20 chars in this line
"""

letter_begin = ["dear", "to our", "fellow investors"]
letter_end = ["sincerely", "best regards", "cordially,"]

lines = sample_text.strip().split("\n")

target_start_idx = None
target_end_idx = None

for index, line in enumerate(lines):
    line = line.lower()

    if any(line.startswith(beg) for beg in letter_begin):
        target_start_idx = index
        continue

    if any(line.startswith(end) for end in letter_end):
        target_end_idx = index
        break

if target_end_idx is not None:
    for index, line in enumerate(lines[target_end_idx + 1 :]):
        if len(line) &gt;= 20:
            target_end_idx += index
            break

if target_start_idx is not None and target_end_idx is not None:
    target = "\n".join(lines[target_start_idx : target_end_idx + 1])
    print(target)
</code></pre>
<p>The output is</p>
<pre><code>Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
</code></pre>
<p><br/></p>
<p><strong>EDIT</strong></p>
<p>Based on your last <a href="https://stackoverflow.com/questions/53188483/python-regex-stop-at-line-with-20-chars/53188699?noredirect=1#comment93662114_53188699">comment</a> I can think of two ways to do this. Hopefully one of them will solve your problem.</p>
<p>Option 1</p>
<pre><code>sample_text = """Some random text right here
.........
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
Other random text with more than 20 chars in this line
.........
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
Other random text with more than 20 chars in this line
"""

letter_begin = ["dear", "to our", "fellow investors"]
letter_end = ["sincerely", "best regards", "cordially,"]

lines = sample_text.strip().split("\n")

target_start_indexes = []
target_end_indexes = []

for index, line in enumerate(lines):
    line = line.lower()

    if any(beg in line for beg in letter_begin):
        target_start_indexes.append(index)
        continue

    if any(end in line for end in letter_end):
        target_end_indexes.append(index)
        continue

for target_index, target_end_idx in enumerate(target_end_indexes):
    for line_index, line in enumerate(lines[target_end_idx + 1 :]):
        if len(line) &gt;= 20:
            target_end_idx += line_index
            target_end_indexes[target_index] = target_end_idx
            break


target = []
if target_start_indexes and target_end_indexes:
    for target_start_idx, target_end_idx in zip(
        target_start_indexes, target_end_indexes
    ):
        target.append("\n".join(lines[target_start_idx : target_end_idx + 1]))

    print("\n".join(target))
</code></pre>
<p>Output</p>
<pre><code>Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
</code></pre>
<p><br/>
Option 2</p>
<pre><code>sample_text = """Some random text right here
.........
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
Other random text with more than 20 chars in this line
.........
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
Other random text with more than 20 chars in this line
"""

letter_begin = ["dear", "to our", "fellow investors"]
letter_end = ["sincerely", "best regards", "cordially,"]

lines = sample_text.strip().split("\n")

target_start_idx = None
target_end_idx = None

for index, line in enumerate(lines):
    line = line.lower()

    if any(beg in line for beg in letter_begin):
        if target_start_idx is None:
            target_start_idx = index
            continue

    if any(end in line for end in letter_end):
        target_end_idx = index

if target_end_idx is not None:
    for index, line in enumerate(lines[target_end_idx + 1 :]):
        if len(line) &gt;= 20:
            target_end_idx += index
            break

if target_start_idx is not None and target_end_idx is not None:
    target = "\n".join(lines[target_start_idx : target_end_idx + 1])
    print(target)
</code></pre>
<p>Output</p>
<pre><code>Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
Other random text with more than 20 chars in this line
.........
Dear Shareholders: We are pleased to provide you with this semiannual report for the fund.
Best regards
Douglas - Director
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you insist on using a monolithic regex, add a <a href="https://docs.python.org/3/howto/regex.html#lookahead-assertions" rel="nofollow noreferrer">positive lookahead</a> for a line containing more than 20 characters at the end:</p>
<pre><code>(?=[^\n]{21,})
</code></pre>
<p>You may also need to add the <a href="https://docs.python.org/3/library/re.html#re.DOTALL" rel="nofollow noreferrer"><code>re.DOTALL</code></a> flag:</p>
<pre><code>re.IGNORECASE | re.DOTALL
</code></pre>
</div>
<span class="comment-copy">Thanks a lot for your help Dusan! I have the problem that the "letter_begin" or "letter_end" does not necissarily needs to be at the beginning of the line, but can be somehere on that line - is there a way to check for line.contains(beg/end) instead of line.startswith(beg/end)?</span>
<span class="comment-copy">Sure, just use <code>if any(beg in line for beg in letter_begin)</code> and <code>if any(end in line for end in letter_end)</code>.</span>
<span class="comment-copy">Hi Dusan, great solution! one thing I noticed during my research: is there a way to fix the start/ end index you set to the first/ last appearance of the letter_begin / letter_ending in the text (e.g. consider a letter in which more than one of the expressions defined in the lists occur -  in this case I will "record" the text from the first appearance of letter_begin until the last appearance of letter_ending items -  any idea?</span>
<span class="comment-copy">@DominikScheld edited based on your last comment.</span>
