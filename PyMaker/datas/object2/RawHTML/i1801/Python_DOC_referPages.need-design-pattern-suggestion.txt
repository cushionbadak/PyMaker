<div class="post-text" itemprop="text">
<p>I need help para to beautify this code :)
The method definesAction will call a Class, based on the args. There is some way to  generalizing this piece of code, taking into account that the Class's are similar.
Thanks in advance</p>
<p>Main Class</p>
<pre><code>def defineAction(args):

    if args.classabc is not None:
        for host in config.getList('ABC', 'hosts'):
            class_abc = ClassABC(config.getConfigs('ABC', host), args.version[0], user, password)
            class_abc.action(args.classabc)

    if args.classxyz is not None:
        for host in config.getList('XYZ', 'hosts'):
            class_xyz = ClassXYZ(config.getConfigs('XYZ', host), args.version[0], user, password)
            class_xyz.action(args.classxyz)

    # ...

def main():

    parser.add_argument('--classabc', choices=['cmd'])
    parser.add_argument('--classxyz', choices=['cmd'])
    # ...
    args = parser.parse_args()
    defineAction(args)
</code></pre>
<p>SubClasses</p>
<pre><code>class ClassABC:
    def __init__(self, configs, user, password):
        self.hostConfigs = configs['host']
        self.host_username = user
        self.host_password = password

    def a_method(self):
        # This Method is equal in all subclasses
    def b_method(self):
        # This Method is different all subclasses

    def action(self, action):
        self.a_method()
        self.b_method()

        if action == 'cmd':
            self.execute_cmd()
</code></pre>
<p>Config FILE</p>
<pre><code>[ABC]
hosts=abc_host1
var_abc=value1

[XYZ]
hosts=xyz_host1,xyz_host2
var_xyz=value2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm working the assumption that the switches are mutually exclusive (in which case you really want to use a <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_mutually_exclusive_group" rel="nofollow noreferrer">mutually exclusive argument group</a>).</p>
<p>You want the argparser action to set the <em>class</em>. If your command-line switch doesn't need to take any arguments, then I'd use <code>action="store_const"</code> here:</p>
<pre><code>parser.add_argument(
    '--classabc', dest="class_", const=ClassABC,
    action="store_const")
parser.add_argument(
    '--classxyz', dest="class_", const=ClassXYZ,
    action="store_const")
</code></pre>
<p>On parsing, the above actions set <code>args.class_</code> to <code>ClassABC</code> or <code>ClassXYZ</code> when one or the other switch is used. Give the classes a class method or an attribute to determine what configuration section to look in, do not hardcode those names anywhere else.</p>
<p>For instance, if both classes have a <code>config_section</code> attribute, (set to <code>'ABC'</code> for <code>ClassABC</code> and <code>'XYZ'</code> for <code>ClassXZY</code>), then you can use that attribute in your loop creating instances:</p>
<pre><code>if args.class_:
    for host in config.getList(class_.config_section, 'hosts'):
        instance = args.class_(config.getConfig(class_.config_section, host), ...)
</code></pre>
<p>The idea is to not switch based on <code>args</code> attributes, you can leave this to <code>argparse</code> as it is already determining the different options for you.</p>
<p>If both command-line switches require an additional argument, then create a custom <a href="https://docs.python.org/3/library/argparse.html#action-classes" rel="nofollow noreferrer"><code>Action</code> subclass</a>:</p>
<pre><code>class StoreClassAction(argparse.Action):
    def __call__(self, parser, namespace, values, **kwargs):
        setattr(namespace, self.dest, (self.const, values)
</code></pre>
<p>then use this as:</p>
<pre><code>parser.add_argument(
    '--classabc', dest="class_", choices=['cmd'], const=ClassABC,
    action=StoreClassAction)
parser.add_argument(
    '--classxyz', dest="class_", choices=['cmd'], const=ClassXYZ,
     action=StoreClassAction)
</code></pre>
<p>Now the <code>args.class_</code> argument is set to <code>(classobject, argumentvalue)</code>, so you can use:</p>
<pre><code>if args.class_:
    cls, action = args.class_
    for host in config.getList(cls.config_section, 'hosts'):
        instance = args.class_(config.getConfig(cls.config_section, host), ...)
        instance.action(action)
</code></pre>
</div>
<span class="comment-copy">Are the arguments exclusive, or can both <code>--classabc</code> and <code>--classxyz</code> be used at the same time?</span>
<span class="comment-copy">they will only be used individually during a call, they will never be used simultaneously.</span>
<span class="comment-copy">Your example uses <code>choices=['cmd']</code>, is that always the same, single string option for all <code>--class*</code> switches? Or is that going to vary?</span>
<span class="comment-copy">What would the command-line switches look like, now you must use <code>--classabc cmd</code> or <code>--classxyz cmd</code> (no other versions allowed). What are the actual rules here, will there always be a required argument for a <code>--class*</code> switch?</span>
<span class="comment-copy">This will be to define the behavior of some methods in the subclass, and will only pass a single value, or in the limit a dict. EDIT: I changed the example subclass</span>
<span class="comment-copy">EDIT: I added the config file, with the information of the actions and their hosts. I'm not realizing how this info will be passed to the class and used by it</span>
<span class="comment-copy">@tiago: give <code>ClassABC</code> an attribute <code>config_section</code> and set it to <code>'ABC'</code>, and do the same for <code>ClassXYZ</code> but set the attribute to <code>'XYZ'</code>. That attribute is then used to read the correct configuration section.</span>
