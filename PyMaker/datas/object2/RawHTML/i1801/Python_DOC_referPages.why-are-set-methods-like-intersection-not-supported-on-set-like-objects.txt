<div class="post-text" itemprop="text">
<p>In Python 3.7, I'd like to calculate the intersection of two dictionaries' keys. To do this, I'd like to call the <code>.intersection()</code> method on their <code>keys()</code>, however it does not work.</p>
<p>.keys() produces a set-like object, however most set methods don't work on it. What works however is the extremely unknown bitwise operator overloads for set-like objects, like <code>&amp;</code>. </p>
<pre><code>m = {'a':1, 'b':2}
n = {'b':3, 'c':4}

m.keys().intersection(n.keys())  # Pythonic, but doesn't work

m.keys() &amp; n.keys()  # works but not readable

set(m.keys()).intersection(set(n.keys()))  # works, readable, but too verbose
</code></pre>
<p>I find that the <code>&amp;</code> overload on a set-like object is extremely rarely used and is not known by most programmers. Method names like <code>.intersection()</code> or <code>.union()</code> is self-documenting and definitely more Pythonic by this definition.</p>
<p>Why isn't it supported then? Even the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=set#frozenset.intersection" rel="nofollow noreferrer">documentation</a> lists the <code>&amp;</code> and <code>.intersection()</code> methods like aliases, not mentioning that only <code>&amp;</code> is supported on set-like objects.</p>
<p><em>note:</em> For some reason, in IPython the autocomplete lists <code>.isdisjoin()</code> as a method which is available on <code>dict.keys()</code>. Out of the 17 set methods, 1 is present.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer"><code>dict</code> views only guarantee the API of <code>collections.abc.Set</code></a>, not to be equivalent to <code>set</code> itself:</p>
<blockquote>
<p>For set-like views, all of the operations defined for the abstract base class <code>collections.abc.Set</code> are available (for example, <code>==</code>, <code>&lt;</code>, or <code>^</code>).</p>
</blockquote>
<p>So they're not claiming to match <code>set</code>, or even <code>frozenset</code>, just <code>collections.abc.Set</code> <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow noreferrer"><code>collections.abc.Set</code> doesn't require any of the named methods aside from <code>isdisjoint</code></a> (which has no operator equivalent).</p>
<p>As for <em>why</em> <code>collections.abc.Set</code> doesn't require the named methods, it may be because they are somewhat more complex (most take varargs, and the varargs can be any iterable, not just other set-like things, so you can, for example, <code>intersection</code> with many iterables at once), and they may have wanted to limit the complexity required to implement new subclasses (especially virtual subclasses, that wouldn't inherit any of the methods <code>collections.abc.Set</code> might choose to provide).</p>
<p>All that said, I generally agree with your point that it seems needlessly inconsistent to omit the method forms. I'd recommend you open a bug on <a href="https://bugs.python.org/" rel="nofollow noreferrer">the Python bug tracker</a> requesting the change; just because it only guarantees <code>Set</code> compatibility doesn't mean it can't do more.</p>
</div>
<div class="post-text" itemprop="text">
<p>The format should be</p>
<pre><code>set.intersection(*others)
</code></pre>
<p>where other is any iterable.
m.keys() is dict_keys not a set so that won't work.</p>
<pre><code>set(m.keys()).intersection(n.keys())
</code></pre>
<p>will work :)</p>
</div>
<span class="comment-copy">If you're worried about being too verbose, you don't need to cast <code>n.keys</code> to <code>set</code> in the last example: <code>set(m.keys()).intersection(n.keys())</code></span>
<span class="comment-copy">While not disagreeing with the general point that the methods should be supported to match expectations, I find the overloads of the various operators rather intuitive, and prefer them to the overly verbose (and often confusing) names of the methods. I know what all the bitwise-operators do by analogy to what they do for bits; <code>^</code> makes sense immediately, but <code>symmetric_difference</code> always takes a moment to register; <code>&lt;</code> and <code>&lt;=</code> are immediately clear, but which one <code>issubset</code> mimics is not.</span>
<span class="comment-copy">@sacul: For that matter, you don't need to call <code>.keys()</code>; <code>set(m).intersection(n)</code> will work equivalently, since <code>dict</code>s already act like unique iterables of their own values. The <i>only</i> reason to bother with <code>.keys()</code> is to get the set-like behaviors; if you're converting to <code>set</code> anyway, you don't need it.</span>
<span class="comment-copy">@ShadowRanger so you are saying that the cleanest code is actually: <code>set(m).intersection(n)</code>, right?</span>
<span class="comment-copy">@hyperknot: Or just <code>m.keys() &amp; n.keys()</code> (and actually, <code>m.keys() &amp; n</code> works just fine too, but it feels weird to leave it asymmetric like that).</span>
