<div class="post-text" itemprop="text">
<p>While testing an application I made using a rest api I discovered this behaviour which I don't understand.<br/>
Lets start by reproducing a similar error as follows -<br/>
In file <code>call.py</code> -<br/>
<strong>Note</strong> that this file has code that manifests itself visually for example a GUI that runs forever. Here I am just showing you a representation and deliberately making it raise an Exception to show you the issue. Making a get request and then trying to parse the result as json will raise a <code>JSONDecodeError</code>.</p>
<pre><code>import requests
from time import sleep

sleep(3)
uri = 'https://google.com'
r = requests.get(uri)
response_dict = r.json()
</code></pre>
<p>Since I want to run this as a daemon process, I decouple this process from the terminal that started it using the following trick -<br/>
In file <code>start.py</code> -</p>
<pre><code>import subprocess
import sys

subprocess.Popen(["python3", "call.py"])
sys.exit(0)
</code></pre>
<p>And then I execute <code>python3 start.py</code><br/>
It <strong>apparently</strong> decouples the process because if there are no exceptions the visual manifestation runs perfectly.<br/>
However in case of an exception I immediately see this output in the terminal, even though I got a new prompt after calling <code>python3 start.py</code> -</p>
<pre><code>$ python3 start.py
$ Traceback (most recent call last):
  File "call.py", line 7, in &lt;module&gt;
    response_dict = r.json()
  File "/home/walker/.local/lib/python3.6/site-packages/requests/models.py", line 896, in json
    return complexjson.loads(self.text, **kwargs)
  File "/usr/lib/python3/dist-packages/simplejson/__init__.py", line 518, in loads
    return _default_decoder.decode(s)
  File "/usr/lib/python3/dist-packages/simplejson/decoder.py", line 370, in decode
    obj, end = self.raw_decode(s)
  File "/usr/lib/python3/dist-packages/simplejson/decoder.py", line 400, in raw_decode
    return self.scan_once(s, idx=_w(s, idx).end())
simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
</code></pre>
<p>Now, I understand that all exceptions MUST be handled in the program itself. And I have done it after this strange issue, but what is not clear to me is <strong>why did this happen at all in the first place</strong>?<br/>
It doesn't happen if I quit the terminal and restart the terminal (the visual manifestation gets stuck in case of a Traceback, and no output on any terminal as expected)<br/>
Why is a decoupled process behaving this way?<br/>
<strong>NOTE</strong>: Decoupling is imperative to me. It is imperative that the GUI run as a background or daemon process and that the terminal that spawns it is freed from it.</p>
</div>
<div class="post-text" itemprop="text">
<p>by "decoupled", I assume you mean you want the stdout/stderr to go to <code>/dev/null</code>?  assuming that's what you mean, that's not what you've told your code to do</p>
<p>from the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>stdin, stdout and stderr specify the executed program’s standard input, standard output and standard error file handles, respectively. Valid values are <code>PIPE</code>, <code>DEVNULL</code>, an existing file descriptor (a positive integer), an existing file object, and <code>None</code>.</p>
<p>With the default settings of <code>None</code>, no redirection will occur; the child’s file handles will be inherited from the parent. </p>
</blockquote>
<p>you therefore probably want to be doing:</p>
<pre><code>from subprocess import Popen, DEVNULL

Popen(["python3", "call.py"], stdin=DEVNULL, stdout=DEVNULL, stderr=DEVNULL)
</code></pre>
<p>based on the OPs comment, I think they might be after a tool like GNU <code>screen</code> or <code>tmux</code>.  terminal multiplexers, like these, allow you to create a virtual terminal that you can disconnect from and reconnect to at need.  these answers see <a href="https://askubuntu.com/a/220880/106239">https://askubuntu.com/a/220880/106239</a> and  <a href="https://askubuntu.com/a/8657/106239">https://askubuntu.com/a/8657/106239</a> have examples for <code>tmux</code> and <code>screen</code> respectively</p>
</div>
<span class="comment-copy">Thanks for the answer. Do you have any idea if this is the correct way to "decouple" ? By "decoupling" i basically mean that the terminal that starts the process must become free of the process (usually until and unless the process finishes, we don't get a new prompt, right?) . Is it possible to do this from WITHIN the same program (not writing <code>start.py</code>. And I want this to happen because of the fact that this is a very long running diagnostic program that basically runs as long as my laptop is ON.</span>
<span class="comment-copy">@raj I've updated my answer based on this comment, hope I've interpreted correctly!</span>
<span class="comment-copy">Thanks a lot but I had actually browsed quite a few resources about tools like <code>nohup</code> , 'screen` etc. The issue with them is that they are platform specific and (or) require additional installation. My idea was that since Python's libraries have matured and modules like <code>subprocess</code>, <code>threading</code> etc have come up, it should be possible to do what we are doing using <code>Popen</code> but without the the additional script. I am satisfied with <code>Popen</code>, its just that I think there is a better solution that that. I really dont want to use additional tools to do what we are doing by <code>Popen</code> now.</span>
<span class="comment-copy">the concept of GUIs and background processes are pretty platform specific; have you ever done any embedded development?  I'd stick with the tools for the OS I'm initially targeting and worry about porting if/when that becomes important</span>
