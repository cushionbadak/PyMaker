<div class="post-text" itemprop="text">
<p>I have to write a function which gets three arguments. lower, higher an cache.
Lower and higher gives a range where a new list is created with. This part is this code: </p>
<pre><code>def one_range(lower, higher, cache):
    list1 = []
    for i in range(lower,higher):
        list1.append(i)
    return list1    
</code></pre>
<p>If "range" is called twice with the same arguments, both times the same list should be returned. The second time the list is not generated again, but reused.
How can i do that?</p>
<p>Edited the orinal function</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that <code>cache</code> is a dictionary, you can make a <code>tuple</code> from the other parameters and see whether that tuple is in the dict. If it is, return the value from the dict, otherwise calculate the value and store it in the dict before returning it. You might also provide a default value for <code>cache</code> so the function can also be used without it.</p>
<pre><code>def one_range(lower, higher, cache=None):
    if cache is not None and (lower, higher) in cache:
        return cache[(lower, higher)]
    lst = []
    for i in range(lower,higher):
        lst.append(i)
    if cache is not None:
        cache[(lower, higher)] = lst
    return lst
</code></pre>
<p>Example:</p>
<pre><code>c = {}
x = one_range(2, 4, c)
y = one_range(1, 4, c)
z = one_range(2, 4, c)
print(x is z) # True
print(c)      # {(2, 4): [2, 3], (1, 4): [1, 2, 3]}
</code></pre>
<p>That's a lot of boiler plate code, though, cluttering the function. In practice, this can be done much easier with a function decorator. If you can not use <code>functools.lru_cache</code>, you can implement your own memoization decorator in just a few lines of code:</p>
<pre><code>def memo(f):
    f.cache = {}
    def _f(*args, **kwargs):
        if args not in f.cache:
            f.cache[args] = f(*args, **kwargs)
        return f.cache[args]
    return _f
</code></pre>
<p>Then use it on your function, without the no longer needed <code>cache</code> parameter:</p>
<pre><code>@memo
def one_range(lower, higher):
    lst = []
    for i in range(lower,higher):
        lst.append(i)
    return lst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that your arguments are hashable, you can do this with <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache()</code></a> (Python 3.2+):</p>
<pre><code>import functools

@functools.lru_cache(maxsize=128)
def mrange(lower, higher):
    print('mrange was called')
    res = []
    for i in range(lower, higher):
        res.append(i)
    return res 
</code></pre>
<p>Smaller points:</p>
<ul>
<li>A dictionary is used to cache results, hence why both positional and keyword arguments must be hashable.</li>
<li>Try to avoid naming objects with names that shadow (mask) existing built-in names, such as <code>range</code> and <code>list</code>.</li>
<li>Use <code>mrange.cache_clear()</code> to clear the cache.</li>
</ul>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; mrange(1, 10)
mrange was called
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; mrange(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<span class="comment-copy">don't call your function <code>range</code>. You won't be able to call the original <code>range</code> from inside it...</span>
<span class="comment-copy">don't call your list <code>list</code> too...</span>
<span class="comment-copy">Thanks, corrected the code :)</span>
<span class="comment-copy">Caching a mutable object seems a bit dangerous - if any caller of your function modifies the returned list, future callers using the same parameters will get the modified version!</span>
<span class="comment-copy">good. Only one thing concerns me: we return a list, which can be modified by the caller, changing the value for all previous callers, which can have unexpected results (oh just saw jasonharper comment which states the same)</span>
<span class="comment-copy">@Jean-FrançoisFabre Good point. In the first approach, one could do <code>return list(cache[(lower, higher)])</code>; using a generic <code>@memo</code> decorator it would be a bit more involved.</span>
<span class="comment-copy">or return a tuple: done</span>
<span class="comment-copy">one other trick would be to do <code>def one_range(lower, higher, cache=dict()):</code> to use a mutable default argument as storage. For once it would be a good use of that "feature". The drawback is that the cache cannot be cleared that way</span>
<span class="comment-copy">@Jean-FrançoisFabre That's indeed a good idea, but given it's unintuitive behaviour can also be very very irritating, especially when new to Python, or even considered a bug by a teacher.</span>
<span class="comment-copy">Thank you for your answer. Unfortunately this is a university task and we can't use any additional tools.</span>
