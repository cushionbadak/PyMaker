<div class="post-text" itemprop="text">
<p>I know how to get a caller method name (from here: <a href="https://stackoverflow.com/questions/2654113/how-to-get-the-callers-method-name-in-the-called-method">How to get the caller's method name in the called method?</a>)</p>
<pre><code>import sys
print sys._getframe().f_back.f_code.co_name
</code></pre>
<p>What I'd like to get is the class name this method belongs to (assuming that it is in the class). 
So if:</p>
<pre><code>def get_some_info():
    print('Class name of caller:', XXX)

class Base:
     def my_method(self):
         get_some_info()

class A(Base):
     pass

class B(Base):
     pass

a = A()
b = B()
a.my_method()
b.my_method()
</code></pre>
<p>should return:</p>
<pre><code> ... A
 ... B
</code></pre>
<p>What should I do in <code>xxx</code>?</p>
<p>I tried (using info on <code>_getframe</code>) do something like:</p>
<pre><code> sys._getframe().f_back.f_code.__self__
</code></pre>
<p>but it doesn't work</p>
<p>UPDATE:</p>
<p>I cannot pass class name to a called function (otherwise that would be easy, but thanks to all who suggested this solution!)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get the calling frame object with <a href="https://docs.python.org/3/library/inspect.html#inspect.currentframe" rel="nofollow noreferrer"><code>inspect.currentframe()</code></a> and get the object that <code>self</code> is bound to through its <code>f_locals</code> attribute:</p>
<pre><code>import inspect

def get_some_info():
    # get the call frame of the calling method
    frame = inspect.currentframe().f_back
    try:
        # try to access the caller's "self"
        try:
            self_obj = frame.f_locals['self']
        except KeyError:
            return None

        # get the class of the "self" and return its name
        return type(self_obj).__name__
    finally:
        # make sure to clean up the frame at the end to avoid ref cycles
        del frame
</code></pre>
<p>The disadvantage of this is that it relies on the first parameter to be named "self". There are a few cases where we use different names, for example when writing a metaclass:</p>
<pre><code>class MyMeta(type):
    def __call__(cls, *args, **kwargs):
        get_some_info()  # won't work!
</code></pre>
<p>And if you have a function with a <code>self</code> variable, it can produce unexpected results:</p>
<pre><code>def not_a_method():
    self = 3
    print(get_some_info())  # output: int
</code></pre>
<p>We can solve both of these problems, but it takes a lot of work. We can inspect the name of the "self" parameter through the calling code object's <code>co_varnames</code> attribute. And in order to check whether the calling function is really a method defined in a class, we can loop through the <code>self</code>'s MRO and try to find the method that called us. The end result is this monstrosity:</p>
<pre><code>def get_some_info():
    # get the call frame of the calling method
    frame = inspect.currentframe().f_back
    try:
        # find the name of the first variable in the calling
        # function - which is hopefully the "self"
        codeobj = frame.f_code
        try:
            self_name = codeobj.co_varnames[0]
        except IndexError:
            return None

        # try to access the caller's "self"
        try:
            self_obj = frame.f_locals[self_name]
        except KeyError:
            return None

        # check if the calling function is really a method
        self_type = type(self_obj)
        func_name = codeobj.co_name

        # iterate through all classes in the MRO
        for cls in self_type.__mro__:
            # see if this class has a method with the name
            # we're looking for
            try:
                method = vars(cls)[func_name]
            except KeyError:
                continue

            # unwrap the method just in case there are any decorators
            try:
                method = inspect.unwrap(method)
            except ValueError:
                pass

            # see if this is the method that called us
            if getattr(method, '__code__', None) is codeobj:
                return self_type.__name__

        # if we didn't find a matching method, return None
        return None
    finally:
        # make sure to clean up the frame at the end to avoid ref cycles
        del frame
</code></pre>
<p>This should handle pretty much everything you throw at it correctly:</p>
<pre><code>class Base:
    def my_method(whatever):
        print(get_some_info())

    @functools.lru_cache()  # could be any properly implemented decorator
    def my_decorated_method(foo):
        print(get_some_info())

    @classmethod
    def my_class_method(cls):
        print(get_some_info())

class A(Base):
    pass

def not_a_method(self=3):
    print(get_some_info())

A().my_method()            # prints "A"
A().my_decorated_method()  # prints "A"
A.my_class_method()        # prints "None"
not_a_method()             # prints "None"
print(get_some_info())     # prints "None"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>inspect.stack()</code>:</p>
<pre><code>def get_some_info():
    _stack = inspect.stack()[1]
    print ('cls:', _stack[0].f_locals['self'].__class__.__name__, 'func:', _stack[3])

....

a = A()
b = B()
a.my_method()
b.my_method()
</code></pre>
<p>Prints:</p>
<pre><code>('cls:', 'A', 'func:', 'my_method')
('cls:', 'B', 'func:', 'my_method')
</code></pre>
</div>
<span class="comment-copy">Why don't you make your <code>get_some_info</code> a class method and print out the <code>self.__name__</code> variable? It should give you the class name....</span>
<span class="comment-copy">@toti08 or If its needs to be instance method he can call <code>self.__class__.__name__</code></span>
<span class="comment-copy">Wow your question is misleading. You aren't looking for the class where the calling method was defined. You're looking for the class of the <code>self</code> variable...</span>
<span class="comment-copy">@Aran-Fey: yes, that's why in an output I'd like to get, I mentioned that it should be <code>A</code> or <code>B</code>, not <code>Base</code></span>
<span class="comment-copy">Note that this won't work for classmethods and staticmethods (nor plain functions obviously)</span>
<span class="comment-copy">@brunodesthuilliers Well, the OP <i>is</i> looking for the type of <code>self</code>, so that's a given...</span>
<span class="comment-copy">@Aran-Fey indeed, but I thought it was worth mentionning nonetheless.</span>
<span class="comment-copy"><code>self</code> is not actually required to be called <code>self</code>, but I've never seen a case where it isn't, aside from exercises contrived to showcase the possibility. Well, that and metas.</span>
