<div class="post-text" itemprop="text">
<p>I want to create a dictionary of this format:</p>
<pre><code>mydic = {
    0: {'a': (20,10), 'b': 1, 'c': 0}, 
    1: {'a': (0,10), 'b': 1, 'c': 0}, 
    2: {'a': (4,5), 'b': 0, 'c': 0}, 
    3: {'a': (6,2), 'b': 0, 'c': 0}, 
    4: {'a': (1,4), 'b': 0, 'c': 1} 
}
</code></pre>
<p>Given four lists:</p>
<pre><code>node = [0,1,2,3,4]
a = [(20,10),(0,10),(4,5),(6,2),(1,4)]
b = [1,0,0,0,0]
c = [0,1,0,0,1]
</code></pre>
<p>Any help is appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>If the iterables are all the same length, you can use <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> with a <em>dict comprehension</em>:</p>
<pre><code>items = node, a, b, c
result = {n: {'a': a_, 'b': b_, 'c': c_} for n, a_, b_, c_ in zip(*items)}
# {0: {'a': (20, 10), 'b': 1, 'c': 0}, 1: {'a': (0, 10), 'b': 0, 'c': 1}, 2: {'a': (4, 5), 'b': 0, 'c': 0}, 3: {'a': (6, 2), 'b': 0, 'c': 0}, 4: {'a': (1, 4), 'b': 0, 'c': 1}}
</code></pre>
<p>Which can also be written like this:</p>
<pre><code>items = node, a, b, c
keys = 'a', 'b', 'c'
result = {x[0]: dict(zip(keys, x[1:])) for x in zip(*items)}
</code></pre>
<p>You could probably also use <a href="https://docs.python.org/3.3/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a> here:</p>
<pre><code>items = node, a, b, c
keys = 'a', 'b', 'c'
result = dict(map(lambda x: (x[0], dict(zip(keys, x[1:]))), zip(*items)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming your lists are all the same size, you just can loop through each index and create the key/value pair for each entry in the dict:</p>
<pre><code>node = [0,1,2,3,4]
a = [(20,10),(0,10),(4,5),(6,2),(1,4)]
b = [1,0,0,0,0]
c = [0,1,0,0,1]

assert(len(node) == len(a) == len(b) == len(c))  #Length should be equal

mydict = dict() # init empty dict

# Loops from 0 to len(node)
for i in range(len(node)):
    entry = {'a': a[i], 'b': b[i], 'c': c[i]}  # Creates dict object matching format
    mydict[node[i]] = entry  # Sets dict as value for each node item

print(mydict)
</code></pre>
<p>This outputs: </p>
<pre><code>{
  0: {'a': (20, 10), 'b': 1, 'c': 0}, 
  1: {'a': (0, 10), 'b': 0, 'c': 1}, 
  2: {'a': (4, 5), 'b': 0, 'c': 0}, 
  3: {'a': (6, 2), 'b': 0, 'c': 0}, 
  4: {'a': (1, 4), 'b': 0, 'c': 1}
}
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/" rel="nofollow noreferrer">docs.python.org/3/tutorial</a> you are welcome</span>
<span class="comment-copy">Why is the <code>1</code> key different then the rest? Seems like that comes out of nowhere. Also, do you have any attempted solutions? Please post what code you have tried.</span>
<span class="comment-copy">Typo sorry, fixed.</span>
<span class="comment-copy">Works, but I'm not a big fan of that <code>for a in a:</code> thing...</span>
<span class="comment-copy">@tobias_k Hmm, what would you rather do here instead?</span>
<span class="comment-copy">I just don't like "shadowing" the list by using the same name again. In older versions of Python, this may even "leak" out of a list comprehension, i.e. <code>a</code> would be an element of <code>a</code> afterwards (not from dict-comps, though, as it seems). Why not use <code>for a_ in a</code> or something like that?</span>
