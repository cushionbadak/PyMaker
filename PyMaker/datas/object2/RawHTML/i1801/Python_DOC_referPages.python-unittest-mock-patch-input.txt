<div class="post-text" itemprop="text">
<p>so i've got a problem with my code.
File 1:</p>
<pre><code>class Abc(object):
...
def function1(self):
 #do something
def function2(self):
 x = input()
 return x+1
</code></pre>
<p>and now i'm trying to test function 2 so i wrote a test for it and i don't know what i am doing wrong:</p>
<pre><code>from unittest.mock import patch
import unittest
from file1 import *

class TestBackend(unittest.TestCase):

    def test_mode_first(self):
        self.assertEqual(Abc().funcion1(), 30)

    @patch('funcion2.input', create=True)
    def test_mode_second(self, mocked_input):
        mocked_input.side_effect = ["QWE"]
        result = Abc().funcion2()
        self.assertEqual(result, 10)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>i get ModuleNotFoundError: No module named 'function2'
so what i am doing wrong in here?</p>
<p>thanks for your help :)</p>
</div>
<div class="post-text" itemprop="text">
<p>You get <code>ModuleNotFoundError</code> because <code>funcion2</code> is not a module. <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer"><code>patch doc</code></a> is clear about this:</p>
<blockquote>
<p>target should be a string in the form 'package.module.ClassName'. The
  target is imported and the specified object replaced with the new
  object, so the target must be importable from the environment you are
  calling patch() from. The target is imported when the decorated
  function is executed, not at decoration time.</p>
</blockquote>
<p>This works for me when executed with <code>python3 -m unittest discover</code> from the directory the files are in.</p>
<p>BTW you have a couple of typos in your example, e.g. <code>Abc().funcion2()</code>, note the missing <code>t</code> in <code>funcion2</code>.</p>
<p>Also, try not to use <code>from â€¦ import *</code>: <a href="https://docs.quantifiedcode.com/python-anti-patterns/maintainability/from_module_import_all_used.html#using-wildcard-imports-from-import" rel="nofollow noreferrer">https://docs.quantifiedcode.com/python-anti-patterns/maintainability/from_module_import_all_used.html#using-wildcard-imports-from-import</a></p>
<pre><code># file1.py
class Abc(object):
    def function1(self):
        return 30

    def function2(self):
        x = input()
        return x + "1"
</code></pre>
<p><br/></p>
<pre><code># test_file1.py
import unittest
from unittest.mock import patch
from file1 import Abc


class TestBackend(unittest.TestCase):
    def test_mode_first(self):
        self.assertEqual(Abc().function1(), 30)

    @patch('builtins.input')
    def test_mode_second(self, mocked_input):
        mocked_input.return_value = "QWE"

        result = Abc().function2()
        self.assertEqual(result, "QWE1")
</code></pre>
</div>
<span class="comment-copy">Please ask one question at a time.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/18161330/using-unittest-mock-to-patch-input-in-python-3">Using unittest.mock to patch input() in Python 3</a></span>
<span class="comment-copy">there is ImportError in your link and i get ModuleNotFoundError: no module named function2</span>
