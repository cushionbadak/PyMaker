<div class="post-text" itemprop="text">
<p>Is it possible to access exec-provided globals dictionary from within a function, if the function was defined outside of the exec-ed code (and thus already bound to different <code>__globals__</code>)?</p>
<p>In other words, is there a way to make the following example work?</p>
<pre><code>def f():
    log("Hi")

exec('f()', {'f': f, 'log': print})
</code></pre>
<p>In general, is it possible to substitute the <code>__globals__</code> of a function?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a pretty weird thing to do, but it's doable.</p>
<p>Your exec call executes the statement <code>f()</code> in the provided globals. It does not execute the <em>body</em> of <code>f</code> in the provided globals. The provided globals are being used in the wrong stack frame. To access those globals from <code>f</code>, you can use <a href="https://docs.python.org/3/library/inspect.html#inspect.currentframe" rel="nofollow noreferrer">stack inspection</a>:</p>
<pre><code>import inspect

def f():
    log = inspect.currentframe().f_back.f_globals['log']
    log('Hi')

exec('f()', {'f': f, 'log': print})
</code></pre>
<p>If you want to execute the body of <code>f</code> with the provided globals rather than just gaining access to the globals, you need to make a copy of <code>f</code> with your own custom globals:</p>
<pre><code>import types
my_f = types.FunctionType(f.__code__,
                          {'log': print},
                          f.__name__,
                          f.__defaults__,
                          f.__closure__)
my_f()
</code></pre>
<p>The function type constructor is sort of documented; it's not in the online docs, but it <em>is</em> documented in the function type's docstring:</p>
<pre class="lang-none prettyprint-override"><code>function(code, globals[, name[, argdefs[, closure]]])

Create a function object from a code object and a dictionary.
The optional name string overrides the name from the code object.
The optional argdefs tuple specifies the default argument values.
The optional closure tuple supplies the bindings for free variables.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if I am fully correct about the explanation. <strong>In short, the example cannot work in Python 3.</strong></p>
<p>The reason is in the combination of 2 circumstances: [1] - <code>exec</code> is a function in Python 3, [2] - the code you try to execute contains function call.</p>
<p>When you provide <code>globals</code> optional argument to the function <code>exec</code> it is local scope of this very function. So the following example works:</p>
<pre><code>exec('log("Hi")', {'log': print})
</code></pre>
<p>But the original one does not. Because in the original example you call the function <code>f</code>. It has its own local scope. What Python does? It checks global scope (actual global scope of the program) and innermost scope (local scope of the function <code>f</code>). Both scopes lack for <code>log</code> and you get <code>NameError</code>.</p>
<p>You can get the very same behavior (the same error) with two regular functions:</p>
<pre><code>def f():
    log("Hi")


def f_():
    log = print
    f()

f_()
</code></pre>
</div>
<span class="comment-copy">Unfortunately, you have not provided any context to the problem. So, why don't you use just <code>exec('log = print; f()')</code>? Then the example works.</span>
<span class="comment-copy">There could multiple contexts in which substituting globals of a function could be of interest. Suppose I'm interested in executing code within an environment, which provides new (or redefines existing) global functions or variables. And suppose I'd like these definitions to work for any outside code, pulled into the script via imports, for example.  In general, though, I'd be most interested in the answer to the question exactly as stated - "is it possible to access exec-provided globals somehow?"</span>
