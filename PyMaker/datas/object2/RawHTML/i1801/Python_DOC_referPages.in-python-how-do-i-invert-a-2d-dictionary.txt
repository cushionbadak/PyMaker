<div class="post-text" itemprop="text">
<p>I have a dictionary in the following form</p>
<pre><code>dict = {
   "a" : {"a1" : 1},
   "b" : {"a2" : 1, "a3" : 2},
   "c" : {"a2" : 3, "a4" : 3}
}
</code></pre>
<p>and I need the reverse index dictionary, in this form:</p>
<pre><code>inverseDict = {
    "a1" : {"a" : 1},
    "a2" : {"b" : 1, "c" : 3},
    "a3" : {"b" : 2},
    "a4" : {"c" : 3}
}
</code></pre>
<p>Basically</p>
<pre><code>inverseDict = {dict.value.key : { dict.key : dict.value.value}}
</code></pre>
<p>So essentially, I need the keys of the values as keys, and the keys as keys of values, while at the same time joining results for duplicate new keys etc.</p>
<p>I've tried to do </p>
<pre><code>ks = dict.keys()
vals = dict.values()

ks2 = vals.keys()
vals2 = vals.values()
</code></pre>
<p>if this makes any sense</p>
<p>But I'm getting an error </p>
<pre><code>'dict_values' object has no attribute 'keys'
</code></pre>
<p>Which from what I understand is because dict.values() .keys() .items() return "views" instead of the actual element itself, but I don't know hot to go about fixing this problem.</p>
<p>Also is there a more efficient solution I should consider, because my actual dict is pretty large (~10k keys), and the resulting inverse dict will also be large  ( &gt;3k keys)</p>
</div>
<div class="post-text" itemprop="text">
<p>using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict(dict)</code></a> and a double loop it's rather easy:</p>
<pre><code>d = {
    "a" : {"a1" : 1},
    "b" : {"a2" : 1, "a3" : 2},
    "c" : {"a2" : 3, "a4" : 3},
}

import collections

inverted = collections.defaultdict(dict)

for key,subd in d.items():
    for k,v in subd.items():  # no inspiration for key/value names...
        inverted[k][key] = v
</code></pre>
<p><code>inverted</code> is</p>
<pre><code>{'a1': {'a': 1},
 'a2': {'b': 1, 'c': 3},
 'a3': {'b': 2},
 'a4': {'c': 3}}
</code></pre>
<p>using <code>defaultdict</code> avoids to test if the entry already exists &amp; creates a dictionary-value if it doesn't. So, just add the key/values brainlessly in the expected order.</p>
<p>Note that those problems where you need to deal items into several objects are hardly solved using comprehensions.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer">setdefault</a>:</p>
<pre><code>d = {
    'a': {'a1': 1},
    'b': {'a2': 1, 'a3': 2},
    'c': {'a2': 3, 'a4': 3}
}

result = {}
for ok, vs in d.items():
    for ik, v in vs.items():
        result.setdefault(ik, {})[ok] = v

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'a4': {'c': 3}, 'a1': {'a': 1}, 'a2': {'c': 3, 'b': 1}, 'a3': {'b': 2}}
</code></pre>
<p>The function <code>setdefault</code> has a similar effect to the usage of <code>defaultdict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution sans standard lib... But Jean-Francois Fabre's answer is more concise and probably easier to modularize. When in doubt, use the standard lib.</p>
<pre><code>OriginalDict = ... (Original dict items)
InvertedDict = {}
for k, v in OriginalDict.items():
    for k_, v_ in v.items():
        if InvertedDict.get(k_) is None:
            InvertedDict[k_] = {}
        InvertedDict[k_][k] = v_
</code></pre>
</div>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/44570561/how-can-i-correct-the-error-attributeerror-dict-keys-object-has-no-attribut" title="how can i correct the error attributeerror dict keys object has no attribut">stackoverflow.com/questions/44570561/â€¦</a></span>
<span class="comment-copy">Just a quick comment, you'll want to avoid using the builtin keyword <code>dict</code> for assignment.  You'll end up shadowing the <code>dict</code> builtin object.</span>
<span class="comment-copy">@Idlehands well it's not the actual name of my <code>dict</code>, just a "dummy" name. but yeah I see your point</span>
<span class="comment-copy">Well it most definitely works but I don't understand why <code>inverted=collections.defaultdict(dict)</code> is better that just using a <code>inverted = {}</code>.</span>
<span class="comment-copy">because with a bare dict you have to test if dict already exists and create it if not: more lines, and slower. You can convert it back to <code>dict</code> if you want: <code>inverted = dict(inverted)</code></span>
<span class="comment-copy">but in both cases you create an empty <code>inverted</code> and go on to fill it up with values? am I not getting something?</span>
<span class="comment-copy">with a default dict, just doing <code>inverted["a_key"]</code> <i>creates</i> a dictionary under <code>a_key</code> key if doesn't exist. You don't have to worry about initialization of the dict.</span>
<span class="comment-copy">good solution. The only drawback is that it creates an empty dict object even if the key is found. <code>setdefault</code> is better when used with immutable objects that are more likely to be interned, or created once and stored in a variable that <code>setdefault</code> can reference</span>
<span class="comment-copy">not bad, but why repeating <code>InvertedDict[k_][k] = v_</code> in the if and outside it?</span>
<span class="comment-copy">D'oh. I forgot a line. *Fixed.</span>
<span class="comment-copy">Yep. That'll look better.</span>
