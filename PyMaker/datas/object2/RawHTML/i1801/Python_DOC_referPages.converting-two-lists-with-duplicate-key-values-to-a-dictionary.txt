<div class="post-text" itemprop="text">
<pre><code>list1 = ['10/20/2008', '3/25/2009', '3/26/2009', '3/28/2009', '3/28/2009', '8/23/2009', '8/23/2009']
list2 = [0,0,0,0,1,0,0]
</code></pre>
<p>I want my output to look like this:</p>
<pre><code>{'10/20/2008': 0, '3/25/2009':0, '3/26/2009': 0, '3/28/2009': [0,1], '8/23/2009': [0,0]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer">setdefault</a>:</p>
<pre><code>list1 = ['10/20/2008', '3/25/2009', '3/26/2009', '3/28/2009', '3/28/2009', '8/23/2009', '8/23/2009']
list2 = [0, 0, 0, 0, 1, 0, 0]

result = {}
for k, v in zip(list1, list2):
    result.setdefault(k, []).append(v)

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'3/28/2009': [0, 1], '3/26/2009': [0], '10/20/2008': [0], '3/25/2009': [0], '8/23/2009': [0, 0]}
</code></pre>
<p>If you want the list of a single item, to be just the single item do this:</p>
<pre><code>result = {k: v[0] if len(v) == 1 else v for k, v in result.items()}
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'3/25/2009': 0, '3/26/2009': 0, '8/23/2009': [0, 0], '10/20/2008': 0, '3/28/2009': [0, 1]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach is to use <code>defaultdict</code> as follows:</p>
<pre><code>from collections import defaultdict
res_dict = defaultdict(list)

for k, v in zip(list1, list2):
    res_dict[k].append(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not exactly a list-only implementation but should do the work.</p>
<pre><code>import numpy as np
listToDict=dict()
npList1=np.array(list1)
npList2=np.array(list2)
for date in set(list1):
    listToDict[date]=list(npList2[[np.where(npList1 == date)[0]]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the python built-in <code>groupby</code>.</p>
<pre><code>from itertools import groupby

list1 = ['10/20/2008', '3/25/2009', '3/26/2009', '3/28/2009', '3/28/2009', '8/23/2009', '8/23/2009']
list2 = [0, 0, 0, 0, 1, 0, 0]

# Zip and sort the list in order to use them with groupby
list3 = [(x, y) for x, y in zip(list1, list2)]
list3.sort()

result = {}

# Group by date.
for value, grouper in groupby(list3, lambda x: x[0]):
    # key_value has the form (date, zero_or_one)
    key_value = grouper.next()
    # Populate result according requirements. 
    result[value] = key_value[1]
    # If more than one value for date, use a list.
    for index, kv in enumerate(grouper):
        if index == 0:
            result[value] = [result[value], kv[1]]
        else:
            result[value].append(value)

print result
</code></pre>
<p>Result:</p>
<pre><code>{'8/23/2009': [0, 0], '3/26/2009': 0, '3/28/2009': [0, 1], '3/25/2009': 0, '10/20/2008': 0}
</code></pre>
</div>
<span class="comment-copy">How firm are you on the requirement that all the unique values should be ints, and the duplicate values should be lists? There are some rather elegant solutions that become available if you're willing for <i>all</i> the values to be lists. The unique ones would simply have a length of 1.</span>
<span class="comment-copy">Doesn't <i>quite</i> match the OP's desired output, since <code>res_dict['10/20/2008']</code> gives <code>[0]</code> rather than <code>0</code>. Also, I think you meant <code>from collections import defaultdict</code>.</span>
<span class="comment-copy">@Kevin both observations are correct, regarding the first one I assumed that it was flexible on this, as you asked to the OP. And regarding your second observation, you are right, thanks!</span>
