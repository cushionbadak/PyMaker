<div class="post-text" itemprop="text">
<p>The following code works in Python 2.7 with <code>_x.__dict__['c']=8</code></p>
<pre><code>class _x:
    def __init__(self):
        self.a = 6
        self.b = 7
        _x.__dict__['c']=8
        print("good!")

y=_x()
print(y.__dict__)
print(_x.__dict__)
</code></pre>
<p>Output:</p>
<pre><code>good!
{'a': 6, 'b': 7}
{'c': 8, '__module__': '__main__', '__doc__': None, '__init__': &lt;function __init__ at 0x00000000049227B8&gt;}
</code></pre>
<p>The above code does not work in Python 3.6 with
<code>_x.__dict__['c']=8</code> and got errors:</p>
<pre><code>TypeError                             Traceback (most recent call last)
&lt;ipython-input-5-b4146e87f5a4&gt; in &lt;module&gt;()
      6         print("good!")
      7 
----&gt; 8 y=_x()
      9 print(y.__dict__)
     10 print(_x.__dict__)

&lt;ipython-input-5-b4146e87f5a4&gt; in __init__(self)
      3         self.a = 6
      4         self.b = 7
----&gt; 5         _x.__dict__['c']=8
      6         print("good!")
      7 

TypeError: 'mappingproxy' object does not support item assignment
</code></pre>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Is there any reason you're trying to use non-public interface? If for some reason you want to set class attribute during instantiation, try</p>
<pre><code>class A:
    def __init__(self):
        self.__class__.k = 1
</code></pre>
<p>If you want to set access dynamically, use <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer"><code>setattr</code></a></p>
<p>Reasoning behind mutability changes described in <a href="https://stackoverflow.com/a/32720603/2161778">this answer</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can set a class variable by specifying the class name before the variable name.</p>
<p>Change:</p>
<pre><code>_x.__dict__['c']=8
</code></pre>
<p>to:</p>
<pre><code>_x.c=8
</code></pre>
</div>
<span class="comment-copy">Why do you want to go through <code>__dict__</code>? Do you just not know about <code>setattr</code>?</span>
<span class="comment-copy">Why are you doing this? It's usually a very bad idea for new construction to just set values on the class (the rare case where it makes sense is when you're numbering instances or the like, but in that case, the class variable should be defined with a base value at definition time). This smells <a href="https://meta.stackexchange.com/q/66377/322040">like an XY problem</a>.</span>
<span class="comment-copy">found a solution:  <code>_x.c = 8</code>  works.</span>
<span class="comment-copy">user2357112, ShadowRanger:  I am converting a python application (by another author) from 2 to 3. Just want to make it work right now and figure out "why" later. Thanks for your comments.</span>
<span class="comment-copy">Note: This will differ behaviorally if <code>A</code> is subclassed; the OP's approach would always set the attribute on <code>A</code>, while this will set the attribute on the subclass if applicable. Plain <code>A.k = 1</code> (or as a sneaky approach only valid on Python 3+, and dependent on CPython implementation details, <code>__class__.k = 1</code>) would match the OP's design.</span>
<span class="comment-copy">Correct, directly setting is an option too, but it's even less viable in proper interfaces, IMO.</span>
<span class="comment-copy">Thanks  a lot for your help, Slam.</span>
<span class="comment-copy">blhsing, Thanks.</span>
<span class="comment-copy">Glad to be of help. Can you mark this answer as accepted if you find it to be correct? (Click on the grey check mark next to the answer.)</span>
