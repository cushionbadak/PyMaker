<div class="post-text" itemprop="text">
<p>I am a new learner with python and right now my code stimulates rolling <strong>one</strong> dice 1,000 times, however I just need some improvement to make it stimulate rolling <strong>two</strong> dice 1,000 times.</p>
<p>Here is what I have so far which is working perfectly just need some improvement:</p>
<pre><code>import random
test_data = [0, 0, 0, 0, 0, 0]
n = 1000
for i in range(n):
  result = random.randint(1, 6)
  test_data[result - 1] = test_data[result - 1] + 1

for i in range(0, 6):
  print ("Number of ", i+1, "'s: ", test_data[i])
</code></pre>
<p>Any suggestions on how to get two dice rolling and get the similar output as what my code is doing right now which is this:</p>
<pre><code>Number of  1 's:  180

Number of  2 's:  161

Number of  3 's:  179

Number of  4 's:  159

Number of  5 's:  146

Number of  6 's:  175
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In that case the outcome are numbers between <code>2</code> and <code>12</code>. For simplicity it is better however to probably maintain the first index.</p>
<p>The <code>test_data</code> list thus needs to be increased to store <code>12</code> items, and as <code>result</code> we should call <code>random.randint(1, 6)</code> <em>twice</em> (not times two), and add these together:</p>
<pre><code>import random

test_data = [0] <b>* 12</b>
n = 1000
for i in range(n):
  # adding up two dices
  result = random.randint(1, 6) <b>+ random.randint(1, 6)</b>
  test_data[result - 1] <b>+= 1</b>

for i, x in <b>enumerate(</b>test_data<b>, 1)</b>:
  print ("Number of ", i, "'s: ", x)</code></pre>
<p>It is also more elegant to write <code>+= 1</code> here, instead of <code>= ... + 1</code>, since here we avoid writing <code>test_data[result - 1]</code> twice. Furthermore in Python one typically enumerates over the collection directly, not over the indices. One can use <code>enumerate(iterable, start_index)</code> to generate an iterable of 2-tuples <code>(i, n)</code> with <code>i</code> the index, and <code>x</code> the element of the collection that is related to that index.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a solution for two indistinguishable dice, meaning that throwing a 1 and a 3 is treated identical to a 3 and a 1. In this approach we use a <code>dict</code> instead of a <code>list</code>, because for two (or more!) indistinguishable dice the list would have "holes" (combinations like 3, 1 that can never occur because we treat them like 1, 3).</p>
<pre><code>import random

counts = {}
for _ in range(1000):
    dice = tuple(sorted([random.randint(1, 6), random.randint(1, 6)]))
    counts[dice] = counts.get(dice, 0) + 1
</code></pre>
<p><code>dice</code> is now both dice, sorted so that 3, 1 is treated as 1, 3, and converted from a list into a tuple (basically an immutable list) so we can use it as key for a dictionary (<code>counts</code>). Then we just increase the count for that particular combination of dice.</p>
<p>Unlike the list, the dictionary is not sorted, but we do want a nice output sorted by what the dice showed, so we sort by the keys = dice:</p>
<pre><code>for dice in sorted(counts.keys()):
    print("{} occurred {} times".format(dice, counts[dice]))
</code></pre>
<p>This gives you:</p>
<pre><code>(1, 1) occurred 22 times
(1, 2) occurred 53 times
(1, 3) occurred 47 times
(1, 4) occurred 55 times
(1, 5) occurred 55 times
(1, 6) occurred 50 times
(2, 2) occurred 27 times
(2, 3) occurred 64 times
(2, 4) occurred 58 times
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>numpy</code>, and this solution allows you to specify any number of dice:</p>
<pre><code>import numpy as np

no_of_dice = 2
sides_on_die = 6
rolls = 1000
dice = np.array([0]*rolls)

for i in range(no_of_dice):
    dice += np.random.randint(1,sides_on_die+1,rolls)
data = np.bincount(dice)

for i in range(no_of_dice,no_of_dice*sides_on_die+1):
    print ("Number of ", i, "'s: ", data[i])
</code></pre>
<p>Yields:</p>
<pre><code>Number of  2 's:  26
Number of  3 's:  55
Number of  4 's:  100
Number of  5 's:  106
Number of  6 's:  139
Number of  7 's:  152
Number of  8 's:  135
Number of  9 's:  104
Number of  10 's:  87
Number of  11 's:  64
Number of  12 's:  32
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are allowed to use other python modules then <code>random</code> you can leverage <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a> to do your counting. By switching from <code>random.randint()</code> to <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer">random.choices</a> you can throw both dices at once:</p>
<pre><code>import random
from collections import Counter


def roll_n_dice_of_sides_x_times(n,x,sides=6):
    """Rolls 'n' dices with 'sides' sides 'x' times. Yields 'x' values that 
    hold the sum of the 'x' dice rolls.""" 
    r = range(1,sides+1)
    yield from (sum(random.choices(r,k=n)) for _ in range(x))

# this does allthe counting and dice throwingof 1000 2-6sided-dice-sums
c = Counter(roll_n_dice_of_sides_x_times(2,1000))

# print the sorten (key,value) tuples of the Counter-dictionary. Sort by 
# how much eyes thrown, then amount of occurences
for eyes,count in sorted(c.items()):
    print(f"Number of {eyes:&gt;3}'s : {count}")
</code></pre>
<p>Output:</p>
<pre><code>Number of   2's : 24
Number of   3's : 51
Number of   4's : 66
Number of   5's : 115
Number of   6's : 149
Number of   7's : 182
Number of   8's : 153
Number of   9's : 116
Number of  10's : 68
Number of  11's : 58
Number of  12's : 18
</code></pre>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a>
<ul>
<li>its a dictionary - you feed it an iterable and int counts how often each element of the iterable occurs:</li>
</ul></li>
</ul>
<pre><code>        print(Counter( [1,2,2,3,3,3,4,4,4,4] ) )

        # Counter({4: 4, 3: 3, 2: 2, 1: 1})
</code></pre>
<ul>
<li><a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer">random.choices</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow noreferrer">literal string interpolation (f-strings)</a></li>
<li><a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">generators</a></li>
</ul>
<hr/>
<p>If instead you wanted the single dice results, you can modify the code to not sum dices but instead deliver the tuples when generating the random numbers. I sorted them, so that (5,4,5) is the same throw as (4,5,5):</p>
<pre><code>import random
from collections import Counter

def roll_n_dice_of_sides_x_times_no_sum(n,x,sides=6):
    """Rolls 'n' dices with 'sides' sides 'x' times. Yields a sorted tuple 
    of the dice throwsof all  'x' dice rolls.""" 
    r = range(1,sides+1)

    # instead of summing, create a tuple (hashable, important for Counter)
    # and return that sorted, so that 4,4,5 == 5,4,4 == 4,5,4 throw:
    yield from ( tuple(sorted(random.choices(r,k=n))) for _ in range(x))

# throw 3 6-sided dice 1000 times and count:
c = Counter(roll_n_dice_of_sides_x_times_no_sum(3,1000))

# print the sorten (key,value) tuples of the Counter-dictionary. Sort by 
# how much eyes thrown, then amount of occurences
for dice,count in sorted(c.items()):
    print(f"{dice} occured {count} times")
</code></pre>
<p>Output (shortened):</p>
<pre><code>(1, 1, 1) occured 3 times
(1, 1, 2) occured 14 times
[...] 
(2, 3, 5) occured 32 times
(2, 3, 4) occured 21 times
[...]
(4, 6, 6) occured 10 times
(5, 5, 5) occured 3 times
(5, 5, 6) occured 20 times
(5, 6, 6) occured 9 times
(6, 6, 6) occured 4 times
</code></pre>
</div>
<span class="comment-copy">No, I simply need the program to roll two dice so that later I can program it where when two threes are rolled it prints "Double 3's were rolled...times" So i just need to figure out how to get two dice rolling if that makes sense?</span>
