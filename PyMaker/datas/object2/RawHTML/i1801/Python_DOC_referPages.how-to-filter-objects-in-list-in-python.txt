<div class="post-text" itemprop="text">
<p>I am using python 3.6. to create two lists. I want to filter it if all of the instances attribute values are the same.</p>
<p>I wrote this code, but it returns false.
How to filter it?</p>
<pre><code>class MyCls:
    def __init__(self, **kwargs):
        self.x = kwargs.get('x')
        self.y = kwargs.get('y')
        self.z = kwargs.get('z')

    def __str__(self):
        return str(self.__dict__)

    def __hash__(self):
        return hash(str(self.__dict__))

    def __eq__(self, other):
        return str(self.__hash__) == str(other.__hash__)


a = MyCls(x='a', y='b', z='c')
b = MyCls(x='a', y='b', z='c')

ab = [a, b]

print(a is b)
# False
print(a == b)
# False

s = set(ab)
print(s)
# print(2 instances)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm answering on the premise that you are playing around with <code>__hash__</code> and <code>__eq__</code> for educational purposes.</p>
<p>I find your hashing and equality methods... weird. </p>
<p>Anyway, the concrete problem with your code is that <code>__eq__</code> does not call the <code>__hash__</code> method.</p>
<p>You can use</p>
<pre><code>return str(self.__hash__()) == str(other.__hash__())
</code></pre>
<p>in <code>__eq__</code> - or better (but still weird)</p>
<pre><code>return hash(self) == hash(other)
</code></pre>
<p>With this adjustment you get</p>
<pre><code>&gt;&gt;&gt; hash(a)
&gt;&gt;&gt; 8280333490847949293
&gt;&gt;&gt; hash(b)
&gt;&gt;&gt; 8280333490847949293
&gt;&gt;&gt; a == b
&gt;&gt;&gt; True
</code></pre>
<p>However, a fundamental flaw with this design is that an instance of <code>MyClass</code> will compare equal with any other object that hashes the same by accident.</p>
<pre><code>&gt;&gt;&gt; class C:
...:    def __hash__(self):
...:        return 8280333490847949293
...:    
&gt;&gt;&gt; C() == a
&gt;&gt;&gt; True
</code></pre>
<p>If you want to compare instance attributes, why not compare the instance dicts directly?</p>
</div>
<span class="comment-copy">the hash of an object should be constant for it's whole lifetime - else some things will break in some unexpected ways (cf <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__hash__</a>: <i>"If a class defines mutable objects and implements an __eq__() method, it should not implement __hash__(), since the implementation of hashable collections requires that a key’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket)."</i>)</span>
<span class="comment-copy">Thanks I understood my mistake. but how to compare instances dicts directly?</span>
<span class="comment-copy">@rootpetit you can access an instance <code>dict</code> with <code>my_object.__dict__</code> or <code>vars(my_object)</code> and compare dictionaries with <code>==</code>. Remember that instances of two different classes can still have equal <code>__dict__</code> attributes, so you probably also need an <code>isinstance</code> check.</span>
<span class="comment-copy">Thanks a lot! I have to fix <code>__eq__</code> to check <code>isinstance of MyCls</code> and <code>return self.__dict__ == other.__dict__</code> to compare attribute (and remove <b>hash</b>).</span>
<span class="comment-copy">@rootpetit you're welcome! If you want to put your objects into a set, they need to be hashable. Have a look at <a href="https://stackoverflow.com/questions/10994229/how-to-make-an-object-properly-hashable">this</a> question.</span>
<span class="comment-copy">I think usecase, and If I use it with set, I implement above class <b>hash</b>. Thanks!</span>
