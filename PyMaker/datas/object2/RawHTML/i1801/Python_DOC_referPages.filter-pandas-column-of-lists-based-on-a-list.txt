<div class="post-text" itemprop="text">
<p>Having a large <code>DataFrame</code> as follows:</p>
<pre><code>userid    user_mentions
1         [2, 3, 4]
1         [3]
2         NaN
2         [1,3]
3         [1,4,5]
3         [4]
</code></pre>
<p>The <code>user_mentions</code> columns is a list of <code>userid</code>s that have been mentioned by each user. For example, the first line means:</p>
<p>user 1 has mentioned users 2, 3, and 4.</p>
<p>I need to create a mention network among the users in the <code>userid</code> column. That is, I want the number of times each user in the <code>userid</code> column has been mentioned by other users in the <code>userid</code> column. So basically, first I need something like this:</p>
<pre><code>filtered = df[df['user_mentions'].isin(df['userid'].unique())]
</code></pre>
<p>But this doesn't work on a column of lists.</p>
<p>If I resolve the above issue, then I can <code>groupby['userid','user_mentions']</code>.</p>
<p><strong>EDIT</strong> </p>
<p>The final output should be:</p>
<pre><code>Source    Target    Number
1         2         1
1         3         2
2         1         1
2         3         1
3         1         1
3         5         1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This isn't a task well suited to Pandas / NumPy. So I suggest you use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> to create a dictionary of counts, then construct a dataframe from the dictionary:</p>
<pre><code>from collections import defaultdict

dd = defaultdict(lambda: defaultdict(int))

for row in df.itertuples(index=False):
    vals = row.user_mentions
    if vals == vals:
        for val in vals:
            dd[row.userid][val] += 1

df = pd.DataFrame([(k, w, dd[k][w]) for k, v in dd.items() for w in v],
                  columns=['source', 'target', 'number'])

print(df)

   source  target  number
0       1       2       1
1       1       3       2
2       1       4       1
3       2       1       1
4       2       3       1
5       3       1       1
6       3       4       2
7       3       5       1
</code></pre>
<p>Of course, you shouldn't put lists in Pandas series in the first place. It's a nested layer of pointers, which should be avoided if at all possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>Following your edit, I would have to agree with @jpp.</p>
<p>To your (unedited) original question, in terms of gathering the number of mentions of each user, you can do:</p>
<pre><code>df['counts'] = df['userid'].apply(lambda x: df['user_mentions'].dropna().sum().count(x))

df[['userid','counts']].groupby('userid').first()
</code></pre>
<p>Yields:</p>
<pre><code>        counts
userid        
1            2
2            1
3            3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way.</p>
<pre><code># Remove the `NaN` rows
df = df.dropna()

# Construct a new DataFrame
df2 = pd.DataFrame(df.user_mentions.tolist(), 
                   index=df.userid.rename('source')
                  ).stack().astype(int).to_frame('target')

# Groupby + size
df2.groupby(['source', 'target']).size().rename('counts').reset_index()

   source  target  counts
0       1       2       1
1       1       3       2
2       1       4       1
3       2       1       1
4       2       3       1
5       3       1       1
6       3       4       2
7       3       5       1
</code></pre>
</div>
<span class="comment-copy">You just completely changed your input dataframe....</span>
<span class="comment-copy">@rahlf23 user 1 has mentioned user 3 once in the first line and once in the second line. So user 1 has mentioned user 3 two times (corresponds to the second line of the output)</span>
<span class="comment-copy">@rahlf23 sorry, the question was vague. Just edited</span>
