<div class="post-text" itemprop="text">
<p>Only the first print command works. I cannot figure out why. I want to display a different prefix and suffix depending on what is passed in.</p>
<pre><code># We are going to have a word and a prefix or a suffix before or after
# that word

def joinWords(string, **sFox):
    if sFox['prefix']: 
        return sFox['prefix'] + string
    elif sFox['suffix']: 
        return string + sFox['suffix']
    return string




#Why does this work?
#print(joinWords("Cookie", prefix="sugar"))

#And this does not?
#print(joinWords("Cookie", suffix="monster"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Referencing to a key that <code>sFox</code> does not have will raise an error.</p>
<p>Also, current code seems to only select the prefix even though suffix and prefix are both provided.</p>
<p>Looping through a <code>(key, value)</code> pair of the <code>sFox</code>, you might want to change your code as follows.</p>
<pre><code>def joinWords(string, **sFox):
    for key, value in sFox.items():
        if key == 'prefix':
            string = value + string
        elif key == 'suffix':
            string = string + value
    return string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem you're having is, <code>kwargs</code> will NOT contain keys that are not specified. When you try to index a non-existent key of a dictionary, it will raise a <code>KeyError</code>,</p>
<p>The most straightforward solution is to check if the key exists before trying to access it:</p>
<pre><code>    if 'prefix' in sFox and sFox['prefix']:
</code></pre>
<p>There are also better Pythonic way to do this. As mentioned, <code>dict.get()</code> is a decent option for a default value:</p>
<pre><code>    if sFox.get('prefix'):
</code></pre>
<p>This way, if <code>prefix'</code> is not in the dictionary, the value will be <code>None</code> which evaluates to boolean false and perfectly does the trick.</p>
<p>Of course, if you don't really need random keyword arguments, try default arguments:</p>
<pre><code>def joinWords(string, prefix=None, suffix=None):
    if prefix:
        return prefix + string
    elif suffix: 
        return string + suffix
    return string
</code></pre>
<p>IMO this might be a better solution unless you're trying to learn about keyword argument packs.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is you use <code>sFox['prefix']</code>, It will raise key error when you don't pass key parameter prefix in  calling <code>print(joinWords("Tits", suffix="monster"))</code>.</p>
<p>To fix it you can use <code>sFox.get('prefix')</code>, it will return default None when you don't pass prefix keyword paramter.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sFox['prefix']</code> will return the item with key <code>prefix</code> in sFox if it exist, or else raise an <code>KeyError</code>.</p>
<p>Even worse, <code>if sFox['prefix']:</code> might still not execute your code even if <code>prefix</code> <em>does</em> exist in <code>sFox</code>, since <code>sFox['prefix']</code> might store the value <code>False</code>.</p>
<p>I think what you're actually trying to do with this line is to test if <code>sFox</code> <em>contains</em> an item with key <code>prefix</code>. In Python, the syntax <code>[key] in [dict]</code> is used for that. </p>
<p>Your program rewritten in it would look like this:</p>
<pre><code>def joinWords(string, **sFox):
    if `prefix` in sFox:
        return sFox['prefix'] + string
    elif `suffix` in sFox:
        return string + sFox['suffix']
    return string
</code></pre>
<p>Now to answer your other question: Only the first part ever gets executed since you <code>return</code> in that part, i.e., leave the function. If you want both parts to execute, you must return only after you've added your suffixes and prefixes. Here's an example:</p>
<pre><code>def joinWords(string, **sFox):
    if `prefix` in sFox:
        string = sFox['prefix'] + string
    if `suffix` in sFox: # Notice only "if" not "elif"
        string =  string + sFox['suffix']
    return string
</code></pre>
<p>Finally, to add a bit of syntactic sugar to the mix - take a look at <a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">python default parameter values</a>. With those you can define your function like this:</p>
<pre><code>def joinWords(string, suffix="", postfix=""):
    return suffix + string + postfix
</code></pre>
</div>
<span class="comment-copy">change to  <code>def joinWords(string, **sFox):     if sFox.get('prefix'):          return sFox['prefix'] + string     if sFox.get('suffix'):          return string + sFox['suffix']     return string</code></span>
<span class="comment-copy"><code>sFox[keyword]</code> will generate an error if the keyword does not exist, instead you should use <code>get()</code>, otherwise do not use elif since prefix and suffix are not mutually exclusive</span>
<span class="comment-copy"><code>if sFox['prefix']</code> is not the correct way to check if the key exists.  If that is what you are trying to do, use <code>if 'prefix' in sFox</code> instead.</span>
<span class="comment-copy">error is very much from begin false.  false is just a value, but error makes your program die.</span>
<span class="comment-copy">Ok, I get it. It's like a variable that was never defined. Since I ran the function multiple times. It was checking for something that was not there in the particular command. Then an error resulted.</span>
