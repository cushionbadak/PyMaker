<div class="post-text" itemprop="text">
<p>I am trying to create a list of dictionary with the lists below. </p>
<pre><code>a = [["Name","Mary","Tom","John"],["Age","21","23","12"],["Gender","F","M","M"]]
</code></pre>
<p>I would like the output to be:</p>
<pre><code>a_list=[{"Name":"Mary", "Age":"21", "Gender":"F"},{"Name":"Tom", "Age":"23", "Gender":"M"},{"Name":"John", "Age":"12", "Gender":"M"}]
</code></pre>
<p>I tried to use <code>zip</code> but could not get it to work. Please help! </p>
</div>
<div class="post-text" itemprop="text">
<p>First we can pull the header entries out so we're left with just the values:</p>
<pre><code>headers, values = zip(*((x[0], x[1:]) for x in a))
print(headers, values)
# ('Name', 'Age', 'Gender') (['Mary', 'Tom', 'John'], ['21', '23', '12'], ['F', 'M', 'M'])
</code></pre>
<p>Then we can <code>zip</code> together the values, then <code>zip</code> each of those triples with <code>headers</code> to form the dictionaries:</p>
<pre><code>print([dict(zip(headers, triple)) for triple in zip(*values)])
# [{'Name': 'Mary', 'Age': '21', 'Gender': 'F'}, {'Name': 'Tom', 'Age': '23', 'Gender': 'M'}, {'Name': 'John', 'Age': '12', 'Gender': 'M'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a_list = []
for i in range(1, len(a[0])):
    diction = {}
    diction[a[0][0]] = a[0][i]
    diction[a[1][0]] = a[1][i]
    diction[a[2][0]] = a[2][i]
    a_list.append(diction)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>list(map(dict, zip(*([(k, i) for i in v] for k, *v in a))))
</code></pre>
<p>This returns:</p>
<pre><code>[{'Name': 'Mary', 'Age': '21', 'Gender': 'F'}, {'Name': 'Tom', 'Age': '23', 'Gender': 'M'}, {'Name': 'John', 'Age': '12', 'Gender': 'M'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a simple solution that I would recommend:</p>
<pre><code>zipped_a = zip(*a)
keys = next(zipped_a)
dicts = [dict(zip(keys, values)) for values in zipped_a]
</code></pre>
<p>Another way to pull keys out of the <code>a_zipped</code> iterator is by using it in nested loops.  The first iteration of the outer loop grabs the keys, while the inerloop grabs each set of values. Unfortunately, this approach is not obvious on first glance:</p>
<pre><code>a_zipped = zip(*a)
dicts = [dict(zip(keys, values)) for keys in a_zipped for values in a_zipped]
</code></pre>
<p>And yet another way to pull out keys from <code>zip(*a)</code> is to use <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">iterable unpacking</a>.  It's clear, but it does create an extra list (<code>all_values</code>):</p>
<pre><code>keys, *all_values = zip(*a)
dicts = [dict(zip(keys, values)) for values in all_values]
</code></pre>
<p>An then there's this silly one-liner:</p>
<pre><code>dicts = [dict(zip(k, v)) for k, *zv in [zip(*a)] for v in zv]
</code></pre>
<hr/>
<h3>Original Answer:</h3>
<p>Sometimes a multiline solution can be really straight forward:</p>
<pre><code># make an iterator for each list
iters = list(map(iter, a))
# pull off first item from each iterator to use as keys        
keys = list(map(next, iters))
# zip the iterators so they are grouped as values, 
# then zip keys and values to make tuples for dict constructor
dicts = [dict(zip(keys, values)) for values in zip(*iters)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use <code>pandas</code> for this, which is more "declarative" in the sense that we specify <em>what</em> we do, and not much <em>how</em> we do that:</p>
<pre><code>import pandas as pd

result = pd.DataFrame({k: v for k, *v in a}).to_dict('records')
</code></pre>
<p>for the given <code>a</code> this gives:</p>
<pre><code>&gt;&gt;&gt; pd.DataFrame({k: v for k, *v in a}).to_dict('records')
[{'Name': 'Mary', 'Age': '21', 'Gender': 'F'}, {'Name': 'Tom', 'Age': '23', 'Gender': 'M'}, {'Name': 'John', 'Age': '12', 'Gender': 'M'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Kindof ugly oneliner:</p>
<p>first triple the first element of each inner list and zip it with the remaining elements, then zip the unpacked innner tuples to feed it into a dict:</p>
<pre><code>a = [["Name","Mary","Tom","John"],["Age","21","23","12"],["Gender","F","M","M"]]

k = list(dict (o) for o in  zip(*[ zip(l[0:1]*3,l[1:]) for l in a] ))
print(k)
</code></pre>
<p>Output:</p>
<pre><code>[{'Gender': 'F', 'Age': '21', 'Name': 'Mary'}, 
 {'Gender': 'M', 'Age': '23', 'Name': 'Tom'}, 
 {'Gender': 'M', 'Age': '12', 'Name': 'John'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">extended iterable unpacking</a>:</p>
<pre><code>a = [["Name", "Mary", "Tom", "John"], ["Age", "21", "23", "12"], ["Gender", "F", "M", "M"]]
result = [dict(val) for val in zip(*([(header, value) for value in values] for header, *values in a))]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[{'Gender': 'F', 'Name': 'Mary', 'Age': '21'}, {'Gender': 'M', 'Name': 'Tom', 'Age': '23'}, {'Gender': 'M', 'Name': 'John', 'Age': '12'}]
</code></pre>
</div>
<span class="comment-copy">what've you tried?</span>
<span class="comment-copy">did you read, experiment and groke <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#zip</a> ?</span>
<span class="comment-copy">can you explain what the code does please?</span>
<span class="comment-copy">@Usernamenotfound I included a broad strokes explanation in the answer, which specific part needs more?</span>
<span class="comment-copy">Can you explain what the <code>*</code> operator does here along with <code>zip</code>?</span>
<span class="comment-copy">@Usernamenotfound The <code>*</code> in this context is argument unpacking.  It "unpacks" some iterable of arguments into individual arguments to the function.  So <code>zip(*[[1, 2], [3, 4]])</code> is the same as <code>zip([1, 2], [3, 4])</code>.</span>
<span class="comment-copy">The last alternative on my answer shows a variation of your answer where you don't need the slicing on the first zip and can therefore get rid of <code>zip(*values)</code>.</span>
<span class="comment-copy">Amazing! Thank you all!</span>
<span class="comment-copy">Shorter one-liner: <code>[dict(zip(k, v)) for k, *zv in [zip(*a)] for v in zv]</code> :)</span>
