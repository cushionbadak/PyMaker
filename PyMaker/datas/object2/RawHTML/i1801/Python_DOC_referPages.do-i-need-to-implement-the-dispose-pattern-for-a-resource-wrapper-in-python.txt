<div class="post-text" itemprop="text">
<p>If I am going to implement a safe resource wrapper in Python, do I need to implement the <a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/dispose-pattern" rel="nofollow noreferrer">Dispose Pattern</a> like C#?</p>
<p>Here is a demo implementation of what I mean:</p>
<pre class="lang-python prettyprint-override"><code>class ResourceWrapper:
    def __init__(self):
        self._python_resource = ...  # A Python object that manages some resources.
        self._external_resource = _allocate_resource()  # A resource handle to an external resource.
        self._is_closed = False  # Whether the object has been closed.

    def __del__(self):
        self._close(manual_close=False)  # Called by GC.

    def close(self):
        self._close(manual_close=True)  # Called by user to free resource early.

    def _close(self, manual_close):
        if not self._is_closed:  # Don’t want a resource to be closed more than once.
            if manual_close:
                # Since `_close` is called by user, we can guarantee that `self._python_resource` is still valid, so we
                # can close it safely.
                self._python_resource.close() 
            else:
                # This means `_close` is called by GC, `self._python_resource` might be already GCed, but we don’t know
                # for sure, so we do nothing and rely on GC to free `self._python_resource`.

                pass

            # GC will not take care of freeing unmanaged resource, so whether manual close or not, we have to close the
            # resource to prevent leaking.

            _free_resource(self._external_resource)

            # Now we mark the object as closed to prevent closing multiple times.

            self._is_closed = True
</code></pre>
<p><code>self._python_resource</code> is a resource wrapper object managed by Python GC, and <code>self._external_resource</code> is a handle to an external resource that is not managed by Python GC.</p>
<p>I want to ensure both managed and unmanaged resource gets freed if user manual closes the wrapper, and, they also gets freed if the wrapper object gets GCed.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, in Python you should use <a href="http://book.pythontips.com/en/latest/context_managers.html" rel="nofollow noreferrer">Context Managers</a>:</p>
<pre><code>class ResourceWrapper:
    def __init__(self):
        ...

    ...


    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self._close(manual_close=False)

with ResourceWrapper() as wrapper:
    # do something with wrapper
</code></pre>
<hr/>
<p><strong>Note 1:</strong> There's this comment in <code>_close()</code> method:</p>
<blockquote>
<p>This means <code>_close</code> is called by GC, <code>self._python_resource</code> might be
  already GCed, but we don’t knowfor sure, so we do nothing and rely on
  GC to free <code>self._python_resource</code>.</p>
</blockquote>
<p>I'm not sure what you mean by that, but as long as you hold reference to an object (and as long as it isn't a <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer">weak reference</a>) it won't be GC'ed.</p>
<p><strong>Note 2:</strong> What happens if an object that is a context manager is used without <code>with</code> block? Then resource will be released when object is garbage collected - but I wouldn't worry about that. Using context managers is common idiom in python (see any example with <code>open()</code>ing file). If that's crucial for your application, you can acquire resources in <code>__enter__()</code>, that way won't be acquired unless in <code>with</code> block.</p>
<p><strong>Note 3, about cyclic references:</strong> If you have two objects that hold reference to each other, you've formed cyclic reference, so that two object won't be freed by "regular" reference-counting GC. Instead, they are to be collected by generational GC, <strong>unless</strong> thay happen to have <code>__del__</code> method. <code>__del__</code> inhibits GC from collecting objects. See <a href="https://docs.python.org/2/library/gc.html#gc.garbage" rel="nofollow noreferrer"><code>gc.garbage</code></a>:</p>
<blockquote>
<p>A list of objects which the collector found to be unreachable but
  could not be freed (uncollectable objects). By default, this list
  contains only objects with <code>__del__() methods</code>. [1] Objects that have
  <code>__del__()</code> methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily
  in the cycle but reachable only from it.</p>
</blockquote>
<p>Python 3.4 introduced <a href="https://www.python.org/dev/peps/pep-0442/" rel="nofollow noreferrer">PEP-442</a>, which introduces safe object finalization. Either way, you won't have invalid references. If you have attribute (<code>hasattr(self, "_python_resource")</code>) it will be valid.</p>
<p>Takeaway: <a href="https://stackoverflow.com/a/2452895/226648">don't use <code>__del__</code></a>.</p>
</div>
<span class="comment-copy">What if user created a wrapper, but forgot to use it in a <code>with</code> block, wouldn't the resource be leaked?</span>
<span class="comment-copy">If there are two objects holding each other’s reference (strong reference), then when the two object gets GCed, one object must be freed before the other one, so when the second object gets GCed, the reference to the first one becomes invalid.</span>
<span class="comment-copy">About <b>Note 2</b>: there are two kinds of resources. One type is normal python objects managed by GC, Another type is a handle type (maybe a pointer or integer) that points to an external resource that can not be managed by GC, we have to manually free it using certain function calls.</span>
