<div class="post-text" itemprop="text">
<p>The code below places three numbers in a queue. Then it attempts to get the numbers back from the queue. But it never does. How to get the data from the queue? </p>
<pre><code>import multiprocessing

queue = multiprocessing.Queue()

for i in range(3):
    queue.put(i)

while not queue.empty():
    print queue.get()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I originally deleted this answer after I read @Martijn Pieters', since he decribed the "why this doesn't work" in more detail and earlier. Then
I realized, that the use case in OP's example doesn't quite fit to the canonical sounding title of </p>
<blockquote>
<p>"How to use multiprocessing.Queue.get method". </p>
</blockquote>
<p>That's not because there's
no child process involved for demonstration, but because in real applications hardly ever a queue is pre-filled and only read out after, but reading
and writing happens interleaved with waiting times in between. The extended demonstration code Martijn showed, wouldn't work in the usual scenarios, because the while loop would break too soon when enqueuing doesn't keep up with reading. So here is the answer reloaded, which is able to deal with the usual interleaved feeds &amp; reads scenarios:</p>
<hr/>
<p>Don't rely on queue.empty checks for synchronization.</p>
<blockquote>
<p>After putting an object on an empty queue there may be an infinitesimal delay before the queue’s empty() method returns False and get_nowait() can return without raising queue.Empty.
  ...</p>
<p><strong>empty()</strong></p>
<p>Return True if the queue is empty, False otherwise. Because of multithreading/multiprocessing semantics, this is not reliable. <a href="https://docs.python.org/3.6/library/multiprocessing.html#multiprocessing.Queue" rel="nofollow noreferrer">docs</a></p>
</blockquote>
<p>Either use <code>for msg in iter(queue.get, sentinel):</code> to <code>.get()</code> from the queue, where you break out of the loop by passing a sentinel value...<a href="https://stackoverflow.com/q/38087427/9059420">iter(callable, sentinel)?</a></p>
<pre><code>from multiprocessing import Queue

SENTINEL = None

if __name__ == '__main__':

    queue = Queue()

    for i in [*range(3), SENTINEL]:
        queue.put(i)

    for msg in iter(queue.get, SENTINEL):
        print(msg)
</code></pre>
<p>...or use <code>get_nowait()</code> and handle a possible <code>queue.Empty</code> exception if you need a non-blocking solution.</p>
<pre><code>from multiprocessing import Queue
from queue import Empty
import time

SENTINEL = None

if __name__ == '__main__':

    queue = Queue()

    for i in [*range(3), SENTINEL]:
        queue.put(i)

    while True:
        try:
            msg = queue.get_nowait()
            if msg == SENTINEL:
                break
            print(msg)
        except Empty:
            # do other stuff
            time.sleep(0.1)
</code></pre>
<p>In case only one process and only one thread within this process is reading the queue, it would be also possible to exchange the last code snippet with:</p>
<pre><code>while True:
    if not queue.empty():  # this is not an atomic operation ...
        msg = queue.get()  # ... thread could be interrupted in between
        if msg == SENTINEL:
            break
        print(msg)
    else:
        # do other stuff
        time.sleep(0.1)
</code></pre>
<p>Since a thread could drop the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">GIL</a> in between checking <code>if not queue.empty()</code> and <code>queue.get()</code>, this wouldn't be suitable for multi-threaded queue-reads in a process. The same applies if multiple processes are reading from the queue. </p>
<p>For single-producer / single-consumer scenarios, using a <code>multiprocessing.Pipe</code> instead of <code>multiprocessing.Queue</code> would be sufficient and more performant, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code actually works, <em>some of the time</em>.</p>
<p>That's because the queue is not <em>instantly</em> not empty. The implementation is a bit more involved to support communication between multiple processes, so threads and pipes are involved that cause the <code>empty</code> state to last a little longer than your code allows for.</p>
<p>See the note in the <a href="https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues" rel="nofollow noreferrer"><em>Pipes and Queues</em> section</a>:</p>
<blockquote>
<p>When an object is put on a queue, the object is pickled and a background thread later flushes the pickled data to an underlying pipe. This has some consequences which are a little surprising, but should not cause any practical difficulties – if they really bother you then you can instead use a queue created with a manager.</p>
<ol>
<li>After putting an object on an empty queue <strong>there may be an infinitesimal delay before the queue’s <code>empty()</code> method returns <code>False</code></strong> [...]</li>
</ol>
</blockquote>
<p>(bold emphasis mine)</p>
<p>If you add a loop to check for emptyness <em>first</em> then your code works:</p>
<pre><code>queue = multiprocessing.Queue()

for i in range(3):
    queue.put(i)

while queue.empty():
    print 'queue is still empty'

while not queue.empty():
    print queue.get()
</code></pre>
<p>When you run the above, most of the time the <code>'queue is still empty'</code> appears once. Sometimes it doesn't appear at all, and sometimes it'll be printed twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>Check <code>queue</code> before using <code>get</code>:</p>
<pre><code>import multiprocessing

queue = multiprocessing.Queue()

for i in range(3):
    queue.put(i)

while not queue.empty():
    if not queue.empty():
        print queue.get()
</code></pre>
</div>
<span class="comment-copy">In the problem situation the “if” statement will not be executed, right?</span>
