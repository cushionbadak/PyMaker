<div class="post-text" itemprop="text">
<p>I need to write a python script that can match two lists of strings and return the shortest and lexographically first common parts of lists.</p>
<p>Lists corresponds to each other which means (a1, b1)...(aN, bN), pairs are frozen.</p>
<p>The rule:</p>
<pre><code>a = ['are', 'you', 'how', 'alan', 'dear']
b = ['yo', 'u', 'nhoware', 'arala', 'de']

result = 'dearalanhowareyou'
</code></pre>
<p>If no such concatenation of string then result is <code>IMPOSSIBLE</code>:</p>
<pre><code>a = ['a', 'b', 'c']
b = ['ab', 'bb', 'cc']

result = 'IMPOSSIBLE'
</code></pre>
<p>Restrictions:</p>
<ul>
<li>every element from each list can be used only once</li>
<li>length of each individual string element [1;100]</li>
<li>max list length is 11</li>
<li>all elements can be permutated only in pairs</li>
</ul>
<p>Now i try to consider all combinations and permutation inside them starting from the shortes and lexographically first.</p>
<p>I need to submit it for a test and during one of test I get <strong>Memory limit condition</strong>, limit is CPU 6 seconds and RAM 1024 MB.</p>
<p>I wonder how can I optimize memory consumptiom?
My current code is here:</p>
<pre><code>from itertools import chain, combinations, groupby, permutations
import timeit
import collections
import sys
import re
import gc
from functools import reduce


def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    for c in chain(*map(lambda x: combinations(iterable, x), range(0, len(iterable)+1))):
        yield c

def give_permutation(i):
    """
    Yields a permutations of a given combination
    """
    for c in sorted(permutations(i), key = lambda x: x[0]):
        yield c

def array_loop(arr):
    """
    Generator-like loop over the list
    """
    for i, element in enumerate(arr):
        yield i, element

def create_dict(arr):
    """
    Index based dictionary
    """
    dicty = {}
    for i, v in array_loop(arr):
        dicty[i] = v
    return dicty

def tricky_sort(a1, a2):
    """
    Sorts one array and return the second array with index-wise order
    """
    for a in zip(*sorted(zip(a1, a2), key=lambda x: (x[0]))):
        yield a

def num_common_letters(a, b):
    """
    Returns number of common elements in two strings
    """
    ac = collections.Counter(a)
    bc = collections.Counter(b)
    return sum(min(ac[key], bc[key]) for key in ac)

def checkMatch(a1, a2):
    """
    Checks for the first shortest match between strings
    """

    assert len(a1) == len(a2)
    iteration_mode = 'fast' if len(a1) &gt;= 8 or len(min(a1, key=len)) &gt;= 10 else 'full'

    # fast check for first sorted elements are equal
    if a1[0] == a2[0]:
        return a1[0]

    # fast check for equal length
    check = 0
    for el1, el2 in zip(a1, a2):
        if len(a1) != len(a2):
            check += 1
            break
    if check == 0 and len(a1) != len(a2):
        return 'IMPOSSIBLE'
    if ''.join(a for a in a1) == ''.join(a for a in a2)[-1:]:
        return 'IMPOSSIBLE'
    # fast check if any two strings have common elements
    if num_common_letters(''.join(a for a in a1), ''.join(a for a in a2)) &lt; 2*min([len(min(a1, key=len)), len(min(a2, key=len))]):
        return 'IMPOSSIBLE'

    lookup_a1 = create_dict(a1)
    lookup_a2 = create_dict(a2)
    range_list = list(range(len(a1)))

    del a1, a2

    clean_combs = []
    sorted_names = []


    for i in powerset(range_list):
        if len(i) &gt; 0:
            if len(''.join(lookup_a1[index] for index in i)) == len(''.join(lookup_a2[index] for index in i)):
                if reduce(lambda x, y: x + y, sorted(''.join(lookup_a1[index] for index in i))) == \
                    reduce(lambda x, y: x + y, sorted(''.join(lookup_a2[index] for index in i))):
                    clean_combs.append(i)
                    sorted_names.append(sorted([lookup_a1[index] for index in i])[0][0])

    del range_list

    if len(clean_combs) &gt; 0:
        _, clean_combs = tricky_sort(sorted_names, clean_combs)
        del sorted_names
        matches = []
        for i in clean_combs:
            for combination in give_permutation(i):
                if lookup_a1[combination[0]][0] != lookup_a2[combination[0]][0]:
                    continue
                first_seq = [lookup_a1[index] for index in combination]
                second_seq = [lookup_a2[index] for index in combination]
                if ''.join(f for f in first_seq) == ''.join(s for s in second_seq):
                    if iteration_mode == 'fast':
                        return ''.join(f for f in first_seq)
                    else:
                        matches.append(''.join(f for f in first_seq))

        if len(matches) &gt; 0:
            matches = sorted(matches, key=lambda x: (len(x), x[0]))
            return matches[0]

    return 'IMPOSSIBLE'


def string_processor(string):
    """
    Splits string by integers and returns arrays with only letters inside
    """
    arr = ' '.join(re.findall(r'[0-9|a-zA-Z]+', string.replace(r'\n', ' '))).strip()
#     all_ints = re.findall(r'[0-9]+', arr)
    arr = re.compile(r'[0-9]+').split(arr)

#     flatten = lambda l: [item for sublist in l for item in sublist]
    arr = [re.findall(r'[a-zA-Z]+', a) for a in arr if len(a) &gt; 0]

#     assert sum([int(a) for a in all_ints]) == len(flatten(result_list)) / 2
#     assert min([len(f) for f in flatten(result_list)]) &gt; 0
#     assert len(flatten(result_list)) &lt; 11*sum([int(a) for a in all_ints])

    for r in arr:
        yield r

def substring_processor(substring, shift = 0):
    """
    Returns two array with the first and the second sequences
    """
    arr1 = []
    arr2 = []
    for i in range(0, len(substring), 2):
        yield substring[i + shift]

def string_arr(arr1, arr2):    
    for t in tricky_sort(arr1, arr2):
        yield t

def process_file(file):
    """
    Iterates over all sequences in a file
    """

    case_counter = 0

    for sub in string_processor(file):
        case_counter += 1
        str1, str2 = string_arr(substring_processor(sub), substring_processor(sub, shift = 1))
        print('Case %s: ' %  str(case_counter) + checkMatch(str1, str2) + '\n')

def read_files():
    """
    Takes input data
    """
    input_string = ''
    for f in sys.stdin:
        input_string += f
    process_file(input_string)

read_files()
</code></pre>
<p>This problem was solved in C++ but i cannot get the idea under the hood <a href="https://github.com/adrian-budau/work/blob/master/Kattis/ACM-ICPC%20-%20World%20Finals%202013/Limited%20Correspondence/main.cpp" rel="nofollow noreferrer">https://github.com/adrian-budau/work/blob/master/Kattis/ACM-ICPC%20-%20World%20Finals%202013/Limited%20Correspondence/main.cpp</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think you could just generate the correct substrings (all of them, as in my opinion, in generatrion time you can not really decide if they are both "lexicographically" first <strong>and</strong> shortest) like this:</p>
<pre><code>from itertools import permutations
from pprint import pprint
a = ['are', 'you', 'how', 'alan', 'dear']
b = ['yo', 'u', 'nhoware', 'arala', 'de']
c = zip(a,b)
m = []
for p in permutations(c):
  stra = ""
  strb = ""
  for t in p:
    stra += t[0]
    strb += t[1]
    if stra == strb: m.append(stra)
pprint(m)
</code></pre>
<p>Then proceed with checking if <code>m</code> remained empty or pick a "first" item with whatever clumsy way, as that list is going to be a short one anyway. Like sorting it alphabetically and then picking the sortest one:</p>
<pre><code>if len(m) == 0: w = "IMPOSSIBLE"
else:
  w = m[0]
  for x in sorted(m):
    if len(x) &lt; len(w): w = x
print(w)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, I ended up with clearly and early specifying situations when such combinations is not possible. For example, we know that the answering strings should start and end with the same symbols. So we can create combination and <strong>BEFORE</strong> making permutation we check for such condition. Also we can check that sum of length of all substrings inside the piece we need to check are equal. If not then we do not go for permutation and instead proceed further</p>
<p>Code</p>
<pre><code>from itertools import chain, combinations, groupby, permutations
import timeit
import collections
import sys
import re
import gc
from functools import reduce


def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    for c in chain(*map(lambda x: combinations(iterable, x), range(0, len(iterable)+1))):
        yield c

def give_permutation(i):
    """
    Yields a permutations of a given combination
    """
    for c in permutations(i):
        yield c

def create_dict(arr):
    """
    Index based dictionary
    """
    dicty = {}
    for i, v in enumerate(arr):
        dicty[i] = v
    return dicty

def tricky_sort(a1, a2):
    """
    Sorts one array and return the second array with index-wise order
    """
    for a in zip(*sorted(zip(a1, a2), key=lambda x: (len(x), x[0]))):
        yield a

def check_complete(starts, ends, array, threshold = 2):
    """
    Checks if combination has both starts and ends
    """
    matches = 0
    for s in starts: 
        if s in array:
            matches += 1
            break
    for e in ends:
        if e in array:
            matches += 1
            break
    return matches == abs(threshold)

def check_match(pairs):
    """
    Checks if answer fits the task
    """
    return ''.join(el[0] for el in pairs) == ''.join(el[1] for el in pairs) 

def algo(a1, a2):
    """
    Checks for the first shortest match between strings
    """

    assert len(a1) == len(a2)

    # fast check for first sorted elements are equal
    if a1[0] == a2[0]:
        return a1[0]

    start_pairs = []
    end_pairs = []
    matches = [] 
    all_pairs = []
    for el1, el2 in zip(a1, a2):
        if el1[0] == el2[0]: start_pairs.append((el1, el2))
        if el1[-1] == el2[-1]: end_pairs.append((el1, el2))
        if el1 == el2: matches.append(el1)
        all_pairs.append(((el1, el2)))
    if len(start_pairs) == 0 or len(end_pairs) == 0: return 'IMPOSSIBLE'

    full_search = 2

    if len(start_pairs) == 1 and len(end_pairs) == 1: 
        full_search = 0
        all_pairs.remove(start_pairs[0])
        all_pairs.remove(end_pairs[0])

    if full_search == 0: 
        if start_pairs[0] == end_pairs[0]:
            return start_pairs[0][0]
        elif start_pairs[0][0] + end_pairs[0][0] == start_pairs[0][1] + end_pairs[0][1]:
            matches.append(start_pairs[0][0] + end_pairs[0][0])
        elif end_pairs[0][0] + start_pairs[0][0] == end_pairs[0][1] + start_pairs[0][1]:
             matches.append(end_pairs[0][0] + start_pairs[0][0])

    lookup_a1 = create_dict([el[0] for el in all_pairs])
    lookup_a2 = create_dict([el[1] for el in all_pairs])
    range_list = list(range(len(all_pairs)))

    del a1, a2

    clean_combs = []
    sorted_names = []

    if len(range_list) &gt; 0:
        for i in powerset(range_list):
            if len(i) &gt; 0 :
                if full_search == 2:
                    if check_complete(start_pairs, end_pairs, [all_pairs[index] for index in i]) and \
                            sum([len(all_pairs[index][0]) for index in i]) == sum([len(all_pairs[index][1]) for index in i]):
                        arr1_str = ''.join(lookup_a1[index] for index in i)
                        arr2_str = ''.join(lookup_a2[index] for index in i)
                        if len(arr1_str) == len(arr2_str):
                            if reduce(lambda x, y: x + y, sorted(arr1_str)) == reduce(lambda x, y: x + y, sorted(arr2_str)):
                                clean_combs.append(i)
                else:
                    clean_combs.append(i)

        if len(clean_combs) &gt; 0:
            for i in clean_combs:
                for combination in give_permutation(i):
                    if full_search == 2:
                        if lookup_a1[combination[0]][0] != lookup_a2[combination[0]][0] or \
                            lookup_a1[combination[-1]][-1] != lookup_a2[combination[-1]][-1]:
                                continue
                        if check_match([all_pairs[index] for index in combination]):
                            matches.append(''.join(all_pairs[index][0] for index in combination))
                    elif full_search == 0:
                        option = start_pairs + [all_pairs[index] for index in combination] + end_pairs
                        if check_match(option):
                            matches.append(''.join(el[0] for el in option))

    if len(matches) &gt; 0:
        matches = sorted(matches, key=lambda x: (len(x), x[0]))
        return matches[0]    
    return 'IMPOSSIBLE'

def string_processor(string):
    """
    Splits string by integers and returns arrays with only letters inside
    """
    arr = ' '.join(re.findall(r'[0-9|a-zA-Z]+', string.replace(r'\n', ' '))).strip()
    all_ints = re.findall(r'[0-9]+', arr)
    arr = re.compile(r'[0-9]+').split(arr)
    arr = [re.findall(r'[a-zA-Z]+', a) for a in arr if len(a) &gt; 0]

    for r in arr:
        yield r

def substring_processor(substring, shift = 0):
    """
    Returns two array with the first and the second sequences
    """
    arr1 = []
    arr2 = []
    for i in range(0, len(substring), 2):
        yield substring[i + shift]

def string_arr(arr1, arr2):    
    for t in tricky_sort(arr1, arr2):
        yield t

def process_file(file):
    """
    Iterates over all sequences in a file
    """

    case_counter = 0

    for sub in string_processor(file):
        case_counter += 1
        str1, str2 = string_arr(substring_processor(sub), substring_processor(sub, shift = 1))
        print('Case %s: ' %  str(case_counter) + algo(str1, str2) + '\n')

def read_files():
    """
    Takes input data
    """
    input_string = ''
    for f in sys.stdin:
        input_string += f
    process_file(input_string)

read_files()
</code></pre>
</div>
<span class="comment-copy">I think the problem is that you "consider all combinations and permutation", and that you need a guided search. There are very few valid permutations – for instance, your first example must start with "dear" – and generating all the other permutations is just wasteful.</span>
<span class="comment-copy">yes, i try to do it more wisely starting from shortest and alphabetically first combinations. may be there is better rule</span>
<span class="comment-copy">There's also a bug in the <code>for el1, el2 in zip(a1, a2)</code> loop – it ignores <code>el1</code> and <code>el2</code>– and plenty of needless list operations (e.g. <code>x for x in y</code>, which you can simplify to <code>y</code>).</span>
<span class="comment-copy">@molbdnilo yes, thanks</span>
<span class="comment-copy">Don't permute and combine and then see if you have a solution. As I said, the result for your first example must start with ("dear", "de"). Then you can only pick "arala" from the second list to make ("dear", "dearala"). Then you have only one possible candidate from the first list; ("dearalan", "dearala"). And so on.</span>
<span class="comment-copy">it is good but to slow. That is why I tried to sort all combinations. My code is much faster</span>
<span class="comment-copy">And memory limit problem is still here</span>
<span class="comment-copy">@paveltr: <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>permutations()</code></a> is a generator, it does not store all permutations in the memory. That was <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted()</code></a> in the original code. Are you sure there is a memory problem?</span>
<span class="comment-copy">It is ok with generator. The issue with your code is CPU time. It more than 6 seconds for one of tests. The full path through all of combinations is not an option, it is too slow.</span>
<span class="comment-copy">Also I found a C++ solution here <a href="https://github.com/adrian-budau/work/blob/master/Kattis/ACM-ICPC%20-%20World%20Finals%202013/Limited%20Correspondence/main.cpp" rel="nofollow noreferrer">github.com/adrian-budau/work/blob/master/Kattis/…</a>. It works extremely fast but I cannot get the idea under the hood</span>
