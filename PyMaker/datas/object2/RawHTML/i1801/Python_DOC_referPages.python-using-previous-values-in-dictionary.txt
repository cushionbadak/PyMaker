<div class="post-text" itemprop="text">
<p>Is there any way to do something like this</p>
<pre><code>dict = {
    'a':1,
    'b':dict['a']+1,
}
</code></pre>
<p>or do I have to create the values first somewhere else and make a dictionary after that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code will not work, since the <code>dict</code> variable (which is, by the way, shadowing the builtin <code>dict</code> function) is <em>not yet defined</em> before the <code>{...}</code> literal has been evaluated, so it can not be used within the <code>{...}</code>.</p>
<p>Instead, you could create an iterable of numbers, e.g. using <code>itertools.count</code> or just <code>iter(range(1, some_number))</code>, and then get the <code>next</code> values from that iterable.</p>
<pre><code>&gt;&gt;&gt; nums = itertools.count(1)
&gt;&gt;&gt; {"a": next(nums), "b": next(nums), "c": next(nums)}
{'a': 1, 'b': 2, 'c': 3}
</code></pre>
<p>Or use the <code>dict</code> function with <code>zip</code> to combine the list of keys with their values:</p>
<pre><code>&gt;&gt;&gt; dict(zip(("a", "b", "c"), itertools.count(1)))
{'a': 1, 'b': 2, 'c': 3}
</code></pre>
<p>(This also works with steps other than <code>1</code>, or in fact with arbitrary lists of values, not just with numbers. In the case of steps always being <code>1</code>, <a href="https://stackoverflow.com/a/53158529/1639625"><code>enumerate</code></a> might indeed be the simpler alternative.)</p>
</div>
<div class="post-text" itemprop="text">
<p>If the increment <strong>is always</strong> <code>1</code> you could use enumerate:</p>
<pre><code>keys = ['a', 'b', 'c']
result = {k: i for i, k in enumerate(keys, 1)}
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'b': 2, 'c': 3, 'a': 1}
</code></pre>
<p>If the increment is custom you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">accumulate</a> with <a href="https://docs.python.org/3/library/operator.html#operator.add" rel="nofollow noreferrer">add</a>:</p>
<pre><code>from itertools import accumulate
from operator import add

keys = ['a', 'b', 'c']
increments = [1, 2, 7]

result = {k: v for k, v in zip(keys, accumulate(increments, add))}
print(result)
</code></pre>
<p>Note that the first value in increments corresponds to the value of the first key. </p>
<p><strong>UPDATE</strong></p>
<p>As mentioned by @tobias_k you could use accumulate without passing <code>add</code>:</p>
<pre><code>result = {k: v for k, v in zip(keys, accumulate(increments))}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a rather silly approach. Define your dict literal within a string, and then use <code>ast.parse</code> to get the value of each expression defining its keys and values. Then you can evaluate each one in turn, providing a custom <code>locals</code> argument to <code>eval</code> in order to forcibly make the dictionary object accessible while the dictionary is still being created.</p>
<pre><code>import ast

def eval_self_referential_dict_literal(s, locals = None):
    """
    Evaluates a string containing a dict literal.
    Capable of resolving keys and values that are present higher up in the literal. Use `d` to refer to the dict itself.
    Provide a mapping to the `locals` parameter if you need to access other names in the literal. You might pass in `locals()`, for example.
    """

    expr = ast.parse(d, mode='eval')
    assert isinstance(expr, ast.Expression)
    dict_node = expr.body
    assert isinstance(dict_node, ast.Dict)

    result = {}
    if locals is None:
        locals = {}
    else:
        locals = locals.copy()
    locals['d'] = result

    for key_node, value_node in zip(dict_node.keys, dict_node.values):
        key = eval(compile(ast.Expression(key_node), '', mode='eval'), globals(), locals)
        value = eval(compile(ast.Expression(value_node), '', mode='eval'), globals(), locals)
        result[key] = value
    return result

d = """
{
    'a':1,
    'b':d['a']+1,
    d['b']: d['a'],
    x: 99
}
"""

x = "blah"

print(eval_self_referential_dict_literal(d, locals()))
</code></pre>
<p>Result:</p>
<pre><code>{'a': 1, 'b': 2, 2: 1, 'blah': 99}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Normally one use defaultict for something like</p>
<pre><code>d = defaultdict(lambda: 1, {"a": 0})
</code></pre>
<p>But one can have more fun definitions:</p>
<pre><code>from collections import defaultdict
import itertools

d = defaultdict(itertools.count().__next__)
print (d['a'], d['b'])
</code></pre>
</div>
<span class="comment-copy">I don't know if this helps, but you could first do <code>dict = {'a':1}</code> and then put <code>dict['b']=dict['a']+1</code> afterwards, and similarly for any other properties. (PS <code>dict</code> is a built-in function so you shouldn't use it as a variable name.)</span>
<span class="comment-copy">Using an ordered dict will probably work.</span>
<span class="comment-copy">@Dschoni, as in <code>dict = collections.OrderedDict(("a", 1), ("b", dict['a']+1))</code>? I wouldn't expect that to work, for the same reason that the OP's original code doesn't work.</span>
<span class="comment-copy">@Kevin it won't work in one single line. But in a loop you can do something like <code>dict.keys()[-1]</code> with an <code>OrderedDict</code></span>
<span class="comment-copy">Ok, but there are already solutions using ordinary dicts that require more than one line, so it's unclear to me what benefit you get from incorporating OrderedDict. (My assumption is that the order of the keys is not actually important; i.e. the OP is never in a position of "I want <code>foo</code> to be one greater than the key preceding it, but I don't know the value of that key")</span>
<span class="comment-copy">Nice idea, using <code>accumulate</code>. But you don't need <code>add</code>, as that's the default anyway; just <code>dict(zip(keys, accumulate(increments)))</code>.</span>
