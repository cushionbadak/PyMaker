<div class="post-text" itemprop="text">
<p>There is given a dictionary with few points with their distance where key - name of the point, and value - it's distance, i.e.</p>
<pre><code>points_dict = {"a": 18, "b": 7, "c": 15, "d": 22, "e": 33, "f": 5}
</code></pre>
<p>The question is to find f.e. <strong>6</strong> shortest routes in order for <strong>3</strong> different points from the dict, so <strong>6</strong> lowest sums of <strong>3</strong> different values from given dict values in order.</p>
<p>I tried to do this in following way - get distances into a list, then sort it to:</p>
<pre><code>example_list = [5, 7, 15, 18, 22, 33]
</code></pre>
<p>And then just get first 6 combinations, so:</p>
<blockquote>
<ol>
<li>5+7+15</li>
<li>5+7+18  </li>
<li>5+7+22  </li>
<li>5+7+33  </li>
<li>7+15+18</li>
</ol>
</blockquote>
<p>and so on...</p>
<p>But as you can see, it isn't right, because 4. <code>5+7+33 = 45</code> while  5. <code>7+15+18 = 40</code>, so it should be before it, as lowest sum, so "shortest" distance. I can't figure out any algorithm and solution to deal with this. Any tips how it can be done?</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Once you have the <code>example_list = [5, 7, 15, 18, 22, 33]</code>, you can use this one liner to get the list of combination by 3 elements sorted by their sum:</p>
<pre><code>from itertools import combinations

sorted(list(combinations(example_list, 3)),key=sum)

#=&gt; [(5, 7, 15), (5, 7, 18), (5, 7, 22), (5, 15, 18), (7, 15, 18), (5, 15, 22), (7, 15, 22), (5, 7, 33), (5, 18, 22), (7, 18, 22), (5, 15, 33), (7, 15, 33), (15, 18, 22), (5, 18, 33), (7, 18, 33), (5, 22, 33), (7, 22, 33), (15, 18, 33), (15, 22, 33), (18, 22, 33)]
</code></pre>
<p>Then pick the first six.</p>
<p>If you want also to keep track of the original keys:</p>
<pre><code>tmp_list = [[k, v] for k, v in points_dict.items()]
sorted(list(combinations(tmp_list, 3)), key = lambda x: sum(i[1] for i in x) )[0:6]

#=&gt; [(['c', 15], ['b', 7], ['f', 5]), (['a', 18], ['b', 7], ['f', 5]), (['b', 7], ['d', 22], ['f', 5]), (['a', 18], ['c', 15], ['f', 5]), (['a', 18], ['c', 15], ['b', 7]), (['c', 15], ['d', 22], ['f', 5])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/itertools.html#recipes" rel="nofollow noreferrer">powerset recipes</a> from itertools, combine it with <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">collection.defaultdict</a> and use only those with 3 element tuples. This will overproduce data though - its not optimal if you have <em>huge</em> dictionaries:</p>
<pre><code>from itertools import combinations, chain
from collections import defaultdict

# https://docs.python.org/3/library/itertools.html#recipes
def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)

    # you can hardcode your 3-tuples here as well and eliminate lots of data and filtering
    # return combinations(s, 3)

    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))


points_dict = {"a": 18, "b": 7, "c": 15, "d": 22, "e": 33, "f": 5}

d = defaultdict(list)
for s in powerset(points_dict.values()):
    if len(s) == 3:
        d[sum(s)].append(s) 

sor = sorted(d)
for s in sor:
    print(s, d[s])
</code></pre>
<p>Output:</p>
<pre><code>27 [(7, 15, 5)]
30 [(18, 7, 5)]
34 [(7, 22, 5)]
38 [(18, 15, 5)]
40 [(18, 7, 15)]
42 [(15, 22, 5)]
44 [(7, 15, 22)]
45 [(18, 22, 5), (7, 33, 5)]
47 [(18, 7, 22)]
53 [(15, 33, 5)]
55 [(18, 15, 22), (7, 15, 33)]
56 [(18, 33, 5)]
58 [(18, 7, 33)]
60 [(22, 33, 5)]
62 [(7, 22, 33)]
66 [(18, 15, 33)]
70 [(15, 22, 33)]
73 [(18, 22, 33)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the powerset receip from itertools, combine it with colleciton.defaultdict and use only those with 3 element tuples:</p>
<pre><code>from itertools import combinations, chain

# https://docs.python.org/2/library/itertools.html#recipes
def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))


points_dict = {"a": 18, "b": 7, "c": 15, "d": 22, "e": 33, "f": 5}
from collections import defaultdict
d = defaultdict(list)
for s in powerset(points_dict.values()):
    if len(s) == 3:
        d[sum(s)].append(s) 

sor = sorted(d)
for s in sor:
    print(s, d[s])
</code></pre>
<p>Output:</p>
<pre><code>27 [(7, 15, 5)]
30 [(18, 7, 5)]
34 [(7, 22, 5)]
38 [(18, 15, 5)]
40 [(18, 7, 15)]
42 [(15, 22, 5)]
44 [(7, 15, 22)]
45 [(18, 22, 5), (7, 33, 5)]
47 [(18, 7, 22)]
53 [(15, 33, 5)]
55 [(18, 15, 22), (7, 15, 33)]
56 [(18, 33, 5)]
58 [(18, 7, 33)]
60 [(22, 33, 5)]
62 [(7, 22, 33)]
66 [(18, 15, 33)]
70 [(15, 22, 33)]
73 [(18, 22, 33)]
</code></pre>
</div>
<span class="comment-copy">Do you start at a certain point? It looks to me this is a variant of the <i>subset sum</i> problem, where you can then "harvest" combinations at the end that are minimal. Or you could use a variant of Dijkstra's algorithm to generate minimal combinations after 3 "hops".</span>
<span class="comment-copy">the fact that it is not an <i>explicit</i> graph does not mean you can not "represent" it as a graph. You can draw a graph with the above information with the given data.</span>
<span class="comment-copy">well yes, it look similar to it, but it it's not a graph. I can't properly describe it because of my poor English.</span>
<span class="comment-copy">Thanks, that exactly what was needed! Yes, keys are also needed (to display in result's output), but i managed to get them later from dict by value, because it needed to be formated in some specific way in print out</span>
