<div class="post-text" itemprop="text">
<p>I have a large list like:</p>
<pre><code>[A][B1][C1]=1
[A][B1][C2]=2
[A][B2]=3
[D][E][F][G]=4
</code></pre>
<p>I want to build a multi-level dict like:</p>
<pre><code>A
--B1
-----C1=1
-----C2=1
--B2=3
D
--E
----F
------G=4
</code></pre>
<p>I know that if I use recursive defaultdict I can write <code>table[A][B1][C1]=1</code>, <code>table[A][B2]=2</code>, but this works only if I hardcode those insert statement. </p>
<p>While parsing the list, I don't how many []'s I need beforehand to call <code>table[key1][key2][...]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it without even defining a class:</p>
<pre><code>from collections import defaultdict

nested_dict = lambda: defaultdict(nested_dict)
nest = nested_dict()

nest[0][1][2][3][4][5] = 6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your example says that at any level there can be a value, and also a dictionary of sub-elements. That is called a <strong>tree</strong>, and there are many implementations available for them. This is one:</p>
<pre><code>from collections import defaultdict
class Tree(defaultdict):
    def __init__(self, value=None):
        super(Tree, self).__init__(Tree)
        self.value = value

root = Tree()
root.value = 1
root['a']['b'].value = 3
print root.value
print root['a']['b'].value
print root['c']['d']['f'].value
</code></pre>
<p>Outputs:</p>
<pre><code>1
3
None
</code></pre>
<p>You could do something similar by writing the input in JSON and using <code>json.load</code> to read it as a structure of nested dictionaries. </p>
</div>
<div class="post-text" itemprop="text">
<p>I'd do it with a subclass of <code>dict</code> that defines <code>__missing__</code>:</p>
<pre><code>&gt;&gt;&gt; class NestedDict(dict):
...     def __missing__(self, key):
...             self[key] = NestedDict()
...             return self[key]
...
&gt;&gt;&gt; table = NestedDict()
&gt;&gt;&gt; table['A']['B1']['C1'] = 1
&gt;&gt;&gt; table
{'A': {'B1': {'C1': 1}}}
</code></pre>
<p>You can't do it directly with defaultdict because <a href="http://docs.python.org/library/collections.html#collections.defaultdict" rel="noreferrer">defaultdict expects the factory function</a> at initialization time, but at initialization time, there's no way to describe the same defaultdict. The above construct does the same thing that default dict does, but since it's a named class (NestedDict), it can reference itself as missing keys are encountered. It is also possible to subclass defaultdict and override <code>__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the simplest implementation of a recursive dictionary is this. Only leaf nodes can contain values.</p>
<pre><code># Define recursive dictionary
tree = lambda: defaultdict(tree)
</code></pre>
<p>Usage:</p>
<pre><code># Create instance
mydict = tree()

tree['a'] = 1
tree['b']['a'] = 2
tree['c']
tree['d']['a']['b'] = 0

# Print
import prettyprint
prettyprint.pp(tree)
</code></pre>
<p>Output:</p>
<pre><code>{
  "a": 1, 
  "b": {
    "a": 1
  }, 
  "c": {},
  "d": {
    "a": {
      "b": 0
    }
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is equivalent to the above, but avoiding lambda notation. Perhaps easier to read ?</p>
<pre><code>def dict_factory():
   return defaultdict(dict_factory)

your_dict = dict_factory()
</code></pre>
<p>Also -- from the comments -- if you'd like to update from an existing dict, you can simply call</p>
<pre><code>your_dict[0][1][2].update({"some_key":"some_value"})
</code></pre>
<p>In order to add values to the dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>Dan O'Huiginn posted a very nice solution on his journal in 2010:</p>
<p><a href="http://ohuiginn.net/mt/2010/07/nested_dictionaries_in_python.html" rel="nofollow">http://ohuiginn.net/mt/2010/07/nested_dictionaries_in_python.html</a></p>
<pre><code>&gt;&gt;&gt; class NestedDict(dict):
...     def __getitem__(self, key):
...         if key in self: return self.get(key)
...         return self.setdefault(key, NestedDict())


&gt;&gt;&gt; eggs = NestedDict()
&gt;&gt;&gt; eggs[1][2][3][4][5]
{}
&gt;&gt;&gt; eggs
{1: {2: {3: {4: {5: {}}}}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A slightly different possibility that allows regular dictionary initialization:   </p>
<pre><code>from collections import defaultdict

def superdict(arg=()):
    update = lambda obj, arg: obj.update(arg) or obj
    return update(defaultdict(superdict), arg)
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; d = {"a":1}
&gt;&gt;&gt; sd = superdict(d)
&gt;&gt;&gt; sd["b"]["c"] = 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add to @Hugo <br/>To have a max depth:</p>
<pre><code>l=lambda x:defaultdict(lambda:l(x-1)) if x&gt;0 else defaultdict(dict)
arr = l(2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may achieve this with a recursive <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>.</p>
<pre><code>from collections import defaultdict

def tree():
    def the_tree():
        return defaultdict(the_tree)
    return the_tree()
</code></pre>
<p>It is important to protect the default factory name, <code>the_tree</code> here, in a closure ("private" local function scope).  Avoid using a one-liner <code>lambda</code> version, which is bugged due to Python's <a href="https://docs.python-guide.org/writing/gotchas/#late-binding-closures" rel="nofollow noreferrer">late binding closures</a>, and implement this with a <code>def</code> instead.</p>
<p>The accepted answer, using a lambda, has a flaw where instances must rely on the <code>nested_dict</code> name existing in an outer scope. If for whatever reason the factory name can not be resolved (e.g. it was rebound or deleted) then pre-existing instances will also become subtly broken:</p>
<pre><code>&gt;&gt;&gt; nested_dict = lambda: defaultdict(nested_dict)
&gt;&gt;&gt; nest = nested_dict()
&gt;&gt;&gt; nest[0][1][2][3][4][6] = 7
&gt;&gt;&gt; del nested_dict
&gt;&gt;&gt; nest[8][9] = 10
# NameError: name 'nested_dict' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have <code>table['A']=defaultdict()</code>.</p>
</div>
<span class="comment-copy">Strongly related: <a href="https://stackoverflow.com/questions/16547643/convert-a-list-of-delimited-strings-to-a-tree-nested-dict-using-python" title="convert a list of delimited strings to a tree nested dict using python">stackoverflow.com/questions/16547643/â€¦</a></span>
<span class="comment-copy">this is sweet!  but how about if i want leaves to  initialize via a standard (int, list, etc) factory?  eg, i want to be able to say:  <code>table[0][1][2][3][4][5] += 1</code></span>
<span class="comment-copy">is there a way to do the same with a built-in dict and .get() ?</span>
<span class="comment-copy">@rikb: i don't see how without setting a fixed depth (to differentiate the leave-nodes)</span>
<span class="comment-copy">class l(dict): __missing__=lambda a,b:a.setdefault(b,l()) and then continue from table=l()</span>
<span class="comment-copy">def nested_dict(): return defaultdict(nested_dict) but i like the lambda version better. it looks a bit more cryptic ;-)</span>
<span class="comment-copy">I think the <code>value</code> construct is unnecessary, at least with respect to the proposed problem. Just remove references to <code>value</code> and assign values directly to dictionary keys.</span>
<span class="comment-copy">+1: Although the <code>value</code> arg/attribute isn't really necessary.</span>
<span class="comment-copy">@Martineau @Jason. The <code>value</code> instance variable is necessary because otherwise you'd loose the children when you assign directly to a node (see my comment to Jason's elegant solution). Intervening <code>__setitem__</code> would provide for a much more robust solution, but it would be a too complicated solution to the simple requirements.</span>
<span class="comment-copy">I was unclear how to modify the other answers to that the collection property was a <code>list</code> instead of a <code>int/float</code>. This answer makes it clear, where  <code>self.value = []</code> was exactly what I was looking for!</span>
<span class="comment-copy">That's not enough. You'll get an error if you try <code>table['A']['B1']['C1']['D2'] = 2</code>. The nodes must be able to hold a value <b>and</b> the children.</span>
<span class="comment-copy">@Apalala: Actually, from the OP's example input, it appears that nodes only need to be able to hold a value <b>or</b> children, never both -- which is why @Jason and I claimed your answer's <code>value</code> attribute was unnecessary.</span>
<span class="comment-copy">@martinau MHO is that it all becomes unstable (bug-prone) unless it is solved as a tree. Syntax and implementation are irrelevant. Is it, or is it not a problem that requires a tree structure? My point is that one should not force a design towards a <i>pretty</i> syntax unless there are compelling reasons to do it. KISS.</span>
<span class="comment-copy">@Apalala I know this is old. but how do we implement a <code>defaultdict</code> that holds both values and children?</span>
<span class="comment-copy">@HalcyonAbrahamRamirez Look at Apalala's answer in this same question.</span>
<span class="comment-copy">just noticed that my post is a duplicate of #2. Sorry</span>
<span class="comment-copy">This may be a dupe, but I thought the example was very illustrative and useful, so I'd say you definitely added some useful content.</span>
<span class="comment-copy">I find this approach nice when I want to create a nested dictionary quickly.  If I want to "re-enable" <code>KeyError</code>, it's easy to convert back to a standard dictionary using <code>dict()</code>.</span>
