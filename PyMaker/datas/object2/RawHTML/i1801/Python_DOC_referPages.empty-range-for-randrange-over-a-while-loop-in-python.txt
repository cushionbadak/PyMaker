<div class="post-text" itemprop="text">
<p>Ive been having an issue with getting a random int from a function after going through a while loop. The purpose of the function is to shuffle a deck:</p>
<pre><code>def shuffling(maindeck, shuffle_steps):
random.seed()
# sets a number of steps and creates a new array to be returned
steps = 0
shuffler = maindeck

while steps &lt; shuffle_steps:
    firstR = random.randrange(len(maindeck) - 1)
    secondR = random.randrange(len(maindeck) - 1)

    shuffler[firstR], shuffler[secondR] = shuffler[secondR], shuffler[firstR]

    steps +=1

return shuffler
</code></pre>
<p>and this is the code that uses the function:</p>
<pre><code>from deck import *
from shuffle import shuffling
gameState = True


while gameState:
    input("Welcome to War! Press any key to continue... \n")

    game_deck = shuffling(total_deck, 500)

    while gameState and len(game_deck) &gt; 1:
        print("Both players draw a card...")

        playerCard = game_deck.pop(0)
        opponentCard = game_deck.pop(0)

        # some code

        keep_playing = input("Play again? (y/n) \n")
        if keep_playing is not ('y' or 'Y'):
           gameState = False

gameState = False

if len(game_deck) &lt; 2:
    print("No cards left!")
    keepPlaying = input("Play again? (y/n) \n")
    if keepPlaying is ('y' or 'Y'):
        gameState = True
</code></pre>
<p>where total_deck is an array from a file deck.py</p>
<p>This code works fine over the first iteration of the while loop, but when the loop iterates I get the error:</p>
<pre><code> ValueError: empty range for randrange()
</code></pre>
<p>And that the error occurs when </p>
<pre><code>random.randrange(len(Maindeck) - 1) 
</code></pre>
<p>is called, since </p>
<pre><code>len(Maindeck) - 1 
</code></pre>
<p>now evaluates to a number equal to or lower than 0? Why is this? </p>
</div>
<div class="post-text" itemprop="text">
<h2>Options:</h2>
<ul>
<li><p>If you have a set of cards in a list and want to <strong>rearrage the whole sequence</strong>, simply use <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow noreferrer">random.shuffle(sequence)</a> for an inplace shuffling.</p></li>
<li><p>If you want to <strong>get a shuffled copy of it</strong>, use <a href="https://docs.python.org/3/library/random.html#random.sample()" rel="nofollow noreferrer">random.sample()</a>  and set the length to the length of the sequence.  </p></li>
</ul>
<hr/>
<p>This line:</p>
<pre><code>shuffler = maindeck
</code></pre>
<p>presuming <code>maindeck</code> is somekind of mutable list data structure, <code>shuffler</code> references the same data that <code>maindeck</code> does - you are shuffling your <code>maindeck</code> (in disguise) and return it - and further down you are maniputaling it. Youcould use <code>random.sample()</code> instead wich returns a shuffled copy of your maindeck.</p>
<p><code>random.seed()</code> sets the starting-internal state of the <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="nofollow noreferrer">Mersenne_Twister</a> that generates your randomness - set it once if you need but not every time you shuffle through your deck. <code>Seeding</code> your random with a fixed value will lead to the same random numbers given u use the same random operations as each random operation changes the internal state - using it without any seed is not needed, its done by default in the sources: see <a href="https://stackoverflow.com/questions/817705/pythons-random-what-happens-if-i-dont-use-seedsomevalue">Python's random: What happens if I don't use seed(someValue)?</a></p>
<p>Your code should use <code>random.sample(maindeck,k=len(maindeck))</code>.</p>
<hr/>
<p>Code:</p>
<pre><code>import random
random.seed(42) # generate same states if same operations are used 

# https://en.wikipedia.org/wiki/Standard_52-card_deck
ranks = ["ace"] + [str(c) for c in range(2,11)] + ["jack", "queen", "king"]
colors = ["clubs","diamonds","hearts","spades"]

def generate_52_card_deck():
    """Returns a new deck of cards. Each card is a tuple of (rank,color)."""
    return [ (r,c) for c in colors for r in ranks  ]

deck = generate_52_card_deck()    
print(deck)

# inplace
random.shuffle(deck)
print(deck)

new_deck = random.sample(deck,k=52)
print("sampled deck:  ", new_deck[:10])
print("original deck: ", deck[::5])
</code></pre>
<p>Output:</p>
<pre><code># after generation (shortened)
[('ace', 'clubs'), ('2', 'clubs'), ('3', 'clubs'), ('4', 'clubs'), 
 ('5', 'clubs'), ('6', 'clubs'), ('7', 'clubs'), ('8', 'clubs'), 
 ('9', 'clubs'), ('10', 'clubs'), ('jack', 'clubs'), ('queen', 'clubs'),
 ('king', 'clubs'), 
 ('ace', 'diamonds'), ('2', 'diamonds'), ('3', 'diamonds'), ('4', 'diamonds'), 
 ('5', 'diamonds'), ('6', 'diamonds'), ('7', 'diamonds'),  ... , 
 ('jack', 'spades'), ('queen', 'spades'), ('king', 'spades')]


# after shuffling once (shortened)
[('10', 'clubs'), ('jack', 'diamonds'), ('king', 'diamonds'), ('4', 'clubs'),
 ('9', 'diamonds'), ('king', 'hearts'), ('4', 'diamonds'), ('ace', 'spades'), 
 ('7', 'diamonds'), ('queen', 'clubs'), ('8', 'spades'), 
 ('queen', 'diamonds'), ('8', 'hearts'), ('4', 'hearts'), ..., 
 ('9', 'spades'), ('2', 'clubs'), ('8', 'clubs'), ('2', 'spades')]

# first 10 cards ...
sampled deck:   [('4', 'spades'), ('king', 'hearts'), ('ace', 'diamonds'), 
                 ('jack', 'clubs'), ('queen', 'hearts'), ('2', 'hearts'),
                 ('6', 'diamonds'), ('3', 'spades'), ('8', 'hearts'), 
                 ('9', 'diamonds')]

# first 10 cards
original deck:  [('10', 'clubs'), ('jack', 'diamonds'), ('king', 'diamonds'), 
                 ('4', 'clubs'), ('9', 'diamonds'), ('king', 'hearts'), 
                 ('4', 'diamonds'), ('ace', 'spades'), ('7', 'diamonds'), 
                 ('queen', 'clubs')]
</code></pre>
<p>If you need the cards value, use:</p>
<pre><code>def get_base_card_value(c):
    # ace == 11 not done here
    v = {"ace":1 ,"jack":10, "queen":10, "king":10}
    return v.get(c[0]) or int(c[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ah! I see the problem! Your Game "uses up" the main deck because the <code>shuffling()</code> function permutes and returns <em>the</em> <em>original</em> deck:</p>
<pre><code>shuffler = maindeck
</code></pre>
<p>does not create a copy of the main deck. Thus</p>
<pre><code>game_deck.pop(0)
</code></pre>
<p>takes its cards from the main deck, too.</p>
<p>Fix: make a deep copy of the main deck and use that (in <code>shuffling()</code>):</p>
<pre><code>import copy
...
shuffler = copy.deepcopy(maindeck)
</code></pre>
<p>Et voila! a fresh game deck for every game.</p>
</div>
<span class="comment-copy">Your shuffle algorithm isn't a uniform shuffle. Anyways, that aside, you can use <code>random.shuffle(maindeck)</code> instead of your own shuffling function.</span>
<span class="comment-copy">Have you noticed that the last card of the deck never gets shuffled? That's because <code>random.randrange(n)</code> never returns <code>n</code> (even says so in the docs). So you should drop the <code>-1</code> in <code>random.randrange(len(maindeck)-1)</code>.</span>
<span class="comment-copy">@SilverSlash is right about the <a href="https://cs.stackexchange.com/a/47342">non-uniform shuffle</a> (<a href="https://stats.stackexchange.com/a/3087">maths details</a>). Also +1 for pointing to the standard library.</span>
<span class="comment-copy"><code>random.seed()</code> without an argument uses the system time as a seed, which should be sufficient for this task (unless @frank resets the system clock before each game :-) ).</span>
<span class="comment-copy">@digitalarbeiter and it serves no purpose whatsoever because using any random-funtion without seeding it, also takes the system time to give it a random internal state - so you can skip it ...</span>
<span class="comment-copy">@digitalarbeiter see <a href="https://stackoverflow.com/questions/817705/pythons-random-what-happens-if-i-dont-use-seedsomevalue">pythons-random-what-happens-if-i-dont-use-seedsomevalue</a></span>
<span class="comment-copy">Indeed. I brought it up because your initial answer seemed to imply the way frank seeds his shuffle was problematic (rather than just redundant).</span>
