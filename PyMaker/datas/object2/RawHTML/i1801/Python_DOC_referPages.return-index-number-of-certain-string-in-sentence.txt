<div class="post-text" itemprop="text">
<p>I'm looking for a method to find a certain string in a sentence and return the index number of the first letter of that string. While that seemed easy ofcourse, I stumbled upon a problem I can't seem to find the solution. The difficulty in the task is trying to find the index number of the original sentence. So the task is to find the string in the sentence, for the first example this is no problem as the country starts before the first whitespace, however for the second this is not the case.</p>
<pre><code>search = 'Mali' 
sentence = 'Panama lies in Central America.'

search = 'Poland'
sentence = 'The criminal was arrested by Interpol and the local police.'
</code></pre>
<p>So I first wrote this simple code:</p>
<pre><code>indexnumber = sentence.lower().find(search.lower())
</code></pre>
<p>which correctly returns 4 for the first, but 29 for the second (while I need 34), as it does not count the number of non-alpa characters. looking for the original sentence obv gives me a -1 because of the whitespaces in between. I thought about trying to count the number of non-alpha characters in between, but couldn't quite figure out how to do that.</p>
<p>Then I tried some overcomplicated loopings, which seemed to work fine, but I'm sure there must be a more pythonic solution to this, then this complicated construction.</p>
<pre><code>counter = 0
indexnr = 0
possible = []
search = search.replace(" ", "")

for charac in sentence:
    if counter &lt;= len(search) - 1 and charac.isalpha():
        if charac.lower() == search.lower()[counter]:
            counter += 1
            possible += [indexnr]
        else:
            counter = 0
            possible = []
    indexnr += 1

print(possible[0])
</code></pre>
<p>Basically, this is a for loop, which creates a list when the letter in the sentence equals the first letter in search, and then looks for the second letter in search and so forth until there is a complete match and the length of the list is equal to the length of the search aka there is a complete match. if there's not a full match, i reset the counter to 0 and clear the list again.</p>
<p>Although this works, I'm looking for an easier solution, for example a way to tell the find function to look in the original sentence, but when it reaches a non-alpha characters, it ignores it or keeps searching until a alpa character screws it up.</p>
<p>Apologies for any possible mistakes with the indenting, first time i'm pasting code here. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following regular expression for searching. These regex can be created by using a for loop.</p>
<p>Check it out on the following link: <a href="https://regexr.com/42eq1" rel="nofollow noreferrer">https://regexr.com/42eq1</a></p>
<p>I dont think there would be a better option :|</p>
<p>[\ ]* -- This searches for 0 or more spaces.</p>
<pre><code>search = 'Mali'
sentence1 = 'Panama lies in Central America.'

search = 'Poland'
sentence = 'The criminal was arrested by Interpol and the local police.'


p = re.compile("[m][\ ]*[a][\ ]*[l][\ ]*[i]")
p = re.compile("[p][\ ]*[o][\ ]*[l][\ ]*[a][\ ]*[n][\ ]*[d]")

indexnumber = sentence.lower().find(search.lower())
print(indexnumber)
print(re.search(p,sentence).start())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for the responses guys. I believe you meant something like this?</p>
<pre><code>for charac in search:
    if charac.isalpha():
        regexpr += '[' + charac.lower() + '][\ ]*'

q = re.compile(regexpr)

indexnr = re.search(q, sentence).start()
</code></pre>
<p>I'm still trying to learn the reg expressions. If i'm not mistaken, if I want to also ignore comma's for example, I should modify the [\ ]* with my own expression right. </p>
<p>edit: is there a possibility to also format your code if you just comment? Didn't find it immediately, so had to answer my own question instead</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>This is easily solved with the regex library.</p>
<p>Read the regex pattern operators section and flags section of the
  regex library <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">docs</a>.</p>
<p>Once you have this, do <code>[pattern].search(target_string)</code>. Save the
  output to a variable - if it matched you will get a match object.</p>
<p>With the matched object you will be able to find the start and end by
  asking for <code>.group(0).start</code> or <code>group(0).end</code> on the variable you
  saved the match object as.</p>
</blockquote>
<p><strong><em>EDIT:</em></strong> I have realised that much of what I have said is wrong, and solving with regex in the normal way is not quite so easy if the word boundary/ies are unknown. @user2849789's answer is better, and does support regex, but in case anybody was looking for another solution which doesn't require regex:</p>
<pre><code>search = 'Poland'
sentence = 'The criminal was arrested by Interpol and the local police.'

srch = search.lower()

sentce = sentence.lower()

indexNr = 0

while indexNr &lt; len(sentce):
    print("sentce[indexNr]=", sentce[indexNr]) #debug
    if sentce[indexNr] == srch[0]:
        print("Found starting char: ", srch[0])
        srchNr = 1
        spaces = 0
        while sentce[(indexNr + srchNr + spaces)] == srch[srchNr] or sentce[(indexNr + srchNr)] == " ":
            print(f"Searching for match! Search char is currently", srch[srchNr], "sentce[(indexNr + srchNr + spaces)] is '" + sentce[(indexNr + srchNr + spaces)] + "'")
            if sentce[(indexNr + srchNr + spaces)] == srch[-1]:
                print("Found word irrelevant of word boundaries! Starting index is ", indexNr)
                break
                #return indexNr
            elif sentce[indexNr + srchNr + spaces] == srch[srchNr]:
                #increment nested while loop counter
                srchNr += 1
            elif sentce[(indexNr + srchNr + spaces)] == " ":
                spaces += 1
    indexNr += 1
</code></pre>
</div>
<span class="comment-copy">If any of the above answers has helped you, do help to upvote and accept them. Since you are a new contributor you might not know :)</span>
<span class="comment-copy">yes, you can format text in the same way in a comment.</span>
<span class="comment-copy">You wouldn't <code>+=</code> onto a regex, the pattern should stay fixed in nearly all cases. After providing my own answer I realised that I don't <i>think</i> I know of a way to do it in regex where the word boundary can be anywhere, there might be still but I don't know of it</span>
