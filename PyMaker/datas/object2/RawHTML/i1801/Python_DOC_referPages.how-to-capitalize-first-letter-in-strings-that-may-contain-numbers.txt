<div class="post-text" itemprop="text">
<p>I would like to read through a file and capitalize the first letters in a string using Python, but some of the strings may contain numbers first. Specifically the file might look like this:</p>
<pre><code>"hello world"
"11hello world"
"66645world hello"
</code></pre>
<p>I would like this to be:</p>
<pre><code>"Hello world"
"11Hello world"
"66645World hello"
</code></pre>
<p>I have tried the following, but this only capitalizes if the letter is in the first position.</p>
<pre><code>with open('input.txt') as input, open("output.txt", "a") as output:
    for line in input:
        output.write(line[0:1].upper()+line[1:-1].lower()+"\n")
</code></pre>
<p>Any suggestions? :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Using regular expressions:</p>
<pre><code>for line in output:
    m = re.search('[a-zA-Z]', line);
    if m is not None:
        index = m.start()
        output.write(line[0:index] + line[index].upper() + line[index + 1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use regular expression to find the position of the first alphabet and then use <code>upper()</code> on that index to capitalize that character. Something like this should work:</p>
<pre><code>import re

s =  "66645hello world"
m = re.search(r'[a-zA-Z]', s)
index = m.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can write a function with a <code>for</code> loop:</p>
<pre><code>x = "hello world"
y = "11hello world"
z = "66645world hello"

def capper(mystr):
    for idx, i in enumerate(mystr):
        if not i.isdigit():  # or if i.isalpha()
            return ''.join(mystr[:idx] + mystr[idx:].capitalize())
    return mystr

print(list(map(capper, (x, y, z))))

['Hello world', '11Hello world', '66645World hello']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>import re

text = "1234hello"
index = re.search("[a-zA-Z]", text).start()
text_list = list(text)
text_list[index] = text_list[index].upper()

''.join(text_list)
</code></pre>
<p>The result is: <code>1234Hello</code></p>
</div>
<div class="post-text" itemprop="text">
<p>May be worth trying ...</p>
<pre><code>&gt;&gt;&gt; s = '11hello World'
&gt;&gt;&gt; for i, c in enumerate(s):
...     if not c.isdigit():
...         break
... 
&gt;&gt;&gt; s[:i] + s[i:].capitalize()
'11Hello world'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can find the first alpha character and capitalize it like this:</p>
<pre><code>with open("input.txt") as in_file, open("output.txt", "w") as out_file:
    for line in in_file:
        pos = next((i for i, e in enumerate(line) if e.isalpha()), 0)
        line = line[:pos] + line[pos].upper() + line[pos + 1:]
        out_file.write(line)
</code></pre>
<p>Which Outputs:</p>
<pre><code>Hello world
11Hello world
66645World hello
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like this, for example:</p>
<pre><code>import re

re_numstart = re.compile(r'^([0-9]*)(.*)')

def capfirst(s):
    ma = re_numstart.match(s)
    return ma.group(1) + ma.group(2).capitalize()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try this:</p>
<pre><code>with open('input.txt') as input, open("output.txt", "a") as output:
for line in input:
    t_line = ""
    for c in line:
        if c.isalpha():
            t_line += c.capitalize()
            t_line += line[line.index(c)+1:]
            break
        else:
            t_line += c
    output.write(t_line)
</code></pre>
<p>Execution result:</p>
<pre><code>Hello world
11Hello world
66645World hello
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expression</a> for that:</p>
<pre><code>import re

line = "66645world hello"

regex = re.compile(r'\D')
tofind = regex.search(line)
pos = line.find(tofind.group(0))+1

line = line[0:pos].upper()+line[pos:-pos].lower()+"\n"

print(line)
</code></pre>
<p>output: <code>66645World</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There is probably a one-line REGEX approach, but using <code>title()</code> should also work:</p>
<pre><code>def capitalise_first_letter(s):
    spl = s.split()
    return spl[0].title() + ' ' + ' '.join(spl[1:])

s = ['123hello world',
"hello world",
"11hello world",
"66645world hello"]


for i in s:
    print(capitalise_first_letter(i))
</code></pre>
<p>Producing:</p>
<pre><code>Hello world
11Hello world
66645World hello
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Okay, there is already a lot of answers, that should work.</p>
<p>I find them overly complicated or complex though...</p>
<p>Here is a simpler solution:</p>
<pre><code>for s in ("hello world", "11hello world", "66645world hello"):
    first_letter = next(c for c in s if not c.isdigit())
    print(s.replace(first_letter, first_letter.upper(), 1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>title()</code> method will capitalize the first alpha character of the string, and ignore the digits before it. It also works well for non-ASCII characters, contrary to the regex methods using <code>[a-zA-Z]</code>.</p>
<p>From the doc:</p>
<blockquote>
<p>str.title() </p>
<p>Return a titlecased version of the string where words
  start with an uppercase character and the remaining characters are
  lowercase. [...] The algorithm uses a simple language-independent
  definition of a word as groups of consecutive letters. The definition
  works in many contexts but it means that apostrophes in contractions
  and possessives form word boundaries, which may not be the desired
  result:</p>
</blockquote>
<p>We can take advantage of it this way:</p>
<pre><code>def my_capitalize(s):
    first, rest = s.split(maxsplit=1)
    split_on_quote = first.split("'", maxsplit=1)
    split_on_quote[0] = split_on_quote[0].title()
    first = "'".join(split_on_quote)

    return first + ' ' + rest
</code></pre>
<p>A few tests:</p>
<pre><code>tests = ["hello world", "11hello world", "66645world hello", "123ça marche!", "234i'm good"]
for s in tests:
    print(my_capitalize(s))

# Hello world
# 11Hello world
# 66645World hello
# 123Ça marche!  # The non-ASCII ç was turned to uppercase
# 234I'm good    # Words containing a quote are treated properly
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="https://docs.python.org/2/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> and <em>repl</em> as a function:</p>
<blockquote>
<p>If repl is a function, it is called for every non-overlapping
  occurrence of pattern. The function takes a single match object
  argument, and returns the replacement string.</p>
</blockquote>
<pre><code>def capitalize(m):
    return m.group(1) + m.group(2).upper() + m.group(3)

lines = ["hello world", "11hello world", "66645world hello"]
for line in lines:
    print re.sub(r'(\d*)(\D)(.*)', capitalize, line)
</code></pre>
<p>Output:</p>
<pre>
Hello world
11Hello world
66645World hello
</pre>
</div>
<div class="post-text" itemprop="text">
<p>Using isdigit() and title() for strings:</p>
<pre><code>s = ['123hello world', "hello world", "11hello world", "66645world hello"]
print [each if each[0].isdigit() else each.title() for each in s ]


# ['123hello world', 'Hello World', '11hello world', '66645world hello']                                                                          
</code></pre>
</div>
<span class="comment-copy">Issue with using [a-z] only would be that it can match alphabet which might not be the first alphabet in the string (if the first alphabet is already in upper case).</span>
<span class="comment-copy">@AnkitJaiswal Yeah I wasn't being super formal, but there's a lot of error checking that can go into this answer to make it more robust.</span>
<span class="comment-copy">This would work if there is no case where the first alphabet comes after a space.</span>
<span class="comment-copy">@AnkitJaiswal, Yup, this doesn't require any splitting. So it should work provided <code>str.isdigit</code> is acceptable for OP's user case.</span>
<span class="comment-copy">Wouldn't it be better to reverse the condition and use <code>string.isalpha()</code> instead?</span>
<span class="comment-copy">@AnkitJaiswal, Not sure what's more efficient. In <i>most</i> cases, though not all, they'll be equivalent. Can you give an example where it wouldn't work?</span>
<span class="comment-copy">This, in my opinion, is preferable to regex.</span>
<span class="comment-copy">@jpp wouldn't this allow non-alphabets also? This is checking for digits only.</span>
<span class="comment-copy">@AnkitJaiswal Good point. Changed it to ignore everything but letters.</span>
