<div class="post-text" itemprop="text">
<p>I'm using <em>Python 2.7.15, Windows 7</em></p>
<p><strong>Context</strong></p>
<p>I wrote a script to read and tokenize each line of a FileZilla log file (specifications <a href="https://wiki.filezilla-project.org/Server_logs" rel="nofollow noreferrer">here</a>) for the IP address of the host that initiated the connection to the FileZilla server. I'm having trouble parsing the <code>log text</code> field that follows the <code>&gt;</code> character. The script I wrote uses the: </p>
<pre><code>    with open('fz.log','r') as rh:
       for lineno, line in rh: 
          pass
</code></pre>
<p>construct to read each line. That for-loop stopped prematurely when it encountered a <code>log text</code> field that contained the <code>SOH</code> and <code>SUB</code> characters. I can't show you the log file since it contains sensitive information but the crux of the problem can be reproduced by reading a textfile that contains those characters on a line. </p>
<p>My goal is to extract the IP addresses (which I can do using <code>re.search()</code>) but before that happens, I have to remove those control characters. I do this by creating a copy of the log file where the lines containing those control characters are removed. There's probably a better way, but I'm more curious why the for-loop just stops after encountering the control characters.</p>
<p><strong>Reproducing the Issue</strong></p>
<p>I reproduced the problem with this code: </p>
<pre><code>if __name__ == '__main__':
    fn = 'writetest.txt'
    fn2 = 'writetest_NoControlChars.txt'

    # Create the problematic textfile
    with open(fn, 'w') as wh: 
        wh.write("This line comes first!\n");
        wh.write("Blah\x01\x1A\n"); # Write Start-of-Header and Subsitute unicode character to line
        wh.write("This comes after!")

    # Try to read the file above, removing the SOH/SUB characters if encountered
    with open(fn, 'r') as rh:
        with open(fn2, 'w') as wh:
            for lineno, line in enumerate(rh):
                sline = line.translate(None,'\x01\x1A')
                wh.write(sline)
                print "Line #{}: {}".format(lineno, sline)
    print "Program executed."
</code></pre>
<p><strong>Output</strong></p>
<p>The code above creates 2 output files and produces the following in a console window: </p>
<pre><code>Line #0: This line comes first!

Line #1: Blah
Program executed.
</code></pre>
<p>I step-debugged through the code in Eclipse and immediately after executing the </p>
<pre><code>for lineno, line in enumerate(rh): 
</code></pre>
<p>statement, <code>rh</code>, the handle for that opened file was closed. I had expected it to move onto the third line, printing out <code>This comes after!</code> to console and writing it out to <code>writetest_NoControlChars.txt</code> but neither events happened. Instead, execution jumped to <code>print "Program executed"</code>.
<a href="https://i.stack.imgur.com/DfnAx.jpg" rel="nofollow noreferrer">Picture of Local Variable values in Debug Console</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You have to open this file in binary mode if you know it contains non-text data: <code>open(fn, 'rb')</code></p>
</div>
<span class="comment-copy">You have to open this file in binary mode if you know it contains non-text data: <code>open(fn, 'rb')</code></span>
<span class="comment-copy">Changing <code>with open(fn, 'r') as rh:</code> to <code>with open(fn, 'rb') as rh:</code> like you suggested worked. Thanks (I'd be happy to accept your answer if you post it as such)!</span>
<span class="comment-copy">I dug a little deeper and the documentation for <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">open()</a> says opening a file in binary mode returns contents of the file as bytes without decoding. By default, <code>open()</code> operates in <code>'Text I/O'</code> mode, which is why it didn't work. I looked at the API for the <a href="https://docs.python.org/3/library/io.html#io.TextIOBase" rel="nofollow noreferrer">io module</a> but couldn't find anything that would explain why the file descriptor would be closed in text mode when those characters are encountered. Did I miss something? How can I dig deeper for an explanation?</span>
<span class="comment-copy">Which operating system and Python version are you using? On my Mac with Python 2.7.11, your code above reports 'This comes after!' at the appropriate time.</span>
<span class="comment-copy"><code>0x1A</code> is, on DOS and Windows systems, the End Of Text code <code>Ctrl-Z</code> for text mode I/O.</span>
<span class="comment-copy">What decides what is "non-text data"? Do you have a reference for that in the official documentation?</span>
<span class="comment-copy">I guess any byte stream which cannot be assigned some known text encoding (utf-8, latin1, windows-1251, etc) should be considered binary. Opening file in binary mode turns off any automatic parsing/processing that happens for text files.</span>
