<div class="post-text" itemprop="text">
<p>I'm sorry if the title is a little bit vague; I am not sure how to put my concern into words. I am a beginner in Python and I am making a Boggle/Word Search game.  </p>
<p><img alt="Please view this image." src="https://i.stack.imgur.com/wrJQe.png"/></p>
<p>I would like the board to stay in the same place/not get pushed back by the user inputs. <strong>Is that possible?</strong></p>
<p>I tried opening a <code>.txt</code> file in <strong>Python</strong> via Notepad but the code stops once the txt file is open; any help with this will do.</p>
<p>I wonder if it is also possible to make python open a new window/console to display the board while the other console goes on and executes the original code.</p>
<p>Finally, <strong>is there a way kind of 'refresh' the user inputs here</strong>? </p>
<p>I would like the line to be empty once the user submits their answer. I've tried making a GUI with tkinter but it was too difficult for me due to the number of pages that I made and that I really have no idea how to use it.</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You have three possible solutions: </p>
<ol>
<li>reprint the whole screen as you want it displayed after user input</li>
<li>create a GUI, where you have a lot more control over what is displayed</li>
<li>if on Unix you can try using <a href="https://docs.python.org/3/howto/curses.html" rel="nofollow noreferrer"><code>curses</code></a> </li>
</ol>
<p>Since, you've already tried tkinter, then the GUI route seems a no-go route for you currently. So you may have similar problems with curses as well. As such, I'd recommend sticking to just reprinting your screen as you want it. You'll end up with a history of previous boards and guesses, but it's an easy way to control what the screen looks like.</p>
<p>eg.</p>
<pre><code>def mainloop(board, words, time_limit):
    correct_guesses = []
    print_board(board)
    while not solved(words, correct_guesses) and now() &lt; time_limit:
         word = get_user_guess()
         if word in words and word not in correct_guesses:
             correct_guesses.append(word)
             print('correct!\n')
         else:
             print('wrong!\n')

    if solved(words, correct_guesses):
        print('complete!')
    else:
        print('times up!')
</code></pre>
<p>You'll end up with something like:</p>
<pre><code>E B C D
C F G H
I J K L
M N O P
your guess: mouse
wrong!

E B C D
C F G H
I J K L
M N O P
your guess: mice
correct!

complete!
</code></pre>
<p>If you want to try <code>curses</code> here is a basic script to get you started:</p>
<pre><code>import curses


def main(stdscr):
    board = [
        ['E', 'B', 'C', 'D'],
        ['C', 'F', 'G', 'H'],
        ['I', 'J', 'K', 'L'],
        ['M', 'N', 'O', 'P'],
    ]

    curses.echo()  # we want to see user input on screen

    user_guess_prompt = 'your guess: '
    guess_line = len(board) + 1 + 2
    guess_column = len(user_guess_prompt)
    max_guess_size = 15

    guess = None
    while guess != 'q':
        # clear the entire screen
        stdscr.clear()

        # a bit of help on how to quit (unlike print, we have to add our own new lines)
        stdscr.addstr('enter q as a guess to exit\n\n')

        # print the board
        for line in board:
            stdscr.addstr(' '.join(line)+'\n')

        # tell the use about their previous guess
        if guess == 'mice':
            stdscr.addstr(guess + ' is correct!\n')
        elif guess is None:
            stdscr.addstr('\n')
        else:
            stdscr.addstr(guess + ' is wrong!\n')

        # prompt for the user's guess
        stdscr.addstr(user_guess_prompt)

        # tell curses to redraw the screen
        stdscr.refresh()

        # get user input with the cursor initially placed at the given line and column 
        guess = stdscr.getstr(guess_line, guess_column, max_guess_size).decode('ascii')


if __name__ == '__main__':
    curses.wrapper(main)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach you may use with python built-in means is to refresh all the data on the screen (clear and print again) when it is necessary. Try the sample code (should work in linux terminal and windows console):</p>
<pre><code>import os
import sys

if sys.platform.startswith("win"):
    def clear_screen():
        os.system('cls')
else:
    def clear_screen():
        os.system('clear')

def print_board(board):
    for row in board:
        print(*row)

data = [[1, 1], [1, 1]]

clear_screen()
print_board(data)

diff = input('\nPlease enter difficulty (easy, medium, hard): ')

clear_screen()
print_board(data)

limit = input('\nEnter time limit in minutes: ')

words = list()
counter = 0
while True:
    clear_screen()
    print_board(data)
    print('\nTime limit is {} minutes.'.format(limit))
    print('\nInput the words you see.')
    words.append(input('&gt;&gt;&gt; '))
    counter += 1
    if counter == 3:
        break

clear_screen()
print_board(data)
print('\nYou have entered the words:')
print(*words, sep=', ')

print('\nEND')
</code></pre>
</div>
<span class="comment-copy">Sorry but this is too broad currently. Without a reproducible example, it's hard to understand what your issue is.</span>
<span class="comment-copy">You need to design and implement a human interface for your program. If you want to keep it text-based, depending on the OS, there may be libraries available the will allow positioning the cursor anywhere within the console (aka terminal) window and output text starting there.Search for things related to <a href="https://en.wikipedia.org/wiki/Curses_(programming_library)" rel="nofollow noreferrer">curses</a>, one common way to do this. Your other choice is to have a graphical human interface. Python comes with a library named <code>tkinter</code> that can be used and there are other third-party ones, like <code>wxPython</code> available, too.</span>
<span class="comment-copy">A fairly common practice way to do this in the idle is to create a buffer to make it appear that the board position never changes. This can be done with a series of newlines encapsulating your board. The exact number needed will depend on your need but here is an example. <code>print("\n"*100+my_board_text)</code> This print's 100 new lines followed by your board.</span>
<span class="comment-copy">For Windows, there's a <code>curses</code> build mentioned in <a href="https://stackoverflow.com/a/19851287/355230">this answer</a> to the question <a href="https://stackoverflow.com/questions/14779486/curses-alternative-for-windows">Curses alternative for windows</a>.</span>
<span class="comment-copy">Thank you for this! I think I'll just go with printing the board everytime a user inputs their answers.</span>
