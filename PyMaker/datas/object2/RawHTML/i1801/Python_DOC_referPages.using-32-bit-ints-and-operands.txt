<div class="post-text" itemprop="text">
<p>Is it possible to somehow override or overload the standard implementation of ints/numbers in python so that it acts like a 32-bit int.</p>
<pre class="lang-none prettyprint-override"><code>a: int
a = 4076863488
&gt;&gt;&gt; -218103808
</code></pre>
<p>Or is it possible to somehow define a variable that can't change type? Doing something like: <code>x: int</code>?
I want to do this because it's annoying to write <code>ctypes.c_int32(n)</code> on every bit operation and assignment. Especially since Python does not use 32 bits bitwise operands.</p>
<p>I know I'm basically trying to change the nature of the language. So maybe I'm asking what you would do if you had to do 32-bit stuff in python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some options:</p>
<ul>
<li>Use Cython. You can declare a native 32-bit int type there, and you even get the advantage that pure numerical code gets compiled to (very) fast C code.</li>
<li>Use a <code>numpy</code> array of a single element: <code>np.zeros((1,), dtype=np.int32)</code>. Provided you only ever use in-place operations (<code>+=</code>, <code>*=</code>, etc.), this will work like a 32-bit int type. Do be aware that if you ever use a regular binary operator (e.g. <code>myint + 3</code>), you might be subjected to type promotion or conversion, and the result will no longer be <code>int32</code>.</li>
<li>Use <code>ctypes.c_int32</code>. This comes built-in to Python, but supports no mathematical operations so you have to wrap and unwrap yourself (e.g. <code>newval = c_int32(v1.value + v2.value)</code>).</li>
<li>Use a library like <a href="https://github.com/nneonneo/fixedint" rel="nofollow noreferrer"><code>fixedint</code></a> (shameless plug), which provides fixed-integer classes that remain fixed size through operations rather than decaying to <code>int</code>. <code>fixedint</code> was specifically designed with fixed-width bitwise math in mind. In this case you would use <code>fixedint.Int32</code>.</li>
</ul>
<p>Some less desirable options:</p>
<ul>
<li><code>struct</code>: Throws errors if your input is out of range. You can work around this with <code>unpack('i', pack('I', val &amp; 0xffffffff))[0]</code>, but that's really unwieldy.</li>
<li><code>array</code>: Throws errors if you try to store a value out of range. Harder to work around than <code>struct</code>.</li>
<li><p>Manual bitmashing. With an unsigned 32-bit int, this is just a matter of adding <code>&amp; 0xffffffff</code> a lot, which is not too bad. But, Python doesn't have any built-in way to wrap a value to a signed 32-bit int, so you'll have to write your own <code>int32</code> conversion function and wrap all your operations with it:</p>
<pre><code>def to_int32(val):
    val &amp;= ((1&lt;&lt;32)-1)
    if val &amp; (1&lt;&lt;31): val -= (1&lt;&lt;32)
    return val
</code></pre></li>
</ul>
<p>Demonstrations of your options:</p>
<h3>Cython</h3>
<pre><code>cpdef int munge(int val):
    cdef int x
    x = val * 32
    x += 0x7fffffff
    return x
</code></pre>
<p>Save as <code>int_test.pyx</code> and compile with <code>cythonize -a -i int_test.pyx</code>.</p>
<pre><code>&gt;&gt;&gt; import int_test
&gt;&gt;&gt; int_test.munge(3)
-2147483553
</code></pre>
<h3>NumPy</h3>
<pre><code>import numpy as np

def munge(val):
    x = val.copy()
    x *= 32
    x += 0x7fffffff
    return x

def to_int32(val):
    return np.array((val,), dtype=np.int32)

print(munge(to_int32(3)))
# prints [-2147483553]
</code></pre>
<h3>ctypes</h3>
<pre><code>from ctypes import c_int32
def munge(val):
    x = c_int32(val.value * 32)
    x = c_int32(x.value + 0x7fffffff)
    return x

print(munge(c_int32(3)))
# prints c_int(-2147483553)
</code></pre>
<h3>fixedint</h3>
<pre><code>import fixedint

def munge(val):
    x = val * 32
    x += 0x7fffffff
    return x

print(munge(fixedint.Int32(3)))
# prints -2147483553
</code></pre>
</div>
<span class="comment-copy">Changing the standard implementation or fixing type for a variable isn't possible (without heavily modifying Python's source code). Most bit operations (<code>&amp; | ^</code>) work with Python's <code>int</code> very well without much difference to an <code>int32</code>.</span>
<span class="comment-copy"><code>int</code>s in Python itself are variable length, but as @MichaelButscher correctly points out, you can generally ignore that and just don't put anything in one that requires more than 32-bits to represent.</span>
<span class="comment-copy">so.. numpy or ctypes then maybe. It needs to overflow, im implementing c code to python (read trying)</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/array.html#module-array" rel="nofollow noreferrer"><code>array</code></a> and <a href="https://docs.python.org/3/library/struct.html#module-struct" rel="nofollow noreferrer"><code>struct</code></a> modules may also be helpful, depending on exactly what you're doing. Also see the answers to the question <a href="https://stackoverflow.com/questions/16745387/python-32-bit-and-64-bit-integer-math-with-intentional-overflow">python 32-bit and 64-bit integer math with intentional overflow</a>.</span>
<span class="comment-copy">Good list; you should add <code>ctypes</code> as it is available basically everywhere without installing anything extra.</span>
<span class="comment-copy">objectnabb: <code>fixedint</code> is also available from <a href="https://pypi.org/project/fixedint/" rel="nofollow noreferrer">PyPi</a> which means it can easily be installed via <code>pip</code>.</span>
<span class="comment-copy">Thank you! This is a very good list. I will have to check these out.</span>
<span class="comment-copy">I am a little bit confuse  here. `  b = 4076863488           print(b)             print(ctypes.c_int32(b))             print(b &amp; 0xffffffff)     `     outputs: <code>4076863488 c_long(-218103808)     4076863488     </code></span>
<span class="comment-copy">@objectnabb <code>b</code> is unchanged by the call to <code>c_int32</code> - the middle print statement is printing a new object that has the signed 32-bit value of the original. Because <code>b</code> has bit 31 set, it is interpreted as a negative integer in 32 bit 2s complement.</span>
