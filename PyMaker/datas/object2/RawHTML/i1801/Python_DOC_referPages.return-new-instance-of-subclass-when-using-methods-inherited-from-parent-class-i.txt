<div class="post-text" itemprop="text">
<p>I want to create a new <code>__str__</code> method for complex type. </p>
<pre><code>import numpy as np  

class Phasor(complex):
    def __str__(self):   
        magnitude = (self.real**2 + self.imag**2)**.5
        angle = np.arctan2(self.imag, self.real)
        return "%s ∠ %s°" % (round(magnitude, 2), round(np.degrees(angle), 2))

a = Phasor(1+1j)
print(a)
print(type(a))
print(a**2)
print(type(a**2))
</code></pre>
<p>Returns</p>
<pre><code>1.41 ∠ 45.0°
&lt;class '__main__.Phasor'&gt;
2j
&lt;type 'complex'&gt;
</code></pre>
<p>In this case, raising the instance to the power returns a complex type instance and not a subclass instance.  </p>
<p>I would like inherited methods to return new instances of the subclass and not complex.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order for arithmetic operators to return an instance of your subclass, you'll have to implement the relevant <a href="https://docs.python.org/3/reference/datamodel.html#object.__add__" rel="nofollow noreferrer">special methods</a> like <code>__add__</code>, <code>__mul__</code>, <code>__pow__</code>, etc.</p>
<p>The bad news is that there's a lot of those methods. The good news is that you can write code that automatically generates those functions for you. Here's a class decorator that does exactly that:</p>
<pre><code>def add_arithmetic_methods(cls):
    def make_func(func_name):
        def func(self, *args, **kwargs):
            super_method = getattr(super(cls, self), func_name)
            return type(self)(super_method(*args, **kwargs))

        func.__name__ = func_name
        func.__qualname__ = '{}.{}'.format(cls.__qualname__, func_name)
        func.__module__ = cls.__module__

        return func

    for func_name in ['add', 'sub', 'mul', 'matmul', 'truediv', 'floordiv',
                      'mod', 'divmod', 'pow', 'lshift', 'rshift', 'and',
                      'xor', 'or', 'radd', 'rsub', 'rmul', 'rmatmul',
                      'rtruediv', 'rfloordiv', 'rmod', 'rdivmod', 'rpow',
                      'rlshift', 'rrshift', 'rand', 'rxor', 'ror', 'iadd',
                      'isub', 'imul', 'imatmul', 'itruediv', 'ifloordiv',
                      'imod', 'ipow', 'ilshift', 'irshift', 'iand', 'ixor',
                      'ior', 'neg', 'pos', 'abs', 'invert']:
        func_name = '__{}__'.format(func_name)
        func = make_func(func_name)
        setattr(cls, func_name, func)

    return cls
</code></pre>
<p>Slap this onto your <code>Phasor</code> class and you're done:</p>
<pre><code>@add_arithmetic_methods
class Phasor(complex):
    def __str__(self):   
        magnitude = (self.real**2 + self.imag**2)**.5
        angle = np.arctan2(self.imag, self.real)
        return "%s ∠ %s°" % (round(magnitude, 2), round(np.degrees(angle), 2))

c = Phasor(3+5j)
print(c**2)
# output: 34.0 ∠ 118.07°
</code></pre>
</div>
<span class="comment-copy">You'll have to implement all the special methods responsible for arithmetic, like <code>__add__</code>, <code>__mul__</code>, <code>__div__</code>, etc.</span>
<span class="comment-copy">@Aran-Fey Might it be possible to create a method that wraps method calls like those?</span>
<span class="comment-copy">@NChauhan Sure, you can write a class decorator that automatically creates those methods for you.</span>
