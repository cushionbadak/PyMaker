<div class="post-text" itemprop="text">
<p>As best I can describe it, I have two lists of strings and I want to return all results from list A that contain any of the strings in list B. Here are details:</p>
<pre><code>A = ['dataFile1999', 'dataFile2000', 'dataFile2001', 'dataFile2002']
B = ['2000', '2001']
</code></pre>
<p>How do I return </p>
<pre><code>C = ['dataFile2000', 'dataFile2001']?
</code></pre>
<p>I've been looking into list comprehensions, doing something like below </p>
<pre><code>C=[x for x in A if B in A] 
</code></pre>
<p>but I can't seem to make it work. Am I on the right track?</p>
</div>
<div class="post-text" itemprop="text">
<p>You were close, use <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any</a>:</p>
<pre><code>C=[x for x in A if any(b in x for b in B)]
</code></pre>
<p>More detailed:</p>
<pre><code>A = ['dataFile1999', 'dataFile2000', 'dataFile2001', 'dataFile2002']
B = ['2000', '2001']

C = [x for x in A if any(b in x for b in B)]

print(C)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['dataFile2000', 'dataFile2001']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any()</a> to check if any element of your list <code>B</code> is in x:</p>
<pre><code>A = ['dataFile1999', 'dataFile2000', 'dataFile2001', 'dataFile2002']

B = ['2000', '2001'] 

c = [x for x in A if any(k in x for k in B)]

print(c)
</code></pre>
<p>Output:</p>
<pre><code>['dataFile2000', 'dataFile2001']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, I would construct a <code>set</code> of the years for the O(1) lookup time.<sup>1</sup></p>
<pre><code>&gt;&gt;&gt; A = ['dataFile1999', 'dataFile2000', 'dataFile2001', 'dataFile2002']
&gt;&gt;&gt; B = ['2000', '2001']
&gt;&gt;&gt; 
&gt;&gt;&gt; years = set(B)
</code></pre>
<p>Now, keep only the elements of <code>A</code> that end with an element of <code>years</code>.</p>
<pre><code>&gt;&gt;&gt; [file for file in A if file[-4:] in years]
&gt;&gt;&gt; ['dataFile2000', 'dataFile2001']
</code></pre>
<p><sup>1</sup> If you have very small lists (two elements certainly qualify) keep the lists. Sets have O(1) lookup but the hashing still introduces overhead.</p>
</div>
<span class="comment-copy">Brilliant, this worked like a charm. Thanks for the quick response!</span>
