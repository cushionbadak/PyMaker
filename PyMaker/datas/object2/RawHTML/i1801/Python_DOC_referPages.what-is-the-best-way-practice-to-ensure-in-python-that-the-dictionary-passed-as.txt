<div class="post-text" itemprop="text">
<p>Suppose there are 2 python modules - Library and application .</p>
<p>Library code : </p>
<pre><code>class lib():

    def __init__(self,arg):
        smallArg = arg['key1']['key2']
        smallArg['key3'] = 2
</code></pre>
<p>Application code :</p>
<pre><code>class app():

    def __init__(self):
        self.arg = {'key1' : {'key2' : {'key3' : 1}}}
        self.libObj = lib(self.arg)

    def getArg(self):
        print(self.arg)

appObj = app()
app.getArg()
</code></pre>
<p>since dictionaries are mutable , this prints the dictionary {'key1' : {'key2' : {'key3' : 2}}} which was changed by library code. This means library could even add more keys or delete them , and application would also get that mutated dictionary. </p>
<p>is there a way/practice to really ensure that the other modules don't disturb the structure of the dictionary passed ?? </p>
<p>---&gt; using copy.deepcopy() or json.loads(json.dumps()) doesn't seem the right way. There must be a better way !</p>
<p>This is just a small example where 2 modules interact with each other. Think about several more modules passing nested dictionaries to each other , computing them and returning them.Any module can change the structure of the nested dictionary. There is a good chance of missing out this detail and might break the code. </p>
<p>Is there a better way ? There must be.  </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, there is no analogue of private or protected data that some other languages attempt to provide. To really preserve the original, <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>copy.deepcopy</code></a> would be the best choice, and you just pay the price of copying the data in memory.</p>
<p>For a shallow map of key/vals, you could avoid a copy by passing a mapping proxy around:</p>
<pre><code>&gt;&gt;&gt; from types import MappingProxyType
&gt;&gt;&gt; d = {'k': 'v'}
&gt;&gt;&gt; d_readonly = MappingProxyType(d)
&gt;&gt;&gt; d_readonly['k']
'v'
&gt;&gt;&gt; d_readonly['k'] = 'spam'
TypeError: 'mappingproxy' object does not support item assignment
</code></pre>
<p>However, this only really works for simple cases: mutable objects nested within <code>d</code>, such as lists and dicts, could still be modified.  </p>
<p>As a style note, most Python developers do not try to program this defensively. Instead, you would just trust the documentation (or RTFS) about whether a library will or will not mutate an input. <strong>Well written libraries will seldom mutate inputs as a side-effect</strong>. Generally, functions will either:</p>
<ul>
<li>Avoid modifying inputs, and return a new object (e.g. <code>sorted</code>), or </li>
<li>Modify the input in-place, and not return anything (e.g. <code>list.sort</code>)</li>
</ul>
</div>
<span class="comment-copy">A function should never mutate any input arguments unless that's the function's only purpose. A constructor shouldn't be doing that.</span>
<span class="comment-copy">If the function's purpose is to modify the argument, and you don't want the modification to affect your original, then <code>deepcopy()</code> is the best solution. Why don't you think it's the right way?</span>
<span class="comment-copy">one simpler way is that you keep a key in dictionary with mutated set to false, and whenever a dictionary is updated make sure to update that key to true hence you can just verify whether dictionary is mutated or not, however if you want to access unchanged version <code>deepcopy()</code> is actually the right way to do so.</span>
<span class="comment-copy">For a in depth discussion on the 'why' of why deepcopy is the correct approach (ignoring the obvious design issues of a lib mutating values) see the pep here -- <a href="https://www.python.org/dev/peps/pep-0416/" rel="nofollow noreferrer">python.org/dev/peps/pep-0416</a></span>
<span class="comment-copy">@DishantArora: It sounds like you're trying to use a technical means to prevent others on your team from writing bad code. That is a noble goal, but the Python language is not designed to support that goal: in Python, even basic protections about private object members are only enforced by convention, not by any language feature. Python takes the stance that programmers should be trusted to understand the libraries they use, and to write code that is not buggy. Whether that trust is a good thing or not is certainly debatable, but for better or worse that's what Python is.</span>
<span class="comment-copy">Yes i agree . That is how it should be . But i do not have access to other modules and these modules modify my input which i didn't want in the first place. I can keep the original objects with me and pass their deepcopy() as arguments . I am just looking for a better means other than deepcopy</span>
