<div class="post-text" itemprop="text">
<ol>
<li>I have two classes: Website and WordpressWebsite. </li>
<li>WordpressWebsite subclasses Website.</li>
</ol>
<p>When an instance of WordpressWebsite is being encoded into JSON, only the attributes of WordpressWebsite are present (and none of the attributes of Website). </p>
<p>My goal is to write a custom encoder which will encode a WordpressWebsite as a Website instead. </p>
<p>This is what I have so far: </p>
<pre><code>from django.core.serializers.json import DjangoJSONEncoder
from websites.models import Website

class WebsiteEncoder(DjangoJSONEncoder):

    def default(self, obj):
        raise Exception()  # TEST
        if isinstance(obj, Website) and hasattr(obj, 'website_ptr'):
            return super().default(obj.website_ptr)
        return super().default(obj)
</code></pre>
<p>I have the following test case:</p>
<pre><code>from django.core import serializers
from django.test import TestCase
from websites.models.wordpress import WordpressWebsite
from websites.serialize import WebsiteEncoder


class SerializationTest(TestCase):

    def setUp(self):
        self.wordpress = WordpressWebsite.objects.create(
            domain='test.com'
        )

    def test_foo(self):
        JSONSerializer = serializers.get_serializer("json")
        json_serializer = JSONSerializer()
        json_serializer.serialize(
            WordpressWebsite.objects.all(),
            cls=WebsiteEncoder
        )
        data = json_serializer.getvalue()
        print(data)
</code></pre>
<p>This test case runs fine. It does not raise an exception. </p>
<p>Does anyone know why WebsiteEncoder.default is not being invoked? </p>
</div>
<div class="post-text" itemprop="text">
<p>Django models are encoded natively with its serializers. Django's own <code>DjangoJSONEncoder</code> supplies a complete serializer for all possible models with any of the default Django datatypes. If you look at the <a href="https://docs.python.org/3/library/json.html?highlight=iterencode#json.JSONEncoder.default" rel="nofollow noreferrer"><code>JSONEncoder.default()</code> documentation</a>, you'll notice that you would only supply encoders for datatypes that are not yet known to the encoder.</p>
<p>Only if you were using a field type which Django doesn't natively support, you could provide an encoder for it - and only that field type - through <code>.default()</code>. Therefore <code>DjangoJSONEncoder</code> isn't what you're looking for.</p>
<p>Trying to make your example work I discovered you can actually customize the process by subclassing <code>django.core.serializers.json.Serializer</code>:</p>
<pre><code>from django.core.serializers.json import Serializer

class WebsiteSerializer(Serializer):
    def get_dump_object(self, obj):
        return {
            "pk": obj.pk,
            **self._current,
        }
</code></pre>
<p>After that, you can make your serializer work in the test case like so:</p>
<pre><code>def test_foo(self):
    serializer = WebsiteSerializer()
    data = serializer.serialize(WordpressWebsite.objects.all())
    print(data)
</code></pre>
</div>
