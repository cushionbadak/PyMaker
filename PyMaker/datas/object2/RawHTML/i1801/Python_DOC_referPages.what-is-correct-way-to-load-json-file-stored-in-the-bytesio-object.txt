<div class="post-text" itemprop="text">
<p>Data which I'm receiving is <code>bytes</code> therefore I need temporary <em>file-like</em> container. To my best knowledge <code>BytesIO</code> is <em>file-like</em> object, but <code>json.load()</code> doesn't work on it:</p>
<pre><code>In [1]: import json
   ...: from io import BytesIO, TextIOWrapper

In [2]: d, b = dict(a=1, b=2), BytesIO()

In [3]: b.write(json.dumps(d).encode())
Out[3]: 16

In [4]: b.seek(0)
Out[4]: 0

In [5]: b.read()
Out[5]: b'{"a": 1, "b": 2}'

In [6]: b.seek(0)
Out[6]: 0

In [7]: json.load(b)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-7-233ac51d2711&gt; in &lt;module&gt;()
----&gt; 1 json.load(b)

/usr/lib/python3.5/json/__init__.py in load(fp, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)
    266         cls=cls, object_hook=object_hook,
    267         parse_float=parse_float, parse_int=parse_int,
--&gt; 268         parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)
    269 
    270 

/usr/lib/python3.5/json/__init__.py in loads(s, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)
    310     if not isinstance(s, str):
    311         raise TypeError('the JSON object must be str, not {!r}'.format(
--&gt; 312                             s.__class__.__name__))
    313     if s.startswith(u'\ufeff'):
    314         raise JSONDecodeError("Unexpected UTF-8 BOM (decode using utf-8-sig)",

TypeError: the JSON object must be str, not 'bytes'
</code></pre>
<p>One method that works:</p>
<pre><code>In [8]: json.loads(b.getvalue().decode())
Out[8]: {'a': 1, 'b': 2}
</code></pre>
<p>Another one, presumably more efficient?</p>
<pre><code>In [10]: b.seek(0)
Out[10]: 0

In [11]: json.load(TextIOWrapper(b, encoding='utf-8'))
Out[11]: {'a': 1, 'b': 2}
</code></pre>
<p>Do I have more (better) alternatives? If no, which one of the above methods should be preferred?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend using <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow noreferrer"><code>TextIOWrapper</code></a> for two reasons:</p>
<ol>
<li>It gives you more control: Not only can you specify an encoding, but also how newlines should be handled (which would be relevant if you were parsing csv data, for example) and a number of other things.</li>
<li>It allows you to process the data in a streaming manner. Imagine you have a 10MB file that's not valid json - <code>fileobj.read().decode()</code> would needlessly load all 10MB into memory, but if you use <code>TextIOWrapper</code> then only a few bytes would be loaded before a <code>JsonDecodeError</code> is thrown.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Since you are dealing with JSON, which is purely texts, you should use <code>io.StringIO</code> instead of <code>io.BytesIO</code>:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; d, b = dict(a=1, b=2), StringIO()
&gt;&gt;&gt; b.write(json.dumps(d))
16
&gt;&gt;&gt; b.seek(0)
0
&gt;&gt;&gt; b.read()
'{"a": 1, "b": 2}'
&gt;&gt;&gt; b.seek(0)
0
&gt;&gt;&gt; json.load(b)
{'a': 1, 'b': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python 3.5, upgrade to 3.6+</p>
<p>3.5</p>
<pre><code>&gt;&gt;&gt; import sys                                                                                                   

&gt;&gt;&gt; sys.version                                                                                                  
'3.5.0 (default, Feb 16 2017, 15:47:16) \n[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)]'


&gt;&gt;&gt; import json                                                                                                  

&gt;&gt;&gt; from io import BytesIO                                                                                       

&gt;&gt;&gt; d, b = dict(a=1, b=2), BytesIO()                                                                             

&gt;&gt;&gt; b.write(json.dumps(d).encode())                                                                              
16


&gt;&gt;&gt; b.seek(0)                                                                                                    
0


&gt;&gt;&gt; json.load(b)                                                                                                 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Users/cmermingas/.pyenv/versions/3.5.0/lib/python3.5/json/__init__.py", line 268, in load
    parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)
  File "/Users/cmermingas/.pyenv/versions/3.5.0/lib/python3.5/json/__init__.py", line 312, in loads
    s.__class__.__name__))
TypeError: the JSON object must be str, not 'bytes'

the JSON object must be str, not 'bytes'
</code></pre>
<p>3.6</p>
<pre><code>&gt;&gt;&gt; import sys

&gt;&gt;&gt; sys.version
'3.6.0 (default, Jul 10 2017, 22:19:26) \n[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)]'

&gt;&gt;&gt; import json

&gt;&gt;&gt; from io import BytesIO

&gt;&gt;&gt; d, b = dict(a=1, b=2), BytesIO()

&gt;&gt;&gt; b.write(json.dumps(d).encode())
16

&gt;&gt;&gt; b.seek(0)
0

&gt;&gt;&gt; json.load(b)
{'a': 1, 'b': 2}
</code></pre>
</div>
<span class="comment-copy">Why don't you use a <code>StringIO</code>?</span>
<span class="comment-copy">@Aran-Fey Data which I'm receiving is <code>bytes</code> and I need temporary file-like container. In the real life example I'm using <code>boto3.client('s3').download_fileobj()</code>.</span>
<span class="comment-copy">You might be receiving the data as bytes, but you first need to decode that, as JSON is a Unicode string, not a bytestream.</span>
<span class="comment-copy">@chepner I get it, but I cannot (prefer not) influence how <code>Fileobj</code> argument is handled inside the <code>download_fileobj()</code>.</span>
<span class="comment-copy">Thanks, regarding <code>TextIOWrapper</code> I wasn't sure whether <code>JsonDecodeError</code> would be raised as soon as the first bits of incompatible <code>JSON</code> are detected. I assume <code>json.load()</code> would throw an exception only if the very first bits seem odd, but it would happily load entire 10M file if first bits seem as valid <code>JSON</code> but then in the middle become broken?</span>
<span class="comment-copy">@NarÅ«nasK It would only load as much data as necessary to detect that the file doesn't contain valid json.</span>
<span class="comment-copy">I'm assuming that <code>as much data as necessary</code> means, that if file is broken somewhere in the middle it would stop reading immediately and would raise an <code>exception</code>.</span>
<span class="comment-copy">Data which I'm receiving is <code>bytes</code> and I need temporary file-like container. In the real life example I'm using <code>boto3.client('s3').download_fileobj()</code>.</span>
<span class="comment-copy">You should use the <code>bytes.decode</code> method to turn the <code>bytes</code> you receive into a string then.</span>
<span class="comment-copy">I'm looking for method, which would too work on other <code>python</code> versions, therefore upgrading is not an option.</span>
