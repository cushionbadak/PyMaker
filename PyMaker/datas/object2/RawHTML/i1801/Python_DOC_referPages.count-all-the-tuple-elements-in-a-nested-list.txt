<div class="post-text" itemprop="text">
<p>I want to get the count of all the elements in a nested list.
<code>nested_lst = [[('NOUN', 'shoe'), ('NOUN', 'shirt'), ('NOUN', 'jacket')], [('VERB', 'jump')], [('NOUN', 'shoe'), ('NOUN', 'shirt'), ('ADJ', 'fancy')]]</code></p>
<p>My expected outcome is:</p>
<pre><code>{'NOUN': 5, 'shoe': 2, 'shirt':2, 'VERB': 1, 'jump': 1, 'jacket': 1, 'ADJ': 1, 'fancy':1}
</code></pre>
<p>My current code: <code>Counter(itertools.chain(*nested_lst))</code> which produced the count of tuples instead of each element. </p>
</div>
<div class="post-text" itemprop="text">
<p>Apply chain two times to get rid of inner tuples</p>
<pre><code>from itertools import chain
from collections import Counter
Counter(chain(*chain(*nested_lst)))
</code></pre>
<p>Or </p>
<pre><code>Counter(chain.from_iterable(chain.from_iterable(nested_lst)))
</code></pre>
<p>Output:</p>
<pre><code>Counter({'ADJ': 1,
         'NOUN': 5,
         'VERB': 1,
         'fancy': 1,
         'jacket': 1,
         'jump': 1,
         'shirt': 2,
         'shoe': 2})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are very close. You just need another iteration through values returned by <code>chain</code> to get desired output:</p>
<pre><code>from collections import Counter
from itertools import chain

nested_lst = [[('NOUN', 'shoe'), ('NOUN', 'shirt'), ('NOUN', 'jacket')], [('VERB', 'jump')], [('NOUN', 'shoe'), ('NOUN', 'shirt'), ('ADJ', 'fancy')]]

print(Counter(y for x in chain.from_iterable(nested_lst) for y in x))
# Counter({'NOUN': 5, 'shoe': 2, 'shirt': 2, 'jacket': 1, 'VERB': 1, 'jump': 1, 'ADJ': 1, 'fancy': 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [2]: for i in nested_lst:
   ...:     for j in i:
   ...:         for k in j:
   ...:             d[k] = d.setdefault(k, 0) + 1
   ...:

In [3]: d
Out[3]:
{'ADJ': 1,
 'NOUN': 5,
 'VERB': 1,
 'fancy': 1,
 'jacket': 1,
 'jump': 1,
 'shirt': 2,
 'shoe': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I your list is only nested once, you can get a flat list with <code>sum()</code>.
After this you can make an empty dictionary, and increase the value in each iteration, where the word appears. If there is a new word, default the value to zero, and one will be added anyways. Most likely not the most efficient solution though.</p>
<pre><code>nested_lst = [[('NOUN', 'shoe'), ('NOUN', 'shirt'), ('NOUN', 'jacket')], [('VERB', 'jump')], [('NOUN', 'shoe'), ('NOUN', 'shirt'), ('ADJ', 'fancy')]]
flat_lst = sum(nested_lst, [])
dct = {}
for typ, name in flat_lst:
    dct[typ] = 1 + dct.setdefault(typ, 0)
    dct[name] = 1 + dct.setdefault(name, 0)

# {'NOUN': 5, 'shoe': 2, 'shirt':2, 'VERB': 1, 'jump': 1, 'jacket': 1, 'ADJ': 1, 'fancy':1}
print(dct)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could always step through each list of tuples and add the counts with <a href="https://docs.python.org/3/library/collections.html#collections.Counter.update" rel="nofollow noreferrer"><code>Counter.update()</code></a>:</p>
<pre><code>from collections import Counter
from itertools import chain

nested_lst = [[('NOUN', 'shoe'), ('NOUN', 'shirt'), ('NOUN', 'jacket')], [('VERB', 'jump')], [('NOUN', 'shoe'), ('NOUN', 'shirt'), ('ADJ', 'fancy')]]

counts = Counter()
for lst in nested_lst:
    counts.update(Counter(chain.from_iterable(lst)))

print(counts)
# Counter({'NOUN': 5, 'shoe': 2, 'shirt': 2, 'jacket': 1, 'VERB': 1, 'jump': 1, 'ADJ': 1, 'fancy': 1})
</code></pre>
</div>
<span class="comment-copy">user seems new, don't forget to include import statements</span>
