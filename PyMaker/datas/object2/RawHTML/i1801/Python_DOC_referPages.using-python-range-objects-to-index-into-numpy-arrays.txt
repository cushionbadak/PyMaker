<div class="post-text" itemprop="text">
<p>I've seen it once or twice before, but I can't seem to find any official docs on it: Using python <code>range</code> objects as indices in numpy.</p>
<pre><code>import numpy as np
a = np.arange(9).reshape(3,3)
a[range(3), range(2,-1,-1)]
# array([2, 4, 6])
</code></pre>
<p>Let's trigger an index error just to confirm that ranges are not in the official range (pun intended) of legal indexing methods:</p>
<pre><code>a['x']

# Traceback (most recent call last):
#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
# IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices
</code></pre>
<p>Now, a slight divergence between numpy and its docs is not entirely unheard of and does not necessarily indicate that a feature is not intended (see for example <a href="https://stackoverflow.com/a/48940730/7207392">here</a>).</p>
<p>So, does anybody know why this works at all? And if it is an intended feature what are the exact semantics / what is it good for? And are there any ND generalizations?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Not a proper answer, but too long for comment.</em></p>
<p>In fact, it seems to work with about any indexable object:</p>
<pre><code>import numpy as np

class MyIndex:
    def __init__(self, n):
        self.n = n
    def __getitem__(self, i):
        if i &lt; 0 or i &gt;= self.n:
            raise IndexError
        return i
    def __len__(self):
        return self.n

a = np.array([1, 2, 3])
print(a[MyIndex(2)])
# [1 2]
</code></pre>
<p>I <em>think</em> the relevant lines in NumPy's code are below this comment in <a href="https://github.com/numpy/numpy/blob/v1.15.3/numpy/core/src/multiarray/mapping.c#L286-L289" rel="nofollow noreferrer"><code>core/src/multiarray/mapping.c</code></a>:</p>
<pre class="lang-c prettyprint-override"><code>/*
 * Some other type of short sequence - assume we should unpack it like a
 * tuple, and then decide whether that was actually necessary.
 */
</code></pre>
<p>But I'm not entirely sure. For some reason, this hangs if you remove the <code>if i &lt; 0 or i &gt;= self.n: raise IndexError</code>, even though there is a <code>__len__</code>, so at some point it seems to be iterating through the given object until <code>IndexError</code> is raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to wrap this up (thanks to @WarrenWeckesser in the comments): This behavior is actually documented. One only has to realize that <code>range</code> objects are python sequences <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="nofollow noreferrer">in the strict sense</a>.</p>
<p>So this is just a case of fancy indexing. Be warned, though, that it is very slow:</p>
<pre><code>&gt;&gt;&gt; a = np.arange(100000)
&gt;&gt;&gt; timeit(lambda: a[range(100000)], number=1000)
12.969507368048653
&gt;&gt;&gt; timeit(lambda: a[list(range(100000))], number=1000)
7.990526253008284
&gt;&gt;&gt; timeit(lambda: a[np.arange(100000)], number=1000)
0.22483703796751797
</code></pre>
</div>
<span class="comment-copy">I've never seen this; is it used in any reputable libraries?</span>
<span class="comment-copy">numpy predates Python 3.  In Python 2, <code>range(3)</code> is a list of integers, which numpy treats as "array-like".  It would have been a mess if numpy didn't also handle that in a backwards compatible way in Python 3.</span>
<span class="comment-copy"><i>"So, does anybody know why this works at all?"</i>  It is a nice feature, informally called "fancy" indexing, and in the docs it is called <a href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing" rel="nofollow noreferrer">advanced indexing</a>.</span>
<span class="comment-copy">@WarrenWeckesser That's right, it says there <code>(...) a non-tuple sequence object</code> (although a <code>non-tuple sequence (such as a list) containing slice objects</code> will trigger basic indexing, it seems). Not sure why it should hang if  <code>IndexError</code> is not raised though, but whatever. I think you could make this an answer.</span>
<span class="comment-copy">It could be that indexing tries <code>np.asarray(x)</code> with works with both <code>range(3)</code> and <code>[0,1,2]</code>.  Other things produce errors or object dtype arrays.  @WarrenWeckesser, makes a good point about compatibility with Py2's version of <code>range</code>.</span>
<span class="comment-copy">It iterating would be consistent with that it is actually quite slow, for example compared to indexing with <code>arange</code>s.</span>
