<div class="post-text" itemprop="text">
<p>I have a dictionary that has a list that has paired numbers as a sublist, 
I am trying to check if there is an overlap between the sublists.</p>
<pre><code>{'5ykw.pdb': [[10, 22], [33, 40], [39, 51], [63, 71], [94, 105]]}
</code></pre>
<p>There is overlap between [33, 40] and [39, 51], and so I want to merge these to make:</p>
<pre><code>{'5ykw.pdb': [[10, 22], [33, 51], [63, 71], [94, 105]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a recursive form of the breadth-first search:</p>
<pre><code>def overlap(a, b) -&gt; bool:
  return a[-1] &gt;= b[0] and a[-1] &lt; b[-1]

def group(d, _c, seen):
   return [_c, 
     [i if i not in seen else group(d, i, seen+[i]) for i in d if overlap(_c, i)]]

r = {'5ykw.pdb': [[10, 22], [33, 40], [39, 51], [63, 71], [94, 105]]}
new_data = [group(r['5ykw.pdb'], i, []) for i in r['5ykw.pdb'] if not any(overlap(c, i) for c in r['5ykw.pdb'])]
final_data = [a if not b else [a[0], max(h for _, h in b)] for a, b in new_data]
</code></pre>
<p>Output:</p>
<pre><code>[[10, 22], [33, 51], [63, 71], [94, 105]]
</code></pre>
<p>This will also work on input with a greater number of overlaps:</p>
<pre><code>r = {'5ykw.pdb':[[15, 20], [18, 21], [19, 30]]}
new_data = [group(r['5ykw.pdb'], i, []) for i in r['5ykw.pdb'] if not any(overlap(c, i) for c in r['5ykw.pdb'])]
final_data = [a if not b else [a[0], max(h for _, h in b)] for a, b in new_data]
</code></pre>
<p>Output:</p>
<pre><code>[[15, 30]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce</code></a> with a custom <code>merge</code> function to create a new list:</p>
<pre><code>from functools import reduce

def merge(acc, curr):
    if not len(acc) or acc[-1][1] &lt; curr[0]:
        acc.append(curr)
        return acc
    acc[-1][1] = curr[1] # update last element in accumulator
    return acc

data = {'5ykw.pdb': [[10, 22], [33, 40], [39, 51], [63, 71], [94, 105]]}
data['5ykw.pdb'] = reduce(merge, data['5ykw.pdb'], [])
print(data)
# {'5ykw.pdb': [[10, 22], [33, 51], [63, 71], [94, 105]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could “de-overlap” the list simply using this function:</p>
<pre><code>def deoverlap(lst):
    if not lst:
        return []
    lst = [sorted(pair) for pair in lst]  # sort pairs (leave out if not needed)
    lst = sorted(lst)  # sort by first item (breaking ties by second item)
    out = []
    prev = lst[0]
    for pair in lst[1:]:
        if prev[1] &gt;= pair[0]:
            if prev[1] &lt; pair[1]:
                prev[1] = pair[1]
        else:
            out.append(prev)
            prev = pair
    out.append(prev)
    return out

dct = {'5ykw.pdb': [[10, 22], [33, 40], [39, 51], [63, 71], [94, 105]]}

dct['5ykw.pdb'] = deoverlap(dct['5ykw.pdb'])

print(dct)  # prints {'5ykw.pdb': [[10, 22], [33, 51], [63, 71], [94, 105]]}
</code></pre>
<p>The only assumption here is that the input to <code>deoverlap()</code> is a list of pairs of a comparable type (typically numbers), where each pair is a list of length 2.</p>
<p>Pairs are sorted internally, then sorted by the first item, then merged if the max of the previous pair is ≥ the min of the current pair. If merging should not happen when they are equal, the 9<sup>th</sup> line of <code>deoverlap()</code> should become</p>
<pre><code>        if prev[1] &gt; pair[0]:
</code></pre>
</div>
<span class="comment-copy">Is it guaranteed that (a) first and second item in sublists (b) all first items (c) all second items are in ascending order? Is <code>[1,2]</code> and <code>[2,3]</code> considered an overlap?</span>
<span class="comment-copy">Related:  <a href="https://stackoverflow.com/q/50592912/674039">Python representation for a set of non-overlapping integer ranges</a></span>
