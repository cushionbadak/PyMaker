<div class="post-text" itemprop="text">
<p>I have a list</p>
<pre><code>my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p>I am looking to write a function <strong>get_n_preceeding(a, list_of_numbers, n)</strong>, which takes an argument <strong>a</strong> and returns <strong>n</strong> numbers which preceded that number in list_of_numbers.</p>
<p>For example:</p>
<pre><code>get_n_preceeding(4, my_list, 2):
</code></pre>
<p>This should return 2 numbers preceding 4 in the list.
i.e. ans = [2,3]</p>
<p>Similarly, if I want 2 numbers preceding 1, it should give the result as 
[9,10] # This I think, is the tricky part.</p>
<p>Similarly, I am looking to write another function <strong>get_n_succeeding(a, list_of_numbers, b)</strong></p>
<pre><code>get_n_succeeding(7, my_list, 2)  # This should return [8,9]
</code></pre>
<p>If I use <code>get_n_succeeding(9, my_list, 2)</code>, it should return [10,1].</p>
<p>I tried using <strong>zip</strong> operator but couldn't do it.</p>
<p>Is there any better way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I used list comprehension for get_n_preceeding and just a for loop for the succeeding, subtracting the length of the array if the succeeding index goes out of bounds.</p>
<pre><code>def get_n_preceeding(a: int, numbers: list, n: int = 2) -&gt; list:
    start = numbers.index(a)
    return [numbers[start - n + x] for x in range(n)]


def get_n_succeeding(a: int, numbers: list, n: int = 2) -&gt; list:
    start = numbers.index(a) + 1
    length = len(numbers)
    output = []
    for x in range(n):
        try:
            output.append(numbers[start + x])
        except IndexError:
            output.append(numbers[start + x - length])
    return output


my_list = list(range(1, 11))
print(get_n_preceeding(1, my_list, 2))  # -&gt; [9, 10]
print(get_n_succeeding(9, my_list, 2))  # -&gt; [10, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3.7/library/array.html#array.array.index" rel="nofollow noreferrer"><code>array.index()</code></a> to find the position, then <a href="https://docs.python.org/3.7/library/stdtypes.html#typesseq-common" rel="nofollow noreferrer">slice the array</a> accordingly:</p>
<pre><code>def get_n_preceding(xs, x, n):
    end = xs.index(x)
    start = end - n
    ys = []
    for i in range(start, end):
        ys.append(xs[i % len(xs)])
    return ys

def get_n_succeeding(xs, x, n):
    start = xs.index(x) + 1
    end = start + n
    ys = []
    for i in range(start, end):
        ys.append(xs[i % len(xs)])
    return ys

get_n_preceding(list(range(10)), 1, 2)   #=&gt; [10, 0]
get_n_preceding(list(range(10)), 5, 2)   #=&gt; [3, 4]
get_n_succeeding(list(range(10)), 8, 2)  #=&gt; [9, 0]
get_n_succeeding(list(range(10)), 5, 2)  #=&gt; [6, 7]
</code></pre>
<p>As noted in the docs, <code>array.index()</code> will find the first matching element, and ignore any later duplicates.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>.index()</code> method to find <code>a</code>'s index.</p>
<pre><code>aIndex = L.index(a)
preceding = []

for x in range(aIndex - n, aIndex): # Counting n numbers before a
if (aIndex - n) &gt;= 0:               
    preceding.append(L[x])                     
else:                               
    aIndex = len(L)                 # "Turns around" the list if a - n &lt; 0
    preceding.append(L[x])

print(preceding)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a generator and <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate(iterable)</a>:</p>
<pre><code>def get_n_preceeding(val,data,n=2, findall=False):
    found_at = []
    for pos,e in enumerate(data):
        if e == val:
            found_at.append(pos)
            if not findall:
                break

    ld = len(data)
    for p in found_at:
        circle = data + data + data
        yield circle[p-n+ld:p+ld]
</code></pre>
<p>Test:</p>
<pre><code>L = [1, 2, 3, 4, 5, 4, 6, 7, 8, 4, 9, 10]

print("Get first")
for part in get_n_preceeding(1,L,2):
    print(part)
print("Get all")
for part in get_n_preceeding(4,L,2,True):
    print(part) 

print("Get circle")
for part in get_n_preceeding(1,L,4):
    print(part)
</code></pre>
<p>Output:</p>
<pre><code>Get first
[9, 10]

Get all
[2, 3]
[4, 5]
[7, 8]

Get circle
[8, 4, 9, 10]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The modulus operator (<code>%</code>) is often a good choice when you need an expression to wrap or repeat regularly. For example, this solution is simple and robust against edge cases (e.g., <code>n &gt; len(lst)</code>):</p>
<pre><code>def get_n_preceding(val, lst, n):
    start = lst.index(val) - n
    return [lst[(start + x) % len(lst)] for x in range(n)]

def get_n_succeeding(val, lst, n):
    start = lst.index(val) + 1
    return [lst[(start + x) % len(lst)] for x in range(n)]
</code></pre>
<p>Results:</p>
<pre><code>L = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
get_n_preceding(4, L, n=2)  # [2, 3]
get_n_preceding(1, L, n=2)  # [9, 10]
get_n_preceding(3, [1, 2, 3], n=5)  # [1, 2, 3, 1, 2]

get_n_succeeding(7, L, n=2)  # [8, 9]
get_n_succeeding(9, L, n=2)  # [10, 1]
get_n_succeeding(3, [1, 2, 3], n=5)  # [1, 2, 3, 1, 2]
</code></pre>
</div>
<span class="comment-copy">No you do not need a <code>zip</code> operator here: you need to find the index where the item is located, and then "slice" the list accordingly.</span>
<span class="comment-copy">What happens when you have duplicate elements?</span>
<span class="comment-copy">"I tried using Zip operator but couldn't do it." Could you show what you have tried? Even non-functional attempts are important.</span>
<span class="comment-copy">@DanielMesejo The list contains unique elements.</span>
<span class="comment-copy"><code>get_n_preceding(list(range(10)), 1, 2)</code>, returns empty list, It should return me [9,10], similarly <code>get_n_succeeding(list(range(10)), 10, 2)</code>, should return [1,2]</span>
<span class="comment-copy">@Shubham Actually, that should give <code>[10, 0]</code>, since the list you’re passing begins with <code>0</code>, not <code>1</code>. Anyway, updated my answer.</span>
<span class="comment-copy">@AndrewMarshall nice one -but range(10) only includes 0-9 - no 10 to be had.</span>
<span class="comment-copy">Argh, yea, <code>[9, 0]</code>. <a href="https://twitter.com/pr0gramm/status/466601467978461184" rel="nofollow noreferrer">There’s only two hard problems in CS…</a>.</span>
<span class="comment-copy">if i use <code>get_n_preceeding(1,L,2)</code> , it is showing me as empty list, i want if 1 is selected, it should return me [9,10]. Idea is kind of circular list.</span>
<span class="comment-copy">@Shubham only a hackish fix - this breaks if you have overlapping ranges, f.e. <code>get_n_preceeding(1,L,20)</code> - essentially you have to make sure your circle is big enough and you shift the found indexes that far to the right that it will still fetch all your items. Its a building block for you to improve on.</span>
