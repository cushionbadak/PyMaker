<div class="post-text" itemprop="text">
<p>I am trying to extract a <code>code block</code> from a <code>.rst</code> document using <em>Python</em> and <em>regex</em>. The code blocks in the document are defined by adding a <code>.. code-block:: python</code> directive to the text and then indenting by a few spaces. </p>
<p>Here is an example from my test document:</p>
<pre><code>.. code-block:: python

  import os
  from selenium import webdriver
  from axe_selenium_python import Axe

  def test_google():
      driver = webdriver.Firefox()
      driver.get("http://www.google.com")
      axe = Axe(driver)
      # Inject axe-core javascript into page.
      axe.inject()
      # Run axe accessibility checks.
      results = axe.execute()
      # Write results to file
      axe.write_results(results, 'a11y.json')
      driver.close()
      # Assert no violations are found
      assert len(results["violations"]) == 0,    axe.report(results["violations"])
      driver.close()
</code></pre>
<p>So far I have this regex:
<code>(\.\. code-block:: python\s\s)(.*\s.+).*?\n\s+(.*\s.+)+</code></p>
<p>The problem with this pattern is that it selects only the first part and last part of the test string. I need help in writing a pattern that can capture <em>everything</em> within the <code>.. code-block:: python</code> code block excluding the <code>..code-block:: python</code> directive.</p>
<p>You can see the progress I have made with this <a href="https://regex101.com/r/9UKjys/1" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you insist on using regex, the following should do the trick, given provided example:</p>
<pre><code>import re

pattern = r"(\.\. code-block:: python\s+$)((\n +.*|\s)+)"

matches = re.finditer(pattern, text, re.M)

for m, match in enumerate(matches):
    for g, group_text in enumerate(match.groups()):
        print("###match {}, group {}:###".format(m, g))
        print(group_text, end="")
</code></pre>
<p>The trick, I believe, is to use nested parenthesis and the MULTILINE or M flag.</p>
<p>The resulting <code>match</code> object(s) will have 3 <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">groups</a>, as defined by the parenthesis:</p>
<ul>
<li>group 1: the '.. code-block:' header</li>
<li>group 2: the contents of the code block</li>
<li>group 3: an empty group as a result of the extra grouping parenthesis.</li>
</ul>
<p>To retrieve group <code>n</code>, use <code>match.group(n)</code>. Note that indexing of groups starts at <code>1</code> and passing <code>0</code> or no arguments will result in the entire matching string.</p>
</div>
<span class="comment-copy">You should use a restructedtext parser.</span>
<span class="comment-copy">Suggest instead putting the content of the code-block into an external file, then use <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html#directive-literalinclude" rel="nofollow noreferrer"><code>literalinclude</code></a> to display it in the .rst file and do whatever you intend to do with the regex with the source file.</span>
<span class="comment-copy">@KlausD. Do you have any recommendations on which parsers I can look into?</span>
<span class="comment-copy"><a href="https://eli.thegreenplace.net/2017/a-brief-tutorial-on-parsing-restructuredtext-rest/" rel="nofollow noreferrer">eli.thegreenplace.net/2017/â€¦</a></span>
<span class="comment-copy">Thank you for the link.</span>
<span class="comment-copy">Thank you for this! It works. Is there a way to select the same text and <i>not</i> include the <code>code-block:: python</code> directive in the match object?</span>
