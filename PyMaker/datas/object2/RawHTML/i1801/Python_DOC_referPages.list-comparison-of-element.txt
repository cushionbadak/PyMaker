<div class="post-text" itemprop="text">
<p>I have a question and it is a bit hard for me to explain so I will be using lots of examples to help you all understand and see if you could help me.</p>
<p>Say I have two lists containing book names from best to worst rated by two people. User1 rated <code>lstA</code>, and user2 rated <code>lstB</code></p>
<pre><code>lstA = ['Harry Potter','1984','50 Shades','Dracula']
lstB = ['50 Shades','Dracula','1984','Harry Potter']
</code></pre>
<p>User one thinks 'Harry Potter' is better than 'Dracula' (HP is index 0, and Dracula is index 3)</p>
<p>User two thinks 'Harry Potter' is worse than Dracula, (HP is index 3 and Dracula is index 1)</p>
<p>In this case, return a tuple <code>('Harry Potter', 'Dracula')</code> [<code>('Dracula', 'Harry Potter')</code> is also fine]</p>
<p>User one also rated '50 shades' better than 'Dracula' and user two also rated '50 shades' better than 'Dracula' (index 2, 3 and 0, 1 respectively). In this case, nothing happens. </p>
<p>The final result of the program should return a list of tuples so, </p>
<pre><code>[('Harry Potter','50 Shades'), ('Harry Potter','Dracula'), ('Harry Potter','1984'), ('1984', '50 Shades'), ('1984','Dracula')]
</code></pre>
<p>Could someone help me to point me in the right direction to come up with an algorithm that gives all the tuples?</p>
</div>
<div class="post-text" itemprop="text">
<p>First formulate your logic mathematically. For all <em>combinations</em> of length 2, given indices <code>idx_a1, idx_a2</code> and <code>idx_b1, idx_b2</code>, if <code>sign(idx_a1 - idx_a2) != sign(idx_b1 - idx_b2)</code>, record the combination.</p>
<p>The below isn't efficient, but it shows one way of transforming this logic to code:</p>
<pre><code>from itertools import combinations

lstA = ['Harry Potter','1984','50 Shades','Dracula']
lstB = ['50 Shades','Dracula','1984','Harry Potter']

def sign(x):
    """Return +1 if integer is positive, -1 if negative"""
    return (x &gt; 0) - (x &lt; 0)

res = []
for a, b in combinations(lstA, 2):
    idx_a1, idx_a2 = lstA.index(a), lstA.index(b)
    idx_b1, idx_b2 = lstB.index(a), lstB.index(b)
    if sign(idx_a1 - idx_a2) != sign(idx_b1 - idx_b2):
        res.append((a, b))

[('Harry Potter', '1984'),
 ('Harry Potter', '50 Shades'),
 ('Harry Potter', 'Dracula'),
 ('1984', '50 Shades'),
 ('1984', 'Dracula')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this would be to accumulate all the positive orderings form each list into a set, then take the difference of the two sets. The positive ordering would be <code>(a, b)</code> when the <code>a</code> precedes <code>b</code> in its respective list. This is the ordering guaranteed by <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>:</p>
<pre><code>from itertools import combinations

setA = set(combinations(lstA, 2))
setB = set(combinations(lstB, 2))

result = setA - setB
</code></pre>
<p>This would simply discard any orderings that the two sets agree on. If both lists had the same books, this would be almost identical to</p>
<pre><code>result = setB - setA
</code></pre>
<p>The only difference would be that all the tuples would be reversed.</p>
<p>If you had different books in each list, you would need to add a couple of extra steps to clean up the duplicates and combine the two sets:</p>
<pre><code>resultA = setA - setB
resultB = setB.difference(x[::-1] for x in setA)
result = resultA | resultB
</code></pre>
<p>The first step computes all the elements from <code>lstA</code> that <code>lstB</code> does not agree with. The next step finds the elements of <code>lstB</code> that aren't reversed versions of what we have in <code>resultA</code>, since the disagreements over books in both lists are guaranteed to be reversed in the sets. I used the method <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.difference" rel="nofollow noreferrer"><code>set.difference</code></a> here in preference to the <code>-</code> operator because that way there is no need to create a set object from the generator expression. You can't just use <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.symmetric_difference" rel="nofollow noreferrer"><code>symmetric_difference</code>/<code>^</code></a> unfortunately because the elements are reversed. The third step just computes the union of the results.</p>
<p>IDEOne Link: <a href="https://ideone.com/DuHTed" rel="nofollow noreferrer">https://ideone.com/DuHTed</a>. This demos both the original case in the question and the asymmetric lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>An efficient version of @jpp's solution is as follows:</p>
<pre><code>from itertools import combinations

lstA = ['Harry Potter','1984','50 Shades','Dracula']
lstB = ['50 Shades','Dracula','1984','Harry Potter']

bIndices = {b: i for i, b in enumerate(lstB)}
aPairs = [sorted(c) for c in combinations(enumerate(lstA), 2)]

mismatches = [(book1[1], book2[1]) for book1, book2 in aPairs if bIndices[book1[1]] &gt; bIndices[book2[1]]]
print(mismatches)
# [('Harry Potter', '1984'), ('Harry Potter', '50 Shades'), ('Harry Potter', 'Dracula'), ('1984', '50 Shades'), ('1984', 'Dracula')]
</code></pre>
<p>Note that <code>aPairs</code> are combinations of (index, book) tuples and each combination is sorted by the index which guarantees that in each pair of books, the first is "better" than the next (for user A).</p>
<p>Now to compute ordering mismatches, we just need to decide whether the corresponding book indices in <code>lstB</code> also preserve this ordering.</p>
<h3>Edit</h3>
<p>As @MadPhysicist noted, <code>combinations</code> preserves the original order in the array in each generated tuple, so no need to create <code>aPairs</code> as a list of sorted <code>(index, book)</code> tuples. We can directly generate <code>mismatches</code> with just <code>bIndices</code>:</p>
<pre><code>lstA = ['Harry Potter','1984','50 Shades','Dracula']
lstB = ['50 Shades','Dracula','1984','Harry Potter']

bIndices = {b: i for i, b in enumerate(lstB)}
mismatches = [(book1, book2) for book1, book2 in combinations(lstA, 2) if bIndices[book1] &gt; bIndices[book2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>iter</code> and then compare indices</p>
<pre><code>res = []  

for i in lstA:
    a = iter(lstB)
    while True:
        try:
            b = next(a)
            if lstA.index(i) &lt; lstA.index(b) and lstB.index(i) &gt; lstB.index(b):
                res.append((i, b))
        except StopIteration:
            break 

print(res)
# [('Harry Potter', '50 Shades'), ('Harry Potter', 'Dracula'), ('Harry Potter', '1984'), ('1984', '50 Shades'), ('1984', 'Dracula')]
</code></pre>
</div>
<span class="comment-copy">You might want to take a look at this link <a href="https://www.geeksforgeeks.org/counting-inversions/" rel="nofollow noreferrer">geeksforgeeks.org/counting-inversions</a> It does precisely what you are looking for.</span>
<span class="comment-copy">You may want to consider selecting an answer by clicking on the green checkmark next to it. That will remove your question from the unanswered queue.</span>
<span class="comment-copy">It appears that you have a habit of not selecting answers. You will gain some reputation for each answer you select, and your question will have a canonical answer for future readers. Please select answers when they help you.</span>
<span class="comment-copy">I think I found a way without using the indices at all.</span>
<span class="comment-copy">Hello, I am not too familiar with "from itertools import combinations" could you explain how that function works? Currently, I am writing using nested for loops but cant quite get the results yet.</span>
<span class="comment-copy">Nice! Although is it guaranteed that all orderings you generate with <code>combinations(lstA, 2)</code> will be "positive orderings"?</span>
<span class="comment-copy">@slider. Yes, that's what the docs seem to be guaranteeing (<a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.combinations</a>), and this confirms: <a href="https://ideone.com/dExkt4" rel="nofollow noreferrer">ideone.com/dExkt4</a></span>
<span class="comment-copy">@slider: I've updated my answer</span>
<span class="comment-copy">Great. Based on that, I think I can simplify mine too a little bit more.</span>
<span class="comment-copy">@slider: hope someone clears this up for us <a href="https://stackoverflow.com/q/53112861/2988730">stackoverflow.com/q/53112861/2988730</a></span>
<span class="comment-copy">I think my way may be even further cleaned up.</span>
<span class="comment-copy">This seems awfully inefficient compared to the other answers, but is probably easier to understand.</span>
<span class="comment-copy">@MadPhysicist How would this be less efficient, other methods are creating extra wasted combinations then filtering through them, this only creates one list of only pairs that will be used</span>
<span class="comment-copy">You're doing a linear search for each element in both lists for one thing. For example, you could use <code>enumerate</code> in your outer loop to avoid <code>lstA.index(i)</code>. Your algorithm probably does indeed save a fraction of the space, but at the cost of a dramatic increase in time.</span>
<span class="comment-copy">@MadPhysicist hmm yeah I guess, Just this same type of problem was at hand before and I used <code>combination</code>s disgarding the unused and was made a point of by MartijnPeters about how inefficient it can be do create all sorts of combinations just to filter a few out</span>
