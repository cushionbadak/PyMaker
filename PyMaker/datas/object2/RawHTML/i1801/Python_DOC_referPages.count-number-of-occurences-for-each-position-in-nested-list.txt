<div class="post-text" itemprop="text">
<p>I have a list <code>X</code> with numbers from <code>1-10</code>, and a function that uses this list to create a new list with random values from 1-10. I want to call this function 100 times and count the number of times the same value occurs on the same position in the nested list. </p>
<p>I've created the function <code>lists</code> to achieve this. My code returns the correct answer, but I'm thinking there has to be a simpler way to write it: </p>
<p>from collections import Counter
    import random</p>
<pre><code>X = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

def randomX(l):
    randomX = [random.choice(X) for i in range(len(data))]
    return randomX

def lists(times):
    lists = [randomX(X) for i in range(times)]
    x1 = Counter(sublist[0] for sublist in lists)
    x2 = Counter(sublist[1] for sublist in lists)
    x3 = Counter(sublist[2] for sublist in lists)
    x4 = Counter(sublist[3] for sublist in lists)
    x5 = Counter(sublist[4] for sublist in lists)
    x6 = Counter(sublist[5] for sublist in lists)
    x7 = Counter(sublist[6] for sublist in lists)
    x8 = Counter(sublist[7] for sublist in lists)
    x9 = Counter(sublist[8] for sublist in lists)
    x10 = Counter(sublist[9] for sublist in lists)
    return x1, x2, x3, x4, x5, x6, x7, x8, x9, x10

print(lists(100))
</code></pre>
<p>This prints a result that looks like this, which is kind of the thing I want, except that I'm going to sort it. However, it seems unnecessary to write pretty much the same thing 10 times in a row, but list slicing won't work with counter. </p>
<pre><code>(Counter({7: 14, 8: 12, 6: 12, 3: 11, 9: 11, 1: 10, 10: 9, 4: 9, 5: 7, 2: 5}),
 Counter({5: 16, 3: 14, 7: 11, 4: 11, 10: 9, 1: 9, 6: 8, 8: 8, 2: 7, 9: 7}),
 Counter({3: 14, 2: 14, 7: 13, 8: 13, 4: 10, 6: 10, 5: 10, 1: 8, 9: 5, 10: 3}),
 Counter({3: 15, 6: 15, 8: 12, 7: 11, 1: 11, 4: 11, 2: 10, 9: 7, 5: 5, 10: 3}),
 Counter({8: 20, 3: 15, 6: 13, 4: 11, 7: 10, 10: 10, 2: 7, 1: 7, 5: 4, 9: 3}),
 Counter({9: 15, 6: 13, 10: 12, 4: 11, 2: 10, 8: 9, 3: 8, 5: 8, 1: 8, 7: 6}),
 Counter({6: 17, 7: 13, 9: 11, 2: 11, 8: 11, 5: 10, 3: 8, 10: 8, 4: 6, 1: 5}),
 Counter({6: 20, 5: 11, 10: 11, 1: 11, 9: 10, 2: 9, 4: 8, 3: 8, 7: 7, 8: 5}),
 Counter({8: 13, 10: 13, 4: 13, 5: 11, 9: 11, 1: 10, 3: 9, 2: 8, 7: 6, 6: 6}),
 Counter({10: 14, 8: 13, 1: 10, 2: 10, 3: 10, 5: 10, 7: 9, 4: 9, 9: 9, 6: 6}))
</code></pre>
<p>Does anyone have any suggestions as to how I can simplify this code? </p>
</div>
<div class="post-text" itemprop="text">
<p>You could transpose your created list to columns using  <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip()</a> and count those.</p>
<p>Small example for what <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip()</a> does:</p>
<pre><code>d = [ [1,2,3,4], [11,12,13,14], [111,112,113,114]]

print(list(zip(*d)))  
</code></pre>
<p>Output:</p>
<pre><code># transposed - each tuple equals one column now
[(1, 11, 111), (2, 12, 112), (3, 13, 113), (4, 14, 114)]
</code></pre>
<hr/>
<p>Your code using zip() and a generator:</p>
<pre><code>from collections import Counter
import random

random.seed(42)

def countEm(data, times):
    datalen = len(data)
    numbers = [ random.choices(data, k=datalen) for _ in range(times)]
    for col in zip(*numbers):
        yield Counter(col) 

X = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# generators can only be consumed once, use  result = list(countEm(X,100)) if you
# want to reuse the result beside printing... 

for count in countEm(X,100):
    print(count) 
</code></pre>
<p>Output:</p>
<pre><code>Counter({9: 18, 7: 13, 10: 13, 5: 12, 3: 11, 8: 11, 1: 8, 4: 6, 6: 4, 2: 4})
Counter({3: 16, 7: 14, 6: 13, 8: 11, 10: 10, 1: 9, 4: 9, 5: 8, 9: 6, 2: 4})
Counter({6: 13, 7: 13, 3: 12, 9: 12, 2: 11, 5: 10, 10: 9, 8: 8, 4: 7, 1: 5})
Counter({10: 17, 2: 15, 6: 12, 3: 9, 9: 9, 5: 9, 8: 9, 7: 8, 1: 7, 4: 5})
Counter({9: 14, 10: 11, 4: 11, 7: 10, 1: 10, 5: 10, 3: 9, 6: 9, 8: 8, 2: 8})
Counter({7: 17, 3: 12, 8: 11, 9: 11, 10: 10, 4: 9, 2: 9, 5: 8, 1: 7, 6: 6})
Counter({3: 13, 2: 13, 5: 13, 1: 11, 10: 11, 6: 10, 8: 9, 7: 8, 9: 7, 4: 5})
Counter({6: 15, 3: 13, 5: 13, 1: 12, 10: 12, 7: 11, 8: 8, 4: 7, 9: 5, 2: 4})
Counter({5: 15, 1: 12, 8: 12, 7: 10, 2: 10, 6: 10, 9: 9, 3: 9, 4: 8, 10: 5})
Counter({3: 13, 9: 13, 4: 12, 10: 10, 2: 10, 1: 9, 8: 9, 7: 8, 6: 8, 5: 8})
</code></pre>
<hr/>
<p>Remarks:</p>
<p>Our random numbers will not match even if you use the same <code>random.seed(42)</code>. Using <em>n times</em> <code>random.choice()</code> changes the internal <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="nofollow noreferrer">random Mersenne_Twister</a>-state different from using <code>random.choices(.., k=n)</code> - if you switched to <code>random.choices</code> you will get identical outputs: </p>
<pre><code>from collections import Counter
import random

random.seed(42)
X = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

def randomX(l):
    lenl=len(l)
    return random.choices(l,k=lenl) 

def lists(times):
    lists = [randomX(X) for i in range(times)]
    x1 = Counter(sublist[0] for sublist in lists)
    x2 = Counter(sublist[1] for sublist in lists)
    x3 = Counter(sublist[2] for sublist in lists)
    x4 = Counter(sublist[3] for sublist in lists)
    x5 = Counter(sublist[4] for sublist in lists)
    x6 = Counter(sublist[5] for sublist in lists)
    x7 = Counter(sublist[6] for sublist in lists)
    x8 = Counter(sublist[7] for sublist in lists)
    x9 = Counter(sublist[8] for sublist in lists)
    x10 = Counter(sublist[9] for sublist in lists)
    return x1, x2, x3, x4, x5, x6, x7, x8, x9, x10

print(*lists(100), sep="\n")
</code></pre>
<p>Output now:</p>
<pre><code>Counter({9: 18, 7: 13, 10: 13, 5: 12, 3: 11, 8: 11, 1: 8, 4: 6, 6: 4, 2: 4})
Counter({3: 16, 7: 14, 6: 13, 8: 11, 10: 10, 1: 9, 4: 9, 5: 8, 9: 6, 2: 4})
Counter({6: 13, 7: 13, 3: 12, 9: 12, 2: 11, 5: 10, 10: 9, 8: 8, 4: 7, 1: 5})
Counter({10: 17, 2: 15, 6: 12, 3: 9, 9: 9, 5: 9, 8: 9, 7: 8, 1: 7, 4: 5})
Counter({9: 14, 10: 11, 4: 11, 7: 10, 1: 10, 5: 10, 3: 9, 6: 9, 8: 8, 2: 8})
Counter({7: 17, 3: 12, 8: 11, 9: 11, 10: 10, 4: 9, 2: 9, 5: 8, 1: 7, 6: 6})
Counter({3: 13, 2: 13, 5: 13, 1: 11, 10: 11, 6: 10, 8: 9, 7: 8, 9: 7, 4: 5})
Counter({6: 15, 3: 13, 5: 13, 1: 12, 10: 12, 7: 11, 8: 8, 4: 7, 9: 5, 2: 4})
Counter({5: 15, 1: 12, 8: 12, 7: 10, 2: 10, 6: 10, 9: 9, 3: 9, 4: 8, 10: 5})
Counter({3: 13, 9: 13, 4: 12, 10: 10, 2: 10, 1: 9, 8: 9, 7: 8, 6: 8, 5: 8})
</code></pre>
</div>
<span class="comment-copy">replace <code>randomX = [random.choice(X) for i in range(len(data))]</code> with <code>return random.choices(X, k=len(data))</code> .. or use it directly w/o the function</span>
<span class="comment-copy">why are you providing <code>X</code>as parameter <code>l</code> to your function and still use the global <code>X</code> in your function? Use <code>l</code> inside of it so you can give any list to your function</span>
<span class="comment-copy">what is keeping you from writing <code>x1 = Counter(sublist[0] for sublist in lists)</code> in a loop?</span>
