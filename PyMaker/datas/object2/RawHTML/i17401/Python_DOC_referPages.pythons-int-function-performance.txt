<div class="post-text" itemprop="text">
<p>Does Python's built-in function <a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow noreferrer">int</a> still try to convert the submitted value even if the value is already an integer?</p>
<p>More concisely: is there any performance difference between <code>int('42')</code> and <code>int(42)</code> caused by conversion algorithm?</p>
</div>
<div class="post-text" itemprop="text">
<p>As per the <a href="http://hg.python.org/cpython/file/d8f48717b74e/Objects/longobject.c#l4921">comments in the source code</a>,</p>
<blockquote>
<p>Convert a number or string to an integer, or return 0 if no arguments
  are given.  If x is a number, return <code>x.__int__</code>().  For floating point
  numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
  bytes, or bytearray instance representing an integer literal in the
  given base</p>
</blockquote>
<p>So, if the input is a number, <code>__int__</code> function will be called on that object and the result will be returned. Internally <a href="http://hg.python.org/cpython/file/d8f48717b74e/Include/object.h#l256"><code>nb_int</code> is an item in PyNumberMethods structure</a>, which corresponds to the <code>__int__</code> function. As per the latest source code at the time of this writing, <a href="http://hg.python.org/cpython/file/d8f48717b74e/Objects/longobject.c#l4954"><code>long_long</code> is the function which corresponds to the <code>nb_int</code> function</a>, which is defined like this</p>
<pre><code>long_long(PyObject *v)
{
    if (PyLong_CheckExact(v))
        Py_INCREF(v);
    else
        v = _PyLong_Copy((PyLongObject *)v);
    return v;
}
</code></pre>
<p>Here <a href="http://hg.python.org/cpython/file/d8f48717b74e/Include/longobject.h#l16"><code>PyLong_checkExact</code></a> is a Macro, which just checks if the current object is really of type long. If it is true, it simply increases the reference count and returns the object as it is, nothing extra is done.</p>
<p>If the input is in the form of a string, the string has to be converted to a number with <a href="http://hg.python.org/cpython/file/d8f48717b74e/Objects/longobject.c#l2336"><code>PyLong_FromUnicodeObject</code></a> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is handled in function <a href="http://hg.python.org/cpython/file/d8f48717b74e/Objects/longobject.c#l4302" rel="nofollow"><code>long_long</code> in <code>Objects/longobject.c</code></a>, as explained in more detail by thefourtheye:</p>
<pre><code>static PyObject *
long_long(PyObject *v)
{
    if (PyLong_CheckExact(v))
        Py_INCREF(v);
    else
        v = _PyLong_Copy((PyLongObject *)v);
    return v;
}
</code></pre>
<p>So, when the argument is already an <code>int</code>, the reference count is incremented and the same object returned.</p>
<p>You can assume similar behavior for immutable types in general,. For example, <code>tuple(mytuple)</code> returns a new reference to <code>mytuple</code>, while, by contrast, <code>list(mylist)</code> creates a copy of <code>mylist</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you pass an <code>int</code> object to <code>int()</code>, you get the same object back (CPython 3.3.2):</p>
<pre><code>&gt;&gt;&gt; a = 1000 * 1000 # large enough to avoid interning
&gt;&gt;&gt; b = int(a)
&gt;&gt;&gt; a is b
True
</code></pre>
<p>I don't know what you mean by "algorithmic performance difference", but it doesn't create a new object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you just compare both?</p>
<pre><code>&gt;&gt;&gt; def f(): int('42')
... 
&gt;&gt;&gt; def g(): int(42)
... 
&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; timeit(f)
0.3384080480027478
&gt;&gt;&gt; timeit(g)
0.2566616949989111
</code></pre>
</div>
<span class="comment-copy"><code>int</code> literal is actually a string without quotes. This conversion is done during compilation (that is during first processing of the source code). The Python's <code>int</code> object must be constructed in both cases. As Python does not use a machine <code>int</code> the complexity should be similar in both cases.</span>
<span class="comment-copy">Though this is almost similar to the actual function, this is in fact an internal helper function.</span>
<span class="comment-copy">@thefourtheye You are right, edited.</span>
<span class="comment-copy">No need to apologise, that is the better answer</span>
<span class="comment-copy">@Crystal Which will depend on the implementation you are using or your end-user will use.</span>
