<div class="post-text" itemprop="text">
<p>That iterating over a dict could yield <strong>sorted keys</strong> was surprising. It would be considerably useful too, if this is a guaranteed behaviour.</p>
<p><em>example code</em></p>
<pre><code>fruits = {3: "banana",
          4: "grapes",
          1: "apple",
          2: "cherry"}

# Looping over the dict itelf
for each in fruits:
    print each, fruits[each]
</code></pre>
<p><em>output</em></p>
<pre><code>1 apple
2 cherry
3 banana
4 grapes
</code></pre>
<p><br/></p>
<pre><code># Looping over the generator produces the same result too
for each in iter(fruits):
    print each, fruits[each]
</code></pre>
<p>Note: I would like to point out that I don't want implement an <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow">ordered dict</a>. I just wanted to verify if the code written above is a normal, recurring behavior in python (version 2.7 above)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can subclass the <code>dict</code> and create your own <code>SortedDict</code> class, like this</p>
<pre><code>class SortedDict(dict):
    def __iter__(self):
        return iter(sorted(super(SortedDict, self).__iter__()))

    def items(self):
        return iter((k, self[k]) for k in self)

fruits = SortedDict({3: "banana",
          4: "grapes",
          1: "apple",
          2: "cherry"})

for each in fruits:
    print each, fruits[each]
</code></pre>
<p>Complete working implementation is <a href="https://stackoverflow.com/a/21310344/1903116">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/stdtypes.html#dict.items" rel="nofollow">From the docs:</a></p>
<blockquote>
<p>Keys and values are listed in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionaryâ€™s history of insertions and deletions.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Iteration over a dict is not guaranteed to produce any particular order. In particular, it is not guaranteed to be sorted, it is not guaranteed to be in insertion order, it may be different between equal dicts, and it may be different from one execution of the interpreter to another. Here's an example:</p>
<pre><code>&gt;&gt;&gt; dict.fromkeys([-1, -2])
{-2: None, -1: None}
&gt;&gt;&gt; dict.fromkeys([-2, -1])
{-1: None, -2: None}
</code></pre>
<p>Two equal dicts, two different orders. Neither dict is in the order the keys were inserted in, and the second dict's keys aren't in sorted order.</p>
<p>If you want to iterate over the keys in sorted order, use</p>
<pre><code>for key in sorted(d)
</code></pre>
<p>If you want to iterate over the keys in the order they were inserted in, use a <code>collections.OrderedDict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Besides OrderedDict, you can just use the built-in sorted function to iterate a dict:</p>
<pre><code>fruits = {3: "banana",
      4: "grapes",
      1: "apple",
      2: "cherry"}

for each in sorted(fruits.items(), key=lambda i:i[0]):
      print each[0], each[1]
</code></pre>
<p>BTW, sorted() returns a two element tuple list, not a dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the docs state, no, keys are not sorted in a Python dict. But many people have found that behavior useful and there exist many implementations of sorted dicts on PyPI. The <a href="http://www.grantjenks.com/docs/sortedcontainers/sorteddict.html" rel="nofollow">SortedDict</a> data type does exactly what you observed: efficiently maintains its keys in sorted order.</p>
<p>One such implementation is the <a href="http://www.grantjenks.com/docs/sortedcontainers/" rel="nofollow">sortedcontainers</a> module which provides sorted list, sorted dict, and sorted set data types. It's implemented in pure-Python but is fast-as-C implementations. Unit tests provide 100% coverage and it's passed hours of stress testing.</p>
<p>Perhaps most importantly, sortedcontainers maintains a <a href="http://www.grantjenks.com/docs/sortedcontainers/performance.html" rel="nofollow">performance comparison</a> of several popular implementations along with a description of their tradeoffs.</p>
</div>
<span class="comment-copy">Python dictionaries aren't sorted, regardless of how you output the values. There is some related information in the post <a href="http://stackoverflow.com/questions/9001509/python-dictionary-sort-by-key">python dictionary sort by key</a></span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/21309374/how-to-make-a-sorted-dictionary-class">How to make a sorted dictionary class?</a></span>
<span class="comment-copy">@thefourtheye I saw that question before. But they are trying to implement a sorted dict. Here, I am asking if the afore mentioned code was a default behavior in Python.</span>
<span class="comment-copy">I never wanted to implement a sorted dict, I was asking to see if the behavior I mentioned above was a normal occurrence in python.</span>
<span class="comment-copy">@user3058846 No it is NOT. Because in this case, small integers in the range (-5, 256) are used as keys which are internally cached and their hash values are the same as their own values. That is why they appear to be sorted already. Try <code>{300: "banana",           400: "grapes",           1000: "apple",           2000: "cherry"}</code></span>
<span class="comment-copy">"They are ordered by their hash" - no, they're not, though it may appear that way sometimes.</span>
<span class="comment-copy">If that's true, then why does it give the error <code>"unhashable type"</code> when trying to assign with a key like a list?</span>
<span class="comment-copy">The hash values are used to locate an entry in a dict, but the entries are not sorted by hash. It's significantly more complex than that. Among other things, hash values are reduced to their last <code>n</code> bits for a hash table with <code>2**n</code> spaces, and there's a <a href="http://hg.python.org/cpython/file/7c47529bda0e/Objects/dictobject.c#l33" rel="nofollow noreferrer">100-line comment</a> in the source explaining the subtleties of Python's collision resolution.</span>
<span class="comment-copy">thanks so much for clarifying. lines removed</span>
