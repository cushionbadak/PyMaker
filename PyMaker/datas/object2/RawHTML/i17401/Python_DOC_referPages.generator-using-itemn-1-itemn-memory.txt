<div class="post-text" itemprop="text">
<p>I have a Python 3.x program that processes several large text files that contain sizeable arrays of data that can occasionally brush up against the memory limit of my puny workstation.  From some basic memory profiling, it seems like when using the generator, the memory usage of my script balloons to hold consecutive elements, using up to twice the memory I expect.</p>
<p>I made a simple, stand alone example to test the generator and I get similar results in Python 2.7, 3.3, and 3.4.  My test code follows, <code>memory_usage()</code> is a modifed version of <a href="https://stackoverflow.com/a/898406/194586">this function from an SO question</a> which uses <code>/proc/self/status</code> and agrees with <code>top</code> as I watch it.  <code>resource</code> is probably a more cross-platform method:</p>
<pre><code>import sys, resource, gc, time

def biggen():
    sizes = 1, 1, 10, 1, 1, 10, 10, 1, 1, 10, 10, 20, 1, 1, 20, 20, 1, 1
    for size in sizes:
        data = [1] * int(size * 1e6)
        #time.sleep(1)
        yield data

def consumer():
    for data in biggen():
        rusage = resource.getrusage(resource.RUSAGE_SELF)
        peak_mb = rusage.ru_maxrss/1024.0
        print('Peak: {0:6.1f} MB, Data Len: {1:6.1f} M'.format(
                peak_mb, len(data)/1e6))
        #print(memory_usage()) # 

        data = None  # go
        del data     # away
        gc.collect() # please.

# def memory_usage():
#     """Memory usage of the current process, requires /proc/self/status"""
#     # https://stackoverflow.com/a/898406/194586
#     result = {'peak': 0, 'rss': 0}
#     for line in open('/proc/self/status'):
#         parts = line.split()
#         key = parts[0][2:-1].lower()
#         if key in result:
#             result[key] = int(parts[1])/1024.0
#     return 'Peak: {peak:6.1f} MB, Current: {rss:6.1f} MB'.format(**result)

print(sys.version)
consumer()
</code></pre>
<p>In practice I'll process data coming from such a generator loop, saving just what I need, then discard it.</p>
<p>When I run the above script, and two large elements come in series (the data size can be highly variable), it seems like Python computes the next before freeing the previous, leading to up to double the memory usage.</p>
<pre><code>$ python genmem.py 
2.7.3 (default, Sep 26 2013, 20:08:41) 
[GCC 4.6.3]
Peak:    7.9 MB, Data Len:    1.0 M
Peak:   11.5 MB, Data Len:    1.0 M
Peak:   45.8 MB, Data Len:   10.0 M
Peak:   45.9 MB, Data Len:    1.0 M
Peak:   45.9 MB, Data Len:    1.0 M
Peak:   45.9 MB, Data Len:   10.0 M
#        ^^  not much different versus previous 10M-list
Peak:   80.2 MB, Data Len:   10.0 M
#        ^^  same list size, but new memory peak at roughly twice the usage
Peak:   80.2 MB, Data Len:    1.0 M
Peak:   80.2 MB, Data Len:    1.0 M
Peak:   80.2 MB, Data Len:   10.0 M
Peak:   80.2 MB, Data Len:   10.0 M
Peak:  118.3 MB, Data Len:   20.0 M
#        ^^  and again...  (20+10)*x
Peak:  118.3 MB, Data Len:    1.0 M
Peak:  118.3 MB, Data Len:    1.0 M
Peak:  118.3 MB, Data Len:   20.0 M
Peak:  156.5 MB, Data Len:   20.0 M
#        ^^  and again. (20+20)*x
Peak:  156.5 MB, Data Len:    1.0 M
Peak:  156.5 MB, Data Len:    1.0 M
</code></pre>
<p>The crazy belt-and-suspenders-and-duct-tape approach <code>data = None</code>, <code>del data</code>, and <code>gc.collect()</code> does nothing.</p>
<p>I'm pretty sure the generator itself is not doubling up on memory because otherwise a single large value it yields would increase the peak usage, and in the <em>same iteration</em> a large object appeared; it's only large consecutive objects.</p>
<p>How can I save my memory?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is in the generator function; particularly in the statement:</p>
<pre><code>    data = [1] * int(size * 1e6)
</code></pre>
<p>Suppose you have old content in the <em>data</em> variable. When you run this statement, it first computes the result, thus you have 2 these arrays in memory; old and new. Only then is <em>data</em> variable changed to point to the new structure and the old structure is released. Try to modify the iterator function to:</p>
<pre><code>def biggen():
    sizes = 1, 1, 10, 1, 1, 10, 10, 1, 1, 10, 10, 20, 1, 1, 20, 20, 1, 1
    for size in sizes:
        data = None
        data = [1] * int(size * 1e6)
        yield data
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried using the <a href="http://docs.python.org/3/library/gc.html" rel="nofollow">gc</a> module? There you can <a href="http://docs.python.org/3/library/gc.html#gc.get_referrers" rel="nofollow">get a list of the objects that still reference your large data</a> between loops, check if its in the <a href="http://docs.python.org/3/library/gc.html#gc.garbage" rel="nofollow">list of unreachable but unfreed objects</a>, or enable some debugs flags.</p>
<p>With luck, a simple call to <a href="http://docs.python.org/3/library/gc.html#gc.collect" rel="nofollow"><code>gc.collect()</code></a> after each loop may fix your problem in a single line.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of:</p>
<pre><code>        data = [1] * int(size * 1e6)
        #time.sleep(1)
        yield data
</code></pre>
<p>Try:</p>
<pre><code>        yield [1] * int(size * 1e6)
</code></pre>
<p>The problem is simply that the generator's <code>data</code> local variable keeps a reference to the yielded list, preventing it from ever being garbage collected until the generator resumes and discards the reference.</p>
<p>In other words, doing <code>del data</code> outside the generator has no effect on garbage collection unless that's the only reference to the data. Avoiding a reference inside the generator makes that true.</p>
<h2>Addendum</h2>
<p>If you have to manipulate the data, first, you can use a hack like this to drop the reference before yielding it:</p>
<pre><code>        data = [1] * int(size * 1e6)
        # ... do stuff with data ...

        # Yield data without keeping a reference to it:
        hack = [data]
        del data
        yield hack.pop()
</code></pre>
</div>
<span class="comment-copy"><code>id_ = None</code> is useless as _id is referenced by ids.</span>
<span class="comment-copy">if you only care about the first element of <code>data</code>, you should refactor <code>plate.good_data</code> to give you a generator, then just grab the first element yielded from it, no?  It seems like all your problems are coming from loading giant pieces of <code>data</code> into memory, the vast majority of which you don't care about.</span>
<span class="comment-copy">what about using temporary list for <code>i</code> and <code>data</code>?  Something like: <code>for [i, data] in enumerate(plate.good_data())</code>. There is a chance the garbage collector does something here?</span>
<span class="comment-copy">@roippi in use, I will be passing <code>data</code> to another function that crunches it down to something more manageable.  I was trying to make progressively more minimal 'programs' to narrow down what the problem was, and even without keeping any reference to it (that I can see), it still eats memory.</span>
<span class="comment-copy">@roippi I might be able to modify my generator to accept a function that does said processing before it returns the item...</span>
<span class="comment-copy">Good thinking, but I get the same result with a <code>collect()</code> (I forgot to mention, but I updated my post).  I'll look at having it tell me what might be keeping a ref though.</span>
<span class="comment-copy">I updated the question to provide an example anyone could run.</span>
<span class="comment-copy">I see it now between yours and ondra's post.  With my simplifications it's easy to make the fix seem trivial, but my actual code makes it a bit more difficult as I do other manipulations with the data and have sequential generators.</span>
<span class="comment-copy">@NickT: I added an example of a quick hack to let you work with a local variable, but still drop the reference when yielding. Beyond that, you'll probably have to show your actual code for further advice.</span>
