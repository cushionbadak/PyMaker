<div class="post-text" itemprop="text">
<p>I sometimes want an object to be treated as a number. This is what I do:</p>
<pre><code>class C(object):
def __init__(self):
    self.a = 1.23
    self.b = 'b'        

def __float__(self):
    return float(self.a)

c = C()
</code></pre>
<p>Explicit casting works:</p>
<pre><code>works = float(c) + 3.141
correct_comparison = (float(c) &lt; 1)
&gt;&gt;&gt; correct_comparison
False
</code></pre>
<p>However, automatic (implicit) casting doesn't work    </p>
<pre><code>wrong_comparison = (c &lt; 1)
&gt;&gt;&gt; wrong_comparison
True

doesnt_work = c + 2.718 #TypeError exception is thrown
</code></pre>
<p>Is there a way to perform automatic casting in Python. How bad is this idea?</p>
<p><strong>UPDATE</strong> @BrenBarn has pointed me to the <a href="http://docs.python.org/2/reference/datamodel.html#emulating-numeric-types" rel="nofollow">"emulating numeric types"</a> section in Python documentation. Indeed, it is possible to define every possible operator, which gives a lot of flexibility, but is also very verbose. It seems that automatic implicit casting is possible only if one defines all the relevant operators. Is there a way to make this less verbose?</p>
</div>
<div class="post-text" itemprop="text">
<p>As @BrenBarn said, you can use inheritance:</p>
<pre><code>class SomeFloat(float):
    def __init__(self, *args):
        super(float, self).__init__(*args)
        self.b = 'b'
</code></pre>
<p>It will be not so verbose.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not the way Python thinks about objects. There is little value coming casting <code>C</code> to a float because Python usually doesn't care what an object <strong>is</strong> but how an object <strong>behaves</strong>. You should implement the custom comparison functions like <code>__lt__</code> and <code>__eq__</code>. See <a href="http://docs.python.org/3/reference/datamodel.html?highlight=__lt__#object.__lt__" rel="nofollow">here</a>. <a href="http://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow">This</a> will also be handy.</p>
<p>The solution may look something like</p>
<pre><code>import functools

@functools.total_ordering
class C(object):

    def __init__(self):
        self.a = 1.2345

    def __float__(self):
        return float(self.a)

    def __eq__(self, other):
        return self.a == float(other)

    def __lt__(self, other):
        return self.a &lt; float(other)

c = C()
assert c &lt; 3.14
assert 3.14 &gt; c
assert c == 1.23456
assert 1.23456 == c
assert c != 1
</code></pre>
</div>
<span class="comment-copy">There is no implicit casting in that sense.  You need to implement the operations yourself.  See <a href="http://docs.python.org/2/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">the documentation</a>.  In some cases, you may be able to inherit from <code>float</code> and thus inherit the builtin versions of math operations, but whether this will work depends on how complex your class is.</span>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/9057669/how-can-i-intercept-calls-to-pythons-magic-methods-in-new-style-classes">this question</a> for a way of writing a proxy object which proxies the operator overloading through for an underlying type.  This makes it less verbose when defining your class, but the mechanism to make this happen is more complex.  It's a tradeoff that may depend on whether you are just making one class like this, or many.</span>
<span class="comment-copy">this doesn't work on Python3: <code>SomeFloat(3.14)</code> raises an exception: "TypeError: object.__init__() takes no parameters"</span>
<span class="comment-copy">That's strange, it must be working in python3 too. By the way, in python &gt; 3.2 you can do: def __init__(self, *args):   super().__init__(*args)</span>
<span class="comment-copy">This works with math.sin(c), but does not work with random.gauss(c, c), any clue as to why?</span>
