<div class="post-text" itemprop="text">
<p>I have a list of sentences:</p>
<pre><code>text = ['cant railway station','citadel hotel',' police stn']. 
</code></pre>
<p>I need to form bigram pairs and store them in a variable. The problem is that when I do that, I get a pair of sentences instead of words. Here is what I did: </p>
<pre><code>text2 = [[word for word in line.split()] for line in text]
bigrams = nltk.bigrams(text2)
print(bigrams)
</code></pre>
<p>which yields </p>
<pre><code>[(['cant', 'railway', 'station'], ['citadel', 'hotel']), (['citadel', 'hotel'], ['police', 'stn'])
</code></pre>
<p>Can't railway station and citadel hotel form one bigram. What I want is </p>
<pre><code>[([cant],[railway]),([railway],[station]),([citadel,hotel]), and so on...
</code></pre>
<p>The last word of the first sentence should not merge with the first word of second sentence.
What should I do to make it work?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/3.3/tutorial/datastructures.html#list-comprehensions">list comprehensions</a> and <a href="http://docs.python.org/3/library/functions.html#zip">zip</a>:</p>
<pre><code>&gt;&gt;&gt; text = ["this is a sentence", "so is this one"]
&gt;&gt;&gt; bigrams = [b for l in text for b in zip(l.split(" ")[:-1], l.split(" ")[1:])]
&gt;&gt;&gt; print(bigrams)
[('this', 'is'), ('is', 'a'), ('a', 'sentence'), ('so', 'is'), ('is', 'this'), ('this',     
'one')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than turning your text into lists of strings, start with each sentence separately as a string. I've also removed punctuation and stopwords, just remove these portions if irrelevant to you:</p>
<pre><code>import nltk
from nltk.corpus import stopwords
from nltk.stem import PorterStemmer
from nltk.tokenize import WordPunctTokenizer
from nltk.collocations import BigramCollocationFinder
from nltk.metrics import BigramAssocMeasures

def get_bigrams(myString):
    tokenizer = WordPunctTokenizer()
    tokens = tokenizer.tokenize(myString)
    stemmer = PorterStemmer()
    bigram_finder = BigramCollocationFinder.from_words(tokens)
    bigrams = bigram_finder.nbest(BigramAssocMeasures.chi_sq, 500)

    for bigram_tuple in bigrams:
        x = "%s %s" % bigram_tuple
        tokens.append(x)

    result = [' '.join([stemmer.stem(w).lower() for w in x.split()]) for x in tokens if x.lower() not in stopwords.words('english') and len(x) &gt; 8]
    return result
</code></pre>
<p>To use it, do like so:</p>
<pre><code>for line in sentence:
    features = get_bigrams(line)
    # train set here
</code></pre>
<p>Note that this goes a little further and actually statistically scores the bigrams (which will come in handy in training the model).</p>
</div>
<div class="post-text" itemprop="text">
<p>Without nltk:</p>
<pre><code>ans = []
text = ['cant railway station','citadel hotel',' police stn']
for line in text:
    arr = line.split()
    for i in range(len(arr)-1):
        ans.append([[arr[i]], [arr[i+1]]])


print(ans) #prints: [[['cant'], ['railway']], [['railway'], ['station']], [['citadel'], ['hotel']], [['police'], ['stn']]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from nltk import word_tokenize 
from nltk.util import ngrams


text = ['cant railway station', 'citadel hotel', 'police stn']
for line in text:
    token = nltk.word_tokenize(line)
    bigram = list(ngrams(token, 2)) 

    # the '2' represents bigram...you can change it to get ngrams with different size
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; text = ['cant railway station','citadel hotel',' police stn']
&gt;&gt;&gt; bigrams = [(ele, tex.split()[i+1]) for tex in text  for i,ele in enumerate(tex.split()) if i &lt; len(tex.split())-1]
&gt;&gt;&gt; bigrams
[('cant', 'railway'), ('railway', 'station'), ('citadel', 'hotel'), ('police', 'stn')]
</code></pre>
<p>Using enumerate and split function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just fixing Dan's code:</p>
<pre><code>def get_bigrams(myString):
    tokenizer = WordPunctTokenizer()
    tokens = tokenizer.tokenize(myString)
    stemmer = PorterStemmer()
    bigram_finder = BigramCollocationFinder.from_words(tokens)
    bigrams = bigram_finder.nbest(BigramAssocMeasures.chi_sq, 500)

    for bigram_tuple in bigrams:
        x = "%s %s" % bigram_tuple
        tokens.append(x)

    result = [' '.join([stemmer.stem(w).lower() for w in x.split()]) for x in tokens if x.lower() not in stopwords.words('english') and len(x) &gt; 8]
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Read the dataset</h1>
<pre><code>df = pd.read_csv('dataset.csv', skiprows = 6, index_col = "No")
</code></pre>
<h1>Collect all available months</h1>
<pre><code>df["Month"] = df["Date(ET)"].apply(lambda x : x.split('/')[0])
</code></pre>
<h1>Create tokens of all tweets per month</h1>
<pre><code>tokens = df.groupby("Month")["Contents"].sum().apply(lambda x : x.split(' '))
</code></pre>
<h1>Create bigrams per month</h1>
<pre><code>bigrams = tokens.apply(lambda x : list(nk.ngrams(x, 2)))
</code></pre>
<h1>Count bigrams per month</h1>
<pre><code>count_bigrams = bigrams.apply(lambda x : list(x.count(item) for item in x))
</code></pre>
<h1>Wrap up the result in neat dataframes</h1>
<pre><code>month1 = pd.DataFrame(data = count_bigrams[0], index= bigrams[0], columns= ["Count"])
month2 = pd.DataFrame(data = count_bigrams[1], index= bigrams[1], columns= ["Count"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a <strong>number of ways</strong> to solve it but I solved in this way:</p>
<pre><code>&gt;&gt;text = ['cant railway station','citadel hotel',' police stn']
&gt;&gt;text2 = [[word for word in line.split()] for line in text]
&gt;&gt;text2
[['cant', 'railway', 'station'], ['citadel', 'hotel'], ['police', 'stn']]
&gt;&gt;output = []
&gt;&gt;for i in range(len(text2)):
    output = output+list(bigrams(text2[i]))
&gt;&gt;#Here you can use list comphrension also
&gt;&gt;output
[('cant', 'railway'), ('railway', 'station'), ('citadel', 'hotel'), ('police', 'stn')]
</code></pre>
</div>
<span class="comment-copy">Now there is ;)</span>
<span class="comment-copy"><code>stemmer</code> changes <code>apple</code> to <code>appl</code> so I get <code>['appl basket']</code>.</span>
<span class="comment-copy">Yeah there are some limitations with Porter stemmer.</span>
<span class="comment-copy">but this is not by sentences, you should use <code>from_documents</code>.</span>
<span class="comment-copy">are they bigrams by default? because i'll be needing them for spell correct.</span>
<span class="comment-copy">@Sword you can see that it generates only bigrams from the last line (before the print). Play with it, try different sentences and see for yourself ;)</span>
