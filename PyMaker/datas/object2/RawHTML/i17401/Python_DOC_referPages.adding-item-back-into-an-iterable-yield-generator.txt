<div class="post-text" itemprop="text">
<p>I thought this is a great moment to use <code>yield</code>, but I'm stuck.</p>
<p>When something fails, I would like to send the item back into the generator. I've read that this is possible, so I'd really like to use my first generator.</p>
<pre><code>states = ["IL", "NY", "NJ"]
for state in states:
    ok = do something
    if not ok:
        *add state back as the first-to-deal with in the generator*
</code></pre>
<p>How to use a generator in such a case?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are probably referring to a <a href="http://www.python.org/dev/peps/pep-0342/" rel="nofollow">coroutine</a>, which leverages the <em>yield expression</em>.  It works a little like this:</p>
<pre><code>def co_gen(li):
    for x in li:
        bad = yield x
        if bad is not None:
            print('ack! {}'.format(bad))
            #other error handling
</code></pre>
<p>and (contrived) usage:</p>
<pre><code>states = ["IL", "NY", "NJ"]

gen = co_gen(states)

for x in gen:
    print('processing state: {}'.format(x))
    if x == 'NY':
        y = gen.send('Boo, Yankees!')
        print( 'processing state after error: {}'.format(y))

# processing state: IL
# processing state: NY
# ack! Boo, Yankees!
# processing state after error: NJ
</code></pre>
<p>Salient points - normal <code>yield</code> behavior assigns <code>None</code> to <code>bad</code>.  If it's not None, something has been <code>send</code>-ed into the generator.  </p>
<p>When we <code>send</code> something into the generator, it <em>resumes operation until it reaches the next yield expression</em>.  So keep that in mind - the above control flow in the coroutine isn't what I'd call "standard" since there is no <code>yield</code>ing done in the error block.</p>
<p>Here is a coroutine that operates a little more like what you were talking about:</p>
<pre><code>def co_gen(li):
    for x in li:
        bad = yield x
        while bad is not None:
            print('error in generator: {}'.format(bad))
            yield
            bad = yield bad

gen = co_gen(states)

for x in gen:
    print('processing state: {}'.format(x))
    if random.choice([0,1]):
        gen.send(x) #discard first yield
        print( 'error: trying {} again'.format(x) )

# processing state: IL
# error in generator: IL
# error: trying IL again
# processing state: IL
# processing state: NY
# error in generator: NY
# error: trying NY again
# processing state: NY
# processing state: NJ
</code></pre>
<p>We <code>send</code> our state back into the generator, and it keeps yielding it until we stop sending it.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def ok(i):
    from random import randint
    return bool(randint(0,1))


def mygen(iterable):
    def helper(iterable):
        for i in iterable:
            elem = yield i
            if elem:
                iterable.append(elem)

    it = helper(iterable)
    sendBack = False
    while True:
        try:
            if sendBack:
                print "Sending back {0}".format(i)
                i = it.send(i)
            else:
                i = it.send(None)
            if ok(i):
                sendBack = False
                yield i
            else:
                sendBack = True

        except StopIteration:
            break

x = range(10)

print list(mygen(x))
#Sending back 1
#Sending back 5
#Sending back 7
#Sending back 1
#Sending back 7
#[0, 2, 3, 4, 6, 8, 9, 5, 1, 7]
</code></pre>
<p>Two generators, sending back the value if the return value evaluates to false for some function. (random in this case). </p>
</div>
<div class="post-text" itemprop="text">
<p>While it's possible to do what you're asking with regular generators and <code>gen.send()</code> and <code>sent_back = yield x</code>, your code will be very complicated. It may be easier to write your own <a href="http://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">iterator type</a>, which supports a method other than <code>send</code> for getting the "sent back" items:</p>
<pre><code>class SendBackIter(object):
    def __init__(self, iterable):
        self.iterator = iter(iterable)
        self.sent_back = []

    def __iter__(self):
        return self

    def __next__(self):
        if self.sent_back:              # if the stack is not empty...
            return self.sent_back.pop() # return the last item from the sent_back stack
        return next(self.iterator)      # otherwise return an item from our iterator

    def send_back(self, obj):
        self.sent_back.append(obj)
</code></pre>
<p>If you only need to deal with repeating an item that just came out of the iteration, you could make it simpler yet:</p>
<pre><code>def RepeatableIter(object);
    def __init__(self, iterable):
        self.iterator = iter(iterable)
        self.last_item = None
        self.repeat = False   # client code can set this to True to repeat the last value

    def __iter__(self):
        return self

    def __next__(self):
        if self.repeat:
            self.repeat = False # only repeat once, by default
        else:
            self.last_item = next(self.iterator)

        return self.last_item
</code></pre>
<p>Here's how you could use that last version:</p>
<pre><code>it = RepeatableIter(["foo", "bar", "baz"])
for item in it:
    if is_not_ok(item):
        it.repeat = True # this means we will get the same item on the next iteration
    else:
        do_something(item)
</code></pre>
</div>
<span class="comment-copy">This looks like an infinite loop to me. You can just put it into a second list to "deal with it later" otherwise you'll keep processing the same item and putting it back into the list?</span>
<span class="comment-copy">It has an external dependency (based on internet), so when there is connection it will continue, I will add some timer to it and then it is allowed to run infinitely (thought it won't).</span>
<span class="comment-copy">Does not address the 'add state back as the first-to-deal with in the generator' requirement, since 'NJ' is returned after the first 'NY' (which resulted in error).</span>
<span class="comment-copy">@isedev yes, you can put <code>yield</code>s in to the <code>#error handling</code> block, like I said.  I'll make it more explicit.</span>
<span class="comment-copy">It really does what I hoped for, but it really seems a lot more complicated than I thought it would be...</span>
<span class="comment-copy">Focusing on the latter part of the code, what exactly do the 3 yields do (it really seems so overly complicated)</span>
<span class="comment-copy">Also, why is directly <code>for x in co_gen(states):</code> not possible?</span>
<span class="comment-copy">It should be put to the front though, not to the end?</span>
