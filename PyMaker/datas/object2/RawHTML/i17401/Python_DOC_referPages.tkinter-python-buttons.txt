<div class="post-text" itemprop="text">
<p>When I want to add a button like</p>
<pre><code>b = Button(app_name,text="..." , command = any_function)
</code></pre>
<p>is it possible to use function with a parameter like</p>
<pre><code>b = Button(app_name, text="..." , command = any_function(7))
</code></pre>
<p>I had tried </p>
<pre><code> (...)
 def cash(price):
        global total
        total.set(total.get() + price)

total = IntVar()
total.set(0)

b1 = Button(app,text = "one ",width = 10,command = cash(1))
b1.pack()
b2 = Button(app,text = "two ",width = 10,command = cash(10))
b2.pack()
b3 = Button(app,text = "three ",width = 10,command = cash(100))
b3.pack()
b4 = Button(app,text = "four ",width = 10,command = cash(1000))
b4.pack()

l_total = Label(app,textvariable = total)
l_total.pack()
(...)
</code></pre>
<p>But <code>l_total</code> already as 1111 when the program run ( 1000+100+10+1) like I had pressed the four buttons and also the buttons doesnt add values to <code>l_total</code> . I just want to know why it doesnt work as I know a solution . </p>
</div>
<div class="post-text" itemprop="text">
<p>What you've written:</p>
<pre><code>b = Button(app_name, text="..." , command = any_function(7))
</code></pre>
<p>â€¦ isn't <em>passing a function</em> as the <code>command</code>, it's <em>calling</em> a function, then <em>passing its result</em> as the <code>command</code>.</p>
<hr/>
<p>What you need to do is to define a new function that, when called with no arguments, calls <code>any_function(7)</code>. Like this:</p>
<pre><code>def any_function_7():
    return any_function(7)
b = Button(app_name, text="..." , command = any_function_7)
</code></pre>
<p>Or, using the shorter <a href="http://docs.python.org/3.3/tutorial/controlflow.html#lambda-expressions" rel="nofollow"><code>lambda</code></a> syntax for defining functions:</p>
<pre><code>b = Button(app_name, text="..." , command = lambda: any_function(7))
</code></pre>
<p>Wrapping an expression up in a function like this, then passing the function around, is a way of deferring the function until later. It can be hard to get your head around, but once you do, it's incredibly useful all over the place.</p>
<hr/>
<p>Another way to look at it is <em>partially applying</em> the function, which gives you a thing that you can <em>finish</em> applying later on. There's a <a href="http://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>partial</code></a> function in the standard library that does this for you:</p>
<pre><code>from functools import partial
b = Button(app_name, text="..." , command = partial(any_function, 7))
</code></pre>
<p>But you can also do it yourself:</p>
<pre><code>def make_any_function_partial(i):
    def wrapped():
        return any_function(i)
    return wrapped
b = Button(app_name, text="..." , command = make_any_function_partial(7))
</code></pre>
<p>And then you can see how this is really just the same trick as using <code>def</code> or <code>lambda</code>, plus another trick on top of it: it's a function that returns a function. So, while you may be calling <code>make_any_function_partial</code> and passing its result to <code>command</code>, just as in your original attempt, the difference is that the result is itself a function.</p>
</div>
