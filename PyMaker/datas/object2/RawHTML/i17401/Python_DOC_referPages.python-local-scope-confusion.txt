<div class="post-text" itemprop="text">
<p>I'm trying to understand Python scopes. See this example:</p>
<pre><code>x = 'foo'

def outer(p):
    print x
    x = 'bar'
    def inner(p):
        print x
    inner(1)

print x
outer(1)
</code></pre>
<p>This code results the following error:</p>
<pre><code>Traceback (most recent call last):
  File "scopes2.py", line 11, in &lt;module&gt;
    outer(1)
  File "scopes2.py", line 4, in outer
    print x
UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>
<p>Now if I remove the <code>x = 'bar'</code> line, then it runs as expected.</p>
<p>How come I cannot use the global <code>x</code> from the <code>print x</code> in <code>outer()</code> until I rebind it to <code>'bar'</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Any time you have an assignment in a function, that variable is considered local for the entirety of the function. You can't just reference the global "until the local assignment"</p>
<hr/>
<p><a href="http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="nofollow">What are the rules for local and global variables in Python</a> (emphasis mine)</p>
<blockquote>
<p>In Python, variables that are only referenced inside a function are
  implicitly global. <strong>If a variable is assigned a new value anywhere
  within the function’s body, it’s assumed to be a local.</strong> If a variable
  is ever assigned a new value inside the function, the variable is
  implicitly local, and you need to explicitly declare it as ‘global’.</p>
<p>Though a bit surprising at first, a moment’s consideration explains
  this. On one hand, requiring global for assigned variables provides a
  bar against unintended side-effects. On the other hand, if global was
  required for all global references, you’d be using global all the
  time. You’d have to declare as global every reference to a built-in
  function or to a component of an imported module. This clutter would
  defeat the usefulness of the global declaration for identifying
  side-effects.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>To refer to the the global <code>x</code> from the function, use</p>
<pre><code>def outer(p):
    global x
    print x
    x = 'bar'
    ...
</code></pre>
<p>Note that the assignment to <code>x</code> would rebind the <em>global</em> <code>x</code> too. If you don't want to happen, rename one of the variables (or, better still, don't use global variables).</p>
</div>
<span class="comment-copy">Does that mean that the interpreter doesn't process the code line-by-line during the execution then? I tried to put in an if 1: pass` <code>else: x='bar'\ndo_error</code> into the <code>outer()</code> function. Although execution would never reach the else branch, it still complained about the undefined local variable. On the other hand it didn't complain at all about the undefined <code>do_error</code>, and run perfectly if I removed the assignment.</span>
<span class="comment-copy">Yes, the interpreter evaluates the entire function to determine global vs local</span>
<span class="comment-copy">if <code>locals()</code> also doesn't contain the name <code>x</code> before the line <code>x = 'bar'</code>, is there a way to "find" it at that point? I mean to find that such a name might be bonded in the block?</span>
<span class="comment-copy">@Mkoch (1 comment up) yes, but that's a matter for a separate question, if you're still curious about it - and not really recommended. A better solution is to just use a different name for the local variable. (3 comments up) this happens because Python is <i>compiled</i> to bytecode and then interpreted, not interpreted directly from the source code. The compiler processes the whole function definition at once and creates a symbol table (name-&gt;memory location) for that entire function.</span>
<span class="comment-copy">@mhlester This thread is pretty old, hopefully, someone responds. So the way interpreter works is that it takes up a function checks its validity and execute line by line ? So in a huge python program, the syntax error in a function can be found only when interpreter reaches that particular function ?</span>
<span class="comment-copy">global is needed if I want to change the global x instead of rebinding it in my local scope, but this does not answer my question imho</span>
