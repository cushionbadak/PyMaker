<div class="post-text" itemprop="text">
<p>I have a numpy matrix X and I would like to add to this matrix as new variables all the possible products between 2 columns.</p>
<pre><code>So if X=(x1,x2,x3) I want X=(x1,x2,x3,x1x2,x2x3,x1x3)
</code></pre>
<p>Is there an elegant way to do that?
I think a combination of numpy and itertools should work</p>
<p>EDIT:
Very good answers but are they considering that X is a matrix? So x1,x1,.. x3 can eventually be arrays?</p>
<p>EDIT:
A Real example </p>
<pre><code>a=array([[1,2,3],[4,5,6]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/itertools.html" rel="nofollow">Itertools</a> should be the answer here.</p>
<pre><code>a = [1, 2, 3]
p = (x * y for x, y in itertools.combinations(a, 2))
print list(itertools.chain(a, p))
</code></pre>
<p>Result:</p>
<pre><code>[1, 2, 3, 2, 3, 6] # 1, 2, 3, 2 x 1, 3 x 1, 3 x 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think Samy's solution is pretty good. If you <em>need</em> to use numpy, you could transform it a little like this:</p>
<pre><code>from itertools import combinations
from numpy import prod

x = [1, 2, 3]
print x + map(prod, combinations(x, 2))
</code></pre>
<p>Gives the same output as Samy's solution:</p>
<pre><code>[1, 2, 3, 2, 3, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your arrays are small, then <a href="https://stackoverflow.com/a/22042088/68063">Samy's pure-Python solution</a> using <a href="http://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> should be fine:</p>
<pre><code>from itertools import combinations, chain

def all_products1(a):
    p = (x * y for x, y in combinations(a, 2))
    return list(chain(a, p))
</code></pre>
<p>But if your arrays are large, then you'll get a substantial speedup by fully vectorizing the computation, using <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.triu_indices.html" rel="nofollow noreferrer"><code>numpy.triu_indices</code></a>, like this:</p>
<pre><code>import numpy as np

def all_products2(a):
    x, y = np.triu_indices(len(a), 1)
    return np.r_[a, a[x] * a[y]]
</code></pre>
<p>Let's compare these:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; data = np.random.uniform(0, 100, (10000,))
&gt;&gt;&gt; timeit(lambda:all_products1(data), number=1)
53.745754408999346
&gt;&gt;&gt; timeit(lambda:all_products2(data), number=1)
12.26144006299728
</code></pre>
<p>The solution using <code>numpy.triu_indices</code> also works for multi-dimensional data:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; np.random.uniform(0, 100, (3,2))
array([[ 63.75071196,  15.19461254],
       [ 94.33972762,  50.76916376],
       [ 88.24056878,  90.36136808]])
&gt;&gt;&gt; all_products2(_)
array([[   63.75071196,    15.19461254],
       [   94.33972762,    50.76916376],
       [   88.24056878,    90.36136808],
       [ 6014.22480172,   771.41777239],
       [ 5625.39908354,  1373.00597677],
       [ 8324.59122432,  4587.57109368]])
</code></pre>
<p>If you want to operate on columns rather than rows, use:</p>
<pre><code>def all_products3(a):
    x, y = np.triu_indices(a.shape[1], 1)
    return np.c_[a, a[:,x] * a[:,y]]
</code></pre>
<p>For example:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; np.random.uniform(0, 100, (2,3))
array([[ 33.0062385 ,  28.17575024,  20.42504351],
       [ 40.84235995,  61.12417428,  58.74835028]])
&gt;&gt;&gt; all_products3(_)
array([[   33.0062385 ,    28.17575024,    20.42504351,   929.97553238,
          674.15385734,   575.4909246 ],
       [   40.84235995,    61.12417428,    58.74835028,  2496.45552756,
         2399.42126888,  3590.94440122]])
</code></pre>
</div>
<span class="comment-copy">I have  a big array so your solutions would be good.  the problem is that you are adding lines. I would like to add columns.</span>
<span class="comment-copy">See revised answer.</span>
