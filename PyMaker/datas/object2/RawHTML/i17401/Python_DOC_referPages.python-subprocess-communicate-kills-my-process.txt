<div class="post-text" itemprop="text">
<p>Why does communicate kill my process?  I want an interactive process but communicate does something so that I cannot take raw_input any more in my process.</p>
<pre><code>from sys import stdin 
from threading import Thread
from time import sleep

if __name__ == '__main__':
    print("Still Running\n")
    x = raw_input()    
    i = 0
    while ('n' not in x ) :
        print("Still Running " + str(i) + " \r\n")
        x = raw_input()
        i += 1

    print("quit")



print(aSubProc.theProcess.communicate('y'))
print(aSubProc.theProcess.communicate('y'))
</code></pre>
<p>exception!</p>
<pre><code>self.stdin.write(input)
ValueError: I/O operation on closed file
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>communicate</code> and <code>wait</code> methods of <code>Popen</code> objects, close the <code>PIPE</code> after the process returns. If you want stay in communication with the process try something like this:</p>
<pre><code>import subprocess
proc = subprocess.Popen("some_process", stdout=subprocess.PIPE, stdin=subprocess.PIPE)
proc.stdin.write("input")
proc.stdout.readline()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why does communicate kill my process? </p>
</blockquote>
<p>From the docs for <a href="http://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow"><code>Popen.communicate(input=None, timeout=None)</code></a>:</p>
<blockquote>
<p>Interact with process: Send data to stdin. Read data from stdout and<br/>
  stderr, until end-of-file is reached. <strong><em>Wait for process to terminate.</em></strong>
<sup>emphasize mine</sup></p>
</blockquote>
<p>You may call <code>.communicate()</code> only once. It means that you should provide all input at once:</p>
<pre><code>#!/usr/bin/env python
import os
import sys
from subprocess import Popen, PIPE

p = Popen([sys.executable, 'child.py'], stdin=PIPE, stdout=PIPE)
print p.communicate(os.linesep.join('yyn'))[0]
</code></pre>
<h3>Output</h3>
<pre><code>Still Running

Still Running 0 

Still Running 1 

quit
</code></pre>
<p>Notice the doubled newlines: one from <code>'\r\n'</code> and another from <code>print</code> statement itself in your script for the child process.</p>
<p>Output shows that the child process received three input lines successfully (<code>'y'</code>, <code>'y'</code>, and <code>'n'</code>).</p>
<p>Here's a similar code using <a href="http://docs.python.org/3.4/library/subprocess.html#subprocess.check_output" rel="nofollow"><code>subprocess.check_output()</code></a>'s <code>input</code> parameter from Python3.4:</p>
<pre><code>#!/usr/bin/env python3.4
import os
import sys
from subprocess import check_output

output = check_output(['python2', 'child.py'], universal_newlines=True,
                      input='\n'.join('yyn'))
print(output, end='')
</code></pre>
<p>It produces the same output.</p>
<hr/>
<p>If you want to provide a different input depending on responses from the child processes then use <code>pexpect</code> module or its analogs to avoid issues mentioned in <a href="http://pexpect.readthedocs.org/en/latest/FAQ.html#whynotpipe" rel="nofollow">Why not just use a pipe (popen())?</a></p>
</div>
<span class="comment-copy">Your code leads to a deadlock due to buffering. See <a href="http://pexpect.readthedocs.org/en/latest/FAQ.html#whynotpipe" rel="nofollow noreferrer">Why not just use a pipe (popen())?</a> Also, <code>proc.communicate()</code> closes pipes when it sees EOF that may happen before/after the child process exits. <code>proc.wait()</code> doesn't close any pipes. It waits for the child process to exit.</span>
