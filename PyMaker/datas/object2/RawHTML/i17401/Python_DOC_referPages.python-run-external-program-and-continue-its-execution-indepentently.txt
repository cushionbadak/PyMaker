<div class="post-text" itemprop="text">
<p>How can i run an external program, let's say "Firefox", from my python script and make sure that its process will remain alive after the termination of my python script? I want to make it crossplatform if it's doable.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no cross-platform way to do this with just the stdlib. However, if you write code for POSIX and for Windows, that's usually good enough, right?</p>
<p>On Windows, you want to pass a <a href="http://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow"><code>creationflags</code></a> argument. Read the docs (both there and <a href="http://msdn.microsoft.com/en-us/library/ms684863%28v=vs.85%29.aspx" rel="nofollow">at MSDN</a>) and decide whether you want a console-detached process, a new-console process, or a new-process-group process, then use the appropriate flag. You may also want to set some of the flags in <code>startupinfo</code>; again, <a href="http://msdn.microsoft.com/en-us/library/ms686331%28v=vs.85%29.aspx" rel="nofollow">MSDN</a> will tell you what they mean.</p>
<p>On POSIX, if you just want the simplest behavior, and you're using 3.2+, you want to pass <code>start_new_session=True</code>. In earlier Python versions, or for other cases, you want to pass a <code>preexec_fn</code> that allows you to do whatever daemonization you want. That could be as little as <code>os.setsid()</code> (what <code>start_new_session</code> does), or a whole lot more. See <a href="http://www.python.org/dev/peps/pep-3143/" rel="nofollow">PEP 3143 -- Standard daemon process library</a> for a discussion of all of the different things you might want to do here.</p>
<p>So, the simplest version is:</p>
<pre><code>def launch_in_background(args):
    try:
        subprocess.CREATE_NEW_PROCESS_GROUP
    except AttributeError:
        # not Windows, so assume POSIX; if not, we'll get a usable exception
        p = subprocess.Popen(args, start_new_session=True)
    else:
        # Windows
        p = subprocess.Popen(args, creationflags=subprocess.CREATE_NEW_PROCESS_GROUP)
</code></pre>
<hr/>
<p>If you're willing to go outside the stdlib, there are dozens of "shell-type functionality" libraries out there, many of which have some kind of "detach" functionality. Just search <a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=shell&amp;submit=search" rel="nofollow"><code>shell</code></a>, <a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=cli&amp;submit=search" rel="nofollow"><code>cli</code></a>, or <a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=subprocess&amp;submit=search" rel="nofollow"><code>subprocess</code></a> at PyPI and find the one you like best.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/204017/how-do-i-execute-a-program-from-python-os-system-fails-due-to-spaces-in-path" title="how do i execute a program from python os system fails due to spaces in path">stackoverflow.com/questions/204017/…</a></span>
<span class="comment-copy">@jonjohnson: How does that answer this question, or even related to it? The question there is about a quoting problem with <code>os.system</code>, and the answer is to use <code>subprocess.call</code>, which will block until the child process finishes…</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/13243807/4279">Popen waiting for child process even when the immediate child has terminated</a></span>
