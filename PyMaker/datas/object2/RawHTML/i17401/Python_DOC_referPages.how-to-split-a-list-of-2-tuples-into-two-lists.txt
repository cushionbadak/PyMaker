<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/19339/transpose-unzip-function-inverse-of-zip">Transpose/Unzip Function (inverse of zip)?</a>
<span class="question-originals-answer-count">
                    12 answers
                </span>
</li>
</ul>
</div>
<p>I have a list of many 2-tuples. 
I would like to split the list into two lists, one list consisting of the first elements of all the tuples in the list, and the other list consisting of the second elements of all the tuples. I wonder how to do that efficiently? Thanks!</p>
<p>For example, I have a list <code>y</code>:</p>
<pre><code>&gt;&gt;&gt; y = [('ab',1), ('cd', 2), ('ef', 3) ]
&gt;&gt;&gt; type(y)
&lt;type 'list'&gt;
</code></pre>
<p>I hope to get two lists <code>['ab', 'cd', 'ef']</code> and <code>[1, 2, 3]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a,b = zip(*y)
</code></pre>
<p>is all you need ... </p>
<p>or if you need them as lists and not tuples</p>
<pre><code>a,b = map(list,zip(*y))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/3/library/functions.html#zip"><code>zip</code></a> and a <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; y = [('ab', 1), ('cd', 2), ('ef', 3)]
&gt;&gt;&gt; a,b = [list(c) for c in zip(*y)]
&gt;&gt;&gt; a
['ab', 'cd', 'ef']
&gt;&gt;&gt; b
[1, 2, 3]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/functions.html#zip">zip</a> with <code>*</code> argument unpacking will give you tuples:</p>
<pre><code>&gt;&gt;&gt; a, b = zip(*y)
&gt;&gt;&gt; a
('ab', 'cd', 'ef')
&gt;&gt;&gt; b
(1, 2, 3)
</code></pre>
<p>If you need lists, you can use <a href="http://docs.python.org/2/library/functions.html#map">map</a> on that:</p>
<pre><code>&gt;&gt;&gt; a, b = map(list, zip(*y))
&gt;&gt;&gt; a
['ab', 'cd', 'ef']
&gt;&gt;&gt; b
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try this:</p>
<pre><code>def get_list(tuples):
    list1 = []
    list2 = []
    for i in tuples:
        list1.append(i[0])
        list2.append(i[1])
    return list1, list2
y = [('ab',1), ('cd', 2), ('ef', 3) ]
letters, numbers = get_list(y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to do it is first convert the list into a temp dictionary, then assign the keys &amp; values of the temp dictionary into two lists</p>
<pre><code>y = [('ab', 1), ('cd', 2), ('ef', 3)]
temp_d = dict(y)
list1 = temp_d.keys()
list2 = temp_d.values()

print list1
print list2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l1 = []
l2 = []
for i in y:
    l1.append(i[0])
    l2.append(i[1])
</code></pre>
<p>l1
    ['ab', 'cd', 'ef']
l2
    [1, 2, 3]</p>
<p>Appending each value into another</p>
</div>
<span class="comment-copy">I think unpacking it to a,b will cast each one to a list automagically ... eg: <code>a,b=zip(*[(1,2),(3,4)]);print(a);print(b);</code></span>
<span class="comment-copy">@JoranBeasley - No, they will be tuples.</span>
<span class="comment-copy">ahh gotcha  ... missed that caveat</span>
<span class="comment-copy">kudos for the tenacity. built-in <code>zip</code> will probably be faster though</span>
<span class="comment-copy">Note that this will only work in Python 2.x.  In Python 3.x, <code>dict.keys</code> and <code>dict.values</code> return <a href="http://docs.python.org/3/glossary.html#view" rel="nofollow noreferrer">view objects</a>.</span>
<span class="comment-copy">Didn't know that.  How would you modify the code using this technique?</span>
<span class="comment-copy">You need to explicitly convert the view objects into lists.  In other words, you would do this <code>list1 = list(temp_d)</code> and then this <code>list2 = list(temp_d.values())</code>.  Notice too that I removed the call to <code>dict.keys</code> in the first example.  It is no longer needed since iterating over a dictionary yields its keys.  Finally, you only need to do this if you are using Python 3.x.  In Python 2.x, your current code would work fine because <code>dict.keys</code> and <code>dict.values</code> return lists.</span>
