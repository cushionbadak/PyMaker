<div class="post-text" itemprop="text">
<p>I'm trying to do some of the <a href="http://en.wikipedia.org/wiki/Code_golf" rel="noreferrer">code golf</a> challenges, but they all require the input to be taken from <code>stdin</code>. How do I get that in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="http://docs.python.org/library/fileinput.html" rel="noreferrer"><code>fileinput</code></a> module:</p>
<pre><code>import fileinput

for line in fileinput.input():
    pass
</code></pre>
<p><a href="http://docs.python.org/library/fileinput.html" rel="noreferrer"><code>fileinput</code></a> will loop through all the lines in the input specified as file names given in command-line arguments, or the standard input if no arguments are provided.</p>
<p>Note: <code>line</code> will contain a trailing newline; to remove it use <code>line.rstrip()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There's a few ways to do it.</p>
<ul>
<li><p><a href="http://docs.python.org/library/sys.html#sys.stdin" rel="noreferrer"><code>sys.stdin</code></a> is a file-like object on which you can call functions <code>read</code> or <code>readlines</code> if you want to read everything or you want to read everything and split it by newline automatically. (You need to <code>import sys</code> for this to work.)</p></li>
<li><p>If you want to <em>prompt</em> the user for input, you can use <a href="https://docs.python.org/2.7/library/functions.html?highlight=raw_input#raw_input" rel="noreferrer"><code>raw_input</code></a> in Python 2.X, and just <a href="https://docs.python.org/3/library/functions.html#input" rel="noreferrer"><code>input</code></a> in Python 3.  </p></li>
<li><p>If you actually just want to read command-line options, you can access them via the <a href="http://docs.python.org/library/sys.html#sys.argv" rel="noreferrer">sys.argv</a> list.</p></li>
</ul>
<p>You will probably find <a href="http://en.wikibooks.org/wiki/Python_Programming/Input_and_output" rel="noreferrer">this Wikibook article on I/O in Python</a> to be a useful reference as well.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys

for line in sys.stdin:
    print line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python also has built-in functions <code>input()</code> and <code>raw_input()</code>. See the Python documentation under <a href="http://docs.python.org/library/functions.html" rel="noreferrer">Built-in Functions</a>.</p>
<p>For example,</p>
<pre><code>name = raw_input("Enter your name: ")   # Python 2.x
</code></pre>
<p>or</p>
<pre><code>name = input("Enter your name: ")   # Python 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's from <a href="http://web.archive.org/web/20140928083217/http://oreilly.com/catalog/lpython/chapter/ch09.html#16308" rel="noreferrer">Learning Python</a>:</p>
<pre><code>import sys
data = sys.stdin.readlines()
print "Counted", len(data), "lines."
</code></pre>
<hr/>
<p>On Unix, you could test it by doing something like:</p>
<pre><code>% cat countlines.py | python countlines.py 
Counted 3 lines.
</code></pre>
<p>On Windows or DOS, you'd do:</p>
<pre><code>C:\&gt; type countlines.py | python countlines.py 
Counted 3 lines.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer proposed by others:</p>
<pre><code>for line in sys.stdin:
  print line
</code></pre>
<p>is very simple and pythonic, but it must be noted that the script will wait until EOF before starting to iterate on the lines of input.</p>
<p>This means that <code>tail -f error_log | myscript.py</code> will not process lines as expected.</p>
<p>The correct script for such a use case would be:</p>
<pre><code>while 1:
    try:
        line = sys.stdin.readline()
    except KeyboardInterrupt:
        break

    if not line:
        break

    print line
</code></pre>
<p><strong>UPDATE</strong><br/>
From the comments it has been cleared that on python 2 only there might be buffering involved, so that you end up waiting for the buffer to fill or EOF before the print call is issued.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>How do you read from stdin in Python?</h2>
<p>I'm trying to do some of the code golf challenges, but they all require the input to be taken from stdin. How do I get that in Python?</p>
</blockquote>
<p>You can use:</p>
<ul>
<li><a href="https://docs.python.org/3/library/sys.html#sys.stdin" rel="noreferrer"><code>sys.stdin</code></a> - A file-like object - call <code>sys.stdin.read()</code> to read everything.</li>
<li><a href="https://docs.python.org/3/library/functions.html#input" rel="noreferrer"><code>input(prompt)</code></a> - pass it an optional prompt to output, it reads from stdin up to the first newline, which it strips. You'd have to do this repeatedly to get more lines, at the end of the input it raises EOFError. (Probably not great for golfing.) In Python 2, this is <code>rawinput(prompt)</code>.</li>
<li><a href="https://docs.python.org/3/library/functions.html#open" rel="noreferrer"><code>open(0).read()</code></a> - In Python 3 <code>open</code> accepts <a href="https://en.wikipedia.org/wiki/File_descriptor" rel="noreferrer">file descriptors</a> (integers representing operating system IO resources), and 0 is the descriptor of <code>stdin</code>. It returns a file-like object like <code>sys.stdin</code> - probably your best bet for golfing.</li>
<li><code>open('/dev/stdin').read()</code> - similar to <code>open(0)</code>, works on Python 2 and 3, but not on Windows (or even Cygwin).</li>
<li><a href="https://docs.python.org/2/library/fileinput.html#fileinput.input" rel="noreferrer"><code>fileinput.input()</code></a> - returns an iterator over lines in all files listed in <code>sys.argv[1:]</code>, or stdin if not given. Use like <code>''.join(fileinput.input())</code>.</li>
</ul>
<p>Both <code>sys</code> and <code>fileinput</code> must be imported, respectively, of course.</p>
<h3>Quick <code>sys.stdin</code> examples compatible with Python 2 and 3, Windows, Unix</h3>
<p>You just need to <code>read</code> from <code>sys.stdin</code>, for example, if you pipe data to stdin:</p>
<pre><code>$ echo foo | python -c "import sys; print(sys.stdin.read())"
foo
</code></pre>
<h3>file example</h3>
<p>Say you have a file, <code>inputs.txt</code>, we can accept that file and write it back out: </p>
<pre><code>python -c "import sys; sys.stdout.write(sys.stdin.read())" &lt; inputs.txt
</code></pre>
<h2>Longer answer</h2>
<p>Here's a complete, easily replicable demo, using two methods, the builtin function, <code>input</code> (use <code>raw_input</code> in Python 2), and <code>sys.stdin</code>. The data is unmodified, so the processing is a non-operation.</p>
<p>To begin with, let's create a file for inputs:</p>
<pre><code>$ python -c "print('foo\nbar\nbaz')" &gt; inputs.txt
</code></pre>
<p>And using the code we've already seen, we can check that we've created the file:</p>
<pre><code>$ python -c "import sys; sys.stdout.write(sys.stdin.read())" &lt; inputs.txt 
foo
bar
baz
</code></pre>
<p>Here's the help on <code>sys.stdin.read</code> from Python 3:</p>
<pre><code>read(size=-1, /) method of _io.TextIOWrapper instance
    Read at most n characters from stream.

    Read from underlying buffer until we have n characters or we hit EOF.
    If n is negative or omitted, read until EOF.
</code></pre>
<h3>Builtin function, <code>input</code> (<code>raw_input</code> in Python 2)</h3>
<p>The builtin function <code>input</code> reads from standard input up to a newline, which is stripped (complementing <code>print</code>, which adds a newline by default.) This occurs until it gets EOF (End Of File), at which point it raises <code>EOFError</code>.</p>
<p>Thus, here's how you can use <code>input</code> in Python 3 (or <code>raw_input</code> in Python 2) to read from stdin - so we create a Python module we call stdindemo.py:</p>
<pre><code>$ python -c "print('try:\n    while True:\n        print(input())\nexcept EOFError:\n    pass')" &gt; stdindemo.py 
</code></pre>
<p>And let's print it back out to ensure it's as we expect:</p>
<pre><code>$ python -c "import sys; sys.stdout.write(sys.stdin.read())" &lt; stdindemo.py 
try:
    while True:
        print(input())
except EOFError:
    pass
</code></pre>
<p>Again, <code>input</code> reads up until the newline and essentially strips it from the line. <code>print</code> adds a newline. So while they both modify the input, their modifications cancel. (So they are essentially each other's complement.)</p>
<p>And when <code>input</code> gets the end-of-file character, it raises EOFError, which we ignore and then exit from the program.</p>
<p>And on Linux/Unix, we can pipe from cat:</p>
<pre><code>$ cat inputs.txt | python -m stdindemo
foo
bar
baz
</code></pre>
<p>Or we can just redirect the file from stdin:</p>
<pre><code>$ python -m stdindemo &lt; inputs.txt 
foo
bar
baz
</code></pre>
<p>We can also execute the module as a script:</p>
<pre><code>$ python stdindemo.py &lt; inputs.txt 
foo
bar
baz
</code></pre>
<p>Here's the help on the builtin <code>input</code> from Python 3:</p>
<pre><code>input(prompt=None, /)
    Read a string from standard input.  The trailing newline is stripped.

    The prompt string, if given, is printed to standard output without a
    trailing newline before reading input.

    If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.
    On *nix systems, readline is used if available.
</code></pre>
<h2><code>sys.stdin</code></h2>
<p>Here we make a demo script using <code>sys.stdin</code>. The efficient way to iterate over a file-like object is to use the file-like object as an iterator. The complementary method to write to stdout from this input is to simply use <code>sys.stdout.write</code>:</p>
<pre><code>$ python -c "print('import sys\nfor line in sys.stdin:\n    sys.stdout.write(line)')" &gt; stdindemo2.py
</code></pre>
<p>Print it back out to make sure it looks right:</p>
<pre><code>$ python -c "import sys; sys.stdout.write(sys.stdin.read())" &lt; stdindemo2.py 
import sys
for line in sys.stdin:
    sys.stdout.write(line)
</code></pre>
<p>And redirecting the inputs into the file:</p>
<pre><code>$ python -m stdindemo2 &lt; inputs.txt
foo
bar
baz
</code></pre>
<p>Golfed into a command:</p>
<pre><code>$ python -c "import sys; sys.stdout.write(sys.stdin.read())" &lt; inputs.txt
foo
bar
baz
</code></pre>
<h2>File Descriptors for Golfing</h2>
<p>Since the file descriptors for <code>stdin</code> and <code>stdout</code> are 0 and 1 respectively, we can also pass those to <code>open</code> in Python 3 (not 2, and note that we still need the 'w' for writing to stdout).</p>
<p>If this works on your system, it will shave off more characters. </p>
<pre><code>$ python -c "open(1,'w').write(open(0).read())" &lt; inputs.txt
baz
bar
foo
</code></pre>
<p>Python 2's <code>io.open</code> does this as well, but the import takes a lot more space:</p>
<pre><code>$ python -c "from io import open; open(1,'w').write(open(0).read())" &lt; inputs.txt 
foo
bar
baz
</code></pre>
<h3>Addressing other comments and answers</h3>
<p>One comment suggests <code>''.join(sys.stdin)</code> but that's actually longer than sys.stdin.read() - plus Python must create an extra list in memory (that's how <code>str.join</code> works when not given a list) - for contrast:</p>
<pre><code>''.join(sys.stdin)
sys.stdin.read()
</code></pre>
<p>The top answer suggests:</p>
<pre><code>import fileinput

for line in fileinput.input():
    pass
</code></pre>
<p>But, since <code>sys.stdin</code> implements the file API, including the iterator protocol, that's just the same as this:</p>
<pre><code>import sys

for line in sys.stdin:
    pass
</code></pre>
<p>Another answer <em>does</em> suggest this. Just remember that if you do it in an interpreter, you'll need to do <kbd>Ctrl</kbd>-<kbd>d</kbd> if you're on Linux or Mac, or <kbd>Ctrl</kbd>-<kbd>z</kbd> on Windows (after <kbd>Enter</kbd>) to send the end-of-file character to the process. Also, that answer suggests <code>print(line)</code> - which adds a <code>'\n'</code> to the end - use <code>print(line, end='')</code> instead (if in Python 2, you'll need <code>from __future__ import print_function</code>). </p>
<p>The real use-case for <code>fileinput</code> is for reading in a series of files.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will echo standard input to standard output:</p>
<pre><code>import sys
line = sys.stdin.readline()
while line:
    print line,
    line = sys.stdin.readline()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Building on all the anwers using <code>sys.stdin</code>, you can also do something like the following to read from an argument file if at least one argument exists, and fall back to stdin otherwise:</p>
<pre><code>import sys
f = open(sys.argv[1]) if len(sys.argv) &gt; 1 else sys.stdin    
for line in f:
#     Do your stuff
</code></pre>
<p>and use it as either</p>
<pre><code>$ python do-my-stuff.py infile.txt
</code></pre>
<p>or</p>
<pre><code>$ cat infile.txt | python do-my-stuff.py
</code></pre>
<p>or even</p>
<pre><code>$ python do-my-stuff.py &lt; infile.txt
</code></pre>
<p>That would make your Python script behave like many GNU/Unix programs such as <code>cat</code>, <code>grep</code> and <code>sed</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following chip of code will help you (it will read all of stdin blocking unto <code>EOF</code>, into one string):</p>
<pre><code>import sys
input_str = sys.stdin.read()
print input_str.split()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2><a href="https://docs.python.org/3/library/argparse.html?highlight=stdin#filetype-objects" rel="noreferrer"><code>argparse</code></a> is an easy solution</h2>
<p>Example compatible with both Python versions 2 and 3:</p>
<pre><code>#!/usr/bin/python

import argparse
import sys

parser = argparse.ArgumentParser()

parser.add_argument('infile',
                    default=sys.stdin,
                    type=argparse.FileType('r'),
                    nargs='?')

args = parser.parse_args()

data = args.infile.read()
</code></pre>
<p>You can run this script in many ways:</p>
<p><strong>1. Using <code>stdin</code></strong></p>
<pre><code>echo 'foo bar' | ./above-script.py
</code></pre>
<p>  or shorter by replacing <code>echo</code> by <a href="https://stackoverflow.com/q/25797252/938111">here</a> <a href="https://unix.stackexchange.com/a/80368/13999">string</a>:</p>
<pre><code>./above-script.py &lt;&lt;&lt; 'foo bar'
</code></pre>
<p><strong>2. Using a filename argument</strong></p>
<pre><code>echo 'foo bar' &gt; my-file.data
./above-script.py my-file.data
</code></pre>
<p><strong>3. Using <code>stdin</code> through the special filename <code>-</code></strong></p>
<pre><code>echo 'foo bar' | ./above-script.py -
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>import sys

print sys.stdin.read().upper()
</code></pre>
<p>and check it with:</p>
<pre><code>$ echo "Hello World" | python myFile.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can read from stdin and then store inputs into <strong>"data"</strong> as follows:</p>
<pre><code>data = ""
for line in sys.stdin:
    data += line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am pretty amazed no one had mentioned this hack so far:</p>
<pre><code>python -c "import sys;print (''.join([l for l in sys.stdin.readlines()]))"
</code></pre>
<p>compatible with both python2 and python3</p>
</div>
<div class="post-text" itemprop="text">
<p>Read from <code>sys.stdin</code>, but to <strong>read binary data on Windows</strong>, you need to be extra careful, because <code>sys.stdin</code> there is opened in text mode and it will corrupt <code>\r\n</code> replacing them with <code>\n</code>.</p>
<p>The solution is to set mode to binary if Windows + Python 2 is detected, and on Python 3 use <code>sys.stdin.buffer</code>.</p>
<pre><code>import sys

PY3K = sys.version_info &gt;= (3, 0)

if PY3K:
    source = sys.stdin.buffer
else:
    # Python 2 on Windows opens sys.stdin in text mode, and
    # binary data that read from it becomes corrupted on \r\n
    if sys.platform == "win32":
        # set sys.stdin to binary mode
        import os, msvcrt
        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    source = sys.stdin

b = source.read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem I have with solution</p>
<pre><code>import sys

for line in sys.stdin:
    print(line)
</code></pre>
<p>is that if you don't pass any data to stdin, it will block forever. That's why I love <a href="https://stackoverflow.com/a/3763257/909579">this answer</a>: check if there is some data on stdin first, and then read it. This is what I ended up doing:</p>
<pre><code>import sys
import select

# select(files to read from, files to write to, magic, timeout)
# timeout=0.0 is essential b/c we want to know the asnwer right away
if select.select([sys.stdin], [], [], 0.0)[0]:
    help_file_fragment = sys.stdin.read()
else:
    print("No data passed to stdin", file=sys.stderr)
    sys.exit(2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had some issues when getting this to work for reading over sockets piped to it. When the socket got closed it started returning empty string in an active loop. So this is my solution to it (which I only tested in linux, but hope it works in all other systems)</p>
<pre><code>import sys, os
sep=os.linesep

while sep == os.linesep:
    data = sys.stdin.readline()               
    sep = data[-len(os.linesep):]
    print '&gt; "%s"' % data.strip()
</code></pre>
<p>So if you start listening on a socket it will work properly (e.g. in bash):</p>
<pre><code>while :; do nc -l 12345 | python test.py ; done
</code></pre>
<p>And you can call it with telnet or just point a browser to localhost:12345</p>
</div>
<div class="post-text" itemprop="text">
<p>Regarding this:</p>
<p><code>for line in sys.stdin:</code></p>
<p>I just tried it on python 2.7 (following someone else's suggestion) for a very large file, and I don't recommend it, precisely for the reasons mentioned above (nothing happens for a long time). </p>
<p>I ended up with a slightly more pythonic solution (and it works on bigger files):</p>
<pre><code>with open(sys.argv[1], 'r') as f:
    for line in f:
</code></pre>
<p>Then I can run the script locally as:</p>
<pre><code>python myscript.py "0 1 2 3 4..." # can be a multi-line string or filename - any std.in input will work
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>n = int(raw_input())
for i in xrange(n):
    name, number = raw_input().split()
</code></pre>
</div>
<span class="comment-copy">Note that this will include a newline character at the end</span>
<span class="comment-copy">To remove the newline at the end, use <code>line.rstrip()</code></span>
<span class="comment-copy">I suggest adding an explanation to this, comment-only answers aren't very useful, but thank you for the example.</span>
<span class="comment-copy">line.rstrip('\n'), otherwise it will drop all the whitespaces</span>
<span class="comment-copy">using this method, how do we know when the input stream ends? I want to add comma after every line <i>excepts</i> for the last line.</span>
<span class="comment-copy">This reads a single line, which isn't really what the OP asked about. I interpret the question as "how do I read a bunch of lines from an open file handle until EOF?"</span>
<span class="comment-copy">The OP isn't asking to read input from a keyboard, He is asking to read from stdin which in a contest situation is usually provided to the contestants.</span>
<span class="comment-copy">Here's a more memory efficient (and maybe faster) way to count lines in Python: <code>print(sum(chunk.count('\n') for chunk in iter(partial(sys.stdin.read, 1 &lt;&lt; 15), '')))</code>. <a href="http://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python#comment11966378_9371238">see <code>wc-l.py</code></a></span>
<span class="comment-copy">The use of <code>cat</code> here is redundant. The correct invocation for Unix systems is <code>python countlines.py &lt; countlines.py</code>.</span>
<span class="comment-copy">"Learning Python" is wrong in directing users to use <code>readlines()</code>. File objects are intended to be iterated over without materializing all of the data in memory.</span>
<span class="comment-copy">The <code>for line in sys.stdin:</code> pattern <b>does not</b> wait for EOF.  But if you test on very small files, responses may get buffered.  Test with more data to see that it reads intermediate results.</span>
<span class="comment-copy">I get wait for End Of File or buffering, when taking input from a stream when using python 2.6.6, but with 3.1.3 I don't. Note <code>print line</code> does not woke in 3.1.3, but <code>print(line)</code> does.</span>
<span class="comment-copy">my python 2.7.5 "for line in sys.stdin", blocks till EOF or some reasonable amount of data has buffered. Fine for stream processing. Not fine for line by line processing or user input.</span>
<span class="comment-copy">I suspect this is related to detection of tty in libc, so when you pipe it detects on a interactive shell it  detects none tty, unbuffer from expect-dev is a handy util that I believe injects a shim via ld_preload so is_atty returns true (I suspect that's how it is handing it)</span>
<span class="comment-copy">@Sean: <b>wrong</b>. <code>for line in sys.stdin:</code> does not "block till EOF". There is a <a href="https://bugs.python.org/issue3907" rel="nofollow noreferrer">read-ahead bug in Python 2</a> that delays the lines until the corresponding buffer is full. It is a buffering issue that is unrelated to EOF. To workaround, use <code>for line in iter(sys.stdin.readline, ''):</code> (use <code>io.open()</code> for ordinary files). You don't need it in Python 3.</span>
<span class="comment-copy">Here is an answer on what to do, if the input file is compressed: <a href="https://stackoverflow.com/a/33621549/778533">stackoverflow.com/a/33621549/778533</a> One can also do <code>add_argument('--in'</code> and then pipe to the script and add <code>--in -</code> to the command line. P.S. <code>in</code> is not a very good name for a variable/attribute.</span>
<span class="comment-copy"><code>in</code> isn't just a bad name for a variable, it is illegal. <code>args.in.read()</code> will raise InvalidSyntax error because of the <code>in</code> reserved keyword. Can simply rename to <code>infile</code> like the python argparse docs do: <a href="https://docs.python.org/3/library/argparse.html?highlight=stdin#filetype-objects" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">Thank you @tommy.carstensen for your feedback, I have just improved the answer. Merry Christmas and Happy New Year ;-)</span>
<span class="comment-copy"><a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="nofollow noreferrer">"do not rely on CPython's efficient implementation of in-place string concatenation for statements in the form a += b or a = a + b . This optimization is fragile even in CPython"</a></span>
<span class="comment-copy">The same thing can be done with <code>data = sys.stdin.read()</code>, without the problem of repeated string concatenations.</span>
<span class="comment-copy">Why use <code>readlines</code> that split into lines and then <code>join</code> again? You can just write <code>print(sys.stdin.read())</code></span>
<span class="comment-copy">I'd seriously recommend hiding this hideous if condition into a method though.</span>
<span class="comment-copy">This method limits the applicability of the program seriously: for example, you cannot use this for interactive input from the terminal, because the input will almost never be "ready" when <code>select</code> is called; or you could also face problems if stdin is connected to a file on a slow medium (network, CD, tape, etc.). You said that "if you don't pass any data to stdin, it will block forever." is a <i>problem</i>, but I would say it's a <i>feature</i>. Most CLI programs (e.g. <code>cat</code>) work this way, and they are expected to. EOF is the only thing you should depend on to detect the end of the input.</span>
<span class="comment-copy">Opening a file is not reading from stdin, like the question asks. -1</span>
<span class="comment-copy">In this case I am passing in <code>sys.stdin</code> as a command-line argument to the script.</span>
<span class="comment-copy">How could you pass <code>sys.stdin</code> as a command-line argument to the script? Arguments are strings and streams are file-like objects, they are not the same.</span>
<span class="comment-copy">@DeFazer edited to show how to use it. Arguments are strings, yes, but as the python docs and I mentioned in an earlier comment above, <code>sys.stdin</code> is a file-like object</span>
