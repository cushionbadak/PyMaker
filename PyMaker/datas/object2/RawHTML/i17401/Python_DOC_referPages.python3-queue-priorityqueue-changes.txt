<div class="post-text" itemprop="text">
<p>I am in the process of "porting" an application of mine from py27 to py33.
For the most part it is quite trivial. That said I have a very odd difference between py27 &amp; py33</p>
<p>I basically have two threads and they communicate via queues. 
The type of data being sent is such: </p>
<p>TX_Queue.put( (3,'SOME_TAG',{some:type,of:data} )</p>
<p>ie, priority, command, data</p>
<p>This works perfectly fine in py27, but now that most of the conversion to py33 is complete I am getting an odd exception every now and again:</p>
<pre><code>return heappop(self.queue)
TypeError: unorderable types: dict() &lt; dict()
</code></pre>
<p>Any idea's what this is or what changed between py27 and py3 with respect to PriorityQueues?</p>
</div>
<div class="post-text" itemprop="text">
<p>Nothing has changed related to <code>PriorityQueue</code>s; what's changed is related to <code>dict</code>, and more generally to sorting objects that have no natural ordering.</p>
<p>The problem is that you're trying to sort two tuples that contain dicts, like this:</p>
<pre><code>(3, 'SOME_TAG', {'some': 'type', 'of': 'data'})
</code></pre>
<p>Tuples compare lexicographically—that is, they first compare the first element, and if those are equal they then try the second element, and if those are equal they then try the third, and so on.</p>
<p>Most of the time, the first or second element will differ, so you won't ever need to compare the third elements, so everything will be fine.</p>
<p>But occasionally, you'll get two values like this:</p>
<pre><code>(3, 'SOME_TAG', {'some': 'type', 'of': 'data'})
(3, 'SOME_TAG', {'some': 'othertype', 'with': 'differentdata'})
</code></pre>
<p>And then, it will need to compare the two dicts to decide which tuple is less.</p>
<p>This is a meaningless thing to do. Dictionaries' items are inherently unordered, so how can you decide which one is less than the other one? In fact, even if there <em>were</em> a fixed and predictable element to the items, what would be the rule you'd expect here? Is the first one less because <code>'of' &lt; 'with'</code>? Or greater because <code>'other type' &lt; 'type'</code>? Or…?</p>
<p>Python 2.x just does something arbitrary and useless; Python 3.x instead raises an exception. This is documented under <a href="http://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="noreferrer">Ordering Comparisons</a> in the "What's New in 3.x" docs:</p>
<blockquote>
<p>The ordering comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>) raise a <code>TypeError</code> exception when the operands don’t have a meaningful natural ordering. </p>
</blockquote>
<p>So, you already had a problem in these cases, but Python 2.x hid the problem by occasionally silently doing something useless, while 3.x makes the problem obvious.</p>
<hr/>
<p>So, what's the solution? Well, what do you <em>want</em> to happen? My guess is that you actually want to sort the first element, ignoring the other elements. In that case, you were getting something <em>close to</em> that automatically in Python 2.x, and you probably didn't notice that sometimes it was unstable in unpredictable ways. But if you actually want that behavior, in both versions, you have to write it yourself.</p>
<p>Unfortunately, unlike most sort-related functions and objects in Python, <code>PriorityQueue</code> doesn't take a <code>key</code> function.* This means you have to "decorate-sort-undecorate" manually. But that isn't too hard. For example:</p>
<pre><code>class TupleSortingOn0(tuple):
    def __lt__(self, rhs):
        return self[0] &lt; rhs[0]
    def __gt__(self, rhs):
        return self[0] &gt; rhs[0]
    def __le__(self, rhs):
        return self[0] &lt;= rhs[0]
    def __ge__(self, rhs):
        return self[0] &gt;= rhs[0]
</code></pre>
<p>Then you can do this:</p>
<pre><code>TX_Queue.put(TupleSortingOn0(3,'SOME_TAG',{some:type,of:data}))
</code></pre>
<hr/>
<p>* Because it uses <a href="http://docs.python.org/2/library/heapq.html" rel="noreferrer"><code>heapq</code></a> under the covers, and <code>heapq</code> doesn't handle keys because the design of "functions that work on a normal list" precludes it…</p>
</div>
<span class="comment-copy">That explained where the change occurred thankyou. The "old method" was fine even though your point about it being broken is valid. Essentially I was using a PriorityQueue to ensure certain signals jumped the other commands (usually 'STOP'), the order of the rest wasn't important AS long as they were in the queue. I have actually just tried: (3, time.time(), 'SOME_TAG', {'some': 'type', 'of': 'data'})  in an attempt to provide something increasing it could sort against. This also failed (I may have missed one .put() though). I will try your sort approach.</span>
<span class="comment-copy">This solved my python2-python3 priority queue upgrade problem as well!   Now that I am enlightened / understand how python2 handled this that arbitrary way, I have a followup question.  Should it be obvious, in this fix/implementation, how TupleSortingOn0 handles the case in which the 0 values are the same/==?  Does the queue then just default-sort to some kind of fifo or other standard sort?  Probably obvious but I don't know- thx</span>
