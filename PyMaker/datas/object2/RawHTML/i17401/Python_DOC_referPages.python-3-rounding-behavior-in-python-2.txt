<div class="post-text" itemprop="text">
<p>In Python 2.x, the built-in <a href="http://docs.python.org/2/library/functions.html#round" rel="noreferrer"><code>round</code></a> has the following behavior:</p>
<blockquote>
<p>if two multiples are equally close, rounding is done <strong>away from 0</strong> (so. for example, round(0.5) is 1.0 and round(-0.5) is -1.0)</p>
</blockquote>
<p>In Python 3.x, <a href="http://docs.python.org/3/library/functions.html#round" rel="noreferrer">this has changed</a> to the more common:</p>
<blockquote>
<p>if two multiples are equally close, rounding is done <strong>toward the even choice</strong> (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2).</p>
</blockquote>
<p>Is there an easy way to get this behavior in Python 2.x? Unfortunately, the <a href="http://docs.python.org/2/library/future_builtins.html" rel="noreferrer"><code>future_builtins</code></a> module doesn't include this. Maybe there's another similar module I haven't found yet? Or, another way to pull Python 3.x functions into Python 2.x?</p>
<p>Obviously, I could write a new function that produces the desired behavior, but I'm more curious if a solution exists that uses the actual Python 3.x function, to avoid adding unnecessary complexity and code to maintain.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless you mind a numpy dependency, <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.around.html" rel="nofollow"><code>numpy.around</code></a> may do the thing:</p>
<pre><code>&gt;&gt;&gt; from numpy import around
&gt;&gt;&gt; around(0.5)
0
&gt;&gt;&gt; around(-0.5)
-0
&gt;&gt;&gt; around(1.5)
2.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 3 round in Python 2</strong></p>
<p>The function can look like this:</p>
<pre><code>def py3round(f):
    if abs(round(f)-f) == 0.5:
        return 2.0*round(f/2.0);
    return round(f)

# Python 3            apply round to ... -.1 -.75 -.5 -.25 0 .25 .5 .75 ...
&gt;&gt;&gt; ' '.join(map(str, map(int, [round(i * 0.25) for i in range(-20, 20)])))
'-5 -5 -4 -4 -4 -4 -4 -3 -3 -3 -2 -2 -2 -2 -2 -1 -1 -1 0 0 0 0 0 1 1 1 2 2 2 2 2 3 3 3 4 4 4 4 4 5'
# Python 2            apply round to ... -.1 -.75 -.5 -.25 0 .25 .5 .75 ...
&gt;&gt;&gt; ' '.join(map(str, map(int, [py3round(i * 0.25) for i in range(-20, 20)])))
'-5 -5 -4 -4 -4 -4 -4 -3 -3 -3 -2 -2 -2 -2 -2 -1 -1 -1 0 0 0 0 0 1 1 1 2 2 2 2 2 3 3 3 4 4 4 4 4 5'
</code></pre>
<p>Let me clarify what round does in <code>bltinmodule.c</code></p>
<pre><code>if hasattr(args[0], '__round__'):
    return args[0].__round__(*args[1:])
else: 
    raise TypeError("type %.100s doesn't define __round__ method")
</code></pre>
<p>So round actually does almost nothing. It depends on the objects passed to it.
That leads to <code>floatobject.c</code> function <code>static PyObject *double_round(double x, int ndigits)</code></p>
<pre><code>z = round(y);
if (fabs(y-z) == 0.5)
    /* halfway between two integers; use round-half-even */
    z = 2.0*round(y/2.0);
</code></pre>
<p>I used the knowledge of these lines in my function above.</p>
<p><strong>Python 2 round in Python 3</strong></p>
<p>I think you need to write a new function. </p>
<pre><code>def python2round(f):
    if round(f + 1) - round(f) != 1:
        return f + abs(f) / f * 0.5
    return round(f)
</code></pre>
<p>The if statement handles the case that <code>i + 0.5</code> and <code>i + 1.5</code> are rounded into different directions = to even numbers and halves. In this case the rounding is done away from zero.</p>
<pre><code># in Python 2          apply round to ... -.1 -.75 -.5 -.25 0 .25 .5 .75 ...
&gt;&gt;&gt; ' '.join(map(str, map(int, [round(i * 0.25) for i in range(-20, 20)])))
'-5 -5 -5 -4 -4 -4 -4 -3 -3 -3 -3 -2 -2 -2 -2 -1 -1 -1 -1 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5'
# in Python 3          apply round to ... -.1 -.75 -.5 -.25 0 .25 .5 .75 ...
&gt;&gt;&gt; ' '.join(map(str, map(int, [python2round(i * 0.25) for i in range(-20, 20)])))
'-5 -5 -5 -4 -4 -4 -4 -3 -3 -3 -3 -2 -2 -2 -2 -1 -1 -1 -1 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5'
</code></pre>
<p>Do you need a solution with the second argument to round, <code>ndigits</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>This response has read the original question, and the answer is "Nope, I can't come up with something that uses the Py3 original code."</p>
<p>But for anyone who is wondering what the code would be that would replicate Py3 behavior in Py2 (including the int vs. float behavior), here's an adaptation of the <code>User</code> code above that includes <code>ndigits</code> and the int vs. float distinction for <code>ndigits = None vs 0</code>.</p>
<pre><code>import sys

def py3round(number, ndigits=None):
    '''
    Simulates Python3 rounding behavior in Python 2

    &gt;&gt;&gt; py3round(2.3)
    2
    &gt;&gt;&gt; py3round(2.7)
    3
    &gt;&gt;&gt; py3round(2.7, 0)
    3.0
    &gt;&gt;&gt; py3round(1.5, 0)
    2.0
    &gt;&gt;&gt; py3round(2.5, 0)
    2.0
    &gt;&gt;&gt; py3round(-1.5)
    -2
    &gt;&gt;&gt; py3round(-2.5)
    -2
    '''
    if sys.version_info[0] &gt;= 3:
        if ndigits is not None:
            return round(number, ndigits)
        else:
            return round(number)        

    intIt = True if ndigits is None else False
    ndigits = ndigits if ndigits is not None else 0

    f = number
    if abs(round(f) - f) == 0.5:
        retAmount = 2.0 * round(f / 2.0, ndigits);
    else:
        retAmount = round(f, ndigits)

    if intIt:
        return int(retAmount)
    else:
        return retAmount
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're super-paranoid about floating point rounding issues, you can look into the <a href="http://docs.python.org/2/library/decimal.html" rel="nofollow">decimal</a> library where you can configure the rounding mode (defaults to ROUND_HALF_EVEN).</p>
<pre><code>&gt;&gt;&gt; import decimal
&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; Decimal(0.5).quantize(Decimal('1'))
Decimal('0')
&gt;&gt;&gt; Decimal(1.5).quantize(Decimal('1'))
Decimal('2')

&gt;&gt;&gt; decimal.getcontext().rounding = decimal.ROUND_HALF_UP
&gt;&gt;&gt; Decimal(0.5).quantize(Decimal('1'))
Decimal('1')
</code></pre>
<p>Otherwise, I think it's more explicit and more maintainable if you just write your own function or use numpy, rather than wish that you could use a py3 function in py2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/2/library/decimal.html#decimal.Decimal.to_integral_value" rel="nofollow noreferrer"><code>decimal.Decimal.to_integral_value</code></a></p>
<p>For example:</p>
<pre><code>float(decimal.Decimal(1.5).to_integral_value(decimal.ROUND_HALF_EVEN))
</code></pre>
<p>The rounding options are documented <a href="https://docs.python.org/2/library/decimal.html#decimal.Context" rel="nofollow noreferrer">here</a>. The two options we are concerned with are:</p>
<pre><code>ROUND_HALF_EVEN (to nearest with ties going to nearest even integer),
ROUND_HALF_UP (to nearest with ties going away from zero),
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def round_to_even(x):
    if x &lt; 0:
        return -round_to_even(-x)
    ipart, fpart = divmod(x, 1)
    ipart = int(ipart)
    fpartx2 = fpart * 2
    if fpartx2 &gt; 1:
        return ipart + 1
    elif fpartx2 == 1:
        return ipart + (ipart &amp; 1)
    else:
        return ipart
</code></pre>
</div>
<span class="comment-copy">I did not realize that 3.x behavior was a thing. I imagine there's an interminably long mailing list thread about that somewhere...</span>
<span class="comment-copy">@AndrewGorcester: almost certainly. The purpose (which may or may not be appropriate in any given situation) is to avoid introducing a bias in any direction. For example imagine a set values with 2 digits after the decimal point (that is to say, they're measured to 1/100 of a unit). If you round away from 0 and the values are all positive with each of the 100 possible fractional parts equally represented then you increase the mean by 1/200. Less than the initial accuracy but systematic and so sometimes quite bad. <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even" rel="nofollow noreferrer">en.wikipedia.org/wiki/Rounding#Round_half_to_even</a></span>
<span class="comment-copy">Yep, see <a href="http://en.wikipedia.org/wiki/IEEE_754-2008#Rounding_rules" rel="nofollow noreferrer">IEEE 754 Rounding Rules</a>.</span>
<span class="comment-copy">Would numpy dependency be an issue?</span>
<span class="comment-copy">@AndrewGorcester: I think I found the beginning of that mailing list thread: <a href="https://mail.python.org/pipermail/python-list/2008-April/509669.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-list/2008-April/509669.html</a></span>
<span class="comment-copy">But we're trying to get the Python 2.x behavior, so that <code>around(-0.5)==-1.0</code> and <code>around(0.5)==1.0</code>.</span>
<span class="comment-copy">@Teepeemm: Nope, other way around (get py3 behavior in py2). This solution works, but isn't ideal.</span>
<span class="comment-copy">+1 This is a great solution if you happen to have numpy lying <code>around</code>.</span>
<span class="comment-copy">@Teepeemm  round(x+10**(-y-1),y) gives 2.x behaviour</span>
<span class="comment-copy">Your code seems to implement the Python 2 rounding in Python 3. I think the questioner wanted the reverse, the Python 3 rounding in Python 2.</span>
<span class="comment-copy">Blkknght is correct, I was looking for the other way around. More importantly, I'm specifically looking for a solution that brings the exact Python 3 behavior into Python 2 without needing to maintain a new function (although it wouldn't be the end of the world).</span>
<span class="comment-copy">Oh sorry.^^ I will have a look into that.. see if something shorter can come out. You will need a new function nevertheless. But once the function meets the specification I do not think you need to maintain it.</span>
<span class="comment-copy">Nice that you dug through the python source to implement the exact same function in python. Short of an answer that pulls in the real CPython function, I like this answer best so far.</span>
<span class="comment-copy">Did you read the question? "Obviously, I could write a new function that produces the desired behavior, but I'm more curious if a solution exists that uses the actual Python 3.x function, to avoid adding unnecessary complexity and LOC to maintain."</span>
