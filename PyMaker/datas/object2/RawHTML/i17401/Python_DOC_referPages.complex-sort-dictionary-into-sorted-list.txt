<div class="post-text" itemprop="text">
<p>I have the following class:</p>
<pre><code>class SalesRecord:
    name = ''
    dollarsSpent = 0
    itemsPurchased = 0
    itemsSold = 0
    position = 0
</code></pre>
<p>I also have a dictionary that is structured with a bunch of these SalesRecords with the SalesRecord.name as the key. How can I sort the values into a sorted list with the following criteria (Assume everything is an integer):</p>
<ol>
<li>Sort by dollarsSpent desc</li>
<li>Then by itemsPurchased - itemsSold desc</li>
<li>Then by itemsPurchased desc</li>
<li>Then by position asc</li>
</ol>
<p>Also, just curious, but what would the overall run-time of such a sort be? Does it need to iterate 4 times in the worst case?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a compound key.</p>
<pre><code>sorted((k, v) for (k, v) in somedict, key=lambda (k, v):
  (-v.dollarsSpent, -(v.itemsPurchased - v.itemsSold),
  -v.itemsPurchased, v.position))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have two options. Both options run in linearithmic time, <code>O(nlog(n))</code>, but you may consider one more readable. You can use a compound sort key:</p>
<pre><code>def sortkey(salesrecord):
    r = salesrecord
    return (
        -r.dollarsSpent,
        -r.itemsPurchased + r.itemsSold,
        -r.itemsPurchased,
        r.position
    )
sorted(salesdict.values(), key=sortkey)
</code></pre>
<p>or sort multiple times, relying on the stability of the sort algorithm:</p>
<pre><code>l = salesdict.values()
l.sort(key=lambda r: r.position)
l.sort(key=lambda r: r.itemsPurchased, reverse=True)
l.sort(key=lambda r: r.itemsPurchased - r.itemsSold, reverse=True)
l.sort(key=lambda r: r.dollarsSpent, reverse=True)
</code></pre>
<p>With a <a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Stability" rel="nofollow">stable sort</a>, you can sort by a number of keys with different priorities by sorting by each key from lowest priority to highest. After sorting by a higher-priority key, items that compare equal by that key are guaranteed to remain in the order they had after the lower-priority key sorts.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest approach is to take advantage of <a href="http://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts" rel="nofollow">sort stability</a> to sort in multiple stages (first by position, then by items purchased descending, etc).</p>
<p>This is less expensive than it seems because the <a href="http://en.wikipedia.org/wiki/Timsort" rel="nofollow">TimSort algorithm</a> takes advantage the elements that are already partially ordered.  </p>
<p>This approach is also easier to get right than trying to build an overly complex <a href="http://docs.python.org/3/glossary.html#term-key-function" rel="nofollow">key-function</a>.</p>
</div>
<span class="comment-copy">Can you show the structure of your dictionary?</span>
<span class="comment-copy">It is just a simple dictionary structure. Ex:    <code>sales['Johnson1'] = the SalesRecord object where SalesRecord.name = 'Johnson1'</code></span>
<span class="comment-copy">What is the benefit of doing it this way versus option 1 as presented by user2357112?</span>
<span class="comment-copy">It doesn't add another name to the scope. Which isn't that big a deal either way.</span>
<span class="comment-copy">Would both options still sort in timsorts worst case time of O(nlog(n))?</span>
<span class="comment-copy">@Gyrien: Yes. One might have a worse constant factor, but it probably won't matter.</span>
<span class="comment-copy">Thanks! Also, why do you sort by r.position first in the second case?</span>
<span class="comment-copy">@Gyrien: After sorting by <code>itemsPurchased</code>, any records with the same number of purchased items will be in the order they were in after the sort by <code>position</code>, so the list will be ordered by purchased items, then position. This principle applies to the next two sorts, too.</span>
