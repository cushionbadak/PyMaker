<div class="post-text" itemprop="text">
<p>I have a class like this:</p>
<pre><code>class Foo(object):
    def __init__(self):
        self.bar = property(self.get_bar)

    def get_bar(self):
        return "bar"

print Foo().bar  #this prints &lt;property object at 0x0051CB40&gt;
</code></pre>
<p>I've seen <a href="https://stackoverflow.com/questions/6193556/how-do-python-properties-work">How do Python properties work?</a>, <a href="https://stackoverflow.com/questions/3941919/how-to-set-a-python-property-in-init?rq=1">How to set a python property in __init__</a>, but they all use the decorator method, which i don't because i want a different name. And I need access to <code>self</code></p>
<p>How do i get the property to behave?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to make a minor change:</p>
<pre><code>class Foo(object):

    def get_bar(self):
        return "bar"

    bar = property(get_bar)

print Foo().bar # prints bar
</code></pre>
<p>The property needs to be an attribute of the class, not the instance; that's how the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a> protocol works.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it like this</p>
<pre><code>class Foo(object):
    def __init__(self):
        self.__bar = None

    def get_bar(self):
        return self.__bar

    def set_bar(self, value):
        self.__bar = value

    bar = property(get_bar, set_bar)

foo = Foo()
print foo.bar    # None
foo.bar = 1
print foo.bar    # 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also do it like shown <a href="https://www.programiz.com/python-programming/property" rel="nofollow noreferrer">here</a>:</p>
<pre><code>class Foo(object):
    def __init__(self):
        self._bar = None

    @property
    def bar(self):
        return self._bar

    @bar.setter
    def bar(self, value):
        self._bar = value

    @bar.deleter
    def bar(self):
        self._bar = None # for instance
</code></pre>
<p>which is equivalent to:</p>
<pre><code>class Also_Foo(object):
    def __init__(self):
        self._bar = None

    def get_bar(self):
        return self._bar

    def set_bar(self, value):
        self._bar = value

    def del_bar(self):
        self._bar = None # for instance

    bar = property(fget=get_bar, fset=set_bar, fdel=del_bar, doc=None)
</code></pre>
<p><strong>BUT</strong> without polluting the class namespace with <code>get</code> and <code>set</code> methods for each attribute.</p>
<p>You retain external direct access to the variable by using <code>._bar</code> instead of <code>.bar</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The object is not instantiated.</p>
<pre><code>class Foo(object):

def get_bar(self):
    return "bar"

bar = Foo()
print(bar.get_bar)
</code></pre>
</div>
<span class="comment-copy">Why would you like to use different name? Is there a reasonable reason?</span>
<span class="comment-copy">Have you tried using property as a decorator or with a docstring?</span>
<span class="comment-copy">A quick solution will be to call <code>__get__</code> on <code>bar</code> explicitly: <code>f = Foo();f.bar.__get__(f, type(f))</code></span>
<span class="comment-copy">(since this is the first web hit I found for my problem:) One other reason a property object can be returned instead of the property (even if the correct way of writing the property is used) is if the class is not instantiated into an object:  print(Foo.bar) instead of print(Foo().bar)</span>
<span class="comment-copy">@MichaelScottCuthbert I think you should add this as an alternative answer, despite not being directly related with the question. I had this problem and your comment saved me! Thank you!</span>
<span class="comment-copy">get_bar is not defined. Idk what i am doing wrong</span>
<span class="comment-copy">I was defining the property before the function. All okay now.</span>
<span class="comment-copy">@gcq Now, try and set the value of <code>bar</code>.</span>
<span class="comment-copy">Why does the output of property work differently if it's <code>bar = property()</code> at the top level vs. <code>self.bar = property()</code> within <code>__init__</code>?</span>
<span class="comment-copy">@EL_DON because the property needs to be an attribute of the <i>class</i>, not the <i>instance</i>; that's how the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a> protocol works.</span>
