<div class="post-text" itemprop="text">
<p><strong>Note: this is not a question - I solved it and posted it here, trying to share what I learned.</strong></p>
<p>I encountered a problem in using numpy last night, and here is how I simplified it to a short code. At first it looks like a bug to me, but just when I try to write this problem I realized that it was my own mistake. Hope someone else later who also comes to this issue can be benefited from it!</p>
<p>This is repeatable on my Win 7 x64, with WinSDK 7.1's C compiler. Python version is 3.3.3, built with MSC v.1600. Numpy version is 1.8.0.</p>
<p>0) Brief summary: when I pass an ndarray to my dll compiled from c code, the c code sees a different array than the one I passed in.</p>
<p>1) Write a c code:</p>
<pre><code>// testdll.c
#include &lt;stdlib.h&gt;

__declspec(dllexport) void copy_ndarray(double *array1, double *array2, size_t array_length);

void copy_ndarray(double *array1, double *array2, size_t array_length)
{
    size_t i;
    for(i=0; i&lt;array_length; i++)
        array2[i] = array1[i];
    return;
}
</code></pre>
<p>2) Write a python code:</p>
<pre><code>import numpy as np
import ctypes


# wrap the function from dll to python
lib = ctypes.cdll.LoadLibrary('./testdll.dll')
fun = lib.copy_ndarray
fun.restype = None
fun.argtypes = [np.ctypeslib.ndpointer(ctypes.c_double), np.ctypeslib.ndpointer(ctypes.c_double), ctypes.c_size_t]
# Initialize array1 and array2
array_length= 10
temp = np.c_[100.*np.ones(array_length), 200.*np.ones(array_length)]
array1 = temp[:, 1]
array2 = np.zeros(array_length)
fun(array1, array2, array_length)
</code></pre>
<p>3) Run the code. See how array1 and array2 are different.</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course it should be different!</p>
<p>When I used <code>array1 = temp[:, 1]</code>, the array1 is not a real size (10,) ndarray. It is a view of the <code>temp</code>, which is size(10, 2). Think about how it is stored in the memory - when the pointer go to another <code>sizeof(double)</code> in c, it will encounter the next element in <code>temp</code>, not in array1.</p>
<p>The way to fix it is - do not use ndarray view when reading your data! Use this line</p>
<pre><code>array1 = temp[:, 1].copy()
</code></pre>
<p>to make a copy, instead of simply using the view.</p>
<p>The correct python code is:</p>
<pre><code>import numpy as np
import ctypes


# wrap the function from dll to python
lib = ctypes.cdll.LoadLibrary('./testdll.dll')
fun = lib.copy_ndarray
fun.restype = None
fun.argtypes = [np.ctypeslib.ndpointer(ctypes.c_double), np.ctypeslib.ndpointer(ctypes.c_double), ctypes.c_size_t]
# Initialize array1 and array2
array_length= 10
temp = np.c_[100.*np.ones(array_length), 200.*np.ones(array_length)]
array1 = temp[:, 1].copy()
array2 = np.zeros(array_length)
fun(array1, array2, array_length)
</code></pre>
<p>I personally find this tricky, because as a data analyzer (honestly I'm not... I'm a researcher, but close enough!), 99% of the times a view is better than the copy, because it is faster, and we don't need the original ndarray once a data is read in anyways. </p>
<p>It is good to learn this and keep this in mind!</p>
</div>
<span class="comment-copy">IMO you should change the title to something that looks like a actual question or make it Google search friendly, so that future users can find it easily. :)</span>
<span class="comment-copy">@AshwiniChaudhary Thank you! I agree. I have updated it, any further suggestions are still welcome! Also, I marked it as community wiki can realized that cannot be undone... Do you think I should still let it open to see whether someone else have a better/neater way to do it? :)</span>
<span class="comment-copy">Others can still post answer, so that's not an issue.</span>
<span class="comment-copy">@AshwiniChaudhary Oh I see... Sorry that I misunderstood the concept of the community wiki. Thanks for clarification!</span>
<span class="comment-copy">You can see this also via <code>np.frombuffer(temp[:, 1])</code>. This calls <code>PyObject_AsWriteBuffer</code> on the view, which in 3.x. gets a <a href="http://docs.python.org/3/c-api/buffer.html#Py_buffer" rel="nofollow noreferrer"><code>Py_buffer</code></a> for the object and returns the <code>buf</code> pointer and <code>len</code>. If it instead used <code>PyObject_GetBuffer</code> it could reconstruct the view based on <code>PyBuffer.strides</code>.</span>
<span class="comment-copy">@eryksun Thanks for your contribution based on the CPython implementation! This is really helpful.</span>
