<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1132941/least-astonishment-and-the-mutable-default-argument">“Least Astonishment” and the Mutable Default Argument</a>
<span class="question-originals-answer-count">
                    32 answers
                </span>
</li>
</ul>
</div>
<p>A few days ago I had a nasty bug related to this issue: when my class's constructor has a default argument of an empty dictionary, all instances of that class point to the same dictionary. Here is an example:</p>
<pre><code>class A:
    def __init__(self, d={}):
        self.D = d

class B:
    def __init__(self):
        self.D = {}

a1 = A()
a2 = A()
b1 = B()
b2 = B()

a1.D.update({'Akey':'Avalue'})
print("Printing a1 dict: ", a1.D)
print("Printing a2 dict: ", a2.D)

b1.D.update({'Bkey':'Bvalue'})
print("Printing b1 dict: ", b1.D)
print("Printing b2 dict: ", b2.D)
</code></pre>
<p>Ouput:</p>
<pre><code>Printing a1 dict:  {'Akey': 'Avalue'}
Printing a2 dict:  {'Akey': 'Avalue'}
Printing b1 dict:  {'Bkey': 'Bvalue'}
Printing b2 dict:  {}
</code></pre>
<p>I suspect that when the dictionary is initialized inside the constructor (as in class B), it creates a new reference for each object. When the dictionary is initialized as a default object, even though it is initialized to the empty dictionary, all objects point to the same dictionary. </p>
<p>Can someone shed light on this behavior and explain more about the inner workings of it? </p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="http://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="nofollow">Python Language Reference</a></p>
<blockquote>
<p>Default parameter values are evaluated when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call.</p>
</blockquote>
<p>When the function is defined, an empty dictionary is created, and bound to the function object. The assignment statement</p>
<pre><code>self.D = d
</code></pre>
<p>assigns the member variable to point to the instance created when the function was defined. Modifying that dictionary will modify the instance bound as the default value.</p>
<p>An alternative definition that likely accomplishes your goal would be something like:</p>
<pre><code>def __init__(self, d=None):
    if d is None:
        self.D = {}
    else:
        self.D = d
</code></pre>
</div>
<span class="comment-copy">and this link in that ticked answer: <a href="http://effbot.org/zone/default-values.htm" rel="nofollow noreferrer">effbot.org/zone/default-values.htm</a></span>
<span class="comment-copy">Your analysis is pretty much correct. All instances of <code>A</code> would share the same dictionary unless you create one and pass it in.</span>
