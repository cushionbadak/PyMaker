<div class="post-text" itemprop="text">
<p>I'm trying to use a python app on a server for the first time.  I started by adding setuptools as root:</p>
<p><code>[root@server mydirectory]# yum install python-setuptools</code></p>
<p>Cool. Then I try setup.py:</p>
<pre><code>[user@server mydirectory]$ python setup.py install
running install
error: can't create or remove files in install directory

The following error occurred while trying to add or remove files in the
installation directory:

    [Errno 13] Permission denied: '/usr/lib/python2.4/site-packages/test-easy-install-25752.write-test'
</code></pre>
<p>This directory <code>/usr/lib/python2.4/site-packages</code> is owned by root, so that makes sense.</p>
<p>My question is, should I chmod the site-packages directory, or should I be running setup.py as root?</p>
</div>
<div class="post-text" itemprop="text">
<p>The traditional way to install stuff system-wide as a non-root user is to use <code>sudo</code>. Which is why you see things like this all over the Python docs:</p>
<pre><code>sudo python setup.py install
</code></pre>
<p>Some people prefer to instead make the site-packages group-writable by some "dev" group so you don't need to do this. (This is effectively what the Mac package manager Homebrew does.)</p>
<hr/>
<p>Alternatively, you can install into per-user site packages. Not every project can do this, but anything based on modern <code>setuptools</code> should be able to do so.</p>
<p>And, while we're at it, if you're installing stuff based on modern <code>setuptools</code>, it's probably better to <code>pip install .</code> instead of <code>python setup.py install</code> anyway. That will, among other benefits, create egg-info files so the package can be detected as a dependency, uninstalled, etc.</p>
<p>See the <a href="https://python-packaging-user-guide.readthedocs.org/en/latest/current.html" rel="nofollow">Python Packaging User Guide</a> for more information.</p>
<hr/>
<p>Finally, you may want to consider using a <a href="http://docs.python.org/3/library/venv.html#venv-def" rel="nofollow">virtual environment</a>. With Python 3.3+, this is built in as <a href="http://docs.python.org/3/library/venv.html" rel="nofollow"><code>venv</code></a>, although it doesn't have its own <code>pip</code> until 3.4. With earlier versions of Python, you can install <a href="https://pypi.python.org/pypi/virtualenv" rel="nofollow"><code>virtualenv</code></a> off PyPI.</p>
<p>Many hosted server environments for Python (2.x or 3.x) come with <code>virtualenv</code> pre-installed. If not, installing <em>it</em> system-wide will of course require you to be rootâ€¦ but after that, you will be able to install (most) other packages into per-project virtual environments instead of system-wide.</p>
</div>
<div class="post-text" itemprop="text">
<p>Installing packages with pip/easy_install and running directly setup.py files require root privileges because they read/write in those restricted folders.</p>
<p>Usually hosts like www.openshift.com support a virtualenv for you so you just activate it and you have your own per-user environment. Affecting the global site-packages is usually forbidden since it may be a shared host.</p>
<p>In my experience, in a local ubuntu-installed laptop, I have two options:</p>
<ol>
<li>Run installs as sudo</li>
<li>Run installs in a virtualenv</li>
</ol>
<p>perhaps your host, if shared, supports virtualenv. Try asking them if it doesn't support it.</p>
</div>
<span class="comment-copy">Can you move to a virtualenv? does your server support virtualenv?</span>
<span class="comment-copy">good question - haven't tried on this server.  I'll look into it.  Is there an alternative?</span>
<span class="comment-copy">See other answers (e.g. @abarnert 's one) for more details. Have no more clues than that.</span>
