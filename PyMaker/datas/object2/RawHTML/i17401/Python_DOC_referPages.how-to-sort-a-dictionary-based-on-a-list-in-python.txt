<div class="post-text" itemprop="text">
<p>I have a dictionary </p>
<pre><code>a = {'ground': obj1, 'floor 1': obj2, 'basement': obj3}
</code></pre>
<p>I have a list.</p>
<pre><code>a_list = ['floor 1', 'ground', 'basement']
</code></pre>
<p>I want to sort dictionary a using its keys based on the list. Is it possible to do that?</p>
<p>i.e.:</p>
<pre><code>sort(a).based_on(a_list) #this is wrong. But I want something like this. 
</code></pre>
<p>The output doesn't have to be another dictionary, I don't mind converting the dictionary to tuples and then sort those.</p>
</div>
<div class="post-text" itemprop="text">
<p>The naive way, sorting the list of (key, value) tuples, using the <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted()</code> function</a> and a custom sort key (called for each <code>(key, value)</code> pair produced by <code>dict.items())</code>):</p>
<pre><code>sorted(a.items(), key=lambda pair: a_list.index(pair[0]))
</code></pre>
<p>The faster way, creating an index map first:</p>
<pre><code>index_map = {v: i for i, v in enumerate(a_list)}
sorted(a.items(), key=lambda pair: index_map[pair[0]])
</code></pre>
<p>This is faster because the dictionary lookup in <code>index_map</code> takes O(1) constant time, while the <code>a_list.index()</code> call has to scan through the list each time, so taking O(N) linear time. Since that scan is called for each key-value pair in the dictionary, the naive sorting option takes O(N^2) quadratic time, while using a map keeps the sort efficient (O(N log N), linearithmic time).</p>
<p>Both assume that <code>a_list</code> contains <em>all</em> keys found in <code>a</code>. However, if that's the case, then you may as well invert the lookup and just <em>retrieve the keys in order</em>:</p>
<pre><code>[(key, a[key]) for key in a_list if key in a]
</code></pre>
<p>which takes O(N) linear time, and allows for extra keys in <code>a_list</code> that don't exist in <code>a</code>.</p>
<p>To be explicit: O(N) &gt; O(N log N) &gt; O(N^2), see <a href="http://bigocheatsheet.com/" rel="nofollow noreferrer">this cheat sheet for reference</a>.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; a = {'ground': 'obj1', 'floor 1': 'obj2', 'basement': 'obj3'}
&gt;&gt;&gt; a_list = ('floor 1', 'ground', 'basement')
&gt;&gt;&gt; sorted(a.items(), key=lambda pair: a_list.index(pair[0]))
[('floor 1', 'obj2'), ('ground', 'obj1'), ('basement', 'obj3')]
&gt;&gt;&gt; index_map = {v: i for i, v in enumerate(a_list)}
&gt;&gt;&gt; sorted(a.items(), key=lambda pair: index_map[pair[0]])
[('floor 1', 'obj2'), ('ground', 'obj1'), ('basement', 'obj3')]
&gt;&gt;&gt; [(key, a[key]) for key in a_list if key in a]
[('floor 1', 'obj2'), ('ground', 'obj1'), ('basement', 'obj3')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could just retrieve the values in order of the keys provided by the list and make a new list out of the key-value pairs.</p>
<p>Example:</p>
<pre><code>d = a      # dictionary containing key-value pairs that are to be ordered
l = a_list # list of keys that represent the order for the dictionary
# retrieve the values in order and build a list of ordered key-value pairs
ordered_dict_items = [(k,d[k]) for k in l]
</code></pre>
</div>
<span class="comment-copy">@Martjin - this has solved one of my problems, but I'm having some trouble understanding where the <code>pair</code> in <code>index_map[pair[0]]</code> comes from / is derived. It could only come from the <code>a.items()</code> tuples, but the link between that and <code>pair</code> isn't clear (yet). Know where I could look for a detailed explanation / more examples of what's going on here?</span>
<span class="comment-copy">@rong: it is exactly that, the <code>(key, value)</code> pair produced by <code>dict.items()</code>. The <code>sorted()</code> function passes <i>each element being sorted</i> to the <code>key</code> callable, and for <code>dict.items()</code> the elements are always tuples with two objects, the key and the value.</span>
