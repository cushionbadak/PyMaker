<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/21839541/extract-information-from-excel-into-python-2d-array">extract information from excel into python 2d array</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have two columns in excel. Date and temp. They look like this:</p>
<pre><code>  date             temp
20130102           34.20
20130102           34.42
20130102           34.23
20130102           34.12
20130102           34.84
20130103           34.48
20130103           34.42
20130103           33.77
20130103           33.62
20130103           33.94
20130103           33.45
</code></pre>
<p>when I extract them into python using numpy, i get 2 arrays like this:</p>
<pre><code>date = [20130102,20130102,20130102,20130102,20130102,20130103,20130103,20130103,20130103]
temp = [34.20,34.42,34.23.....,33.45]
</code></pre>
<p>How do I convert this into 1 array of arrays by combining 1 date with all corresponding temps for that date.</p>
<pre><code>dataarray = [[20130102,34.20,34.42,34.23,34.12,34.84],[20130103,34.48,34.42,33.77,33.62,33.94,33.45]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get the exact format that you specify (a list of lists), I'd use <a href="http://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> and then a couple of list comprehensions to unpack the group generators:</p>
<pre><code>import itertools
groups = itertools.groupby(zip(date, temp), lambda dv:dv[0])
list_of_lists = [[d] + [v[1] for v in values] for d, values in groups]
</code></pre>
<p>I'm assuming, based on your example, that your data is available <em>in sorted order</em>. If not, the <code>groupby</code> function won't do what you need it to do, and you'd be better off with a dictionary (see below).</p>
<hr/>
<p>But my guess is, if you want to actually <em>do</em> anything with this data after you've unpacked it, it'll be more convenient to have it in a dictionary by date, in which case you'll want to go with the <a href="http://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> strategy in <a href="https://stackoverflow.com/a/21841530/2069350">Joran's answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>d = {}
for date,temp in zip(dates,temps):
   try:
       d[date].append(temp)
   except KeyError:
       d[date] = [temp]

print d
</code></pre>
<p>you could use defaultdict to improve it slightly</p>
<pre><code>from collections import defaultdict
d = defaultdict(list)
for date,temp in zip(dates,temps):
   d[date].append(temp)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try a dictionary where the key is the date and the result is an array that you append to. So you'd simply parse through the pairs and calling dataArray[date[i]].append(temp[i]) or the like. Don't forget to create the array if the key is currently null though.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really want to have the array format, here is Joran's answer edited to give you the dataarray:</p>
<pre><code>d = {}
for date,temp in zip(dates,temps):
   try:
       d[date].append(temp)
   except KeyError:
       d[date] = [temp]

dataarray = []
for year, temps in d.iteritems():
    tmp = [year]
    tmp.extend(temps)
    dataarray.append(tmp)
print dataarray
</code></pre>
</div>
<span class="comment-copy">Didn't you already get an answer to this in <a href="http://stackoverflow.com/questions/21839541/extract-information-from-excel-into-python-2d-array">your previous question</a>? If the issue is that you got a lists of lists rather than a 2D NumPy array there… well, of course you did. A NumPy array is square, it can't be jagged (where different rows have different lengths).</span>
<span class="comment-copy">Aside: it's not clear to me that's a particularly useful data format.  If you want to do something with the daily temperatures (such as get statistics on them, or whatever) then I think you're going about this the wrong way.</span>
<span class="comment-copy">In <a href="http://stackoverflow.com/questions/21839541/extract-information-from-excel-into-python-2d-array">his previous question</a> he specifically said he wanted this  list-of-list formats when I suggested a dict would be better. Of course he also asked this question after already getting an equivalent answer there, so… who knows what he's after.</span>
<span class="comment-copy">figured out my question. Thanks for providing the perfect answer. this is exactly what i was looking for</span>
<span class="comment-copy">@user1681664 Looks like your input data contains a bunch of blank lines, maybe? I'd trim them out when you're reading the data from whatever your data source is (e.g. if you're reading from a file, <code>for line in file: if not line.strip(): continue</code>). That way you don't waste time processing garbage data.</span>
<span class="comment-copy">Is that widely accepted practice to use try in such a way? I would personally rather do "if date in d" rather than try but I don't really have a reason beyond "it looks better" :-). Plus, your way is likely faster anyway.</span>
<span class="comment-copy">@CodeMonkey: See <a href="http://docs.python.org/3/glossary#term-eafp" rel="nofollow noreferrer">Easier to Ask Forgiveness than Permission</a> (and the link to LBYL, and the entry on duck typing) in the glossary for why this is widely accepted practice.</span>
<span class="comment-copy">@JoranBeasley: No idea why someone downvoted this; I already up voted it. Although I think using <code>setdefault</code> would be clearer than either a <code>try</code> statement or an <code>if</code> in this case.</span>
<span class="comment-copy">yeah I dont disagree ... I just would do it with a defaultdict normally ... I dont think ive ever used the setdefault feature</span>
<span class="comment-copy">@JoranBeasley: The way I see it, the choice between <code>defaultdict</code> and <code>setdefault</code> is entirely on how you intend to use the thing after building it. In many cases, you intend to use it exactly once to create some output, so it doesn't matter. But otherwise, it usually matters whether you get a <code>KeyError</code> or <code>[]</code> for looking up a missing key. (As a side note, <code>setdefault</code> is one of the few cases that can't easily be handled by the upcoming except-expression PEP, not yet published, but see the thread starting <a href="https://mail.python.org/pipermail/python-ideas/2014-February/025437.html" rel="nofollow noreferrer">here</a>.)</span>
