<div class="post-text" itemprop="text">
<p>I was working on making a wrapper object that would take an instance of an arbitrary class and then automatically wrap all of its own magic methods to simply use the magic method (and value) of the wrapped object. For some reason, this doesn't work:</p>
<pre><code>class Wrapper:
    def __init__(self, wrapped):
        self.wrapped = wrapped
        for method in filter(lambda x: x.startswith("__") and (x not in 
        ["__init__", "__new__", "__class__", "__metaclass__"]), 
        dir(wrapped)):
            if hasattr(getattr(wrapped, method), "__call__"):
                new_func = functools.partial(getattr(type(wrapped), method), self.wrapped)
                setattr(self, method, new_func)


t = Wrapper(7)
t + 8
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  TypeError: unsupported operand type(s) for +: 'Wrapper' and 'int'

class Tester:
    def __init__(self):
        self.v = 5
    def __add__(self, other):
        return self.v + other

y = Tester()
y + 7
12
t = Wrapper(y)
t + 9
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'Wrapper' and 'int'

9 + t
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'Wrapper'

t.__add__
functools.partial(&lt;function Tester.__add__ at 0x7fbec6372170&gt;, &lt;__main__.Tester object at 0x7fbec6392990&gt;)

t.__add__(7)
12
</code></pre>
<p>I thought maybe the partial wasn't working properly with the distinction between the type's method and an instance method, but when I directly call my wrapper's magic add, it works properly. (This is tested in CPython 3.3)</p>
</div>
<div class="post-text" itemprop="text">
<p>Special methods are <a href="http://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow">always looked up on the <em>type</em> of the instance</a> (here the class object), not on the instance.  Otherwise a <code>__repr__</code> on a class would be used when you tried to print the representation of the class itself; <code>type(class).__repr__(class)</code> would use the correct magic method, while <code>class.__repr__()</code> would raise an exception because <code>self</code> was not provided.</p>
<p>You'll need to implement these special methods directly on the wrapper, propagating any exceptions that might be raised when called on the wrapped object.</p>
</div>
<span class="comment-copy">You cannot set special methods on instances, they are always looked up on the type.</span>
<span class="comment-copy">Hmm. You're right. I tried a similar example and cpython does totally ignore it unless I call the magic method directly. Do you know if this is somewhere in the language reference? (Is this a design decision or an implementation detail?) Does this constraint apply across all implementations?</span>
<span class="comment-copy">See my answer, it is a design decision.</span>
<span class="comment-copy">Hmm. That's a good point. I was thinking that this was done for performance reasons, but you make a good point, doing it otherwise has logical issues. Thanks!</span>
