<div class="post-text" itemprop="text">
<p>I am relatively new to working with csv files in python and would appreciate some guidiance. I have 6 separate csv files. I would like to copy data from column 1, column 2 and column 3 from each of the csv files into the corresponding first 3 columns in a new file.</p>
<p>How do I word that into my code?</p>
<p>Here is my incomplete code:</p>
<pre><code>import csv

file1 = open ('fileA.csv', 'rb')
reader1 = csv.reader (file1)
file2 = open ('fileB.csv', 'rb')
reader2 = csv.reader (file2)
file3 = open ('fileC.csv', 'rb')
reader3 = csv.reader (file3)
file4 = open ('fileD.csv', 'rb')
reader4 = csv.reader (file4)
file5 = open ('fileE.csv', 'rb')
reader5 = csv.reader (file5)
file6 = open ('fileF.csv', 'rb')
reader6 = csv.reader (file6)

WriteFile = open ('NewFile.csv','wb')
writer = csv.writer(WriteFile)

next(reader1, None)
Data1 = (col[0:3] for col in reader1)
next(reader2, None)
Data2 = (col[0:3] for col in reader2)
next(reader3, None)
Data3 = (col[0:3] for col in reader3)
next(reader4, None)
Data4 = (col[0:3] for col in reader4)
next(reader5, None)
Data5 = (col[0:3] for col in reader5)
next(reader6, None)
Data6 = (col[0:3] for col in reader6)
.......????????

file1.close()
file2.close()
file3.close()
file4.close()
file5.close()
file6.close()
WriteFile.close()
</code></pre>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just want these all concatenated, that's easy. You can either call <code>writerows</code> on each of your iterators, or <a href="http://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>chain</code></a> them together:</p>
<pre><code>writer.writerows(itertools.chain(Data1, Data2, Data3, Data4, Data5, Data6))
</code></pre>
<hr/>
<p>Or, if you want them interleaved, where you get row 1 from Data1, then row 1 from Data 2, and so on, and then row 2 from Data 1, etc., use <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> to transpose the data, and then <code>chain</code> again to flatten it:</p>
<pre><code>writer.writerows(itertools.chain.from_iterable(zip(Data1, Data2, Data3, 
                                                   Data4, Data5, Data6)))
</code></pre>
<hr/>
<p>If the files are of different lengths, that <code>zip</code> will stop as soon as you reach the end of <em>any</em> of the files. Is that what you want? I have no idea. You might want that. You might want to fill in the gaps with blank rows (in which case look at <a href="http://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow"><code>zip_longest</code></a>). You might want to skip over the gaps (which you can do with <code>zip_longest</code> plus <a href="http://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a>). Or a million other possibilities.</p>
<hr/>
<p>As a side note, once you get to this many similar variables, it's usually a good sign that you really wanted a single iterable instead of separate variables. For example:</p>
<pre><code>filenames = ('fileA.csv', 'fileB.csv', 'fileC.csv', 
             'fileD.csv', 'fileE.csv', 'fileF.csv')
files = [open(filename, 'rb') for filename in filenames]
readers = [csv.reader(file) for file in files]

WriteFile = open ('NewFile.csv','wb')
writer = csv.writer(WriteFile)

for reader in readers:
    next(reader, None)

Data = [(col[0:3] for col in reader) for reader in readers]

writer.writerows(itertools.chain.from_iterable(Data))

for file in files:
    file.close()
WriteFile.close()
</code></pre>
<p>(Notice that I used list comprehensions, not generator expressions, for the collections of files, readers, data, etc. That's because we need to iterate over them repeatedly—e.g., create a <code>reader</code> for every file, and later call <code>close</code> on every file. Also because there are a fixed, small number of elements—6—so "wasting" a whole list isn't really any issue.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The way I understand your question is that you have six separate csv's that have 3 columns each and the data in each column is of the same type in all six files.  If so you could use pandas.  Say you had 3 files that looked like ... </p>
<pre><code>file1:
      col1    col2   col3
        1       1      1
        1       1      1
</code></pre>
<p>and then a second and third file with 2's in the second and 3's in the third you could write...</p>
<pre><code>#!/usr/bin/env python

import pandas as pd

cols = ['col1', 'col2', 'col3']
files = ['~/one.txt', '~/two.txt', '~/three.txt']
data_1 = pd.read_csv(files[0], sep=',', header=False, names=cols)
data_2 = pd.read_csv(files[1], sep=',', header=False, names=cols)
data_3 = pd.read_csv(files[2], sep=',', header=False, names=cols)

data_final = data_1.append(data_2).append(data_3)
</code></pre>
<p>Then data_final should have the contents of all three data sets stacked on each other.  You can modify for 6 (or n) datasets.  Hope this is what you wanted.</p>
<pre><code>Out[1]:    col1    col2    col3
             1       1       1
             1       1       1
             2       2       2
             2       2       2
             3       3       3
             3       3       3
</code></pre>
</div>
<span class="comment-copy">Can you show us some small example inputs and the expected output? Do you want to have the first 3 columns of every row in file1, then the first 3 columns of every row in file 2, etc.? Or interleaved, so the first 3 columns of the first row in file 1, then of the first row in file 2, …, file 6, then the second row in file 1, etc.? Or "merged" in some way? Or …?</span>
<span class="comment-copy">Thanks very much for your explanation. I like the itertools method. Using the itertools approach, I get the following error:        Traceback (most recent call last): File "C:\Python33\Joining_columns_csv.py", line 12, in &lt;module&gt; next(reader, None) _csv.Error: iterator should return strings, not bytes (did you open the file in text mode?) Could you please help me resolve this error?</span>
<span class="comment-copy">Well, that error message comes from the <code>next</code> call from your original code, before it even gets to the <code>writerows</code> using the <code>chain</code> call. So clearly the code you posted was already broken, before even getting to this point, or your actual code is not the same as what you posted. Either way, there's no way to fix that as a followup to this problem. Maybe ask a new question, posting a <a href="http://stackoverflow.com/help/mcve">MCVE</a> that demonstrates it?</span>
<span class="comment-copy">@user3302763: But I can make a quick guess: If you're using Python 2, you always want to give the <code>csv</code> module binary files, but in Python 3, you usually want to give it <i>text</i> files. My guess is that you typed in some sample code meant for 2.x and tried to run it in 3.3. See the examples in the 3.x docs, like <a href="http://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer">this one</a>, instead: <code>open</code> the files in <code>'r'</code> mode, not <code>'rb'</code> mode.</span>
<span class="comment-copy">Thanks. Yes, I recently upgraded to python 3 and it is giving me grief with all the little changes from python 2. I changed the read and mode from 'rb' to 'rt' and it solved the problem. Thanks again. It was much appreciated!</span>
