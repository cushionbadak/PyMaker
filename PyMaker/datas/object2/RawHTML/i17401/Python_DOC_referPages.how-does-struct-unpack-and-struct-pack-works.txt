<div class="post-text" itemprop="text">
<p>I'm currently trying to to learn how to parse PPM file. I did the following in a python interpreter:</p>
<pre><code>&gt;&gt;&gt; x = open('file.ppm')
&gt;&gt;&gt; x.readline()
'P6\n'
&gt;&gt;&gt; x.readline()
'2 3\n'
&gt;&gt;&gt; x.readline()
'255\n'
&gt;&gt;&gt; x.readline()
'\n'
&gt;&gt;&gt; x.readline()
'\x174R\x03\xd7\x1e\xb5e!-\xcd(D\\oL\x01'
</code></pre>
<p>I understand the basic structure of a PPM file. I'm most curious about the last line, however. The byte encoding that contains the info on the pixel's colour. The file above should parse back into</p>
<pre><code>P6
2 3
255
10 23 52 82 3 215 30 181 101 33 45 205 40 68 92 111 76 1
</code></pre>
<p>By using <code>struct.pack('B',x)</code>, I see that the integers get packed into the byte encoding above. However, I'm not sure how to reverse this process using <code>struct.unpack</code>. Most importantly, I'm not sure where to cut off each of the byte encoding since they all appear on the same line, and each doesn't seem to have the same length either (?).</p>
<p>I also tried to pack the whole line by doing <code>struct.pack('I','\x174R\x03\xd7\x1e\xb5e!-\xcd(D\\oL\x01')</code>. I don't understand why it could not directly convert the byte encoding into integers.</p>
<p>How can I use <code>struct.pack(...)</code> to parse the byte encoding back into integers? Also, what is happening as those values are being packed/ unpacked? </p>
</div>
<div class="post-text" itemprop="text">
<p>First three strings are not packed by <code>struct.pack</code>. So simply use them (<code>strip</code> or <code>rstrip</code> if you want remove spaces around).</p>
<pre><code>&gt;&gt;&gt; 'P6\n'
'P6\n'
&gt;&gt;&gt; 'P6\n'.rstrip()
'P6'
</code></pre>
<p>For the last bytes:</p>
<pre><code>&gt;&gt;&gt; b = b'\x174R\x03\xd7\x1e\xb5e!-\xcd(D\\oL\x01'
&gt;&gt;&gt; struct.unpack('%dB' % len(b), b)
(23, 52, 82, 3, 215, 30, 181, 101, 33, 45, 205, 40, 68, 92, 111, 76, 1)
</code></pre>
<p>or using <a href="http://docs.python.org/2/library/functions.html#bytearray" rel="nofollow"><code>bytearray</code></a>: (You can use <a href="http://docs.python.org/3/library/functions.html#bytes" rel="nofollow"><code>bytes</code></a> instead in Python 3.x); Iterating <code>bytearray</code> yields <code>int</code>s.</p>
<pre><code>&gt;&gt;&gt; list(bytearray(b))
[23, 52, 82, 3, 215, 30, 181, 101, 33, 45, 205, 40, 68, 92, 111, 76, 1]
</code></pre>
<p><strong>NOTE</strong> As Martijn Pieters commented, you'd better open the file with binary mode when you're dealing with binary data.</p>
<pre><code>f = open('file.ppm', 'rb') # b: binary mode
</code></pre>
</div>
<span class="comment-copy">Reading the Format Strings section on the documentation might help: <a href="http://docs.python.org/2/library/struct.html#struct-format-strings" rel="nofollow noreferrer">docs.python.org/2/library/struct.html#struct-format-strings</a></span>
<span class="comment-copy">Don't open the file in text mode and use <code>.readline()</code>. Open in binary mode, use <code>.read(number_of_bytes)</code> to read sections instead. In text mode platform-specific line terminators are translated to <code>\n</code> newlines and that's usually not what you want in a binary file read. The <code>\n</code> of your one-but-last <code>.readline()</code> is part of the section read with the last <code>.readline()</code> for example.</span>
<span class="comment-copy">Note that does require the <code>\n</code> to be part of the data. It's probably not a good idea to read a binary format in text mode.</span>
<span class="comment-copy">@MartijnPieters, Thank you. I updated the answer.</span>
