<div class="post-text" itemprop="text">
<p>I am originally a C programmer. I have seen numerous tricks and "hacks" to read many different arguments. </p>
<p>What are some of the ways Python programmers can do this?</p>
<h3>Related</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/20063/whats-the-best-way-to-grab-parse-command-line-arguments-passed-to-a-python-scrip">What’s the best way to grab/parse command line arguments passed to a Python script?</a></li>
<li><a href="https://stackoverflow.com/questions/362426/implementing-a-command-action-parameter-style-command-line-interfaces">Implementing a “[command] [action] [parameter]” style command-line interfaces?</a></li>
<li><a href="https://stackoverflow.com/questions/567879/how-can-i-process-command-line-arguments-in-python">How can I process command line arguments in Python?</a></li>
<li><a href="https://stackoverflow.com/questions/642648/how-do-i-format-positional-argument-help-using-pythons-optparse">How do I format positional argument help using Python’s optparse?</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The canonical solution in the standard library is <code>argparse</code> (<a href="https://docs.python.org/3/library/argparse.html" rel="noreferrer">docs</a>):</p>
<p>Here is an example:</p>
<pre><code>from argparse import ArgumentParser

parser = ArgumentParser()
parser.add_argument("-f", "--file", dest="filename",
                    help="write report to FILE", metavar="FILE")
parser.add_argument("-q", "--quiet",
                    action="store_false", dest="verbose", default=True,
                    help="don't print status messages to stdout")

args = parser.parse_args()
</code></pre>
<p><code>argparse</code> supports (among other things):</p>
<ul>
<li>Multiple options in any order.</li>
<li>Short and long options.</li>
<li>Default values.</li>
<li>Generation of a usage help message.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys

print("\n".join(sys.argv))
</code></pre>
<p><a href="https://docs.python.org/3/library/sys.html#sys.argv" rel="noreferrer"><code>sys.argv</code></a> is a list that contains all the arguments passed to the script on the command line.</p>
<p>Basically,</p>
<pre><code>import sys
print(sys.argv[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just going around evangelizing for <a href="http://code.google.com/p/argparse/" rel="noreferrer">argparse</a> which is better for <a href="http://argparse.googlecode.com/svn/trunk/doc/argparse-vs-optparse.html" rel="noreferrer">these</a> reasons.. essentially:</p>
<p><em>(copied from the link)</em></p>
<ul>
<li><p>argparse module can handle positional
and optional arguments, while
optparse can handle only optional
arguments</p></li>
<li><p>argparse isn’t dogmatic about
what your command line interface
should look like - options like -file
or /file are supported, as are
required options. Optparse refuses to
support these features, preferring
purity over practicality</p></li>
<li><p>argparse produces more
informative usage messages, including
command-line usage determined from
your arguments, and help messages for
both positional and optional
arguments. The optparse module
requires you to write your own usage
string, and has no way to display
help for positional arguments.</p></li>
<li><p>argparse supports action that
consume a variable number of
command-line args, while optparse
requires that the exact number of
arguments (e.g. 1, 2, or 3) be known
in advance</p></li>
<li><p>argparse supports parsers that
dispatch to sub-commands, while
optparse requires setting
<code>allow_interspersed_args</code> and doing the
parser dispatch manually</p></li>
</ul>
<p>And my personal favorite:</p>
<ul>
<li>argparse allows the type and
action parameters to <code>add_argument()</code>
to be specified with simple
callables, while optparse requires
hacking class attributes like
<code>STORE_ACTIONS</code> or <code>CHECK_METHODS</code> to get
proper argument checking</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There is also <a href="https://docs.python.org/library/argparse.html" rel="noreferrer"><code>argparse</code> stdlib module</a> (an "impovement" on stdlib's <code>optparse</code> module). Example from <a href="https://docs.python.org/howto/argparse.html" rel="noreferrer">the introduction to argparse</a>:</p>
<pre><code># script.py
import argparse

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'integers', metavar='int', type=int, choices=range(10),
         nargs='+', help='an integer in the range 0..9')
    parser.add_argument(
        '--sum', dest='accumulate', action='store_const', const=sum,
        default=max, help='sum the integers (default: find the max)')

    args = parser.parse_args()
    print(args.accumulate(args.integers))
</code></pre>
<p>Usage:</p>
<pre><code>$ script.py 1 2 3 4
4

$ script.py --sum 1 2 3 4
10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to do it is using <code>sys.argv</code>. This will print the script name as the first argument and all the other parameters that you pass to it.</p>
<pre><code>import sys

for arg in sys.argv:
    print arg
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://github.com/docopt/docopt">docopt</a> library is really slick.  It builds an argument dict from the usage string for your app.</p>
<p>Eg from the docopt readme:</p>
<pre><code>"""Naval Fate.

Usage:
  naval_fate.py ship new &lt;name&gt;...
  naval_fate.py ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;]
  naval_fate.py ship shoot &lt;x&gt; &lt;y&gt;
  naval_fate.py mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored | --drifting]
  naval_fate.py (-h | --help)
  naval_fate.py --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --speed=&lt;kn&gt;  Speed in knots [default: 10].
  --moored      Moored (anchored) mine.
  --drifting    Drifting mine.

"""
from docopt import docopt


if __name__ == '__main__':
    arguments = docopt(__doc__, version='Naval Fate 2.0')
    print(arguments)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need something fast and not very flexible</p>
<p><strong>main.py:</strong></p>
<pre><code>import sys

first_name = sys.argv[1]
last_name = sys.argv[2]
print("Hello " + first_name + " " + last_name)
</code></pre>
<p>Then run <code>python main.py James Smith</code></p>
<p>to produce the following output:</p>
<blockquote>
<p>Hello James Smith</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>#set default args as -h , if no args:
if len(sys.argv) == 1: sys.argv[1:] = ["-h"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use optparse myself, but really like the direction Simon Willison is taking with his recently introduced <a href="http://github.com/simonw/optfunc/tree/master" rel="noreferrer">optfunc</a> library.  It works by:</p>
<blockquote>
<p>"introspecting a function
  definition (including its arguments
  and their default values) and using
  that to construct a command line
  argument parser."</p>
</blockquote>
<p>So, for example, this function definition:</p>
<pre><code>def geocode(s, api_key='', geocoder='google', list_geocoders=False):
</code></pre>
<p>is turned into this optparse help text:</p>
<pre><code>    Options:
      -h, --help            show this help message and exit
      -l, --list-geocoders
      -a API_KEY, --api-key=API_KEY
      -g GEOCODER, --geocoder=GEOCODER
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like getopt from stdlib, eg:</p>
<pre><code>try:
    opts, args = getopt.getopt(sys.argv[1:], 'h', ['help'])
except getopt.GetoptError, err: 
    usage(err)

for opt, arg in opts:
    if opt in ('-h', '--help'): 
        usage()

if len(args) != 1:
    usage("specify thing...")
</code></pre>
<p>Lately I have been wrapping something similiar to this to make things less verbose (eg; making "-h" implicit).</p>
</div>
<div class="post-text" itemprop="text">
<p>As you can see <a href="http://docs.python.org/library/optparse.html#module-optparse" rel="noreferrer">optparse</a> "The optparse module is deprecated with and will not be developed further; development will continue with the <a href="http://docs.python.org/library/argparse.html#module-argparse" rel="noreferrer">argparse</a> module." </p>
</div>
<div class="post-text" itemprop="text">
<p>Pocoo's <a href="http://click.pocoo.org/" rel="noreferrer">click</a> is more intuitive, requires less boilerplate, and is at least as powerful as argparse.</p>
<p>The only weakness I've encountered so far is that you can't do much customization to help pages, but that usually isn't a requirement and <a href="http://docopt.org/" rel="noreferrer">docopt</a> seems like the clear choice when it is.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may be interested in a little Python module I wrote to make handling of command line arguments even easier (open source and free to use) - <a href="http://freshmeat.net/projects/commando" rel="nofollow">Commando</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend looking at <a href="http://docopt.org/" rel="nofollow">docopt</a> as a simple alternative to these others.</p>
<p>docopt is a new project that works by parsing your --help usage message rather than requiring you to implement everything yourself. You just have to put your usage message in the POSIX format.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another option is <a href="https://pypi.python.org/pypi/argh" rel="nofollow">argh</a>. It builds on argparse, and lets you write things like:</p>
<pre><code>import argh

# declaring:

def echo(text):
    "Returns given word as is."
    return text

def greet(name, greeting='Hello'):
    "Greets the user with given name. The greeting is customizable."
    return greeting + ', ' + name

# assembling:

parser = argh.ArghParser()
parser.add_commands([echo, greet])

# dispatching:

if __name__ == '__main__':
    parser.dispatch()
</code></pre>
<p>It will automatically generate help and so on, and you can use decorators to provide extra guidance on how the arg-parsing should work.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import argparse

parser = argparse.ArgumentParser(description='Process some integers.')
parser.add_argument('integers', metavar='N', type=int, nargs='+',
                   help='an integer for the accumulator')
parser.add_argument('--sum', dest='accumulate', action='store_const',
                   const=sum, default=max,
                   help='sum the integers (default: find the max)')

args = parser.parse_args()
print(args.accumulate(args.integers))

Assuming the Python code above is saved into a file called prog.py
$ python prog.py -h

Ref-link: https://docs.python.org/3.3/library/argparse.html
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution is <a href="https://github.com/ponty/entrypoint2" rel="nofollow">entrypoint2</a>. Example:</p>
<pre><code>from entrypoint2 import entrypoint
@entrypoint
def add(file, quiet=True): 
    ''' This function writes report.

    :param file: write report to FILE
    :param quiet: don't print status messages to stdout
    '''
    print file,quiet
</code></pre>
<p>help text:</p>
<pre><code>usage: report.py [-h] [-q] [--debug] file

This function writes report.

positional arguments:
  file         write report to FILE

optional arguments:
  -h, --help   show this help message and exit
  -q, --quiet  don't print status messages to stdout
  --debug      set logging level to DEBUG
</code></pre>
</div>
<span class="comment-copy">Use docopt (see @ralbatross's answer at <a href="http://stackoverflow.com/a/14790373/116891">stackoverflow.com/a/14790373/116891</a>). I've tried every other way and, really, docopt is the only one I will use going forward.</span>
<span class="comment-copy">I don't think there's one single best way. argparse is standard and featureful. docopt is very elegant but not in the standard library. For very easy lightweight use you can <a href="http://stackoverflow.com/a/43234054/318488">make function default values handle comand line argument defaults for you</a>.</span>
<span class="comment-copy">Yes, these are the best. Since they're part of the standard library, you can be sure they'll be available and they're easy to use. optparse in particular is powerful and easy.</span>
<span class="comment-copy">optparse is one of the best; getopt is old and really ought to be considered deprecated.</span>
<span class="comment-copy">at this point (12/2011), argparse is now considered a better option than optparse, correct?</span>
<span class="comment-copy">Python Documentation suggests the use of <a href="http://docs.python.org/library/argparse.html#module-argparse" rel="nofollow noreferrer">argparse</a> instead of optparse.</span>
<span class="comment-copy">Since <code>optparse</code> is deprecated, the asker of the question is no longer a member on stack overflow, and this is the accepted answer on a highly visible question - please consider completely rewriting your example code to use stdlib <code>argparse</code> instead.</span>
<span class="comment-copy">For really simple stuff, this is the way to go, although you probably only want to use <code>sys.argv[1:]</code> (avoids the script name).</span>
<span class="comment-copy">It's for Python3</span>
<span class="comment-copy">It works when I run it on Python 2.7.13</span>
<span class="comment-copy">This is now part of standard Python as of 2.7 and 3.2 :)</span>
<span class="comment-copy">What are "optional arguments"? You say they're in optparse. I thought that they were arguments that may or may not be provided, but you said they're in optparse while going on to say that "optparse requires that the exact number of arguments be known in advance". So either your definition of "optional argument" differs from what I thought, or your answer is inconsistent with itself.</span>
<span class="comment-copy">Just a gripe: argparse documentation is also insanely, insanely complicated. You can't get a simple answer for "how do I make a command line argument take in a single value, and how do I access that value." &lt;/gripe&gt;</span>
<span class="comment-copy">@osman This gentle <a href="https://docs.python.org/3/howto/argparse.html" rel="nofollow noreferrer">tutorial</a> on argparse might help...</span>
<span class="comment-copy">@ArtOfWarfare "optional arguments" in this context presumably means arguments specified with option-like arguments such as <code>-f</code> or <code>--foo</code>, while "exact number of arguments be known in advance" presumably means positional arguments given without any preceding option flags.</span>
<span class="comment-copy">its just a copy and paste</span>
<span class="comment-copy">@blitu12345 at the time of the publication of my answer there were no other answers that mention argparse in any way. The module itself was not in stdlib¶ What do you have against code examples from the documentation? Why do you think it is necessary to come up with your own examples instead of examples provided by the author of the module? And I don't like link-only answers (I'm not alone).</span>
<span class="comment-copy">Peoples coming here already had an idea whats in the documentation and will be here only for further clearance about the topic.Same was my case but what i really found here is a copy and paste from the original docs.Peace!</span>
<span class="comment-copy">"Peoples coming here already had an idea whats in the documentation" - i <i>highly</i> doubt that assumtion. somehow.</span>
<span class="comment-copy">This has rapidly become my favorite way to go.  It's string parsing so it's kind of brittle, but it's brittle <i>all in one place</i> and you can preview your logic at <a href="http://try.docopt.org" rel="nofollow noreferrer">try.docopt.org</a> .  Optional and mutually-exclusive arguments are done in a really elegant way.</span>
<span class="comment-copy">I am desperate to see the rest of the code for naval_fate.py</span>
<span class="comment-copy">A more realistic usage would be <code>python main.py "James Smith"</code> which puts <code>James Smith</code> in <code>sys.argv[1]</code> and produces an <code>IndexError</code> when you try to use the nonexistent <code>sys.argv[2]</code>.  Quoting behavior will somewhat depend on which platform and shell you run Python from.</span>
<span class="comment-copy">I don't agree that my usage is less realistic. Pretend your program needs to know the exact first and last name of a person to run the script in a business where people can have multiple first and last names? If James Smith has Joseph as an extra first or last name, how would distinguish between whether Joseph is an extra first or last name if you only do <code>python main.py "James Joseph Smith"</code>? If you are concerned with index out of bounds, you can add a check for the number of provided arguments. Less realistic or not, my example shows how to handle multiple arguments.</span>
<span class="comment-copy">There is already another command-line parsing module named Commando: <a href="https://github.com/lakshmivyas/commando" rel="nofollow noreferrer">github.com/lakshmivyas/commando</a>. It wraps argparse by using decorators.</span>
<span class="comment-copy">python and wheel re-invention</span>
<span class="comment-copy">This is the best solution. Using <code>argh</code> is easier than another libs or using <code>sys</code>.</span>
<span class="comment-copy">I wanted to like <code>argh</code> but it's not particularly suitable for scenarios where your utmost desire is not to have a command with subcommands.</span>
<span class="comment-copy">@tripleee YMMV, but I found that this was more of a defect in the documentation than in the library itself. It seems perfectly feasible to have <code>def frobnicate_spleches(...)</code> defining a function that does whatever your script does, then doing <code>if __name__ == '__main__': argh.dispatch_command(frobnicate_spleches)</code> at the end of the file.</span>
