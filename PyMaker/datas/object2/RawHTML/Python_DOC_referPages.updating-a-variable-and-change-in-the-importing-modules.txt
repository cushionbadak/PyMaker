<div class="post-text" itemprop="text">
<p>Let's say I have two python classes in common.py:</p>
<p>common.py</p>
<pre><code>class A:
    def func1:
             ...
    def func2:

class B:
    def func1:
          ....
    def func2

if volatile == 1:
    commonObj = A()
else:
    commonObj = B()
</code></pre>
<p>Now there are set of modules let's say:</p>
<p>user1.py,
user2.py, ...</p>
<p>which use <code>commonObj</code> like this below:</p>
<pre><code>from common import commonObj

commonObj.func1()
commonObj.func2()
</code></pre>
<p>All these modules form one server, which continuously runs as a process.</p>
<p>I would like to ask how would I achieve this:
Suppose there is a way I can change the value of variable <code>volatile</code> any time, the user modules i.e user1.py, ... etc all should now access the updated value in <code>commonObj</code>, without having to restart the server.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without changing code in <code>user*.py</code> modules I can suggest this workaround:</p>
<pre><code>class A:
    def func1:
        ...

class B:
    def func1:
        ...

class Common:
    def func1:
        if volatile == 1:
            return A.func1(self)
        else:
            return B.func1(self)

    ...

commonObj = Common()
</code></pre>
<p>Changing <code>volatile</code> value will have effect on what <code>func1</code> will be executed without restarting the server.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your approach towards problem is wrong. You want some dynamic behavior and trying to achieve it statically. Let us assume you, somehow, can change the value of <code>volatile</code> variable. Your <code>user.py</code> file will not ever get any benefit from the value of <code>commonObj</code> being changed because it will only call methods from this obj only once.</p>
<p>If, on the other hand, you have some piece of code that can run repeatedly (like a function), and using <code>commonObj</code> like this</p>
<pre><code>def some_function():
    commonObj.func1()
    commonObj.func1()
</code></pre>
<p>You can dynamically get <code>commonObj</code> like this</p>
<p><strong>common.py</strong></p>
<pre><code>def get_common_obj():
    if volatile == 1:
       return A()
    return B()
</code></pre>
<p>Now use this to get you object in user.py</p>
<pre><code>from common import get_common_obj

common_obj = get_common_obj()
common_obj.func1()
common_obj.func2()
</code></pre>
</div>
<span class="comment-copy">changing code in the user*.py modules should be avoided.</span>
<span class="comment-copy">why do you want to do this?</span>
<span class="comment-copy">struggling with this for quite some time, ran out of ideas. Second, update my python knowledge.</span>
<span class="comment-copy">i mean why do you want this functionality? what's the broader picture? see <a href="https://meta.stackexchange.com/q/66377/492979">meta.stackexchange.com/q/66377/492979</a></span>
<span class="comment-copy">Once they've imported <code>common.py</code>, they don't look at the file anymore. Changing the file won't affect the process at all.</span>
<span class="comment-copy">Thanks Sanyash, looks like a solution to me.</span>
<span class="comment-copy">Nafees, your comment : "Your user.py file will not ever get any benefit from the value of commonObj being changed because it will only call methods from this obj only once." This point I am not understand properly. Why once ?</span>
