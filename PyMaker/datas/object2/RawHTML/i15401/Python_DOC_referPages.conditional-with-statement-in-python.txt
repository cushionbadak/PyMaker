<div class="post-text" itemprop="text">
<p>Is there a way to begin a block of code with a with statement, but conditionally?</p>
<p>Something like:</p>
<pre><code>if needs_with():
    with get_stuff() as gs:

# do nearly the same large block of stuff,
# involving gs or not, depending on needs_with()
</code></pre>
<p>To clarify, one scenario would have a block encased in the with statement, while another possibility would be the same block, but not encased (i.e., as if it wasn't indented)</p>
<p>Initial experiments of course give indentation errors..</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid duplicating code and are using a version of Python prior to 3.7 (when <code>contextlib.nullcontext</code> was introduced) or even 3.3 (when <code>contextlib.ExitStack</code> was introduced), you could do something like:</p>
<pre><code>class dummy_context_mgr():
    def __enter__(self):
        return None
    def __exit__(self, exc_type, exc_value, traceback):
        return False
</code></pre>
<p>or:</p>
<pre><code>import contextlib

@contextlib.contextmanager
def dummy_context_mgr():
    yield None
</code></pre>
<p>and then use it as:</p>
<pre><code>with get_stuff() if needs_with() else dummy_context_mgr() as gs:
   # do stuff involving gs or not
</code></pre>
<p>You alternatively could make <code>get_stuff()</code> return different things based on <code>needs_with()</code>.</p>
<p>(See <a href="https://stackoverflow.com/a/34798330/179715">Mike's answer</a> or <a href="https://stackoverflow.com/a/53088625/179715">Daniel's answer</a> for what you can do in later versions.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.3 introduced <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="noreferrer"><code>contextlib.ExitStack</code></a> for just this kind of situation.  It gives you a "stack", to which you add context managers as necessary.  In your case, you would do this:</p>
<pre><code>from contextlib import ExitStack

with ExitStack() as stack:
    if needs_with():
        gs = stack.enter_context(get_stuff())

    # do nearly the same large block of stuff,
    # involving gs or not, depending on needs_with()
</code></pre>
<p>Anything that is entered to <code>stack</code> is automatically <code>exit</code>ed at the end of the <code>with</code> statement as usual.  (If nothing is entered, that's not a problem.)  In this example, whatever is returned by <code>get_stuff()</code> is <code>exit</code>ed automatically.</p>
<p>If you have to use an earlier version of python, you might be able to use the <a href="https://contextlib2.readthedocs.org/en/latest/" rel="noreferrer"><code>contextlib2</code></a> module, although this is not standard.  It backports this and other features to earlier versions of python.  You could even do a conditional import, if you like this approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>A third-party option to achieve exactly this:<br/>
<a href="https://pypi.python.org/pypi/conditional" rel="noreferrer">https://pypi.python.org/pypi/conditional</a></p>
<pre><code>from conditional import conditional

with conditional(needs_with(), get_stuff()):
    # do stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.7 you can use <code>contextlib.nullcontext</code>:</p>
<pre><code>from contextlib import nullcontext

if needs_with():
    cm = get_stuff()
else:
    cm = nullcontext()

with cm as gs:
    # Do stuff
</code></pre>
<p><code>contextlib.nullcontext</code> is pretty much just a no-op context manager. You can pass it an argument that it will yield, if you depend on something existing after the <code>as</code>:</p>
<pre><code>&gt;&gt;&gt; with nullcontext(5) as value:
...     print(value)
...
5
</code></pre>
<p>Otherwise it'll just return <code>None</code>:</p>
<pre><code>&gt;&gt;&gt; with nullcontext() as value:
...     print(value)
...
None
</code></pre>
<p>It's super neat, check out the docs for it here: <a href="https://docs.python.org/3/library/contextlib.html#contextlib.nullcontext" rel="nofollow noreferrer">https://docs.python.org/3/library/contextlib.html#contextlib.nullcontext</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>contextlib.nested</code> to put 0 or more context managers into a single <code>with</code> statement.</p>
<pre><code>&gt;&gt;&gt; import contextlib
&gt;&gt;&gt; managers = []
&gt;&gt;&gt; test_me = True
&gt;&gt;&gt; if test_me:
...     managers.append(open('x.txt','w'))
... 
&gt;&gt;&gt; with contextlib.nested(*managers):                                                       
...  pass                                                    
...                                                             
&gt;&gt;&gt; # see if it closed
... managers[0].write('hello')                                                                                                                              
Traceback (most recent call last):                              
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;                                   
ValueError: I/O operation on closed file
</code></pre>
<p>This solution has its quirks and I just noticed that as of 2.7 its been deprecated. I wrote my own context manager to handle juggling multiple context managers. Its worked for me so far, but I haven't really considered edge conditons</p>
<pre><code>class ContextGroup(object):
    """A group of context managers that all exit when the group exits."""

    def __init__(self):
        """Create a context group"""
        self._exits = []

    def add(self, ctx_obj, name=None):
        """Open a context manager on ctx_obj and add to this group. If
        name, the context manager will be available as self.name. name
        will still reference the context object after this context
        closes.
        """
        if name and hasattr(self, name):
            raise AttributeError("ContextGroup already has context %s" % name)
        self._exits.append(ctx_obj.__exit__)
        var = ctx_obj.__enter__()
        if name:
            self.__dict__[name] = var

    def exit_early(self, name):
        """Call __exit__ on named context manager and remove from group"""
        ctx_obj = getattr(self, name)
        delattr(self, name)
        del self._exits[self._exits.index(ctx_obj)]
        ctx_obj.__exit__(None, None, None)

    def __enter__(self):
        return self

    def __exit__(self, _type, value, tb):
        inner_exeptions = []
        for _exit in self._exits:
            try:
                _exit(_type, value, tb )
            except Exception, e:
                inner_exceptions.append(e)
        if inner_exceptions:
            r = RuntimeError("Errors while exiting context: %s" 
                % (','.join(str(e)) for e in inner_exceptions))

    def __setattr__(self, name, val):
        if hasattr(val, '__exit__'):
            self.add(val, name)
        else:
            self.__dict__[name] = val
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It was hard to find @farsil's nifty Python 3.3 one-liner, so here it is in its own answer:</p>
<pre><code>with ExitStack() if not needs_with() else get_stuff() as gs:
     # do stuff
</code></pre>
<p>Note that ExitStack should come first, otherwise <code>get_stuff()</code> will be evaluated. </p>
</div>
<span class="comment-copy">write a function for the body of the with?</span>
<span class="comment-copy">This context manager should be in the standard python library, imho. Thanks for this.</span>
<span class="comment-copy">How about using the names <i>should_...</i> and <i>dont</i>. Then statements like this would read <code>with get_stuff() if should_get_stuff() else dont() as gs:</code> ?</span>
<span class="comment-copy">@RiazRizvi I wouldn't have personally named it that way; I was using the names from the question.</span>
<span class="comment-copy">@jjmontes <a href="https://docs.python.org/3/library/contextlib.html#simplifying-support-for-single-optional-context-managers" rel="nofollow noreferrer">contextlib.ExitStack</a> (new python 3.3) can be used as a dummy context manager.</span>
<span class="comment-copy">+1, this should be the selected answer. As pointed <a href="https://docs.python.org/3/library/contextlib.html?highlight=contextmanager#simplifying-support-for-single-optional-context-managers" rel="nofollow noreferrer">here</a> it is meant to deal with this kind of problem. Also, it can be used as a nifty one-liner: <code>with get_stuff() if needs_with() else ExitStack() as gs</code>.</span>
<span class="comment-copy">Does it support an <code>as ...</code> clause at the end of the <code>with</code> statement?</span>
<span class="comment-copy">looking at the source... yes it does. <code>with conditional(needs_with(), get_stuff()) as stuff:</code>  will give you a reference to the <code>get_stuff()</code> context manager (if and only if the condition is met, otherwise you get <code>None</code>)</span>
<span class="comment-copy">As I mention in my answer, python 3.3 has added <code>contextlib.ExitStack</code>, which appears to do very much what your <code>ContextGroup</code> does.  I will say I'm a little surprised that it hasn't been backported, but if you're willing to require python &gt;=3.3, that might be a nice robust alternative for you.</span>
<span class="comment-copy"><code>contextlib2</code> is a pypi package which has backported <code>ExitStack</code> to python 2</span>
