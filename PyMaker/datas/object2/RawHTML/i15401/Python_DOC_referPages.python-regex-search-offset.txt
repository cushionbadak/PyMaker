<div class="post-text" itemprop="text">
<p>I am trying to search for a particular string in a line and print 10 characters after the string in the line.</p>
<p>For example : </p>
<pre><code>"Empty user name specified in NTLM authentication. Port=443, Client ip=/10.234.112.164, port=2629. Prompting for auth again."
</code></pre>
<p>I want to search for "ip=/" in the above line and get the next 15 characters.
So effectively, i need "10.234.112.164," value.</p>
<p>I have tried using re.search and .end() index. I'm not sure how to further get the data.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you want to get the IP address from the 'log?'.If you want to get IP,there must be error if you search for "ip=/" in the above line and get the next 15 characters,because IP is between 'x.x.x.x' and 'xxx.xxx.xxx.xxx'.For example,If IP is 10.24.12.14,the result you get(the next 15 chars) is '10.24.12.14, po',do you want this?</p>
<p>so you should make some modifications:</p>
<pre><code>&gt;&gt;&gt; a = '......in NTLM authentication. Port=443, Client ip=/10.234.112.164, port=2629.'
&gt;&gt;&gt; b = '......in NTLM authentication. Port=443, Client ip=/10.23.12.14, port=2629.29.'
&gt;&gt;&gt; c = '......in NTLM authentication. Port=443, Client ip=/1.3.1.1, port=2629.29.'
&gt;&gt;&gt; d = '......in NTLM authentication. Port=443, Client ip=/110.223.111.211, port=2629.29.'
&gt;&gt;&gt; re.search(r'ip=\/(\d+.\d+.\d+.\d+)', a).group(1)
'10.234.112.164'
&gt;&gt;&gt; re.search(r'ip=\/(\d+.\d+.\d+.\d+)', b).group(1)
'10.23.12.14'
&gt;&gt;&gt; re.search(r'ip=\/(\d+.\d+.\d+.\d+)', c).group(1)
'1.3.1.1'
&gt;&gt;&gt; re.search(r'ip=\/(\d+.\d+.\d+.\d+)', d).group(1)
'110.223.111.211'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="http://www.regular-expressions.info/brackets.html" rel="nofollow">capturing groups</a>.</p>
<pre><code>ip=\/(.{15})
</code></pre>
<p><code>()</code> called capturing groups and <code>{}</code> called repitation quantifier. So <code>.{15}</code> repeats the previous token <code>.</code>(<em>matches any character except line breaks</em>) exactly 15 times.</p>
<p>Code:</p>
<pre><code>&gt;&gt;&gt; s = "Empty user name specified in NTLM authentication. Port=443, Client ip=/10.234.112.164, port=2629. Prompting for auth again."
&gt;&gt;&gt; re.search(r'ip=\/(.{15})', s).group(1)
'10.234.112.164,'
</code></pre>
<p><strong>OR</strong></p>
<p><a href="http://www.regular-expressions.info/lookaround.html" rel="nofollow">Positive lookbehind assertion</a>.</p>
<pre><code>(?&lt;=ip=\/).{15}
</code></pre>
<p><code>(?&lt;=ip=\/)</code> called positive lookbehind which asserts that the match must be preceded by the string <code>ip=/</code> . And the pattern <code>.{15}</code> matches exactly 15 characters.</p>
<p><a href="https://regex101.com/r/gX3sD2/2" rel="nofollow">DEMO</a></p>
<p>Code:</p>
<pre><code>&gt;&gt;&gt; s = "Empty user name specified in NTLM authentication. Port=443, Client ip=/10.234.112.164, port=2629. Prompting for auth again."
&gt;&gt;&gt; re.search(r'(?&lt;=ip=\/).{15}', s).group()
'10.234.112.164,'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this without regex by using <a href="https://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow">partition</a>:</p>
<pre><code>&gt;&gt;&gt; s = "Empty user name specified in NTLM authentication. Port=443, Client ip=/10.234.112.164, port=2629. Prompting for auth again."
&gt;&gt;&gt; s.partition('ip=/')[2].partition(',')[0]
'10.234.112.164'
</code></pre>
<p>This just gets everything after the <code>ip=/</code> and before the following comma, so it does not matter what the specific length or format of the ip address is (and if there is no <code>ip=/</code>, it will return an empty string).</p>
</div>
<span class="comment-copy">Welcome to Stack Overflow! What regex pattern are you using, and what results does it return? Please edit that into your question.</span>
<span class="comment-copy">Thanks a lot NeoWu and Avinash Raj. NeoWu, you got it bang on target. That was exactly what i wanted! But there were other such searches i needed to do (like for example exctracting Usernames from the log) for which Avinash's method would be perfect!</span>
