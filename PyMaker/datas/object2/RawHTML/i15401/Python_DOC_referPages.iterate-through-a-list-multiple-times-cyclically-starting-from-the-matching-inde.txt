<div class="post-text" itemprop="text">
<p>I need to do the following in python.  I have a list of strings, <code>list</code>, a string to search for, <code>text</code>, and variable containing the number of elements to print, <code>x</code>.  I want to iterate through <code>x</code> no. of consecutive elements of the <code>list</code>, wrapping around to the front of <code>list</code> if necessary.  </p>
<p>First I need to find the first element in <code>list</code> that has <code>text</code> as a substring.  I will then start with the first element of <code>list</code> <em>after</em> that matched element, and continue to iterate through a total of <code>x</code> consecutive elements of the <code>list</code>, wrapping around if necessary.</p>
<p>How would I do this?</p>
<pre><code>x = 11
text = "string5"
list = ["string1", "string2", "string3", "string4", "string5", "string6", "string7"]

# not sure what to do here...
for elem in list:
    if text in elem:
        #iterate through list, begin with elem and get the next 11 elements
        #once you've reached string7, start over with string1`
</code></pre>
<p>In this example I want to end up looking at the following 11 elements:</p>
<pre><code>string6
string7
string1
string2
string3
string4
string5
string6
string7
string1
string2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>For our problem data:</strong></p>
<pre><code>x = 11 #no. of elements to get
text = 'string5' #text to search in elements of list
lst = ['string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7'] 
n = len(lst) 
</code></pre>
<p><strong>Algorithm 1:</strong> (Cycle &amp; Slice)</p>
<p>Most pythonic way is using the functions, <code>islice</code> and <code>cycle</code> from the <code>itertools</code> module offcourse:</p>
<ul>
<li>Cycle through / Repeat the list infinitely (<code>cycle</code> function)</li>
<li>Slice out / Pick the desired elements using start/stop indices from the repeated list (<code>slice</code> function)</li>
</ul>
<p>Code:</p>
<pre><code>for i, val in enumerate(lst):
    if text in val:
        desired = list( islice( cycle( lst), i+1, i+1+x))
</code></pre>
<p><strong>Algorithm 2:</strong> (Loop &amp; Modulo Indexing)</p>
<p>A more traditional way would be:</p>
<ul>
<li>Loop through the list <code>x</code> no. of times starting after the matched index, <code>i+1</code></li>
<li>Cycle through the list elements using <code>modulo</code> indexing  </li>
</ul>
<p>Code:</p>
<pre><code>for i, val in enumerate(lst):
    if text in val:
        desired = [ lst[ j%n] for j in range(i+1, i+1+x)] 
</code></pre>
<p><strong>Algorithm 3 - Bad Implementations:</strong> (Rotate &amp; Repeat)</p>
<p>Many poor/ slow implementations are also possible e.g. using <code>numpy</code> functions, like <code>roll</code>, <code>tile</code>:</p>
<ul>
<li>Roll/ Rotate the <code>numpy</code> array so as to start it with the element at the matching index, <code>i</code></li>
<li>Tile / Repeat the array so as to increase its length more than the desired <code>x</code> no. of elements</li>
<li>Pick <code>x</code> no. of elements</li>
</ul>
<p>Code: </p>
<pre><code>def nextx(lst,i,n,x):
    ll = np.array(lst)
    rll = np.roll(ll, n-i)
    trll = np.tile(rll, x%n+1)
    return list(trll[:x])
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; nextx(lst,5,7,11)
['string6', 'string7', 'string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7', 'string1', 'string2']
&gt;&gt;&gt; nextx(lst,5,7,11) == [lst[j%len(lst)] for j in range(5,5+11)] == list(islice(cycle(lst),5,5+11))
True
</code></pre>
<p><strong>Timing:</strong></p>
<p>iPython line magic function <code>%timeit</code> shows that <code>Algorithm 1</code> is not surprisingly <code>~1.5 and ~11 times faster</code> than 2 and 3 respectively:</p>
<pre><code>&gt;&gt;&gt; %timeit list( islice( cycle( lst), 5, 5+11))
100000 loops, best of 3: 1.83 µs per loop

&gt;&gt;&gt; %timeit [ lst[ j%len(lst)] for j in range(5, 5+11)] 
100000 loops, best of 3: 2.76 µs per loop

&gt;&gt;&gt; %timeit nextx(lst,5,7,11)
10000 loops, best of 3: 20.6 µs per loop
</code></pre>
<p><strong>Conclusion:</strong></p>
<p>Using <code>itertools</code> is the Fastest and Slickest way to go whenever you can use <code>cycle</code>, <code>islice</code>, <code>count</code>, <code>repeat</code>, etc!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3.4/library/itertools.html#itertools.cycle"><code>cycle</code> from <code>itertools</code></a>, maybe in combination with <a href="https://docs.python.org/3.4/library/itertools.html#itertools.islice"><code>islice</code></a> and <a href="https://docs.python.org/3/library/functions.html#enumerate"><code>enumerate</code></a>.</p>
<pre><code>from itertools import cycle, islice

x = 11
text = "string5"
lst = ["string1", "string2", "string3", "string4", "string5", "string6", "string7"]
for i, elem in enumerate(lst):
    if text in elem:
        next11 = list(islice(cycle(lst), i+1, i+1+x))
        print(next11)
        print(len(next11))
</code></pre>
<p>Output:</p>
<pre><code>['string6', 'string7', 'string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7', 'string1', 'string2']
11
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hope this will help</p>
<pre><code>&gt;&gt;&gt; x = 11
&gt;&gt;&gt; text = "string5"
&gt;&gt;&gt; list = ["string1", "string2", "string3", "string4", "string5", "string6", "string7"]

&gt;&gt;&gt; for i in range(len(list)):
        if text in list[i]:
            a=i+1;
            break;

&gt;&gt;&gt; L = [list[i%len(list)] for i in range(a, a+x)]

&gt;&gt;&gt; L
['string6', 'string7', 'string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7',     'string1', 'string2']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Was annoid not getting it, so here is a beautiful solution.. :P</p>
<pre><code>&gt;&gt;&gt; x = 11
&gt;&gt;&gt; text = "string5"
&gt;&gt;&gt; list = ["string1", "string2", "string3", "string4", "string5", "string6", "string7"]
&gt;&gt;&gt; offset = list.index(text)
&gt;&gt;&gt; list_len = len(list)
&gt;&gt;&gt; for i in range(x):
&gt;&gt;&gt;     print(list[(i+offset)%list_len])
</code></pre>
<p>It assumes that each string in the list is unique, else you can just set the offset.</p>
</div>
<div class="post-text" itemprop="text">
<p>use a while-loop?</p>
<pre><code>i = 0
n = 0
while 1:
  if i &gt; len(list):
    i = 0
  if (k &gt; x):
    break
  print(list[i])
  i += 1
  k += 1
</code></pre>
</div>
<span class="comment-copy">I meant the element after "text". Sorry</span>
<span class="comment-copy">You use <code>if text in elem</code>. Is it intentional to search if <code>ŧest</code> is present in <code>elem</code>, or did you mean to compare the strings,  <code>if text == elem</code>?</span>
<span class="comment-copy">@spectras OP is now pretty clear that he is looking for a substring: "<i>first element in list that has text as a substring</i>"</span>
<span class="comment-copy">Then not only is your answer the one with best style, but it's also the only one that actually does what he wants.</span>
<span class="comment-copy">No, i don't want to compare the strings. I'm looking for a substring. It's intended.</span>
<span class="comment-copy">Good point using <code>itertools</code>. However, I would just use <code>lst.index(text)</code> to find out the starting position.</span>
<span class="comment-copy">@spectras <code>index</code> would not work. He's not testing for equality, but whether <code>text</code> is <i>in</i> <code>elem</code>. Also, there could be multiple matches.</span>
<span class="comment-copy">Indeed, only given his sample I supposed the use of <code>in</code> instead of a comparison was a mistake in his code. Would be worth asking him. And if there are multiple matches, <code>index</code> returns the first one.</span>
<span class="comment-copy">Upvoting anyway, because this answer is by far the most pythonic one.</span>
