<div class="post-text" itemprop="text">
<p>Look this code:</p>
<pre><code>class MyClass_1():
    @staticmethod
    def method_1(func):
        return func(1, 2, 3)

class MyClass_2():
    my_func = lambda a,b,c : a*b*c # I need to call this method

    def method_2(self):
        result = MyClass_1.method_1(self.my_func)
        print(result)
</code></pre>
<p>My error:</p>
<blockquote>
<p>TypeError: () takes 3 positional arguments but 4 were given</p>
</blockquote>
<p>I need to call the lambda function <code>my_func</code> in the same way as the code above, but a <code>self</code> is appearing from somewhere I don't know and causing this error.</p>
<p>What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>my_func</code> is a class attribute of <code>MyClass_2</code>, you should not be accessing it through <code>self</code> (an instance of the class).  Instead, you should be accessing it through the class directly:</p>
<pre><code>result = MyClass_1.method_1(MyClass_2.my_func)
                            ^^^^^^^^^
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class MyClass_1():
...     @staticmethod
...     def method_1(func):
...         return func(1, 2, 3)
...
&gt;&gt;&gt; class MyClass_2():
...     my_func = lambda a,b,c : a*b*c # I need to call this method
...     def method_2(self):
...         result = MyClass_1.method_1(MyClass_2.my_func)
...         print(result)
...
&gt;&gt;&gt; MyClass_2().method_2()
6
&gt;&gt;&gt;
</code></pre>
<p>For more information, you can check out these sources:</p>
<ul>
<li><a href="https://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="nofollow noreferrer">https://docs.python.org/3/reference/compound_stmts.html#class-definitions</a></li>
<li><a href="https://stackoverflow.com/q/207000/2555451">Python: Difference between class and instance attributes</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>A <code>lambda</code> is just different syntax for defining a function object. Functions in class bodies are <em>always</em> bound and passed a <code>self</code> argument (as they are <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow">descriptors</a>).</p>
<p>Simply give your <code>lambda</code> that argument:</p>
<pre><code>my_func = lambda self, a, b, c: a * b * c
</code></pre>
<p>The alternative would be for you to unwrap the method and pass in the plain function object:</p>
<pre><code>result = MyClass_1.method_1(self.my_func.__func__)
</code></pre>
<p>or to wrap your <code>lambda</code> in a <code>staticmethod</code> object:</p>
<pre><code>my_func = staticmethod(lambda a, b, c: a * b * c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to give your <code>lambda</code> a self argument.  Lambdas are just ordinary functions.  There is no difference between this:</p>
<pre><code>class Foo():
    my_func = lambda a,b,c : a*b*c
</code></pre>
<p>and this</p>
<pre><code>class Foo():
    def my_func(a, b, c):
        return a*b*c
</code></pre>
<p>In both cases, <code>my_func</code> is a method, and <code>self</code> will be passed if you call it on an instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>lambdas are small anonymous functions and can be written in the parameter list of a method directly. Assigning them to a variable is usually not desirable. A typical use of lambda here would be:</p>
<pre><code>class MyClass_1():
    @staticmethod
    def method_1(func):
        return func(1, 2, 3)

class MyClass_2():

    def method_2(self):
        result = MyClass_1.method_1(lambda a,b,c: a*b*c)
        print(result)

MyClass_2().method_2()    
</code></pre>
</div>
<span class="comment-copy">Do you understand why <code>def my_func(a,b,c): return a*b*c</code> wouldn't work? A lambda is just the same as using <code>def</code>, if you define it in a class you need to include the <code>self</code>.</span>
<span class="comment-copy">Yeah.. that's a good thing to think about... wouldn't work even I make it static?</span>
<span class="comment-copy">With <code>@staticmethod</code> it would work, with <code>@classmethod</code> you would need a <code>cls</code> first parameter. In all respects (except the function name shown in tracebacks) a lambda is neither more nor less than a one line function returning the same expression.</span>
<span class="comment-copy">Thats very interesting. Nice information. Thanks!!</span>
<span class="comment-copy">Worked. But how/where <code>self</code> enter in this history?</span>
<span class="comment-copy">When you call <code>my_func</code> on <code>self</code>, Python will implicitly pass a reference to the class instance as the first argument.  But <code>my_func</code> is a class attribute, which means it doesn't need/use this reference.  So, we call it from the class directly to avoid this.</span>
<span class="comment-copy">Got it! Thank you!</span>
