<div class="post-text" itemprop="text">
<p><code>operator</code> provides <code>attrgetter</code> to make a function that retrieves a field from an object.</p>
<p>Why isn't this included in  <code>operator</code> (or somewhere else in the standard libraries)? </p>
<pre><code>def attrsetter(name):
    def setter( obj, val):
        setattr(obj, name, val)
    return setter
</code></pre>
<p>The only reason that I can think of is that there are edge cases where this straightforward approach will break.  In which case, what are these edge cases so that I can try to trap/avoid them?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>attrgetter</code> is designed to be used in places where a function is required as a replacement for <code>lambda</code>. For example:</p>
<pre><code># equivalent
heads = map(attrgetter('head'), objs)
heads = map(lambda o: o.head, objs)
</code></pre>
<p>In other words, the point of <code>attrgetter</code> is to create a side-effect-free function that returns a useful value, and which can be used in expressions that require a function. An <code>attrsetter</code>, on the other hand, would only operate by side effect, and would need to return <code>None</code> by Python convention. Since <code>attrsetter</code> would not be at all useful as argument to <code>map</code> and similar, it is not provided. If you need <code>attrsetter</code>, simply write a normal <code>for</code> loop.</p>
<p>Also note that both of the above idioms are better expressed with a list comprehension:</p>
<pre><code>heads = [o.head for o in objs]
</code></pre>
<p><code>attrgetter</code> is rarely needed and has lost much of its appeal once it was announced that <code>lambda</code> will not be removed from Python 3 after all.</p>
</div>
<span class="comment-copy"><code>itemsetter</code> is missing too. My bet is that it isn't as useful as the getter counterparts so they didn't add it.</span>
<span class="comment-copy">Maybe they just don't see many use cases.  Normally these operators return a value so they can be used functionally, e.g. with <code>map</code>, <code>filter</code>, etc.  Setting something typically returns <code>None</code>.</span>
<span class="comment-copy">Also, since <code>attrgetter</code> provides fancy stuff allowing more attributes and dotted names, you probably want to create a symmetric setter able to set multiple attributes with dotted names.</span>
<span class="comment-copy">@Bakuriu it's actually called <a href="https://docs.python.org/3/library/operator.html#operator.setitem" rel="nofollow noreferrer"><code>setitem</code></a> to be coherent with <code>__setitem__</code>.</span>
<span class="comment-copy">I think the side effect argument is kind of moot given the <code>operator</code> module provides <code>setitem</code> and <code>delitem</code>. Also I agree that most of the time <code>attrgetter</code> is better expressed through a comprehension but there's valid use cases for using the former. One of thing that makes <code>attrgetter</code> appealing over <code>lambda</code> is that the CPython ships a C implementation that is significantly faster in a hot loop and allows multiple attributes to be retrieved at once using <code>attrgetter(*attrs)</code>.</span>
<span class="comment-copy">@SimonCharette I agree that the side effect is not essential. Based on when it appeared, I argued <code>attrgetter</code> was the result of the short-lived (and IMO misguided) attempt to rid Python of <code>lambda</code>. <code>lambda x: x.foo</code> was often cited as an example of <code>lambda</code>'s usefulness, so <code>attrgetter</code> was introduced to replace it. Since <code>setattr</code> was rarely used in lambdas, there was no need for an <code>attrsetter</code>. It's not a good reason not to have one in the future, just an explanation of why it wasn't added originally. If you need it, I think it makes sense to propose adding it on bugs.python.org.</span>
