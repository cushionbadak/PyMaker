<div class="post-text" itemprop="text">
<p>There are similar errors but I could not find a solution for bz2.</p>
<p>The following program fails on the decompress:</p>
<pre><code>import bz2

un =  'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'
pw =  'BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08'
decoded_un = bz2.decompress(un)
decoded_pw = bz2.decompress(pw)

print(decoded_un)
print(decoded_pw)
</code></pre>
<p>I tried using <code>bytes(un, 'UTF-8)</code> but that would not work. I think I did not have this problem in Python 3.3.</p>
<p>EDIT: this was for the Python challenge I have two bits of code which work thanks to Martijn:</p>
<pre><code>import bz2

un_saved =  'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'
pw_saved =  'BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08'
print(bz2.decompress(un_saved.encode('latin1')))
print(bz2.decompress(pw_saved.encode('latin1')))
</code></pre>
<p>This one works from the webpage:</p>
<pre><code># http://www.pythonchallenge.com/pc/def/integrity.html

import urllib.request
import re
import os.path
import bz2

fname = "008.html"

if not os.path.isfile(fname):
    url = 'http://www.pythonchallenge.com/pc/def/integrity.html'
    response = urllib.request.urlopen(url)
    webpage = response.read().decode("utf-8")
    with open(fname, "w") as fh:
        fh.write(webpage)

with open(fname, "r") as fh:
    webpage = fh.read()
    re_un = '\\nun: \'(.*)\'\\n'
    m = re.search(re_un, webpage)
    un = m.group(1)
    print(un)

    pw_un = '\\npw: \'(.*)\'\\n'
    m = re.search(pw_un, webpage)
    pw = m.group(1)
    print(pw)

    unde = un.encode('latin-1').decode('unicode_escape').encode('latin1')
    pwde = pw.encode('latin-1').decode('unicode_escape').encode('latin1')
    decoded_un = bz2.decompress(unde)
    decoded_pw = bz2.decompress(pwde)

    print(decoded_un)
    print(decoded_pw)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>bz2</code> library deals with <em><code>bytes</code> objects</em>, not strings:</p>
<pre><code>un = b'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'
pw = b'BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08'
</code></pre>
<p>In other words, using <code>bytes()</code> works just fine, just make sure you use the correct encoding. UTF-8 is not that encoding; if you have bytes masking as string character codepoints, use Latin-1 to encode instead; Latin 1 maps characters one-on-one to bytes:</p>
<pre><code>un = un.encode('latin1')
</code></pre>
<p>or</p>
<pre><code>un = bytes(un, 'latin1')
</code></pre>
<p>Also see the <a href="https://docs.python.org/3/howto/unicode.html" rel="nofollow">Python <em>Unicode HOWTO</em></a>:</p>
<blockquote>
<p>Latin-1, also known as ISO-8859-1, is a similar encoding. Unicode code points 0–255 are identical to the Latin-1 values, so converting to this encoding simply requires converting code points to byte values; if a code point larger than 255 is encountered, the string can’t be encoded into Latin-1.</p>
</blockquote>
<p>I'll leave the decoding to you. Have fun with the Python Challenge!</p>
<p>Note that if you loaded these characters <em>as they are</em> from a webpage, they will <strong>not</strong> by ready-made bytes! You'll have the characters <code>'\'</code>, <code>'x'</code>, <code>8</code> and <code>2</code> rather than a codepoint with hex value 82. You'd need to interpret those sequences as a Python string literal first:</p>
<pre><code>&gt;&gt;&gt; un = r'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'
&gt;&gt;&gt; un
'BZh91AY&amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07&lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084'
&gt;&gt;&gt; un.encode('latin-1').decode('unicode_escape')
'BZh91AY&amp;SYA¯\x82\r\x00\x00\x01\x01\x80\x02À\x02\x00 \x00!\x9ah3M\x07&lt;]É\x14áBA\x06¾\x084'
&gt;&gt;&gt; un.encode('latin-1').decode('unicode_escape').encode('latin1')
b'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'
</code></pre>
<p>Note the <em>double</em> backslashes in the representation of <code>un</code>. Only the last <code>bytes</code> result is then decompressable!</p>
</div>
<span class="comment-copy">Do you have a link I could use to understand the different encoding ? I am really struggling with this ... This was for the Python Challenge ...</span>
<span class="comment-copy">@BlueTrin: yeah, I recognised the strings. Not sure if I have a link for you, but take into account that the challenge was written for Python 2, before Python 3 was mainstream.</span>
<span class="comment-copy"><a href="http://www.joelonsoftware.com/articles/Unicode.html" rel="nofollow noreferrer">joelonsoftware.com/articles/Unicode.html</a> <a href="http://farmdev.com/talks/unicode/" rel="nofollow noreferrer">farmdev.com/talks/unicode</a></span>
<span class="comment-copy">@IgnacioVazquez-Abrams: less helpful in this context, where the bytes are taken from a webpage but whatever extraction method used by the OP gave them a string rather than bytes..</span>
<span class="comment-copy">@BlueTrin: I suspect there was something else wrong here, I updated the answer. In future, can you make sure you always include the <i>full error</i> you got with the code you tried?</span>
