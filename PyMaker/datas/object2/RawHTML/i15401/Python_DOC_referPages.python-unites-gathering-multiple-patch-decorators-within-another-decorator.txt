<div class="post-text" itemprop="text">
<p>I'm writing an internal unit tests framework which involves mocking multiple functions/classes.<br/>
@patch seems to be working great for my needs, but as there are many tests that will require to patch many different classes/functions, I'm looking to avoid writing multiple @patch before every test and maybe encapsulate them all into another decorator.
To better illustrate my needs:</p>
<p>current state:</p>
<pre><code>@patch('p.A', mockedA)
@patch('p.B', mockedB)
.
.
@patch('p.N', mockedN)
def test_this()
</code></pre>
<p>desired state:</p>
<pre><code>@patch_all
def test_this()
</code></pre>
<p>Is it possible to implement something like this?, so far I wasn't able to as @patch requires to be followed either def or another @.<br/></p>
<p><strong>EDIT 2:</strong><br/>
I've tried Michele's suggestion, but the test is no longer being identified as a test:<br/>
After adding functools.wraps to the patch_all decorator, it worked.</p>
<pre><code>def patch_all(f):
@patch('p.A', moduleA.classA.methodA)
@patch('p.B', moduleB.classB.methodB)
.
.
@patch('p.N', moduleN.classN.methodN)
wraps(f)
def functor(*args, **kwargs):
    return f(*args, **kwargs)
return functor


class TestWrapper(unittest.TestCase):
    @patch_all
    def my_test(self):
        my test goes here...
</code></pre>
<p>With the @patch_all decorator this is what I get:<br/></p>
<pre><code>nosetests Tester.py --nocapture 

----------------------------------------------------------------------
Ran 0 tests in 0.000s

OK
</code></pre>
<p>If I remove it:</p>
<pre><code>$ nosetests Tester.py --nocapture 
.
----------------------------------------------------------------------
Ran 1 test in 7.692s

OK
</code></pre>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>patch</code> decorator like all decorators is just a function that take a function and return a function (<strong>[EDIT]</strong> in the original version I forgot <code>@functools.wraps(f)</code> to make a correct test decorator, thanks to @MenyIssakov to let me know that my answer was wrong). You can define your own <code>patch_all</code> decorator like</p>
<pre><code>def patch_all(f):
    @patch('p.A', argsA)
    @patch('p.B', argsB)
    .
    .
    @patch('p.N', argsN)
    @functools.wraps(f)
    def functor(*args, **kwargs):
        return f(*args, **kwargs)
    return functor
</code></pre>
<p>Now you can use <code>@patch_all</code> decorator in your tests like:</p>
<pre><code>@patch_all
def test_all(mockN, ..., mockB, mockA):
    my beautiful test
</code></pre>
<p>You can go over this and define your own decorator that take a list of tuple to pass to the patch calls.</p>
<p>However i think that is not a good idea: test should be simple and mocking should be explicit to make clear the aim of the test. If you must patch a lot of objects/methods/functions in a lot of tests functions consider to <a href="https://docs.python.org/3/library/unittest.mock.html#test-prefix" rel="nofollow">apply the decorator to the class</a> instead of the single methods to write it just one time for all test methods. </p>
</div>
<span class="comment-copy">Your test name must start bu <code>test_</code> otherwise the runner doesn't recognize it</span>
<span class="comment-copy">Doesn't work either. Though,  I believe if that was a must, it wouldn't have ran when I remove the decorator.</span>
<span class="comment-copy">Ok,  it depend from the runner. I need some time to look at it.  Maybe use <code>@wrap</code> decorator should fix it. But I cannot try it now,  i'm using a phone. I'll can try it later in the day.</span>
<span class="comment-copy">You're right! i've added the functools.wraps and no it works.</span>
<span class="comment-copy">I'll fix my answer later</span>
<span class="comment-copy">Hi Michele, I've tried your example which I did something similar before. my issue after using this method is that the test is no longer being identified as a unit test (I'm using nose). Once I remove the patch_all annotation and run the nosetests tests.py It attempts to run my test, if I put back the patch_all annotation, i get the message that it ran 0 tests.</span>
