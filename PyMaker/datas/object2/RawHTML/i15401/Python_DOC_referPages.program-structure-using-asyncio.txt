<div class="post-text" itemprop="text">
<p>I currently have a program structured like this:</p>
<pre><code>set_up_everthing()

while True:
    if new_client_ready():
        connect_new_client()

    for client in clients:
        if client.is_ready():
            get_input_from(client)

    update_program_state_based_on_input()

    for client in clients:
        if client.is_ready():
            send_output_to(client)

clean_up()
</code></pre>
<p>The network I/O currently uses sockets and select, but I want to rewrite it to use the asyncio library. I think I understand how to make a simple asyncio program, the idea seems to be that when you want to do some I/O, you <code>yield from</code> a function that does it, so when the main loop gets a new client, it does <code>yield from accept_client()</code>, and when that client receives information it does <code>yield from read_information()</code>, and so on. However, I can't work out how to combine this with other parts of the program.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your snippet roughly describes how asyncio works itself.</p>
<p>Please take a look on <a href="https://code.google.com/p/tulip/source/browse/examples/echo_server_tulip.py" rel="nofollow">asyncio example</a> for how to <strong>use</strong> asyncio:</p>
<pre><code>import asyncio

@asyncio.coroutine
def echo_server():
    yield from asyncio.start_server(handle_connection, 'localhost', 8000)

@asyncio.coroutine
def handle_connection(reader, writer):
    while True:
        data = yield from reader.read(8192)
        if not data:
            break
        writer.write(data)

loop = asyncio.get_event_loop()
loop.run_until_complete(echo_server())
try:
    loop.run_forever()
finally:
    loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>asyncio</code> module has two levels of APIs: The <strong>low-level</strong> <a href="https://docs.python.org/3/library/asyncio-protocol.html" rel="nofollow">transports &amp; protocols API</a> and the <strong>high-level</strong> <a href="https://docs.python.org/3/library/asyncio-stream.html" rel="nofollow">streams API</a>. They are like different frameworks. Depending on the API level you are using, your program structure may differ dramatically.</p>
<p>To prevent yourself from going crazy, normally you don't want to mix these two levels of APIs.</p>
<p>The two levels differ in that <strong>you receive data in different ways</strong>. The low-level API provides an event-driven interface, your program responds to incoming events by implementing callbacks - <strong>The framwork calls your code</strong>. The high-level API have a nicer look, in that it provides readers &amp; writers, and <strong>your code calls the framework</strong>.</p>
<p>The examples in <code>asyncio</code> docs should be easy enough to follow.</p>
</div>
<span class="comment-copy">here's <a href="http://pastebin.com/g08YaJyz" rel="nofollow noreferrer">a simple but complete port forwarder implementation using <code>asyncio</code></a>.</span>
<span class="comment-copy">Thank you!  A very helpful answer, expressed simply and concisely.</span>
<span class="comment-copy">The stream and protocol styles aren't <i>that</i> different. The key if you use protocols is that you may need to make an asynchronous request while handling incoming data, so you have to <code>create_task</code> so that your data handling code can be a coroutine. You also have to know how to wake up a suspended task when data is ready, e.g. because your remote peer answered a request.</span>
