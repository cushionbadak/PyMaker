<div class="post-text" itemprop="text">
<p>I am now starting exploring Python, and was testing how arguments can be passed to a script with "argparse".
The way I wrote a sample script was as following, where arguments passed through flags -i and -o are compulsory and flag -u is optional:</p>
<pre><code>#!/usr/bin/python

import sys
import argparse

## set usage options and define arguments
usage = "usage: %prog [options]"
parser = argparse.ArgumentParser(usage)

parser.add_argument("-i",  action="store", dest="input", help="input file")
parser.add_argument("-o",  action="store", dest="output", help="output file")
parser.add_argument("-u", action="store_true", dest="isunfolded", default=False, help="optional flag")

args = parser.parse_args()

print len(sys.argv)  
if len(sys.argv) &lt; 2:
#        parser.print_help()   
        print 'Incorrect number of params'
        exit()
else:
        print "Correct number of params: ", len(sys.argv)
</code></pre>
<p>Running this script:</p>
<pre><code>&gt; ./test-args.py -i a -o b
</code></pre>
<p>prints:</p>
<pre><code>5
Correct number of params:  5
</code></pre>
<p>I understand the printing statement in the if conditional (5 is higher than 2), however, after reading the argparse documentation (<a href="https://docs.python.org/3/library/argparse.html" rel="nofollow">https://docs.python.org/3/library/argparse.html</a>) I still don't quite understand why -i and -o flags are counted as arguments. This behaviour seems to be quite different from e.g. perl Getopt::Std, which I'm more used to.</p>
<p>So, the question is what is the best way of parsing arguments in Python and to evaluate the presence of mandatory arguments (without using required=True)</p>
</div>
<div class="post-text" itemprop="text">
<p>It gives you 5 because <code>sys.argv</code> contains the raw input passed to python as arguments (the script name and 4 arguments). </p>
<p>You can see <code>argparse</code> as an abstraction for this, so once you use it, you can forget about <code>sys.argv</code>. In most cases it is better not to mix these two methods. </p>
<p><code>argparse</code> its a nice way to handle arguments, I don't quite get why you don't want to use the  <code>required</code> option when that's exactly the way to go. Another alternative is to parse the <code>sys.argv</code> yourself (regex maybe?) and drop <code>argparse</code> altogether.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a Python <code>getopt</code> which probably is similar to the Perl one (assuming both are modelled after the C/Unix version).</p>
<p><a href="https://docs.python.org/2/library/getopt.html" rel="nofollow">https://docs.python.org/2/library/getopt.html</a></p>
<p>In your code, <code>sys.argv</code> is a list of strings from the command line (as interpreted by the shell and interpreter).  It is the raw input for any of the parsers ('getopt', 'optparse', 'argparse').  And it is available for your parsing as well.  When learning it is a good idea to include a </p>
<pre><code>print sys.argv
</code></pre>
<p>line.  <code>parser.parse_args()</code> uses this list.  <code>sys.argv[0]</code> is used as <code>prog</code> attribute (in the default usage), while <code>sys.argv[1:]</code> (the rest) is parsed according to the rules you define with <code>add_argument</code>.   For testing I often like to use <code>parse_args</code> with a custom list of strings, e.g.</p>
<pre><code>print parser.parse_args(['-i', 'input', '-o', 'output', '-u'])
</code></pre>
<p>With your definition I'd expect to see something like:</p>
<pre><code>Namespace(input='input', output='output', isunfolded=True)
</code></pre>
<p>The parser returns an object (type <code>argparse.Namespace</code>), which has attributes defined by your arguments.  Values are usually accessed with expressions like <code>args.input</code>, <code>args.isunfolded</code>.  The docs also show how you easily express this as a dictionary.</p>
<p>By long standing UNIX conventions, arguments flagged by strings like '-i' are options, that is they are optional.  <code>argparse</code> generalizes this concept by letting you specify a <code>required=True</code> parameter.</p>
<p>Other arguments are positionals.  They are interpreted according to their order.  And as such they are normally required.  What <code>argparse</code> adds is the ability to define those positionals, such as type, nargs, etc.  With <code>nargs='?'</code> they are optional.  Many of the <code>nargs</code> values are similar to regular expression characters (e.g. +?*).  In fact <code>argparse</code> uses a form a regular expression parsing to allocate strings among arguments.  </p>
<hr/>
<p>I'd refine your arguments thus (taking advantage of various defaults)</p>
<pre><code>a1 = parser.add_argument("-i", "--input", help="input file")  # 'store' is the default
a2 = parser.add_argument("-o", "--output",help="output file") # use the --output as dest
a3 = parser.add_argument("-u", "--isunfolded",  action="store_true", help="optional flag")
</code></pre>
<p>If <code>input</code> and <code>output</code> were required, I could change them to:</p>
<pre><code>parser.add_argument("input", help="input file")  # 'store' is the default
parser.add_argument("output",help="output file") # use the --output as dest
parser.add_argument("-u", "--isunfolded",  action="store_true", help="optional flag")
</code></pre>
<p>Now <code>input</code> and <code>output</code> are positional arguments, as in <code>test.py -u inputfile outputfile</code></p>
<p>By using <code>a1 = parser...</code> I can look at the object produced by this statement.</p>
<pre><code>print a1
</code></pre>
<p>produces</p>
<pre><code>_StoreAction(option_strings=['-i', '--input'], dest='input', nargs=None, const=None,
    default=None, type=None, choices=None, help='input file', metavar=None)
</code></pre>
<p>This tells me that <code>a1</code> is a <code>_StoreAction</code> object (a subclass of <code>argparse.Action</code>).  It also displays a number (not all) of its attributes, ones that define its action.  A positional, on the other hand, has values like these:</p>
<pre><code>a2 = p.add_argument("output", help="output file")
_StoreAction(option_strings=[], dest='output', nargs=None, const=None, 
    default=None, type=None, choices=None, help='output file', metavar=None)
</code></pre>
<p>It may also be instructive to look at <code>a1.required</code> and <code>a2.required</code>, which are respectively False and True.  <code>required</code> is an <code>Action</code> attribute that is not routinely displayed, but is, never the less accessible.</p>
<p>I've pulled all these test values from a parser defined in an interactive shell (<code>Ipython</code>).  It's a great way to explore Python and modules like <code>argparse</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>After reading other related posts it seems that the best way to do this is as was suggested by @Rufflewind and inspect the args itself:</p>
<pre><code>if not args.input or not args.output:
        print 'Incorrect number of params'
        exit()
else:
        print "Correct number of params"
</code></pre>
</div>
<span class="comment-copy">You should print len(args), not len(sys.argv)</span>
<span class="comment-copy">Why don't you want to use <code>required=True</code>?  Also, <code>sys.argv</code> contains the <i>unparsed</i> list of arguments, namely <code>["./test-args.py", "-i", "a", "-o", "-b"]</code>.  If you want the parsed arguments, you should inspect <code>args.input</code>, <code>args.output</code>, and <code>args.isunfolded</code>.  After the arguments are parsed, they are no longer in the form of a list (except for positional arguments), so it makes no sense to ask for "number of arguments".</span>
<span class="comment-copy">@Rufflewind yes I know that inspect args.input, args.output, and args.isunfolded is the best way to do it, but since I'm still learning Python I want to understand these simple forms.</span>
<span class="comment-copy">@Ashalynd "print len(args)" produces the following error: "TypeError: object of type 'Namespace' has no len()"</span>
