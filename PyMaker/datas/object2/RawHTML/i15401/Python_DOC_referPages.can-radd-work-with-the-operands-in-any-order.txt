<div class="post-text" itemprop="text">
<p>I want my <code>Fraction</code> class to work as a float when it's being added to floats or integers so I can naturally perform operations with it, but it's only working when the <code>Fraction</code> is the rightmost operand. Is there a way to make it work with the operands in any order or should I override another method that I haven't learned of?</p>
<p>Code (I guess variable names are pretty self-explanatory):</p>
<pre><code>def __radd__(self,target):
    if type(target) == int or type(target) == float:
        return target + self.num/self.den
</code></pre>
<p><code>1 + Fraction(1,2)</code> returns <code>1.5</code> as it should but <code>Fraction(1,2) + 1</code> raises:</p>
<pre><code>Traceback (most recent call last):
  File "/Users/mac/Desktop/programming/python/fraction.py", line 86, in &lt;module&gt;
    print(my_fraction + 1)
  File "/Users/mac/Desktop/programming/python/fraction.py", line 28, in __add__
    new_den = self.den * target.den
AttributeError: 'int' object has no attribute 'den'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow"><code>__radd__</code> special method</a> only applies to when you do <code>value + self</code>.  If you want to handle <code>self + value</code>, you need to overload the <a href="https://docs.python.org/3/reference/datamodel.html#object.__add__" rel="nofollow"><code>__add__</code> special method</a>.</p>
<p>Since they both do the same thing, you can just do:</p>
<pre><code>def __add__(self, target):
    if isinstance(target, (int, float)):
        return target + self.num/self.den
__radd__ = __add__
</code></pre>
<p>An easy way to remember this is to treat the <code>r</code> in <code>__radd__</code> as standing for "right".  So, you use <code>__radd__</code> when your class is on the right of the <code>+</code> operator.</p>
<p>Also, you'll notice that I used <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow"><code>isinstance</code></a> to do the typechecking.  Aside from being cleaner, this way is preferred by most Python programmers and is explicitly advocated in <a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="nofollow">PEP 0008</a>.</p>
</div>
<span class="comment-copy">If you'd like this class to work on Python 2, you will need to convert self.num &amp;/or self.den to float, eg, <code>return target + float(self.num)/self.den</code>. FWIW, in my Fraction class I promote ints to fractions, but I guess it's easy enough for the user to explicitly convert ints themself. BTW, if you want to convert floats to rational form you can use <a href="http://en.wikipedia.org/wiki/Continued_fraction#Calculating_continued_fraction_representations" rel="nofollow noreferrer">continued fraction</a> techniques.</span>
<span class="comment-copy">Thanks a lot, this worked perfectly! Good data on <code>isinstance</code> too, I didn't know about it.</span>
