<div class="post-text" itemprop="text">
<p>Is there a way to autogenerate a dictionary list of multiple constraints in scipy.minimize? When I use the following code (where the list constraint is a list of sage multivariate polynomials over the same ring)</p>
<pre><code>cons = [{'type': 'eq', 'fun': lambda s: ((constraint[0])(*s))},
        {'type': 'eq', 'fun': lambda s: ((constraint[1])(*s))},
        {'type': 'eq', 'fun': lambda s: ((constraint[2])(*s))},
        {'type': 'eq', 'fun': lambda s: ((constraint[3])(*s))}]

y0 = [.5 for xx in x]
bnds = tuple([(0.0, 1.0) for xx in x])
ssoln = scipy.optimize.minimize(HH, y0, jac=dHH, method='SLSQP', bounds=bnds, constraints=cons)
print ssoln
</code></pre>
<p>My output is</p>
<pre><code>status: 0
 success: True
    njev: 14
    nfev: 22
     fun: -2.2669026273652237
       x: array([ 0.034829615490635,  0.933405952554424,  0.93340765416238 ,
        0.093323548109654,  0.335713397575351,  0.413107862378296])
 message: 'Optimization terminated successfully.'
     jac: array([-3.321836605297572,  2.640225014918886,  2.640252390205999,
       -2.273713195767229, -0.682455873949375, -0.351132324172705,  0.               ])
     nit: 14
</code></pre>
<p>However if I try to create cons by</p>
<pre><code>cons=[]
for ii in range(len(constraint)):
    cons.append({'type': 'eq', 'fun': lambda s:  ((constraint[ii])(*s))})
</code></pre>
<p>minimize fails with</p>
<pre><code>status: 6
 success: False
    njev: 1
    nfev: 1
     fun: -4.1588830833596715
       x: array([ 0.5,  0.5,  0.5,  0.5,  0.5,  0.5])
 message: 'Singular matrix C in LSQ subproblem'
     jac: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.])
     nit: 1
</code></pre>
<p>My list, constraint, of sage polynomials may change in length, in number of polynomials from problem to problem and I don't want to have to hard code the cons dict list as first given above for each problem. Is there a way to automate?</p>
<p>The following works but I understand it is not best practices to eval strings</p>
<pre><code>str1='{\'type\': \'eq\', \'fun\': lambda s: ((constraint['
str2='])(*s))},'
mystr='['
for ii in range(len(constraint)):
    mystr=mystr+str1+str(ii)+str2
mystr=mystr+']'
cons = eval(mystr)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is in your loop. The <code>lambda</code> operator performs what is called a <strong>lazy</strong> evaluation. At the end of your loop, the lambda the cons is performing the function on the last value of <code>ii</code>, instead of on each index.</p>
<p>To perform a <strong>strict</strong> evaluation, you can use the <code>partial</code> object from the python <code>functools</code> module (in both <a href="https://docs.python.org/2/library/functools.html?highlight=partial#functools.partial" rel="nofollow noreferrer">python 2</a> or <a href="https://docs.python.org/3/library/functools.html?highlight=partial#functools.partial" rel="nofollow noreferrer">python 3</a>).</p>
<p>To exemplify, with <code>lambda</code>:</p>
<pre><code>constraint = (lambda x: x, lambda x: x**2, lambda x: x**3, lambda x: x**4)

cons=[]
for ii in range(len(constraint)):
    # lambda s will evaluate the last value of ii
    cons.append({'type': 'eq', 'fun': lambda s: ((constraint[ii])(s))})

print([i['fun'](2) for i in cons])
# The value of ii is 3, so it will always call lambda x: x**4
&gt;&gt; [16, 16, 16, 16]

from functools import partial

def f_constraint(s, index):
    return constraint[index](s)

cons=[]
for ii in range(len(constraint)):
    # the value of ii is set in each loop
    cons.append({'type': 'eq', 'fun': partial(f_constraint, index=ii)})

print([i['fun'](2) for i in cons])
&gt;&gt; [2, 4, 8, 16]
</code></pre>
<p>Replacing s by *s to match your definition:</p>
<pre><code>from functools import partial

def f_constraint(s, index):
    return constraint[index](*s)

cons=[]
for ii in range(len(constraint)):
    cons.append({'type': 'eq', 'fun': partial(f_constraint, index=ii)})
</code></pre>
<p>Hope it helps!</p>
</div>
<span class="comment-copy">I have recently run into this problem myself. Did you ever find a solution that didn't involve evaluating the string?</span>
