<div class="post-text" itemprop="text">
<p>I'm having trouble understanding the semantics of "eval()" and "exec" in Python. (All code in this question behaves the same way in Python 2.7.8 and Python 3.4.2). The <a href="https://docs.python.org/2/library/functions.html#eval">documentation</a> for "eval" says:</p>
<blockquote>
<p>If both [locals and globals] are omitted, the expression is executed
  in the environment where eval() is called.</p>
</blockquote>
<p>There is similar language for "exec". I clearly don't understand this sentence because I would expect the four functions defined by the following program to do the same thing.</p>
<pre><code>def h(x):
    ls = locals()
    exec('def i(y): return (w, x, y)', globals(), ls)
    i = ls['i']
    def       j(y): return (w, x, y)
    k = eval('lambda y: (w, x, y)')
    l =       lambda y: (w, x, y)
    return i, j, k, l

w = 1

i, j, k, l = h(2)
</code></pre>
<p>They do not.</p>
<pre><code>&gt;&gt;&gt; i(3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1, in i
NameError: name 'x' is not defined
&gt;&gt;&gt; j(3)
(1, 2, 3)
&gt;&gt;&gt; k(3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1, in &lt;lambda&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; l(3)
(1, 2, 3)
</code></pre>
<p>Disassembling the code reveals why: "x" is treated as a global variable by "eval" and "exec".</p>
<pre><code>from dis import dis
print("This is `i`:")
dis(i)
print("This is `j`:")
dis(j)
print("This is `k`:")
dis(k)
print("This is `l`:")
dis(l)
print("For reference, this is `h`:")
dis(h)
</code></pre>
<p>Output:</p>
<pre><code>This is `i`:
  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_GLOBAL              1 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE        
This is `j`:
 25           0 LOAD_GLOBAL              0 (w)
              3 LOAD_DEREF               0 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE        
This is `k`:
  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_GLOBAL              1 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE        
This is `l`:
 27           0 LOAD_GLOBAL              0 (w)
              3 LOAD_DEREF               0 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE        
For reference, this is `h`:
 22           0 LOAD_NAME                0 (locals)
              3 CALL_FUNCTION            0
              6 STORE_FAST               1 (ls)

 23           9 LOAD_CONST               1 ('def i(y): return (w, x, y)')
             12 LOAD_NAME                1 (globals)
             15 CALL_FUNCTION            0
             18 LOAD_FAST                1 (ls)
             21 EXEC_STMT           

 24          22 LOAD_FAST                1 (ls)
             25 LOAD_CONST               2 ('i')
             28 BINARY_SUBSCR       
             29 STORE_FAST               2 (i)

 25          32 LOAD_CLOSURE             0 (x)
             35 BUILD_TUPLE              1
             38 LOAD_CONST               3 (&lt;code object j at 0x7ffc3843c030, file "test.py", line 25&gt;)
             41 MAKE_CLOSURE             0
             44 STORE_FAST               3 (j)

 26          47 LOAD_NAME                2 (eval)
             50 LOAD_CONST               4 ('lambda y: (w, x, y)')
             53 CALL_FUNCTION            1
             56 STORE_FAST               4 (k)

 27          59 LOAD_CLOSURE             0 (x)
             62 BUILD_TUPLE              1
             65 LOAD_CONST               5 (&lt;code object &lt;lambda&gt; at 0x7ffc3843c3b0, file "test.py", line 27&gt;)
             68 MAKE_CLOSURE             0
             71 STORE_FAST               5 (l)

 28          74 LOAD_FAST                2 (i)
             77 LOAD_FAST                3 (j)
             80 LOAD_FAST                4 (k)
             83 LOAD_FAST                5 (l)
             86 BUILD_TUPLE              4
             89 RETURN_VALUE
</code></pre>
<h2>The question</h2>
<p>"j" and "l" above have the behaviour I want. How can I get this behaviour using "eval" or "exec"?</p>
<h2>Failure 1</h2>
<p>Using a class instead of a function as the outer wrapper does change the semantics, but in the opposite to the desired way. It makes "x" into a global.</p>
<pre><code>class H:
    x = 2
    f = staticmethod(eval('lambda y: (w, x, y)'))

H.dis(H.f)

w = 1
H.f(3)
</code></pre>
<p>Output:</p>
<pre><code>  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_GLOBAL              1 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE        
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1, in &lt;lambda&gt;
NameError: global name 'x' is not defined
</code></pre>
<p>Wrapping in "classmethod" or leaving it as an unbound instance method just makes things worse.</p>
<h2>Failure 2</h2>
<p>Substituting "x" using string interpolation works for integers:</p>
<pre><code>def h(x):
    return eval('lambda y: (w, %r, y)' % x)

k = h(2)

dis(k)

w = 1
k(3)
</code></pre>
<p>Output:</p>
<pre><code>  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_CONST               1 (2)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE        
(1, 2, 3)
</code></pre>
<p>However, I don't want to assume that "x" can be losslessly converted to a string and back. The attempt is broken in the following examples:</p>
<pre><code>k = h(lambda: "something")

k = h(open('some_file', 'w'))

cell = ["Wrong value"]
k = h(cell)
cell[0] = "Right value"
k(3)
</code></pre>
<h2>Failure 3</h2>
<p>Since Python is looking for a global variable, one obvious attempt is to pass "x" as a global variable:</p>
<pre><code>def h(x):
    my_globals = {'w': w, 'x': x}
    return eval('lambda y: (w, x, y)', my_globals)

k = h(2)

dis(k)

w = 1
k(3)
</code></pre>
<p>Output:</p>
<pre><code>  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_GLOBAL              1 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE        
(1, 2, 3)
</code></pre>
<p>This attempt is broken because it reads the value of "w" too early:</p>
<pre><code>w = "Wrong value"
k = h(2)
w = "Right value"
k(3)
</code></pre>
<h2>Success 1</h2>
<p>I did eventually find an approach that works, but I really don't like it:</p>
<pre><code>def h(x):
    return eval('lambda x: lambda y: (w, x, y)')(x) 

k = h(2)

dis(k)

w = 1
k(3)
</code></pre>
<p>Output:</p>
<pre><code>  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_DEREF               0 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE
(1, 2, 3)
</code></pre>
<p>In particular, this is going to become painful if I do not know the full list of local variables captured by the string I'm passing to "eval".</p>
<p>Can you do better?</p>
<p><strong><em>Update 2014-12-25</em></strong></p>
<h2>Failure 4</h2>
<p>Looking for more ways of creating the local variable "x", I tried this:</p>
<pre><code>def h(x):
    ls = locals()
    exec('x = x\ndef i(y): return (w, x, y)', globals(), ls)
    exec('_ = x\ndef j(y): return (w, x, y)', globals(), ls)
    return ls['i'], ls['j'], ls['_'], ls['x']

i, j, check1, check2 = h(2)

assert check1 == 2
assert check2 == 2

w = 1

print("This is `i`:")
dis(i)
print("This is `j`:")
dis(j)

print("i(3) = %r" % (i(3),))
print("j(3) = %r" % (j(3),))
</code></pre>
<p>The extra assignment to "x" has no effect. The assertions verify that "x" is in the dictionary of locals, but it is not captured by the lambdas. Here is the output:</p>
<pre><code>This is `i`:
  2           0 LOAD_GLOBAL              0 (w)
              3 LOAD_GLOBAL              1 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE
This is `j`:
  2           0 LOAD_GLOBAL              0 (w)
              3 LOAD_GLOBAL              1 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE
</code></pre>
<p>The calls to "i" and "j" both crash, complaining that there is no global variable "x".</p>
<h2>Success 2</h2>
<p><em>[Edit 2014-12-29: This succeeds only on Python 3.]</em></p>
<p>Another way of creating a local variable is like this:</p>
<pre><code>def h(x):
    i = eval('[lambda y: (w, x, y) for x in [x]][0]')
    j = eval('[lambda y: (w, x, y) for _ in [x]][0]')
    return i, j

i, j = h(2)

w = 1

print("This is `i`:")
dis(i)
print("This is `j`:")
dis(j)

print("i(3) = %r" % (i(3),))
print("j(3) = %r" % (j(3),))
</code></pre>
<p>Strangely, in this case the extra assignment to "x" does have an effect. This does work, i.e. "i" is different from "j". Here is the output:</p>
<pre><code>This is `i`:
  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_DEREF               0 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE
This is `j`:
  1           0 LOAD_GLOBAL              0 (w)
              3 LOAD_GLOBAL              1 (x)
              6 LOAD_FAST                0 (y)
              9 BUILD_TUPLE              3
             12 RETURN_VALUE
i(3) = (1, 2, 3)
</code></pre>
<p>The call to "j" crashes, complaining that there is no global "x", but "i" works as desired and has the correct bytecode.</p>
<p>Why does this work, while "Failure 4" above does not? What is the rule that determines whether the local "x" can be captured? And what is the history of this design? (It seems absurd!)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you want your created functions to inherit the local environment of the function that creates them, but <em>also</em> the real global environment (of the function that creates them).  That's why you don't like them referring to x as a global, right?</p>
<p>The following creates a "wrapper" function around the desired function, all within the same exec string.  The values of the creating function's locals are passed in <em>when you call or re-call the wrapper</em>, creating a new wrapped closure.</p>
<p>The code is sensitive to new variables being created in the locals context. It goes to some trouble to make sure that the function and wrapper names are both known and have values there.</p>
<pre><code>def wrap_f(code, gs, ls, wrapper_name, function_name):
    ls[function_name] = ls[wrapper_name] = None
    arglist = ",".join(ls.keys())
    wrapcode = """
def {wrapper_name}({arglist}):
{code}
    return {function_name}
    """.format(wrapper_name=wrapper_name, arglist=arglist, 
               code=code, function_name=function_name)
    exec(wrapcode, gs, ls)
    wrapper = ls[wrapper_name]
    return wrapper, wrapper(**ls)
</code></pre>
<p>So, to answer the original question, this code...</p>
<pre><code>def h(x):
    mcode = "    def m(y): return (w, x, y)"  # must be indented 4 spaces.
    mwrap, m = wrap_f(mcode, globals(), locals(), "mwrap", "m")
    return m

w = 1
m = h(2)
print m(3)
</code></pre>
<p>...produces this output:</p>
<pre><code>(1, 2, 3)
</code></pre>
<p>And this example shows what to do when the locals in the creator function change:</p>
<pre><code>def foo(x):
    barleycode = """
    def barley(y):
        print "barley's x =", x
        print "barley's y =", y
    """
    barleywrap, barley = wrap_f(barleycode, globals(), locals(), 
                               "barleywrap", "barley")
    barley("this string")
    print

    x = "modified x"
    barley = barleywrap(**locals())
    barley("new arg")
    print

    x = "re-modified x"
    barley("doesn't see the re-mod.")

x = "the global x"

foo("outer arg")
</code></pre>
<p>This produces the output:</p>
<pre><code>barley's x = outer arg
barley's y = this string

barley's x = modified x
barley's y = new arg

barley's x = modified x
barley's y = doesn't see the re-mod.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure I quite got it myself, but I'll try my best:
I guess when you run the eval/exec python does not understand that it was inside the function, I don't really know why.
What I'll try to do is using format string like this</p>
<pre><code>k = eval("lambda y: (w, {0}, y)".format(x))
</code></pre>
<p>I'm not sure if this thing works though.
Also, why do you need to use eval and exec this way?</p>
</div>
<div class="post-text" itemprop="text">
<p>I will share in my own understanding that why python behave like this</p>
<h2>How Lambda Captures references</h2>
<p>Every time a variable that's not in the parameter list used, python creates a <strong>closure</strong> for it. For example</p>
<pre><code>y
def h(x):
    l =lambda y: (w, x,y)
</code></pre>
<p>creates a closure that captures x, you could check it by accessing</p>
<pre><code>l.__closure__
</code></pre>
<p>which will show you that x is store along with the function creation.
However, y is <strong>NOT</strong> stored with the function because it is defined as a global variable</p>
<h2>Class definition</h2>
<p>This will cause name error when run <code>A.f()</code></p>
<pre><code>class A:
    c = 1
    f = lambda :c+1
</code></pre>
<p>since python will look for c in global namespace which doesn't have <code>c</code> defined</p>
<h2>The Reason</h2>
<p><a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">Python 3's doc to exec function</a> said</p>
<blockquote>
<p>If exec gets two separate objects as <em>globals</em> and <em>locals</em>, the code
  will be executed as if it were embedded in a <strong><em>class</em></strong> definition.</p>
</blockquote>
<p>which shows why the lambda isn't capture variables in the locals namespace</p>
<h2>Work Around</h2>
<pre><code>k = eval('lambda y: (w, x, y)',dict(globals(),**))
</code></pre>
</div>
<span class="comment-copy"><code>i</code> and <code>j</code> are <b>not locals</b>. They are closures. Python determines closures at compile time, but the only way to produce such a closure in <code>eval()</code> is the manner in which you already discovered. You <b>cannot</b> create the closure in any other way.</span>
<span class="comment-copy">It is surprising that the variables passed in "locals" cannot be captured. Why is this?</span>
<span class="comment-copy">Because closures need more scaffolding; the lifetime of the variable is extended beyond the function lifetime, and a regular local won't do there.</span>
<span class="comment-copy">Right, you found another way to create a new scope; list comprehensions (and dict and set comprehensions and generator expressions) allow you to create a parent scope in a single expression too.</span>
<span class="comment-copy">You can also use the default-argument hack. It was common before PEP 227 added lexical scoping to Python 2.1. You can make it more reliable with a 3.x keyword-only argument: <code>k = eval('lambda y,*,x=x: (w,x,y)')</code>.</span>
<span class="comment-copy">"I think you want your created functions to inherit the local environment of the function that creates them, but also the real global environment (of the function that creates them). That's why you don't like them referring to x as a global, right?" &lt;-- Correct and close enough. :-)</span>
<span class="comment-copy">I take your point that I don't need to know 'the full list of local variables captured by the string I'm passing to "eval"'. I only need to know a superset of those, and 'locals().keys()' will do.</span>
<span class="comment-copy">The way I would put it, you don't need to know which ones are needed, you only have to have all the ones that are possibly needed.  Those variable names do all go into the 'barleywrap' part of the string passed to eval.</span>
<span class="comment-copy">apt1002 -- I edited the answer to include a more direct answer to the question as you wrote it.  Check the "it's an answer" button if you think it is!</span>
