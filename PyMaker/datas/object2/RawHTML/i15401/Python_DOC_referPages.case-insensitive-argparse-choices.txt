<div class="post-text" itemprop="text">
<p>Is it possible to check <a href="https://docs.python.org/3/library/argparse.html#choices">argparse choices</a> in case-insensitive manner?</p>
<pre><code>import argparse
choices = ["win64", "win32"]
parser = argparse.ArgumentParser()
parser.add_argument("-p", choices=choices)
print(parser.parse_args(["-p", "Win32"]))
</code></pre>
<p>results in:</p>
<pre><code>usage: choices.py [-h] [-p {win64,win32}]
choices.py: error: argument -p: invalid choice: 'Win32' (choose from 'win64','win32')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Transform the argument into lowercase by using</p>
<pre><code>type = lambda s : s.lower()
</code></pre>
<p>for the <code>-p</code> switch.</p>
<p>As pointed out by <a href="https://stackoverflow.com/users/1126841/chepner">chepner</a> in the comments, since <code>str.lower</code> is already an appropriate function, the lambda wrapper is not necessarily needed and you could instead simply use</p>
<pre><code>type = str.lower
</code></pre>
<p>directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>lower</code> in the <code>type</code> is nice way of doing this, if you don't mind loosing the case information.</p>
<p>If you want to retain the case, you could define a custom <code>choices</code> class.  The <code>choices</code> needs two methods, <code>__contains__</code> (for testing <code>in</code>), and iteration (to list the choices).</p>
<pre><code>class mylist(list):
    # list subclass that uses lower() when testing for 'in'
    def __contains__(self, other):
        return super(mylist,self).__contains__(other.lower())
choices=mylist(['win64','win32'])
parser = argparse.ArgumentParser()
parser.add_argument("-p", choices=choices)
print(parser.parse_args(["-p", "Win32"]))
# Namespace(p='Win32')
</code></pre>
<p>The help is:</p>
<pre><code>usage: ipython [-h] [-p {win64,win32}]

optional arguments:
  -h, --help        show this help message and exit
  -p {win64,win32}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Keeping the case information would also be possible with a one liner:
</p>
<pre><code>type = lambda arg: {x.lower(): x for x in choices}[arg.lower()],
</code></pre>
<p>Where choices would be the same list as passed to the choices parameter.</p>
</div>
<span class="comment-copy">You can get rid of the lambda by simply using <code>type = str.lower</code>, since <code>str.lower</code> is a function that takes a string and returns it in lower case.</span>
<span class="comment-copy">@chepner Good point, it didn't occur to me.</span>
<span class="comment-copy">@5gon12eder Nice use of lambda</span>
<span class="comment-copy">Since the <a href="https://docs.python.org/2/library/string.html#string.lower" rel="nofollow noreferrer">string.lower(s)</a> <i>function</i> was deprecated and replaced with the <a href="https://docs.python.org/2/library/stdtypes.html#str.lower" rel="nofollow noreferrer">s.lower()</a> <i>method</i>, I would recommend the lambda approach as originally suggested.</span>
<span class="comment-copy">@Mark Neither version uses the deprecated function from the <code>string</code> module. Note that <code>str.lower</code> (without <code>ing</code>) is used, which is the method from the <code>str</code> class taking <code>self</code> as its only parameter which is why the trick works.</span>
<span class="comment-copy">Just to be safe, I'd probably do <code>choices = mylist(map(str.lower, ['win64', 'win32']))</code>, or override <code>__init__</code> to do this.</span>
