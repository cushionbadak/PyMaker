<div class="post-text" itemprop="text">
<p>TLDR: I'm looking for a comprehensive or authoritative explanation (tutorial/book/presentation/...) of asyncio for application developers.</p>
<p>While I have a decent understanding of event loops and futures/deferreds/promises (largely thanks to JavaScript), somehow the intricacies of Python's asyncio continue to confound me. asyncio seems significantly more complex than what I'm used to - presumably because it was partly designed for low-level compatibility with existing implementations (Twisted, Tornado etc.) and because it allows for multiple event loops in separate threads.</p>
<p>As far as I can tell, there's no comprehensive walkthrough of the basic concepts, so I've consulted the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">official docs</a> as well as various <a href="http://www.drdobbs.com/open-source/the-new-asyncio-in-python-34-servers-pro/240168408" rel="nofollow noreferrer">articles</a> and <a href="http://www.slideshare.net/saghul/asyncio" rel="nofollow noreferrer">presentations</a> across the web.</p>
<p>Yet I remain unsure of my understanding, quite possibly because it's not always clear what's relevant at the application level or if you don't need to worry about the aforementioned alternatives. (Many resources seem to assume familiarity with Twisted et al.)</p>
<p>A few examples of things that induced uncertainty for me:</p>
<ul>
<li>So far I've only used <code>asyncio.coroutine</code> in combination with <code>yield from</code>, but <a href="https://stackoverflow.com/questions/26542686/python-3-asyncio-yield-from-vs-asyncio-async-stack-usage">this comparison</a> suggests I should reconsider.</li>
<li>A server might either be created using <code>loop.create_server(MyProtocol)</code> or <code>asyncio.start_server(my_connection_handler)</code> - when would I use either?</li>
<li>What is proper hygiene in managing loops' life cycle (e.g. <code>loop.close()</code> after <code>loop.run_forever()</code>)?</li>
<li>I have yet to understand why <code>Task</code>s are required in addition to <code>Future</code>s.</li>
<li>What if I want a class constructor to be non-blocking (i.e. use <code>yield from</code>, which appears to be invalid)?</li>
<li>Can class getters be asynchronous (i.e. combining <code>@property</code> and <code>asyncio.coroutine</code>)?</li>
<li>How do I know whether any given function is asynchronous? For example, I'd expect <code>StreamWriter.write</code> to be non-blocking, but I don't know whether that's actually the case.</li>
</ul>
<p>I'm not asking for answers to these particular questions, they merely illustrate how I'm struggling at a conceptual level.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am like you,  looking for answers, but i can help you withone thing:</p>
<p>Regarding  the non-blocking problem: </p>
<p>I created a program that uses asynchronous loops to listen to twitter feeds, </p>
<p>i found the answer here: 
<a href="https://stackoverflow.com/questions/22445054/asyncio-yield-from-concurrent-futures-future-of-an-executor?rq=1">asyncio yield from concurrent.futures.Future of an Executor</a></p>
<p>Basically,  using the executor, you can make any task non-blocking. Just a warning, my tasks are independant and do not need syncing, i just needed them to become non blocking. If you need them to wait for each toher, youhave to use semaphore</p>
<p>Here os how i did it :</p>
<pre><code>@asyncio.coroutine
def boucle_deux():
#faire attendre la boucle si pas bcp de mots
    while True:
        print("debut du deux")
        value = t.next()
        future2 = loop.run_in_executor(None, mention, "LQNyL2xvt9OQMvje7jryaHkN8",
                                       "IRJX6S17K44t8oiVGCjrj6XCVKqGSX9ClfpGpfC467rajqePGb",
                                       "2693346740-km3Ufby8r9BbYpyzcqwiHhss22h4YkmnPN4LnLM",
                                       "53R8GAAncFJ1aHA1yJe1OICfjqUbqwcMR38wSqvbzsQMB", 23, value)
        response2 = yield from future2
        yield from asyncio.sleep(5)
        print("fin du deux")

asyncio.Task(boucle_deux())
</code></pre>
<p>Here are a few links i found that helped me better understand:</p>
<p><a href="http://www.drdobbs.com/open-source/the-new-asyncio-in-python-34-servers-pro/240168408" rel="nofollow noreferrer">http://www.drdobbs.com/open-source/the-new-asyncio-in-python-34-servers-pro/240168408</a></p>
<p><a href="http://sahandsaba.com/understanding-asyncio-node-js-python-3-4.html" rel="nofollow noreferrer">http://sahandsaba.com/understanding-asyncio-node-js-python-3-4.html</a></p>
<p><a href="http://www.drdobbs.com/open-source/the-new-asyncio-module-in-python-34-even/240168401" rel="nofollow noreferrer">http://www.drdobbs.com/open-source/the-new-asyncio-module-in-python-34-even/240168401</a></p>
<p><a href="http://ntoll.org/article/asyncio" rel="nofollow noreferrer">http://ntoll.org/article/asyncio</a></p>
<p>Sure it is not a book, but it is a good starting place</p>
</div>
<span class="comment-copy">If you are asking for book or tutorial I cannot help you. But I can answer on maybe any particular question about asyncio.</span>
<span class="comment-copy">Thanks. Right now, I'm not sure it makes sense for me to turn the above into individual questions, as that wouldn't help my understanding at the conceptual level. Perhaps I'm overthinking it though, so will consider that.</span>
<span class="comment-copy">Thanks, knowing about Executor might well come in handy. However, "you can make any task non-blocking" assumes that I already know which parts are blocking - but how would I? (See <code>StreamWriter</code> example above.) I'd also found the articles you mention - hopefully there'll be more coverage in the future.</span>
<span class="comment-copy">For streamWriter, it is a Streaming Object, which means it answers to any messages it receives, just like a server, so it is not blocking. it is just listening. As to dertermine what is blocking, well in my case,i did a quick test and tried to run two tasks at the same time and realized it was blocking  and then i understood. My task was taking a long time, so if i as trying to run two in the same thread, it blocked the other one, hence the executors so the tasks have their own thread. That's how i understood it. But there are a lot of uses cases, and you are right, they are not documented.</span>
<span class="comment-copy">Even if Twisted Matrix is different, it helped to read about how it works: <a href="http://stackoverflow.com/questions/6117587/twisted-making-code-non-blocking" title="twisted making code non blocking">stackoverflow.com/questions/6117587/â€¦</a>. I also found out this: <a href="https://pypi.python.org/pypi/aioprocessing/0.0.1" rel="nofollow noreferrer">pypi.python.org/pypi/aioprocessing/0.0.1</a> , which is trying to solve the problem through libraries.</span>
<span class="comment-copy">I found <a href="http://stackabuse.com/python-async-await-tutorial/" rel="nofollow noreferrer">this</a> helpful - which is more recent and up to date specifying the changes in 3.5 and on.</span>
