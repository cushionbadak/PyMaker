<div class="post-text" itemprop="text">
<p>I'm trying to write a networked game with Pygame and asyncio, but I can't work out how to avoid hanging on reads. Here is my code for the client:</p>
<pre><code>@asyncio.coroutine
def handle_client():
    print("Connected!")
    reader, writer = yield from asyncio.open_connection('localhost', 8000)
    while True:
        mouse_up = False
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()                
            elif event.type == pygame.MOUSEBUTTONUP:
                mouse_up = True

        if mouse_up:
            print("Writing")
            writer.write(b"Mouse up")
        print("Waiting to read")
        line = yield from reader.read(2**12)
        print(line.decode())

    writer.close()
</code></pre>
<p>This hangs on the line <code>line = yield from reader.read(2**12)</code>. I previously thought that the point of asyncio was that it was non-blocking, and so if there wasn't any data to read it would just continue executing. I see now that this isn't the case.</p>
<p>How do I integrate the asyncio networking code with the Pygame drawing and event code?</p>
</div>
<div class="post-text" itemprop="text">
<p>The point of <code>yield from</code> is to switch the execution to the asyncio's event loop <em>and</em> to block the current coroutine until the result is available. To schedule a task without blocking the current coroutine, you could use <code>asyncio.async()</code>.</p>
<p>To print read-so-far data without blocking the pygame loop:</p>
<pre><code>@asyncio.coroutine
def read(reader, callback):
    while True:
        data = yield from reader.read(2**12)
        if not data: # EOF
            break
        callback(data)

@asyncio.coroutine
def echo_client():
    reader, ...
    chunks = []
    asyncio.async(read(reader, chunks.append))
    while True:
        pygame.event.pump() # advance pygame event loop
        ...
        if chunks: # print read-so-far data
            print(b''.join(chunks).decode())
            del chunks[:]
        yield from asyncio.sleep(0.016) # advance asyncio loop
</code></pre>
<p>There should be no blocking calls inside the <code>while</code> loop.</p>
<p><code>read()</code> and <code>sleep()</code> coroutines run concurrently in the same thread (obviously you could run other coroutines concurrently too).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can "transform" a blocking task into a non-blocking one.</p>
<p>I suggest this: <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executor" rel="noreferrer">https://docs.python.org/3/library/asyncio-eventloop.html#executor</a>.</p>
<p>I have a function that listens to a twitter feed, function "mention", and I run it in an executor, so if it hangs, it doesn't block the other tasks.</p>
<pre><code>@asyncio.coroutine
def boucle_deux():
#faire attendre la boucle si pas bcp de mots
    while True:
        print("debut du deux")
        value = t.next()
        future2 = loop.run_in_executor(None, mention, "LQNyL2xvt9OQMvje7jryaHkN8",
                                       "IRJX6S17K44t8oiVGCjrj6XCVKqGSX9ClfpGpfC467rajqePGb",
                                       "2693346740-km3Ufby8r9BbYpyzcqwiHhss22h4YkmnPN4LnLM",
                                       "53R8GAAncFJ1aHA1yJe1OICfjqUbqwcMR38wSqvbzsQMB", 23, value)
        response2 = yield from future2
        yield from asyncio.sleep(5)
        print("fin du deux")

asyncio.Task(boucle_deux())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>well since you are trying to read the value of 'line' right after you call read()  you need that value at any cost...</p>
<p>if the coroutine wouldn't stop cause there are no data, you could get an AttributeError on the line.decode() call if 'line' then is None.</p>
<p>one thing you can do is to set a timeout on the blocking call and handle the timeout exception:</p>
<pre><code>...
print("Waiting to read")
try:  # block at most for one second
    line = yield from asyncio.wait_for(reader.read(2**12), 1)
except asyncio.TimeoutError:
    continue
else:
    print(line.decode())
...
</code></pre>
</div>
<span class="comment-copy">Thanks. Would I put the <code>clock.tick()</code> call at the usual place in the loop, or would I need to write my own asynchrous one to avoid blocking the networking code?</span>
<span class="comment-copy">@sweeneyrod: the latter. The <code>sleep()</code> call above emulates async <code>tick()</code></span>
<span class="comment-copy">Wouldn't this cause the pygame code (the event loop, and sleeping) to be called for each client, rather than only once?</span>
<span class="comment-copy">@sweeneyrod: the answer is about <i>"how to avoid hanging on reads."</i> There should be only one pygame loop.</span>
<span class="comment-copy">The purpose of the executor is to run slow or blocking operations (the processus is preempted by the kernel's scheduler) in a separate thread. StreamReader.read() never blocks.</span>
