<div class="post-text" itemprop="text">
<p>The built-in <code>vars(obj)</code> returns a dict with key/values mirroring the attributes of <code>obj</code>. Is there an inverse of this function?  I.e. a function that takes a dictionary and returns an object.</p>
<p>I've come up with two ways of doing it, neither of which would be obvious to someone reading it. The first version involves assigning a new dict to <code>self.__dict__</code>:</p>
<pre><code>class _Tmp(object):
    def __init__(self, dct):
        self.__dict__ = dct
obj = _Tmp({'hello': 'world'})
assert obj.hello == 'world'
</code></pre>
<p>and the second version uses a non-standard call to the <code>type</code> builtin:</p>
<pre><code>obj = type('', (), {'hello': 'world'})
assert obj.hello == 'world'
</code></pre>
<p>Is there an easier/more readable way?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3 and up you can use <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace"><code>types.SimpleNamespace</code></a>:</p>
<pre><code>from types import SimpleNamespace

obj = SimpleNamespace(**{'hello': 'world'})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is the module <a href="https://pypi.python.org/pypi/attrdict/1.2.0" rel="nofollow"><code>attrdict</code></a> that does what you want. </p>
</div>
<span class="comment-copy">What makes you think the call to <code>type()</code> is <i>non-standard</i>?</span>
<span class="comment-copy">@MartijnPieters it has no name and no bases (which all the examples I've seen uses).</span>
<span class="comment-copy">What object would you expect?</span>
<span class="comment-copy">@thebjorn: that's because you gave it an empty string, and you could easily use <code>(object,)</code> as the bases. I'm not sure why not using either is non-standard however.</span>
<span class="comment-copy">Very interesting thing for Python to provide. Definitely has it's uses, I'm sure, though it reminds me a lot of Javascript objects. And for people who have yet to jump to Python 3, the code given in the documentation worked to define <code>SimpleNamespace</code> in my Python 2.7.5.</span>
<span class="comment-copy">It's not clear with OP wants, but this isn't really an exact inverse as vars() as vars() doesn't create a new object and changes to the vars() output are reflected in the original object and vice versa. SimpleNamespace creates a copy which can be modified without changing the original dictionary.</span>
<span class="comment-copy">@KevinShea: it is quite clear what the OP wants, which is to create an object with attributes, taken from a dictionary. <code>SimpleNamespace</code> does <i>exactly</i> that.</span>
<span class="comment-copy">@KevinShea: I don't think that the OP ever realised that <code>vars()</code> just returns a reference to the <code>__dict__</code> dictionary of an instance, for example. Nowhere are they asking for such a direct connection. You can't have that kind of connection easily, as the <code>__dict__</code> slot of instances is read-only. You can't create instances that take a pre-existing dictionary for their <code>__dict__</code> attribute, so you can only do it with explicit <code>__getattr__</code> and <code>__setattr__</code> and <code>__delattr__</code> hooks that translate to a separate attribute that's not named <code>__dict__</code>.</span>
