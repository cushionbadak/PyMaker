<div class="post-text" itemprop="text">
<p>I am creating a method that constructs an anonymous method to return a function of multiple variables e.g. f(x, y, z) = b. I want the user to be able to pass a list of variables:</p>
<pre><code>def get_multivar_lambda(expression, variables=["x"])
</code></pre>
<p>I then want the returned anonymous function to take exactly <code>len(variables)</code> arguments (either positional based on their list index or keyword based on the string in the list). I know I can use <code>*args</code> and check the length, but this seems inelegant. </p>
<p>Is this possible? How might I do this?</p>
<p>Here is an example of how I did it for one variable (where <code>seval</code> is a from module <code>simple_eval</code>):</p>
<pre><code>def get_lambda(expression, variable="x"):                                       
    return lambda arg: seval(expression.replace(variable, str(arg))) 
</code></pre>
<p>And here's how I did it by just checking the length of the <code>arguments*</code> passed:</p>
<pre><code>def get_multivar_lambda(expression, variables=["x"]):

    def to_return(*arguments):
        if len(variables) != len(arguments):
            raise Exception("Number of arguments != number of variables")
        for v, a in zip(variables, arguments):
            expression.replace(v, a)
        return seval(expression)

    return to_return
</code></pre>
<p>EDIT: I am taking expression and variables from user input, so a safe way to do this would be best. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you can use Python 3 then the newly introduced(Python 3.3+) <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature"><code>inspect.Signature</code></a> and <a href="https://docs.python.org/3/library/inspect.html#inspect.Parameter"><code>inspect.Parameter</code></a> can make your code very clean(<a href="https://www.python.org/dev/peps/pep-0362/">PEP 362 - Function Signature Object</a>). These come very handy in decorators as well:</p>
<pre><code>from inspect import Parameter, signature, Signature

def get_multivar_lambda(expression, variables=["x"]):

    params = [Parameter(v, Parameter.POSITIONAL_OR_KEYWORD) for v in variables]
    sig = Signature(params)

    def to_return(*args, **kwargs):
        values = sig.bind(*args, **kwargs)
        for name, val in values.arguments.items():
            print (name, val)

    to_return.__signature__ = signature(to_return).replace(parameters=params)
    return to_return
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; f = get_multivar_lambda('foo')
&gt;&gt;&gt; f(1)
x 1
&gt;&gt;&gt; f(1, 2)
Traceback (most recent call last):
  File "&lt;pyshell#43&gt;", line 1, in &lt;module&gt;
  ...
    raise TypeError('too many positional arguments') from None
TypeError: too many positional arguments
&gt;&gt;&gt; f(x=100)
x 100
</code></pre>
<p>Will produce useful error messages for user as well:</p>
<pre><code>&gt;&gt;&gt; g = get_multivar_lambda('foo', variables=['x', 'y', 'z'])
&gt;&gt;&gt; g(20, 30, x=1000)
Traceback (most recent call last):
  File "&lt;pyshell#48&gt;", line 1, in &lt;module&gt;
    ....
TypeError: multiple values for argument 'x'
&gt;&gt;&gt; g(1000, y=2000, z=500)
x 1000
y 2000
z 500
</code></pre>
<p>Function signature for introspection purpose:</p>
<pre><code>&gt;&gt;&gt; inspect.getargspec(g)
ArgSpec(args=['x', 'y', 'z'], varargs=None, keywords=None, defaults=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like this is definitely possible. I've written a solution using <code>ast</code>. It's a bit more verbose than the other solutions, but the returned object is a function that works without any intermediary compilation steps such as with the <code>simple_eval</code> solutions.</p>
<pre><code>import ast

def get_multi_lambda(expr, args=()):
    code_stmt = ast.parse(expr, mode='eval')

    collector = NameCollector()
    collector.visit(code_stmt)

    arg_set = set(args)
    if arg_set - collector.names:
        raise TypeError("unused args", arg_set - collector.names)
    elif collector.names - arg_set:
        # very zealous, meant to stop execution of arbitrary code 
        # -- prevents use of *any* name that is not an argument to the function
        # -- unfortunately this naive approach also stops things like sum
        raise TypeError("attempted nonlocal name access", 
            collector.names - arg_set)

    func_node = create_func_node(args, code_stmt)
    code_obj = compile(func_node, "&lt;generated&gt;", "eval")
    return eval(code_obj, {}, {})

def create_func_node(args, code_stmt):
    lambda_args = ast.arguments(
        args=[ast.arg(name, None) for name in args],
        vararg=None, varargannotation=None, kwonlyargs=[], kwarg=None,
        kwargannotation=None, defaults=[], kw_defaults=[]
    )
    func = ast.Lambda(args=lambda_args, body=code_stmt.body)
    expr = ast.Expression(func)
    ast.fix_missing_locations(expr)
    return expr

class NameCollector(ast.NodeVisitor):
    """Finds all the names used by an ast node tree."""

    def __init__(self):
        self.names = set()

    def visit_Name(self, node):
        self.names.add(node.id)

# example usage
func = get_multi_lambda('a / b + 1', ['a', 'b'])
print(func(3, 4)) # prints 1.75 in python 3
</code></pre>
<p>You could choose to exclude the second names check if you can trust the source of these multi-lambda expressions, or you can add exceptions for certain names you think are fine. eg. <code>min</code>, <code>max</code>, <code>sum</code>, etc...</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think you can do exactly what you want to (generally define functions with specific numbers of arguments).</p>
<p>But simpleeval has variable replacement built in: <a href="https://pypi.python.org/pypi/simpleeval#names" rel="nofollow">https://pypi.python.org/pypi/simpleeval#names</a></p>
<p>So the lessons to be learned:</p>
<ul>
<li>Look for other ways to get what you want.</li>
<li>There isn't too much of a difference between raising an exception when calling a function (due to the interpreter finding the wrong number of arguments) and raising an exception inside.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I find using a class object instead of standard function should be better.</p>
<pre><code>from simpleeval import simple_eval as seval



class MultivarLambda(object):
    def __init__(self, expression, variables):
        self.__expression = expression
        self.__variables = variables


    def __call__(self, *args):
        line = self.__expression

        for v, arg in zip(self.__variables, args):
            line = line.replace(v, arg)

        return seval(line)



f = MultivarLambda("(A)**2 + (B)**2", ["A", "B"])

print f('3', '4')
print f('5', '-12')

# 25
# 169
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could parse the expression into AST. You can then walk through the AST to evaluate the expression. This can be safe, provided you explicitly list those node types which you wish to handle.</p>
<p>For example, using <a href="https://stackoverflow.com/a/9558001/190597">J.F. Sebastian's AST evaluator</a>, you could do something like</p>
<pre><code>import ast
import operator as op
import textwrap
def make_func(expression, variables):
    template = textwrap.dedent('''\
        def func({}):
            return eval_expr({!r}, locals())
        ''').format(','.join(variables), expression)
    namespace = {'eval_expr':eval_expr}
    exec template in namespace
    return namespace['func']


def eval_expr(expr, namespace):
    """
    &gt;&gt;&gt; eval_expr('2^6')
    4
    &gt;&gt;&gt; eval_expr('2**6')
    64
    &gt;&gt;&gt; eval_expr('1 + 2*3**(4^5) / (6 + -7)')
    -5.0
    """
    # Module(body=[Expr(value=...)])
    return eval_(ast.parse(expr).body[0].value, namespace)  


def eval_(node, namespace=None):
    """
    https://stackoverflow.com/a/9558001/190597 (J.F. Sebastian)
    """
    if namespace is None:
        namespace = dict()
    if isinstance(node, ast.Num):  # &lt;number&gt;
        return node.n
    elif isinstance(node, ast.operator):  # &lt;operator&gt;
        return operators[type(node)]
    elif isinstance(node, ast.BinOp):  # &lt;left&gt; &lt;operator&gt; &lt;right&gt;
        return eval_(node.op, namespace)(eval_(node.left, namespace),
                                         eval_(node.right, namespace))
    elif isinstance(node, ast.Name):
        return namespace[node.id]
    else:
        raise TypeError(node)

operators = {ast.Add: op.add, ast.Sub: op.sub, ast.Mult: op.mul,
             ast.Div: op.truediv, ast.Pow: op.pow, ast.BitXor: op.xor,
             ast.USub: op.neg}

f = make_func('x', ['x'])
print(f(2))
# 2

g = make_func('x+y+z', ['x','y','z'])
print(g(1,2,3))
# 6   
</code></pre>
<p>Which can be used like this:</p>
<pre><code>f = make_func('x', ['x'])
print(f(2))
# 2

g = make_func('x+y+z', ['x','y','z'])
print(g(1,2,3))
# 6
</code></pre>
</div>
<span class="comment-copy">Why silently remove unused variables? That's a point of failure: I will pass in an expression with unused variables, and then pass in arguments for those variables, getting a confusing error. Either <i>ignore</i> unused variables or <code>raise</code> on unused variables.</span>
<span class="comment-copy">Also, can you use SymPy?</span>
<span class="comment-copy">Good point! I'll fix that later on.</span>
<span class="comment-copy">Probably, but part of this is just the learning experience! Specifically, learning what I can and can't do using the features of Python.</span>
<span class="comment-copy">I changed your loop to use <code>zip</code> because the asterisks were in the wrong place. Also, try <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str.translate</a> for your replacement operation.</span>
<span class="comment-copy">How would one add other functions like <code>min</code>, <code>max</code>, <code>sum</code>, etc?</span>
<span class="comment-copy">They are there by default. Getting rid of the <code>elif</code> branch that throws the exception is the simplest way. A safer way might be to change the elif clause to something like: <code>collector.names - arg_set - set(['min', 'max', 'sum', ...])</code>.</span>
<span class="comment-copy">Is this dangerous if the expression is taken as text input from the user?</span>
<span class="comment-copy">Yes, exec'ing user input is dangerous.</span>
<span class="comment-copy">Is there a safe way to do what I am asking, or is this pretty much it?</span>
