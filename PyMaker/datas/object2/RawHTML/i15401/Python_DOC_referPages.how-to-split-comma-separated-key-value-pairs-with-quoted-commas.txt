<div class="post-text" itemprop="text">
<p>I know there are a lot of other posts about parsing comma-separated values, but I couldn't find one that splits key-value pairs and handles quoted commas.</p>
<p>I have strings like this:</p>
<pre><code>age=12,name=bob,hobbies="games,reading",phrase="I'm cool!"
</code></pre>
<p>And I want to get this:</p>
<pre><code>{
  'age': '12',
  'name': 'bob',
  'hobbies': 'games,reading',
  'phrase': "I'm cool!",
}
</code></pre>
<p>I tried using <code>shlex</code> like this:</p>
<pre><code>lexer = shlex.shlex('''age=12,name=bob,hobbies="games,reading",phrase="I'm cool!"''')
lexer.whitespace_split = True
lexer.whitespace = ','
props = dict(pair.split('=', 1) for pair in lexer)
</code></pre>
<p>The trouble is that <code>shlex</code> will split the <code>hobbies</code> entry into two tokens, i.e. <code>hobbies="games</code> and <code>reading"</code>.  Is there a way to make it take the double quotes into account?  Or is there another module I can use?</p>
<p>EDIT: Fixed typo for <code>whitespace_split</code></p>
<p>EDIT 2: I'm not tied to using <code>shlex</code>. Regex is fine too, but I didn't know how to handle the matching quotes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You just needed to use your <code>shlex</code> lexer in POSIX mode. </p>
<p>Add <code>posix=True</code> when creating the lexer. </p>
<p>(See <a href="https://docs.python.org/3/library/shlex.html#parsing-rules" rel="noreferrer">the shlex parsing rules</a>)</p>
<pre><code>lexer = shlex.shlex('''age=12,name=bob,hobbies="games,reading",phrase="I'm cool!"''', posix=True)
lexer.whitespace_split = True
lexer.whitespace = ','
props = dict(pair.split('=', 1) for pair in lexer)
</code></pre>
<p>Outputs :</p>
<pre><code>{'age': '12', 'phrase': "I'm cool!", 'hobbies': 'games,reading', 'name': 'bob'}
</code></pre>
<p>PS : Regular expressions won't be able to parse key-value pairs as long as the input can contain quoted <code>=</code> or <code>,</code> characters. Even preprocessing the string wouldn't be able to make the input be parsed by a regular expression, because that kind of input cannot be formally defined as a regular language. </p>
</div>
<div class="post-text" itemprop="text">
<p>It's possible to do with a regular expression. In this case, it might actually be the best option, too. I think this will work with most input, even escaped quotes such as this one: <code>phrase='I\'m cool'</code></p>
<p>With the VERBOSE flag, it's possible to make complicated regular expressions quite readable.</p>
<pre><code>import re
text = '''age=12,name=bob,hobbies="games,reading",phrase="I'm cool!"'''
regex = re.compile(
    r'''
        (?P&lt;key&gt;\w+)=      # Key consists of only alphanumerics
        (?P&lt;quote&gt;["']?)   # Optional quote character.
        (?P&lt;value&gt;.*?)     # Value is a non greedy match
        (?P=quote)         # Closing quote equals the first.
        ($|,)              # Entry ends with comma or end of string
    ''',
    re.VERBOSE
    )

d = {match.group('key'): match.group('value') for match in regex.finditer(text)}

print(d)  # {'name': 'bob', 'phrase': "I'm cool!", 'age': '12', 'hobbies': 'games,reading'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could abuse Python tokenizer to parse the key-value list:</p>
<pre><code>#!/usr/bin/env python
from tokenize import generate_tokens, NAME, NUMBER, OP, STRING, ENDMARKER

def parse_key_value_list(text):
    key = value = None
    for type, string, _,_,_ in generate_tokens(lambda it=iter([text]): next(it)):
        if type == NAME and key is None:
            key = string
        elif type in {NAME, NUMBER, STRING}:
            value = {
                NAME: lambda x: x,
                NUMBER: int,
                STRING: lambda x: x[1:-1]
            }[type](string)
        elif ((type == OP and string == ',') or
              (type == ENDMARKER and key is not None)):
            yield key, value
            key = value = None

text = '''age=12,name=bob,hobbies="games,reading",phrase="I'm cool!"'''
print(dict(parse_key_value_list(text)))
</code></pre>
<h3>Output</h3>
<pre><code>{'phrase': "I'm cool!", 'age': 12, 'name': 'bob', 'hobbies': 'games,reading'}
</code></pre>
<hr/>
<p>You could use a finite-state machine (FSM) to implement a stricter parser. The parser uses only the current state and the next token to parse input:</p>
<pre><code>#!/usr/bin/env python
from tokenize import generate_tokens, NAME, NUMBER, OP, STRING, ENDMARKER

def parse_key_value_list(text):
    def check(condition):
        if not condition:
            raise ValueError((state, token))

    KEY, EQ, VALUE, SEP = range(4)
    state = KEY
    for token in generate_tokens(lambda it=iter([text]): next(it)):
        type, string = token[:2]
        if state == KEY:
            check(type == NAME)
            key = string
            state = EQ
        elif state == EQ:
            check(type == OP and string == '=')
            state = VALUE
        elif state == VALUE:
            check(type in {NAME, NUMBER, STRING})
            value = {
                NAME: lambda x: x,
                NUMBER: int,
                STRING: lambda x: x[1:-1]
            }[type](string)
            state = SEP
        elif state == SEP:
            check(type == OP and string == ',' or type == ENDMARKER)
            yield key, value
            state = KEY

text = '''age=12,name=bob,hobbies="games,reading",phrase="I'm cool!"'''
print(dict(parse_key_value_list(text)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok, I actually figured out a pretty nifty way, which is to split on both comma and equal sign, then take 2 tokens at a time.</p>
<pre><code>input_str = '''age=12,name=bob,hobbies="games,reading",phrase="I'm cool!"'''

lexer = shlex.shlex(input_str)
lexer.whitespace_split = True
lexer.whitespace = ',='

ret = {}
try:
  while True:
    key = next(lexer)
    value = next(lexer)

    # Remove surrounding quotes
    if len(value) &gt;= 2 and (value[0] == value[-1] == '"' or
                            value[0] == value[-1] == '\''):
      value = value[1:-1]

    ret[key] = value

except StopIteration:
  # Somehow do error checking to see if you ended up with an extra token.
  pass

print ret
</code></pre>
<p>Then you get:</p>
<pre><code>{
  'age': '12',
  'name': 'bob',
  'hobbies': 'games,reading',
  'phrase': "I'm cool!",
}
</code></pre>
<p>However, this doesn't check that you don't have weird stuff like: <code>age,12=name,bob</code>, but I'm ok with that in my use case.</p>
<p>EDIT: Handle both double-quotes and single-quotes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python seems to offer many ways to solve the task. Here is a little more c like implemented way, processing each char. Would be interesting to know different run times.</p>
<pre><code>str = 'age=12,name=bob,hobbies="games,reading",phrase="I\'m cool!"'
key = ""
val = ""
dict = {}
parse_string = False
parse_key = True
# parse_val = False
for c in str:
    print(c)
    if c == '"' and not parse_string:
        parse_string = True
        continue
    elif c == '"' and parse_string:
        parse_string = False
        continue
    if parse_string:
        val += c
        continue
    if c == ',': # terminate entry
        dict[key] = val #add to dict
        key = ""
        val = ""
        parse_key = True
        continue
    elif c == '=' and parse_key:
        parse_key = False
    elif parse_key:
        key += c
    else:
        val+=c
dict[key] = val
print(dict.items())
# {'phrase': "I'm cool!", 'age': '12', 'name': 'bob', 'hobbies': 'games,reading'}
</code></pre>
<p>demo: <a href="http://repl.it/6oC/1" rel="nofollow">http://repl.it/6oC/1</a></p>
</div>
<span class="comment-copy">A better strategy could be like this: First split by equal signs and then split by the last comma in each string.</span>
<span class="comment-copy">Easiest way o do that is to use a regexp.</span>
<span class="comment-copy">@SeçkinSavaşçı: Unless there are equal signs within quotation marks...</span>
<span class="comment-copy">If you insist on not using a regexp, and double quotes will always be used for strings and never appear within them, you could split the string on <code>"</code> so you can identify the quoted strings, and work around them.</span>
<span class="comment-copy">@ScottHunter completely agree with you, that's why my suggestion is not qualified as a valid answer.</span>
<span class="comment-copy">I think this one is the best, since it handles all the cases and uses the <code>shlex</code> library, instead of reinventing the wheel.</span>
<span class="comment-copy">Nice!  This is much cleaner and more understandable than using <code>shlex</code>.</span>
<span class="comment-copy">it breaks on <a href="http://ideone.com/0BhRX1" rel="nofollow noreferrer"><code>phrase='I\',m cool!'</code></a>.</span>
<span class="comment-copy">Yes. If that is a an actual possible input, then escaped quotes should be sanitized somehow before running the regex search.  Another example, which is almost plausible is: <code>phrase="I'm \"cool\", I think..."</code></span>
<span class="comment-copy">@HåkenLid: I only bring this up because you've mentioned it in your answer. OP hasn't said anything about escaping quotes inside strings. btw, <a href="http://ideone.com/wOZ01D" rel="nofollow noreferrer">FSM-based solution from my answer works in this case</a></span>
<span class="comment-copy">It's something that might be relevant, depending on what kind of input could be expected.</span>
<span class="comment-copy">It also handles <code>key="value=value"</code></span>
<span class="comment-copy">Doesn't handle single quoted strings.</span>
<span class="comment-copy">If you have <code>name="bob"</code> rather than <code>name=bob</code>, you can also play with <code>exec()</code>.</span>
<span class="comment-copy">mh I got correct results, maybe it doesn't look like python, but why the downvote?</span>
