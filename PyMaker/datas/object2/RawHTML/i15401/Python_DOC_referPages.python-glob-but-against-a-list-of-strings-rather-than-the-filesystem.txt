<div class="post-text" itemprop="text">
<p>I want to be able to match a pattern in <a href="https://docs.python.org/2/library/glob.html" rel="noreferrer"><code>glob</code></a> format to a list of strings, rather than to actual files in the filesystem. Is there any way to do this, or convert a <code>glob</code> pattern easily to a regex?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Good artists copy; great artists <a href="http://quoteinvestigator.com/2013/03/06/artists-steal/" rel="noreferrer">steal</a>.</em></p>
<p>I stole ;)</p>
<p><code>fnmatch.translate</code> translates globs <code>?</code> and <code>*</code> to regex <code>.</code> and <code>.*</code> respectively. I tweaked it not to.  </p>
<pre><code>import re

def glob2re(pat):
    """Translate a shell PATTERN to a regular expression.

    There is no way to quote meta-characters.
    """

    i, n = 0, len(pat)
    res = ''
    while i &lt; n:
        c = pat[i]
        i = i+1
        if c == '*':
            #res = res + '.*'
            res = res + '[^/]*'
        elif c == '?':
            #res = res + '.'
            res = res + '[^/]'
        elif c == '[':
            j = i
            if j &lt; n and pat[j] == '!':
                j = j+1
            if j &lt; n and pat[j] == ']':
                j = j+1
            while j &lt; n and pat[j] != ']':
                j = j+1
            if j &gt;= n:
                res = res + '\\['
            else:
                stuff = pat[i:j].replace('\\','\\\\')
                i = j+1
                if stuff[0] == '!':
                    stuff = '^' + stuff[1:]
                elif stuff[0] == '^':
                    stuff = '\\' + stuff
                res = '%s[%s]' % (res, stuff)
        else:
            res = res + re.escape(c)
    return res + '\Z(?ms)'
</code></pre>
<p>This one Ã  la <code>fnmatch.filter</code>, both <code>re.match</code> and <code>re.search</code> work.  </p>
<pre><code>def glob_filter(names,pat):
    return (name for name in names if re.match(glob2re(pat),name))
</code></pre>
<p>Glob patterns and strings found on this page pass test.  </p>
<pre><code>pat_dict = {
            'a/b/*/f.txt': ['a/b/c/f.txt', 'a/b/q/f.txt', 'a/b/c/d/f.txt','a/b/c/d/e/f.txt'],
            '/foo/bar/*': ['/foo/bar/baz', '/spam/eggs/baz', '/foo/bar/bar'],
            '/*/bar/b*': ['/foo/bar/baz', '/foo/bar/bar'],
            '/*/[be]*/b*': ['/foo/bar/baz', '/foo/bar/bar'],
            '/foo*/bar': ['/foolicious/spamfantastic/bar', '/foolicious/bar']

        }
for pat in pat_dict:
    print('pattern :\t{}\nstrings :\t{}'.format(pat,pat_dict[pat]))
    print('matched :\t{}\n'.format(list(glob_filter(pat_dict[pat],pat))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>glob</code> module uses the <a href="https://docs.python.org/2/library/fnmatch.html"><code>fnmatch</code> module</a> for <em>individual path elements</em>.</p>
<p>That means the path is split into the directory name and the filename, and if the directory name contains meta characters (contains any of the characters <code>[</code>, <code>*</code> or <code>?</code>) then these are expanded <em>recursively</em>.</p>
<p>If you have a list of strings that are simple filenames, then just using the <a href="https://docs.python.org/2/library/fnmatch.html#fnmatch.filter"><code>fnmatch.filter()</code> function</a> is enough:</p>
<pre><code>import fnmatch

matching = fnmatch.filter(filenames, pattern)
</code></pre>
<p>but if they contain full paths, you need to do more work as the regular expression generated doesn't take path segments into account (wildcards don't exclude the separators nor are they adjusted for cross-platform path matching).</p>
<p>You can construct a simple <a href="http://en.wikipedia.org/wiki/Trie">trie</a> from the paths, then match your pattern against that:</p>
<pre><code>import fnmatch
import glob
import os.path
from itertools import product


# Cross-Python dictionary views on the keys 
if hasattr(dict, 'viewkeys'):
    # Python 2
    def _viewkeys(d):
        return d.viewkeys()
else:
    # Python 3
    def _viewkeys(d):
        return d.keys()


def _in_trie(trie, path):
    """Determine if path is completely in trie"""
    current = trie
    for elem in path:
        try:
            current = current[elem]
        except KeyError:
            return False
    return None in current


def find_matching_paths(paths, pattern):
    """Produce a list of paths that match the pattern.

    * paths is a list of strings representing filesystem paths
    * pattern is a glob pattern as supported by the fnmatch module

    """
    if os.altsep:  # normalise
        pattern = pattern.replace(os.altsep, os.sep)
    pattern = pattern.split(os.sep)

    # build a trie out of path elements; efficiently search on prefixes
    path_trie = {}
    for path in paths:
        if os.altsep:  # normalise
            path = path.replace(os.altsep, os.sep)
        _, path = os.path.splitdrive(path)
        elems = path.split(os.sep)
        current = path_trie
        for elem in elems:
            current = current.setdefault(elem, {})
        current.setdefault(None, None)  # sentinel

    matching = []

    current_level = [path_trie]
    for subpattern in pattern:
        if not glob.has_magic(subpattern):
            # plain element, element must be in the trie or there are
            # 0 matches
            if not any(subpattern in d for d in current_level):
                return []
            matching.append([subpattern])
            current_level = [d[subpattern] for d in current_level if subpattern in d]
        else:
            # match all next levels in the trie that match the pattern
            matched_names = fnmatch.filter({k for d in current_level for k in d}, subpattern)
            if not matched_names:
                # nothing found
                return []
            matching.append(matched_names)
            current_level = [d[n] for d in current_level for n in _viewkeys(d) &amp; set(matched_names)]

    return [os.sep.join(p) for p in product(*matching)
            if _in_trie(path_trie, p)]
</code></pre>
<p>This mouthful can quickly find matches using globs anywhere along the path:</p>
<pre><code>&gt;&gt;&gt; paths = ['/foo/bar/baz', '/spam/eggs/baz', '/foo/bar/bar']
&gt;&gt;&gt; find_matching_paths(paths, '/foo/bar/*')
['/foo/bar/baz', '/foo/bar/bar']
&gt;&gt;&gt; find_matching_paths(paths, '/*/bar/b*')
['/foo/bar/baz', '/foo/bar/bar']
&gt;&gt;&gt; find_matching_paths(paths, '/*/[be]*/b*')
['/foo/bar/baz', '/foo/bar/bar', '/spam/eggs/baz']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On Python 3.4+ you can just use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.match" rel="noreferrer"><code>PurePath.match</code></a>.</p>
<pre><code>pathlib.PurePath(path_string).match(pattern)
</code></pre>
<p>On Python 3.3 or earlier (including 2.x), get <a href="https://pypi.python.org/pypi/pathlib/" rel="noreferrer"><code>pathlib</code> from PyPI</a>.</p>
<p>Note that to get platform-independent results (which will depend on <em>why</em> you're running this) you'd want to explicitly state <code>PurePosixPath</code> or <code>PureWindowsPath</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>While <a href="https://docs.python.org/2/library/fnmatch.html#fnmatch.fnmatch" rel="nofollow"><code>fnmatch.fnmatch</code></a> can be used directly to check whether a pattern matches a filename or not, you can also use the <code>fnmatch.translate</code> method to generate the regex out of the given <code>fnmatch</code> pattern:</p>
<pre><code>&gt;&gt;&gt; import fnmatch
&gt;&gt;&gt; fnmatch.translate('*.txt')
'.*\\.txt\\Z(?ms)'
</code></pre>
<p>From the <a href="https://docs.python.org/2/library/fnmatch.html#fnmatch.translate" rel="nofollow">documenation</a>:</p>
<blockquote>
<p><code>fnmatch.translate(pattern)</code></p>
<p>Return the shell-style pattern converted to a regular expression.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>never mind, I found it. I want the <a href="https://docs.python.org/2/library/fnmatch.html" rel="nofollow">fnmatch</a> module.</p>
</div>
<span class="comment-copy">Why the hell is this downvoted really?</span>
<span class="comment-copy">Can you add more content and context please? As in the expected output for a dummy file system</span>
<span class="comment-copy">So you want to give a list of files as a python <code>list</code> to glob, instead of it taking from the filesystem?</span>
<span class="comment-copy">@ap: it is a little more work than it looks like at first glance, when matching path elements at different levels.</span>
<span class="comment-copy">darnit, the moment I put up a bounty I get hit with a crapload of work at my job :-(  Sorry, can't elaborate much at the moment. The problem with fnmatch is that if you use <code>a/b/*/f.txt</code> it will not only match <code>a/b/c/f.txt</code> and <code>a/b/q/f.txt</code> (both intended matches) but also <code>a/b/c/d/f.txt</code> and <code>a/b/c/d/e/f.txt</code>, which behaves like the Mercurial ** glob. It looks like ** is not supported by fnmatch or glob, at least not directly.</span>
<span class="comment-copy">Great scoop! Yes, translating the pattern to one that ignores path separators is a great idea. Note that it doesn't handle <code>os.sep</code> or <code>os.altsep</code> though, but it should be easy enough to adjust for that.</span>
<span class="comment-copy">Thanks @martijn-pieters</span>
<span class="comment-copy">I usually just canonicalize paths into using forward slashes first before any processing.</span>
<span class="comment-copy">Oh wait -- fnmatch doesn't handle the pathname segmentization... sigh.</span>
<span class="comment-copy">Can you provide examples, where <code>fnmatch</code> does not handle your case?</span>
<span class="comment-copy">@BhargavRao: <code>glob.glob()</code> applies patters to path elements separetely</span>
<span class="comment-copy">@MartijnPieters Yep. But when you look at the cpython implementation of <a href="https://github.com/python/cpython/blob/74bfc0455896315d48a42eb7e4b52ab758adbac3/Lib/glob.py" rel="nofollow noreferrer">glob</a>, they just split on the path sep and recursively use <code>fnmatch</code>! So <i>What is the problem with using <code>fnmatch</code></i> is my question. (My draft answer is already ready based on few assumptions, Just waiting for the OP to clarify)</span>
<span class="comment-copy">Oops Martijn, you've answered on the same lines, up for that! Hadn't see your answer! Discarding my draft right away :)</span>
