<div class="post-text" itemprop="text">
<p>I am doing a hangman project in python, and am having a bit of trouble. When a letter in the word is repeated (eg. 'n' in 'banana') I want my code to output:</p>
<pre><code>&gt;&gt;&gt;_ _ N _ N _ 
</code></pre>
<p>instead of</p>
<pre><code>&gt;&gt;&gt;_ _ N _ _ _
</code></pre>
<p>as it does currently. Here is my code:</p>
<pre><code>def click_1 (key):
    if key in word:
        x = word.index(key)
        for key in word[x]:
            hidden_word[x] = key
            print (hidden_word)
    else:
        print ("Nope")
</code></pre>
<p>where:</p>
<pre><code>word = word_list[random.randint(0,3)]
</code></pre>
<p>and: </p>
<pre><code>hidden_word = ["_ "] * len(word)
</code></pre>
<p>If someone could provide help for this, I would greatly appreciate it.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>str.index()</code> only ever returns the <em>first match</em> in a string. Rather than finding each matching word, loop over all characters in <code>word</code> with an index provided by the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code> function</a>:</p>
<pre><code>def click_1 (key):
    if key in word:
        for index, character in enumerate(word):
            if character == key:
                hidden_word[index] = character
        print (hidden_word)
    else:
        print ("Nope")
</code></pre>
<p>Quick demo:</p>
<pre><code>&gt;&gt;&gt; word = 'BANANA'
&gt;&gt;&gt; hidden_word = ["_ "] * len(word)
&gt;&gt;&gt; def click_1 (key):
...     if key in word:
...         for index, character in enumerate(word):
...             if character == key:
...                 hidden_word[index] = character
...         print (hidden_word)
...     else:
...         print ("Nope")
... 
&gt;&gt;&gt; click_1('N')
['_ ', '_ ', 'N', '_ ', 'N', '_ ']
&gt;&gt;&gt; click_1('B')
['B', '_ ', 'N', '_ ', 'N', '_ ']
&gt;&gt;&gt; click_1('A')
['B', 'A', 'N', 'A', 'N', 'A']
</code></pre>
</div>
<span class="comment-copy">Why am I getting down voted? Am I doing something wrong?</span>
<span class="comment-copy">Thanks buddy, fixed the problem very simply and understandably. So enumerate is basically the same as index, except it doesn't only return one number?</span>
<span class="comment-copy">@18166: <code>enumerate()</code> simply adds a running index to a sequence. So <code>character</code> is bound to each character in <code>word</code>, and <code>enumerate()</code> adds a counter with that.</span>
<span class="comment-copy">There's a much easier way of handling this. Rather than trying to keep track of your "hidden word," just generate it on the fly each time. Your hidden word should always be <code>''.join([letter if letter in guessed_letters else "_" for ch in real_word])</code>. Since in a standard hangman game you should be saving the guessed letters anyway, this is a simple way to handle that.</span>
<span class="comment-copy">@adamsmith I like what you have put, but what is ch and real_world?</span>
<span class="comment-copy">@18166 whoops, <code>ch</code> was left over from a re-factor that was supposed to make it easier to understand, but that just made it harder :). <code>real_word</code> is the opposite of <code>hidden_word</code> -- it's the actual unmasked word. So it would be something like <code>''.join([letter if letter in guessed_letters else "_" for letter in word])</code></span>
