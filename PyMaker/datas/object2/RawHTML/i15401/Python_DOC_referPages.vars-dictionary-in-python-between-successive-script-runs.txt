<div class="post-text" itemprop="text">
<p>I am trying to develop a simpler protocol for documenting the namespace of my work environment, before, during and after a script is run.  Apparently, the only things I have available in Python, is to access the vars(), locals() or globals() dictionaries before I run a script, then immediately after.  This is moderately successful, in the sense that I can capture the namespace additions (via their keys) but I have no way of knowing the order in which the various entities are added to the dictionary.  Short of manually sorting the list to produce a time sequential list, is there anything I have overlooked in trying to determine the order that the namespace is created.  Below is the results of a before and after snapshot of the vars() dictionary:</p>
<pre><code>&gt;&gt;&gt; # vars() keys before running script
&gt;&gt;&gt; vars_keys_0 = vars().keys()
&gt;&gt;&gt; for key in vars_keys_0:
...     print('key: {:&lt;15} - {}'.format(key,type(vars()[key])))
... 
key: __builtins__    - &lt;type 'module'&gt;
key: __name__        - &lt;type 'str'&gt;
key: pywin           - &lt;type 'module'&gt;
key: __doc__         - &lt;type 'NoneType'&gt;
key: __package__     - &lt;type 'NoneType'&gt;
&gt;&gt;&gt; 
&gt;&gt;&gt; # vars() keys after running script
&gt;&gt;&gt; vars_keys_1 = vars().keys()
&gt;&gt;&gt; for key in vars_keys_1:
...     print('key: {:&lt;15} - {}'.format(key,type(vars()[key])))
...     
key: rand_pnts       - &lt;class 'numpy.core.records.recarray'&gt;
key: arr             - &lt;class 'numpy.core.records.recarray'&gt;
key: random          - &lt;type 'module'&gt;
key: extent_LRBT     - &lt;type 'function'&gt;
key: pnts            - &lt;type 'list'&gt;
    ..... snip ....
key: lineIntersect   - &lt;type 'function'&gt;
key: from_XsYs       - &lt;type 'function'&gt;
key: from_extent     - &lt;type 'function'&gt;
key: Xs              - &lt;type 'list'&gt;
key: vars_keys_0     - &lt;type 'list'&gt;
key: lineIntersect2  - &lt;type 'function'&gt;
&gt;&gt;&gt;
</code></pre>
<p>Differences between steps are easy to collect via sets:</p>
<pre><code>v1 = vars().keys() # at step 1
v2 = vars().keys() # at step 2 then
diff = set(v2).difference(set(v1))  # yields the difference in namespace
</code></pre>
<p>The dictionaries are unordered as expected, but surely I am missing something that would enable one to gather namespace additions in sequential order.</p>
<p>EDIT:
With the additional suggestion from below, I tried this simple script to test</p>
<pre><code>import sys
def zipper(Xs,Ys):
  '''zip two lists'''
  return zip(Xs,Ys)
#--------------------------------------------------------------------
if __name__ == "__main__":
  _order = []
  _seen = set(vars())
  def trace_names(frame, event, arg):
    if event == 'call' and arg is None:
      # enter first frame, return 'local' trace
      return trace_names
    if event in ('line', 'return'):
      # (last) line in top-level frame executed
      _order.extend(frame.f_globals.viewkeys() - _seen)
      _seen.update(frame.f_globals)
  sys.settrace(trace_names)

  Xs = [0,0,2,2,0]
  Ys = [1,3,3,1,1]
  print('Zipped lists {}',format(zipper(Xs,Ys)))

  sys.settrace(None)
  print(_order)
</code></pre>
<p>The results unfortunately are more confusing:
('Zipped lists {}', '[(0, 1), (0, 3), (2, 3), (2, 1), (0, 1)]')
['trace_names', '_seen', 'Xs', 'Ys', 'CmdTarget', 'Object', 'win32ui', 'default_scintilla_encoding', 'app', 'Queue', 'thread_test', 'WindowOutputDocument', 'WindowOutputDocumentParent', 're', 'window', 'WindowOutputViewScintilla', 'test', 'string', 'WindowOutput', 'scintillacon', 'docview', 'WindowOutputView', 'RTFWindowOutput', 'WindowOutputFrame',.......'ScintillaControlInterface', 'EM_GETSELTEXT', 'EM_EXSETSEL', 'dllid', 'EM_EXLINEFROMCHAR', 'EM_FINDTEXTEX', 'ScintillaNotification', 'os']</p>
<p>If the def placement is in error, please advise.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only way to track order is to use full-on tracing. You could do that with the <a href="https://docs.python.org/3/library/sys.html#sys.settrace" rel="nofollow"><code>sys.settrace()</code> hook</a>, but you'll have to move everything into a <code>main()</code> function as you cannot attach a tracer to the <em>current</em> frame, only new frames:</p>
<pre><code>import sys

_order = []
_seen = set()

def trace_names(frame, event, arg):
    if event == 'call' and arg is None:
        # enter first frame, return 'local' trace
        return trace_names
    if event in ('line', 'return'):
        # (last) line in top-level frame executed
        _order.extend(frame.f_locals.viewkeys() - _seen)
        _seen.update(frame.f_locals)

sys.settrace(trace_names)

# run your script
main()

sys.settrace(None)
print(_order)
</code></pre>
<p>This traces the order of locals added in the next scope <em>only</em>; if any functions modify globals you could not determine their exact order other than in whole groups, by inspecting <code>globals()</code> from the tracer.</p>
</div>
<span class="comment-copy">I don't understand why the order matters here.</span>
<span class="comment-copy">Simple...I am trying to develop a flowchart of the process run.  I use flowcharts for teaching purposes and also for documention, ergo, order is important.  I manually order the differences in the dictionaries now.  My question then becomes, python "knows" when things were done...is there a way to access this list of events from namespace or elsewhere.</span>
<span class="comment-copy">That I am afraid yielded everything... ['pnts', 'Ys', 'trace_names', '_seen', 'Xs', 'fromarrays', 'array', '<b>all</b>', 'record', '_typestr', 'types', 'fromfile', 'nt', '_byteorderconv', 'chararray', 'ndarray', 'isfileobj', 'get_remaining_size', 'format_parser', 'bytes', 'find_duplicate', 'recarray', 'fromstring', 'sb', 'os', 'fromrecords', 'numfmt', 'arr', 'CmdTarget', 'Object', 'win32ui', 'default_scintilla_encoding', 'app', ...... plus hundreds more.  I loaded the above after my if <b>name</b> == "<b>main</b>": line with the last two lines after the <b>main</b> code block</span>
<span class="comment-copy">@Dan: put your main code in a function, and if needed trace the <code>f_locals</code> too. You are now tracing the globals of anything your top-level code calls.</span>
<span class="comment-copy">tried in a main block and I got rid of it and moved everything after the defs with my code between your ... sys.settrace(trace_names) ... my 4 lines of code ... sys.settrace(None) and I got the following with or without a main block &gt;&gt;&gt; ('Zipped lists {}', '[(0, 1), (0, 3), (2, 3), (2, 1), (0, 1)]') ['Xs', 'Ys', 'self', 'attr', 'o', 'msg', 'message', 'item', 'timeout', 'block', 'n', '_Condition__waiters', .... 'rc', 'len', 'str', 'end', 'currentPos', 'anchorPos', 'atEnd', 'text', 'start', 'cr', 'crBuff', 'addressCrBuff'] .  I think I am getting further from what I need</span>
<span class="comment-copy">@DanPatterson: made it a little clearer; you <i>have</i> to start a new scope, at which point you may as well use a <code>main</code> function (or you'd need to make this a separate file and import your original script as a module, at which point you'll need to trace <code>f_globals</code>).</span>
<span class="comment-copy">Thanks for your help @Martijn but at this stage I think it will be quicker to collect namespace in my doc header as I go along.</span>
