<div class="post-text" itemprop="text">
<p>I built a simple Python program to find if an input is a power of two or not. I have two functions, <code>power_of_two</code> and <code>play_again</code>. After <code>power_of_two</code> runs, <code>play_again</code> then runs and reruns <code>power_of_two</code> </p>
<p>Here's my code:</p>
<pre><code>num = int(raw_input('Input a number (type 0 to quit): '))
def power_of_two(x):
    y=1
    z=[]
    while y &lt; x:
        y=y*2
        z.append(y)
    if x in z or x == 1:
        print 'true'
    elif x == 0:
        quit()
    else: 
        print 'false'
    play_again()

def play_again():
    num = int(raw_input('Input a number: '))
    power_of_two(num)

power_of_two(num)
</code></pre>
<p><strong>Is code like this acceptable among Python programmers or is there a better way to replicate what I am doing here?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>One problem with this approach is that you will eventually run out of stack, because we have a pair of mutually recursive functions. Each call uses up memory in the stack, which is never recovered.</p>
<p>This isn't obvious with an interactive program since it will take a long time to create enough recursive calls, but if we speed things up:</p>
<pre><code>def power_of_two(x):
    print(str(x))
    play_again(x)

def play_again(x):
    power_of_two(x+1)

power_of_two(1)
</code></pre>
<p>We get:</p>
<pre><code>RuntimeError: maximum recursion depth exceeded while calling a Python object
</code></pre>
<p>Some languages can do tail-call optimisation so this technique works fine - but in Python it's better to create a loop to "play again", unless you can be sure that there will only be a small call depth.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not a very good way to programme in general because (aside from the possible maximum recursion depth problem) if your programme gets more complicated, you will end up with multiple <a href="http://en.wikipedia.org/wiki/Spaghetti_code" rel="nofollow">spaghetti-like</a> jumps between different functions, making it increasingly hard to read and debug.</p>
<p>Instead it is more standard to have a <code>main</code> function that controls the overall programme flow and calls the other functions. It will also be better to have a clearer separation of roles between the two functions.</p>
<pre><code>def power_of_two(x):
    y = 1
    while y &lt; x:
        y *= 2
    return y == x

def get_number():
    return int(raw_input('Input a number (type 0 to quit): '))

def main():
    while True:
        n = get_number()
        if n == 0:
            return
        print power_of_two(n)

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No - as was already said, you have the risk to run into stack overflow.</p>
<p>You would better do</p>
<pre><code>def power_of_two(x):
    y=1
    z=[]
    while y &lt; x:
        y=y*2
        z.append(y)
    if x in z or x == 1:
        print 'true'
    elif x == 0:
        quit()
    else: 
        print 'false'


def play():
    while True:
        num = int(raw_input('Input a number (type 0 to quit): '))
        power_of_two(num)
</code></pre>
<p>This is close to your solution, but far from perfect.</p>
<p>It would be better to jet the function just do what it promises: check if the number is a power of two and nothing else.</p>
<pre><code>def power_of_two(x):
    y = 1
    z = set((1,)) # as only "in" is performed, a set is better here...
    # Having 1 in the set initially saves the extra check for x == 1...
    while y &lt; x:
        y = y * 2
        z.append(y)
    return x in z


def play():
    while True:
        num = int(raw_input('Input a number (type 0 to quit): '))
        if num == 0:
            return # or just break
        else:
            print power_of_two(num) # prints "True" or "False"
            print 'true' if power_of_two(num) else 'false' # prints "true" or "false"
</code></pre>
<p>If you want to use a for loop, you can craft an iterable in the form of a generator which yields values until there are no more:</p>
<pre><code>def numbers():
    while True:
        num = int(raw_input('Input a number (type 0 to quit): '))
        if num == 0:
            return # or just break
        else:
            yield num

def play():
    for num in numbers():
        # power_of_two() is the same as above.
        print power_of_two(num) # prints "True" or "False"
        print 'true' if power_of_two(num) else 'false' # prints "true" or "false"
</code></pre>
<p>Even this inner while loop can be replaced with a for loop, e. g. for counting:</p>
<pre><code>def numbers():
    import itertools
    for round in itertools.count(1):
        num = int(raw_input('Input number ' + str(round) + ' (type 0 to quit): '))
        if num == 0:
            return # or just break
        else:
            yield num
</code></pre>
</div>
<span class="comment-copy">This might be more appropriate for the <a href="http://codereview.stackexchange.com">code review stack exchange</a>.</span>
<span class="comment-copy">Try using OOP @michaelpri</span>
<span class="comment-copy">@michaelpri You would probably get more answers and better reception there, but it's up to you.</span>
<span class="comment-copy">@michaelpri That depends on if you can provide an iterable which brings the needed conditions.</span>
<span class="comment-copy">Why use <code>quit()</code> instead of just <code>break</code>? From the <a href="https://docs.python.org/3/library/constants.html?highlight=quit#quit" rel="nofollow noreferrer">docs</a> I don't quite understand when <code>quit()</code> is appropriate.</span>
<span class="comment-copy">@HÃ¥kenLid You are right; I used it here only because the OP used it.</span>
