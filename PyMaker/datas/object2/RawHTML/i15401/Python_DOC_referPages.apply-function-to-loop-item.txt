<div class="post-text" itemprop="text">
<p>Consider the code below:</p>
<pre><code>f = open('file.txt')

for l in f:
    k = l.strip() # Remove the newline character.
    print(k)

f.close()
</code></pre>
<p>I'd like to automatically remove the newline. I know I could do:</p>
<pre><code>for k in [l.strip() for l in f]:
    print(k)
</code></pre>
<p>But this requires looping the length of <code>f</code> twice (and loading the whole thing into memory). I'm wondering if there is something even more Pythonic like:</p>
<pre><code>for lambda l: l.strip() in f:
    print(l)
</code></pre>
<p>or maybe just:</p>
<pre><code>for l.strip() in f:
    print(l)
</code></pre>
<p>Of course, neither of these work. To see how this could be applied elsewhere, here's an example with nested lists:</p>
<pre><code>d =  [['hi'], ['hello'], ['howdy']]
for item in d:
    item = item[0] # Get the nested item.
    if item == 'hello':
         print(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Welcome to the world of Python iterators :)</p>
<p>You have the right idea with the list comprehensions, except you want it to lazy-load and not build up the entire list in memory first (which may even be untenable for very large files): use <strong>generator expressions</strong> instead, which have the same syntax except the square brackets are replaced by parentheses (which you can omit if it is the sole argument to a function):</p>
<pre><code>with open(filename) as f:
    for l in (l.strip() for l in f.readlines()):
        print(l)
</code></pre>
<blockquote>
<p><strong>Source:</strong> Read more about them in <a href="http://legacy.python.org/dev/peps/pep-0289/" rel="nofollow">the relevant Python Enhancement Proposal</a> and the <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow">official docs</a>.</p>
</blockquote>
<hr/>
<p>An alternative, functional way of doing it with a syntax similar to LISP's is using <code>map</code> which applies a function to each element of an iterator — it doesn't have to be a sequence, and assuming you're on Python this will involve looping through all the lines just once:</p>
<pre><code>for l in map(lambda l: l.strip (), f):
    print(l)
</code></pre>
<hr/>
<p>Also, <code>f.readlines()</code> would probably be clearer than just looping over <code>f</code>, and a <code>with</code> statement is more Pythonic than calling <code>f.close()</code> yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow">generator expression</a>:</p>
<pre><code>for k in (l.strip() for l in f):
    print(k)
</code></pre>
<p>This is very similar to the list comprehension, except that it produces items lazily (one-by-one) instead of collecting them all into a list at once.  So, we only loop the length of <code>f</code> a single time and also avoid dumping everything into memory all at one time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Haven't tested but should be right: the important part is using <code>replace</code>. In my opinion a for loop is a valid way to do it, but if you want a one liner, use something like:</p>
<pre><code>no_new_lines = None
with open('path/to/file', 'rb') as file_content:
    no_new_lines = file_content.read().replace('\r\n', '\n').replace('\n', '')
</code></pre>
<p>Please do note that "<code>replace</code>" makes a copy of the to-be-replaced content. A huge file opened on a system with little memory will cause issues (<code>MemoryError</code>). Anyway, test it, see what works better.</p>
</div>
<span class="comment-copy">The second way seems enoughly pythonic to me</span>
<span class="comment-copy">What do you mean "automatically" remove the newline?  Your first example is fine.  Just do what you need to do inside the loop.</span>
<span class="comment-copy">Wow, thanks for all the quick responses. Python always has a fantastic way to get what you want. Both YatharthROCK's and iCodez's answers are great. Since @YatharthROCK came with a few references, I accepted it.</span>
<span class="comment-copy">Do you know whether this has been back-ported to 2?</span>
<span class="comment-copy">Yes, generator expressions have been around since version 2.4.  See here for details: <a href="https://docs.python.org/3/whatsnew/2.4.html#pep-289-generator-expressions" rel="nofollow noreferrer">docs.python.org/3/whatsnew/…</a></span>
<span class="comment-copy">Oh cool, I thought they were a Python 3 only thing with all the other lazy-loading aspects of map, sorted and the rest. You've been using it for much longer than I have ;)</span>
