<div class="post-text" itemprop="text">
<p>I'm parsing a binary file format and I want a better way to check for the end of a file while performing a read or seek. Basically, when I f.read(8) on a file f, I want to know if less than 8 bytes are returned without having to check the length of the returned value. Similarly, if I call f.seek(8, 1), I want to know if I didn't actually seek 8 bytes. Is my best bet to create wrappers for these functions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Checking the length of the string returned by <code>read()</code> is simple, clean, and efficient. All of Python's collection objects (strings, lists, tuples, dicts, sets, etc) store their length as an attribute, so fetching the length is a very cheap and fast operation.</p>
<p>However, testing that data is correct before you operate on it can be tedious and cumbersome. And if the data is almost always correct such testing is inefficient. This coding style is called Look Before You Leap or <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow">LBYL</a>. In contrast, a popular coding style in Python is It is Easier to Ask for Forgiveness than Permission or <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">EAFP</a>. In other words, rather than testing the data and then deciding how to proceed, simply assume that the data is correct, and raise an exception if problems arise.</p>
<p>EAFP code is generally easier to implement, read and maintain than LBYL code. And in Python <code>try: ... except</code> is very efficient, and often faster than equivalent <code>if: ... else:</code> code, so use of exceptions is encouraged. See the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Exceptions" rel="nofollow">Python syntax and semantics</a>.  </p>
<p>So rather than testing that the data is the correct length before attempting to unpack it you can just put all your <code>struct.unpack()</code> calls into a <code>try: ... except struct.error</code> block and bail out if the exception is raised. This approach means you don't need to worry about whether each of your <code>seek()</code> or <code>read()</code> calls take you past the end of the file.</p>
<p>If you do want to stick with the LBYL approach you <em>could</em> write a wrapper for <code>seek()</code> but it won't be very efficient, since there's no simple way to tell if you seek past the end of the file. So such a wrapper would add extra overhead to every <code>seek()</code> call, which wastes CPU time if most of those calls don't take you past the end of the file. </p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>f = open("some.txt", "rw+")    


str1 = f.read(8)

for num in range(1,9):
    f.seek(0,0)
    str2 = f.read(8-num)
    if str1 == str2:
        print 'file is less than 8'
        break


f.close()
</code></pre>
<p>8 can be replaced with a variable. I don't see why you wouldn't compare lengths.</p>
<p>EDIT: Here's the entire thing.</p>
</div>
<span class="comment-copy"><i>I want to know if less than 8 bytes are returned without having to check the length of the returned value</i>: why?</span>
<span class="comment-copy">For example, I might try and read in 4 bytes because the format specification says the next 4 bytes represents an unsigned integer. If there are less than 4 bytes, the following call to struct.unpack("&gt;I", inputBytes) will throw an error. Similarly, if the length indicator says the data section will be 512 bytes, if the read doesn't return 512 bytes, some error may error while trying to handle the data. Finally, if there's a 4 byte field I want to skip over, if I try and skip over it but it ends up putting me at the end of the file, I want to know so I can exit.</span>
<span class="comment-copy">As <b>the</b> original paladin of EAFP vs LBYL, see e.g <a href="https://books.google.com/books?id=JnR9hQA3SncC&amp;pg=PA134&amp;lpg=PA134&amp;dq=martelli+eafp&amp;source=bl&amp;ots=Jc2_Jv24-v&amp;sig=qPAmiAgU8EFgA4NPlCqs3OZm_SU&amp;hl=en&amp;sa=X&amp;ei=-uicVL-eOImZgwTB64KIDQ&amp;ved=0CDMQ6AEwAw#v=onepage&amp;q=martelli%20eafp&amp;f=false" rel="nofollow noreferrer">books.google.com/â€¦</a> , I can do no less than up this comment!-)</span>
<span class="comment-copy">Thanks, @AlexMartelli! Although you can do EAFP in any language, the fact that Python makes it especially easy is one of the main things I love about writing in Python.</span>
<span class="comment-copy">Why the downvote? Is there something wrong with this code? Please point it out.</span>
<span class="comment-copy">@user2999500 did you downvote this code?</span>
