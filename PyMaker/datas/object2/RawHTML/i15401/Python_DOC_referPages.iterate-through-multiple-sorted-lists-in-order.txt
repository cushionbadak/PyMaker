<div class="post-text" itemprop="text">
<p>Suppose I have a number of lists of pairs (int, str), not necessarily of the same length. The only constraint here is that the lists are sorted in ascending order by their integer parts:</p>
<pre><code>a = [(1, 'a'), (4, 'a'), (6, 'b'), (7, 'c'), (12, 'a')]
b = [(5, 'd'), (10, 'c'), (11,'e')]
c = [(0, 'b'), (3, 'd')]
</code></pre>
<p>What I would like to do is to emit the string elements in the order in which their corresponding integer elements occur i.e. in this case:</p>
<pre><code>(0, 'b'), (1, 'a'), (3, 'd'), (4, 'a'), ... 
</code></pre>
<p>I am wondering if there is an obvious (nice + pythonic) way to do this just using iterators of <code>a</code>, <code>b</code> and <code>c</code>? I've looked at <code>itertools</code> but can't immediately see how to use the functionality in this case. The lists <code>a</code>, <code>b</code>, <code>c</code> might be very large so I'd like to do this without reading them into memory and then sorting ...</p>
</div>
<div class="post-text" itemprop="text">
<p>Since the lists are already sorted, you can use <a href="https://docs.python.org/3/library/heapq.html#heapq.merge"><code>heapq.merge</code></a>:</p>
<pre><code>&gt;&gt;&gt; import heapq
&gt;&gt;&gt; a = [(1, 'a'), (4, 'a'), (6, 'b'), (7, 'c'), (12, 'a')]
&gt;&gt;&gt; b = [(5, 'd'), (10, 'c'), (11,'e')]
&gt;&gt;&gt; c = [(0, 'b'), (3, 'd')]
&gt;&gt;&gt; for i in heapq.merge(a, b, c):
...     i
...
(0, 'b')
(1, 'a')
(3, 'd')
(4, 'a')
(5, 'd')
(6, 'b')
(7, 'c')
(10, 'c')
(11, 'e')
(12, 'a')
&gt;&gt;&gt;
</code></pre>
<p>This is also very efficient with large lists since it uses iterators internally.  From the docs link given above:</p>
<blockquote>
<p>Similar to <code>sorted(itertools.chain(*iterables))</code> but returns an
  iterable, <strong>does not pull the data into memory all at once</strong>, and
  assumes that each of the input streams is already sorted (smallest to
  largest).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_iterator = iter(sorted(a+b+c))
</code></pre>
<p>is by far the most pythonic imho (although you can probably just leave it as a list and not wrap the extra <code>iter</code></p>
<p>you could certainly speed it up if this was a bottleneck(which I doubt it is)</p>
</div>
<div class="post-text" itemprop="text">
<p><code>heapq.merge</code> is likely the best choice.  FWIW <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> also offers a mergesort tool, similar to the accepted accepted answer:</p>
<pre><code>import operator as op

import more_itertools

list(more_itertools.collate(a, b, c, key=op.itemgetter(0)))
</code></pre>
<p>Output</p>
<pre><code>[(0, 'b'),
 (1, 'a'),
 (3, 'd'),
 (4, 'a'),
 (5, 'd'),
 (6, 'b'),
 (7, 'c'),
 (10, 'c'),
 (11, 'e'),
 (12, 'a')]
</code></pre>
<p>See <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collate" rel="nofollow noreferrer"><code>more_itertools</code> docs</a> for more information.</p>
</div>
<span class="comment-copy">There is no way to do it without reading them all.  If you don't read them all, you can't know whether the one you didn't read should actually have come out first.  Also, if they're lists, they're already all in memory anyway.</span>
<span class="comment-copy">more performant than my answer ... especially if the lists are large</span>
<span class="comment-copy">hey bro can we use collections.deque, how will be performance of it???</span>
<span class="comment-copy">The lists are already sorted. No need to sort them again. In this case heapq.merge() a better option.</span>
