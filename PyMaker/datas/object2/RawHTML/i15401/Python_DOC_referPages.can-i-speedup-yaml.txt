<div class="post-text" itemprop="text">
<p>I made a little test case to compare YAML and JSON speed :</p>
<pre><code>import json
import yaml
from datetime import datetime
from random import randint

NB_ROW=1024

print 'Does yaml is using libyaml ? ',yaml.__with_libyaml__ and 'yes' or 'no'

dummy_data = [ { 'dummy_key_A_%s' % i: i, 'dummy_key_B_%s' % i: i } for i in xrange(NB_ROW) ]


with open('perf_json_yaml.yaml','w') as fh:
    t1 = datetime.now()
    yaml.safe_dump(dummy_data, fh, encoding='utf-8', default_flow_style=False)
    t2 = datetime.now()
    dty = (t2 - t1).total_seconds()
    print 'Dumping %s row into a yaml file : %s' % (NB_ROW,dty)

with open('perf_json_yaml.json','w') as fh:
    t1 = datetime.now()
    json.dump(dummy_data,fh)
    t2 = datetime.now()
    dtj = (t2 - t1).total_seconds()
    print 'Dumping %s row into a json file : %s' % (NB_ROW,dtj)

print "json is %dx faster for dumping" % (dty/dtj)

with open('perf_json_yaml.yaml') as fh:
    t1 = datetime.now()
    data = yaml.safe_load(fh)
    t2 = datetime.now()
    dty = (t2 - t1).total_seconds()
    print 'Loading %s row from a yaml file : %s' % (NB_ROW,dty)

with open('perf_json_yaml.json') as fh:
    t1 = datetime.now()
    data = json.load(fh)
    t2 = datetime.now()
    dtj = (t2 - t1).total_seconds()
    print 'Loading %s row into from json file : %s' % (NB_ROW,dtj)

print "json is %dx faster for loading" % (dty/dtj)
</code></pre>
<p>And the result is :</p>
<pre><code>Does yaml is using libyaml ?  yes
Dumping 1024 row into a yaml file : 0.251139
Dumping 1024 row into a json file : 0.007725
json is 32x faster for dumping
Loading 1024 row from a yaml file : 0.401224
Loading 1024 row into from json file : 0.001793
json is 223x faster for loading
</code></pre>
<p>I am using PyYAML 3.11 with libyaml C library on ubuntu 12.04.
I know that json is much more simple than yaml, but with a 223x ratio between json and yaml I am wondering whether my configuration is correct or not.</p>
<p>Do you have same speed ratio ?<br/>
How can I speed up <code>yaml.load()</code> ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You've probably noticed that Python's syntax for data structures is <strong>very</strong> similar to JSON's syntax.</p>
<p>What's happening is Python's <code>json</code> library encodes Python's builtin datatypes <a href="https://github.com/python-git/python/blob/master/Lib/json/decoder.py" rel="nofollow noreferrer">directly into text chunks</a>, replacing <code>'</code> into <code>"</code> and deleting <code>,</code> here and there (to oversimplify a bit).</p>
<p>On the other hand, <code>pyyaml</code> has to <a href="http://pyyaml.org/wiki/PyYAMLDocumentation#Dumper" rel="nofollow noreferrer">construct a whole representation graph</a> before serialising it into a string.</p>
<p>The same kind of stuff has to happen backwards when loading.</p>
<p>The only way to speedup <code>yaml.load()</code> would be to write a new <code>Loader</code>, but I doubt it could be a huge leap in performance, except if you're willing to write your own single-purpose sort-of <code>YAML</code> parser, taking <a href="https://stackoverflow.com/questions/2451732/how-is-it-that-json-serialization-is-so-much-faster-than-yaml-serialization-in-p#comment7661771_2452043">the following comment</a> in consideration:</p>
<blockquote>
<p>YAML builds a graph because it is a general-purpose serialisation
  format that is able to represent multiple references to the same
  object. If you know no object is repeated and only basic types appear,
  you can use a json serialiser, it will still be valid YAML.</p>
</blockquote>
<p>-- <strong>UPDATE</strong></p>
<p>What I said before remains true, but if you're running <code>Linux</code> there's a way to speed up <code>Yaml</code> parsing. By default, Python's <code>yaml</code> uses the Python parser. You have to tell it that you want to use <code>PyYaml</code> <code>C</code> parser.</p>
<p>You can do it this way:</p>
<pre><code>import yaml
from yaml import CLoader as Loader, CDumper as Dumper

dump = yaml.dump(dummy_data, fh, encoding='utf-8', default_flow_style=False, Dumper=Dumper)
data = yaml.load(fh, Loader=Loader)
</code></pre>
<p>In order to do so, you need <code>yaml-cpp-dev</code> (package later renamed to <code>libyaml-cpp-dev</code>) installed, for instance with apt-get:</p>
<pre><code>$ apt-get install yaml-cpp-dev
</code></pre>
<p>And <code>PyYaml</code> with <code>LibYaml</code> as well. But that's already the case based on your output.</p>
<p>I can't test it right now because I'm running OS X and <code>brew</code> has some trouble installing <code>yaml-cpp-dev</code> but if you follow <a href="http://pyyaml.org/wiki/PyYAMLDocumentation" rel="nofollow noreferrer">PyYaml documentation</a>, they are pretty clear that performance will be much better.</p>
</div>
<div class="post-text" itemprop="text">
<p>For reference, I compared a couple of human-readable formats and indeed Python's yaml reader is <em>by far</em> the slowest. (Note the log-scaling in the below plot.) If you're looking for speed, you want <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">Python's built-in JSON reader</a>:</p>
<p><a href="https://i.stack.imgur.com/iExgn.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/iExgn.png"/></a></p>
<hr/>
<p>Code to reproduce the plot:</p>
<pre><code>import numpy
import perfplot

import json
import yaml
from yaml import Loader, CLoader
import pandas


def setup(n):
    data = numpy.random.rand(n, 3)

    with open('out.yml', 'w') as f:
        yaml.dump(data.tolist(), f)

    with open('out.json', 'w') as f:
        json.dump(data.tolist(), f, indent=4)

    with open('out.dat', 'w') as f:
        numpy.savetxt(f, data)

    return


def yaml_python(arr):
    with open('out.yml', 'r') as f:
        out = yaml.load(f, Loader=Loader)
    return out


def yaml_c(arr):
    with open('out.yml', 'r') as f:
        out = yaml.load(f, Loader=CLoader)
    return out


def json_read(arr):
    with open('out.json', 'r') as f:
        out = json.load(f)
    return out


def loadtxt(arr):
    with open('out.dat', 'r') as f:
        out = numpy.loadtxt(f)
    return out


def pandas_read(arr):
    out = pandas.read_csv('out.dat', header=None, sep=' ')
    return out.values


perfplot.show(
    setup=setup,
    kernels=[
        yaml_python, yaml_c, json_read, loadtxt, pandas_read
        ],
    n_range=[2**k for k in range(18)],
    logx=True,
    logy=True,
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, I also noticed that JSON is way faster. So a reasonable approach would be to convert YAML to JSON first. If you don't mind ruby, then you can get a big speedup and ditch the <code>yaml</code> install altogether:</p>
<pre><code>import commands, json
def load_yaml_file(fn):
    ruby = "puts YAML.load_file('%s').to_json" % fn
    j = commands.getstatusoutput('ruby -ryaml -rjson -e "%s"' % ruby)
    return json.loads(j[1])
</code></pre>
<p>Here is a comparison for 100K records:</p>
<pre><code>load_yaml_file: 0.95 s
yaml.load: 7.53 s
</code></pre>
<p>And for 1M records:</p>
<pre><code>load_yaml_file: 11.55 s
yaml.load: 77.08 s
</code></pre>
<p>If you insist on using yaml.load anyway, remember to put it in a virtualenv to avoid conflicts with other software.</p>
</div>
<span class="comment-copy">loading is still 12x slower with yaml.my sample is a list of 600,000 empty dictionaries. Yaml doesn't need to do anything extra except slightly cleverer syntax analysis which should take almost no extra time.</span>
<span class="comment-copy">On mac: brew install yaml-cpp libyaml</span>
<span class="comment-copy">Jivan you're a bloody legend.  I was going to rewrite some python code in C++ to speed things up.  My 6MB yaml file took 53 seconds to load using the standard yaml loader, and only 3 seconds with CLoader.</span>
<span class="comment-copy">I am not sure why you are saying that the CLoader speedup is only of interest if you are running under Linux;  I just tried this under windows and it works, giving me a huge speedup.</span>
<span class="comment-copy">The comment you link to is incorrect. PyYAML doesn't build a graph. There are no connections between the <code>Node</code>s that the representer emits, not even in the case of a single object occurring multiple times in a data-structure.</span>
<span class="comment-copy">I don't mind ruby, but I do mind bogus answers. 1) you're not really using ruby, in your code you are using a <a href="https://ruby-doc.org/stdlib-2.3.0/libdoc/yaml/rdoc/YAML.html" rel="nofollow noreferrer">thin layer around libyaml C library</a>: "The underlying implementation is the libyaml wrapper Psych". 2) you compare that with PyYAML without the libyaml C library. If you had, you would see that Python wrapping libyaml is not 7 times slower but only a few percent. 3) the announcement for the deprecation of the <code>commands</code> module was made in PEP 0361 in 2006, you still propose to use that more than <b>eleven</b> years later.</span>
