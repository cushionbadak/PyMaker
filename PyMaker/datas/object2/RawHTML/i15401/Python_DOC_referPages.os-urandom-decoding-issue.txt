<div class="post-text" itemprop="text">
<p>Im trying to get a <em>private_key</em> so, I tried this:</p>
<pre><code>private_key = os.urandom(32).encode('hex')
</code></pre>
<p>But it throws this error:</p>
<pre><code>AttributeError: 'bytes' object has no attribute 'encode'
</code></pre>
<p>So I check questions and solved that, in Python3x bytes can be only <strong>decode.</strong> Then I change it to:</p>
<pre><code>private_key = os.urandom(32).decode('hex')
</code></pre>
<p>But now it throws this error:</p>
<pre><code>LookupError: 'hex' is not a text encoding; use codecs.decode() to handle arbitrary codecs
</code></pre>
<p>And I really didnt understand why. When I tried this after last error;</p>
<pre><code>private_key = os.urandom(32).codecs.decode('hex')
</code></pre>
<p>It says </p>
<blockquote>
<p>AttributeError: 'bytes' object has no attribute 'codecs'</p>
</blockquote>
<p>So I stuck, what can I do for fixing this? I heard this is working in Python 2x, but I need to use it in 3x.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/binascii.html#binascii.hexlify"><code>binascii.hexlify</code></a>. It works both in Python 2.x and Python 3.x.</p>
<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; binascii.hexlify(os.urandom(32))
b'daae7948824525c1b8b59f9d5a75e9c0404e46259c7b1e17a4654a7e73c91b87'
</code></pre>
<p>If you need a string object instead of a bytes object in Python 3.x, use <code>decode()</code>:</p>
<pre><code>&gt;&gt;&gt; binascii.hexlify(os.urandom(32)).decode()
'daae7948824525c1b8b59f9d5a75e9c0404e46259c7b1e17a4654a7e73c91b87'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, <code>bytes</code> object has no <code>.encode()</code> method (to strengthen Unicode text vs. binary data (bytes) distinction).</p>
<p>For bytes to bytes conversions, you could <a href="https://docs.python.org/3/library/codecs.html#codecs.encode" rel="nofollow">use <code>codecs.encode()</code> method</a>:</p>
<pre><code>import codecs
import os

print(codecs.encode(os.urandom(32), 'hex').decode())
</code></pre>
<p>And in reverse:</p>
<pre><code>print(codecs.decode(hex_text, 'hex')) # print representation of bytes object
</code></pre>
<p>Note: there is no <code>.decode()</code> call because bytes returned by <code>os.urandom</code> has no character encoding (it is not a text, it is just a random sequence of bytes).</p>
<p><code>codecs</code> may use <code>binascii.hexlify</code>, <code>binascii.unhexlify</code> internally.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>private_key = "".join(["%02x" % ord(x) for x in os.urandom(32)])
</code></pre>
</div>
<span class="comment-copy">Still giving same error</span>
<span class="comment-copy">@tamamdir, Could you show the traceback?</span>
<span class="comment-copy"><i>private_key = binascii.hexlify(os.urandom(32)).decode('hex') LookupError: 'hex' is not a text encoding; use codecs.decode() to handle arbitrary codecs</i></span>
<span class="comment-copy">@tamamdir, Remove <code>.decode('hex')</code> part. Just <code>binascii.hexlify(os.urandom(32))</code> or <code>binascii.hexlify(os.urandom(32)).decode()</code></span>
<span class="comment-copy">This produces the error: TypeError: ord() expected string of length 1, but int found.</span>
<span class="comment-copy">Mr. Me so remove ord(), leave just x.  I've only 2.7 on BSD and Linux in my order, maybe on other platform urandom() work differently</span>
