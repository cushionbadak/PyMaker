<div class="post-text" itemprop="text">
<p>I need a way to compute the nth root of a long integer in Python. </p>
<p>I tried <code>pow(m, 1.0/n)</code>, but it doesn't work:</p>
<blockquote>
<p>OverflowError: long int too large to convert to float</p>
</blockquote>
<p>Any ideas?</p>
<p>By long integer I mean REALLY long integers like:</p>
<blockquote>
<p>11968003966030964356885611480383408833172346450467339251
  196093144141045683463085291115677488411620264826942334897996389
  485046262847265769280883237649461122479734279424416861834396522
  819159219215308460065265520143082728303864638821979329804885526
  557893649662037092457130509980883789368448042961108430809620626
  059287437887495827369474189818588006905358793385574832590121472
  680866521970802708379837148646191567765584039175249171110593159
  305029014037881475265618958103073425958633163441030267478942720
  703134493880117805010891574606323700178176718412858948243785754
  898788359757528163558061136758276299059029113119763557411729353
  915848889261125855717014320045292143759177464380434854573300054
  940683350937992500211758727939459249163046465047204851616590276
  724564411037216844005877918224201569391107769029955591465502737
  961776799311859881060956465198859727495735498887960494256488224
  613682478900505821893815926193600121890632</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can make it run slightly faster by avoiding the while loops in favor of setting low to 10 ** (len(str(x)) / n) and high to low * 10.  Probably better is to replace the len(str(x)) with the bitwise length and using a bit shift.  Based on my tests, I estimate a 5% speedup from the first and a 25% speedup from the second.  If the ints are big enough, this might matter (and the speedups may vary).  Don't trust my code without testing it carefully.  I did some basic testing but may have missed an edge case.  Also, these speedups vary with the number chosen.</p>
<p>If the actual data you're using is much bigger than what you posted here, this change may be worthwhile.</p>
<pre><code>from timeit import Timer

def find_invpow(x,n):
    """Finds the integer component of the n'th root of x,
    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.
    """
    high = 1
    while high ** n &lt; x:
        high *= 2
    low = high/2
    while low &lt; high:
        mid = (low + high) // 2
        if low &lt; mid and mid**n &lt; x:
            low = mid
        elif high &gt; mid and mid**n &gt; x:
            high = mid
        else:
            return mid
    return mid + 1

def find_invpowAlt(x,n):
    """Finds the integer component of the n'th root of x,
    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.
    """
    low = 10 ** (len(str(x)) / n)
    high = low * 10

    while low &lt; high:
        mid = (low + high) // 2
        if low &lt; mid and mid**n &lt; x:
            low = mid
        elif high &gt; mid and mid**n &gt; x:
            high = mid
        else:
            return mid
    return mid + 1

x = 237734537465873465
n = 5
tests = 10000

print "Norm", Timer('find_invpow(x,n)', 'from __main__ import find_invpow, x,n').timeit(number=tests)
print "Alt", Timer('find_invpowAlt(x,n)', 'from __main__ import find_invpowAlt, x,n').timeit(number=tests)
</code></pre>
<p>Norm 0.626754999161</p>
<p>Alt 0.566340923309</p>
</div>
<div class="post-text" itemprop="text">
<p>If it's a REALLY big number. You could use a binary search.</p>
<pre><code>def find_invpow(x,n):
    """Finds the integer component of the n'th root of x,
    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.
    """
    high = 1
    while high ** n &lt;= x:
        high *= 2
    low = high/2
    while low &lt; high:
        mid = (low + high) // 2
        if low &lt; mid and mid**n &lt; x:
            low = mid
        elif high &gt; mid and mid**n &gt; x:
            high = mid
        else:
            return mid
    return mid + 1
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; x = 237734537465873465
&gt;&gt;&gt; n = 5
&gt;&gt;&gt; y = find_invpow(x,n)
&gt;&gt;&gt; y
2986
&gt;&gt;&gt; y**n &lt;= x &lt;= (y+1)**n
True
&gt;&gt;&gt;
&gt;&gt;&gt; x = 119680039660309643568856114803834088331723464504673392511960931441&gt;
&gt;&gt;&gt; n = 45
&gt;&gt;&gt; y = find_invpow(x,n)
&gt;&gt;&gt; y
227661383982863143360L
&gt;&gt;&gt; y**n &lt;= x &lt; (y+1)**n
True
&gt;&gt;&gt; find_invpow(y**n,n) == y
True
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://code.google.com/p/gmpy/" rel="noreferrer">Gmpy</a> is a C-coded Python extension module that wraps the GMP library to provide to Python code fast multiprecision arithmetic (integer, rational, and float), random number generation, advanced number-theoretical functions, and more.</p>
<p>Includes a <code>root</code> function:</p>
<blockquote>
<p>x.root(n): returns a 2-element tuple (y,m), such that y is the
  (possibly truncated) n-th root of x; m, an ordinary Python int,
  is 1 if the root is exact (x==y**n), else 0.  n must be an ordinary
  Python int, &gt;=0.</p>
</blockquote>
<p>For example, 20th root:</p>
<pre><code>&gt;&gt;&gt; import gmpy
&gt;&gt;&gt; i0=11968003966030964356885611480383408833172346450467339251 
&gt;&gt;&gt; m0=gmpy.mpz(i0)
&gt;&gt;&gt; m0
mpz(11968003966030964356885611480383408833172346450467339251L)
&gt;&gt;&gt; m0.root(20)
(mpz(567), 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking for something standard, fast to write with high precision. I would use decimal and adjust the precision (getcontext().prec) to at least the length of x.</p>
<h2>Code (Python 3.0)</h2>
<pre><code>from decimal import *

x =   '11968003966030964356885611480383408833172346450467339251\
196093144141045683463085291115677488411620264826942334897996389\
485046262847265769280883237649461122479734279424416861834396522\
819159219215308460065265520143082728303864638821979329804885526\
557893649662037092457130509980883789368448042961108430809620626\
059287437887495827369474189818588006905358793385574832590121472\
680866521970802708379837148646191567765584039175249171110593159\
305029014037881475265618958103073425958633163441030267478942720\
703134493880117805010891574606323700178176718412858948243785754\
898788359757528163558061136758276299059029113119763557411729353\
915848889261125855717014320045292143759177464380434854573300054\
940683350937992500211758727939459249163046465047204851616590276\
724564411037216844005877918224201569391107769029955591465502737\
961776799311859881060956465198859727495735498887960494256488224\
613682478900505821893815926193600121890632'

minprec = 27
if len(x) &gt; minprec: getcontext().prec = len(x)
else:                getcontext().prec = minprec

x = Decimal(x)
power = Decimal(1)/Decimal(3)

answer = x**power
ranswer = answer.quantize(Decimal('1.'), rounding=ROUND_UP)

diff = x - ranswer**Decimal(3)
if diff == Decimal(0):
    print("x is the cubic number of", ranswer)
else:
    print("x has a cubic root of ", answer)
</code></pre>
<h2>Answer</h2>
<p>x is the cubic number of 22873918786185635329056863961725521583023133411
451452349318109627653540670761962215971994403670045614485973722724603798
107719978813658857014190047742680490088532895666963698551709978502745901
704433723567548799463129652706705873694274209728785041817619032774248488
2965377218610139128882473918261696612098418</p>
</div>
<div class="post-text" itemprop="text">
<p>Oh, for numbers <em>that</em> big, you would use the decimal module.</p>
<p>ns: your number as a string</p>
<pre><code>ns = "11968003966030964356885611480383408833172346450467339251196093144141045683463085291115677488411620264826942334897996389485046262847265769280883237649461122479734279424416861834396522819159219215308460065265520143082728303864638821979329804885526557893649662037092457130509980883789368448042961108430809620626059287437887495827369474189818588006905358793385574832590121472680866521970802708379837148646191567765584039175249171110593159305029014037881475265618958103073425958633163441030267478942720703134493880117805010891574606323700178176718412858948243785754898788359757528163558061136758276299059029113119763557411729353915848889261125855717014320045292143759177464380434854573300054940683350937992500211758727939459249163046465047204851616590276724564411037216844005877918224201569391107769029955591465502737961776799311859881060956465198859727495735498887960494256488224613682478900505821893815926193600121890632"
from decimal import Decimal
d = Decimal(ns)
one_third = Decimal("0.3333333333333333")
print d ** one_third
</code></pre>
<p>and the answer is: 2.287391878618402702753613056E+305</p>
<p>TZ pointed out that this isn't accurate... and he's right.  Here's my test.</p>
<pre><code>from decimal import Decimal

def nth_root(num_decimal, n_integer):
    exponent = Decimal("1.0") / Decimal(n_integer)
    return num_decimal ** exponent

def test():
    ns = "11968003966030964356885611480383408833172346450467339251196093144141045683463085291115677488411620264826942334897996389485046262847265769280883237649461122479734279424416861834396522819159219215308460065265520143082728303864638821979329804885526557893649662037092457130509980883789368448042961108430809620626059287437887495827369474189818588006905358793385574832590121472680866521970802708379837148646191567765584039175249171110593159305029014037881475265618958103073425958633163441030267478942720703134493880117805010891574606323700178176718412858948243785754898788359757528163558061136758276299059029113119763557411729353915848889261125855717014320045292143759177464380434854573300054940683350937992500211758727939459249163046465047204851616590276724564411037216844005877918224201569391107769029955591465502737961776799311859881060956465198859727495735498887960494256488224613682478900505821893815926193600121890632"
    nd = Decimal(ns)
    cube_root = nth_root(nd, 3)
    print (cube_root ** Decimal("3.0")) - nd

if __name__ == "__main__":
    test()
</code></pre>
<p>It's off by about 10**891</p>
</div>
<div class="post-text" itemprop="text">
<p>Possibly for your curiosity:</p>
<p><a href="http://en.wikipedia.org/wiki/Hensel_Lifting" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Hensel_Lifting</a></p>
<p>This could be the technique that Maple would use to actually find the nth root of large numbers.</p>
<p>Pose the fact that <code>x^n - 11968003.... = 0 mod p</code>, and go from there...</p>
</div>
<div class="post-text" itemprop="text">
<p>In older versions of Python, <code>1/3</code> is equal to 0.  In Python 3.0, <code>1/3</code> is equal to 0.33333333333 (and <code>1//3</code> is equal to 0).</p>
<p>So, either change your code to use <code>1/3.0</code> or switch to Python 3.0 .</p>
</div>
<div class="post-text" itemprop="text">
<p>I came up with my own answer, which takes @Mahmoud Kassem's idea, simplifies the code, and makes it more reusable:</p>
<pre><code>def cube_root(x):
    return decimal.Decimal(x) ** (decimal.Decimal(1) / decimal.Decimal(3))
</code></pre>
<p>I tested it in Python 3.5.1 and Python 2.7.8, and it seemed to work fine.</p>
<p>The result will have as many digits as specified by the decimal context the function is run in, which by default is 28 decimal places. According to the documentation for the <code>power</code> function in the <code>decimal</code> module, "<a href="https://docs.python.org/3/library/decimal.html#decimal.Context.power" rel="nofollow">The result is well-defined but only “almost always correctly-rounded”.</a>". If you need a more accurate result, it can be done as follows:</p>
<pre><code>with decimal.localcontext() as context:
    context.prec = 50
    print(cube_root(42))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try converting the exponent to a floating number, as the default behaviour of / in Python is integer division</p>
<p>n**(1/float(3))</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, if you're not particularly worried about precision, you could convert it to a sting, chop off some digits, use the exponent function, and then multiply the result by the root of how much you chopped off.</p>
<p>E.g. 32123 is about equal to 32 * 1000, the cubic root is about equak to cubic root of 32 * cubic root of 1000.  The latter can be calculated by dividing the number of 0s by 3.</p>
<p>This avoids the need for the use of extension modules.</p>
</div>
<span class="comment-copy">Do you mean pow(x, 1/n) ?</span>
<span class="comment-copy">As David is implying, pow(n, 1/3) will give you the cubic (i.e. 3rd) root of n.</span>
<span class="comment-copy">No it won't, since 1/3 == 0 in python &lt; 3.</span>
<span class="comment-copy">(But it won't be what the OP wanted, either).</span>
<span class="comment-copy">Py3 doesn't have integer limitations... they can grow forever until memory runs out. I tested on my installation. That's a solution.</span>
<span class="comment-copy">Your second function, find_invpowAlt, gives a wildly wrong answer for x=118997879821732370764604711647724283139870175351576755860556891902958645241483485254092600557474860904935286687480039428945219115513349647465379580432922136155355040992635166676363150438436216219094913514982415747153956476970303302126880391024128871557664284712411567099374094385902892603751471822837746770111, n=3</span>
<span class="comment-copy">The line <code>low = high/2</code> should be <code>low = high // 2</code> if you actually want an integer out at the end.</span>
<span class="comment-copy">I wrote it using <code>low = high/2</code> intentionally, as I directly copied that answer from <a href="https://stackoverflow.com/revisions/356206/2">Markus's Code</a> as a means of benchmarking it when compared to my proposed improvement.  I'll note that since then, Markus has updated his code to correct a bug and tzs has replied to my code that it also has a bug.  However, I don't actually remember the details of the problem nor of my solution, so I no longer feel competent to address these shortcomings.</span>
<span class="comment-copy">It will still fail for numbers &gt; ~10**1000. Changing <code>mid = (low + high) // 2</code> to <code>mid = int((low + high) // 2) + 1</code> would fix that.</span>
<span class="comment-copy">Downvoted because it has bugs. I tried <code>find_invpow(64, 3)</code> and got 3, even though the result should have been 4.</span>
<span class="comment-copy">@EliasZamaria Fixed</span>
<span class="comment-copy">OK. I undid the downvote.</span>
<span class="comment-copy">The line <code>low = high/2</code> should be <code>low = high // 2</code> if you actually want an integer out at the end.</span>
<span class="comment-copy">With <code>gmpy2</code> this results in: <code>'mpz' object has no attribute 'root'</code>.</span>
<span class="comment-copy">gmpy2 uses a new mpfr type based on the MPFR library.  gmpy2.root(x, n) -&gt; mpfr  Return n-th root of x. The result always an 'mpfr'.</span>
<span class="comment-copy">@Zelphir gmpy2 has <code>gmpy2.iroot</code> to compute integer roots.</span>
<span class="comment-copy">Um. This could work, but it's not accurate. Using your terms, and if answer equals d<b>one_third, then how much (answer</b>3 - d) should be?</span>
<span class="comment-copy">Decimal is about as accurate as you need it to be... my 0.333 string is just for brevity.</span>
<span class="comment-copy">tz... you're correct.  It' way off...  oh well.  The newton's method above does rock though!</span>
<span class="comment-copy">Please continue, preferably with actual code</span>
<span class="comment-copy">As far as I can tell, there was no indication that it used Python 2.</span>
<span class="comment-copy">n**(1.0/3) will do the job too</span>
<span class="comment-copy">OverflowError: long int too large to convert to float, it just would not work cause the huge number cannot be converted</span>
<span class="comment-copy">As far as I can tell, there was no indication that it used Python 2.</span>
<span class="comment-copy">I'm worried about precision because i know this number, for example is the third power of another integer. (And of course i need to know this integer) :)</span>
<span class="comment-copy">Also, converting to string might become problematic with huge numbers.</span>
<span class="comment-copy">@Attila: Not in the definition of huge he gave in the post.  Also, not sure exactly what format he is accepting input in, but the basic idea of truncation will work in most formats.</span>
<span class="comment-copy">He has working code, just <i>the <b>problem</b> is precision</i></span>
