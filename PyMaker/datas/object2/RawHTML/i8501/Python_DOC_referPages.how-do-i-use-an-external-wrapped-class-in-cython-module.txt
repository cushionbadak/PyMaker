<div class="post-text" itemprop="text">
<p>I have an external class that is already wrapped (I mean, it is directly accessible by python with no further effort), and now I want it to be <em>part</em> of a larger cython module (in other words, embed it). </p>
<p>I could have explicitly python-import it. But the things is that the external class is already used in an <code>extern</code> function in the cython module (so that the class is eventually <code>#include</code>d in source). Python import require the module to be compiled, then the two module may have two different copy of the same class...</p>
<p>How should I then use an external already wrapped class in cython?</p>
<hr/>
<p>(Possibly oversimplified) example:</p>
<p>Foo.cpp:</p>
<pre><code>#include "Python.h"
#include "foo.hpp"

struct Foo_wrapper {
    PyObject_HEAD
    foo bar;
};

static int Foo_init(Foo_wrapper* self, PyObject* args, PyObject*) {
    ....
}

static PyTypeObject FooType {...};
</code></pre>
<p>Spam.pyx:</p>
<pre><code>cdef extern from "some_functions.hpp":
    cdef some_function1(some_type); // this returns a wrapped foo object

def spam(arg1, arg2, arg3):
    // wrap arg1, arg2, arg3 to some_type
    return some_function1(an_instance_of_some_type); // huh? but foo isn't available here!
</code></pre>
<p>And I want to use the foo class in <code>spam.pyx</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should be fine (almost) as it is. This <code>cdef extern</code> line isn't quite right:</p>
<pre><code>cdef extern from "some_functions.hpp":
    object some_function1(some_type); // this returns a wrapped foo object
</code></pre>
<p>Note the change to <code>object</code> - this tells Cython that the function returns a Python object. The C/C++ declaration would look like:</p>
<pre><code>PyObject* some_function1(some_type);
// or
Foo_wrapper* some_function1(some_type);
</code></pre>
<p>Either will work.</p>
<p>The reason that the Cython code will be fine with it is that the <code>PyObject_HEAD</code> includes a pointer <code>ob_type</code> that points to the <code>PyTypeObject FooType</code>. This is set up when the object is created. The <code>PyTypeObject</code> contains all the details the Python interpreter needs to use the returned object and so everything should work fine.</p>
<hr/>
<p>The whole thing is basically the equivalent of the Python code:</p>
<pre><code># in "somemodule.py"
def a_function():
    import something_else
    return something_else.Class()
</code></pre>
<p>The Python interpreter can use the returned value, despite the <code>Class</code> not being known in the "global" namespace.</p>
<hr/>
<p>The one thing to be careful of is that you should ensure that the <code>Foo</code> module initialization function has been called at least once before creating a <code>Foo_wrapper</code>. The reason being is that this function usually does some things like calling <code>PyType_Ready(&amp;FooType)</code> needed to make sure that <code>FooType</code> is properly set up. An easy way to do this would be to add the following lines to <code>some_function1</code>:</p>
<pre><code>PyObject* m = PyImport_ImportModule("Foo");
if (m==NULL) return NULL; // an error
Py_CLEAR(m); // don't need to keep a reference to it
</code></pre>
<p>There are other ways of doing the same thing though.</p>
</div>
<span class="comment-copy">I <i>think</i> Python import is right. I don't think there's a problem unless the two definitions end up different (i.e. you compile module 1, change the class, compile module 2). The question could do with an minimal complete example though.</span>
<span class="comment-copy">@DavidW, I don't <i>think</i> direct import is right. But I'd give it a try if you said so. I don't think because you define two empty classes Foo and Bar, then Foo is the same logical class with Bar, but not to the interpreter. Or if you define two classes in two different module with the same name, they're still not the same.</span>
<span class="comment-copy">This is kind of why a simple example of some code would help. I'm not 100% clear on what you're actually doing!</span>
<span class="comment-copy">@DavidW, please see the added example.</span>
<span class="comment-copy">That clarifies things a lot. Let me think about it a little.</span>
<span class="comment-copy">Per my understanding to your answer, (correct me if I'm wrong), I just need to <i>register</i> the type for interpreter to recognize it. And the <i>registeration</i> is done via <code>PyType_Ready</code>, and once the function is called, the interpreter will just know the type. Furthermore, that function should, if done natively, to be called in the cython module init function. Is it right?</span>
<span class="comment-copy">That's basically right. If <code>Foo.cpp</code> already compiles to a Python module then I think it's cleaner to do the module import somewhere (possibly in <code>some_function1</code> or from Cython) rather than calling <code>PyType_Ready</code> yourself. If <code>Foo.cpp</code> never gets compiled to a Python module then calling <code>PyType_Ready</code> from the Cython module init function (i.e. call it in the global scope of your .pyx file) is as good as anything.</span>
<span class="comment-copy">Is possible to ideally wrap it as an actual class with <b>init</b>? Or I will have to use some factory function. (Yes, in the example the some_function1 is somehow a factory function.)</span>
<span class="comment-copy">You add <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_init" rel="nofollow noreferrer">a <code>tp_init</code> function</a> to the <code>TypeObject</code></span>
<span class="comment-copy">Yap, I had the function, but it's not accessible from the module. I had only called PyType_Ready, and not had it added to the module namespace. I had managed to add it from python side though. Thanks.</span>
