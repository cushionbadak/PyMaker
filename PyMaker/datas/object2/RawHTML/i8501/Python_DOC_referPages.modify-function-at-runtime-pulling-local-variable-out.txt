<div class="post-text" itemprop="text">
<p>Imagine this simple function creating a modified value of a variable <code>default</code>, <code>modified</code>:</p>
<pre><code>default = 0
def modify():
    modified = default + 1
    print(modified)  # replace with OS call, I can't see the output

modify()  # 1
default  # 0
</code></pre>
<p>disassembled:</p>
<pre><code>import dis
dis.dis(modify)
2           0 LOAD_GLOBAL              0 (default)
            3 LOAD_CONST               1 (1)
            6 BINARY_ADD
            7 STORE_FAST               0 (modified)
3          10 LOAD_GLOBAL              1 (print)
           13 LOAD_FAST                0 (modified)
           16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
           19 POP_TOP
           20 LOAD_CONST               0 (None)
           23 RETURN_VALUE
</code></pre>
<p>I can't change the function <code>modify()</code>, but I know what's in it either directly (I can see the code) or indirectly (disassembly). What I need it is to get a value of the <code>modified</code> variable, so I though maybe there is a way how to remove specific parts (<code>print(modified)</code>) of the function through <code>dis</code> module, but I didn't find anything.</p>
<p>Is there any way how to remove probably everything except <code>return_value</code> after <code>16 CALL_FUNCTION</code> and replace it with e.g. <code>return modified</code>? Or is there any other way how to pull a local variable out without actually executing the last line(s)?</p>
<p>As a possible solution I see 3 ways:</p>
<ul>
<li>pulling disassembled codes and creating my own function (or inplace) according to them with removing the code I don't want (everything after <code>16 ...</code>)</li>
<li>modifying the function's <em>return</em> value, so that it returns <code>modified</code> (that unfortunately calls the OS function)</li>
<li>manually recreating the function according to the source code</li>
</ul>
<p>I'd like to avoid the second way, which is probably easier than the first one, but I must avoid the third way, so... is there any way how to solve my problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a 4th option: replace the <code>print()</code> global:</p>
<pre><code>printed = []
print = lambda *args: printed.extend(args)
modify()
del print
modified = printed[0]
</code></pre>
<p>It is otherwise possible to produce modified bytecode, but this can easily lead to bugs that blow up the interpreter (there is zero protection from invalid bytecode), so be warned.</p>
<p>You can create a new function object with a new code object with updated bytecode; based on the offsets in the dis you showed, I manually created new bytecode that would return the local variable at index 0:</p>
<pre><code>&gt;&gt;&gt; altered_bytecode = modify.__code__.co_code[:8] + bytes(
...     [dis.opmap['LOAD_FAST'], 0,   # load local variable 0 onto the stack
...      dis.opmap['RETURN_VALUE']])) # and return it.
&gt;&gt;&gt; dis.dis(altered_bytecode)
          0 LOAD_GLOBAL              0 (0)
          2 LOAD_CONST               1 (1)
          4 BINARY_ADD
          6 STORE_FAST               0 (0)
          8 LOAD_FAST                0 (0)
         10 RETURN_VALUE
</code></pre>
<p><code>RETURN_VALUE</code> returns the object at the top of the stack; all I did was inject a <code>LOAD_FAST</code> opcode to load what <code>modified</code> references onto the stack.</p>
<p>You'd have to create a new <code>code</code> object, then a new <code>function</code> object wrapping the code object, to make this callable:</p>
<pre><code>&gt;&gt;&gt; code = type(modify.__code__)
&gt;&gt;&gt; function = type(modify)
&gt;&gt;&gt; ocode = modify.__code__
&gt;&gt;&gt; new_modify = function(
...     code(ocode.co_argcount, ocode.co_kwonlyargcount, ocode.co_nlocals, ocode.co_stacksize,
...          ocode.co_flags, altered_bytecode,
...          ocode.co_consts, ocode.co_names, ocode.co_varnames, ocode.co_filename,
...          'new_modify', ocode.co_firstlineno, ocode.co_lnotab, ocode.co_freevars,
...          ocode.co_cellvars),
...     modify.__globals__, 'new_modify', modify.__defaults__, modify.__closure__)
&gt;&gt;&gt; new_modify()
1
</code></pre>
<p>This does, obviously, require some understanding of how Python bytecode works in the first place; the <code>dis</code> module does contain descriptions of the various codes, and the <a href="https://docs.python.org/3/library/dis.html#dis.opmap" rel="nofollow noreferrer"><code>dis.opmap</code> dictionary</a> lets you map back to byte values.</p>
<p>There are a few modules out there that try to make this easier; take a look at <a href="https://pypi.python.org/pypi/byteplay" rel="nofollow noreferrer"><code>byteplay</code></a>, the <a href="http://pwnypack.readthedocs.io/en/latest/pwnypack/bytecode.html" rel="nofollow noreferrer"><code>bytecode</code> module of the <code>pwnypack</code> project</a> or several others, if you want to explore this further.</p>
<p>I can also heartily recommend you watch the <a href="https://www.youtube.com/watch?v=mxjv9KqzwjI" rel="nofollow noreferrer"><em>Playing with Python Bytecode</em> presentation</a> given by Scott Sanderson, Joe Jevnik at PyCon 2016, and play with their <a href="https://pypi.python.org/pypi/codetransformer" rel="nofollow noreferrer"><code>codetransformer</code> module</a>. Highly entertaining and very informative.</p>
</div>
<span class="comment-copy">That isn't a modified version of the variable. It's an entirely new object</span>
<span class="comment-copy">@MosesKoledoye edited (I meant value).</span>
<span class="comment-copy">There is a 4th option: replace the <code>print()</code> global. <code>printed = []; print = lambda *args: printed.extend(args)</code>, then run <code>modify()</code> and, optionaly, <code>del print</code> to remove the masking global.</span>
<span class="comment-copy">@MartijnPieters Oh, I'm blind. So simple and I even went for disassembling! -_- Anyway, if there's a way with disassembling, it might be interesting too.</span>
<span class="comment-copy">Hehe, never disappointing Python. There's always a package! I didn't know about the returning of the top item only, this makes things a little bit easier in a case where only a single call is undesired. The bytecode presentation is awesome, I remember watching it on YT.</span>
<span class="comment-copy">@KeyWeeUsr: I was in the audience the first time I saw it. :-D</span>
<span class="comment-copy">Also surprised by <a href="https://youtu.be/mxjv9KqzwjI?t=15m40s" rel="nofollow noreferrer">that</a>? :D</span>
<span class="comment-copy">@KeyWeeUsr: a previous revision of the post (lost during a grace edit) used just the opcode integers, not <code>dis.opmap</code>, which is arguably a little easier to read. :-) Not that I memorise these values however..</span>
