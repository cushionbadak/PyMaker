<div class="post-text" itemprop="text">
<p>python version <code>3.5.2</code><br/>
I tried to get parent class from a child class:</p>
<pre><code>class A:
    pass
class B(A):
    pass
</code></pre>
<p>after a little research, I got a solution from <a href="https://docs.python.org/3/library/stdtypes.html#class.__bases__" rel="nofollow noreferrer">python doc</a>: use <code>__base__</code>. (a special class attribute)
But I couldn't find <strong>this <code>"__base__"</code></strong> in <code>B.__dict__</code> or <code>dir(B)</code>, which are my normal ways of getting attributes.</p>
<p>This is definitely class related information, if it's not in <code>B.__dict__</code> where is it? (although I realized that <code>"__base__"</code> is returned by <code>type(B).__dict__</code>)<br/>
And why isn't <code>dir()</code> returning it? based on <a href="https://stackoverflow.com/questions/14361256/whats-the-biggest-difference-between-dir-and-dict-in-python">this stackoverflow question</a> I read, <code>dir()</code> has some logics behind and it is supposed to return "a complete picture of all available attributes."</p>
<p>I initally thought this is hiding on purpose...but you can still easily manipulate a child's parent:</p>
<pre><code>class C:
    pass
B.__bases__ = (C,) # voila, B got a new Dad
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See the note on <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer"><code>dir()</code></a> (emphasis mine):</p>
<blockquote>
<p>Note: Because <code>dir()</code> is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. <strong>For example, metaclass attributes are not in the result list when the argument is a class.</strong></p>
</blockquote>
<p><code>B</code> is a class, its metaclass is <code>type</code>. So if you really want the <em>full</em> picture, you should also look as the metaclassâ€™ <code>dir()</code>:</p>
<pre><code>&gt;&gt;&gt; B.__class__ is type
True
&gt;&gt;&gt; dir(type)
['__abstractmethods__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__',
 '__delattr__', '__dict__', '__dictoffset__', '__dir__', '__doc__', '__eq__', '__flags__',
 '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__',
 '__init_subclass__', '__instancecheck__', '__itemsize__', '__le__', '__lt__',
 '__module__', '__mro__', '__name__', '__ne__', '__new__', '__prepare__', '__qualname__',
 '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__',
 '__subclasscheck__', '__subclasses__', '__subclasshook__', '__text_signature__',
 '__weakrefoffset__', 'mro']
</code></pre>
<p>And there you have <code>__base__</code> and <code>__bases__</code>, and also those other things that appeared in <a href="https://docs.python.org/3/library/stdtypes.html#special-attributes" rel="nofollow noreferrer">the list you linked</a>, like <code>mro</code> and <code>__subclasses__</code>.</p>
</div>
<span class="comment-copy">when I read that document, I thought <code>type(A).__dict__</code> to <code>A.__dict__</code> is like class attributes to instance attributes. so I said to myself, even though <code>type(A).__dict__</code> has <code>__bases__</code> does not mean <code>A.__dict__</code> has as well. You know, like <b>static</b> var vs <b>instance</b> var....now I realized that <code>type(type(A)) == type(A)</code> they are both classes, so <code>A.__dict__ &gt;= type(A).__dict__</code>. but thanks for the answer</span>
