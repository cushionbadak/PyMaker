<div class="post-text" itemprop="text">
<p>How could I use data obtained(a variable) from a process in another process of the same project ? For example from the code below I want to use variable "b" in an interface for plotting and analysing that. Thanks!</p>
<pre><code>import time
import multiprocessing
import time
import os
import sys
import matplotlib.animation as animation
import time
import libtiepie
import numpy as np
import matplotlib.pyplot as plt
from copy import deepcopy
from printinfo import *
from math import*
import pylab
import tkinter as tk
import matplotlib.animation as animation
from tkinter import*
from tkinter import ttk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
from matplotlib.figure import Figure
from matplotlib.animation import FuncAnimation

def calc_square():

    k=0
    fig=plt.figure()
    while k&lt;3000:

        # Print library info:
        print_library_info()

        # Search for devices:
        libtiepie.device_list.update()

        # Try to open an oscilloscope with block measurement support:
        scp = None
        for item in libtiepie.device_list:
            if item.can_open(libtiepie.DEVICETYPE_OSCILLOSCOPE):
                scp = item.open_oscilloscope()
                if scp.measure_modes &amp; libtiepie.MM_BLOCK:
                    break
                else:
                    scp = None

        if scp:
            try:

                    # Set measure mode:
                    scp.measure_mode = libtiepie.MM_BLOCK

                    # Set sample frequency:
                    scp.sample_frequency = 5e6  # 1 MHz

                    # Set record length:
                    scp.record_length = 1000  # 15000 samples

                    # Set pre sample ratio:
                    scp.pre_sample_ratio = 0.1  # 0 %

                    # For all channels:
                    for ch in scp.channels:
                        # Enable channel to measure it:
                        ch.enabled = True

                        # Set range:
                        ch.range = 8  # 8 V

                        # Set coupling:
                        ch.coupling = libtiepie.CK_ACV  # DC Volt

                    # Set trigger timeout:
                    scp.trigger_time_out = 100e-3  # 100 ms

                    # Disable all channel trigger sources:
                    for ch in scp.channels:
                        ch.trigger.enabled = False

                    # Setup channel trigger:
                    ch = scp.channels[0]  # Ch 1

                    # Enable trigger source:
                    ch.trigger.enabled = True

                    # Kind:
                    ch.trigger.kind = libtiepie.TK_RISINGEDGE  # Rising edge

                    # Level:
                    ch.trigger.levels[0] = 0.75  # 50 %

                    # Hysteresis:
                    ch.trigger.hystereses[0] = 0.1  # 5 %

                    # Print oscilloscope info:
                    #print_device_info(scp)

                    # Start measurement:
                    scp.start()

                    # Wait for measurement to complete:
                    while not scp.is_data_ready:
                        time.sleep(0.01)  # 10 ms delay, to save CPU time

                    # Get data:
                    data = scp.get_data()

                    ax = fig.add_subplot(111)
                    t = np.linspace(0, (scp.record_length/scp.sample_frequency)*1000, scp.record_length)
                    a=deepcopy(data)
                    a=np.transpose(a)
                    b=a[:,0]
                    #ax.plot(t,b)
                    #plt.ion()
                    #plt.show()
                    #plt.pause(0.001)
                    #ax.cla()

            except Exception as e:
                print('Exception: ' + e.message)
                sys.exit(1)

            # Close oscilloscope:
            del scp

        else:
            print('No oscilloscope available with block measurement support!')
        k=k+1

if __name__ == "__main__":

    p1 = multiprocessing.Process(target=calc_square)      

    p1.start()
    # p2.start()
    p1.join()
    # p2.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To send the data from one process to another you can use multiprocessing queue, as mentioned in the <a href="https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes" rel="nofollow noreferrer">docs</a></p>
<pre><code>from multiprocessing import Process, Queue
q = Queue()

def function1(q):
  a = 3434
  q.put(a)
def function2(a):
  c = a**2
  q.put(c)
p1 = Process(target=function1, args=(q,))
p1.start()
b = q.get()
p1.join()
p2 = Process(target=function2, args=(b,))
p2.start()
c = q.get()
p2.join()
print c
</code></pre>
<p>Here is the working <a href="https://repl.it/GxhQ/0" rel="nofollow noreferrer">example</a> as well of passing the variable for one process to another</p>
</div>
<span class="comment-copy">just to be clear you have 2 threads, thread1 returns a variable and you want to pass this variable to another thread2 function ?</span>
<span class="comment-copy">This example give me errors:   RuntimeError:         An attempt has been made to start a new process before the         current process has finished its bootstrapping phase.          This probably means that you are not using fork to start your         child processes and you have forgotten to use the proper idiom         in the main module:              if <b>name</b> == '<b>main</b>':                 freeze_support()                 ...          The "freeze_support()" line can be omitted if the program         is not going to be frozen to produce an executable.</span>
<span class="comment-copy">Code is working fine for me and on online interpreter as well. I omitted if <b>name</b> == '<b>main</b>' here because on online platforms all the code if imported and if the code is imported then it wouldn't run, hence I skipped it here.</span>
