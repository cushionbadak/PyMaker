<div class="post-text" itemprop="text">
<p>From <a href="https://stackoverflow.com/questions/43177876/adding-a-single-character-to-add-keys-in-counter">Adding a single character to add keys in Counter</a> , @AshwiniChaudhary gave an excellent answer to create a new <code>Counter</code> object with a different set() function: </p>
<pre><code>from collections import Counter

class CustomCounter(Counter):
    def __setitem__(self, key, value):
        if len(key) &gt; 1 and not key.endswith(u"\uE000"):
            key += u"\uE000"
        super(CustomCounter, self).__setitem__(key, value)
</code></pre>
<p>To allow user-defined char/str to append to the key, I've tried:</p>
<pre><code>from collections import Counter, defaultdict

class AppendedStrCounter(Counter):
    def __init__(self, str_to_append):
        self._appended_str = str_to_append
        super(AppendedStrCounter, self).__init__()
    def __setitem__(self, key, value):
        if len(key) &gt; 1 and not key.endswith(self._appended_str):
            key += self._appended_str
        super(AppendedStrCounter, self).__setitem__(tuple(key), value)
</code></pre>
<p>But it's returning an empty Counter:</p>
<pre><code>&gt;&gt;&gt; class AppendedStrCounter(Counter):
...     def __init__(self, str_to_append):
...         self._appended_str = str_to_append
...         super(AppendedStrCounter, self).__init__()
...     def __setitem__(self, key, value):
...         if len(key) &gt; 1 and not key.endswith(self._appended_str):
...             key += self._appended_str
...         super(AppendedStrCounter, self).__setitem__(tuple(key), value)
... 
&gt;&gt;&gt; AppendedStrCounter('foo bar bar blah'.split())
AppendedStrCounter()
</code></pre>
<p>That's because I'm missing the iter in the <code>__init__()</code>:</p>
<pre><code>from collections import Counter, defaultdict

class AppendedStrCounter(Counter):
    def __init__(self, iter, str_to_append):
        self._appended_str = str_to_append
        super(AppendedStrCounter, self).__init__(iter)
    def __setitem__(self, key, value):
        if len(key) &gt; 1 and not key.endswith(self._appended_str):
            key += self._appended_str
        super(AppendedStrCounter, self).__setitem__(tuple(key), value)
</code></pre>
<p>[out]:</p>
<pre><code>&gt;&gt;&gt; AppendedStrCounter('foo bar bar blah'.split(), u'\ue000')
AppendedStrCounter({('f', 'o', 'o', '\ue000'): 1, ('b', 'a', 'r', '\ue000'): 1, ('b', 'l', 'a', 'h', '\ue000'): 1})
</code></pre>
<p>But the value for <code>'bar'</code> is wrong, it should be 2 instead of 1. </p>
<p><strong>Is using <code>iter</code> to the <code>__init__()</code> the right way to initialize the <code>Counter</code>?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out in
<a href="https://stackoverflow.com/questions/43196793#comment73466405_43196793">Felix's comment</a>,
<a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>
does not document <em>how</em> its <code>__init__</code> method adds keys or sets values, only that it does.
Since it is not explicitly designed for subclassing, the wisest thing to do is <em>not</em> subclass it.</p>
<p>The
<a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc</code></a>
module exists to provide easily-subclassed abstract classes of Python's builtin types, including <code>dict</code>
(<code>MutableMapping</code>, in ABC terms).
So, if all you need is "a <code>Counter</code>-like class"
(as opposed to "a subclass of <code>Counter</code> that will satisfy builtins like <code>isinstance</code> and <code>issubclass</code>),
you can create your own <code>MutableMapping</code> that has-a <code>Counter</code>, and then "middleman" the initializer and the three methods that <code>Counter</code> adds to the typical <code>dict</code>:</p>
<pre><code>import collections
import collections.abc


def _identity(s):
    '''
    Default mutator function.
    '''
    return s


class CustomCounter(collections.abc.MutableMapping):
    '''
    Overrides the 5 methods of a MutableMapping:
    __getitem__, __setitem__, __delitem__, __iter__, __len__

    ...and the 3 non-Mapping methods of Counter:
    elements, most_common, subtract
    '''

    def __init__(self, values=None, *, mutator=_identity):
        self._mutator = mutator
        if values is None:
            self._counter = collections.Counter()
        else:
            values = (self._mutator(v) for v in values)
            self._counter = collections.Counter(values)
        return

    def __getitem__(self, item):
        return self._counter[self._mutator(item)]

    def __setitem__(self, item, value):
        self._counter[self._mutator(item)] = value
        return

    def __delitem__(self, item):
        del self._counter[self._mutator(item)]
        return

    def __iter__(self):
        return iter(self._counter)

    def __len__(self):
        return len(self._counter)

    def __repr__(self):
        return ''.join([
          self.__class__.__name__,
          '(',
          repr(dict(self._counter)),
          ')'
          ])

    def elements(self):
        return self._counter.elements()

    def most_common(self, n):
        return self._counter.most_common(n)

    def subtract(self, values):
        if isinstance(values, collections.abc.Mapping):
            values = {self._mutator(k): v for k, v in values.items()}
            return self._counter.subtract(values)
        else:
            values = (self._mutator(v) for v in values)
            return self._counter.subtract(values)


def main():
    def mutator(s):
        # Asterisks are easier to print than '\ue000'.
        return '*' + s + '*'

    words = 'the lazy fox jumps over the brown dog'.split()

    # Test None (allowed by collections.Counter).
    ctr_none = CustomCounter(None)
    assert 0 == len(ctr_none)

    # Test typical dict and collections.Counter methods.
    ctr = CustomCounter(words, mutator=mutator)
    print(ctr)
    assert 1 == ctr['dog']
    assert 2 == ctr['the']
    assert 7 == len(ctr)
    del(ctr['lazy'])
    assert 6 == len(ctr)
    ctr.subtract(['jumps', 'dog'])
    assert 0 == ctr['dog']
    assert 6 == len(ctr)
    ctr.subtract({'the': 5, 'bogus': 100})
    assert -3 == ctr['the']
    assert -100 == ctr['bogus']
    assert 7 == len(ctr)
    return


if "__main__" == __name__:
    main()
</code></pre>
<p>Output (line-wrapped, for ease of reading):</p>
<pre class="lang-none prettyprint-override"><code>CustomCounter({
  '*brown*': 1,
  '*lazy*': 1,
  '*the*': 2,
  '*over*': 1,
  '*jumps*': 1,
  '*fox*': 1,
  '*dog*': 1
  })
</code></pre>
<p>I added a keyword-only argument to the initializer, <code>mutator</code>, to store the function that converts real-world whatevers to the "mutant" counted versions.
Note that this likely means that <code>CustomCounter</code> no longer stores "hashable objects", but "hashable objects that don't make the mutator barf".</p>
<p>Also, if the standard library's <code>Counter</code> ever gets new methods, you'll have to update <code>CustomCounter</code> to "override" them.
(You could maybe work around that by using
<a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a>
to pass any unknown attributes to <code>self._counter</code>, but any keys in the arguments will be handed to the <code>Counter</code> in their raw, "un-mutated" form.</p>
<p>Finally, as I noted before, it's not <em>actually</em> a subclass of <code>collections.Counter</code>, if other code is specifically looking for one.</p>
</div>
<span class="comment-copy">You're making the assumption that the superclass constructor uses <code>__setitem__</code> for each item it adds, but there's no guarantee that it must. <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/2/library/collections.html#collections.Counter</a> only promises how its constructor will behave, not how it is implemented.</span>
<span class="comment-copy">Take a close look at the referenced answer of @AshwiniChaudhary. In the example in his answer, the counter of the "the" key is also 1 instead of 2</span>
<span class="comment-copy">Changing how keys are stored could have some nasty surprises...  For example, no one can store <code>'word\ue000'</code> counts separately from <code>'word'</code> in that <code>CustomCounter</code>.  Also, how do they get specific words back out?  The user has to remember to ask for <code>cc['word\ue000']</code> whenever they want <code>cc['word']</code>, which completely defeats the OOP goal of encapsulation.</span>
