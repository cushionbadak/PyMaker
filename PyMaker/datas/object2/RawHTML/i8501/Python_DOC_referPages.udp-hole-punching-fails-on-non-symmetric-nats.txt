<div class="post-text" itemprop="text">
<p>For a little while now, I got a serious issue on my UDP hole punching system which may involve things that are out of my reach now. I'll try to explain as precisely as possible because this is really bothering me :</p>
<p>UDP Hole punching method involves a third host S, which basically is public (not behind any kind of NAT or persistent firewall), that will be used by two clients A and B to get to know each other. Client A sends a udp packet to S, such that S can know its public IP and Port (which were mapped by A's NAT). Client B does the same. Then S matches A and B by sending to A B's public address, and A's public address to B. Therefore, they each know each other's address and can proceed to communicate.</p>
<p>So far so good, but here is the catch : it works only on special cases.</p>
<p>I am aware of the problem caused by Symmetric NATs (NATs that map your private IP and Port to a specific different address for each destination address you want to reach, so let's say I send a packet to S1 and S2, S1 will see a public address with port 50263 whereas S2 will see 50264). I am also aware that some Non-Symmetric NAT require you to send a UDP packet to a specific address before allowing to receive one from the same address.</p>
<p>So what I've understood so far is that as long as your NAT is not Symmetric, when opening a new socket, and send whatever byte array, your NAT will allocate a public IP and port to it. The public server tells your peer this public address such that it can communicate with you. You then have to send a packet to that peer in order to allow him to reply.</p>
<p>But it actually doesn't work everytime. I've tried at my university appartment, and managed to connect to myself using my public IP address, even by being behind a NAT. I also managed to send a UDP packet to a friend's, but it worked only once in the hundred of tests I made. I am now trying at home and it doesn't work at all.</p>
<p>I've setup 2 public VPS on the internet, and sent one packet to each one of them to see if my NAT was Symmetric, but no, the port that gets displayed on both of them is the same. I just can reach myself only from those public servers. Using Wireshark, I observe the packets leaving my computer but it seems that they get dropped beofre going back.</p>
<p>I've written simple python scripts to try out sending simply to myself :</p>
<p><strong>Server</strong></p>
<pre><code>import socket
import sys
from helper import *

# This script is used to allow a client to know which external address it has.

def main():

    # Port used to receive client requests
    port = 6666

    # We create a UDP socket on this port
    sockfd = socket.socket (socket.AF_INET, socket.SOCK_DGRAM)
    sockfd.bind (("", port))

    print ("Address discoverer started on port %d" % port)

    # Server loop
    while True:

        # We wait for any client to request for his address.
        data, addr = sockfd.recvfrom(1)

        # Once a client has sent a request, we send him back his external address, which we obtained using the packet he sent us.
        sockfd.sendto (addr2bytes(addr), addr)

        print ("Client %s:%d requested his address" % addr)

if __name__ == "__main__":
    main()
</code></pre>
<p><strong>Client</strong></p>
<pre><code>import sys
import socket
from helper import *

def main():

    master = ("xxx.xxx.xxx.xxx", 6666)
    me = ("yyy.yyy.yyy.yyy", 6666)

    sockfd = socket.socket (socket.AF_INET, socket.SOCK_DGRAM)
    sockfd.bind(('',6666))
    sockfd.sendto (bytearray([0]), master)

    data, addr = sockfd.recvfrom (6)
    a = bytes2addr(data)
    print ('My address is %s:%d' % a)

    for i in range (0, 10):

        sockfd.sendto ('hi myself'.encode('utf-8'), me)
        data, addr = sockfd.recvfrom (1024)
        print ("Received : " + data.decode('utf-8'))

if __name__ == "__main__":
    main()
</code></pre>
<p>Executed on one of my public VPS, it works. Executed at home, I don't receive anything. It seems that sending from a public host grants all accesses, but behind a NAT is completely different.</p>
<p>Am I missing something fundamental ? I think I did pretty much every possible test but no success.</p>
</div>
<div class="post-text" itemprop="text">
<p>Depending on what you want to achieve, you may want to use <a href="https://en.wikipedia.org/wiki/Internet_Gateway_Device_Protocol" rel="nofollow noreferrer">IGD</a> (<a href="https://tools.ietf.org/html/rfc6970" rel="nofollow noreferrer">spec</a>) to retrieve your public IP and/or configure port forwarding automatically. Most home routers support UPnP IGD, from what I can tell. </p>
<p>Here's an example script that uses <a href="https://github.com/miniupnp/miniupnp" rel="nofollow noreferrer">miniupnpc</a>, a minimal UPnP IGD client, and the <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer">ipaddress</a> and <a href="https://docs.python.org/3/library/socket.html" rel="nofollow noreferrer">socket</a> modules from python's standard library:</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
    IGDTestScript.py
    ================

    Description:           UPnP IGD example script
    Author:                shaggyrogers
    Creation Date:         2018-03-28
    License:               None / Public domain
"""

import ipaddress
import socket
import sys

import miniupnpc


def main(args):
    # Get IP address for default interface
    allhosts = ipaddress.ip_address(socket.INADDR_ALLHOSTS_GROUP)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.connect((allhosts.compressed, 0))
    localIP = ipaddress.ip_address(sock.getsockname()[0])

    if localIP.is_global:
        print(f'Public IP: {localIP} (no NAT)')
        return 0

    print(f'Local IP: {localIP}')

    # Discover and connect to IGD device
    igd = miniupnpc.UPnP()
    assert igd.discover() &gt; 0
    assert igd.selectigd() != ''

    # Get public IP
    publicIP = ipaddress.ip_address(igd.externalipaddress())
    assert publicIP.is_global
    print(f'Public IP: {publicIP}')

    # Dump port mappings
    i, mapping = 0, igd.getgenericportmapping(0)

    while mapping:
        print(f'Port mapping {i}: {mapping}')
        i += 1
        mapping = igd.getgenericportmapping(i)

    # Create/update port mapping
    externalPort, internalPort, protocol = 1234, 4321, 'TCP'
    assert igd.addportmapping(externalPort, protocol, localIP.compressed,
                            internalPort, 'test mapping', '')
    print((f'Added port mapping: {protocol} {publicIP}:{externalPort}'
           f' --&gt; {localIP.compressed}:{internalPort}'))

    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
</code></pre>
<p>Sample output:</p>
<pre><code>Local IP: 192.168.1.123
Public IP: 203.0.113.1
Port mapping 0: (8908, 'TCP', ('192.168.1.123', 9100), 'tcp_map', '1', '', 0)
Port mapping 1: (22222, 'UDP', ('192.168.1.123', 22222), 'udp_map', '1', '', 0)
Added port mapping: TCP 203.0.113.1:1234 -&gt; 192.168.1.123:4321
</code></pre>
</div>
<span class="comment-copy">Does your ISP use CGN? If so, you have a double NAT, and that will be a problem.</span>
