<div class="post-text" itemprop="text">
<p>I have a string:</p>
<pre><code>string = u'11a2ee22b333c44d5e66e777e8888'
</code></pre>
<p>I want to find all <code>k</code> consecutive chunks of digits where <code>n &lt;= k &lt;= m</code>. </p>
<p>Using regular expression only:
say for example <code>n=2</code> and <code>m=3</code> 
   using <code>(?:\D|^)(\d{2,3})(?:\D|$)</code></p>
<pre><code>re.findall(u'(?:\D|^)(\d{2,3})(?:\D|$)',u'11a2ee22b333c44d5e66e777e8888')
</code></pre>
<p>Gives this output:</p>
<pre><code>['11', '333', '66']
</code></pre>
<p>Desired output:</p>
<pre><code>['11', '22', '333', '44', '66', '777']
</code></pre>
<p>I know there are alternate solutions like:</p>
<pre><code>filter(lambda x: re.match('^\d{2,3}$', x), re.split(u'\D',r'11a2ee22b333c44d5e66e777e8888'))
</code></pre>
<p>which gives the desired output, but I want to know what's wrong with the first approach? </p>
<p>It seems <code>re.findall</code> goes in sequence and skips the previous part when matched, so what can be done?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Note:</strong> The result you show in your question is not what I'm getting:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(u'(?:\D|^)(\d{2,3})(?:\D|$)',u'11a2ee22b333c44d5e66e777e8888')
[u'11', u'22', u'44', u'66']
</code></pre>
<p>It's still missing some of the matches you want, but not the same ones.</p>
<p>The problem is that even though non-capturing groups like <code>(?:\D|^)</code> and <code>(?:\D|$)</code> don't <em>capture</em> what they match, they still <em>consume</em> it.</p>
<p>This means that the match which yields <code>'22'</code> has actually consumed:</p>
<ol>
<li><code>e</code>, with <code>(?:\D|^)</code> – not captured (but still consumed)</li>
<li><code>22</code> with <code>(\d{2,3})</code> – captured</li>
<li><code>b</code> with <code>(?:\D|$)</code> – not captured (but still consumed)</li>
</ol>
<p>… so that <code>b</code> is no longer available to be matched before <code>333</code>.</p>
<p>You can get the result you want with lookbehind and lookahead syntax:</p>
<pre><code>&gt;&gt;&gt; re.findall(u'(?&lt;!\d)\d{2,3}(?!\d)',u'11a2ee22b333c44d5e66e777e8888')
[u'11', u'22', u'333', u'44', u'66', u'777']
</code></pre>
<p>Here, <code>(?&lt;!\d)</code> is a negative lookbehind, checking that the match is not preceded by a digit, and <code>(?!\d)</code> is a negative lookahead, checking that the match is not followed by a digit. Crucially, these constructions do not consume any of the string.</p>
<p>The various lookahead and lookbehind constructions are described in the 
<a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">Regular Expression Syntax</a> section of Python's <code>re</code> documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>lookaround regex,\d{2,3} means 2 or 3 digits, (?=[a-z]) means letter after digits. </p>
<pre><code>In [136]: re.findall(r'(\d{2,3})(?=[a-z])',string)
Out[136]: ['11', '22', '333', '44', '66', '777']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could even generalize it with a function:</p>
<pre><code>import re

string = "11a2ee22b333c44d5e66e777e8888"

def numbers(n,m):
    rx = re.compile(r'(?&lt;!\d)(\d{' + '{},{}'.format(n,m) + '})(?!\d)')
    return rx.findall(string)

print(numbers(2,3))
# ['11', '22', '333', '44', '66', '777']
</code></pre>
</div>
<span class="comment-copy">Try your pattern at <a href="https://regex101.com/" rel="nofollow noreferrer">regex101.com</a> , or another of the many online Python flavored regex testers.  Some give explanations of and/or graphics showing how the pattern works.</span>
<span class="comment-copy">Your non-capturing <i>groups</i> consume text.  <code>re.findall</code> only returns non-overlapping matches.  When you consume the text you end up creating overlaps.  Try <i>look ahead assertions</i>, <i>negative lookahead assertions</i>, positive and negative <i>lookbehind assertions</i>.</span>
