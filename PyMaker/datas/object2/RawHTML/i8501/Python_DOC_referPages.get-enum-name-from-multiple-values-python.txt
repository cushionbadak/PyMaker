<div class="post-text" itemprop="text">
<p>I'm trying to get the name of a enum given one of its multiple values:</p>
<pre><code>class DType(Enum):
    float32 = ["f", 8]
    double64 = ["d", 9]
</code></pre>
<p>when I try to get one value giving the name it works:</p>
<pre><code>print DType["float32"].value[1]  # prints 8
print DType["float32"].value[0]  # prints f
</code></pre>
<p>but when I try to get the name out of a given value only errors will come:</p>
<pre><code>print DataType(8).name
print DataType("f").name
</code></pre>
<blockquote>
<p>raise ValueError("%s is not a valid %s" % (value, cls.<strong>name</strong>))</p>
<p>ValueError: 8 is not a valid DataType</p>
<p>ValueError: f is not a valid DataType</p>
</blockquote>
<p>Is there a way to make this? or am I using the wrong data structure?</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way is to use the <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer"><code>aenum</code></a> library<sup>1</sup>, which would look like this:</p>
<pre><code>from aenum import MultiValueEnum

class DType(MultiValueEnum):
    float32 = "f", 8
    double64 = "d", 9
</code></pre>
<p>and in use:</p>
<pre><code>&gt;&gt;&gt; DType("f")
&lt;DType.float32: 'f'&gt;

&gt;&gt;&gt; DType(9)
&lt;DType.double64: 'd'&gt;
</code></pre>
<p>As you can see, the first value listed is the canonical value, and shows up in the <code>repr()</code>.</p>
<p>If you want all the possible values to show up, or need to use the stdlib <code>Enum</code> (Python 3.4+), then the <a href="https://stackoverflow.com/a/24107853/208880">answer found here</a> is the basis of what you want (and will also work with <code>aenum</code>):</p>
<pre><code>class DType(Enum):
    float32 = "f", 8
    double64 = "d", 9

    def __new__(cls, *values):
        obj = object.__new__(cls)
        # first value is canonical value
        obj._value_ = values[0]
        for other_value in values[1:]:
            cls._value2member_map_[other_value] = obj
        obj._all_values = values
        return obj

    def __repr__(self):
        return '&lt;%s.%s: %s&gt;' % (
                self.__class__.__name__,
                self._name_,
                ', '.join([repr(v) for v in self._all_values]),
                )
</code></pre>
<p>and in use:</p>
<pre><code>&gt;&gt;&gt; DType("f")
&lt;DType.float32: 'f', 8&gt;

&gt;&gt;&gt; Dtype(9)
&lt;DType.float32: 'f', 9&gt;
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<span class="comment-copy">Enums can't have multiple value per name. Why do you need this, is one of these an alias? When would use use <code>'f'</code> and when <code>9</code>?</span>
<span class="comment-copy">exactly what i was looking for.  Thank you very much</span>
<span class="comment-copy">@Ruvalcaba:  Glad to help.  When an answer works for you, you should accept it (click on the green check mark by that answer's score).</span>
<span class="comment-copy">Just change the import to:  from aenum import MultiValueEnum  class DType(MultiValueEnum):         float32 = "f", 8     double64 = "d", 9</span>
<span class="comment-copy">@epinal: Good point, updated.</span>
<span class="comment-copy">@Rotareti:  Hard to say.  Having real-world use-cases would help prove the need, but even then <code>Enum</code> is meant as a building-block more than a whole bunch of comprehensive solutions.</span>
