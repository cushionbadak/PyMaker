<div class="post-text" itemprop="text">
<p>I am writing a c-extension and want to test it in pytest.</p>
<p>Part of what I am testing is whether the reference counts are correct on my objects. Thus I build a small test in pure python that puzzles me...</p>
<p>from Ipython i get:</p>
<pre><code>In [1]: x = 153513514215

In [2]: import sys

In [3]: sys.getrefcount(x)
Out[3]: 2
</code></pre>
<p>So fare so good, 1 reference from assignment and 1 from the caller.</p>
<p>However the following script (stackoverflow_test.py) gives the following results</p>
<pre><code>import sys

def test_ref_count_int():
    x = 677461248192962146784178
    assert sys.getrefcount(x) == 2

def test_ref_count_str():
    y = 'very long and probbably very unique string'
    assert sys.getrefcount(y) == 2

def normal_te_st():
    x = 222677461248192962146784178
    y = '!!!!very long and probbably unique string!!!!'
    print ('x refcount = {}'.format(sys.getrefcount(x)))
    print ('y refcount = {}'.format(sys.getrefcount(y)))

if __name__ == '__main__':
    normal_te_st()
</code></pre>
<p>when I run it as a normal python script</p>
<pre><code>$ python3 stackoverflow_test.py
x refcount = 4
y refcount = 4
</code></pre>
<p>Why 4 and not 2?. </p>
<p>When I run it with pytest</p>
<pre><code>$ python3 -m pytest stackoverflow_test.py
=================== test session starts ===================
platform linux -- Python 3.4.3, pytest-3.0.7, py-1.4.33, pluggy-0.4.0
rootdir: /opt/projects/0001_Intomics/00005_TextMining/jcr/textmining/tests, inifile:
collected 2 items

stackoverflow_test.py FF

======================== FAILURES =========================
___________________ test_ref_count_int ____________________

    def test_ref_count_int():
        x = 677461248192962146784178
&gt;       assert sys.getrefcount(x) == 2
E       assert 3 == 2
E        +  where 3 = &lt;built-in function getrefcount&gt;(677461248192962146784178)
E        +    where &lt;built-in function getrefcount&gt; = sys.getrefcount

stackoverflow_test.py:7: AssertionError
___________________ test_ref_count_str ____________________

    def test_ref_count_str():
        y = 'very long and probbably very unique string'
&gt;       assert sys.getrefcount(y) == 2
E       AssertionError: assert 3 == 2
E        +  where 3 = &lt;built-in function getrefcount&gt;('very long and probbably very unique string')
E        +    where &lt;built-in function getrefcount&gt; = sys.getrefcount

stackoverflow_test.py:11: AssertionError
</code></pre>
<p>Why 3 and not 2?</p>
<p><strong>Question: How come that</strong></p>
<ul>
<li>python = 4 ref counts</li>
<li>pytest = 3 ref counts</li>
<li>ipython session = 2 ref counts</li>
</ul>
<p>I would expect it to behave like in ipython in all 3 cases, can anybody explain what is going on, and give me some hints how to best test the objects I am creating.</p>
</div>
<div class="post-text" itemprop="text">
<p>Literals in your code are stored in a code object. The bytecode stack is another reference:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def normal_te_st():
...     x = 222677461248192962146784178
...     y = '!!!!very long and probbably unique string!!!!'
...     print ('x refcount = {}'.format(sys.getrefcount(x)))
...     print ('y refcount = {}'.format(sys.getrefcount(y)))
...
&gt;&gt;&gt; normal_te_st.__code__.co_consts
(None, 222677461248192962146784178, '!!!!very long and probbably unique string!!!!', 'x refcount = {}', 'y refcount = {}')
&gt;&gt;&gt; dis.dis(normal_te_st)
  2           0 LOAD_CONST               1 (222677461248192962146784178)
              2 STORE_FAST               0 (x)

  3           4 LOAD_CONST               2 ('!!!!very long and probbably unique string!!!!')
              6 STORE_FAST               1 (y)

  4           8 LOAD_GLOBAL              0 (print)
             10 LOAD_CONST               3 ('x refcount = {}')
             12 LOAD_ATTR                1 (format)
             14 LOAD_GLOBAL              2 (sys)
             16 LOAD_ATTR                3 (getrefcount)
             18 LOAD_FAST                0 (x)
             20 CALL_FUNCTION            1
             22 CALL_FUNCTION            1
             24 CALL_FUNCTION            1
             26 POP_TOP

  5          28 LOAD_GLOBAL              0 (print)
             30 LOAD_CONST               4 ('y refcount = {}')
             32 LOAD_ATTR                1 (format)
             34 LOAD_GLOBAL              2 (sys)
             36 LOAD_ATTR                3 (getrefcount)
             38 LOAD_FAST                1 (y)
             40 CALL_FUNCTION            1
             42 CALL_FUNCTION            1
             44 CALL_FUNCTION            1
             46 POP_TOP
             48 LOAD_CONST               0 (None)
             50 RETURN_VALUE
</code></pre>
<p>The <code>LOAD_CONST</code> opcodes load the object from the <code>co_consts</code> tuple attached to the code object; that tuple is one reference. <code>STORE_FAST</code> then puts that into a local variable, that's the second reference.</p>
<p>Then there's the <code>LOAD_FAST</code> opcode, this takes a name from local storage and puts it on the stack, <a href="https://github.com/python/cpython/blob/d4edfc9abffca965e76ebc5957a92031a4d6c4d4/Python/ceval.c#L1175-L1186" rel="nofollow noreferrer">again incrementing the reference count</a>.</p>
<p>Last but not least, you pass that value to the <code>sys.getrefcount()</code> call.</p>
<p>If you want to learn about what references your objects, you may want to look at <a href="https://docs.python.org/3/library/gc.html#gc.get_referrers" rel="nofollow noreferrer"><code>gc.get_referrers()</code></a>; this function excludes itself and the stack when called, so you can mentally add +2:</p>
<pre><code>&gt;&gt;&gt; import gc
&gt;&gt;&gt; def gc_demo():
...     x = 222677461248192962146784178
...     print(gc.get_referrers(x))
...
&gt;&gt;&gt; gc_demo()
[(None, 222677461248192962146784178), &lt;frame object at 0x106a25a98&gt;]
</code></pre>
<p>That prints 2 objects; the <code>co_consts</code> tuple, and the current call frame (for the locals).</p>
<p><code>py.test</code> does some additional <a href="https://github.com/pytest-dev/pytest/blob/5721d8aed1f55703588923f5828ca49e731bc8bd/_pytest/assertion/rewrite.py" rel="nofollow noreferrer">import-time magic</a> which <a href="https://github.com/pytest-dev/pytest/blob/5721d8aed1f55703588923f5828ca49e731bc8bd/_pytest/assertion/rewrite.py#L719-L769" rel="nofollow noreferrer">rewrites <code>assert</code> statements</a>, and as a result the reference count is different again.</p>
<p>You may also want to read the <a href="https://docs.python.org/3/extending/extending.html#reference-counts" rel="nofollow noreferrer"><em>Reference Counts</em> section</a> of the <em>Extending Python with C or C++</em> documentation, the <a href="https://docs.python.org/3/c-api/intro.html#objects-types-and-reference-counts" rel="nofollow noreferrer"><em>Objects, Types and Reference Counts</em> section</a> of the <em>C API Reference Manual</em>, and last but not least the <a href="https://docs.python.org/3/c-api/intro.html#debugging-builds" rel="nofollow noreferrer"><em>Debugging Builds</em> section</a> of the same same, to learn how to create a Python build that helps you trace reference counts in detail.</p>
<p>You should never rely on a specific number of references to an object. I can trivially add more references to you objects by reaching into the function object, for example (<code>foo = normal_te_st.__code__.co_conts[1]</code> would increment the reference count before even running the function). What exactly requires the reference count to go up is an implementation detail. Just make sure <strong>your own code</strong> handles references correctly.</p>
</div>
<span class="comment-copy">thanks for the references, I need to chew on it, but this answer was what I was hoping for...</span>
