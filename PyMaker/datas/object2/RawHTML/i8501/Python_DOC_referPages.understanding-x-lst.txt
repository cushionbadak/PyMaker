<div class="post-text" itemprop="text">
<p>I'm going through some old code trying to understand what it does, and I came across this odd statement:</p>
<pre><code>*x ,= p
</code></pre>
<p><code>p</code> is a list in this context. I've been trying to figure out what this statement does. As far as I can tell, it just sets <code>x</code> to the value of <code>p</code>. For example:</p>
<pre><code>p = [1,2]
*x ,= p    
print(x)
</code></pre>
<p>Just gives</p>
<pre><code>[1, 2]
</code></pre>
<p>So is this any different than <code>x = p</code>? Any idea what this syntax is doing?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>*x ,= p</code> is basically an obfuscated version of <code>x = list(p)</code> using <a href="https://www.python.org/dev/peps/pep-3132/" rel="noreferrer">extended iterable unpacking</a>. The comma after <code>x</code> is required to make the assignment target a tuple (it could also be a list though).</p>
<p><code>*x, = p</code> <strong>is</strong> different from <code>x = p</code> because the former creates a <em>copy</em> of <code>p</code> (i.e. a new list) while the latter creates a <em>reference</em> to the original list. To illustrate:</p>
<pre><code>&gt;&gt;&gt; p = [1, 2]
&gt;&gt;&gt; *x, = p 
&gt;&gt;&gt; x == p
True
&gt;&gt;&gt; x is p
False
&gt;&gt;&gt; x = p
&gt;&gt;&gt; x == p
True
&gt;&gt;&gt; x is p
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's a feature that was introduced in Python 3.0 (<a href="https://www.python.org/dev/peps/pep-3132/" rel="noreferrer">PEP 3132</a>). In Python 2, you could do something like this:</p>
<pre><code>&gt;&gt;&gt; p = [1, 2, 3]
&gt;&gt;&gt; q, r, s = p
&gt;&gt;&gt; q
1
&gt;&gt;&gt; r
2
&gt;&gt;&gt; s
3
</code></pre>
<p>Python 3 extended this so that one variable could hold multiple values:</p>
<pre><code>&gt;&gt;&gt; p = [1, 2, 3]
&gt;&gt;&gt; q, *r = p
&gt;&gt;&gt; q
1
&gt;&gt;&gt; r
[2, 3]
</code></pre>
<p>This, therefore, is what is being used here. Instead of two variables to hold three values, however, it is just one variable that takes each value in the list. This is different from <code>x = p</code> because <code>x = p</code> just means that <code>x</code> is another name for <code>p</code>. In this case, however, it is a new list that just happens to have the same values in it. (You may be interested in <a href="https://stackoverflow.com/q/1132941/5827958">"Least Astonishment" and the Mutable Default Argument</a>)</p>
<p>Two other common ways of producing this effect are:</p>
<pre><code>&gt;&gt;&gt; x = list(p)
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; x = p[:]
</code></pre>
<p>Since Python 3.3, the list object actually has a method intended for copying:</p>
<pre><code>x = p.copy()
</code></pre>
<p>The slice is actually a very similar concept. As nneonneo pointed out, however, that works only with objects such as lists and tuples that support slices. The method you mention, however, works with any iterable: dictionaries, sets, generators, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should always throw these to <a href="https://docs.python.org/3/library/dis.html" rel="noreferrer"><code>dis</code></a> and see what it throws back at you; you'll see how <code>*x, = p</code> is actually different from <code>x = p</code>:</p>
<pre><code>dis('*x, = p')
  1           0 LOAD_NAME                0 (p)
              2 UNPACK_EX                0
              4 STORE_NAME               1 (x)
</code></pre>
<p>While, the simple assignment statement:</p>
<pre><code>dis('x = p')
  1           0 LOAD_NAME                0 (p)
              2 STORE_NAME               1 (x)
</code></pre>
<p><sup>(Stripping off unrelated <code>None</code> returns)</sup></p>
<p>As you can see <code>UNPACK_EX</code> is the different op-code between these; <a href="https://docs.python.org/3/library/dis.html#opcode-UNPACK_EX" rel="noreferrer">it's documented as</a>:</p>
<blockquote>
<p>Implements assignment with a starred target: Unpacks an iterable in TOS (top of stack) into individual values, where the total number of values can be smaller than the number of items in the iterable: one of the new values will be a list of all leftover items.</p>
</blockquote>
<p>Which is why, as Eugene noted, you get a new object that's referred to by the name <code>x</code> and not a reference to an already existing object (as is the case with <code>x = p</code>). </p>
<hr/>
<p><code>*x,</code> does seem very odd (the extra comma there and all) but it is required here. The left hand side must either be a tuple or a list and, due to the quirkiness of creating a single element tuple in Python, you need to use a trailing <code>,</code>:</p>
<pre><code>i = 1, # one element tuple
</code></pre>
<p>If you like confusing people, you can always use the <code>list</code> version of this:</p>
<pre><code>[*x] = p
</code></pre>
<p>which does exactly the same thing but doesn't have that extra comma hanging around there.</p>
</div>
<span class="comment-copy">It's different because instead of assigning an alias, it copies the list.</span>
<span class="comment-copy">See <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">python.org/dev/peps/pep-3132</a></span>
<span class="comment-copy">Omitting the comma gives an error message to which this might be an interesting reference: "SyntaxError: starred assignment target must be in a list or tuple".</span>
<span class="comment-copy">Also worth noting that the comma actually belongs to the <code>*x</code>, as the starred assignment must be in a list or tuple. So the more explicit way to write that statement is <code>(*x,) = p</code></span>
<span class="comment-copy">Important to note, this works when <code>p</code> is <i>any</i> iterable.</span>
<span class="comment-copy">Might be worth adding something like <code>x[0] = 3; p #=&gt; [1, 2]</code> to the first half and <code>x[0] = 3; p #=&gt; [3, 2]</code> to the second, to illustrate why <code>is</code> and <code>==</code> are different</span>
<span class="comment-copy">Note, though, that your second bit of code, <code>x = p[:]</code> requires that <code>p</code> be slice-able. This excludes things like generators.</span>
<span class="comment-copy">@nneonneo: Good point. I've edited now.</span>
<span class="comment-copy">Wait, 3.0!? I thought it was way more recent, 3.5 or 3.6 or something.</span>
<span class="comment-copy">@user2357112: In <a href="https://www.python.org/download/releases/3.0/whatsnew/" rel="nofollow noreferrer">What's New In Python 3.0</a>, you will find this bullet point: <code>PEP 3132 was accepted</code>. In addition, the PEP itself says the Python version is 3.0. I'm pretty sure that must be the case, then.</span>
<span class="comment-copy">@River: Ah, yes. I had forgotten about that one. I kept the slice because it is useful for more than just lists and is still a commonly-seen tactic, but I added the <code>.copy</code> method.</span>
