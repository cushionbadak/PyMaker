<div class="post-text" itemprop="text">
<p>How can one define the initial contents of the keyword arguments dictionary? Here's an ugly solution:</p>
<pre><code>def f(**kwargs):
    ps = {'c': 2}
    ps.update(kwargs)
    print(str(ps))
</code></pre>
<p>Expected behaviour:</p>
<pre><code>f(a=1, b=2) =&gt; {'c': 2, 'a': 1, 'b': 2}
f(a=1, b=2, c=3) =&gt; {'c': 3, 'a': 1, 'b': 2}
</code></pre>
<p>Yet, I would like to do something a little bit more in the lines of:</p>
<pre><code>def f(**kwargs = {'c': 2}):
    print(str(kwargs))
</code></pre>
<p>Or even:</p>
<pre><code>def f(c=2, **kwargs):
    print(str(???))
</code></pre>
<p>Ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>First to address the issues with your current solution:</p>
<pre><code>def f(**kwargs):
    ps = {'c': 2}
    ps.update(kwargs)
    print(str(ps))
</code></pre>
<p>This creates a new dictionary and then has to take the time to update it with all the values from kwargs.  If kwargs is large that can be fairly inefficient and as you pointed out is a bit ugly.</p>
<p>Obviously your second isn't valid.</p>
<p>As for the third option, an implementation of that was already given by <a href="https://stackoverflow.com/users/4029014/austin-hastings">Austin Hastings</a> </p>
<p>If you are using kwargs and not keyword arguments for default values there's probably a reason (or at least there should be; for example an interface that defines <code>c</code> without explicitly requiring <code>a</code> and <code>b</code> might not be desired even though the implementation may require a value for <code>c</code>).</p>
<p>A simple implementation would take advantage of <code>dict.setdefault</code> to update the values of kwargs if and only if the key is not already present:</p>
<pre><code>def f(**kwargs):
    kwargs.setdefault('c', 2)
    print(str(kwargs))
</code></pre>
<p>Now as mentioned by the OP in a previous comment, the list of default values may be quite long, in that case you can have a loop set the default values:</p>
<pre><code>def f(**kwargs):
    defaults = {
        'c': 2,
         ...
    }
    for k, v in defaults.items():
        kwargs.setdefault(k, v)
    print(str(kwargs))
</code></pre>
<p>A couple of performance issues here as well. First the <code>defaults</code> dict literal gets created on every call of the function.  This can be improved upon by moving the defaults outside of the function like so:</p>
<pre><code>DEFAULTS = {
    'c': 2,
     ...
}
def f(**kwargs):
    for k, v in DEFAULTS.items():
        kwargs.setdefault(k, v)
    print(str(kwargs))
</code></pre>
<p>Secondly in Python 2, <code>dict.items</code> returns a copy of the (key, value) pairs so instead <code>dict.iteritems</code> or <code>dict.viewitems</code> allows you to iterate over the contents and thus is more efficient.  In Python 3, 'dict.items` is a view so there's no issue there.</p>
<pre><code>DEFAULTS = {
    'c': 2,
     ...
}
def f(**kwargs):
    for k, v in DEFAULTS.iteritems():  # Python 2 optimization
        kwargs.setdefault(k, v)
    print(str(kwargs))
</code></pre>
<p>If efficiency and compatibility are both concerns, you can use the <code>six</code> library for compatibility as follows:</p>
<pre><code>from six import iteritems

DEFAULTS = {
    'c': 2,
     ...
}
def f(**kwargs):
    for k, v in iteritems(DEFAULTS):
        kwargs.setdefault(k, v)
    print(str(kwargs))
</code></pre>
<p>Additionally, on every iteration of the <code>for</code> loop, a lookup of the <code>setdefault</code> method of <code>kwargs</code> needs to be performed.  If you truly have a really large number of default values a micro-optimization is to assign the method to a variable to avoid repeated lookup:</p>
<pre><code>from six import iteritems

DEFAULTS = {
    'c': 2,
     ...
}
def f(**kwargs):
    setdefault = kwargs.setdefault
    for k, v in iteritems(DEFAULTS):
        setdefault(k, v)
    print(str(kwargs))
</code></pre>
<p>Lastly if the number of default values is instead expected to be larger than the number of kwargs, it would likely be more efficient to update the default with the kwargs.  To do this, you can't use the global default or it would update the defaults with every run of the function, so the defaults need to be moved back into the function. This would leave us with the following:</p>
<pre><code>def f(**kwargs):
    defaults = {
        'c': 2,
         ...
    }
    defaults.update(kwargs)
    print(str(defaults))
</code></pre>
<p>Enjoy :D</p>
</div>
<div class="post-text" itemprop="text">
<p>A variation possible on your first approach on Python 3.5+ is to define the default and expand the provided arguments on a single line, which also lets you replace <code>kwargs</code> on the same line, e.g.:</p>
<pre><code>def f(**kwargs):
    # Start with defaults, then expand kwargs which will overwrite defaults if
    # it has them
    kwargs = {'c': 2, **kwargs}
    print(str(kwargs))
</code></pre>
<p>Another approach (that won't produce an identical string) that creates a mapping that behaves the same way using <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><code>collections.ChainMap</code></a> (3.3+):</p>
<pre><code>from collections import ChainMap

def f(**kwargs):
    # Chain overrides over defaults
    # {'c': 2} could be defined outside f to avoid recreating it each call
    ps = ChainMap(kwargs, {'c': 2})
    print(str(ps))
</code></pre>
<p>Like I said, that won't produce the same string output, but unlike the other solutions, it won't become more and more costly as the number of passed keyword arguments increases (it doesn't have to copy them at all).</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried:</p>
<pre><code>def f(c=2, **kwargs):
    kwargs['c'] = c
    print(kwargs)
</code></pre>
<p><strong>Update</strong></p>
<p>Barring that, you can use <code>inspect</code> to access the code object, and get the keyword-only args from that, or even all the args:</p>
<pre><code>import inspect

def f(a,b,c=2,*,d=1,**kwargs):
    code_obj = inspect.currentframe().f_code
    nposargs = code_obj.co_argcount
    nkwargs = code_obj.co_kwonlyargcount
    localvars = locals()
    kwargs.update({k:localvars[k] for k in code_obj.co_varnames[:nposargs+nkwargs]})

    print(kwargs)

g=f

g('a', 'b')
</code></pre>
</div>
<span class="comment-copy">Your first approach is good enough.</span>
<span class="comment-copy">Check <a href="https://git.io/vSRf8" rel="nofollow noreferrer">requests repository</a>, it uses same method.</span>
<span class="comment-copy">Of course the <code>print(str(defaults))</code> could be replaced with <code>print(defaults)</code> for all of the above but then it wouldn't have ended being virtually identical to the OP</span>
<span class="comment-copy">Of course the <code>print(str(defaults))</code> could be replaced with <code>print(defaults)</code> for all of the above but then it wouldnt have ended being virtually identical to the OP</span>
<span class="comment-copy">Oops commented on wrong post lol</span>
<span class="comment-copy">I don't like the duplication of <code>c</code> both in the arguments list and in the <code>kwargs</code> dictionary update. The list can be long (...)</span>
<span class="comment-copy">You asked for it...</span>
