<div class="post-text" itemprop="text">
<p>First of all, sorry if the title isn't very explicit, it's hard for me to formulate it properly. That's also why I haven't found if the question has already been asked, if it has.</p>
<p>So, I have a list of string, and I want to perform a "procedural" search replacing every <code>*</code> in my target-substring by any possible substring.<br/>
Here is an example:</p>
<pre><code>strList = ['obj_1_mesh',
           'obj_2_mesh',
           'obj_TMP',
           'mesh_1_TMP',
           'mesh_2_TMP',
           'meshTMP']

searchFor('mesh_*')
# should return: ['mesh_1_TMP', 'mesh_2_TMP']
</code></pre>
<p>In this case where there is just one <code>*</code> I just split each string with <code>*</code> and use <code>startswith()</code> and/or <code>endswith()</code>, so that's ok.
But I don't know how to do the same thing if there are multiple <code>*</code> in the search string.</p>
<p>So my question is, <strong>how do I search for any number of unknown substrings in place of <code>*</code> in a list of string?</strong><br/>
For example:</p>
<pre><code>strList = ['obj_1_mesh',
           'obj_2_mesh',
           'obj_TMP',
           'mesh_1_TMP',
           'mesh_2_TMP',
           'meshTMP']

searchFor('*_1_*')
# should return: ['obj_1_mesh', 'mesh_1_TMP']
</code></pre>
<p>Hope everything is clear enough. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use the regular expression package for this if I were you. You'll have to learn a little bit of regex to make correct search queries, but it's not too bad. '.+' is pretty similar to '*' in this case.</p>
<pre><code>import re

def search_strings(str_list, search_query):
    regex = re.compile(search_query)
    result = []
    for string in str_list:
        match = regex.match(string)
        if match is not None:
            result+=[match.group()]
    return result

strList= ['obj_1_mesh',
          'obj_2_mesh',
          'obj_TMP',
          'mesh_1_TMP',
          'mesh_2_TMP',
          'meshTMP']

print search_strings(strList, '.+_1_.+')
</code></pre>
<p>This should return ['obj_1_mesh', 'mesh_1_TMP']. I tried to replicate the '*_1_*' case. For 'mesh_*' you could make the search_query 'mesh_.+'. Here is the link to the python regex api: <a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">https://docs.python.org/2/library/re.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Consider using 'fnmatch' which provides Unix-like file pattern matching. More info here <a href="http://docs.python.org/2/library/fnmatch.html" rel="nofollow noreferrer">http://docs.python.org/2/library/fnmatch.html</a></p>
<pre><code>from fnmatch import fnmatch
strList = ['obj_1_mesh',
       'obj_2_mesh',
       'obj_TMP',
       'mesh_1_TMP',
       'mesh_2_TMP',
       'meshTMP']

searchFor = '*_1_*'

resultSubList = [ strList[i] for i,x in enumerate(strList) if fnmatch(x,searchFor) ]
</code></pre>
<p>This should do the trick</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way to do this is to use <code>fnmatch</code>, as shown in ma3oun's answer. But here's a way to do it using <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">Regular Expressions</a>, aka regex.</p>
<p>First we transform your <code>searchFor</code> pattern so it uses <code>'.+?'</code> as the "wildcard" instead of <code>'*'</code>. Then we compile the result into a regex pattern object so we can efficiently use it multiple tests.</p>
<p>For an explanation of regex syntax, please see the docs. But briefly, the dot means any character (on this line), the <code>+</code> means look for one or more of them, and the <code>?</code> means do non-greedy matching, i.e., match the smallest string that conforms to the pattern rather than the longest, (which is what greedy matching does). </p>
<pre><code>import re

strList = ['obj_1_mesh',
           'obj_2_mesh',
           'obj_TMP',
           'mesh_1_TMP',
           'mesh_2_TMP',
           'meshTMP']

searchFor = '*_1_*'
pat = re.compile(searchFor.replace('*', '.+?'))

result = [s for s in strList if pat.match(s)]
print(result)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['obj_1_mesh', 'mesh_1_TMP']
</code></pre>
<p>If we use <code>searchFor = 'mesh_*'</code> the result is</p>
<pre><code>['mesh_1_TMP', 'mesh_2_TMP']
</code></pre>
<hr/>
<p>Please note that this solution is <em>not</em> robust. If <code>searchFor</code> contains other characters that have special meaning in a regex they need to be <a href="https://docs.python.org/3/library/re.html#re.escape" rel="nofollow noreferrer">escaped</a>. Actually, rather than doing that <code>searchFor.replace</code> transformation, it would be cleaner to just write the pattern using regex syntax in the first place.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the string you are looking for looks always like <em>string</em> you can just use the find function, you'll get something like:</p>
<pre><code>for s in strList:
    if s.find(searchFor) != -1:
        do_something()
</code></pre>
<p>If you have more than one string to look for (like abc*123*test) you gonna need to look for the each string, find the second one in the same string starting at the index you found the first + it's len and so on.</p>
</div>
<span class="comment-copy">You might want to take a look into <code>re</code> for regular expressions.</span>
<span class="comment-copy">Explain how you arrive at <code>['mesh_ok1', 'mesh_ok2']</code> as the expected output for the first example.</span>
<span class="comment-copy">Oh yes sorry, that's because I modified my example code without changing the result. I edit that right now.</span>
<span class="comment-copy">It's probably a Good Idea to use non-greedy matching here.</span>
<span class="comment-copy">Yeah thats up to the OP. I used greedy since I thought it intuitively made more sense in this particular case. OP if you want non-greedy use '*' instead of '+'.</span>
<span class="comment-copy">Thanks! All the answers are good, but since this one is less condensed it's easier for me to understand it (since I don't use much regex and don't fully understand it for now). I also change the '+' in '*' as suggested, I think it's more precise this way.</span>
<span class="comment-copy">Hey so just to explain it a bit more, the dot matches any character and then the * says match 0 or more of the previous pattern. The + says match 1 or more. To give an example '.+_1_.+' will not match ' _1_TMP', but '.*_1_.*' will.</span>
<span class="comment-copy">Yes, that's what I figured out by testing. Thanks again :)</span>
<span class="comment-copy">This answer would be a bit better if you provided a link to documentation for fnmatch, and also briefly explained what fnmatch does. Simply saying something like "fnmatch provides the ability to match patterns similar to unix filename wildcards" is all you need to take this from a good answer to a great answer.</span>
