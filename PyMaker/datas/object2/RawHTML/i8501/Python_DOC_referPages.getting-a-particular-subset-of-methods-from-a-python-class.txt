<div class="post-text" itemprop="text">
<p>I have read other posts in Stack Overflow that answer this question, but I am interested in a specific subset of methods.</p>
<p>Suppose you have a class <code>Cn</code> with <code>n</code> higher than 1, as well as classes <code>C0</code>, <code>C1</code>, ..., <code>Cn-1</code> such that, for each <code>i</code> between 1 and <code>n-1</code>, class <code>Ci+1</code> inherits from class <code>Ci</code>.</p>
<p>My question is: <strong>for any <code>i</code> higher than 1, how can I obtain the list of methods that belong to <code>Ci</code> but not to <code>Ci-1</code></strong>?  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can find all names defined on the class itself in the <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer"><code>__dict__</code> attribute</a> of a class; you can use the <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer"><code>vars()</code> function</a> to list those more succinctly:</p>
<pre><code>from types import FunctionType

for name, object in vars(Ci).items():
    if isinstance(object, FunctionType):
        print(name, 'is defined on Ci directly and not inherited')
</code></pre>
<p>You may need to vary the test for functions; I'm assuming here you only want plain function objects (which are bound into methods when looked up on the instance), but you may need to test for class or static methods or other callables too, depending on your use-case.</p>
<p>This will include names that have been re-defined; so these exist on the parent <em>too</em> but <code>Ci</code> provides a new implementation that masks that of a parent.</p>
<p>If you must find all names that uniquely belong to <code>Ci</code> and no parent provides, you'll have to filter on names that exist on the bases:</p>
<pre><code>parent_defined = set().union(*(dir(b) for b in Ci.__bases__))

for name, object in vars(Ci).items():
    if name not in parent_defined and isinstance(object, FunctionType):
        print(name, 'is defined on Ci directly and not inherited')
</code></pre>
</div>
<span class="comment-copy">So you want all methods on a given that are not inherited from a parent.</span>
<span class="comment-copy">Indeed @MartijnPieters.</span>
<span class="comment-copy">I'm not competent enough to write this as an answer, but in the interpreter <code>set(dir(C)) - set(dir(B))</code> seems to work (<code>C</code> inherits from <code>B</code>, <code>B</code> inherits from some class <code>A</code>).</span>
<span class="comment-copy">What about <i>redefined</i> methods? So those methods for which <code>Ci</code> provides an implementation that differs from the same name existing on <code>Ci-1</code>?</span>
<span class="comment-copy">@timgeb Thank you for your comment, that works just perfect for the problem at hand - I do not have redefined methods in my case.</span>
<span class="comment-copy">Cool. What about using <code>callable</code> instead of <code>isinstance</code>? (You have a typo in that line, btw.) Also what about functions that are just attributes of the class object, but not defined there? (Take <code>X.foo = lambda: 42</code> for some class <code>X</code>.)</span>
<span class="comment-copy">@timgeb: depends on the use-case. Should static and class methods count  (and those are <i>not</i> callable, they are bindable, producing a callable object)? Should classes set as attributes count?</span>
<span class="comment-copy">@timgeb: there is <i>zero difference</i> between setting a function as an attribute on the class after the fact or defining it in the class body. <code>lambda</code> expressions still produce a function object.</span>
<span class="comment-copy">Huh, what about being bound or unbound?</span>
<span class="comment-copy">@DaneelOlivaw: no, <code>vars()</code> returns <b>unbound objects</b>. Your decorators return objects that are not plain functions.</span>
