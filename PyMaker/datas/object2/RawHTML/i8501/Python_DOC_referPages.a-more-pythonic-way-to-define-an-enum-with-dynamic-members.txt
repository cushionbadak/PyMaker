<div class="post-text" itemprop="text">
<p>I needed to create an enum to represent the ISO country codes. The country code data comes from a json file which can be obtained from: <a href="https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes" rel="nofollow noreferrer">https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes</a></p>
<p>So what I've done is:</p>
<pre><code>data = json.load(open('slim-2.json'))
codes_list = [(data[i]['alpha-2'], int(data[i]['country-code']))
              for i in range(len(data))]

CountryCode = enum.Enum('CountryCode', codes_list,)

names_dict = {int(data[i]['country-code']):data[i]['name'] 
              for i in range(len(data))}
setattr(CountryCode, '_names', names_dict)

CountryCode.choices = classmethod(lambda cls:((member.value, name) 
                                  for name, member in cls.__members__.items()))
setattr(CountryCode, '__str__' ,lambda self: self.__class__._names[self.value])
</code></pre>
<p>This code snippet is frankly ugly. I looked at alternative ways to define the enum class but couldn't piece together a solution. Is there a way to define the enum in the following form:</p>
<pre><code>class CountryCode(enum.Enum):

    data = json.load(open('slim-2.json'))
    # Some code to define the enum members

    @classmethod
    def choices(cls):
    # etc...
</code></pre>
<p>Any suggestions on how to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>data = json.load(open('slim-2.json'))
CountryCode = enum.Enum('CountryCode', [
    (x['alpha-2'], int(x['country-code'])) for x in data
])
CountryCode._names = {x['alpha-2']: x['name'] for x in data}
CountryCode.__str__ = lambda self: self._names[self.name]
CountryCode.choices = lambda: ((e.value, e.name) for e in CountryCode)
</code></pre>
<ul>
<li>Replaced <code>[...data[i]... for i in range(len(data))]</code> with <code>[...x... for x in data]</code>; You can itearte sequence (list, <code>data</code> in the code) without using indexes.</li>
<li>Used <code>CountryCode.attr = ...</code> consistently; instead of mixing <code>CountryCode.attr = ...</code> and <code>setattr(CountryCode, 'attr', ...)</code>.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><em>Update</em>  For a general <code>json-to-Enum</code> solution check out <a href="https://stackoverflow.com/q/43730305/208880">When should I subclass EnumMeta instead of Enum?</a>.</p>
<hr/>
<p>It looks like you are trying to keep track of three pieces of data:</p>
<ul>
<li>country name</li>
<li>country code</li>
<li>country 2-letter abbreviaton</li>
</ul>
<p>You should consider using a technique inspired by a <code>namedtuple</code> mixin as <a href="https://stackoverflow.com/a/26703636/208880">illustrated in this answer</a>:</p>
<hr/>
<p><strong>The stdlib way</strong></p>
<p>We'll need a base class to hold the behavior:</p>
<pre><code>from enum import Enum
import json

class BaseCountry(Enum):

    def __new__(cls, record):
        member = object.__new__(cls)
        member.country_name = record['name']
        member.code = int(record['country-code'])
        member.abbr = record['alpha-2']
        member._value_ = member.abbr, member.code, member.country_name
        if not hasattr(cls, '_choices'):
            cls._choices = {}
        cls._choices[member.code] = member.country_name
        cls._choices[member.abbr] = member.country_name
        return member                

    def __str__(self):
        return self.country_name

    @classmethod
    def choices(cls):
        return cls._choices.copy()
</code></pre>
<p>Then we can use that to create the actual <code>Country</code> class:</p>
<pre><code>Country = BaseCountry(
        'Country',
        [(rec['alpha-2'], rec) for rec in json.load(open('slim-2.json'))],
        )
</code></pre>
<hr/>
<p><strong>The <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>aenum</code></a> way</strong> <sup>1</sup> <sup>2</sup></p>
<pre><code>from aenum import Enum, MultiValue
import json

class Country(Enum, init='abbr code country_name', settings=MultiValue):

    _ignore_ = 'this country'  # do not add these names as members

    # create members
    this = vars()
    for country in json.load(open('slim-2.json')):
        this[country['alpha-2']] = (
                country['alpha-2'],
                int(country['country-code']),
                country['name'],
                )

    # return a dict of choices by abbr or country code to name
    @classmethod
    def choices(cls):
        mapping = {}
        for member in cls:
            mapping[member.code] = member.name
            mapping[member.abbr] = member.name
        return mapping

    # have str() print just the country name
    def __str__(self):
        return self.country_name
</code></pre>
<hr/>
<p>While I included the <code>choices</code> method, you may not need it:</p>
<pre><code>&gt;&gt;&gt; Country('AF')
&lt;Country.AF: ('AF', 4, 'Afghanistan')&gt;

&gt;&gt;&gt; Country(4)
&lt;Country.AF: ('AF', 4, 'Afghanistan')&gt;

&gt;&gt;&gt; Country('Afghanistan')
&lt;Country.AF: ('AF', 4, 'Afghanistan')&gt;
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
<p><sup>2</sup> This requires <code>aenum 2.0.5+</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there is a way to define the <code>enum</code> using the alternate declaration syntax you want. It works by hiding the "ugly" code in a metaclass derived from <code>enum.EnumMeta</code>. If you wished, it would also be possible to define the <code>choices()</code> class method there, too.</p>
<pre><code>import enum
import json

class CountryCodeMeta(enum.EnumMeta):
    def __new__(metacls, cls, bases, classdict):
        data = classdict['data']
        names = [(country['alpha-2'], int(country['country-code'])) for country in data]

        temp = type(classdict)()
        for name, value in names:
            temp[name] = value

        excluded = set(temp) | set(('data',))
        temp.update(item for item in classdict.items() if item[0] not in excluded)

        return super(CountryCodeMeta, metacls).__new__(metacls, cls, bases, temp)

class CountryCode(enum.Enum, metaclass=CountryCodeMeta):
    data = json.load(open('slim-2.json'))

    @classmethod
    def choices(cls):
        return ((member.value, name) for name, member in cls.__members__.items())
</code></pre>
</div>
<span class="comment-copy">The only way to programatically assign the members of an Enum is by using the <code>Enum()</code> initialiser, so unfortunately, there isn't a way to do this via the class declaration. And you can't subclass an Enum that already has members assigned. You can specify a mixin (the <code>type</code> parameter) to add behaviour, but that doesn't help much in your case.</span>
<span class="comment-copy">I suspected that... thanks.</span>
<span class="comment-copy">@dirkgroten: While this isn't possible with the stdlib <code>Enum</code>, it is possible with <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>aenum</code></a>.</span>
<span class="comment-copy">Learning a lot from this post :-) Both <code>aenum</code> and <code>metaclass</code> show that I was wrong...</span>
<span class="comment-copy">@PeterPudaite:  If creating <code>Enum</code>s from json is common for you, check out <a href="http://stackoverflow.com/q/43730305/208880">this answer</a> which details a <code>JSONEnum</code>.</span>
<span class="comment-copy">Thanks, that's much more compact!</span>
<span class="comment-copy">I wasn't aware of the aenum library. That does make it much clearer to understand what's going on.  Just one thing. What is the purpose of <code>_ignore_ = 'this country'</code>?</span>
<span class="comment-copy">@PeterPudaite:  Just added a comment to the code.  <code>_ignore_</code> is a list of names that should not become <code>Enum</code> members; in this case, the <code>this</code> and <code>country</code> temporary variables.</span>
<span class="comment-copy">OK gotcha. I'm looking at the aenum repo home page. Is there more documentation for aenum elsewhere?   And thanks for creating the library!</span>
<span class="comment-copy">@martineau:  <a href="https://meta.stackoverflow.com/a/317309/208880">It's an interesting conundrum.</a>  On the one hand, I want folks to trust that <code>aenum</code> is a solid package; on the other hand, I like getting kudos for a good library; on the gripping hand, I want up-votes because my answer is good, not because I'm the Python core developer that happened to write <code>Enum</code>, <code>enum34</code>, and <code>aenum</code>.  By way of contrast, if you look at my <a href="https://stackoverflow.com/search?q=%5Bdbf%5Duser%3A208880"><code>dbf</code> answers</a> you'll see that anytime I reference my <code>dbf</code> library I disclose that I'm the author.</span>
<span class="comment-copy">@martineau: I'll look into those <code>_EnumDIct</code> changes, and also about making <code>_EnumDict</code> public, since it's difficult to work with <code>EnumMeta</code> without it.  As far as extending <code>EnumMeta</code> -- sure, get the word out that it can be done -- but preferably as a secondary portion of the answer with the primary portion being the boring but safe <code>__new__</code> or plain old ordinary methods.  PEP 435 <code>Enum</code>s are not ordinary classes, and <code>EnumMeta</code> is not a typical metaclass.  As you've seen, it is easy to break them if unaware of the underlying complexities.</span>
<span class="comment-copy">OK I've never used meta classes so this approach is new to me. I can understand to some degree what's going on in the first few lines but the block from <code>temp = type(....</code> until <code>temp.update(....</code> doesn't make sense to me. What is that block doing?</span>
<span class="comment-copy">@Peter: That section first creates an empty temporary instance of a dictionary-like <code>enum._EnumDict'</code> class to use in the <code>super()</code> call at the end. It first populates this with the names and values extracted from the JSON data. Then it creates a <code>set</code> of the things it doesn't want copied from the <code>classdict</code> argument it was passed, which includes any of the JSON defined names it just put in, plus the name <code>'data'</code>, which it knows was defined in the <code>CountryCode</code> class definition and shouldn't be an <code>enum</code> member. Lastly it copies anything else from <code>classdict</code> that hasn't been  excluded.</span>
<span class="comment-copy">...continued: A nice thing about metaclasses is that they can do almost anything if you take the time to understand the nitty-gritty of how they work. For the <code>enum</code> class it's a little more involved because it already has a custom metaclass that needs to also be understood—but most of the time for "normal" classes, that won't be necessary.</span>
<span class="comment-copy">Thanks. I've started to read up on it. I think I'll be making use of it for other things soon.</span>
<span class="comment-copy">@martineau: I created a question/answer about <a href="http://stackoverflow.com/q/43730305/208880">deriving from <code>EnumMeta</code></a>.</span>
