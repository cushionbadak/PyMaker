<div class="post-text" itemprop="text">
<p>Assume the following class:</p>
<pre><code>class PersistenceType(enum.Enum):
  keyring = 1
  file = 2

  def __str__(self):
    type2String = {PersistenceType.keyring: "keyring", PersistenceType.file: "file"}
    return type2String[self]

  @staticmethod
  def from_string(type):
    if (type == "keyring" ):
        return PersistenceType.keyring
    if (type == "file"):
        return PersistenceType.file
    raise ???
</code></pre>
<p>Being a python noob, I am simply wondering: what specific kind of exception should be raised here?</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is <a href="https://docs.python.org/3/library/exceptions.html#ValueError" rel="nofollow noreferrer"><code>ValueError</code></a>:</p>
<blockquote>
<p>Raised when a built-in operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as <code>IndexError</code>.</p>
</blockquote>
<p>The longer answer is that almost none of that class should exist. Consider:</p>
<pre><code>class PersistenceType(enum.Enum):
    keyring = 1
    file = 2
</code></pre>
<p>This gives you everything your customized enum does: </p>
<ul>
<li><p>To get the same result as your customised <code>__str__</code> method, just use the <code>name</code> property:</p>
<pre><code>&gt;&gt;&gt; PersistenceType.keyring.name
'keyring'
</code></pre></li>
<li><p>To get a member of the enum using its name, treat the enum as a dict:</p>
<pre><code>&gt;&gt;&gt; PersistenceType['keyring']
&lt;PersistenceType.keyring: 1&gt;
</code></pre></li>
</ul>
<p>Using the built-in abilities of <code>Enum.enum</code> gives you several advantages:</p>
<ol>
<li><p>You're writing much less code.</p></li>
<li><p>You aren't repeating the names of the enum members all over the place, so you aren't going to miss anything if you modify it at some point.</p></li>
<li><p>Users of your enum, and readers of code that uses it, don't need to remember or look up any customized methods.</p></li>
</ol>
<p>If you're coming to Python from Java, it's always worth bearing in mind that:</p>
<p><a href="http://dirtsimple.org/2004/12/python-is-not-java.html" rel="nofollow noreferrer"><strong>Python Is Not Java</strong></a> (or, stop writing so much code)</p>
<p><a href="http://www.catb.org/jargon/html/G/Guido.html" rel="nofollow noreferrer"><strong>Guido<sup>1</sup> has a time machine</strong></a> (or, stop writing so much code)</p>
<hr/>
<p><sup>1</sup> â€¦ or in this case Ethan Furman, the author of the <code>enum</code> module.</p>
</div>
<span class="comment-copy"><code>AttributeError</code>? I am guessing this because the same type of an error shows up when you access a member that doesn't exist.</span>
<span class="comment-copy">Fancy. Something along the lines I was hoping for. Interestingly enough; I built my code on something some "more experienced" python people showed me long time ago. One question though: when I use the "dict" approach ... and the string is invalid ... I guess I will hit a pretty ugly exception message?</span>
<span class="comment-copy">You'll get a <code>KeyError</code>, which is exactly what you want, because you'll have supplied a nonexistent key. This is better than a custom exception, because again, a) you won't have to implement and maintain it, and b) users of the class won't have to go searching to find out what it means.</span>
<span class="comment-copy">Well. Yes, less code for me to maintain. But now my outer command line shell should probably catch that error, as the user doesn't know about hashes or anything. But I just found that argparse and "choices" gives me what I need there!</span>
<span class="comment-copy">Yep, by all means catch <code>KeyError</code> at the point it's raised so you can show something friendlier to the user (or rely on something else e.g. argparse to do so). You'll have to catch <i>something</i> regardless, and if it's a built-in exception, that code will be clearer and more maintainable.</span>
