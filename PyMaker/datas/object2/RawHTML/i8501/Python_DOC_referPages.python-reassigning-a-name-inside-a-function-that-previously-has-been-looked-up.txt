<div class="post-text" itemprop="text">
<p>Why do I get error in 3rd code below, but not in first two? I am using Python 3.6.0, Anaconda 4.3.1 (64-bit) Jupyter. </p>
<p>Code 1:</p>
<pre><code>c = 100
def fib():
    c = 20
    a = c
    print ("a in fib", a)
    print ("c in fib", c)
fib()
print ("c", c)
</code></pre>
<p>Output of Code 1:</p>
<pre><code>a in fib 20
c in fib 20
c 100
</code></pre>
<p>Code 2:</p>
<pre><code>c = 100
def fib():
    a = c
    print ("a in fib", a)
    print ("c in fib", c)   
fib()
print ("c", c)
</code></pre>
<p>Output of Code 2:</p>
<pre><code>a in fib 100
c in fib 100
c 100
</code></pre>
<p>Code 3:</p>
<pre><code>c = 100
def fib():
    a = c
    print ("a in fib", a)
    print ("c in fib", c)
    c = 20  
fib()
print ("c", c)
</code></pre>
<p>Output of Code 3:</p>
<hr/>
<pre><code>UnboundLocalError                         Traceback (most recent call last)
&lt;ipython-input-42-d6affa26dc65&gt; in &lt;module&gt;()
      7 
      8 
----&gt; 9 fib()
     10 print ("c", c)

&lt;ipython-input-42-d6affa26dc65&gt; in fib()
      1 c = 100
      2 def fib():
----&gt; 3     a = c
      4     print ("a in fib", a)
      5     print ("c in fib", c)

UnboundLocalError: local variable 'c' referenced before assignment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This behavior is called lexical scoping. Here's the relevant part of the official <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">Python docs</a> (emphasis mine):</p>
<blockquote>
<p><strong>If a name binding operation occurs anywhere within a code block, all
  uses of the name within the block are treated as references to the
  current block.</strong> This can lead to errors when a name is used within a
  block before it is bound. This rule is subtle. Python lacks
  declarations and allows name binding operations to occur anywhere
  within a code block. <strong>The local variables of a code block can be
  determined by scanning the entire text of the block for name binding
  operations.</strong></p>
</blockquote>
<p>And for the definition of <a href="https://docs.python.org/3/reference/executionmodel.html#binding-of-names" rel="nofollow noreferrer">"name binding operations"</a> (emphasis mine again):</p>
<blockquote>
<p><em>Names</em> refer to objects. Names are introduced by name binding
  operations.</p>
<p>The following constructs bind names: formal parameters to functions,
  <code>import</code> statements, class and function definitions (these bind the
  class or function name in the defining block), and <strong>targets that are
  identifiers if occurring in an assignment</strong>, <code>for</code> loop header, or after
  <code>as</code> in a <code>with</code> statement or <code>except</code> clause. The <code>import</code> statement of the
  form <code>from ... import *</code> binds all names defined in the imported module,
  except those beginning with an underscore. This form may only be used
  at the module level.</p>
<p>A target occurring in a <code>del</code> statement is also considered bound for
  this purpose (though the actual semantics are to unbind the name).</p>
</blockquote>
<p>So in your 3rd code example, the <code>c = 20</code> at the end of the block qualifies as a name binding operation via the "targets that are identifiers if occurring in an assignment" clause. That makes all occurrences of <code>c</code> in that function refer to the <em>local</em> variable <code>c</code>. At runtime, though, your code hits the <code>a = c</code> line first. Since <code>c</code> hasn't actually been defined in the local scope yet, you get the exception.</p>
<p>In the first block, you define <code>c</code> locally before you try to reference it, so no problem there.</p>
<p>In the second, you don't perform any name binding operations on <code>c</code> within the function, so Python assumes you want the outer definition.</p>
<p>As to <em>why</em> it works this way, see <a href="https://stackoverflow.com/questions/19064520/why-is-locality-determined-at-compile-time">this question</a>:</p>
<blockquote>
<p>The rationale for lexical scoping is not just for performance (full lexical scoping including closures actually has a performance cost, see the funcarg problems), it's for simplicity and reliability. While it may be surprising when first learning the language, the rules are actually dead simple so an experienced programmer can instantly tell which use of an identifier refers to which scope. One can understand functions in isolation, as execution isn't affected by who calls this functions and how they decided to name their variables.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This is the  <a href="https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">official explanation</a> you're looking for</p>
<pre><code>&gt;&gt;&gt; x = 10
&gt;&gt;&gt; def foo():
...     print(x)
...     x += 1
&gt;&gt;&gt; foo()
Traceback (most recent call last):
...
UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>
<blockquote>
<p>This is because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope. Since the last statement in foo assigns a new value to x, the compiler recognizes it as a local variable. Consequently when the earlier print(x) attempts to print the uninitialized local variable and an error results.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Well that is an interesting corner case. The reason comes from the way Python binds variable to a block:</p>
<blockquote>
<p>4.2.1. Binding of names<br/>
  ...<br/>
  The following constructs bind names: ... targets that are identifiers if occurring in an assignment....
  <strong>If a name is bound in a block, it is a local variable of that block</strong>, unless declared as nonlocal or global.</p>
</blockquote>
<p>In first block, c is local to function and is assigned before use: fine and the global C in unchanged by the <code>fib()</code> function call</p>
<p>In second block c is not assigned in function definition: <code>a=c</code> uses the global variable</p>
<p>In third, <code>c</code> is assigned inside the bloc, so it is local. But it is used before assignement, hence the error. If you want to use the global value, you must declare it as global:</p>
<pre><code>def fib():
    global c
    a = c
    print ("a in fib", a)
    print ("c in fib", c)
    c = 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I can't say for certain, but I think the most likely explanation is that the first two see a global version of the variable 'c'. </p>
<p>The third one must see that you define a local variable 'c' at the bottom of the 'fib' function and so doesn't use the global 'c' variable. Really, it's a pretty good example of why you shouldn't use global variables in this way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python "assumes" that we want a local variable due to the assignment to a inside of fib(), so the first print statement throws this error message. Any variable which is changed or created inside of a function is local, if it hasn't been declared as a global variable. To tell Python, that we want to use the global variable, we have to use the keyword "global", as can be seen in the following example:</p>
<pre><code>c = 100
def fib():
    global c
    a = c
    print ("a in fib", a)
    print ("c in fib", c)
    c = 20  
fib()
print ("c", c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When we use global variables we fundamentally make it available to all the functions that we have defined or plan to define. In your code when you say 
<code>c=100</code>
You have a global variable defined. But to use it inside a function without being hidden by a local variable, you have do this</p>
<pre><code>def fib():
   global c
   print(c)
   c=10
   a=c
   print(a,c)
</code></pre>
<p><code>fib()</code></p>
<p><code>Output:
100
10 10</code></p>
<p>Local variables need definition to be referenced in the same scope. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is because you can use but not change a string value in Python (once assigned).</p>
<blockquote>
<p>You can "update" an existing string by (re)assigning a variable to another string.<a href="https://www.tutorialspoint.com/python/python_strings.htm" rel="nofollow noreferrer"> [ref]</a></p>
</blockquote>
<p>In your scenario, you're using variable <code>c</code> and assigning it to <code>a</code>, but further you must play with your newly created variable <code>a</code> and not change <code>c</code>.</p>
</div>
<span class="comment-copy">I changed your title. I'm not entirely happy with the wording, but I think it is more descriptive than the original.</span>
<span class="comment-copy">To be honest, I think that behavior is a wart and surprising. Does anyone know the reasoning for this? What's the problem with changing <code>s</code> from global to local on the fly?</span>
<span class="comment-copy">@timgeb As it turns out, that's been asked here before. It's not a terribly deep explanation, but see update.</span>
<span class="comment-copy">Alright, thanks for providing the rationale. I may not agree. :)</span>
<span class="comment-copy">Literally has nothing to do with the problem.</span>
