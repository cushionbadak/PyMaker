<div class="post-text" itemprop="text">
<p>As everyone knows, you can do <code>del sys.modules[module]</code> to delete an imported module. So I was thinking: how is this different from rewriting <code>sys.modules</code>? An interesting fact is, rewriting <code>sys.modules</code> can't truely delete a module.</p>
<pre><code># a_module.py
print("a module imported")
</code></pre>
<p>Then</p>
<pre><code>import sys

def func1():
    import a_module
    # del sys.modules['a_module']
    sys.modules = {
        k: v for k, v in sys.modules.items() if 'a_module' not in k}
    print('a_module' not in sys.modules)  # True

def func2():
    import a_module

func1()  # a module imported
func2()  # no output here
</code></pre>
<p>If I use <code>del sys.modules['a_module']</code>, calling <code>func2()</code> also prints <code>a module imported</code>, which implies that <code>a_module</code> is successfully deleted.</p>
<p>My question is: What does <code>del sys.modules[module]</code> actually do, besides changing the dictionary?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sys.modules</code> is the <em>Python-accessible reference</em> to the <em>canonical</em> data structure for tracking what modules are imported. Removing a name from that dictionary means that any future attempts to import the module will result in Python loading the module from scratch.</p>
<p>In other words, whenever you use an <code>import</code> statement, the first thing Python does is check if the dictionary that <code>sys.modules</code> references already has an entry for that module and proceed with the next step (binding names in the current namespace) without loading the module first. If you delete entries from <code>sys.modules</code>, then Python won't find the already-loaded module and loads again.</p>
<p>Note the careful wording about <em>Python-accessible</em> here. The actual dictionary lives on the Python heap and <code>sys.modules</code> is just one reference to it. You <em>replaced</em> that reference with another dictionary by assigning to <code>sys.modules</code>. However, the interpreter has <em>more references to it</em>; they just are not accessible from Python code, not without <code>ctypes</code> trickery to access the C-API anyway.</p>
<p>Note that this is <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="noreferrer"><em>explicitly documented</em></a>:</p>
<blockquote>
<p>However, replacing the dictionary will not necessarily work as expected and deleting essential items from the dictionary may cause Python to fail.</p>
</blockquote>
<p>From the C-API, you'd have to use <code>PyThreadState_Get()-&gt;interp-&gt;modules</code> to get the internal reference to the dictionary.</p>
</div>
<span class="comment-copy">Thank you. Is this documented somewhere? I didn't know there are "more refs".</span>
<span class="comment-copy">@laike9m: a lot of this is implementation detail; I did a quick deep-dive in the source code. Other Python implementations are likely to handle interpreter state differently.</span>
<span class="comment-copy">@laike9m: I note, for example, that the <a href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" rel="nofollow noreferrer">C-API documentation for <code>PyInterpreterState</code></a> makes no mention of any struct members, and the documentation for <code>sys.modules</code> explicitly warns against replacing the <code>sys.modules</code> reference.</span>
