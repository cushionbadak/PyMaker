<div class="post-text" itemprop="text">
<p>For an automation project, I have to persist user id/password to allow my scripts to connect to a remote service.</p>
<p>My idea is to use the <a href="https://pypi.python.org/pypi/keyring" rel="nofollow noreferrer">keyring</a> module to achieve some better level of security; but as not all platforms support keyring; I am looking into storing credentials into a flat file, too. I created a "Credentials" class; and figured that using <code>pickle</code> I could just dump/load objects of that class, like:</p>
<pre><code>def _store_to_file(credentials):
    from pickle import dump
    pkl = open('whatever.dat', 'wb')
    dump(credentials, pkl)
    pkl.close()
</code></pre>
<p>Unfortunately, this file gives away the password in plain text:</p>
<pre><code>S'_password'
p6
S'bla'
</code></pre>
<p>I understand that file, stored by a local script isn't offering real security. But I was hoping to at least get to a point where one would need more than a simple "less whatever.dat" to acquire that password text.</p>
<p>I had hoped that pickle has some kind of "scramble" mode; but couldn't find anything. Am I overlooking something?</p>
<p>Alternatively: is there another way to persist my objects that easily, but not that "easy human readable"?</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple solution; based on the comment by Keef Baker --- using AES encryption to scramble on password/username; like this:</p>
<pre><code>class Credentials(object):

  def __init__(self, user, password):
      self._user = aes.encrypt(user)
      self._password = aes.encrypt(password)

  @property
  def user(self):
      return aes.decrypt(self._user)

  @property
  def password(self):
      return aes.decrypt(self._password)

  from Crypto.Cipher import AES
  aes = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should not.</p>
<p>The problem in applications that try to keep a safely encrypted copy of a key is just that they need another key to decrypt it. It could be encrypted too by would need still another key. It could... (sorry joking :-) ). It only makes sense when you have to store multiple secrets, because you unlock the secure vault with one single password - what keyring and password managers do...</p>
<p>For one single password, the correct and portable way is to rely on the OS to provide a secure folder. Both Linux (and Unix-like) and provide either access control rules (only accessible to user), or encrypted folders if you need better security. Just document it and respect the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="nofollow noreferrer">single responsibility principle</a>.</p>
</div>
<span class="comment-copy">To be honest I'd create an encrypt and decrypt function using <code>bcrypt</code> which would then store a base64 encoded, encrypted password into your pickle file.</span>
<span class="comment-copy">So scramble the data before pickling it</span>
<span class="comment-copy">Maybe <a href="https://pypi.python.org/pypi/EncryptedPickle/0.1.4" rel="nofollow noreferrer">pypi.python.org/pypi/EncryptedPickle/0.1.4</a></span>
<span class="comment-copy">@KeefBaker Unless I am mistaken: bcrypt will only allow me to <b>hash</b> a password. But I need the password in <b>plain text</b> later on. In other words: I need something that gives me encrypt() and decrypt() functions; like codecs with rot13. But maybe 10 percent harder than rot13 ;-)</span>
<span class="comment-copy">My bad, I thought I was using bcrypt in my project. I was actually using <code>from Crypto.Cipher import AES</code></span>
<span class="comment-copy">Upvoted, with the caveat that obviously in real code you wouldn't use rot13, but e.g. <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer"><code>hashlib</code></a> or, better, <a href="https://cryptography.io/en/latest/" rel="nofollow noreferrer"><code>cryptography</code></a>, with a key stored in a separate <code>secrets.py</code> module (which can be kept out of version control if necessary).</span>
<span class="comment-copy">I don't see that hashlib gives me decrypt/encrypt; but cryptography does ;-)</span>
<span class="comment-copy">@ZeroPiraeus But Keef gave me another good hint; so I reworked to use AES encryption at least.</span>
<span class="comment-copy">@ZeroPiraeus As I liked your feedback; feel free to look into <a href="http://stackoverflow.com/questions/43274703/trouble-with-encode-encrypt-pad-using-same-code-for-python2-and-python3" title="trouble with encode encrypt pad using same code for python2 and python3">stackoverflow.com/questions/43274703/â€¦</a> as well ;-)</span>
<span class="comment-copy">I understand all of that. But this is an company internal tool. When some intruder manages to scan the local disk of one of my coworkers; we are already in deep sh... trouble. And just for the record: the same password that we need to talk to that servers I want to talk to ... is also used to talk to our SVN server. And that password sits there in some .svn folder in plain text.</span>
