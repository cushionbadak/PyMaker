<div class="post-text" itemprop="text">
<p>How can I get a Python list from a text file with the following contents?</p>
<pre><code>'hallo'
'hallo\n'
'\x00' * 1
100
'400 + 2'
400 + 2
</code></pre>
<p>For example:</p>
<pre><code>ll = ["hallo", "hallo\n", "\x00", 100, 402, 402]
</code></pre>
<p>with the types:</p>
<pre><code>[string, string, string, int, int, int]
</code></pre>
<p>Means, every string which python understands as <code>int</code> should be from type <code>int</code>.</p>
<p>I tried to use <code>eval</code> but it has difficulties with <code>\n</code> and <code>\x00</code>. </p>
<p>The user input (list of strings to convert) is assumed to be safe.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>WARNING :</strong> Using <code>eval</code> is <a href="https://stackoverflow.com/questions/1832940/is-using-eval-in-python-a-bad-practice">dangerous</a>. Be very careful with it, or, better yet, find an alternative without.</p>
<p>That being said, you could define a regex to check if the string looks like something you'd like to <code>eval</code>. For example, anything with only numbers, spaces and mathematical operators could be deemed safe:</p>
<pre><code>import re

l = ['hallo', 'hallo\n', '\x00' * 1, '100', 100, '400 + 2', '400 + - ', 400 + 2]


def string_or_expression(something):
    if isinstance(something, str):
        expression = re.compile('\A[\d\.\-\+\*\/ ]+\Z')
        if expression.match(something):
            try:
                return eval(something)
            except:
                return something
    return something

print([string_or_expression(s) for s in l])
# ['hallo', 'hallo\n', '\x00', 100, 100, 402, '400 + - ', 402]
</code></pre>
<p>With Python3, you might use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a>, which might be a little less dangerous than a plain <code>eval</code> :</p>
<pre><code>import re
import ast

l = ['hallo', 'hallo\n', '\x00' * 1, '100', 100, '400 + 2', '400 + - ', 400 + 2]


def string_or_expression(something):
    if isinstance(something,str):
      expression = re.compile('\A[\d\.\-\+\*\/ ]+\Z')
      if expression.match(something):
          try:
              return ast.literal_eval(something)
          except:
              return something
    return something

print([string_or_expression(s) for s in l])
# ['hallo', 'hallo\n', '\x00', 100, 100, 402, '400 + - ', 402]
</code></pre>
<p>Yet another alternative would be to use @poke's <a href="https://stackoverflow.com/a/20748308/6419007">"expression evaluation algorithm"</a>, since <code>literal_eval</code> doesn't understand <code>'2 * 3'</code>.</p>
<p>Finally, even a "safe" expression like <code>'2**2**2**2**2**2**2**2**2**2'</code> could bring your server down.</p>
</div>
<div class="post-text" itemprop="text">
<p>how about:</p>
<pre><code> def try_eval(x):
    try:
        res=eval(x)
    except:
        res=x
    return res

[try_eval(x) for x in l]
</code></pre>
<p>output:</p>
<pre><code>['hallo', 'hallo\n', '\x00', 100, 402]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's get serious about avoiding dangerous eval here &gt;:)</p>
<pre><code>import compiler

def is_math(expr):
    """Return True if the expression smells mathematical."""

    try:
        module = compiler.parse(expr)
        stmt, = module.getChildNodes()
        discard, = stmt.getChildNodes()
        code, = discard.getChildNodes()
        return not isinstance(code, compiler.ast.Name)
    except ValueError:
        return False
    except TypeError:
        return False

t = [eval(s) if is_math(s) else s for s in l]
</code></pre>
<p>Yes, I took a couple of assumptions here, but you can modify them to suit your needs as strictly as you really need. The AST is pretty easy to understand. When you do a <code>parse</code>, you get a Module. Inside the Module is a Statement. Inside that is (most likely) discard code (that just means it isn't being used anywhere).</p>
<p>If it isn't discard code, we assume it's a string. For one thing, this is likely to prevent any dangerous side effects from eval. (Someone prove me wrong here – wrap a dangerous expression in discard code.)</p>
<p>Inside that is the meat of your expression – from there I assume that anything that is a plain string will appear to be a name in the AST. Anything that isn't a name is probably a number or a math operation.</p>
<p>I <em>think</em> eval should be safe at this point, which is necessary if the expression is really math.</p>
</div>
<span class="comment-copy">Do you only want to convert strings and numbers, or do you plant to eval any Python object?</span>
<span class="comment-copy">How would you possibly decide what string stays a string and what gets evaluated? I.e. why does <code>'400 + 2'</code> become an evaluated number, how do you decide that? – Anyway, you need to write some smaller parser for this to detect what you want to do with the input. Once you have that, there shouldn’t be a problem evaluating the input according to your decision. The question as it stands is kind of too broad for SO.</span>
<span class="comment-copy">From the question you have stated, I agree with poke, it is a little to broad, and you should define what you want to do with the input for each case. It looks like its heading toward regular expression/s in a loop/iterator at the moment. Is that list exhaustive in terms of inputs?</span>
<span class="comment-copy">You keep changing your input to the point where it’s no longer clear what you are trying to do. Please actually clarify what you are trying to do; not just what the results from your examples are supposed to do, but what actually happens with the input.</span>
<span class="comment-copy">Sorry for specializing the question multiple times. It should now be fine.</span>
<span class="comment-copy">You don't actually need to evaluate the math by the time you've written that regex. You could declare that an expression that "looks like math" is probably a number. This kind of approximation is much safer than using eval, and well worth the tradeoff IMO.</span>
<span class="comment-copy">@kojiro: That would be nice, but how would you convert <code>'400 + 2'</code> to <code>402</code> then?</span>
<span class="comment-copy">Ah, nice, OP changed the question on me. Or perhaps I misunderstood it from the get-go. I thought OP was asking for an interpretation of the types.</span>
<span class="comment-copy">Adding a comment <i>“Be very careful here!!!”</i> does not really do anything helpful. Once you use <code>eval</code> on user input, you have already lost and cannot be careful anymore.</span>
<span class="comment-copy">@poke: True. Still, I left the comment so that if OP plays with the solution and copy-pastes it somewhere else, that there's a clear reminder of a very dangerous method call. I'd be interested to know what the most dangerous expression could be with just digits and basic operators.</span>
<span class="comment-copy">eval will not tolerate <code>\x00</code> so the result will be:  <code>['hallo', 'hallo\n', '\x00 * 1', 100, 402]</code></span>
<span class="comment-copy">Same comment as for user1753919 <code>['hallo', 'impOrt shutil; shutil.rmtree("/home/user")', '400 + 2']</code> There's a typo to make it "safer". You get the idea.</span>
<span class="comment-copy">@mr.wolle I did copy paste... the result is actually <code>\x00</code> and not <code>\x00*1</code>. You can check it...</span>
<span class="comment-copy">You shouldn't call <code>eval</code> without some kind of check.</span>
<span class="comment-copy">OP needs more information than just <code>number</code> or <code>string</code>. Still, your method is interesting.</span>
<span class="comment-copy">Updated, somewhat hesitantly. Given my new understanding of the question I don't think eval is avoidable. (Even if I unparsed the AST and executed it, the result would be essentially eval.)</span>
<span class="comment-copy">You could write your own expression evaluator, like I’ve <a href="http://stackoverflow.com/a/20748308/216074">outlined in one of my answers</a>. Then you’re completely safe on the evaluating side of the question (I still consider the detection part rather difficult/unclear).</span>
<span class="comment-copy">Seems one can defeat this rather easily using parentheses. I will have to try harder…</span>
