<div class="post-text" itemprop="text">
<p>I have a class:</p>
<pre><code>class Portfolio:
    def __init__(self, value):
        self.value = value

class GenericStrategy:
    def __init__(self, portfolio: Portfolio):
        self.portfolio = portfolio

    def modify_ptf_value(new_value):
        self.portfolio.value = new_value
        # This should return an error
</code></pre>
<p>I'will write some strategies which will inherit from <code>GenericStrategy</code>. I'd like their methods to be able to read the attribute portfolio but not to modify it, nor its attributes.</p>
<p>I read something about the <code>@properties</code> decorator, but it only works if I don't want the attribute (and its attributes) to be accessible from the outside, i can still modify the attribute (and its attributes) from methods 'inside' the object.
Is there a way to make the attribute (and its attributes) 'read-only' except for the <code>__init__</code> method? Is my design wrong and should start over? I know it is up to the user not to modify "protected" attributes, but I would like to make it bullet proof. Any idea is well accepted, even if it requires a substantial change in the class design.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>As opposed to other (commonly used) programming languages <em>Python</em> comes with a new approach regarding accessing class/instance members. For example, nothing is really private, the fields/methods that:</p>
<ul>
<li>start with an <code>_</code>, are regular fields</li>
<li>start with <code>__</code> (and end with at most one <code>_</code>), are just name mangled, but they still can be accessed (even modified/deleted) from outside the class</li>
</ul>
<p>So, at the end it's a matter of convention, and it relies that it will be followed by those who write code. Bottom line is there's <strong>nothing</strong> that would prevent an user gaining access to a class/instance's internals.</p>
<p><em>Note</em>: In other language it's possible too to access private members: there are methods officially supported (like <strong><em>Reflection</em></strong> (<a href="https://docs.oracle.com/javase/tutorial/reflect/" rel="nofollow noreferrer">[Oracle]: Trail: The Reflection API</a>) for <em>Java</em>), or not so officially supported (which require some "tricks" - e.g.: <code>reinterpret_cast</code>ing a <code>class</code> to a <code>struct</code> with the same structure for <em>C++</em>). Nowadays, more and more languages tend to offer a way to alter an instance structure.</p>
<p>Anyway, there is the so called <strong><em>Descriptor Protocol</em></strong> (<a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">[Python]: Descriptor HowTo Guide</a>) which is one of the <em>Python</em>'s most powerful (and also most misunderstood) features.</p>
<p>Using <em>descriptors</em> (as a side comment, <em>properties</em> rely on them), I wrote a piece of code that achieves (on some degree) what you're asking for:</p>
<pre><code>class LockedAttribute(object):
    def __init__(self, name):
        self._name = name
        self._set_count = 0
        self._set_treshold = 1

    def __get__(self, instance, cls):
        return instance.__dict__[self._name]

    def __set__(self, instance, value):
        if self._set_count &gt;= self._set_treshold:
            raise AttributeError("Can't set attribute '{}'".format(self._name))
        else:
            instance.__dict__[self._name] = value
            self._set_count += 1

    def __delete__(self, instance):
        raise AttributeError("Can't delete attribute '{}'".format(self._name))


class GenericStrategy(object):
    portfolio = LockedAttribute("portfolio")

    def __init__(self, portfolio):
        self.portfolio = portfolio
        try:
            self.portfolio = portfolio
        except AttributeError as e:
            print("  ERROR: {}".format(e))

    def set_portfolio(self, new_value):
        self.portfolio = new_value


if __name__ == "__main__":
    strategy = GenericStrategy("some portfolio name")
    print("Portfolio: {}".format(strategy.portfolio))
    try:
        del strategy.portfolio
    except AttributeError as e:
        print("  ERROR: {}".format(e))
    try:
        strategy.set_portfolio("some 2nd portfolio name")
    except AttributeError as e:
        print("  ERROR: {}".format(e))
    try:
        strategy.portfolio = "some 3rd portfolio name"
    except AttributeError as e:
        print("  ERROR: {}".format(e))
    print("Portfolio: {}".format(strategy.portfolio))
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>I removed <code>__</code> from the private attribute's name (<code>portfolio</code>) to avoid using the mangling that I was talking about, in my code (would make it more difficult to read)</li>
<li>For <em>Py27</em> compatibility, the classes inherit <code>object</code>. If the compatibility isn't mandatory, the inheritance relation can be deleted (in <em>Py3x</em> it is by default)</li>
<li>I added the <code>try/except</code> blocks to illustrate the behavior, in <em>production</em> they should be deleted</li>
<li>As I stated above, if anyone wants to alter this behavior, <strong>can</strong></li>
</ul>
</div>
<span class="comment-copy">This way the whole object portfolio cannot be changed, but I can still change attributes of the object portfolio. I edited the question to make it clearer. Descriptors seem like a great thing, I need to learn how they work.</span>
<span class="comment-copy">Hmm, I was afraid that this would be the next question. The general answer is that you <b>can't</b> make them <b>truly</b> <i>bullet proof</i>. A consumer of your class/instance will be able to play with them. Regarding the question itself, I don't have an answer. An alternative would be to make the <code>portfolio</code> type objects use <code>LockedAttribute</code> as well, and make them <i>read-only</i> (,or initialize them in <code>GenericStrategy.__init__</code> - which would break any aggregation), but I doubt that this would fit your needs.</span>
<span class="comment-copy">I felt like it was impossible... Thanks for the answer anyway, the locked attribute class is great</span>
<span class="comment-copy">Thank you. You can take a look at <a href="https://docs.python.org/2/library/abc.html" rel="nofollow noreferrer">[Python]: abc module</a>, or <a href="https://docs.python.org/2/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer">[Python]: <code>__setattr__</code> method</a>, maybe you could something from there to get you closer to your goal.</span>
