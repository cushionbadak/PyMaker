<div class="post-text" itemprop="text">
<p>So, I have this list</p>
<pre><code>l = ['abc', 'retro', '', '', 'images', 'cool', '', 'end']
</code></pre>
<p>and, I want to join them in a way such as:</p>
<pre><code>l = ['abc retro', '', '', 'images cool', '', 'end']
</code></pre>
<p>I tried lots of methods but nothing seemed to work. Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> and a list comprehension. Group into <code>''</code>s and non <code>''</code> and join items from the latter using <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>str.join</code></a>. The ternary operator in the rear of the comprehension uses the group key to decide what to do for each group:</p>
<pre><code>from itertools import groupby

l = ['abc','retro','','','images','cool','','end']

r = [j for k, g in groupby(l, lambda x: x=='') 
                          for j in (g if k else (' '.join(g),))]
print(r)
# ['abc retro', '', '', 'images cool', '', 'end']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another version using good old while loops to edit the list in place:</p>
<pre><code>In [6]: l=['abc','retro','','','images','cool','','end']

In [7]: i = 1
   ...: while i &lt; len(l):
   ...:     while l[i-1] and l[i]:
   ...:         l[i-1] += ' ' + l[i]
   ...:         del l[i]
   ...:     i += 1
   ...:

In [8]: l
Out[8]: ['abc retro', '', '', 'images cool', '', 'end']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another <code>groupby</code> approach. It doesn't use a list comp, but I think that makes it a little more readable. ;) And unlike the other (current)  answers it uses a single loop rather than nested loops (apart from the loop that <code>.join</code> uses internally).</p>
<p>We use <code>bool</code> as the key function, so the groups are either true-ish or false-ish. A false-ish group is a group of empty strings, so we extend the output list <code>new</code> with the group. A true-ish group contains only non-empty strings, so we join it, and append the result to <code>new</code>.</p>
<pre><code>from itertools import groupby

old = ['abc', 'retro', '', '', 'images', 'cool', '', 'end']

new = []
for k, g in groupby(old, key=bool):
    if k:
        new.append(' '.join(g))
    else:
        new.extend(g)

print(new)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['abc retro', '', '', 'images cool', '', 'end']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without using lambda functions with list comprehension  you could do it the old fashion way by just iterating through the lists.</p>
<pre><code>l=['abc','retro','','','images','cool','','end']

result = list()
for x in range(len(l)):
    if l[x]:
        #Its not empty lets move to next until we find one or more consecutive non empty elements
        for y in range(x+1, len(l)):
            if l[y]:
                result.append(l[x]+' '+l[y])
                x = y

            else:
                x = y
                break
    else:
        result.append(l[x])

    #We are going to append last element, because we might have read an empty before
    if x == len(l)-1:
        result.append(l[x])

print result
</code></pre>
<p>^^ The solution above is not correct, and would only fit this case.</p>
<p>Here is another generic approach using a stack approach </p>
<pre><code>l=['abc','retro','','','images','are','cool','','end']

result = list()
previous = ''
while l:
    current = l.pop(0)
    if current:
        if previous:
            previous+=' '+current
        else:
            previous = current
    else:
        result.append(previous)
        result.append('')
        previous = ''

result.append(current)
print result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools.chain</code> and <code>itertools.groupby()</code> with <code>bool</code> as the key-function:</p>
<pre><code>In [21]: from itertools import groupby, chain

In [22]: list(chain.from_iterable([' '.join(g)] if k else g for k, g in groupby(lst, bool)))
Out[22]: ['abc retro', '', '', 'images cool', '', 'end']
</code></pre>
</div>
<span class="comment-copy">So the empty strings should not be joined?</span>
<span class="comment-copy">do you want the element between the empty string in a list ?</span>
<span class="comment-copy">yes, the empty elements have to be there.</span>
<span class="comment-copy">@WillemVanOnsem yes, the empty elements shouldn't be joined.</span>
<span class="comment-copy">just perfect..!</span>
<span class="comment-copy">You can simplify that (and speed it up) by replacing the lambda by <code>bool</code>, and reversing the test in the inner loop: <code>r = [j for k, g in groupby(l, bool) for j in ([' '.join(g)] if k else g)]</code>. <code>bool</code> is implemented in C so it <i>should</i> be faster than calling a Python function (the lambda).</span>
<span class="comment-copy">I'll pay that, although mutating the source list <i>may</i> not be desirable, but I guess it's ok here, since the OP is assigning the modified list back to <code>l</code>.</span>
<span class="comment-copy">This doesn't work so well if there are more than two words in a row, eg, <code>l=['abc','retro','','','images','are','cool','','end']</code>, or if <code>l</code> ends in an empty string.</span>
<span class="comment-copy">Yes you are correct, also forgot about iterators in python. Will update post with another solution</span>
<span class="comment-copy">The new version is better, but it still has a few problems. It adds extra empty strings, and it does't handle the end of the list properly. You can fix it by changing <code>result.append(previous)</code> to <code>if previous: result.append(previous)</code>, and replace <code>result.append(current)</code> with <code>if previous: result.append(previous)</code> too. Also, <code>.pop(0)</code> is ver inefficient because all the subsequent list items have to get moved down after the first one's deleted. It's much better to do <code>for current in l:</code></span>
