<div class="post-text" itemprop="text">
<p>I have a string, and I have a list of positions of the substrings that I need to delete:</p>
<pre><code>text = 'ab cd ef gh'
positions = [[2, 5], [8, 11]]
</code></pre>
<p>Every element of the list contains start and end position of substring. End position is exclusive, and start position is inclusive. So the string should be transformed to:</p>
<pre><code>text = 'ab ef'
</code></pre>
<p>Length of the list with positions is unknown, so the soultion can't be just hardcoded.</p>
<p>Is there any effective way to delete multiple substrings by their positions? Positions can't overlap.</p>
</div>
<div class="post-text" itemprop="text">
<p>Strings are <strong>immutable</strong>, so in-place deletion is a no-go. And successive concatenation is suboptimal.</p>
<p>You can convert the string to list so it can be <em>mutated</em> and simply wipe off the desired positions by <strong>deleting</strong> each unwanted slice. Use <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>str.join</code></a> to recreate your string:</p>
<pre><code>text = 'ab cd ef gh'

lst = list(text)
for i in positions[::-1]: # iterate from behind so index does not shrink inwards
    del lst[slice(*i)]

text = ''.join(lst)
print(text)
# 'ab ef'
</code></pre>
<p>Note that conversion to list for the mutation of immutable types is also suggested by the docs as best practice:</p>
<blockquote>
<p>Concatenating immutable sequences always results in a new object. This
  means that building up a sequence by repeated concatenation will have
  a <strong>quadratic runtime cost</strong> in the total sequence length. To get a <strong>linear runtime cost</strong>, you must switch to one of the alternatives below:</p>
<ol>
<li>if concatenating <code>str</code> objects, you can build a list and use
  <code>str.join()</code> at the end or else write to an <code>io.StringIO</code> instance and
  retrieve its value when complete</li>
</ol>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You have to offset for future indexes. So we first get the rest of the string (excluding the two indexes) via <code>text[:2] + text[5:]</code> and then we also need to offset it too, because we are removing items from the string.  So, we'll add our offset to each position item.</p>
<pre><code>text = 'ab cd ef gh'
positions = [[2,5],[8,11]]
offsetNextIndexes = 0
for position in positions:
    text = text[:position[0] + offsetNextIndexes] + text[position[1] + offsetNextIndexes:]
    offsetNextIndexes += position[0] - position[1]
print(text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should work easily.</p>
<pre><code>" ".join(text.split()[0::2])
</code></pre>
<p>The slicing will help here to skip some parts, it works as </p>
<pre><code>[start:end:difference]
</code></pre>
</div>
<span class="comment-copy">What are these values <code>[2,5]</code>?</span>
<span class="comment-copy">@AKS indeces [start, end]. Judging by desired output it's [inclusive, exclusive].</span>
<span class="comment-copy">Is <code>end</code> index inclusive or exclusive? You have asked a very unclear question and that too without showing what you have already tried to achieve the expected output.</span>
<span class="comment-copy">You can specify the spacing you need using slicing</span>
<span class="comment-copy">Is it possible for positions to overlap?</span>
