<div class="post-text" itemprop="text">
<p>I have a list in Python</p>
<pre><code>list1 = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1]
</code></pre>
<p>There are "groupings" of consecutive 1's and 0's. For my purposes, I am only interested in the consecutive 1's. Let's say if there is a solitary 1, e.g. </p>
<pre><code> ... 0, 0, 1, 0, 0 ...
</code></pre>
<p>I would like it to be changed into a 0. Similarly, if there are only pairs of 1's, these should become 0s as well. e.g. </p>
<pre><code>.... 0, 0, 1, 1, 0, 0...
</code></pre>
<p>should become</p>
<pre><code>.... 0, 0, 0, 0, 0, 0...
</code></pre>
<p>But "triplets" of consecutive ones or higher are ok. </p>
<p>I considered keeping track of the counts of 1s via a dictionary, but this feels too complex. The idea would be to iterate through the list, keeping track of the count of consecutive 1s in a list. But, how do you "go back" and switch the 1s to 0s?</p>
<pre><code>counter_list = []
for i in list1: 
    if i == 1:
        counter_list = counter_list + 1
            if len(counter_list)==1 or len(counter_list)==2:
                # now I don't know how to "go back" to change these elements into 0s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> can help by grouping the list into runs of 0s or 1s. From there, we can use the length of a group of 1s to decide whether to switch it to 0s, and use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a> to fuse the groups back into one stream:</p>
<pre><code>import itertools

groups = ((key, list(group)) for key, group in itertools.groupby(list1))

fixed_groups = (group if key==0 or len(group)&gt;2 else [0]*len(group)
                for key, group in groups)

result = list(itertools.chain.from_iterable(fixed_groups))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an <em>erosion</em> followed by a <em>dilation</em>, common operations in computer vision:</p>
<pre><code>&gt;&gt;&gt; from scipy.ndimage.morphology import binary_dilation, binary_erosion
&gt;&gt;&gt; print(list1)
[0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1]
&gt;&gt;&gt; print(binary_dilation(binary_erosion(list1)).astype(int))
[0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
</code></pre>
<p>The composition of the two operations is called an <em>opening</em>:</p>
<pre><code>&gt;&gt;&gt; from scipy.ndimage.morphology import binary_opening
&gt;&gt;&gt; print(binary_opening(list1).astype(int))
[0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use methods from image processing for this. The morphological operation "opening" with the structure element [1 1 1]should do the job. Should be a 1-liner.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a simple for-loop. Not sure it is the most efficient way, but it does the trick.</p>
<pre><code>list1 = [0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,1,1,1]

counter_list = []
for i,elem in enumerate(list1):
    if elem==1:
        counter_list.append(i)
    else:
        if len(counter_list)&gt;0 and len(counter_list)&lt;=2:
            for e in counter_list:
                list1[e] = 0
        counter_list= []
print(list1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could turn it into a string and use a regular expression to substitute short runs of <code>'1'</code> with equivalent runs of <code>'0'</code>, then turn it back into a list:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; list1 = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1]
&gt;&gt;&gt; ''.join(map(str, list1))
'0001110011000111111'
&gt;&gt;&gt; re.sub(r'(?&lt;!1)1{,2}(?!1)', lambda x: len(x.group())*'0', _)
'0001110000000111111'
&gt;&gt;&gt; list(map(int, _))
[0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
</code></pre>
</div>
<span class="comment-copy">There are a lot of ways you could do this... what have you tried?</span>
<span class="comment-copy">It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far (forming a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>), example input (if there is any), the expected output, and the output you actually get (output, tracebacks, etc.). The more detail you provide, the more answers you are likely to receive. Check the <a href="https://stackoverflow.com/tour">tour</a> and <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a>.</span>
<span class="comment-copy">@juanpa.arrivillaga I've tried iteration and keeping track of the 1s in a list. This is tricky though, because if the list is only size 1 or 2, I'm not sure how to "go back" and switch these values.</span>
<span class="comment-copy">... then <i>share your attempts</i></span>
<span class="comment-copy">@juanpa.arrivillaga Sorry! Edits above.</span>
<span class="comment-copy">wait, len doesn't work on groups - fixing...</span>
<span class="comment-copy">Fixed the len problem.</span>
<span class="comment-copy">So far, by the use of generators, this looks like the most efficient approach at least.</span>
<span class="comment-copy">@ShanZhengYang: I'd expect the <code>binary_opening</code> thing to be a lot more efficient, actually, especially if you're working with NumPy arrays instead of lists.</span>
<span class="comment-copy">my answer was a minute too late =). This composition is called opening.</span>
<span class="comment-copy">Thanks @yar , I edited that into the answer</span>
<span class="comment-copy">see @wim's answer</span>
<span class="comment-copy">@ShanZhengYang yep, thank you... I wrote it in parallel =)</span>
