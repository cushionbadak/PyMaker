<div class="post-text" itemprop="text">
<p>I have a to generate all possible combinations of a tuple of tuples</p>
<pre><code>( (base1 , position1) , (base2 , position2) )
</code></pre>
<p>The <code>bases = ["U", "C", "A", "G"]</code> and the <code>positions = [0,1,2,3,4,5,6,7,8]</code>.</p>
<p>Requirements</p>
<ul>
<li>no repeats</li>
<li>the bases can be the same but the positions must be
different</li>
<li>the order must be kept.</li>
</ul>
<p>For example:</p>
<p><code>( (A,1), (B,2) ) == ( (B,2) , (A,1) )</code> and
<code>( (A,1), (B,1) )</code> should be discarded.</p>
<p>Sample output:</p>
<p><code>[ ( (U,0) , (U,1) ), ( (U,0) , (U,2) ), ( (U,0) , (U,3) ) ...]</code></p>
<p>Should have a length of 448</p>
<hr/>
<p>Example:</p>
<p>For a string length 2:</p>
<pre><code>((U,0),(U,1))
((U,0),(C,1))
((U,0),(A,1))
((U,0),(G,1))

((C,0),(U,1))
((C,0),(C,1))
((C,0),(A,1))
((C,0),(G,1))

((A,0),(U,1))
((A,0),(C,1))
((A,0),(A,1))
((A,0),(G,1))

((G,0),(U,1))
((G,0),(C,1))
((G,0),(A,1))
((G,0),(G,1))
</code></pre>
<p>would be all the combinations... I think</p>
<hr/>
<p>I have this so far</p>
<pre><code>all_possible = []
nucleotides = ["U","C","A","G"]


for i in range(len(nucleotides)):
    for j in range(8):
        all_possible.append(((nucleotides[i],j),(nucleotides[i],j)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want the Cartesian product of (every possible 2-base word)  X (every 2-combination drawn from range(8)).</p>
<p>You can get this in general by</p>
<pre><code>from itertools import product, combinations

def build(num_chars, length):
    bases = ["U", "C", "A", "G"]
    for letters in product(bases, repeat=num_chars):
        for positions in combinations(range(length), num_chars):
            yield list(zip(letters, positions))
</code></pre>
<p>which gives us</p>
<pre><code>In [4]: output = list(build(2, 8))

In [5]: len(output)
Out[5]: 448

In [6]: output[:4]
Out[6]: 
[[('U', 0), ('U', 1)],
 [('U', 0), ('U', 2)],
 [('U', 0), ('U', 3)],
 [('U', 0), ('U', 4)]]

In [7]: output[-4:]
Out[7]: 
[[('G', 4), ('G', 7)],
 [('G', 5), ('G', 6)],
 [('G', 5), ('G', 7)],
 [('G', 6), ('G', 7)]]
</code></pre>
</div>
<span class="comment-copy">Can you clarify the problem? What does the output look like specifically? I'm not certain what your example is even supposed to illustrate.</span>
<span class="comment-copy">I am not sure what you're asking exactly ^ but <code>itertools</code> will almost certainly have something that will help you with this: <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html</a></span>
<span class="comment-copy">Using the <code>bases</code> and <code>positions</code> lists you give, <code>len([((b1, p1), (b2, p2)) for (b1, b2) in product(bases, bases) for (p1, p2) in combinations(positions, 2)])</code> results in 576, not 448. I think your <code>positions</code> list is too long.</span>
