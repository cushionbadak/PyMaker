<div class="post-text" itemprop="text">
<p>I have a small python script, which uses <code>argparse</code> to let the user define options. It uses two flags for different modes and an argument to let the user define a file. See the simplified example below:</p>
<pre><code>#!/usr/bin/python3

import argparse
from shutil import copyfile

def check_file(f):
    # Mock function: checks if file exists, else "argparse.ArgumentTypeError("file not found")"
    return f

def main():
    aFile = "/tmp/afile.txt"

    parser = argparse.ArgumentParser(description="An example",formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("-f", "--file", help="A file, used with method A.", default=aFile, type=check_file)
    parser.add_argument("-a", "--ay", help="Method A, requires file.", action='store_true')
    parser.add_argument("-b", "--be", help="Method B, no file required.", action='store_true')

    args = parser.parse_args()
    f = args.file
    a = args.ay
    b = args.be

    if a:
        copyfile(f, f+".a")
    elif b:
        print("Method B")

if __name__ == "__main__":
    main()
</code></pre>
<p>Method A requires the file.</p>
<p>Method B does not.</p>
<p>If I run the script with method A, I either use the default file or one that is defined with <code>-f</code>/<code>--file</code>. The script checks if the file exists and everything is fine.</p>
<p>Now, if I run the script with method B, it shouldn't require the file, but the default option is checked and if it doesn't exist the argparse function raises the exception and the script exits.</p>
<p>How can I configure argparse to make <code>-f</code> optional, if <code>-b</code> is defined and require it, if <code>-a</code> is defined? </p>
<p><strong>edit:</strong> I just realized that it would be enough for me to make <code>-f</code> and <code>-b</code> mutually exclusive. But then, if I run <code>-b</code> only, the <code>check_file</code> is executed anyways. Is there a way to prevent that?</p>
<pre><code>#!/usr/bin/python3

import argparse
from shutil import copyfile

def check_file(f):
    # Mock function: checks if file exists, else "argparse.ArgumentTypeError("file not found")"
    print("chk file")
    return f

def main():
    aFile = "/tmp/afile.txt"

    parser = argparse.ArgumentParser(description="An example",formatter_class=argparse.RawTextHelpFormatter)
    group = parser.add_mutually_exclusive_group(required=True)

    group.add_argument("-f", "--file", help="A file, used with method A.", default=aFile, type=check_file)
    parser.add_argument("-a", "--ay", help="Method A, requires file.", action='store_true')
    group.add_argument("-b", "--be", help="Method B, no file required.", action='store_true')

    args = parser.parse_args()
    f = args.file
    a = args.ay
    b = args.be

    if a:
        print("File: "+str(f))
    elif b:
        print("Method B")
        print("file: "+str(f))

if __name__ == "__main__":
    main()
</code></pre>
<p>Output:</p>
<pre><code>chk file
Method B
file: /tmp/afile.txt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can defined subparser with ay/be as subcommand or alternatively declare a second parser instance for a. Something like:</p>
<pre><code>parser = argparse.ArgumentParser(
    description="An example",
    formatter_class=argparse.RawTextHelpFormatter
)
# ensure either option -a or -b only
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument("-a", "--ay", help="Method A, requires file.",
                   action='store_true')
group.add_argument("-b", "--be", help="Method B, no file required.",
                   action='store_true')
# define a parser for option -a
parser_a = argparse.ArgumentParser()
parser_a.add_argument("-f", "--file", help="A file, used with method A.",
                      type=check_file, required=True)
parser_a.add_argument("-a", "--ay", help="Method A, requires file.",
                      action='store_true')

# first parse - get either -a/-b
args = parser.parse_known_args(sys.argv[1:])
# if -a, use the second parser to ensure -f is in argument
# note parse_known_args return tuple, the first one is the populated namespace
if args[0].ay:
    args = parser_a.parse_args(sys.argv[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem lies with how <code>argparse</code> handles defaults.  You'd get this behavior even if <code>-f</code> was the only argument.  If the default is a string value, it will be 'evaluated' if the Action isn't seen.</p>
<pre><code>parser.add_argument("-f", "--file", help="A file, used with method A.", default=aFile, type=check_file)
</code></pre>
<p>At the start of parsing defaults are put into the <code>args</code> namespace. During parsing it keeps track of whether Actions have been seen.  At the end of parsing it checks Namespace values for Actions which haven't been seen.  If they match the default (the usual case) and are strings, it passes the default through the <code>type</code> function.</p>
<p>In your <code>-f</code> case, the default is probably a file name, a string.  So it will be 'evaluated' if the user doesn't provide an alternative.  In earlier <code>argparse</code> versions defaults were evaluate regardless of whether they were used or not.  For something like a <code>int</code> or <code>float</code> type that wasn't a problem, but for <code>FileType</code> it could result in unneeded file opening/creation.</p>
<p>Ways around this?</p>
<ul>
<li>write <code>check_file</code> so it gracefully handles <code>aFile</code>.</li>
<li>make sure <code>aFile</code> is valid so <code>check_file</code> runs without error.  This the usual case.</li>
<li>use a non-string default, e.g. an already open file.</li>
<li><p>use the default default None, and add the default value after parsing.</p>
<p><code>if args.file is None:
     args.file = aFile</code></p></li>
</ul>
<p>Combining this with <code>-a</code> and <code>-b</code> actions you have to decide whether:</p>
<ul>
<li><p>if <code>-a</code>, is a <code>-f</code> value required?  If <code>-f</code> isn't provided, what's the right <code>default</code>.</p></li>
<li><p>if <code>-b</code>, does it matter whether <code>-f</code> has a default or whether the user provides this argument?  Could you just ignore it?</p></li>
</ul>
<p>If <code>-f</code> is useful only when <code>-a</code> is True, why not combine them?</p>
<pre><code>parser.add_argument('-a', nargs='?', default=None, const='valid_file', type=check_file)
</code></pre>
<p>With <code>?</code>, this works in 3 ways. <a href="https://docs.python.org/3/library/argparse.html#const" rel="nofollow noreferrer">(docs on <code>const</code>)</a></p>
<ul>
<li>no <code>-a</code>, <code>args.a = default</code></li>
<li>bare <code>-a</code>, <code>args.a = const</code></li>
<li>-a afile<code>,</code>args.a = <code>afile</code></li>
</ul>
<hr/>
<p>An even simpler example of this behavior </p>
<pre><code>In [956]: p = argparse.ArgumentParser()
In [957]: p.add_argument('-f',type=int, default='astring')
...
In [958]: p.parse_args('-f 1'.split())
Out[958]: Namespace(f=1)
In [959]: p.parse_args(''.split())
usage: ipython3 [-h] [-f F]
ipython3: error: argument -f: invalid int value: 'astring'
</code></pre>
<p>The string default is passed through <code>int</code> resulting in an error.  If I'd set default to something else like a list, <code>default=[1,2,3]</code>, it would have run even though <code>int</code> would have choked on the default.</p>
</div>
<span class="comment-copy">You might want to look at [<a href="http://stackoverflow.com/questions/4466197/python-argparse-with-dependencies](this)" title="python argparse with dependencies%5d(this)">stackoverflow.com/questions/4466197/â€¦</a> question.</span>
<span class="comment-copy"><code>4466197</code> is a poor answer for this case.  'groups' are not designed for nesting, and they don't solve the 'default' evaluation problem here.</span>
