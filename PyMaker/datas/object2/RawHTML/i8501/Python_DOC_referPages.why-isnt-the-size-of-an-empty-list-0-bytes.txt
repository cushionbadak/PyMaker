<div class="post-text" itemprop="text">
<p>Today itself I ran the code given below in <strong>Python 2.7.13</strong> and found that the list size isn't 0 when it is empty:</p>
<pre><code>import sys as s
data = []
for k in range(n):
    a = len(data)
    b = sys.getsizeof(data)
    print('Length:{0:3d};Size in bytes:{1:4d}'.format(a,b))
    data.append(None)
</code></pre>
<p><strong>Output on my Machine:</strong></p>
<pre><code>Length: 0; Size in bytes : 72
Length: 1; Size in bytes : 104
Length: 2; Size in bytes : 104
Length: 3; Size in bytes : 104
Length: 4; Size in bytes : 104
Length: 5; Size in bytes : 136
Length: 6; Size in bytes : 136
Length: 7; Size in bytes : 136
Length: 8; Size in bytes : 136
Length: 9; Size in bytes : 200
Length: 10; Size in bytes : 200
Length: 11; Size in bytes : 200
Length: 12; Size in bytes : 200
Length: 13; Size in bytes : 200
Length: 14; Size in bytes : 200
Length: 15; Size in bytes : 200
Length: 16; Size in bytes : 200
Length: 17; Size in bytes : 272
Length: 18; Size in bytes : 272
Length: 19; Size in bytes : 272
</code></pre>
<p>I want to know why is this happening?</p>
<blockquote>
<p>It seems that Python is reserving memory for something.
  What is that something??</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Because the size of the list, as returned from <code>sys.getsizeof</code>, doesn't include only the elements that list contains. </p>
<p>Every object in Python is represented by a <code>C</code>-struct; this struct contains pointers to all the things that make the list a list (its methods, mainly). It's also taken into consideration when <code>sys.getsizeof</code> is invoked. </p>
<p>You can always take a look at the <a href="https://github.com/python/cpython/blob/16f852345bcdec1bbb15e5363fad6b33bf960912/Objects/listobject.c#L2428" rel="nofollow noreferrer">implementation of <code>list.__sizeof__</code></a> in the master branch of the CPython repository on GitHub:</p>
<pre><code>static PyObject *
list___sizeof___impl(PyListObject *self)
{
    Py_ssize_t res;

    res = _PyObject_SIZE(Py_TYPE(self)) + self-&gt;allocated * sizeof(void*);
    return PyLong_FromSsize_t(res);
}
</code></pre>
<p><sup>(Trimmed off unrelated arg clinic output.)</sup></p>
<p>The <code>sizeof</code> <a href="https://github.com/python/cpython/blob/3ceca68741f8a2d3a4436b6d54eae76aa5bcc4c5/Objects/listobject.c#L2471" rel="nofollow noreferrer">function for <code>2.x</code></a> does the same thing.</p>
<p>The return value <code>res</code> also includes the size of the list object type <code>_PyObject_SIZE(Py_Type(self))</code>.</p>
<p>Since everything in Python is an object, this behavior can be observed everywhere, e.x, integer <code>0</code>:</p>
<pre><code>&gt;&gt;&gt; getsizeof(0)
24
</code></pre>
<p>while you wouldn't normally expect this, it makes perfect sense when you realize everything in Python has "additional baggage" which allows behavior we take for granted.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is implemented in C, and as such will be storing data in a C struct.</p>
<p>Remember that all things are 'objects' - objects <em>must</em> have a type and an object size, even if they don't store <em>anything</em>.</p>
<p>Below are the <a href="https://svn.python.org/projects/python/trunk/Include/object.h" rel="nofollow noreferrer"><code>PyObject_VAR_HEAD</code></a> and <a href="https://svn.python.org/projects/python/trunk/Include/listobject.h" rel="nofollow noreferrer"><code>PyListObject</code></a> C datatypes.</p>
<pre class="lang-c prettyprint-override"><code>#define PyObject_VAR_HEAD               \
    PyObject_HEAD                       \
    Py_ssize_t ob_size; /* Number of items in variable part */

typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 &lt;= ob_size &lt;= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;
</code></pre>
<p>Remember that <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer"><code>sys.getsizeof()</code></a> will return the underlying memory usage, not something that you really need to consider or worry about from Python:</p>
<blockquote>
<p>Return the size of an object in bytes.</p>
<p>Only the memory consumption directly attributed to the object is accounted for, not the memory consumption of objects it refers to.</p>
</blockquote>
<p>Additionally, as your test shows, there is an amount of pre-allocation going on. New memory is not associated with the <code>list</code> on <em>every</em> call to <code>append()</code>.</p>
</div>
<span class="comment-copy">Another reason is for efficiency reasons (read about dynamic arrays and amortized analysis <a href="https://en.wikipedia.org/wiki/Amortized_analysis" rel="nofollow noreferrer">en.wikipedia.org/wiki/Amortized_analysis</a>)</span>
<span class="comment-copy">thanks for the reference..</span>
