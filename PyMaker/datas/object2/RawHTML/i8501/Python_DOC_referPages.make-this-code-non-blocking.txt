<div class="post-text" itemprop="text">
<p>I'm using the VSphere API, here are the lines that I'm dealing with:</p>
<pre><code>    task = vm.PowerOff()
    while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
        time.sleep(1)
        log.info("task {} is running".format(task))
    log.ingo("task {} is done".format(task))
</code></pre>
<p>The problem here is that this blocks the execution completely whilst the task is not finished. I would like the logging part to be ran "in parallel", so I can start other tasks.</p>
<p>I thought about creating a function that would accept a task as parameter, and poll the <code>info.state</code> attribute just like now, but how do I make this non blocking ? </p>
<p>EDIT: I'm using Python 2.7</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> and create an event loop. You can use <code>asyncio.async()</code> to create an asynchronous task that won't block the event loop execution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example of using the threading module: </p>
<pre><code>import threading

class VMShutdownThread(threading.Thread):
    def __init__(self, vm):
        self.vm = vm
    def run(self):
        task = vm.PowerOff()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            time.sleep(1)
            log.info("task {} is running".format(task))
        log.info("task {} is done".format(task))

vm_shutdown_thread = VMShutdownThread(vm)

vm_shutdown_thread.start() 
</code></pre>
<p>If you create a <a href="https://docs.python.org/2/library/logging.html" rel="nofollow noreferrer">logger</a>, you can configure it to print the thread name.</p>
</div>
<span class="comment-copy">Hello, thanks for your answer. I ommited to say I'm in Python 2.7, I'm editing my post :)</span>
<span class="comment-copy">Ok, in that case, you can use python's threading module. Create a worker to do this task and then join() the worker when it's done.</span>
<span class="comment-copy">I will try it, thanks</span>
<span class="comment-copy">I can't accept your answer since it's for Python 3, yet if you happened to feel like putting a little example of what you said for Python 2, I'd gladly accept your answer so you can earn reputation :)</span>
<span class="comment-copy">Also, make sure you look into thread safety if you plan on using a lot of threads. For example, consider the scenario when two threads are trying to do stuff to the same object.</span>
