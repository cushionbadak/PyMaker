<div class="post-text" itemprop="text">
<p>In Python, I can do string replacements of slashes as such:</p>
<pre><code>&gt;&gt;&gt; s = 'ab\c'
&gt;&gt;&gt; s.replace('\\', '\\\\')
'ab\\\\c'
&gt;&gt;&gt; print s.replace('\\', '\\\\')
ab\\c
</code></pre>
<p>In Julia, when I could do this:</p>
<pre><code>julia&gt; s = "ab\\c"
"ab\\c"

julia&gt; replace(s, "\\\\", "\\\\\\\\")
"ab\\c"
</code></pre>
<p>I've tried this but it throws some syntax error:</p>
<pre><code>julia&gt; replace(s, r"\", r"\\")
ERROR: syntax: "\" is not a unary operator
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Julia REPL outputs strings in <strong>escaped</strong> form. It might be best to wrap things with a <code>println</code> as in <code>println(replace(s, "\\", "\\\\"))</code>. In this case you get:</p>
<pre><code>julia&gt; s = "ab\\c"
"ab\\c"

julia&gt; println(s)
ab\c

julia&gt; println(replace(s, "\\", "\\\\"))
ab\\c
</code></pre>
<p>Regarding the use of regular expressions, the first <code>r"\"</code> is a partial regular expression and the parser continue and generates an error on the following <code>\</code> after a closing <code>"</code>, and the second regexp is unnecessary as it is the string to be inserted.</p>
<p>UPDATE: More details about Julia vs. Python escaping in the other answer.</p>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two sources of confusion here, one of which is the printing vs. REPL output issue that Dan mentions. The root cause of confusion, however, seems to be that string literals have different escaping behavior in Julia and Python:</p>
<ul>
<li><p>In Julia, a <code>\</code> inside of a string literal <em>always</em> escapes the next character – a single backslash never produces a literal backslash, it always combines with the following characters. If the following character has no special meaning as an escape, then the following character is produced by itself and no backslash is in the resulting string. This is the case here: there is no special meaning to escapes beginning with <code>c</code> so <code>"ab\c"</code> is the same as just <code>"abc"</code>.</p></li>
<li><p>In Python, a <code>\</code> inside of a string literal <em>sometimes</em> escapes the next character, but if the following character has no special meaning, then it does not introduce an escape so the sequence produces a literal backslash as well as whatever follows. In this case, <code>'ab\c'</code> or <code>"ab\c"</code> are both equal to <code>"ab\\c"</code> (the second backslash is escaped by the first backslash, producing a single literal backslash).</p></li>
</ul>
<p>Note that the two backslash form is how the Python prompt prints the string back to you – this is the standard way to write this string, properly escaped, instead of relying on the fact that <code>c</code> has no special meaning as an escape character. If the backslash were instead followed by some other character with special meaning as an escape (see examples below), then the input string would mean something else entirely.</p>
<p>Here some examples in Python:</p>
<pre><code>&gt;&gt;&gt; [c for c in "ab\c"]
['a', 'b', '\\', 'c']

&gt;&gt;&gt; [c for c in "ab\\c"]
['a', 'b', '\\', 'c']

&gt;&gt;&gt; [c for c in "a\bc"]
['a', '\x08', 'c']

&gt;&gt;&gt; [c for c in "a\\bc"]
['a', '\\', 'b', 'c']

&gt;&gt;&gt; [c for c in "\abc"]
['\x07', 'b', 'c']

&gt;&gt;&gt; [c for c in "\\abc"]
['\\', 'a', 'b', 'c']
</code></pre>
<p>Here are the analogous examples in Julia:</p>
<pre><code>julia&gt; [c for c in "ab\c"]
3-element Array{Char,1}:
 'a'
 'b'
 'c'

julia&gt; [c for c in "ab\\c"]
4-element Array{Char,1}:
 'a'
 'b'
 '\\'
 'c'

julia&gt; [c for c in "a\bc"]
3-element Array{Char,1}:
 'a'
 '\b'
 'c'

julia&gt; [c for c in "a\\bc"]
4-element Array{Char,1}:
 'a'
 '\\'
 'b'
 'c'

julia&gt; [c for c in "\abc"]
3-element Array{Char,1}:
 '\a'
 'b'
 'c'

julia&gt; [c for c in "\\abc"]
4-element Array{Char,1}:
 '\\'
 'a'
 'b'
 'c'
</code></pre>
<p>The escapes <code>\a</code> and <code>\b</code> have special meaning in both languages – they encode the ASCII "bell" and "backspace" characters in each language. The difference lies in the sequence <code>\c</code>: in Julia this encodes just the character <code>c</code> whereas in Python it encodes two characters – backslash and <code>c</code> – because <code>c</code> happens not to have a special meaning as an escape. Julia's string escaping rules closely resemble C, C++, Java, Perl and Ruby and were derived from them. I'm not sure what the provenance of Python's string escaping behavior is.</p>
<p><strong>Update:</strong> Invalid escapes in string literals will be syntax errors in future versions of both Julia (<a href="https://github.com/JuliaLang/julia/issues/21284" rel="nofollow noreferrer">issue #21284</a>) and Python (<a href="https://docs.python.org/3/whatsnew/3.6.html#deprecated-python-behavior" rel="nofollow noreferrer">3.6 release notes</a>). This brings Julia and Python's behaviors for escaping of string literals into agreement.</p>
</div>
<span class="comment-copy">How about <code>replace(s, "\\", "\\\\")</code>? (in Julia, of course)</span>
<span class="comment-copy">I may have misunderstood but what's wrong with <code>replace(s, "\\", "\\\\")</code>. you don't need to escape the backslashes.</span>
<span class="comment-copy">Julia REPL outputs strings in <b>escaped</b> form. It might be best to wrap things with a <code>println</code> as in <code>println(replace(s, "\\", "\\\\"))</code></span>
<span class="comment-copy">In this case though <code>replace(s, "\\", "\\\\")</code> will still output <code>"ab\\\\c"</code> on the REPL?</span>
<span class="comment-copy">As for the second <code>replace</code>, the error comes from the first regular-expression (which needs another backslash), and the second parameter should just be a string in any case: `replace(s, r"\\", "\\\\")</span>
<span class="comment-copy">I started editing your answer to add some info about differences in escaping  behavior, but it ended up being a pretty complete rewrite of the answer, so I just wrote a different answer.</span>
<span class="comment-copy">Just FYI:  A backslash-character pair that is not a valid escape sequence now generates a DeprecationWarning. Although this will eventually become a SyntaxError, that will not be for several Python releases. ( <a href="https://docs.python.org/3/whatsnew/3.6.html" rel="nofollow noreferrer">docs.python.org/3/whatsnew/3.6.html</a> )</span>
<span class="comment-copy">Thanks, @Liso. Similarly, on Julia master, invalid escape sequences are now a syntax error: <a href="https://github.com/JuliaLang/julia/issues/21284" rel="nofollow noreferrer">github.com/JuliaLang/julia/issues/21284</a>. We decided to go straight to error instead of going through a deprecation period. Python and Julia now have nearly identical behavior wrt string escapes.</span>
