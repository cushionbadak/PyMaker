<div class="post-text" itemprop="text">
<p>So when ever I run my program and connect to it with the echo client it gives me this error. </p>
<pre><code>Starting server
Serving on ('127.0.0.1', 8881)
Exception in callback UVTransport._call_connection_made
handle: &lt;Handle UVTransport._call_connection_made&gt;
Traceback (most recent call last):
File "uvloop/cbhandles.pyx", line 52, in uvloop.loop.Handle._run (uvloop/loop.c:48414)
File "uvloop/handles/tcp.pyx", line 141, in uvloop.loop.TCPTransport._call_connection_made (uvloop/loop.c:80488)
File "uvloop/handles/basetransport.pyx", line 140, in uvloop.loop.UVBaseTransport._call_connection_made (uvloop/loop.c:65774)
File "uvloop/handles/basetransport.pyx", line 137, in uvloop.loop.UVBaseTransport._call_connection_made (uvloop/loop.c:65671)
AttributeError: 'coroutine' object has no attribute 'connection_made'
/home/kenton/Programming/bridal/bridal-middle/middle/lib/server.py:16:RuntimeWarning: coroutine 'handle_request' was never awaited
loop.run_forever()
</code></pre>
<p>As far as I know I have everything that should be awaited awaited. 
Here is the code:</p>
<pre><code>class Server:

    def __init__(self, port):
        asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    loop = asyncio.get_event_loop()
    server = loop.run_until_complete(self.init(loop))

    print("Serving on {}".format(server.sockets[0].getsockname()))
    try:
        loop.run_forever()
    except KeyboardInterrupt:
        print("\rclosing the server")
        pass

    server.close()
    loop.run_until_complete(server.wait_closed())
    loop.close()

    async def init(self, loop):
        server = await loop.create_server(self.handle_request, '127.0.0.1', 8881)
        return server

    async def handle_request(self):
        print(datetime.datetime.now())
        reader = asyncio.StreamReader()
        writer = asyncio.StreamWriter()
        data = await reader.read(100)
        message = data.decode()
        addr = writer.get_extra_info('peername')
        code = message.partition('-')
        if code[0].startswith("1") or code[0].startswith("5"):
            accounts = lib.settings.database.accounts
            if code[0] == "101":
                result = await self.login_101(code, accounts, writer)
            if code[0] == "501":
                result = await accounts.find_one({"username":code[2]})
                print("looking up", code[0])
            #code logic to keep asking for a valid username if one exists
                if result is None:
                    username = code[2]
                    print(username, " does not exist. Creating")
                    writer.write(b"0")
                    await writer.drain()
                    data = await reader.read(100)
                    message = data.decode()
                    code = message.partition('-')
                    post = {"username":username,"password":code[0],"email":code[2]}
                    post_id = await accounts.insert_one(post).inserted_id
                    writer.write(b(post_id))
                    await writer.drain()
        print("Closed the client socket")
        writer.close()
        print(datetime.datetime.now())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Regarding your error message, the actual error is:</p>
<pre><code>AttributeError: 'coroutine' object has no attribute 'connection_made'
</code></pre>
<p>And the line below is just a warning (<code>RuntimeWarning: coroutine 'handle_request' was never awaited</code>).</p>
<p>You might be mixing <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.start_server" rel="nofollow noreferrer"><code>asyncio.start_server</code></a> with <code>loop.create_server()</code>.</p>
<p><a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_server" rel="nofollow noreferrer"><code>loop.create_server()</code></a>'s first parameter is <code>protocol_factory</code> which is a callable that returns an instance of a <code>Protocol</code> (and not a coroutine as in your code above):</p>
<pre><code>import asyncio

class MyProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        print("Connection made", transport)

    def data_received(self, data):
        print("Data received", data)

loop = asyncio.get_event_loop()
# Each client connection will create a new protocol instance
coro = loop.create_server(MyProtocol, '127.0.0.1', 8888)
server = loop.run_until_complete(coro)
loop.run_forever()
</code></pre>
<p>See full echo server example <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_server" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">Your indentation looks messed up. Fix that first.</span>
<span class="comment-copy">It runs until you have it calls the method handle_request. If the indentation is messed up can you point it out?</span>
<span class="comment-copy">Most of the body of <code>__init__</code> is indented wrong, for example.</span>
<span class="comment-copy">Thank you this got me all set. I was just wondering if these functions (data_received and connection_made) run asynchronous. I know that you normally have to add async before the function delaration to make it asynchronous so I was wondering if these are?</span>
