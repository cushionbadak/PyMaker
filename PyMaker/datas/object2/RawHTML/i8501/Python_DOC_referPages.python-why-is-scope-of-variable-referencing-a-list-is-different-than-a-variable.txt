<div class="post-text" itemprop="text">
<p>I have found that the scope of a variable referencing a List is different than the variable referencing a Tuple or Integer or String. Why does it happen ?</p>
<p>1) When I am using an Integer, String or Tuple:- </p>
<pre><code>&gt;&gt;&gt; def foo(anInt, aStr, aTup):
         anInt += 5
         aStr  += ' hi'
         aTup  += (12,)
         print (anInt,aStr,aTup)
&gt;&gt;&gt; anInt, aStr, aTup = 5, 'Fox', (11,)
&gt;&gt;&gt; foo(anInt, aStr, aTup)
10 Fox hi (11, 12)
&gt;&gt;&gt; print (anInt, aStr, aTup)
5 Fox (11,)
</code></pre>
<p>2) When i am using an List:- </p>
<pre><code>&gt;&gt;&gt; def foo(aList):
        aList.append(2)
        print (aList)
&gt;&gt;&gt; aList = [1]
&gt;&gt;&gt; foo(aList)
[1, 2]
&gt;&gt;&gt; print (aList)
[1, 2]
</code></pre>
<p>In the first case changes in the values of anInt, aStr, aTup is limited to the scope of function while in case of a List scope changes.</p>
<p>'</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not a question of scope. The scope does not differ between types. It can not differ, in fact: a variable is just a named reference to a value, completely type-agnostic.</p>
<p>But some types in Python are mutable (once created, a value can be changed), and <code>list</code> is one of them. Some are immutable, and changing a value of these types requires creating a new object. <code>+=</code> works in two different ways for mutable and immutable types. For immutable types <code>a += b</code> is equivalent to <code>a = a + b</code>. A new object is created and the <code>a</code> variable now refers to it. But the objects of mutable types are modified "in place", quite as your list. You may want to read <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">this</a>.</p>
<p>Now let's have a look at scopes. Here you have global objects that are passed to a function. The function uses them as its parameters, not as global objects (yes, <code>aList</code> inside the function is not the same variable as <code>aList</code> outside it, <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">here</a> is more information on scopes). It uses other references to the same objects, and it can not modify the variables, it can just modify objects the variables refer to. But only the mutable objects.</p>
<p>You may be surprised if you compare the results of two following code samples.</p>
<pre><code>&gt;&gt;&gt; a = 1; a1 = a; a1 += 1; a
1

&gt;&gt;&gt; a = [1]; a1 = a; a1 += [1]; a
[1, 1]
</code></pre>
<p>What is the difference? The only difference is that <code>int</code> is an immutable type, and the <code>list</code> is a mutable one. After assigning <code>a</code> to <code>a1</code> they always refer a single object. But the <code>+=</code> operator creates a new object in case of <code>int</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference is that the immutable types int, string and tuple are passed by value. When the function updates the value, it is updating a local copy. </p>
<p>The list is passed by reference. When you use append, it is updating the original list.</p>
</div>
<span class="comment-copy">List is a mutable datatype in python. String,integer tuple etc are not.</span>
<span class="comment-copy">So how does mutability affect the scope?</span>
<span class="comment-copy">The scope is working <i>exactly the same</i> in both examples. In the first example, you use the augmented assignment operator <code>+=</code> which for immutable data-structures returns and reassigns a <i>new object</i> to the local variable. Outside this local scope, these effects are no longer visible. In the second example, you use <code>.append</code>, which <i>mutates the list in place</i>, and the effect will be visible in any scope where the list is accessible (i.e. your global scope).</span>
<span class="comment-copy">Furthermore, because it bears repeating: Python's evaluation strategy is not different for mutable or immutable types either. It works <i>exactly the same</i>. The technical name for Python's evaluation strategy is <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="nofollow noreferrer">call by sharing</a>. This is sometimes called "call by object value" or even just "call by value", but it is certainly not like call-by-reference, or else you would be able to write a true swap function in Python.</span>
<span class="comment-copy">This is false. Python's evaluation strategy is not different for mutable or immutable types. It works <i>exactly the same</i>. The technical name for Python's evaluation strategy is <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="nofollow noreferrer">call by sharing</a>. This is sometimes called "call by object value" or even just "call by value", but it is certainly not like call-by-reference, or else you would be able to write a true swap function in Python.</span>
<span class="comment-copy">I just wanted to identify that it's not a question of scope but how the values are updated.</span>
<span class="comment-copy">I'm sorry, but it's still incorrect. First, your claim about the difference in evaluation strategy for mutable and immutable types is simply wrong. Second, you aren't updating a "local copy", the variables still hold references to the <i>same immutable object</i>. Objects are <i>never copied</i> with assignment in Python. The difference is that in one case you are mutating an object, in another, you are reassigning a local variable to reference a new object when you use the augmented assignment operator (<code>+=</code>).</span>
