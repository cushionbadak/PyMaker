<div class="post-text" itemprop="text">
<p>A <a href="https://en.wikipedia.org/wiki/Turing_machine" rel="nofollow noreferrer">Turing machine</a> manipulates symbols on an <strong>infinite strip of tape</strong> according to a table of rules. </p>
<p>In my case entries on the tape can be either 0's and 1's (binary).  </p>
<p>The tape starts off 'empty' with an infinity of 0's in both positive and negative directions. This tape gets written on based on the rules that the machine follows, potentially adding 0's or 1's to the unwritten edges.</p>
<p>Since the tape values are binary is there a most efficient way to represent them in memory as the machine writes to the tape, adding new values to the left or right?  Obviously I don't need to represent the infinite zeros (unwritten tape), but I do need to expand the data structure as new values are added to the ends of the tape.</p>
<p>A python list could do the trick, shown here inserting a 1 on the left:</p>
<pre><code>start_time = time.time()
tape = [0]*10000000
print tape[:10]
insertion_time = time.time()
tape = [1] + tape 
print tape[:10]
print "total execution time: ", time.time() - start_time
print "time to add entry: ", time.time() - insertion_time
</code></pre>
<p>this outputs:</p>
<pre><code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
total execution time:  0.257364034653
time to add entry:  0.109524011612
</code></pre>
<p>Using list.insert does make it 23x faster:</p>
<pre><code>start_time = time.time()
tape = [0]*100000
print tape[:10]
insertion_time = time.time()
tape.insert(0, [1])
print tape[:10]
print "execution time: ", time.time() - start_time
print "time to add entry: ", time.time() - insertion_time
</code></pre>
<p>giving:</p>
<pre><code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]
execution time:  0.0270080566406
time to add entry:  0.00468802452087
</code></pre>
<p>Is there a more efficient way to represent the binary tape than using a <code>list</code> object?</p>
</div>
<div class="post-text" itemprop="text">
<p>Given that the tape is infinite at both ends, you will have to consider the <code>(-inf, -1]</code> range of indices too. The best representation, IMO, would be a pair of lists - one for the non-negative range and the other for the negative range (with indexing reversed). As you move beyond the allocated range of the tape, you will simply have to append to the respective list (which, unlike prepending to a list, is a fast operation).</p>
<p>A draft implementation (using an enhanced version of <code>GrowingList</code> from <a href="https://stackoverflow.com/a/4544699/6394138">this answer</a>):</p>
<pre><code>class GrowingList(list):
    def __init__(self, default_value):
        self.default_value=default_value

    def __getitem__(self, i):
        return list.__getitem__(i) if i &lt; len(self) else self.default_value

    def __setitem__(self, i, v):
        if i &gt;= len(self):
            self.extend([self.default_value]*(i + 1 - len(self)))
        list.__setitem__(self, i, v)

class Tape:
    def __init__(self):
        self.pos_range=GrowingList(0)
        self.neg_range=GrowingList(0)

    def __getitem__(self, i):
        if i &gt;= 0:
            return self.pos_range[i]
        else:
            return self.neg_range[-i-1]

    def __setitem__(self, i, v):
        if i &gt;= 0:
            self.pos_range[i]=v
        else:
            self.neg_range[-i-1]=v

    def __repr__(self):
        start = -len(self.neg_range)
        end = len(self.pos_range)
        data = list(reversed(self.neg_range)) + self.pos_range
        return "Tape(range=[{}, {}), data={})".format(start, end, data)


t = Tape()
print(t)
t[4]=1
print(t)
t[-2]=1
print(t)
</code></pre>
<p>Output:</p>
<pre><code>Tape(range=[0, 0), data=[])
Tape(range=[0, 5), data=[0, 0, 0, 0, 1])
Tape(range=[-2, 5), data=[1, 0, 0, 0, 0, 0, 1])
</code></pre>
</div>
<span class="comment-copy">Have you considered a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque</code></a>? Note that <code>list.insert</code> is an in-place update, you don't need to assign the result.</span>
<span class="comment-copy">instead of <code>tape = tape.insert(0,[1])</code> use <code>tape.insert(0,1)</code></span>
<span class="comment-copy">interesting I will try deque, had not heard of that before!  Thanks for the heads-up about list.insert - I was able to execute the code now and will update.</span>
<span class="comment-copy">Although a deque is faster than a list for appending data at both ends, it is slower for accessing data in the middle, see the warning in the manual. Maybe more problematic in your case is thatâ€‹ prepending data will shift the indices of existing items.</span>
<span class="comment-copy">Shifting the indices doesn't matter at least for my purpose.  I like Leon's suggestion of <i>appending</i> to two lists (one index-reversed).</span>
<span class="comment-copy">I like the idea of appending to two index lists, one with indexing reversed - I will try this.</span>
<span class="comment-copy">@user391339 I added to the answer some quick and dirty draft code</span>
