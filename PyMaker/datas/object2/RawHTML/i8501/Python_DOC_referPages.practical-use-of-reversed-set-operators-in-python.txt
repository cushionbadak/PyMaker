<div class="post-text" itemprop="text">
<p>Is there any difference between using the reversed union or intersection operators on sets in Python?</p>
<p>for instance, </p>
<p><code>s &amp; z</code> corresponds to <code>s.__and__(z)</code></p>
<p><code>z &amp; s</code> corresponds to <code>s.__rand__(z)</code></p>
<p>If these are supposed to return the same thing, why have the reversed operator in the first place? Am I missing something?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>set</code> and <code>frozenset</code> follow the number protocol and they <a href="https://github.com/python/cpython/blob/master/Objects/setobject.c#L2035" rel="nofollow noreferrer">don't define the reversed operations explicitly</a> but they get these "for free" because they <a href="https://github.com/python/cpython/blob/master/Objects/setobject.c#L2083" rel="nofollow noreferrer">implement the normal methods (like <code>__and__</code>)</a>.</p>
<p>However reversed operations are particularly useful when dealing with subclasses because if the <a href="https://docs.python.org/reference/datamodel.html#object.__rand__" rel="nofollow noreferrer">right operand is a subclass of the left operand the reversed operation is <strong>attempted</strong> first</a>. But in case of plain <code>set</code>s and <code>frozenset</code>s this doesn't make any difference because they don't inherit from each other. </p>
<p>These reversed operations are also used if the first operand returns <code>NotImplemented</code> in it's <code>__add__</code>. But again this isn't really useful for <code>set</code> and <code>frozenset</code> because they only allow operations with other <code>set</code>-alikes and at least <code>set</code> and <code>frozenset</code> don't return <code>NotImplemented</code> when the other operand is another <code>set</code>. </p>
<p>Also <code>z &amp; s</code> doesn't correspond to <code>s.__rand__(z)</code>, except when <code>s</code> is a subclass of <code>z</code>. Otherwise <code>z.__and__(s)</code> will be attempted before <code>s.__rand__(z)</code>.</p>
<p>So I doubt there are use-cases for the reversed union and intersection but it should explain "why these methods exist".</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__rand__" rel="nofollow noreferrer"><code>__rand__</code></a> is only called if if the left operand does not support the corresponding operation and the operands are of different types.</p>
<p>I would imagine that <code>s.__rand__(z)</code> would just call <code>z.__and__(s)</code> under the covers.</p>
</div>
<span class="comment-copy">It's for when the left-side object doesn't implement the <code>__and__</code> method.</span>
<span class="comment-copy">Are you saying that if I make custom classes that inherit from <code>set</code> or <code>frozenset</code>, and these classes have different <code>__and__</code> methods, then one needs to watch for the order and what the <code>__rand__</code> methods contain as well?</span>
<span class="comment-copy">Indeed with <code>set</code> and <code>frozenset</code> you need to be careful about the order when you subclass one and try to operate with the other. If you subclass <code>set</code> and implement <code>__and__</code> and <code>__rand__</code> your subclasses methods will be called first when you try to do <code>set() &amp; subclass()</code> (=&gt; <code>subclass.__rand__</code> is called first) or <code>subclass() &amp; set()</code> (=&gt; <code>subclass.__and__</code> is called first). But if you try to use this subclass with <code>frozenset</code> you need to watch out for the order: <code>frozenset() &amp; subclass()</code> will call <code>frozenset.__and__</code> first!</span>
<span class="comment-copy">Since the operation is invalid except between two sets, the other argument is guaranteed to have the correct method or else there's an error and the rand method doesn't need to be the one that produces it.</span>
