<div class="post-text" itemprop="text">
<p>If I create a list in python, and assign a different list to it, changes of the first list are reflected in the second list:</p>
<pre><code>a = [1, 2, 3]
b = a
a[0] = 0
print(b)
&gt;&gt;&gt; [0, 2, 3]
</code></pre>
<p>Is it possible to achieve this behavior when creating a numpy array from a list?
What I want:</p>
<pre><code>import numpy as np
a = [1, 2, 3]
b = np.array(a)
a[0] = 0
print(b)
&gt;&gt;&gt; [ 0 2 3 ]
</code></pre>
<p>But what actually happens is that b is <code>[ 1 2 3 ]</code>. I realize that this is difficult due to dynamic resizing of the list. But if I could tell numpy that this list is never resized, it should work somehow.
Is this behavior achievable? Or am I missing some really bad drawbacks?</p>
</div>
<div class="post-text" itemprop="text">
<p>Fundamentally the issue is that Python lists <em>are not really arrays</em>. OK, CPython lists are ArrayLists, but they are arrays of Py_Object pointers, so they can hold heterogenous data. See <a href="http://www.laurentluce.com/posts/python-list-implementation/" rel="nofollow noreferrer">here</a> for an excellent exposition on the implementation details of CPython lists. Also, they are resizable, and all the <code>malloc</code> and <code>realloc</code> gets taken care of under the hood. However, you <em>can</em> achieve something like what you want if you use vanilla Python arrays available in the <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer"><code>array</code></a> module.</p>
<pre><code>&gt;&gt;&gt; import numpy as np # third party
&gt;&gt;&gt; import array # standard library module
</code></pre>
<p>Let's make a <em>real</em> array:</p>
<pre><code>&gt;&gt;&gt; a = array.array('i', [1,2,3])
&gt;&gt;&gt; a
array('i', [1, 2, 3])
</code></pre>
<p>We can use <code>numpy.frombuffer</code> if we want our <code>np.array</code> to share the underyling memory of the buffer:</p>
<pre><code>&gt;&gt;&gt; arr = np.frombuffer(a, dtype='int32')
&gt;&gt;&gt; arr
array([1, 2, 3], dtype=int32)
</code></pre>
<h2>EDIT: WARNING</h2>
<p>As stated by @user2357112 in the comments:</p>
<blockquote>
<p>Watch out - <code>numpy.frombuffer</code> is still using the old buffer protocol
  (or on Python 3, the compatibility functions that wrap the new buffer
  protocol in an old-style interface), so it's not very memory-safe. If
  you create a NumPy array from an <code>array.array</code> or <code>bytearray</code> with
  <code>frombuffer</code>, you must not change the size of the underlying array.
  Doing so risks arbitrary memory corruption and segfaults when you
  access the NumPy array</p>
</blockquote>
<p>Note, I had to explicitly pass <code>dtype='int32'</code> because I initialized my <code>array.array</code> with the <code>i</code> signed int typecode, which on my system corresponds to a 32 bit int. Now, presto:</p>
<pre><code>&gt;&gt;&gt; a
array('i', [1, 2, 3])
&gt;&gt;&gt; a[0] = 88
&gt;&gt;&gt; a
array('i', [88, 2, 3])
&gt;&gt;&gt; arr
array([88,  2,  3], dtype=int32)
&gt;&gt;&gt;
</code></pre>
<p>Now, if we use <code>dtype=object</code>, we actually can share the underlying objects. However, with numerical types, we <em>can't mutate</em>, only replace. However, we can wrap a Python <code>int</code> in a class to make a mutable object:</p>
<pre><code>&gt;&gt;&gt; class MutableInt:
...     def __init__(self, val):
...         self.val = val
...     def __repr__(self):
...         return repr(self.val)
...
&gt;&gt;&gt; obj_list = [MutableInt(i) for i in range(1, 8)]
&gt;&gt;&gt; obj_list
[1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>Now, we create an array that consists of the same <em>objects</em>:</p>
<pre><code>&gt;&gt;&gt; obj_array = np.array(obj_list, dtype=object)
&gt;&gt;&gt; obj_array
array([1, 2, 3, 4, 5, 6, 7], dtype=object)
</code></pre>
<p>Now, we can mutate the int wrapper in the list:</p>
<pre><code>&gt;&gt;&gt; obj_list[0].val = 88
&gt;&gt;&gt; obj_list
[88, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>And the effects are visible in the <code>numpy</code> array!:</p>
<pre><code>&gt;&gt;&gt; obj_array
array([88, 2, 3, 4, 5, 6, 7], dtype=object)
</code></pre>
<p>Note, though, you've now essentially created a less useful version of a Python <code>list</code>, one that isn't resizable, and doesn't have the nice O(1) amortized <code>append</code> behavior. We also lose any memory efficiency gains that a <code>numpy</code> array might give you!</p>
<p>Also, note that in the above the <code>obj_list</code> and <code>obj_array</code> are not sharing the same underlying buffer, they are making *two different arrays of holding the same Py_Obj pointer values:</p>
<pre><code>&gt;&gt;&gt; obj_list[1] = {}
&gt;&gt;&gt; obj_array
array([88, 2, 3, 4, 5, 6, 7], dtype=object)
&gt;&gt;&gt; obj_list
[88, {}, 3, 4, 5, 6, 7]
&gt;&gt;&gt;
</code></pre>
<p>We cannot access the underlying buffer to a python <code>list</code> because this is not exposed. Theoretically, they <em>could</em> if they exposed the buffer protocol: <a href="https://docs.python.org/3/c-api/buffer.html#bufferobjects" rel="nofollow noreferrer">https://docs.python.org/3/c-api/buffer.html#bufferobjects</a></p>
<p>But they don't. <code>bytes</code> and <code>bytearray</code> objects <em>do</em> expose the buffer protocol. <code>bytes</code> are essentially Python 2 <code>str</code>, and <code>bytearray</code> is a mutable version of <code>bytes</code>, so they are essentially mutable <code>char</code> arrays like in C:</p>
<pre><code>&gt;&gt;&gt; barr = bytearray([65, 66, 67, 68])
&gt;&gt;&gt; barr
bytearray(b'ABCD')
</code></pre>
<p>Now, let's make a <code>numpy</code> array that shares the underlying buffer:</p>
<pre><code>&gt;&gt;&gt; byte_array = np.frombuffer(barr, dtype='int8')
&gt;&gt;&gt; byte_array
array([65, 66, 67, 68], dtype=int8)
</code></pre>
<p>Now, we will see changes reflected across both objects:</p>
<pre><code>&gt;&gt;&gt; byte_array[1] = 98
&gt;&gt;&gt; byte_array
array([65, 98, 67, 68], dtype=int8)
&gt;&gt;&gt; barr
bytearray(b'AbCD')
</code></pre>
<p>Now, before you think you can use this to subvert the immutability of Python <code>bytes</code> objects, think again:</p>
<pre><code>&gt;&gt;&gt; bs = bytes([65, 66, 67, 68])
&gt;&gt;&gt; bs
b'ABCD'
&gt;&gt;&gt; byte_array = np.frombuffer(bs, dtype='int8')
&gt;&gt;&gt; byte_array
array([65, 66, 67, 68], dtype=int8)
&gt;&gt;&gt; bs
b'ABCD'
&gt;&gt;&gt; byte_array[1] = 98
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: assignment destination is read-only
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [1,2,3]
</code></pre>
<p>A list contains pointers to objects (in this case integers) elsewhere in memory.</p>
<pre><code>b = a
</code></pre>
<p><code>b</code> points to the same list as <code>a</code>.  It's just another name</p>
<pre><code>c = a[:]
</code></pre>
<p><code>c</code> is new, but it contains the same pointers as <code>a</code></p>
<pre><code>arr = np.array(a)
</code></pre>
<p><code>arr</code> has the same numeric values as <code>a</code>, but it stores those values in its own databuffer.  It has, in effect, evaluated <code>a</code>, and made a new object.  There is no connection, other than by value, with <code>a</code>.</p>
<pre><code>arr1 = arr[:]
</code></pre>
<p>a new array, but with a shared data buffer, a <code>view</code>.</p>
<pre><code>arr2 = arr.copy()
</code></pre>
<p>a new array with its own data buffer.</p>
<pre><code>arr[0]
</code></pre>
<p>is a number, created from <code>arr</code>.  It's equal in value to <code>a[0]</code> but does not reference the same numeric object.</p>
</div>
<span class="comment-copy">"If I create a list in python, and assign a different list to it, changes of the first list are reflected in the second list" - no, you don't have a first list and a second list. You have <b>one list</b> and two names for it. With <code>np.array(a)</code>, you're making an actual second object. You can't have it mirror changes to the list it was created from; NumPy arrays don't support that and couldn't support it without sacrificing almost everything that justifies their existence.</span>
<span class="comment-copy">Yes, I was aware that it is just a different name. Thanks, I thought that it wouldn't work, but I wasn't sure.</span>
<span class="comment-copy">Watch out - <code>numpy.frombuffer</code> is still using the old buffer protocol (or on Python 3, the compatibility functions that wrap the new buffer protocol in an old-style interface), so it's not very memory-safe. If you create a NumPy array from an <code>array.array</code> or <code>bytearray</code> with <code>frombuffer</code>, you must not change the size of the underlying array. Doing so risks arbitrary memory corruption and segfaults when you access the NumPy array.</span>
<span class="comment-copy">@user2357112 good advice. I would likely never actually use the above, but I simply wanted to illustrate a little bit about the <code>numpy</code> and <code>python</code> internals. I edited to add a warning.</span>
