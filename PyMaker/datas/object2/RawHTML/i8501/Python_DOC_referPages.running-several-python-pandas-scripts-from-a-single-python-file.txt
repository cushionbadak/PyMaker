<div class="post-text" itemprop="text">
<p>I have a script named test1.py which is not in a module. It just has code that should execute when the script itself is run. There are no functions, classes, methods, etc. I have another script which runs as a service. I want to call test1.py from the script running as a service.</p>
<p>For example:</p>
<h3>File test1.py</h3>
<pre><code>print "I am a test"
print "see! I do nothing productive."
</code></pre>
<h3>File service.py</h3>
<pre><code># Lots of stuff here
test1.py # do whatever is in test1.py
</code></pre>
<p>I'm aware of one method which is opening the file, reading the contents, and basically eval'ing it. I'm assuming there's a better way of doing this. Or at least I hope so.</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual way to do this is something like the following.</p>
<p>test1.py</p>
<pre><code>def some_func():
    print 'in test 1, unproductive'

if __name__ == '__main__':
    # test1.py executed as script
    # do something
    some_func()
</code></pre>
<p>service.py</p>
<pre><code>import test1

def service_func():
    print 'service func'

if __name__ == '__main__':
    # service.py executed as script
    # do something
    service_func()
    test1.some_func()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is possible in Python 2 using</p>
<pre><code>execfile("test2.py")
</code></pre>
<p>See the <a href="https://docs.python.org/2/library/functions.html#execfile" rel="noreferrer">documentation</a> for the handling of namespaces, if important in your case.</p>
<p>However, you should consider using a different approach; your idea (from what I can see) doesn't look very clean.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way:</p>
<h3>File test1.py:</h3>
<pre><code>print "test1.py"
</code></pre>
<h3>File service.py:</h3>
<pre><code>import subprocess

subprocess.call("test1.py", shell=True)
</code></pre>
<p>The advantage to this method is that you don't have to edit an existing Python script to put all its code into a subroutine.</p>
<p>Documentation: <a href="https://docs.python.org/2/library/subprocess.html" rel="noreferrer">Python 2</a>, <a href="https://docs.python.org/3/library/subprocess.html" rel="noreferrer">Python 3</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you want test1.py to remain executable with the same functionality as when it's called inside service.py, then do something like:</p>
<p>test1.py</p>
<pre><code>def main():
    print "I am a test"
    print "see! I do nothing productive."

if __name__ == "__main__":
    main()
</code></pre>
<p>service.py</p>
<pre><code>import test1
# lots of stuff here
test1.main() # do whatever is in test1.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should not be doing this.  Instead, do:</p>
<p>test1.py:</p>
<pre><code> def print_test():
      print "I am a test"
      print "see! I do nothing productive."
</code></pre>
<p>service.py</p>
<pre><code>#near the top
from test1 import print_test
#lots of stuff here
print_test()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/reference/simple_stmts.html#the-import-statement" rel="noreferrer"><code>import test1</code></a> for the 1st use - it will execute the script. For later invocations, treat the script as an imported module, and call the <a href="http://docs.python.org/library/functions.html#reload" rel="noreferrer"><code>reload(test1)</code></a> method.</p>
<blockquote>
<p>When <code>reload(module)</code> is executed:</p>
<ul>
<li>Python modules’ code is recompiled and the <strong>module-level code reexecuted</strong>, defining a new set of objects which are bound to names in the module’s dictionary. The init function of extension modules is not called </li>
</ul>
</blockquote>
<p>A simple check of <a href="http://docs.python.org/library/sys.html#sys.modules" rel="noreferrer"><code>sys.modules</code></a> can be used to invoke the appropriate action. To keep referring to the script name as a string (<code>'test1'</code>), use the <a href="http://docs.python.org/library/functions.html#__import__" rel="noreferrer">'<strong>import</strong>()'</a> builtin.</p>
<pre><code>import sys
if sys.modules.has_key['test1']:
    reload(sys.modules['test1'])
else:
    __import__('test1')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os

os.system("python myOtherScript.py arg1 arg2 arg3")  
</code></pre>
<p>Using os you can make calls directly to your terminal. If you want to be even more specific you can concatenate your input string with local variables, ie.</p>
<pre><code>command = 'python myOtherScript.py ' + sys.argv[1] + ' ' + sys.argv[2]
os.system(command)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not just import test1? Every python script is a module. A better way would be to have a function e.g. main/run in test1.py, import test1 and run test1.main(). Or you can execute test1.py as a subprocess.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an example with <code>subprocess</code> library:</p>
<pre><code>import subprocess

python_version = '3'
path_to_run = './'
py_name = '__main__.py'

# args = [f"python{python_version}", f"{path_to_run}{py_name}"]  # Avaible in python3
args = ["python{}".format(python_version), "{}{}".format(path_to_run, py_name)]

res = subprocess.Popen(args, stdout=subprocess.PIPE)
output, error_ = res.communicate()

if not error_:
    print(output)
else:
    print(error_)
</code></pre>
</div>
<span class="comment-copy">The better way is to write methods and classes and use them</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/30076185/4279">Python 3: Call python script with input with in a python script using subprocess</a></span>
<span class="comment-copy">What if <code>test1.py</code> is located in some far-away directory?</span>
<span class="comment-copy">@EvgeniSergeev See <a href="http://stackoverflow.com/questions/67631/how-to-import-a-module-given-the-full-path" title="how to import a module given the full path">stackoverflow.com/questions/67631/…</a></span>
<span class="comment-copy">Why do you named it 'some_func()' instead of 'main()'?</span>
<span class="comment-copy">@LucasMalor: Presumably because it's intended to normally <i>not</i> be the <code>main()</code> function -- which wouldn't be very descriptive (or accurate) in that case.</span>
<span class="comment-copy">This doesn't really answer the question though, does it? You aren't executing the whole script, you're executing some functions from within the script that you import.</span>
<span class="comment-copy">directly what i need in python 32 it is exec(open('test2.py').read())</span>
<span class="comment-copy">This approach executes the scripts within the calling namespace. :)</span>
<span class="comment-copy">This is defiitely not the "best" or "most pythonic" way of doing it, but it's exactly what I was looking for :)</span>
<span class="comment-copy">to pass command-line arguments to the script, you could edit <code>sys.argv</code> list.</span>
<span class="comment-copy">More comprehensive treatment on Python 3 equivalents: <a href="http://stackoverflow.com/questions/436198/what-is-an-alternative-to-execfile-in-python-3-0" title="what is an alternative to execfile in python 3 0">stackoverflow.com/questions/436198/…</a></span>
<span class="comment-copy">I had to use <code>subprocess.call("./test1.py", shell=True)</code> to make it work</span>
<span class="comment-copy">Do not use <code>shell=True</code> unless it's necessary.</span>
<span class="comment-copy">@PiotrDobrogost - Could you specify which situations would make it necessary?</span>
<span class="comment-copy">It won't work on a typical Unix where the current directory is not in PATH. <code>test1.py</code> should be executable and have the shebang line (<code>#!/usr/bin/env python</code>) and you should specify the full path or you need to provide the executable yourself: <code>call([sys.executable, os.path.join(get_script_dir(), 'test1.py')])</code> where <a href="http://stackoverflow.com/a/22881871/4279"><code>get_script_dir()</code> is defined here</a>.</span>
<span class="comment-copy">I had to use subprocess.call("Python test1.py", shell=True) to make it work as the default program to open a "py" file is Notepad instead of Python.exe on my workstation.</span>
<span class="comment-copy">What if you have runtime parameters?</span>
<span class="comment-copy">when you import test1 how does it know where the file is? does it have to be in the same directory? what if its not?</span>
<span class="comment-copy"><code>reload</code> is gone in Python 3.</span>
<span class="comment-copy">importing a module is not equivalent to running it e.g., consider <code>if __name__ == "__main__":</code> guard. There could be other more subtle differences. Don't leave arbitrary code at the global level. Put it in a function and call it after the import as suggested in the <a href="http://stackoverflow.com/a/1186847/4279">accepted answer</a> instead</span>
<span class="comment-copy">calls to <code>os.system</code> should be avoided, you can do the same with any Class from <code>Popen, Call, </code></span>
<span class="comment-copy">From the <a href="https://docs.python.org/2/library/os.html#os.system" rel="nofollow noreferrer">Python documentation</a>: The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function.</span>
