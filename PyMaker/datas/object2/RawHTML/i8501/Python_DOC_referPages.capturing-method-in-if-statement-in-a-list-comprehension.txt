<div class="post-text" itemprop="text">
<p>I have a following use case:</p>
<pre><code>[(x, f(x)) for x in list_x if f(x) == cond(x)]
</code></pre>
<p>Above list comprehension, I think makes a f(x) call twice? How do I avoid that and capture value of f(x) so that f(x) is called only once.</p>
<p>I guess, easy fix is to convert above list comprehension into a for loop, but am curious if it can be done efficiently using a list comprehension.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a nested generator expression to call the function only once:</p>
<pre><code>[(x, fx) for (x, fx) in ((x, f(x)) for x in list_x) if fx == cond(x)]
</code></pre>
<p>The generator expression is iterated in lockstep to produce the <code>(x, fx)</code> tuples for the list comprehension.</p>
<p>If you find this easier on the reader, you can split out the generator expression into a separate name first:</p>
<pre><code>mapped_x = ((x, f(x)) for x in list_x)
filtered_x = [(x, fx) for (x, fx) in mapped_x if fx == cond(x)]
</code></pre>
<p>To re-iterate this point: the generator expression is executed lazily; the <code>for</code> loop in the expression is advanced step by step for each step in the <code>for ... in mapped_x</code> loop.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; list_x = range(5)
&gt;&gt;&gt; f = lambda x: print('f({!r})'.format(x)) or (x ** 2 - 1)
&gt;&gt;&gt; cond = lambda x: print('cond({!r})'.format(x)) or x % 2 == 0
&gt;&gt;&gt; mapped_x = ((x, f(x)) for x in list_x)
&gt;&gt;&gt; [(x, fx) for (x, fx) in mapped_x if fx == cond(x)]
f(0)
cond(0)
f(1)
cond(1)
f(2)
cond(2)
f(3)
cond(3)
f(4)
cond(4)
[(1, 0)]
</code></pre>
<p>Note how <code>f(x)</code> is called just once, and the condition is checked immediately.</p>
<p>How efficient this is depends on how costly the <code>f(x)</code> call is; a generator expression is executed as a separate function frame, and the interpreter will switch between the two frames (the loop for the list comprehension is also a frame object). </p>
<p>If <code>f(x)</code> is a Python function, you'll already have won, as you now halved the number of function frame objects that are created (each <code>f(x)</code> call creates a frame object too, and creating these is relatively costly). For C functions, you should create some trial runs with the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a> to see what is faster for your expected list size.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you do not want to call <code>f</code> twice, you can apply <code>f</code> to the list first</p>
<p><code>[a for a in map(lambda x: (x, f(x)), list_x) if a[1] == cond(x)]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Filter would be a clean way of doing this.  It will evaluate the function passed and if it returns true, it will keep the element, otherwise, no.</p>
<pre><code>print (list(filter(lambda x: x[1] == cond(x[0]), [(x, f(x)) for x in list_x])))
</code></pre>
</div>
<span class="comment-copy">if you use <code>map</code> why not using <code>filter</code> as well?...</span>
<span class="comment-copy">You are welcome to provide your version of answer</span>
<span class="comment-copy">Note that using a <code>lambda</code> slows this down significantly (creating and popping the function frame object N times for a list length N).</span>
<span class="comment-copy">@MartijnPieters I doubt the qualifier will be  <code>significantly</code>. Not that I don't trust you.</span>
<span class="comment-copy">@AnthonyKong: you'd be surprised. Try it out with <code>timeit</code>, or check out <a href="//stackoverflow.com/a/14648595">Python Function calls are really slow</a></span>
