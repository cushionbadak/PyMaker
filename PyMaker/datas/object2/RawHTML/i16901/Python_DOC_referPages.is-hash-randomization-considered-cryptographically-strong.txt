<div class="post-text" itemprop="text">
<p>Starting from the <a href="https://docs.python.org/3/whatsnew/3.3.html#summary-release-highlights" rel="nofollow">CPython 3.3</a>, hash randomization is enabled by default. On previous versions it could be turned on by specifying the <a href="https://docs.python.org/2.7/using/cmdline.html#cmdoption-R" rel="nofollow"><code>-R</code> command-line option</a> or by setting the <a href="https://docs.python.org/2.7/using/cmdline.html#envvar-PYTHONHASHSEED" rel="nofollow"><code>PYTHONHASHSEED</code> environment variable</a> to <code>random</code>.</p>
<p>Citing the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow">documentation</a>:</p>
<blockquote>
<p>By default, the <code>__hash__()</code> values of str, bytes and datetime
  objects are “salted” with an unpredictable random value. Although they
  remain constant within an individual Python process, they are not
  predictable between repeated invocations of Python.</p>
</blockquote>
<p>Does this mean that the generated value will be cryptographically strong? </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3, the hash seed is not cryptographically strong; it is generated at startup with the following pseudo-random generator:</p>
<pre class="lang-c prettyprint-override"><code>/* Fill buffer with pseudo-random bytes generated by a linear congruent
   generator (LCG):

       x(n+1) = (x(n) * 214013 + 2531011) % 2^32

   Use bits 23..16 of x(n) to generate a byte. */
static void
lcg_urandom(unsigned int x0, unsigned char *buffer, size_t size)
{
    size_t index;
    unsigned int x;

    x = x0;
    for (index=0; index &lt; size; index++) {
        x *= 214013;
        x += 2531011;
        /* modulo 2 ^ (8 * sizeof(int)) */
        buffer[index] = (x &gt;&gt; 16) &amp; 0xff;
    }
}
</code></pre>
<p>which is not <a href="https://security.stackexchange.com/questions/4268/cracking-a-linear-congruential-generator">cryptographically strong</a>.</p>
<p>There are also <a href="http://bugs.python.org/issue14621" rel="nofollow noreferrer">other problems with the hash seeding</a> that still made it possible to force collisions.</p>
<p>Python 3.4 <a href="https://docs.python.org/3/whatsnew/3.4.html#whatsnew-pep-456" rel="nofollow noreferrer">addressed these issues</a> by introducing a <a href="https://131002.net/siphash/" rel="nofollow noreferrer">more secure hashing algorithm</a> by default, and made it pluggable.</p>
<p>If you need cryptographically strong random numbers in your program use <a href="https://docs.python.org/dev/library/random.html#random.SystemRandom" rel="nofollow noreferrer"><code>random.SystemRandom()</code></a> or <a href="https://docs.python.org/dev/library/os.html#os.urandom" rel="nofollow noreferrer"><code>os.urandom()</code></a> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Prior to 3.4, Python used a variant of FNV, which is not cryptographically secure. Unfortunately, simply adding a random value to a weak hash function like Python tried doesn't provide any real security. It is easy to generate strings that will have the same FNV hash, even in the presence of randomization, thanks to the weakness of the underlying hash algorithm.</p>
<p>Note that this is true even if the seed is perfectly random and not leaked to the client.</p>
<p>To consider why, imagine a very weak hash function - simply adding up all the characters in the string. In this case, if you add a random value to the beginning, then the hash of any single string will be random. However, if two strings have characters which sum to the same value, then they will hash to the same value, regardless of what the random seed is. Therefore, the random seed doesn't provide any collision resistance. What Python actually did isn't quite this bad, but it isn't much better, either.</p>
<p>In 3.4, Python switched the default algorithm to SipHash, which is beleived to by cryptographically secure against collision DOS attacks. Unfortunately, anyone using 2.x is completely out of luck.</p>
</div>
<span class="comment-copy">What do you mean by <code>cryptographically secure (at least for one session)</code>?</span>
<span class="comment-copy">Also, <code>hash</code> of an integer is that integer only. That won't change between the interpreter invocation.</span>
