<div class="post-text" itemprop="text">
<p>Looking at kismet's source code in packet_ieee80211.h is the section </p>
<pre><code>enum crypt_type {
    crypt_none = 0,
crypt_unknown = 1,
crypt_wep = (1 &lt;&lt; 1),
crypt_layer3 = (1 &lt;&lt; 2),
// Derived from WPA headers
crypt_wep40 = (1 &lt;&lt; 3),
crypt_wep104 = (1 &lt;&lt; 4),
crypt_tkip = (1 &lt;&lt; 5),
crypt_wpa = (1 &lt;&lt; 6),
crypt_psk = (1 &lt;&lt; 7),
crypt_aes_ocb = (1 &lt;&lt; 8),
crypt_aes_ccm = (1 &lt;&lt; 9),
//WPA Migration Mode
crypt_wpa_migmode = (1 &lt;&lt; 19),
// Derived from data traffic
crypt_leap = (1 &lt;&lt; 10),
crypt_ttls = (1 &lt;&lt; 11),
crypt_tls = (1 &lt;&lt; 12),
crypt_peap = (1 &lt;&lt; 13),
crypt_isakmp = (1 &lt;&lt; 14),
    crypt_pptp = (1 &lt;&lt; 15),
crypt_fortress = (1 &lt;&lt; 16),
crypt_keyguard = (1 &lt;&lt; 17),
crypt_unknown_nonwep = (1 &lt;&lt; 18),
};
</code></pre>
<p>I understand this as shifting bits but that's about it. Suppose I have the int 706, how do I break this number up into the cryptset as defined above i.e. how can I extract which crypts are used give 706 especially ported to python</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Aruisdante's answer is very good, I just wanted to expand on the answer if you have to use a Python previous to 3.4, as there <a href="https://pypi.python.org/pypi/enum34" rel="nofollow">does exist a backport</a> on PyPI:</p>
<pre><code>from enum import IntEnum

class Crypt(IntEnum):
    none = 0
    unknown = 1
    wep = (1 &lt;&lt; 1)
    layer3 = (1 &lt;&lt; 2)
    # Derived from WPA headers
    wep40 = (1 &lt;&lt; 3)
    wep104 = (1 &lt;&lt; 4)
    tkip = (1 &lt;&lt; 5)
    wpa = (1 &lt;&lt; 6)
    psk = (1 &lt;&lt; 7)
    aes_ocb = (1 &lt;&lt; 8)
    aes_ccm = (1 &lt;&lt; 9)
    # WPA Migration Mode
    wpa_migmode = (1 &lt;&lt; 19)
    # Derived from data traffic
    leap = (1 &lt;&lt; 10)
    ttls = (1 &lt;&lt; 11)
    tls = (1 &lt;&lt; 12)
    peap = (1 &lt;&lt; 13)
    isakmp = (1 &lt;&lt; 14)
    pptp = (1 &lt;&lt; 15)
    fortress = (1 &lt;&lt; 16)
    keyguard = (1 &lt;&lt; 17)
    unknown_nonwep = (1 &lt;&lt; 18)

    @classmethod
    def find_crypts(cls, magic_number):
        crypts = []
        for mask in cls:
            if magic_number &amp; mask == mask:
                crypts.append(mask)
        if len(crypts) &gt; 1:
            # remove false positive of none
            crypts = crypts[1:]
        return crypts

print Crypt.find_crypts(0)
[&lt;Crypt.none: 0&gt;]
print Crypt.find_crypts(706)
[&lt;Crypt.wep: 2&gt;, &lt;Crypt.wpa: 64&gt;, &lt;Crypt.psk: 128&gt;, &lt;Crypt.aes_ccm: 512&gt;]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, what you have to understand here is that this enum is defining a series of <a href="http://en.wikipedia.org/wiki/Mask_%28computing%29">bitmasks</a>. In this case, each one of these enum values, in binary, contains one and only one <code>1</code>. For example,</p>
<pre><code>crypt_wep = (1 &lt;&lt; 1) = 0b10
crypt_wpa = (1 &lt;&lt; 6) = 0b1000000
</code></pre>
<p>And so on. Using the bitshift operator is just an easy way of representing <em>'I want the nth+1 binary digit to be the flag'</em> </p>
<p>This lets us bitwise <code>or</code> a bunch of these values together and get a <em>magic number</em> that describes a combination of these crypt values uniquely as bit flags. To test if a <em>magic number</em> contains a value, we can simply bitwise <code>and</code> it with the value we wish to test</p>
<pre><code>magic_number = crypt_wep | crypt_wpa
has_wep      = (magic_number &amp; crypt_wep) == crypt_wep
has_wpa      = (magic_number &amp; crypt_wpa) == crypt_wpa
</code></pre>
<p><code>has_wep</code> and <code>has_wpa</code> will be <code>true</code> if and only if <code>magic_number</code> contained those bit flags.</p>
<p>So lets look at the number <code>706</code>, which in binary is <code>0b1011000010</code>. We can look at this and immediately see that it must have been built with <code>crypt_wep</code>, <code>crypt_wpa</code>, <code>crypt_psk</code> and <code>crypt_aes_ccm</code>, because the correct bits are set for those values.</p>
<p>So how to port to python? Well, python has <a href="https://docs.python.org/3/library/enum.html">enums</a> just like C/C++ does if you're in python 3.4 or later. So you can simply create the same enum table in python, and apply the same bitwise tests to determine what your <em>magic number</em> represents. If you're on a version of python that doesn't have enums, you can simply define a class with some static constants in it to get the same effect (and build in a method to test for the set of crypts a magic number contains). Such a class could look like this:</p>
<pre><code>class CryptKeys(object):
    crypt_masks = {
                    'crypt_unknown':1,
                     ....
                    'crypt_unknown_nonwep': (1 &lt;&lt; 18)
                   }
    @classmethod
    def find_crypts(cls, magic_number):
        if magic_number == 0:
            return ['crypt_none']
        else:
            return [name for name, mask in cls.crypt_masks.items() if magic_number &amp; mask == mask]
</code></pre>
</div>
<span class="comment-copy">awesome that works great</span>
