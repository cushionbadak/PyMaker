<div class="post-text" itemprop="text">
<p>I was wondering how to convert a decimal into a fraction in its lowest form in Python.</p>
<p>For example:</p>
<pre><code>0.25  -&gt; 1/4
0.5   -&gt; 1/2
1.25  -&gt; 5/4
3     -&gt; 3/1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have two options:</p>
<ol>
<li><p>Use <a href="https://docs.python.org/2/library/stdtypes.html#float.as_integer_ratio" rel="noreferrer"><code>float.as_integer_ratio()</code></a>:</p>
<pre><code>&gt;&gt;&gt; (0.25).as_integer_ratio()
(1, 4)
</code></pre>
<p>(as of Python 3.6, you can <a href="https://docs.python.org/3/library/decimal.html#decimal.Decimal.as_integer_ratio" rel="noreferrer">do the same with a <code>decimal.Decimal()</code> object</a>.)</p></li>
<li><p>Use the <a href="https://docs.python.org/2/library/fractions.html#fractions.Fraction" rel="noreferrer"><code>fractions.Fraction()</code> type</a>:</p>
<pre><code>&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; Fraction(0.25)
Fraction(1, 4)
</code></pre></li>
</ol>
<p>The latter has a very helpful <code>str()</code> conversion:</p>
<pre><code>&gt;&gt;&gt; str(Fraction(0.25))
'1/4'
&gt;&gt;&gt; print Fraction(0.25)
1/4
</code></pre>
<p>Because floating point values can be imprecise, you can end up with 'weird' fractions; limit the denominator to 'simplify' the fraction somewhat, with <a href="https://docs.python.org/2/library/fractions.html#fractions.Fraction.limit_denominator" rel="noreferrer"><code>Fraction.limit_denominator()</code></a>:</p>
<pre><code>&gt;&gt;&gt; Fraction(0.185)
Fraction(3332663724254167, 18014398509481984)
&gt;&gt;&gt; Fraction(0.185).limit_denominator()
Fraction(37, 200)
</code></pre>
<p>If you are using Python 2.6 still, then <code>Fraction()</code> doesn't yet support passing in a <code>float</code> directly, but you <em>can</em> combine the two techniques above into:</p>
<pre><code>Fraction(*0.25.as_integer_ratio())
</code></pre>
<p>Or you can just use the <a href="https://docs.python.org/2/library/fractions.html#fractions.Fraction.from_float" rel="noreferrer"><code>Fraction.from_float()</code> class method</a>:</p>
<pre><code>Fraction.from_float(0.25)
</code></pre>
<p>which essentially does the same thing, e.g. take the integer ratio tuple and pass that in as two separate arguments.</p>
<p>And a small demo with your sample values:</p>
<pre><code>&gt;&gt;&gt; for f in (0.25, 0.5, 1.25, 3.0):
...     print f.as_integer_ratio()
...     print repr(Fraction(f)), Fraction(f)
... 
(1, 4)
Fraction(1, 4) 1/4
(1, 2)
Fraction(1, 2) 1/2
(5, 4)
Fraction(5, 4) 5/4
(3, 1)
Fraction(3, 1) 3
</code></pre>
<p>Both the <code>fractions</code> module and the <code>float.as_integer_ratio()</code> method are new in Python 2.6.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from fractions import Fraction

print(Fraction(0.25))
print(Fraction(0.5))
print(Fraction(1.25))
print(Fraction(3))

#1/4
#1/2
#5/4
#3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To expand upon Martijn Pieters excellent answer with an additional option due to the imprecision inherent with more complex floats. For example:</p>
<pre><code>&gt;&gt;&gt; f = 0.8857097
&gt;&gt;&gt; f.as_integer_ratio()
(1994440937439217, 2251799813685248)          # mathematically wrong
&gt;&gt;&gt; Fraction(f)
Fraction(1994440937439217, 2251799813685248)  # same result but in a class
&gt;&gt;&gt; Fraction(f).limit_denominator()
Fraction(871913, 984423)                      # still imprecise
</code></pre>
<p>The mathematical result desired was <code>8857097/10000000</code> which can be achieved by casting to a string and then manipulating it. </p>
<p><strong>Edited Response</strong></p>
<p>I found a much simpler way to resolve the accuracy issue.</p>
<pre><code>&gt;&gt;&gt; Fraction(str(f))
Fraction(8857097, 10000000)
</code></pre>
<p>Casting as to a string also allows for accurate Decimal instances</p>
<pre><code>&gt;&gt;&gt; Decimal(f).as_integer_ratio()
(1994440937439217, 2251799813685248)
&gt;&gt;&gt; Decimal(str(f)).as_integer_ratio()
(8857097, 10000000)
</code></pre>
<p><strong>Original Response</strong></p>
<pre><code>def float_to_ratio(flt):
    if int(flt) == flt:        # to prevent 3.0 -&gt; 30/10
        return int(flt), 1
    flt_str = str(flt)
    flt_split = flt_str.split('.')
    numerator = int(''.join(flt_split))
    denominator = 10 ** len(flt_split[1])
    return numerator, denominator
</code></pre>
<p>Now let's test it:</p>
<pre><code>&gt;&gt;&gt; float_to_ratio(f)
(8857097, 10000000)      # mathematically correct
</code></pre>
<p>I will note that this kind of fraction precision is not optimized and will usually not be needed, but for completeness it is here. This function doesn't simplify the fraction, but you can do additional processing to reduce it: </p>
<pre><code>&gt;&gt;&gt; n = 0.5
&gt;&gt;&gt; float_to_ratio(n)
(5, 10)
&gt;&gt;&gt; Fraction(*float_to_ratio(n))
Fraction(1, 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you'd like to print a <em>proper fraction</em>, this little recipe should do:</p>
<pre><code>from fractions import Fraction    

def dec_to_proper_frac(dec):
    sign = "-" if dec &lt; 0 else ""
    frac = Fraction(abs(dec))
    return (f"{sign}{frac.numerator // frac.denominator} "
            f"{frac.numerator % frac.denominator}/{frac.denominator}")
</code></pre>
<p>This will print as follows:</p>
<pre><code>&gt;&gt;&gt; dec_to_proper_frac(3.75)
&gt;&gt;&gt; "3 3/4"
</code></pre>
</div>
<span class="comment-copy">Convert 0.25 to 25/100, then figure out largest common factor?</span>
<span class="comment-copy">Thanks! Options 1 works, but option 2 (Fraction(0.25)) gives me the error: "TypeError: 'float' object cannot be interpreted as an index". Can you tell me why?</span>
<span class="comment-copy">Great answer. Links and examples very helpful.</span>
<span class="comment-copy">@user2370460: What version of Python are you using?</span>
<span class="comment-copy">@user2370460: Ah, yes, only version 2.7 and up support passing in a float or decimal type; use <code>Fraction(*(0.25).as_integer_ratio())</code> instead in that case.</span>
<span class="comment-copy">@user2370460: I totally managed to miss the available <code>Fraction.from_float()</code> class method, much clearer. <code>Fraction.from_float(0.25)</code>.</span>
<span class="comment-copy">Thanks, but this gives me:    "TypeError: 'float' object cannot be interpreted as an index". Can you tell me why?</span>
<span class="comment-copy">Good suggestion, but I'd like to add: the one-argument constructor works well for some numbers, but not others. For instance, <code>Fraction(.2)</code> becomes <code>Fraction(3602879701896397, 18014398509481984)</code>. It might be better to use the two-argument constructor, ex. <code>Fraction(2,10)</code></span>
<span class="comment-copy">@Kevin: that's because .2 cannot be accurately represented by a float. See my answer for a workaround; limit the denominator and you can bring back it back to 2/10 in a jiffy.</span>
<span class="comment-copy">What result does your function give for <code>-3.75</code>?</span>
<span class="comment-copy">Good point, overlooked the floor-division operator...fixed.</span>
