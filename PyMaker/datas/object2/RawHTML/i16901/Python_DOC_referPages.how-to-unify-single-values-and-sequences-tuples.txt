<div class="post-text" itemprop="text">
<p>In my work, my Python scripts get a lot of input from non-Python-professional users.
So, for example, if my function needs to handle both single values and a series of values (Polymorphism/Duck Typing, Yo!) I would like to do something like this pseudo-code:</p>
<pre><code>def duck_typed(args):
    """
    args - Give me a single integer or a list of integers to work on.

    """
    for li in args:
        &lt;do_something&gt;
</code></pre>
<p>If the user passes me a list:</p>
<pre><code>[1,2]
</code></pre>
<p>a tuple:</p>
<pre><code>(1,2)
</code></pre>
<p>or even a singleton tuple (terminology help here, please)</p>
<pre><code>(1,)
</code></pre>
<p>everything works as expected.  But as soon as the user passes in a single integer everything goes to $%^&amp;:</p>
<p>1</p>
<pre><code>TypeError: 'int' object is not iterable  
</code></pre>
<p><br/></p>
<h1>The Difference between Smart and Clever</h1>
<p>Now, I immediately think, "No problem, I just need to get clever!"  and I do something like this:</p>
<pre><code>def duck_typed(args):
    """
    args - Give me a single integer or a list of integers to work on.

    """
    args = (args,)  # &lt;= Ha ha!  I'm so clever!

    for li in args:
        &lt;do_something&gt;
</code></pre>
<p><br/> </p>
<p>Well, now it works for the single integer case:</p>
<pre><code>args = (1,)
</code></pre>
<blockquote>
<p>(1,)</p>
</blockquote>
<p>but when the user passes in an iterable, the $%^&amp;*s come out again.  My trick gives me a nested iterable:</p>
<pre><code>args = ((1,2),)
</code></pre>
<blockquote>
<p>((1,2),)</p>
</blockquote>
<p><strong>ARGH!</strong></p>
<p><br/></p>
<h1>The Usual Suspects</h1>
<p>There are of course the usual workarounds.  Try/except clauses:</p>
<pre><code>try:
    args = tuple(args)
except TypeError:
    args = tuple((args,))
</code></pre>
<p><br/>
These work, but I run into this issue <em>A LOT</em>.  This is really a 1-line problem and try/except is a 4-line solution.  I would really love it if I could just call:</p>
<pre><code>tuple(1)
</code></pre>
<p>have it return (1,) and call it a day.</p>
<p><br/></p>
<h1>Other People Use this Language Too, You Know</h1>
<p>Now I'm aware that my needs in my little corner of the Python programming universe don't apply to the rest of the Python world.  Being dynamically typed makes Python such a wonderful language to work in -- especially after years of work in neurotic languages such as C.  (Sorry, sorry.  I'm not bashing C.  It's quite good at what its good at, but you know: <a href="http://xkcd.com/353/" rel="nofollow">xkcd</a>)</p>
<p>I'm quite sure the creators of the Python language have a very good reason to not allow <code>tuple(1)</code>.</p>
<p><br/></p>
<h1>Question 1</h1>
<p>Will someone please explain <em>why</em> the creators chose to not allow <code>tuple(1)</code> and/or <code>list(1)</code> to work?  I'm sure its completely sane reason and bloody obvious to many.  I may have just missed it during my tenure at the School of Hard Knocks.  (It's on the other side of the hill from Hogwarts.)</p>
<h1>Question 2</h1>
<p>Is there a more practical -- hopefully 1-line -- way to make the following conversion?</p>
<p>X(1)  -&gt; (1,)<br/>
X((1,2)) -&gt; (1,2)</p>
<p>If not, I guess I could just break down and roll my own.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>if isinstance(variable, int):
   variable = (variable, )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">Duck typing</a> <em>explains and validates</em> why <code>list(1)</code> fails.</p>
<p>The method was expecting a Duck but was given a Hamster, and Hamsters can't swim<sup>1</sup>.</p>
<blockquote>
<p>In duck typing, a programmer is only concerned with <em>ensuring that objects behave as demanded</em> of them in a given context, rather than ensuring that they are of a <em>specific</em> type.</p>
</blockquote>
<p>But not all objects/types behave the same, or "as demanded". In this case, an integer does <em>not</em> behave like an iterable and causes an exception. However, <code>list("quack")</code> works precisely because a string <em>does</em> act like an iterable and goes Quack - ['q','u','a','c','k']! To make <a href="https://docs.python.org/3/library/stdtypes.html#list" rel="nofollow noreferrer"><code>list</code></a> take a non-iterable would actually mean <em>special casing</em>, not <em>duck typing</em>.</p>
<p>Expecting an integer to "be iterable" sounds like a design issue because this requires an <em>implicit change in multiplicity</em>. That is, the concepts of a <em>value</em> and a <em>sequence</em> of [zero or more] values should be kept separate. Polymorphism doesn't apply in this case as polymorphism (of any type) only works over unification - and there is no unification to "iterate a non-iterable".</p>
<p>Furthermore, having <code>list(itr)</code> <em>only</em> accept an iterable fits in the strongly-typed Python model and avoids edge-cases. Consider that if <code>list(x)</code> was written in such a way that it allowed a non-iterable as well, one could not determine if the result would be [x] or [x<sub>0</sub>..x<sub>n</sub>] without knowing the value supplied. Python simply forbids this operation and puts the <em>burden of changing multiplicity</em> - or, passing a Duck - on the calling code.</p>
<hr/>
<p>See <a href="https://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-an-object-is-iterable">In Python, how do I determine if an object is iterable?</a> which presents several solutions to wrap (or otherwise deal with) a non-iterable value.</p>
<p>While I do <em>not</em> recommend this approach, as it changes the multiplicity, I would likely write such a coercion function as follows. Unlike <code>isinstance</code> checks it will handle all non-iterable values. However, you will have to work out the rules for what should happen on <code>ensure_iterable(None)</code>.</p>
<pre><code>def ensure_iterable(x):        
    try:
        return iter(x)
    except TypeError:
        return (x,)
</code></pre>
<p>And then "one line" usage:</p>
<pre><code>for li in ensure_iterable(args):
    pass
</code></pre>
<hr/>
<p><sup>1</sup> Hamsters can swim .. or at least stay afloat for a little bit. However I find the analogy is apt (and more memorable) precisely because a wet/drowning hamster is a sad thought. Keep those little critters safe and dry!</p>
</div>
<span class="comment-copy">The fact that you want to make such a conversion indicates bad design. I'd suggest writing a separate function for the plain int case.</span>
<span class="comment-copy">Why is writing a method that works on any object "Duck Typing/Polymorphism" but wanting to work on a single integer or a list of them "Bad Design"?</span>
<span class="comment-copy">@JS. Because it normally indicates a change in multiplicity requirements (not count). These are difference concepts: a <i>value</i> and a <i>sequence</i> of [zero or more] values.</span>
<span class="comment-copy">(You will get better responses if you focus on the problem/issue instead of begging opinions.)</span>
<span class="comment-copy">@user2864740: Fine.  But if I have to perform the same, complex operation on a single digit as I have to perform on hundreds, why does Polymorphism go out the window?</span>
<span class="comment-copy">Good point.  I do use that one quite a bit and overlooked it here.  Definitely better. This form usually brings a lot of screaming from The Community to "use Duck Typing!"</span>
<span class="comment-copy">@JS. Which is why it <i>failed</i> with <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">Duck typing</a>. The method was expecting a Duck but was given a Hamster, and Hamsters can't swim. "In duck typing, a programmer is only concerned with <i>ensuring that objects behave as demanded</i> of them in a given context, rather than ensuring that they are of a <i>specific</i> type" - but not all objects/types behave the same, or "as demanded".</span>
