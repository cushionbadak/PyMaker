<div class="post-text" itemprop="text">
<p>How to write a function ( a generator) that takes three letters (<code>l1</code>, <code>l2</code>, <code>l3</code>) and three numbers (<code>n1</code>, <code>n2</code>, <code>n3</code>) and gives all the possible combinations in which <code>l1</code> occurs <code>n1</code> times, <code>l2</code> <code>n2</code> times and <code>l3</code> <code>n3</code> times. </p>
<p>For example:</p>
<pre><code>for i in function('a', 2, 'b', 1, 'c', 0):
    print(i)
</code></pre>
<p>gives:</p>
<pre><code>aab
baa
aba 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow"><code>itertools.permutations</code></a>, all you need is a thin wrapper around it:</p>
<pre><code>from itertools import permutations

def l_n_times(l1, n1, l2, n2, l3, n3):
    return permutations(l1*n1 + l2*n2 + l3*n3)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; for item in set(l_n_times('a', 2, 'b', 1, 'c', 0)):
...     print(''.join(item))
...

baa
aba
aab
</code></pre>
<p><code>permutations</code> already returns a generator so you don't have use <code>yield</code> yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>Doesn't seem to me that <code>itertools</code> would help a lot here, though a recursive implementation may look like this:</p>
<pre><code>def combine(l1, n1, l2, n2, l3, n3):
    counters = {l1: n1, l2: n2, l3: n3}  # remaining characters to use
    buf = []                             # string under construction
    def recur(depth):
        if not depth:  # we've reached the bottom
            yield ''.join(buf)
            return
        # choosing next character
        for s, c in counters.iteritems():
            if not c:  # this character is exhausted 
                continue
            counters[s] -= 1
            buf.append(s)
            for val in recur(depth-1):
                # going down recursively
                yield val

            # restore the state before trying next character
            buf.pop()
            counters[s] += 1

    length = sum(counters.values())
    return recur(length)

for s in combine('a', 2, 'b', 1, 'c', 0):
    print s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lets admit you have a data structure like:</p>
<pre><code>letters = {'a': 2, 'b': 1, 'c': 0}
</code></pre>
<p>a recursive function would be:</p>
<pre><code>def r(letters, prefix = ''):
    for k,v in letters.items():
        if v &gt; 0:
            d = dict(letters)
            d[k] = v - 1
            for val in r(d, prefix + k):
                yield val
    if all(v == 0 for _, v in letters.items()):
        yield prefix
</code></pre>
<p>No duplicates, and it does use a generator. Quite heavy compared to a simple itertools call.</p>
</div>
<div class="post-text" itemprop="text">
<p>The docs for itertools have this to say;</p>
<blockquote>
<p>The code for combinations() can be also expressed as a subsequence of permutations() after filtering entries where the elements are not in sorted order (according to their position in the input pool):</p>
</blockquote>
<p>Since we want all combinations with no duplicates, we'll just enforce strict ordering (ie only yield values that are greater than the greatest one so far);</p>
<p>This would seem to do just that;</p>
<pre class="lang-py prettyprint-override"><code>def dfunc(l,n):
  old=[]
  for i in it.permutations(''.join(list(a*b for a,b in sorted(it.izip(l,n))))):
    if i &gt; old:
      old=i
      yield i

&gt;&gt;&gt; dfunc(['b','c','a'],[1,0,2])
&lt;generator object dfunc at 0x10ba055a0&gt;

&gt;&gt;&gt; list(dfunc(['b','c','a'],[1,0,2]))
[('a', 'a', 'b'), ('a', 'b', 'a'), ('b', 'a', 'a')]
</code></pre>
</div>
<span class="comment-copy">That is certainly something you could do, and <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> will help, but where's your code so far?</span>
<span class="comment-copy">As <code>permutations</code> doesn't check whether the different characters are the same, this returns duplicates.</span>
<span class="comment-copy">@jonrsharpe Issues fixed.</span>
<span class="comment-copy">Well, strictly seen this is a set that you're iterating through, not a generator anymore. It will use quite a bit of memory with many letters.</span>
<span class="comment-copy">@JoachimIsaksson Any suggestions for improvement?</span>
<span class="comment-copy">@AlexThornton I'm trying to figure that out myself actually, but I've not found a good solution using itertools (yet) :)</span>
<span class="comment-copy">As with Alex Thornton's original answer, this will print duplicates</span>
<span class="comment-copy">yes it will. I will figure some recursive thing that does not, to give a different answer</span>
