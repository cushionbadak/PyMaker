<div class="post-text" itemprop="text">
<p>I have a class <code>A</code> made by someone else, that I cannot edit:</p>
<pre><code>class A:
    def __init__(self, x):
        self.x = x
</code></pre>
<p>Now I'm trying to inherit my own class <code>B</code> from <code>A</code>, and have <code>x</code> as a property instead of an attribute.
Is this possible?</p>
<p>I already tried:</p>
<pre><code>class B(A):
    def __init__(self, x):
        super().__init__(x)

    @property
    def x(self):
        return super().x

    @x.setter
    def x(self, x):
        super().x = x
        print(x)  # my stuff goes here
</code></pre>
<p>But as I expected, it's not possible: <code>AttributeError: 'super' object has no attribute 'x'</code></p>
<p>Is there any other method, some workaroud maybe?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you cannot use <code>super()</code> for anything other than class attributes; <code>x</code> is an <em>instance</em> attribute, and there is no inheritance mechanism for attributes.</p>
<p>Instance attributes live in a single namespace; there is no 'parent instance' attribute namespace.</p>
<p>You can still reach the attribute in the instance <code>__dict__</code> object:</p>
<pre><code>class B(A):
    @property
    def x(self):
        return self.__dict__['x']

    @x.setter
    def x(self, x):
        self.__dict__['x'] = x
        print(x)  # my stuff goes here
</code></pre>
<p>A property is a <em>data descriptor</em>, meaning that it is looked up before the instance attributes are consulted (see the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">descriptor howto</a>), but you can still access it directly.</p>
</div>
<span class="comment-copy">Thanks for the answer, I'll accept asap. :) Might be a bit "hacky" way (well, at least looks a bit hacky to access <code>__dict__</code>), but seems to work just great</span>
