<div class="post-text" itemprop="text">
<p>I need to iterate over a circular list, possibly many times, each time starting with the last visited item.</p>
<p>The use case is a connection pool. A client asks for connection, an iterator checks if pointed-to connection is available and returns it, otherwise loops until it finds one that is available.</p>
<p>Is there a neat way to do it in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/2.7/library/itertools.html#itertools.cycle" rel="noreferrer"><code>itertools.cycle</code></a>, that's its exact purpose:</p>
<pre><code>from itertools import cycle

lst = ['a', 'b', 'c']

pool = cycle(lst)

for item in pool:
    print item,
</code></pre>
<p>Output:</p>
<pre><code>a b c a b c ...
</code></pre>
<p>(Loops forever, obviously)</p>
<hr/>
<p>In order to manually advance the iterator and pull values from it one by one, simply call <a href="https://docs.python.org/2/library/functions.html#next" rel="noreferrer"><code>next(pool)</code></a>:</p>
<pre><code>&gt;&gt;&gt; next(pool)
'a'
&gt;&gt;&gt; next(pool)
'b'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The correct answer is to use <a href="https://docs.python.org/2.7/library/itertools.html#itertools.cycle">itertools.cycle</a>. But, let's assume that library function doesn't exist. How would you implement it?</p>
<p>Use a <a href="https://docs.python.org/2.7/reference/expressions.html#yieldexpr">generator</a>:</p>
<pre><code>def circular():
    while True:
        for connection in ['a', 'b', 'c']:
            yield connection
</code></pre>
<p>Then, you can either use a <a href="https://docs.python.org/2/tutorial/controlflow.html#for-statements"><code>for</code></a> statement to iterate infinitely, or you can call <a href="https://docs.python.org/2/library/functions.html#next"><code>next()</code></a> to get the single next value from the generator iterator:</p>
<pre><code>connections = circular()
next(connections) # 'a'
next(connections) # 'b'
next(connections) # 'c'
next(connections) # 'a'
next(connections) # 'b'
next(connections) # 'c'
next(connections) # 'a'
#....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or you can do like this:</p>
<pre><code>conn = ['a', 'b', 'c', 'c', 'e', 'f']
conn_len = len(conn)
index = 0
while True:
    print(conn[index])
    index = (index + 1) % conn_len
</code></pre>
<p>prints a b c d e f a b c... forever</p>
</div>
<div class="post-text" itemprop="text">
<p>you can accomplish this with <code>append(pop())</code> loop:</p>
<pre><code>l = ['a','b','c','d']
while 1:
    print l[0]
    l.append(l.pop(0))
</code></pre>
<p>or <code>for i in range()</code> loop:</p>
<pre><code>l = ['a','b','c','d']
ll = len(l)
while 1:
    for i in range(ll):
       print l[i]
</code></pre>
<p>or simply:</p>
<pre><code>l = ['a','b','c','d']

while 1:
    for i in l:
       print i
</code></pre>
<p>all of which print:</p>
<pre><code>&gt;&gt;&gt;
a
b
c
d
a
b
c
d
...etc.
</code></pre>
<p>of the three I'd be prone to the append(pop()) approach as a function</p>
<pre><code>servers = ['a','b','c','d']

def rotate_servers(servers):
    servers.append(servers.pop(0))
    return servers

while 1:
    servers = rotate_servers(servers)
    print servers[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need a custom iterator -- I'll adapt the iterator from <a href="https://stackoverflow.com/a/7542261/208880">this answer</a>.</p>
<pre><code>from itertools import cycle

class ConnectionPool():
    def __init__(self, ...):
        # whatever is appropriate here to initilize
        # your data
        self.pool = cycle([blah, blah, etc])
    def __iter__(self):
        return self
    def __next__(self):
        for connection in self.pool:
            if connection.is_available:  # or however you spell it
                return connection
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you wish to cycle <code>n</code> times, implement the <code>ncycles</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipe</a>:</p>
<pre><code>from itertools import chain, repeat


def ncycles(iterable, n):
    "Returns the sequence elements n times"
    return chain.from_iterable(repeat(tuple(iterable), n))

list(ncycles(["a", "b", "c"], 3))
# ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another alternative, maybe not so pythonic.</p>
<pre><code>my_list = [1, 2, 3, 4]

for i in range(10):
    print my_list[i % len(my_list)]
</code></pre>
<p>One can control range argument to cyclic iterate 5 times, for example:</p>
<pre><code>for i in range(len(my_list) * 5):
    print my_list[i % len(my_list)]   
</code></pre>
</div>
<span class="comment-copy">Can you post some sample code of what you have and what you've tried?</span>
<span class="comment-copy">You are printing items in a loop. What I want to leave the loop and come back later? (I want to start where I left off).</span>
<span class="comment-copy">@user443854 use <code>pool.next()</code> to get the single next item from the cycle</span>
<span class="comment-copy">@user443854 FWIW this is a much better answer than mine. No reason to go around re-implementing library functions!</span>
<span class="comment-copy">pool.next() didn't work for me, only next(pool). Probably because of Python 3?</span>
<span class="comment-copy">@fjsj that is correct, on Python 3 you need to use <code>next(iterator)</code> (which BTW also works just fine on Python 2.x, and therefore is the canonical form that should be used). See <a href="http://stackoverflow.com/questions/1073396/is-generator-next-visible-in-python-3-0">Is generator.next() visible in python 3.0?</a> for a more in-depth explanation. Updated my answer accordingly.</span>
<span class="comment-copy">Nice! How does it know to start over when the list is exhausted?</span>
<span class="comment-copy">@user443854 the <code>while True</code> means to repeat forever</span>
<span class="comment-copy">@juanchopanza: Yep; <code>itertools.cycle</code> is a better answer. This shows how you could write the same functionality if <code>itertools</code> isn't available :)</span>
<span class="comment-copy">Does the simple generator also save a copy of each element like <code>itertools.cycle</code> does? Or would the simple generator be a more memory-efficient design? Per the <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>cycle</code> docs</a>: <code>Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable).</code></span>
<span class="comment-copy">@dthor this generator creates a list with three elements and literates over it, then destroys the list and creates a new one, in perpetuity. That documentation for <code>cycle</code> implies that the input iterable is converted to <code>list</code> before its generator starts, since <code>iterable</code> is only "good for one pass over the set of values".</span>
<span class="comment-copy">Upvoting this because it helped me with a completely different use case where I simply want to iterate over a list a number of times, each time with the start element advancing one step. My use case is to iterate over the players in a game of poker, advancing the dealer puck one player forward for each round.</span>
<span class="comment-copy">itertools recipe is indeed a goldmine!</span>
