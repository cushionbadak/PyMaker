<div class="post-text" itemprop="text">
<p>I'm writing a Python application that takes as a command as an argument, for example:</p>
<pre><code>$ python myapp.py command1
</code></pre>
<p>I want the application to be extensible, that is, to be able to add new modules that implement new commands without having to change the main application source. The tree looks something like:</p>
<pre><code>myapp/
    __init__.py
    commands/
        __init__.py
        command1.py
        command2.py
    foo.py
    bar.py
</code></pre>
<p>So I want the application to find the available command modules at runtime and execute the appropriate one.</p>
<p>Python defines an <strong>__import__</strong> function, which takes a string for a module name:</p>
<blockquote>
<p>__import__(name, globals=None, locals=None, fromlist=(), level=0)</p>
<p>The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. </p>
<p>Source: <a href="https://docs.python.org/3/library/functions.html#__import__" rel="noreferrer">https://docs.python.org/3/library/functions.html#<strong>import</strong></a></p>
</blockquote>
<p>So currently I have something like:</p>
<pre><code>command = sys.argv[1]
try:
    command_module = __import__("myapp.commands.%s" % command, fromlist=["myapp.commands"])
except ImportError:
    # Display error message

command_module.run()
</code></pre>
<p>This works just fine, I'm just wondering if there is possibly a more idiomatic way to accomplish what we are doing with this code.</p>
<p>Note that I specifically don't want to get in to using eggs or extension points. This is not an open-source project and I don't expect there to be "plugins". The point is to simplify the main application code and remove the need to modify it each time a new command module is added.</p>
</div>
<div class="post-text" itemprop="text">
<p>With Python older than 2.7/3.1, that's pretty much how you do it. </p>
<p>For newer versions, see <code>importlib.import_module</code> for <a href="https://docs.python.org/2/library/importlib.html#importlib.import_module" rel="noreferrer">Python 2</a> and and <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="noreferrer">Python 3</a>.</p>
<p>You can use <code>exec</code> if you want to as well.</p>
<p>Or using <code>__import__</code> you can import a list of modules by doing this:</p>
<pre><code>&gt;&gt;&gt; moduleNames = ['sys', 'os', 're', 'unittest'] 
&gt;&gt;&gt; moduleNames
['sys', 'os', 're', 'unittest']
&gt;&gt;&gt; modules = map(__import__, moduleNames)
</code></pre>
<p>Ripped straight from <a href="http://web.archive.org/web/20120315061111/http://www.diveintopython.net/functional_programming/dynamic_import.html" rel="noreferrer">Dive Into Python</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The recommended way for Python 2.7 and 3.1 and later is to use <a href="http://docs.python.org/3/library/importlib.html#importlib.import_module" rel="noreferrer"><code>importlib</code></a> module:</p>
<blockquote>
<p>importlib.import_module(name, package=None)</p>
<p>Import a module. The name argument specifies what module to import in absolute or relative terms (e.g. either pkg.mod or ..mod). If the name is specified in relative terms, then the package argument must be set to the name of the package which is to act as the anchor for resolving the package name (e.g. import_module('..mod', 'pkg.subpkg') will import pkg.mod).</p>
</blockquote>
<p>e.g.</p>
<pre><code>my_module = importlib.import_module('os.path')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Note: <strong>imp</strong> is deprecated since Python 3.4 in favor of <strong>importlib</strong></p>
</blockquote>
<p>As mentioned the <a href="http://docs.python.org/library/imp.html" rel="noreferrer">imp</a> module provides you loading functions:</p>
<pre><code>imp.load_source(name, path)
imp.load_compiled(name, path)
</code></pre>
<p>I've used these before to perform something similar.  </p>
<p>In my case I defined a specific class with defined methods that were required.
Once I loaded the module I would check if the class was in the module, and then create an instance of that class, something like this:</p>
<pre><code>import imp
import os

def load_from_file(filepath):
    class_inst = None
    expected_class = 'MyClass'

    mod_name,file_ext = os.path.splitext(os.path.split(filepath)[-1])

    if file_ext.lower() == '.py':
        py_mod = imp.load_source(mod_name, filepath)

    elif file_ext.lower() == '.pyc':
        py_mod = imp.load_compiled(mod_name, filepath)

    if hasattr(py_mod, expected_class):
        class_inst = getattr(py_mod, expected_class)()

    return class_inst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/library/imp.html#imp.load_module" rel="noreferrer">imp module</a>, or the more direct <a href="http://docs.python.org/library/functions.html#__import__" rel="noreferrer"><code>__import__()</code></a> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want it in your locals:</p>
<pre><code>&gt;&gt;&gt; mod = 'sys'
&gt;&gt;&gt; locals()['my_module'] = __import__(mod)
&gt;&gt;&gt; my_module.version
'2.6.6 (r266:84297, Aug 24 2010, 18:46:32) [MSC v.1500 32 bit (Intel)]'
</code></pre>
<p>same would work with <code>globals()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://www.python.org/doc/2.5.2/ref/exec.html" rel="noreferrer"><code>exec</code></a>:</p>
<pre><code>exec "import myapp.commands.%s" % command
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar as @monkut 's solution but reusable and error tolerant described here <a href="http://stamat.wordpress.com/dynamic-module-import-in-python/" rel="nofollow">http://stamat.wordpress.com/dynamic-module-import-in-python/</a>:</p>
<pre><code>import os
import imp

def importFromURI(uri, absl):
    mod = None
    if not absl:
        uri = os.path.normpath(os.path.join(os.path.dirname(__file__), uri))
    path, fname = os.path.split(uri)
    mname, ext = os.path.splitext(fname)

    if os.path.exists(os.path.join(path,mname)+'.pyc'):
        try:
            return imp.load_compiled(mname, uri)
        except:
            pass
    if os.path.exists(os.path.join(path,mname)+'.py'):
        try:
            return imp.load_source(mname, uri)
        except:
            pass

    return mod
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like what you really want is a plugin architecture.  </p>
<p>You should have a look at the  <a href="http://peak.telecommunity.com/DevCenter/setuptools#extensible-applications-and-frameworks" rel="nofollow noreferrer">entry points</a> functionality provided by the setuptools package.  It offers a great way to discover plugins that are loaded for your application.</p>
</div>
<div class="post-text" itemprop="text">
<p>for ex: my module names are like jan_module/ feb_module/ mar_module</p>
<blockquote>
<p>month='feb'<br/>
  exec 'from %s_module import *'%(month)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Nowadays you should use <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">importlib</a>. </p>
<h2>Import a source file</h2>
<p>The <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="nofollow noreferrer">docs</a> actually provide a recipe for that, and it goes like:</p>
<pre><code>import sys
import importlib.util

file_path = 'pluginX.py'
module_name = 'pluginX'

spec = importlib.util.spec_from_file_location(module_name, file_path)
module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(module)

# check if it's all there..
def bla(mod):
    print(dir(mod))
bla(module)
</code></pre>
<h2>Import a package</h2>
<p>Importing a package (<em>e.g.</em>, <code>pluginX/__init__.py</code>) under your current dir is actually straightforward:</p>
<pre><code>import importlib

pluginX = importlib.import_module('pluginX')

# check if it's all there..
def bla(mod):
    print(dir(mod))
bla(module)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The below piece worked for me:</p>
<pre><code>&gt;&gt;&gt;import imp; 
&gt;&gt;&gt;fp, pathname, description = imp.find_module("/home/test_module"); 
&gt;&gt;&gt;test_module = imp.load_module("test_module", fp, pathname, description);
&gt;&gt;&gt;print test_module.print_hello();
</code></pre>
<p>if you want to import in shell-script:</p>
<pre><code>python -c '&lt;above entire code in one line&gt;'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following worked for me:</p>
<pre><code>import sys, glob
sys.path.append('/home/marc/python/importtest/modus')
fl = glob.glob('modus/*.py')
modulist = []
adapters=[]
for i in range(len(fl)):
    fl[i] = fl[i].split('/')[1]
    fl[i] = fl[i][0:(len(fl[i])-3)]
    modulist.append(getattr(__import__(fl[i]),fl[i]))
    adapters.append(modulist[i]())
</code></pre>
<p>It loads modules from the folder 'modus'. The modules have a single class with the same name as the module name. E.g. the file modus/modu1.py contains:</p>
<pre><code>class modu1():
    def __init__(self):
        self.x=1
        print self.x
</code></pre>
<p>The result is a list of dynamically loaded classes "adapters".</p>
</div>
<span class="comment-copy">What does the fromlist=["myapp.commands"] do?</span>
<span class="comment-copy">@PieterMÃ¼ller : in a python shell type this:  <code>dir(__import__)</code>. The fromlist should be a list of names to emulate "from name import ...".</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/8718885/import-module-from-string-variable">Import module from string variable</a></span>
<span class="comment-copy">As of 2019, you should look for <code>importlib</code>: <a href="https://stackoverflow.com/a/54956419/687896">stackoverflow.com/a/54956419/687896</a></span>
<span class="comment-copy">what is the differece to exec?</span>
<span class="comment-copy">How could you use <code>__init__</code> of that module?</span>
<span class="comment-copy">One problem with this solution for the OP is that trapping exceptions for one or two bad "command" modules makes his/her whole command-app fail on one exception. Personally I'd for loop over each <b>import</b> individually wrapped in a try: mods=__import__()\nexcept ImportError as error: report(error) to allow other commands to continue to work while the bad ones get fixed.</span>
<span class="comment-copy">Another problem with this solution, as Denis Malinovsky points out below, is that the python docs themselves recommend not using <code>__import__</code>. The 2.7 docs: "Because this function is meant for use by the Python interpreter and not for general use it is better to use importlib.import_module()..." When using python3, the <code>imp</code> module solves this proble, as monkut mentions below.</span>
<span class="comment-copy">fyi this is a funny "abuse" of map :) I wonder why python doesn't have thing like <code>foreach</code> though</span>
<span class="comment-copy">Recommended by which source or authority?</span>
<span class="comment-copy">Documentation advises <a href="https://docs.python.org/2/library/functions.html#__import__" rel="nofollow noreferrer">against</a> using <code>__import__</code> function in favor of above mentioned module.</span>
<span class="comment-copy">This works well for import <code>os.path</code> ; how about <code>from os.path import *</code>?</span>
<span class="comment-copy">I get the answer here <a href="https://stackoverflow.com/a/44492879/248616">stackoverflow.com/a/44492879/248616</a> ie. calling <code>globals().update(my_module.__dict)</code></span>
<span class="comment-copy">@NamGVU, this is a dangerous method since it's polluting your globals and can override any identifiers with the same names.  The link you've posted has a better, improved version of this code.</span>
<span class="comment-copy">Good and simple solution. I'we written a similar one: <a href="http://stamat.wordpress.com/dynamic-module-import-in-python/" rel="nofollow noreferrer">stamat.wordpress.com/dynamic-module-import-in-python</a> But your's has some flaws: What about exceptions? IOError and ImportError? Why not check for the compiled version first and then for the source version. Expecting a class reduces reusability in your case.</span>
<span class="comment-copy">In the line where you construct MyClass in the target module you are adding a redundant reference to the class name. It is already stored in <code>expected_class</code> so you could do <code>class_inst = getattr(py_mod,expected_name)()</code> instead.</span>
<span class="comment-copy"><i>Note that if a properly matching byte-compiled file (with suffix .pyc or .pyo) exists, it will be used instead of parsing the given source file</i>. <a href="https://docs.python.org/2/library/imp.html#imp.load_source" rel="nofollow noreferrer">https://docs.python.org/2/library/imp.html#imp.load_source</a></span>
<span class="comment-copy">Heads up: this solution works; however, the imp module is going to be deprecated in favor of import lib, see imp's page: """Deprecated since version 3.4: The imp package is pending deprecation in favor of importlib."""</span>
<span class="comment-copy">How do I get a handle to the module through the exec, so that I can call (in this example) the .run() method?</span>
<span class="comment-copy">You can then do getattr(myapp.commands, command) to access the module.</span>
<span class="comment-copy">... or add <code>as command_module</code> to the end of import statement and then do <code>command_module.run()</code></span>
<span class="comment-copy">In some version of Python 3+ <b>exec</b> was converted into a function with the added benefit that the resultant referenced created in source get stored into the locals() argument of exec(). To further isolate the exec'd referenced from the local code block locals you can provide your own dict, like an empty one and reference the references using that dict, or pass that dict to other functions exec(source, gobals(), command1_dict)    .... print(command1_dict['somevarible'])</span>
<span class="comment-copy">This is not working in python 3.7 can anyone suggest alternate to this</span>
<span class="comment-copy">I specifically mentioned I don't want to use entry points and a plugin type architecture. The reason for the design is more of code maintainability and modularity rather than allowing arbitrary plugins to be included.</span>
<span class="comment-copy">Please don't bury answers without providing a reason in the comments. It doesn't help anyone.</span>
<span class="comment-copy">I'd like to know why this is bad stuff.</span>
<span class="comment-copy">Same as me, since I new to Python and want to know, why this is bad.</span>
<span class="comment-copy">This is bad not just because it's bad python, but also it's just generally bad code.  What is <code>fl</code>?  The for loop definition is overly complex.  The path is hard coded (and for an example, irrelevant).  It's using discouraged python (<code>__import__</code>), what's all that <code>fl[i]</code> stuff for?   This is basically unreadable, and is unnecessarily complex for something that is not all that hard - see the top voted answer with its one-liner.</span>
