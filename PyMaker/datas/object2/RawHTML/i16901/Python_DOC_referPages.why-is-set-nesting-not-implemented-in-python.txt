<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; li = [2, [3, 4]]
&gt;&gt;&gt; 3 in li
False

&gt;&gt;&gt; {2, {3, 4}}
TypeError: unhashable type: 'set'
</code></pre>
<p>Why is set nesting (which is used in mathematics) not implemented in Python (2.x and 3.x)?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is implemented, but you need to use a <a href="https://docs.python.org/3/glossary.html#term-hashable">hashable type</a> instead. <a href="https://docs.python.org/3/library/stdtypes.html#frozenset"><code>frozenset()</code></a> is that type. The documentation even tells you so:</p>
<blockquote>
<p>To represent sets of sets, the inner sets must be <code>frozenset</code> objects.</p>
</blockquote>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; {2, frozenset([3, 4])}
set([frozenset([3, 4]), 2])
</code></pre>
<p>This is because a regular <code>set()</code> is <em>mutable</em>, which is incompatible with the requirements of the datastructure used for sets (and dictionaries); these require stable objects that can be re-located when used as a key in a table based on their hash.</p>
<p>The documentation again:</p>
<blockquote>
<p>The <code>set</code> type is mutable — the contents can be changed using methods like <code>add()</code> and <code>remove()</code>. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The <code>frozenset</code> type is immutable and <em>hashable</em> — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As @Martin Pieters mentioned, it is possible if you use frozenset objects instead of regular sets, because frozenset objects are hashable. </p>
<p>The reason for this is because the normal containers of python (list, dict, set, ...) are mutable, that means they can change in their lifetime (an element might be added to a set). mutable datatypes can't be hashable (since hashable basically means "identifying an immutable object with a unique number(=hash)).</p>
<p>frozenset objects are hashable, which means they can be used in sets, this comes at the cost of not longer being able to change the frozenset after it has been created (no update() method is available for frozenset). This means if you want to change a frozenset that is nested in a set, you have to create a new set from the frozen set, make your changes to that set, remove the old frozenset and convert the new set to a frozenset and add it (this seems convoluted, let me know if this is hard to understand).</p>
<p>The reason why sets can only consist of hashable objects has to do with the fact that every object in a set has to be unique to that set and python checks for that by using the hashes of the objects, since that is a efficient and safe way to do it.</p>
</div>
<span class="comment-copy">Note that you still cannot expect <code>3 in li</code> to work, even if you're using <code>frozensets</code>. You will have to inspect each subset / sublist individually.</span>
<span class="comment-copy">Sets contain unique elements only, thus a hash is used to determine equality. Sets aren't hashable, because they are mutable: <a href="http://stackoverflow.com/questions/14193438/are-python-sets-mutable" title="are python sets mutable">stackoverflow.com/questions/14193438/are-python-sets-mutable</a></span>
<span class="comment-copy">@msvalkon: I wouldn't even like <code>3 in li</code> to return <code>True</code>. Because that would be a different evaluation of that expression than is done in mathematics.</span>
<span class="comment-copy">Given that the Python developers wanted sets to be mutable, this explains why the frozenset type had to be created. Cool!</span>
