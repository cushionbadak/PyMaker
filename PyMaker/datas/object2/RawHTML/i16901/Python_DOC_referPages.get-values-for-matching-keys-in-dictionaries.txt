<div class="post-text" itemprop="text">
<p>I have two <code>OrderedDict</code> dictionaries, and I want to retrieve values for matching keys in both dictionaries:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d1 = OrderedDict()
&gt;&gt;&gt; d2 = OrderedDict()

&gt;&gt;&gt; d1["A"] = 2
&gt;&gt;&gt; d1["B"] = 3
&gt;&gt;&gt; d1["C"] = 2

&gt;&gt;&gt; d2["D"] = 90
&gt;&gt;&gt; d2["B"] = 11
&gt;&gt;&gt; d2["C"] = 25

&gt;&gt;&gt; # search both dicts and output values where key matches

(3, 11)
(2, 25)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>print [(d1[key], d2[key]) for key in d1.viewkeys() &amp; d2]
# [(2, 25), (3, 11)]
</code></pre>
<p><code>d1.viewkeys() &amp; d2</code> is used to get the keys which are present in both the dictionaries. Once we get that, simply get the values corresponding to that from both the dictionaries.</p>
<p>This works because, as per the <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="nofollow">Dictionary View Objects Python 2.7 Documentation</a>,</p>
<blockquote>
<p>Keys views are set-like since their entries are unique and hashable. </p>
</blockquote>
<p>Since <code>viewkeys</code> are already set-like, we can use set operations on them directly.</p>
<p><strong>Note:</strong> If you are using Python 3.x, then you have to use <code>keys</code> function, like this</p>
<pre><code>print([(d1[key], d2[key]) for key in d1.keys() &amp; d2])
</code></pre>
<p>because, as per the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow">Dictionary View Objects Python 3.x Documentation</a>,</p>
<blockquote>
<p>The objects returned by dict.keys(), dict.values() and dict.items() are view objects. </p>
</blockquote>
<p>Since <code>keys</code> itself returns a view object, and as their entries are unique and hashable, we can use that like set.</p>
<p><strong>Note:</strong> In Python 2.x, <code>dict.keys</code> returns a list of keys. Since we cannot do set operations on a list, we cannot use the Python 3.x solution.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = d1.keys()
b = d2.keys()
for i in range(0, len(a)):
  for j in range(0, len(b)):
    if (a[i]==b[j]):
      print d1[a[i]], d2[b[j]] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can easily do that as:</p>
<pre><code>res = [(d1[i], d2[i]) for i in d1 if i in d2]

&gt;&gt;&gt; print res
[(3, 11), (2, 25)]
</code></pre>
</div>
<span class="comment-copy">Good. Write so me code to do that and you're done.</span>
<span class="comment-copy">The world is unfair.  <a href="http://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python">Certain duplicates</a>, no effort questions are upvoted like crazy, and certain ones are downvoted!</span>
<span class="comment-copy">@devnull Up-voted too, which is a sign of the times :)</span>
<span class="comment-copy">@juanchopanza I didn't suggest that the question be upvoted.  (I didn't vote on it either way.)  But I do expect the community to be a <i>bit</i> consistent.</span>
<span class="comment-copy">@devnull I didn't mean to imply that. In my view it is fully deserving of a down-vote, and so is the one you linked.</span>
<span class="comment-copy">This is very very in-efficient.</span>
