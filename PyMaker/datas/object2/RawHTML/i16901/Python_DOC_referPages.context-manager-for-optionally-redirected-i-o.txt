<div class="post-text" itemprop="text">
<p>I'm often faced with the situation that depending on some command line argument, input might either come from a file or standard input. The same goes for output. I really like how context managers in python 3 work, and therefore try to make all my <code>open</code> calls part of some <code>with</code> statement. But in this case, I'm having trouble.</p>
<pre><code>if args.infile:
    with open(args.infile, "r") as f:
        process(f)
else:
    process(sys.stdin)
</code></pre>
<p>is already clumsy, and with both input and output I'd have to cater for four combinations. I would like something easier, e.g.</p>
<pre><code>with (open(args.infile, "r") if args.infile
      else DummyManager(sys.stdin)) as f:
    process(f)
</code></pre>
<p>Is there something like this DummyManager in the python standard libraries? Something which implements the context manager protocol, but only to return a fixed value from its <code>__enter__</code> method? I guess the most likely location for such a class would be <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow">contextlib</a>, and since I didn't find anything like this there, perhaps there is no such thing. Are there other elegant solutions you can suggest?</p>
</div>
<div class="post-text" itemprop="text">
<p>In your case, you could use <a href="https://docs.python.org/3/library/fileinput.html" rel="nofollow"><code>fileinput</code> module</a>:</p>
<pre><code>from fileinput import FileInput

with FileInput(args.infile) as file:
    process(file)
# sys.stdin is still open here
</code></pre>
<p>If <code>args.infile='-'</code> then it uses <code>sys.stdin</code>. If <code>inplace=True</code> parameter then it redirects <code>sys.stdout</code> to the input file. You could pass several filenames. If there are no filenames it uses filenames given at the command-line or stdin.</p>
<p>Or you could leave the file as is:</p>
<pre><code>import sys
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--log', default=sys.stdout, type=argparse.FileType('w'))
args = parser.parse_args()
with args.log:
    args.log.write('log message')
# sys.stdout may be closed here
</code></pre>
<p>It should be fine for most programs where stdout may be used to write the result.</p>
<p>To avoid closing <code>sys.stdin / sys.stdout</code>, you could use <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow"><code>ExitStack</code></a> to enable the context managers conditionally:</p>
<pre><code>from contextlib import ExitStack

with ExitStack() as stack:
    if not args.files:
       files = [sys.stdin]
    else:
       files = [stack.enter_context(open(name)) for name in args.files]

    if not args.output:
       output_file = sys.stdout
       stack.callback(output_file.flush) # flush instead of closing 
    else:
       output_file = stack.enter_context(open(args.output, 'w'))

    process(files, output_file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's trivial to create one with the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="nofollow"><code>@contextlib.contextmanager</code> decorator</a>:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def dummy_manager(ob):
    yield ob
</code></pre>
<p>That's it; this creates a context manager that does nothing but hand you <code>ob</code> back, and the <code>__exit__</code> handler does exactly nothing.</p>
<p>I'd use it like this:</p>
<pre><code>f = open(args.infile, "r") if args.infile else dummy_manager(sys.stdin)
with f:
    process(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need a dummy manager in your case.  <code>sys.stdin</code>, being file-like, can be used as a context manager.</p>
<pre><code>with (open(args.infile, "r") if args.infile else sys.stdin) as f:
    process(f)
</code></pre>
<p>One thing to note is that when <code>__exit__</code>ing the block, sys.stdin gets <code>close</code>d (while you ordinarily don't need/want to close it yourself), but that shouldn't be a problem. </p>
</div>
<div class="post-text" itemprop="text">
<p>Various <code>ArgParse</code> wrappers and replacements now exist which support this nicely.  I like <a href="http://click.pocoo.org/5/api/" rel="nofollow noreferrer"><code>click</code></a>:</p>
<pre><code>with click.open_file(filename) as lines:
    for line in lines:
        process(line)
</code></pre>
<p>This will handle <code>sys.stdin</code> if <code>filename</code> is <code>-</code> and otherwise fall back to the regular <code>open</code> with a <code>close</code> hidden in the context manager's <code>finally</code> part.</p>
</div>
<span class="comment-copy">This works with Python 2.7â€”<code>FileInput()</code> didn't gain context manager support until 3.2.</span>
