<div class="post-text" itemprop="text">
<p>I was handed some code that looks like this:</p>
<p>In "header.hpp":</p>
<pre><code>enum class my_enum_type {
    val1 = 0;
    ... 
}
</code></pre>
<p>In "header_lib.pyx":</p>
<pre><code>cdef extern from "header.hpp":
    enum my_enum_type:
        val1 = 0;
        ...
...
</code></pre>
<p>Later in "header_lib.pyx":</p>
<pre><code>def foo():
    ...
    return my_enum_type.val1
</code></pre>
<p>I was told this should have no problems, but that is not the case from my experience just now,and as evident in this post: <a href="https://stackoverflow.com/questions/9341511/defining-enums-in-cython-code-that-will-be-used-in-the-c-part-of-code">Defining enums in Cython code that will be used in the C part of code</a>. </p>
<p>However, it doesn't recognize "val1" by itself either if I write "return val1". What's the correct way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can declare a <code>enum</code> in Cython as:</p>
<pre><code>ctypedef enum options: OPT1, OPT2, OPT3
</code></pre>
<p>or</p>
<pre><code>ctypedef enum options:
    OPT1,
    OPT2,
    OPT3
</code></pre>
<p>And and example could be:</p>
<pre><code>def main():
    cdef options test
    test = OPT2
    f(test)

cdef void f(options inp):
    if inp == OPT1:
        print('OPT1')
    elif inp == OPT2:
        print('OPT2')
    elif inp == OPT3:
        print('OPT3')
</code></pre>
<p>When running <code>main()</code> you will see <code>"OPT2"</code> printed. You could pass the variable <code>test</code> to a <code>C</code> or <code>C++</code> function in the same way as shown here for the <code>cdef</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>After fighting this issue for several hours, I finally found a suitable solution! In fact, this is what I would have expected Cython to do for me.</p>
<p>This solution is divided in two components:</p>
<ol>
<li><p>On one side we have a Cython enum. This enum can either be originated by wrapping C/C++ code in an extern block...</p>
<pre><code>cdef extern from "header.hpp":
    enum my_c_enum_type:
        val1 = 0;
        val2 = 1;
        val3 = 2;
</code></pre>
<p>... or directly in Cython.</p>
<pre><code>ctypedef enum my_c_enum_type:
    val1,    #Default value is 0
    val2,    #Default value is 1
    val3     #Default value is 2
</code></pre></li>
<li><p>On the other we have Python. Since Python 3.4, there is a supported class Enum that emulates that functionality (<a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">link to official documentation</a>). Here we should replicate the enum in pure Python:</p>
<pre><code>from enum import Enum
class my_p_enum_type(Enum):
    UNDEFINED=0
    INTEGER=1
    FRACTIONAL=2
    BATCH=3
</code></pre></li>
</ol>
<p>Now we have a fancy python class with the same functionality. In order to interact between the Python and Cython worlds we use:</p>
<pre><code># from Python to Cython
def func(enum_obj):
    if not isinstance(enum_obj, my_p_enum_type):
         raise TypeError
    # Use in a cython function that accepts only my_c_enum_type Cython enum
    myCythonEnumFunc(enum_obj.value)
    ...

# from Cython to Python
def func():
    # a Cython enum
    cdef my_c_enum_type a_cython_enum = val1
    # creating a python enum
    return my_p_enum_type(a_cython_enum)
    ...
</code></pre>
<p>This solution translates Cython/C enums (which in Python are mere ints) into a proper Python Enum class with the same characteristics, and translates the value inside a Python Enum object into the original Cython class. The downside is that you still need to maintain two different pieces of code with the same structure... but you do that all the time with Cython!</p>
</div>
<span class="comment-copy">Did you check the answer below?</span>
<span class="comment-copy">Note that the OP asks about <code>enum class</code> not <code>enum</code>.</span>
