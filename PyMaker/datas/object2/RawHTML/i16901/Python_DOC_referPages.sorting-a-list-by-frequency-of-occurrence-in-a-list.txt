<div class="post-text" itemprop="text">
<p>I have a list of integers(or could be even strings), which I would like to sort by the frequency of occurrences in Python, for instance: </p>
<pre><code>a = [1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5]
</code></pre>
<p>Here the element <code>5</code> appears 4 times in the list, <code>4</code> appears 3 times. So the output sorted list would be :</p>
<pre><code>result = [5, 5, 5, 5, 3, 3, 3, 4, 4, 4, 1, 1, 2]
</code></pre>
<p>I tried using <code>a.count()</code>, but it gives the number of occurrence of the element.
I would like to sort it. Any idea how to do it ?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter
print [item for items, c in Counter(a).most_common() for item in [items] * c]
# [5, 5, 5, 5, 3, 3, 3, 4, 4, 4, 1, 1, 2]
</code></pre>
<p>Or even better (efficient) implementation</p>
<pre><code>from collections import Counter
from itertools import repeat, chain
print list(chain.from_iterable(repeat(i, c) for i,c in Counter(a).most_common()))
# [5, 5, 5, 5, 3, 3, 3, 4, 4, 4, 1, 1, 2]
</code></pre>
<p>Or</p>
<pre><code>from collections import Counter
print sorted(a, key=Counter(a).get, reverse=True)
# [5, 5, 5, 5, 3, 3, 3, 4, 4, 4, 1, 1, 2]
</code></pre>
<p>If you prefer in-place sort</p>
<pre><code>a.sort(key=Counter(a).get, reverse=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [15]: a = [1,1,2,3,3,3,4,4,4,5,5,5,5]

In [16]: counts = collections.Counter(a)

In [17]: list(itertools.chain.from_iterable([[k for _ in range(counts[k])] for k in sorted(counts, key=counts.__getitem__, reverse=True)]))
Out[17]: [5, 5, 5, 5, 3, 3, 3, 4, 4, 4, 1, 1, 2]
</code></pre>
<p>Alternatively:</p>
<pre><code>answer = []
for k in sorted(counts, key=counts.__getitem__, reverse=True):
    answer.extend([k for _ in range(counts[k])])
</code></pre>
<p>Of course, <code>[k for _ in range(counts[k])]</code> can be replaced with <code>[k]*counts[k]</code>.<br/>
So line 17 becomes </p>
<pre><code>list(itertools.chain.from_iterable([[k]*counts[k] for k in sorted(counts, key=counts.__getitem__, reverse=True)]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using Python 3.3 and the built in <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow">sorted</a> function, with the count as the key:</p>
<pre><code>&gt;&gt;&gt; a = [1,1,2,3,3,3,4,4,4,5,5,5,5]
&gt;&gt;&gt; sorted(a,key=a.count)
[2, 1, 1, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5]
&gt;&gt;&gt; sorted(a,key=a.count,reverse=True)
[5, 5, 5, 5, 3, 3, 3, 4, 4, 4, 1, 1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not interesting way...</p>
<pre><code>a = [1,1,2,3,3,3,4,4,4,5,5,5,5]

from collections import Counter
result = []
for v, times in sorted(Counter(a).iteritems(), key=lambda x: x[1], reverse=True):
    result += [v] * times
</code></pre>
<p>One liner:</p>
<pre><code>reduce(lambda a, b: a + [b[0]] * b[1], sorted(Counter(a).iteritems(), key=lambda x: x[1], reverse=True), [])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you happen to be using numpy already, or if using it is an option, here's another alternative:</p>
<pre><code>In [309]: import numpy as np

In [310]: a = [1, 2, 3, 3, 1, 3, 5, 4, 4, 4, 5, 5, 5]

In [311]: vals, counts = np.unique(a, return_counts=True)

In [312]: order = np.argsort(counts)[::-1]

In [313]: np.repeat(vals[order], counts[order])
Out[313]: array([5, 5, 5, 5, 4, 4, 4, 3, 3, 3, 1, 1, 2])
</code></pre>
<p>That result is a numpy array.  If you want to end up with a Python list, call the array's <code>tolist()</code> method:</p>
<pre><code>In [314]: np.repeat(vals[order], counts[order]).tolist()
Out[314]: [5, 5, 5, 5, 4, 4, 4, 3, 3, 3, 1, 1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Occurrence in array and within a sets of equal size:</p>
<pre><code>rev=True

arr = [6, 6, 5, 2, 9, 2, 5, 9, 2, 5, 6, 5, 4, 6, 9, 1, 2, 3, 4, 7 ,8 ,8, 8, 2]
print arr

arr.sort(reverse=rev)

ARR = {}
for n in arr:
  if n not in ARR:
    ARR[n] = 0
  ARR[n] += 1

arr=[]
for k,v in sorted(ARR.iteritems(), key=lambda (k,v): (v,k), reverse=rev):
  arr.extend([k]*v)
print arr
</code></pre>
<h3>Results:</h3>
<pre><code>[6, 6, 5, 2, 9, 2, 5, 9, 2, 5, 6, 5, 4, 6, 9, 1, 2, 3, 4, 7, 8, 8, 8, 2]
[2, 2, 2, 2, 2, 6, 6, 6, 6, 5, 5, 5, 5, 9, 9, 9, 8, 8, 8, 4, 4, 7, 3, 1]
</code></pre>
</div>
<span class="comment-copy">Does the order of <code>4</code> and <code>3</code> in the output matter?</span>
<span class="comment-copy">NO, It does not matter really, if it makes it more simpler</span>
<span class="comment-copy">Cool, otherwise I have to sort it again :-)</span>
<span class="comment-copy">Thank you so much for your help.</span>
<span class="comment-copy"><code>[k]*counts[k]</code>??</span>
<span class="comment-copy">@Aशwiniचhaudhary: I considered that, but it might not work out exceptionally well, if the elements are not primitive types. References, and all...</span>
<span class="comment-copy">If you are worried about mutable types then <code>Counter</code> won't even work at the first place.</span>
<span class="comment-copy">Fair point. Touché!</span>
<span class="comment-copy"><code>list.count</code> will make it very inefficient I believe.</span>
<span class="comment-copy">@thefourtheye I'd have to time it to be sure, but that sounds right. Admittedly, this is very safe for a small list like the example.</span>
