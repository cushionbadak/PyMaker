<div class="post-text" itemprop="text">
<p>I am trying to write a piece of code where I know that in my combination of 4 numbers, 3 are in the correct position. I would like to iterate over all 6 possible numbers and create all possible iterations.
Essentially, if I have a combination [1,2,3,4] and I know 3 are in the correct position, I would like to generate:
[2,2,3,4],[3,2,3,4],[4,2,3,4],[5,2,3,4],[6,2,3,4],[1,1,3,4],[1,3,3,4],[1,4,3,4],[1,5,3,4],[1,6,3,4],[1,2,1,4],etc...</p>
<p>I have this piece of code which generates all possible iterations to be [6,6,6,6]</p>
<pre><code>def create_guess_list(guess):
guess_list = []
for i in range(0,4):
    for j in range(1,7):
        temp = guess
        if j != temp[i]:
            temp[i] = j
            guess_list.append(temp)
return guess_list
</code></pre>
<p>I am assuming that every time I create a new combination, even though I am putting it in a temporary list, Python is overwriting it.
How can I avoid this without creating a blank list each time and appending as I go?
(or is this the only way?)</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to copy a list is to use a full slice. Change this line</p>
<pre><code>temp = guess
</code></pre>
<p>To this</p>
<pre><code>temp = guess[:]
</code></pre>
<p>If you don't make a copy of the list, either by using a slice or some other way, then you've got two variables pointing to the same list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> to generate all possible combinations, and then filter those out where not enough numbers are matching:</p>
<pre><code>import itertools
def guess_list (guess, correct):
    for combination in itertools.product(range(1, 7), repeat=4):
        if sum(c == g for c, g in zip(combination, guess)) == correct:
            yield combination
</code></pre>
<pre><code>&gt;&gt;&gt; list(guess_list([1, 2, 3, 4], 3))
[(1, 1, 3, 4), (1, 2, 1, 4), (1, 2, 2, 4), (1, 2, 3, 1), (1, 2, 3, 2), (1, 2, 3, 3), (1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 3, 6), (1, 2, 4, 4), (1, 2, 5, 4), (1, 2, 6, 4), (1, 3, 3, 4), (1, 4, 3, 4), (1, 5, 3, 4), (1, 6, 3, 4), (2, 2, 3, 4), (3, 2, 3, 4), (4, 2, 3, 4), (5, 2, 3, 4), (6, 2, 3, 4)]
</code></pre>
<p>As for your solution, the problem with it is that you are modifying the original guess. At <code>temp = guess</code> you are only copying a reference to the guess list. So both variables <code>guess</code> and <code>temp</code> reference the same list object. Then later, when you do <code>temp[i] = j</code>, you are changing an item of that list object which both variables reference. So you are changing your original guess there (making all further inspections of <code>guess</code> incorrect). For the same reason, you also keep appending the same object to the <code>guess_list</code> list. To fix this, you have to create a copy of your <code>guess</code> list instead; you can do that using <code>temp = guess[:]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>temp = guess</code> is assigning the content of <code>guess</code> to a variable called <code>temp</code> (both variables are pointing to the same object).</p>
<p>In order to create an independent copy you should create a new list from <code>guess</code> like so:</p>
<pre><code>temp = list(guess)  # or temp = guess[:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import combinations, product

ALPHABET = [1, 2, 3, 4, 5, 6]
SAME = {a:[a] for a in ALPHABET}
DIFF = {a:[x for x in ALPHABET if x != a] for a in ALPHABET}

def all_possible_solutions(guess, num_right):
    # how many items need to be substituted?
    width = len(guess)
    num_wrong = width - num_right

    # which items should be substituted?
    for replace_at in combinations(range(width), num_wrong):

        # figure out new basis
        basis = [
            DIFF[g] if index in replace_at else SAME[g]
            for index,g in enumerate(guess)
        ]

        # return combinations from new basis
        for combo in product(*basis):
            yield combo
</code></pre>
</div>
<span class="comment-copy">@pinkfloydx33 Think <a href="http://en.wikipedia.org/wiki/Mastermind_(board_game)" rel="nofollow noreferrer">MasterMind</a>. OP knows three of the four are correct, but doesn't know which.</span>
<span class="comment-copy">Ok I see. I read it as though the set of numbers is the right set of numbers just wrong positions, which didn't make sense if you were going to say that three were in the right place but the fourth wasn't. I had to read it like five more times before it clicked.</span>
<span class="comment-copy">You'll probably want to do <code>... == correct</code> rather than <code>&gt;=</code>. Otherwise you include the original guess in there.</span>
<span class="comment-copy">@RobWatts Yeah, youâ€™re right, thanks</span>
