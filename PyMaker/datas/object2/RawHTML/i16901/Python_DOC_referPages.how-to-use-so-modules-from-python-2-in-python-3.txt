<div class="post-text" itemprop="text">
<p>probably my question is obvious but I was not able to find an obvious decision. </p>
<p>There are Python 2.6+ extensions called <strong>audit</strong> and <strong>auparse</strong>. These are dynamical libraries distributed with <strong>audit-libs-python</strong> package:</p>
<pre><code>[vitaly@thermaltake tmp]$ repoquery -lq audit-libs-python
/usr/lib64/python2.7/site-packages/_audit.so
/usr/lib64/python2.7/site-packages/audit.py
/usr/lib64/python2.7/site-packages/audit.pyc
/usr/lib64/python2.7/site-packages/audit.pyo
/usr/lib64/python2.7/site-packages/auparse.so
</code></pre>
<p>I would like to use this extension in the up-to-date Python interpreter because of <a href="https://stackoverflow.com/a/23402745/2361497">suspicions about the incorrect handling of dynamic memory in python 2.6+</a>. For some reason I cannot load them from Python 3.3:</p>
<pre><code>[vitaly@thermaltake ~]$ python3.3
Python 3.3.2 (default, Mar  5 2014, 08:21:05) 
[GCC 4.8.2 20131212 (Red Hat 4.8.2-7)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append("/usr/lib64/python2.7/site-packages/")
&gt;&gt;&gt; import auparse
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: /usr/lib64/python2.7/site-packages/auparse.so: undefined symbol: _Py_ZeroStruct
&gt;&gt;&gt; import audit
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib64/python2.7/site-packages/audit.py", line 28, in &lt;module&gt;
    _audit = swig_import_helper()
  File "/usr/lib64/python2.7/site-packages/audit.py", line 24, in swig_import_helper
    _mod = imp.load_module('_audit', fp, pathname, description)
  File "/usr/lib64/python3.3/imp.py", line 183, in load_module
    return load_dynamic(name, filename, file)
ImportError: /usr/lib64/python2.7/site-packages/_audit.so: undefined symbol: PyInstance_Type
</code></pre>
<p>I would be glad if anyone could clarify the procedure of importing the modules of this kind into the modern Python interpreter. It's hard to believe that backward compatibility between 2nd and 3rd branches was broken in this case too. Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>.so</code> modules have to be compiled for each specific Python version - you can't even reuse an <code>.so</code> module built for Python 2.6 with Python 2.7.</p>
<p>When crossing over to Python 3 it gets worse, <a href="https://docs.python.org/3/howto/cporting.html" rel="nofollow noreferrer">since there are some API changes</a>, and the SO simply won't build unchanged from the .C file (with possible exceptions).</p>
<p>One workaround is to serve the functions you want to use in the 2.6 module with xmlrpc, then call then from a separate Python process runing Python 3.x - that should be the simplest way.</p>
</div>
