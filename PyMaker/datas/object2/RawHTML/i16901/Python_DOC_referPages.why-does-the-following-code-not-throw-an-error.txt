<div class="post-text" itemprop="text">
<p>I am trying to write an abstract class using Python 3 as shown below:</p>
<pre><code>from abc import *


class Base(metaclass=ABCMeta):
    @abstractmethod
    def __init__(self, text=''):
        self._text = text

    @property
    @abstractmethod
    def text(self):
        return self._text

    @text.setter
    @abstractmethod
    def text(self, text):
        self._text = text


class SubClass(Base):

    def __init__(self, text):
        super().__init__(text)

    @property
    def text(self):
        return super().text

q = SubClass("Test")
</code></pre>
<p>When I run the file the interpreter does not complain that text.setter is not implemented. Why is there no error?</p>
</div>
<div class="post-text" itemprop="text">
<p>Both the getter and setter for the <code>text</code> property in your <code>Base</code> class are named <code>text</code>, so they only appear once in the <code>__abstractmethods__</code> set. When you override the getter in the <code>SubClass</code>, it "counts" as if it had overridden the setter too.</p>
<p>Unfortunately, while a getter-only abstract <code>property</code> works fine, there doesn't really seem to be an elegant way to have a property with both an abstract getter and setter. If you use a single name, then only that name needs to be overridden (and the override need not have a setter, as you've discovered). If you use separate names for those functions and then use <code>text = property(_text_get, _text_set)</code>, the concrete subclass will need to replace all three things (the getter, setter and the property object itself). A better approach may be to have the property itself be concrete in the <code>Base</code> class, but have it make calls to abstract getter and setter implementation functions, which can be abstract, and which subclasses can easily override:</p>
<pre><code>@abstractmethod
def _text_get_imp(self):
    return self._text

@abstractmethod
    _text_set_imp(self, value):
    self._text = value

@property
def text(self):
    return self._text_get_imp()

@text.setter
def text(self, value)
    self._text_set_imp(value)
</code></pre>
<p><strong>Edit</strong>: After reading the docs today for the (now deprecated) <a href="https://docs.python.org/3/library/abc.html#abc.abstractproperty" rel="nofollow"><code>abc.abstractproperty</code></a>, I think I understand a bit better why there's no error from the read-only property (it's not quite as simple as I made it sound above).</p>
<p>The reason you don't get an error is that your new property has a different implementation of "setting" than the base class. That behavior is to raise an exception, of course, but that is technically a different behavior that overrides the behavior of original setter.</p>
<p>If you had updated the old property by using <code>@Base.text.getter</code> as the decorator for the overridden setter function in <code>SubClass</code> rather than creating a new <code>property</code> completely from scratch, you'd get an error about an abstract method <code>text</code> not being overridden.</p>
</div>
<span class="comment-copy">Which particular version of Python 3 is this?</span>
<span class="comment-copy">Aren't you providing a base implementation with <code>self._text = text</code> in the abstract declaration of text.setter? Inheritance of abstract classes will provide the base implementation to the subclass in the event the subclass does not override it, at least in most OO languages that's how it works.</span>
<span class="comment-copy">@user2357112 It is Python 3.4</span>
<span class="comment-copy">@RyanJ: Ordinarily, everything with <code>abstractmethod</code> on it needs to be overridden to instantiate a class. For example, even though there's a real function with a real implementation under the <code>abstractmethod</code> decorator for <code>__init__</code>, it still needs to be overridden.</span>
<span class="comment-copy">Ah, yes. I popped over to the python documentation for the abc library and indeed this is the case. I don't have a version of python that is that new so I can't test.</span>
