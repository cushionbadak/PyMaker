<div class="post-text" itemprop="text">
<p>I have a list ["Roll_Number","Marks in subjects"]:</p>
<pre><code>list_1=[(1,22),(1,22),(2,29),(2,16),(3,56),(4,32),(4,12)]
</code></pre>
<p>I tried this code in python to get sum of all subjects for each roll_no :</p>
<pre><code> sub_sum = [0] * 4 #Roll No :4
 if i in range(0,len(list1)):
 if k in range(0,5):
    if (list1[i][0]==k):
       sub_sum[k] = list1[i][1] + sub_sum[k]
       i=i+1
    else:
        k=k+1
        break
</code></pre>
<p>Getting an infinite loop.
Expected Result : <code>1:44 , 2:45, 3:56 , 4:44</code>
Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do that as follows:</p>
<pre><code>from collections import defaultdict

a = [(1,22),(1,22),(2,29),(2,16),(3,56),(4,32),(4,12)]

b = defaultdict(lambda: 0)
for i,j in a:
    b[i] += j

&gt;&gt;&gt; print b
{1:44, 2:45, 3:56, 4:44}
</code></pre>
<p><a href="http://repl.it/RqP" rel="nofollow"><h2>DEMO</h2></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Since your list is sorted by first element already, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> for a relatively simple one-line solution:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby as gb
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; 
&gt;&gt;&gt; l = [(1,22),(1,22),(2,29),(2,16),(3,56),(4,32),(4,12)]
&gt;&gt;&gt; 
&gt;&gt;&gt; {a: sum(t[1] for t in b) for a,b in gb(l, itemgetter(0))}
{1: 44, 2: 45, 3: 56, 4: 44}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using defaultdict</p>
<pre><code>&gt;&gt;&gt; list_1=[(1,22),(1,22),(2,29),(2,16),(3,56),(4,32),(4,12)]
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; res = defaultdict(int)
&gt;&gt;&gt; for key, val in list_1:
...   res[key] += val
... 
&gt;&gt;&gt; print res
defaultdict(&lt;type 'int'&gt;, {1: 44, 2: 45, 3: 56, 4: 44})
&gt;&gt;&gt; print dict(res)
{1: 44, 2: 45, 3: 56, 4: 44}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can also use the <code>groupby</code> from <code>itertools</code></p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; result = [(k, sum(r[1] for r in rows)) for k, rows in groupby(list_1, key=itemgetter(0))]
&gt;&gt;&gt; result
[(1, 44), (2, 45), (3, 56), (4, 44)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not the most intuitive </p>
<pre><code>from collections import Counter
from itertools import chain, repeat
Counter(chain.from_iterable(repeat(x, y) for x, y in list_1))
Counter({3: 56, 2: 45, 1: 44, 4: 44})
</code></pre>
</div>
<span class="comment-copy">No you don't. Give us the actual code.</span>
<span class="comment-copy">Use <code>d = defaultdict(lambda: 0)</code> and you won't need the <code>try-except</code>, or <code>b[i] = b.get(i, 0) + j</code> even.</span>
<span class="comment-copy">@ErikAllik, I am a bit busy right now. Please feel free to edit my answer with your suggestions. Thank you very much.</span>
<span class="comment-copy"><code>defaultdict(int)</code> works because <code>int() == 0</code>. Better than a lambda expression.</span>
<span class="comment-copy">Thanks sshashank and Erik, can we further sort this final dictionary "b" by marks I mean the 2d element ?</span>
<span class="comment-copy">what's wrong with defaultdict(int)?</span>
<span class="comment-copy">This is a very wasteful approach. List multiplication is completely unnecessary here. Not to mention nobody will have a clue as to what you're trying to do just by looking at the code.</span>
<span class="comment-copy">@arshajii, it's a lark</span>
<span class="comment-copy">@arshajii, eliminated the list multiplication. As for the readability part granted it's not very readable - but that goes for your groupby solution as well</span>
