<div class="post-text" itemprop="text">
<p>Both my professor and <a href="http://www.secnetix.de/olli/Python/lambda_functions.hawk" rel="nofollow">this guy</a> claim that <code>range</code> creates a list of values. </p>
<blockquote>
<p>"Note: The range function simply returns a list containing the numbers
  from x to y-1. For example, range(5, 10) returns the list [5, 6, 7, 8,
  9]."</p>
</blockquote>
<p>I believe this is to be inaccurate because:</p>
<pre><code>type(range(5, 10))
&lt;class 'range'&gt;
</code></pre>
<p>Furthermore, the only apparent way to access the integers created by <code>range</code> is to iterate through them, which leads me to believe that labeling <code>range</code> as a lists is incorrect.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.x, <a href="https://docs.python.org/2/library/functions.html#range"><code>range</code></a> returns a list, but in Python 3.x <a href="https://docs.python.org/3/library/functions.html#func-range"><code>range</code></a> returns an immutable sequence, of type <a href="https://docs.python.org/3/library/stdtypes.html#range"><code>range</code></a>.</p>
<p><strong>Python 2.x:</strong></p>
<pre><code>&gt;&gt;&gt; type(range(10))
&lt;type 'list'&gt;
&gt;&gt;&gt; type(xrange(10))
&lt;type 'xrange'&gt;
</code></pre>
<p><strong>Python 3.x:</strong></p>
<pre><code>&gt;&gt;&gt; type(range(10))
&lt;class 'range'&gt;
</code></pre>
<p>In Python 2.x, if you want to get an iterable object, like in Python 3.x, you can use <a href="https://docs.python.org/2/library/functions.html#xrange"><code>xrange</code></a> function, which returns an immutable sequence of type <a href="https://docs.python.org/2/library/stdtypes.html#typesseq-xrange"><code>xrange</code></a>.</p>
<p>Advantage of <code>xrange</code> over <code>range</code> in Python 2.x:</p>
<blockquote>
<p>The advantage of <code>xrange()</code> over <code>range()</code> is minimal (since <code>xrange()</code> still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the rangeâ€™s elements are never used (such as when the loop is usually terminated with break). </p>
</blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<p>Furthermore, the only apparent way to access the integers created by <code>range()</code> is to iterate through them, </p>
</blockquote>
<p>Nope. Since <code>range</code> objects in Python 3 are immutable sequences, they support indexing as well. Quoting from the <code>range</code> function documentation,</p>
<blockquote>
<p>Ranges implement all of the common sequence operations except concatenation and repetition</p>
<p>...</p>
<p>Range objects implement the <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence"><code>collections.abc.Sequence</code></a> ABC, and provide features such as containment tests, <strong>element index lookup</strong>, slicing and support for negative indices.</p>
</blockquote>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; range(10, 20)[5]
15
&gt;&gt;&gt; range(10, 20)[2:5]
range(12, 15)
&gt;&gt;&gt; list(range(10, 20)[2:5])
[12, 13, 14]
&gt;&gt;&gt; list(range(10, 20, 2))
[10, 12, 14, 16, 18]
&gt;&gt;&gt; 18 in range(10, 20)
True
&gt;&gt;&gt; 100 in range(10, 20)
False
</code></pre>
<p>All these are possible with that immutable <code>range</code> sequence.</p>
<hr/>
<p>Recently, I faced a problem and I think it would be appropriate to include here. Consider this Python 3.x code</p>
<pre><code>from itertools import islice
numbers = range(100)
items = list(islice(numbers, 10))
while items:
    items = list(islice(numbers, 10))
    print(items)
</code></pre>
<p>One would expect this code to print every ten numbers as a list, till 99. But, it would run infinitely. Can you reason why?</p>
<p><strong>Solution</strong></p>
<blockquote class="spoiler">
<p> Because the <code>range</code> returns an immutable <em>sequence</em>, not an iterator object. So, whenever <code>islice</code> is done on a <code>range</code> object, it always starts from the beginning. Think of it as a drop-in replacement for an immutable list. Now the question comes, how will you fix it? Its simple, you just have to get an iterator out of it. Simply change<br/>
<br/>
<code>numbers = range(100)</code><br/>
<br/>
 to<br/>
<br/>
<code>numbers = iter(range(100))</code><br/>
<br/>
 Now, <code>numbers</code> is an iterator object and it remembers how long it has been iterated before. So, when the <code>islice</code> iterates it, it just starts from the place where it previously ended.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><strong>It depends.</strong></p>
<p>In python-2.x, <code>range</code> actually creates a list (which is also a sequence) whereas <code>xrange</code> creates an <code>xrange</code> object that can be used to iterate through the values.</p>
<p>On the other hand, in python-3.x, <code>range</code> creates an iterable (or more specifically, a sequence)</p>
</div>
<div class="post-text" itemprop="text">
<p>range creates a list if the python version used is 2.x .
In this scenario range is to be used only if its referenced more than once otherwise use xrange which creates a generator there by redusing the memory usage  and sometimes time as it has lazy approach. </p>
<p>xrange is not there in python 3.x rather range stands for what xrange is for python 2.x</p>
<p>refer to question
 <a href="https://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange">What is the difference between range and xrange functions in Python 2.X?</a></p>
</div>
<span class="comment-copy">Your last sentence is incorrect.  <code>range</code> objects implement <code>__getitem__</code>.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/20535342/lazy-evaluation-python">Lazy evaluation python</a></span>
<span class="comment-copy">This question is not aware of the differences between Python 2 and 3, and is <i>not</i> a dupe of the one linked.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/135041/should-you-always-favor-xrange-over-range">Should you always favor xrange() over range()?</a></span>
<span class="comment-copy">It returns a <code>range</code> object that happens to be iterable, but is more than a plain iterator :) (eg: <code>range(1, 100, 17)[3]</code> is perfectly legal)</span>
<span class="comment-copy">@JonClements Thanks, updated the answer with the information about <code>range</code> and <code>xrange</code> objects :-)</span>
<span class="comment-copy">unrelated: <code>x in range(large_number)</code> in Python 3 may use an optimized implementation that doesn't iterate over the range.</span>
<span class="comment-copy">There's no "sort of" about it - <code>range()</code> in python 3 returns an iterable, <code>import collections; isinstance(range(2), collections.Iterable)</code> is True (and to nitpick - don't use the heading syntax for emphasis - if you really need to, bold is more appropriate)</span>
<span class="comment-copy">@dbr, Thank you. Answer updated.</span>
<span class="comment-copy">@dbr: it is a bit more complex than just an iterable, though.</span>
<span class="comment-copy">range object is not an <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">iterator</a>, it is an <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">iterable</a> (more specifically it is a <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer">sequence</a>).</span>
<span class="comment-copy">note: list is a sequence i.e., <code>range()</code> returns sequences on both Python 2 and 3</span>
