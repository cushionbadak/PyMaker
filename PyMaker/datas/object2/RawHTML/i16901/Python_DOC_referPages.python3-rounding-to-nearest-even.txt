<div class="post-text" itemprop="text">
<p>Python3.4 rounds to the nearest even (in the tie-breaker case).</p>
<pre><code>&gt;&gt;&gt; round(1.5)
2
&gt;&gt;&gt; round(2.5)
2
</code></pre>
<p>But it only seems to do this when rounding to an integer.</p>
<pre><code>&gt;&gt;&gt; round(2.75, 1)
2.8
&gt;&gt;&gt; round(2.85, 1)
2.9
</code></pre>
<p>In the final example above, I would have expected 2.8 as the answer when rounding to the nearest even.</p>
<p>Why is there a discrepancy between the two behaviors?</p>
</div>
<div class="post-text" itemprop="text">
<p>Floating point numbers are only <em>approximations</em>; 2.85 cannot be represented <em>exactly</em>:</p>
<pre><code>&gt;&gt;&gt; format(2.85, '.53f')
'2.85000000000000008881784197001252323389053344726562500'
</code></pre>
<p>It is slightly <em>over</em> 2.85.</p>
<p>0.5 and 0.75 <em>can</em> be represented exactly with binary fractions (1/2 and 1/2 + 1/4, respectively).</p>
<p>The <code>round()</code> function <a href="https://docs.python.org/3/library/functions.html#round">documents this explicitly</a>:</p>
<blockquote>
<p><strong>Note</strong>: The behavior of <code>round()</code> for floats can be surprising: for example, <code>round(2.675, 2)</code> gives <code>2.67</code> instead of the expected <code>2.68</code>. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See <a href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues"><em>Floating Point Arithmetic: Issues and Limitations</em></a> for more information.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Martijn got it exactly right. If you want an int-rounder to round to the nearest even, then I would go with this:</p>
<pre><code>def myRound(n):
    answer = round(n)
    if not answer%2:
        return answer
    if abs(answer+1-n) &lt; abs(answer-1-n):
        return answer + 1
    else:
        return answer - 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To answer the title... If you use <code>int(n)</code>, it truncates towards zero. If the result is not even, then you add one:</p>
<pre><code>n = 2.7     # your whatever float
result = int(n)
if not (result &amp; 1):     
    result += 1
</code></pre>
</div>
<span class="comment-copy">there are so many dupes of this that it almost hurts.</span>
<span class="comment-copy">@AirThomas, this is python3 specific in that round() only started rounding to nearest even in python3 AFAIK.</span>
<span class="comment-copy">@AlexCouper: the even-rounding changed your expectation of what would happen, perhaps, but the differences in what you expected and what you observed are still explained by all those duplicates.</span>
<span class="comment-copy">@user3477950 apologies - at the time of writing I couldn't find any, but following your comment I found <a href="http://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior" title="python 3 x rounding behavior">stackoverflow.com/questions/10825926/…</a></span>
<span class="comment-copy">Ah - and therefore round(2.25, 1) does indeed go down to 2.2 as expected.</span>
<span class="comment-copy">And here is a useful tool with detailed explanation of how floating numbers are stored <a href="http://www.h-schmidt.net/FloatConverter/IEEE754.html" rel="nofollow noreferrer">h-schmidt.net/FloatConverter/IEEE754.html</a></span>
<span class="comment-copy">What's the intent of this code?  For an integer input <code>n</code>, it seems to be returning simply <code>n - n % 2</code>.</span>
<span class="comment-copy">@MarkDickinson: That's what it would do for an <code>int</code> input. However, for a float input, it would round to the nearest even int</span>
<span class="comment-copy">I don't think this is what the OP wanted.  (And this doesn't work for negative numbers, by the way:  -1.5 would be 'rounded' to 0.)</span>
<span class="comment-copy">I have never seen someone use <code>&amp; 1</code> instead of <code>% 2</code> to check whether a number is even before... without the surrounding context, I'm not sure I'd even realize that was what you were doing. I'd assume you were doing some kind of flag comparison or something instead.</span>
<span class="comment-copy">@MarkDickinson: Thanks for pointing to the bug ;) You are right that Alex had something different in his head.</span>
<span class="comment-copy">@ArtOfWarfare: I believe that masking the bit is technically less complex (hence faster) than computing the modulo. It is quite common when checking integer for odd/even. As there is no <code>odd</code> function in Python, the two are functionally equivalent. Anyway, I would put a short comment to the real code in both cases ;)</span>
<span class="comment-copy">@pepr They compile to the same thing in languages such as C, and aren't equivalent in overloadable languages such as Python.</span>
