<div class="post-text" itemprop="text">
<p>Today, I saw one statement which didn't throw an exception. Can anyone explain the theory behind it?</p>
<pre><code>&gt;&gt;&gt; x, y = {'a': 2, 'b': 5}
&gt;&gt;&gt; x
'a'
&gt;&gt;&gt; y
'b'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, every <a href="https://docs.python.org/2/glossary.html#iterable">iterable</a> can be unpacked<sup>1</sup>:</p>
<pre><code>&gt;&gt;&gt; x,y,z = [1, 2, 3]  # A list
&gt;&gt;&gt; x,y,z
(1, 2, 3)
&gt;&gt;&gt; x,y,z = 1, 2, 3  # A tuple
&gt;&gt;&gt; x,y,z
(1, 2, 3)
&gt;&gt;&gt; x,y,z = {1:'a', 2:'b', 3:'c'}  # A dictionary
&gt;&gt;&gt; x,y,z
(1, 2, 3)
&gt;&gt;&gt; x,y,z = (a for a in (1, 2, 3))  # A generator
&gt;&gt;&gt; x,y,z
(1, 2, 3)
&gt;&gt;&gt;
</code></pre>
<p>Moreover, because iterating over a dictionary returns only its keys:</p>
<pre><code>&gt;&gt;&gt; for i in {1:'a', 2:'b', 3:'c'}:
...     print i
...
1
2
3
&gt;&gt;&gt;
</code></pre>
<p>unpacking a dictionary (which iterates over it) likewise unpacks only its keys.</p>
<hr/>
<p><sup>1</sup>Actually, I should say that every iterable can be unpacked <em>as long as</em> the names to unpack into equals the length of the iterable:</p>
<pre><code>&gt;&gt;&gt; a,b,c = [1, 2, 3]  # Number of names == len(iterable)
&gt;&gt;&gt;
&gt;&gt;&gt; a,b = [1, 2, 3]  # Too few names
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack (expected 2)
&gt;&gt;&gt;
&gt;&gt;&gt; a,b,c,d = [1, 2, 3]  # Too many names
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: need more than 3 values to unpack
&gt;&gt;&gt;
</code></pre>
<p>But this is only the case for Python 2.x.  In Python 3.x, you have <a href="https://docs.python.org/3/whatsnew/3.0.html#new-syntax">extended iterable unpacking</a>, which allows you to unpack an iterable of any (finite) size into just the names you need:</p>
<pre><code>&gt;&gt;&gt; # Python 3.x interpreter
...
&gt;&gt;&gt; a, *b, c = [1, 2, 3, 4]
&gt;&gt;&gt; a, b, c
(1, [2, 3], 4)
&gt;&gt;&gt;
&gt;&gt;&gt; a, *b = [1, 2, 3, 4]
&gt;&gt;&gt; a, b
(1, [2, 3, 4])
&gt;&gt;&gt;
&gt;&gt;&gt; *a, b, c = [1, 2, 3, 4]
&gt;&gt;&gt; a, b, c
([1, 2], 3, 4)
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Iterating a <code>dict</code> iterates over the keys. Since your dict literal has exactly two keys, you can unpack it into a 2-tuple.</p>
<p>This is probably not a good practice in general, since (before python 3.7, or possibly earlier in some other implementations) dicts are unordered and <code>x == 'b'</code> and <code>y == 'a'</code> would be a perfectly legal outcome of that code.</p>
</div>
<div class="post-text" itemprop="text">
<p>when you iterate over a dictionary, you get its keys</p>
<pre><code>data = {'a': 2, 'b': 5}
for key in data:
    print key
</code></pre>
<p>Unpacking is nothing else than iterating over the object and put the elements in the given variables:</p>
<pre><code>keys = tuple(data) # gives ('a', 'b')
x, y = ('a', 'b')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No rocket science behind it. <code>dict</code> is an iterable, which return the keys in each iteration. <code>tuple()</code> can receive any iterable as argument (as long as they are finite), so:</p>
<pre><code>&gt;&gt;&gt;tuple({'a': 2, 'b': 5})
('a','b')
</code></pre>
<p>Seeing this, is easy to infer that unpacking will work as shown. Moreover, any <em>finite</em> iterable can be unpacked:</p>
<pre><code>&gt;&gt;&gt; i = iter(range(3))
&gt;&gt;&gt; a,b,c = i
&gt;&gt;&gt; a,b,c
(0, 1, 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When in iterable context, dicts are treated as an (unordered) collection of keys, which is what you get when you do <code>list(some_dict)</code>, which is the same as calling <code>keys()</code> on the dict:</p>
<pre><code>&gt;&gt;&gt; d = {'a': 3, 'b': 5}
&gt;&gt;&gt; list(d)
['a', 'b']
&gt;&gt;&gt; d.keys()
['a', 'b']
</code></pre>
<p>However, you can also do more.</p>
<p>You can unpack both a <code>dict</code>'s both keys <em>and</em> values if you turn it into a list of pairs first:</p>
<pre><code>&gt;&gt;&gt; d = {'a': 3, 'b': 5}
&gt;&gt;&gt; d_pairs = d.items()
&gt;&gt;&gt; print d_pairs
[('a', 3), ('b', 5)]
&gt;&gt;&gt; ((k1, v1), (k2, v2)) = d_pairs
&gt;&gt;&gt; print k1, v1, k2, v2
a 3 b 5
</code></pre>
<p>or if you just want the pairs</p>
<pre><code>&gt;&gt;&gt; p1, p2 = d_pairs
&gt;&gt;&gt; print p1, p2
('a', 3) ('b', 5)
</code></pre>
<p>or, say, just the keys:</p>
<pre><code>&gt;&gt;&gt; ((k1, _), (k2, _)) = d_pairs
&gt;&gt;&gt; print k1, k2
a b
</code></pre>
<p>etc.</p>
<p>But of course since dictionaries — and I mean in general, not only in Python — contain their items in an un-ordered manner, <code>items()</code> (in Python) will also return them in a seemingly arbitrary order, and thus there is no way to know which key will be stored in which variable:</p>
<pre><code>&gt;&gt;&gt; ((k1, v1), (k2, v2)) = {'bar': 3, 'foo': 5}.items()
&gt;&gt;&gt; print k1, v1, k2, v2
foo 5 bar 3
</code></pre>
<p>As you see, the order of the pairs returned by <code>items()</code> was reversed in comparison to their definition order.</p>
</div>
<span class="comment-copy">Since it's not mentioned below, I'll say this design decision was likely influenced by utility. When a dict gives you its keys, it is implicitly giving you access to its values. If it returned its values instead, it would be harder to access its keys.</span>
<span class="comment-copy">I guess, that means every iterable can be unpacked?</span>
<span class="comment-copy">Yes, but it doesn't usually make sense for iterables that are mutable (both in length and content) and even less so for unordered iterables. You would have no way of gaurenteeing what key wound up where, and no way of gaurenteing you provided enough variables to unpack to.</span>
<span class="comment-copy">@aIKid, not the infinite ones</span>
<span class="comment-copy">isn't it very confusing, if there is only one key in dict?    x={'a':3},  print x gives {'a': 3} while if we do x,={'a':3} and then print x then result is 'a'.</span>
<span class="comment-copy">@nik_kgp - The first piece of code is assigning the dictionary itself to <code>x</code>.  The second piece however is <i>unpacking</i> the dictionary into <code>x</code>.</span>
<span class="comment-copy">Thanks for mentioning that they are unordered.</span>
<span class="comment-copy">As of Python 3.6, dicts are ordered.</span>
<span class="comment-copy">@geoffspear: it's a language feature in python 3.7+</span>
<span class="comment-copy">similarly we can use <code>&gt;&gt;&gt; list({'a': 2, 'b': 5})</code> :)</span>
<span class="comment-copy">No rocket science :D!+1</span>
<span class="comment-copy">+1 for mentioning the ordering is not necessarily kept intact when unpacking.</span>
