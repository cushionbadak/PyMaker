<div class="post-text" itemprop="text">
<p>In Python 3.3 a <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap"><code>ChainMap</code></a> class was added to the <a href="https://docs.python.org/3/library/collections.html"><code>collections</code></a> module:</p>
<blockquote>
<p>A ChainMap class is provided for quickly linking a number of mappings
  so they can be treated as a single unit. It is often much faster than
  creating a new dictionary and running multiple update() calls.</p>
</blockquote>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; from collections import ChainMap
&gt;&gt;&gt; x = {'a': 1, 'b': 2}
&gt;&gt;&gt; y = {'b': 10, 'c': 11}
&gt;&gt;&gt; z = ChainMap(y, x)
&gt;&gt;&gt; for k, v in z.items():
        print(k, v)
a 1
c 11
b 10
</code></pre>
<p>It was motivated by <a href="http://bugs.python.org/issue11089">this issue</a> and made public by <a href="http://bugs.python.org/issue11297">this one</a> (no <code>PEP</code> was created).</p>
<p>As far as I understand, it is an alternative to having an extra dictionary and maintaining it with <a href="https://docs.python.org/3/library/stdtypes.html#dict.update"><code>update()</code></a>s.</p>
<p>The questions are:</p>
<ul>
<li>What use cases does <code>ChainMap</code> cover?</li>
<li>Are there any real world examples of <code>ChainMap</code>? </li>
<li>Is it used in third-party libraries that switched to python3?</li>
</ul>
<p>Bonus question: is there a way to use it on Python2.x?</p>
<hr/>
<p>I've heard about it in <a href="https://www.youtube.com/watch?v=OSGv2VnC0go"><code>Transforming Code into Beautiful, Idiomatic Python</code></a> PyCon talk by Raymond Hettinger and I'd like to add it to my toolkit, but I lack in understanding when should I use it. </p>
</div>
<div class="post-text" itemprop="text">
<p>I like @b4hand's examples, and indeed I have used in the past ChainMap-like structures (but not ChainMap itself) for the two purposes he mentions: multi-layered configuration overrides, and variable stack/scope emulation.</p>
<p>I'd like to point out two other motivations/advantages/differences of <code>ChainMap</code>, compared to using a dict-update loop, thus only storing the "final" version":</p>
<ol>
<li><p><strong>More information:</strong> since a ChainMap structure is "layered", it supports answering question like: Am I getting the "default" value, or an overridden one? What is the original ("default") value? At what level did the value get overridden (borrowing @b4hand's config example: user-config or command-line-overrides)? Using a simple dict, the information needed for answering these questions is already lost.</p></li>
<li><p><strong>Speed tradeoff:</strong> suppose you have <code>N</code> layers and at most <code>M</code> keys in each, constructing a ChainMap takes <code>O(N)</code> and each lookup <code>O(N)</code> worst-case[*], while construction of a dict using an update-loop takes <code>O(NM)</code> and each lookup <code>O(1)</code>. This means that if you construct often and only perform a few lookups each time, or if <code>M</code> is big, ChainMap's lazy-construction approach works in your favor.</p></li>
</ol>
<p>[*] The analysis in (2) assumes dict-access is <code>O(1)</code>, when in fact it is <code>O(1)</code> on average, and <code>O(M)</code> worst case. See more details <a href="https://wiki.python.org/moin/TimeComplexity#dict" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I could see using <code>ChainMap</code> for a configuration object where you have multiple scopes of configuration like command line options, a user configuration file, and a system configuration file. Since lookups are ordered by the order in the constructor argument, you can override settings at lower scopes. I've not personally used or seen <code>ChainMap</code> used, but that's not surprising since it is a fairly recent addition to the standard library.</p>
<p>It might also be useful for emulating stack frames where you push and pop variable bindings if you were trying to implement a lexical scope yourself.</p>
<p>The <a href="https://docs.python.org/3.4/library/collections.html#chainmap-objects" rel="noreferrer">standard library docs for ChainMap</a> give several examples and links to similar implementations in third-party libraries. Specifically, it names Djangoâ€™s <a href="http://code.djangoproject.com/browser/django/trunk/django/template/context.py" rel="noreferrer">Context class</a> and Enthought's <a href="https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py" rel="noreferrer">MultiContext class</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll take a crack at this:</p>
<p>Chainmap looks like a very just-so kind of abstraction.  It's a good solution for a very specialized kind of problem.  I propose this use case. </p>
<p>If you have:</p>
<ol>
<li>multiple mappings (e.g, dicts)</li>
<li>some duplication of keys in those mappings (same key can appear in multiple mappings, but not the case that all keys appear in all mappings)</li>
<li>a consuming application which wishes to access the value of a key in the "highest priority" mapping where there is a total ordering over all the mappings for any given key (that is, mappings may have equal priority, but only if it is known that there are no duplications of key within those mappings) (In the Python application, packages can live in  the same directory (same priority) but must have different names, so, by definition, the symbol names in that directory cannot be duplicates.)</li>
<li>the consuming application does not need to change the value of a key</li>
<li>while at the same time the mappings must maintain their independent identity and can be changed asynchronously by an external force</li>
<li>and the mappings are big enough, expensive enough to access, or change often enough between application accesses, that the cost of computing the projection (3) each time your app needs it is a significant performance concern for your application...</li>
</ol>
<p>Then, 
you might consider using a chainmap to create a view over the collection of mappings. </p>
<p>But this is all after-the-fact justification.  The Python guys had a problem, came up with a good solution in the context of their code, then did some extra work to abstract their solution so we could use it if we choose.  More power to them.  But whether it's appropriate for your problem is up to you to decide.</p>
</div>
<div class="post-text" itemprop="text">
<p>To imperfectly answer your:</p>
<blockquote>
<p>Bonus question: is there a way to use it on Python2.x?</p>
</blockquote>
<pre><code>from ConfigParser import _Chainmap as ChainMap
</code></pre>
<p>However keep in mind that this isn't a real <code>ChainMap</code>, it inherits from <code>DictMixin</code> and only defines:</p>
<pre><code>__init__(self, *maps)
__getitem__(self, key)
keys(self)

# And from DictMixin:
__iter__(self)
has_key(self, key)
__contains__(self, key)
iteritems(self)
iterkeys(self)
itervalues(self)
values(self)
items(self)
clear(self)
setdefault(self, key, default=None)
pop(self, key, *args)
popitem(self)
update(self, other=None, **kwargs)
get(self, key, default=None)
__repr__(self)
__cmp__(self, other)
__len__(self)
</code></pre>
<p>Its implementation also doesn't seem particularly efficient.</p>
</div>
<span class="comment-copy">Real-world use-case: the GET and POST parameter mappings in a web framework, providing a combined view on two distinct and separate dictionaries.</span>
<span class="comment-copy">As for using it in 2.x, the <a href="http://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py" rel="nofollow noreferrer">source code</a> looks like it could possibly Just Work, though I haven't tried</span>
<span class="comment-copy">FWIW, there is a precursor already in Python2.7:  <code>from ConfigParser import _ChainMap as ChainMap</code>.</span>
<span class="comment-copy">@RaymondHettinger thank you for the nice and useful comments and for the <code>ChainMap</code> itself. You could have made a good answer out of the chain of comments :)</span>
<span class="comment-copy">if you want to import in 2.7 as Raymond suggests, it's actually <code>_Chainmap</code> (note the capitalization of m)</span>
<span class="comment-copy">+1 This is a reasonable comparison.  It would by nice to have some analogies to other technologies.  For example, operating system command lines have a notion of a path which is essentially a chain of directory lookups until a match is found.  In Python, that would be modeled with a ChainMap.</span>
<span class="comment-copy">+1 This is a nice answer that covers the alternative implementations and links to the multiple examples of chained name spaces mentioned in the docs.</span>
<span class="comment-copy">Chainmap is useful where all keys appear in all mappings, for example if you want to push and pop versions of the mapping.</span>
<span class="comment-copy">Fair enough, though if all your dicts have all the same keys, you can probably just create a new single dict with updated values faster.</span>
<span class="comment-copy">Yes it would be faster, but it wouldn't support pop/push functionality.</span>
