<div class="post-text" itemprop="text">
<p>Is there a way to make argparse recognize anything between two quotes as a single argument? It seems to keep seeing the dashes and assuming that it's the start of a new option</p>
<p>I have something like:</p>
<pre><code>mainparser = argparse.ArgumentParser()
subparsers = mainparser.add_subparsers(dest='subcommand')
parser = subparsers.add_parser('queue')
parser.add_argument('-env', '--extraEnvVars', type=str,
                        help='String of extra arguments to be passed to model.')
...other arguments added to parser...
</code></pre>
<p>But when I run:</p>
<pre><code>python Application.py queue -env "-s WHATEVER -e COOL STUFF"
</code></pre>
<p>It gives me:</p>
<pre><code>Application.py queue: error: argument -env/--extraEnvVars: expected one argument
</code></pre>
<p>If I leave off the first dash, it works totally fine, but it's kind of crucial that I be able to pass in a string with dashes in it. I've tried escaping it with \ , which causes it to succeed but adds the \ to the argument string Does anyone know how to get around this? This happens whether or not -s is an argument in parser.</p>
<p>EDIT: I'm using Python 2.7.</p>
<p>EDIT2: </p>
<pre><code>python Application.py -env " -env"
</code></pre>
<p>works perfectly fine, but</p>
<pre><code>python Application.py -env "-env"
</code></pre>
<p>does not.</p>
<p>EDIT3: Looks like this is actually a bug that's being debated already: <a href="http://www.gossamer-threads.com/lists/python/bugs/89529">http://www.gossamer-threads.com/lists/python/bugs/89529</a>, <a href="http://python.6.x6.nabble.com/issue9334-argparse-does-not-accept-options-taking-arguments-beginning-with-dash-regression-from-optp-td578790.html">http://python.6.x6.nabble.com/issue9334-argparse-does-not-accept-options-taking-arguments-beginning-with-dash-regression-from-optp-td578790.html</a>. It's only in 2.7 and not in optparse. </p>
<p>EDIT4: The current open bug report is: <a href="http://bugs.python.org/issue9334">http://bugs.python.org/issue9334</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can start the argument with a space <code>python tst.py -e ' -e blah'</code> as a very simple workaround.  Simply <code>lstrip()</code> the option to put it back to normal, if you like.</p>
<p>Or, if the first "sub-argument" is not also a valid argument to the original function then you shouldn't need to do anything at all.  That is, the only reason that <code>python tst.py -e '-s hi -e blah'</code> doesn't work is because <code>-s</code> is a valid option to <code>tst.py</code>.</p>
<p>Also, the <a href="http://docs.python.org/2.7/library/optparse.html" rel="noreferrer">optparse</a> module, now deprecated, works without any issue.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated answer:</strong></p>
<p>You can put an equals sign when you call it:</p>
<pre><code>python Application.py -env="-env"
</code></pre>
<hr/>
<p><strong>Original answer:</strong></p>
<p>I too have had troubles doing what you are trying to do, but there is a workaround build into argparse, which is the <a href="http://docs.python.org/3.4/library/argparse.html#partial-parsing" rel="noreferrer">parse_known_args</a> method.  This will let all arguments that you haven't defined pass through the parser with the assumption that you would use them for a subprocess. The drawbacks are that you won't get error reporting with bad arguments, and you will have to make sure that there is no collision between your options and your subprocess's options.</p>
<p>Another option could be to force the user's to use a plus instead of a minus:</p>
<pre><code>python Application.py -e "+s WHATEVER +e COOL STUFF"
</code></pre>
<p>and then you change the '+' to '-' in post processing before passing to your subprocess.</p>
</div>
<div class="post-text" itemprop="text">
<p>This issue is discussed in depth in <a href="http://bugs.python.org/issue9334" rel="nofollow noreferrer">http://bugs.python.org/issue9334</a>.  Most of the activity was in 2011.  I added a patch last year, but there's quite a backlog of <code>argparse</code> patches.  </p>
<p>At issue is the potential ambiguity in a string like <code>'--env'</code>, or <code>"-s WHATEVER -e COOL STUFF"</code> when it follows an option that takes an argument.  </p>
<p><code>optparse</code> does a simple left to right parse.  The first <code>--env</code> is an option flag that takes one argument, so it consumes the next, regardless of what it looks like.  <code>argparse</code>, on the other hand, loops through the strings twice.  First it categorizes them as 'O' or 'A' (option flag or argument).  On the second loop it consumes them, using a <code>re</code> like pattern matching to handle variable <code>nargs</code> values.  In this case it looks like we have <code>OO</code>, two flags and no arguments.</p>
<p>The solution when using <code>argparse</code> is to make sure an argument string will not be confused for an option flag.  Possibilities that have been shown here (and in the bug issue) include:</p>
<pre><code>--env="--env"  # clearly defines the argument.

--env " --env"  # other non - character
--env "--env "  # space after

--env "--env one two"  # but not '--env "-env one two"'
</code></pre>
<p>By itself <code>'--env'</code> looks like a flag (even when quoted, see <code>sys.argv</code>), but when followed by other strings it does not.  But <code>"-env one two"</code> has problems because it can be parsed as <code>['-e','nv one two']</code>, a `'-e' flag followed by a string (or even more options).</p>
<p><code>--</code> and <code>nargs=argparse.PARSER</code> can also be used to force <code>argparse</code> to view all following strings as arguments.  But they only work at the end of argument lists.</p>
<p>There is a proposed patch in issue9334 to add a <code>args_default_to_positional=True</code> mode. In this mode, the parser only classifies strings as option flags if it can clearly match them with defined arguments. Thus '--one' in '--env --one' would be classed as as an argument.  But the second '--env' in '--env --env' would still be classed as an option flag. </p>
<hr/>
<p>Expanding on the related case in</p>
<p><a href="https://stackoverflow.com/questions/45541581/using-argparse-with-argument-values-that-begin-with-a-dash">Using argparse with argument values that begin with a dash ("-")</a></p>
<pre><code>parser = argparse.ArgumentParser(prog="PROG")
parser.add_argument("-f", "--force", default=False, action="store_true")
parser.add_argument("-e", "--extra")
args = parser.parse_args()
print(args)
</code></pre>
<p>produces</p>
<pre><code>1513:~/mypy$ python3 stack16174992.py --extra "--foo one"
Namespace(extra='--foo one', force=False)
1513:~/mypy$ python3 stack16174992.py --extra "-foo one"
usage: PROG [-h] [-f] [-e EXTRA]
PROG: error: argument -e/--extra: expected one argument
1513:~/mypy$ python3 stack16174992.py --extra "-bar one"
Namespace(extra='-bar one', force=False)
1514:~/mypy$ python3 stack16174992.py -fe one
Namespace(extra='one', force=True)
</code></pre>
<p>The "-foo one" case fails because the <code>-foo</code> is interpreted as the <code>-f</code> flag plus unspecified extras.  This is the same action that allows <code>-fe</code> to be interpreted as <code>['-f','-e']</code>.</p>
<p>If I change the <code>nargs</code> to <code>REMAINDER</code> (not <code>PARSER</code>), everything after <code>-e</code> is interpreted as arguments for that flag:  </p>
<pre><code>parser.add_argument("-e", "--extra", nargs=argparse.REMAINDER)
</code></pre>
<p>All cases work.  Note the value is a list.  And quotes are not needed:</p>
<pre><code>1518:~/mypy$ python3 stack16174992.py --extra "--foo one"
Namespace(extra=['--foo one'], force=False)
1519:~/mypy$ python3 stack16174992.py --extra "-foo one"
Namespace(extra=['-foo one'], force=False)
1519:~/mypy$ python3 stack16174992.py --extra "-bar one"
Namespace(extra=['-bar one'], force=False)
1519:~/mypy$ python3 stack16174992.py -fe one
Namespace(extra=['one'], force=True)
1520:~/mypy$ python3 stack16174992.py --extra --foo one
Namespace(extra=['--foo', 'one'], force=False)
1521:~/mypy$ python3 stack16174992.py --extra -foo one
Namespace(extra=['-foo', 'one'], force=False)
</code></pre>
<p><code>argparse.REMAINDER</code> is like '*', except it takes everything that follows, whether it looks like a flag or not.  <code>argparse.PARSER</code> is more like '+', in that it expects a <code>positional</code> like argument first.  It's the <code>nargs</code> that <code>subparsers</code> uses.</p>
<p>This uses of <code>REMAINDER</code> is documented, <a href="https://docs.python.org/3/library/argparse.html#nargs" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#nargs</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>paser.add_argument("--argument_name", default=None, nargs=argparse.REMAINDER)
</code></pre>
<blockquote>
<blockquote>
<p>python_file.py --argument_name "--abc=10 -a=1 -b=2 cdef"</p>
</blockquote>
</blockquote>
<p>Note: the argument values have to be passed only within double quotes and this doesn't work with single quotes</p>
</div>
<span class="comment-copy">What version of Python are you using?</span>
<span class="comment-copy">I'm using Python 2.7.</span>
<span class="comment-copy">This works fine for me on Python 2.7. Do you have any <i>other</i> arguments configured?</span>
<span class="comment-copy">Yes, a number of them. Also, -e is the argument of one of the subparsers of my program. I'll post a more complete code snippet to make it clearer.</span>
<span class="comment-copy">Hm...pretty sure. All of my other options work fine, and extraEnvVars does what it's supposed to do as long as the quoted string doesn't start with a dash.  For example, python Application.py queue -env " -env" works fine.</span>
<span class="comment-copy">I don't think it happens because -s is a valid option to the subparser. I tried it with           python Application.py queue -e "-notarealoption"  and got the same error.   I like using lstrip a little better than replace + with - like SethMMorton suggested though, but it really seems like there should be a way to quote a string such that nothing inside it is replaced/altered/read by argparse.</span>
<span class="comment-copy">Oh really?  I had just based that supposition off my short testing right now.  I made a script that took one argument, <code>-a</code>, and simply sent it <code>-a '-b hello'</code> and it worked just fine.  But I am using a different version of Python, I guess.</span>
<span class="comment-copy">I edited my original question. Apparently this is a known bug in argparse in &gt;2.7 :(. I ended up altering sys.argv before I called parser.parse_args() to add a dummy character to the beginning of the -env option, and stripping it off afterwards. It's hacky and unpythonic as hell but I finally got what I wanted.</span>
<span class="comment-copy">I had success using a string in quotes that begins with a space.  So my parser failed on an argument multi-value input of <code>-10:a 10:b</code> but worked for <code>' -10:a' 10:b</code>.</span>
<span class="comment-copy">I don't think parse_known_args helps me. I'm not looking to read the arguments in the quotes at all; I'd like the quoted string to be passed as a single object to -env.  I've considered going the post processing route, and I probably will if I don't get a better answer from here, but it feels hacky, and it means that + characters in the string are changed to -. I'd really like to be able to pass a string with any characters in it at all.</span>
<span class="comment-copy">I see what you are asking... If you want to read in multiple strings without the quotes then use <code>nargs='+'</code> which tells <code>-env</code> to read in one or more strings.</span>
<span class="comment-copy">But I'd also like some of those strings to have dashes in them, even possibly having the same names as the arguments in my subparser. Something like python Application.py queue -env "-env blah" should work.</span>
<span class="comment-copy">I'm sorry, I'm out of ideas.  I've tried to do the same thing but ultimately opted to simply reimplement the options in my parser to pass the the subprocess because I couldn't get what you are trying to do to work.  Good luck!  I hope someone comes up with a good suggestions we can try.</span>
<span class="comment-copy">@sfendel Try using an equals sign: <code>python Application.py -env="-env"</code></span>
<span class="comment-copy">Thank you very much: <code>nargs=argparse.PARSER</code> helped me.</span>
<span class="comment-copy">I'm not quite sure what's changed, but now <code>python Application.py queue -env "-s WHATEVER -e COOL STUFF"</code> works.  <code>queue -env "-foo"</code> still raises the error, because the standalone '-foo' (or '--foo') is still interpreted as a flag.  The spaces after the apprent flag do make a difference.</span>
