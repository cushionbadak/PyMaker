<div class="post-text" itemprop="text">
<p>Simple Python question, but I'm scratching my head over the answer!</p>
<p>I have an array of strings of arbitrary length called <code>path</code>, like this:</p>
<pre><code>path = ['country', 'city', 'items']
</code></pre>
<p>I also have a dictionary, <code>data</code>, and a string, <code>unwanted_property</code>. I know that the dictionary is of arbitrary depth and is dictionaries all the way down, with the exception of the <code>items</code> property, which is always an array. </p>
<p>[CLARIFICATION: The point of this question is that I don't know what the contents of <code>path</code> will be. They could be anything. I also don't know what the dictionary will look like. I need to walk down the dictionary as far as the path indicates, and then delete the unwanted properties from there, without knowing in advance what the path looks like, or how long it will be.]</p>
<p>I want to retrieve the parts of the data object (if any) that matches the <code>path</code>, and then delete the <code>unwanted_property</code> from each. </p>
<p>So in the example above, I would like to retrieve:</p>
<pre><code>data['country']['city']['items']
</code></pre>
<p>and then delete <code>unwanted_property</code> from each of the items in the array. I want to amend the original data, not a copy. (CLARIFICATION: By this I mean, I'd like to end up with the original dict, just minus the unwanted properties.)</p>
<p>How can I do this in code? </p>
<p>I've got this far:</p>
<pre><code>path = ['country', 'city', 'items']
data = {
    'country': {
        'city': {
            'items': [
                {
                    'name': '114th Street',
                    'unwanted_property': 'foo',
                },
                {
                    'name': '8th Avenue',
                    'unwanted_property': 'foo',
                },
            ]
        }
    }
}
for p in path:
    if p == 'items':
        data = [i for i in data[p]]
    else:
        data = data[p]
if isinstance(data, list):
    for d in data:
        del d['unwanted_property']
else:
    del data['unwanted_property']
</code></pre>
<p>The problem is that this doesn't amend the original data. It also relies on <code>items</code> always being the last string in the path, which may not always be the case.</p>
<p>CLARIFICATION: I mean that I'd like to end up with:</p>
<pre><code>{
    'country': {
        'city': {
            'items': [
                {
                    'name': '114th Street'
                },
                {
                    'name': '8th Avenue'
                },
            ]
        }
    }
}
</code></pre>
<p>Whereas what I have available in <code>data</code> is only <code>[{'name': '114th Street'}, {'name': '8th Avenue'}]</code>.</p>
<p>I feel like I need something like XPath for the dictionary. </p>
</div>
<div class="post-text" itemprop="text">
<p>The problem you are overwriting the original <code>data</code> reference. Change your processing code to</p>
<pre>
<b>temp = data</b>
for p in path:
<b>    temp = temp[p]</b>
if isinstance(<b>temp</b>, list):
    for d in <b>temp</b>:
        del d['unwanted_property']
else:
    del <b>temp</b>['unwanted_property']
</pre>
<p>In this version, you set <code>temp</code> to point to the same object that <code>data</code> was referring to. <code>temp</code> is not a copy, so any changes you make to it will be visible in the original object. Then you step <code>temp</code> along itself, while <code>data</code> remains a reference to the root dictionary. When you find the path you are looking for, any changes made via <code>temp</code> will be visible in <code>data</code>.</p>
<p>I also removed the line <code>data = [i for i in data[p]]</code>. It creates an unnecessary copy of the list that you never need, since you are not modifying the references stored in the list, just the contents of the references.</p>
<p>The fact that <code>path</code> is not pre-determined (besides the fact that <code>items</code> is going to be a <code>list</code>) means that you may end up getting a <code>KeyError</code> in the first loop if the path does not exist in your dictionary. You can handle that gracefully be doing something more like:</p>
<pre><code>try:
    temp = data
    for p in path:
        temp = temp[p]
except KeyError:
    print('Path {} not in data'.format(path))
else:
    if isinstance(temp, list):
        for d in temp:
            del d['unwanted_property']
    else:
        del temp['unwanted_property']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem you are facing is that you are re-assigning the <code>data</code> variable to an undesired value. In the body of your <code>for</code> loop you are setting <code>data</code> to the next level down on the tree, for instance given your example <code>data</code> will have the following values (in order), up to when it leaves the <code>for</code> loop:</p>
<pre><code>data == {'country': {'city': {'items': [{'name': '114th Street', 'unwanted_property': 'foo',}, {'name': '8th Avenue', 'unwanted_property': 'foo',},]}}}

data == {'city': {'items': [{'name': '114th Street', 'unwanted_property': 'foo',}, {'name': '8th Avenue', 'unwanted_property': 'foo',},]}}

data == {'items': [{'name': '114th Street', 'unwanted_property': 'foo',}, {'name': '8th Avenue', 'unwanted_property': 'foo',},]}

data == [{'name': '114th Street', 'unwanted_property': 'foo',}, {'name': '8th Avenue', 'unwanted_property': 'foo',},]
</code></pre>
<p>Then when you delete the items from your dictionaries at the end you are left with <code>data</code> being a list of those dictionaries as you have lost the higher parts of the structure. Thus if you make a backup reference for your data you can get the correct output, for example:</p>
<pre><code>path = ['country', 'city', 'items']
data = {
    'country': {
        'city': {
            'items': [
                {
                    'name': '114th Street',
                    'unwanted_property': 'foo',
                },
                {
                    'name': '8th Avenue',
                    'unwanted_property': 'foo',
                },
            ]
        }
    }
}

data_ref = data

for p in path:
    if p == 'items':
        data = [i for i in data[p]]
    else:
        data = data[p]
if isinstance(data, list):
    for d in data:
        del d['unwanted_property']
else:
    del data['unwanted_property']

data = data_ref
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def delKey(your_dict,path):
     if len(path) == 1:
         for item in your_dict:
            del item[path[0]]
         return 
     delKey(  your_dict[path[0]],path[1:])

data
{'country': {'city': {'items': [{'name': '114th Street', 'unwanted_property': 'foo'}, {'name': '8th Avenue', 'unwanted_property': 'foo'}]}}}
path
['country', 'city', 'items', 'unwanted_property']

delKey(data,path)

data
{'country': {'city': {'items': [{'name': '114th Street'}, {'name': '8th Avenue'}]}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to remove the key <code>unwanted_property</code>.</p>
<pre><code>names_list = []

def remove_key_from_items(data):
    for d in data:
        if d != 'items':
            remove_key_from_items(data[d])
        else:
            for item in data[d]:
                unwanted_prop = item.pop('unwanted_property', None)
                names_list.append(item)
</code></pre>
<p>This will remove the key. The second parameter <code>None</code> is returned if the key <code>unwanted_property</code> does not exist.</p>
<p><strong>EDIT</strong>:
You can use <code>pop</code> even without the second parameter. It will raise <code>KeyError</code> if the key does not exist. </p>
<p><strong>EDIT 2</strong>: Updated to recursively go into depth of <code>data</code> dict until it finds the <code>items</code> key, where it pops the <code>unwanted_property</code> as desired and append into the <code>names_list</code> list to get the desired output.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">operator.itemgetter</a> you can compose a function to return the final key's value.</p>
<pre><code>import operator, functools
def compose(*functions):
    '''returns a callable composed of the functions

    compose(f, g, h, k) -&gt; f(g(h(k())))
    '''
    def compose2(f, g):
        return lambda x: f(g(x))
    return functools.reduce(compose2, functions, lambda x: x)

get_items = compose(*[operator.itemgetter(key) for key in path[::-1]])
</code></pre>
<p>Then use it like this:</p>
<pre><code>path = ['country', 'city', 'items']
unwanted_property = 'unwanted_property'

for thing in get_items(data):
    del thing[unwanted_property]
</code></pre>
<p>Of course if the path contains non-existent keys it will throw a KeyError - you probably should account for that:</p>
<pre><code>path = ['country', 'foo', 'items']
get_items = compose(*[operator.itemgetter(key) for key in path[::-1]])
try:
    for thing in get_items(data):
        del thing[unwanted_property]
except KeyError as e:
    print('missing key:', e)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>path = ['country', 'city', 'items']
previous_data = data[path[0]]
previous_key = path[0]
for i in path:
    previous_data = previous_data[i]
    previous_key = i
    if isinstance(previous_data, list):
          for c, b in enumerate(previous_data):
              if "unwanted_property" in b:
                   del previous_data[c]["unwanted_property"]

current_dict = {}
previous_data_dict = {}
for i, a in enumerate(path):
    if i == 0:
        current_dict[a] = data[a]
        previous_data_dict = data[a]
    else:
        if a == previous_key:
            current_dict[a] = previous_data
        else:
            current_dict[a] = previous_data_dict[a]
            previous_data_dict = previous_data_dict[a]
data = current_dict

print(data)
</code></pre>
<p>Output:</p>
<pre><code>{'country': {'city': {'items': [{'name': '114th Street'}, {'name': '8th Avenue'}]}}, 'items': [{'name': '114th Street'}, {'name': '8th Avenue'}], 'city': {'items': [{'name': '114th Street'}, {'name': '8th Avenue'}]}}
</code></pre>
</div>
<span class="comment-copy">When you say it doesn't amend the original data, how do you mean? <code>data</code> is not changed?</span>
<span class="comment-copy">@COLDSPEED I mean that <code>data</code> is now only <code>[{'name': '114th Street'}, {'name': '8th Avenue'}]</code> whereas I'd like it to be the full dict, just minus the unwanted property.</span>
<span class="comment-copy">Assign a new variable <code>temp</code> to <code>data</code>, and then do the exact thing with <code>temp</code>.</span>
<span class="comment-copy">Why you do this: <code>data = [i for i in data[p]]</code></span>
<span class="comment-copy">@COLDSPEED not sure that would help? Then <code>temp</code> would just be an array, and <code>data</code> would be the original dict, and I still wouldn't have the amended dict that I'm trying to end up with.</span>
<span class="comment-copy">Thanks. Sorry, I've explained the question really badly. The point is that I don't know what the contents of <code>path</code> will be in advance.</span>
<span class="comment-copy">@Richard. That's fine. You will get a <code>KeyError</code> the moment <code>temp[p]</code> does not exist.</span>
<span class="comment-copy">@Richard. I have updated with a technique to handle that case explicitly.</span>
<span class="comment-copy">Thanks! So <code>temp</code> now is just <code>[{'name': '114th Street'}, {'name': '8th Avenue'}]</code> - is there some way I can glue this back into the original dictionary? (See the clarification - I want to end up with the original dictionary, just minus the unwanted properties.)</span>
<span class="comment-copy">@Richard <code>temp</code> is <i>not a copy at all</i>.</span>
<span class="comment-copy">Technically you are better off just operating on <code>data_ref</code> instead of <code>data</code>. The problem is that you may end up getting a <code>KeyError</code> in the first loop, in which you have irrecoverably screwed up your data. My answer already suggests doing it that way.</span>
<span class="comment-copy">True, I was simply trying to make minimal modifications to the code present for this example, and was obviously busy writing this when your answer went up, so I didn't notice.</span>
<span class="comment-copy">Thanks. Sorry, I've explained the question really badly. The point is that I don't know what the contents of <code>path</code> will be in advance.</span>
<span class="comment-copy">I have edited the answer, this will pop out the unwanted_property key from any depth you make that for loop dive into.</span>
<span class="comment-copy">This will <i>not</i> do what the question asks at all. It does not go to any depth past the outer dictionary.</span>
<span class="comment-copy">@MadPhysicist I am just rectifying the part where he is trying to delete the key. <code>del d['unwanted_property']</code></span>
<span class="comment-copy">Thanks. Sorry, I've explained the question really badly. The point is that I don't know what the contents of <code>path</code> will be in advance.</span>
<span class="comment-copy">This is not very flexible. Why not get the reference to <code>data["country"]["city"]["items"]</code>, then iterate on the length of that?</span>
<span class="comment-copy">@MadPhysicist Edited.</span>
<span class="comment-copy">You don't know the length/depth of path.</span>
<span class="comment-copy">@MadPhysicist I have fixed my solution.</span>
