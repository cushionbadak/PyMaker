<div class="post-text" itemprop="text">
<p>The following never prints anything in Python 3.6</p>
<pre><code>from itertools import product, count

for f in product(count(), [1,2]): 
    print(f)
</code></pre>
<p>Instead, it just sits there and burns CPU. The issue seems to be that <code>product</code> never returns an iterator if it's over an infinite space because it evaluates the full <code>product</code> first. This is surprising given that the <code>product</code> is supposed to be a generator.</p>
<p>I would have expected this to start counting up (to infinity), something like the behavior of this generator (taken <a href="https://docs.python.org/3.6/library/itertools.html#itertools.product" rel="nofollow noreferrer">directly from the docs</a>):</p>
<pre><code>for tup in ((x,y) for x in count() for y in [1,2]):
    print(tup)
</code></pre>
<p>But whereas my generator starts counting immediately, the one using <code>product</code> never counts at all.</p>
<p>Other tools in <code>itertools</code> do what I'd expect. For example, the following:</p>
<pre><code>for f in takewhile(lambda x: True, count()): 
    print(f)
</code></pre>
<p>will print a stream of numbers because <code>takewhile</code> is lazy.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="noreferrer"><code>itertools.product</code></a> generates its results lazily, but this is not true for the arguments. They are evaluated eagerly. Each iterable argument is first converted to a tuple:</p>
<p>The evaluation of the arguments (not the production of results) is very similar to the Python implementation shown in the docs:</p>
<pre><code>...
pools = [tuple(pool) for pool in args] * repeat
</code></pre>
<p>Whereas, in the <a href="https://github.com/python/cpython/blob/master/Modules/itertoolsmodule.c#L2072" rel="noreferrer">CPython implementation</a>, <code>pools</code> is a tuple of tuples:</p>
<pre class="lang-c prettyprint-override"><code>for (i=0; i &lt; nargs ; ++i) {
     PyObject *item = PyTuple_GET_ITEM(args, i);
     PyObject *pool = PySequence_Tuple(item);   /* here */
     if (pool == NULL)
         goto error;
     PyTuple_SET_ITEM(pools, i, pool);
     indices[i] = 0;
 }
</code></pre>
<p>This is so since <code>product</code> sometimes needs to go over an iterable more than once, which is not possible if the arguments were left as iterators that can only be consumed once.</p>
<p>You practically cannot build a tuple from an <code>itertools.count</code> object. Consider <em>slicing</em> to a reasonable length with <code>itertools.islice</code> before passing to <code>product</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The issue seems to be that product never returns an iterator</p>
</blockquote>
<p>No, <code>product</code> is already "lazy".</p>
<p>The issue is that<code>count()</code> counts to infinity. 
From <code>count</code>'s <a href="https://docs.python.org/3.4/library/itertools.html#itertools.count" rel="nofollow noreferrer">docs</a>:</p>
<p>Equivalent to:</p>
<pre><code>def count(start=0, step=1):
    # count(10) --&gt; 10 11 12 13 14 ...
    # count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...
    n = start
    while True:
        yield n
        n += step
</code></pre>
<p>You code is basically the same as doing:</p>
<pre><code>def count():
    i = 0
    while True:
        yield i
        i += 1

count()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found that </p>
<pre><code>for tup in ((x,y) for x in count() for y in [1,2]):
    print(tup)
</code></pre>
<p>does what I expect. This is odd given that it <a href="https://docs.python.org/3.6/library/itertools.html#itertools.product" rel="nofollow noreferrer">is listed as equivelent in the docs</a>. This seems like a bug in <code>itertools.product</code>, but it seems unlikely given how standard it is.</p>
</div>
<span class="comment-copy">DeepSpace's answer is misleading: product is <i>not</i> lazy, so far as I can tell, given that it takes (I assume) infinite time to return, whereas the equivalent example in the documentation does as I expect.</span>
<span class="comment-copy">This answer saved me from filing a bug report with python, well done.</span>
<span class="comment-copy">I'm confused, shouldn't the loop start counting (to infinity)? The issue is that it doesn't return anything from <code>count</code></span>
<span class="comment-copy">I added an example where I get what I'd expect from a lazy evaluated function.</span>
<span class="comment-copy">@Shep <code>count()</code> is evaluated <i>first</i>, the rest of the code is never reached, so to speak</span>
<span class="comment-copy">Count returns an iterator, evaluating it takes very little time.</span>
<span class="comment-copy">ok, so taking it straight from the docs: "<code>product(A, B)</code> returns the same as <code>((x,y) for x in A for y in B)</code>". I don't find this to be true when <code>A</code> is <code>count()</code></span>
