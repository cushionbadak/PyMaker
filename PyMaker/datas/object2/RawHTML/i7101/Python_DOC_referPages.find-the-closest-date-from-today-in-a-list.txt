<div class="post-text" itemprop="text">
<p>My objective is to get the next closest date (in the future, not past) to today's date from a list. For simplicity's sake, the list (in the format of e.g. <code>2017-01-31</code>; <code>YYYY-MM-DD</code>) is each football game in the season and I am trying to create a script that in part finds the "next" football game. </p>
<p>I have searched the internet and Stack Overflow for answers and found a <a href="https://stackoverflow.com/a/17249420/7801871">promising post</a>, however the solutions provided are using a different format and when I try to tailor it to mine, it trips exceptions. </p>
<p>My logic includes parsing an RSS feed, so I am just going to provide the raw list instead. With this in mind, my simplified code is as follows:</p>
<pre><code>today = str(datetime.date.today())
print(today)

scheduledatelist = ['2017-09-01', '2017-09-09', '2017-09-16', '2017-09-23', '2017-09-30', '2017-10-07', '2017-10-14', '2017-10-21', '2017-10-27', '2017-11-11', '2017-11-18', '2017-11-25']
scheduledatelist = list(reversed(scheduledatelist)) #purpose: to have earliest dates first
</code></pre>
<p>This is my attempt at adapting the previous post's solution (I am not well versed in functional programming, so I may not be adapting it right):</p>
<pre><code>get_datetime = lambda s: datetime.datetime.strptime(s, "%Y-%m-%d")
base = get_datetime(today)
later = filter(lambda d: today(d[0]) &gt; today, scheduledatelist)
closest_date = min(later, key = lambda d: today(d[0]))
print(closest_date)
</code></pre>
<p>Regardless of my attempt (which may not be the best in my situation as it changes the format and I need the end value to still be <code>YYYY-MM-DD</code>), is there an easier way of doing this? I need that next game (closest to today) value as that will continue on to be used in my logic. So to recap, how can I find the closest date in my list, looking toward the future, from today. Thank you for your help!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do:</p>
<pre><code>min(scheduledatelist, key=lambda s: 
                  datetime.datetime.strptime(s, "%Y-%m-%d").date()-datetime.date.today())
</code></pre>
<p>For the single closest date to today. </p>
<p>You can use the same function to sort by distance from today:</p>
<pre><code>sorted(scheduledatelist, key=lambda s: 
              datetime.datetime.strptime(s, "%Y-%m-%d").date()-datetime.date.today())
</code></pre>
<p>And the returned list will be in increasing distance in days from today. Works if the dates are before or after today. </p>
<p>If you want only dates in the future, filter out the dates in the past. Since the date strings are in <a href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow noreferrer">ISO 8601</a> format, you can compare lexically:</p>
<pre><code>min([d for d in scheduledatelist if d&gt;str(datetime.date.today())], key=lambda s: 
              datetime.datetime.strptime(s, "%Y-%m-%d").date()-datetime.date.today())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>first of all let's create <code>datetime.date</code> objects from strings using <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime" rel="nofollow noreferrer"><code>datetime.datetime.strptime</code></a> and <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.date" rel="nofollow noreferrer"><code>datetime.datetime.date</code></a> methods since <code>datetime.date</code> objects are ordered and easier to work with:</p>
<pre><code>date_format = '%Y-%m-%d'
dates = [datetime.datetime.strptime(date_string,
                                    date_format).date()
</code></pre>
<p>then let's filter out dates that take place in future (after today)</p>
<pre><code>today = datetime.date.today()
future_dates = [date
                for date in dates
                if date &gt;= today]
</code></pre>
<p>then we can simply find next closest date using <code>min</code></p>
<pre><code>next_closest_date = min(future_dates)
</code></pre>
<p>which gives us</p>
<pre><code>&gt;&gt;&gt;next_closest_date
2017-09-01
</code></pre>
<p>for given example</p>
<hr/>
<h2>WARNING</h2>
<p>If there is no dates going after today this will cause error like</p>
<pre><code>ValueError: min() arg is an empty sequence
</code></pre>
<p>if it's ok then we can leave it, but if we don't want to get errors â€“ we can specify default value for <code>min</code> in case of empty sequence like</p>
<pre><code>next_closest_date = min(future_dates, default=None)
</code></pre>
<hr/>
<p>Finally we can write a function as follows</p>
<pre><code>import datetime


# `default` value is returned when there is no future date strings found
def get_next_closest_date(date_strings, date_format, default=None):
    today = datetime.date.today()
    dates = [datetime.datetime.strptime(date_string,
                                        date_format).date()
             for date_string in date_strings]
    future_dates = [date
                    for date in dates
                    if date &gt;= today]
    return min(future_dates, default)
</code></pre>
<p>and use it like</p>
<pre><code>scheduledatelist = ['2017-09-01', '2017-09-09', '2017-09-16', '2017-09-23',
                    '2017-09-30', '2017-10-07', '2017-10-14', '2017-10-21',
                    '2017-10-27', '2017-11-11', '2017-11-18', '2017-11-25']
next_closest_date = get_next_closest_date(date_strings=scheduledatelist,
                                          date_format='%Y-%m-%d')
print(next_closest_date)
</code></pre>
</div>
<span class="comment-copy">will the format always be yyyy-mm-dd ?</span>
<span class="comment-copy">Option #3 did the trick, as I am looking for future dates but will definitely keep the others in mind as I'll definitely find a use for them! Thank you so much for your help! One last thing: is it possible for me to hardcode a date into the "today" part so I can make sure everything is sound for developer purposes? If I try to replace datetime.date.today() with 2017-10-27 to test, it obviously doesn't work. Is there an easy and temporary test work around? Thanks!</span>
<span class="comment-copy">Yes. Just use <code>datetime.datetime.strptime('1941-12-07', "%Y-%m-%d").date()</code> or whatever infamous date you want to use. For the filter, just use the actual date string instead of <code>str(datetime.date.today())</code></span>
<span class="comment-copy">Also, if I run the function as is without any modification at all (which is my ultimate intent), I get a "TypeError: unorderable types: NoneType() &lt; list()". I am doing something wrong on my end? Thanks!</span>
<span class="comment-copy">EDIT: So I found that the issue was the default statement in the function return. Without it, it acts as expected. However, I understand why you used this; is there a way that I can resolve this without having to take out the default statement?</span>
<span class="comment-copy">@J.Squillaro: we can filter <code>None</code> values using <code>filter(None, next_closest_dates_with_none_values)</code> or <code>list(filter(None, next_closest_dates_with_none_values))</code> if you need list (since <code>filter</code> creates iterator)</span>
