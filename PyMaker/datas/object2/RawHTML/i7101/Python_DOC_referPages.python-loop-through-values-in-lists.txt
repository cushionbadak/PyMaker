<div class="post-text" itemprop="text">
<p>I have the file 'f1' that looks like this: </p>
<pre><code>ID        X         Y         Z
1   439748.5728 7948406.945 799.391875
1   439767.6229 7948552.995 796.977271
1   439805.7229 7948711.745 819.359365
1   439799.3729 7948851.446 776.425797
2   440764.5749 7948991.146 235.551602
2   440504.2243 7948984.796 326.929119
2   440104.1735 7948984.796 536.893601
2   439742.2228 7949003.846 737.887029
2   438580.1705 7949537.247 196.300929
3   438142.0196 7947340.142 388.997748
3   438599.2205 7947333.792 480.580256
3   439126.2716 7947340.142 669.802869
4   438453.1702 7947594.143 600.856103
4   438294.4199 7947657.643 581.018396
4   438167.4197 7947702.093 515.149846
</code></pre>
<p>I want to run a command (let's say print to make it simpler here) using the x, y, z values for each ID value in the file f1</p>
<pre><code>import numpy as np
f1 = ('file1.txt')


id = np.loadtxt(f1, skiprows=1, usecols=[0])
for i in id:
    x = np.loadtxt(f1, skiprows=1, usecols=[1])
    y = np.loadtxt(f1, skiprows=1, usecols=[2])
    z = np.loadtxt(f1, skiprows=1, usecols=[3])
    print ('The x, y, z lists of id= %g are:' %(i))
    print (x,y,z)
</code></pre>
<p>This code returns x, y and z lists for each line of f1, but I would like that it returns the x, y and z lists for each different value of the ID column. </p>
<p>For instance for ID = 3 it should return:</p>
<pre><code>[438142.0196, 438599.2205, 439126.2716] [7947340.142, 7947333.792, 7947340.142] [388.997748, 480.580256, 669.802869]
</code></pre>
<p>Any help would be very much appreciated !</p>
</div>
<div class="post-text" itemprop="text">
<p>Make a container for your result:</p>
<pre><code>d = {}
</code></pre>
<p>Iterate over the file and split each line to extract the parts you are interested in</p>
<pre><code>id_, *xyz = line.strip().split()
</code></pre>
<p>Then add it to the dictionary</p>
<pre><code>try:
    d[id_].append(xyz)
except KeyError:
    d[id_] = []
    d[id_].append(xyz)
</code></pre>
<hr/>
<p>Using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">collections.defaultdict</a> as the container simplifies the code a bit - you don't need to account for KeyErrors the first time an <code>id_</code> is seen.</p>
<pre><code>d = collections.defaultdict(list)
...
    d[id_].append(xyz)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're able to use Pandas, here's a simple solution:</p>
<pre><code>import pandas as pd
fname = "file1.txt"
df = pd.read_csv("f1.txt", sep=" ") # or substitute with appropriate separator

for i in df.ID.unique():
    print(df.loc[df.ID==i])

   ID            X            Y           Z
0   1  439748.5728  7948406.945  799.391875
1   1  439767.6229  7948552.995  796.977271
2   1  439805.7229  7948711.745  819.359365
3   1  439799.3729  7948851.446  776.425797
   ID            X            Y           Z
4   2  440764.5749  7948991.146  235.551602
5   2  440504.2243  7948984.796  326.929119
6   2  440104.1735  7948984.796  536.893601
7   2  439742.2228  7949003.846  737.887029
8   2  438580.1705  7949537.247  196.300929
    ID            X            Y           Z
9    3  438142.0196  7947340.142  388.997748
10   3  438599.2205  7947333.792  480.580256
11   3  439126.2716  7947340.142  669.802869
    ID            X            Y           Z
12   4  438453.1702  7947594.143  600.856103
13   4  438294.4199  7947657.643  581.018396
14   4  438167.4197  7947702.093  515.149846
</code></pre>
<p>To get precisely the output you specified in OP, use:</p>
<pre><code>for i in df.ID.unique():
    print ('The x, y, z lists of id= %g are:' %(i))
    print(df.loc[df.ID==i, ['X','Y','Z']].values)

The x, y, z lists of id= 1 are:
[[  4.39748573e+05   7.94840695e+06   7.99391875e+02]
 [  4.39767623e+05   7.94855300e+06   7.96977271e+02]
 [  4.39805723e+05   7.94871175e+06   8.19359365e+02]
 [  4.39799373e+05   7.94885145e+06   7.76425797e+02]]
The x, y, z lists of id= 2 are:
[[  4.40764575e+05   7.94899115e+06   2.35551602e+02]
 [  4.40504224e+05   7.94898480e+06   3.26929119e+02]
 [  4.40104173e+05   7.94898480e+06   5.36893601e+02]
 [  4.39742223e+05   7.94900385e+06   7.37887029e+02]
 [  4.38580171e+05   7.94953725e+06   1.96300929e+02]]
The x, y, z lists of id= 3 are:
[[  4.38142020e+05   7.94734014e+06   3.88997748e+02]
 [  4.38599220e+05   7.94733379e+06   4.80580256e+02]
 [  4.39126272e+05   7.94734014e+06   6.69802869e+02]]
The x, y, z lists of id= 4 are:
[[  4.38453170e+05   7.94759414e+06   6.00856103e+02]
 [  4.38294420e+05   7.94765764e+06   5.81018396e+02]
 [  4.38167420e+05   7.94770209e+06   5.15149846e+02]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this -</p>
<pre><code>import numpy as np
mydata = np.genfromtxt(r'path\to\my\text.txt', skip_header=1) # to skip the header which is a text

finalArr = [] # to display our final result
for i in xrange(len(mydata)):
    if mydata[i][0] == 3:  # 3 is the ID, column 1 of the txt file. Change it with some other ID
        temp=[]
        for j in xrange(1, len(mydata[i])):
            temp.append(mydata[i][j])
        finalArr.append(temp)

print finalArr
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No <code>try-except</code>, no <code>defaultdict</code>, no <code>pandas</code>.  Just build the dictionary of data using the well kept secret that you can reference a <code>dict</code> value not only 
by <code>d[k]</code> but also by the method <code>d.get</code> that allows you to specify a default value if the key is not yet present in <code>d</code>, just like in <code>d.get(k, default)</code>.</p>
<p>Our default value must be the empty list, to which we can append a list of values to be obtained from the rest of the line, that we can get using the new syntax of Python <code>a, *r = alist</code></p>
<pre><code>21:25 $ python
Python 3.6.2 |Continuum Analytics, Inc.| (default, Jul 20 2017, 13:51:32) 
[GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; # lines = open('yourdata').readlines()
&gt;&gt;&gt; lines = '''ID        X         Y         Z
... 1   439748.5728 7948406.945 799.391875
... 1   439767.6229 7948552.995 796.977271
... 1   439805.7229 7948711.745 819.359365
... 1   439799.3729 7948851.446 776.425797
... 2   440764.5749 7948991.146 235.551602
... 2   440504.2243 7948984.796 326.929119
... 2   440104.1735 7948984.796 536.893601
... 2   439742.2228 7949003.846 737.887029
... 2   438580.1705 7949537.247 196.300929
... 3   438142.0196 7947340.142 388.997748
... 3   438599.2205 7947333.792 480.580256
... 3   439126.2716 7947340.142 669.802869
... 4   438453.1702 7947594.143 600.856103
... 4   438294.4199 7947657.643 581.018396
... 4   438167.4197 7947702.093 515.149846'''.split('\n')
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; ################## TL ; DR ###############################
&gt;&gt;&gt; for k, *rest in (line.split() for line in lines[1:] if line):
...     d[k] = d.get(k, []) + [[float(f) for f in rest]] 
... ################## TL ; DR ###############################
&gt;&gt;&gt; for k in d:
...     print(k)
...     for l in d[k]: print('\t', l)
... 
1
         [439748.5728, 7948406.945, 799.391875]
         [439767.6229, 7948552.995, 796.977271]
         [439805.7229, 7948711.745, 819.359365]
         [439799.3729, 7948851.446, 776.425797]
2
         [440764.5749, 7948991.146, 235.551602]
         [440504.2243, 7948984.796, 326.929119]
         [440104.1735, 7948984.796, 536.893601]
         [439742.2228, 7949003.846, 737.887029]
         [438580.1705, 7949537.247, 196.300929]
3
         [438142.0196, 7947340.142, 388.997748]
         [438599.2205, 7947333.792, 480.580256]
         [439126.2716, 7947340.142, 669.802869]
4
         [438453.1702, 7947594.143, 600.856103]
         [438294.4199, 7947657.643, 581.018396]
         [438167.4197, 7947702.093, 515.149846]
&gt;&gt;&gt; 
</code></pre>
<p>If you need a dictionary of <code>numpy</code> arrays,</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; for k in d: d[k] = np.array(d[k])
</code></pre>
<p>That's all.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answers here seem unduly complicated. Here's a two-liner using only numpy:</p>
<p>Just load the whole file and find the unique ids:</p>
<pre><code>a = np.loadtxt('file1.txt', skiprows=1)
ids = np.unique(a[0, :])
# ids = array([ 1.,  2.,  3.,  4.])
</code></pre>
<p>Then, create a list by indexing <code>a</code> at each id:</p>
<pre><code>b = [a[a[:, 0] == i, 1:] for i in ids]
</code></pre>
<p>which gives:</p>
<pre><code>[array([[  4.39748573e+05,   7.94840695e+06,   7.99391875e+02],
        [  4.39767623e+05,   7.94855300e+06,   7.96977271e+02],
        [  4.39805723e+05,   7.94871175e+06,   8.19359365e+02],
        [  4.39799373e+05,   7.94885145e+06,   7.76425797e+02]]),
 array([[  4.40764575e+05,   7.94899115e+06,   2.35551602e+02],
        [  4.40504224e+05,   7.94898480e+06,   3.26929119e+02],
        [  4.40104173e+05,   7.94898480e+06,   5.36893601e+02],
        [  4.39742223e+05,   7.94900385e+06,   7.37887029e+02],
        [  4.38580171e+05,   7.94953725e+06,   1.96300929e+02]]),
 array([[  4.38142020e+05,   7.94734014e+06,   3.88997748e+02],
        [  4.38599220e+05,   7.94733379e+06,   4.80580256e+02],
        [  4.39126272e+05,   7.94734014e+06,   6.69802869e+02]]),
 array([[  4.38453170e+05,   7.94759414e+06,   6.00856103e+02],
        [  4.38294420e+05,   7.94765764e+06,   5.81018396e+02],
        [  4.38167420e+05,   7.94770209e+06,   5.15149846e+02]])]
</code></pre>
<p>For example, if you now want the y-values for the first id, just use <code>b[0][:, 1]</code>.</p>
</div>
<span class="comment-copy">The way you are doing it right now also is not effecient.  It loads the file multiple times.  I would say you might be able to do something like:  <code>x,y,z = np.loadtxt(f1, skiprows=1, usecols=[1,2,3])</code> . and then x,y,z are auto assigned and can be assigned accordingly.  You will want to make sure usecols is correct though since it is 0-indexed.  So 1,2,3 would actually get column 2,3,4 accordingly to numpy.loadtxt parameters... but depending what you want, There are even better answers I can give.  Im just trying to determine more of what you actually need.</span>
<span class="comment-copy">Do you actually need a numpy ndarray?</span>
<span class="comment-copy">Instead of iterating through the <code>ID</code>, you could use a <code>groupby</code>: <code>for val, frame in df.groupby(['ID']): print(val, frame)</code>.</span>
<span class="comment-copy">Agreed!  I avoided <code>groupby</code> to keep my answer as close to OP's as possible.  But <code>groupby</code> is a more elegant and scalable solution.</span>
