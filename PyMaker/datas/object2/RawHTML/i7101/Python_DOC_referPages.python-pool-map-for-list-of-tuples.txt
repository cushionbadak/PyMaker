<div class="post-text" itemprop="text">
<p>I've got a following issue. I'm trying to refactor my code in order to process API calls using multithreading. My core data is simple list of tuples in following format:</p>
<pre><code>lst = [('/Users/sth/photo1.jpg',
      '/Users/sth/photo2'),
      ('/Users/sth/photo1.jpg',
      '/Users/sth/photo3'), (...)]
</code></pre>
<p>Function that I use takes <b>lst</b> list and process it through an API which requires a pair of photos. After all a single number is returned for each pair. So far, I'm using a loop to put a tuple into my function and produce mentioned number. I would like to paralellize the whole computation in a way that one process takes a part of my list and calls the function for the tuples inside a batch. To do that I was trying to use pool function for multiprocessing module:</p>
<pre><code>from multiprocessing.dummy import Pool as ThreadPool 
pool = ThreadPool(2)
results = pool.map(score_function, lst)
</code></pre>
<p>However, following error occurs:</p>
<pre><code>IOError: [Errno 2] No such file or directory: 'U'
</code></pre>
<p>Something strange is happening here. It tries to treat a single character from my tuple as an argument. Any ideas how to do it properly? </p>
<p>Thank You</p>
<p>@edit </p>
<p>The lack of score_function definition is my bad. Let me update the question: </p>
<pre><code>def score_function(pairs):
    score_list = list()

    for pair in pairs:
       score = findElement(target = pair[0], source = pair[1])
       score_list.append([pair[0], pair[1], score])

    return score_list
</code></pre>
<p>Where findElement is defined as:</p>
<pre><code>def findElement(target, source):

    with open(source, 'rb') as source_:
        source_bytes = source_.read()

    with open(target, 'rb') as target_:
        target_bytes = target_.read()

    score = API_request(target_bytes = target_bytes,
                        source_bytes = source_bytes)
    return score
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is the for loop. It breaks your tuple to individual strings. Do this and it should work:</p>
<pre><code>def score_function(pairs):
    score_list = list()

    score = findElement(target = pairs[0], source = pairs[1])
    score_list.append([pairs[0], pairs[1], score])

    return score_list
</code></pre>
<p>You probably assumed your <code>score_function</code> would receive the <code>lst</code> variable as a parameter. This does not happen. <code>lst</code> needs to be a list as it is in your case, and pool.map automatically splits that to individual elements and feeds exactly one element to <code>score_function</code> and keeps doing so until the whole list has been processed by your workers.  Each call to a worker receives as a parameter just the one element it is supposed to work on.  Your individual elements are tuples (path1, path2), and when you call <code>for</code> on this tuple, you receive just one single path (string) in your loop and pair[1] is just the second character of this string.</p>
<p>Hope this helps. </p>
</div>
<div class="post-text" itemprop="text">
<p>Without knowing your score_function and how you define and access it, I guess that you have something like</p>
<pre><code>def score_function(param):
    with open(param[1], "r") as fp:
        ....
</code></pre>
<p>in there. </p>
<p>The error indicates your param is not a tuple at all but a string (param[1], if param is a tuple, would be the second element, while param[1], if param is a string, would be the second character, in your case U from /Users...). Put</p>
<pre><code>print param
</code></pre>
<p>there and see what it is. Either your lst is all wrong and is missing parentheses, and pool.map flattens it and sends each individual component to your function as a string, or you have one offending entry in your lst that is not a tuple. If for example there is an entry and you have forgotten to put parentheses around it, it would send each individual string as a parameter</p>
<pre><code>lst = [('/Users/bar/photo1.jpg', '/Users/bar/photo2'),
       ('/Users/bar/photo2.jpg', '/Users/bar/photo3'),
       '/Users/bar/photo3.jpg', '/Users/bar/photo4',
       (...., .....), (...., .....)]
</code></pre>
<p>it would be able to process the first two but the third (and fourth as it is now a separate entry instead of the second component in a tuple) would cause exactly the error you are getting now. Either way, printing out the parameter your <code>score_function</code> receives should help you figure out where your problem is.  Your use of pool.map is correct and it should work, assuming your input is what you expect it to be. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.starmap" rel="nofollow noreferrer">starmap</a> function insted of map like this:</p>
<pre><code>from multiprocessing import Pool 
pool = Pool(processes=4)
results = pool.starmap(score_function, lst)
pool.close()
pool.join()
</code></pre>
</div>
<span class="comment-copy">Could you share your score_function as well, at least the key parts like definition and how you access the parameter in there, please.</span>
<span class="comment-copy">@Hannu You're right. I've just added a score_function definition</span>
<span class="comment-copy">I posted another answer, it should help a bit.</span>
<span class="comment-copy">Simple solution. It did the job :) I'm grateful.</span>
