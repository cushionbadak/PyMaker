<div class="post-text" itemprop="text">
<p>I'm trying to get the source, callee list, defaults, keywords, args and varargs of the functions in a python script.</p>
<p>Currently, I'm importing the module and using the python <code>inspect</code> module's <code>getmembers</code> function and passing the <code>isfunction</code> parameter like so:</p>
<pre><code>members = inspect.getmembers(myModule, inspect.isfunction)
</code></pre>
<p>However, this method doesn't work if <code>myModule</code>'s imports aren't available to me (since <code>myModule</code> has to be imported first).</p>
<p>I tried using the python <code>ast</code> module to <code>parse</code> and <code>dump</code> the syntax tree, but getting the function source involved very hacky techniques and/or questionable and far from maintainable third party libraries. I believe I've scoured the documentation and stackoverflow pretty thoroughly and have failed to find a suitable solution. Am I missing something?</p>
</div>
<div class="post-text" itemprop="text">
<p>So I looked around some more and quickly Frankenstein'd a solution using <a href="https://stackoverflow.com/a/33876795/4470041">this dude's answer</a> to get each function's source. It isn't anywhere near perfect yet, but here it is if you're interested:</p>
<pre><code>import ast
import re
import json


st = open('filename.py').read()
tree = ast.parse(st)
functions_info = {}


def parse(function):
    global st
    global functions_info
    fn_info = {}
    fn_info['Args'] = []
    fn_info['Source'] = []
    fn_info['Callees'] = []

    print(function.name)

    for arg in function.args.args:
        fn_info['Args'].append(arg.arg)

    lastBody = function.body[-1]

    while isinstance (lastBody,(ast.For,ast.While,ast.If)):
        lastBody = lastBody.Body[-1]
    lastLine = lastBody.lineno

    if isinstance(st,str):
        st = st.split("\n")
    for i , line in enumerate(st,1):
        if i in range(function.lineno,lastLine+1):
            # print(line)
            fn_info['Source'].append(line)

    for line in fn_info['Source']:
        if not line.lstrip().startswith('#'):
            fn_pattern = r'(\w+)\('
            match = re.search(fn_pattern, line)
            if match:
                callee = match.group(1)
                fn_info['Callees'].append(callee)

    functions_info[function.name] = fn_info

for obj in tree.body:
    if isinstance(obj, ast.ClassDef):
        for func in obj.body:
            if isinstance(func, (ast.FunctionDef)):
                parse(func)

    if isinstance(obj, ast.FunctionDef):
        parse(obj)

print(json.dumps(functions_info, indent=4))
</code></pre>
<p>Output:</p>
<pre><code>{
    "displayWonder": {
        "Source": [
            "    def displayWonder(self):",
            "        return \"Hello \" + str(self.displayGreeting())"
        ],
        "Args": [
            "self"
        ],
        "Callees": []
    },
    "displayGreeting": {
        "Source": [
            "    def displayGreeting(self):",
            "        string = \"Greetings \" + self.myName",
            "        return string"
        ],
        "Args": [
            "self"
        ],
        "Callees": []
    },
    "myStatic": {
        "Source": [
            "    @staticmethod",
            "    def myStatic():",
            "        return \"I am static\""
        ],
        "Args": [],
        "Callees": []
    },
    "displayHello": {
        "Source": [
            "    def displayHello(self):",
            "        return \"Hello \" + self.myName"
        ],
        "Args": [
            "self"
        ],
        "Callees": []
    },
    "__init__": {
        "Source": [
            "    def __init__(self):",
            "        self.myName = 'Wonder?'"
        ],
        "Args": [
            "self"
        ],
        "Callees": []
    },
    "main": {
        "Source": [
            "def main():",
            "    hello = Hello(\"Wonderful!!!\")",
            "    # name = unicode(raw_input(\"Enter name: \"), 'utf8')",
            "    # print(\"User specified:\", name)",
            "    print(hello.displayGreeting())"
        ],
        "Args": [],
        "Callees": []
    }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A possible workaround is to monkeypatch the <code>__import__</code> function with a custom function that never throws an ImportError and returns a dummy module instead:</p>
<pre><code>import builtins

def force_import(module):
    original_import = __import__

    def fake_import(*args):
        try:
            return original_import(*args)
        except ImportError:
            return builtins
    builtins.__import__ = fake_import

    module = original_import(module)

    builtins.__import__ = original_import
    return module
</code></pre>
<p>This would allow you to import <code>myModule</code> even if its dependencies cannot be imported. Then you can use <code>inspect.getmembers</code> as you normally would:</p>
<pre><code>myModule = force_import('myModule')
members = inspect.getmembers(myModule, inspect.isfunction)
</code></pre>
<hr/>
<p>A problem with this solution is that it only works around the failing imports. If <code>myModule</code> tries to access any members of the imported modules, its import will fail:</p>
<pre><code># myModule.py

import this_module_doesnt_exist # works

print(this_module_doesnt_exist.variable) # fails
</code></pre>
<pre><code>force_import('myModule')
# AttributeError: module 'builtins' has no attribute 'variable'
</code></pre>
<p>In order to work around this, you can create a dummy class that never throws an AttributeError:</p>
<pre><code>class DummyValue:
    def __call__(self, *args, **kwargs):
        return self

    __getitem__ = __setitem__ = __delitem__ = __call__
    __len__ = __length_hint__ = __bool__ = __call__
    __iter__ = __next__ = __call__
    __getattribute__ = __call__
    __enter__ = __leave__ = __call__
    __str__ = __repr__ = __format__ = __bytes__ = __call__
    # etc
</code></pre>
<p>(See <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">the data model documentation</a> for a list of dunder methods you may have to implement.)</p>
<p>Now if <code>force_import</code> returns an instance of this class (change <code>return builtins</code> to <code>return DummyValue()</code>), importing <code>myModule</code> will succeed.</p>
</div>
<span class="comment-copy">How is the module not available for import but it's possible you can <code>ast.parse</code> its source?</span>
<span class="comment-copy">I had thought of this and ran into the exact same problem :) Thanks anyway!</span>
<span class="comment-copy">@AnuragPande I've added a similar workaround for the AttributeError.</span>
