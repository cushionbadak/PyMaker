<div class="post-text" itemprop="text">
<p>Was hoping someone could help me in trying to print a class method's variable. As show below in my code, I want to print variable A of the method "on_status", which is part of my class MyStreamListener. Is this possible? Bit of a noob question...appreciate any insight. Thank you!</p>
<pre><code>Y = 0
class MyStreamListener(tweepy.StreamListener):

    def __init__(self, api=None, **options):
        self.api = api
        self.retry_time_start = options.get("retry_time", 5.0)
        self.retry_420_start = options.get("retry_420", 60.0)

    def on_connect(self):
        pass

    def on_status(self, status):
        X = '@' + status.user.screen_name + ' - ' + status.text
        if not any(badword in X for badword in badwords):
            print(X)
            print(status.created_at)
            self.A = status.user.screen_name



    def on_error(self, status_code):
        if status_code == 420:
            Y = 1


myStreamListener = MyStreamListener()
myStream = tweepy.Stream(auth = api.auth, listener=myStreamListener)
# async parameter on filter will allow stream to run on a new thread when connection is closed and old thread is blocked
while True:

    if Y != 1:
        print(myStream.filter(track=['test'], async = True))
        --- WANT TO PRINT VARIABLE A HERE ---
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, you should not describe your class's ordinary methods as "class methods". In Python, as "class method" is a method that is called on a class, rather than on an object of a class. Such methods are defined using the <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>@classmethod</code> decorator</a>, and take as their first parameter the class (named <code>cls</code> by convention) rather than an object (named <code>self</code> by convention). (So a <code>MyStreamListener</code> class method could be called as either <code>MyStreamListener.my_class_method()</code>, or as <code>myStreamListener.my_class_method()</code>, where <code>myStreamListener</code> is an object of type <code>MyStreamListener</code>.)</p>
<p>Secondly, if you assign a variable <code>self.A</code> within a method, that variable belongs to the object, not the method, and can be accessed anywhere where the object is available, as <code>object_var.A</code>, where <code>object_var</code> is a variable holding the object. If you're inside a method, then you would use <code>self.A</code>. If you're in client code that has just instantiated your class as <code>myStreamListener</code>, then you would use <code>myStreamListener.A</code>.</p>
<p>Thirdly, if you will be accessing <code>A</code> from outside <code>on_status</code>, where it might not have been initialised yet, you should initialise it with some sensible value in <code>__init__</code>.</p>
</div>
<span class="comment-copy">Assuming that <code>on_status</code> has already been called, just do <code>print(myStream.A)</code>.</span>
<span class="comment-copy">The method might not be executed, so the variable can't exist. The same applies when the condition inside the method is not met.</span>
<span class="comment-copy">this is a plain instance-method, not a <code>classmethod</code></span>
<span class="comment-copy">Note: <code>Y = 1</code> in <code>on_error()</code> will not change the global <code>Y</code> without a <code>global</code> declaration, so <code>Y</code> will never equal <code>1</code>. However, I would recommend against <code>global</code> and just make <code>Y</code> an instance variable too. It is best practice to initialize your variables in <code>__init__()</code>.</span>
<span class="comment-copy">Thank you all for the help and feedback!</span>
<span class="comment-copy">Thank you very much for the critique and feedback, appreciate it greatly.</span>
<span class="comment-copy">the only issue here is that the tweepy API im using gets my variable A from the on_status method. I don't know how I could initialize in init</span>
<span class="comment-copy">For example, you could initialise with <code>self.A = None</code> in <code>__init__</code>, which would mean that an attempt to read <code>A</code> before it had been written to would return <code>None</code>, rather than raising an <code>AttributeError</code> exception. What behaviour are you expecting if you attempt to print <code>A</code> when <code>on_status</code> has only been called with a <code>status</code> that contains anything in <code>badwords</code>? (I.e. So when <code>A</code> has not been set.) That will determine how you should handle the possibility of an uninitialised <code>A</code>.</span>
