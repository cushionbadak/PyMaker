<div class="post-text" itemprop="text">
<p>I lived with the assumption, that defining the <code>_ _len_ _</code> and <code>_ _getitem_ _</code> methods are sufficient for a class, so its instances can be iterated over via a <code>for element in instance:</code>, until it got violated an example. My original code is quite different, but this shows the problem nicely entering an endless loop: </p>
<pre><code>class Limited(object):
    def __init__(self, size=5):
        self.size = size

    def __len__(self):
        return self.size

    def __getitem__(self, item):
        return item*10

if __name__ == "__main__":
    test = Limited(4)
    assert len(test) == 4

    for q in test:
        print q
</code></pre>
<p>I could not find a specific reference to the requirements for terminating an iteration loop, but it seems that an exception like an IndexError or StopIteration is necessary for termination, if one does not want to comply to full Iterator protocol. </p>
<p>Is that correct and where to find it documented?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Answer</h2>
<p>Yes, an <em>IndexError</em> is required to terminate.  </p>
<h2>Documentation</h2>
<p>See the documentation for <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><em>__getitem__()</em></a> which has the note:</p>
<blockquote>
<p>Note for loops expect that an IndexError will be raised for illegal
  indexes to allow proper detection of the end of the sequence.</p>
</blockquote>
<h2>Underlying source code</h2>
<p>The logic for creating an iterator is in Objects/iterobject.c:</p>
<pre><code>static PyObject *
iter_iternext(PyObject *iterator)
{
    seqiterobject *it;
    PyObject *seq;
    PyObject *result;

    assert(PySeqIter_Check(iterator));
    it = (seqiterobject *)iterator;
    seq = it-&gt;it_seq;
    if (seq == NULL)
        return NULL;
    if (it-&gt;it_index == PY_SSIZE_T_MAX) {
        PyErr_SetString(PyExc_OverflowError,
                        "iter index too large");
        return NULL;
    }

    result = PySequence_GetItem(seq, it-&gt;it_index);
    if (result != NULL) {
        it-&gt;it_index++;
        return result;
    }
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration))
    {
        PyErr_Clear();
        Py_DECREF(seq);
        it-&gt;it_seq = NULL;
    }
    return NULL;
}
</code></pre>
<h2>Worked out example</h2>
<p>To fix the OP's code, only two lines need to be added to the beginning of the <em>__getitem__()</em> method:</p>
<pre><code>class Limited(object):
    def __init__(self, size=5):
        self.size = size

    def __len__(self):
        return self.size

    def __getitem__(self, item):
        if item &gt;= len(self):
            raise IndexError
        return item*10

if __name__ == "__main__":
    test = Limited(4)
    assert len(test) == 4

    for q in test:
        print(q)
</code></pre>
<p>This outputs a finite sequence:</p>
<pre><code>0
10
20
30
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just implementing the <code>__getItem__</code> method python will try to acces all indexes from <code>0</code> to <code>infinite</code>, so if you dont specify when to stop it will keep calling the method.</p>
<p>Just check if the index value is higher than the size for example:</p>
<pre><code>class Limited(object):
    def __init__(self, size=5):
        self.size = size

    def __len__(self):
        return self.size

    def __getitem__(self, item):
      if item &lt; self.size:
        return item*10
      raise IndexError
</code></pre>
<p>Here you have a <a href="https://repl.it/KE7u/0" rel="nofollow noreferrer">live example</a></p>
</div>
