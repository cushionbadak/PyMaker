<div class="post-text" itemprop="text">
<p>I have a sorted list of numbers like:</p>
<pre><code>a = [77,98,99,100,101,102,198,199,200,200,278,299,300,300,300]
</code></pre>
<p>I need to find the max index of each values which is divisible by 100.</p>
<p>Output should be like: <code>4,10,15</code></p>
<p>My Code:</p>
<pre><code>a = [77,98,99,100,101,102,198,199,200,200,278,299,300,300,300]
idx = 1
for i in (a):
    if i%100 == 0:
        print idx
    idx = idx+1
</code></pre>
<p>Output of above code: </p>
<pre><code>4
9
10
13
14
15
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case people are curious, I benchmarked the dict comprehension technique against the backward iteration technique. Dict comprehension is about twice the speed. Changing to <code>OrderedDict</code> resulted in MASSIVE slowdown. About 15x slower than the dict comprehension.</p>
<pre><code>def test1():
    a = [77,98,99,100,101,102,198,199,200,200,278,299,300,300,300]
    max_index = {}
    for i, item in enumerate(a[::-1]):
        if item not in max_index:
            max_index[item] = len(a) - (i + 1)
    return max_index

def test2():
    a = [77,98,99,100,101,102,198,199,200,200,278,299,300,300,300]
    return {item: index for index, item in enumerate(a, 1)}

def test3():
    a = [77,98,99,100,101,102,198,199,200,200,278,299,300,300,300]
    OrderedDict((item, index) for index, item in enumerate(a, 1))

if __name__ == "__main__":
    import timeit
    print(timeit.timeit("test1()", setup="from __main__ import test1"))
    print(timeit.timeit("test2()", setup="from __main__ import test2"))
    print(timeit.timeit("test3()", setup="from __main__ import test3; from collections import OrderedDict"))

3.40622282028
1.97545695305
26.347012043
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a simple dict-comprehension or <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> with divisible items as the keys, old values will be replaced by newest values automatically.</p>
<pre><code>&gt;&gt;&gt; {item: index for index, item in enumerate(lst, 1) if not item % 100}.values()
dict_values([4, 10, 15])

# if order matters
&gt;&gt;&gt; from collections import OrderedDict    
&gt;&gt;&gt; OrderedDict((item, index) for index, item in enumerate(lst, 1) if not item % 100).values()
odict_values([4, 10, 15])
</code></pre>
<p>Another way will be to loop over reversed list and use a <code>set</code> to keep track of items seen so far(<code>lst[::-1]</code> may be slightly faster than <code>reversed(lst)</code> for tiny lists).</p>
<pre><code>&gt;&gt;&gt; seen = set()
&gt;&gt;&gt; [len(lst) - index for index, item in enumerate(reversed(lst))
        if not item % 100 and item not in seen and not seen.add(item)][::-1]
[4, 10, 15]
</code></pre>
<p>You can see the sort-of equivalent code of the above <a href="https://stackoverflow.com/a/17347744/846892">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>could</em> use <code>itertools.groupby</code> since your data is sorted:</p>
<pre><code>&gt;&gt;&gt; a = [77,98,99,100,101,102,198,199,200,200,278,299,300,300,300]
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [list(g)[-1][0] for k,g in groupby(enumerate(a), lambda t: (t[1] % 100, t[1])) if k[0] == 0]
[3, 9, 14]
</code></pre>
<p>Although this is a little cryptic.</p>
<p>Here's a complicated approach using only a list-iterator and accumulating into a list:</p>
<pre><code>&gt;&gt;&gt; run, prev, idx = False, None, []
&gt;&gt;&gt; for i, e in enumerate(a):
...     if not (e % 100 == 0):
...         if not run:
...             prev = e
...             continue
...         idx.append(i - 1)
...         run = False
...     else:
...         if prev != e and run:
...             idx.append(i - 1)
...         run = True
...     prev = e
...
&gt;&gt;&gt; if run:
...     idx.append(i)
...
&gt;&gt;&gt; idx
[3, 9, 14]
</code></pre>
<p>I think this is best dealt with a dictionary approach like @AshwiniChaudhary It is more straightforward, and much faster:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit("{item: index for index, item in enumerate(a, 1)}", "from __main__ import a")
1.842843743012054
&gt;&gt;&gt; timeit.timeit("[list(g)[-1][0] for k,g in groupby(enumerate(a), lambda t: (t[1] % 100, t[1])) if k[0] == 0]", "from __main__ import a, groupby")
8.479677081981208
</code></pre>
<p>The <code>groupby</code> approach is pretty slow, note, the complicated approach is faster, and not far-off form the dict-comprehension approach:</p>
<pre><code>&gt;&gt;&gt; def complicated(a):
...     run, prev, idx = False, None, []
...     for i, e in enumerate(a):
...         if not (e % 100 == 0):
...             if not run:
...                 prev = e
...                 continue
...             idx.append(i - 1)
...             run = False
...         else:
...             if prev != e and run:
...                 idx.append(i - 1)
...             run = True
...         prev = e
...     if run:
...         idx.append(i)
...     return idx
...
&gt;&gt;&gt; timeit.timeit("complicated(a)", "from __main__ import a, complicated")
2.6667005629860796
</code></pre>
<p><h3>Edit</h3> Note, the performance difference narrows if we call <code>list</code> on the dict-comprehension <code>.values()</code>:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit("list({item: index for index, item in enumerate(a, 1)}.values())", "from __main__ import a")
2.3839886570058297
&gt;&gt;&gt; timeit.timeit("complicated(a)", "from __main__ import a, complicated")
2.708565960987471
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>it seemed like a good idea at the start, got a bit twisty, had to patch a couple of cases...   </p>
<pre><code>a = [0,77,98,99,100,101,102,198,199,200,200,278,299,300,300,300, 459, 700,700]

bz = [*zip(*((i, d//100) for i, d in enumerate(a) if d%100 == 0 and d != 0))]
[a for a, b, c in zip(*bz, bz[1][1:]) if c-b != 0] + [bz[0][-1]]    

Out[78]: [4, 10, 15, 18]  
</code></pre>
<p>enumerate, zip to create <code>bz</code> which mates 100's numerator(s) with indices   </p>
<pre><code>bz = [*zip(*((i, d//100) for i, d in enumerate(a) if d%100 == 0 and d != 0))]
print(*bz, sep='\n')
(4, 9, 10, 13, 14, 15, 17, 18)
(1, 2, 2, 3, 3, 3, 7, 7)
</code></pre>
<p>then zip again, <code>zip(*bz, bz[1][1:])</code> lagging the numerator tuple to allow the lagged difference to give a selection logic <code>if c-b != 0</code>for the last index of each run but the last</p>
<p>add the last 100's match because its always the end of the last run <code>+ [bz[0][-1]]</code></p>
</div>
<span class="comment-copy">all those who are saying that indexes should start at 0, guys that implementation is not correct anyway, even if he starts from 0.</span>
<span class="comment-copy">A normal loop is fine, old values will be replaced automatically.</span>
<span class="comment-copy">@AshwiniChaudhary That's pretty fair. I wanted to minimize writes for performance reasons, but not sure that actually works over minimizing the <code>in</code> checks.</span>
<span class="comment-copy">Thanks Slater for detailed information and solution. Kudos!!</span>
<span class="comment-copy">I wonder if the overhead of an <code>OrderedDict</code> is worth it vs sorting the values of a regular dict.</span>
<span class="comment-copy">@StevenRumbalski Just checked, looks like it's not unless there's something super specific in this use case that requires it.</span>
<span class="comment-copy">You can make it slightly faster by caching <code>idx.append</code> in a local variable.</span>
