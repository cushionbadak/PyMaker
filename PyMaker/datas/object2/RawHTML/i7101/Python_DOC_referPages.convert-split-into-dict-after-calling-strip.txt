<div class="post-text" itemprop="text">
<p>I would like to create a dictionary of values resulting from a split() sequence without whitespace.</p>
<p>If I had a list of strings that were formatted like so:</p>
<pre><code>lines = ['Item1 = A         Item2 = B         Item3 = C',
         'Item4 = D     Item5 = E']
</code></pre>
<p>I know how to get the <em>pairs</em> by whitespace &gt;2 by:</p>
<p><code>s = [y for x in lines for y in x.split('  ') if y]</code></p>
<p>This returns another list of strings with the <em>pairs</em>:</p>
<p><code>s = ['Item1 = A', 'Item2 = B', 'Item3 = C', 'Item4 = D', 'Item5 = E']</code></p>
<p>So far so good. Now from here I need to break the <em>pairs</em> by the <code>=</code>, the left side is the <code>key</code> and the right side is the <code>value</code>. I can do this by:</p>
<p><code>t = [y.split('=') for x in lines for y in x.split('  ') if y]</code></p>
<p>This returns another list of strings with <em>broken pairs</em>:</p>
<p><code>t = ['Item1 ', ' A', 'Item2 ', ' B', 'Item3 ', ' C', 'Item4 ', 'D', 'Item5 ', ' E']</code></p>
<p>Now each item has either a trailing or a leading whitespace. This is easily fixed by updating that last list comprehension line to:</p>
<p><code>t = [z.strip() for x in lines for y in x.split('  ') for z in y.split('=') if y]</code></p>
<p>In order to make this a dictionary I know to call a generator expression:</p>
<p><code>d = dict(y.split('=') for x in lines for y in x.split('  ') if y)</code></p>
<p>But this keeps that trailing or leading whitespace with the <code>key</code> and <code>value</code>. If I were to add the <code>z.strip()</code> I get the error:</p>
<p><code>ValueError: dictionary update sequence element #0 has length 5; 2 is required</code></p>
<p><strong>Question:</strong></p>
<blockquote>
<p>How can I use the <code>dict()</code> generator and <code>strip()</code> whitespace from the <code>split('=')</code> call at the same time? Or am I forced to <code>strip()</code> after the <code>dict()</code> call?</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>s = ['Item1 = A', 'Item2 = B', 'Item3 = C', 'Item4 = D', 'Item5 = E']

#b = dict([x.split(' = ') for x in s])  # list comprehension: slightly faster.
b = dict(x.split(' = ') for x in s)     # generator expr.   : memory efficient.

print(b)  # {'Item3': 'C', 'Item1': 'A', 'Item4': 'D', 'Item5': 'E', 'Item2': 'B'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could iterate over <code>t</code> using <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow noreferrer"><code>range</code></a> with a step of <code>2</code>:</p>
<pre><code>&gt;&gt;&gt; t = [z.strip() for x in lines for y in x.split('  ') for z in y.split('=') if y]
&gt;&gt;&gt; t
['Item1', 'A', 'Item2', 'B', 'Item3', 'C', 'Item4', 'D', 'Item5', 'E']

&gt;&gt;&gt; dict((t[i], t[i + 1]) for i in range(0, len(t), 2))
{'Item2': 'B', 'Item3': 'C', 'Item1': 'A', 'Item4': 'D', 'Item5': 'E'}
</code></pre>
<p>To fit it all in one line you could also write:</p>
<pre><code>&gt;&gt;&gt; d = dict(tuple(k.strip() for k in y.split('=')) for x in lines for y in x.split('  ') if y)

&gt;&gt;&gt; d
{'Item2': 'B', 'Item3': 'C', 'Item1': 'A', 'Item4': 'D', 'Item5': 'E'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you could identify a pattern to match with a regex, then you could use <code>re</code> and <code>itertools</code> to handle the <code>dict</code> creation</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; import re
&gt;&gt;&gt; dict(itertools.chain.from_iterable(re.findall('(\w+\d+) = (\w+)', line) for line in lines))
{'Item1': 'A', 'Item2': 'B', 'Item4': 'D', 'Item3': 'C', 'Item5': 'E'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's my go at it:</p>
<pre><code>lines = ['Item1 = A         Item2 = B         Item3 = C',
         'Item4 = D     Item5 = E']
gen = (piece for line in lines for piece in line.split() if piece != '=')
d = dict(zip(gen, gen))
print(d)
&gt;&gt;&gt; {'Item4': 'D', 'Item2': 'B', 'Item1': 'A', 'Item3': 'C', 'Item5': 'E'}
</code></pre>
<p>Or if you like to cram things into one line:</p>
<pre><code>d = dict(zip(*[(p for l in lines for p in l.split() if p != '=')] * 2))
</code></pre>
<p>Instead of splitting by double spaces and then by equals, just split by whitespace in general and then remove equals tokens. Then pass the generator twice to <code>zip</code> to generate the pairs for <code>dict</code>.</p>
<p>The drawback of this solution is that it requires to have always whitespace around the equals symbols.</p>
</div>
<span class="comment-copy">You should look at dedicated parsers such as <code>configparser</code> (standard library) or <code>pyparsing</code> (third-party).</span>
<span class="comment-copy">you could simply <code>split</code> on <code>' = '</code> instead of <code>'='</code> to avoid <code>strip</code>ing.</span>
<span class="comment-copy">Don't edit questions with an answer. Answers belong in answers. Accepts are enough to signal that the problem is solved.</span>
<span class="comment-copy">@AndrasDeak I edited with an updated answer; the solution I used was not identical to the posted answer. Difference seems like a good reason to post.</span>
<span class="comment-copy">In that case add an answer of your own down below, where it belongs.</span>
<span class="comment-copy">Excellent solution! The only slight improvement I need is to add a <code>.strip()</code> or <code>.rstrip()</code> to remove any <code>'\n'</code> characters.</span>
<span class="comment-copy">Found the correct solution sequence. I've updated my post. Thank you for the help!</span>
<span class="comment-copy">using <code>split</code> as a variable name is confusing.</span>
<span class="comment-copy">@Ev.Kounis Yeah you're probably right I've changed it.</span>
