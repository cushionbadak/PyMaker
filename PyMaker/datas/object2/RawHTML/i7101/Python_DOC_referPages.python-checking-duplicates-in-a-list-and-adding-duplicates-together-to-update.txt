<div class="post-text" itemprop="text">
<p>The objective of my problem is to read in a thread post such as this:</p>
<pre><code>([
{
    'title': 'Invade Manhatten, anyone?',
    'tags': ['world-domination', 'hangout'],
    'posts': [
        {
            'author': 'Mr. Sinister',
            'content': "I'm thinking 9 pm?",
            'upvotes': 2,
        },
        {
            'author': 'Mystique',
            'content': "Sounds fun!",
            'upvotes': 0,
        },
        {
            'author': 'Magneto',
            'content': "I'm in!",
            'upvotes': 0,
        },
    ],
}
</code></pre>
<p>]))</p>
<p>And create a definition to output this:</p>
<pre><code>[('Mr. Sinister', '2', 'Cautioiusly Evil'), ('Magneto', '0', 'Insignificantly Evil'), ('Mystique', '0', 'Insignificantly Evil')]
</code></pre>
<p>Where the list is sorted from highest upvotes to lowest upvotes, with ties broken alphabetically.</p>
<p>However, when I was given this thread:</p>
<pre><code>([
{
    'title': 'Invade Manhatten, anyone?',
    'tags': ['world-domination', 'hangout'],
    'posts': [
        {
            'author': 'Mr. Sinister',
            'content': "I'm thinking 9 pm?",
            'upvotes': 2,
        },
        {
            'author': 'Mr. Sinister',
            'content': "Sounds fun!",
            'upvotes': 0,
        },
        {
            'author': 'Mr. Sinister',
            'content': "I'm in!",
            'upvotes': 0,
        },
    ],
}
</code></pre>
<p>]))</p>
<p>Where the author posts multiple times, my program outputs:</p>
<pre><code>[('Mr. Sinister', '2', 'Cautioiusly Evil'), ('Mr. Sinister', '0', 'Insignificantly Evil'), ('Mr. Sinister', '0', 'Insignificantly Evil')]
</code></pre>
<p>My program prints each individual post rather than combining the results like this:</p>
<pre><code>[('Mr. Sinister', 2, 'Cautiously Evil')]
</code></pre>
<p>Just to clarify, if the thread was:</p>
<pre><code>([
{
    'title': 'Invade Manhatten, anyone?',
    'tags': ['world-domination', 'hangout'],
    'posts': [
        {
            'author': 'Mr. Sinister',
            'content': "I'm thinking 9 pm?",
            'upvotes': 2,
        },
        {
            'author': 'Loki',
            'content': "Sounds fun!",
            'upvotes': 2,
        },
        {
            'author': 'Mr. Sinister',
            'content': "I'm in!",
            'upvotes': 2,
        },
        {
            'author': 'Loki',
            'content': "I'm in it!",
            'upvotes': 20,
        },

    ],
}
</code></pre>
<p>]))</p>
<p>It should input:</p>
<pre><code>[('Loki', 22, 'Justifiably Evil'), ('Mr. Sinister', 4, 'Cautiously Evil')]
</code></pre>
<p>My code for this is here:</p>
<pre><code>  def author_rankings(thread_list):
# TODO: Determine (author, upvotes, ranking) over all threads.
counterA = 0
counterB=2

listA = []
Final = []
Double = {}
for i in thread_list[0]['posts']:
    for ii in i:
        if ii == 'content':
            null = 1
        else:
            b = str(i[ii])
            if b in Double:
              Double[b]
            a = b
            if a.isdigit():
              a = int(a)
            listA.append(a)
bel=[]
for qq in listA:
    if counterA == counterB:
        bel = []
        counterB+=2
    if counterA%2 ==0:
         bel.append(qq)
         counterA+=1
    else:
       bel.append(qq)
       qq = int(qq)
       if qq == 0:
           bel.append('Insignificantly Evil')

     elif qq &lt; 20:
          bel.append('Cautiously Evil')


     elif qq &lt; 100:
          bel.append('Justifiably Evil')

     elif qq &lt; 500:
           bel.append('Wickedly Evil')

     elif qq &gt;= 500:
          bel.append('Diabolically Evil')

     counterA+=1



     tuuple = tuple(bel)
     Final.append(tuuple)



Final.sort()      

Final.sort(key=lambda tup: -tup[1])
</code></pre>
<p>I know I code slightly un-pythonic/ hard to read. Sorry for the inconvenience.</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>I do not understand what you are asking, because the logic isn't very clear. </p>
<p>However, the aggregation can be done like so:</p>
<pre><code>some_pages = [
        {
            'title': 'Invade Manhatten, anyone?',
            'tags': ['world-domination', 'hangout'],
            'posts': [
                {
                    'author': 'Mr. Sinister',
                    'content': "I'm thinking 9 pm?",
                    'upvotes': 2,
                },
                {
                    'author': 'Mr. Sinister',
                    'content': "Sounds fun!",
                    'upvotes': 0,
                },
                {
                    'author': 'Mr. Sinister',
                    'content': "I'm in!",
                    'upvotes': 0,
                },
            ],
        }
    ]

author_aggregation = {}
for pages in some_pages:
    for post in pages.get('posts', []):
        a = post.get('author')
        v = post.get('upvotes')
        c = post.get('content')
        if a in author_aggregation:
            author_aggregation.update({a: {'upvotes': author_aggregation[a]['upvotes'] += v, 'content': author_aggregation[a]['content'].append(c)}})
        else:
            author_aggregation[a] = {'upvotes': v, 'content': [c]}
</code></pre>
<h1>Related:</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/18066269/group-by-and-aggregate-the-values-of-a-list-of-dictionaries-in-python">Group by and aggregate the values of a list of dictionaries in Python</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This might work, it ignores content (can be added as well if needed), only takes upvotes and author. It also uses a dictionary and not a list:</p>
<pre><code>authors = dict()

for post in x[0]['posts']:
    try:
        authors[post['author']] += post['upvotes']

    except KeyError:
        authors[post['author']] = post['upvotes']

for k, upvotes in authors.iteritems():
    if upvotes == 0:
        authors[k] = (upvotes, "Insignificantly Evil")

    elif upvotes &lt; 20:
        authors[k] = (upvotes, "Cautioiusly Evil")

    elif upvotes &lt; 100:
        authors[k] = (upvotes, "Justifiably Evil")

    elif upvotes &lt;= 500:
        authors[k] = (upvotes, "Wickedly Evil")

    elif upvotes &gt; 500:
        authors[k] = (upvotes, "Diabolically Evil")

print authors
</code></pre>
<p>Outputs:</p>
<pre><code>{'Mr. Sinister': (2, 'Cautioiusly Evil')}
</code></pre>
<p>And:</p>
<pre><code>{'Mr. Sinister': (4, 'Cautioiusly Evil'), 'Loki': (22, 'Justifiably Evil')}
</code></pre>
<p>For the 2nd example.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code works, hopefully it is readable enough so you can adapt it</p>
<pre><code>x = in[0]  # returns a dict from your input

for post in x.get('posts'):
        author = post.get('author')
        if author not in d.keys():
            d[author] = post
        else:
            d.get('author')['upvotes'] += post.get('upvotes')
</code></pre>
<p>This will return a dict without duplicate authors and won't update the score if it is already there.</p>
<p>I tried it on your data and it worked</p>
<blockquote>
<p>d
  {'Mr. Sinister': {'content': "I'm thinking 9 pm?", 'upvotes': 2, 'author': 'Mr. Sinister'}}</p>
</blockquote>
</div>
<span class="comment-copy">Do you want to sum the upvotes for an <i>author</i>?</span>
<span class="comment-copy">I'm sorry, this thing is just unreadable, it's not "slightly un-pythonic" it's the devils work. Can't you at least give meaningful names and such? make our life easier while trying to help?</span>
<span class="comment-copy">@droravr Sorry! I changed the variables to more understandable names.</span>
<span class="comment-copy">Iterate over the posts and keep the data in a dictionary of <code>author:upvote</code> pairs, adding upvotes during the iteration.  You will have to account for missing keys with the dictionary get method or testing first or catching the KeyError or using a collections dictionary container. When the posts are finished iterate over the dictionary items and construct tuples by adding the appropriate <i>evilness</i>.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">docs.python.org/3/howto/sorting.html</a></span>
<span class="comment-copy">Your code doesn't count all the votes of the same poster. It will just take the votes from the first post of each author.</span>
<span class="comment-copy">I edited the answer, thanks</span>
