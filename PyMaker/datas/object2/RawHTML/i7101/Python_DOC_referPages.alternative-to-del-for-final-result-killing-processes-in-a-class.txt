<div class="post-text" itemprop="text">
<p>This dummy class is similar to a current project of mine:</p>
<pre><code>class EndProcess(object):

    def __init__(self):
        self._Q = multiprocessing.Queue()

        self.p1 = multiprocessing.Process(target=self.worker, args=("p1",))
        self.p2 = multiprocessing.Process(target=self.worker, args=("p2",))
        self.p3 = multiprocessing.Process(target=self.worker, args=("p3",))
        self.p1.start()
        self.p2.start()
        self.p3.start()


    def worker(self, name):
        while True:
            rnd = random.randint(0, 100)
            self._Q.put((name, rnd))
            print(name, rnd)
            time.sleep(1)


    def __del__(self):
        # "log" final state of Queue
        while not self._Q.empty():
            print(self._Q.get())

        # free resources
        ...

        # clean up workers
        self.p1.terminate()
        self.p2.terminate()
        self.p3.terminate()


if __name__ == "__main__":
    ep = EndProcess()
</code></pre>
<p>The problem is that <code>__del__</code> is not guaranteed to be always called, especially at important points in time, since <code>__del__</code> is only called by Python's garbage collector when the reference count of the object reaches zero.</p>
<p>How can I assure that resources always get set free and the workers always get terminated?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How can I assure that resources always get set free and the workers always get terminated?</p>
</blockquote>
<p>You can accomplish this by implementing the context manager methods <a href="https://docs.python.org/3/reference/datamodel.html#object.__enter__" rel="nofollow noreferrer"><code>__enter__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__exit__" rel="nofollow noreferrer"><code>__exit__</code></a>. You can then use your <code>EndProcess</code> class with the context manger statement <code>with</code>. This way, your clean-up logic will executed even if an error occurs:</p>
<pre><code>class EndProcess(object):
    def __init__(self):
        self._Q = multiprocessing.Queue()
        self.p1 = multiprocessing.Process(target=self.worker, args=("p1",))
        self.p2 = multiprocessing.Process(target=self.worker, args=("p2",))
        self.p3 = multiprocessing.Process(target=self.worker, args=("p3",))
        self.p1.start()
        self.p2.start()
        self.p3.start()

    def worker(self, name):
        while True:
            rnd = random.randint(0, 100)
            self._Q.put((name, rnd))
            print(name, rnd)
            time.sleep(1)

    def __enter__(self):
        # Add your setup logic here. Initialize any data structures.
        # set any threads, etc.
        pass

    def __exit__(self, exc_type, exc_value, traceback):
        # The three arguments to `__exit__` describe the exception
        # caused the `with` statement execution to fail. If the `with`
        # statement finishes without an exception being raised, these
        # arguments will be `None`.
        #
        # These arguments may be useful for things such as logging, or 
        # debugging.
        while not self._Q.empty():
            print(self._Q.get())
        ...
        self.p1.terminate()
        self.p2.terminate()
        self.p3.terminate()
        ...
</code></pre>
<p>Now you can use <code>EndProcess</code> instances in a context manager statement:</p>
<pre><code>end_process = EndProcess()
...
with end_process as ep:
    # Use ep like you would normally. `__enter__` and `__exit__` will be
    # automatically.
    pass
</code></pre>
</div>
<span class="comment-copy">Perhaps you're looking for the <a href="https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers" rel="nofollow noreferrer"><i>With Statement Context Managers</i></a>?</span>
<span class="comment-copy">So you suggest that I wrap the process creation and starting in a with-statement? Wouldn't this block my main process' <code>__init__</code> method?</span>
<span class="comment-copy">No? If you create an instance of <code>EndProcess</code> before the <code>with</code> statement, and then do <code>with end_process_object as name:</code> that would seem to work to me. <code>__enter__</code> will be called when the <code>with</code> statement starts. And <code>__exit__</code> will be called when the <code>with</code> statement is exited, so you could put your clean-up work there.</span>
<span class="comment-copy">Would you mind giving some example (some lines of code)? I guess I have misunderstood something about the context manager's concept...at least I can not figure out how to correctly implement your suggestion at the moment.</span>
<span class="comment-copy">Sure, I'll try to give a quick answer.</span>
