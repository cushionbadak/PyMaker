<div class="post-text" itemprop="text">
<p>I have a string...</p>
<pre><code>my_string="The way you see people is the way you treat them and the Way you treat them is what they become"
</code></pre>
<p>my def should return this:</p>
<pre><code>{2: ['is'],
 3: ['and', 'see', 'the', 'way', 'you'],
 4: ['them', 'they', 'what'],
 5: ['treat'], 
 6: ['become', 'people']}
</code></pre>
<p>My solution returns:</p>
<pre><code>{3: {'you', 'see', 'way', 'and', 'the'},
 6: {'become', 'people'}, 
 2: {'is'},
 5: {'treat'}, 
 4: {'what', 'them', 'they'}}
</code></pre>
<p>i need to sorted that dictionary by key and change value's class...my values class is {} but i want []
My solution:</p>
<pre><code>def n_letter_dictionary(my_string):
    my_string=my_string.lower().split()
    sample_dictionary={}
    r=[]
    for word in my_string:
        lw=len(word)
        if lw in sample_dictionary:
            sample_dictionary[lw].add(word)
        else:
            sample_dictionary[lw] = {word}

    return sample_dictionary



print(n_letter_dictionary("The way you see people is the way you treat them 
and the Way you treat them is what they become"))
</code></pre>
<p>how can i do this?anyone can help?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have sets, because you create one here:</p>
<pre><code>sample_dictionary[lw] = {word}
</code></pre>
<p>You'd need to make it a list there:</p>
<pre><code>sample_dictionary[lw] = [word]
</code></pre>
<p>and use <code>.append()</code>, not <code>.add()</code> to add more elements.</p>
<p>Note that your code can be simplified by using <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault()</code></a>:</p>
<pre><code>def n_letter_dictionary(my_string):
    sample_dictionary = {}
    for word in my_string.lower().split():
        sample_dictionary.set_default(len(word), []).append(word)
    return sample_dictionary
</code></pre>
<p><code>.setdefault()</code> returns the value for a given key; if the key is missing it'll first set that key to the default value provided in the second argument.</p>
<p>If you wanted to only keep <em>unique</em> words you'd have to either convert the sets to lists <em>after the fact</em> with an extra loop:</p>
<pre><code>def n_letter_dictionary(my_string):
    sample_dictionary = {}
    for word in my_string.lower().split():
        sample_dictionary.set_default(len(word), set()).add(word)
    return {l: list(v) for l, v in sample_dictionary.items()}
</code></pre>
<p>The last line is a dictionary comprehension; it builds a new dictionary with the same keys, and each <code>set</code> value converted to a list. Note that sets are unordered, so the resulting list will list the unique words in arbitrary order. If you need to preserve the order of the words in the input, then you'll have collect those words into a list, and then apply a technique from <a href="https://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-whilst-preserving-order">How do you remove duplicates from a list in whilst preserving order?</a> to each value.</p>
<p>Dictionaries are otherwise unordered too, just like sets, and can't be sorted. See <a href="https://stackoverflow.com/questions/9001509/how-can-i-sort-a-dictionary-by-key">How can I sort a dictionary by key?</a> for work-arounds.</p>
<p>For example, you could produce an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict()</code> instance</a> from the sorted <code>(key, value)</code> pairs:</p>
<pre><code>from collections import OrderedDict

def n_letter_dictionary(my_string):
    sample_dictionary = {}
    for word in my_string.lower().split():
        sample_dictionary.set_default(len(word), set()).add(word)
    return OrderedDict((l, list(v)) for l, v in sorted(sample_dictionary.items()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use Counter() from collections to solve this problem. It will make your life easier.</p>
<pre><code>import collections
c = collections.Counter(mystring.lower().split(' '))
for key in sorted([*c]):
    print("{0} : {1}".format(key, c[key]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dicts are unordered by default in python &lt; 3.7. What you can do is use an OrderedDict. It retains the order of data insertion, and if you insert the data sorted, it will stay sorted.</p>
<pre><code>from collections import OrderedDict
unordered_dict = {
   3: {'you', 'see', 'way', 'and', 'the'},
   6: {'become', 'people'}, 
   2: {'is'},
   5: {'treat'}, 
   4: {'what', 'them', 'they'}}

ordered_dict = OrderedDict()
for key in sorted(unordered_dict.keys()):
    ordered_dict[key] = unordered_dict[key]
</code></pre>
</div>
<span class="comment-copy">dictionaries cannot be sorted. They are unstructured data containers (at least up to Python 3.6). converting the <code>set</code> to <code>list</code> is trivial</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> would return the items in the right order, but I'm unsure on how it will print out. You'd also need to create the <code>OrderedDict</code> in the end like <code>return OrderedDict(sorted(sample_dictionary.items(), key=lambda x: x[0]))</code></span>
<span class="comment-copy">You don't need to call <code>keys()</code> to produce an iterable of the keys. <code>sorted(unordered_dict)</code> would do.</span>
<span class="comment-copy">Yeah, I'd forgotten that part. Good catch.</span>
