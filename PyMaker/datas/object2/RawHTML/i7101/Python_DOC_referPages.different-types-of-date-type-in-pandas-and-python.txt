<div class="post-text" itemprop="text">
<p>I am working on building a trading strategy back-test that has to do with storing date as the index. Can someone explain the difference (and also the mutability when doing assignment) of the following type of data for date?</p>
<pre><code>a=pd.date_range('1/1/2016',periods=10,freq='w')
b=datetime.datetime(2016,1,4)
c=pd.datetime(2016,1,4)
d=pd.Timestamp(153543453435)
</code></pre>
<p>When I print it, the data types are as below:</p>
<pre><code>&lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt; (print(type(a))
&lt;class 'pandas._libs.tslib.Timestamp'&gt; (print(type(a[0]))
&lt;class 'datetime.datetime'&gt;
&lt;class 'datetime.datetime'&gt;
&lt;class 'pandas._libs.tslib.Timestamp'&gt;
</code></pre>
<p>It would be great if someone can explain in details the difference of them and the mutability when doing variable assignment?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>dti = pd.date_range('1/1/2016',periods=10,freq='w')
</code></pre>
<p>According to <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DatetimeIndex.html" rel="nofollow noreferrer">the docs</a> <code>DatetimeIndex</code> is:</p>
<blockquote>
<p><strong>Immutable</strong> ndarray of datetime64 data, represented internally as int64, and which can be boxed to Timestamp objects that are subclasses of datetime and carry metadata such as frequency information.</p>
</blockquote>
<pre><code>ts = dti[0]
</code></pre>
<p>Furthermore the pandas <code>Timestamp</code> object is designed to be immutable:</p>
<pre><code>ts  # returns Timestamp('2016-01-03 00:00:00', freq='W-SUN')
ts.replace(year=2015)  # returns Timestamp('2015-01-03 00:00:00', freq='W-SUN')
ts  # returns Timestamp('2016-01-03 00:00:00', freq='W-SUN')
</code></pre>
<p>Note how the year of the original <code>Timestamp</code> object did not change. Instead the replace method returned a new <code>Timestamp</code> object.</p>
<p>Lastly, with respect to native python <code>datetime</code> objects, according to <a href="https://docs.python.org/3/library/datetime.html#available-types" rel="nofollow noreferrer">the python docs</a>:</p>
<blockquote>
<p>Objects of these types are immutable.</p>
</blockquote>
<p>Here is a <a href="https://stackoverflow.com/questions/13703720/converting-between-datetime-timestamp-and-datetime64">good SO post</a> about converting between different types representing datetimes.</p>
<p>So why would you use one as opposed to another?</p>
<p><code>datetimes</code> can be a pain to work with. That's why pandas created their own wrapper class (<code>Timestamp</code>). Metadata is stored on these objects that makes their manipulation easier. The <code>DatetimeIndex</code> is just a sequence of <a href="https://docs.scipy.org/doc/numpy/reference/arrays.datetime.html" rel="nofollow noreferrer"><code>numpy datetime64</code></a> objects that are boxed into <code>Timestamp</code> objects for the added functionality. For example using <code>Timestamp</code>/<code>DatetimeIndex</code> you can:</p>
<ul>
<li>Add a certain number of business days to a datetimeindex.</li>
<li>Create sequences that span a certain number of weeks.</li>
<li>Change timezones.</li>
<li>etc.</li>
</ul>
<p>All of these things would be a royal pain without the extra methods and metadata stored on the <code>Timestamp</code> and <code>DatetimeIndex</code> classes.</p>
<p>Take a look at the <a href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#timeseries-timestamp-limits" rel="nofollow noreferrer">pandas docs</a> for more examples.</p>
</div>
