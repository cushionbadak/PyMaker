<div class="post-text" itemprop="text">
<p>I'm writing a function that finds a string near a identical string(s) in a larger piece of text. So far so good, just not pretty. </p>
<p>I'm having trouble trimming the resulting string to the nearest sentence/whole word, without leaving any characters hanging over. The trim distance is based on a number of words either side of the keyword.</p>
<pre><code>keyword = "marble"
string = "Right. This marble is as slippery as this marble. Kwoo-oooo-waaa! Ahhhk!"

with 1 word distance (either side of key word) it should result in:
2 occurrences found
"This marble is..."
"...this marble. Kwoo-oooo-waaa!"

with 2 word distance:
2 occurrences found
"Right. This marble is as..."
"...as this marble. Kwoo-oooo-waaa! Ahhhk!"
</code></pre>
<p>what I've got so far is based on character, not word distance.</p>
<pre><code>2 occurrences found
"ght. This marble is as sli"
"y as this marble. Kwoo-ooo"
</code></pre>
<p>However a regex could split it to the nearest whole word or sentence. Is that the most Pythonic way to achieve this? This is what I've got so far:</p>
<pre><code>import re

def trim_string(s, num):
  trimmed = re.sub(r"^(.{num}[^\s]*).*", "$1", s) # will only trim from left and not very well
  #^(.*)(marble)(.+) # only finds second occurrence???

  return trimmed

s = "Right. This marble is as slippery as this marble. Kwoo-oooo-waaa! Ahhhk!"
t = "Marble"


if t.lower() in s.lower():

  count = s.lower().count(t.lower())
  print ("%s occurrences of %s" %(count, t))

  original_s = s

  for i in range (0, count):
    idx = s.index(t.lower())
    # print idx

    dist = 10
    start = idx-dist
    end = len(t) + idx+dist
    a = s[start:end]

    print a
    print trim_string(a,5)

    s = s[idx+len(t):]
</code></pre>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this regex to match up to N non-whitespace substring on either side of <code>marble</code>:</p>
<p>2 words:</p>
<pre><code>(?:(?:\S+\s+){0,2})?\bmarble\b\S*(?:\s+\S+){0,2}
</code></pre>
<p><strong>RegEx Breakup:</strong></p>
<pre><code>(?:(?:\S+\s+){0,2})? # match up to 2 non-whitespace string before keyword (lazy)
\bmarble\b\S*        # match word "marble" followed by zero or more non-space characters
(?:\s+\S+){0,2}      # match up to 2 non-whitespace string after keyword
</code></pre>
<p><a href="https://regex101.com/r/8HAdYg/2" rel="nofollow noreferrer">RegEx Demo</a></p>
<p>1 word regex:</p>
<pre><code>(?:(?:\S+\s+){0,1})?\bmarble\b\S*(?:\s+\S+){0,1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this without <code>re</code> if you ignore the punctuation:</p>
<pre><code>import itertools as it
import string

def nwise(iterable, n):
    ts = it.tee(iterable, n)
    for c, t in enumerate(ts):
        next(it.islice(t, c, c), None)
    return zip(*ts)

def grep(s, k, n):
    m = str.maketrans('', '', string.punctuation)
    return [' '.join(x) for x in nwise(s.split(), n*2+1) if x[n].translate(m).lower() == k]

In []
keyword = "marble"
sentence = "Right. This marble is as slippery as this marble. Kwoo-oooo-waaa! Ahhhk!"
print('...\n...'.join(grep(sentence, keyword, n=2)))

Out[]:
Right. This marble is as...
...as this marble. Kwoo-oooo-waaa! Ahhhk!

In []:
print('...\n...'.join(grep(sentence, keyword, n=1)))

Out[]:
This marble is...
...this marble. Kwoo-oooo-waaa!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <code>ngrams()</code> function from <a href="https://stackoverflow.com/a/13424002/2799941">this answer</a>, here's one approach which just takes all the n-grams and then chooses the ones with <code>keyword</code> in the middle:</p>
<pre><code>def get_ngrams(document, n):
    words = document.split(' ')
    ngrams = []
    for i in range(len(words)-n+1):
        ngrams.append(words[i:i+n])
    return ngrams

keyword = "marble"
string = "Right. This marble is as slippery as this marble. Kwoo-oooo-waaa! Ahhhk!"

n = 3
pos = int(n/2 - .5)
# ignore punctuation by matching the middle word up to the number of chars in keyword
result = [ng for ng in get_ngrams(string, n) if ng[pos][:len(keyword)] == keyword]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.adjacent" rel="nofollow noreferrer"><code>more_itertools.adajacent</code></a><sup><a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.adjacent" rel="nofollow noreferrer">1</a></sup> is a tool that probes neighboring elements.</p>
<pre><code>import operator as op
import itertools as it

import more_itertools as mit


# Given
keyword = "marble"
iterable = "Right. This marble is as slippery as this marble. Kwoo-oooo-waaa! Ahhhk!"
</code></pre>
<p>Code</p>
<pre><code>words = iterable.split(" ")
pred = lambda x: x in (keyword, "".join([keyword, "."]))

neighbors = mit.adjacent(pred, words, distance=1)    
[" ".join([items[1] for items in g]) for k, g in it.groupby(neighbors, op.itemgetter(0)) if k]
# Out: ['This marble is', 'this marble. Kwoo-oooo-waaa!']

neighbors = mit.adjacent(pred, words, distance=2)
[" ".join([items[1] for items in g]) for k, g in it.groupby(neighbors, op.itemgetter(0)) if k]
# Out: ['Right. This marble is as', 'as this marble. Kwoo-oooo-waaa! Ahhhk!']
</code></pre>
<p>The OP may adjust the final output of these results as desired.</p>
<hr/>
<p><strong>Details</strong></p>
<p>The given string has been split into an iterable of <code>words</code>. A a <em>simple predicate</em><sup><a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">2</a></sup> was defined, returning <code>True</code> if the keyword (or a keyword with a trailing period) is found in the iterable.</p>
<pre><code>words = iterable.split(" ")
pred = lambda x: x in (keyword, "".join([keyword, "."]))

neighbors = mit.adjacent(pred, words, distance=1)
list(neighbors)
</code></pre>
<p>A list of <code>(bool, word)</code> tuples are returned from the <code>more_itertools.adjacent</code> tool:</p>
<p>Output</p>
<pre><code>[(False, 'Right.'),
 (True, 'This'),
 (True, 'marble'),
 (True, 'is'),
 (False, 'as'),
 (False, 'slippery'),
 (False, 'as'),
 (True, 'this'),
 (True, 'marble.'),
 (True, 'Kwoo-oooo-waaa!'),
 (False, 'Ahhhk!')]
</code></pre>
<p>The first index is <code>True</code> for any valid occurences of keywords and neighboring words with a distance of 1.  We use this boolean and <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to find and group together consecutive, neighboring items.  For example:</p>
<pre><code>neighbors = mit.adjacent(pred, words, distance=1)
[(k, list(g)) for k, g in it.groupby(neighbors, op.itemgetter(0))]
</code></pre>
<p>Output</p>
<pre><code>[(False, [(False, 'Right.')]),
 (True, [(True, 'This'), (True, 'marble'), (True, 'is')]),
 (False, [(False, 'as'), (False, 'slippery'), (False, 'as')]),
 (True, [(True, 'this'), (True, 'marble.'), (True, 'Kwoo-oooo-waaa!')]),
 (False, [(False, 'Ahhhk!')])]
</code></pre>
<p>Finally, we apply a condition to filter the <code>False</code> groups and join the strings together.</p>
<pre><code>neighbors = mit.adjacent(pred, words, distance=1)    
[" ".join([items[1] for items in g]) for k, g in it.groupby(neighbors, op.itemgetter(0)) if k]
</code></pre>
<p>Ouput</p>
<pre><code>['This marble is', 'this marble. Kwoo-oooo-waaa!']
</code></pre>
<p><sup><a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.adjacent" rel="nofollow noreferrer">1</a><sub><a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party library that implements many useful tools including the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>.</sub></sup></p>
<p><sup><a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">2</a><sub>Note, stronger predicates can certainly be made for keywords with any punctuation, but this one was used for simplicity.</sub></sup></p>
</div>
<span class="comment-copy">How do you want to handle whitespace? If you just consider single spaces between "words" you could use <code>.split()</code> on the input text then use list indexes to manipulate sub-set and re-join the words into a single string. It gets you out of using regex if that's a benefit to you.</span>
<span class="comment-copy">I don't want any leading or trailing whitespace in the results, if that's what you mean. The inclusion of of ellipsis (...) is there to illustrate that the string has been broken at that point.</span>
<span class="comment-copy">The regex will also capture words like - <code>marbleilz</code> should be <code>\W*</code> after the word not <code>\S*</code>.</span>
<span class="comment-copy">Yes you are right @droravr, edited now.</span>
<span class="comment-copy">This still has a bug if no space comes after the <code>.</code> for example - <a href="https://regex101.com/r/8HAdYg/3" rel="nofollow noreferrer">regex101.com/r/8HAdYg/3</a></span>
<span class="comment-copy">May be: <code>(?:(?:\S+\s+){0,2})?\bmarble\b\S?(?:\s*\S+){0,2}</code> but we don't know if missing space between words is a realistic use case or not. Only OP can tell us.</span>
<span class="comment-copy">That's fair enough :)</span>
