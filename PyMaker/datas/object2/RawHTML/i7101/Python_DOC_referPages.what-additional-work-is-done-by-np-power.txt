<div class="post-text" itemprop="text">
<p>I realised that <code>np.power(a, b)</code> is slower than <code>np.exp(b * np.log(a))</code>:</p>
<pre><code>import numpy as np
a, b = np.random.random((2, 100000))
%timeit np.power(a, b) # best of 3: 4.16 ms per loop
%timeit np.exp(b * np.log(a)) # best of 3: 1.74 ms per loop
</code></pre>
<p>The results are the same (with a few numerical errors of order 1e-16). </p>
<p>What additional work is done in <code>np.power</code>? Furthermore, how can I find an answer to these kind of questions myself?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://github.com/numpy/numpy/blob/3b7908d299fc3287486bbe453e2335c1fa50fc29/numpy/core/src/npymath/npy_math_internal.h.src" rel="nofollow noreferrer">Under the hood</a> both expressions call the respective C functions <code>pow</code> or <code>exp</code> and <code>log</code> and <a href="https://gist.github.com/adler-j/a440d4539ad1bbaa7dc3e2727f93e8b1" rel="nofollow noreferrer">running a profiling on those in C++</a>, without any numpy code, gives:</p>
<pre><code>pow      : 286 ms
exp(log) :  93 ms
</code></pre>
<p>This is consistent with the numpy timings. It thus seems like the primary difference is that the C function <code>pow</code> is slower than <code>exp(log)</code>. </p>
<p>Why? It seems that part of the reson is that the expressions are not equivalent for all input. For example, with negative <code>a</code> and integer <code>b</code>, <code>power</code> works while <code>exp(log)</code> fails:</p>
<pre><code>&gt;&gt;&gt; np.power(-2, 2)
4
&gt;&gt;&gt; np.exp(2 * np.log(-2))
nan
</code></pre>
<p>Another example is <code>0 ** 0</code>:</p>
<pre><code>&gt;&gt;&gt; np.power(0, 0)
1
&gt;&gt;&gt; np.exp(0 * np.log(0))
nan
</code></pre>
<p>Hence, the <code>exp(log)</code> trick only works on a subset of inputs, while <code>power</code> works on all (valid) inputs.</p>
<p>In addition to this, <code>power</code> is guaranteed to give full precision according to the <a href="https://en.wikipedia.org/wiki/IEEE_754" rel="nofollow noreferrer">IEEE 754 standard</a>, while <code>exp(log)</code> may suffer from rounding errors.</p>
</div>
<span class="comment-copy">The entire source code is available at <a href="https://github.com/numpy/numpy" rel="nofollow noreferrer">github.com/numpy/numpy</a>, I found several <code>power</code> functions there and can't be sure which is which (I don't invest time in looking through it) but you could try there, just search with quotes "def power" as a start</span>
<span class="comment-copy">@OferSadan Can you tell me a little bit more, where you found these <code>power</code>functions, can't find them myself (turns put NumPy is really big...)</span>
<span class="comment-copy">At the top of the <a href="https://github.com/numpy/numpy" rel="nofollow noreferrer">github page</a> there is a search field. Typing <code>"def power"</code> finds 3 hits.</span>
<span class="comment-copy">Exactly what @unutbu said</span>
<span class="comment-copy">Side note: <code>%timeit a**b</code> gives the same time as <code>%timeit np.power(a,b)</code> for me.</span>
<span class="comment-copy">And as for OP's question about finding answer yourself - I checked debugger for type of: <code>np.power</code>, <code>np.log</code>, <code>np.exp</code> - it was <code>ufunc</code>  and in the documentation of numpy I found that these are defined in <code>generate_umath.py</code> as: <code>pow</code>, <code>log</code> and <code>npy_ObjectPower</code>. The last one is actually C function found in <a href="https://raw.githubusercontent.com/numpy/numpy/d46df62746995481439b650790589e60a8070172/numpy/core/src/umath/funcs.inc.src" rel="nofollow noreferrer">this file</a> and returns <code>PyNumber_Power</code> and this is actually Python's <code>pow</code> <a href="https://docs.python.org/3/c-api/number.html" rel="nofollow noreferrer">according to docs</a></span>
<span class="comment-copy">Moreover, <code>pow()</code> always gives you the full accuracy of double precision floating point numbers, even in cases where the combination of <code>exp()</code> and <code>log()</code> loses a few digits.</span>
<span class="comment-copy">You can actually do the "log trick" with negatives if you assign <code>a = a.astype(complex)</code> and pull the real part, but you lose the speed advantage</span>
<span class="comment-copy">Sure, but you also need to handle <code>a = b = 0</code>!</span>
<span class="comment-copy">True, although<code>0**0=1</code> is more convention than identity, and technically <code>0**0=nan</code> is also correct.  It's just not very useful!</span>
