<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/41708458/assign-environment-variables-from-bash-script-to-current-session-from-python">Assign environment variables from bash script to current session from Python</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I have a script called "script.sh," whose contents are:</p>
<pre><code>#!/bin/sh
export A=5
</code></pre>
<p>I want to execute this script from <em>within</em> python (iPython actually) and read the variable 'A'.</p>
<pre><code>import os
import subprocess

subprocess.call('./script.sh')
A=os.environ['A']
</code></pre>
<p>Unfortunately, this doesn't seem to work, giving me an error that A cannot be found. If I understand correctly, subprocess is actually running in a different shell than the one that os.environ queries. But then why can't I run something like:</p>
<pre><code>subprocess.call('echo $A')
</code></pre>
<p>?</p>
<p>What should I change to make this work? In general, I just want to obtain the value of "A" from the script, preferably by executing the script through some form of shell (the actual script is quite long).</p>
<p>For some more info, the script will contain <em>login credentials</em>, so ideally I'd like a safe,minimalist way of accessing their values.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to source the script in the subshell (so it sets the variable in the same shell process), then echo the variable in that subshell:</p>
<pre><code>a = subprocess.check_output('source ./script.sh; echo "$A"', shell=True)
</code></pre>
<p>Then you can read from the pipe to get the value of the variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>The trick will be to spawn a new shell and tell it to both interpret your script's code, and can print out its environment in a way that Python can read it. A one-liner:</p>
<pre><code>In [10]: subprocess.check_output(["bash", "-c", "source ./script.sh; env"])
Out[10]: '...\nA=5\n...'
</code></pre>
<p>What's happening: In general, environment variables are set at the beginning of a program, and any subprocesses can't modify their parent's environment; it's a sort of sandbox. But <code>source</code> is a bash builtin where bash says "instead of spawning script.sh as a new (sub-)subprocess which couldn't modify my environ, run the lines of code as myself (bash) and modify my environ accordingly for future commands". And <code>env</code> is tacked on so that bash prints the environment separated by newlines. <code>check_output</code> simply grabs that output and brings it back into Python.</p>
<p>(As a side note, that <code>source</code> command is what you use to update a shell to use a certain virtualenv: <code>source my_project/bin/activate</code>. Then the $PATH and other variables of your current shell are updated to use the virtualenv python and libraries for the rest of that session. You can't just say <code>my_project/bin/activate</code> since it would set them in a subshell, doing nothing :))</p>
</div>
<span class="comment-copy">There is nothing you can do to make this work. A subshell can't set environment variables in its parent.</span>
<span class="comment-copy">@DanielRoseman: Right, I've just added an edit. Is there a way I could access it from the subprocess shell? That's the part I don't get</span>
<span class="comment-copy">Yes, you're successfully setting the environment variable in the shell spawned by <code>subprocess.call</code>, which then disappears right after your script runs.</span>
<span class="comment-copy">The subprocess is using a different instance of the shell each time.</span>
<span class="comment-copy"><code>os.environ</code> is captured the first time the <code>os</code> is imported. Even if it wasn't the subprocess, it wouldn't work. <a href="https://docs.python.org/3/library/os.html#os.environ" rel="nofollow noreferrer">docs.python.org/3/library/os.html#os.environ</a></span>
<span class="comment-copy">Thanks for your answer. I'm not an expert at this but from what I understand, shell=true and stdout=PIPE is discouraged in the answers I've seen. Specifically, if my script contains credentials, is this still a good solution?</span>
<span class="comment-copy">I changed it from <code>subprocess.call</code> to <code>subprocess.check_output</code>. Is that still discourged? If so, you should use <code>Popen()</code> and <code>communicate</code>.</span>
<span class="comment-copy">I don't see how credentials in the script are relevant to this.</span>
<span class="comment-copy">If it contains credentials, you shouldn't be <code>export</code>ing them at all unless you're sure your OS protects environment variables from being read out of process metadata (modern systems do, a great many old ones don't).</span>
<span class="comment-copy">@CharlesDuffy I thought he meant there were credentials elsewhere in the script, not that the value of <code>A</code> is credentials, but you're probably right.</span>
<span class="comment-copy">Environment variables can contain literal newlines. This thus isn't a safe way of representing and parsing them.</span>
<span class="comment-copy">(Consider if an attacker were able to set an environment variable, say via CGI's automatic header-&gt;variable mechanism, with a value akin to that created by <code>CGI_X_evil=$'hello\nLD_PRELOAD=/tmp/exploit.so'</code> -- if code parsing the output of <code>env</code> saw <code>LD_PRELOAD=/tmp/exploit.so</code> and then updated your Python program's environment with that, future programs that your Python tool invoked would be running arbitrary code).</span>
<span class="comment-copy">@CharlesDuffy Generally, a good point. OP was only trying to update their Python program's environment as a means to an end; as they explained, all they want to do is read the environment created by the script, and get it as a string in Python. Nobody's talking about using that output as the environment for any future program, or the current program; just extracting trusted environment variables.</span>
