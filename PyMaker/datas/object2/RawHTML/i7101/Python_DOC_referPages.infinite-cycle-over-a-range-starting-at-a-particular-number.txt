<div class="post-text" itemprop="text">
<p>Say I have a range:</p>
<pre><code>r = range(1, 6)
</code></pre>
<p>Using this range, I want to cycle infinitely and yield the numbers as they come:</p>
<pre><code>for i in cycle(r):
    yield(i)
</code></pre>
<p>This would correctly produce values of:</p>
<pre><code>1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, ...
</code></pre>
<p>However, I sometimes want to start the yielding from a specific value but continue on with the range as it's defined. That is, if I want to start at <code>3</code>, the sequence would be:</p>
<pre><code>3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, ...
</code></pre>
<p>Is there a way to do this with a combination of <code>range</code> and <code>cycle</code> (or some other way)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow noreferrer"><code>dropwhile</code></a> until you reach the first value you want to emit:</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle, dropwhile
&gt;&gt;&gt; iterable = dropwhile(lambda x: x &lt; 3, cycle(range(1, 6)))
&gt;&gt;&gt; for _ in range(10):
...     print(next(iterable))
...
3
4
5
1
2
3
4
5
1
2
</code></pre>
<p>Per the docs (emphasis mine):</p>
<blockquote>
<p>Make an iterator that drops elements from the iterable as long as the
  predicate is true; <strong>afterwards, returns every element</strong>.</p>
</blockquote>
<p>The <code>predicate</code> only takes effect until the first value for which it evaluates false-y.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way to do this is to chain two ranges together and pass the chain to <code>cycle</code>.</p>
<pre><code>from itertools import cycle, chain

def shift_cycle(lo, start, stop):
    return cycle(chain(range(start, stop), range(lo, start)))

for t in zip(range(12), shift_cycle(1, 3, 6)):
    print('{}: {}'.format(*t))
</code></pre>
<p><strong>output</strong></p>
<pre><code>0: 3
1: 4
2: 5
3: 1
4: 2
5: 3
6: 4
7: 5
8: 1
9: 2
10: 3
11: 4
</code></pre>
<p>This approach has an advantage over <code>islice</code> or <code>dropwhile</code> if the <code>start</code> and <code>stop</code> args are large because it doesn't need to discard the unwanted initial items.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>cycle</code> starts from the beginning of the iterator given to it, give it an iterator (a sequence in this case) that starts where you want:</p>
<pre><code>r = tuple(range(3,6)) + tuple(range(1,3))
</code></pre>
<p>The <code>1</code> above is the lowest value to repeat, the <code>6</code> is one more than the highest value, and the <code>3</code> used twice is the starting value. It should be clear how to generalize this to other cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>perhaps unesthetic but practical? <code>sys.maxsize</code> being "practically infinite" for many purposes</p>
<pre><code>import sys

r, n = 5, 3
cyc = (i%r + 1 for i in range(n, sys.maxsize))

next(cyc)
Out[106]: 4

next(cyc)
Out[107]: 5

next(cyc)
Out[108]: 1

next(cyc)
Out[109]: 2

next(cyc)
Out[110]: 3

next(cyc)
Out[111]: 4

next(cyc)
Out[112]: 5

next(cyc)
Out[113]: 1
</code></pre>
<p><code>sys.maxsize*1e-9/3600/24/365
Out[117]: 292.471208677536</code> </p>
<p>that's years at 1 ns per request - on a 64 bit system</p>
<p>but of course it runs a bit slower</p>
<pre><code>timeit.timeit('next(cyc)','r, n = 5, 3; cyc = (i%r + 1 for i in range(n, sys.maxsize))')
Out[126]: 0.2556792100261305
</code></pre>
<p>the modulo takes more time as requests keeps upping <code>i</code></p>
<p>but that doesn't seem to be the big time sink</p>
<pre><code>timeit.timeit('max%5', 'max=sys.maxsize')

Out[120]: 0.07545763840474251

timeit.timeit('1111%5')
Out[122]: 0.01156394737682831

timeit.timeit('111%5')
Out[123]: 0.011720469965638358
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you are looking for the <code>islice</code> function</p>
<pre><code>from itertools import islice, cycle
offset = 2
r = range(1, 6)
generator = islice(cycle(r), offset, None)
</code></pre>
</div>
<span class="comment-copy">Did you look into <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow noreferrer"><code>dropwhile</code></a>?</span>
<span class="comment-copy">you could just call <code>next</code> twice and then start looking at the results?</span>
<span class="comment-copy">@jonrsharpe How will that ever produce 1 or 2 in the range if I keep dropping those every time they are encountered??</span>
<span class="comment-copy">@JasonStein I want this to work for an arbitrary start point, obviously...</span>
<span class="comment-copy">Simple way would be to use <code>itertools.islice(itertools.cycle(r), 2, None)</code></span>
<span class="comment-copy">Ohhh! You are very right! When I read through the docs, I understood it as drop while the value <b>always</b> evaluates to Truthy. Thanks, great solution!</span>
<span class="comment-copy">Ha, perfect! Very elegant, thanks!</span>
