<div class="post-text" itemprop="text">
<p>I am calling a function that starts a process that takes longer to execute, many different things are done. This function chiefly handles instances of a particular class, <code>Item</code>. These items are categorized by different attributes: <code>category1</code>, <code>category2</code> and <code>category3</code>.</p>
<p>Now, there is a different model that applies some sort of rules to these categories: <code>Rule</code> with many-to-many attributes: <code>categories1</code>, <code>categories2</code> and <code>categories3</code>. A rule applies to an <code>Item</code>, if the same rule points to different categories, only one of them should be applied. The decision of which one is defined by a certain logic encapsulated in a function:</p>
<pre><code>class Rule(models.Model):
    warehouse = models.ForeignKey('Warehouse')
    categories1 = models.ManyToManyField('Category1')
    categories2 = models.ManyToManyField('Category2')
    categories3 = models.ManyToManyField('Category3')

    @staticmethod
    def get_rules_that_applies(item):
        rules = warehouse.rule_set.all()
        if not rules.exists():
            return None
        # ... determine which rule applies to the item by filtering, etc.
        return rule
</code></pre>
<p>The issue lies in the <code>get_rules_that_applies</code> method. Every time we need to get the rule that applies to a certain item and let me say again that many many items are involved in the process we are talking about, <code>warehouse.rule_set.all()</code> is called.</p>
<p>Since the rules <strong>will not</strong> change during this process, we can just cache all the rules in the ware house, but how? How can I make sure <code>warehouse = warehouse.rule_set.all()</code> is cached and all filtering and QuerySet operations that act on these rules are not hitting the database?</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe that the solution you are seeking is the <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memoization</a> of the <code>get_rules_that_applies</code> method.</p>
<p>There is a tool ready-made for that, called <a href="https://pypi.python.org/pypi/django-memoize" rel="nofollow noreferrer"><code>django-memoize</code></a> and <a href="https://pythonhosted.org/django-memoize/" rel="nofollow noreferrer">those</a> are its docs.</p>
<p>Quick-start on usage:    </p>
<ol>
<li><code>pip install django-memoize</code></li>
<li><p>Place it on your <code>INSTALLED_APPS</code></p>
<pre><code>INSTALLED_APPS = [
    '...',
    'memoize',
]
</code></pre></li>
<li><p>In your <code>model.py</code>:</p>
<pre><code>from memoize import memoize

class Rule(models.Model):
    warehouse = models.ForeignKey('Warehouse')
    categories1 = models.ManyToManyField('Category1')
    categories2 = models.ManyToManyField('Category2')
    categories3 = models.ManyToManyField('Category3')

    @staticmethod
    @memoize(timeout=something_reasonable_in_seconds)
    def get_rules_that_applies(item):
        rules = warehouse.rule_set.all()
        if not rules.exists():
            return None
           # ... determine which rule applies to the item by filtering, etc.
        return rules
</code></pre></li>
</ol>
<hr/>
<p><strong>(Update) A Semi-DIY Approach:</strong></p>
<p>Since my answer, I read the following post: <a href="https://www.peterbe.com/plog/cache_memoize-cache-decorator-for-django" rel="nofollow noreferrer">https://www.peterbe.com/plog/cache_memoize-cache-decorator-for-django</a> which is accompanied by a <a href="https://gist.github.com/peterbe/fd6ffc23325df849b27c549e769ce570" rel="nofollow noreferrer">gist</a> on how to achieve memoization yourself.</p>
<hr/>
<p><strong>A More DIY Approach:</strong></p>
<p><strong>Python 3.2 and up:</strong></p>
<p>The <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>@functools.lru_cache</code></a> decorator which is a:</p>
<blockquote>
<p>Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls. It can save time when an expensive or I/O bound function is periodically called with the same arguments.</p>
</blockquote>
<p>How to use it:</p>
<pre><code>from functools import lru_cache


class Rule(models.Model):
    ...

    @lru_cache(maxsize=a_reasonable_integer_size_of_cache)
    def get_rules_that_applies(item):
        rules = warehouse.rule_set.all()
        if not rules.exists():
            return None
            # ... determine which rule applies to the item by filtering, etc.
        return rules
</code></pre>
<p><code>maxsize</code>: Defines the size of the cache in function calls to be stored. It can be set to <code>None</code> to cache every call.</p>
<p><strong>Python &lt; 3.2</strong></p>
<p>In here <a href="https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python?answertab=votes#tab-top">What is memoization and how can I use it in Python?</a> exist a more "old school" approach.</p>
<hr/>
<p><strong>How to cache a queryset with either of the above methods:</strong></p>
<p>Why not define an intermediate function to form the queryset and cache that functions results?</p>
<pre><code>@lru_cache(maxsize=None)

or 

@memoize()
def middle_function():
    return warehouse.rule_set.all()
</code></pre>
<p>and then in your <code>get_rules_that_applies</code> function:</p>
<pre><code>def get_rules_that_applies(item):
    rules = middle_function()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have 2 option:</p>
<ol>
<li>cache the item in the view</li>
<li>cahce the item in the model</li>
</ol>
<p>The code will be the same in view and in the model, Import cahce:</p>
<pre><code>from django.core.cache import cache
</code></pre>
<p>Code:</p>
<pre><code>if cache.get('query_result') is not None:
    return cache.get('query_result')
else:
    cache.set('query_result', result, 3600)
    #cache.set('cache_name', 'your query', 'expiry time')
    return rule
</code></pre>
<p>Your model will be:</p>
<pre><code>class Rule(models.Model):
warehouse = models.ForeignKey('Warehouse')
categories1 = models.ManyToManyField('Category1')
categories2 = models.ManyToManyField('Category2')
categories3 = models.ManyToManyField('Category3')

@staticmethod
def get_rules_that_applies(item):
    rules = warehouse.rule_set.all()
    if not rules.exists():
        return None
    # ... determine which rule applies to the item by filtering, etc.
    if cache.get('query_result') is not None:
        return cache.get('query_result')
    else:
        cache.set('query_result', result, 3600)
        #cache.set('cache_name', 'your query', 'expiry time')
        return rule

    return rule
</code></pre>
<p>Few info about Django query, When they are evaluated?:</p>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/1.11/ref/models/querysets/#when-querysets-are-evaluated" rel="nofollow noreferrer">https://docs.djangoproject.com/en/1.11/ref/models/querysets/#when-querysets-are-evaluated</a></p>
</blockquote>
<p>Hope this help</p>
</div>
<span class="comment-copy">What is warehouse in get_rules_that_applies?</span>
<span class="comment-copy">@DimaKudosh yeah I should have mentioned it: the <code>warehouse</code> is like the "master/context" object where all the process happens. Everything in the app revolves around a single <code>warehouse</code> instance.</span>
<span class="comment-copy">I'm not really after a cache with a timeout, it can and should be cashed during the entire lifecycle of the execution of the process (you can easily tell when it finishes when the <code>warehouse</code> instance is freed up from memory). Also, that would cache the rule for the item right? (since it's caching the function results) Can't I just force-cache a queryset?</span>
<span class="comment-copy">@dabadaba I made an edit on how to cache a queryset as I imagine it :)  Btw, for <code>memoize</code> I don't know, but the <code>lru_cache</code> doesn't seem to have a timeout.</span>
<span class="comment-copy">I just realized I can't use <code>django-memoize</code> because my Django version is older.</span>
<span class="comment-copy">@dabadaba You can still use the <code>@lru_cache</code> though or create your own as shown here: <a href="https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python?answertab=votes#tab-top" title="what is memoization and how can i use it in python">stackoverflow.com/questions/1988804/â€¦</a></span>
<span class="comment-copy">using Python 2.7 so I guess I can't</span>
<span class="comment-copy">this would be caching the rule that applies to the item, not the source queryset of rules</span>
