<div class="post-text" itemprop="text">
<p>I'm fairly new in 'recursive functions'. So, I'm trying to wrap my head around why we use recursive functions and how recursive functions work and I think I've a fairly good understanding about it.</p>
<p>Two days ago, I was trying to solve the shortest path problem. I've a following graph(it's in python): </p>
<pre><code> graph = {'a': ['b', 'c'],
             'b': ['c', 'd'],
             'c': ['d'],
             'd': ['c'],
             'e': ['f'],
             'f': ['c']}
</code></pre>
<p>I'm just trying to find a path, not the shortest path.So, here is the code:</p>
<pre><code>def find_path(graph,start,end,path=[]):
    path = path + [start]
    #Just a Test
    print(path)

    if start == end:
        return path

    if start not in graph:
        return None

    for node in graph[start]:
        if node not in path:
            new_path = find_path(graph,node,end,path)
        if new_path:
            #Just a test
            print(path)
            return new_path

print(find_path({'a':['b','c'],'b':['c','d'],'c':['d'],'d':['c'],'e':
['f'],'f':['c']},'a','d'))
</code></pre>
<p>My starting vertex is 'a' and the ending vertex is 'd'.</p>
<p>In the fourth line I just printed the 'path' to see where the path goes.</p>
<p>On line 17th I also printed the 'path', again just to test. And here is the result: </p>
<pre><code>['a']
['a', 'b']
['a', 'b', 'c']
['a', 'b', 'c', 'd']
['a', 'b', 'c']
['a', 'b']
['a']
['a', 'b', 'c', 'd']
</code></pre>
<p>The first four lines of the result is the result of 'print(path)' on line 4 of the code. But, line 5th, 6th and 7th is the result of 'print(path)' on line 17th of the code.</p>
<p>My question is why the list of the path is decreasing by one vertex each time?</p>
<p>I've been trying to find it's solution for 2 days. I've went to forums, read the documentation about recursion and watched videos. But, no luck.</p>
<p>I would be greatful if somebody can answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>First I am just going to give an explanation of what backtracking means. I also posted this answer <a href="https://stackoverflow.com/questions/35255028/how-to-solve-sudoku-by-backtracking-and-recursion/35255295#35255295">here</a>. </p>
<p>Recursion means to call the function from within that same function. Now what happens is that when the function encounters a call to itself.. imagine that a new page opens up and control is transferred from the old page onto this new page to the start of the function, when the function encounters the call again in this new page, another page opens up beside it and in this way new pages keep popping up beside the old page. Do note that all the local variables are only in scope with their respective pages. That is if you want to access the value in the previous page you either pass it to the function in parameters or make the variable global.</p>
<p>The only way to go back is using return statement. When the function encounters it the control goes from the new page back to the old page on the same line from where it was called and starts executing whatever is below that line. This is where backtracking starts. In order to avoid issues like feeding data again when its filled up you usually need to put a return statement after every call to the function.</p>
<p>Now in your code, </p>
<pre><code>def find_path(graph,start,end,path=[]):
    path = path + [start]
    #Just a Test
    print(path)

    if start == end:
        return path

    if start not in graph:
        return None

    for node in graph[start]:
        if node not in path:
            new_path = find_path(graph,node,end,path)  &lt;---- when function returns it will start executing from here again.
        if new_path:
            #Just a test
            print(path)
            return new_path
</code></pre>
<p>And note that your <code>path</code> variable is not a global variable. It's a local. This means everytime you call its resetted. To avoid this you are passing the path value again in the function parameters (in the last). </p>
<p>So finally when the function returns after it has found <code>d</code> it returns to the previous state where the path variable has only <code>a, b, c</code> in it. that's what you print out.</p>
<p>Edit:- Just in case anybody objects, my explanation of recursion using pages is purely non-technichal, if you want to know how it really happens then you'll have to read about activation record and how it pushes all the state onto a stack</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because recursion yields results from "innermost" to "outermost" calls. That is the first line 17 <code>print</code> statement occurs from the deepest recursion level where the path has the most nodes. After that level returned the next level "upwards" is printed (one node less in the path). Note that your <code>print</code> function comes <em>after</em> the recursive call to <code>find_path</code>.</p>
<p>You can visualize it as follows:</p>
<pre><code>find_path(..., path=['a'])  # Recursion level 1.
|
|   find_path(..., path=['a', 'b'])  # Recursion level 2.
|   |
|   |   find_path(..., path=['a', 'b', 'c'])  # Recursion level 3.
|   |   print(path)  # Prints ['a', 'b', 'c'].
|   |   return  # Return from level 3.
|   |
|   print(path)  # Prints ['a', 'b'].
|   return  # Return from level 2.
|
print(path)  # Prints ['a'].
return  # Return from level 1.
</code></pre>
<p>If you want the single (sub-)paths to be printed in "increasing" order then you can simply place the <code>print</code> function <em>before</em> the recursive call to <code>find_path</code>.</p>
<p>It's the <code>new_path</code> variable which holds the recursively found path while <code>path</code> just holds the path to the current node.</p>
<p>By the way the <code>if new_path:</code> clause might fail if the previous <code>if</code> branch has not been entered yet because then <code>new_path</code> is undefined.</p>
</div>
<div class="post-text" itemprop="text">
<p>1) The <code>find_path</code> method is first called with <code>a</code> as the start node which sets the path as <code>['a']</code> and calls the <code>find_path</code> method with <code>b</code> as the start node before printing path on line 17.</p>
<p>2) The call to <code>find_path</code> method with <code>b</code> as the start node sets the path as <code>['a','b']</code> and calls the <code>find_path</code> method with <code>c</code> as the start node before printing path on line 17.</p>
<p>3) The call to <code>find_path</code> method with <code>c</code> as the start node sets the path as <code>['a','b','c']</code> and calls the <code>find_path</code> method with <code>d</code> as the start node before printing path on line 17.</p>
<p>4) The call to <code>find_path</code> method with <code>d</code> as the start node sets the path as <code>['a','b','c','d']</code> prints it on line 4 and returns.</p>
<p>5) Now it returns on line 14 in the execution of method <code>find_path</code> with <code>c</code> as the start node (which had set the path as <code>['a','b','c']</code> as mentioned in point 3)  and prints path on line 17 (which is line 5th of your result) and returns.</p>
<p>6) This returns on line 14 in the execution of method <code>find_path</code> with <code>b</code> as the start node (which had set the path as <code>['a','b']</code> as mentioned in point 2) and prints path on line 17 (which is line 6th of your result) and returns.</p>
<p>7) This returns on line 14 in the execution of method <code>find_path</code> with <code>a</code> as the start node (which had set the path as <code>['a']</code> as mentioned in point 1) and prints path on line 17 (which is line 6th of your result) and returns.</p>
<p>You can imagine it as LIFO (Last In First Out)</p>
</div>
<span class="comment-copy">BTW, you need to be careful when using mutable default arguments like <code>path</code>. Please see <a href="https://stackoverflow.com/q/1132941/4014959">“Least Astonishment” and the Mutable Default Argument</a>.</span>
<span class="comment-copy">Actually the reason why the list of vertices is decreasing by one for each line is due to the fact that you perform the recursive call to <code>find_path</code> <i>before</i> the <code>print</code> function. If you want the lists to be printed in opposite order then you can <i>first</i> <code>print(path)</code> and <i>after that</i> perform the recursive call to <code>find_path</code>.</span>
<span class="comment-copy">wow! wandering-warrior your page to page analogy is very helpful.I understood very well.Thank you!</span>
<span class="comment-copy"><i>"The only way to go back is using return statement."</i> - The same is possible using <code>yield</code> (nesting generators via <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer"><code>yield from</code></a>).</span>
<span class="comment-copy">yea sorry actually copied this from another question i answered. Not going into language specifics and just keepin it simple :)</span>
<span class="comment-copy">@a_guest Good point, and this problem is definitely a great candidate for a recursive generator. But it's probably a Good Idea for Protul to master simple recursion first before investigating the wonderful world of recursive generators. I'm not claiming that recursive generators are particularly difficult, and in many cases they actually simplify the code, but I think you'll agree that they are conceptually more advanced than traditional recursion.</span>
<span class="comment-copy">I suppose this mechanism is more often referred to as <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="nofollow noreferrer">"LIFO"</a> (Last In, First Out).</span>
<span class="comment-copy">Thanks @a_guest. Updated it.</span>
