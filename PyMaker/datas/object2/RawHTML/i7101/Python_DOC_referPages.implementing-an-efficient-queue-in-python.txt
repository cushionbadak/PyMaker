<div class="post-text" itemprop="text">
<p>I have been trying to implement a queue in Python, and I've been running into a problem. </p>
<p>I am attempting to use lists to implement the Queue data structure, however I can't quite figure out how to make <code>enqueue</code> and <code>dequeue</code> O(1) operations. </p>
<p>Every example I have seen online, seems to just append the <code>enqueue</code> operation and remove the first element from the list for the <code>dequeue</code> operation. But this would make the <code>dequeue</code> operation O(n) (where n is the size of the list) correct?</p>
<p>Is there something basic I have missed? Or do you have to use LinkedLists to implement a Queue efficiently? </p>
<pre><code>import unittest

class Queue():
    def __init__(self):
        self._queue = []
        self.size = 0
        self.maxSize = 10

    def enqueue(self, item):
        if self.size &lt; self.maxSize:
            self._queue.append(item)

    def dequeue(self):
        '''
        Removes an item from the front of the list. Remove first element of
        the array
        '''
        first = self._queue[0]
        del self._queue[0]
        return first
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/users/1097347/uri-goren">Uri Goren</a> astutely <a href="https://stackoverflow.com/questions/45688871/implementing-an-efficient-queue-in-python#comment78335497_45688871">noted above</a>, the Python stdlib already implemented an efficient queue on your fortunate behalf: <a href="https://docs.python.org/3/library/collections.html#deque-objects" rel="nofollow noreferrer"><code>collections.deque</code></a>.</p>
<h2>What Not to Do</h2>
<p>Avoid reinventing the wheel by hand-rolling your own:</p>
<ul>
<li><a href="https://stackoverflow.com/a/48459059/2809027">Linked list implementation</a>. While doing so reduces the worst-case time complexity of your <code>dequeue()</code> and <code>enqueue()</code> methods to O(1), the <code>collections.deque</code> type already does so. It's also thread-safe and presumably more space and time efficient, given its C-based heritage.</li>
<li><a href="https://stackoverflow.com/a/48577248/2809027">Python list implementation</a>. As I <a href="https://stackoverflow.com/questions/45688871/implementing-an-efficient-queue-in-python#comment85545411_48577248">note below</a>, implementing the <code>enqueue()</code> methods in terms of a Python list increases its worst-case time complexity to <strong>O(n).</strong> Since removing the last item from a C-based array and hence Python list is a constant-time operation, implementing the <code>dequeue()</code> method in terms of a Python list retains the same worst-case time complexity of O(1). But who cares? <code>enqueue()</code> remains pitifully slow.</li>
</ul>
<p>To quote the <a href="https://docs.python.org/3/library/collections.html#deque-objects" rel="nofollow noreferrer">official <code>deque</code> documentation</a>:</p>
<blockquote>
<p>Though <code>list</code> objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for <code>pop(0)</code> and <code>insert(0, v)</code> operations which change both the size and position of the underlying data representation.</p>
</blockquote>
<p>More critically, <code>deque</code> <em>also</em> provides out-of-the-box support for a maximum length via the <code>maxlen</code> parameter passed at initialization time, obviating the need for manual attempts to limit the queue size (which inevitably breaks thread safety due to race conditions implicit in if conditionals).</p>
<h2>What to Do</h2>
<p>Instead, implement your <code>Queue</code> class in terms of the standard <code>collections.deque</code> type as follows:</p>
<pre><code>from collections import deque

class Queue():
    '''
    Thread-safe, memory-efficient, maximally-sized queue supporting queueing and
    dequeueing in worst-case O(1) time.
    '''


    def __init__(self, max_size = 10):
        '''
        Initialize this queue to the empty queue.

        Parameters
        ----------
        max_size : int
            Maximum number of items contained in this queue. Defaults to 10.
        '''

        self._queue = deque(maxlen=max_size)


    def enqueue(self, item):
        '''
        Queues the passed item (i.e., pushes this item onto the tail of this
        queue).

        If this queue is already full, the item at the head of this queue
        is silently removed from this queue *before* the passed item is
        queued.
        '''

        self._queue.append(item)


    def dequeue(self):
        '''
        Dequeues (i.e., removes) the item at the head of this queue *and*
        returns this item.

        Raises
        ----------
        IndexError
            If this queue is empty.
        '''

        return self._queue.pop()
</code></pre>
<p>The proof is in the hellish pudding:</p>
<pre><code>&gt;&gt;&gt; queue = Queue()
&gt;&gt;&gt; queue.enqueue('Maiden in Black')
&gt;&gt;&gt; queue.enqueue('Maneater')
&gt;&gt;&gt; queue.enqueue('Maiden Astraea')
&gt;&gt;&gt; queue.enqueue('Flamelurker')
&gt;&gt;&gt; print(queue.dequeue())
Flamelurker
&gt;&gt;&gt; print(queue.dequeue())
Maiden Astraea
&gt;&gt;&gt; print(queue.dequeue())
Maneater
&gt;&gt;&gt; print(queue.dequeue())
Maiden in Black
</code></pre>
<h2>It Is Dangerous to Go Alone</h2>
<p>Actually, <strong>don't do that either.</strong></p>
<p>You're better off just using a raw <code>deque</code> object rather than attempting to manually encapsulate that object in a <code>Queue</code> wrapper. The <code>Queue</code> class defined above is given <em>only</em> as a trivial demonstration of the general-purpose utility of the <code>deque</code> API.</p>
<p>The <code>deque</code> class provides <a href="https://docs.python.org/3/library/collections.html#deque-objects" rel="nofollow noreferrer">significantly more features</a>, including:</p>
<blockquote>
<p>...iteration, pickling, <code>len(d)</code>, <code>reversed(d)</code>, <code>copy.copy(d)</code>, <code>copy.deepcopy(d)</code>, membership testing with the in operator, and subscript references such as <code>d[-1]</code>.</p>
</blockquote>
<p>Just use <code>deque</code> anywhere a single- or double-ended queue is required. That is all.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can keep head and tail node instead of a queue list in <code>queue class</code></p>
<pre><code>class Node(object):
  def __init__(self, item = None):
    self.item = item
    self.next = None
    self.previous = None


class Queue(object):
  def __init__(self):
    self.length = 0
    self.head = None
    self.tail = None

  def enqueue(self, x):
    newNode = Node(x)
    if self.head == None:
      self.head = self.tail = newNode
    else:
      self.tail.next = newNode
      newNode.previous = self.tail
      self.tail = newNode
    self.length += 1


  def dequeue (self):
    item = self.head.item
    self.head = self.head.next 
    self.length -= 1
    if self.length == 0:
      self.last = None
    return item
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Queue implementation using list in Python, handling enqueue and dqueue as per inbuild queue data structure:</p>
<pre><code>    class queue:

def __init__(self, max_size, size=0, front=0, rear=0):
    self.queue = [[] for i in range(5)] #creates a list [0,0,0,0,0]
    self.max_size = max_size
    self.size = size
    self.front = front
    self.rear = rear


def enqueue(self, data):
    if not self.isFull():
        self.queue[self.rear] = data
        self.rear = int((self.rear + 1) % self.max_size)
        self.size += 1
    else:
        print('Queue is full')

def dequeue(self):
    if not self.isEmpty():
        print(self.queue[self.front], 'is removed')
        self.front = int((self.front + 1) % self.max_size)
        self.size -= 1
    else:
        print('Queue is empty')

def isEmpty(self):
    return self.size == 0

def isFull(self):
    return self.size == self.max_size

def show(self):
    print ('Queue contents are:')
    for i in range(self.size):
        print (self.queue[int((i+self.front)% self.max_size)])

    # driver program
    q = queue(5)
    q.enqueue(1)
    q.enqueue(2)
    q.enqueue(3)
    q.enqueue(4)
    q.enqueue(5)
    q.dequeue()
    q.show()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In dequeue method there is no any loop. You only have to do list operations. Therefore the time complexity for dequeue is also O(n)(linear).</p>
<pre><code>class Queue:
    def __init__(self):
       self.items=[]
    def enqueue(self,item):
       self.items.append(item)
    def dequeue(self):
       return self.items.pop(0)
    def isEmpty(self):
       return self.items==[]
    def __len__(self):
       return len(self.items)
</code></pre>
</div>
<span class="comment-copy">Why not use <code>collections.deque</code> ?</span>
<span class="comment-copy">In your example, shouldn't <code>Maiden in Black</code> be the first thing off the queue?  I would think your <code>dequeue</code> method would use <code>self._queue.popleft()</code> (<code>popleft</code> instead of <code>pop</code>).  Then again, this just goes to show another problem with rolling one's own. :)</span>
<span class="comment-copy"><b>No.</b> Python lists are internally implemented as <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">C arrays</a> rather than linked lists. While the average and amortized worst-case times for appending to Python lists <i>is</i> O(1), the non-amortized worst-case time for the above <code>self.items.append(item)</code> call is <b>O(n)</b> (i.e., linear rather than constant). Ergo, your <code>enqueue</code> implementation <i>does</i> effectively contain an implicit loop. While that loop is presumably implemented via an efficient assembly-based contiguous memory copy, efficient alternatives requiring <i>no</i> such copy are well-known.</span>
