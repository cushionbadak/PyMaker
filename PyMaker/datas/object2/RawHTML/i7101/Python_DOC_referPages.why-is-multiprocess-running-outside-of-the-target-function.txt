<div class="post-text" itemprop="text">
<p>I have this code:</p>
<pre><code>import multiprocessing
with open('pairs.txt') as f:
    pairs = f.read().splitlines()

print(pairs)


def worker(pairtxt):
    print(pairtxt)

if __name__ == '__main__':
    jobs = []
    for i in pairs:
        p = multiprocessing.Process(target=worker, args=(i,))
        jobs.append(p)
        p.start()
</code></pre>
<p>When I run this, it outputs pairs variable(not pairtxt) 3 times, I'm guessing once by itself and twice by the multiprocessing but why is it even running outside the target function?</p>
<p>My output I'm getting with pairs.txt containing 2 lines "1" and "2"</p>
<pre><code>['1', '2']
['1', '2']
1
['1', '2']
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try moving the <code>with open</code> and <code>print(pairs)</code> statements into your <code>if __name__ == '__main__'</code> block. </p>
<p>I suspect that python is running the full script every time the subprocess is called, as it wants to ensure that all of the dependencies are met (imports and such) for the function that you hand it. By having running code in your script that's outside of your <code>main</code> block, it's running that every time your subprocess is run as well. </p>
<pre><code>import multiprocessing
def worker(pairtxt):
    print(pairtxt)

if __name__ == '__main__':
    with open('pairs.txt') as f:
        pairs = f.read().splitlines()

    print(pairs)
    jobs = []
    for i in pairs:
        p = multiprocessing.Process(target=worker, args=(i,))
        jobs.append(p)
        p.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because Python is a dynamic language. When importing a module, all toplevel statements in that module are executed. The reason you usually don't notice is that many modules only declare things, or at least check if they're the main module before performing actions. </p>
<p>In your example, you have a completely unconditional section loading a file and printing its contents before you even define the worker function. This may or may not execute once per process in multiprocessing; it wouldn't on unixlikes where fork is available, because they can simply clone the existing process instead of importing the module anew. </p>
<p>This is documented under <a href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods" rel="nofollow noreferrer">Safe importing of main module</a>, and is a frequent gotcha of multiprocessing. </p>
</div>
<span class="comment-copy">What are you trying to achieve? We have no idea what is inside pairs.txt :)</span>
<span class="comment-copy">For the processes to run on the function only and output the line they are assigned by "for i in pairs" which works fine but, it is printing pairs which mean that the process is running outside the function and seems to be running my entire script. Inside pairs.txt is just 2 lines of simple words.</span>
<span class="comment-copy">I have used pairs = [1, 2] and ran the code and it printed "1" first, then "2".</span>
<span class="comment-copy">I edited my main post with my results to better explain.</span>
<span class="comment-copy">Try moving the <code>with open</code> and <code>print(pairs)</code> statements into your <code>if __name__ == '__main__'</code> block.</span>
