<div class="post-text" itemprop="text">
<p>I'm trying to use Hy, which is a Lisp dialect built on top of Python.</p>
<p>I've tried running the following, but, as expected, I get an <code>AttributeError: Cannot overwrite NamedTuple attribute __init__</code>.</p>
<pre><code>(defclass Key [NamedTuple]
  ;; Simple container for holding keywords
  (defn --init-- [self KEY IDX END]
    (setv self.KEY KEY)
    (setv self.IDX IDX)
    (setv self.END END)))
</code></pre>
<p>On the other hand, I don't know which syntax to use for defining field variables in a class. I've tried the following, but it raises a <code>NameError: name 'KEY' is not defined</code>.</p>
<pre><code>(defclass Key [NamedTuple]
  (setv self.KEY KEY)
  (setv self.IDX IDX)
  (setv self.END END))
</code></pre>
<p>So how exactly do I set field variables in a Lispy/Python class?</p>
</div>
<div class="post-text" itemprop="text">
<p>
Named tuples from Python's standard library don't need a class declaration. You create the class using a function call.</p>
<pre class="lang-clj prettyprint-override"><code>=&gt; (import [collections [namedtuple]])
=&gt; (namedtuple 'Point3D '[x y z])
&lt;class '__console__.Point3D'&gt;
=&gt; (setv Point3D _)  ; Hy's repl sets _ to the previous result.
=&gt; (Point3D 1 2 3)
Point3D(x=1, y=2, z=3)
</code></pre>
<p>Named tuple instances are immutable, like normal Python tuples. You can't assign to them.</p>
<p>Python lets you set arbitrary attributes on most objects though. Here's an example of doing that in Hy.</p>
<pre class="lang-clj prettyprint-override"><code>=&gt; (setv spam (fn[]))
=&gt; (setv spam.x 7)
=&gt; spam.x
7
</code></pre>
<p>In the above example, I set an attribute <code>x</code> on an empty function object. Some objects don't have an attribute dict though. You can create such objects yourself using the <code>__slots__</code> syntax. (See the <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__" rel="nofollow noreferrer">Python documentation</a> for how this works.)</p>
<p>In Python (and Hy) <code>self</code> doesn't exist in a class declaration, only in methods, because it's the first argument. That's why you can't assign to it. You can just <code>setv</code> a name directly instead, but that puts in in the class dict, not in any particular instance.</p>
<pre class="lang-clj prettyprint-override"><code>=&gt; (defclass Foo []
... (setv class-foo 7)  ; lives in the class dict
... (defn __init__ [self foo]
...   (setv self.foo foo)))  ; lives in the instance dict
=&gt; Foo.class-foo
7
=&gt; (. (Foo 12) foo)  ; the (.) form accesses attributes.
12
=&gt; (. (Foo 12) class-foo)  ; not in the instance, so look in its class
7
</code></pre>
<hr/>
<p>Hy does not yet have a syntax for Python's type annotations. The <code>NamedTuple</code> metaclass uses these. You can work around this in some cases by creating the <code>__annotations__</code> dict yourself.</p>
<pre class="lang-clj prettyprint-override"><code>(import [collections [OrderedDict]]
        [typing [NamedTuple]])

(defclass Key [NamedTuple]
  (setv (get (vars) '__annotations__)
        (doto (OrderedDict)
              (assoc 'KEY KEY
                     'IDX IDX
                     'END END))))
</code></pre>
<p>This should work the same as the Python</p>
<pre class="lang-py prettyprint-override"><code>class Key(NamedTuple):
    KEY: KEY
    IDX: IDX
    END: END
</code></pre>
<p>Though it actually compiles to something more like</p>
<pre class="lang-py prettyprint-override"><code>class Key(NamedTuple):
    :G_1235 = OrderedDict()
    :G_1235[HySymbol('KEY')] = KEY
    :G_1235[HySymbol('IDX')] = IDX
    :G_1235[HySymbol('END')] = END
    vars()[HySymbol('__annotations__')] = :G_1235
</code></pre>
<p>There are other ways to create an <code>OrderedDict</code> in Hy, but this is one of the most straightforward. We need the annotations dict to be ordered because <code>NamedTuple</code>s are ordered.</p>
<p>A <code>HySymbol</code> is-a Python string (subclass), and works the same in most contexts. The <code>:G_1235</code> is a Hy gensym name. These aren't Python valid identifiers, but Hy compiles to Python Abstract Syntax Trees and the AST will accept names like that. You can see for yourself how Hy compiles things in the repl with the <code>--spy</code> option or <code>(disassemble ...)</code> function for either the AST itself, or its approximate Python equivalent.</p>
<p>You can also provide a default value for <code>NamedTuple</code> by assigning to a name you've annotated in the class body with <code>setv</code>.</p>
<hr/>
<p>If you're on Python 3.6+ (and you would be given the <code>NamedTuple</code> metaclass), then you can use kwargs to make an <code>OrderedDict</code>, due to <a href="https://www.python.org/dev/peps/pep-0468/" rel="nofollow noreferrer">PEP 468</a>. Don't make <code>OrderedDict</code>s this way in earlier versions where the order of kwargs is not guaranteed.</p>
<p>In Hy,</p>
<pre class="lang-clj prettyprint-override"><code>(defclass Foo [NamedTuple]
  (setv (get (vars) '__annotations__)
        (OrderedDict :name str
                     :ID int)
        name "foo"
        ID 42))
</code></pre>
<p>Note that one <code>setv</code> can assign multiple pairs. Those last two pairs are used by the metaclass as the <code>NamedTuple</code> defaults.</p>
<p>At the repl</p>
<pre class="lang-clj prettyprint-override"><code>=&gt; (Foo)
Foo(name='foo', ID=42)
=&gt; (Foo "bar")
Foo(name='bar', ID=42)
=&gt; _.ID
42
</code></pre>
</div>
<span class="comment-copy">You can in fact create new named tuples in Python 3.6 using <code>typing.NamedTuple</code> though. See <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">@bjd2385 Oh, that's a new feature. It's using a metaclass and type annotations. Hy does not yet support Python's type annotations at all, so I don't think the equivalent can work in Hy. I'll update the answer with a workaround.</span>
<span class="comment-copy">@bjd2385 see the workaround above</span>
