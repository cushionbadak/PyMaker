<div class="post-text" itemprop="text">
<p>I have a file named <code>fin</code>that I need to modify.</p>
<p>In Python I created a script that makes the modifications I need and then save it in new file named <code>fout</code>.</p>
<p>The older file is useless to me, so I use <code>os.remove('fin')</code> to remove it. However, the modified file should be named <code>fin</code>, so I use <code>os.rename('fout','fin')</code>.</p>
<p>I thought about a shortcut that is straight up using<code>os.rename('fout','fin')</code>, expecting it to delete <code>fin</code> since it's the same name, but I`m not sure if this is in fact deleting my older file or if it may cause some trouble if I do this several times (doing this task over a 1000 times).</p>
<p>My question is: is this the cleanest and fastest way to achieve this goal? In summary I just want to make corrections in the original file and overwriting it.</p>
<p>code:</p>
<pre><code>import os

f = open('fin','w') 
f.write('apples apple apples\napple apples apple\napples apple apples') 
f.close()

with open('fin', 'rt') as fin:
   with open('fout', 'wt') as fout:
      for line in fin:
         fout.write(line.replace('apples', 'orange'))
os.rename('fout', 'fin')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your pattern works on POSIX systems, but won't work on Windows. I'd recommend <a href="https://docs.python.org/3/library/os.html#os.replace" rel="nofollow noreferrer">using <code>os.replace</code></a> which replaces existing files in an OS agnostic fashion. It requires Python 3.3 or higher, but then, new code should generally be targetting Python 3 anyway.</p>
<p>It's the preferred pattern because it guarantees atomicity; the <code>fin</code> file is always in a complete state, either before or after, with no risk of failures leading to it existing in a partial/corrupt state.</p>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't seem from your example that you would have a reason to iterate through the file line by line. If that is the case this is a pretty simple solution.</p>
<pre><code>f = open('fin','w').write('apples apple apples\napple apples apple\napples apple apples')

s = open('fin').read().replace('apples', 'oranges')
open('fin','w').write(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the sake of cross compatibilty, I recommend you invert the <strong>with</strong> code. My suggestion code is</p>
<pre><code>f = open('fin','w') 
f.write('apples apple apples\napple apples apple\napples apple apples') 
f.close()

with open('fout', 'wt') as fout:
    with open('fin', 'rt') as fin:
        for line in fin.readlines():
            fout.write(line.replace('apples', 'orange'))
    os.unlink('fin')
    os.rename('fout', 'fin')
</code></pre>
</div>
<span class="comment-copy">According to the documentation this will most likely work on Unix (across different filesystems can fail) but it will not work Windows. <a href="https://docs.python.org/3.6/library/os.html?highlight=rename#os.rename" rel="nofollow noreferrer"><b>RTFM</b></a></span>
<span class="comment-copy">Yes, it's deleting the old file (if there are no hardlinks to it). No, it won't fail if repeated, if you're on an OS with POSIX semantics.</span>
<span class="comment-copy">@ChristianDean, a rename after the new file is closed makes the operation atomic -- a reader will see one or the other, but even if your program crashes, you'll never leave a half-written file. Directly rewriting doesn't offer that guarantee. (There are actually some subtle caveats around when the rename operation itself is flushed to disk, but they're outside the scope of a comment).</span>
<span class="comment-copy">@ChristianDean modifying the original file would not guarantee an atomic operation, i.e. it could fail in the middle in an unknown state. Using another file ensures you don't end up in an unknown state.</span>
<span class="comment-copy">@Evan no because it would create an exception and <code>fin</code> would never be changed from the old state. So you would be in a known state not the new state. The worst position to be in is an unknown state.</span>
<span class="comment-copy">Note that this <i>"may fail if src and dst are on different filesystems"</i> (from the docs you linked). The safe way to do this would be to <code>shutil.move</code> the file to the destination folder, then <code>os.replace</code> as a 2nd step.</span>
<span class="comment-copy">@Rawing: The files were already opened in the same folder, so that's generally not a concern.</span>
<span class="comment-copy">Thanks for answering! In summary, <code>os.replace</code> will always guarantee atomicity whereas <code>os.remove</code> won't? Therefore, there's no particular reason for opting for 'os.remove' before renaming a file back to its original name?</span>
<span class="comment-copy">@yellow01: Doing <code>os.remove</code> followed by <code>os.rename</code> leaves a race condition where: 1. A crash could leave you with <code>fout</code> and no <code>fin</code> 2. A new <code>fin</code> could be created, causing <code>os.rename</code> to fail (on Windows). <code>os.replace</code> is guaranteed atomic; <code>fin</code> will contain the complete old or new data, period. In a crash state, you might have an <code>fout</code> with partial or garbage data, but <code>fin</code> is always at a known good state. <code>os.remove</code> followed by <code>os.rename</code> can't make that guarantee.</span>
<span class="comment-copy">Line by line iteration makes the code more scalable and writing to a new file then replacing is safer. If the real files might be a GB or more in size, reading the whole thing in, replacing, then writing out could easily end up slower, or not work at all, depending on whether you have the RAM to hold it all, and whether the file is large enough to exceed virtual address space (on a 32 bit version of Python). Not using separate files breaks atomicict; a failure during write could leave a corrupt file, rather than guaranteeing you see old or new state only, not some corrupt intermediate one.</span>
<span class="comment-copy">You are completely correct, but details about usage were not specified in the question. He only mentioned doing this "over 1000 times", which would suggest lots of smaller files to me. I don't see any need to make all code scalable to GB file sizes by default unless there is some sort of expectation that you might want to use that code for enormous files at a later date.</span>
<span class="comment-copy">Sorry, just edited my comment to add the other concern: Atomicity. A failure in your code gives no guarantees on file contents; all the data could be lost on a failure (e.g. hitting Ctrl-C at just the wrong time, power loss, etc.), because there are phases in which the old data is gone, and the new data is not synced to disk.</span>
<span class="comment-copy">Oh, and pedantic point: Without using <code>with</code> statements, there are no guarantees on the files being closed promptly. On CPython, you're okay (at least for now), but on any other version of Python, you might have opened <code>fin</code> for write (truncating it), written the new data to the file buffer, but it could take an indeterminate amount of time before the buffer is flushed and the file closed, widening the race condition in which a crash would corrupt the file. <i>Always</i> use <code>with</code> statements for files.</span>
<span class="comment-copy">@yellow01: Even at 1 B, not using separate files with atomic renames leaves a race. Opening a file for write immediately truncates it, and the write itself must (definitionally) occur later. In between, your data exists <i>nowhere</i> but in memory, and could be lost for any number of reasons. So you still need to use separate files with atomic <code>os.replace</code>. That said, if you have known small files, you could run faster by reading in the whole <code>fin</code>, doing your string operation all at once, then writing the whole thing to <code>fout</code>; memory concerns don't arise, and bulk operations can be faster.</span>
<span class="comment-copy">Umm... You're reading from <code>fout</code> (which doesn't exist), writing to <code>fin</code> (losing whatever it had), then replacing <code>fin</code> with <code>fout</code> (losing whatever you might have managed to write).</span>
<span class="comment-copy">@ShadowRanger ... Sorry, was focusing on the <b>with</b> section of the code. Fixed now.</span>
<span class="comment-copy">Still problematic. You <code>unlink</code> and overwrite <code>fin</code> before you've closed <code>fout</code>, so data may still be in buffers, not on disk. You'd want those operations outside the <code>with</code> block. Also, using <code>.readlines()</code> here is pointless and just slows things down; files are already lazy iterables of their lines; calling <code>.readlines()</code> makes it an eager read that delays processing and consumes potentially unbounded memory. Even with all that fixed, you haven't actually changed anything for the better. Inverting <code>with</code> blocks accomplishes nothing except possibly creating <code>fout</code> when <code>fin</code> doesn't exist.</span>
<span class="comment-copy">Also, as noted elsewhere, <code>unlink</code> followed by <code>rename</code> can never be atomic (in fact, it's guaranteed non-atomic on all OSes, where <code>rename</code> is atomic on POSIX systems); <code>os.replace</code> is atomic everywhere, as long as you've closed (and thereby flushed buffers to disk) first.</span>
<span class="comment-copy">Code working now. You can supply a better answer if you have.</span>
