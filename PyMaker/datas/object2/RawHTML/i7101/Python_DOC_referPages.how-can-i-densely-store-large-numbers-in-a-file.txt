<div class="post-text" itemprop="text">
<p>I need to store and handle huge amounts of very long numbers, which are in range from 0 to f 64 times (ffffffffff.....ffff).</p>
<p>If I store these numbers in a file, I need 1 byte for each character (digit) + 2 bytes for \n symbol = up to 66 bytes. However to represent all possible numbers we need not more than 34 bytes (4 bits represent digits from 0 to f, therefore 4 [bits] * 64 [amount of hex digits]/8 [bits a in byte] = 32 bytes + \n, of course).</p>
<p>Is there any way to store the number without consuming excess memory? </p>
<p>So far I have created converter from hex (with 16 digits per symbol) to a number with base of 76 (hex + all letters and some other symbols), which reduces size of a number to 41 + 2 bytes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to store 32 bytes long. Why not just store them as binary numbers? That way you need to store only 32 bytes per number instead of 41 or whatever. You can add on all sorts of quasi-compression schemes to take advantage of things like most of your numbers being shorter than 32 bytes.</p>
<p>If your number is a string, convert it to an <code>int</code> first. Python3 <code>int</code>s are basically infinite precision, so you will not lose any information:</p>
<pre><code>&gt;&gt;&gt; num = '113AB87C877AAE3790'
&gt;&gt;&gt; num = int(num, 16)
&gt;&gt;&gt; num
317825918024297625488
</code></pre>
<p>Now you can convert the result to a byte array and write it to a file opened for binary writing:</p>
<pre><code>with open('output.bin', 'wb') as file:
    file.write(num.to_bytes(32, byteorder='big'))
</code></pre>
<p>The <code>int</code> method <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer"><code>to_bytes</code></a> converts your number to a string of bytes that can be placed in a file. You need to specify the string length and the order. <code>'big'</code> makes it easier to read a hex dump of the file.</p>
<p>To read the file back and decode it using <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow noreferrer"><code>int.from_bytes</code></a> in a similar manner:</p>
<pre><code>with open('output.bin', 'rb') as file:
    bytes = file.read(32)
    num = int.from_bytes(bytes, byteorder='big')
</code></pre>
<p>Remember to always include the <code>b</code> in the file mode, or you may run into unexpected problems if you try to read or write data with codes for <code>\n</code> in it.</p>
<p>Both the read and write operation can be looped as a matter of course.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you anticipate storing an even distribution of numbers, then see Mad Physicist's answer. However, If you anticipate storing mostly small numbers but need to be able to store a few large numbers, then these schemes may also be useful.</p>
<p>If you only need to account for integers that are 255 or fewer bytes (2040 or fewer bits) in length, then simply convert the <code>int</code> to a <code>bytes</code> object and store the length in an additional byte, like this:</p>
<pre><code># This was only tested with non-negative integers!
def encode(num):
    assert isinstance(num, int)
    # Convert the number to a byte array and strip away leading null bytes.
    # You can also use byteorder="little" and rstrip.
    # If the integer does not fit into 255 bytes, an OverflowError will be raised.
    encoded = num.to_bytes(255, byteorder="big").lstrip(b'\0')
    # Return the length of the integer in the first byte, followed by the encoded integer.
    return bytes([len(encoded)]) + encoded
def encode_many(nums):
    return b''.join(encode(num) for num in nums)
def decode_many(byte_array):
    assert isinstance(byte_array, bytes)
    result = []
    start = 0
    while start &lt; len(byte_array):
        # The first byte contains the length of the integer.
        int_length = byte_array[start]
        # Read int_length bytes and decode them as int.
        new_int = int.from_bytes(byte_array[(start+1):(start+int_length+1)], byteorder="big")
        # Add the new integer to the result list.
        result.append(new_int)
        start += int_length + 1
    return result
</code></pre>
<p>To store integers of (practically) infinite length, you can use this scheme, based on variable-length quantities in the MIDI file format. First, the rules:</p>
<ul>
<li>A byte has eight bits (for those who don't know).</li>
<li>In each byte <strong>except the last</strong>, the left-most bit (the highest-order bit) will be <code>1</code>.</li>
<li>The lower seven bits (i.e. all bits except the left-most bit) in each byte, when concatenated together, form an integer with a variable number of bits.</li>
</ul>
<p>Here are a few examples:</p>
<ul>
<li><code>0</code> in binary is <code>00000000</code>. It can be represented in one byte without modification as <code>00000000</code>.</li>
<li><code>127</code> in binary is <code>01111111</code>. It can be represented in one byte without modification as <code>01111111</code>.</li>
<li><code>128</code> in binary is <code>10000000</code>. It must be converted to a two-byte representation: <code>10000001 00000000</code>. Let's break that down:

<ul>
<li>The left-most bit in the first byte is <code>1</code>, which means that it is <strong>not</strong> the last byte.</li>
<li>The left-most bit in the second byte is <code>0</code>, which means that it is the last byte.</li>
<li>The lower seven bits in the first byte are <code>0000001</code>, and the lower seven bits in the second byte are <code>0000000</code>. Concatenate those together, and you get <code>00000010000000</code>, which is 128.</li>
</ul></li>
<li><code>173249806138790</code> in binary is <code>100111011001000111011101001001101111110110100110</code>.

<ul>
<li>To store it:

<ul>
<li>First, split the binary number into groups of seven bits: <code>0100111 0110010 0011101 1101001 0011011 1111011 0100110</code> (a leading <code>0</code> was added)</li>
<li>Then, add a <code>1</code> in front of each byte except the last, which gets a <code>0</code>: <code>10100111 10110010 10011101 11101001 10011011 11111011 00100110</code></li>
</ul></li>
<li>To retrieve it:

<ul>
<li>First, drop the first bit of each byte: <code>0100111 0110010 0011101 1101001 0011011 1111011 0100110</code></li>
<li>You are left with an array of seven-bit segments. Join them together: <code>100111011001000111011101001001101111110110100110</code></li>
<li>When that is converted to decimal, you get 173,249,806,138,790.</li>
</ul></li>
</ul></li>
</ul>
<p>Why, you ask, do we make the left-most bit in the last byte of each number a <code>0</code>? Well, doing that allows you to concatenate multiple numbers together without using line breaks. When writing the numbers to a file, just write them one after another. When reading the numbers from a file, use a loop that builds an array of integers, ending each integer whenever it detects a byte where the left-most bit is <code>0</code>.</p>
<p>Here are two functions, <code>encode</code> and <code>decode</code>, which convert between <code>int</code> and <code>bytes</code> in Python 3.</p>
<pre><code># Important! These methods only work with non-negative integers!
def encode(num):
    assert isinstance(num, int)
    # If the number is 0, then just return a single null byte.
    if num &lt;= 0:
        return b'\0'
    # Otherwise...
    result_bytes_reversed = []
    while num &gt; 0:
        # Find the right-most seven bits in the integer.
        current_seven_bit_segment = num &amp; 0b1111111
        # Change the left-most bit to a 1.
        current_seven_bit_segment |= 0b10000000
        # Add that to the result array.
        result_bytes_reversed.append(current_seven_bit_segment)
        # Chop off the right-most seven bits.
        num = num &gt;&gt; 7
    # Change the left-most bit in the lowest-order byte (which is first in the list) back to a 0.
    result_bytes_reversed[0] &amp;= 0b1111111
    # Un-reverse the order of the bytes and convert the list into a byte string.
    return bytes(reversed(result_bytes_reversed))
def decode(byte_array):
    assert isinstance(byte_array, bytes)
    result = 0
    for part in byte_array:
        # Shift the result over by seven bits.
        result = result &lt;&lt; 7
        # Add in the right-most seven bits from this part.
        result |= (part &amp; 0b1111111)
    return result
</code></pre>
<p>Here are two functions for working with lists of <code>int</code>s:</p>
<pre><code>def encode_many(nums):
    return [encode(num) for num in nums]
def decode_many(byte_array):
    parts = []
    # Split the byte array after each byte where the left-most bit is 0.
    start = 0
    for i, b in enumerate(byte_array):
        # Check whether the left-most bit in this byte is 0.
        if not (b &amp; 0b10000000):
            # Copy everything up to here into a new part.
            parts.append(byte_array[start:(i+1)])
            start = i + 1
    return [decode(part) for part in parts]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The densest possible way without knowing more about the numbers would be 256 bits per number (32 bytes).</p>
<p>You can store them right after one another.</p>
<p>A function to write to a file might look like this:</p>
<pre><code>def write_numbers(numbers, file):
    for n in numbers:
        file.write(n.to_bytes(32, 'big'))

with open('file_name', 'wb') as f:
    write_numbers(get_numbers(), f)
</code></pre>
<p>And to read the numbers, you can make a function like this:</p>
<pre><code>def read_numbers(file):
    while True:
        read = file.read(32)
        if not read:
            break
        yield int.from_bytes(read, 'big')

with open('file_name', 'rb') as f:
    for n in read_numbers(f):
        do_stuff(n)
</code></pre>
</div>
<span class="comment-copy">Unrelated note: <code>\n</code> only takes one byte. On Windows, the line ending is <code>\r\n</code>, which takes two bytes.</span>
<span class="comment-copy">Have you considered storing the file in binary?</span>
<span class="comment-copy">Related note: you may want to look at how the MIDI format stores numbers. Basically, there is a byte array, but only the lower seven bits of each byte are used. These seven-bit segments are concatenated together to make the big integer. The highest bit is 0 for all of the bytes except the last (or maybe it was the other way around... I don't remember). All consecutive bytes with all 0's are omitted from left.</span>
<span class="comment-copy">If you store each number as a 32-byte binary, there is no need for line breaks.</span>
<span class="comment-copy">Have you tried any of the well-known data compressors? There are several in the standard library. If all your numbers require 256 bits you might as well just store them as 32 byte binary, as DYZ suggests, but even then you may be able to reduce the space further by using a compression algorithm. It really depends on the nature of your data.</span>
<span class="comment-copy">The question has the [python] tag.  No Python code?</span>
<span class="comment-copy">You are better off just encoding the length in a separate byte. Taking one bit from each byte takes up 2 bytes in the average case, while any number up to 32 can comfortably fit into 5 bits.</span>
<span class="comment-copy">@gboffi I have written some example code in Python 3 and added it to my answer.</span>
<span class="comment-copy">Wouldn't this require some structure, i.e., a distribution with many small numbers, to be more efficient than just storing the numbers in 32 bytes? The original post does not say anything about that.</span>
<span class="comment-copy">@wecsam No it did not make any claims as to what the distribution looks like at all. But for your scheme to be more efficient than just storing the numbers as 32 bytes each, <i>you</i> have to make assumptions of how the values are distributed.</span>
