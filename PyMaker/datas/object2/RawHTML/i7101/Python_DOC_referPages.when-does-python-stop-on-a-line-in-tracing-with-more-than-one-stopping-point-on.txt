<div class="post-text" itemprop="text">
<p>Consider these two examples:</p>
<pre><code>x = 1; y = 2; z = 3
</code></pre>
<p>and:</p>
<pre><code>for i in range(3): print(i)
</code></pre>
<p>In the latter, if you step through this in a debugger like <em>pdb</em>, you'll it will stop at the <code>print(i)</code> at each iteration of a loop. </p>
<p>However in the first example, it stops once. </p>
<p>Investigating further, disassembling the multi-statement line we see that there are in fact two entries for the first line in <code>co_lnotab</code>. But <code>dis.dis()</code> lies about this. </p>
<p>As for the <em>for</em> loop there is just the one line in the <code>lnotab</code> but the place that you stop at on each interation, offset 10, is at the target of a jump. So is that what triggers stopping even though the line number hasn't changed? </p>
<pre><code>import dis
&gt;&gt;&gt; x = compile('x = 1; y = 2; z = 3', 'foo', 'exec')
&gt;&gt;&gt; x.co_lnotab
b'\x04\x00\x04\x00'
&gt;&gt;&gt; dis.dis(x)
  1           0 LOAD_CONST               0 (1)
              2 STORE_NAME               0 (x)
              4 LOAD_CONST               1 (2)
              6 STORE_NAME               1 (y)
              8 LOAD_CONST               2 (3)
             10 STORE_NAME               2 (z)
             12 LOAD_CONST               3 (4)
             14 STORE_NAME               3 (a)
             16 LOAD_CONST               4 (None)
             18 RETURN_VALUE
&gt;&gt;&gt; y = compile('for i in range(3): print(i)', 'foo', 'exec')
&gt;&gt;&gt; y.co_lnotab
b'\x0e\x00'
&gt;&gt;&gt; dis.dis(y)
  1           0 SETUP_LOOP              24 (to 26)
              2 LOAD_NAME                0 (range)
              4 LOAD_CONST               0 (3)
              6 CALL_FUNCTION            1
              8 GET_ITER
        &gt;&gt;   10 FOR_ITER                12 (to 24)
             12 STORE_NAME               1 (i)
             14 LOAD_NAME                2 (print)
             16 LOAD_NAME                1 (i)
             18 CALL_FUNCTION            1
             20 POP_TOP
             22 JUMP_ABSOLUTE           10
        &gt;&gt;   24 POP_BLOCK
        &gt;&gt;   26 LOAD_CONST               1 (None)
             28 RETURN_VALUE
&gt;&gt;&gt;
</code></pre>
<p>Where is the source code for this logic? I've looked in the Python C code, but I can't find it, say in <code>ceval.c</code> looking for <code>PyTrace_LINE</code>.</p>
<p><em>Edit</em>:</p>
<p>Based on user2357112's answer and reading the code suggested there, I was able to verify that one <em>can</em> stop/trace on each statement of the code.
I used my new Python assembler, <a href="https://github.com/rocky/python-xasm" rel="nofollow noreferrer">pyc-xasm</a>, to modify the bytecode to this:</p>
<pre><code>  2:
            LOAD_CONST           (1)
            STORE_NAME           (x)
            JUMP_FORWARD         L2B

L2A:
  2:
            LOAD_CONST           (2)
            STORE_NAME           (y)
            JUMP_FORWARD         L2D
L2B:
            JUMP_ABSOLUTE        L2A

L2C:
  2:
            LOAD_CONST           (3)
            STORE_NAME           (z)
            JUMP_FORWARD         L3
L2D:
            JUMP_ABSOLUTE        L2C

L3:
  3:
            LOAD_NAME            (x)
            LOAD_NAME            (y)
            BINARY_ADD
            LOAD_NAME            (z)
            BINARY_ADD
            PRINT_ITEM
            PRINT_NEWLINE
            LOAD_CONST           (None)
            RETURN_VALUE
</code></pre>
<p>And running this will cause Python to stop before each line.</p>
</div>
<div class="post-text" itemprop="text">
<p>PDB tracing uses a trace function set through <a href="https://docs.python.org/3/library/sys.html#sys.settrace" rel="nofollow noreferrer"><code>sys.settrace</code></a>. There are a number of events that will trigger the trace function, but the ones you're looking at are all <em>line</em> events:</p>
<blockquote>
<p><code>'line'</code><br/>
  The interpreter is about to <strong>execute a new line of code</strong> or <strong>re-execute the condition of a loop</strong>. The local trace function is called; <em>arg</em> is <code>None</code>; the return value specifies the new local trace function. See <code>Objects/lnotab_notes.txt</code> for a detailed explanation of how this works.</p>
</blockquote>
<p>As the docs say, you can see a more detailed explanation of the line event triggers in <a href="https://github.com/python/cpython/blob/master/Objects/lnotab_notes.txt" rel="nofollow noreferrer"><code>Objects/lnotab_notes.txt</code></a>. The most relevant section is</p>
<blockquote>
<p>We fix this by only calling the line trace function for a forward jump if the
  co_lnotab indicates we have jumped to the <em>start</em> of a line, i.e. if the current
  instruction offset matches the offset given for the start of a line by the
  co_lnotab.  For backward jumps, however, we always call the line trace function,
  which lets a debugger stop on every evaluation of a loop guard (which usually
  won't be the first opcode in a line).</p>
</blockquote>
<p>So PDB will pause on the start of a line, or if execution jumps backward in the code.</p>
<hr/>
<p>If you want to see the source code that triggers line events, it's in <code>Python/ceval.c</code> under <a href="https://github.com/python/cpython/blob/3.6/Python/ceval.c#L4530" rel="nofollow noreferrer"><code>maybe_call_line_trace</code></a>. PDB's source code is, predictably, under <a href="https://github.com/python/cpython/blob/3.6/Lib/pdb.py" rel="nofollow noreferrer"><code>Lib/pdb.py</code></a>.</p>
</div>
<span class="comment-copy">I'm very curious about what's led you to look into this. What are you working on?</span>
<span class="comment-copy">For a very long time, I have been working on debuggers, which includes python debuggers. See <a href="https://pypi.python.org/pypi/trepan3k" rel="nofollow noreferrer">pypi.python.org/pypi/trepan3k</a>.  I think you should be able to set a breakpoint where ever you want, which could be done by specifying a bytecode offset in a function. Or decide which statement of the multiple statements to stop at. With the advance of some recent bytecode manipulation tools, I am within reach of doing that. It's a lot of work though, and might not cover every case.</span>
<span class="comment-copy">Awesome! I'm working on a python debugger right now (literally) that you may be interested in: <a href="https://github.com/alexmojaki/birdseye" rel="nofollow noreferrer">github.com/alexmojaki/birdseye</a></span>
