<div class="post-text" itemprop="text">
<p>Given a list of multiple iterables, I want to test if all items are <a href="https://en.wikipedia.org/wiki/Disjoint_sets" rel="nofollow noreferrer">disjoint</a>.  </p>
<blockquote>
<p>two sets are said to be <strong>disjoint</strong> if they have no element in common</p>
</blockquote>
<p>Example:</p>
<pre><code>iterables = ["AB", "CDE", "AF"]
all_disjoint(iterables)
# False

iterables = ["AB", "CDE", "FG"]
all_disjoint(iterables)
# True
</code></pre>
<p>Python sets have an <code>isdisjoint</code> method which works, but it is designed for testing two elements at a time.  One approach is to apply this method to each pairwise group of elements:</p>
<pre><code>import itertools as it


def pairwise_(iterable):
    """s -&gt; (s0,s1), (s1,s2), (s2,s3), ..., (sn,s0)"""
    # Modified: the last element wraps back to the first element.
    a, b = it.tee(iterable, 2)
    first = next(b, None)
    b = it.chain(b, [first])
    return zip(a, b)


def all_disjoint(x):
    return all((set(p0).isdisjoint(set(p1))) for p0, p1 in pairwise_(x))
</code></pre>
<p>Here I modified the <code>pairwise</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipe</a> to attach the first element one last time.  This is not quite right however as it only tests neighboring items rather than each item against all other items in the list.  I would like to test all elements more elegantly, with less code.  Is there a simpler way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>IIUC, you can take your list of strings, combine them, and then check if the combined length is equal to the length of the set equivalent of that string or not.</p>
<p>You can use <code>''.join</code> to join your strings and define your function:</p>
<pre><code>def all_disjoint(iterables):
    total = ''.join(iterables)
    return len(total) == len(set(total))
</code></pre>
<p>Now, test:</p>
<pre><code>all_disjoint(['AB', 'CDE', 'AF'])
# False

all_disjoint(['AB', 'CDE', 'FG'])
# True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, <code>set(list('AB'))</code> would result in in the set <code>{'A', 'B'}</code>.</p>
<p>Second, by enumerating over <code>s</code> and then using <code>for s2 in s[n+1:]</code> one only looks at the upper diagonal and avoids the need to compare values against itself or the other pair.  For example, if <code>s = ['A', 'B', 'C']</code>, then [(s1, s2) for n, s1 in enumerate(s) for s2 in s[n+1:]] would result in: <code>[('A', 'B'), ('A', 'C'), ('B', 'C')]</code>.  This is equivalent to the result from <code>list(combinations(s, 2))</code> if one were to import <code>combinations</code> from <code>itertools</code>.</p>
<p>Given the above, I use the <code>any</code> generator to compare the lack of any intersection between each subset.</p>
<p>Because of the <code>any</code> construct, it will short circuit upon the first observation of a common element, avoiding the need to calculate each pair.  </p>
<pre><code>s = ['AB', 'CDE', 'AF']
&gt;&gt;&gt; not any(set(list(s1)).intersection(set(list(s2))) 
            for n, s1 in enumerate(s) for s2 in s[n+1:])
False

s = ['AB', 'CDE', 'FG']
&gt;&gt;&gt; not any(set(list(s1)).intersection(set(list(s2))) 
            for n, s1 in enumerate(s) for s2 in s[n+1:])
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given what you said about wanting to test that each item is disjoint with <em>all</em> other items, I think this does what you want:</p>
<pre><code>import itertools as it

def all_disjoint(x):
    return all((set(p0).isdisjoint(set(p1))) for p0, p1 in it.combinations(x, 2))

iterables = ['AB', 'CDE', 'AF']
print(all_disjoint(iterables))  # -&gt; False

iterables = ['AB', 'CDE', 'FG']
print(all_disjoint(iterables))  # -&gt; True

# your code gives different answer on this one 
# (because it doesn't check what you want)
iterables = ['AB', 'CDE', 'AH', 'FG']
print(all_disjoint(iterables))  # -&gt; False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I add these answers for others who are interested.</p>
<p><strong>Approach 1</strong>: I realize this can be done with a multiset (<code>Counter</code>).</p>
<pre><code>import itertools as it
import collections as ct


def all_disjoint(iterables):
    return all(not v-1 for v in ct.Counter(it.chain.from_iterable(iterables)).values())
</code></pre>
<hr/>
<p><strong>Approach 2</strong>: From the <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> library, <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.unique_to_each" rel="nofollow noreferrer"><code>more_itertools.unique_to_each</code></a> yields all unique items from every iterable.  The following code compares the lengths of the results to the original iterables:</p>
<pre><code>import more_itertools as mit

def all_disjoint(iterables):
    return all(len(x) == len(y) for x, y in zip(iterables, mit.unique_to_each(*iterables)))
</code></pre>
</div>
<span class="comment-copy">Your code tests to see if each iterable in <code>x</code> is disjoint from the one immediately before it and the one immediately after it (when those exist). This isn't the same as determining whether all of them are disjoint from all the others. Is that your goal? There's nothing wrong with modifying recipes, btw.</span>
<span class="comment-copy">You are right.  This code only tests if neighboring items are disjoint.  Rather, I would like to test that each item is disjoint with all other items.  As for modifying recipes, I would simply like less code.</span>
<span class="comment-copy"><code>reduce</code> is a poor way to join strings, since it takes quadratic time. <code>''.join</code> is much better.</span>
<span class="comment-copy">@user2357112 Agreed. Don't know why I thought of reduce. Have modified.</span>
<span class="comment-copy">This work  well for strings and answers the question is asked.  The idea of comparing the lengths the merged string with it's set is pythonic.  Thanks.</span>
<span class="comment-copy">I think it is also worth noting that this executes twice as fast as any of the other solutions on this page. total 1.1 usec vs intersection 5.79 usec vs isdisjoint 3.53 usec.</span>
<span class="comment-copy"><code>set('AB')</code> also produces <code>{'A', 'B'}</code>.  <code>list</code> is not required.  Clever approach with testing the upper diagonal with nested <code>for</code> loops.</span>
<span class="comment-copy">Thank you.  Why do you have <code>pairwise</code>?  You don't seem to use it.</span>
<span class="comment-copy">pylang: Good pointâ€”gone now. It was just a leftover from some earlier development.</span>
<span class="comment-copy">+1 for using <code>itertools</code> and this straight-forward approach.  <code>permutations</code> might make more groups than needed, e.g, testing <code>('AB', 'CDE')</code> and <code>('CDE', 'AB')</code> is equivalent.   However, I can more easily extend this approach to non-iterables, e.g. <code>lst = ["AB", "CDE", "AD", 123, "FG"]</code>.</span>
<span class="comment-copy">When I wrote this it occurred to me that <code>permutations()</code> was going to produce what were effectively duplicates because order matters in them, but not in sets. I think I have a simple fix for that and will update my answer accordingly (if it works out).</span>
<span class="comment-copy"><code>combinations</code> seems to work.  I would change  <code>p</code>s to <code>c</code>s.  Great answer.</span>
