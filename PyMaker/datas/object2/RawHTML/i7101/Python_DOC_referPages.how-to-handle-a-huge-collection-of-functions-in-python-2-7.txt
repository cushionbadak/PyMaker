<div class="post-text" itemprop="text">
<p>So I am working on this existing code base which has about 150 or so functions as time series</p>
<p>I wanted to store them in a class in order to prevent namespace pollution. </p>
<p>This is what exists</p>
<pre><code>import some.module
def func1(start_date, end_date):
    some code here
    return time_series
def func2(start_date, end_date):
    some code here
    return time_series
.
.
.
def func150(start_date, end_date):
    some code here
    return time_series
</code></pre>
<p>Each one of these functions is a unique name without any pattern. I tired to put them in a class</p>
<pre><code>def function_builder(some_data):
    def f(start_date, end_date):
        some_code_here()
        return series
    return f

class TimeSeries():
    func1 = function_builder(some_data)
    func2 = function_builder(some_other_data)
    .
    .
    .
    func150 = function_builder(some_other_other_data)
</code></pre>
<p>My hope was that this would lead to me simply being able to import the time series and use it like</p>
<pre><code>from some.location import TimeSeries as ts
#Actual code use
data = ts.func1(start_date, end_date)
</code></pre>
<p>But this approach throws the following error</p>
<p><strong>TypeError: unbound method f() must be called with TimeSeries instance as first argument (got date instead)</strong></p>
<p>please advise on how I should proceed with a huge collection of functions. I am new to programming and I want to do this correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're probably better off creating a submodule rather than a class with multiple functions. However, if you <em>really</em> want to do it the way you described, you need to use static methods instead of methods:</p>
<pre><code>class TimeSeries():
    func1 = staticmethod(function_builder(some_data))
    func2 = staticmethod(function_builder(some_other_data))
    # ...
</code></pre>
<p>Alternately, because you already have <code>function_builder</code>,</p>
<pre><code>def function_builder(some_data):
    def f(start_date, end_date):
        some_code_here()
        return series
    return staticmethod(f)

class TimeSeries():
    func1 = function_builder(some_data)
    func2 = function_builder(some_other_data)
    # ...
</code></pre>
<p>The <code>staticmethod</code> function takes a function and returns a static method-y version of it. Thus, it can also be used as a function decorator.</p>
<p>You can (should?) programatically generate your time series functions if your inputs to <code>function_builder</code> can be generated algorithmically. You can use <code>__setattr__</code> or update <code>__dict__</code> to add your functions to a submodule (or object in this module, but that's less elegant, IMHO).</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you really should do is separate your functions out into <em>separate modules</em> if you are trying to prevent name-space pollution. However, you could just use a <code>SimpleNamespace</code>:</p>
<pre><code>In [1]: def func1(a, b):
   ...:     return a + b
   ...: def func2(a, b, c):
   ...:     return a*b*c
   ...: def func3(x):
   ...:     return 2**x
   ...:

In [2]: from types import SimpleNamespace

In [3]: group1 = SimpleNamespace(func1=func1, func2=func2, func3=func3)
</code></pre>
<p>And now you've conveniently organized your name-spaces:</p>
<pre><code>In [7]: group1.func1(1,2)
Out[7]: 3

In [8]: group1.func2(1, 2, 3)
Out[8]: 6

In [9]: group1.func3(8)
Out[9]: 256
</code></pre>
<p>Although, they will still be under the module's namespace if you do a simple <code>import yourmodule</code>. Even though <code>SimpleNamespace</code> is essentially a class, <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">equivalent to the following</a>:</p>
<pre><code>class SimpleNamespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def __repr__(self):
        keys = sorted(self.__dict__)
        items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
        return "{}({})".format(type(self).__name__, ", ".join(items))

    def __eq__(self, other):
        return self.__dict__ == other.__dict__
</code></pre>
</div>
<span class="comment-copy">You're getting the unbound method error because you are trying to call class methods without first constructing an instance of the class. If these functions are already in use, it's a safe bet that cramming them all into a class is probably not the solution for you.</span>
<span class="comment-copy">This isn't really the best use of a class. Why not just put them in a dict or something?</span>
<span class="comment-copy">Dict isn't a bad idea. I was considering that before someone told me that you can use classes as a namespace</span>
<span class="comment-copy">Instead of a class, why don't you put them in separate <i>modules</i>?</span>
