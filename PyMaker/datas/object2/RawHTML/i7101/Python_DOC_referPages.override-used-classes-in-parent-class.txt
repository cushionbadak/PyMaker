<div class="post-text" itemprop="text">
<p>Suppose there is a class <code>NiceClass</code> using some other class <code>LesserClass</code> in a place I can't edit</p>
<pre><code># NiceClass.py

class LesserClass:
    ...
    # stuff
    ...

class NiceClass:
    ...
    # Lots of use of lesser class in here...
    ...
</code></pre>
<p>Now I want to use my own class <code>MyLesserClass</code> instead of <code>LesserClass</code> everywhere in an inherited version of <code>NiceClass</code></p>
<pre><code># MyNiceClass.py

from NiceClass import NiceClass
from NiceClass import LesserClass as oldLesserClass

class LesserClass(oldLesserClass):
    ...
    # Some extra stuff
    ...

class MyNiceClass(NiceClass):
    ...
    # Everywhere LesserClass was used I now want to use MyLesserClass
    ...
</code></pre>
<p>But all the non-overridden methods in <code>MyNiceClass</code> will use the <code>LesserClass</code> from the old <code>NiceClass.py</code>.</p>
<p>Everything would work as I want if I just copy-pasted in the whole definition of <code>NiceClass</code> into <code>MyNiceClass.py</code>.</p>
<p>It's like I just want to inherit the source code and not the whole namespace. Maybe inheritence is the wrong way?</p>
</div>
<div class="post-text" itemprop="text">
<p>I hope this is only limited to methods under <code>NiceClass</code> using the class <code>LesserClass</code>.</p>
<p>Now if you want the methods inside <code>MyNiceClass</code> to use <code>MyLesserClass</code> instead of <code>LesserClass</code> then you could update the <code>__globals__</code> dict of those methods and make the name <code>'LesserClass'</code> point to <code>MyLesserClass</code>.</p>
<p>Here's a simple example demonstrating the same by overriding <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a>:</p>
<pre><code>class A:
    a = 'A.a'
    b = 'A.b'


class B:
    def func_a(self):
        print(A.a)

    def func_b(self):
        print(A.b)


class C:
    a = 'C.a'
    b = 'C.b'


class D(B):
    def func_a(self):
        print(C.a)

    def __getattribute__(self, attr):
        value = object.__getattribute__(self, attr)
        if callable(value):
            value = update_namespace(value, {'old': {'name': 'A', 'obj': A}, 'new': {'obj': C}})
        return value


def update_namespace(func, namespace):
    def wrapper(*args, **kwargs):
        # Update the globals
        func.__globals__[namespace['old']['name']] = namespace['new']['obj']
        val = func(*args, **kwargs)
        # Restore it back to the actual value
        func.__globals__[namespace['old']['name']] = namespace['old']['obj']
        return val
    return wrapper


d = D()
d.func_a()  # This should print C.a
d.func_b()  # This should print C.b
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>C.a
C.b
</code></pre>
</div>
<span class="comment-copy">Your question is still unclear. Please try to provide more clarity. What is your expectation and issue ?</span>
