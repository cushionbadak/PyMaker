<div class="post-text" itemprop="text">
<p>I've defined a class with 5 instance variables</p>
<pre><code>class PassPredictData:
    def __init__(self, rating, name, lat, long, elev):
        self.rating = rating
        # rest of init code
</code></pre>
<p>I want to ensure:</p>
<ul>
<li><code>rating</code> is an int</li>
<li><code>name</code> is a str</li>
<li><code>lat</code>, <code>long</code>, <code>elev</code> are floats</li>
</ul>
<p>When reading my input file, everything works creating a list of objects based on my class. When I start comparing values I got weird results since the instance variables were still strings.</p>
<p>Is the "most Pythonic way" to cast the values as the object is being created using <code>int(string)</code> and <code>float(string)</code> when calling the constructor or should this casting be done with logic inside the class?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you type <code>import this</code> in the Python interpreter, you will get "The Zen of Python, by Tim Peters". The first three lines seem to apply to your situation:</p>
<pre><code>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
</code></pre>
<p>I would recommend implementing your class like this:</p>
<pre><code>class PassPredictData:
    def __init__(self, rating, name, lat, long, elev):
        self.rating = int(rating)
        self.name = str(name)
        self.lat = float(lat)
        self.long = float(long)
        self.elev = float(elev)
</code></pre>
<p>This is the implementation you mention in your question. It is <strong>simple</strong> and <strong>explicit</strong>. Beauty is in the eye of the beholder.</p>
<p><strong>Responses to Comments</strong></p>
<p>The implementation is <strong>explicit to the writer of the class</strong> versus some other solution that hides the type conversion behind some opaque mechanism.</p>
<p>There is a valid argument that it is not obvious from the function signature what the expected parameter types are. However, the question implies that all parameters are passed as strings. In that case, the expected type is <code>str</code> for all the constructor parameters. Perhaps the question title does not clearly describe the problem. Maybe a better title would be "<strong>Enforce Instance Variable Types When Passing Strings as Parameters to Constructor</strong>".</p>
</div>
<div class="post-text" itemprop="text">
<p>Personally, I would do any string parsing <em>before</em> passing the values to the constructor, unless parsing is one (or <em>the</em>) explicitly stated responsibility of the class. I prefer my program to fail because I didn't explicitly cast a value than to be too flexible and end up in a Javascript-like <code>0 == "0"</code> situation. That said, if you want to accept strings as parameters you can just call <code>int(my_parameter)</code> or <code>float(my_parameter)</code> as needed in the constructor and that will make sure this are numbers not matter you pass a number, a string or even a Boolean.</p>
<p>In case you want to know more about type safety in Python, you can take a look at <a href="https://docs.python.org/3/library/typing.html" rel="noreferrer">type annotations</a>, which are supported by type checkers like <a href="http://mypy-lang.org/" rel="noreferrer">mypy</a>, and the <a href="http://docs.enthought.com/traits/" rel="noreferrer">traits package</a> for type safety in class attributes.</p>
</div>
<div class="post-text" itemprop="text">
<p>EDIT: (edit because the topic of the question changed) <strong>I would not recommend convert type of parameters at init time</strong>. For example:</p>
<pre><code>class PassPredictData:
    def __init__(self, rating, name, lat, long, elev):
        self.rating = int(rating)
        self.name = str(name)
        ...
</code></pre>
<p>In my opinion, This type of Implicit conversion is dangerous for few reasons. </p>
<ol>
<li><strong>Implicitly</strong> converts parameter type to another without giving warning is very misleading </li>
<li>It <strong>won't raise any exceptions</strong> if users pass in undesired type. This goes hand in hand with the implicit casting. This could be avoided using explicit type checking.</li>
<li>Silently convert type <strong>violates duck-typing</strong></li>
</ol>
<p>Instead of convert type of parameters, <strong>it is better to check the parameter type at init time.</strong> This approach would avoid the above three issues. To accomplish this you may use the strong type checking from <a href="https://github.com/dobarkod/typedecorator/" rel="noreferrer">typedecorator</a> I like it because it is <strong>simple</strong> and very <strong>readable</strong></p>
<p>For Python2 [edit: leaving this as a reference as OP requested]</p>
<pre><code>from typedecorator import params, returns, setup_typecheck, void, typed

class PassPredictData:
    @void
    @params(self=object, rating = int, name = str, lat = float, long = float, elev = float)
    def __init__(self, rating, name, lat, long, elev):
        self.rating = rating
        self.name = name
        self.lat = lat
        self.long = long
        self.elev = elev

setup_typecheck()     
x = PassPredictData(1, "derp" , 6.8 , 9.8, 7.6) #works fine
x1 = PassPredictData(1.8, "derp" , 6.8 , 9.8, 7.6) #TypeError: argument rating = 1.8 doesn't match signature int
x2 = PassPredictData(1, "derp" , "gagaga" , 9.8, 7.6) #TypeError: argument lat = 'gagaga' doesn't match signature float
x3 = PassPredictData(1, 5 , 6.8 , 9.8, 7.6) #TypeError: argument name = 5 doesn't match signature str
</code></pre>
<p>For Python3 you can use the <em>annotation syntax</em>:</p>
<pre><code>class PassPredictData1:
    @typed
    def __init__(self : object, rating : int, name : str, lat : float, long : float, elev : float):
        self.rating = rating

setup_typecheck()    
x = PassPredictData1(1, 5, 4, 9.8, 7.6)
</code></pre>
<p>throws an error:</p>
<blockquote>
<p>TypeError: argument name = 5 doesn't match signature str</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Seems like there's a million ways to do this, but here's the formula I use:</p>
<pre><code>class PassPredictData(object):
    types = {'lat'   : float,
             'long'  : float,
             'elev'  : float,
             'rating': int,
             'name'  : str,
             }

    def __init__(self, rating, name, lat, long, elev):
        self.rating = rating
        [rest of init code]

    @classmethod
    def from_string(cls, string):
        [code to parse your string into a dict]

        typed = {k: cls.types[k](v) for k, v in parsed.items()}

        return cls(**typed)
</code></pre>
<p>A thing that's nice about this: you can directly use a <code>re.groupdict()</code> to produce your dict (as an example):</p>
<p><code>parsed = re.search('(?P&lt;name&gt;\w): Latitude: (?P&lt;lat&gt;\d+), Longitude: (?P&lt;long&gt;\d+), Elevation: (?P&lt;elev&gt;\d+) meters. (?P&lt;rating&gt;\d)', some_string).groupdict()</code></p>
</div>
<div class="post-text" itemprop="text">
<h2>Define custom field types</h2>
<p>One way is to define your own field types and do the conversion and error handling in them. The fields are going to be based on <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>. This is something you're going to find in <a href="https://docs.djangoproject.com/en/1.11/topics/db/models/" rel="nofollow noreferrer">Django models</a>, <a href="http://flask-sqlalchemy.pocoo.org/2.1/models/" rel="nofollow noreferrer">Flask-SQLAlchemy</a>, <a href="http://www.django-rest-framework.org/api-guide/fields/" rel="nofollow noreferrer">DRF-Fields</a> etc</p>
<p>Having such custom fields will allow you to cast them, validate them and this will work not just in <code>__init__</code>, but anywhere we try to assign a value to it.</p>
<pre><code>class Field:
    type = None

    def __init__(self, default=None):
        self.value = default

    def __get__(self, instance, cls):
        if instance is None:
            return self
        return self.value

    def __set__(self, instance, value):
        # Here we could either try to cast the value to
        # desired type or validate it and throw an error
        # depending on the requirement.
        try:
            self.value = self.type(value)
        except Exception:
            raise ValueError('Failed to cast {value!r} to {type}'.format(
                value=value, type=self.type
            ))

class IntField(Field):
    type = int


class FloatField(Field):
    type = float


class StrField(Field):
    type = str


class PassPredictData:
    rating = IntField()
    name = StrField()
    lat = FloatField()
    long = FloatField()
    elev = FloatField()

    def __init__(self, rating, name, lat, long, elev):
        self.rating = rating
        self.name = name
        self.lat = lat
        self.long = long
        self.elev = elev
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; p = PassPredictData(1.2, 'foo', 1.1, 1.2, 1.3)
&gt;&gt;&gt; p.lat = '123'
&gt;&gt;&gt; p.lat
123.0
&gt;&gt;&gt; p.lat = 'foo'
...
ValueError: Failed to cast 'foo' to &lt;class 'float'&gt;
&gt;&gt;&gt; p.name = 123
&gt;&gt;&gt; p.name
'123'
</code></pre>
<hr/>
<h2>Use a static analyzer</h2>
<p>Another option is to use static analyzers like <a href="http://mypy.readthedocs.io/en/latest/" rel="nofollow noreferrer">Mypy</a> and catch the errors before the program gets executed. The code below is using <a href="https://www.python.org/dev/peps/pep-0526/" rel="nofollow noreferrer">Python 3.6 syntax</a>, but you can make it work with other versions as well by making some changes.</p>
<pre><code>class PassPredictData:
    rating: int
    name: str
    lat: float
    long: float
    elev: float

    def __init__(self, rating: int, name: str, lat: float, long: float, elev: float) -&gt; None:
        self.rating = rating
        self.name = name
        self.lat = lat
        self.long = long
        self.elev = elev

PassPredictData(1, 2, 3, 4, 5)
PassPredictData(1, 'spam', 3.1, 4.2, 5.3)
PassPredictData(1.2, 'spam', 3.1, 4.2, 5)
</code></pre>
<p>When we run Mypy on this we get:</p>
<pre><code>/so.py:15: error: Argument 2 to "PassPredictData" has incompatible type "int"; expected "str"
/so.py:17: error: Argument 1 to "PassPredictData" has incompatible type "float"; expected "int"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.5+ you can use type hints and the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">typing</a> module.</p>
<pre class="lang-py prettyprint-override"><code>class PassPredictData:
    def __init__(self, rating: int, name: str, lat: float, long: float, elev: float):
        self.rating = rating
        #rest of init code
</code></pre>
<p>Note that these are just hints. Python doesn't actually do anything with them like showing an error if the wrong type is used.</p>
</div>
<div class="post-text" itemprop="text">
<p>You said that you cannot use 3rd-party libraries, but others finding this question might. The <a href="https://pypi.python.org/pypi/typeguard" rel="nofollow noreferrer"><code>typeguard</code></a> is worth mentioning here.</p>
<pre><code>from typeguard import typechecked

class PassPredictData:
     @typechecked
     def __init__(self, rating: int, name: str, lat: float, long: float, elev: float):
         ...
</code></pre>
<p>BTW. by default the decorator is disabled when Python is run in optimized mode (<code>-O</code>)! And it is easy to disable the checks when you're sure they're not needed. </p>
<p>BTW. Perhaps the <code>lat</code>, <code>long</code>, <code>elev</code> should be <code>numbers.Real</code> with cast inside the constructor to <code>float</code> ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>Even without relying on external libraries you can define your own simple typechecking decorator in just a few lines. This uses the <code>inspect</code> module from Core-Python to get the parameter names, but even without it you could just <code>zip</code> the <code>args</code> with a list of types, although this will make using <code>kwargs</code> difficult.</p>
<pre><code>import inspect

def typecheck(**types):
    def __f(f):
        def _f(*args, **kwargs):
            all_args = {n: a for a, n in zip(args, inspect.getargspec(f).args)}
            all_args.update(kwargs)
            for n, a in all_args.items():
                t = types.get(n)
                if t is not None and not isinstance(a, t):
                    print("WARNING: Expected {} for {}, got {}".format(t, n, a))
            return f(*args, **kwargs)
        return _f
    return __f

class PassPredictData:

    @typecheck(rating=int, name=str, elev=float)
    def __init__(self, rating, name, lat=0.0, long=0.0, elev=0.0):
        self.rating = rating

p = PassPredictData(5.1, "foo", elev=4)
# WARNING: Expected &lt;class 'int'&gt; for rating, got 5.1
# WARNING: Expected &lt;class 'float'&gt; for elev, got 4
</code></pre>
<p>Instead of printing a warning, you could of course also raise an exception.  <em>Or,</em> using the same approach, you could also just (try to) cast the parameters to the expected type:</p>
<pre><code>def typecast(**types):
    def __f(f):
        def _f(*args, **kwargs):
            all_args = {n: a for a, n in zip(args, inspect.getargspec(f).args)}
            all_args.update(kwargs)
            for n, a in all_args.items():
                t = types.get(n)
                if t is not None:
                    all_args[n] = t(a) # instead of checking, just cast
            return f(**all_args) # pass the map with the typecast params
        return _f
    return __f

class PassPredictData:

    @typecast(rating=int, name=str, elev=float)
    def __init__(self, rating, name, lat=0.0, long=0.0, elev=0.0):
        print([rating, name, lat, long, elev])

p = PassPredictData("5", "foo", elev="3.14")
# Output of print: [5, 'foo', 0.0, 0.0, 3.14]
</code></pre>
<p>Or a simpler version, without <code>inspect</code>, but not working for <code>kwargs</code> and requiring to provide the type for each parameter, including <code>self</code> (or <code>None</code> for no type cast):</p>
<pre><code>def typecast(*types):
    def __f(f):
        def _f(*args):
            return f(*[t(a) if t is not None else a 
                       for a, t in zip(args, types)])
        return _f
    return __f

class PassPredictData:

    @typecast(None, int, str, float, float, float)
    def __init__(self, rating, name, lat=0.0, long=0.0, elev=0.0):
        print([rating, name, lat, long, elev])
</code></pre>
</div>
<span class="comment-copy">The simplest way to do it is as you suggested, with explicity casting the value. It is simple and readable solution. It also states the user what values you expect (int / float)</span>
<span class="comment-copy">Python has no primitive types. <i>Everything is an object</i></span>
<span class="comment-copy">that is a great point @juanpa.arrivillaga. That makes flavio-milan's answer a lot more relevant.</span>
<span class="comment-copy">Remember that Python is duck-typed...what if someone wants to pass a <code>BigFloat</code> for lat/long/elev?</span>
<span class="comment-copy">"Pythonic means coding beautifully in harmony with the language to get the maximum benefits from Python." -Raymond Hettinger, from <a href="https://youtu.be/wf-BqAjZb8M" rel="nofollow noreferrer">Beyond PEP8</a>. In other words, Pythonic means doing stuff that <i>makes sense</i> and <i>makes your code simpler</i> give <i>the features and common idioms</i> of Python.</span>
<span class="comment-copy">For me trying to be "Pythionc", this is the best and simplest approach @david-cullen. Thanks!</span>
<span class="comment-copy">This isn't explicit: it's implicit behavior of the class. Someone has to read your source code to find out that their arguments are being cast to a different type</span>
<span class="comment-copy">This won't raise exceptions though, if they aren't of the correct type. E.g. <code>str(0.5)</code>.</span>
<span class="comment-copy">And if you think about it. This code does not actually "ensures that parameter type" like the question asked. Users can pass in any type they want and this code is implicitly changing the parameter type afterward. Implicitly changing the type of instance variables without raising exception/warning is not good coding practice. One may argue it would be fine for an ordinary small function, but I think this kind of "behind the scene" magical type change is especially dangerous for a class initialization.</span>
<span class="comment-copy">-1  This violates duck-typing.   If I pass a <code>MyFloat</code> instance, a subclass of <code>float</code>, you should not silently convert it to a <code>float</code> instance.  You should just use my subclass.</span>
<span class="comment-copy">... and if you have to do this more often, you can define a helper function like <code>PassPredictData.fromStringParams(...)</code></span>
<span class="comment-copy">"and end up in a Javascript-like 0 == "0" " I'm suddenly reminded of the infamous <a href="https://www.destroyallsoftware.com/talks/wat" rel="nofollow noreferrer">wat talk</a> showing some of the horrors of Javascript's over flexibility.</span>
<span class="comment-copy">Type annotations are great. I'd argue that more Python programmers (and other comparable languages) should use them. They can greatly increase code clarity. It's easy to be warned of incompatibilities and they're easy to gradually introduce, too (since the lack of them doesn't stop anything from working). Good IDEs like PyCharm support them out of the box and will use them well.</span>
<span class="comment-copy">thanks @oliver-koo. I updated the question to specify Python3 (and vanilla at that), so the annotation syntax is a good approach. Due to the existing python code, it will be easier to change the class definition to handle the issues I'm seeing. Your approach fits with that thinking.</span>
<span class="comment-copy">@lucholland glad to help :) Should I edit out the Python2 example? or should I leave the example for Python2 in case people look for it in the future? This question seems to be a popular question and I won't doubt if people run into the same question using Python2</span>
<span class="comment-copy">I'd leave the Python2 example for others @oliver-koo</span>
<span class="comment-copy">The type annotations can be used in static analysis, very useful. But I didn't know of setup_typecheck, that sounds even more useful, thanks!</span>
<span class="comment-copy">Python 2 has its own style of python annotations in the same form as Python 3's, but in a comment. <a href="http://mypy.readthedocs.io/en/latest/python2.html" rel="nofollow noreferrer">mypy.readthedocs.io/en/latest/python2.html</a> and <a href="https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code" rel="nofollow noreferrer">python.org/dev/peps/pep-0484/…</a></span>
<span class="comment-copy">+1  This is a nice approach!  You may think of the classmethod <code>PassPredictData.fromstring</code> as an alternate constructor.  It's like a factory function, so this should be comfortable and familiar to the OP (who mentioned they're from java background).  And it's also Pythonic, there is precedent for alternate constructors provided as a convenience in the standard libraries already (e.g. <code>dict.fromkeys</code>, <code>datetime.fromtimestamp</code> to name a couple)</span>
<span class="comment-copy">Thanks for the "this feels like Java" in the first example @ashwini-chaudhary. The second example is closer to what I consider "Pythonic".</span>
<span class="comment-copy">A follow up @ashwini-chaudhary. What does the <code>-&gt; None</code> at the end of the <code>__init__</code> provide / do with the constructor?</span>
<span class="comment-copy">@lucholland There's no standard definition of "Pythonic". The first one is a standard approach that you will see in many popular Python libraries, for example check <a href="https://docs.djangoproject.com/en/1.11/topics/db/models/" rel="nofollow noreferrer">Django models</a>, <a href="http://flask-sqlalchemy.pocoo.org/2.1/models/" rel="nofollow noreferrer">Flask-SQLAlchemy</a>, <a href="http://www.django-rest-framework.org/api-guide/fields/" rel="nofollow noreferrer">DRF-Fields</a> etc. So, it depends on the use case, if this is needed only for one or two classes then this may be an overkill, but i you want to use it at lots of places then this will reduce a lot of work.</span>
<span class="comment-copy">@lucholland That's the return type, the syntax(aka <a href="https://www.python.org/dev/peps/pep-3107/" rel="nofollow noreferrer">function annotations</a>) is specific to Python 3. You could use <a href="http://mypy.readthedocs.io/en/latest/python2.html" rel="nofollow noreferrer">type comments to make it work in Python 2</a>.</span>
<span class="comment-copy">-1 Whilst this can be appropriate for an ORM (the database prevents duck-typing anyway), using descriptors here is over-engineering and adding unnecessary complexity.  It looks like being clever just for the sake of it.  Why not just convert types when reading the text from the file?</span>
<span class="comment-copy">However, you can use the mypy type checker to process them, I believe.</span>
<span class="comment-copy">Just realized that the question is actually not asking about typechecking but about automatic casting of parameters. Hence, I assume, the downvote. Now added a variant of my approach that does the casting automatically.</span>
