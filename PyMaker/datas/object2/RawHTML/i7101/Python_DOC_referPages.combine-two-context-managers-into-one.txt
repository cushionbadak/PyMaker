<div class="post-text" itemprop="text">
<p>I use Python 2.7 and I know that I can write this:</p>
<pre><code>with A() as a, B() as b:
    do_something()
</code></pre>
<p>I want to provide a convenience helper which does both. The usage of this helper should  look like this:</p>
<pre><code>with AB() as ab:
    do_something()
</code></pre>
<p>Now AB() should do both: Create context A() and create context B().</p>
<p>I have no clue how to write this convenience helper</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't re-invent the wheel; this is not as simple as it looks.</p>
<p>Context managers are treated as a <em>stack</em>, and should be exited in reverse order in which they are entered, for example. If an exception occurred, this order <em>matters</em>, as any context manager could suppress the exception, at which point the remaining managers will not even get notified of this. The <code>__exit__</code> method is also permitted to raise a <em>different</em> exception, and other context managers then should be able to handle that new exception. Next, successfully creating <code>A()</code> means it should be notified if <code>B()</code> failed with an exception.</p>
<p>Now, if all you want to do is create a <em>fixed</em> number of context managers you know up front, just use the <a href="https://docs.python.org/2/library/contextlib.html#contextlib.contextmanager" rel="noreferrer"><code>@contextlib.contextmanager</code> decorator</a> on a generator function:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def ab_context():
    with A() as a, B() as b:
        yield (a, b)
</code></pre>
<p>then use that as:</p>
<pre><code>with ab_context() as ab:
</code></pre>
<p>If you need to handle a <em>variable</em> number of context managers, then don't build your own implementation; use the standard library <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="noreferrer"><code>contextlib.ExitStack()</code> implementation</a> instead:</p>
<pre><code>from contextlib import ExitStack

with ExitStack() as stack:
    cms = [stack.enter_context(cls()) for cls in (A, B)]

    # ...
</code></pre>
<p>The <code>ExitStack</code> then takes care of correct nesting of the context managers, handling exiting correctly, in order, and with the correct passing of exceptions (including not passing the exception on when suppressed, and passing on new-ly raised exceptions).</p>
<p>If you feel the two lines (<code>with</code>, and separate calls to <code>enter_context()</code>) are too tedious, you can use a separate <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="noreferrer"><code>@contextmanager</code>-decorated generator function</a>:</p>
<pre><code>from contextlib import ExitStack, contextmanager

@contextmanager
def multi_context(*cms):
    with ExitStack() as stack:
        yield [stack.enter_context(cls()) for cls in cms]
</code></pre>
<p>then use <code>ab_context</code> like this:</p>
<pre><code>with multi_context(A, B) as ab:
    # ...
</code></pre>
<p>For Python 2, install the <a href="https://pypi.python.org/pypi/contextlib2" rel="noreferrer"><code>contextlib2</code> package</a>, and use the following imports:</p>
<pre><code>try:
    from contextlib import ExitStack, contextmanager
except ImportError:
    # Python 2
    from contextlib2 import ExitStack, contextmanager
</code></pre>
<p>This lets you avoid reinventing this wheel on Python 2 too.</p>
<p>Whatever you do, do <strong>not</strong> use <a href="https://docs.python.org/2/library/contextlib.html#contextlib.nested" rel="noreferrer"><code>contextlib.nested()</code></a>; this was removed from the library in Python 3 for very good reasons; it too did not implement handling entering and exiting of nested contexts correctly.</p>
</div>
<span class="comment-copy">In your example, you have not used <code>a</code> or <code>b</code> or <code>ab</code> - which raises the question:  why not just <code>with AB():</code> ?</span>
<span class="comment-copy">@MartinBonner yes, you are right. In my case I don't need the variable "ab". The answer of Martin Bonner uses (a,b) which is good.</span>
<span class="comment-copy">"this is not as simple as it looks" - ain't that the truth!</span>
