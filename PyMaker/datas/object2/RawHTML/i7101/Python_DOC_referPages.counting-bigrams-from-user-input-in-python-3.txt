<div class="post-text" itemprop="text">
<p>I'm stuck and need a little guidance. I'm trying hard to learn Python on my own using Grok Learning. Below is the Problem and example output along with where I am in the code. I appreciate any tips that will help me solve this problem.</p>
<blockquote>
<p><em>In linguistics, a bigram is a pair of adjacent words in a sentence. The sentence "<strong>The big red ball.</strong>" has three bigrams: The big, big
  red, and red ball.</em></p>
<p><em>Write a program to read in multiple lines of input from the user, where each line is a space-separated sentence of words. Your program
  should then count up how many times each of the bigrams occur across
  all input sentences. The bigrams should be treated in a case
  insensitive manner by converting the input lines to lowercase. Once
  the user stops entering input, your program should print out each of
  the bigrams that appear more than once, along with their corresponding
  frequencies. For example:</em></p>
<pre><code>Line: The big red ball
Line: The big red ball is near the big red box
Line: I am near the box
Line: 
near the: 2
red ball: 2
the big: 3
big red: 3
</code></pre>
</blockquote>
<p>I haven't gotten very far with my code and am really stuck.  But here is where I am:</p>
<pre><code>words = set()
line = input("Line: ")
while line != '':
  words.add(line)
  line = input("Line: ")
</code></pre>
<p>Am I even doing this right? Try not to import any modules and just use built-in functionality.</p>
<p>Thanks,
Jeff</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's start with the function that receives a sentence (with punctuation) and returns a list of all lowercase bigrams found.</p>
<p>So, we first need to strip all non-alphanumerics from the sentence, convert all letters to lowercase counterparts, and then split the sentence by spaces into a list of words:</p>
<pre><code>import re

def bigrams(sentence):
    text = re.sub('\W', ' ', sentence.lower())
    words = text.split()
    return zip(words, words[1:])
</code></pre>
<p>We'll use the standard (builtin) <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code></a> package for regular expression based substitution of non-alphanumerics with spaces, and the builtin <code>zip</code> function to pair-up consecutive words. (We pair the list of words with the same list, but shifted by one element.)</p>
<p>Now we can test it:</p>
<pre><code>&gt;&gt;&gt; bigrams("The big red ball")
[('the', 'big'), ('big', 'red'), ('red', 'ball')]
&gt;&gt;&gt; bigrams("THE big, red, ball.")
[('the', 'big'), ('big', 'red'), ('red', 'ball')]
&gt;&gt;&gt; bigrams(" THE  big,red,ball!!?")
[('the', 'big'), ('big', 'red'), ('red', 'ball')]
</code></pre>
<p>Next, for counting bigrams found in each sentence, you might use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>.</p>
<p>For example, like this:</p>
<pre><code>from collections import Counter

counts = Counter()
for line in ["The big red ball", "The big red ball is near the big red box", "I am near the box"]:
    counts.update(bigrams(line))
</code></pre>
<p>We get:</p>
<pre><code>&gt;&gt;&gt; Counter({('the', 'big'): 3, ('big', 'red'): 3, ('red', 'ball'): 2, ('near', 'the'): 2, ('red', 'box'): 1, ('i', 'am'): 1, ('the', 'box'): 1, ('ball', 'is'): 1, ('am', 'near'): 1, ('is', 'near'): 1})
</code></pre>
<p>Now we just need to print those that appear more than once:</p>
<pre><code>for bigr, cnt in counts.items():
    if cnt &gt; 1:
        print("{0[0]} {0[1]}: {1}".format(bigr, cnt))
</code></pre>
<p>All put together, with a loop for user input, instead of the fixed list:</p>
<pre><code>import re
from collections import Counter

def bigrams(sentence):
    text = re.sub('\W', ' ', sentence.lower())
    words = text.split()
    return zip(words, words[1:])

counts = Counter()
while True:
    line = input("Line: ")
    if not line:
        break
    counts.update(bigrams(line))

for bigr, cnt in counts.items():
    if cnt &gt; 1:
        print("{0[0]} {0[1]}: {1}".format(bigr, cnt))
</code></pre>
<p>The output:</p>
<pre><code>Line: The big red ball
Line: The big red ball is near the big red box
Line: I am near the box
Line: 
near the: 2
red ball: 2
big red: 3
the big: 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>words = []
while True:
    line = input("Line: ").strip().lower()
    if not line: break
    words.extend(line.split())


counts = {}
for t in zip(words[::2], words[1::2]):
    if t not in counts: counts[t] = 0
    counts[t] += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>usr_input = "Here is a sentence without multiple bigrams. Without multiple bigrams, we cannot test a sentence."

def get_bigrams(word_string):
    words = [word.lower().strip(',.') for word in word_string.split(" ")]
    pairs = ["{} {}".format(w, words[i+1]) for i, w in enumerate(words) if i &lt; len(words) - 1]
    bigrams = {}

    for bg in pairs:
        if bg not in bigrams:
            bigrams[bg] = 0
        bigrams[bg] += 1
    return bigrams

print(get_bigrams(usr_input))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using only knowledge learnt from previous modules of the Grok Learning Python Course mentioned by the OP, this code works fine in performing what was required:</p>
<pre><code>counts = {} # this creates a dictionary for the bigrams and the tally for each one
n = 2
a = input('Line: ').lower().split() # the input is converted into lowercase, then split into a list
while a:
  for x in range(n, len(a)+1):
    b = tuple(a[x-2:x]) # the input gets sliced into pairs of two words (bigrams)
    counts[b] = counts.get(b,0) + 1 # adding the bigrams as keys to the dictionary, with their count value set to 1 initially, then increased by 1 thereafter
  a = input('Line: ').lower().split()  
for c in counts:
  if counts[c] &gt; 1: # tests if the bigram occurs more than once
    print(' '.join(c) + ':', counts[c]) # prints the bigram (making sure to convert the key from a tuple into a string), with the count next to it
</code></pre>
<p>Note: You may need to scroll right to fully view the notes made on code. </p>
<p>It is pretty straightforward and doesn't require importing anything, etc. I realise I am quite late to the conversation, but hopefully anyone else doing the same course / struggling with similar problems will find this answer helpful.</p>
</div>
<span class="comment-copy">Hi @Jeff, when approaching problems like this think about them with out the actual code. Try to describe them in english. Step 1 read line of input. Step 2 break lines into bigrams, step 3 count bigrams. Until you have an outline of what you need to do. It is difficult to code.   Your first set of code almost completes step 1 reading input. see inspectorG4dget answer. for step 1.</span>
<span class="comment-copy">OK I am officially further than I have been in days. Progress is progress :) Thank-you!!</span>
<span class="comment-copy">Would +1 again for the maximum usage of the batteries included.</span>
<span class="comment-copy">The only problem with this is that Grok Learning does not like importing modules like re. They want me to learn by using built-in functionality. Thank-you for this though, I will take from it what I can.</span>
<span class="comment-copy">@JeffSingleton, <code>re</code> is needed only to strip punctuation, so you can skip that part if it's not required (although I wanted to show in my answer that preprocessing is also important). <code>Counter</code> can also be simply (re-)implemented -- but the beauty of Python is actually in having all those nice pieces ready at your disposal. That's why the motto of Python is "with batteries included."</span>
<span class="comment-copy">Thank-you @inspectorG4dget.  I asked for guidance and that is what you gave. I'm still working toward a solution, but this helped me get passed where I was.</span>
