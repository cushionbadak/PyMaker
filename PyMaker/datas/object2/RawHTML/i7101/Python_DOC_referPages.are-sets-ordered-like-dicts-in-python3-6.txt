<div class="post-text" itemprop="text">
<p>Due to changes in <code>dict</code> implementation in Python 3.6 it is now ordered by default. Do <code>set</code>s preserve order as well now?</p>
<p>I could not find any information about it but as both of those data structures are very similar in the way they work under the hood I thought it might be the case.</p>
<p>I know there is no promise for <code>dict</code>s to be ordered in all cases but they are most of the time. As stated in Python docs:</p>
<blockquote>
<p>The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>No, <code>set</code>s are still unordered.</p>
<p>You can verify this just by displaying a <code>set</code> that should have a "well-defined hash order"<sup>1</sup> to make sure we don't accidentally get a <code>set</code> that looks ordered but actually isn't:</p>
<pre><code>&gt;&gt;&gt; a_set = {3,2,1}
&gt;&gt;&gt; a_set
{1, 2, 3}
&gt;&gt;&gt; list(a_set)
[1, 2, 3]
</code></pre>
<p>If it were ordered you would expect <code>{3, 2, 1}</code> and <code>[3, 2, 1]</code> as result of the examples.</p>
<p>While <code>dict</code>s are actually ordered (same example just a bit modified):</p>
<pre><code>&gt;&gt;&gt; a_dict = {3: 3, 2: 2, 1:1}
&gt;&gt;&gt; a_dict
{3: 3, 2: 2, 1: 1}
&gt;&gt;&gt; list(a_dict)
[3, 2, 1]
</code></pre>
<hr/>
<p><sup>1</sup> "well-defined hash order":</p>
<p>For integers that satisfy <code>0 &lt;= integer &lt; sys.hash_info.modulus</code> the <code>hash</code> is just the number itself. That means if the set is ordered "based" on the hash (and not ordered based on the insertion "time") and the hash values don't collide (that's why I used small numbers and numbers that only differ by one) the order should be deterministic because they occupy slots inside the set that are next to each other: </p>
<ul>
<li>Either from smallest to highest</li>
<li>or a from a specific value to the highest and then from the smallest to the specific value. This case happens if the next (in the sense of neighboring) free slot in the set is the first one.</li>
</ul>
<p>As an example for the latter:</p>
<pre><code>&gt;&gt;&gt; a_set = {6,7,8,9}
&gt;&gt;&gt; a_set
{8, 9, 6, 7}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>set</code>s are not ordered in Python 3.6, not even as a CPython implementation detail. A simple example illustrates this:</p>
<pre><code>&gt;&gt;&gt; import string
&gt;&gt;&gt; string.digits
'0123456789'
&gt;&gt;&gt; set(string.digits)
{'7', '0', '2', '8', '6', '9', '1', '5', '4', '3'}
</code></pre>
<p>The Python 3 <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="noreferrer">docs</a> are clear on this:</p>
<blockquote>
<p>A set is an unordered collection with no duplicate elements.</p>
</blockquote>
</div>
<span class="comment-copy">Thanks for asking this. I had some code that depended on the random order of sets.</span>
<span class="comment-copy">@byxor You should not depend on <i>random</i> order, sets are <i>arbitrarily</i> ordered but far from random due to the hashing</span>
<span class="comment-copy">Negative <code>int</code>s also hash to themselves (apart from <code>-1</code>), although I'm not sure what the exact lower boundary is</span>
<span class="comment-copy">@Chris_Rands Yes, but because <code>-1</code> and <code>-2</code> both hash to <code>-2</code> there's a collision.:)</span>
<span class="comment-copy">Yes and <code>-1</code> behaves this way because it's an error code in C; I believe the boundary is <code>(sys.maxsize // 4) - 1</code>, at least this is what Martijn Pieters told me previously</span>
<span class="comment-copy">That's good to know. But it makes sense if one wants to catch errors during <code>hash</code>. I also found the maximum value. It's <code>sys.hash_info.modulus</code>. :)</span>
<span class="comment-copy">But the docs on <code>dict</code> also say that "It is best to think of a dictionary as an <b>unordered</b> set of key: value pairs, with the requirement that the keys are unique (within one dictionary)." (<a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">source</a>). That's just the language spec, the implementation <i>could</i> be ordered...</span>
<span class="comment-copy">@MSeifert "best to think of" is the key phrasing I think, there is no such caveat for the <code>set</code> docs</span>
<span class="comment-copy">I thought that's just "fluff" (or included because PyPy had an ordered dictionary for a long time). But, like I said, that's just the language spec. It doesn't mean an implementation could implement it in an ordered fashion (i.e. with buckets or similar).</span>
