<div class="post-text" itemprop="text">
<p>Here's my code:</p>
<pre><code>import _thread
import time
def print_time(name, delay):
    count=1
    while count&lt;=5:
        time.delay(delay)
        print ("Thread %s Time is %s"%(count, time.ctime(time.time())))
        count = count+1

_thread.start_new_thread(print_time,("T-1",2))
_thread.start_new_thread(print_time,("T-2",4))
</code></pre>
<p>The output should be various lines telling the current time. But after running the program I got no output and no error. Why is this happening? I use Python 3.6.</p>
</div>
<div class="post-text" itemprop="text">
<p>Probably the first question is why you're using <code>_thread</code>. I am guessing your issue is that your main thread finishes before <code>print_time</code> manages to produce any output, and on this particular system, that exits the whole program. </p>
<p>From the section Caveats in the <a href="https://docs.python.org/3/library/_thread.html" rel="nofollow noreferrer">_thread documentation</a>:</p>
<blockquote>
<p>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing <code>try</code> â€¦ <code>finally</code> clauses or executing object destructors.</p>
</blockquote>
<p>When using <code>threading</code> instead, you get to choose whether to await threads with the <code>daemon</code> argument. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>threading</code>:</p>
<pre><code>import threading
import time

def print_time(name, delay):
    count=1
    while count&lt;=5:
        time.sleep(delay)
        print ("Thread %s Time is %s"%(count, time.ctime(time.time())))
        count = count+1

t1 = threading.Thread(target=print_time, args=("T-1",2))
t2 = threading.Thread(target=print_time, args=("T-2",4))

t1.start()
t2.start()
</code></pre>
<blockquote>
<p>The threading module provides an easier to use and higher-level threading API built on top of this [<code>_thread</code>] module.</p>
</blockquote>
</div>
<span class="comment-copy">Use the multiprocessing library</span>
<span class="comment-copy">@whackmadoodle3000 Which module should I import?</span>
<span class="comment-copy">multiprocessing <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow noreferrer">docs.python.org/2/library/multiprocessing.html</a></span>
<span class="comment-copy">Given the sample doesn't contain any actual work, there's no indication the multiprocessing module would be any more appropriate. It is useful for message passing programs and using multiple processors for Python code, but has its own caveats (in particular, the lack of fork on Windows, and the serialization of data passed between processes).</span>
<span class="comment-copy">Can't we use the <code>thread</code> module? I'm currently learning proxy servers and they use the <code>thread</code> module.</span>
<span class="comment-copy">Sure you can... you just have to pay attention and handle all the details. Or you can use the modules in the standard library that already do that. In this case, you expected an implicit synchronization (probably in the form of joining all threads to the main thread) but you needed to make it explicit.</span>
<span class="comment-copy">My system says <code>ImportError: no module named thread</code>. What should I do?</span>
<span class="comment-copy">I thought you meant <code>_thread</code>, which is in the standard library. It's quite low level. I don't know what you're trying to do; if you're using Python 3.6, it's likely a good idea to look at <a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="nofollow noreferrer">concurrent futures</a> which provides a common high level interface to run tasks in either threads or processes.</span>
