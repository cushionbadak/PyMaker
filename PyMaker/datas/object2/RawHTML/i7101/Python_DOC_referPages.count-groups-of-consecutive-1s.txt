<div class="post-text" itemprop="text">
<p>I have a list of '1's and '0s' and I would like to calculate the number of groups of consecutive '1's. </p>
<pre><code>mylist = [0,0,1,1,0,1,1,1,1,0,1,0]
</code></pre>
<p>Doing it by hand gives us 3 groups but is there a way to do it by python?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Option 1</strong></p>
<p>With <code>pandas</code>. First, initialise a dataframe:</p>
<pre><code>In [78]: df
Out[78]: 
    Col1
0      0
1      0
2      1
3      1
4      0
5      1
6      1
7      1
8      1
9      0
10     1
11     0
</code></pre>
<p>Now calculate sum total by number of groups:</p>
<pre><code>In [79]: df.sum() / df.diff().eq(1).cumsum().max()
Out[79]: 
Col1    2.333333
dtype: float64
</code></pre>
<p>If you want just the number of groups, <code>df.diff().eq(1).cumsum().max()</code> is enough.</p>
<hr/>
<p><strong>Option 2</strong></p>
<p>With <code>itertools.groupby</code>:</p>
<pre><code>In [88]: sum(array) / sum(1 if sum(g) else 0 for  _, g in  itertools.groupby(array))
Out[88]: 2.3333333333333335
</code></pre>
<p>If you want just the number of groups, <code>sum(1 if sum(g) else 0 for  _, g in  itertools.groupby(array))</code> is enough.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here I count whenever there is a jump from 0 to 1.
Prepending the 0 prevents not counting a leading sequence.</p>
<pre><code>import numpy as np

mylist_arr = np.array([0] + [0,0,1,1,0,1,1,1,1,0,1,0])
diff = np.diff(mylist_arr)
count = np.sum(diff == 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can try this </p>
<pre><code>import numpy as np
import pandas as pd
df=pd.DataFrame(data = [0,0,1,1,0,1,1,1,1,0,1,0])
df['Gid']=df[0].diff().eq(1).cumsum()
df=df[df[0].eq(1)]
df.groupby('Gid').size()
Out[245]: 
Gid
1    2
2    4
3    1
dtype: int64

sum(df.groupby('Gid').size())/len(df.groupby('Gid').size())
Out[244]: 2.3333333333333335
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one solution:</p>
<pre><code>durations = []

for n, d in enumerate(mylist):
    if (n == 0 and d == 1) or (n &gt; 0 and mylist[n-1] == 0 and d == 1):
        durations.append(1)
    elif d == 1:
        durations[-1] += 1

def mean(x):
    return sum(x)/len(x)

print(durations)
print(mean(durations))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>mylist = [0,0,1,1,0,1,1,1,1,0,1,0]
previous = mylist[0]
count = 0

for i in mylist[1:]:
   if i == 1:
       if previous == 0:
            previous = 1
   else:
       if i == 0:
            if previous == 1:
                 count += 1
                 previous = 0

print count
</code></pre>
<p>Output:</p>
<pre><code>3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>import itertools
import operator

def get_1_groups(ls):
    return sum(map(operator.itemgetter(0), itertools.groupby(ls)))
</code></pre>
<p>This works because <code>itertools.groupby</code> returns (the iterable equivalent) of:</p>
<pre><code>itertools.groupby([0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0])
# ==&gt;
[(0, [0, 0]), (1, [1, 1]), (0, [0]), (1, [1, 1, 1, 1]), (0, [0]), (1, [1]), (0, [0])]
</code></pre>
<p>So you are just summing the first item.</p>
<p>If you can have other items that are not 0, they would add to the sum.</p>
<p>You can do something like this:</p>
<pre><code>def count_groups(ls, target=1):
    return sum(target == value for value, _ in itertools.groupby(ls))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be accomplished without much work by simply summing the number of times the list transitions from <code>0</code> to <code>1</code> (Counting <a href="https://en.wikipedia.org/wiki/Signal_edge" rel="nofollow noreferrer">rising signal edges</a>):</p>
<pre><code>count = 0
last = 0
for element in mylist:
    if element != last:
        last = element
        if element:  # 1 is truthy
            count += 1
print count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution:</p>
<h1>c is the list to play on</h1>
<pre><code>   c=[1,0,1,1,1,0]
   max=0
   counter = 0

   for j in c:
     if j==1:
        counter+=1

     else:
        if counter&gt;max:
           max=counter
           counter=0
           continue

   if counter&gt;max:
      max=counter

   print(max)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A Quick and dirty one-liner (almost)</p>
<pre><code>import re
mylist = [0,0,1,1,0,1,1,1,1,0,1,0]
print len(re.sub(r'0+', '0', ''.join(str(x) for x in mylist)).strip('0').split('0')) 
3
</code></pre>
<p>step by step:</p>
<pre><code>import re
mylist = [0,0,1,1,0,1,1,1,1,0,1,0]
sal1 = ''.join(str(x) for x in mylist) # returns a string from the list
sal2 = re.sub(r'0+', '0', sal1)   # remove duplicates of zeroes
sal3 = sal2.strip('0')            # remove 0s from the start &amp; the end of the string
sal4 = len(sal3.split('0'))       # split the string using '0' as separators into a list, and calculate it's length
</code></pre>
<p>This throws:</p>
<pre><code>sal  -&gt; 001101111010
sal2 -&gt; 01101111010
sal3 -&gt; 110111101
sal4 -&gt; 3
</code></pre>
</div>
<span class="comment-copy">This looks like a job for a <code>groupBy</code> function, although I don't know if Python had such a function standard. Search the docs for that name.</span>
<span class="comment-copy">there is a groupby function in python --- although its mostly used to group rows together</span>
<span class="comment-copy">Yes gotcha. Sorry fairly new to this. Your answer is most succinct amongst others. Also not too complicated.</span>
<span class="comment-copy">How do I apply get_group() to the dataframe?</span>
<span class="comment-copy">Hey, why the downvote?</span>
