<div class="post-text" itemprop="text">
<p>I'm trying to run several sockets on different ports as the following:</p>
<p>Socket:</p>
<pre><code>import socket

class Receiver:
    TCP_IP = '127.0.0.1'  # by default
    TCP_PORT = 1999  # by default
    BUFFER_SIZE = 1024

    def __init__(self, TCP_IP, TCP_PORT):
        self.TCP_IP = TCP_IP
        self.TCP_PORT = TCP_PORT

    def initialize(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind((self.TCP_IP, self.TCP_PORT))
        s.listen(1)

        conn, addr = s.accept()
        print('Connection address:', addr)
        while 1:
            data = conn.recv(self.BUFFER_SIZE)
            if not data: break
            rdata = 'U'.encode() + data
            print("received data:", data[1:5])
            conn.send(rdata[0:5])  # echo
        conn.close()
</code></pre>
<p>And Runner:</p>
<pre><code>from NVGEmulator.Receiver import Receiver
import threading
class FireStarter:

    def starter(self):
        nvgEmu1 = Receiver('127.0.0.1', 2999)
        print("FIRST INITIALIZED")
        nvgEmu1.initialize()

        nvgEmu2 = Receiver('127.0.0.1', 2998)
        nvgEmu2.initialize()
        print("SECOND INITIALIZED")

    def starter_second(self):
        nvgEmu2 = Receiver('127.0.0.1', 2998)
        print("SECOND INITIALIZED")
        nvgEmu2.initialize()

if __name__ == '__main__':
    print("Receiver has been started")
    fs = FireStarter()
    thr = threading.Thread(target=fs.starter())
    thr.start()
    thr.join()

    thr2 = threading.Thread(target=fs.starter_second())
    thr2.start()
</code></pre>
<p>When I run FireStarter, it runs only the first instance of socket. I've read that there is "threading" library which can run several processes in async, but anyway there is no result, cause in console I see that "FIRST INITIALIZED". How to run the second or the third socket listener? May be there is another approach to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two problems in that code.</p>
<p>The first one: here the second socket is waiting for the first one to end as it is trapped in the while loop:</p>
<pre><code>def starter(self):
    nvgEmu1 = Receiver('127.0.0.1', 2999)
    print("FIRST INITIALIZED")
    nvgEmu1.initialize()

    nvgEmu2 = Receiver('127.0.0.1', 2998)
    nvgEmu2.initialize()
    print("SECOND INITIALIZED")
</code></pre>
<p>The second one is this join sentence <code>thr.join()</code>, with that you are forcing the second thread to wait for the first one, avoiding to run it in parallel.</p>
<p>Probably the approach I would follow is spawning a thread within the <code>initialize</code> function inside your <strong>Receiver</strong> class and manage the thread there (maybe extending the Thread class), with that you avoid to spawn by yourself a new thread each time and you have your code more encapsulated.</p>
</div>
<span class="comment-copy">I would recommend using an event-based library like <a href="http://eventlet.net/" rel="nofollow noreferrer"><code>eventlet</code></a>, <a href="http://www.gevent.org/" rel="nofollow noreferrer"><code>gevent</code></a>, or, if using Python 3, the native <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> module.  This will allow you to simultaneously listen on all sockets and handle packets from any of them at the same time, without the overhead of threads.</span>
