<div class="post-text" itemprop="text">
<p>I need to patch three methods (<code>_send_reply</code>, <code>_reset_watchdog</code> and <code>_handle_set_watchdog</code>)  with mock methods before testing a call to a fourth method (<code>_handle_command</code>) in a unit test of mine.</p>
<p>From looking at the documentation for the <a href="http://www.voidspace.org.uk/python/mock/" rel="noreferrer">mock</a> package, there's a few ways I could go about it:</p>
<p><strong>With <code>patch.multiple</code> as decorator</strong></p>
<pre><code>@patch.multiple(MBG120Simulator,
                _send_reply=DEFAULT,
                _reset_watchdog=DEFAULT,
                _handle_set_watchdog=DEFAULT,
                autospec=True)
def test_handle_command_too_short_v1(self,
                                     _send_reply,
                                     _reset_watchdog,
                                     _handle_set_watchdog):
    simulator = MBG120Simulator()
    simulator._handle_command('XA99')
    _send_reply.assert_called_once_with(simulator, 'X?')
    self.assertFalse(_reset_watchdog.called)
    self.assertFalse(_handle_set_watchdog.called)
    simulator.stop()
</code></pre>
<p><strong>With <code>patch.multiple</code> as context manager</strong></p>
<pre><code>def test_handle_command_too_short_v2(self):
    simulator = MBG120Simulator()

    with patch.multiple(simulator,
                        _send_reply=DEFAULT,
                        _reset_watchdog=DEFAULT,
                        _handle_set_watchdog=DEFAULT,
                        autospec=True) as mocks:
        simulator._handle_command('XA99')
        mocks['_send_reply'].assert_called_once_with('X?')
        self.assertFalse(mocks['_reset_watchdog'].called)
        self.assertFalse(mocks['_handle_set_watchdog'].called)
        simulator.stop()
</code></pre>
<p><strong>With multiple <code>patch.object</code> decoratorations</strong></p>
<pre><code>@patch.object(MBG120Simulator, '_send_reply', autospec=True)
@patch.object(MBG120Simulator, '_reset_watchdog', autospec=True)
@patch.object(MBG120Simulator, '_handle_set_watchdog', autospec=True)
def test_handle_command_too_short_v3(self,
                                     _handle_set_watchdog_mock,
                                     _reset_watchdog_mock,
                                     _send_reply_mock):
    simulator = MBG120Simulator()
    simulator._handle_command('XA99')
    _send_reply_mock.assert_called_once_with(simulator, 'X?')
    self.assertFalse(_reset_watchdog_mock.called)
    self.assertFalse(_handle_set_watchdog_mock.called)
    simulator.stop()
</code></pre>
<p><strong>Manually replacing methods using <code>create_autospec</code></strong></p>
<pre><code>def test_handle_command_too_short_v4(self):
    simulator = MBG120Simulator()

    # Mock some methods.
    simulator._send_reply = create_autospec(simulator._send_reply)
    simulator._reset_watchdog = create_autospec(simulator._reset_watchdog)
    simulator._handle_set_watchdog = create_autospec(simulator._handle_set_watchdog)

    # Exercise.
    simulator._handle_command('XA99')

    # Check.
    simulator._send_reply.assert_called_once_with('X?')
    self.assertFalse(simulator._reset_watchdog.called)
    self.assertFalse(simulator._handle_set_watchdog.called)
</code></pre>
<p>Personally I think the last one is clearest to read, and will not result in horribly long lines if the number of mocked methods grow. It also avoids having to pass in <code>simulator</code> as the first (<code>self</code>) argument to <code>assert_called_once_with</code>.</p>
<p>But I don't find any of them particularly nice. Especially the multiple <code>patch.object</code> approach, which requires careful matching of the parameter order to the nested decorations.</p>
<p>Is there some approach I've missed, or a way to make this more readable? What do you do when you need to patch multiple methods on the instance/class under test?</p>
</div>
<div class="post-text" itemprop="text">
<p>No you didn't have missed anything really different from what you proposed. </p>
<p>About readability my taste is for decorator way because it remove the mocking stuff from test body... but it is just taste.</p>
<p>You are right: if you patch the static instance of the method by <code>autospec=True</code> you must use self in <code>assert_called_*</code> family check methods. But your case is just a small class because you know exactly what object you need to patch and you don't really need other context for your patch than test method.</p>
<p>You need just patch your object use it for all your test: often in tests you cannot have the instance to patch before doing your call and in these cases <code>create_autospec</code> cannot be used: you can just patch the static instance of the methods instead.</p>
<p>If you are bothered by passing the instance to <code>assert_called_*</code> methods consider to use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.ANY" rel="noreferrer"><code>ANY</code></a> to break the dependency. Finally I wrote hundreds of test like that and I never had a problem about the arguments order.</p>
<p>My standard approach at your test is</p>
<pre><code>@patch('mbgmodule.MBG120Simulator._send_reply', autospec=True)
@patch('mbgmodule.MBG120Simulator._reset_watchdog', autospec=True)
@patch('mbgmodule.MBG120Simulator._handle_set_watchdog', autospec=True)
def test_handle_command_too_short(self,mock_handle_set_watchdog,
                                          mock_reset_watchdog,
                                          mock_send_reply):
    simulator = MBG120Simulator()
    simulator._handle_command('XA99')
    # You can use ANY instead simulator if you don't know it
    mock_send_reply.assert_called_once_with(simulator, 'X?')
    self.assertFalse(mock_reset_watchdog.called)
    self.assertFalse(mock_handle_set_watchdog_mock.called)
    simulator.stop()
</code></pre>
<ul>
<li>Patching is out of the test method code </li>
<li>Every mock starts by <code>mock_</code> prefix</li>
<li>I prefer to use simple <code>patch</code> call and absolute path: it is clear and neat what you are doing</li>
</ul>
<p>Finally: maybe create <code>simulator</code> and stop it are <code>setUp()</code> and <code>tearDown()</code> responsibility and tests should take in account just to patch some methods and do the checks.</p>
<p>I hope that answer is useful but the question don't have a unique valid answer because <em>readability</em> is not an absolute concept and depends from the reader. Moreover even the title speaking about general case, question examples are about the specific class of problem where you should patch methods of the object to test.</p>
<p><strong>[EDIT]</strong></p>
<p>I though a while about this question and I found what bother me: you are trying to test and sense on private methods. When this happen the first thing that you should ask is why? There are a lot chances that the answer is because these methods should be public methods of private collaborators (<a href="https://rads.stackoverflow.com/amzn/click/com/0131177052" rel="nofollow noreferrer">that not my words</a>). </p>
<p>In that new scenario you should sense on private collaborators and you cannot change just your object. What you need to do is to patch the static instance of some other classes.</p>
</div>
<span class="comment-copy">Thanks a lot for the thorough answer. In order:  1) Good point about my case being special (that I have access to the instance et.c.). 2) Thanks for the tip about ANY. 3) Yes, perhaps I'm exaggerating the brittleness of the argument order when using decorators. 4) Question: So <code>@patch('package.module.Class.some_method', autospec=True)</code> is equivalent to <code>@patch.object(package.module.Class, 'some_method', autospec=True)</code> ? That's nice, and if so I also prefer your way of doing it.  ...</span>
<span class="comment-copy">...  5) I'm a bit hesitant to use <code>setUp</code> and <code>tearDown</code> as I like my tests to be completely self contained, eventhough it'll mean some more typing. But that's just a personal preference. 6) .. and on that note, yes sorry for asking a question which only has mostly subjective answers! 7) I'll consider what you said about testing private methods. I do like being able to do so easily in Python, and it's important that this code has 100% line coverage. But I'll consider breaking them out into collaborator(s). The class under test is quite small though.  Again, thanks for the great answer.</span>
<span class="comment-copy">Gah. Sorry for the horrible formatting. I'm really not friends with SO comment functionality. Anyway, accepting your answer as it is very good.</span>
<span class="comment-copy">How many questions.... file a new question and I'll answer :).... 4) Yes are the same (I use <code>patch.object</code> just when I must). 5) If you did it in all your test why bother the reader to understand it at every test?.. I'm using <code>setUp()</code> and <code>tearDown()</code> just occasionally but some cases by them you can improve readability. 7) Wow 100% coverage :) ... If you use some inspect tool that will yield for private access; even if python give to you the possibility of use private method that doesn't mean it is a good thing to do even in tests....</span>
<span class="comment-copy">@estan ... I used to test and sense on private data but from when I stop to do it I saw my design become better and do a little effort to expose some properties and create new class that have just one <i>responsibility</i> produce a very neat code.</span>
