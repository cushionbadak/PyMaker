<div class="post-text" itemprop="text">
<p>I have a list, and i want to return each element in that list along with its position in it.</p>
<p>for example: </p>
<pre><code>my_enumerate(['dog', 'pig', 'cow']) 
</code></pre>
<p>should return:</p>
<pre><code>[(0, 'dog'), (1, 'pig'), (2, 'cow')]
</code></pre>
<p>The following is how I've approached it:</p>
<pre><code>def my_enumerate(items):
''' returning position of item in a list'''
lista = []
for num in range(0, len(items)+1):
    for item in items:
        lista.append("({0}, {1})".format(num, item))
return lista
</code></pre>
<p>which returned to me:</p>
<pre><code>['(0, dog)', '(0, pig)', '(0, cow)', '(1, dog)', '(1, pig)', '(1, cow)', '(2, dog)', '(2, pig)', '(2, cow)', '(3, dog)', '(3, pig)', '(3, cow)']
</code></pre>
<p>The function should behave exactly like the built-in enumerate function, but I'm not allowed to use it. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your program produces cartesian product of all the indexes and elements of the list. It takes each index and produces all the strings with the elements in the list. Also, note that, you should iterate only till the length of the list, when you do <code>len(items) + 1</code>, you are actually exceeding the actual length of the list.</p>
<p>You can use only the first loop, like this</p>
<pre><code>&gt;&gt;&gt; def my_enumerate(items):
...     lista = []
...     for num in range(len(items)):
...         lista.append("({0}, {1})".format(num, items[num]))
...     return lista
... 
&gt;&gt;&gt; my_enumerate(['dog', 'pig', 'cow']) 
['(0, dog)', '(1, pig)', '(2, cow)']
</code></pre>
<p>You can also use a simple <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a>, like this</p>
<pre><code>&gt;&gt;&gt; def my_enumerate(items):
...     return ["({0}, {1})".format(num, items[num]) for num in range(len(items))]
... 
&gt;&gt;&gt; my_enumerate(['dog', 'pig', 'cow']) 
['(0, dog)', '(1, pig)', '(2, cow)']
</code></pre>
<p><strong>Note 1:</strong> In Python 3.x, you don't have to use the positions in the format string unless it is necessary. So, <code>"({}, {})".format</code> is enough.</p>
<p><strong>Note 2:</strong> If you actually wanted to return tuples, like <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a>, then you should not use string formatting, instead prepare tuples like this</p>
<pre><code>&gt;&gt;&gt; def my_enumerate(items):
...     return [(num, items[num]) for num in range(len(items))]
... 
&gt;&gt;&gt; my_enumerate(['dog', 'pig', 'cow']) 
[(0, 'dog'), (1, 'pig'), (2, 'cow')]
</code></pre>
<p><strong>Note 3:</strong> If you actually wanted to simulate <code>enumerate</code> like it works in Python 3.x, then you should better use a generator function, like this</p>
<pre><code>&gt;&gt;&gt; def my_enumerate(items):
...     for num in range(len(items)):
...         yield (num, items[num])
...     
... 
&gt;&gt;&gt; my_enumerate(['dog', 'pig', 'cow']) 
&lt;generator object my_enumerate at 0x7f5ff7abf900&gt;
&gt;&gt;&gt; list(my_enumerate(['dog', 'pig', 'cow']))
[(0, 'dog'), (1, 'pig'), (2, 'cow')]
</code></pre>
<p><strong>Note 4:</strong> More good news is, you can write the same <code>my_enumerate</code>, with <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator" rel="nofollow"><code>yield from</code></a> and a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow">generator expression</a>, like this</p>
<pre><code>&gt;&gt;&gt; def my_enumerate(items):
...     yield from ((num, items[num]) for num in range(len(items)))
... 
&gt;&gt;&gt; my_enumerate(['dog', 'pig', 'cow']) 
&lt;generator object my_enumerate at 0x7f5ff7abfe10&gt;
&gt;&gt;&gt; list(my_enumerate(['dog', 'pig', 'cow']))
[(0, 'dog'), (1, 'pig'), (2, 'cow')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you write it as a generator, it will even work with infinite generators:</p>
<pre><code>def my_enumerate(items):
    i = 0
    for e in items:
        yield (i, e)
        i += 1

print(list(my_enumerate(['dog', 'pig', 'cow']))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it in a one-liner pretty easily using <code>zip</code>, <code>range</code>, and <code>len</code>:</p>
<pre><code>def my_enumerate(items):
    return zip(range(len(myList)), myList)

my_list = ['dog', 'pig', 'cow']
print(my_enumerate(my_list)) # prints [(0, 'dog'), (1, 'pig'), (2, 'cow')]
</code></pre>
<p>The above would be the Python 2 version. Note that in Python 3, <code>zip</code> returns a generator, which actually may be just what you need, but if you absolutely need a list, you can just wrap the returned expression in a <code>list()</code> call.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simplest:</p>
<pre><code>def my_enumerate(items):
    return list(enumerate(items))
</code></pre>
</div>
<span class="comment-copy">Thanks! But what about the strings that appear around the tuples? how would i be able to remove them and put them around  <code>item</code> thats inside the tuple. (as same as Top example).</span>
<span class="comment-copy">@Moh'dH Please check "Note 2" in the latest answer.</span>
<span class="comment-copy">You beat me to it. I think this is the most elegant solution. And to encapsulate that in a function, we can do: <code>my_enumeration = lambda li : zip(range(len(li)), li)</code>. You don't need to <code>list()</code> the return value of <code>zip</code>, though. <code>zip</code> returns a list.</span>
<span class="comment-copy">@szabad Ah, sorry, I am using Python 3 on repl.it and in Python 3, zip returns a generator/iterable. But I have made the note in my answer.</span>
<span class="comment-copy">Actually OP says <code>The function should behave exactly like the built-in enumerate function, but I'm not allowed to use it.</code></span>
<span class="comment-copy">I want to drive in a nail, and I'm not allowed to use a hammer (even though I have one). I'm not going to explain why I can't use the hammer.</span>
<span class="comment-copy">@wim I learned to implement a large portion of C++ stdlib in University and I can easily say it was one of the most enlightening experiences of my life and it made me very interested in algorithms and data structures. Re-inventing the wheel for educational purposes is not always a bad thing.</span>
