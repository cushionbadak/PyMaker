<div class="post-text" itemprop="text">
<p>Saludos.</p>
<p>I want to sums even index of a list, and i do it works normally with every list, BUT when if the passed list like argument have a duplicated item, the code dont work like it should.</p>
<p>example, I have this code:</p>
<pre><code>def sumar_indices_pares(array):
    """
        sums even-indexes elements 
    """
    suma = []
    while array == []:
        return 0
    for i in array:
        if array.index(i) % 2 == 0 :
            suma.append(i)
    return sum(suma)
</code></pre>
<p>if i pass like argument the next:</p>
<pre><code>   sumar_indices_pares([1,2,3,4,5])    # give 9 and this is ok
</code></pre>
<p>But, when i put like argument a list with duplicated items, the loop 'for' iterate and when its over index [1] like is not even ("Par" in spanish) obviously don't sums that index but when the loop reach a even index but with the same value of previous index the code don't sums the even index, example:</p>
<pre><code>sumar_indices_pares([1,2,3,4,2])   # it gives 4 and should be 6 because (1+3+2) = 6 
</code></pre>
<p>so, the first index with value of 2 is not even so  don't sums that index, but should sums the next index with value of 2 because is a even index.</p>
<p>Note: argument list empty will return 0, that part is ok ;).</p>
<p>Any Solution? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow"><code>index()</code></a> will return the <em>first</em> index for a given value. If you have duplicate values it will indeed always return the index of the first value.</p>
<p>As an example, given the list <code>[1,3,3,4,6,3]</code></p>
<pre><code>index:    0   1   2   3   4   5
values:   1   3   3   4   6   3
</code></pre>
<p>Each call of <code>index()</code> will start a new search from "left to right", stopping when the first occurrence of the searched value is found. For example, if you're looking for <code>3</code> it will do something like that:</p>
<pre><code>index:    0   1   2   3   4   5
values:   1   3   3   4   6   3

index(3)  No  Yes
              ^
              |
            3 is found
            stop here
</code></pre>
<p>Please note that even if it worked when you had non duplicate values, it was not very efficient as the program has to perform that linear search in the list on each iteration.</p>
<hr/>
<p>For small lists, the canonical way to iterate over <em>even</em> items is probably to use the slice syntax:</p>
<pre><code>suma = array[::2]
return sum(suma)
</code></pre>
<p>For sake of completeness, if you need to iterate over odd index, you will write:</p>
<pre><code>return sum(array[1::2])
</code></pre>
<hr/>
<p>For long lists this can be inefficient too as this will make a <em>copy</em> of the list containing only the required items. If you need to deal with such lists, you will probably need to take a look at <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow"><code>itertools.islice</code></a>:</p>
<pre><code>&gt;&gt;&gt; l=[0,1,2,3,4,5]

&gt;&gt;&gt; import itertools
&gt;&gt;&gt; itertools.islice(l, 0, None, 2)   # Returns an iterator from first (idx 0)
                                      # to last (None) item, stepping by 2
                                      # -- not a (partial) copy of the list
&lt;itertools.islice object at 0x7f5369ccf680&gt;
&gt;&gt;&gt; sum(itertools.islice(l, 0, None, 2))
6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can actually do this in one line, using slices like @SylvainLeroux mentioned:</p>
<pre><code>sum(array[::2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>enumerate</code>. Looking for the index the way you are trying to do it is inefficient, and gives the wrong answer when there are duplicates as you have seen.</p>
<pre><code>def sumar_indices_pares(array):
    """
        sums even-indexes elements 
    """
    suma = []
    if array == []:
        return 0
    for i, item in enumerate(array):
        if i % 2 == 0 :
            suma.append(item)
    return sum(suma)
</code></pre>
<p>You don't need a special case for the empty list if you use <code>sum</code> with a generator expression</p>
<pre><code>def sumar_indices_pares(array):
    """
        sums even-indexes elements 
    """
    return sum(item for i, item in enumerate(array) if i % 2 == 0)
</code></pre>
</div>
<span class="comment-copy">Why are you using a <code>while</code> loop instead of an <code>if</code> statement around <code>return 0</code>?</span>
<span class="comment-copy"><code>array.index(x)</code> should take the first occurence of <code>x</code> in the list. Thats why when duplicate, it doesn't gave you expected result.</span>
<span class="comment-copy">Instead of adding the values to a list and summing them later, you should just sum them directly. That way you save a lot of memory for large input lists and you don’t need two iterations.</span>
<span class="comment-copy">@KSFT and it should be written as <code>if not array:</code></span>
<span class="comment-copy">You just copied my answer into the end of yours...</span>
