<div class="post-text" itemprop="text">
<p>I was looking up how to create a function that removes duplicate characters from a string in python and found this on stack overflow: </p>
<pre><code>    from collections import OrderedDict

    def remove_duplicates (foo) :
        print " ".join(OrderedDict.fromkeys(foo))
</code></pre>
<p>It works, but how? I've searched what OrderedDict and fromkeys mean but I can't find anything that explains how it works in this context.</p>
</div>
<div class="post-text" itemprop="text">
<p>I will give it a shot:</p>
<p><a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow">OrderedDict</a> are dictionaries that store keys in order they are added. Normal dictionaries don't. If you look at <strong>doc</strong> of <code>fromkeys</code>, you find:</p>
<blockquote>
<p>OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.</p>
</blockquote>
<p>So the <code>fromkeys</code> class method, creates an <code>OrderedDict</code> using items in the input iterable S (in my example characters from a string) as keys. In a dictionary, keys are unique, so duplicate items in <code>S</code> are ignored.</p>
<p>For example:</p>
<pre><code>s = "abbcdece" # example string with duplicate characters

print(OrderedDict.fromkeys(s))
</code></pre>
<p>This results in an OrderedDict:</p>
<pre><code>OrderedDict([('a', None), ('b', None), ('c', None), ('d', None), ('e', None)])
</code></pre>
<p>Then <code>" ".join(some_iterable)</code> takes an iterable and joins its elements using a space in this case. It uses only keys, as iterating through a dictionary is done by its keys. For example:</p>
<pre><code>for k in OrderedDict.fromkeys(s): # k is a key of the OrderedDict
    print(k)
</code></pre>
<p>Results in: </p>
<pre><code>a
b
c
d
e
</code></pre>
<p>Subsequently, call to join:</p>
<pre><code>print(" ".join(OrderedDict.fromkeys(s)))
</code></pre>
<p>will print out:</p>
<pre><code>a b c d e
</code></pre>
<p><strong>Using set</strong></p>
<p>Sometimes, people use a set for this:</p>
<pre><code>print( " ".join(set(s)))
# c a b d e
</code></pre>
<p>But unlike sets in C++, sets in python do not guarantee order. So using a set will give you unique values easily, but they might be in a different order then they are in the original list or string (as in the above example). </p>
<p>Hope this helps a bit.</p>
</div>
<div class="post-text" itemprop="text">
<p>By list comprehension</p>
<pre><code>print ' '.join([character for index, character in enumerate(foo) if character not in foo[:index]])
</code></pre>
</div>
<span class="comment-copy">Note that this method isn't very fast</span>
<span class="comment-copy">creating all those <code>foo[:index]</code> is not very efficient - let alone scanning each one with <code>in</code></span>
<span class="comment-copy">You don't seem to get the question at all... He is asking how his code works. He doesn't need nor want an alternate solution.</span>
