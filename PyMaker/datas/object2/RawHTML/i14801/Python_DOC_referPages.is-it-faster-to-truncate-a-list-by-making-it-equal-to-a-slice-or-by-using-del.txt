<div class="post-text" itemprop="text">
<p>Suppose I have a <code>list</code> <code>TruncList</code> with some number of elements greater than <code>n</code>. If I want to remove <code>n</code> elements from the end of that list, is it faster to <strong>redefine the list as a slice of itself</strong> preserving the desired elements, as by <code>TruncList = TruncList[:-n]</code>, or to <strong>delete the slice of unwanted elements</strong> from the list, as by <code>del TruncList[-n:]</code>?</p>
<p>Does the answer change if I was removing the <em>first</em> <code>n</code> elements from <code>TruncList</code> instead, as in <code>TruncList = TruncList[n:]</code> versus <code>del TruncList[:n]</code>?</p>
<p>Besides speed, is one of these methods more Pythonic than the other?</p>
<p>I would imagine that the redefinition method might be slower, since it iterates through <code>TruncList</code> and then reassigns it, while <code>del</code> truncates the list in place, but I'm not sure if either of these are the case.</p>
<p>I would also suppose <code>del</code> is the better route, because it seems like the natural use of the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>It'll depend entirely on <em>how many elements you delete</em>.</p>
<p>In CPython, the <code>list</code> type uses a dynamic overallocation strategy to avoid having to resize the underlying C array too often. There is an <code>array</code> to hold the elements, and it is kept slightly too large at all times.</p>
<p>Deletion then (using <code>del TruncList[-n:]</code>) <strong>could</strong> be a virtually free operation, provided <code>n</code> is sufficiently small. In fact, you can safely delete up to <strong>half</strong> the size of the over-allocated array, before a resize occurs. Resizing requires copying across all existing references to a new array.</p>
<p>Using a slice is <em>always</em> going to create new list object, requiring allocation of memory and copying across of the elements involved. This is slightly more work than re-allocation of data.</p>
<p>So, without measuring time performance (using <code>timeit</code>), I'd expect the <code>del</code> option to be faster than slicing; in the case of <code>n &lt; len(TruncList) // 2</code> (less than half the length) in many cases you don't even incur a resize, and even if you did, slightly less work needs to be done as only the internal array has to be recreated.</p>
<p>When you remove items <em>from the front</em>, you'll always have to recreate the internal array. The differences won't be a stark then, but creating a slice is still going to result in allocation for an entirely new object.</p>
</div>
<div class="post-text" itemprop="text">
<p>So I tested it out myself using <code>timeit</code> with these samples:</p>
<pre><code>  ## Make a list of 500 elements and then remove the first 80...
def slice_front():
    "Make the list equal to all but the first eighty elements."
    trunc = 80
    TruncList = range(500)
    TruncList = TruncList[trunc:]

def del_front():
    "Use del to remove the first eighty elements."
    trunc = 80
    TruncList = range(500)
    del TruncList[:trunc]


  ## Make a list of 500 elements and then remove the last 80...
def slice_end():
    "Make the list equal to all but the last eighty elements."
    trunc = 80
    TruncList = range(500)
    TruncList = TruncList[:-trunc]

def del_end():
    "Delete the last eighty elements from the list using del."
    trunc = 80
    TruncList = range(500)
    del TruncList[-trunc:]
</code></pre>
<p>...and got these results:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit(slice_front, number = 66666)
1.3381525804258112
&gt;&gt;&gt; timeit.timeit(del_front, number = 66666)
1.0384902281466895
&gt;&gt;&gt; timeit.timeit(slice_end, number = 66666)
1.3457694381917094
&gt;&gt;&gt; timeit.timeit(del_end, number = 66666)
1.026411701603827
</code></pre>
<p>It looks like <code>del</code> is faster, and by quite a broad margin.</p>
<hr/>
<p><strong>EDIT</strong></p>
<p>If I run the same samples but with <code>trunc = 2</code> instead, these are the results:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit(slice_front, number = 66666)
1.3947686585537422
&gt;&gt;&gt; timeit.timeit(del_front, number = 66666)
1.0224893312699308
&gt;&gt;&gt; timeit.timeit(slice_end, number = 66666)
1.4089230444569498
&gt;&gt;&gt; timeit.timeit(del_end, number = 66666)
1.042288032264116
</code></pre>
<p><code>del</code> is still faster.</p>
<p>Here's a test where nearly all of the list elements are removed: <code>trunc = 80</code> and <code>TruncList = range(81)</code>...</p>
<pre><code>&gt;&gt;&gt; timeit.timeit(slice_front, number = 66666)
0.25171681555993247
&gt;&gt;&gt; timeit.timeit(del_front, number = 66666)
0.2696609454136185
&gt;&gt;&gt; timeit.timeit(slice_end, number = 66666)
0.2635454769274057
&gt;&gt;&gt; timeit.timeit(del_end, number = 66666)
0.294670910710936
</code></pre>
<p>In this case, <code>del</code> is somewhat slower than the redefinition method.</p>
</div>
<span class="comment-copy">Why don't you try it? See the <a href="https://docs.python.org/3/library/timeit.html#module-timeit" rel="nofollow noreferrer"><code>timeit</code></a> module.</span>
<span class="comment-copy">@mhawke That may be the best question of all. :v I'll do that now.</span>
<span class="comment-copy">@Augusta And then submit an answer to your question with your results so that future generations will learn :)</span>
<span class="comment-copy">@halex I'll do just that!</span>
<span class="comment-copy">Depends what you what to do with the list afterwards.  If you <code>pop()</code> each item then that will leave the list in-place with "empty" entries that can be reused.    In CPython it is more efficient to pop from the right.  Subsequent appends to the list will use the entries without a resize (if the same number of elements, or less).   Of course the performance effect will vary depending on the size of the list.  Deleting a slice on the left will mean a resize (realloc or equivalent).</span>
<span class="comment-copy">You are removing far fewer than half the elements, so no (internal) resize takes place.</span>
<span class="comment-copy">@MartijnPieters I thought that the lengths involved might have something to do with it right after I posted the first set of numbers, so I ran a few more tests with different parameters. It's about as you say.</span>
<span class="comment-copy">Timings would be improved if you could create the test lists up front; create N lists of equal size for N <code>timeit</code> tests and have each test truncate one of those objects. It'll illustrate better what the difference is between the two.</span>
<span class="comment-copy">You can use <code>from __main__ import ...</code> in the setup argument (the second argument to <code>timeit</code> to import names from the interactive interpreter, then use a string for the first argument to use those names. <code>from __main__ import slice_front as test, long_list_of_lists; testdata = iter(long_list_of_lists)</code> for example, and the first argument could be <code>test(next(testdata))</code> to pass in each element of <code>long_list_of_lists</code> to <code>slice_front</code> each iteration of the <code>timeit</code> run.</span>
<span class="comment-copy">you can do that; the whole list is still created up front though. The list comprehension is executed <i>first</i> before calling <code>iter()</code>.</span>
