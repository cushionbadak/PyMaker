<div class="post-text" itemprop="text">
<p>Can anyone amend <a href="http://code.activestate.com/recipes/500261/" rel="noreferrer">namedtuple</a> or provide an alternative class so that it works for mutable objects?</p>
<p>Primarily for readability, I would like something similar to namedtuple that does this:</p>
<pre><code>from Camelot import namedgroup

Point = namedgroup('Point', ['x', 'y'])
p = Point(0, 0)
p.x = 10

&gt;&gt;&gt; p
Point(x=10, y=0)

&gt;&gt;&gt; p.x *= 10
Point(x=100, y=0)
</code></pre>
<p>It must be possible to pickle the resulting object.  And per the characteristics of named tuple, the ordering of the output when represented must match the order of the parameter list when constructing the object.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a mutable alternative to <code>collections.namedtuple</code> - <a href="https://pypi.python.org/pypi/recordclass" rel="noreferrer">recordclass</a>.</p>
<p>It has the same API and memory footprint as <code>namedtuple</code> and it supports assignments (It should be faster as well). For example:</p>
<pre><code>from recordclass import recordclass

Point = recordclass('Point', 'x y')

&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p
Point(x=1, y=2)
&gt;&gt;&gt; print(p.x, p.y)
1 2
&gt;&gt;&gt; p.x += 2; p.y += 3; print(p)
Point(x=3, y=5)
</code></pre>
<p>For python 3.6 and higher <code>recordclass</code> (since 0.5) support typehints:</p>
<pre><code>from recordclass import recordclass, RecordClass

class Point(RecordClass):
   x: int
   y: int

&gt;&gt;&gt; Point.__annotations__
{'x':int, 'y':int}
&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p
Point(x=1, y=2)
&gt;&gt;&gt; print(p.x, p.y)
1 2
&gt;&gt;&gt; p.x += 2; p.y += 3; print(p)
Point(x=3, y=5)
</code></pre>
<p>There is a more complete <a href="http://nbviewer.ipython.org/urls/bitbucket.org/intellimath/recordclass/raw/default/examples/what_is_recordclass.ipynb" rel="noreferrer">example</a> (it also includes performance comparisons).</p>
<p>Since 0.9 <code>recordclass</code> library provides another  variant -- <code>recordclass.structclass</code> factory function. It can produce classes, whose instances occupy less memory than <code>__slots__</code>-based instances. This is can be important for the instances with attribute values, which has not intended to have reference cycles. Here is an illustrative <a href="https://nbviewer.jupyter.org/urls/bitbucket.org/intellimath/recordclass/raw/a6ea188bb636004f3596919a0a13872653dc5bc4/examples/reducing_memory_usage.ipynb" rel="noreferrer">example</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems like the answer to this question is no.</p>
<p>Below is pretty close, but it's not technically mutable. This is creating a new <code>namedtuple()</code> instance with an updated x value:</p>
<pre><code>Point = namedtuple('Point', ['x', 'y'])
p = Point(0, 0)
p = p._replace(x=10) 
</code></pre>
<p>On the other hand, you can create a simple class using <code>__slots__</code> that should work well for frequently updating class instance attributes:</p>
<pre><code>class Point:
    __slots__ = ['x', 'y']
    def __init__(self, x, y):
        self.x = x
        self.y = y
</code></pre>
<p>To add to this answer, I think <code>__slots__</code> is good use here because it's memory efficient when you create lots of class instances. The only downside is that you can't create new class attributes.</p>
<p>Here's one relevant thread that illustrates the memory efficiency -  <a href="https://stackoverflow.com/questions/1336791/dictionary-vs-object-which-is-more-efficient-and-why">Dictionary vs Object - which is more efficient and why?</a> </p>
<p>The quoted content in the answer of this thread is a very succinct explanation why <code>__slots__</code> is more memory efficient - <a href="https://stackoverflow.com/questions/472000/python-slots">Python slots</a> </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>The latest <a href="https://pypi.python.org/pypi/namedlist/">namedlist</a> 1.7 passes all of your tests with both Python 2.7 and Python 3.5</strong> as of Jan 11, 2016. <strong>It is a pure python implementation</strong> whereas the <code>recordclass</code> is a C extension. Of course, it depends on your requirements whether a C extension is preferred or not.</p>
<p>Your tests (but also see the note below):</p>
<pre><code>from __future__ import print_function
import pickle
import sys
from namedlist import namedlist

Point = namedlist('Point', 'x y')
p = Point(x=1, y=2)

print('1. Mutation of field values')
p.x *= 10
p.y += 10
print('p: {}, {}\n'.format(p.x, p.y))

print('2. String')
print('p: {}\n'.format(p))

print('3. Representation')
print(repr(p), '\n')

print('4. Sizeof')
print('size of p:', sys.getsizeof(p), '\n')

print('5. Access by name of field')
print('p: {}, {}\n'.format(p.x, p.y))

print('6. Access by index')
print('p: {}, {}\n'.format(p[0], p[1]))

print('7. Iterative unpacking')
x, y = p
print('p: {}, {}\n'.format(x, y))

print('8. Iteration')
print('p: {}\n'.format([v for v in p]))

print('9. Ordered Dict')
print('p: {}\n'.format(p._asdict()))

print('10. Inplace replacement (update?)')
p._update(x=100, y=200)
print('p: {}\n'.format(p))

print('11. Pickle and Unpickle')
pickled = pickle.dumps(p)
unpickled = pickle.loads(pickled)
assert p == unpickled
print('Pickled successfully\n')

print('12. Fields\n')
print('p: {}\n'.format(p._fields))

print('13. Slots')
print('p: {}\n'.format(p.__slots__))
</code></pre>
<p>Output on Python 2.7</p>
<pre>
1. Mutation of field values  
p: 10, 12

2. String  
p: Point(x=10, y=12)

3. Representation  
Point(x=10, y=12) 

4. Sizeof  
size of p: 64 

5. Access by name of field  
p: 10, 12

6. Access by index  
p: 10, 12

7. Iterative unpacking  
p: 10, 12

8. Iteration  
p: [10, 12]

9. Ordered Dict  
p: OrderedDict([('x', 10), ('y', 12)])

10. Inplace replacement (update?)  
p: Point(x=100, y=200)

11. Pickle and Unpickle  
Pickled successfully

12. Fields  
p: ('x', 'y')

13. Slots  
p: ('x', 'y')
</pre>
<p>The only difference with Python 3.5 is that the <code>namedlist</code> has become smaller, the size is 56 (Python 2.7 reports 64).</p>
<p><strong>Note that I have changed your test 10 for in-place replacement.</strong> The <code>namedlist</code> has a <code>_replace()</code> method which does a shallow copy, and that  makes perfect sense to me because the <code>namedtuple</code> in the standard library behaves the same way. Changing the semantics of the <code>_replace()</code> method would be confusing. In my opinion the <code>_update()</code> method should be used for in-place updates. Or maybe I failed to understand the intent of your test 10?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer">types.SimpleNamespace</a> was introduced in Python 3.3 and supports the requested requirements.</p>
<pre><code>from types import SimpleNamespace
t = SimpleNamespace(foo='bar')
t.ham = 'spam'
print(t)
namespace(foo='bar', ham='spam')
print(t.foo)
'bar'
import pickle
with open('/tmp/pickle', 'wb') as f:
    pickle.dump(t, f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a very Pythonic alternative for this task, since Python-3.7, you can use 
<code>dataclasses</code> module that not only behaves like a mutable <code>NamedTuple</code> because they use normal class definitions they also support other classes features.</p>
<p>From PEP-0557:</p>
<blockquote>
<p>Although they use a very different mechanism, Data Classes can be thought of as "mutable namedtuples with defaults". Because Data Classes use normal class definition syntax, you are free to use inheritance, metaclasses, docstrings, user-defined methods, class factories, and other Python class features.</p>
<p>A class decorator is provided which inspects a class definition for variables with type annotations as defined in <a href="https://www.python.org/dev/peps/pep-0526" rel="noreferrer">PEP 526</a>, "Syntax for Variable Annotations". In this document, such variables are called fields. Using these fields, the decorator adds generated method definitions to the class to support instance initialization, a repr, comparison methods, and optionally other methods as described in the <a href="https://www.python.org/dev/peps/pep-0557/#specification" rel="noreferrer">Specification</a> section. Such a class is called a Data Class, but there's really nothing special about the class: the decorator adds generated methods to the class and returns the same class it was given.</p>
</blockquote>
<p>This feature is introduced in <a href="https://www.python.org/dev/peps/pep-0557/" rel="noreferrer">PEP-0557</a> that you can read about it in more details on provided documentation link.</p>
<p>Example:</p>
<pre><code>In [20]: from dataclasses import dataclass

In [21]: @dataclass
    ...: class InventoryItem:
    ...:     '''Class for keeping track of an item in inventory.'''
    ...:     name: str
    ...:     unit_price: float
    ...:     quantity_on_hand: int = 0
    ...: 
    ...:     def total_cost(self) -&gt; float:
    ...:         return self.unit_price * self.quantity_on_hand
    ...:    
</code></pre>
<p>Demo:</p>
<pre><code>In [23]: II = InventoryItem('bisc', 2000)

In [24]: II
Out[24]: InventoryItem(name='bisc', unit_price=2000, quantity_on_hand=0)

In [25]: II.name = 'choco'

In [26]: II.name
Out[26]: 'choco'

In [27]: 

In [27]: II.unit_price *= 3

In [28]: II.unit_price
Out[28]: 6000

In [29]: II
Out[29]: InventoryItem(name='choco', unit_price=6000, quantity_on_hand=0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following is a good solution for Python 3: A minimal class using <code>__slots__</code> and <code>Sequence</code> abstract base class; does not do fancy error detection or such, but it works, and behaves mostly like a mutable tuple (except for typecheck).</p>
<pre><code>from collections import Sequence

class NamedMutableSequence(Sequence):
    __slots__ = ()

    def __init__(self, *a, **kw):
        slots = self.__slots__
        for k in slots:
            setattr(self, k, kw.get(k))

        if a:
            for k, v in zip(slots, a):
                setattr(self, k, v)

    def __str__(self):
        clsname = self.__class__.__name__
        values = ', '.join('%s=%r' % (k, getattr(self, k))
                           for k in self.__slots__)
        return '%s(%s)' % (clsname, values)

    __repr__ = __str__

    def __getitem__(self, item):
        return getattr(self, self.__slots__[item])

    def __setitem__(self, item, value):
        return setattr(self, self.__slots__[item], value)

    def __len__(self):
        return len(self.__slots__)

class Point(NamedMutableSequence):
    __slots__ = ('x', 'y')
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; p = Point(0, 0)
&gt;&gt;&gt; p.x = 10
&gt;&gt;&gt; p
Point(x=10, y=0)
&gt;&gt;&gt; p.x *= 10
&gt;&gt;&gt; p
Point(x=100, y=0)
</code></pre>
<p>If you want, you can have a method to create the class too (though using an explicit class is more transparent):</p>
<pre><code>def namedgroup(name, members):
    if isinstance(members, str):
        members = members.split()
    members = tuple(members)
    return type(name, (NamedMutableSequence,), {'__slots__': members})
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; Point = namedgroup('Point', ['x', 'y'])
&gt;&gt;&gt; Point(6, 42)
Point(x=6, y=42)
</code></pre>
<hr/>
<p>In Python 2 you need to adjust it slightly - if you <a href="https://stackoverflow.com/questions/29444130/why-is-slots-behaving-differently-in-python-2-and-3-when-inheriting-from-an/29444131#29444131">inherit from <code>Sequence</code>, the class will have a <code>__dict__</code></a> and the <code>__slots__</code> will stop from working.</p>
<p>The solution in Python 2 is to not inherit from <code>Sequence</code>, but <code>object</code>. If <code>isinstance(Point, Sequence) == True</code> is desired, you need to register the  <code>NamedMutableSequence</code> as a base class to <code>Sequence</code>:</p>
<pre><code>Sequence.register(NamedMutableSequence)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's implement this with dynamic type creation:</p>
<pre><code>import copy
def namedgroup(typename, fieldnames):

    def init(self, **kwargs): 
        attrs = {k: None for k in self._attrs_}
        for k in kwargs:
            if k in self._attrs_:
                attrs[k] = kwargs[k]
            else:
                raise AttributeError('Invalid Field')
        self.__dict__.update(attrs)

    def getattribute(self, attr):
        if attr.startswith("_") or attr in self._attrs_:
            return object.__getattribute__(self, attr)
        else:
            raise AttributeError('Invalid Field')

    def setattr(self, attr, value):
        if attr in self._attrs_:
            object.__setattr__(self, attr, value)
        else:
            raise AttributeError('Invalid Field')

    def rep(self):
         d = ["{}={}".format(v,self.__dict__[v]) for v in self._attrs_]
         return self._typename_ + '(' + ', '.join(d) + ')'

    def iterate(self):
        for x in self._attrs_:
            yield self.__dict__[x]
        raise StopIteration()

    def setitem(self, *args, **kwargs):
        return self.__dict__.__setitem__(*args, **kwargs)

    def getitem(self, *args, **kwargs):
        return self.__dict__.__getitem__(*args, **kwargs)

    attrs = {"__init__": init,
                "__setattr__": setattr,
                "__getattribute__": getattribute,
                "_attrs_": copy.deepcopy(fieldnames),
                "_typename_": str(typename),
                "__str__": rep,
                "__repr__": rep,
                "__len__": lambda self: len(fieldnames),
                "__iter__": iterate,
                "__setitem__": setitem,
                "__getitem__": getitem,
                }

    return type(typename, (object,), attrs)
</code></pre>
<p>This checks the attributes to see if they are valid before allowing the operation to continue.</p>
<p>So is this pickleable?  Yes if (and only if) you do the following:</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; Point = namedgroup("Point", ["x", "y"])
&gt;&gt;&gt; p = Point(x=100, y=200)
&gt;&gt;&gt; p2 = pickle.loads(pickle.dumps(p))
&gt;&gt;&gt; p2.x
100
&gt;&gt;&gt; p2.y
200
&gt;&gt;&gt; id(p) != id(p2)
True
</code></pre>
<p>The definition has to be in your namespace, and must exist long enough for pickle to find it.  So if you define this to be in your package, it should work.</p>
<pre><code>Point = namedgroup("Point", ["x", "y"])
</code></pre>
<p>Pickle will fail if you do the following, or make the definition temporary (goes out of scope when the function ends, say):</p>
<pre><code>some_point = namedgroup("Point", ["x", "y"])
</code></pre>
<p>And yes, it does preserve the order of the fields listed in the type creation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Tuples are by definition immutable.</p>
<p>You can however make a dictionary subclass where you can access the attributes with dot-notation;</p>
<pre><code>In [1]: %cpaste
Pasting code; enter '--' alone on the line to stop or use Ctrl-D.
:class AttrDict(dict):
:
:    def __getattr__(self, name):
:        return self[name]
:
:    def __setattr__(self, name, value):
:        self[name] = value
:--

In [2]: test = AttrDict()

In [3]: test.a = 1

In [4]: test.b = True

In [5]: test
Out[5]: {'a': 1, 'b': True}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want similar behavior as namedtuples but mutable try <a href="https://bitbucket.org/ericvsmith/namedlist" rel="nofollow">namedlist</a></p>
<p>Note that in order to be mutable it <em>cannot</em> be a tuple.</p>
</div>
<div class="post-text" itemprop="text">
<p>Provided performance is of little importance, one could use a silly hack like:</p>
<pre><code>from collection import namedtuple

Point = namedtuple('Point', 'x y z')
mutable_z = Point(1,2,[3])
</code></pre>
</div>
<span class="comment-copy">Could you use a list?</span>
<span class="comment-copy">You could make a very simple Point class that did this.</span>
<span class="comment-copy">See also: <a href="http://stackoverflow.com/q/5131044/">stackoverflow.com/q/5131044</a>. Is there a reason you can't just use a dictionary?</span>
<span class="comment-copy">@senshin Thanks for the link.  I prefer not to use a dictionary for the reason pointed out in it.  That response also linked to <a href="http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/?in=user-97991" rel="nofollow noreferrer">code.activestate.com/recipes/…</a>, which is pretty close to what I'm after.</span>
<span class="comment-copy">A mutable namedtuple is called a class.</span>
<span class="comment-copy">Like it. 'This library actually is a “proof of concept” for the problem of “mutable” alternative of named tuple.`</span>
<span class="comment-copy"><code>recordclass</code> is slower, takes more memory, and requires C-extensions as <a href="https://gist.github.com/grantjenks/a06da0db18826be1176c31c95a6ee572" rel="nofollow noreferrer">compared</a> with Antti Haapala's recipe and <code>namedlist</code>.</span>
<span class="comment-copy"><code>recordclass</code> is a mutable version of <code>collection.namedtuple</code> that inherits it's api, memory footprint, but support assignments.  <code>namedlist</code> is actually instance of python class with slots. It's more usefull if you don't need fast access to it's fields by index.</span>
<span class="comment-copy">Attribute access for <code>recordclass</code> instance (python 3.5.2) is about 2-3% slower than for <code>namedlist</code></span>
<span class="comment-copy">When using <code>namedtuple</code> and simple class creation <code>Point = namedtuple('Point', 'x y')</code>, Jedi can autocomplete attributes, while this is not the case for <code>recordclass</code>. If I use the longer creation code (based on <code>RecordClass</code>), then Jedi understands the <code>Point</code> class, but not its constructor or attributes... Is there a way to get <code>recordclass</code> to work nicely with Jedi?</span>
<span class="comment-copy">Close, but clunky.  Let's say I wanted to do a += assignment, I would then need to do: p._replace(x = p.x + 10) vs. p.x += 10</span>
<span class="comment-copy">yeah, it's not really changing the existing tuple, it's creating a new instance</span>
<span class="comment-copy">There is important nuance. The <code>namedlist</code> store values in the list instance. The thing is that <code>cpython</code>'s <code>list</code> is actually a dynamic array. By design, it allocates more memory than necessary in order to make mutation of the list cheaper.</span>
<span class="comment-copy">@intellimath namedlist is a bit of misnomer. It does not actually inherit from <code>list</code> and by default uses <code>__slots__</code> optimization. When I measured, memory use was less than <code>recordclass</code>: 96 bytes vs 104 bytes for six fields on Python 2.7</span>
<span class="comment-copy">@GrantJ Yes. <code>recorclass</code> uses more memory because it's a <code>tuple</code>-like object with variable memory size.</span>
<span class="comment-copy">Anonymous downvotes are not helping anybody. What is wrong with the answer? Why the downvote?</span>
<span class="comment-copy">I love the safety against typos that it provides with respect to <code>types.SimpleNamespace</code>. Unfortunately, pylint does not like it :-(</span>
<span class="comment-copy">I've been looking for something like this for years. Great replacement for a dotted dict library like dotmap</span>
<span class="comment-copy">Wow, for me it was very very very helpful, thanks!</span>
<span class="comment-copy">This needs more upvotes. It’s exactly what the OP was looking for, it’s in the standard library, and it could not be simpler to use. Thanks!</span>
<span class="comment-copy">-1 The OP made it very clear with his tests what he needs and <code>SimpleNamespace</code> fails tests 6-10 (access by index, iterative unpacking, iteration, ordered dict, in-place replacement) and 12, 13 (fields, slots). Note that the documentation (that you linked in the answer) specifically says <i>"<code>SimpleNamespace</code> may be useful as a replacement for <code>class NS: pass</code>. However, for a structured record type use <code>namedtuple()</code> instead."</i></span>
<span class="comment-copy">It was made very clear with the tests in the OP what is needed and <code>dataclass</code> fails tests 6-10 (access by index, iterative unpacking, iteration, ordered dict, in-place replacement) and 12, 13 (fields, slots) in Python 3.7.1.</span>
<span class="comment-copy">If you add an <code>__iter__</code> method with <code>for k in self._attrs_: yield getattr(self, k)</code>, that will support unpacking like a tuple.</span>
<span class="comment-copy">It's also pretty easy to add <code>__len__</code>, <code>__getitem__</code>,  and <code>__setiem__</code> methods to support getting valus by index, like <code>p[0]</code>. With these last bits, this seems like the most complete and correct answer (to me anyway).</span>
<span class="comment-copy"><code>__len__</code> and <code>__iter__</code> are good.  <code>__getitem__</code> and <code>__setitem__</code> can really be mapped to <code>self.__dict__.__setitem__</code> and <code>self.__dict__.__getitem__</code></span>
<span class="comment-copy">Thanks for the link.  This looks like the closest so far, but I need to evaluate it in more detail.  Btw, I'm totally aware tuples are immutable, which is why I'm looking for a solution <i>like</i> namedtuple.</span>
<span class="comment-copy">This answer isn't very well explained. It looks confusing if you don't understand the mutable nature of lists. --- In this example... to re-assign <code>z</code>, you have to call <code>mutable_z.z.pop(0)</code> then <code>mutable_z.z.append(new_value)</code>. If you get this wrong, you'll end up with more than 1 element and your program will behave unexpectedly.</span>
<span class="comment-copy">@byxor that, or you could just: <code>mutable_z.z[0] = newValue</code>. It is indeed a hack, as stated.</span>
<span class="comment-copy">Oh yeah, I'm surprised I missed the more obvious way to re-assign it.</span>
