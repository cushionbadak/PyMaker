<div class="post-text" itemprop="text">
<p>I'm kinda stumped here. Here's the code.</p>
<pre><code>def getIP(self,commandline):
    """
    A thread that sets an IP using the method specified in commandline
    """

    getter_process = subprocess.Popen(commandline,stdout=subprocess.PIPE)
    myip = getter_process.communicate()[0].decode(encoding="ascii", errors="ignore").replace("\n","")

    print("getIP with ", commandline, " result:" , myip)

    if isIP(myip):
        self.lock1.acquire()
        try:
            GLib.idle_add(self.setIndicatingMenus,myip,self.hIndicator)
        finally:
            self.lock1.release()
            print("debug2")

    print("getIP end")

    return False


def askIP(self,ind):
    """
    Start subprocesses asking for external IP in separate threads
    """
    print("askIP start")
    #list of commandlines that are supposed to return IP as a result
    IPgettingMethods = [
    ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
    ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],

    # and other command line commands I may want in separate threads
    ]

    for i in IPgettingMethods:
        th = Thread(target=self.getIP, args=(i,))
        th.start()


    return False
</code></pre>
<p>Basically, whenever <code>askIP</code> is called, it launches several <code>getIP</code> threads that perform subprocesses specified in <code>IPgettingMethods</code>. These subprocesses may return the <code>myip</code> value at different speeds. Also, they may not return a valid value (in that case <code>isIP(myip)</code> will return <code>False</code>). But one (or more than one) of the threads will eventually reach <code>GLib.idle_add(self.setIndicatingMenus,myip,self.hIndicator)</code>.</p>
<p>My question is: how can I make <code>GLib.idle_add(self.setIndicatingMenus,myip,self.hIndicator)</code> run only ONCE per that calling of <code>askIP</code>? In other words, how can I make only the thread that reaches it first to call it, and make all others ignore it? </p>
<p>Maybe I can kill other threads from the "winner" thread after it calls <code>GLib.idle_add</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>This sounds like it would be well suited to using <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow"><code>concurrent.futures</code></a> -- a way of submitting and controlling multiple jobs. Here you have many helper threads that do the leg work of calling the subprocess and one master thread that collects the results and decides what to do with them. For instance:</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed
from time import sleep
from random import random

job_count = 10

def is_even(x):
    return x % 2 == 0

def do_something(i):
    "All odd jobs complete before even jobs"
    if not is_even(i):
        return i
    sleep(0.1 + random())
    return i

with ThreadPoolExecutor(max_workers=job_count) as executor:
    successful_result = None
    futures = [executor.submit(do_something, i) for i in range(job_count)]

    for future in as_completed(futures):
        result = future.result()
        if is_even(result):
            successful_result = result
            break

print("the first successful result was:", successful_result)
</code></pre>
<p>As applied to your problem:</p>
<pre><code>def getIP(self, commandline):
    getter_process = subprocess.Popen(commandline, stdout=subprocess.PIPE)
    myip = getter_process.communicate()[0].decode(encoding="ascii", errors="ignore").replace("\n","")
    return myip if isIP(myIP) else None

def askIP(self,ind):
    """
    Start subprocesses asking for external IP in separate threads
    """

    print("askIP start")
    #list of commandlines that are supposed to return IP as a result
    IPgettingMethods = [
        ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
        ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
        # and other command line commands I may want in separate threads
    ]

    def get_ip_controller():
        with ThreadPoolExecutor(len(IPgettingMethods)) as executor:
            futures = [executor.submit(self.getIP, i) for i in IPgettingMethods]
            for future in as_completed(futures):
                ip = future.result()
                if ip:
                    GLib.idle_add(self.setIndicatingMenus, ip, self.hIndicator)
                    break

    Thread(target=get_ip_controller).start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use a global variable as a guard: the first thread to reach that point of execution sets the variable, and other threads, when seeing the variable is already set, skip that piece of code:</p>
<pre><code>def getIP(self,commandline):
    """
    A thread that sets an IP using the method specified in commandline
    """

    global guard

    getter_process = subprocess.Popen(commandline,stdout=subprocess.PIPE)
    myip = getter_process.communicate()[0].decode(encoding="ascii", errors="ignore").replace("\n","")

    print("getIP with ", commandline, " result:" , myip)

    if isIP(myip) and not guard:
        self.lock1.acquire()
        try:
            GLib.idle_add(self.setIndicatingMenus,myip,self.hIndicator)
            guard = True
        finally:
            self.lock1.release()
            print("debug2")

    print("getIP end")

    return False

def askIP(self,ind):
    """
    Start subprocesses asking for external IP in separate threads
    """

    global guard

    guard = False

    print("askIP start")
    #list of commandlines that are supposed to return IP as a result
    IPgettingMethods = [
    ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
    ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],

    # and other command line commands I may want in separate threads
    ]

    for i in IPgettingMethods:
        th = Thread(target=self.getIP, args=(i,))
        th.start()


    return False
</code></pre>
<p>"Manually" killing a thread is almost never a good idea. Let them die when they reach the end of the function, preventing them from doing work by setting a guard.</p>
</div>
<span class="comment-copy">It may introduce a race, but it may also work as you intend.  Try switching your Lock to a <code>threading.Event</code> and if the <code>Event</code> is not set, set it and do the <code>idle_add</code> call.  If it is set, return False.</span>
<span class="comment-copy">You could also do this with a Queue with a single item.  Then you check <code>Queue.empty()</code> and if not, do a <code>Queue.get(false)</code> so you don't block in case another thread beat you in the race.</span>
<span class="comment-copy">@sberry good suggestion on <code>Queue</code>, was almost about to implement it with unique tokens.</span>
<span class="comment-copy">Seems to work well so far! Thanks! 8)</span>
