<div class="post-text" itemprop="text">
<p>I'm trying to get a handle on python Parallelism.  This is the code i'm using</p>
<pre><code>import time
from concurrent.futures import ProcessPoolExecutor

def listmaker():
    for i in xrange(10000000):
        pass

#Without duo core

start = time.time()
listmaker()
end = time.time()
nocore = "Total time, no core, %.3f" % (end- start)


#with duo core
start = time.time()
pool = ProcessPoolExecutor(max_workers=2) #I have two cores
results = list(pool.map(listmaker()))
end = time.time()
core = "Total time core, %.3f" % (end- start)

print nocore
print core
</code></pre>
<p>I was under the assumption that because i'm using two cores my the speed be be close to double. However when i run this code most of the time the <code>nocore</code> output is faster than the <code>core</code> output. This is true even if I change</p>
<pre><code>def listmaker():
        for i in xrange(10000000):
            pass
</code></pre>
<p>to</p>
<pre><code>def listmaker():
        for i in xrange(10000000):
            print i
</code></pre>
<p>In fact in some runs the <code>no core</code> run is faster.  Could someone shed some light on the issue?  I'm is my setup correct? I'm I doing something wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're using <code>pool.map()</code> incorrectly. Take a look at the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map" rel="nofollow">pool.map</a> documentation. It expects an iterable argument, and it will pass each of the items from the iterable to the pool individually. Since your function only returns <code>None</code>, there is nothing for it to do. However, you're still incurring the overhead of spawning extra processes, which takes time.</p>
<p>Your usage of <code>pool.map</code> should look like this:</p>
<pre><code>results = pool.map(function_name, some_iterable)
</code></pre>
<p>Notice a couple of things:    </p>
<ul>
<li>Since you're using the print statement rather than a function, I'm assuming you're using some Python2 variant. In Python2, <code>pool.map</code> returns a list anyway. No need to convert it to a list again.</li>
<li>The first argument should be the function name <strong>without parentheses</strong>. This identifies the function that the pool workers should execute. When you include the parentheses, the function is called right there, instead of in the pool.   </li>
<li><code>pool.map</code> is intended to call a function on every item in an iterable, so your test cases needs to create some iterable for it to consume, instead of a function that takes no arguments like your current example.</li>
</ul>
<p>Try to run your trial again with some actual input to the function, and retrieve the output. Here's an example:</p>
<pre><code>import time
from concurrent.futures import ProcessPoolExecutor

def read_a_file(file_name):
    with open(file_name) as fi:
        text = fi.read()
    return text

file_list = ['t1.txt', 't2.txt', 't3.txt']

#Without duo core
start = time.time()
single_process_text_list = []
for file_name in file_list:
    single_process_text_list.append(read_a_file(file_name))
end = time.time()
nocore = "Total time, no core, %.3f" % (end- start)


#with duo core
start = time.time()
pool = ProcessPoolExecutor(max_workers=2) #I have two cores
multiprocess_text_list = pool.map(read_a_file, file_list)
end = time.time()
core = "Total time core, %.3f" % (end- start)

print(nocore)
print(core)
</code></pre>
<p>Results:</p>
<blockquote>
<p>Total time, no core, 0.047<br/>
  Total time core, 0.009</p>
</blockquote>
<p>The text files are 150,000 lines of gibberish each. Notice how much work had to be done before the parallel processing was worth it. When I ran the trial with 10,000 lines in each file, the single process approach was still faster because it didn't have the overhead of spawning extra processes. But with that much work to do, the extra processes become worth the effort.</p>
<p>And by the way, this functionality is available with <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.pool.multiprocessing.Pool" rel="nofollow">multiprocessing pools</a> in Python2, so you can avoid importing anything from futures if you want to.</p>
</div>
<span class="comment-copy"><code>pool.map(listmaker())</code> calls the <code>listmaker</code> function right away (in the main process), and passes the return value (<code>None</code>) to <code>pool.map</code>. You need to pass the function <code>listmaker</code> (without parentheses) and a iterable of arguments to <code>pool.map</code>.</span>
<span class="comment-copy">That WORKED!, I didn't realize I had called the function like that, if you make it an answer ill mark it.</span>
<span class="comment-copy">Thanks for the information.</span>
<span class="comment-copy">@hrand I've posted some example code that you may find useful.</span>
<span class="comment-copy">This is great! Thanks</span>
