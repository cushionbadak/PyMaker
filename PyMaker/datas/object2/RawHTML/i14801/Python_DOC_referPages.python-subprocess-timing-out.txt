<div class="post-text" itemprop="text">
<p>I have a script that runs another command, waits for it to finish, logs the stdout and stderr and based the return code does other stuff. Here is the code:</p>
<pre><code>p = subprocess.Popen(command, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
o, e = p.communicate()
if p.returncode:
    # report error

# do other stuff
</code></pre>
<p>The problem I'm having is that if <code>command</code> takes a long time to run none of the other actions get done. The possible errors won't get reported and the other stuff that needs to happen if no errors doesn't get done. It essentially doesn't go past <code>p.communicate()</code> if it takes too long. Some times this command can takes hours (or even longer) to run and some times it can take as little as 5 seconds.</p>
<p>Am I missing something or doing something wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>As per the documentation located <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow">here</a>, it's safe to say that you're code is waiting for the subprocess to finish.</p>
<p>If you need to go do 'other things' while you wait you could create a loop like:</p>
<pre><code>while p.poll():
    # 'other things'
    time.sleep(0.2)
</code></pre>
<p>Pick a sleep time that's reasonable for how often you want python to wake up and check the subprocess as well as doing its 'other things'.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>Popen.communicate</code> waits for the process to finish, before anything is returned. Thus it is not ideal for any long running command; and even less so if the subprocess can hang waiting for input, say prompting for a password.</p>
<hr/>
<p>The <code>stderr=subprocess.PIPE, stdout=subprocess.PIPE</code> are needed <em>only</em> if you want to capture the output of the command into a variable. If you are OK with the output going to your terminal, then you can remove these both; and even use <code>subprocess.call</code> instead of <code>Popen</code>. Also, if you do not provide <em>input</em> to your subprocess, then do not use <code>stdin=subprocess.PIPE</code> at all, but direct that from the null device instead (in Python 3.3+ you can use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.DEVNULL" rel="nofollow"><code>stdin=subprocess.DEVNULL</code></a>; in Python &lt;3.3 use <code>stdin=open(os.devnull, 'rb')</code></p>
<hr/>
<p>If you need the contents too, then instead of calling <code>p.communicate()</code>, you can read <code>p.stdout</code> and <code>p.stderr</code> yourself in chunks and output to the terminal, but it is a bit complicated, as it is easy to deadlock the program - the dummy approach would try to read from the subprocess' <code>stdout</code> while the subprocess would want to write to <code>stderr</code>. For this case there are 2 remedies:</p>
<ul>
<li><p>you could use <a href="https://docs.python.org/3/library/select.html" rel="nofollow"><code>select.select</code></a> to poll both <code>stdout</code> and <code>stderr</code> to see whichever becomes ready first and read from it then</p></li>
<li><p>or, if you do not care for <code>stdout</code> and <code>stderr</code> being combined into one,
you can use <a href="https://docs.python.org/2/library/subprocess.html#subprocess.STDOUT" rel="nofollow"><code>STDOUT</code></a> to redirect the stderr stream into the stdout stream: <code>stdout=subprocess.PIPE, stderr=subprocess.STDOUT</code>; now all the output comes to <code>p.stdout</code> that you can read easily in loop and output the chunks, without worrying about deadlocks:</p></li>
</ul>
<hr/>
<p>If the stdout, stderr are going to be <em>huge</em>, you can also spool them to a file right there in <code>Popen</code>; say,</p>
<pre><code>stdout = open('stdout.txt', 'w+b')
stderr = open('stderr.txt', 'w+b')

p = subprocess.Popen(..., stdout=stdout, stderr=stderr)
while p.poll() is None:
    # reading at the end of the file will return an empty string
    err = stderr.read()  
    print(err)
    out = stdout.read()
    print(out)
    # if we met the end of the file, then we can sleep a bit
    # here to avoid spending excess CPU cycles just to poll;
    # another option would be to use `select`
    if not err and not out:  # no input, sleep a bit
        time.sleep(0.01)
</code></pre>
</div>
<span class="comment-copy">communicate is going to block until the command returns,  if the output is needed elsewhere in your code then you will need to wit.</span>
<span class="comment-copy">Also if you want the stdout and stderr logged you can redirect to a file. You can also use <code>check_call</code> with a try/except which will raise a  calledProcessError for a non zero exit status or use call if you want your code to continue redirecting the stderr to a file</span>
<span class="comment-copy">what is your Python version? Does <code>command</code> generate large output (100K or more)? How do you know that the script hangs on <code>.communicate()</code> even long after <code>command</code> has finished? Do you need to handle the output while the command is still running?</span>
<span class="comment-copy">I actually do want the stdout and stderr. Your comment has me thinking though. What would be the behavior if the stdout and stderr being captured is extremely large? Since the script is not behaving as expected with long runs, the stdout can be significant. Would the python script fail while the subprocess continues running?</span>
