<div class="post-text" itemprop="text">
<pre><code>    &gt;&gt;&gt; last_phonemes(['AE1', 'B', 'S', 'IH0', 'N', 'TH'])
    ['IH0', 'N', 'TH']
    &gt;&gt;&gt; last_phonemes(['IH0', 'N'])
    ['IH0', 'N']
    &gt;&gt;&gt; last_phonemes(['B', 'S'])
    []
</code></pre>
<p>In this program I am looking for the last item that ends with 0,1 or 2 and return that item along with everything that comes after it </p>
</div>
<div class="post-text" itemprop="text">
<p>This searches from the end of the list, returning the appropriate slice the first time it hits a match (and returning <code>[]</code> if it doesn't):</p>
<pre><code>def last_phonemes(seq):
    for i, s in enumerate(reversed(seq), 1):
        if s.endswith(("0", "1", "2")):
            return seq[-i:]
    return []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow">dropwhile</a> function from the itertools package. For example:</p>
<pre><code>&gt;&gt;&gt; from itertools import dropwhile
&gt;&gt;&gt; list(dropwhile(lambda x: x != 'IH0', ['AE1', 'B', 'S', 'IH0', 'N', 'TH']))
['IH0', 'N', 'TH']
&gt;&gt;&gt; list(dropwhile(lambda x: x != 'IH0', ['IH0', 'N']))
['IH0', 'N']
&gt;&gt;&gt; list(dropwhile(lambda x: x != 'IH0', ['B', 'S']))
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Loop over the list backwards, and return a sliced list:</p>
<pre><code>def last_phonemes(lst):
    for i in xrange(len(lst)-1, -1, -1):
        if lst[i][-1] in "012":
            return lst[i:]
    return []
</code></pre>
<p>Replace <code>xrange</code> with <code>range</code> if you're using Python 3.</p>
</div>
<span class="comment-copy">Wow why didn't I think of returning the negative slice instead of trying to wrap with <code>len(seq)</code>? Good answer</span>
<span class="comment-copy">Actually, it needs to be the last one that ends in "012". That'll teach me to read the question properly...</span>
<span class="comment-copy">@srgerg which makes the function more like <code>[el for idx, el in dropwhile(lambda idx, el: any(ch.endswith(('0','1','2')) for ch in seq[idx+1:]), enumerate(seq))]</code> Yuck.</span>
<span class="comment-copy">@AdamSmith Yuck indeed! Zero's answer is much better and even more pythonic.</span>
<span class="comment-copy">This would work better if you did <code>for i, el in enumerate(lst): if el[-2] in '012': return lst[i:]</code>, but even better if you could enumerate from the back!</span>
<span class="comment-copy">You use xrange(len(lst) -1, -1, -1) to iterate backwards. Then either break or return when you find the first instance. edit: fixed args to xrange</span>
<span class="comment-copy">@Matt: Good point.</span>
