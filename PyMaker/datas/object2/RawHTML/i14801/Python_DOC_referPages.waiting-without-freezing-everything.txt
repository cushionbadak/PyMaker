<div class="post-text" itemprop="text">
<p>I am attempting to work on a victory statement. I want screen the flash Blue and Yellow rapidly but not too rapidly when the victory requirements are met which is for now left clicking. The issue is that I cannot find a way to achieve this without making the game change based on the computer running the program. I tried to make it rerun the color several times so that the color will last longer before changing, but on a faster or a slower system, this effect will be different most likely.</p>
<pre><code>if V == 2:
    if Blue == 1:
        D.fill(BLUE)
        Blue = 2
    elif Blue == 2:
        D.fill(BLUE)
        Blue = 3
    elif Blue == 3:
        D.fill(BLUE)
        Blue = 4
    elif Blue == 4:
        D.fill(BLUE)
        Blue = 5
    elif Blue == 5:
        D.fill(YELLOW)
        Blue = 6
    elif Blue == 6:
        D.fill(YELLOW)
        Blue = 7
    elif Blue == 7:
        D.fill(YELLOW)
        Blue = 8
    elif Blue == 8:
        D.fill(YELLOW)
        Blue = 1
</code></pre>
<p>This just reruns the color four times before changing which is not ideal. I have tried to use a wait function but this freezes the entire program during this time which makes all other things feel really unresponsive obviously. Is there a way to make it flash without this restating idea and without freezing the whole program for however long? Thanks.</p>
<p>Upon the use of one of the answers given by you guys, I have managed to get it to work sort of. The issue is that now, the flashing ceases whenever I use any form of input such as for instance an arrow key. Ideally, the flashing would not cease until V = 0 which would be when the game reset.</p>
<pre><code>if V == 2:
    if event.type == event_500ms:
        if Blue == 1:
            D.fill(BLUE)
            Blue = 2
        elif Blue == 2:
            D.fill(YELLOW)
            Blue = 1
</code></pre>
<p>This is the new version of that code shown prior. In case it matters, here is the entire loop.</p>
<pre><code>    if event.type == pygame.QUIT:
        pygame.quit()
        sys.exit()

    elif event.type == pygame.KEYDOWN:
        if event.key == pygame.K_LEFT:
            x_speed =- 3
            x2_speed = 3
            y3_speed =- 3
            y4_speed = 3
        elif event.key == pygame.K_RIGHT:
            x_speed = 3
            x2_speed =- 3
            y3_speed = 3
            y4_speed =- 3
        elif event.key == pygame.K_UP:
            y_speed =- 3
            y2_speed = 3
            x3_speed =- 3
            x4_speed = 3
        elif event.key == pygame.K_DOWN:
            y_speed = 3
            y2_speed =- 3
            x3_speed = 3
            x4_speed =- 3
        elif event.key == pygame.K_TAB:
            GMT += 1
            CIP = 2
            if GMT % 2:
                GM = 2
            else:
                GM = 1

    if event.type == pygame.KEYUP:
        if event.key == pygame.K_LEFT:
            x_speed=0
            x2_speed=0
            y3_speed=0
            y4_speed=0
        elif event.key == pygame.K_RIGHT:
            x_speed=0
            x2_speed=0
            y3_speed=0
            y4_speed=0
        elif event.key == pygame.K_UP:
            y_speed=0
            y2_speed=0
            x3_speed=0
            x4_speed=0
        elif event.key == pygame.K_DOWN:
            y_speed=0
            y2_speed=0
            x3_speed=0
            x4_speed=0

    elif event.type == MOUSEBUTTONDOWN:
        x_coord = 300
        y_coord = 300
        x2_coord = 300
        y2_coord = 300
        x3_coord = 300
        y3_coord = 300
        x4_coord = 300
        y4_coord = 300
        X5_coord = 30
        Y5_coord = 10
        direction = 'right'
        D.fill(BLACK)
        G = random.randrange(1, 10)
        CO = 2
        V = 2

    elif event.type == MOUSEBUTTONUP:
        X5_coord = 30
        Y5_coord = 10
        direction = 'right'

    if direction == 'right':
        X5_coord += 10
        if X5_coord == 670:
            direction = 'down'
    elif direction == 'down':
        Y5_coord += 10
        if Y5_coord == 460:
            direction = 'left'
    elif direction == 'left':
        X5_coord -= 10
        if X5_coord == 10:
            direction = 'up'
    elif direction == 'up':
        Y5_coord -= 10
        if Y5_coord == 10:
            direction = 'right'





x_coord = x_coord + x_speed
y_coord = y_coord + y_speed

x2_coord = x2_coord + x2_speed
y2_coord = y2_coord + y2_speed

x3_coord = x3_coord + x3_speed
y3_coord = y3_coord + y3_speed

x4_coord = x4_coord + x4_speed
y4_coord = y4_coord + y4_speed

if GM == 2 and CIP == 2:
    D.fill(BLACK)
    CIP = 1

if GM == 1:
    D.fill(MEXON)

if G &gt;= 6:
    B(L6, (80, 150))

if G == 1 and CO == 2:
    x_coord = 366
    y_coord = 201

    x2_coord = 234
    y2_coord = 399

    x3_coord = 201
    y3_coord = 366

    x4_coord = 399
    y4_coord = 234

    CO = 1

elif G == 2 and CO == 2:
    x_coord = 240
    y_coord = 312

    x2_coord = 360
    y2_coord = 288

    x3_coord = 312
    y3_coord = 240

    x4_coord = 288
    y4_coord = 360

    CO = 1

elif G == 3 and CO == 2:
    x_coord = 405
    y_coord = 228

    x2_coord = 195
    y2_coord = 372

    x3_coord = 228
    y3_coord = 405

    x4_coord = 372
    y4_coord = 195

    CO = 1

elif G == 4 and CO == 2:
    x_coord = 179
    y_coord = 309

    x2_coord = 421
    y2_coord = 291

    x3_coord = 309
    y3_coord = 179

    x4_coord = 291
    y4_coord = 421

    CO = 1

elif G == 5 and CO == 2:
    x_coord = 315
    y_coord = 450

    x2_coord = 285
    y2_coord = 150

    x3_coord = 450
    y3_coord = 315

    x4_coord = 150
    y4_coord = 285

    CO = 1

elif G == 6 and CO == 2:
    x_coord = 180
    y_coord = 390

    x2_coord = 420
    y2_coord = 210

    x3_coord = 390
    y3_coord = 180

    x4_coord = 210
    y4_coord = 420

    CO = 1

elif G == 7 and CO == 2:
    x_coord = 267
    y_coord = 204

    x2_coord = 333
    y2_coord = 396

    x3_coord = 204
    y3_coord = 267

    x4_coord = 396
    y4_coord = 333

    CO = 1

elif G == 8 and CO == 2:
    x_coord = 363
    y_coord = 390

    x2_coord = 237
    y2_coord = 210

    x3_coord = 390
    y3_coord = 363

    x4_coord = 210
    y4_coord = 237

    CO = 1

elif G == 9 and CO == 2:
    x_coord = 234
    y_coord = 273

    x2_coord = 366
    y2_coord = 327

    x3_coord = 273
    y3_coord = 234

    x4_coord = 327
    y4_coord = 366

    CO = 1

elif G == 10 and CO == 2:
    x_coord = 102
    y_coord = 267

    x2_coord = 498
    y2_coord = 333

    x3_coord = 267
    y3_coord = 102

    x4_coord = 333
    y4_coord = 498

    CO = 1

if V == 2:
    if event.type == event_500ms:
        if Blue == 1:
            D.fill(BLUE)
            Blue = 2
        elif Blue == 2:
            D.fill(YELLOW)
            Blue = 1



B(L1, (47, 45))
B(L2, (47, 60))
B(L2C, (65, 75))
B(L3, (47, 90))
B(L4, (47, 105))
B(L5, (47, 120))

L(D, PINDLER, (40, 5), (695, 5), 10)
L(D, PINDLER, (3, 42), (3, 495), 10)
L(D, PINDLER, (3, 495), (695, 495), 10)
L(D, PINDLER, (695, 495), (695, 5), 10)

L(D, PINDLER, (3, 41), (658, 42), 10)
L(D, PINDLER, (40, 5), (40, 458), 10)
L(D, PINDLER, (40, 458), (658, 458), 10)
L(D, PINDLER, (658, 458), (658, 42), 10)

FINISH(D, Fx, Fy)

MOLINE1(D, x_coord, y_coord)

MOLINE2(D, x2_coord, y2_coord)

MOLINE3(D, x3_coord, y3_coord)

MOLINE4(D, x4_coord, y4_coord)

MOLINE5(D, X5_coord, Y5_coord)


pygame.draw.line(D, PINDLER, (303, 302), (307, 306), 1)
pygame.draw.line(D, PINDLER, (307, 302), (303, 306), 1)






pygame.display.flip()

clock.tick(60)
</code></pre>
<p>I would show all of the code, but it doesn't like to indent properly for the site to recognize it as code. Once, I manually put four spaces in all 500 lines. It wasn't fun.</p>
<p>Upon request for more information, I have taken the liberty of giving all of the code. Hope this helps. Thanks.</p>
<pre><code>import pygame, sys, random
from pygame.locals import *

pygame.init()

BLACK =          (  0,   0,   0)
ABINO =          ( 34,  45, 102)
PINDLER =        (255, 123,  90)
MEXON =          (200, 190, 220)
WHITE =          (255, 255, 255)
YELLOW =         (255, 255,   0)
RED =            (255,   0,   0)
BLUE =           (  0,   0, 255)

size = [700, 500]
D = pygame.display.set_mode(size)
L = pygame.draw.aaline
R = pygame.draw.rect
G = random.randrange(1, 10)
GM = 1
GMT = 2
CIP = 1
CO = 2
V = 0
Blue = 1
event_500ms = pygame.USEREVENT + 1
pygame.time.set_timer(event_500ms, 500)

pygame.display.set_caption("Moline")
myfont = pygame.font.SysFont("monospace", 15)
T = myfont.render
M1S = "RULES:"
M2S = "1. To start, press each arrow key in a random sequence"
M2F = " for roughly one second."
M3S = "2. To win, re-merge the four men on the crossmark."
M4S = "3. Complete before the running man completes a lap."
M5S = "4. Mouse movement is illegal and causes a severe time penalty."
L1 = T(M1S, 1, (255, 255, 0))
L2 = T(M2S, 1, (255, 255, 0))
L2C = T(M2F, 1, (255, 255, 0))
L3 = T(M3S, 1, (255, 255, 0))
L4 = T(M4S, 1, (255, 255, 0))
L5 = T(M5S, 1, (255, 255, 0))
B = D.blit
Fx = 10
Fy = 10
L6 = T("cheeeeeeeeese", 1, (255, 255, 0))

def MOLINE1(D, x, y):
    pygame.draw.ellipse(D, BLACK, [1 + x, y, 10, 10], 0)

    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [10 + x, 27 + y], 2)
    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [x, 27 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 17 + y], [5 + x, 7 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [9 + x, 17 + y], 2)
    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [1 + x, 17 + y], 2)

def MOLINE2(D, x, y):
    pygame.draw.ellipse(D, BLACK, [1 + x, y, 10, 10], 0)

    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [10 + x, 27 + y], 2)
    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [x, 27 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 17 + y], [5 + x, 7 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [9 + x, 17 + y], 2)
    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [1 + x, 17 + y], 2)

def MOLINE3(D, x, y):
    pygame.draw.ellipse(D, BLACK, [1 + x, y, 10, 10], 0)

    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [10 + x, 27 + y], 2)
    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [x, 27 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 17 + y], [5 + x, 7 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [9 + x, 17 + y], 2)
    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [1 + x, 17 + y], 2)

def MOLINE4(D, x, y):
    pygame.draw.ellipse(D, BLACK, [1 + x, y, 10, 10], 0)

    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [10 + x, 27 + y], 2)
    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [x, 27 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 17 + y], [5 + x, 7 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [9 + x, 17 + y], 2)
    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [1 + x, 17 + y], 2)

def MOLINE5(D, x, y):
    pygame.draw.ellipse(D, BLACK, [1 + x, y, 10, 10], 0)

    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [10 + x, 27 + y], 2)
    pygame.draw.line(D, BLACK, [5 + x, 17 + y], [x, 27 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 17 + y], [5 + x, 7 + y], 2)

    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [9 + x, 17 + y], 2)
    pygame.draw.line(D, PINDLER, [5 + x, 7 + y], [1 + x, 17 + y], 2)

def FINISH(D, x, y):
    R(D, BLACK, ( 4, 42, 6, 6))
    R(D, WHITE, (10, 42, 6, 6))
    R(D, BLACK, (16, 42, 6, 6))
    R(D, WHITE, (22, 42, 6, 6))
    R(D, BLACK, (28, 42, 6, 6))
    R(D, WHITE, (34, 42, 6, 6))

    R(D, WHITE, ( 4, 48, 6, 6))
    R(D, BLACK, (10, 48, 6, 6))
    R(D, WHITE, (16, 48, 6, 6))
    R(D, BLACK, (22, 48, 6, 6))
    R(D, WHITE, (28, 48, 6, 6))
    R(D, BLACK, (34, 48, 6, 6))

    R(D, BLACK, ( 4, 54, 6, 6))
    R(D, WHITE, (10, 54, 6, 6))
    R(D, BLACK, (16, 54, 6, 6))
    R(D, WHITE, (22, 54, 6, 6))
    R(D, BLACK, (28, 54, 6, 6))
    R(D, WHITE, (34, 54, 6, 6))

x_speed = 0
y_speed = 0

x2_speed = 0
y2_speed = 0

x3_speed = 0
y3_speed = 0

x4_speed = 0
y4_speed = 0

x_coord = 300
y_coord = 300

x2_coord = 300
y2_coord = 300

x3_coord = 300
y3_coord = 300

x4_coord = 300
y4_coord = 300

X5_coord = 30
Y5_coord = 10

direction = 'right'

clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                x_speed =- 3
                x2_speed = 3
                y3_speed =- 3
                y4_speed = 3
            elif event.key == pygame.K_RIGHT:
                x_speed = 3
                x2_speed =- 3
                y3_speed = 3
                y4_speed =- 3
            elif event.key == pygame.K_UP:
                y_speed =- 3
                y2_speed = 3
                x3_speed =- 3
                x4_speed = 3
            elif event.key == pygame.K_DOWN:
                y_speed = 3
                y2_speed =- 3
                x3_speed = 3
                x4_speed =- 3
            elif event.key == pygame.K_TAB:
                GMT += 1
                CIP = 2
                if GMT % 2:
                    GM = 2
                else:
                    GM = 1

        if event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT:
                x_speed=0
                x2_speed=0
                y3_speed=0
                y4_speed=0
            elif event.key == pygame.K_RIGHT:
                x_speed=0
                x2_speed=0
                y3_speed=0
                y4_speed=0
            elif event.key == pygame.K_UP:
                y_speed=0
                y2_speed=0
                x3_speed=0
                x4_speed=0
            elif event.key == pygame.K_DOWN:
                y_speed=0
                y2_speed=0
                x3_speed=0
                x4_speed=0

        elif event.type == MOUSEBUTTONDOWN:
            x_coord = 300
            y_coord = 300
            x2_coord = 300
            y2_coord = 300
            x3_coord = 300
            y3_coord = 300
            x4_coord = 300
            y4_coord = 300
            X5_coord = 30
            Y5_coord = 10
            direction = 'right'
            D.fill(BLACK)
            G = random.randrange(1, 10)
            CO = 2
            V = 2

        elif event.type == MOUSEBUTTONUP:
            X5_coord = 30
            Y5_coord = 10
            direction = 'right'

        if direction == 'right':
            X5_coord += 10
            if X5_coord == 670:
                direction = 'down'
        elif direction == 'down':
            Y5_coord += 10
            if Y5_coord == 460:
                direction = 'left'
        elif direction == 'left':
            X5_coord -= 10
            if X5_coord == 10:
                direction = 'up'
        elif direction == 'up':
            Y5_coord -= 10
            if Y5_coord == 10:
                direction = 'right'





    x_coord = x_coord + x_speed
    y_coord = y_coord + y_speed

    x2_coord = x2_coord + x2_speed
    y2_coord = y2_coord + y2_speed

    x3_coord = x3_coord + x3_speed
    y3_coord = y3_coord + y3_speed

    x4_coord = x4_coord + x4_speed
    y4_coord = y4_coord + y4_speed

    if GM == 2 and CIP == 2:
        D.fill(BLACK)
        CIP = 1

    if GM == 1:
        D.fill(MEXON)

    if G &gt;= 6:
        B(L6, (80, 150))

    if G == 1 and CO == 2:
        x_coord = 366
        y_coord = 201

        x2_coord = 234
        y2_coord = 399

        x3_coord = 201
        y3_coord = 366

        x4_coord = 399
        y4_coord = 234

        CO = 1

    elif G == 2 and CO == 2:
        x_coord = 240
        y_coord = 312

        x2_coord = 360
        y2_coord = 288

        x3_coord = 312
        y3_coord = 240

        x4_coord = 288
        y4_coord = 360

        CO = 1

    elif G == 3 and CO == 2:
        x_coord = 405
        y_coord = 228

        x2_coord = 195
        y2_coord = 372

        x3_coord = 228
        y3_coord = 405

        x4_coord = 372
        y4_coord = 195

        CO = 1

    elif G == 4 and CO == 2:
        x_coord = 179
        y_coord = 309

        x2_coord = 421
        y2_coord = 291

        x3_coord = 309
        y3_coord = 179

        x4_coord = 291
        y4_coord = 421

        CO = 1

    elif G == 5 and CO == 2:
        x_coord = 315
        y_coord = 450

        x2_coord = 285
        y2_coord = 150

        x3_coord = 450
        y3_coord = 315

        x4_coord = 150
        y4_coord = 285

        CO = 1

    elif G == 6 and CO == 2:
        x_coord = 180
        y_coord = 390

        x2_coord = 420
        y2_coord = 210

        x3_coord = 390
        y3_coord = 180

        x4_coord = 210
        y4_coord = 420

        CO = 1

    elif G == 7 and CO == 2:
        x_coord = 267
        y_coord = 204

        x2_coord = 333
        y2_coord = 396

        x3_coord = 204
        y3_coord = 267

        x4_coord = 396
        y4_coord = 333

        CO = 1

    elif G == 8 and CO == 2:
        x_coord = 363
        y_coord = 390

        x2_coord = 237
        y2_coord = 210

        x3_coord = 390
        y3_coord = 363

        x4_coord = 210
        y4_coord = 237

        CO = 1

    elif G == 9 and CO == 2:
        x_coord = 234
        y_coord = 273

        x2_coord = 366
        y2_coord = 327

        x3_coord = 273
        y3_coord = 234

        x4_coord = 327
        y4_coord = 366

        CO = 1

    elif G == 10 and CO == 2:
        x_coord = 102
        y_coord = 267

        x2_coord = 498
        y2_coord = 333

        x3_coord = 267
        y3_coord = 102

        x4_coord = 333
        y4_coord = 498

        CO = 1

    if V == 2:
        if event.type == event_500ms:
            if Blue == 1:
                D.fill(BLUE)
                Blue = 2
            elif Blue == 2:
                D.fill(YELLOW)
                Blue = 1



    B(L1, (47, 45))
    B(L2, (47, 60))
    B(L2C, (65, 75))
    B(L3, (47, 90))
    B(L4, (47, 105))
    B(L5, (47, 120))

    L(D, PINDLER, (40, 5), (695, 5), 10)
    L(D, PINDLER, (3, 42), (3, 495), 10)
    L(D, PINDLER, (3, 495), (695, 495), 10)
    L(D, PINDLER, (695, 495), (695, 5), 10)

    L(D, PINDLER, (3, 41), (658, 42), 10)
    L(D, PINDLER, (40, 5), (40, 458), 10)
    L(D, PINDLER, (40, 458), (658, 458), 10)
    L(D, PINDLER, (658, 458), (658, 42), 10)

    FINISH(D, Fx, Fy)

    MOLINE1(D, x_coord, y_coord)

    MOLINE2(D, x2_coord, y2_coord)

    MOLINE3(D, x3_coord, y3_coord)

    MOLINE4(D, x4_coord, y4_coord)

    MOLINE5(D, X5_coord, Y5_coord)


    pygame.draw.line(D, PINDLER, (303, 302), (307, 306), 1)
    pygame.draw.line(D, PINDLER, (307, 302), (303, 306), 1)






    pygame.display.flip()

    clock.tick(60)

pygame.quit()
</code></pre>
<p>Recognize, this is not a finished product and thus may seem awkward in some respect because this program has evolved a lot. Thus might have some non used globals or some inaccurate text.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you <strong>can´t get any events for the amount of time the game pauses</strong> when you use for instance the <a href="http://www.pygame.org/docs/ref/time.html#pygame.time.wait" rel="nofollow"><code>pygame.time.wait()</code></a> or <a href="http://www.pygame.org/docs/ref/time.html#pygame.time.delay" rel="nofollow"><code>pygame.time.delay()</code></a> functions of the PyGame <code>time</code> module.</p>
<p>To avoid this problem you could <strong>create your very own event which appears on the event queue every given number of milliseconds</strong>. You could use <a href="http://www.pygame.org/docs/ref/time.html#pygame.time.set_timer" rel="nofollow"><code>pygame.time.set_timer()</code></a> to create an event:</p>
<pre><code>import pygame    
pygame.init()

#color tupels
BLUE = (55,155,255)
YELLOW = (255,255,0)


#create a new event id called event_500ms
event_500ms = pygame.USEREVENT + 1

#set timer event to appear on the event queue every 500 milliseconds
pygame.time.set_timer(event_500ms, 500)

screen = pygame.display.set_mode((800,800))

#global variable V for state-machine
V = 0

while True:
    #get events from the event queue
    for ev in pygame.event.get():
        if ev.type == pygame.KEYDOWN and ev.key == pygame.K_ESCAPE:
                pygame.quit()
                exit()
        #left (ev.button == 3) mousbutton down -&gt; set variable V = 1
        if ev.type == pygame.MOUSEBUTTONDOWN and ev.button == 3:
            V = 1

        #check for the event_500ms event    
        if ev.type == event_500ms:
            if V == 1:
                screen.fill(BLUE)
                V = 2
            elif V == 2:
                screen.fill(YELLOW)
                V = 0

            pygame.display.flip() #update whole screen
</code></pre>
<p>In this code we use a sort of a so-called <a href="http://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow"><em>state-machine</em></a> with 3 different stages:</p>
<ol>
<li><strong>Set <code>V = 1</code></strong>, if a <code>pygame.MOUSEBUTTONDOWN</code> event accurse,  <em>(Next state: 2)</em></li>
<li><strong>Fill the <code>screen</code> blue and increment <code>V</code></strong>, if variable <code>V</code> equals <code>1</code>. <em>(Next state: 3)</em></li>
<li><strong>Fill the <code>screen</code> yellow and rest <code>V</code> to <code>0</code></strong>, if variable <code>V</code> equals <code>2</code>. <em>(Next state: 1)</em></li>
</ol>
<p>I hope this helps :)</p>
</div>
<div class="post-text" itemprop="text">
<p>There a two solutions to you problem, which represents the both approaches you tried: Either you wait a specific time for your next tick or you do something each tick but then you have the problem that ticks are dependent on how fast the computer is (and other factors like programs running in the background). (With tick I refer to each run through your main loop, which you probably use.)</p>
<p>At the moment you say "okay, I want to change the background every fourth tick", with the problem that this might be every milisecond, or every second or whenever. So we need to not depend on the amount of ticks that happened but the amount of time. We can use <a href="https://docs.python.org/3.4/library/time.html#time.perf_counter" rel="nofollow">time.perf_counter()</a> to get the current time. This gives us:</p>
<pre><code>#Initialize old_time somewhere
new_time = time.perf_counter()
if new_time - old_time &gt; 0.05:
    change_background()
    old_time = new_time
</code></pre>
<p>Normally you don't want to do this for every thing that is time dependent. Instead as the first thing in your while loop calculate a delta time, often called <code>dt</code></p>
<pre><code>while True:
    dt = time.perf_counter() - old_time
    old_time = time.perf_counter()
    change_background(dt)
</code></pre>
<p>Then handle the <code>dt</code> the same way we handled it before:</p>
<pre><code>def change_background(dt):
    cumulative_time += dt
    if cumulative_time &gt; 0.05:
        #do things
        cumulative_time = 0
</code></pre>
<p>The other way would be to use some kind of <code>sleep</code>. As you already saw this will freeze the whole thread - but you can create more than one (of course you don't need to use threads, you could use processes or greenlets or all that other fancy multiprocessing stuff). The whole thing is a bit complicated, so I will not go into details here, but generally it is a good idea to have different threads for input and processing. The relative new <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow"><code>asyncio</code></a> module deals with exactly that kind of problem. There are also different solutions like <a href="https://greenlet.readthedocs.org/en/latest/" rel="nofollow">greenlets</a> or <a href="https://docs.python.org/3.4/library/threading.html" rel="nofollow">threads</a>. Doing things asyncronuos can be confusing at the beginning, the first solution can take you relative far.</p>
<p>EDIT:
My answer is independent of pygame, the events used in the other answer does this in the background for you. It is still a good idea to understand this delta time idea and to use it e.g. in physics computation. Generally being dependent on ticks (instead of time) is a bad idea and can give you unexpected behavior. It is said that the original space invaders did depend on ticks for their physics and graphics computations. Thus it sped up everytime you shoot enough enemies. This was an unexpected result (and then kept because it was a good mechanic to increase difficulty). The same problem is faced by emulators: Often old games (which depend on ticks and not on time) would run incredible fast because modern computers have much more processing power. An emulator has to take that into account and "slow processing down".</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you could try:</p>
<pre><code>import time
time.sleep(5)
</code></pre>
</div>
<span class="comment-copy">You might find a solution that works here: <a href="http://www.pygame.org/docs/ref/time.html" rel="nofollow noreferrer"><code>pygame.time</code></a></span>
<span class="comment-copy">Use Threads for this task. Do color change in different Thread using sleep()</span>
<span class="comment-copy">Hey, maybe the problem is that your <code>if V == 2:  if event.type == event_500ms: ...</code> statement is <b>not</b> located in the <i>event loop*</i> (<code>for event in pygame.event.get():</code>). But it’s nor really clear, because you cut of this part in your post. Please show us the first lines of your <i>entire</i> main game loop... :)</span>
<span class="comment-copy">Sadly, changing the indent breaks the progress I've obtained thus far. It seems to be place in the loop as it should. Nevertheless, I have taken the liberty of adding the entire program to my post. Thanks for the help.</span>
<span class="comment-copy">@YUI: As I mentioned in my last comment, in my opinion the <i>new</i> <code>if</code>-statement for color changing should be <b>inside</b> the event loop. Anyway, maybe it is better to post a new question for that new problem?! :)</span>
<span class="comment-copy">Using global variables for such simple things feels wrong to me, but I can't come up with a better idea. I know it's close to the authors own try, but is there a "better"/"idiomatic" way to do such things?</span>
<span class="comment-copy">@syntonym: I know what you mean and this is a very interesting question, but actually <i>every variable</i> in this program is <i>global</i> and accessible form everywhere. For instance the <code>screen</code> is defined as <i>the</i> mean game screen at the beginning of the code and will be used in the game loop <i>like</i> a global variable. It is the same thing with the two color variables <code>BLUE</code> and <code>YELLOW</code>. So why not use a global variable for the color-change mechanism? BTW: Sorry for my English…</span>
<span class="comment-copy"><code>screen</code> is of global interest, so declaring it as global variable is good. <code>V</code> on the other hand is not of global interest but only in the very specific scope of the animation. In this small example it may be fine, but what happens if we have 10 animations or hundreds? Also the declaration of <code>V</code> may be hundreds of lines away of the usage of it. On the other hand I don't know a "good solution" to it.. But I don't know pygame, there is probably a solution for animations in it? Don't worry about your English, it's fine!</span>
<span class="comment-copy">@syntonym: Hey, I really understand what you mean. But I am afraid, I don´t know any better solutions for animations in PyGame. Most of the code I have seen use a so called "Clock"-object <code>pygame.time.Clock</code> and call the <code>.tick()</code> method of this object every iteration of the main game loop (i.e. once per frame). By calling for instance <code>Clock.tick(30)</code> once per frame, the program will never run at faster than 30 frames per second. By knowing that <b>all</b> animations are done in the main game loop, counting the frames to determine the speed of a character. I hope I could help you a little bit.</span>
<span class="comment-copy">I was able to use this method to get my game to not freeze during the process, but sadly, upon making any form of input such as an arrow key, it pauses the flashing until I stop inputting. Any ideas for this? I added more content to the question to assist you. Thanks!</span>
<span class="comment-copy">In my opinion your solution is very nice, because it is, as you said, independent of PyGame.</span>
<span class="comment-copy">This does not solve the problem, because then all other things will freeze too.</span>
