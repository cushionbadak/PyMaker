<div class="post-text" itemprop="text">
<p>I don't understand why the following code is returning an error <code>AttributeError: 'Dice' object has no attribute 'die1'</code> in the <code>__str__</code> method. I know that I have created one, and my debugger shows it as a class attribute. What is wrong with this (simple) code? </p>
<pre><code>   class Dice(QMainWindow) :
        """A game of Dice."""

        def __init__(self, parent = None):
            """Build a game with two dice."""

            QMainWindow.__init__(self, parent)

            super(Dice, self).__init__(parent)
            uic.loadUi("Dice.ui", self)

            self.die1 = Die()
            self.die2 = Die()
            self.rollButton.clicked.connect(self.rollButtonClickedHandler)


        def __str__( self ):
            """String representation for Dice.
            """
            return "Die1: %s\nDie2: %s" % ( str(self.die1),  str(self.die2) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As noted in the comments, the error is raised because <code>loadUi</code> calls <code>__str__</code> on the class instance (i.e. <code>self</code>) before <code>die1</code> has been set.</p>
<p>The reason <em>why</em> the <code>uic</code> module does this is because it collects a lot of debugging information whilst parsing the <code>ui</code> file, and that includes logging the object passed as the <code>baseinstance</code> argument of <code>loadUi</code>.</p>
<p>Unfortunately, it does this by (indirectly) calling <code>__str__</code> when it probably should be calling <code>__repr__</code>. (Or possibly just not logging debugging information <em>at all</em> when calling the python API functions. The command-line interface has an option for <em>switching on</em> debugging, but it seems this only controls whether the logged information is displayed, rather than whether it is gathered in the first place).</p>
<p>It certainly is natural to want to call <code>loadUi</code> at the earliest possible point during initialisation - just as you'd do with <code>setupUi</code>. But no matter how you load the ui into your application, <code>uic</code> will generate the code in exactly the same way. The only difference with <code>loadUi</code> is that it calls <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow"><code>exec()</code></a> on the generated code at runtime, whereas with <code>pyuic</code>, the same code is just imported as a static module.</p>
<p>There a number of ways to solve your immediate problem. Personally, I think I would probably choose to pre-initialise <code>die1/die2</code> as class attributes:</p>
<pre><code>   class Dice(QMainWindow) :
        """A game of Dice."""
        die1 = die2 = None

        def __init__(self, parent=None):
            """Build a game with two dice."""
            super().__init__(parent)
            uic.loadUi("Dice.ui", self)
            self.die1 = Die()
            self.die2 = Die()
            ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actual answer: move the <code>uic.loadUi</code> call to <em>after</em> you create the <code>die</code>s.</p>
<p>Comments on code:</p>
<ul>
<li>Only call the constructor once (not once as <code>QMainWindow</code> and once as <code>super</code>)</li>
<li>When using <code>%s</code>, you don't need to also call <code>str()</code> -- that's what <code>%s</code> does.</li>
<li>If writing Python3 only code, your <code>super</code> call can leave out the <code>Dice, self</code> portion and just be <code>super().__init__(parent)</code></li>
</ul>
</div>
<span class="comment-copy">What's obviously wrong is that you <code>__init__</code> the base class twice (once explicitly and once with <code>super</code> -- lose one of them!), but that doesn't explain the error you observe.</span>
<span class="comment-copy">The error is raised because <code>loadUi</code> calls <code>__str__</code> on your class instance (which you passed to it as <code>self</code>) before <code>die1</code> has been set.</span>
<span class="comment-copy">Thanks for pointing out the double contructor call, I noticed that one myself, after a night's sleep! However ekhumoro nailed the problem! Thanks! Care to comment further? I'm switching from PyQt4 to PyQt5 and have always compiled the ui outside of my code. I thought I would need to load the ui before setting up signals, Is that true? Also why would loadUi call the str method on my class?</span>
<span class="comment-copy">if you are on python 3x you can call parent methods without the class. ''super().__init__(parent)''</span>
