<div class="post-text" itemprop="text">
<p>Today I wrote test and typoed in one of test methods. My tests failed but I don't understand why. Is it special behaviour of Python properties or something else?</p>
<pre><code>from unittest import TestCase


class FailObject(object):
    def __init__(self):
        super(FailObject, self).__init__()
        self.__action = None

    @property
    def action(self):
        return self.__action

    @action.setter
    def action(self, value):
        self.__action = value


def do_some_work(fcells, fvalues, action, value):
    currentFailObject = FailObject()
    rects = [currentFailObject]
    return rects


class TestModiAction(TestCase):
    def testSetFailObjectAction(self):
        rect = FailObject  # IMPORTANT PART
        rect.action = "SOME_ACTION" # No fail!
        self.assertEquals("SOME_ACTION", rect.action)

    def testSimple(self):
        fcells = []
        fvalues = []
        rects = do_some_work(fcells, fvalues, 'act', 0.56)

        rect = rects[0]
        self.assertEquals('act', rect.action)
</code></pre>
<p>When I run this testcase with nose tests:</p>
<pre><code>.F
======================================================================
FAIL: testSimple (test.ufsim.office.core.ui.cubeeditor.TestProperty.TestModiAction)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "TestProperty.py", line 36, in testSimple
    self.assertEquals('act', rect.action)
AssertionError: 'act' != 'SOME_ACTION'

----------------------------------------------------------------------
Ran 2 tests in 0.022s

FAILED (failures=1)
</code></pre>
<p>If I fix typo with instance creation in <strong>testSetFailObjectAction</strong> all tests are work as expected. But this example turn me back to question: Is it safe to use properties? What if I will typo again some day?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow"><code>patch</code></a> and <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.PropertyMock" rel="nofollow"><code>PropertyMock</code></a>  from <a href="https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock" rel="nofollow"><code>mock</code></a> to this kind of jobs:</p>
<pre><code>@patch(__name__."FailObject.action", new_callable=PropertyMock, return_value="SOME_ACTION")
def testSetFailObjectAction(self, mock_action):
    self.assertEquals("SOME_ACTION", FailObject().action)
    self.assertTrue(mock_action.called)
    #This fail
    self.assertEquals("SOME_ACTION", FailObject.action)
</code></pre>
<p>By <code>patch</code> you replace the property <code>action</code> just for the test context and you can also check if the property has been used.</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay, that is Python default behaviour. In <strong>testSetFailObjectAction</strong> we add new static class variable that hides our properties. There is no way to protect yourself from mistakes like this.</p>
<p>The only suggestation is to use Traits library.</p>
</div>
<span class="comment-copy">Are you supposed to be setting <code>currentFailObject.action = action</code> in <code>do_some_work</code>? Currently nothing should make your (sample) code change <code>currentFailObject</code>'s <code>action</code> property to <code>'act'</code></span>
