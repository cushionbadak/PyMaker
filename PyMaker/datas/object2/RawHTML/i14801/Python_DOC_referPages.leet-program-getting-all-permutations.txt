<div class="post-text" itemprop="text">
<p>I wrote a straightforward function that converts letters in words to their 'leet' numerical counterparts.</p>
<pre><code>def Leet(word):
    letters = list(word.lower())
    for n, letter, in enumerate(letters):
        if letter == 'o':
            letters[n]= '0'
        elif letter == 'i':
            letters[n]= '1'
        elif letter == 'z':
            letters[n]= '2'
        elif letter == 'e':
            letters[n]= '3'
        elif letter == 'a':
            letters[n]= '4'
        elif letter == 's':
            letters[n]= '5'
        elif letter == 'g':
            letters[n]= '6'
        elif letter == 't':
            letters[n]= '7'
        elif letter == 'b':
            letters[n]= '8'
    return ''.join(letters)
</code></pre>
<p>so when I input <code>'zit'</code>, the program will return <code>'217'</code>. </p>
<p>My question is, how can I change it to give me every possible permutation (<code>'217'</code>, <code>'2it'</code>, <code>'z1t'</code>, <code>'zi7'</code>, <code>'21t'</code>, etc.)? I've read about <code>itertools</code> but I am stumped as to how to apply it to my function.</p>
</div>
<div class="post-text" itemprop="text">
<p>First observation is that you can shorten the lookup, like this:</p>
<pre><code>REPLACE = { letter: str(index) for index, letter in enumerate('oizeasgtb') }

def Leet2(word):
    letters = [ REPLACE.get(l, l) for l in word.lower() ]
    return ''.join(letters)
</code></pre>
<p><code>REPLACE</code> looks like:</p>
<pre><code>{'a': '4', 'b': '8', 'e': '3', 'g': '6', 'i': '1', 
 'o': '0', 's': '5', 't': '7', 'z': '2'}
</code></pre>
<p>And the <code>REPLACE.get(l,l)</code> gives you back either the replacement letter, or the original letter if there is no replacement.</p>
<p>The second observation is that you don't really want permutations, which are shifts in ordering. The permutations of '217' are:</p>
<pre><code>&gt;&gt;&gt; [ ''.join(p) for p in permutations('217') ]
['217', '271', '127', '172', '721', '712']
</code></pre>
<p>What you really need is the product of a list that encodes all the possible choices for a given character position:</p>
<pre><code>[('z', '2'), ('i', '1'), ('t', '7')]
</code></pre>
<p>How this works might be clearer if I also show a possibility list with some characters for which there is no valid replacement. For <code>'red'</code> for example:</p>
<pre><code>[('r',), ('e', '3'), ('d',)]
</code></pre>
<p>Now we need the string-joined product of those options. Putting it all together:</p>
<pre><code>from itertools import product

def Leet2Combos(word):
    possibles = []
    for l in word.lower():
        ll = REPLACE.get(l, l)
        possibles.append( (l,) if ll == l else (l, ll) )
    return [ ''.join(t) for t in product(*possibles) ]

print Leet2Combos('zit')
print Leet2Combos('red')
</code></pre>
<p>Gives:</p>
<pre><code>['zit', 'zi7', 'z1t', 'z17', '2it', '2i7', '21t', '217']
['red', 'r3d']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a>. Also, I would suggest using a <code>dict</code> for the mapping instead of a cascade of <code>if/elif</code>.</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; LEET = { 'z': '2', 'i': '1', 't': '7' } # and all the others     
&gt;&gt;&gt; word = "zit"
&gt;&gt;&gt; [''.join(letters) for letters in product(*({c, LEET.get(c, c)} for c in word))]
['zit', 'zi7', 'z1t', 'z17', '2it', '2i7', '21t', '217']
</code></pre>
<p>Note that <code>LEET.get(c, c)</code> will get the "leet" letter from the dict, or use the original letter as a default. The <code>{...}</code> is used to make those pairs sets, so there are no duplicates for letters with no replacement. In older versions of Python, you might have to use <code>set([...])</code> instead.</p>
<p>That rather complex <code>product(*...)</code> line works roughly like this:</p>
<pre><code>    product(*({c, LEET.get(c, c)} for c in 'zit'))
==&gt; product(*({'z', LEET.get('z', 'z')}, {'i', LEET.get('i', 'i')}, {'t', LEET.get('t', 't')}))
==&gt; product(*({'z', '2'}, {'i', '1'}, {'t', '7'}))
==&gt; product(  {'z', '2'}, {'i', '1'}, {'t', '7'} )
</code></pre>
<p>which produces the <a href="http://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow">cartesian product</a> of all those letters and their replacements.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to do it is to use <a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow">itertools.product</a>, as you mentionned, which will perform a cartesian product of a list.</p>
<p>The problem will be to have this list, of every combinaison e.g for zit the list should be:</p>
<pre><code>[['z', '2'], ['i', '1'], ['t', '7']]
</code></pre>
<p>My code:</p>
<pre><code>import itertools

def leet(word):
    leet_matches = [['a', '4'],
    ['b' ,'8'],
    ['c'],
    ['d'],
    ['e', '3'],
    ['f'],
    ['g', '6'],
    ['h'],
    ['i', '1'],
    ['j'],
    ['k'],
    ['l'],
    ['m'],
    ['n'],
    ['o', '0'],
    ['p'],
    ['q'],
    ['r'],
    ['s', '5'],
    ['t', '7'],
    ['u'],
    ['v'],
    ['w'],
    ['x'],
    ['y'],
    ['z', '2']]
    l = []
    for letter in word:
        for match in leet_matches:
            if match[0] == letter:
                l.append(match)
    return list(itertools.product(*l))

print leet("zit")
</code></pre>
<p>Note that using list of list (or tuples) instead of Dict allows you to have several replacements for one letter, e.g. "i" can become "1" or "!"</p>
</div>
<span class="comment-copy">Note that a dictionary <code>{'o': '0', ...}</code> would make this <b>much</b> neater.</span>
<span class="comment-copy">Nice answer. I wonder what's with the <code>*</code>, in <code>product(*[(...</code>? I'm not 100% comfortable with Python yet.</span>
<span class="comment-copy">This works great for words like <code>'zit'</code> for which there are two choices for every letter position. It works slightly less well for words like <code>'red'</code>, for which it returns <code>['red', 'red', 'r3d', 'r3d', 'red', 'red', 'r3d', 'r3d']</code>--a list with duplicates. Suggest wrapping either the result or the internal list tuples with a <code>set()</code> operation to compensate.</span>
