<div class="post-text" itemprop="text">
<p>I'm working on porting a library so that it is compatible with both python 2 and 3.  The library receives strings or string-like objects from the calling application and I need to ensure those objects get converted to unicode strings.</p>
<p>In python 2 I can do:</p>
<pre><code>unicode_x = unicode(x)
</code></pre>
<p>In python 3 I can do:</p>
<pre><code>unicode_x = str(x)
</code></pre>
<p>However, the best cross-version solution I have is:</p>
<pre><code>def ensure_unicode(x):
  if sys.version_info &lt; (3, 0):
    return unicode(x)
  return str(x)
</code></pre>
<p>which certainly doesn't seem great (although it works).  Is there a better solution?</p>
<p>I am aware of <code>unicode_literals</code> and the <code>u</code> prefix but both of those solutions do not work as the inputs come from clients and are not literals in my library.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't re-invent the compatibility layer wheel. Use the <a href="http://pythonhosted.org/six/" rel="noreferrer"><code>six</code> compatibility layer</a>, a small one-file project that can be included with your own:</p>
<blockquote>
<p>Six supports every Python version since 2.6. It is contained in only one Python file, so it can be easily copied into your project. (The copyright and license notice must be retained.)</p>
</blockquote>
<p>It includes a <a href="http://pythonhosted.org/six/#six.text_type" rel="noreferrer"><code>six.text_type()</code> callable</a> that does exactly this, convert a value to Unicode text:</p>
<pre><code>import six

unicode_x = six.text_type(x)
</code></pre>
<p>In the <a href="https://bitbucket.org/gutworth/six/src/784c6a213c4527ea18f86a800f51bf16bc1df5bc/six.py?at=default" rel="noreferrer">project source code</a> this is defined as:</p>
<pre><code>import sys

PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
# ...

if PY3:
    # ...
    text_type = str
    # ...

else:
    # ...
    text_type = unicode
    # ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Calling the <code>str</code>'s constructor in Python 3 with a <code>bytes</code> string will not behave as you'd expect:</p>
<pre><code>&gt;&gt;&gt; import six
&gt;&gt;&gt; six.text_type(b'bytestring')
"b'bytestring'"
</code></pre>
<p>To see why that is, the <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer">docs</a> for the <code>str</code>'s constructor say:</p>
<blockquote>
<p>Passing a <code>bytes</code> object to <code>str()</code> without the encoding or errors
  arguments falls under the first case of returning the informal string
  representation.</p>
</blockquote>
<p>To work around this, use something similar to Django's <code>force_text</code> (1.11):</p>
<p><a href="https://docs.djangoproject.com/en/1.11/_modules/django/utils/encoding/#force_text" rel="nofollow noreferrer">https://docs.djangoproject.com/en/1.11/_modules/django/utils/encoding/#force_text</a></p>
<pre><code>def force_text(s, encoding='utf-8', strings_only=False, errors='strict'):
    """
    Similar to smart_text, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    # Handle the common case first for performance reasons.
    if issubclass(type(s), six.text_type):
        return s
    if strings_only and is_protected_type(s):
        return s
    try:
        if not issubclass(type(s), six.string_types):
            if six.PY3:
                if isinstance(s, bytes):
                    s = six.text_type(s, encoding, errors)
                else:
                    s = six.text_type(s)
            elif hasattr(s, '__unicode__'):
                s = six.text_type(s)
            else:
                s = six.text_type(bytes(s), encoding, errors)
        else:
            # Note: We use .decode() here, instead of six.text_type(s, encoding,
            # errors), so that if s is a SafeBytes, it ends up being a
            # SafeText at the end.
            s = s.decode(encoding, errors)
    except UnicodeDecodeError as e:
        if not isinstance(s, Exception):
            raise DjangoUnicodeDecodeError(s, *e.args)
        else:
            # If we get to here, the caller has passed in an Exception
            # subclass populated with non-ASCII bytestring data without a
            # working unicode method. Try to handle this without raising a
            # further exception by individually forcing the exception args
            # to unicode.
            s = ' '.join(force_text(arg, encoding, strings_only, errors)
                         for arg in s)
    return s
</code></pre>
<p>I know this will end up making you depend entirely on Django for such a tiny issue, so you can either copy the entire <code>django.utils.encoding</code> module to your project, or just use Django.</p>
<p>Also, if you don't really care about staying Python 2 compatible, be sure to check <code>force_text</code>'s implementation in Django 2:</p>
<p><a href="https://docs.djangoproject.com/en/2.2/_modules/django/utils/encoding/#force_text" rel="nofollow noreferrer">https://docs.djangoproject.com/en/2.2/_modules/django/utils/encoding/#force_text</a></p>
<pre><code>def force_text(s, encoding='utf-8', strings_only=False, errors='strict'):
    """
    Similar to smart_text, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    # Handle the common case first for performance reasons.
    if issubclass(type(s), str):
        return s
    if strings_only and is_protected_type(s):
        return s
    try:
        if isinstance(s, bytes):
            s = str(s, encoding, errors)
        else:
            s = str(s)
    except UnicodeDecodeError as e:
        raise DjangoUnicodeDecodeError(s, *e.args)
    return s
</code></pre>
</div>
<span class="comment-copy">That's what I was looking for.  Perfect.  Thank you.</span>
