<div class="post-text" itemprop="text">
<p>I have two modules:</p>
<p><strong>constants.py</strong></p>
<pre><code>def define_sizes(supersample):    
    global SUPERSAMPLE
    global WIDTH
    global HEIGHT
    global LINE_WIDTH

    SUPERSAMPLE = supersample
    WIDTH = 1280*SUPERSAMPLE
    HEIGHT = 854*SUPERSAMPLE
    LINE_WIDTH = 1*SUPERSAMPLE

define_sizes(1)
</code></pre>
<p><strong>test.py</strong></p>
<pre><code>from constants import *


print(WIDTH, HEIGHT, LINE_WIDTH)
# Draw something

define_sizes(4)

print(WIDTH, HEIGHT, LINE_WIDTH)
# Draw the same thing, but bigger
</code></pre>
<p>The result is:</p>
<pre><code>1280 854 1
1280 854 1
</code></pre>
<p>I would expect to get:</p>
<pre><code>1280 854 1
5120 3416 4
</code></pre>
<p>Why is that? What am I missing? Can I fix it to give expected results?</p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend something like the answer by adarsh for "real code", but if what you need to do is just to hack some existing code as quickly as possibly, you might try reimporting the constants, with a <code>test.py</code> like:</p>
<pre class="lang-py prettyprint-override"><code>from constants import *

print(WIDTH, HEIGHT, LINE_WIDTH)

define_sizes(4)

from constants import *

print(WIDTH, HEIGHT, LINE_WIDTH)
</code></pre>
<p>You would also have to modify <code>constants.py</code> so that it doesn't reset the <code>SUPERSAMPLE</code> to 1 when reimporting, something like:</p>
<pre><code>def define_sizes(supersample):
    global SUPERSAMPLE
    global WIDTH
    global HEIGHT
    global LINE_WIDTH

    SUPERSAMPLE = supersample
    WIDTH = 1280*SUPERSAMPLE
    HEIGHT = 854*SUPERSAMPLE
    LINE_WIDTH = 1*SUPERSAMPLE

if not 'SUPERSAMPLE' in globals():
    define_sizes(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't share global variables across modules in Python as such. You could use a config module, by importing it where ever you need it in the project and since there would only be one instance of it, you can use that as a global. It is described in the <a href="https://docs.python.org/3/faq/programming.html#how-do-i-share-global-variables-across-modules" rel="nofollow">documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In this situation I'd probably do</p>
<pre><code>class Sizes(object):
    def __init__(self, supersample=1)
        self.SUPERSAMPLE = supersample
    def resize(self, supersample)
        self.SUPERSAMPLE = supersample
    @property
    def WIDTH(self): return 1280*self.SUPERSAMPLE
    @property
    def HEIGHT(self): return 854*self.SUPERSAMPLE
    @property
    def LINE_WIDTH(self): return self.SUPERSAMPLE

sizes = Sizes(1)
resize = sizes.resize
</code></pre>
<p>which I then can use like</p>
<pre><code>from constants import sizes as s

print(s.WIDTH, s.HEIGHT, s.LINE_WIDTH)
# Draw something

s.resize(4)

print(s.WIDTH, s.HEIGHT, s.LINE_WIDTH)
# Draw the same thing, but bigger
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Once you did <code>from constants import *</code> names <code>WIDTH</code>, <code>HEIGHT</code>, <code>LINE_WIDTH</code> were imported into this module's namespace, they referring to the values (objects) they had at the time of import.</p>
<p>Even if <code>constants.WIDTH</code> is overwritten, variable <code>test.WIDTH</code> still references the old value.</p>
<p>The cleanest solution is to access those values through the <code>constants</code> module:</p>
<pre><code>import constants


print(constants.WIDTH, constants.HEIGHT, constants.LINE_WIDTH)
# Draw something

define_sizes(4)

print(constants.WIDTH, constants.HEIGHT, constants.LINE_WIDTH)
# Draw the same thing, but bigger
</code></pre>
</div>
<span class="comment-copy">One way would be to <code>return</code> the values rather than use globals, so you could do <code>WIDTH, HEIGHT, LINE_WIDTH = define_sizes(4)</code></span>
<span class="comment-copy">@Jkdc - Sure. In this case, which is minimal working example. In my real-life script, there are maybe 50 constants which need redefinition? It would be very ugly to return them all and then put them in global namespace anyway...</span>
<span class="comment-copy">I am trying to hack existing code to execute twice with different <code>SUPERSAMPLE</code> constant in one run.</span>
<span class="comment-copy">You might consider <a href="http://stackoverflow.com/a/2298388/1068887">this</a>?</span>
<span class="comment-copy">@adarsh - Yes, I have considered this, however that would require me to refactor existing code which uses those 50 constants. It seems to be the only reasonable way. Anyway, <code>Python does not support globals shared between several modules: this is a feature.</code> explains why it does not work.</span>
<span class="comment-copy">"You would also have to modify <code>constants.py</code> so that it doesn't reset the <code>SUPERSAMPLE</code> to 1 when reimporting" That holds only on <code>reload(constants)</code>. If you do <code>from constants import *</code> several times, the version cached in <code>sys.modules</code> is used so that they aren't reset each time.</span>
<span class="comment-copy">@glglgl - It does work, however, when I'm testing...</span>
<span class="comment-copy">However, can I use this <code>config</code> and <code>mod</code> concept to redefine all constants by just changing one parameter? It seems I would need to duplicate all constant code in <code>mod</code> module.</span>
<span class="comment-copy">You could have a function that alters all the variables you need to modify using the parameter value as the argument. I am not sure what you mean by "I would need to duplicate all constant code in mod module"</span>
<span class="comment-copy">Right, I had to give it more thought. You are right.</span>
