<div class="post-text" itemprop="text">
<p>I am parsing over two million text files for a project and need your help with regex <strong>make it faster</strong>. I need to split the words so I am able to do it using:</p>
<pre><code>text_file = re.sub(r'\W+',' ', text_file)
</code></pre>
<p>However, for hyphenated words, I would like to remove the hyphen but <strong>combine</strong> the word (i.e. non-profit would be nonprofit instead of "non", "profit"). Currently, I am able to do this with two search and replace (not ideal at all). The end output would be a list of words that will used by collections.Counter() object.</p>
<pre><code>def mod1(text_file):
     text_file = re.sub('\s*-\s*', '', text_file) # handling hyphens :( O(n)
     text_file = re.sub(r'\W+',' ', text_file)
     text_file = text_file.lower()
     return(text_file)
</code></pre>
<p>Any <strong>faster processing</strong> tips to do this beyond regex would also be much appreciated. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>After using <code>lower()</code>, you can use <code>re.sub(r'([a-z])-([a-z])', r'\1\2', s)</code> to remove hyphens. </p>
<p>Then <code>re.split(r'[^a-z]')</code>, to split the words. </p>
<pre><code>s = s.lower()
s = re.sub(r'([a-z])-([a-z])', r'\1\2', s)
s = re.split(r'[^a-z]', s)
</code></pre>
<p>This solution may (or may not) be faster <em>depending on the text it is used on</em>. It does have some probable speed ups though: </p>
<ul>
<li>Ignoring numbers allows usage of <code>[a-z]</code> instead of <code>\w</code>.</li>
<li><code>lower()</code> being called first, allows <code>re.sub()</code> to search for half the letters; that is <code>[a-z]</code> instead of <code>[A-Za-z]</code>.</li>
<li>Assuming no spaces before and after hyphens (since usually that should be the case) allows replacing of <code>'\s*-\s*'</code> with a faster <code>[a-z]-[a-z]</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like this,</p>
<pre><code>&gt;&gt;&gt; s = 'non-profit foo:?bar/buzz'
&gt;&gt;&gt; ''.join(re.sub(r'\W+', ' ',i.strip()) for i in s.split('-'))
'nonprofit foo bar buzz'
</code></pre>
<p>OR</p>
<p>You could define a function in the <code>re.sub</code>'s replacement part.</p>
<pre><code>&gt;&gt;&gt; s = 'non-profit foo:?bar/buzz'
&gt;&gt;&gt; re.sub(r'\W+', lambda m: re.sub(r'.*', '', m.group(0)) if re.match(r'\s*-\s*$', m.group(0)) else re.sub(r'.*', r' ', m.group(0)), s)
'nonprofit foo bar buzz'
</code></pre>
<p>OR</p>
<p>Keep it simple...</p>
<pre><code>&gt;&gt;&gt; re.sub(r'\W+', lambda m: '' if re.match(r'\s*-\s*$', m.group(0)) else ' ', s)
'nonprofit foo bar buzz'
</code></pre>
<p>This code will do the replace for every match founded. That is, after each single match, function m is called. <code>\W+</code> matches one or more non-word  characters. If a match is found, it will return an empty string if the matchobject.group(0) satisfies this <code>\s*-\s*$</code> condition else it would return a single space string. That is the match was replaced with the return value.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow"><code>str.translate</code></a> method , that is more faster than <code>regex</code>:</p>
<pre><code>&gt;&gt;&gt; import string
&gt;&gt;&gt; s ='aslkdf -  sadlk#gjf'
&gt;&gt;&gt; s.translate(str.maketrans(string.punctuation,32*' ','-'+string.whitespace))
'aslkdfsadlk gjf'
</code></pre>
<p>Answers benchmark :</p>
<pre><code>#Avinash Raj
:~$ python3 -m timeit "import re;s='aslkdf -  sadlk#gjf';re.sub(r'\W+', lambda m: '' if re.match(r'\s*-\s*$', m.group(0)) else ' ', s)"
100000 loops, best of 3: 7.96 usec per loop
#Kasra
:~$ python3 -m timeit "import string;s='aslkdf -  sadlk#gjf';s.translate(str.maketrans(string.punctuation,32*' ','-'+string.whitespace))"
100000 loops, best of 3: 4.75 usec per loop
#user 5061
:~$ python3 -m timeit "import re;s='aslkdf -  sadlk#gjf';s=s.lower();s = re.sub(r'([a-z])-([a-z])', r'\1\2', s);re.split(r'[^a-z]', s)"
100000 loops, best of 3: 8.46 usec per loop
</code></pre>
</div>
<span class="comment-copy">So you don't want to split, you only want to replace non-words characters with a space, (except for hyphen separated words). What is the expected result for <code>abc123 abc#123-123abc   -123abc-abc</code>? And do you want to obtain in fine a list or a string with each "words" separated by a space? Please edit your question with clear examples with expected results.</span>
<span class="comment-copy">I need to obtain a list of words. Will edit it. Thanks.</span>
<span class="comment-copy">Where are the clear examples?</span>
<span class="comment-copy">Thanks. I am already using timeit to check and compare processing times. It seems like split and combine using regex has to be called twice regardless. Will see if there are more other solutions. Cheers!</span>
<span class="comment-copy">@everestbaker Let me know of its speed. Also, my solution assumes you have no spaces in hyphenated words. Is that assumption incorrect?</span>
<span class="comment-copy">Using the same list of sample text files, processing time went down to 0.064 secs compared to 0.081 for the original solution. Much faster. Thanks. Will wait and see if there are any other suggestions.</span>
<span class="comment-copy">but this solution uses both re.split and re.sub</span>
<span class="comment-copy">Agreed Avinash. I'm looking into it as I might have to use a much bigger sample size.</span>
<span class="comment-copy">I believe <code>split</code> complexity is O(n), so your solution has exactly the same complexity as the OP approach right?</span>
<span class="comment-copy">Thanks Avinash. Your solution works but is much slower. For a list of text file (combined file size ~ 400kb), the read time was around 9.6 secs compared to 0.08 secs for calling regex twice.</span>
<span class="comment-copy">check my update.. @matino</span>
<span class="comment-copy">Thanks. It's much faster than your previous solution (0.3 secs compared to 9.6 secs) but it's slower than the original approach (0.08 secs). It seems like split and combine are two different tasks and will need to be called twice. Let's see if we are wrong. Cheers!</span>
<span class="comment-copy">Thanks for the str.translate tip. Will look into it further later because I am getting a TypeError: translate() takes exactly one argument (2 given).</span>
<span class="comment-copy">Thanks Kasra. The processing speed is similar to the picked solution. Definitely food for thought in my next project to further explore str.translate. Cheers!</span>
<span class="comment-copy">I am using large sample files so I feel confident with the proposed solution. Also, just to put everything in context, I'm building a word frequency program and calling 's' again in collections.counter provides a the count of single characters (A-Z) in your case in my output text file.</span>
<span class="comment-copy">@Kasra Your tests are flawed. The string you are using to conduct tests is not representative of the "usual text". It has no upper case, no numbers etc. I tried timing some text from wikipedia; my solution is about 20% faster with some texts, and about 1% faster with other text. However since both of us don't know the actual text used our tests cant be that accurate.</span>
<span class="comment-copy">@Kasra I m not saying my solution is better. I m saying that only the asker could test and get reliable results and determine which one is faster.</span>
