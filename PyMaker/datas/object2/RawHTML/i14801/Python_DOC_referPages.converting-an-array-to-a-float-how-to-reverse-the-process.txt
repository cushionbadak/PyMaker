<div class="post-text" itemprop="text">
<p>Suppose we start with an integer numpy array with integers between 0 and 99, i.e.</p>
<pre><code>x = np.array([[1,2,3,1],[10,5,0,2]],dtype=int)
</code></pre>
<p>Now we want to represent rows in this array with a single unique value. One simple way to do this is representing it as a floating number. An intuitive way to do this is </p>
<pre><code>rescale = np.power(10,np.arange(0,2*x.shape[1],2)[::-1],dtype=float)
codes = np.dot(x,rescale)
</code></pre>
<p>where we exploit that the integers have at most 2 digits. (I'm casting <code>rescale</code> as a float to avoid exceeding the maximum value of int in case the entries of <code>x</code> have more elements; this is not very elegant) </p>
<p>This returns</p>
<pre><code>array([  1020301.,  10050002.])
</code></pre>
<p>How can this process be reversed to obtain <code>x</code> again? </p>
<p>I'm thinking of converting <code>codes</code> to a string, then split the string every 2nd entry. I'm not too familiar with these string operations, especially when they have to be executed on all entries of an array simultaneously. A problem is also that the first number has a varying number of digits, so trailing zeros have to be added in some way. </p>
<p>Maybe something simpler is possible using some divisions or rounding, or perhaps represting the rows of the array in a different manner. Important is that at least the initial conversion is fast and vectorized.</p>
<p>Suggestions are welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you need to find the correct number of columns:</p>
<pre><code>number_of_cols = max(ceil(math.log(v, 100)) for v in codes)
</code></pre>
<p>Note that is your first column is always 0, then there is no way with your code to know it even existed: <code>[[0, 1], [0, 2]] -&gt; [1., 2.] -&gt; [[1], [2]] or [[0, 0, 0, 1], [0, 0, 0, 2]]</code>. It might be something to consider. </p>
<p>Anyways, here is a mockup for the string way:</p>
<pre><code>def decode_with_string(codes):
    number_of_cols = max(ceil(math.log(v, 100)) for v in codes)
    str_format = '{:0%dd}'%(2*number_of_cols) # prepare to format numbers as string
    return [[int(str_format.format(int(code))[2*i:2*i+2]) # extract the wanted digits
             for i in range(number_of_cols)] # for all columns
            for code in codes] # for all rows
</code></pre>
<p>But you can also compute the numbers directly:</p>
<pre><code>def decode_direct(codes):
    number_of_cols = max(ceil(math.log(v, 100)) for v in codes)
    return [[floor(code/(100**index)) % 100
             for index in range(number_of_cols-1, -1, -1)]
            for code in codes]
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; codes = [  1020301.,  10050002.]
&gt;&gt;&gt; number_of_cols = max(ceil(math.log(v, 100)) for v in codes)
&gt;&gt;&gt; print(number_of_cols)
4
&gt;&gt;&gt; print(decode_with_strings(codes))
[[1, 2, 3, 1], [10, 5, 0, 2]]
&gt;&gt;&gt; print(decode_direct(codes))
[[1, 2, 3, 1], [10, 5, 0, 2]]
</code></pre>
<p>Here is a numpy solution:</p>
<pre><code>&gt;&gt;&gt; divisors = np.power(0.01, np.arange(number_of_cols-1, -1, -1))
&gt;&gt;&gt; x = np.mod(np.floor(divisors*codes.reshape((codes.shape[0], 1))), 100)
</code></pre>
<p>Finally, you say you use <code>float</code> in case of overflow of <code>int</code>. First, the mantissa of floating point numbers is also limited, so you don't eliminate the risk of overflow. Second, in Python3, integer actually have <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="nofollow">unlimited precision</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could exploit that Numpy stores its arrays as continuous blocks in memory. So storing the memory-block as binary string and remembering the shape of the array should be sufficient:</p>
<pre><code>import numpy as np

x = np.array([[1,2,3,1],[10,5,0,2]], dtype=np.uint8) # 8 Bit are enough for 2 digits
x_sh = x.shape
# flatten array and convert to binarystring
xs = x.ravel().tostring()

# convert back and reshape:
y = np.reshape(np.fromstring(xs, np.uint8), x_sh)
</code></pre>
<p>The reason for flattening the array first is that you don't need to pay attention to the storage order of 2D arrays (C or FORTRAN order). Of course you also could generate a string for each row separately too:</p>
<pre><code>import numpy as np

x = np.array([[1,2,3,1],[10,5,0,2]], dtype=np.uint8) # 8 Bit are enough for 2 digits

# conversion:
xss = [xr.tostring() for xr in x]

# conversion back:
y = np.array([np.fromstring(xs, np.uint8) for xs in xss])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your numbers are between 0 and 99, you should  rather pad up to 2 digits: 0 becomes "00" , 5 becomes "05" and 50 becomes "50". That way, all you need to do is repeatedly divide your number by 100 and you'll get the values. Your encoding will also be smaller, since every number is encoded in 2 digits instead of 2-3 as you currently do.</p>
<p>If you want to be able to detect [0,0,0] (which is currently undistinguishable from [0] or [O.....O]) as well, add a 1 in front of your number: 1000000 is [0,0,0] and 100 is [0]. When your division returns 1, you know you've finished.</p>
<p>You can easily construct a string with that information and cast it to a number afterwards.</p>
</div>
<span class="comment-copy">You should define rescale using powers of 100 instead of 10, and you can directly reverse the range when creating it instead of after taking the power: <code>rescale = np.power(100, np.arange(x.shape[0]-1, 0, -1), dtype=float)</code>.</span>
<span class="comment-copy">@FrancisColas That's great. Here you would need <code>x.shape[1]</code>, btw.</span>
<span class="comment-copy">Yes indeed, I just copied your <code>x.shape[0]</code>. And that should actually be <code>np.arange(x.shape[1]-1, -1, -1)</code>.</span>
<span class="comment-copy">I'm looking for a solution with numpy which is often faster and easier to read. You are right about the zeros. What I in fact do is add a constant to the numpy array to avoid this.</span>
<span class="comment-copy">I added a numpy solution which is doing the reverse of your encoding.</span>
<span class="comment-copy">Excellent! That works well. I really feel like accepting both answers here, but I guess your answer achieves what I want the most.</span>
<span class="comment-copy">Dietrich's answer is actually proposing a different way to encode your values, whereas I just propose ways to decode as requested. That might just be an instance of the <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>.</span>
<span class="comment-copy">As for your wishes of readability and speed, I would advise you to test the three methods I propose to see which is the fastest (for readability, that's your choice).</span>
<span class="comment-copy">The second method is most useful for me. However, for my program I really need a vectorized version so that I can quickly calculate the strings for an array and compare them with stored strings using np.searchsorted. In fact my <code>x</code> is 2d.</span>
<span class="comment-copy">I'm not sure, I am able to follow you here. When looking for <code>z</code>, does <code>np.searchsorted(xss, z.tostring())</code> not do what you want?</span>
<span class="comment-copy">Yes. But it's using a list comprehension to generate the strings,  which is usually slower than some numpy method applied directly to all vectors.</span>
