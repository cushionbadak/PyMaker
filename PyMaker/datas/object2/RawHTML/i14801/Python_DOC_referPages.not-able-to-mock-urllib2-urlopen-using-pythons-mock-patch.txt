<div class="post-text" itemprop="text">
<p>Below is a code snippet of my api.py module</p>
<pre><code># -*- coding: utf-8 -*-

from urllib2 import urlopen
from urllib2 import Request

class API:

    def call_api(self, url, post_data=None, header=None):
        is_post_request = True if (post_data and header) else False
        response = None
        try:
            if is_post_request:
                url = Request(url = url, data = post_data, headers = header)
            # Calling api
            api_response = urlopen(url)
            response = api_response.read()
        except Exception as err:
            response = err

        return response
</code></pre>
<p>I am trying to mock <code>urllib2.urlopen</code> in <code>unittest</code> of above module. I have written </p>
<pre><code># -*- coding: utf-8 -*-
# test_api.py

from unittest import TestCase
import mock

from api import API

class TestAPI(TestCase):

    @mock.patch('urllib2.Request')
    @mock.patch('urllib2.urlopen')
    def test_call_api(self, urlopen, Request):
        urlopen.read.return_value = 'mocked'
        Request.get_host.return_value = 'google.com'
        Request.type.return_value = 'https'
        Request.data = {}
        _api = API()
        assert _api.call_api('https://google.com') == 'mocked'
</code></pre>
<p>After I run the unittest, I get an exception</p>
<pre><code>&lt;urlopen error unknown url type: &lt;MagicMock name='Request().get_type()' id='159846220'&gt;&gt;
</code></pre>
<p>What am I missing? Please help me out.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are patching the wrong things: take a look to <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch">Where to patch</a>.</p>
<p>In <code>api.py</code> by</p>
<pre><code>from urllib2 import urlopen
from urllib2 import Request
</code></pre>
<p>you create a local reference to <code>urlopen</code> and <code>Request</code> in your file. By <code>mock.patch('urllib2.urlopen')</code> you are patching the original reference and leave the <code>api.py</code>'s one untouched.</p>
<p>So, replace your patches by</p>
<pre><code>@mock.patch('api.Request')
@mock.patch('api.urlopen')
</code></pre>
<p>should fix your issue.... but is not enough.</p>
<p>In your test case <code>api.Request</code> are not used but <code>urllib2.urlopen()</code> create a <code>Request</code> by use the patched version: that is why <code>Request().get_type()</code> is a <code>MagicMock</code>.</p>
<p>For a complete fix you should change your test at all. First the code:</p>
<pre><code>@mock.patch('api.urlopen', autospec=True)
def test_call_api(self, urlopen):
    urlopen.return_value.read.return_value = 'mocked'
    _api = API()
    self.assertEqual(_api.call_api('https://google.com'), 'mocked')
    urlopen.assert_called_with('https://google.com')
</code></pre>
<p>Now the clarification... In your test you don't call <code>Request()</code> because you pass just the first parameter, so I've removed useless patch. Moreover you are patching <code>urlopen</code> function and not <code>urlopen</code> object, that means the <code>read()</code> method you want mocked is a method of the object return by <code>urlopen()</code> call.</p>
<p>Finally I add a check on <code>urlopen</code> call and <a href="https://docs.python.org/3/library/unittest.mock.html#autospeccing"><code>autospec=True</code></a> that is always a good practice.</p>
</div>
<span class="comment-copy">I made the changes. The value of <code>_api.call_api('https://google.com')</code>  is <code>&lt;MagicMock name='urlopen().read()' id='3069563372'&gt;</code> which doesn't match "mocked". Why? P.S. I have updated last line with <code>assert</code> in test_api.py</span>
<span class="comment-copy">I should rewrite your test.... Too much details are wrong.</span>
<span class="comment-copy">@Hussain now it should be OK</span>
<span class="comment-copy">Yes. Thanks a lot. Great insight on mock patching. I guess I can make some changes and make it work for <code>requests</code> too</span>
