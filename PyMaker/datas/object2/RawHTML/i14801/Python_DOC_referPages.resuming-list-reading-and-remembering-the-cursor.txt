<div class="post-text" itemprop="text">
<p>I'm trying to make a list temporarily unreadable when a flag is set to <code>False</code>. That is, reading the list when the flag is <code>False</code> gives no value (as if it was empty or the list is already exhausted). Once it's set back to <code>True</code>, the list becomes readable again and the cursor continues from where it last stopped. My current implementation resumes reading, but doesn't remember where the cursor previously was. Does anyone know how to change it? I know I could have a variable keeping track of where the cursor is/was, but is there a more elegant way?</p>
<pre><code>items = range(0, 5)
flag = True

def values():
    for v in items:
        while not flag:
            yield None
        yield v

def read():
    for i in values():
        if i is None:
            return
        yield i

def run():
    global flag
    # should print just 0 1 2, as flag is False when i == 2
    for i in read():
        if i == 2:
            flag = False
        print i

    print "flip!"

    # should print just 3 4, as the previous cursor position should be used
    flag = True
    for i in read():
        print i

run() # outputs 0 1 2 flip 0 1 2 3 4 rather than the expected 0 1 2 flip 3 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot do what you want with the generator; generators are specialised iterators, and iterators can only be iterated over <em>once</em>. Once they are exhausted (<code>StopIterator</code> has been raised), they cannot yield more items. </p>
<p>Your code on the other hand expects <code>StopIteration</code> to be raised (the first loop ends), and then a second loop continues to iterate again.</p>
<p>Instead of handling this in the generator, <em>simply stop iterating</em>. Create the generator <strong>once</strong>, then use it in both loops:</p>
<pre><code>def run():
    iterator = read()
    for i in iterator:
        print i
        if i == 2:
            break   # stop iterating

    print 'flip'

    # resume iterating
    for i in iterator:
        print i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your first loop works fine,you can add <code>print "**********"</code> after your first <code>for</code> loop!to see the result.</p>
<p>But for second loop you have a miss understanding, because in second loop you cant iterate over your list from that part you have convert <code>falg</code> to <code>False</code>! the second loop will began from start,so you can save the index of the last element in first loop to <code>indx</code> variable and pass it to your function : </p>
<pre><code>items = range(0, 5)
flag = True

def values(indx):
    for v in items[indx:]:
        while not flag:
            yield None
        yield v

def read(indx=0):
    for i in values(indx):
        if i is None:
            return
        yield i

def run():
    global flag
    global indx
    # should print just 0 1 2
    for i,j in enumerate(read(),1):
        if j == 2:
            flag = False
            indx=i
        print j
    print "**********"

    # should print just 3 4
    flag = True
    for i in read(indx):
        print i
    print '********'
run() 
</code></pre>
<p>result :</p>
<pre><code>0
1
2
**********
3
4
********
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To do this would be fundamentally broken <a href="https://docs.python.org/2/library/stdtypes.html#iterator.next" rel="nofollow">according the Python's iterator protocol</a>:</p>
<blockquote>
<p>The intention of the protocol is that once an iteratorâ€™s next() method raises StopIteration, it will continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken. </p>
</blockquote>
<p>What you should do is make this a class and store the index as an instance variable. This way you do not have to pass in arguments or rely on a global variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may find the generator below of interest. Using a generator's <code>send()</code> method we can send data back to the generator. See <a href="https://docs.python.org/2/reference/expressions.html#yield-expressions" rel="nofollow">Yield expressions</a> in the Python docs for further info on this feature. (The Python 3 version of that doc is <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="nofollow">here</a>).</p>
<pre><code>#!/usr/bin/env python

def latched_iter(iterable):
    ''' Yield items from iterable only when latch is True '''
    latch = False
    while True:
        latch = yield iterable.next() if latch else None


def main():
    gen = latched_iter(iter('abcdefghijklmnop'))
    gen.send(None)

    for i in xrange(25):
        try:
            val = gen.send(i &lt; 5 or i &gt;= 10)
        except StopIteration:
            break
        print i, val


if __name__ == '__main__':
    main()
</code></pre>
<p><strong>output</strong></p>
<pre><code>0 a
1 b
2 c
3 d
4 e
5 None
6 None
7 None
8 None
9 None
10 f
11 g
12 h
13 i
14 j
15 k
16 l
17 m
18 n
19 o
20 p
</code></pre>
</div>
<span class="comment-copy">Can you explain that what you mean by <i>readable</i> exactly?</span>
<span class="comment-copy">@Kasra As in, <code>read()</code> returns as if the list is exhausted <code>flag</code> is False. If <code>flag</code> is <code>True</code>, <code>read()</code> returns the next element. Hope this makes it clearer.</span>
<span class="comment-copy">You basically want to replace the rest of the iteration <i>count</i> by <code>None</code> values? So your iterator normally produces 5 values, when you set the flag you need to yield (5 - already_yielded_count) times <code>None</code>, then yield the 'unyielded' numbers when the flag is toggled again but you started iterating again? You <b>can't do that</b>, because once you ended an iterator you cannot use it again.</span>
<span class="comment-copy">In other words, once <code>StopIteration</code> has been raised your iterator is not supposed to start yielding again. Ever.</span>
<span class="comment-copy">What problem are you trying to solve here? Wouldn't simply <i>not iterating for a while</i> when you reach the flag condition be better?</span>
