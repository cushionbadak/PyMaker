<div class="post-text" itemprop="text">
<p>I have an class that can be constructed via alternative constructors using class methods.</p>
<pre><code>class A:

    def __init__(self, a, b):
            self.a = a
            self.b = b

    @classmethod
    def empty(cls, b):
        return cls( 0 , b)
</code></pre>
<p>So let's say instead of constructing <code>A</code> like <code>A()</code> I can now also do <code>A.empty()</code>. </p>
<p>For user convenience, I would like to extend this <code>empty</code> method even further, so that I can initialize <code>A</code> via <code>A.empty()</code> as well as the more specialized but closely-related <code>A.empty.typeI()</code> and <code>A.empty.typeII()</code>.</p>
<p>My naive approach did not quite do what I wanted:</p>
<pre><code>class A:

    def __init__(self, a, b):
            self.a = a
            self.b = b

    @classmethod
    def empty(cls, b):

        def TypeI(b):
            return cls( 0 , b-1)

        def TypeII(b):
            return cls( 0 , b-2)

        return cls( 0 , b)
</code></pre>
<p>Can anyone tell me how that could be done (or at least convince me why that would be terrible idea). I want to stress that for usage I imagine such an approach to be very convenient and clear for the users as the functions are grouped intuitively.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can implement what you want by making <code>Empty</code> a nested class of <code>A</code> rather than a class method. More than anything else this provides a convenient namespace — instances of it are never created — in which to place various alternative constructors and can easily be extended.</p>
<pre><code>class A(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __repr__(self):
        return 'A({}, {})'.format(self.a, self.b)

    class Empty(object):  # nested class
        def __new__(cls, b):
            return A(0, b)  # ignore cls &amp; return instance of enclosing class

        @staticmethod
        def TypeI(b):
            return A(0, b-1)

        @staticmethod
        def TypeII(b):
            return A(0, b-2)

a = A(1, 1)
print('a: {}'.format(a))      # --&gt; a: A(1, 1)
b = A.Empty(2)
print('b: {}'.format(b))      # --&gt; b: A(0, 2)
bi = A.Empty.TypeI(4)
print('bi: {}'.format(bi))    # --&gt; bi: A(0, 3)
bii = A.Empty.TypeII(6)
print('bii: {}'.format(bii))  # --&gt; bii: A(0, 4)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can’t really do that because <code>A.empty.something</code> would require the underlying method object to be bound to the type, so you can actually call it. And Python simply won’t do that because the type’s member is <code>empty</code>, not <code>TypeI</code>.</p>
<p>So what you would need to do is to have some object <code>empty</code> (for example a <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow">SimpleNamespace</a>) in your type which returns <em>bound</em> classmethods. The problem is that we cannot yet access the type as we define it with the <code>class</code> structure. So we cannot access its members to set up such an object. Instead, we would have to do it afterwards:</p>
<pre><code>class A:
    def __init__ (self, a, b):
        self.a = a
        self.b = b

    @classmethod
    def _empty_a (cls, b):
        return cls(1, b)

    @classmethod
    def _empty_b (cls, b):
        return cls(2, b)

A.empty = SimpleNamespace(a = A._empty_a, b = A._empty_b)
</code></pre>
<p>Now, you can access that member’s items and get bound methods:</p>
<pre><code>&gt;&gt;&gt; A.empty.a
&lt;bound method type._empty_a of &lt;class '__main__.A'&gt;&gt;
&gt;&gt;&gt; A.empty.a('foo').a
1
</code></pre>
<p>Of course, that isn’t really that pretty. Ideally, we want to set this up when we define the type. We could use meta classes for this but we can actually solve this easily using a class decorator. For example this one:</p>
<pre><code>def delegateMember (name, members):
    def classDecorator (cls):
        mapping = { m: getattr(cls, '_' + m) for m in members }
        setattr(cls, name, SimpleNamespace(**mapping))
        return cls
    return classDecorator

@delegateMember('empty', ['empty_a', 'empty_b'])
class A:
    def __init__ (self, a, b):
        self.a = a
        self.b = b

    @classmethod
    def _empty_a (cls, b):
        return cls(1, b)

    @classmethod
    def _empty_b (cls, b):
        return cls(2, b)
</code></pre>
<p>And magically, it works:</p>
<pre><code>&gt;&gt;&gt; A.empty.empty_a
&lt;bound method type._empty_a of &lt;class '__main__.A'&gt;&gt;
</code></pre>
<hr/>
<p>Now that we got it working somehow, of course we should discuss whether this is actually something you want to do. My opinion is that you shouldn’t. You can already see from the effort it took that this isn’t something that’s usually done in Python. And that’s already a good sign that you shouldn’t do it. <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow"><em>Explicit is better than implicit</em></a>, so it’s probably a better idea to just expect your users to type the full name of the class method. My example above was of course structured in a way that <code>A.empty.empty_a</code> would have been longer than just a <code>A.empty_a</code>. But even with your name, there isn’t a reason why it couldn’t be just an underscore instead of a dot.</p>
<p>And also, you can simply add multiple default paths inside a single method. Provide default argument values, or use sensible fallbacks, and you probably don’t need many class methods to create alternative versions of your type.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is generally better to have uniform class interfaces, meaning the different usages should be consistent with each other. I consider <code>A.empty()</code> and <code>A.empty.type1()</code> to be <em>inconsistent</em> with each other, because the prefix <code>A.empty</code> ituitively means different things in each of them.</p>
<p>A better interface would be:</p>
<pre><code>class A:
    @classmethod
    def empty_default(cls, ...): ...
    @classmethod
    def empty_type1(cls, ...): ...
    @classmethod
    def empty_type2(cls, ...): ...
</code></pre>
<p>Or:</p>
<pre><code>class A:
    @classmethod
    def empty(cls, empty_type, ...): ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an enhanced implementation of my <a href="https://stackoverflow.com/a/29261762/355230">other answer</a> that makes it — as one commenter put it —  "play well with inheritance". You may not need this, but others doing something similar might.</p>
<p>It accomplishes this by using a <a href="https://docs.python.org/2/reference/datamodel.html?highlight=metaclass#customizing-class-creation" rel="nofollow noreferrer">metaclass</a> to dynamically create and add an nested <code>Empty</code> class similar to that shown in the other answer. The main difference is that the default <code>Empty</code> class in derived classes will now return <code>Derived</code> instances instead of instances of <code>A</code>, the base class.</p>
<p>Derived classes can override this default behavior by defining their own nested <code>Empty</code> class (it can even be derived from the one in the one in the  base class). Also note that for Python 3, metaclasses are specified using different syntax:</p>
<pre><code>class A(object, metaclass=MyMetaClass):
</code></pre>
<p>Here's the revised implementation using Python 2 metaclass syntax:</p>
<pre><code>class MyMetaClass(type):
    def __new__(metaclass, name, bases, classdict):
        # create the class normally
        MyClass = super(MyMetaClass, metaclass).__new__(metaclass, name, bases,
                                                        classdict)
        # add a default nested Empty class if one wasn't defined
        if 'Empty' not in classdict:
            class Empty(object):
                def __new__(cls, b):
                    return MyClass(0, b)

                @staticmethod
                def TypeI(b):
                    return MyClass(0, b-1)

                @staticmethod
                def TypeII(b):
                    return MyClass(0, b-2)
            setattr(MyClass, 'Empty', Empty)
        return MyClass

class A(object):
    __metaclass__ = MyMetaClass
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __repr__(self):
        return '{}({}, {})'.format(self.__class__.__name__, self.a, self.b)

a = A(1, 1)
print('a: {}'.format(a))      # --&gt; a: A(1, 1)
b = A.Empty(2)
print('b: {}'.format(b))      # --&gt; b: A(0, 2)
bi = A.Empty.TypeI(4)
print('bi: {}'.format(bi))    # --&gt; bi: A(0, 3)
bii = A.Empty.TypeII(6)
print('bii: {}'.format(bii))  # --&gt; bii: A(0, 4)
</code></pre>
<p>With the above, you can now do something like this:</p>
<pre><code>class Derived(A):
    pass  # inherits everything, except it will get a custom Empty

d = Derived(1, 2)
print('d: {}'.format(d))      # --&gt; d: Derived(1, 2)
e = Derived.Empty(3)
print('e: {}'.format(e))      # --&gt; e: Derived(0, 3)
ei = Derived.Empty.TypeI(5)
print('ei: {}'.format(ei))    # --&gt; ei: Derived(0, 4)
eii = Derived.Empty.TypeII(7)
print('eii: {}'.format(eii))  # --&gt; eii: Derived(0, 5)
</code></pre>
</div>
<span class="comment-copy">This doesn't make sense syntactically - <code>A.empty.typeI()</code> would call an <i>attribute</i> of the classmethod object, not a nested function (which, by design, is inaccessible from outside the method).</span>
<span class="comment-copy">While this is cool, it is worth pointing out this does not play well with inheritence, while <code>@classmethod</code> constructors usually do (by returning <code>cls(...)</code> instead of the explicit class they are defined in)</span>
<span class="comment-copy">@shx2: My answer was meant to show how to do what the OP wanted to accomplish as simply as possible. Please define what exactly you mean by "playing well" with inheritance. If that's for its methods to return instances of the derived class instead of <code>A</code>, one way to accomplish that would be for it to simply define its own nested <code>Empty</code> class. It might be possible to make that automatic by using a metaclass—and I considered doing it—but felt it was beyond the scope of the question.</span>
<span class="comment-copy">@shx2: I've added <a href="http://stackoverflow.com/a/30244299/355230">another answer</a> that addresses the inheritance issue.</span>
