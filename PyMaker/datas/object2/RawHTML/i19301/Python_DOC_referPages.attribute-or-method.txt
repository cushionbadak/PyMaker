<div class="post-text" itemprop="text">
<p>I am writing a python script which calculates various quantities based on two parameters, the long radius and short radius of a spheroid. It occurred to me that I could write a spheroid class to do this. However, I'm new to object oriented design and wonder if you more experienced chaps can help me. </p>
<p>An instance is instantiated with parameters a and b for the long radius and short radius respectively, so I've designed the class as follows: </p>
<pre><code>class Spheroid:
  def __init__(self,a,b):
    self.longax  = a
    self.shortax = b
</code></pre>
<p>One of the quantities I want to calculate is the volume. The volume of a spheroid is 4*pi/3 * a * b * b.</p>
<p>My question is, do I define a method or an attribute for this in my class? </p>
<p>e.g. I could define a method:</p>
<pre><code>def Volume(self):
  return 4*pi/3 * self.longax * self.shortax * self.shortax
</code></pre>
<p>or I could just use an attribute:</p>
<pre><code>self.volume = 4*pi/3 * self.longax * self.shortax * self.shortax
</code></pre>
<p>I could also just include it in the init method:</p>
<pre><code>class Spheroid:
  def __init__(self,a,b):
    self.longax  = a
    self.shortax = b
    self.volume = 4*pi/3 * a * b * b.
</code></pre>
<p>Which is better to use and why? In general, when would I use a method and when would I use an attribute? I wouldn't normally care but I have a whole load of these to implement and I'd like to have an idea about OO design for future reference. </p>
<p>Thanks</p>
<p>EDIT:</p>
<p>After implementing properties as per Martijn's suggestion, I ended up with something like this:</p>
<pre><code>class Spheroid(object):
  def __init__(self,a,b):
    self.shortax = a
    self.longax  = b
    self.alpha=self.longax/self.shortax

    @property
    def volume(self):
        return (4*np.pi/3) * self.shortax * self.shortax * self.longax

    @property
    def epsilon(self):
        return np.sqrt(1-self.alpha**(-2))

    @property
    def geometricaspect(self):
        return 0.5 + np.arcsin(self.epsilon)*0.5*self.alpha/self.epsilon

    @property
    def surfacearea(self):
        return 4*np.pi*self.shortax**2*self.geometricaspect
</code></pre>
<p>I instantiated an instance s = Spheroid() but whenever I try something like s.volume or s.epsilon I get an AttributeError:</p>
<p>AttributeError: 'Spheroid' object has no attribute 'volume'</p>
<p>What am I doing wrong here?</p>
<p>Also, in my <strong>init</strong> method I used self.alpha = self.longax/self.shortax instead of a/b, does this make any difference? Is one way preferable?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a 3rd option: make it both an attribute and a method, by using a <a href="http://docs.python.org/3/library/functions.html#property" rel="nofollow">property</a>:</p>
<pre><code>class Spheroid(object):
    def __init__(self, a, b):
        self.long  = a
        self.short = b

    @property
    def volume(self):
        return 4 * pi / 3 * self.long * self.short * self.short
</code></pre>
<p>You access <code>.volume</code> like an attribute:</p>
<pre><code>&gt;&gt;&gt; s = Spheroid(2, 3)
&gt;&gt;&gt; s.volume
75.39822368615503
</code></pre>
<p>In order for the <code>property</code> descriptor to work correctly, in Python 2 you need to make sure your class inherits from <code>object</code>; in Python 3 the baseclass can be safely omitted.</p>
<p>In this case, the calculation of the volume is cheap enough, but a property lets you <em>postpone</em> having to calculate the volume until you actually need it.</p>
<p>The above example creates a read-only property; only a getter is defined:</p>
<pre><code>&gt;&gt;&gt; s.volume = None
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre>
<p>You could easily cache the result of the property calculation:</p>
<pre><code>class Spheroid(object):
    _volume = None

    def __init__(self, a, b):
        self.long  = a
        self.short = b

    @property
    def volume(self):
        if self._volume is None:
            self._volume = 4 * pi / 3 * self.long * self.short * self.short
        return self._volume
</code></pre>
<p>so that you only have to calculate it <em>once</em> per <code>Spheroid</code> instance.</p>
<p>What you use depends on many factors; how easy does your API need to be to use, how often will the volume be calculated, how <em>many</em> Spheroid instances will be created, etc. If you create a million of these in a loop but only ever need the volume for a handfull of them, it makes sense to use a property instead of setting the volume in the <code>__init__</code>.</p>
<p>If, however, your class could <em>adjust</em> itself based on the volume; say, by adjusting one of the radii automatically, then a <code>@property</code> makes more sense still:</p>
<pre><code>class Spheroid(object):
    def __init__(self, a, b):
        self.long  = a
        self.short = b

    @property
    def volume(self):
        return 4 * pi / 3 * self.long * self.short * self.short

    @volume.setter
    def volume(self, newvolume):
        # adjust the short radius
        self.short = sqrt(newvolume / (4 * pi / 3 * self.long))
</code></pre>
<p><em>Now</em> you have a spheroid which naturally adjusts it's short attribute as you adjust the volume:</p>
<pre><code>&gt;&gt;&gt; s = Spheroid(2, 1)
&gt;&gt;&gt; s.volume
8.377580409572781
&gt;&gt;&gt; s.volume = 75.39822368615503
&gt;&gt;&gt; s.long, s.short
(2, 3.0)
</code></pre>
<p>Note: technically, <em>anything</em> you access on an object with <code>.name</code> notation is an attribute; methods included. For the purpose of this answer, I used your <code>attribute</code> as any value that is not called (doesn't use <code>()</code> after the name).</p>
</div>
<div class="post-text" itemprop="text">
<p>will you always use this data?</p>
<p>if not, you could use a property and then lazily compute it...</p>
<pre><code>class Spheroid(object):
  def __init__(self,a,b):
    self.longax  = a
    self.shortax = b
    self._volume = None

  @property
  def volume(self):
      if self._volume is None :
           self._volume = 4*pi/3 * self.longax * self.shortax * self.shortax
      return self._volume
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would implement volume as a method because of the following:</p>
<ol>
<li>it can be computed from other attributes, so it saves space to compute it (unless this is very complicated computation and than you can consider caching it)</li>
<li>it is not a natural "feature" of the object, for example for circle the radius is an attribute but not the area (this is not really format definition)</li>
<li>Something like volume is kind of abstract method, if you want to have family of objects and compute the volume for each of them in polymorphic way.</li>
</ol>
</div>
<span class="comment-copy">Excellent question. Note this the tradeoffs are language dependent. One answer might be obvious in C++ with a different answer in Python.</span>
<span class="comment-copy">damnit beat me to it.</span>
<span class="comment-copy">You might want to mention that another benefit of this is that <code>volume</code> is "read-only" as well.</span>
<span class="comment-copy">i included caching with my answer though...</span>
<span class="comment-copy">@JonathanVanasco: That is the next step; it is not a requirement :-)</span>
<span class="comment-copy">Hi Martijn, thanks for your post.   Can you explain why defining a property is better than just using a method? With a method, I would also delay the calculation of the volume until I call the method, no?</span>
<span class="comment-copy">If you change <code>self._volume = ...</code> to <code>self.volume = ...</code>, then you avoid subsequent function calls.</span>
<span class="comment-copy">@Robᵩ In Python2.7, which I use, it raises an AttributeError.  [ and I've wished so often that I could do that ]</span>
<span class="comment-copy">@Robᵩ: No, you cannot. Data descriptors (like a property) are first looked up on the class and cannot be replaced by a instance attribute.</span>
<span class="comment-copy">You are both correct, I was wrong. I tested with old-style classes, which test wasn't valid. Thanks.</span>
<span class="comment-copy">Can you elaborate on the "saves space" argument?</span>
<span class="comment-copy">if you save it as field, you have an extra integer per object</span>
