<div class="post-text" itemprop="text">
<p>What is the most efficient way to shift a list in python? 
Right now I have something like this:</p>
<pre><code>&gt;&gt;&gt; def shift(l, n):
...     return l[n:] + l[:n]
... 
&gt;&gt;&gt; l = [1,2,3,4]
&gt;&gt;&gt; shift(l,1)
[2, 3, 4, 1]
&gt;&gt;&gt; shift(l,2)
[3, 4, 1, 2]
&gt;&gt;&gt; shift(l,0)
[1, 2, 3, 4]
&gt;&gt;&gt; shift(l,-1)
[4, 1, 2, 3]
</code></pre>
<p>Is there a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="http://docs.python.org/library/collections.html#deque-objects" rel="noreferrer"><code>collections.deque</code></a> is optimized for pulling and pushing on both ends. They even have a dedicated <code>rotate()</code> method. </p>
<pre><code>from collections import deque
items = deque([1, 2])
items.append(3)        # deque == [1, 2, 3]
items.rotate(1)        # The deque is now: [3, 1, 2]
items.rotate(-1)       # Returns deque to original state: [1, 2, 3]
item = items.popleft() # deque == [2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about just using <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="noreferrer"><code>pop(0)</code></a>?</p>
<blockquote>
<p><code>list.pop([i])</code></p>
<p>Remove the item at the given position in the list, and return it. If
  no index is specified, <code>a.pop()</code> removes and returns the last item in
  the list. (The square brackets around the <code>i</code> in the method signature
  denote that the parameter is optional, not that you should type square
  brackets at that position. You will see this notation frequently in
  the Python Library Reference.)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Numpy can do this using the <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.roll.html#numpy.roll"><code>roll</code></a> command:</p>
<pre><code>&gt;&gt;&gt; import numpy
&gt;&gt;&gt; a=numpy.arange(1,10) #Generate some data
&gt;&gt;&gt; numpy.roll(a,1)
array([9, 1, 2, 3, 4, 5, 6, 7, 8])
&gt;&gt;&gt; numpy.roll(a,-1)
array([2, 3, 4, 5, 6, 7, 8, 9, 1])
&gt;&gt;&gt; numpy.roll(a,5)
array([5, 6, 7, 8, 9, 1, 2, 3, 4])
&gt;&gt;&gt; numpy.roll(a,9)
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what you want to have happen when you do this:</p>
<pre><code>&gt;&gt;&gt; shift([1,2,3], 14)
</code></pre>
<p>You might want to change your:</p>
<pre><code>def shift(seq, n):
    return seq[n:]+seq[:n]
</code></pre>
<p>to:</p>
<pre><code>def shift(seq, n):
    n = n % len(seq)
    return seq[n:] + seq[:n]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want to iterate over these sets of elements rather than construct a separate data structure, consider using iterators to construct a generator expression:</p>
<pre><code>def shift(l,n):
    return itertools.islice(itertools.cycle(l),n,n+len(l))

&gt;&gt;&gt; list(shift([1,2,3],1))
[2, 3, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simplest way I can think of:                                        </p>
<pre><code>a.append(a.pop(0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This also depends on if you want to shift the list in place (mutating it), or if you want the function to return a new list.  Because, according to my tests, something like this is at least twenty times faster than your implementation that adds two lists:</p>
<pre><code>def shiftInPlace(l, n):
    n = n % len(l)
    head = l[:n]
    l[:n] = []
    l.extend(head)
    return l
</code></pre>
<p>In fact, even adding a <code>l = l[:]</code> to the top of that to operate on a copy of the list passed in is still twice as fast.</p>
<p>Various implementations with some timing at <a href="http://gist.github.com/288272" rel="noreferrer">http://gist.github.com/288272</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Just some notes on timing:</p>
<p>If you're starting with a list, <code>l.append(l.pop(0))</code> is the fastest method you can use. This can be shown with time complexity alone:</p>
<ul>
<li>deque.rotate is <strong>O(k)</strong> (k=number of elements)</li>
<li>list to deque conversion is <strong>O(n)</strong></li>
<li>list.append and list.pop are both <strong>O(1)</strong></li>
</ul>
<p>So if you are starting with <code>deque</code> objects, you can <code>deque.rotate()</code> at the cost of O(k). But, if the starting point is a list, the time complexity of using <code>deque.rotate()</code> is O(n). <code>l.append(l.pop(0)</code> is faster at O(1).</p>
<p>Just for the sake of illustration, here are some sample timings on 1M iterations:</p>
<p>Methods which require type conversion:</p>
<ul>
<li><code>deque.rotate</code> with deque object: <strong>0.12380790710449219 seconds</strong> (fastest)</li>
<li><code>deque.rotate</code> with type conversion: <strong>6.853878974914551 seconds</strong></li>
<li><code>np.roll</code> with nparray: <strong>6.0491721630096436 seconds</strong></li>
<li><code>np.roll</code> with type conversion: <strong>27.558452129364014 seconds</strong></li>
</ul>
<p>List methods mentioned here:</p>
<ul>
<li><code>l.append(l.pop(0))</code>: <strong>0.32483696937561035 seconds</strong> (fastest)</li>
<li>"<code>shiftInPlace</code>": <strong>4.819645881652832 seconds</strong></li>
<li>...</li>
</ul>
<p>Timing code used is below.</p>
<hr/>
<h2>collections.deque</h2>
<p>Showing that creating deques from lists is O(n):</p>
<pre><code>from collections import deque
import big_o

def create_deque_from_list(l):
     return deque(l)

best, others = big_o.big_o(create_deque_from_list, lambda n: big_o.datagen.integers(n, -100, 100))
print best

# --&gt; Linear: time = -2.6E-05 + 1.8E-08*n
</code></pre>
<p>If you need to create deque objects:</p>
<p>1M iterations @ 6.853878974914551 seconds</p>
<pre><code>setup_deque_rotate_with_create_deque = """
from collections import deque
import random
l = [random.random() for i in range(1000)]
"""

test_deque_rotate_with_create_deque = """
dl = deque(l)
dl.rotate(-1)
"""
timeit.timeit(test_deque_rotate_with_create_deque, setup_deque_rotate_with_create_deque)
</code></pre>
<p>If you already have deque objects:</p>
<p>1M iterations @ 0.12380790710449219 seconds</p>
<pre><code>setup_deque_rotate_alone = """
from collections import deque
import random
l = [random.random() for i in range(1000)]
dl = deque(l)
"""

test_deque_rotate_alone= """
dl.rotate(-1)
"""
timeit.timeit(test_deque_rotate_alone, setup_deque_rotate_alone)
</code></pre>
<h2>np.roll</h2>
<p>If you need to create nparrays</p>
<p>1M iterations @ 27.558452129364014 seconds</p>
<pre><code>setup_np_roll_with_create_npa = """
import numpy as np
import random
l = [random.random() for i in range(1000)]
"""

test_np_roll_with_create_npa = """
np.roll(l,-1) # implicit conversion of l to np.nparray
"""
</code></pre>
<p>If you already have nparrays:</p>
<p>1M iterations @ 6.0491721630096436 seconds</p>
<pre><code>setup_np_roll_alone = """
import numpy as np
import random
l = [random.random() for i in range(1000)]
npa = np.array(l)
"""

test_roll_alone = """
np.roll(npa,-1)
"""
timeit.timeit(test_roll_alone, setup_np_roll_alone)
</code></pre>
<h2>"Shift in place"</h2>
<p>Requires no type conversion</p>
<p>1M iterations @ 4.819645881652832 seconds</p>
<pre><code>setup_shift_in_place="""
import random
l = [random.random() for i in range(1000)]
def shiftInPlace(l, n):
    n = n % len(l)
    head = l[:n]
    l[:n] = []
    l.extend(head)
    return l
"""

test_shift_in_place="""
shiftInPlace(l,-1)
"""

timeit.timeit(test_shift_in_place, setup_shift_in_place)
</code></pre>
<h2>l.append(l.pop(0))</h2>
<p>Requires no type conversion</p>
<p>1M iterations @ 0.32483696937561035</p>
<pre><code>setup_append_pop="""
import random
l = [random.random() for i in range(1000)]
"""

test_append_pop="""
l.append(l.pop(0))
"""
timeit.timeit(test_append_pop, setup_append_pop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For an immutable implementation, you could use something like this:</p>
<pre><code>def shift(seq, n):
    shifted_seq = []
    for i in range(len(seq)):
        shifted_seq.append(seq[(i-n) % len(seq)])
    return shifted_seq

print shift([1, 2, 3, 4], 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I also got interested in this and compared some of the suggested solutions with <a href="https://github.com/nschloe/perfplot" rel="nofollow noreferrer">perfplot</a> (a small project of mine).</p>
<p>It turns out that</p>
<pre><code>for _ in range(n):
    data.append(data.pop(0))
</code></pre>
<p>is <em>by far</em> the fastest method for small shifts <code>n</code>.</p>
<p>For larger <code>n</code>, </p>
<pre><code>data[n:] + data[:n]
</code></pre>
<p>isn't bad.</p>
<p>Essentially, perfplot performs the shift for increasing large arrays and measures the time. Here are the results:</p>
<p><code>shift = 1</code>:</p>
<p><a href="https://i.stack.imgur.com/NieCa.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/NieCa.png"/></a></p>
<p><code>shift = 100</code>:</p>
<p><a href="https://i.stack.imgur.com/RJWNR.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/RJWNR.png"/></a></p>
<hr/>
<p>Code to reproduce the plot:</p>
<pre><code>import numpy
import perfplot
import collections


shift = 100


def list_append(data):
    return data[shift:] + data[:shift]


def shift_concatenate(data):
    return numpy.concatenate([data[shift:], data[:shift]])


def roll(data):
    return numpy.roll(data, -shift)


def collections_deque(data):
    items = collections.deque(data)
    items.rotate(-shift)
    return items


def pop_append(data):
    for _ in range(shift):
        data.append(data.pop(0))
    return data


perfplot.save(
    "shift100.png",
    setup=lambda n: numpy.random.rand(n).tolist(),
    kernels=[list_append, roll, shift_concatenate, collections_deque, pop_append],
    n_range=[2 ** k for k in range(7, 20)],
    logx=True,
    logy=True,
    xlabel="len(data)",
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Possibly a ringbuffer is more suitable. It is not a list, although it is likely that it can behave enough like a list for your purposes.</p>
<p>The problem is that the efficiency of a shift on a list is O(n), which becomes significant for large enough lists.</p>
<p>Shifting in a ringbuffer is simply updating the head location which is O(1)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are looking for this:</p>
<pre><code>a.insert(0, x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If efficiency is your goal, (cycles? memory?) you may be better off looking at the array module: <a href="http://docs.python.org/library/array.html" rel="nofollow noreferrer">http://docs.python.org/library/array.html</a></p>
<p>Arrays do not have the overhead of lists.  </p>
<p>As far as pure lists go though, what you have is about as good as you can hope to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another alternative:</p>
<pre><code>def move(arr, n):
    return [arr[(idx-n) % len(arr)] for idx,_ in enumerate(arr)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I take this cost model as a reference:</p>
<p><a href="http://scripts.mit.edu/~6.006/fall07/wiki/index.php?title=Python_Cost_Model" rel="nofollow">http://scripts.mit.edu/~6.006/fall07/wiki/index.php?title=Python_Cost_Model</a></p>
<p>Your method of slicing the list and concatenating two sub-lists are linear-time operations. I would suggest using pop, which is a constant-time operation, e.g.:</p>
<pre><code>def shift(list, n):
    for i in range(n)
        temp = list.pop()
        list.insert(0, temp)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know if this is 'efficient', but it also works:</p>
<pre><code>x = [1,2,3,4]
x.insert(0,x.pop())
</code></pre>
<p>EDIT: Hello again, I just found a big problem with this solution!
Consider the following code:</p>
<pre><code>class MyClass():
    def __init__(self):
        self.classlist = []

    def shift_classlist(self): # right-shift-operation
        self.classlist.insert(0, self.classlist.pop())

if __name__ == '__main__':
    otherlist = [1,2,3]
    x = MyClass()

    # this is where kind of a magic link is created...
    x.classlist = otherlist

    for ii in xrange(2): # just to do it 2 times
        print '\n\n\nbefore shift:'
        print '     x.classlist =', x.classlist
        print '     otherlist =', otherlist
        x.shift_classlist() 
        print 'after shift:'
        print '     x.classlist =', x.classlist
        print '     otherlist =', otherlist, '&lt;-- SHOULD NOT HAVE BIN CHANGED!'
</code></pre>
<p>The shift_classlist() method executes the same code as my x.insert(0,x.pop())-solution, otherlist is a list indipendent from the class. After passing the content of otherlist to the MyClass.classlist list, calling the shift_classlist() also changes the otherlist list:</p>
<p>CONSOLE OUTPUT:</p>
<pre><code>before shift:
     x.classlist = [1, 2, 3]
     otherlist = [1, 2, 3]
after shift:
     x.classlist = [3, 1, 2]
     otherlist = [3, 1, 2] &lt;-- SHOULD NOT HAVE BIN CHANGED!



before shift:
     x.classlist = [3, 1, 2]
     otherlist = [3, 1, 2]
after shift:
     x.classlist = [2, 3, 1]
     otherlist = [2, 3, 1] &lt;-- SHOULD NOT HAVE BIN CHANGED!
</code></pre>
<p>I use Python 2.7. I don't know if thats a bug, but I think it's more likely that I missunderstood something here.</p>
<p>Does anyone of you know why this happens?</p>
</div>
<div class="post-text" itemprop="text">
<p>The following method is O(n) in place with constant auxiliary memory:</p>
<pre><code>def rotate(arr, shift):
  pivot = shift % len(arr)
  dst = 0
  src = pivot
  while (dst != src):
    arr[dst], arr[src] = arr[src], arr[dst]
    dst += 1
    src += 1
    if src == len(arr):
      src = pivot
    elif dst == pivot:
      pivot = src
</code></pre>
<p>Note that in python, this approach is horribly inefficient compared to others as it can't take advantage of native implementations of any of the pieces.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have similar thing. For example, to shift by two...</p>
<pre><code>def Shift(*args):
    return args[len(args)-2:]+args[:len(args)-2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you've got the most efficient way</p>
<pre><code>def shift(l,n):
    n = n % len(l)  
    return l[-U:] + l[:-U]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a list <code>X = ['a', 'b', 'c', 'd', 'e', 'f']</code> and a desired shift value of <code>shift</code> <strong>less than list length</strong>, we can define the function <code>list_shift()</code> as below</p>
<pre><code>def list_shift(my_list, shift):
    assert shift &lt; len(my_list)
    return my_list[shift:] + my_list[:shift]
</code></pre>
<p>Examples, </p>
<p><code>list_shift(X,1)</code> returns <code>['b', 'c', 'd', 'e', 'f', 'a']</code>
<code>list_shift(X,3)</code> returns <code>['d', 'e', 'f', 'a', 'b', 'c']</code></p>
</div>
<div class="post-text" itemprop="text">
<p>What is the use case? Often, we don't actually need a fully shifted array --we just need to access a handful of elements in the shifted array. </p>
<p>Getting Python slices is runtime O(k) where k is the slice, so a sliced rotation is runtime N. The deque rotation command is also O(k). Can we do better? </p>
<p>Consider an array that is extremely large (let's say, so large it would be computationally slow to slice it). An alternative solution would be to leave the original array alone and simply calculate the index of the item that would have existed in our desired index after a shift of some kind. </p>
<p>Accessing a shifted element thus becomes O(1). </p>
<pre><code>def get_shifted_element(original_list, shift_to_left, index_in_shifted):
    # back calculate the original index by reversing the left shift
    idx_original = (index_in_shifted + shift_to_left) % len(original_list)
    return original_list[idx_original]

my_list = [1, 2, 3, 4, 5]

print get_shifted_element(my_list, 1, 2) ----&gt; outputs 4

print get_shifted_element(my_list, -2, 3) -----&gt; outputs 2 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Following function copies sent list to a templist, so that pop function does not affect the original list: </p>
<pre><code>def shift(lst, n, toreverse=False):
    templist = []
    for i in lst: templist.append(i)
    if toreverse:
        for i in range(n):  templist = [templist.pop()]+templist
    else:
        for i in range(n):  templist = templist+[templist.pop(0)]
    return templist
</code></pre>
<p>Testing: </p>
<pre><code>lst = [1,2,3,4,5]
print("lst=", lst)
print("shift by 1:", shift(lst,1))
print("lst=", lst)
print("shift by 7:", shift(lst,7))
print("lst=", lst)
print("shift by 1 reverse:", shift(lst,1, True))
print("lst=", lst)
print("shift by 7 reverse:", shift(lst,7, True))
print("lst=", lst)
</code></pre>
<p>Output:</p>
<pre><code>lst= [1, 2, 3, 4, 5]
shift by 1: [2, 3, 4, 5, 1]
lst= [1, 2, 3, 4, 5]
shift by 7: [3, 4, 5, 1, 2]
lst= [1, 2, 3, 4, 5]
shift by 1 reverse: [5, 1, 2, 3, 4]
lst= [1, 2, 3, 4, 5]
shift by 7 reverse: [4, 5, 1, 2, 3]
lst= [1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Jon Bentley in <a href="https://books.google.by/books?id=4gX0CwAAQBAJ&amp;pg=PT29&amp;lpg=PT29#v=onepage&amp;q&amp;f=false" rel="nofollow noreferrer">Programming Pearls</a> (Column 2) describes an elegant and efficient algorithm for rotating an <code>n</code>-element vector <code>x</code> left by <code>i</code> positions:</p>
<blockquote>
<p>Let's view the problem as transforming the array <code>ab</code> into the array
  <code>ba</code>, but let's also assume that we have a function that reverses the
  elements in a specified portion of the array. Starting with <code>ab</code>, we
  reverse <code>a</code> to get <code>a<sup>r</sup>b</code>, reverse <code>b</code> to get
  <code>a<sup>r</sup>b<sup>r</sup></code>, and then reverse the whole
  thing to get <code>(a<sup>r</sup>b<sup>r</sup>)<sup>r</sup></code>,
  which is exactly <code>ba</code>. This results in the following code for
  rotation:</p>
<pre><code>reverse(0, i-1)
reverse(i, n-1)
reverse(0, n-1)
</code></pre>
</blockquote>
<p>This can be translated to Python as follows:</p>
<pre><code>def rotate(x, i):
    i %= len(x)
    x[:i] = reversed(x[:i])
    x[i:] = reversed(x[i:])
    x[:] = reversed(x)
    return x
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def rotate(x, i):
...     i %= len(x)
...     x[:i] = reversed(x[:i])
...     x[i:] = reversed(x[i:])
...     x[:] = reversed(x)
...     return x
... 
&gt;&gt;&gt; rotate(list('abcdefgh'), 1)
['b', 'c', 'd', 'e', 'f', 'g', 'h', 'a']
&gt;&gt;&gt; rotate(list('abcdefgh'), 3)
['d', 'e', 'f', 'g', 'h', 'a', 'b', 'c']
&gt;&gt;&gt; rotate(list('abcdefgh'), 8)
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
&gt;&gt;&gt; rotate(list('abcdefgh'), 9)
['b', 'c', 'd', 'e', 'f', 'g', 'h', 'a']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>for similar functionality as shift in other languages:</p>
<pre><code>def shift(l):
    x = l[0]
    del(l[0])
    return x
</code></pre>
</div>
<span class="comment-copy">This is not really shift as the other languages (Perl, Ruby) use the term. This is rotate. Maybe the question should be updated accordingly ?</span>
<span class="comment-copy">@dzhelil I really like your original solution because it doesn't introduce mutations</span>
<span class="comment-copy"><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.roll.html" rel="nofollow noreferrer">numpy.roll</a></span>
<span class="comment-copy">I think <code>rotate</code> is the right word, not <code>shift</code>.</span>
<span class="comment-copy">For future readers: <code>collections.deque rotate()</code> is faster than slicing according to <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a></span>
<span class="comment-copy">But be aware, using <code>deque.rotate</code> requires a type conversion to a <code>deque</code> object first, which is slower than <code>l.append(l.pop(0))</code>. So if you have a deque object to start with, sure it is fastest. Otherwise, use <code>l.append(l.pop(0))</code>.</span>
<span class="comment-copy">To elaborate,  <code>deque.rotate</code> is O(k) but <b>type conversion from list to deque is O(n)</b>. So if you start with a list, using deque.rotate is O(n)+O(k)=O(n). <code>l.append(l.pop(0))</code> on the other hand is O(1).</span>
<span class="comment-copy">@Purrell, popping the front item is O(n). In wiki.python.org/moin/TimeComplexity it's listed as O(k), and k is the number of elements in the list following the popped item, because the data structure shifts all following elements toward the front of the list. Only the last element can be popped in O(1) time for this reason.</span>
<span class="comment-copy">But wouldn't it cost O(k) for removing each element in the list where k is number of remaining elements. So the total time will be O(n^2) <a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a></span>
<span class="comment-copy">This doesn't really answer the question.  The question isn't about returning items in order, but rather about creating a new list that is in a different order.</span>
<span class="comment-copy">no, the answer to the question using pop would be <code>l.append(l.pop(0)</code>. Which if I am not mistaken is O(1).</span>
<span class="comment-copy">This is very elegant and pythonic IMHO</span>
<span class="comment-copy">list.pop internally calls list_ass_slice which uses memmove to very quickly move all the items, but it's still O(n).  See <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/listobject.c</a> and <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a>.  The only item that can be removed from a python list in constant time is the last.</span>
<span class="comment-copy">NB: This will crash for empty lists.</span>
<span class="comment-copy">True.  Exercise for the reader.</span>
<span class="comment-copy">This is the fastest way for lists. <code>collections.deque</code> is faster but for most common cases of list length on a single iteration, or any case of multiple iterations, <code>a.append(a.pop(0))</code> is going to be faster than the type conversion to deque</span>
<span class="comment-copy">Instead of <code>l[:n] = []</code> I would go for <code>del l[:n]</code>. Just an alternative.</span>
<span class="comment-copy">Oh, yeah, good old del.  I often forget about del; the list operation that's a statement, not a method.  Did py3k change that quirk, or have we still got it?</span>
<span class="comment-copy">@keturn: <code>del</code> is still a statement in Py3. However <code>x.__delitem__(y) &lt;==&gt; del x[y]</code>, so if you prefer using methods, <code>l.__delitem__(slice(n))</code> is also equivalent and works in both 2 &amp; 3.</span>
<span class="comment-copy">while list.pop() is a constant-time operation, list.pop(0) is <i>not</i>. It runs in linear time with respect to list length. You can test that by modifying your timeit setup: <code>l = [random.random() for i in range(100000)]</code></span>
<span class="comment-copy">list.pop is not a constant time operation.  list.pop runs in O(k) time where k is the number of elements past the removed element, so list.pop(0) is O(n).  Internally, list.pop uses list_ass_slice which uses memmove to move items way faster than you ever could with python, but for long lists it is still very time consuming.  See <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/listobject.c</a> and <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a></span>
<span class="comment-copy">You should provide a working example.</span>
<span class="comment-copy">update: take this as a better reference: <a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a>, use <code>collections.dequeue</code> pop and appendleft, which both are O(1) ops. In my first answer above, insert is O(n).</span>
<span class="comment-copy">should be <code>collections.deque</code></span>
<span class="comment-copy">That happens because <code>x.classlist = otherlist</code> makes <code>x.classlist</code> refer to the same list as <code>otherlist</code> and then when you call <code>x.shift_classlist()</code> it mutates the list and because both names refer to the same list object. Both names appear to change because they are just aliases for the same object. Use <code>x.classlist = otherlist[:]</code> instead to assign a copy of the list.</span>
<span class="comment-copy">Hey wow! Thank you very much! I really didn't know that and It's really good to know! :)</span>
<span class="comment-copy">well, actually you could use list.pop and list.append. It isn't the language's fault you wrote a 12 line function that is O(n), when you could have just wrote "l.append(l.pop(0))" which is constant time.</span>
<span class="comment-copy">l.append(l.pop(0)) is O(n) (l.pop(0) has to shift every element), thus if you wanted to shift m values the complexity is actually O(n*m).  The complexity of the algorithm I provided is O(n) regardless of the number of shifts.  In practice, this is slow because so much logic is done in python ops instead of C (list.pop is implemented in c, see <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/listobject.c</a>).</span>
<span class="comment-copy">That is exactly what the OP has.  You just changed the names and added an assert.</span>
<span class="comment-copy">not sure I follow your comment!</span>
<span class="comment-copy">The function <code>list_shift</code> in your answer is identical to the function <code>shift</code> in the original question, so this is not an answer to the actual question: "Is there a better way?"</span>
<span class="comment-copy">yes it O(1) using list slicing</span>
<span class="comment-copy">-1: This is doing something different from what is asked, and BTW is also equivalent to <code>L.pop(0)</code></span>
