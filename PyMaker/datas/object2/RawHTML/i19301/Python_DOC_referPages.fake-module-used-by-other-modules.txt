<div class="post-text" itemprop="text">
<p>Is any possibility to fake module, which is used(import) by other modules that I use in my tests?</p>
<p>Example: 
This is my test.py:</p>
<pre><code>import unittest 
import module1
//test code here
module1.some_method()
//test code here
</code></pre>
<p>This is module1.py:</p>
<pre><code>import module_i_want_to_fake
//module code here
</code></pre>
<p>Based on example: the question is: how can I fake <code>module_i_want_to_fake</code> in test.py</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do an <code>import foo</code>, if <code>sys.modules['foo']</code> already exists, the interpreter just returns that instead of doing a fresh import.</p>
<p>So, to fake out <code>module1</code>'s <code>import</code> statement, just get the value filled in before you load <code>module1</code>. This is a bit hacky, but very simple. For example:</p>
<p>mytest.py:</p>
<pre><code>import sys
import unittest 
import my_fake_module
sys.modules['module_i_want_to_fake'] = my_fake_module
import module1
//test code here
module1.some_method()
//test code here
</code></pre>
<p>module1.py:</p>
<pre><code>import module_i_want_to_fake
print(module_i_want_to_fake)
</code></pre>
<p>This will print out something like this:</p>
<pre><code>&lt;module 'my_fake_module' from 'my_fake_module.pyc'&gt;
</code></pre>
<p>If you need to fake out <code>module1</code> more thoroughly (even if it tries to introspect the module), you can create a new module (via <code>types.ModuleType</code>) with the code from <code>my_fake_module</code> but the name <code>'module_i_want_to_fake'</code>, and any other changes you want.</p>
<p>If you need to do this more dynamically than can be accomplished by just renaming modules statically in advance, you can build an import hook, as described in <a href="http://www.python.org/dev/peps/pep-0302/" rel="nofollow">PEP 302</a>. This requires you to reimplement a good chunk of the import mechanism, which is a huge pain in 2.x, but <a href="http://docs.python.org/3/library/importlib.html" rel="nofollow"><code>importlib</code></a> in 3.1+ makes it a lot easier.</p>
<p>Fortunately, usually, you don't need to do either of these.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python3 I do this:</p>
<p><strong>Create simple fake class in a module</strong></p>
<pre><code># module test.py
thismodule = sys.modules[__name__]
setattr(thismodule, "something", type("something", (), {}))
</code></pre>
<p>This is cool, but what you probably want is generate from a config data file.</p>
<p><strong>Create fake class in a module from cfg file</strong></p>
<pre><code># module test.py
import configparser

cfg = configparser.ConfigParser()
cfg.read("/path/to/fname.ini")

for section in cfg.sections():
    name = cfg[str(section)]['name']
    setattr(thismodule, name, type(name, (), {}))
</code></pre>
<p>Ok, now let's try in module1</p>
<pre><code># Import only the main module
import test

# now you can use as you want
test.something
</code></pre>
<p>Enjoy!!</p>
</div>
<span class="comment-copy">What is the reason? You can do <code>import module1 as m1</code> Or use another name as a reference to it.</span>
<span class="comment-copy">but when I import module1, then module1 will import module_i_want_to_fake, but I want it import my_fake_module</span>
<span class="comment-copy">So you want to, from outside of <code>module1</code>, intercept its <code>import</code> statements so you can substitute different modules?</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/5122465/can-i-fake-a-package-or-at-least-a-module-in-python-for-testing-purposes">Can I "fake" a package ( or at least a module ) in python for testing purposes?</a></span>
