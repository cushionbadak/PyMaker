<div class="post-text" itemprop="text">
<p>In Python a way to implement the Singleton pattern is with metaclasses.</p>
<pre><code>class Singleton(type):
    def __init__(cls, name, bases, dict):
        super(Singleton, cls).__init__(name, bases, dict)
        cls.INSTANCE = None

    def __call__(cls, *args, **kwargs):
        if cls.INSTANCE is None:
            cls.INSTANCE = super(Singleton, cls).__call__(*args, **kwargs)
        return cls.INSTANCE
</code></pre>
<p>But in Eclipse with PyDev dict parameter raises a warning: <code>Assignment to reserved built-in symbol: dict</code>.</p>
<p>Also PEP 8 says:</p>
<blockquote>
<p>If a function argument's name clashes with a reserved keyword, it is
  generally better to append a single trailing underscore rather than
  use an abbreviation or spelling corruption. Thus class_ is better than
  clss. (Perhaps better is to avoid such clashes by using a synonym.)</p>
</blockquote>
<p>I found on the web different names assigned to the parameter instead of dict, such as dictionary, classdict and attrs.</p>
<p>And a approach with *args and **kwargs:</p>
<pre><code>class Singleton(type):
    def __init__(cls, *args, **kwargs):
        super(Singleton, cls).__init__(*args, **kwargs)
        cls.INSTANCE = None

    def __call__(cls, *args, **kwargs):
        if cls.INSTANCE is None:
            cls.INSTANCE = super(Singleton, cls).__call__(*args, **kwargs)
        return cls.INSTANCE
</code></pre>
<p>I think this last snippet is the best because is safe if type init method changes his signature.</p>
<p><strong>The questions:</strong></p>
<ol>
<li><p>What name do you assign to the parameter instead of dict?</p></li>
<li><p>What do you think about this last snippet?</p></li>
<li><p>What do you think is the best option? Change parameter name or use *args and **kwargs?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p><code>dict</code> is a built-in type, you can use <code>namespace</code> or <code>attributes</code> or whatever instead. It doesn't really matter here, it is just a local variable name.</p>
<p>There is no requirement for it to be named anything specific as it is a positional parameter. The <a href="http://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="nofollow">datamodel documentation</a> uses <code>namespace</code>.</p></li>
<li><p>Using <code>*args</code> and <code>**kwargs</code> is more than fine there. In fact, the <code>__init__()</code> of a metaclass can be passed additional keyword arguments, so it is good practice to pass those on to the super <code>__init__</code> method.</p></li>
<li><p>I'd use <code>*args</code> and <code>**kwargs</code> when I don't care about the parameters. That way you future-proof the method.</p></li>
</ol>
<p>Note that in Python 3, you no longer need to give <code>super()</code> any arguments:</p>
<pre><code>class Singleton(type):
    def __init__(cls, *args, **kwargs):
        super().__init__(*args, **kwargs)
        cls.INSTANCE = None

    def __call__(cls, *args, **kwargs):
        if cls.INSTANCE is None:
            cls.INSTANCE = super().__call__(*args, **kwargs)
        return cls.INSTANCE
</code></pre>
</div>
<span class="comment-copy">Implementing Singleton like this is an anti-pattern. Using a class method is explicit and readable. Oh, and it's not really a singleton: <a href="http://ideone.com/E52yj6" rel="nofollow noreferrer">ideone.com/E52yj6</a>.</span>
<span class="comment-copy">@lqc You are misunderstand the Singleton pattern. In this <a href="http://ideone.com/s8BiMe" rel="nofollow noreferrer">snippet</a> you could see the classes A and B are Singletons.</span>
<span class="comment-copy">Great answer. Thank you!</span>
