<div class="post-text" itemprop="text">
<p><strong>Performance, elegancy and readability</strong> are the requirements for <strong>"the best way"</strong></p>
<p>I have the array of dictionaries:</p>
<pre><code>items = [
    {'id1' : 1, 'id2' : 2, 'other' : 'xxx'},
    {'id1' : 1, 'id2' : 3, 'other' : 'yyy'},
    {'id1' : 2, 'id2' : 4, 'other' : 'zzz'}
]
</code></pre>
<p>The result should be: <code>ids = [1,2,3,4]</code> (list of id1 and id2)</p>
<p><strong>Edit:</strong>
Something like this:</p>
<pre><code>ids = []
for item in items:
   if item.id1 not in ids:
       ids.append(item.id1)
   if item.id2 not in ids:
       ids.append(item.id2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; set(x for y in items for x in y.values())
set([1, 2, 3, 4])
</code></pre>
<hr/>
<p>Update for updated question</p>
<pre><code>&gt;&gt;&gt; set(v for y in items for (k,v) in y.items() if k.startswith('id'))
set([1, 2, 3, 4])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This could be done pretty easily by using <a href="http://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable()</code></a> to flatten a nested <a href="http://www.youtube.com/watch?v=pShL9DCSIUw" rel="nofollow">generator expression</a> producing the values of the ids - we presume that all keys are going to be strings, and that starting with <code>"id"</code> specifies an id. We then make a set of those values to remove duplicates:</p>
<pre><code>from itertools import chain

set(chain.from_iterable((value for name, value in item.items() 
                         if name.startswith("id"))
                        for item in items))
</code></pre>
<p>If you really want a list, then you could create one from the set, but in most cases, the set should be fine as-is. Note that the set has no order, so if you want an order you will need to use <code>sorted()</code>, for example.</p>
<p><code>itertools.chain.from_iterable()</code> is the most efficient and readable way to flatten an iterable.</p>
<p>Your specification isn't clear when it comes to what an id is. If you have a set of keys which define an id, then something like this might be more appropriate as the if clause of the inner generator expression:</p>
<pre><code>if name in {"id1", "id2"}
</code></pre>
</div>
<span class="comment-copy">Note that the values aren't actually ordered. Unless you explicitly want <code>id1</code> and <code>id2</code>. Do you need the original order?</span>
<span class="comment-copy">I forgot to mention that there are other elements in the dictionary and just want a list of ids.</span>
<span class="comment-copy">@ShankarCabus What defines an id? What other elements will there be? You haven't given us enough information here.</span>
<span class="comment-copy">Checking membership of a set built like that that would take longer than a tuple. Even though it would be a tiny amount longer.</span>
<span class="comment-copy">@jamylak True, but it generally doesn't matter either way, and I tend to use a set as it's a good habit for when the set of possibilities is huge (the only case it's likely to matter).</span>
