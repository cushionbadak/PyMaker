<div class="post-text" itemprop="text">
<p>Where X is any programming language (C#, Javascript, Lisp, Perl, Ruby, Scheme, etc) which supports some flavour of closures.  </p>
<p>Some limitations are mentioned in the <a href="http://ivan.truemesh.com/archives/000411.html" rel="nofollow noreferrer">Closures in Python</a> (compared to Ruby's closures), but the article is old and many limitations do not exist in modern Python any more.</p>
<p>Seeing a code example for a concrete limitation would be great.</p>
<p><strong>Related questions</strong>:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python">Can you explain closures (as they relate to Python)?</a></li>
<li><a href="https://stackoverflow.com/questions/36636/what-is-a-closure">What is a ‘Closure’?</a></li>
<li><a href="https://stackoverflow.com/questions/111102/how-does-a-javascript-closure-work">How does a javascript closure work ?</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The most important limitation, currently, is that you cannot assign to an outer-scope variable. In other words, closures are read-only:</p>
<pre><code>&gt;&gt;&gt; def outer(x): 
...     def inner_reads():
...         # Will return outer's 'x'.
...         return x
...     def inner_writes(y):
...         # Will assign to a local 'x', not the outer 'x'
...         x = y
...     def inner_error(y):
...         # Will produce an error: 'x' is local because of the assignment,
...         # but we use it before it is assigned to.
...         tmp = x
...         x = y
...         return tmp
...     return inner_reads, inner_writes, inner_error
... 
&gt;&gt;&gt; inner_reads, inner_writes, inner_error = outer(5)
&gt;&gt;&gt; inner_reads()
5
&gt;&gt;&gt; inner_writes(10)
&gt;&gt;&gt; inner_reads()
5
&gt;&gt;&gt; inner_error(10)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 11, in inner_error
UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>
<p>A name that gets assigned to in a local scope (a function) is always local, unless declared otherwise. While there is the 'global' declaration to declare a variable global even when it is assigned to, there is no such declaration for enclosed variables -- yet. In Python 3.0, there is (will be) the 'nonlocal' declaration that does just that.</p>
<p>You can work around this limitation in the mean time by using a mutable container type:</p>
<pre><code>&gt;&gt;&gt; def outer(x):
...     x = [x]
...     def inner_reads():
...         # Will return outer's x's first (and only) element.
...         return x[0]
...     def inner_writes(y):
...         # Will look up outer's x, then mutate it.      
...         x[0] = y
...     def inner_error(y):
...         # Will now work, because 'x' is not assigned to, just referenced.
...         tmp = x[0]
...         x[0] = y
...         return tmp
...     return inner_reads, inner_writes, inner_error
... 
&gt;&gt;&gt; inner_reads, inner_writes, inner_error = outer(5)
&gt;&gt;&gt; inner_reads()
5
&gt;&gt;&gt; inner_writes(10)
&gt;&gt;&gt; inner_reads()
10
&gt;&gt;&gt; inner_error(15)
10
&gt;&gt;&gt; inner_reads()
15
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The only difficulty I've seen people encounter with Python's in particular is when they try to mix non-functional features like variable reassignment with closures, and are surprised when this doesn't work:</p>
<pre><code>def outer ():
    x = 1
    def inner ():
        print x
        x = 2
    return inner
outer () ()
</code></pre>
<p>Usually just pointing out that a function has its own local variables is enough to deter such silliness.</p>
</div>
<div class="post-text" itemprop="text">
<p>A limitation (or "limitation") of Python closures, comparing to Javascript closures, is that it <strong>cannot</strong> be used for effective <strong>data hiding</strong></p>
<h3>Javascript</h3>
<pre><code>var mksecretmaker = function(){
    var secrets = [];
    var mksecret = function() {
        secrets.push(Math.random())
    }
    return mksecret
}
var secretmaker = mksecretmaker();
secretmaker(); secretmaker()
// privately generated secret number list
// is practically inaccessible
</code></pre>
<h3>Python</h3>
<pre><code>import random
def mksecretmaker():
    secrets = []
    def mksecret():
        secrets.append(random.random())
    return mksecret

secretmaker = mksecretmaker()
secretmaker(); secretmaker()
# "secrets" are easily accessible,
# it's difficult to hide something in Python:
secretmaker.__closure__[0].cell_contents # -&gt; e.g. [0.680752847190161, 0.9068475951742101]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Fixed in Python 3 via the <a href="https://docs.python.org/3/reference/simple_stmts.html?#nonlocal" rel="nofollow noreferrer"><code>nonlocal</code></a> statement:</p>
<blockquote>
<p>The <code>nonlocal</code> statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope excluding globals. This is important because the default behavior for binding is to search the local namespace first. The statement allows encapsulated code to rebind variables outside of the local scope besides the global (module) scope.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>@John Millikin</p>
<pre><code>def outer():
    x = 1 # local to `outer()`

    def inner():
        x = 2     # local to `inner()`
        print(x)
        x = 3
        return x

    def inner2():
        nonlocal x
        print(x)  # local to `outer()`
        x = 4     # change `x`, it is not local to `inner2()`
        return x

    x = 5         # local to `outer()`
    return (inner, inner2)

for inner in outer():
    print(inner()) 

# -&gt; 2 3 5 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><sub>comment for <a href="https://stackoverflow.com/a/141767/4279">@Kevin Little's answer</a> to include the code example</sub></p>
<p><code>nonlocal</code> does not solve completely this problem on python3.0:</p>
<pre><code>x = 0 # global x
def outer():
    x = 1 # local to `outer`
    def inner():
        global x
        x = 2 # change global
        print(x) 
        x = 3 # change global
        return x
    def inner2():
##        nonlocal x # can't use `nonlocal` here
        print(x)     # prints global
##        x = 4      # can't change `x` here
        return x
    x = 5
    return (inner, inner2)

for inner in outer():
    print(inner())
# -&gt; 2 3 3 3
</code></pre>
<p>On the other hand:</p>
<pre><code>x = 0
def outer():
    x = 1 # local to `outer`
    def inner():
##        global x
        x = 2
        print(x) # local to `inner` 
        x = 3 
        return x
    def inner2():
        nonlocal x
        print(x)
        x = 4  # local to `outer`
        return x
    x = 5
    return (inner, inner2)

for inner in outer():
    print(inner())
# -&gt; 2 3 5 4
</code></pre>
<p>it works on python3.1-3.3</p>
</div>
<div class="post-text" itemprop="text">
<p>The better workaround until 3.0 is to include the variable as a defaulted parameter in the enclosed function definition:</p>
<pre>
def f()
    x = 5
    def g(y, z, x=x):
        x = x + 1
</pre>
</div>
<span class="comment-copy"><code>nonlocal</code> as you mentined solves this problem.  An inner class with <code>__call__</code> can solve it too (but version with a list is more succinct).</span>
<span class="comment-copy">UnboundLocalError</span>
<span class="comment-copy">you need a      return inner</span>
<span class="comment-copy">@Moe thanks ; @JF exactly. Closures work just like any other function, but for some reason people think they should perform magic when assigning variables.</span>
<span class="comment-copy">My comment is too big. I've posted it as an answer.</span>
<span class="comment-copy">Even when using standard OO data-hiding, you can get to a Python Class' __private_variable using obj._Class__private_variable. The point of data hiding is to provide abstractions, not security, and if your client code is bent on breaking poking around.</span>
<span class="comment-copy">My comment is too big. I've posted it as an answer.</span>
<span class="comment-copy">Hmmm ... presumably the nonlocal variable is shared between all instances of the closure? Making it rather like a static / class variable?</span>
<span class="comment-copy">I know this is a really old answer, but it is plain wrong for python3.2 - you can totally use nonlocal in the first example and get the expected results. I don't have a python3.0 build to check if it was different back then, but if it was I would consider it a bug, as the <a href="http://www.python.org/dev/peps/pep-3104/" rel="nofollow noreferrer">PEP</a> doesn't state it should be different. The only (obvious) limitation is that you can't use <code>global x</code> and <code>nonlocal x</code> in the same scope.</span>
<span class="comment-copy">@l4mpi: It produces <code>SyntaxError: no binding for nonlocal 'x' found</code> on python3.0 if you uncomment <code>nonlocal</code>. But it works on python3.1-3.3</span>
<span class="comment-copy">Ah, thanks for the answer. This seems even more like a bug now, although I wasn't able to find a bug report or a note in the 3.1 release notes...</span>
<span class="comment-copy">The value of outer <code>x</code> will always be <code>5</code>.</span>
