<div class="post-text" itemprop="text">
<p>So I'm making a Yu-Gi-Oh database program. I have all the information stored in a large text file. Each monster is chategorized in the following way: </p>
<pre><code>|Name|NUM 1|DESC 1|TYPE|LOCATION|STARS|ATK|DEF|DESCRIPTION
</code></pre>
<p>Here's an actual example:</p>
<pre><code>|A Feather of the Phoenix|37;29;18|FET;YSDS;CP03|Spell Card}Spell||||Discard 1 card. Select from your Graveyard and return it to the top of your Deck.|
</code></pre>
<p>So I made a program that searches this large text file by name and it returns the information from the text file without the '|'. Here it is:</p>
<pre><code>    with open('TEXT.txt') as fd:
         input=[x.strip('|').split('|') for x in fd.readlines()]
         to_search={x[0]:x for x in input}
         print('\n'.join(to_search[name]))
</code></pre>
<p>Now I'm trying to edit my program so I can search for the name of the monster and choose which attribute I want to display. So it'd appear like</p>
<pre><code>A Feather of the Phoenix 
Description:
Discard 1 card. Select from your Graveyard and return it to the top of your Deck.    
</code></pre>
<p>Any clues as to how I can do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, this is a variant dialect of CSV, and can be parsed with the <a href="http://docs.python.org/3/library/csv.html" rel="nofollow"><code>csv</code></a> module instead of trying to do it manually. For example:</p>
<pre><code>with open('TEXT.txt') as fd:
    rows = csv.reader(fd, delimiter='|')
    to_search = {row[1]:row for row in rows}
    print('\n'.join(to_search[name]))
</code></pre>
<p>You might also prefer to use <code>DictReader</code>, so each row is a <code>dict</code> (keyed off the names in the header row, or manually-specified column names if you don't have one):</p>
<pre><code>with open('TEXT.txt') as fd:
    rows = csv.DictReader(fd, delimiter='|')
    to_search = {row['Name']:row for row in rows}
    print('\n'.join(to_search[name]))
</code></pre>
<p>Then, to select a specific attribute:</p>
<pre><code>with open('TEXT.txt') as fd:
    rows = csv.DictReader(fd, delimiter='|')
    to_search = {row['Name']:row for row in rows}
    print(to_search[name][attribute])
</code></pre>
<p>Howeverâ€¦ I'm not sure this is a good design in the first place. Do you really want to re-read the entire file for each lookup? I think it makes more sense to read it into memory once, into a general-purpose structure that you can use repeatedly. And in fact, you've almost got such a structure:</p>
<pre><code>with open('TEXT.txt') as fd:
    monsters = list(csv.DictReader(fd, delimiter='|'))
monsters_by_name = {monster['Name']: monster for monster in monsters}
</code></pre>
<p>Then you can build additional indexes, like a multi-map of monsters by location, etc., if you need them.</p>
<hr/>
<p>All this being said, your original code can almost handle what you want already. <code>to_search[name]</code> is a <code>list</code>. If you just build a map from attribute names to indices, you can do this:</p>
<pre><code>attributes = ['Name', 'NUM 1', 'DESC 1', 'TYPE', 'LOCATION', 'STARS', 'ATK', 'DEF', 'DESCRIPTION']
attributes_by_name = {value: idx for idx, value in enumerate(attributes)}
# ...
with open('TEXT.txt') as fd:
     input=[x.strip('|').split('|') for x in fd.readlines()]
     to_search={x[0]:x for x in input}
     attribute_index = attributes_by_name[attributes]
     print(to_search[name][attribute_index])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could look at the <code>namedtuple</code> class in <code>collections</code>. You will want to make each entry a <code>namedtuple</code> with your fields as attributes. The namedtuple might look like:</p>
<pre><code>Card = namedtuple('Card', 'name, number, description, whatever_else')
</code></pre>
<p>As shown in the collections documentation, namedtuple and csv work well together:</p>
<pre><code>import csv
for card in map(Card._make, csv.reader(open("cards", "rb"))):
    print card.name, card.description # format however you want here
</code></pre>
<p>The mechanics around search can be very complicated. For example, if you want a really fast search built around an exact match, you could build a dictionary for each attribute you're interested in:</p>
<pre><code>name_map = {card.name: card for card in all_cards}
search_result = name_map[name_you_searched_for]
</code></pre>
<p>You could also do a <code>startswith</code> search:</p>
<pre><code>possibles = [card for card in all_cards if card.name.startswith(search_string)]
# here you need to decide what to do with these possibles, in this example, I'm just snagging the first one, and I'm not handling the possibility that you don't find one, you should.
search_result = possibles[0]
</code></pre>
<p>I recommend against trying to search the file itself. This is an extremely complex kind of search to do and is typically left up to database systems to implement this kind of functionality. If you need to do this, consider switching the application to sqlite or another lightweight database.</p>
</div>
<span class="comment-copy">This is perfect! Thank you for your help.</span>
