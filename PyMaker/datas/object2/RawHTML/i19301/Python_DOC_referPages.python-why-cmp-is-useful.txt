<div class="post-text" itemprop="text">
<p>According to the <a href="http://docs.python.org/2/library/functions.html#cmp" rel="noreferrer">doc</a> and this <a href="http://www.tutorialspoint.com/python/number_cmp.htm" rel="noreferrer">tutorial</a>,</p>
<p><code>cmp() returns -1 if x &lt; y</code> </p>
<p>and </p>
<p><code>cmp() returns 0 if  x == y</code> </p>
<p>and </p>
<p><code>cmp() returns 1 if  x &gt; y</code> </p>
<p>The tutorial also said that</p>
<blockquote>
<p>cmp() returns the sign of the difference of two numbers</p>
</blockquote>
<p>I don't really get what does it mean <em>sign of the difference of two numbers</em>. Doesn't that mean that it returns a value when the sign of number aren't equal ( positive and negative sign ) ? Since...</p>
<pre><code>cmp(80, 100) :  -1      # both have positive sign.
cmp(180, 100) :  1      # both also have positive sign.
cmp(-80, 100) :  -1
cmp(80, -100) :  1
</code></pre>
<p>**Note: code from the tutorial.*</p>
<p>Despite my confusion in sign differences, I can't really think of why do we need a built-in function to return a value of -1 when x &lt; y. </p>
<p>Isn't the function <strong><code>cmp( )</code></strong> easily implemented ? Is there any reason why Python creators keep <code>cmp( )</code> function, or is there any hidden usage of this Python's <strong><code>cmp( )</code></strong> function ?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Why cmp( ) is useful?</h1>
</blockquote>
<p>It isn't very useful, which is why it was deprecated (the builtin <code>cmp</code> is gone and builtin sorts no longer accept one in Python 3). <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="noreferrer">Rich comparison methods</a> supplanted it:</p>
<pre><code>object.__lt__(self, other)
object.__le__(self, other)
object.__eq__(self, other)
object.__ne__(self, other)
object.__gt__(self, other)
object.__ge__(self, other)
</code></pre>
<p>This allows the <code>&lt;</code> symbol (and other symbols) to be overloaded comparison operators, enabling, for example, subset and superset comparisons of set objects.</p>
<pre><code>&gt;&gt;&gt; set('abc') &lt; set('cba')
False
&gt;&gt;&gt; set('abc') &lt;= set('cba')
True
&gt;&gt;&gt; set('abc') == set('cba')
True
&gt;&gt;&gt; set('abc') &gt;= set('cba')
True
&gt;&gt;&gt; set('abc') &gt; set('cba')
False
</code></pre>
<p>while it could enable the above, <code>cmp</code> wouldn't allow the following:</p>
<pre><code>&gt;&gt;&gt; set('abc') == set('bcd')
False
&gt;&gt;&gt; set('abc') &gt;= set('bcd')
False
&gt;&gt;&gt; set('abc') &lt;= set('bcd')
False
</code></pre>
<h2>Toy usage for <code>cmp</code></h2>
<p>Here's an interesting usage which uses its result as an index (it returns -1 if the first is less than the second, 0 if equal, and 1 if greater than):</p>
<pre><code>def cmp_to_symbol(val, other_val):
    '''returns the symbol representing the relationship between two values'''
    return '=&gt;&lt;'[cmp(val, other_val)]

&gt;&gt;&gt; cmp_to_symbol(0, 1)
'&lt;'
&gt;&gt;&gt; cmp_to_symbol(1, 1)
'='
&gt;&gt;&gt; cmp_to_symbol(1, 0)
'&gt;'
</code></pre>
<p>According to the docs, you should treat cmp as if it wasn't there:</p>
<p><a href="https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="noreferrer">https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons</a></p>
<h2><code>cmp</code> removed, equivalent operation</h2>
<p>But you can use this as the equivalent:</p>
<pre><code>(a &gt; b) - (a &lt; b)
</code></pre>
<p>in our little toy function, that's this:</p>
<pre><code>def cmp_to_symbol(val, other_val):
    '''returns the symbol representing the relationship between two values'''
    return '=&gt;&lt;'[(val &gt; other_val) - (val &lt; other_val)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I don't really get what does it mean <em>sign of the difference of two numbers.</em></p>
</blockquote>
<p>This means: take the difference, and then the sign of that difference. For example, if <code>x</code> and <code>y</code> are two numbers:</p>
<ul>
<li><code>x &lt; y</code> =&gt; <code>x - y &lt; 0</code> and the function returns -1.</li>
<li><code>x == y</code> =&gt; <code>x - y == 0</code> and the function returns 0.</li>
<li><code>x &gt; y</code> =&gt; <code>x - y &gt; 0</code> and the function returns 1.</li>
</ul>
<p>For more information on three-way comparisons, see <a href="http://en.wikipedia.org/wiki/Three-way_comparison">Wikipedia</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For sorting sequences of items. When you are sorting a list of items you only need to know one item is greater or less than another item.</p>
<p>More info here: <a href="http://wiki.python.org/moin/HowTo/Sorting/#The_Old_Way_Using_the_cmp_Parameter" rel="nofollow">http://wiki.python.org/moin/HowTo/Sorting/#The_Old_Way_Using_the_cmp_Parameter</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Trivalued comparators are very useful when sorting.  You don't just want to know whether two elements are equal; you also want to know their relative order so that you know how to rearrange them to move closer to a sorted list.  This is why C (<code>strcmp</code>) and Perl (<code>cmp</code>) both have similar operations (in those cases for strings, but it's the same idea).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Another use case: <strong>Finding the sign (- / +)</strong> of a number</p>
</blockquote>
<p>If you want to find out, what the sign (+/-) of a number is, you can easily use <code>0</code> as the second argument to the <code>cmp</code> function</p>
<pre><code>cmp(-123, 0) #returns -1
cmp( 123, 0) #returns  1
</code></pre>
</div>
<span class="comment-copy">From <a href="https://www.python.org/dev/peps/pep-0207/" rel="nofollow noreferrer">PEP 207</a>: "The main motivation comes from NumPy, whose users agree that A&lt;B should return an array of elementwise comparison outcomes; they currently have to spell this as less(A,B) because A&lt;B can only return a Boolean result or raise an exception."</span>
<span class="comment-copy">Your bit about sets and <code>&gt;=</code> doesn't really hold as <code>cmp</code> could return an appropriate result for those cases. It would not work for the the NumPy case mentioned in my previous comment.</span>
<span class="comment-copy">@LeviMorrison PEP 207 is a very good point, I'll mention that later. Now - what would be the appropriate result for two sets with each differences and an intersection (for example  <code>set('ab')</code> and <code>set('bc')</code>)? These sets are not ordered, currently test <code>False</code> for equality, less than, and greater than, and <code>cmp</code> would thus have no reasonable result, to my current thinking.</span>
<span class="comment-copy">Ah, I forgot that <code>&gt;=</code> was intended to be a set operation when posting that. Honestly I don't think it is a good idea to do that -- I don't think that notation is used in set theory and isn't intuitive, at least to me -- but numpy's usage for element-wise comparisons seems fine. Maybe switch to a numpy example?</span>
<span class="comment-copy">@LeviMorrison I will probably add a numpy example since you bring it up. I do enjoy curating my answers, so if you see others with anything you'd like me to add or criticisms, please leave a suggestion for improvement.</span>
