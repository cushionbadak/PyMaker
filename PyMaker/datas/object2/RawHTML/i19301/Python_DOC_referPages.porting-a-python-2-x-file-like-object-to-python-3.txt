<div class="post-text" itemprop="text">
<p>I'm working on improving Python 3.X support for <a href="https://code.google.com/p/pyfilesystem/" rel="nofollow">PyFilesystem</a>. It's an abstraction for filesystems. Each filesystem object has an open method that returns a file-like object.</p>
<p>The problem I'm facing is that the open method works <code>open</code> on Python 2.X, but I would like it to work like <code>io.open</code> which returns one of a number of binary or text mode streams.</p>
<p>What I could use, is a way of taking a Python 2.X file-like object, and returning an appropriate io stream object that reads/writes to the underlaying file-like object (but handles buffering/unicode etc if required).</p>
<p>I was thinking something like the following:</p>
<pre><code>def make_stream(file_object, mode, buffering, encoding):
    # return a io instance
</code></pre>
<p>I can't see any straight forward way of doing that with the stdlib. But it strikes me as something the io module must be doing under the hood, since its a software layer that provides the buffering/unicode functionality.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 2 includes the same <a href="http://docs.python.org/2/library/io.html" rel="nofollow"><code>io</code> library</a> too.</p>
<p>Use <code>from io import open</code> to work the same across Python versions.</p>
<p>Your API should then offer a <code>open()</code> equivalent (called <code>open()</code> or <code>make_stream()</code>) that uses the <code>io</code> class library to provide the same functionality.</p>
<p>All that you need to do is create a class that implements the <a href="http://docs.python.org/3/library/io.html#io.RawIOBase" rel="nofollow"><code>io.RawIOBase</code> ABC</a>, then use the <em>other</em> classes provided by the library to add buffering and text handling <em>as needed</em>:</p>
<pre><code>import io

class MyFileObjectWrapper(io.RawIOBase):
    def __init__(self, *args):
        # do what needs done

    def close(self):
        if not self.closed:
            # close the underlying file
        self.closed = True

    # ... etc for what is needed (e.g. def read(self, maxbytes=None), etc.

def open(fileobj, mode='r', buffering=-1, encoding=None, errors=None, newline=None):
    # Mode parsing and validation adapted from the io/_iomodule.c module
    reading, writing, appending, updating = False
    text, binary, universal = False

    for c in mode:
        if c == 'r':
            reading = True;
            continue
        if c == 'w':
            writing = True;
            continue
        if c == 'a':
            appending = True;
            continue
        if c == '+':
            updating = True;
            continue
        if c == 't':
            text = True;
            continue
        if c == 'b':
            binary = True;
            continue
        if c == 'U':
            universal = reading = True;
            continue
        raise ValueError('invalid mode: {!r}'.format(mode))

    rawmode = []
    if reading:   rawmode.append('r')
    if writing:   rawmode.append('w')
    if appending: rawmode.append('a')
    if updating:  rawmode.append('+')
    rawmode = ''.join(rawmode)

    if universal and (writing or appending):
        raise ValueError("can't use U and writing mode at once")

    if text and binary) {
        raise ValueError("can't have text and binary mode at once")

    if reading + writing + appending &gt; 1:
        raise ValueError("must have exactly one of read/write/append mode")

    if binary
        if encoding is not None:
            raise ValueError("binary mode doesn't take an encoding argument")
        if errors is not None:
            raise ValueError("binary mode doesn't take an errors argument")
        if newline is not None:
            raise ValueError("binary mode doesn't take a newline argument")

    raw = MyFileObjectWrapper(fileobj)

    if buffering == 1:
        buffering = -1
        line_buffering = True
    else:
        line_buffering = False

    if buffering &lt; 0:
        buffering = SOME_SUITABLE_DEFAULT

    if not buffering
        if not binary:
            raise ValueError("can't have unbuffered text I/O")

        return raw

    if updating:
        buffered_class = io.BufferedRandom
    elif writing or appending:
        buffered_class = io.BufferedWriter
    elif reading:
        buffered_class = io.BufferedReader

    buffer = buffered_class(raw, buffering)

    if binary:
        return buffer

    return io.TextIOWrapper(buffer, encoding, errors, newline, line_buffering)
</code></pre>
<p>The above code is mostly adapted from the <a href="http://hg.python.org/cpython/file/2.7/Modules/_io/_iomodule.c#l290" rel="nofollow"><code>Modules/_io/_iomodule.c</code> <code>io_open</code> function</a>, but with the raw file object replaced by the <code>MyFileObjectWrapper</code> subclass of the <code>io.RawIOBase</code> ABC.</p>
</div>
<span class="comment-copy">Yes, I know. From Python 2.6 onwards. But I still need to provide the io interface for file-like objects. These aren't actual file objects. The data comes from a variety of different sources.</span>
<span class="comment-copy">@WillMcGugan: Right, I misunderstood you then. The <code>io</code> library <code>open</code> function is just a factory. It returns instances of a series of classes. There is nothing magical about that, you can just implement the same thing in your own library.</span>
<span class="comment-copy">@WillMcGugan: You can use the <code>io</code> library abstract base classes as a template, of course, to make your objects match expectations. You can also <i>reuse</i> the <code>io</code> buffer and text wrapper classes, if you provide your own raw file object implementation.</span>
<span class="comment-copy">I had considered that, but it looks like a lot of work to provide the shill classes for each combination of mode/buffering. Guess I was hoping for something simpler.</span>
<span class="comment-copy">You can also refer to the <a href="http://hg.python.org/cpython/file/c9910fd022fc/Lib/io.py#l81" rel="nofollow noreferrer">2.6 implementation</a>. It was ported to C in 2.7.</span>
