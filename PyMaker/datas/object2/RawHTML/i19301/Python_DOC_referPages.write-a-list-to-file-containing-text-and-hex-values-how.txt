<div class="post-text" itemprop="text">
<p>I need to write a list of values to a text file. Because of Windows, when I need to write a line feed character, windows does \n\r and other systems do \n.</p>
<p>It occurred to me that maybe I should write to file in binary.</p>
<p>How to I create a list like the following example and write to file in binary?</p>
<pre><code>output = ['my first line', hex_character_for_line_feed_here, 'my_second_line']
</code></pre>
<p>How come the following does not work?</p>
<pre><code>output = ['my first line', '\x0a', 'my second line']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't. Open the file in text mode and just let Python handle the newlines for you.</p>
<p>When you use the <a href="http://docs.python.org/3/library/functions.html#open" rel="nofollow"><code>open()</code> function</a> you can set how Python should handle newlines with the <code>newline</code> keyword parameter:</p>
<blockquote>
<p>When writing output to the stream, if <em>newline</em> is <code>None</code>, any <code>'\n'</code> characters written are translated to the system default line separator, <code>os.linesep</code>. If <em>newline</em> is <code>''</code> or <code>'\n'</code>, no translation takes place. If <em>newline</em> is any of the other legal values, any <code>'\n'</code> characters written are translated to the given string.</p>
</blockquote>
<p>So the default method is to write the correct line separator for your platform:</p>
<pre><code>with open(outputfilename, 'w') as outputfile:
    outputfile.write('\n'.join(output))
</code></pre>
<p>and does the <em>right thing</em>; on Windows <code>\r\n</code> characters are saved instead of <code>\n</code>.</p>
<p>If you specifically want to write <code>\n</code> <em>only</em> and not have Python translate these for you, use <code>newline=''</code>:</p>
<pre><code>with open(outputfilename, 'w', newline='') as outputfile:
    outputfile.write('\n'.join(output))
</code></pre>
<p>Note that <code>'\x0a'</code> is <em>exactly</em> the same character as <code>\n</code>; <code>\r</code> is <code>\x0d</code>:</p>
<pre><code>&gt;&gt;&gt; '\x0a'
'\n'
&gt;&gt;&gt; '\x0d'
'\r'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a text file, "myTextFile" in the same directory as your Python script. Then write something like:</p>
<pre><code># wb opens the file in "Write Binary" mode
myTextFile = open("myTextFile.txt", 'wb')

output = ['my first line', '369as3', 'my_second_line']

for member in output:
    member.encode("utf-8") # Or whatever encoding you like =)
    myTextFile.write(member + "\n")
</code></pre>
<p>This outputs a binary text file that looks like:</p>
<pre><code>my first line
369as3
my_second_line
</code></pre>
<p><em><strong>Edit:</strong> Updated for Python 3</em></p>
</div>
<span class="comment-copy">open the file in binary mode open(path,"wb")</span>
<span class="comment-copy">i get that part for sure but in python 3.3, what does the hex representation of a line feed looks like using my example above? Something like... \x0a  ?</span>
<span class="comment-copy">import os os.linesep</span>
<span class="comment-copy">I guess my question is, how do I convert anything inside of a list to its hex character representation if it isn't already, then write to file?</span>
<span class="comment-copy"><code>'\x0a'</code> is <i>exactly</i> the same character as <code>'\n'</code>.</span>
<span class="comment-copy">line feed is not the only hex character I'd like to add to this string. For some reason this does not work: output = ['my first line', '\x0a', 'my second line']</span>
<span class="comment-copy">@Vini: Why do you need to add explicit linefeeds? They'll work just fine, btw, Python will write those to your file unchanged. <code>'\x0a'</code> <i>is the same character</i> as <code>\n</code>.</span>
<span class="comment-copy">Record separators, Carriage Returns. I am basically building a string that follows a standard and gets encoded to pdf417 Bar Codes.</span>
<span class="comment-copy">@Vini: If you need to write <i>exact</i> line separators, set <code>newline=''</code> and no translation takes place. If you need them translated to platform-specific newlines, use <code>newline=None</code>. This is still ASCII data, so textual mode is just fine.</span>
<span class="comment-copy">@Vini: That is because you are opening the file with <code>newline=None</code> and a <code>\r\n</code> is written. Use <code>newline=''</code> instead.</span>
<span class="comment-copy">This is Python 3; you need to write <i>bytes</i>, not strings to files when opening a file in binary mode. Your code does not work on Python 3.</span>
<span class="comment-copy">Ah I see, the OP didn't specify the version. Edited my code to encode the string to bytes first.</span>
<span class="comment-copy">Yes, he did, in the tags on the question.</span>
<span class="comment-copy">Didn't see the tag. Still, edited my code to encode the string to bytes first.</span>
