<div class="post-text" itemprop="text">
<p>E.g., I have:</p>
<pre><code>def readDb():
    # Fetch a lot of data from db, spends a lot time
    ...
    return aList

def calculation():
    x = readdb()
    # Process x
    ...
    return y
</code></pre>
<p>In the python interpreter,<br/>
each time I run <code>calculation()</code> it takes a lot of time to re-read the database, which is unnecessary.<br/>
How can I store the result from <code>readdb()</code> to avoid this reducdant process?</p>
<p><strong>Edit:</strong><br/>
I found a similar question here but I don't quite know the answer<br/>
<a href="https://stackoverflow.com/questions/10230869/">Save functions for re-using without re-execution</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def readDb():
    ... #Fetch a lot of data from db, spends a lot time
    return aList

def calculation(data):
    x=data
    ...process x...
    return y

data = readDb()

calculation(data)
calculation(data)
calculation(data)
</code></pre>
<p>This will only hit the database once.</p>
<p>Basically, you want to save the results of readDb() to a seperate variable which you can then pass to calculation().</p>
</div>
<div class="post-text" itemprop="text">
<p>Write a simple decorator:</p>
<pre><code>class memo(object):
    def __init__(self, fun):
        self.fun = fun
        self.res = None
    def __call__(self):
        if self.res is None:
            self.res = self.fun()
        return self.res

@memo
def readDb():
    # ... etc
    return aList
</code></pre>
<p>For more general solutions, look here: <a href="http://code.activestate.com/recipes/498245-lru-and-lfu-cache-decorators/" rel="noreferrer">http://code.activestate.com/recipes/498245-lru-and-lfu-cache-decorators/</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated answer for modern Python</strong></p>
<p>For anyone still searching for how to do this, the standard library <code>functools</code> includes a decorator function <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>@functools.lru_cache</code></a> to do this. </p>
<p>For example (from the docs): </p>
<pre><code>@lru_cache(maxsize=32)
def get_pep(num):
    'Retrieve text of a Python Enhancement Proposal'
    resource = 'http://www.python.org/dev/peps/pep-%04d/' % num
    try:
        with urllib.request.urlopen(resource) as s:
            return s.read()
    except urllib.error.HTTPError:
        return 'Not Found'
</code></pre>
<p>This would store the last <code>32</code> calls to <code>get_pep</code> and when it is called with the same argument, the cached value will be returned. </p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python" title="what is memoization and how can i use it in python">stackoverflow.com/questions/1988804/â€¦</a> - this solves a more general problem.</span>
<span class="comment-copy">You dont want to have an updated copy of the database each time ?</span>
<span class="comment-copy">@NPE Not really related. That deals only with Dynamic Programming.</span>
<span class="comment-copy">@AshRj: The technique is far more widely applicable than dynamic programming.</span>
<span class="comment-copy">Gosh! Never thought of this simple solution! Thanks!</span>
