<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/14986568/python-how-to-ensure-that-del-method-of-an-object-is-called-before-the-mod">Python how to ensure that __del__() method of an object is called before the module dies?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have a global instance, which I expect to be destroyed (function <code>__del__</code> called) when the Python interpreter exits. Am I expecting too much of the Python interpreter?
My method of testing this is to put a print in the <code>__del__</code> function, run <code>python.exe</code> from a command line, and then pressing Ctrl/Break. At this point, I would expect to see the print in the command-line window. However, I do not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you're expecting too much. Python <a href="http://docs.python.org/3/reference/datamodel.html?highlight=__del__#object.__del__" rel="nofollow">doesn't make any guarantees</a> about calling <code>__del__</code>:</p>
<blockquote>
<p>It is not guaranteed that <code>__del__()</code> methods are called for objects that still exist when the interpreter exits.</p>
</blockquote>
<p>Edit:</p>
<p>Generally, you should avoid using <code>__del__</code>. For most cases context managers are better. For the rare case when you need to make sure that some external (i.e. allocated from C code) resource gets cleaned up when the interpreter exits you can use the <a href="http://docs.python.org/3/library/atexit.html" rel="nofollow"><code>atexit</code> module</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could add a handler for the <code>signal.SIGBREAK</code> signal.  That would let you intercept <code>ctrl</code> + <code>break</code>.  Form <a href="http://docs.python.org/2/library/signal.html#example" rel="nofollow">the documentation</a>:</p>
<pre><code>import signal, os

def handler(signum, frame):
    print 'Someone is trying to exit!', signum

signal.signal(signal.SIGBREAK, handler)
</code></pre>
</div>
<span class="comment-copy">OK, I have noticed a difference between terminating the Python interpreter with Ctrl/Break (<b>del</b> not called) and with Ctrl/C (<b>del</b> called). I therefore assume that the Ctrl/Break kills the process, whereas Ctrl/C ends it properly. What should I expect from closing the window then? (perhaps this question should be asked in a different forum though).</span>
<span class="comment-copy">also of interest:  <a href="http://stackoverflow.com/q/14628486/748858">stackoverflow.com/q/14628486/748858</a></span>
<span class="comment-copy">And another reason you shouldn't rely on <code>__del__</code>:  <a href="http://stackoverflow.com/a/14323849/748858">stackoverflow.com/a/14323849/748858</a></span>
<span class="comment-copy">My aim is to save the current state into a database just before the executable instance (which contains the global object in memory) is terminated. Is it conceptually wrong to perform DB operations in the destructor?</span>
<span class="comment-copy">Would this handle closing the window as well?</span>
<span class="comment-copy">No.  @Lqc's answer is a better fit</span>
<span class="comment-copy">Thank you very much!</span>
