<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>alist =  [11,12,13,11,15]
blist = ['A', 'A', 'B', 'A', 'B']
</code></pre>
<p>I want to make a dictionary where items in blist are keys and items in alist are values with lists corresponding to indices in the two lists:</p>
<p>the outcome should be:</p>
<pre><code>{'A': [11, 12, 11], 'B': [13, 15]}
</code></pre>
<p>I have tried this:</p>
<pre><code>dictNames = {}
for i in xrange(len(alist)):
    for letter in blist:
        if letter not in dictNames:
            dictNames[letter] = []
        else:
            dictNames[letter].append(alist[i])
</code></pre>
<p>which gives the outcome:</p>
<pre><code>{'A': [11, 11, 12, 12, 12, 13, 13, 13, 11, 11, 11, 15, 15, 15], 'B': [11, 12, 12, 13, 13, 11, 11, 15, 15]}
</code></pre>
<p>Why does it not append to the pre-existing letter in the dictionary instead of adding to it when it is already in the dictionary? </p>
</div>
<div class="post-text" itemprop="text">
<p>First, you loop over both lists. For every item in alist, it loops through blist. So the inner loop runs 25 times. Instead, you want it to run 5 times, so you want only one loop.</p>
<p>Second, you correctly initialize the list if it does not yet exist, but in that case the number is not added to the list. The number should always be added to the list, even if it is a new list.</p>
<p>I changed your code to take these two things into account, and it works a little better:</p>
<pre><code>for i in xrange(len(alist)):
    letter = blist[i]
    if letter not in dictNames:
        dictNames[letter] = []
    dictNames[letter].append(alist[i])
</code></pre>
<p>Output:</p>
<pre><code>{'A': [11, 12, 11], 'B': [13, 15]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <code>defaultdict</code> for ease:</p>
<pre><code>from collections import defaultdict

dictNames = defaultdict(list)
for key, value in zip(blist, alist):
    dictNames[key].append(value)
</code></pre>
<p>This creates:</p>
<pre><code>&gt;&gt;&gt; dictNames
defaultdict(&lt;type 'list'&gt;, {'A': [11, 12, 11], 'B': [13, 15]})
</code></pre>
<p><code>defaultdict</code> is a subclass of <code>dict</code> so it'll still work just like any other <code>dict</code>.</p>
<p>Without <code>defaultdict</code> you'll have to test if the key is already present with <code>setdefault()</code>:</p>
<pre><code>dictNames = {}
for key, value in zip(blist, alist):
    dictNames.setdefault(key, []).append(value)
</code></pre>
<p>resulting in:</p>
<pre><code>&gt;&gt;&gt; dictNames
{'A': [11, 12, 11], 'B': [13, 15]}
</code></pre>
<p>The real trick here is using <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code></a> to combine your key and value lists instead of your double loops.</p>
</div>
<div class="post-text" itemprop="text">
<p>This way preserves order</p>
<pre><code>from collections import defaultdict

alist =  [11,12,13,11,15]
blist = ['A', 'A', 'B', 'A', 'B']

d = defaultdict(list)
seen = defaultdict(set)

for k, v in zip(blist, alist):
    if v not in seen[k]:
        d[k].append(v)
        seen[k].add(v)

print d
</code></pre>
<hr/>
<pre><code>defaultdict(&lt;type 'list'&gt;, {'A': [11, 12], 'B': [13, 15]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a one-line solution:</p>
<pre><code> {k: [alist[i] for i in range(len(blist)) if blist[i] == k] for k in set(blist)}
</code></pre>
<p>The only problem is that the time complexity is O(n^2) in worst case, inadequate for large lists. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is the shortest expression I can come up with currently:</p>
<pre><code>from itertools import groupby

{k: {x[1] for x in v} for k, v in groupby(sorted(zip(blist, alist)), lambda x: x[0])}
</code></pre>
<p>The relevant (and not yet mentioned) part is the call to <code>groupby</code>, also described in the following similar question: <a href="https://stackoverflow.com/questions/3749512/python-group-by">Python group by</a></p>
</div>
<span class="comment-copy">thatÂ´s great - I get it! thanks!</span>
<span class="comment-copy">Probably even better with list.enumerate().</span>
<span class="comment-copy">This works except you will have duplicate <code>11</code>s</span>
<span class="comment-copy">Indeed, that shoud be <code>defaultdict(set)</code>. Also the mapping should be the other way around.</span>
<span class="comment-copy">how would I do it without the default dict (so I understand the logic better...)?</span>
<span class="comment-copy">@edg <code>defaultdict</code> is easy, but it's the same as <code>d.setdefault(k, []).append(val)</code></span>
<span class="comment-copy">@edg: in your example output, the duplicates have been removed.</span>
