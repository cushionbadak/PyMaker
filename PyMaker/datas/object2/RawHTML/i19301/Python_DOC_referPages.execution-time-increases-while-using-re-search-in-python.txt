<div class="post-text" itemprop="text">
<p>I am processing a 500MB file. the processing time increased when used re.search.</p>
<p>Please find the below cases i have tested. In all the cases i am reading file line by line and using only one <code>if</code> condition.</p>
<p>Case1:</p>
<pre><code>prnt = re.compile(r"(?i)&lt;spanlevel level='7'&gt;")
if prnt.search(line):
print "Matched"
out_file.write(line)
else:
out_file.write(line) 
</code></pre>
<p>This has taken 16 seconds to read the entire file.</p>
<p>Case2:</p>
<pre><code>if re.search(r"(?i)&lt;spanlevel level='7'&gt;",line):
print "Matched"
out_file.write(line)
else:
out_file.write(line)
</code></pre>
<p>This has taken 25 seconds to read the file.</p>
<p>Case3:</p>
<pre><code>if "&lt;spanlevel level='7'&gt;" in line:
print "Matched"
out_file.write(line)
else:
out_file.write(line)
</code></pre>
<p>This has taken only 8 seconds to read the file.</p>
<p>Can any one of you please let know the diference between the three cases. and Case3 is processing very fast but i am unable to do case-insensitive match. how to do a case-insensitive match in Case3 ?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Case insensitive search for case 3 first:</p>
<pre><code>if "&lt;spanlevel level='7'&gt;" in line.lower():
</code></pre>
<p>By lowercasing <code>line</code>, you make that a lowercase search.</p>
<p>As for why case 2 is so much slower: using a pre-compiled regular expression is going to be faster, as you then avoid the cache lookup for the regular expression pattern for each and every line you read from the file. Under the hood, <code>re.search()</code> will also call <code>re.compile()</code> if no cached copy already exists and that extra function call and cache check is going to cost you.</p>
<p>That is doubly painful on Python 3.3, which switched to a new caching model using the <a href="http://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code> decorator</a>, one that is actually slower than the previous implementation. See <a href="https://stackoverflow.com/questions/14756790/why-are-uncompiled-repeatedly-used-regexes-so-much-slower-in-python-3/14757032#14757032">Why are uncompiled, repeatedly used regexes so much slower in Python 3?</a></p>
<p>A simple text search with <code>in</code> is faster for exact text matches. Regular expressions are great for complex matching, you are simply looking for an exact match, albeit case insensitive.</p>
</div>
<span class="comment-copy">Generally, when you are not in need of regex, don't use it. Regex is usually more expensive than character scanning or indexOf</span>
<span class="comment-copy">You are using Python 2 syntax but tagged this with <code>python-3.x</code>. What is it, python 2 or 3?</span>
<span class="comment-copy">@MartijnPieters I am using python 2.7</span>
<span class="comment-copy">The <i>fastest</i> way to do this would probably be to clone the <a href="http://hg.python.org/cpython/file/2.7/Objects/stringlib/fastsearch.h" rel="nofollow noreferrer"><code>fastsearch</code></a> C implementation behind <code>str.find</code>, modify it to be case-insensitive, build an <code>ifind</code> extension module around it, then run that against an <code>mmap</code> of your file. But that's a lot of work. Unless someone's already done it and posted it on PyPI, or this is really important to your work, either your "case 1" or Martijn Pieters' answer is probably good enough, right?</span>
<span class="comment-copy">Not completely related, but using <code>re.finditer</code> on a <code>mmap</code> file might also be a suitable alternative.</span>
<span class="comment-copy">Martijn: It doesn't look like the OP's using Python 3.</span>
<span class="comment-copy">@martineau: I looked at the tags. Although the use <code>print</code> statement is incongruous.</span>
<span class="comment-copy">@martineau: Thanks for pointing that out, the question tag was indeed incorrect.</span>
<span class="comment-copy">Martijn: Sure...and even though it didn't apply, the references in your answer about the Py 3.3 issues is good information to disseminate.</span>
