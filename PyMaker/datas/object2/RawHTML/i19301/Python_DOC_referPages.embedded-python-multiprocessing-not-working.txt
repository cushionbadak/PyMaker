<div class="post-text" itemprop="text">
<p>I'm using Python 3.1.4 that is embedded as a scripting environment in an application(x64).
So far I have encountered a lot of limitations with the embedded python. I don't know if it is normal or if the programmers of the application have blocked some functionalities. </p>
<p>For example the following code isn't working:</p>
<pre><code>from multiprocessing import Process
def f(name):
    print('hello', name)

if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()

# --&gt; error in forking.py: 'module' object has no attribute 'argv'
# print(sys.argv) gives the same error
</code></pre>
<p><code>sys.executable</code> return the path to the application. </p>
<p>I've tried this as wel:</p>
<pre><code>multiprocessing.forking.set_executable('C:\Python31\python.exe')
multiprocessing.set_executable('C:\Python31\python.exe')
</code></pre>
<p>Without success.</p>
<p>Is there a workaround possible ? It is very unlikely that I would have the leverage to make the developers of the application change something in their code. </p>
<p>Thanks</p>
<p><strong>EDIT</strong></p>
<p>I got it to work by adding the following:</p>
<p><code>sys.argv = ['c:/pathToScript/scipt.py']</code></p>
<p>I needed this line as well:</p>
<p><code>multiprocessing.set_executable('C:/Python31/python.exe')</code></p>
<p>Otherwise an other instance of the application open instead of running the code.</p>
<p>The only problem I have left is that I can't use the methods that control the application itself (like: create_project(), add_report(),..). My primary goal was to be able to call multiple methods without the need to wait for the first one to finish completion. But I think this is just not possible. </p>
</div>
<div class="post-text" itemprop="text">
<p>By default, <code>sys.argv</code> is not available in embedded code:</p>
<blockquote>
<h1><a href="http://docs.python.org/3/c-api/intro.html#embedding-python" rel="noreferrer">Embedding Python</a></h1>
<p>The basic initialization function is Py_Initialize(). This initializes
  the table of loaded modules, and creates the fundamental modules
  builtins, __main__, and sys. It also initializes the module search
  path (sys.path).</p>
<p>Py_Initialize() does not set the “script argument list” (sys.argv). If
  this variable is needed by Python code that will be executed later, it
  must be set explicitly with a call to PySys_SetArgvEx(argc, argv,
  updatepath) after the call to Py_Initialize()</p>
</blockquote>
<p>On Windows, <code>multiprocessing</code> must spawn new processes from scratch. It uses a command line switch <code>--multiprocessing-fork</code> to distinguish child processes, and also transmits the original <code>argv</code> from parent to child.</p>
<p>Assigning <code>sys.argv = ['c:/pathToScript/scipt.py']</code> before creating subprocesses, like you discovered, 
would seem to be a good workaround.</p>
<p>A second relevant piece of documentation is that of <a href="http://docs.python.org/2/library/multiprocessing.html#multiprocessing.set_executable" rel="noreferrer"><code>multiprocessing.set_executable()</code></a>:</p>
<blockquote>
<p>Sets the path of the Python
  interpreter to use when starting a child process. (By default
  <code>sys.executable</code> is used). Embedders will probably need to do some thing
  like</p>
<p><code>set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))</code> <br/>before
  they can create child processes. (Windows only)</p>
</blockquote>
</div>
<span class="comment-copy">are you sure you don't mean to use threading instead of multiprocessing?</span>
<span class="comment-copy">Which OS?......</span>
<span class="comment-copy">@ Ionut Hulub: I've problems as well with threading, something with the GIL I presume. That's why I tried with multiprocessing   @ NPE: Windows 7, 64bit</span>
