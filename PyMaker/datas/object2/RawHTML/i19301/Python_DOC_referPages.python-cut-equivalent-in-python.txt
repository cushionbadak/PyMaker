<div class="post-text" itemprop="text">
<p>I want to parse a path (not filename) by the forward slash. Below takes the full path "filename" and reads up to the 7th "/". </p>
<p><strong>EDIT: I realized the above was confusing when I stated filename. I meant, I needed to parse the full path. e.g. I could need the first 7 "/"s  to the left and remove 5 trailing "/"s.</strong> </p>
<p>Python:</p>
<pre><code>"/".join(filename.split("/")[:7])
</code></pre>
<p>Bash:</p>
<pre><code>some command that prints filename | cut -d'/' -f1-7`
</code></pre>
<p>It looks so much cleaner with the cut tool. Is there a better/ more efficient way to write this in Python? </p>
</div>
<div class="post-text" itemprop="text">
<p>Usually I would recommend using functions from the <a href="http://docs.python.org/3/library/os.path.html" rel="nofollow"><code>os.path</code></a> module for handling paths.  I prefer to let the library handle all of the edge cases that can occur with valid paths.</p>
<p>As was you pointed out in the comments, <a href="http://docs.python.org/3/library/os.path.html#os.path.split" rel="nofollow"><code>os.path.split()</code></a> splits just the last path element.  To use it, one could write:</p>
<pre><code>l = []
while True:
    head, tail = os.path.split(filename)
    l.insert(0, tail)
    if head == "/":
        l.insert(0, "")
        break
    filename = head
"/".join(l[:7])
</code></pre>
<p>Although more verbose, this will correctly normalize artifacts such as
duplicate slashes.</p>
<p>On the other hand, your use of <code>string.split()</code> matches the semantics of <code>cut(1)</code>.</p>
<p><hr/>
Sample test cases:</p>
<pre class="lang-bsh prettyprint-override"><code>$ echo '/a/b/c/d/e/f/g/h' | cut -d'/' -f1-7 
/a/b/c/d/e/f

$ echo '/a/b/c/d/e/f/g/h/' | cut -d'/' -f1-7 
/a/b/c/d/e/f

$ echo '/a//b///c/d/e/f/g/h' | cut -d'/' -f1-7
/a//b///c
</code></pre>
<hr/>
<pre><code># Tests and comparison to string.split()

import os.path

def cut_path(filename):
    l = []
    while True:
        head, tail = os.path.split(filename)
        l.insert(0, tail)
        if head == "/":
            l.insert(0, "")
            break
        filename = head
    return "/".join(l[:7])

def cut_string(filename):
    return "/".join( filename.split("/")[:7] )

def test(filename):
    print("input:", filename)
    print("string.split:", cut_string(filename))
    print("os.path.split:", cut_path(filename))
    print()

test("/a/b/c/d/e/f/g/h")
test("/a/b/c/d/e/f/g/h/")
test("/a//b///c/d/e/f/g/h")

# input: /a/b/c/d/e/f/g/h
# string.split: /a/b/c/d/e/f
# os.path.split: /a/b/c/d/e/f
#
# input: /a/b/c/d/e/f/g/h/
# string.split: /a/b/c/d/e/f
# os.path.split: /a/b/c/d/e/f
#
# input: /a//b///c/d/e/f/g/h
# string.split: /a//b///c
# os.path.split: /a/b/c/d/e/f
</code></pre>
</div>
<span class="comment-copy">I don't think this does what I want. os.path.split splits the filename from the directory it's in, contained in a 2 element array. Rather, I need to split up the path based on number of slashes and return a single string. [:7] doesn't even make sense here.</span>
<span class="comment-copy">Updated my question. It was a little misleading.</span>
<span class="comment-copy">Good point.  I should have paid closer attention to the documentation to which I linked.  I updated my answer accordingly.</span>
