<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/2/reference/expressions.html#is" rel="noreferrer">is</a> operator is used test for identity.</p>
<p>I was wondering if the <code>is</code> operator and <code>id()</code> function call any <code>__magic__</code> method, the way <code>==</code> calls <code>__eq__</code>.</p>
<p>I had some fun checking out <code>__hash__</code>:</p>
<pre><code>class Foo(object):
    def __hash__(self):
        return random.randint(0, 2 ** 32)

a = Foo()
b = {}
for i in range(5000):
    b[a] = i
</code></pre>
<p>Think about dict <code>b</code> and the value of <code>b[a]</code></p>
<blockquote class="spoiler">
<p> Every subsequent lookup of <code>d[a]</code> is either a <code>KeyError</code> or a random integer.</p>
</blockquote>
<p>But as the <a href="http://docs.python.org/2/reference/datamodel.html#specialnames" rel="noreferrer">docs on the special methods</a> state</p>
<blockquote>
<p>[<em>the default implementation of</em>] x.<code>__hash__</code>() returns id(x).</p>
</blockquote>
<p>So there <em>is</em> relation between the two, but just the other way around. </p>
<p>I've seen many <a href="https://stackoverflow.com/q/13650293/383793">questions</a> on <code>is</code> and <code>id</code> here, and the <a href="https://stackoverflow.com/a/2038341/383793">answers</a> have helped many <a href="https://stackoverflow.com/q/13062135/383793">confused</a> minds, but I couldn't find an answer to this one.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, <code>is</code> is a straight pointer comparison, and <code>id</code> just returns the address of the object cast to a <code>long</code>.</p>
<p>From <a href="http://hg.python.org/cpython/file/bd8afb90ebf2/Python/ceval.c#l4423"><code>ceval.c</code></a>:</p>
<pre><code>case PyCmp_IS:
    res = (v == w);
    break;
case PyCmp_IS_NOT:
    res = (v != w);
    break;
</code></pre>
<p><code>v</code> and <code>w</code> here are simply <code>PyObject *</code>.</p>
<p>From <a href="http://hg.python.org/cpython/file/bd8afb90ebf2/Python/bltinmodule.c#l962"><code>bltinmodule.c</code></a>:</p>
<pre><code>static PyObject *
builtin_id(PyObject *self, PyObject *v)
{
    return PyLong_FromVoidPtr(v);
}

PyDoc_STRVAR(id_doc,
"id(object) -&gt; integer\n\
\n\
Return the identity of an object. This is guaranteed to be unique among\n\
simultaneously existing objects. (Hint: it's the object's memory address.)");
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is: No, they do not. As the docs that you link to say:</p>
<blockquote>
<p>The operators <code>is</code> and <code>is not</code> test for object identity: <code>x is y</code> is true if and only if <code>x</code> and <code>y</code> are the same object.</p>
</blockquote>
<p>Being "the same object" is not something you're allowed to override. If your object is not the same object as another, it cannot pretend to be.</p>
<hr/>
<p>So… Why? What would be the harm of letting you override <code>is</code> and/or <code>id</code>? Obviously it would almost always be a stupid thing to do, but Python lets you do a lot of stupid things if you try hard enough.</p>
<p>The design FAQ and similar documents don't say. But I suspect it's primarily because it makes it easier to debug Python and some of the deeper standard library modules, knowing there is some way, from within the interpreter, to verify that two names really do refer to the same object, or to print out the <code>id</code> to make sure a name hasn't changed over time, etc. Imagine debugging <code>weakref</code>, or even <code>pickle</code>, without that.</p>
<hr/>
<p>So, what exactly does "same object" mean? Well, that's up to the interpreter. Obviously it has to be impossible to distinguish two instances of the same object at the language level, and probably at the interpreter level as well (especially since there's a well-defined API for plugging into most interpreter implementations).</p>
<p>All of the major implementations handle this by deferring to the notion of identity at the lower level. CPython compares the values of the <code>PyObject*</code> pointers, Jython identity-compares the Java references, PyPy does an <code>is</code> on the objectspace objects…</p>
<p>It's worth looking at the <a href="https://bitbucket.org/pypy/pypy/src/ca87ef6535e0/pypy/interpreter/baseobjspace.py?at=pytest-update#cl-648" rel="noreferrer">PyPy source</a>, which requires the "<code>x is y</code> iff <code>x</code> and <code>y</code> are the same object" to be true in both directions. The top-level expression <code>x is y</code> is true iff, whatever objects <code>wx</code> and <code>wy</code> in the appropriate objectspace are, <code>wy.is_(wx)</code> is true, and <code>is_</code> is implemented as <code>wy is wx</code>. So, <code>x is y</code> at level N iff <code>y is x</code> at level N-1.</p>
<hr/>
<p>Notice that this means you could pretty easily use PyPy to build a dialect of Python where <code>is</code> <em>can</em> be overridden, just by attaching <code>is_</code> to a dunder method <code>__is__</code> at the higher level. But there's a simpler way to do the same thing:</p>
<pre><code>def is_(x, y):
    if hasattr(x, '__is__'):
        return x.__is__(y)
    elif hasattr(y, '__is__'):
        return y.__is__(x)
    else:
        return x is y
</code></pre>
<p>Now play with <code>is_(x, y)</code> instead of <code>x is y</code>, and see if you can find any fun trouble before doing the hard work of modifying the interpreter (even if it isn't that hard, in this case).</p>
<hr/>
<p>So, what does <code>is</code> have to do with <code>id</code>? Could <code>is</code> be implemented on top of <code>id</code>—e.g., <code>x is y</code> just checks <code>id(x) == id(y)</code>? Well, <a href="http://docs.python.org/3/library/functions.html#id" rel="noreferrer"><code>id</code></a>:</p>
<blockquote>
<p>Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same <code>id()</code> value.</p>
</blockquote>
<p>So, the <code>id</code> of an object is unique and constant during its lifetime, and <code>x is y</code> is true iff they're the same object, therefore <code>x is y</code> is true iff <code>id(x) == id(y)</code>, right?</p>
<p>Well, <code>id</code> can be rebound to whatever you want, and that isn't allowed to affect <code>is</code>. If you crafted the definition very carefully (keep in mind that if you discard the <code>builtins</code> reference to <code>id</code>, whatever implementation used to be there isn't even guaranteed to exist anymore, or to work correctly if it does exist…), you <em>could</em> define <code>is</code> on top of the default implementation of <code>id</code>.</p>
<p>But it would be an odd thing to do. In CPython, where <code>id(x)</code> just "returns the address of the object in memory", which is the same thing as the value of the pointer to the object in memory. But that's just an artifact of CPython; there's nothing saying other implementations have to make <code>id</code> return the underlying value used for identity comparison as an integer. In fact, it's not clear how you'd even do that in an implementation written in a language without pointers (that can be cast to integers). In PyPy, the <code>id</code> of an object may even be a value computed the first time it's accessed and stashed in a dictionary in the objectspace, keyed by the object itself. </p>
<hr/>
<p>As for <code>__hash__</code>, you're misreading an important part of the docs.</p>
<blockquote>
<p>[...] <code>x.__hash__()</code> returns <code>id(x)</code>.</p>
</blockquote>
<p>The part you ellipsized makes it clear that this is only true for instances of user-defined classes (that don't redefine <code>__hash__</code>). It's obviously not true for, e.g., <code>tuple</code>. In short, identity has nothing to do with hashing, except that for some objects the identity makes a convenient hash value.</p>
</div>
<span class="comment-copy">Your example is actually quite amusing. Favourited for that :)</span>
<span class="comment-copy">That definition of the default <code>hash</code> isn't right. In CPython, <code>PyBaseObject_Type.tp_hash</code> is <code>long _Py_HashPointer(void *p) {long x; size_t y = (size_t)p; y = (y &gt;&gt; 4) | (y &lt;&lt; (8 * SIZEOF_VOID_P - 4)); x = (long)y; if (x == -1) x = -2; return x;}</code> This rotates the address by 4 bits to reduce hash collisions, given the bottom 2-4 bits of the address are probably 0.</span>
<span class="comment-copy">+1 for digging into the source (which I was too lazy to do ;))</span>
<span class="comment-copy">A line of code is worth a thousand pictures.</span>
<span class="comment-copy">This answer is specific to CPython; in other implementations (at least Jython and PyPy), <code>is</code> is not pointer comparison, and <code>id</code> does not return the address.</span>
<span class="comment-copy">"If your object is not the same object as another, it cannot pretend to be."  +1</span>
