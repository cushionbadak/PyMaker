<div class="post-text" itemprop="text">
<p>I have K python files that need to exist everywhere, previously I tried to seperate their logic and import them one by one at every python code, now I just want to circularly import every one of those K files inside each other.</p>
<p>It seems that this could result in K^2 load, however I couldn't free enough brain space to actually think about it.</p>
<p>Lets say K=4 and there are a.py,b.py,c.py,d.py: I'm thinking of importing everything from b.py,c.py,d.py at the end of a.py -and- b.py c.py and d.py will just import a.py at the top. And an any.py just imports a.py as everything is already inside it.</p>
<p>The alternative is any.py imports a.py b.py c.py d.py, however it's hard too keep those 4 separate.</p>
</div>
<div class="post-text" itemprop="text">
<p>As all the comments have pointed out, this is a suspicious design that likely to mislead you and your collaborators/readers, make maintenance harder, etc.</p>
<p>But it's not a performance issue.</p>
<p>When you call import on the same thing multiple times, it takes constant (and almost no) time each time after the first. The (default) import mechanism looks it up in sys.modules, sees that it's already there, and returns it. So, there is no O(K^2) going on here; it's O(K). </p>
<p>You can test this for yourself very easily. Create these files:</p>
<pre><code># a.py
print('a')
import b
import c

# b.py
import a
print('b')

# c.py
import a
print('c')
</code></pre>
<p>Now, fire up a Python interpreter and do this:</p>
<pre><code>&gt;&gt;&gt; import a
a
b
c
&gt;&gt;&gt; import b
&gt;&gt;&gt; import a
</code></pre>
<p>Each item appears exactly once, because the importer never gets to the <code>print</code> statement after the first time.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is basically what packages are for. Put all the Python files in a directory, add an <code>__init__.py</code> that imports them all, and then you can just import the directory as a Python module.</p>
</div>
<span class="comment-copy">If you had tried this you would've found some interesting results. The basic gist is that it is impossible to do your setup without resorting to hacks.</span>
<span class="comment-copy">Actually I wrote the explanation in the 3rd paragraph wrong, let me edit the question, only a.py is going to import others at the end of the file and others will just import a.py at the top, should work then</span>
<span class="comment-copy">why not? it simplifies stuff for me</span>
<span class="comment-copy">instead of keeping thousands of lines at one file, can separate it into several files but at the same time keep the scope</span>
<span class="comment-copy">Splitting it into three physical files that still have tons of dependencies with one another doesn't have any benefit. The benefit of decent modules is their <i>modularity</i> -- a decent module can, to some degree, be treated in isolation. Your hypothetical splitting doesn't yield and modularity or other benefit. Besides, why do you worry about performance anyway? It doesn't matter for your use case, it often doesn't matter at all, this has no chance of affecting overall performance, there are billions of lower-hanging fruit, etc. In other words, you seem to have your priorities backwards.</span>
<span class="comment-copy">I also tested something similar after unhelpful comments, additionally in an appengine environment to see whether circular imports have any side effects in that environment (imports not getting cached etc.) and concluded the same, thanks for the answer</span>
<span class="comment-copy">@KaanSoral: This behavior is documented in <a href="http://docs.python.org/2/reference/simple_stmts.html#the-import-statement" rel="nofollow noreferrer">The <code>import</code> statement</a> and the various links from there (although this is one of the places where the 3.x documentation is a whole lot better—see <a href="http://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">The import system</a>—even if a few details are not correct for 2.x). Unless you build custom import hooks or otherwise screw with the system, this is guaranteed to be true in any Python environment, or even implementation.</span>
<span class="comment-copy">Interesting, I tried to test it with a simple directory importing two files, inside those files there are 3 functions, they basically call each other py1 to py2 to py1, to see whether the scope is the same, however it wasn't, are you sure every file in that package will share the same scope after importing the whole module?</span>
<span class="comment-copy">@KaanSoral: I'm not sure what you mean by <code>scope</code> here. Please give a concrete example of what you expected and what you saw.</span>
<span class="comment-copy">basically, lets say there are 2 files and each has many functions inside, functions from those 2 files can't call each other, only the last imported file's function can call the functions from the first imported file, imports are in <b>init</b>.py as you mentioned, this is what I saw</span>
