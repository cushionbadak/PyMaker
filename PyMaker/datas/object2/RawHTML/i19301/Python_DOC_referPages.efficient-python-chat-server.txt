<div class="post-text" itemprop="text">
<p>I am now writing a unicast chat server model, the flow will be as follows:</p>
<ul>
<li>Sender send out message to the chat server, in the message the server also specify the message recipient id</li>
<li>The chat server will route the message to the right client, based on the recipient id</li>
</ul>
<p>I implemented the chat server model using python standard library asyncore. I found that the CPU goes up, once the client connect to the server (1% vs 24%). I believe the performance is limited by the looping of the handle_write function.</p>
<p>Is there a better (e.g. more efficient) framework to accomplish my chat server requirement?</p>
<p>Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course we'd need actual code to debug the problem. But what you're mainly asking is:</p>
<blockquote>
<p>Is there a better (e.g. more efficient) framework to accomplish my chat implementation?</p>
</blockquote>
<p>Yes. It's generally accepted that <code>asyncore</code> sucks. It's hard to use as well as being inefficient. It's especially bad on Windows, because <code>select</code> especially sucks on Windows.</p>
<p>So, yes, using a different framework will probably make things better.</p>
<p>Unfortunately, an SO question is not a good place to get recommendations for frameworks, but I can throw out a list of usual suspects: <a href="http://twistedmatrix.com" rel="nofollow">twisted</a>, <a href="https://github.com/saucelabs/monocle" rel="nofollow">monocle</a>, <a href="http://gevent.org" rel="nofollow">gevent</a>, <a href="http://eventlet.net/" rel="nofollow">eventlet</a>, <a href="http://www.python.org/dev/peps/pep-3156/" rel="nofollow">tulip</a>.</p>
<p>Alternatively, if you're not worried about scalability to more than a few dozen clients, just about performance at the small scale, using a thread per client (or even two threads, one for reads and one for writes) and blocking I/O is incredibly simple.</p>
<p>Finally, if you're staying up to date with Python 3.x, there's a good chance that 3.4 will have a new and improved async I/O module that's much more efficient and much easier to use than <code>asyncore</code> (and it will almost certainly be based on <code>tulip</code>). So… the best solution may be to get a time machine and go forward a few months. (Or, if you're a reader searching for this answer in the future, look in the standard library under <a href="http://docs.python.org/3/library/ipc.html" rel="nofollow">IPC</a> and guess which module is the new-and-improved async I/O module.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I just read from a web, talking about the efficiency between different python web servers (<a href="http://nichol.as/benchmark-of-python-web-servers" rel="nofollow">Link</a>).</p>
<p>I think I will use gevent as it is very efficient (seems).</p>
</div>
<span class="comment-copy">Not really a question, but look at <a href="http://eventlet.net/" rel="nofollow noreferrer">eventlet</a></span>
