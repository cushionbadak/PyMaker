<div class="post-text" itemprop="text">
<p>I'd interacting with a lot of deeply nested json I didn't write, and would like to make my python script more 'forgiving' to invalid input. I find myself writing involved try-except blocks, and would rather just wrap the dubious function up.</p>
<p>I understand it's a bad policy to swallow exceptions, but I'd rather prefer they to be printed and analysed later, than to actually stop execution. It's more valuable, in my use-case to continue executing over the loop than to get all keys.</p>
<p>Here's what I'm doing now:</p>
<pre><code>try:
    item['a'] = myobject.get('key').METHOD_THAT_DOESNT_EXIST()
except:
    item['a'] = ''
try:
    item['b'] = OBJECT_THAT_DOESNT_EXIST.get('key2')
except:
    item['b'] = ''
try:
    item['c'] = func1(ARGUMENT_THAT_DOESNT_EXIST)
except:
    item['c'] = ''
...
try:
    item['z'] = FUNCTION_THAT_DOESNT_EXIST(myobject.method())
except:
    item['z'] = ''
</code></pre>
<p>Here's what I'd like, (1):</p>
<pre><code>item['a'] = f(myobject.get('key').get('subkey'))
item['b'] = f(myobject.get('key2'))
item['c'] = f(func1(myobject)
...
</code></pre>
<p>or (2):</p>
<pre><code>@f
def get_stuff():
   item={}
   item['a'] = myobject.get('key').get('subkey')
   item['b'] = myobject.get('key2')
   item['c'] = func1(myobject)
   ...
   return(item)
</code></pre>
<p>...where I can wrap either the single data item (1), or a master function (2), in some function that turns execution-halting exceptions into empty fields, printed to stdout.  The former would be sort of an item-wise skip - where that key isn't available, it logs blank and moves on - the latter is a row-skip, where if any of the fields don't work, the entire record is skipped.</p>
<p>My understanding is that some kind of wrapper should be able to fix this.  Here's what I tried, with a wrapper:</p>
<pre><code>def f(func):
   def silenceit():
      try:
         func(*args,**kwargs)
      except:
         print('Error')
      return(silenceit)
</code></pre>
<p>Here's why it doesn't work.  Call a function that doesn't exist, it doesn't try-catch it away:</p>
<pre><code>&gt;&gt;&gt; f(meow())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'meow' is not defined
</code></pre>
<p>Before I even add a blank return value, I'd like to get it to try-catch correctly.  If the function had worked, this would have printed "Error", right?  </p>
<p>Is a wrapper function the correct approach here?</p>
<p><strong>UPDATE</strong></p>
<p>I've had a lot of really useful, helpful answers below, and thank you for them---but I've edited the examples I used above to illustrate that I'm trying to catch more than nested key errors, that I'm looking specifically for a function that wraps a try-catch for...</p>
<ol>
<li>When a method doesn't exist. </li>
<li>When an object doesn't exist, and is getting a method called on it. </li>
<li>When an object that does not exist is being called as an argument to a function. </li>
<li>Any combination of any of these things. </li>
<li>Bonus, when a function doesn't exist.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You could use a defaultdict and <a href="https://speakerdeck.com/pyconslides/transforming-code-into-beautiful-idiomatic-python-by-raymond-hettinger-1">the context manager approach as outlined in Raymond Hettinger's PyCon 2013 presentation</a></p>
<pre><code>from collections import defaultdict
from contextlib import contextmanager

@contextmanager
def ignored(*exceptions):
  try:
    yield
  except exceptions:
    pass 

item = defaultdict(str)

obj = dict()
with ignored(Exception):
  item['a'] = obj.get(2).get(3) 

print item['a']

obj[2] = dict()
obj[2][3] = 4

with ignored(Exception):
  item['a'] = obj.get(2).get(3) 

print item['a']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are lots of good answers here, but I didn't see any that address the question of whether you can accomplish this via decorators.</p>
<p>The short answer is "no," at least not without structural changes to your code.  Decorators operate at the function level, not on individual statements.  Therefore, in order to use decorators, you would need to move each of the statements to be decorated into its own function.</p>
<p>But note that you can't just put the assignment itself inside the decorated function.  You need to return the rhs expression (the value to be assigned) from the decorated function, then do the assignment outside.</p>
<p>To put this in terms of your example code, one might write code with the following pattern:</p>
<pre><code>@return_on_failure('')
def computeA():
    item['a'] = myobject.get('key').METHOD_THAT_DOESNT_EXIST()

item["a"] = computeA()
</code></pre>
<p><code>return_on_failure</code> could be something like:</p>
<pre><code>def return_on_failure(value):
  def decorate(f):
    def applicator(*args, **kwargs):
      try:
         f(*args,**kwargs)
      except:
         print('Error')

    return applicator

  return decorate
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's very easy to achieve using configurable decorator.</p>
<pre><code>def get_decorator(errors=(Exception, ), default_value=''):

    def decorator(func):

        def new_func(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except errors, e:
                print "Got error! ", repr(e)
                return default_value

        return new_func

    return decorator

f = get_decorator((KeyError, NameError), default_value='default')
a = {}

@f
def example1(a):
    return a['b']

@f
def example2(a):
    return doesnt_exist()

print example1(a)
print example2(a)
</code></pre>
<p>Just pass to get_decorator tuples with error types which you want to silence and default value to return.
Output will be</p>
<pre><code>Got error!  KeyError('b',)
default
Got error!  NameError("global name 'doesnt_exist' is not defined",)
default
</code></pre>
<p><strong>Edit:</strong> Thanks to martineau i changed default value of errors to tuples with basic Exception to prevents errors.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what exceptions you expect.</p>
<p>If your only use case is <code>get()</code>, you could do</p>
<pre><code>item['b'] = myobject.get('key2', '')
</code></pre>
<p>For the other cases, your decorator approach might be useful, but not in the way you do it.</p>
<p>I'll try to show you:</p>
<pre><code>def f(func):
   def silenceit(*args, **kwargs): # takes all kinds of arguments
      try:
         return func(*args, **kwargs) # returns func's result
      except Exeption, e:
         print('Error:', e)
         return e # not the best way, maybe we'd better return None
                  # or a wrapper object containing e.
  return silenceit # on the correct level
</code></pre>
<p>Nevertheless, <code>f(some_undefined_function())</code>won't work, because</p>
<p>a) <code>f()</code> isn't yet active at the executon time and</p>
<p>b) it is used wrong. The right way would be to wrap the function and then call it: <code>f(function_to_wrap)()</code>.</p>
<p>A "layer of lambda" would help here:</p>
<pre><code>wrapped_f = f(lambda: my_function())
</code></pre>
<p>wraps a lambda function which in turn calls a non-existing function. Calling <code>wrapped_f()</code> leads to calling the wrapper which calls the lambda which tries to call <code>my_function()</code>. If this doesn't exist, the lambda raises an exception which is caught by the wrapper.</p>
<p>This works because the name <code>my_function</code> is not executed at the time the lambda is defined, but when it is executed. And this execution is protected and wrapped by the function <code>f()</code> then.  So the exception occurs inside the lambda and is propagated to the wrapping function provided by the decorator, which handles it gracefully.</p>
<p>This move towards inside the lambda function doesn't work if you try to replace the lambda function with a wrapper like</p>
<pre><code>g = lambda function: lambda *a, **k: function(*a, **k)
</code></pre>
<p>followed by a</p>
<pre><code>f(g(my_function))(arguments)
</code></pre>
<p>because here the name resolution is "back at the surface": <code>my_function</code> cannot be resolved and this happens before <code>g()</code> or even <code>f()</code> are called. So it doesn't work.</p>
<p>And if you try to do something like</p>
<pre><code>g(print)(x.get('fail'))
</code></pre>
<p>it cannot work as well if you have no <code>x</code>, because <code>g()</code> protects <code>print</code>, not <code>x</code>.</p>
<p>If you want to protect <code>x</code> here, you'll have to do</p>
<pre><code>value = f(lambda: x.get('fail'))
</code></pre>
<p>because the wrapper provided by <code>f()</code> calls that lambda function which raises an exception which is then silenced.</p>
</div>
<div class="post-text" itemprop="text">
<p>in your case you first evaluate the value of the meow call (which doesn't exist) and then wrap it in the decorator. this doesn't work that way.</p>
<p>first the exception is raised before it was wrapped, then the wrapper is wrongly indented (<code>silenceit</code> should not return itself). You might want to do something like:</p>
<pre><code>def hardfail():
  return meow() # meow doesn't exist

def f(func):
  def wrapper():
    try:
      func()
    except:
      print 'error'
  return wrapper

softfail =f(hardfail)
</code></pre>
<p>output:</p>
<pre><code>&gt;&gt;&gt; softfail()
error

&gt;&gt;&gt; hardfail()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in hardfail
NameError: global name 'meow' is not defined
</code></pre>
<p>anyway in your case I don't understand why you don't use a simple method such as</p>
<pre><code>def get_subkey(obj, key, subkey):
  try:
    return obj.get(key).get(subkey, '')
  except AttributeError:
    return ''
</code></pre>
<p>and in the code:</p>
<pre><code> item['a'] = get_subkey(myobject, 'key', 'subkey')
</code></pre>
<p><strong>Edited:</strong></p>
<p>In case you want something that will work at any depth. You can do something like:</p>
<pre><code>def get_from_object(obj, *keys):
  try:
    value = obj
    for k in keys:
        value = value.get(k)
    return value
  except AttributeError:
    return ''
</code></pre>
<p>That you'd call:</p>
<pre><code>&gt;&gt;&gt; d = {1:{2:{3:{4:5}}}}
&gt;&gt;&gt; get_from_object(d, 1, 2, 3, 4)
5
&gt;&gt;&gt; get_from_object(d, 1, 2, 7)
''
&gt;&gt;&gt; get_from_object(d, 1, 2, 3, 4, 5, 6, 7)
''
&gt;&gt;&gt; get_from_object(d, 1, 2, 3)
{4: 5}
</code></pre>
<p>And using your code</p>
<pre><code>item['a'] = get_from_object(obj, 2, 3) 
</code></pre>
<p>By the way, on a personal point of view I also like @cravoori solution using contextmanager. But this would mean having three lines of code each time:</p>
<pre><code>item['a'] = ''
with ignored(AttributeError):
  item['a'] = obj.get(2).get(3) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you're dealing with lots of broken code, it may be excusable to use <code>eval</code> in this case.</p>
<pre><code>def my_eval(code):
  try:
    return eval(code)
  except:  # Can catch more specific exceptions here.
    return ''
</code></pre>
<p>Then wrap all your potentially broken statements:</p>
<pre><code>item['a'] = my_eval("""myobject.get('key').get('subkey')""")
item['b'] = my_eval("""myobject.get('key2')""")
item['c'] = my_eval("""func1(myobject)""")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not just use cycle?</p>
<pre><code>for dst_key, src_key in (('a', 'key'), ('b', 'key2')):
    try:
        item[dst_key] = myobject.get(src_key).get('subkey')
    except Exception:  # or KeyError?
        item[dst_key] = ''
</code></pre>
<p>Or if you wish write a little helper:</p>
<pre><code>def get_value(obj, key):
    try:
        return obj.get(key).get('subkey')
    except Exception:
        return ''
</code></pre>
<p>Also you can combine both solutions if you have a few places where you need to get value and helper function would be more reasonable.</p>
<p>Not sure that you actually need a decorator for your problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Extending @iruvar answer - starting with Python 3.4 there is an existing context manager for this in Python standard lib: <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="nofollow noreferrer">https://docs.python.org/3/library/contextlib.html#contextlib.suppress</a></p>
<pre><code>from contextlib import suppress

with suppress(FileNotFoundError):
    os.remove('somefile.tmp')

with suppress(FileNotFoundError):
    os.remove('someotherfile.tmp')
</code></pre>
</div>
<span class="comment-copy">For accessing nested JSON specifically, you might want to look at <a href="https://github.com/NYTimes/safejson" rel="nofollow noreferrer">safeJSON</a>.  This works by effectively wrapping the object <code>myobject</code>.</span>
<span class="comment-copy">Hmm, that's neat.  I'm going to investigate this.  Thanks.</span>
<span class="comment-copy">link is down. any ideas where to find it?</span>
<span class="comment-copy">@jdennison, corrected the link</span>
<span class="comment-copy">That's a great talk, really brought a lot of things together for me. I'll now recommend this along with <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" rel="nofollow noreferrer">Code Like a Pythonista: Idiomatic Python</a>. Thanks.</span>
<span class="comment-copy">that is a great slide - thank you for sharing</span>
<span class="comment-copy">Forgive me for a lack of knowledge here. I'm attempting to use it in my script, but it's not giving me the result I'm looking for. My error is 'AttributeError: 'NoneType' object has no attribute text' resulting from f(soup.find("span", class_='xxx').text). I'm defining the decorator as 'f = get_decorator(errors=(AttributeError,), default_value="#NA")'. What am I doing wrong here?</span>
<span class="comment-copy">@MVersteeg: You need to apply <code>@f</code> to a function that returns the value of the <code>soup.find("span", class_='xxx').text</code> expression that's generating the exception -- as shown in the examples in the answer.</span>
<span class="comment-copy">Upvoted, although I'd change the signature of <code>get_decorator()</code> to <code>def get_decorator(default_value='', *errors)</code> to simplify calling it slightly.</span>
<span class="comment-copy">@martineau i changed errors default value to prevent exceptions</span>
<span class="comment-copy">It's worth noting that -- especially for one time usage -- that <code>@get_decorator((KeyError, NameError), default_value='default')</code> before the function would also work.</span>
<span class="comment-copy">This was helpful, but I'm still working on it.  (Exception is misspelled above, but got it.)  Taking this a little farther, is there a way that, instead of wrapping with lambda, I could make another function, g() that does that lambda wrap for me on a generic function, including *args, and **kwargs?  So that I could call g(anyfunction()) and it would have the full effect I'm looking for?</span>
<span class="comment-copy">When I tried it, I did <code>&gt;&gt;&gt; wrapped_p = f(lambda *z,**z: func(*z,**z))</code> and got <code>File "&lt;stdin&gt;", line 1 SyntaxError: duplicate argument 'z' in function definition</code></span>
<span class="comment-copy">Of course; you could do a <code>g = lambda function: lambda *a, **k: function(*a, **k)</code> which enables you to do <code>g(anyfunction)()</code>. (Only in this way: you don't want to wrap the function result, but the function itself.)</span>
<span class="comment-copy">And if you use your <code>z</code> twice, it's clear you get an error...</span>
<span class="comment-copy">Thanks, that was silly of me.  But even using this function to wrap my function, I seem to have the same problem.  So, <code>&gt;&gt;&gt; g = f(lambda function: lambda *a, **k: function(*a,**k))</code>  Then I call it with  <code>&gt;&gt;&gt; g(print)(x.get('fail'))</code> and get a message that x doesn't exist, rather than the silent failure I'm looking for.</span>
<span class="comment-copy">Thanks! The return in the wrong place fixes what I thought I was doing, but wasn't.  But I'm still at a loss in how it the internal exception from meow() is called before the wrap.  The reason I can't use the simple method is that I am calling at several different depths, using several different objects with different attributes.  I'd be writing a function per assignment, which would be as cumbersome as just try-catching.  So, I'm looking for something that can generically catch failed functions and return '', printing an error to stdout.</span>
<span class="comment-copy">made changes to show a more generic version</span>
<span class="comment-copy">never ever ever use eval in any programing language</span>
<span class="comment-copy">I'm trying to make it more generic, not just for one-level deep missing keys, but with a lot of functions that can fail to assign data for a lot of reasons.</span>
