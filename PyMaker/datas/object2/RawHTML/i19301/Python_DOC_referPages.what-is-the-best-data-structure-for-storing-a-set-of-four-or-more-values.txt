<div class="post-text" itemprop="text">
<p>Say I have the following <code>variables</code> and its corresponding <code>values</code> which represents a <code>record</code>. </p>
<pre><code>name = 'abc'
age = 23
weight = 60
height = 174
</code></pre>
<p>Please note that the <code>value</code> could be of different <code>types</code> (<code>string</code>, <code>integer</code>, <code>float</code>, reference-to-any-other-object, etc). </p>
<p>There will be many <code>records</code> (at least &gt;100,000). Each and every <code>record</code> will be <code>unique</code> when all these four <code>variables</code> (actually its <code>values</code>) are put together. In other words, there exists no <code>record</code> with all 4 <code>values</code> are the same.</p>
<p>I am trying to find an efficient data structure in <code>Python</code> which will allow me to (store and) retrieve <code>records</code> based on any one of these <code>variables</code> in <code>log(n)</code> time complexity. </p>
<p>For example:</p>
<pre><code>def retrieve(name=None,age=None,weight=None,height=None) 
    if name is not None and age is None and weight is None and height is None:
        /* get all records with the given name */
    if name is None and age is not None and weight is None and height is None:
        /* get all records with the given age */
    ....
    return records
</code></pre>
<p>The way the <code>retrieve</code> should be called is as follows: </p>
<pre><code>retrieve(name='abc') 
</code></pre>
<p>The above should return <code>[{name:'abc', age:23, wight:50, height=175}, {name:'abc', age:28, wight:55, height=170}, etc]</code></p>
<pre><code>retrieve(age=23) 
</code></pre>
<p>The above should return <code>[{name:'abc', age:23, wight:50, height=175}, {name:'def', age:23, wight:65, height=180}, etc]</code></p>
<p>And, I may need to add one or two more <code>variables</code> to this record in future. For example, say, <code>sex = 'm'</code>. So, the <code>retrieve</code> function must be scalable.</p>
<p>So in short: Is there a data structure in <code>Python</code> which will allow <code>storing a record</code> with <code>n</code> number of <code>columns</code> (name, age, sex, weigh, height, etc) and <code>retrieving records</code> based on any (one) of the <code>column</code> in <code>logarithmic</code> (or ideally <code>constant - O(1)</code> look-up time) complexity?  </p>
</div>
<div class="post-text" itemprop="text">
<p>There isn't a single data structure built into Python that does everything you want, but it's fairly easy to use a combination of the ones it does have to achieve your goals and do so fairly efficiently.</p>
<p>For example, say your input was the following data in a comma-separated-value file called <code>employees.csv</code> with field names defined as shown by the first line:</p>
<pre class="lang-none prettyprint-override"><code>name,age,weight,height
Bob Barker,25,175,6ft 2in
Ted Kingston,28,163,5ft 10in
Mary Manson,27,140,5ft 6in
Sue Sommers,27,132,5ft 8in
Alice Toklas,24,124,5ft 6in
</code></pre>
<p>The following is working code which illustrates how to read and store this data into a list of records, and automatically create separate look-up tables for finding records associated with the values of contained in the fields each of these record.</p>
<p>The records are instances of a class created by <code>namedtuple</code> which is a very memory efficient because each one lacks a <code>__dict__</code> attribute that class instances normally contain. Using them will make it possible to access the fields of each by name using dot syntax, like <code>record.fieldname</code>.</p>
<p>The look-up tables are <code>defaultdict(list)</code> instances, which provide dictionary-like <strong><em>O</em></strong>(1) look-up times on average, and also allow multiple values to be associated with each one. So the look-up key is the value of the field value being sought, and the data associated with it will be a list of the integer indices of the <code>Person</code> records stored in the <code>employees</code> list with that value â€” so they'll all be relatively small.</p>
<p>Note that the code for the class is completely data-driven in that it doesn't contain any hardcoded field names which instead are all taken from the first row of csv data input file when it's read in. Of course when using an instance, all <code>retrieve()</code> method calls must provide valid field names.</p>
<p><strong>Update</strong></p>
<p>Modified to not create a lookup table for every unique value of every field when the data file is first read. Now the <code>retrieve()</code> method "lazily" creates them only when one is needed (and saves/caches the result for future use). Also modified to work in  Python 2.7+ including 3.x.</p>
<pre><code>from collections import defaultdict, namedtuple
import csv

class DataBase(object):
    def __init__(self, csv_filename, recordname):
        # Read data from csv format file into a list of namedtuples.
        with open(csv_filename, 'r') as inputfile:
            csv_reader = csv.reader(inputfile, delimiter=',')
            self.fields = next(csv_reader)  # Read header row.
            self.Record = namedtuple(recordname, self.fields)
            self.records = [self.Record(*row) for row in csv_reader]
            self.valid_fieldnames = set(self.fields)

        # Create an empty table of lookup tables for each field name that maps
        # each unique field value to a list of record-list indices of the ones
        # that contain it.
        self.lookup_tables = {}

    def retrieve(self, **kwargs):
        """ Fetch a list of records with a field name with the value supplied
            as a keyword arg (or return None if there aren't any).
        """
        if len(kwargs) != 1: raise ValueError(
            'Exactly one fieldname keyword argument required for retrieve function '
            '(%s specified)' % ', '.join([repr(k) for k in kwargs.keys()]))
        field, value = kwargs.popitem()  # Keyword arg's name and value.
        if field not in self.valid_fieldnames:
            raise ValueError('keyword arg "%s" isn\'t a valid field name' % field)
        if field not in self.lookup_tables:  # Need to create a lookup table?
            lookup_table = self.lookup_tables[field] = defaultdict(list)
            for index, record in enumerate(self.records):
                field_value = getattr(record, field)
                lookup_table[field_value].append(index)
        # Return (possibly empty) sequence of matching records.
        return tuple(self.records[index]
                        for index in self.lookup_tables[field].get(value, []))

if __name__ == '__main__':
    empdb = DataBase('employees.csv', 'Person')

    print("retrieve(name='Ted Kingston'): {}".format(empdb.retrieve(name='Ted Kingston')))
    print("retrieve(age='27'): {}".format(empdb.retrieve(age='27')))
    print("retrieve(weight='150'): {}".format(empdb.retrieve(weight='150')))
    try:
        print("retrieve(hight='5ft 6in'):".format(empdb.retrieve(hight='5ft 6in')))
    except ValueError as e:
        print("ValueError('{}') raised as expected".format(e))
    else:
        raise type('NoExceptionError', (Exception,), {})(
            'No exception raised from "retrieve(hight=\'5ft\')" call.')
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>retrieve(name='Ted Kingston'): [Person(name='Ted Kingston', age='28', weight='163', height='5ft 10in')]
retrieve(age='27'): [Person(name='Mary Manson', age='27', weight='140', height='5ft 6in'),
                     Person(name='Sue Sommers', age='27', weight='132', height='5ft 8in')]
retrieve(weight='150'): None
retrieve(hight='5ft 6in'): ValueError('keyword arg "hight" is an invalid fieldname')
                           raised as expected
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><em>Is there a data structure in Python which will allow storing a record with <code>n</code> number of columns (name, age, sex, weigh, height, etc) and retrieving records based on any (one) of the column in logarithmic (or ideally constant - O(1) look-up time) complexity?</em></p>
</blockquote>
<p>No, there is none. But you could try to implement one on the basis of one dictionary per value dimension. As long as your values are hashable of course. If you implement a custom class for your records, each dictionary will contain references to the same objects. This will save you some memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>Given <a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow">http://wiki.python.org/moin/TimeComplexity</a> how about this:</p>
<ul>
<li>Have a dictionary for every column you're interested in - <code>AGE</code>, <code>NAME</code>, etc. </li>
<li>Have the keys of that dictionaries (<code>AGE</code>, <code>NAME</code>) be possible values for given column (35 or "m"). </li>
<li>Have a list of lists representing values for one "collection", e.g. <code>VALUES = [ [35, "m"], ...]</code></li>
<li>Have the value of column dictionaries (<code>AGE</code>, <code>NAME</code>) be lists of indices from the <code>VALUES</code> list.</li>
<li>Have a dictionary which maps column name to index within lists in <code>VALUES</code> so that you know that first column is age and second is sex (you could avoid that and use dictionaries, but they introduce large memory footrpint and with over 100K objects this may or not be a problem).</li>
</ul>
<p>Then the <code>retrieve</code> function could look like this:</p>
<pre><code>def retrieve(column_name, column_value):
    if column_name == "age":
        return [VALUES[index] for index in AGE[column_value]]      
    elif ...: # repeat for other "columns"
</code></pre>
<p>Then, this is what you get</p>
<pre><code>VALUES = [[35, "m"], [20, "f"]]
AGE = {35:[0], 20:[1]}
SEX = {"m":[0], "f":[1]}
KEYS = ["age", "sex"]

retrieve("age", 35)
# [[35, 'm']]
</code></pre>
<p>If you want a dictionary, you can do the following:</p>
<pre><code>[dict(zip(KEYS, values)) for values in retrieve("age", 35)]
# [{'age': 35, 'sex': 'm'}]
</code></pre>
<p>but again, dictionaries are a little heavy on the memory side, so if you can go with lists of values it might be better.</p>
<p>Both dictionary and list retrieval are O(1) on average - worst case for dictionary is O(n) - so this should be pretty fast. Maintaining that will be a little bit of pain, but not so much. To "write", you'd just have to append to the <code>VALUES</code> list and then append the index in <code>VALUES</code> to each of the dictionaries.</p>
<p>Of course, then best would be to benchmark your actual implementation and look for potential improvements, but hopefully this make sense and will get you going :)</p>
<p>EDIT:</p>
<p>Please note that as @moooeeeep said, this will only work if your values are hashable and therefore can be used as dictionary keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could achieve logarithmic time complexity in a relational database using indexes (<code>O(log(n)**k)</code> with single column indexes). Then to retrieve data just construct appropriate SQL:</p>
<pre><code>names = {'name', 'age', 'weight', 'height'}

def retrieve(c, **params):
    if not (params and names.issuperset(params)):
        raise ValueError(params)
    where = ' and '.join(map('{0}=:{0}'.format, params))
    return c.execute('select * from records where ' + where, params)
</code></pre>
<p>Example:</p>
<pre><code>import sqlite3

c = sqlite3.connect(':memory:')
c.row_factory = sqlite3.Row # to provide key access

# create table
c.execute("""create table records
             (name text, age integer, weight real, height real)""")

# insert data
records = (('abc', 23, 60, 174+i) for i in range(2))
c.executemany('insert into records VALUES (?,?,?,?)', records)

# create indexes
for name in names:
    c.execute("create index idx_{0} on records ({0})".format(name))

try:
    retrieve(c, naame='abc')
except ValueError:
    pass
else:
    assert 0

for record in retrieve(c, name='abc', weight=60):
    print(record['height'])
</code></pre>
<p>Output:</p>
<pre><code>174.0
175.0
</code></pre>
</div>
<span class="comment-copy">Could you please justify the -1? It is a genuine programming question.</span>
<span class="comment-copy">Maybe this will help you - <a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a> ?</span>
<span class="comment-copy">Why not using sql for this? Seems more appropiate. Python has builtin support for sqlite.</span>
<span class="comment-copy">SQL will be slow, given OP mentions time complexity, he's probably not very happy about being tied by I/O.</span>
<span class="comment-copy">Is this question about providing an implementation of such data structure, or is it about whether or not a ready-to-use implementation exists?</span>
<span class="comment-copy">Could you tell me the name of the following syntax? names = {'name', 'age', 'weight', 'height'}</span>
<span class="comment-copy">@LEDFantom: It is a <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow noreferrer">set display</a> (a literal that creates <code>set()</code> object). It is available on both Python 2.7 and Python 3.</span>
