<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/11277432/how-to-remove-a-key-from-a-python-dictionary">How to remove a key from a Python dictionary?</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>Is there any other way to delete an item in a dictionary only if the given key exists, other than:</p>
<pre><code>if key in mydict:
    del mydict[key]
</code></pre>
<p>The scenario is that I'm given a collection of keys to be removed from a given dictionary, but I am not certain if all of them exist in the dictionary. Just in case I miss a more efficient solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/3/library/stdtypes.html#dict.pop" rel="noreferrer"> <code>dict.pop</code></a>:</p>
<pre><code> mydict.pop("key", None)
</code></pre>
<p>Note that if the second argument, i.e. <code>None</code> is not given, <code>KeyError</code> is raised if the key is not in the dictionary. Providing the second argument prevents the conditional exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is also:</p>
<pre><code>try:
    del mydict[key]
except KeyError:
    pass
</code></pre>
<p>This only does 1 lookup instead of 2.  However, <code>except</code> clauses are expensive, so if you end up hitting the except clause frequently, this will probably be less efficient than what you already have.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Approach: calculate keys to remove, mutate dict</h1>
<p>Let's call <code>keys</code> the list/iterator of keys that you are given to remove. I'd do this:</p>
<pre><code>keys_to_remove = set(keys).intersection(set(mydict.keys()))
for key in keys_to_remove:
    del mydict[key]
</code></pre>
<p>You calculate up front all the affected items and operate on them.</p>
<h1>Approach: calculate keys to keep, make new dict with those keys</h1>
<p>I prefer to create a new dictionary over mutating an existing one, so I would probably also consider this:</p>
<pre><code>keys_to_keep = set(mydict.keys()) - set(keys)
new_dict = {k: v for k, v in mydict.iteritems() if k in keys_to_keep}
</code></pre>
<p>or:</p>
<pre><code>keys_to_keep = set(mydict.keys()) - set(keys)
new_dict = {k: mydict[k] for k in keys_to_keep}
</code></pre>
</div>
<span class="comment-copy">@user1929959 Nope, that question wants a copy of the dictionary, and doesn't care about hte case that the key is not in the input.</span>
<span class="comment-copy">For reference, the second argument to <code>.pop()</code> is what it returns if the key is not found.</span>
<span class="comment-copy">Does this only do 1 lookup?</span>
<span class="comment-copy">it does 2 lookups</span>
<span class="comment-copy">that is my fear. I wasn't sure about the cost of two look-ups per deletion vs. that of using try-except.</span>
<span class="comment-copy">@SimonHughes -- See <a href="http://programmers.stackexchange.com/questions/175655/python-forgiveness-vs-permission-and-duck-typing/175663#175663">this answer</a> on programmers ...</span>
<span class="comment-copy">This is called the <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">eaiser to ask for forgiveness than permission</a> (EAFP) Python style.</span>
<span class="comment-copy">And EAFP is the recommended approach in Python.  I would like to see the evidence and rationale for the statement "except clauses are expensive."</span>
<span class="comment-copy">@Bobort -- This has been a pretty well explained in a number of places.  See <a href="http://softwareengineering.stackexchange.com/questions/175655/python-forgiveness-vs-permission-and-duck-typing/175663#175663">this answer</a> on programmers or <a href="https://mail.python.org/pipermail/tutor/2011-January/081143.html" rel="nofollow noreferrer">this response</a> on the python mailing list.  In short, setting up the try/except block is cheap, but handling the exception is less cheap.</span>
