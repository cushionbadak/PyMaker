<div class="post-text" itemprop="text">
<p>I'm mocking out a call to <code>requests.post</code> using the <code>Mock</code> library: </p>
<pre><code>requests.post = Mock()
</code></pre>
<p>The the call involves multiple arguments: the URL, a payload, some auth stuff, etc. I want to assert that <code>requests.post</code> is called with a particular URL, but I don't care about the other arguments. When I try this: </p>
<pre><code>requests.post.assert_called_with(requests_arguments)
</code></pre>
<p>the test fails, as it expects it to be called with only that argument. </p>
<p>Is there any way to check if a single argument is used somewhere in the function call without having to pass in the other arguments? </p>
<p>Or, even better, is there a way to assert a specific URL and then abstract data types for the other arguments (i.e., data should be a dictionary, auth should be an instance of HTTPBasicAuth, etc.)? </p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know <code>Mock</code> doesn't provide a way to achieve what you want via <code>assert_called_with</code>. You could access the <a href="http://docs.python.org/3.3/library/unittest.mock.html#unittest.mock.Mock.call_args"><code>call_args</code></a> and <a href="http://docs.python.org/3.3/library/unittest.mock.html#unittest.mock.Mock.call_args_list"><code>call_args_list</code></a> members and perform the assertions manually.</p>
<p>However the is a simple (and dirty) way of achieving <em>almost</em> what you want. You have to implement a class whose <code>__eq__</code> method always returns <code>True</code>:</p>
<pre><code>def Any(cls):
    class Any(cls):
        def __eq__(self, other):
            return True
    return Any()
</code></pre>
<p>Using it as:</p>
<pre><code>In [14]: caller = mock.Mock(return_value=None)


In [15]: caller(1,2,3, arg=True)

In [16]: caller.assert_called_with(Any(int), Any(int), Any(int), arg=True)

In [17]: caller.assert_called_with(Any(int), Any(int), Any(int), arg=False)
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
&lt;ipython-input-17-c604faa06bd0&gt; in &lt;module&gt;()
----&gt; 1 caller.assert_called_with(Any(int), Any(int), Any(int), arg=False)

/usr/lib/python3.3/unittest/mock.py in assert_called_with(_mock_self, *args, **kwargs)
    724         if self.call_args != (args, kwargs):
    725             msg = self._format_mock_failure_message(args, kwargs)
--&gt; 726             raise AssertionError(msg)
    727 
    728 

AssertionError: Expected call: mock(0, 0, 0, arg=False)
Actual call: mock(1, 2, 3, arg=True)
</code></pre>
<p>As you can see it only checks for the <code>arg</code>. You have to create subclasses of <code>int</code>, otherwise the comparisons wont work<sup>1</sup>. However you still have to provide all the arguments. If you have many arguments you might shorten your code using tuple-unpacking:</p>
<pre><code>In [18]: caller(1,2,3, arg=True)

In [19]: caller.assert_called_with(*[Any(int)]*3, arg=True)
</code></pre>
<p>Except for this I cannot think of a way to avoid passing all parameters to <code>assert_called_with</code> and work it as you intend.</p>
<hr/>
<p>The above solution can be extended to check for types of other arguments. For example:</p>
<pre><code>In [21]: def Any(cls):
    ...:     class Any(cls):
    ...:         def __eq__(self, other):
    ...:             return isinstance(other, cls)
    ...:     return Any()

In [22]: caller(1, 2.0, "string", {1:1}, [1,2,3])

In [23]: caller.assert_called_with(Any(int), Any(float), Any(str), Any(dict), Any(list))

In [24]: caller(1, 2.0, "string", {1:1}, [1,2,3])

In [25]: caller.assert_called_with(Any(int), Any(float), Any(str), Any(dict), Any(tuple))
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
&lt;ipython-input-25-f607a20dd665&gt; in &lt;module&gt;()
----&gt; 1 caller.assert_called_with(Any(int), Any(float), Any(str), Any(dict), Any(tuple))

/usr/lib/python3.3/unittest/mock.py in assert_called_with(_mock_self, *args, **kwargs)
    724         if self.call_args != (args, kwargs):
    725             msg = self._format_mock_failure_message(args, kwargs)
--&gt; 726             raise AssertionError(msg)
    727 
    728 

AssertionError: Expected call: mock(0, 0.0, '', {}, ())
Actual call: mock(1, 2.0, 'string', {1: 1}, [1, 2, 3])
</code></pre>
<p>however this doesn't allow arguments that can be, for example, both an <code>int</code> or a <code>str</code>. Allowing multiple arguments to <code>Any</code> and using multiple-inheritance wont help. We can solve this using <a href="http://docs.python.org/2/library/abc.html#abc.ABCMeta"><code>abc.ABCMeta</code></a></p>
<pre><code>def Any(*cls):
    class Any(metaclass=abc.ABCMeta):
        def __eq__(self, other):
            return isinstance(other, cls)
    for c in cls:
        Any.register(c)
    return Any()
</code></pre>
<p>Example:</p>
<pre><code>In [41]: caller(1, "ciao")

In [42]: caller.assert_called_with(Any(int, str), Any(int, str))

In [43]: caller("Hello, World!", 2)

In [44]: caller.assert_called_with(Any(int, str), Any(int, str))
</code></pre>
<hr/>
<p><sup>1</sup> I used the name <code>Any</code> for the function since it is "used as a class" in the code. Also <code>any</code> is a built-in...</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the <code>ANY</code> helper to always match arguments you don't know or aren't checking for.</p>
<p>More on the ANY helper: 
<a href="https://docs.python.org/3/library/unittest.mock.html#any" rel="noreferrer">https://docs.python.org/3/library/unittest.mock.html#any</a></p>
<p>So for instance you could match the argument 'session' to anything like so:</p>
<pre><code>from unittest.mock import ANY
requests_arguments = {'slug': 'foo', 'session': ANY}
requests.post.assert_called_with(requests_arguments)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>@mock.patch.object(module, 'ClassName')
def test_something(self, mocked):
    do_some_thing()
    args, kwargs = mocked.call_args
    self.assertEqual(expected_url, kwargs.get('url'))
</code></pre>
<p>see: <a href="https://docs.python.org/3.3/library/unittest.mock.html#calls-as-tuples">calls-as-tuples</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use : assert_any_call(args) 
<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_any_call" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_any_call</a></p>
<p>requests.post.assert_any_call(requests_arguments)</p>
</div>
<span class="comment-copy">I used a variation on this, but in newer versions of mock they use != as the comparison (at least for kwargs), so you need to override <code>def __neq__(self, other): return False</code> as well.</span>
<span class="comment-copy">This is built into the framework now (sans type checking) as another answer brings out: <a href="https://stackoverflow.com/a/27152023/452274">stackoverflow.com/a/27152023/452274</a></span>
<span class="comment-copy">I use this solution too though but it does not give the type checking.</span>
<span class="comment-copy">This should actually be accepted answer, as it works perfectly.</span>
