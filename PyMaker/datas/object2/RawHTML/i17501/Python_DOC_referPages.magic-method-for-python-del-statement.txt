<div class="post-text" itemprop="text">
<p>Quick question, what is the magic method python calls when you say <code>del object</code>? I know it's not <code>__del__</code> and it isn't <code>__delete__</code>, so what gets called if anything? If nothing is called, then how can I customize the events that occur when you delete an object? </p>
<hr/>
<p>Take a look at the following example:</p>
<pre><code>class SingletonError(Exception):
    pass

class Singleton(type):

    def __new__(metacls, name, parents, kwargs):
        cls = super(Singleton, metacls).__new__(metacls, name, parents, kwargs)
        cls._instance = None
        return cls

    def __call__(cls, *args, **kwargs):
        if not cls._instance:
            inst = cls.__new__(cls, *args, **kwargs)
            inst.__init__(*args, **kwargs)
            cls._instance = inst
            return cls._instance
        else:
            raise SingletonError("Cannot initialize multiple singletons.")

class Logger(object, metaclass = Singleton):

    def __new__(cls, *logging_args, **logging_kwargs):
        self = super(Logger, cls).__new__(cls)
        logging_args_dict = {'log%i' % pos : i for pos, i in enumerate(logging_args, 1)}
        kwargs = dict(logging_args_dict, **logging_kwargs)
        self.__dict__ = kwargs
        return self

log = Logger()
</code></pre>
<p>When I delete log I would like it to set Logger._instance to None again, so you can reinitialize the singleton. How might I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="http://docs.python.org/3/library/weakref.html" rel="nofollow">weak reference</a> instead; as all references to the <code>Logger()</code> instances are cleaned up, the weak reference won't prevent the object from being reaped.</p>
<pre><code>import gc
import weakref

def __call__(cls, *args, **kwargs):
    gc.collect()  # optional, clear existing weak references
    inst = cls._instance and cls._instance()  # de-reference the weakref
    if inst is None:
        inst = cls.__new__(cls, *args, **kwargs)
        inst.__init__(*args, **kwargs)
        cls._instance = weakref.ref(inst)
        return inst
    else:
        del inst  # clear local early
        raise SingletonError("Cannot initialize multiple singletons.")
</code></pre>
<p><code>cls._instance</code> is now a weak reference object; you call it to retrieve the referenced object, and if it returns <code>None</code> the object is gone and you'll need to create a new one.</p>
<p>Just take into account that the deletion is not necessarily going to be instantaneous; garbage collection needs to run to reap the object once the last regular reference has been removed.</p>
<p>The <a href="http://docs.python.org/3/library/gc.html#gc.collect" rel="nofollow"><code>gc.collect()</code> call</a> as the first line in the <code>__call__</code> ensures that any weak refences are cleaned up before testing.</p>
</div>
<span class="comment-copy">You can't, because <code>del</code> doesn't delete the object, it deletes the <i>name</i> that points to the object.</span>
<span class="comment-copy"><a href="http://docs.python.org/2/reference/datamodel.html#object.__del__" rel="nofollow noreferrer">docs.python.org/2/reference/datamodel.html#object.__del__</a></span>
<span class="comment-copy">Okay, I edited the question to include the scenario I am faced with and why I brought up this question in the first place.</span>
<span class="comment-copy">What do you expect to happen if you do <code>log = Logger()</code> and then <code>foo = log</code> and then <code>del log</code>?  The Logger object still exists under the name <code>foo</code>.  The object can't know how many names are referencing it.  You're better off giving your class a method called <code>clear</code> or <code>delete</code> or something that explicitly resets <code>_instance</code>.</span>
<span class="comment-copy">Ah I see, that makes a lot more sense, thanks</span>
