<div class="post-text" itemprop="text">
<p>What's the best way to emulate single-precision floating point in python?  (Or other floating point formats for that matter?)  Just use ctypes?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://numpy.scipy.org/" rel="noreferrer"><code>numpy</code></a> has a <a href="http://docs.scipy.org/doc/numpy/user/basics.types.html?highlight=float32#array-types-and-conversions-between-types" rel="noreferrer"><code>float32</code></a> type.</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>numpy</code> (the excellent suggestion of other answers) is inapplicable for you (e.g. because you're in an environment that doesn't allow arbitrary third-party extensions), the <a href="http://docs.python.org/library/array.html?highlight=array#module-array" rel="noreferrer">array</a> module in Python standard library is fine too -- type code <code>'f'</code> gives you 32-bit floats.  Besides those and the (usual) double precision floats, there isn't much for "other floating point formats" -- what did you have in mind?  (e.g. <code>gmpy</code> offers GMP's modest support for floats with much longer, arbitrary bit sizes -- but it's modest indeed, e.g., no trig functions).</p>
</div>
<div class="post-text" itemprop="text">
<p>how about ctypes.c_float from standard library?</p>
</div>
<div class="post-text" itemprop="text">
<p>If your application suits arrays/matrices, you can use numpy with <code>float32</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to use Python's <code>struct</code> module to truncate a 64-bit float to the precision of a 32-bit float.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; x = 1.1122334455667788
&gt;&gt;&gt; x
1.1122334455667788
&gt;&gt;&gt; struct.unpack('f', struct.pack('f', x))[0]
1.1122334003448486
</code></pre>
<p>To do arithmetic only with 32-bit floats, you would need to apply this truncation operation to the result of every arithmetic operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>To expand a little on the <code>ctypes</code> option [1]:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; ctypes.sizeof(ctypes.c_int)                                                                                                                                                        
4
&gt;&gt;&gt; ctypes.sizeof(ctypes.c_long)                                                                                                                                                       
8

&gt;&gt;&gt; ctypes.sizeof(ctypes.c_float)                                                                                                                                                      
4
&gt;&gt;&gt; ctypes.sizeof(ctypes.c_double)                                                                                                                                                     
8
</code></pre>
<p>With numpy [2], e.g.:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.zeros((1,1), dtype='uint8').nbytes                                                                                                                                              
1
&gt;&gt;&gt; np.zeros((1,1), dtype='uint16').nbytes                                                                                                                                             
2
&gt;&gt;&gt; np.zeros((1,1), dtype='uint64').nbytes                                                                                                                                             
8
&gt;&gt;&gt; np.zeros((1,1), dtype='float').nbytes  # watch out for this one
8
&gt;&gt;&gt; np.zeros((1,1), dtype='float32').nbytes                                                                                                                                            
4
&gt;&gt;&gt; np.zeros((1,1), dtype='float64').nbytes                                                                                                                                            
8
&gt;&gt;&gt; np.zeros((1,1), dtype='single').nbytes                                                                                                                                             
4
&gt;&gt;&gt; np.zeros((1,1), dtype='double').nbytes                                                                                                                                             
8
</code></pre>
<p>numpy.astype does conversions, e.g.</p>
<pre><code>&gt;&gt;&gt; np.zeros((1,1), dtype='double').astype('single').nbytes                                                                                                                            
4
</code></pre>
<p>[1] <a href="https://docs.python.org/3/library/ctypes.html#fundamental-data-types" rel="nofollow noreferrer">https://docs.python.org/3/library/ctypes.html#fundamental-data-types</a></p>
<p>[2] <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.dtypes.html" rel="nofollow noreferrer">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.dtypes.html</a></p>
</div>
<span class="comment-copy">What do you mean by "emulate"?  Read floats from binary blobs?  Execute math in single-precision and get the same results as another language?  (If the latter, note that "float" math in C on x86 is actually evaluated in 80-bit and reduced to 32-bit when it's stored.)</span>
