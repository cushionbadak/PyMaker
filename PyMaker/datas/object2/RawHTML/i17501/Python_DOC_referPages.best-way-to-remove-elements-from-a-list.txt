<div class="post-text" itemprop="text">
<p>I would like to know what is the best way/efficient way to remove element(s) from the list.</p>
<p>There are <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="noreferrer">few functions</a> provided by Python:</p>
<ol>
<li><code>some_list.remove(value)</code>, but it throws error if value is not found.</li>
<li><code>some_list.pop(some_list[index])</code>, removes the item at the given position in the list, and return it.</li>
<li><code>del (some_list[index])</code>, it removes element from the given index, it's different from pop as it doesn't return value.</li>
</ol>
<p>Scenarios:</p>
<ul>
<li>If you have few items to remove say one element or between 1 to 5.  </li>
<li>If you have to remove multiple items in a sequence.</li>
<li>If you have to remove different items based on a condition.</li>
<li>How about if you have a list of lists and want to remove elements in sequence.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="http://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<p>Scenario 1:</p>
<pre><code>[item for item in my_list if 1 &lt;= item &lt;=5 ]
</code></pre>
<p>Scenario 2:</p>
<pre><code>to_be_removed = {'a', '1', 2}
[item for item in my_list if item not in to_be_removed ]
</code></pre>
<p>Scenario 3:</p>
<pre><code>[item for item in my_list if some_condition()]
</code></pre>
<p>Scenario 4(Nested list comprehension):</p>
<pre><code>[[item for item in seq if some_condition] for seq in my_list]
</code></pre>
<p>Note that if you want to remove just one item then <code>list.remove</code>, <code>list.pop</code> and <code>del</code> are definitely going to be very fast, but using these methods while iterating over the the list can result in unexpected output.</p>
<p>Related: <a href="https://stackoverflow.com/questions/17299581/loop-forgets-to-remove-some-items">Loop “Forgets” to Remove Some Items</a></p>
</div>
<div class="post-text" itemprop="text">
<p><em>My answer is not exactly to your question but after you read this, I hope you can decide which type you need to choose for your needs.</em> </p>
<p><strong>Python’s lists are <a href="http://en.wikipedia.org/wiki/Variable-length_array" rel="noreferrer">variable-length arrays</a>, not Lisp-style linked lists. The implementation uses a contiguous array of references to other objects, and keeps a pointer to this array.</strong></p>
<p><strong>This makes indexing a list a[i] an operation whose cost is independent of the size of the list or the value of the index.</strong></p>
<p>When items are appended or inserted, the array of references is resized.
Some algorithm is applied to improve the performance of appending items repeatedly;
when the array must be grown, some extra space is allocated so the next few times
don’t require an actual resize i.e over-allocation. <a href="https://github.com/python-git/python/blob/master/Objects/listobject.c" rel="noreferrer">More Information</a></p>
<p><strong>Removing vs Pop vs Delete:</strong></p>
<p>At first glance it looks like all of them are doing the same thing. </p>
<p><strong>Under the hood its behaving different.</strong></p>
<p><strong><a href="https://github.com/python-git/python/blob/master/Objects/listobject.c#L2312" rel="noreferrer">removing</a></strong> : remove an element from the list by iterating from 0 index till the first
    match of the element is found. taking more time to iterate if the element is at the end.</p>
<p><strong><a href="https://github.com/python-git/python/blob/master/Objects/listobject.c#L916" rel="noreferrer">pop</a></strong> : removing element from the list by using the index. taking less time.</p>
<p><strong>del</strong> : is a python statement that removes a name from a namespace, or an item
    from a dictionary, or an item from a list by using the index. </p>
<p>REMOVE:</p>
<ul>
<li>it removes the first occurence of value.</li>
<li>raises ValueError if the value is not present.</li>
<li>it takes only one argument, so you can't remove multiple value in one shot.</li>
</ul>
<p>POP:</p>
<ul>
<li>remove and return item at index (default last).</li>
<li>Raises IndexError if list is empty or index is out of range.</li>
<li>it takes only one argument, so you can't remove multiple value in one shot.</li>
</ul>
<p>DEL:</p>
<ul>
<li>remove the item at index and return nothing.</li>
<li>it can remove slices from a list or can clear the whole list.</li>
</ul>
<p><strong>Benchmark</strong>:</p>
<p>Worst case : deleting from the end of the list.</p>
<pre><code>yopy:-&gt; python -m timeit "x=range(1000)" "x.pop(999)"
100000 loops, best of 3: 10 usec per loop
yopy:-&gt; python -m timeit "x=range(1000)" "x.remove(999)"
10000 loops, best of 3: 31.3 usec per loop
yopy:-&gt; python -m timeit "x=range(1000)" "del x[999]"
100000 loops, best of 3: 9.86 usec per loop
yopy:-&gt;
</code></pre>
<p>Best case: begining of the list.</p>
<pre><code>yopy:-&gt; python -m timeit "x=range(1000)" "x.remove(1)"
100000 loops, best of 3: 10.3 usec per loop
yopy:-&gt; python -m timeit "x=range(1000)" "x.pop(1)"
100000 loops, best of 3: 10.4 usec per loop
yopy:-&gt; python -m timeit "x=range(1000)" "del x[1]"
100000 loops, best of 3: 10.4 usec per loop
yopy:-&gt;
</code></pre>
<p>Point to be noted:</p>
<p>if array grows or shrinks in the middle</p>
<ul>
<li>Realloc still depends on total length.</li>
<li>But, All the trailing elements have to be copied</li>
</ul>
<p>So, now I hope you can decide what you need to choose for your needs.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use filter instead of list comprehension:</p>
<p>Scenario 1:</p>
<pre><code>filter(lambda item: 1 &lt;= item &lt;= 5, my_list)
</code></pre>
<p>Scenario 2:</p>
<pre><code>to_be_removed = {'a', '1', 2}
filter(lambda item: item not in to_be_removed, my_list)
</code></pre>
<p>Scenario 3:</p>
<pre><code>filter(lambda item: some_condition(), my_list)
</code></pre>
<p>Scenario 4(Nested filtered list):</p>
<pre><code>filter(lambda seq: filter(lambda item: some_condition(), seq), my_list) 
</code></pre>
<p>For some reason, it's the same thing as a list comprhension, but it's quite clear that we are filtering things instead of generating them.</p>
</div>
<div class="post-text" itemprop="text">
<p>Good question, and <a href="https://stackoverflow.com/questions/21510140/best-way-to-remove-elements-from-a-list#21511293">James’ answer</a> is the only one with actual performance data for Python 2.x for some of the suggested approaches. (See also <a href="https://stackoverflow.com/questions/21510140/best-way-to-remove-elements-from-a-list#comment79336699_21511293">my comment</a> on that question.)</p>
<p>To complete the picture for Python 3.x, here are a few more tests. Because a single test may modify its list, we need <em>N</em> lists to modify for <em>N</em> tests; therefore I’ve created the set of lists before running a test. </p>
<pre><code># Python 3.6.2 (default, Jul 18 2017, 14:13:41) 
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; number = 10000   # Number of tests.
&gt;&gt;&gt; # Generate `number` lists of 1000 integer elements.
&gt;&gt;&gt; setup = """
... lists=[[_ for _ in range(1000)] for _ in range(10000)]
... i = 0
... """
&gt;&gt;&gt;
</code></pre>
<p>All tests, whether they modify a list in place of generate a new one, iterate over that set of lists, to ensure that the conditions for the tests are the same. For simplicity’s sake, all tests remove a single element from the middle of the list.</p>
<p>Let’s start with the examples from the question using the <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">built-in list() functions</a>:</p>
<pre><code># remove()
&gt;&gt;&gt; stmt = """
... l = lists[i]     # Get the current work list.
... l.remove(500)    # Remove element.
... i += 1           # On to the next list.
... """
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.08474616194143891

# pop()
&gt;&gt;&gt; stmt = "l = lists[i]; l.pop(500); i += 1"
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.01088976499158889

# index() and pop()
&gt;&gt;&gt; stmt = "l = lists[i]; l.pop(l.index(500)); i += 1"
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.08841867197770625

# del
&gt;&gt;&gt; stmt = "l = lists[i]; del l[500]; i += 1"
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.008702976978383958

# index() and del
&gt;&gt;&gt; stmt = "l = lists[i]; del l[l.index(500)]; i += 1"
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.08238211390562356
</code></pre>
<p>List comprehensions as outlined in <a href="https://stackoverflow.com/questions/21510140/best-way-to-remove-elements-from-a-list#21510181">Ashwini Chaudhary’s answer</a>:</p>
<pre><code>&gt;&gt;&gt; stmt = "l = lists[i]; [_ for _ in l if _ != 500]; i += 1"
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.44951551605481654
</code></pre>
<p>Using filter() as outlined in <a href="https://stackoverflow.com/questions/21510140/best-way-to-remove-elements-from-a-list#21510281">Loïc Faure-Lacroix’s answer</a>. Note, however, that the examples in the above answer return a <code>filter</code> object for Python 3.x, and not a list like they do for Python 2.x!</p>
<pre><code># Generate a filter object.
&gt;&gt;&gt; stmt = "l=lists[i]; filter(lambda _: _ != 500, l); i += 1"
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.0031418869039043784

# Generate a list from the filter object.
&gt;&gt;&gt; stmt = "l=lists[i]; list(filter(lambda _: _ != 500, l)); i += 1"
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
1.1863253980409354
</code></pre>
<p>Removing an element that does <em>not</em> exist using Python’s built-in functions requires an additional test; the list comprehension and the filter solution handle non-existing list elements gracefully. </p>
<pre><code># Catch a resulting exception.
&gt;&gt;&gt; stmt = """
... l = lists[i]
... try:
...     del l[l.index(1234)]
... except ValueError:
...     pass
... i += 1
... """
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.1451275929575786

# Test if the element exists, then delete.
&gt;&gt;&gt; stmt = """
... l = lists[i]
... if 1234 in l:
...     del l[l.index[1234]]
... i += 1
... """
&gt;&gt;&gt; timeit.timeit(stmt, setup=setup, number=number)
0.13344507792498916
</code></pre>
<p>I hope I got this right… 🤓</p>
</div>
<span class="comment-copy">Put them in a loop and benchmark?</span>
<span class="comment-copy">Are you saying 'subsequence' in the last scenario?</span>
<span class="comment-copy">@zhangxaochen yes something like some_list=[[1,2,3],[6,7]] etc</span>
<span class="comment-copy">Best in what way, and is this remove elements based on their position or their value?</span>
<span class="comment-copy">@Tony Hopkinson In terms of "Best practice" like code execution, elegant way etc.</span>
<span class="comment-copy">Thanks for your answer. So for only removing one item are list.remove, list.pop better than del (list[index]). list.remove can throw value not found error etc?</span>
<span class="comment-copy">@user3247054 You can use try-except to handle such errors. <code>list.pop</code> and <code>del</code> are almost the same, the only difference being that pop returns the value as well.</span>
<span class="comment-copy">thanks for your reply. What about filters mentioned below are they better than list comprehension?</span>
<span class="comment-copy">@user3247054 Another problem with filter is that it returns an iterator in Python3, so an additional <code>list()</code> call will be required there. <code>map</code> and <code>filter</code> can beat LC by a whisker only when used with a built-in function, not lambda.</span>
<span class="comment-copy">@user3247054 With built-in functions, for example: <code>filter(None, my_list)</code>, <code>filter(str.isupper, my_list)</code> etc, but in Python 3 you'll have to use an additional list call as it returns an iterator there. To get an iterator in Python 2 you can use <code>itertools.ifilter</code>.</span>
<span class="comment-copy">Note that the above code snippets work only for Python 2.x, where <a href="https://docs.python.org/2/library/functions.html#range" rel="nofollow noreferrer"><code>range()</code></a> produces an actual list of integers. For Python 3.x, the function returns a <a href="https://docs.python.org/3.6/library/stdtypes.html#typesseq-range" rel="nofollow noreferrer"><code>Range</code></a> object which is different than an actual sequence.</span>
<span class="comment-copy">Thanks for your answer? Are filters better than list comprehension in terms of efficiency, less error prone(error throw by code) etc.</span>
<span class="comment-copy">@user3247054 No, <code>filter</code> with lambda is actually slower than a LC.</span>
<span class="comment-copy">I'd say that the filter is less error prone, because it cannot modify items in the lists. The list comprehension is more like a swiss knife.</span>
<span class="comment-copy">So when should one use filter then?</span>
<span class="comment-copy">@user3247054 In my test, filter is slowlier by a margin of 2 using lambdas. Just mentioning that list comprehension can be replaced by "map/filter/reduce" sometimes. I guess the speed problem could be improved much if the python dev really cared about it.</span>
