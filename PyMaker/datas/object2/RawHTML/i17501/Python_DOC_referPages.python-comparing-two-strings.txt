<div class="post-text" itemprop="text">
<p>Is there a function to compare how many characters two strings (of the same length) differ by? I mean only substitutions. For example, AAA would differ from AAT by 1 character. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is a nice use case for the zip function!</p>
<pre><code>def count_substitutions(s1, s2):
    return sum(x != y for (x, y) in zip(s1, s2))
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; count_substitutions('AAA', 'AAT')
1
</code></pre>
<p>From the docs:</p>
<pre><code>zip(...)
    zip(seq1 [, seq2 [...]]) -&gt; [(seq1[0], seq2[0] ...), (...)]

    Return a list of tuples, where each tuple contains the i-th element
    from each of the argument sequences.  The returned list is truncated
    in length to the length of the shortest argument sequence.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will work:</p>
<pre><code>&gt;&gt;&gt; str1 = "AAA"
&gt;&gt;&gt; str2 = "AAT"
&gt;&gt;&gt; sum(1 for x,y in enumerate(str1) if str2[x] != y)
1
&gt;&gt;&gt; str1 = "AAABBBCCC"
&gt;&gt;&gt; str2 = "ABCABCABC"
&gt;&gt;&gt; sum(1 for x,y in enumerate(str1) if str2[x] != y)
6
&gt;&gt;&gt;
</code></pre>
<p>The above solution uses <a href="http://docs.python.org/3/library/functions.html#sum" rel="nofollow"><code>sum</code></a>, <a href="http://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a>, and a <a href="http://www.python.org/dev/peps/pep-0289/" rel="nofollow">generator expression</a>.</p>
<hr/>
<p>Because <code>True</code> can evaluate to <code>1</code>, you could even do:</p>
<pre><code>&gt;&gt;&gt; str1 = "AAA"
&gt;&gt;&gt; str2 = "AAT"
&gt;&gt;&gt; sum(str2[x] != y for x,y in enumerate(str1))
1
&gt;&gt;&gt;
</code></pre>
<p>But I personally prefer the first solution because it is clearer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Building on what poke said I would suggest the <a href="https://pypi.python.org/pypi/jellyfish/0.1.2" rel="nofollow">jellyfish</a> package. It has several distance measures like what you are asking for. Example from the documentation:</p>
<pre><code>IN [1]: jellyfish.damerau_levenshtein_distance('jellyfish', 'jellyfihs')
OUT[1]: 1
</code></pre>
<p>or using your example:</p>
<pre><code>IN [2]: jellyfish.damerau_levenshtein_distance('AAA','AAT')
OUT[2]: 1
</code></pre>
<p>This will work for many different string lengths and should be able to handle most of what you throw at it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Similar to simon's answer, but you don't have to zip things in order to just call a function on the resulting tuples because that's what <code>map</code> does anyway (and <code>itertools.imap</code> in Python 2). And there's a handy function for <code>!=</code> in <code>operator</code>. Hence:</p>
<pre><code>sum(map(operator.ne, s1, s2))
</code></pre>
</div>
<span class="comment-copy"><a href="http://en.wikipedia.org/wiki/Levenshtein_distance" rel="nofollow noreferrer">Levenshtein distance</a> for example?</span>
<span class="comment-copy">Might I suggest avoiding variable names starting with lowercase L? I thought you were comparing 11 to  1</span>
<span class="comment-copy">@mhlester: You have a point there. But what are good abbreviations for several letters in a string?</span>
<span class="comment-copy">If it's only used in a comprehension, it doesn't much matter. I fully support your x/y :)</span>
<span class="comment-copy">beautiful, thanks</span>
<span class="comment-copy">Could the operator.ne be replaced with a lambda function?</span>
<span class="comment-copy">@goodcow: sure, but I don't think it would improve things in any way other than reducing the number of <code>import</code> lines at the top of your file :-)</span>
<span class="comment-copy">Nice! This version is quite a bit faster than my version on Python 3.3!</span>
