<div class="post-text" itemprop="text">
<p>I want to create a python module which can have its functions called from a C++ class and call c++ functions from that class </p>
<p>i have looked at boost however it hasn't seemed to make any sense 
it refers to a shared library (which i have no idea how to create) and i cant fallow the code they use in examples (it seems very confusing)</p>
<p>here is their hello world tutorial 
(<a href="http://www.boost.org/doc/libs/1_55_0b1/libs/python/doc/tutorial/doc/html/index.html#python.quickstart" rel="nofollow">http://www.boost.org/doc/libs/1_55_0b1/libs/python/doc/tutorial/doc/html/index.html#python.quickstart</a>)</p>
<p>Following C/C++ tradition, let's start with the "hello, world". A C++ Function:</p>
<pre><code>char const* greet()
{
   return "hello, world";
}
</code></pre>
<p>can be exposed to Python by writing a Boost.Python wrapper:</p>
<pre><code>include &lt;boost/python.hpp&gt;

BOOST_PYTHON_MODULE(hello_ext)
{
    using namespace boost::python;
    def("greet", greet);
}
</code></pre>
<p>That's it. We're done. We can now build this as a shared library. The resulting DLL is now
visible to Python. Here's a sample Python session:</p>
<pre><code>&gt;&gt;&gt; import hello_ext
&gt;&gt;&gt; print hello_ext.greet()
hello, world
</code></pre>
<p>Next stop... Building your Hello World module from start to finish...</p>
<p>could someone please help explain what is being done and most of all how python knows about the C++ file</p>
</div>
<div class="post-text" itemprop="text">
<p>Python does not know about the C++ file, it will only be aware of the <em>extension module</em> that is compiled from the C++ file. This extension module is an object file, called a shared library. This file has an interface that looks to Python <em>as if it was a normal Python module</em>. </p>
<p>This object file will only exist after you tell a compiler to compile the C++ file and link it with all the libraries it needs. Of course, the first library needed is Boost.Python itself, which must be available on the system where you are compiling.</p>
<p>You can tell Python to compile the C++ file for you, so that you do not need to mess with the compiler and its library flags. In order to do so, you need a file called <code>setup.py</code> where you use the Setuptools library or the standard Distutils to define how your other Python modules are to be installed on the system. One of the steps for installing is compiling all extension modules, called the <code>build_ext</code> phase.</p>
<p>Let us imagine you have the following directories and files:</p>
<pre><code>hello-world/
├── hello_ext.cpp
└── setup.py
</code></pre>
<p>The content of <code>setup.py</code> is:</p>
<pre><code>from distutils.core import setup
from distutils.extension import Extension


hello_ext = Extension(
    'hello_ext',
    sources=['hello_ext.cpp'],
    include_dirs=['/opt/local/include'],
    libraries=['boost_python-mt'],
    library_dirs=['/opt/local/lib'])


setup(
    name='hello-world',
    version='0.1',
    ext_modules=[hello_ext])
</code></pre>
<p>As you can see, we are telling Python there is an Extension we want to compile, where the source file is, and where the included libraries are to be found. <em>This is system-dependent</em>. The example shown here is for a Mac OS X system, where Boost libraries were installed via MacPorts.</p>
<p>The content of <code>hello_ext.cpp</code> is as shown in the tutorial, but take care to reorder things so that the <code>BOOST_PYTHON_MODULE</code> macro comes <strong>after the definitions of whatever must be exported to Python</strong>:</p>
<pre><code>#include &lt;boost/python.hpp&gt;

char const* greet()
{
   return "hello, world";
}

BOOST_PYTHON_MODULE(hello_ext)
{
    using namespace boost::python;
    def("greet", greet);
}
</code></pre>
<p>You can then tell Python to compile and link for you by executing the following on the command line:</p>
<pre><code>$ python setup.py build_ext --inplace
running build_ext
building 'hello_ext' extension
/usr/bin/clang -fno-strict-aliasing -fno-common -dynamic -pipe -Os -fwrapv -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -I/opt/local/include -I/opt/local/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c hello_ext.cpp -o build/temp.macosx-10.9-x86_64-2.7/hello_ext.o
/usr/bin/clang++ -bundle -undefined dynamic_lookup -L/opt/local/lib -Wl,-headerpad_max_install_names -L/opt/local/lib/db46 build/temp.macosx-10.9-x86_64-2.7/hello_ext.o -L/opt/local/lib -lboost_python-mt -o ./hello_ext.so
</code></pre>
<p>(The <code>--inplace</code> flag tells Python to leave the products of compilation right next to the source files. The default is to move them to a <code>build</code> directory, to keep the source directory clean.)</p>
<p>After that, you will find a new file called <code>hello_ext.dll</code> (or <code>hello_ext.so</code> on Unix) on the <code>hello-world</code> directory. If you start a Python interpreter in that directory, you will be able to import the module <code>hello_ext</code> and use the function <code>greet</code>, as shown in the Boost tutorial.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is an interpreted language. This means that it needs a virtual machine to execute the statements. For example, if it encounters <code>a = 5</code>, python (or rather the virtual machine that interprets your python code), will create an object in memory that holds some information and the value 5 and will make sure that any following reference to <code>a</code> will find the object. Same goes for more complex statements like <a href="http://docs.python.org/3.3/library/functions.html?highlight=filter#input" rel="nofollow"><code>input</code></a>, on these commands, the virtual machine will trigger a hard coded routine which will do a lot of work under the hood before returning back to read the next piece of python code. So far, so good.</p>
<p>About modules. When issuing the <code>import</code> statement, python will look for the specified module name into its path. This is usually a <code>.py</code> file containing only pure python code to interpret. But that can also be a <code>.pyd</code> file, containing compiled routines that python can use like an executable would do with a <a href="https://en.wikipedia.org/wiki/Library_%28computing%29#Shared_libraries" rel="nofollow">shared library</a>. This file contains symbols and entry points so that when the interpreter finds a special method name like <code>mymodule.mymethod()</code> it knows where to find the routine to execute and runs it.</p>
<p>However, these routines have to conform to a specific interface, and that's why it is not straightforward to expose C/C++ functions to python. The most obvious problem is that python <code>int</code> is not a C <code>int</code>, not a <code>short</code>, not even a <code>long</code>. It's a special structure that holds a lot more information like how often the variable is referenced (to be able to free memory for variables that are not referenced anymore), the type of the value it holds, etc. Of course, a typical C/C++ library doesn't work with these complex types, but uses vanilla <code>int</code>, <code>float</code>, <code>char*</code> and other nice plain types. So one has to translate the necessary python values to simple C types that can be understood by the library, and convert back the potential results delivered by the library into a format usable by python's virtual machine. This is what is called the <em>wrapper</em>. The wrapper also has to take care of funny things like reference counts, memory management on the heap, initialization and finalization, and other monkeys. See some <a href="http://docs.python.org/3/extending/extending.html#a-simple-example" rel="nofollow">examples</a> to get an idea of how such code can look like. This is not extremely complicated, but still some work.</p>
<p>Now you get an idea of all the hard work done under the hood by the <code>Python.Boost</code> library (or other wrapping tools for that matters) when calling the ridiculously simple <code>def("greet", greet);</code>. </p>
</div>
<span class="comment-copy">Look at SWIG. Boost.Python requires its own library to be linked with your extension, and this library is a pain to get for anyone using your code. SWIG will give you a .cpp file that you can compile like any other Python module written in C++.</span>
