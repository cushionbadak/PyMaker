<div class="post-text" itemprop="text">
<p>in order to automatically generate parameterized tests, I am trying to add methods to a class in by freezing some parameters of an existing method. Here is the piece of Python 3 code</p>
<pre><code>class A:
    def f(self, n):
        print(n)

params = range(10)

for i in params:
    name = 'f{0}'.format(i)
    method = lambda self: A.f(self, i)
    setattr(A, name, method)
</code></pre>
<p>However, the following lines then produce rather disappointing output</p>
<pre><code>a = A()
a.f0()
</code></pre>
<p>prints "9" (instead of "0"). I must be doing something wrong, but I can't see what. Can you help ?</p>
<p>Thanks a lot </p>
<hr/>
<p>Edit: this question is indeed a duplicate. I would like to acknowledge the quality of all comments, which go much deeper than the raw answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try</p>
<pre><code>method = lambda self, i=i: A.f(self, i)
</code></pre>
<p>because otherwise when you call the method <code>i</code>'s value may have changed </p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to "freeze" parameters in Python is to use <a href="http://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial</code></a>. It's roughly equivalent to warwaruk's lambda version, but if you have a function with lots of arguments yet only want to freeze one or two of them (or if you only know certain arguments and don't care about the rest) using <code>partial</code> is more elegant as you only specify the arguments you want to freeze rather than having to repeat the whole function signature in the lambda.</p>
<p>An example for your program:</p>
<pre><code>class A:
    def f(self, n):
        print(n)

from functools import partial

for i in range(10): # params
    setattr(A, 'f{0}'.format(i), partial(A.f, n=i))
</code></pre>
<p>Depending on which version of Python 3 you're using, you may not need to include the <code>0</code> in the string format placeholder; starting with 3.1, iirc, it should be automatically substituted.</p>
</div>
<span class="comment-copy">for such things in tests try <a href="http://www.voidspace.org.uk/python/mock/" rel="nofollow noreferrer">mock</a></span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/1841268/generating-functions-inside-loop-with-lambda-expression-in-python">Generating functions inside loop with lambda expression in python</a></span>
<span class="comment-copy">@warwaruk: after looking at the quick start guide, I am not sure how mock can help... but I am quite happy to learn about this package. Might prove useful at some point.</span>
<span class="comment-copy">This is related to variable scopes. <code>lambda</code> is a simple function with body of <code>A.f(self, i)</code>. When you call a method with this body, <code>i</code>'s value is requested. It is taken from outer scope. Search SO and google for closures</span>
<span class="comment-copy">@Sebastien It's due to the fact that, without the <code>=i</code> part, the value of <code>i</code> will not be determined until the lambda function is executed (in which case it goes with the most recent value assigned to <code>i</code>, which after your loop will be <code>9</code>). This is true for all Python functions, in fact, and is the reason why you can have issues when referring to nonlocal variables (but is also the reason you can declare a function before declaration of the nonlocal value it uses). There's quite a bit more to scope in Python than that, but that's how it basically works.</span>
<span class="comment-copy">@Sebastien Python variables are actually very similar to Java variables (there are some oddities around primitives not being objects, but nothing that affects common operations). It's languages like C, C++ which differ significantly from Python and Java. By the way, Java sidesteps the moral equivalent of this problem (with an inner class instead of a <code>lambda</code>/closure) by requiring <code>i</code> to be <code>final</code>, i.e. non-modifiable.</span>
<span class="comment-copy">@Sebastien Scope isn't really the issue here, time of evaluation is. In fact, without this behavior, it would be a lot harder to write closures in Python. (Note that Python [3] actually defaults to <code>final</code>-like behavior for all nonlocal variables; you can modify attributes of the variables, just as you can with non-final members of <code>final</code> objects in Java, but you cannot assign a different object to the nonlocal variable without first declaring the variable as <code>nonlocal</code> inside the closure.)</span>
<span class="comment-copy">There's also <code>global</code>, which acts similarly to <code>nonlocal</code> but for global/module-level variables. It also has the difference that, while the statement <code>nonlocal x</code> requires <code>x</code> to exist in lexical scope when the function is created, the statement <code>global x</code> does not (but if you don't create the variable at execution time of the module, all uses of that variable in functions will require the usage of <code>global x</code> even if you don't assign anything to it in those others; while this pattern does have some uses [I remember using it with <code>ply</code>/<code>llvmpy</code>], it's not something you'll want to do regularly).</span>
