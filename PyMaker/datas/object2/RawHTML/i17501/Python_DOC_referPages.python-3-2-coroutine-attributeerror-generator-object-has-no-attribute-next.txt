<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/python3.2
import sys

def match_text(pattern):
    line = (yield)
    if pattern in line:
        print(line)

x = match_text('apple')
x.next()

for line in input('&gt;&gt;&gt;&gt; '):
    if x.send(line):
        print(line)

x.close()
</code></pre>
<p>This is a coroutine but Python3.2 sees it as a generator - why? What is going on here? I'm referring to Python Essential Reference by David Beazeley pg:20.</p>
<p>To quote the relevant section:</p>
<pre><code>Normally, functions operate on a single set of input arguments. However, a function can
also be written to operate as a task that processes a sequence of inputs sent to
it.This type of function is known as a coroutine and is created by using the yield 
statement as an expression (yield) as shown in this example:
 def print_matches(matchtext):
   print "Looking for", matchtext
   while True:
     line = (yield)       # Get a line of text
     if matchtext in line:
       print line

To use this function, you first call it, advance it to the first (yield), and then 
start sending data to it using send(). For example:
&gt;&gt;&gt; matcher = print_matches("python")
&gt;&gt;&gt; matcher.next() # Advance to the first (yield)
Looking for python
&gt;&gt;&gt; matcher.send("Hello World")
&gt;&gt;&gt; matcher.send("python is cool")
python is cool
&gt;&gt;&gt; matcher.send("yow!")
&gt;&gt;&gt; matcher.close() # Done with the matcher function call
</code></pre>
<p>Why doesn't my code work - not that DB's works..</p>
<pre><code>deathstar&gt; python3.2 xxx   
Traceback (most recent call last):
  File "xxx", line 9, in &lt;module&gt;
    matcher.next() # Advance to the first (yield)
AttributeError: 'generator' object has no attribute 'next'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're getting thrown off by the error message; type-wise, Python doesn't make a distinction - you can <code>.send</code> to anything that uses <code>yield</code>, even if it doesn't do anything with the sent value internally.</p>
<p>In 3.x, there is no longer a <code>.next</code> method attached to these; instead, use the built-in free function <code>next</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For python version 3.2 the syntax for the <code>next()</code> in-built function should be <code>matcher.__next__()</code> or <code>next(matcher)</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>In the case you find yourself patching somebody's code, it seems that the built-in python3 next() function calls the iterator's <strong>next</strong>() function, so you may be able to find/replace somebody's python2 <code>.next(</code> with the python3-tolerable <code>.__next__(</code> as I just did to make portions of the primefac module work in python3 (among other trivial changes).</p>
<p>Here's the <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">reference</a>:</p>
<blockquote>
<p>next(iterator[, default])</p>
<p>Retrieve the next item from the iterator by calling its <strong>next</strong>() 
     method. If default is given, it is returned if the iterator is 
     exhausted, otherwise StopIteration is raised.</p>
</blockquote>
</div>
<span class="comment-copy">Duplicate of <a href="http://stackoverflow.com/questions/12274606/theres-no-next-function-in-a-yield-generator-in-python-3" title="theres no next function in a yield generator in python 3">stackoverflow.com/questions/12274606/â€¦</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/12274606/theres-no-next-function-in-a-yield-generator-in-python-3">there's no next() function in a yield generator in python 3</a></span>
