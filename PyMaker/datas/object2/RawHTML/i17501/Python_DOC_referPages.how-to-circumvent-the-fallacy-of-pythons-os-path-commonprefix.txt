<div class="post-text" itemprop="text">
<p>My problem is to find the common <em>path</em> prefix of a given set of files.</p>
<p>Literally I was expecting that "os.path.commonprefix" would do just that. Unfortunately, the fact that <code>commonprefix</code> is located in <code>path</code> is rather misleading, since it actually will search for string prefixes. </p>
<p>The question to me is, how can this actually be solved for paths? The issue was briefly mentioned in <a href="https://stackoverflow.com/a/7288019/1804173">this (fairly high rated) answer</a> but only as a side-note and the proposed solution (appending slashes to the input of commonprefix) imho has issues, since it will fail for instance for:</p>
<pre><code>os.path.commonprefix(['/usr/var1/log/', '/usr/var2/log/'])
# returns /usr/var but it should be /usr
</code></pre>
<p>To prevent others from falling into the same trap, it might be worthwhile to discuss this issue in a separate question: Is there a simple / portable solution for this problem that does not rely on nasty checks on the file system (i.e., access the result of commonprefix and check whether it is a directory and if not returns a <code>os.path.dirname</code> of the result)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Awhile ago I ran into this where <code>os.path.commonprefix</code> is a string prefix and not a path prefix as would be expected. So I wrote the following:</p>
<pre><code>def commonprefix(l):
    # this unlike the os.path.commonprefix version
    # always returns path prefixes as it compares
    # path component wise
    cp = []
    ls = [p.split('/') for p in l]
    ml = min( len(p) for p in ls )

    for i in range(ml):

        s = set( p[i] for p in ls )         
        if len(s) != 1:
            break

        cp.append(s.pop())

    return '/'.join(cp)
</code></pre>
<p>it could be made more portable by replacing <code>'/'</code> with <code>os.path.sep</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems that this issue has been corrected in recent versions of Python.  New in version 3.5 is the function <a href="https://docs.python.org/3/library/os.path.html#os.path.commonpath" rel="noreferrer"><code>os.path.commonpath()</code></a>, which returns the common path instead of the common string prefix.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you want the common directory path, one way is to:</p>
<ol>
<li>Use only directory paths as input. If your input value is a file name, call <code>os.path.dirname(filename)</code> to get its directory path.</li>
<li>"Normalize" all the paths so that they are relative to the same thing and don't include double separators. The easiest way to do this is by calling <code>os.path.abspath( )</code> to get the path relative to the root. (You might also want to use <code>os.path.realpath( )</code> to remove symbolic links.)</li>
<li>Add a final separator (found portably with <code>os.path.sep</code> or <code>os.sep</code>) to the end of all the normalized directory paths.</li>
<li>Call <code>os.path.dirname( )</code> on the result of <code>os.path.commonprefix( )</code>.</li>
</ol>
<p>In code (without removing symbolic links):</p>
<pre><code>def common_path(directories):
    norm_paths = [os.path.abspath(p) + os.path.sep for p in directories]
    return os.path.dirname(os.path.commonprefix(norm_paths))

def common_path_of_filenames(filenames):
    return common_path([os.path.dirname(f) for f in filenames])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A robust approach is to split the path into individual components and then find the longest common prefix of the component lists.</p>
<p>Here is an implementation which is cross-platform and can be generalized easily to more than two paths:</p>
<pre><code>import os.path
import itertools

def components(path):
    '''
    Returns the individual components of the given file path
    string (for the local operating system).

    The returned components, when joined with os.path.join(), point to
    the same location as the original path.
    '''
    components = []
    # The loop guarantees that the returned components can be
    # os.path.joined with the path separator and point to the same
    # location:    
    while True:
        (new_path, tail) = os.path.split(path)  # Works on any platform
        components.append(tail)        
        if new_path == path:  # Root (including drive, on Windows) reached
            break
        path = new_path
    components.append(new_path)

    components.reverse()  # First component first 
    return components

def longest_prefix(iter0, iter1):
    '''
    Returns the longest common prefix of the given two iterables.
    '''
    longest_prefix = []
    for (elmt0, elmt1) in itertools.izip(iter0, iter1):
        if elmt0 != elmt1:
            break
        longest_prefix.append(elmt0)
    return longest_prefix

def common_prefix_path(path0, path1):
    return os.path.join(*longest_prefix(components(path0), components(path1)))

# For Unix:
assert common_prefix_path('/', '/usr') == '/'
assert common_prefix_path('/usr/var1/log/', '/usr/var2/log/') == '/usr'
assert common_prefix_path('/usr/var/log1/', '/usr/var/log2/') == '/usr/var'
assert common_prefix_path('/usr/var/log', '/usr/var/log2') == '/usr/var'
assert common_prefix_path('/usr/var/log', '/usr/var/log') == '/usr/var/log'
# Only for Windows:
# assert common_prefix_path(r'C:\Programs\Me', r'C:\Programs') == r'C:\Programs'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've made a small python package <code>commonpath</code> to find common paths from a list. Comes with a few nice options.</p>
<p><a href="https://github.com/faph/Common-Path" rel="nofollow">https://github.com/faph/Common-Path</a></p>
</div>
<span class="comment-copy">Related issue: <a href="http://bugs.python.org/issue10395" rel="nofollow noreferrer">bugs.python.org/issue10395</a>. A patch is in the pipe line.</span>
<span class="comment-copy">I accepted this answer since it is fairly robust while maintaining good brevity. It is interesting to see that in contrast to a solution based on <code>os.path.commenprefix</code> (see Dan Getz's answer), the component-wise comparison does not depend on whether the input paths are file or directory names (simply because filenames are unique components). For a more robust approach I recommend EOL's answer and to learn more about the problems of <code>os.path.commonprefix</code> Dan Getz' answer is very instructive. Thank you all!</span>
<span class="comment-copy">This gives a reasonable answer with both file or directory names, but in the general case you can't know for certain if the result of the function is a file or directory name without doing more work (such as by controlling the input). Also, I believe this returns the exact same result as <code>os.path.dirname(os.path.commonprefix([p + '/' for p in l]))</code>?</span>
<span class="comment-copy">@DanGetz It apparently does not do the same. I just tried it on windows by replacing it with <code>os.path.sep</code> and the code provided by @DanD results in the correct common path while your snippet returns <code>None</code></span>
<span class="comment-copy">@thatsIch what inputs cause that? I was unaware <code>dirname</code> <i>could</i> return <code>None</code>.</span>
<span class="comment-copy">@DanGetz I must have messed it up somewhere. I just tried it again in a fresh environment and it works. My bad.</span>
<span class="comment-copy">Thanks!  This is Yet Another Reason to switch to python 3 -- glad I finally did it last year.</span>
<span class="comment-copy">When I was thinking about this idea I rejected it initially, because I though appending a slash is a problem when working with relative paths, like a blank file name in the current directory. However, when wrapping all paths into <code>os.path.abspath</code>, even a mixture of relative and absolute paths should be no problem, right?</span>
<span class="comment-copy">@bluenote10 Right, <code>abspath</code> instead of <code>normpath</code> will handle the relative paths. Not sure about blank file names, because that's ambiguous with duplicated path separators. Does anyone allow zero-length file names?</span>
<span class="comment-copy">Oh, I didn't mean empty file names, just <code>"aSimpleFileName"</code>.</span>
<span class="comment-copy">One should probably mention that it all depends on whether <code>paths</code> are <i>file</i> paths or <i>directory</i> paths (this must be a convention in case we want to avoid file system access). In my problem <code>paths</code> would be in fact files not directories. I think in this case the proper order is: (a) convert to abspath to deal with mixture of relative/absolute paths; (b) apply dirname to convert to a proper directory. From that point I think we can safely apply your solution.</span>
<span class="comment-copy">Oh, now I see it, good point. You need to know in advance if your string is a file or directory path. I thought I was getting around that, but instead I was just assuming directories.</span>
