<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/14366401/correctly-parsing-string-literals-with-pythons-re-module">Correctly parsing string literals with python's re module</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I was wondering what regex-string you can use to parse a python string. After several fails I came to a regex-code, which can parse one of the most used string formats, like </p>
<pre><code>"this is \"my string\", which ends here"
</code></pre>
<p>This is my regex-"code":</p>
<pre><code>"([^"\\]|(\\.))*"
</code></pre>
<p>I asked this question because I didn't find anything like that on the Internet before. Can I work with that expression and "develop" it to parse all kinds of python strings? If you find this question interesting and <a href="http://regexpal.com" rel="nofollow">I recommend you</a>, where you can check your expressions very quickly.</p>
</div>
<div class="post-text" itemprop="text">
<p>This seems to handle everything correctly:</p>
<pre><code>rr = r'''(?xi)
        (r|u|ru|ur|)
        (
            ''\' (\\. | [\s\S])*? ''\'
            |
            """ (\\. | [\s\S])*? """
            |
            ' (\\. | [^'\n])* '
            |
            " (\\. | [^"\n])* "
        )
'''
</code></pre>
<p>Test: <a href="https://ideone.com/DEimLl" rel="nofollow">https://ideone.com/DEimLl</a></p>
<p>Syntax reference: <a href="http://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow">http://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Your regex pattern ( and the one in @thebjorn link) will fail if there is an odd number&gt;1 of backslashes before the quote, I suggest you to use this pattern (with singleline mode):</p>
<pre><code>"(?:[^"\\]|\\{2}|\\.)*"
</code></pre>
<p>an optimised way:</p>
<pre><code>"(?:(?=([^"\\]+|\\{2}|\\.))\1)*"
</code></pre>
<p>to deal with single quotes too:</p>
<pre><code>(["'])(?:[^"'\\]|\\{2}|\\.|(?!\1)["'])*\1
</code></pre>
<p>or</p>
<pre><code>(["'])(?:(?=([^"'\\]+|\\{2}|\\.|(?!\1)["']))\2)*\1
</code></pre>
<p><i>(note that the last character of the four patterns are exactly on the same line, a sign?)</i></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a different way, which uses <a href="http://docs.python.org/2/library/tokenize.html#tokenize.generate_tokens" rel="nofollow">tokenize.generate_tokens</a> to identify Python strings. The tokenize module uses regex; so by using <code>tokenize</code> you leave the complex dirty work to Python itself. By using higher-level functions you can be more confident the regex is correct (and avoid reinventing the wheel). Moreover, this will correctly identify Python strings of all sorts (e.g. strings of the single quoted, double quoted, and triple quoted varieties) without being confused by comments.</p>
<pre><code>import tokenize
import token
import io
import collections

class Token(collections.namedtuple('Token', 'num val start end line')):
    @property
    def name(self):
        return token.tok_name[self.num]

text = r'''foo = 1 "this is \"my string\", which ends here" bar'''

for tok in tokenize.generate_tokens(io.BytesIO(text).readline):
    tok = Token(*tok)            # 1
    if tok.name == 'STRING':     # 2
        print(tok.val)
</code></pre>
<ol>
<li>tokenize.generate_tokens returns tuples. The Token class allows you
to access the information in the tuple in a nicer way.</li>
<li>In particular, each Token has a name, such as 'STRING', 'NEWLINE',
'INDENT', or 'OP'. You can use this to identify Python strings.</li>
</ol>
<hr/>
<p>Edit: I like using the Token class so I don't have to write
<code>token.tok_name[num]</code> in lots of places. However, for the code above, it might be clearer and easier to forget about the Token class and just write the main idea explicitly:</p>
<pre><code>import tokenize
import token
import io

text = r'''foo = 1 "this is \"my string\", which ends here" bar'''

for num, val, start, end, line in tokenize.generate_tokens(io.BytesIO(text).readline):
    if token.tok_name[num]  == 'STRING': 
        print(val)
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/14366401/correctly-parsing-string-literals-with-pythons-re-module" title="correctly parsing string literals with pythons re module">stackoverflow.com/questions/14366401/…</a></span>
<span class="comment-copy"><code>r'"(?:\\"|[^"])*"'</code></span>
<span class="comment-copy">Don't forget that you need to handle prefixes also (unicode/raw strings.) For example, u"ª unicode string", r"\I have 3 literal backslashes\\", UR'unícode and no\e\s\c\a\p\e characters'. Also delimiters - '/"/'''/""". And even though you can't escape delimiters in a raw string, you still can't end a raw string with a backslash. Lots of edge cases involved in doing what you want.</span>
<span class="comment-copy">It looks very technical and excellent, but indeed very complex form new like me. --- <code>Token(*tok)</code> you says <code>The Token class allows you to access the information in the tuple in a nicer way.</code> Not clear to me. -- I have bookmarked this answer to explore further. Thanks for adding this answer.</span>
<span class="comment-copy">Why the <code>Token</code> class? just <code>Token = collections.namedtuple('Token', 'num val start end line')</code> and then <code>tok = Token._make(tok)</code> will do... (unless I'm missing something)</span>
<span class="comment-copy">@JonClements: In longer code, I don't like writing <code>token.tok_name[num]</code> all over the place. Replacing that with a <code>name</code> attribute is the purpose of the Token class.</span>
<span class="comment-copy">@unutbu my apologies - I misread the intent of what <code>name</code> was doing there... - ignore me :)</span>
<span class="comment-copy">@JonClements: No problem; thanks for prompting me to explain, since I forget that it's 10x easier to write code than understand other people's code. :)</span>
