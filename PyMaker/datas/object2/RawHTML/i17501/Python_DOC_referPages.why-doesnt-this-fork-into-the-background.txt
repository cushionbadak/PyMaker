<div class="post-text" itemprop="text">
<p>I want to fork into the background to run a long-running function, with the parent exiting immediately. I can't use <code>os.fork()</code> because I need Windows support. This is what I came up with:</p>
<pre><code>#!/usr/bin/env python3

import multiprocessing
import time

def long_running_function(timeout=30):
    time.sleep(timeout)

if __name__ == '__main__':
    multiprocessing.Process(target=long_running_function).start()
</code></pre>
<p>It <em>does</em> spawn a child process: <code>ps</code> shows two Python processes with the same command string. However, on both my Mac and the Windows machine I tried it on, it acts as if I'd called <code>join()</code> on the <code>Process</code>: both parent and child keep running, and if I do <kbd>ctrl</kbd>-<kbd>c</kbd>, both die. What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>To start multiprocessing Process can fork but it is not required. Process uses a similar API as Threading does which does not cause a call to the fork() API from the OS. In Python a simple fork example would be:</p>
<pre><code>#!/usr/bin/env python

"""A basic fork in action"""

import os

def my_fork():
    child_pid = os.fork()
    if child_pid == 0:
        print "Child Process: PID# %s" % os.getpid()
    else:
        print "Parent Process: PID# %s" % os.getpid()

if __name__ == "__main__":
    my_fork()
</code></pre>
<p>Notice how we're importing the os library. In your example you aren't causing fork() to never be called.</p>
<p>Please note that on Windows, fork() does not exist so you cannot fork as you will be able to on *nix systems. </p>
<p>Please see <a href="https://www.ibm.com/developerworks/aix/library/au-multiprocessing/" rel="nofollow">HERE</a> for a good article explaining forking in Python.</p>
</div>
<span class="comment-copy">Just wonder, is this possible? So on linux if you ctrl+C the main python process the forked process continues to run, correct?</span>
<span class="comment-copy">What are you using this for? Keeping a program running after <code>^C</code> is usually an anti-pattern.</span>
<span class="comment-copy">@laike9m Yes. Programs that start daemons use this model (fork, exec, parent exits), including some (most?) init scripts.</span>
<span class="comment-copy">@LambdaFairy I'm not trying to ignore <code>^C</code> specifically (besides, that's a different issue, involving <a href="http://docs.python.org/3/library/signal.html" rel="nofollow noreferrer"><code>signal</code></a>); I'm trying to fork into the background.</span>
<span class="comment-copy">@laike9m Actually, I shouldn't <i>have</i> to signal the parent: it should exit immediately after starting the child, having nothing else to do. Just like an init script.</span>
<span class="comment-copy">Asker specifically states he cannot use <code>os.fork()</code>.</span>
<span class="comment-copy">Specifically because I need Windows compatability.</span>
<span class="comment-copy">Did you read the article? I mean it does explain how to use multiprocessing/subprocess/Process properly in order to obtain what you are looking for. I know that os.fork() is not available everywhere, I mentioned that. Anyways, hopefully that article helps you.</span>
<span class="comment-copy">Here's the full link to the article, just in case. <a href="https://www.ibm.com/developerworks/aix/library/au-multiprocessing/" rel="nofollow noreferrer">ibm.com/developerworks/aix/library/au-multiprocessing</a></span>
