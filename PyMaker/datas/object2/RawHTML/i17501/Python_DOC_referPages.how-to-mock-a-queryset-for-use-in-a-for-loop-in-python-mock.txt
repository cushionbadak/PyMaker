<div class="post-text" itemprop="text">
<p>I am writing some unit tests and want to use Mock.</p>
<p>Given the following code:</p>
<pre><code># the 'real' query set is a Django database model
# qs = SomeDjangoModel.objects.filter(name='some_name')
qs = mock.Mock()
qs.filter.return_value = qs
item = mock.Mock()
item.do_work.return_value = "Some text"
qs.iter.return_value = iter([item])
# below is the code I want to test..
qs = qs.filter(name='some name')
qs = qs.filter(valid_from__lte=Timezone.now())
for obj in qs:
    obj.do_work()
</code></pre>
<p>when run, I get </p>
<blockquote>
<p>TypeError: 'Mock' object is not iterable</p>
</blockquote>
<p>I have tried patching</p>
<pre><code>@mock.patch('__builtin__.iter')
</code></pre>
<p>but I just can't seem to get it to work.
I haven't succeeded in figuring out what really goes on when the query set "used" by the for-loop.</p>
<p>Help is greatly appreciated!</p>
<p>[edited with further added example code, after first solution proposal]</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to use <a href="https://docs.djangoproject.com/en/1.8/ref/models/querysets/#django.db.models.query.QuerySet.iterator" rel="nofollow noreferrer"><code>iterator</code></a> and <a href="https://docs.python.org/3/library/unittest.mock.html#magic-mock" rel="nofollow noreferrer"><code>MagicMock</code></a> which has <code>__iter__</code> defined</p>
<pre><code>from unittest.mock import Mock, MagicMock
from datetime import datetime

qs = MagicMock()
qs.filter.return_value = qs
item = Mock()
item.do_work.return_value = "Some text"
qs.iterator.return_value = iter([item])
# below is the code I want to test..
qs = qs.filter(name='some name')
qs = qs.filter(valid_from__lte=datetime.now())
for obj in qs:
    obj.do_work()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Usually I mock the QuerySet to be a list instead, that seems easier. So:</p>
<pre><code>something.return_value = [item]
</code></pre>
<p>where <code>something</code> is the function or place where you're computing the QuerySet. As an actual example:</p>
<pre><code>MyModel.objects.filter.return_value = [item]
</code></pre>
<p>This only works if you're not using QuerySet specific characteristics.</p>
</div>
<div class="post-text" itemprop="text">
<p>A colleague of mine helped me solve this. The following code does I wanted.</p>
<pre><code>  def the_iter(self):
        return iter(self.my_test_list)

    def test_my_code(self):
        qs = mock.Mock()
        qs.filter.return_value = qs
        the_item = mock.Mock()
        the_item.do_work.return_value = "Some text"
        self.my_test_list = [the_item]
        qs.__iter__ = mock.Mock(side_effect=self.the_iter)

        # below is the code I want to test..
        qs = qs.filter(name='some name')
        qs = qs.filter(colour='Yellow')
        for obj in qs:
            print obj.do_work()
</code></pre>
</div>
<span class="comment-copy">Where does the QuerySet come from?</span>
<span class="comment-copy">@SimeonVisser It's a django database model.</span>
<span class="comment-copy">How does this work with chaining e.g. <code>filter()</code> in multiple steps.</span>
<span class="comment-copy">Thanks, but this didn't do it for me. I added some codelines to my example, to better illustrate what I am trying to do. Any further hints/clues would be great!</span>
<span class="comment-copy">this answer actually helped me :)</span>
