<div class="post-text" itemprop="text">
<p>I am trying to find the largest cube root that is a whole number, that is less than 12,000. </p>
<pre><code>processing = True
n = 12000
while processing:
    n -= 1
    if n ** (1/3) == #checks to see if this has decimals or not
</code></pre>
<p>I am not sure how to check if it is a whole number or not though! I could convert it to a string then use indexing to check the end values and see whether they are zero or not, that seems rather cumbersome though. Is there a simpler way?</p>
</div>
<div class="post-text" itemprop="text">
<p>To check if a float value is a whole number, use the <a href="http://docs.python.org/2/library/stdtypes.html#float.is_integer"><code>float.is_integer()</code> method</a>:</p>
<pre><code>&gt;&gt;&gt; (1.0).is_integer()
True
&gt;&gt;&gt; (1.555).is_integer()
False
</code></pre>
<p>The method was added to the <code>float</code> type in Python 2.6.</p>
<p>Take into account that in Python 2, <code>1/3</code> is <code>0</code> (floor division for integer operands!), and that floating point arithmetic can be imprecise (a <code>float</code> is an approximation using binary fractions, <em>not</em> a precise real number). But adjusting your loop a little this gives:</p>
<pre><code>&gt;&gt;&gt; for n in range(12000, -1, -1):
...     if (n ** (1.0/3)).is_integer():
...         print n
... 
27
8
1
0
</code></pre>
<p>which means that anything over 3 cubed, (including 10648) was missed out due to the aforementioned imprecision:</p>
<pre><code>&gt;&gt;&gt; (4**3) ** (1.0/3)
3.9999999999999996
&gt;&gt;&gt; 10648 ** (1.0/3)
21.999999999999996
</code></pre>
<p>You'd have to check for numbers <strong>close</strong> to the whole number instead, or not use <code>float()</code> to find your number. Like rounding down the cube root of <code>12000</code>:</p>
<pre><code>&gt;&gt;&gt; int(12000 ** (1.0/3))
22
&gt;&gt;&gt; 22 ** 3
10648
</code></pre>
<p>If you are using Python 3.5 or newer, you can use the <a href="https://docs.python.org/3/library/math.html#math.isclose"><code>math.isclose()</code> function</a> to see if a floating point value is within a configurable margin:</p>
<pre><code>&gt;&gt;&gt; from math import isclose
&gt;&gt;&gt; isclose((4**3) ** (1.0/3), 4)
True
&gt;&gt;&gt; isclose(10648 ** (1.0/3), 22)
True
</code></pre>
<p>For older versions, the naive implementation of that function (skipping error checking and ignoring infinity and NaN) <a href="https://www.python.org/dev/peps/pep-0485/#proposed-implementation">as mentioned in PEP485</a>:</p>
<pre><code>def isclose(a, b, rel_tol=1e-9, abs_tol=0.0):
    return abs(a - b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use the modulo (%) operator. This tells us how many remainders we have when we divide x by y - expresses as <code>x % y</code>. Every whole number must divide by 1, so if there is a remainder, it must not be a whole number. </p>
<p>This function will return a boolean, <code>True</code> or <code>False</code>, depending on whether <code>n</code> is a whole number.</p>
<pre><code>def is_whole(n):
    if n % 1 == 0:
        return True
    else:
        return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use this:</p>
<pre><code>if k == int(k):
    print(str(k) + "is a whole number!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to loop or to check anything. Just take a cube root of 12,000 and round it down: </p>
<pre><code>r = int(12000**(1/3.0))
print r*r*r # 10648
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="http://en.wikipedia.org/wiki/Modulo_operation" rel="noreferrer">modulo</a> operation for that.</p>
<pre><code>if (n ** (1.0/3)) % 1 != 0:
    print("We have a decimal number here!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Wouldn't it be easier to test the cube roots? Start with 20 (20**3 = 8000) and go up to 30 (30**3 = 27000). Then you have to test fewer than 10 integers.</p>
<pre><code>for i in range(20, 30):
    print("Trying {0}".format(i))
    if i ** 3 &gt; 12000:
        print("Maximum integral cube root less than 12000: {0}".format(i - 1))
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about </p>
<pre><code>if x%1==0:
    print "is integer"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The above answers work for many cases but they miss some. Consider the following:</p>
<pre><code>fl = sum([0.1]*10)  # this is 0.9999999999999999, but we want to say it IS an int
</code></pre>
<p>Using this as a benchmark, some of the other suggestions don't get the behavior we might want:</p>
<pre><code>fl.is_integer() # False

fl % 1 == 0     # False
</code></pre>
<p>Instead try:</p>
<pre><code>def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
    return abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)

def is_integer(fl):
    return isclose(fl, round(fl))
</code></pre>
<p>now we get:</p>
<pre><code>is_integer(fl)   # True
</code></pre>
<p><code>isclose</code> comes with <a href="https://docs.python.org/3/library/math.html#math.isclose" rel="nofollow">Python 3.5+</a>, and for other Python's you can use this mostly equivalent definition (as mentioned in the corresponding <a href="https://www.python.org/dev/peps/pep-0485/#proposed-implementation" rel="nofollow">PEP</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/2/library/functions.html#round" rel="nofollow"><code>round</code></a> function to compute the value. </p>
<p>Yes in python as many have pointed when we compute the value of a cube root, it will give you an output with a little bit of error. To check if the value is a whole number you can use the following function:</p>
<pre><code>def cube_integer(n):
    if round(n**(1.0/3.0))**3 == n:
        return True
    return False
</code></pre>
<p>But remember that <a href="https://docs.python.org/2/library/functions.html#int" rel="nofollow"><code>int(n)</code></a> is equivalent to <a href="https://docs.python.org/2/library/math.html#math.floor" rel="nofollow"><code>math.floor</code></a> and because of this if you find the <code>int(41063625**(1.0/3.0))</code> you will get 344 instead of 345.</p>
<p>So please be careful when using <code>int</code> withe cube roots.</p>
<p>Hope I have answered your question. If you have any other queries then you can <a href="http://radiusofcircle.blogspot.com" rel="nofollow">contact me</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just a side info, <code>is_integer</code> is doing internally: </p>
<pre><code>import math
isInteger = (math.floor(x) == x)
</code></pre>
<blockquote>
<p>Not exactly in python, but the cpython implementation is implemented as mentioned above.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Try using:</p>
<pre><code>int(val) == val
</code></pre>
<p>It will give lot more precision than any other methods.</p>
</div>
<span class="comment-copy">it would make it easier to work from the cube root n --&gt; (n * n * n &lt; 12000)</span>
<span class="comment-copy">Not knowing python, this sort of statement would make me nervous as it   seems to require perfect math to work in the real world.</span>
<span class="comment-copy">@PeterM: The method indeed only returns <code>True</code> if there are no decimals at all. There may be a misunderstanding on the part of the OP about floating point arithmetic and precision,  of course.</span>
<span class="comment-copy">@MartijnPieters Yeah and one small slip in a floating point calculation and all of a sudden you have these little, unwanted decimals like 0.00000000000000000001</span>
<span class="comment-copy">@PeterM: and the default representation will round to 16 digits; <code>1.0000000000000001</code> is displayed as <code>1.0</code>.</span>
<span class="comment-copy">@AllDani.com: I'm not sure what you are asking. <code>1.1</code> is not an integer, because the decimal portion is not 0.</span>
<span class="comment-copy">Going to the basics, I like it. You could do <code>return n % 1 == 0</code> to save some lines.</span>
<span class="comment-copy">it fails for <a href="http://stackoverflow.com/a/26447472/4279">larger numbers</a> while <code>.is_integer()</code> continues to work.</span>
<span class="comment-copy">Your link IMHO doesn't show that it doesn't work. It just shows that large floats lose precision. <code>is_integer</code> uses a similar method (<code>o = (floor(x) == x) ? Py_True : Py_False;</code>). But I agree, one should use <code>is_integer()</code> as it is much clearer.</span>
<span class="comment-copy">yes. It just shows that large float may lose precision i.e., <code>large_float == large_int</code> may fail even if <code>large_float == float(large_int)</code>.</span>
<span class="comment-copy"><code>123456789012345678901234567890.0 != 123456789012345678901234567890</code> but <code>123456789012345678901234567890.0 == float(123456789012345678901234567890)</code></span>
<span class="comment-copy">Yeah, but <code>k = 123456789012345678901234567890.0</code> then <code>k == int(k)</code> is True, which is the correct answer.</span>
<span class="comment-copy">This is a reasonable answer.</span>
<span class="comment-copy">if <code>n</code> is 6.2, 6.0, 6.12312412, we all have <code>"We have a decimal number here!"</code>?</span>
<span class="comment-copy">Moreover, floats have round-off errors so that you can miss number when calculating if <code>n**(1/3)</code> is integer. For example on my computer ` 10648**(1/3)=21.999999999999996 ` instead of <code>22</code>: problem! With this answer's method there is no such problem. I think this is the only correct solution from a mathematic point of view (others solutions are Python-correct).</span>
<span class="comment-copy"><code>math.fsum([0.1] * 10) == 1</code></span>
<span class="comment-copy">Can you give an example to back up the claim that "It will give lot more precision"?  This seems unfounded.</span>
