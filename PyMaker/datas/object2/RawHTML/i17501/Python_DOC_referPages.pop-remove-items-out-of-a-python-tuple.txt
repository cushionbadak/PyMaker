<div class="post-text" itemprop="text">
<p>I am not sure if I can make myself clear but will try.</p>
<p>I have a tuple in python which I go through as follows (see code below). While going through it, I maintain a counter (let's call it 'n') and 'pop' items that meet a certain condition.</p>
<p>Now of course once I pop the first item, the numbering all goes wrong, how can I do what I want to do more elegantly while removing only certain entries of a tuple on the fly?</p>
<pre><code>for x in tupleX:
  n=0
  if (condition):
     tupleX.pop(n)
  n=n+1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As <code>DSM</code> mentions, <code>tuple</code>'s are immutable, but even for lists, a more elegant solution is to use <code>filter</code>:</p>
<pre><code>tupleX = filter(str.isdigit, tupleX)
</code></pre>
<p>or, if <code>condition</code> is not a function, use a comprehension:</p>
<pre><code>tupleX = [x for x in tupleX if x &gt; 5]
</code></pre>
<p>if you really need tupleX to be a tuple, use a generator expression and pass that to <code>tuple</code>:</p>
<pre><code>tupleX = tuple(x for x in tupleX if condition)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>ok I figured out a crude way of doing it.</p>
<p>I store the "n" value in the for loop when condition is satisfied in a list (lets call it delList) then do the following:</p>
<pre><code>    for ii in sorted(delList, reverse=True):
    tupleX.pop(ii)
</code></pre>
<p>Any other suggestions are welcome too.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you want dictionaries?</p>
<pre><code>d = dict( (i,value) for i,value in enumerate(tple))
while d:
    bla bla bla
    del b[x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes we can do it.
First convert the tuple into an list, then delete the element in the list after that again convert back into tuple.</p>
<p>Demo:</p>
<pre><code>my_tuple = (10, 20, 30, 40, 50)

# converting the tuple to the list
my_list = list(my_tuple)
print my_list  # output: [10, 20, 30, 40, 50]

# Here i wanna delete second element "20"
my_list.pop(1) # output: [10, 30, 40, 50]
# As you aware that pop(1) indicates second position

# Here i wanna remove the element "50"
my_list.remove(50) # output: [10, 30, 40]

# again converting the my_list back to my_tuple
my_tuple = tuple(my_list)


print my_tuple # output: (10, 30, 40)
</code></pre>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>A tuple is declared as unchangable.</p>
<p>And you are not gonna pop item inside itself iteration, it causes error because it changes the length of list obj.
But you can do it in list comprehensions, on the opposite side.</p>
<pre><code>tupleX = tuple( [ e for e in list( tupleX ) if not condition( e ) ] )
</code></pre>
<p>This keeps elements that didnt match the condition rather than popping it out of the tuple/list.</p>
<p>But if you are intend to do it as similar as your own way, you have to make your tuple a list beforehand by sth like <code>listX = list( tupleX )</code>. youd better add the index of unwanted materials inside the iteration into a list ( unwanted_list ), and iterate unwanted_list and pop ele out in the original list. then make it back to tuple like <code>tuple( listX )</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There is a simple but practical solution.</p>
<p>As DSM said, tuples are immutable, but we know Lists are mutable.
So if you change a tuple to a list, it will be mutable. Then you can delete the items by the condition, then after changing the type to a tuple again. Thatâ€™s it.</p>
<p>Please look at the codes below:</p>
<pre><code>tuplex = list(tuplex)
for x in tuplex:
  if (condition):
     tuplex.pop(tuplex.index(x))
tuplex = tuple(tuplex)
print(tuplex)
</code></pre>
<p>For example, the following procedure will delete all even numbers from a given tuple.</p>
<pre><code>tuplex = (1, 2, 3, 4, 5, 6, 7, 8, 9)
tuplex = list(tuplex)
for x in tuplex:
  if (x % 2 == 0):
     tuplex.pop(tuplex.index(x))
tuplex = tuple(tuplex)
print(tuplex)
</code></pre>
<p>if you test the type of the last tuplex, you will find it is a tuple.</p>
<p>Finally, if you want to define an index counter as you did (i.e., n), you should initialize it before the loop, not in the loop.</p>
</div>
<span class="comment-copy"><code>tuple</code>s are immutable, and don't have a <code>pop</code> method.  Are you really talking about a <code>list</code>?</span>
<span class="comment-copy">For others' reference, the generator expression is optimal in terms of speed.</span>
<span class="comment-copy">@Alecg_O: can you provide benchmarks for that claim?  In fact, in the case that the <code>condition</code> is an (unapplied) C function (as in the example I provided), <code>filter</code> is usually faster; generator expressions must execute some python bytecode, but aren't required to create a call-frame (also as in my example for the list comprehension).</span>
<span class="comment-copy">According to the <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer">docs</a>, the filter and generator solutions are functionally identical - both return an iterable of the original filtered by condition, and by this definition both are constant time. However, assuming the OP requires a tuple for output, the difference comes in the conversion back. For proof: take tuple() off the generator and they'll both return instantly, but tuple() the filter and it takes longer proportional to the size of tupleX.</span>
<span class="comment-copy">Interesting sidenote: I came across this post while looking for the most efficient way to "remove" a single item from a tuple. While these are all great solutions, ironically "x = list(x); x.remove(&lt;item&gt;); x = tuple(x)" is faster than any of them :P</span>
<span class="comment-copy">no I have to work with a tuple as its given to me by an external function that I can't edit-old hierarchical code with too many dependancies.</span>
<span class="comment-copy">ok, see the edit...</span>
<span class="comment-copy">thank you, I will try this -more elegant than my method.</span>
