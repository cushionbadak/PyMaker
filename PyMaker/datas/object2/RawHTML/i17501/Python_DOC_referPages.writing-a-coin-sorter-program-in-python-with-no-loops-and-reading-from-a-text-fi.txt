<div class="post-text" itemprop="text">
<p>How do I read every line of a file in Python and store each line as an element in a list? </p>
<p>I want to read the file line by line and append each line to the end of the list.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open(fname) as f:
    content = f.readlines()
# you may also want to remove whitespace characters like `\n` at the end of each line
content = [x.strip() for x in content] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="http://docs.python.org/tutorial/inputoutput.html#reading-and-writing-files" rel="noreferrer">Input and Ouput</a>:</p>
<pre><code>with open('filename') as f:
    lines = f.readlines()
</code></pre>
<p>or with stripping the newline character:</p>
<pre><code>lines = [line.rstrip('\n') for line in open('filename')]
</code></pre>
<p><sup>Editor's note: This answer's original whitespace-stripping command, <code>line.strip()</code>, as implied by Janus Troelsen's comment, would remove <em>all leading and trailing</em> whitespace, not just the trailing <code>\n</code>.</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>This is more explicit than necessary, but does what you want.</p>
<pre><code>with open("file.txt", "r") as ins:
    array = []
    for line in ins:
        array.append(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will yield an "array" of lines from the file.</p>
<pre><code>lines = tuple(open(filename, 'r'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want the <code>\n</code> included:</p>
<pre><code>with open(fname) as f:
    content = f.readlines()
</code></pre>
<p>If you do not want <code>\n</code> included:</p>
<pre><code>with open(fname) as f:
    content = f.read().splitlines()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could simply do the following, as has been suggested:</p>
<pre><code>with open('/your/path/file') as f:
    my_lines = f.readlines()
</code></pre>
<p>Note that this approach has 2 downsides:</p>
<p>1) You store all the lines in memory. In the general case, this is a very bad idea. The file could be very large, and you could run out of memory. Even if it's not large, it is simply a waste of memory.</p>
<p>2) This does not allow processing of each line as you read them. So if you process your lines after this, it is not efficient (requires two passes rather than one).</p>
<p>A better approach for the general case would be the following:</p>
<pre><code>with open('/your/path/file') as f:
    for line in f:
        process(line)
</code></pre>
<p>Where you define your process function any way you want. For example:</p>
<pre><code>def process(line):
    if 'save the world' in line.lower():
         superman.save_the_world()
</code></pre>
<p>(The implementation of the <code>Superman</code> class is left as an exercise for you).</p>
<p>This will work nicely for any file size and you go through your file in just 1 pass. This is typically how generic parsers will work.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't care about closing the file, this one-liner works:</p>
<pre><code>lines = open('file.txt').readlines()
</code></pre>
<p>The <em>traditional</em> way:</p>
<pre><code>fp = open('file.txt') # Open file on read mode
lines = fp.read().split("\n") # Create a list containing all lines
fp.close() # Close file
</code></pre>
<p>Using <code>with</code> and <code>readlines()</code> <strong>(recommended)</strong>:</p>
<pre><code>with open('file.txt') as fp:
    lines = fp.readlines()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Data into list</p>
<p>Assume that we have a text file with our data like in the following lines:</p>
<h3>Text file content:</h3>
<pre><code>line 1
line 2
line 3
</code></pre>
<ul>
<li>Open the cmd in the same directory (right click the mouse and choose cmd or PowerShell)</li>
<li>Run <code>python</code> and in the interpreter write:</li>
</ul>
<h3>The Python script</h3>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; with open("myfile.txt", encoding="utf-8") as file:
...     x = [l.strip() for l in file]
&gt;&gt;&gt; x
['line 1','line 2','line 3']
</code></pre>
<h3>Using append</h3>
<pre><code>x = []
with open("myfile.txt") as file:
    for l in file:
        x.append(l.strip())
</code></pre>
<h3>Or...</h3>
<pre><code>&gt;&gt;&gt; x = open("myfile.txt").read().splitlines()
&gt;&gt;&gt; x
['line 1', 'line 2', 'line 3']
</code></pre>
<h3>Or...</h3>
<pre><code>&gt;&gt;&gt; x = open("myfile.txt").readlines()
&gt;&gt;&gt; x
['linea 1\n', 'line 2\n', 'line 3\n']
</code></pre>
<h3>Or...</h3>
<pre><code>&gt;&gt;&gt; y = [x.rstrip() for x in open("my_file.txt")]
&gt;&gt;&gt; y
['line 1','line 2','line 3']


with open('testodiprova.txt', 'r', encoding='utf-8') as file:
    file = file.read().splitlines()
  print(file)

with open('testodiprova.txt', 'r', encoding='utf-8') as file:
  file = file.readlines()
  print(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should encapsulate the open command. </p>
<pre><code>array = []
with open("file.txt", "r") as f:
  for line in f:
    array.append(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Clean and Pythonic Way of Reading the Lines of a File Into a List</strong></p>
<hr/>
<p>First and foremost, you should focus on opening your file and reading its contents in an efficient and pythonic way. Here is an example of the way I personally DO NOT prefer:</p>
<pre class="lang-python prettyprint-override"><code>infile = open('my_file.txt', 'r')  # Open the file for reading.

data = infile.read()  # Read the contents of the file.

infile.close()  # Close the file since we're done using it.
</code></pre>
<p>Instead, I prefer the below method of opening files for both reading and writing as it
is very clean, and does not require an extra step of closing the file
once you are done using it. In the statement below, we're opening the file
for reading, and assigning it to the variable 'infile.'  Once the code within
this statement has finished running, the file will be automatically closed.</p>
<pre class="lang-python prettyprint-override"><code># Open the file for reading.
with open('my_file.txt', 'r') as infile:

    data = infile.read()  # Read the contents of the file into memory.
</code></pre>
<p>Now we need to focus on bringing this data into a <strong>Python List</strong> because they are iterable, efficient, and flexible.  In your case, the desired goal is to bring each line of the text file into a separate element. To accomplish this, we will use the <strong>splitlines()</strong> method as follows:</p>
<pre class="lang-python prettyprint-override"><code># Return a list of the lines, breaking at line boundaries.
my_list = data.splitlines()
</code></pre>
<hr/>
<p><strong><em>The Final Product:</em></strong></p>
<pre class="lang-python prettyprint-override"><code># Open the file for reading.
with open('my_file.txt', 'r') as infile:

    data = infile.read()  # Read the contents of the file into memory.

# Return a list of the lines, breaking at line boundaries.
my_list = data.splitlines()
</code></pre>
<p><em>Testing Our Code:</em></p>
<ul>
<li>Contents of the text file:</li>
</ul>
<pre class="lang-none prettyprint-override"><code>     A fost odatã ca-n povesti,
     A fost ca niciodatã,
     Din rude mãri împãrãtesti,
     O prea frumoasã fatã.
</code></pre>
<ul>
<li>Print statements for testing purposes:</li>
</ul>
<pre class="lang-python prettyprint-override"><code>    print my_list  # Print the list.

    # Print each line in the list.
    for line in my_list:
        print line

    # Print the fourth element in this list.
    print my_list[3]
</code></pre>
<ul>
<li>Output (different-looking because of unicode characters):</li>
</ul>
<pre class="lang-none prettyprint-override"><code>     ['A fost odat\xc3\xa3 ca-n povesti,', 'A fost ca niciodat\xc3\xa3,',
     'Din rude m\xc3\xa3ri \xc3\xaemp\xc3\xa3r\xc3\xa3testi,', 'O prea
     frumoas\xc3\xa3 fat\xc3\xa3.']

     A fost odatã ca-n povesti, A fost ca niciodatã, Din rude mãri
     împãrãtesti, O prea frumoasã fatã.

     O prea frumoasã fatã.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To read a file into a list you need to do three things:</p>
<ul>
<li>Open the file</li>
<li>Read the file</li>
<li>Store the contents as list</li>
</ul>
<p>Fortunately Python makes it very easy to do these things so the shortest way to read a file into a list is:</p>
<pre><code>lst = list(open(filename))
</code></pre>
<p>However I'll add some more explanation.</p>
<h2>Opening the file</h2>
<p>I assume that you want to open a specific file and you don't deal directly with a file-handle (or a file-like-handle). The most commonly used function to open a file in Python is <a href="https://docs.python.org/library/functions.html#open" rel="noreferrer"><code>open</code></a>, it takes one mandatory argument and two optional ones in Python 2.7:</p>
<ul>
<li>Filename</li>
<li>Mode</li>
<li>Buffering (I'll ignore this argument in this answer)</li>
</ul>
<p>The filename should be a string that represents the <em>path to the file</em>. For example:</p>
<pre><code>open('afile')   # opens the file named afile in the current working directory
open('adir/afile')            # relative path (relative to the current working directory)
open('C:/users/aname/afile')  # absolute path (windows)
open('/usr/local/afile')      # absolute path (linux)
</code></pre>
<p>Note that the file extension needs to be specified. This is especially important for Windows users because file extensions like <code>.txt</code> or <code>.doc</code>, etc. are hidden <em>by default</em> when viewed in the explorer.</p>
<p>The second argument is the <code>mode</code>, it's <code>r</code> by default which means "read-only". That's exactly what you need in your case. </p>
<p>But in case you actually want to create a file and/or write to a file you'll need a different argument here. <a href="https://stackoverflow.com/a/30566011/5393381">There is an excellent answer if you want an overview</a>.</p>
<p>For reading a file you can omit the <code>mode</code> or pass it in explicitly:</p>
<pre><code>open(filename)
open(filename, 'r')
</code></pre>
<p>Both will open the file in read-only mode. In case you want to read in a binary file on Windows you need to use the mode <code>rb</code>:</p>
<pre><code>open(filename, 'rb')
</code></pre>
<p>On other platforms the <code>'b'</code> (binary mode) is simply ignored.</p>
<hr/>
<p>Now that I've shown how to <code>open</code> the file, let's talk about the fact that you always need to <code>close</code> it again. Otherwise it will keep an open file-handle to the file until the process exits (or Python garbages the file-handle). </p>
<p>While you could use:</p>
<pre><code>f = open(filename)
# ... do stuff with f
f.close()
</code></pre>
<p>That will fail to close the file when something between <code>open</code> and <code>close</code> throws an exception. You could avoid that by using a <code>try</code> and <code>finally</code>:</p>
<pre><code>f = open(filename)
# nothing in between!
try:
    # do stuff with f
finally:
    f.close()
</code></pre>
<p>However Python provides context managers that have a prettier syntax (but for <code>open</code> it's almost identical to the <code>try</code> and <code>finally</code> above):</p>
<pre><code>with open(filename) as f:
    # do stuff with f
# The file is always closed after the with-scope ends.
</code></pre>
<p>The last approach is the <strong>recommended</strong> approach to open a file in Python!</p>
<h2>Reading the file</h2>
<p>Okay, you've opened the file, now how to read it? </p>
<p>The <code>open</code> function returns a <a href="https://docs.python.org/2/library/stdtypes.html#bltin-file-objects" rel="noreferrer"><code>file</code></a> object and it supports Pythons iteration protocol. Each iteration will give you a line:</p>
<pre><code>with open(filename) as f:
    for line in f:
        print(line)
</code></pre>
<p>This will print each line of the file. Note however that each line will contain a newline character <code>\n</code> at the end (you might want to check if your Python is built with <a href="https://docs.python.org/2/glossary.html#term-universal-newlines" rel="noreferrer">universal newlines support</a> - otherwise you could also have <code>\r\n</code> on Windows or <code>\r</code> on Mac as newlines). If you don't want that you can could simply remove the last character (or the last two characters on Windows):</p>
<pre><code>with open(filename) as f:
    for line in f:
        print(line[:-1])
</code></pre>
<p>But the last line doesn't necessarily has a trailing newline, so one shouldn't use that. One could check if it ends with a trailing newline and if so remove it:</p>
<pre><code>with open(filename) as f:
    for line in f:
        if line.endswith('\n'):
            line = line[:-1]
        print(line)
</code></pre>
<p>But you could simply remove all whitespaces (including the <code>\n</code> character) from the <em>end of the string</em>, this will also remove all other <em>trailing</em> whitespaces so you have to be careful if these are important:</p>
<pre><code>with open(filename) as f:
    for line in f:
        print(f.rstrip())
</code></pre>
<p>However if the lines end with <code>\r\n</code> (Windows "newlines") that <code>.rstrip()</code> will also take care of the <code>\r</code>!</p>
<h2>Store the contents as list</h2>
<p>Now that you know how to open the file and read it, it's time to store the contents in a list. The simplest option would be to use the <a href="https://docs.python.org/2/library/functions.html#func-list" rel="noreferrer"><code>list</code></a> function:</p>
<pre><code>with open(filename) as f:
    lst = list(f)
</code></pre>
<p>In case you want to strip the trailing newlines you could use a list comprehension instead:</p>
<pre><code>with open(filename) as f:
    lst = [line.rstrip() for line in f]
</code></pre>
<p>Or even simpler: The <a href="https://docs.python.org/2/library/stdtypes.html#file.readlines" rel="noreferrer"><code>.readlines()</code></a> method of the <code>file</code> object by default returns a <code>list</code> of the lines:</p>
<pre><code>with open(filename) as f:
    lst = f.readlines()
</code></pre>
<p>This will also include the trailing newline characters, if you don't want them I would recommend the <code>[line.rstrip() for line in f]</code> approach because it avoids keeping two lists containing all the lines in memory.</p>
<p>There's an additional option to get the desired output, however it's rather "suboptimal": <a href="https://docs.python.org/2/library/stdtypes.html#file.read" rel="noreferrer"><code>read</code></a> the complete file in a string and then split on newlines:</p>
<pre><code>with open(filename) as f:
    lst = f.read().split('\n')
</code></pre>
<p>or:</p>
<pre><code>with open(filename) as f:
    lst = f.read().splitlines()
</code></pre>
<p>These take care of the trailing newlines automatically because the <code>split</code> character isn't included. However they are not ideal because you keep the file as string and as a list of lines in memory!</p>
<h2>Summary</h2>
<ul>
<li>Use <code>with open(...) as f</code> when opening files because you don't need to take care of closing the file yourself and it closes the file even if some exception happens.</li>
<li><code>file</code> objects support the iteration protocol so reading a file line-by-line is as simple as <code>for line in the_file_object:</code>.</li>
<li>Always browse the documentation for the available functions/classes. Most of the time there's a perfect match for the task or at least one or two good ones. The obvious choice in this case would be <code>readlines()</code> but if you want to process the lines before storing them in the list I would recommend a simple list-comprehension.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I'd do it like this.</p>
<pre><code>lines = []
with open("myfile.txt") as f:
    for line in f:
        lines.append(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one more option by using list comprehensions on files;</p>
<pre><code>lines = [line.rstrip() for line in open('file.txt')]
</code></pre>
<p>This should be more efficient way as the most of the work is done inside the Python interpreter.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html" rel="noreferrer"><code>numpy.genfromtxt</code></a>, for example:</p>
<pre><code>import numpy as np
data = np.genfromtxt("yourfile.dat",delimiter="\n")
</code></pre>
<p>This will make <code>data</code> a NumPy array with as many rows as are in your file.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you'd like to read a file from the command line or from stdin, you can also use the <code>fileinput</code> module:</p>
<pre><code># reader.py
import fileinput

content = []
for line in fileinput.input():
    content.append(line.strip())

fileinput.close()
</code></pre>
<p>Pass files to it like so:</p>
<pre><code>$ python reader.py textfile.txt 
</code></pre>
<p>Read more here: <a href="http://docs.python.org/2/library/fileinput.html">http://docs.python.org/2/library/fileinput.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>The simplest way to do it</strong></p>
<p>A simple way is to:</p>
<ol>
<li>Read the whole file as a string</li>
<li>Split the string line by line</li>
</ol>
<p>In one line, that would give:</p>
<pre><code>lines = open('C:/path/file.txt').read().splitlines()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Read and write text files with Python 2 and Python 3; it works with Unicode</h1>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Define data
lines = ['     A first string  ',
         'A Unicode sample: €',
         'German: äöüß']

# Write text file
with open('file.txt', 'w') as fp:
    fp.write('\n'.join(lines))

# Read text file
with open('file.txt', 'r') as fp:
    read_lines = fp.readlines()
    read_lines = [line.rstrip('\n') for line in read_lines]

print(lines == read_lines)
</code></pre>
<p>Things to notice:</p>
<ul>
<li><code>with</code> is a so-called <a href="https://docs.python.org/2/reference/compound_stmts.html#with" rel="noreferrer">context manager</a>. It makes sure that the opened file is closed again.</li>
<li>All solutions here which simply make <code>.strip()</code> or <code>.rstrip()</code> will fail to reproduce the <code>lines</code> as they also strip the white space.</li>
</ul>
<h2>Common file endings</h2>
<p><code>.txt</code></p>
<h2>More advanced file writing / reading</h2>
<ul>
<li>CSV: Super simple format (<a href="https://stackoverflow.com/a/41585079/562769">read &amp; write</a>)</li>
<li>JSON: Nice for writing human-readable data; VERY commonly used (<a href="https://stackoverflow.com/a/37795053/562769">read &amp; write</a>)</li>
<li>YAML: YAML is a superset of JSON, but easier to read (<a href="https://stackoverflow.com/a/42054860/562769">read &amp; write</a>, <a href="https://stackoverflow.com/a/1729545/562769">comparison of JSON and YAML</a>)</li>
<li>pickle: A Python serialization format (<a href="https://stackoverflow.com/a/33245595/562769">read &amp; write</a>)</li>
<li><a href="http://msgpack.org/" rel="noreferrer">MessagePack</a> (<a href="https://pypi.python.org/pypi/msgpack-python" rel="noreferrer">Python package</a>): More compact representation (<a href="https://stackoverflow.com/q/43442194/562769">read &amp; write</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format" rel="noreferrer">HDF5</a> (<a href="http://docs.h5py.org/en/latest/quick.html" rel="noreferrer">Python package</a>): Nice for matrices (<a href="https://stackoverflow.com/a/41586571/562769">read &amp; write</a>)</li>
<li>XML: exists too *sigh* (<a href="https://stackoverflow.com/a/1912483/562769">read</a> &amp; <a href="https://stackoverflow.com/a/3605831/562769">write</a>)</li>
</ul>
<p>For your application, the following might be important:</p>
<ul>
<li>Support by other programming languages</li>
<li>Reading / writing performance</li>
<li>Compactness (file size)</li>
</ul>
<p>See also: <em><a href="https://en.wikipedia.org/wiki/Comparison_of_data_serialization_formats" rel="noreferrer">Comparison of data serialization formats</a></em></p>
<p>In case you are rather looking for a way to make configuration files, you might want to read my short article <em><a href="https://martin-thoma.com/configuration-files-in-python/" rel="noreferrer">Configuration files in Python</a></em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Introduced in Python 3.4, <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> has a really convenient method for reading in text from files, as follows:</p>
<pre><code>from pathlib import Path
p = Path('my_text_file')
lines = p.read_text().splitlines()
</code></pre>
<p>(The <code>splitlines</code> call is what turns it from a string containing the whole contents of the file to a list of lines in the file).</p>
<p><code>pathlib</code> has a lot of handy conveniences in it. <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text" rel="noreferrer"><code>read_text</code></a> is nice and concise, and you don't have to worry about opening and closing the file. If all you need to do with the file is read it all in in one go, it's a good choice.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>f = open("your_file.txt",'r')
out = f.readlines() # will append in the list out
</code></pre>
<p>Now variable out is a list (array) of what you want. You could either do:</p>
<pre><code>for line in out:
    print line
</code></pre>
<p>or</p>
<pre><code>for line in f:
    print line
</code></pre>
<p>you'll get the same results.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use the splitlines() functions. Here is an example.</p>
<pre><code>inp = "file.txt"
data = open(inp)
dat = data.read()
lst = dat.splitlines()
print lst
# print(lst) # for python 3
</code></pre>
<p>In the output you will have the list of lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>A real easy way:</p>
<pre><code>with open(file) as g:
    stuff = g.readlines()
</code></pre>
<p>If you want to make it a fully-fledged program, type this in:</p>
<pre><code>file = raw_input ("Enter EXACT file name: ")
with open(file) as g:
    stuff = g.readlines()
print (stuff)
exit = raw_input("Press enter when you are done.")
</code></pre>
<p>For some reason, it doesn't read .py files properly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just open your file for reading using:</p>
<pre><code>file1 = open("filename","r")
# And for reading use
lines = file1.readlines()
file1.close()
</code></pre>
<p>The list <code>lines</code> will contain all your lines as individual elements, and you can call a specific element using <code>lines["linenumber-1"]</code> as Python starts its counting from 0.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to are faced with a <strong>very large / huge file</strong> and want to <strong>read faster</strong> (imagine you are in a Topcoder/Hackerrank coding competition), you might read a considerably bigger chunk of lines into a memory buffer at one time, rather than just iterate line by line at file level.</p>
<pre class="lang-python prettyprint-override"><code>buffersize = 2**16
with open(path) as f: 
    while True:
        lines_buffer = f.readlines(buffersize)
        if not lines_buffer:
            break
        for line in lines_buffer:
            process(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To my knowledge Python doesn't have a native array data structure. But it does support the list data structure which is much simpler to use than an array.</p>
<pre><code>array = [] #declaring a list with name '**array**'
with open(PATH,'r') as reader :
    for line in reader :
        array.append(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use this:</p>
<pre><code>import pandas as pd
data = pd.read_csv(filename) # You can also add parameters such as header, sep, etc.
array = data.values
</code></pre>
<p><code>data</code> is a dataframe type, and uses values to get ndarray. You can also get a list by using <code>array.tolist()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily do it by the following piece of code:</p>
<pre><code>lines = open(filePath).readlines()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>The easiest ways to do that with some additional benefits are:</strong></p>
<pre><code>lines = list(open('filename'))
</code></pre>
<p>or</p>
<pre><code>lines = tuple(open('filename'))
</code></pre>
<p>or</p>
<pre><code>lines = set(open('filename'))
</code></pre>
<p>In the case with <code>set</code>, we must be remembered that we don't have the line order preserved and get rid of the duplicated lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also use the loadtxt command in NumPy. This checks for fewer conditions than genfromtxt, so it may be faster.</p>
<pre><code>import numpy
data = numpy.loadtxt(filename, delimiter="\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check out this short snippet</p>
<pre><code>fileOb=open("filename.txt","r")
data=fileOb.readlines() #returns a array of lines.
</code></pre>
<p>or </p>
<pre><code>fileOb=open("filename.txt","r")
data=list(fileOb) #returns a array of lines.
</code></pre>
<p>refer <a href="https://docs.python.org/3.3/tutorial/inputoutput.html" rel="nofollow noreferrer">docs</a> for reference</p>
</div>
<div class="post-text" itemprop="text">
<h2>Outline and Summary</h2>
<p>With a <code>filename</code>, handling the file from a <code>Path(filename)</code> object, or directly with <code>open(filename) as f</code>, do one of the following:</p>
<ul>
<li><code>list(fileinput.input(filename))</code></li>
<li>using <code>with path.open() as f</code>, call <code>f.readlines()</code> </li>
<li><code>list(f)</code></li>
<li><code>path.read_text().splitlines()</code></li>
<li><code>path.read_text().splitlines(keepends=True)</code></li>
<li>iterate over <code>fileinput.input</code> or <code>f</code> and <code>list.append</code> each line one at a time</li>
<li>pass <code>f</code> to a bound <code>list.extend</code> method</li>
<li>use <code>f</code> in a list comprehension</li>
</ul>
<p>I explain the use-case for each below.</p>
<blockquote>
<h2>In Python, how do I read a file line-by-line?</h2>
</blockquote>
<p>This is an excellent question. First, let's create some sample data:</p>
<pre><code>from pathlib import Path
Path('filename').write_text('foo\nbar\nbaz')
</code></pre>
<p>File objects are lazy iterators, so just iterate over it.</p>
<pre><code>filename = 'filename'
with open(filename) as f:
    for line in f:
        line # do something with the line
</code></pre>
<p>Alternatively, if you have multiple files, use <code>fileinput.input</code>, another lazy iterator. With just one file:</p>
<pre><code>import fileinput

for line in fileinput.input(filename): 
    line # process the line
</code></pre>
<p>or for multiple files, pass it a list of filenames:</p>
<pre><code>for line in fileinput.input([filename]*2): 
    line # process the line
</code></pre>
<p>Again, <code>f</code> and <code>fileinput.input</code> above both are/return lazy iterators.
You can only use an iterator one time, so to provide functional code while avoiding verbosity I'll use the slightly more terse <code>fileinput.input(filename)</code> where apropos from here.</p>
<blockquote>
<h2>In Python, how do I read a file line-by-line <strong>into a list?</strong></h2>
</blockquote>
<p>Ah but you want it in a list for some reason? I'd avoid that if possible. But if you insist... just pass the result of <code>fileinput.input(filename)</code> to <code>list</code>:</p>
<pre><code>list(fileinput.input(filename))
</code></pre>
<p>Another direct answer is to call <code>f.readlines</code>, which returns the contents of the file (up to an optional <code>hint</code> number of characters, so you <em>could</em> break this up into multiple lists that way). </p>
<p>You can get to this file object two ways. One way is to pass the filename to the <code>open</code> builtin:</p>
<pre><code>filename = 'filename'

with open(filename) as f:
    f.readlines()
</code></pre>
<p>or using the new Path object from the <code>pathlib</code> module (which I have become quite fond of, and will use from here on):</p>
<pre><code>from pathlib import Path

path = Path(filename)

with path.open() as f:
    f.readlines()
</code></pre>
<p><code>list</code> will also consume the file iterator and return a list - a quite direct method as well:</p>
<pre><code>with path.open() as f:
    list(f)
</code></pre>
<p>If you don't mind reading the entire text into memory as a single string before splitting it, you can do this as a one-liner with the <code>Path</code> object and the <code>splitlines()</code> string method. By default, <code>splitlines</code> removes the newlines:</p>
<pre><code>path.read_text().splitlines()
</code></pre>
<p>If you want to keep the newlines, pass <code>keepends=True</code>:</p>
<pre><code>path.read_text().splitlines(keepends=True)
</code></pre>
<blockquote>
<p>I want to read the file line by line and append each line to the end of the list.</p>
</blockquote>
<p>Now this is a bit silly to ask for, given that we've demonstrated the end result easily with several methods. But you might need to filter or operate on the lines as you make your list, so let's humor this request.</p>
<p>Using <code>list.append</code> would allow you to filter or operate on each line before you append it:</p>
<pre><code>line_list = []
for line in fileinput.input(filename):
    line_list.append(line)

line_list
</code></pre>
<p>Using <code>list.extend</code> would be a bit more direct, and perhaps useful if you have a preexisting list:</p>
<pre><code>line_list = []
line_list.extend(fileinput.input(filename))
line_list
</code></pre>
<p>Or more idiomatically, we could instead use a list comprehension, and map and filter inside it if desirable:</p>
<pre><code>[line for line in fileinput.input(filename)]
</code></pre>
<p>Or even more directly, to close the circle, just pass it to list to create a new list directly without operating on the lines:</p>
<pre><code>list(fileinput.input(filename))
</code></pre>
<h2>Conclusion</h2>
<p>You've seen many ways to get lines from a file into a list, but I'd recommend you avoid materializing large quantities of data into a list and instead use Python's lazy iteration to process the data if possible.</p>
<p>That is, prefer <code>fileinput.input</code> or <code>with path.open() as f</code>.</p>
</div>
<span class="comment-copy">Please accept an answer</span>
<span class="comment-copy">@user1251007 the user has one question (this one), no answers, and hasn't been on the site in 9 years. I don't see that happening.</span>
<span class="comment-copy">@JaredSmith you are right - I didn't check the profile but just judged based on the score that the user would be reasonable active ...</span>
<span class="comment-copy">@user1251007 better to be early than good :)</span>
<span class="comment-copy">@user1251007 maybe so, but the score and the user's rep all come from this post apparently.</span>
<span class="comment-copy">Don't use <code>file.readlines()</code> in a <code>for</code>-loop, a file object itself is enough: <code>lines = [line.rstrip('\n') for line in file]</code></span>
<span class="comment-copy">In the case you are working with Big Data using <code>readlines()</code> is not very efficient as it can result in <b>MemoryError</b>. In this case it is better to iterate over the file using <code>for line in f:</code> and working with each <code>line</code> variable.</span>
<span class="comment-copy">I checked the memory profile of different ways given in the answers using the procedure mentioned <a href="https://stackoverflow.com/a/45679009/3529829">here</a>. The memory usage is far better when each line is read from the file and processed, as suggested by @DevShark <a href="https://stackoverflow.com/a/35622867/3529829">here</a>. Holding all lines in a collection object is <b>not</b> a good idea if memory is a constraint or the file is large.         The execution time is similar in both the approaches.</span>
<span class="comment-copy">Also, <code>.rstrip()</code> will work slightly faster if you are stripping whitespace from the ends of lines.</span>
<span class="comment-copy">if you only want to discard the newline: <code>lines = (line.rstrip('\n') for line in open(filename))</code></span>
<span class="comment-copy">For a list it should be <code>lines = [line.rstrip('\n') for line in open(filename)]</code></span>
<span class="comment-copy">Won't the 2nd option leave the file open (since it's not guarded by a context on its own)?</span>
<span class="comment-copy">@yo' It does, but most people do not care about that in small programs. There is no harm in small programs since the leaked file object are garbage collected, but it is not a good habit to do this.</span>
<span class="comment-copy">Safer: <code>with open('filename') as f: lines = [line.rstrip('\n') for line in f]</code></span>
<span class="comment-copy">This is a direct answer to the question</span>
<span class="comment-copy">I prefer this answer since it doesn't require to load the whole file into memory (in this case it is still appended to <code>array</code> though, but there might be other circumstances). Certainly for big files this approach might mitigate problems.</span>
<span class="comment-copy">Appending to an array is slow. I cannot think of a use case where this is the best solution.</span>
<span class="comment-copy">This answer received less votes than it deserve (and do not deserve downvotes). It is much better than using <code>readlines</code>.</span>
<span class="comment-copy">@haccks is it better because it doesn't load the whole file to memory or is there more?</span>
<span class="comment-copy"><code>open</code> returns a file which can be iterated over. When you iterate over a file, you get the lines from that file. <code>tuple</code> can take an iterator and instantiate a tuple instance for you from the iterator that you give it. <code>lines</code> is a tuple created from the lines of the file.</span>
<span class="comment-copy">@MarshallFarrier Try <code>lines = open(filename).read().split('\n')</code> instead.</span>
<span class="comment-copy">does it close the file?</span>
<span class="comment-copy">@NoctisSkytower I find <code>lines = open(filename).read().splitlines()</code> a little cleaner, and I believe it also handles DOS line endings better.</span>
<span class="comment-copy">@mklement0 Assuming a file of 1000 lines, a <code>list</code> takes up about 13.22% more space than a <code>tuple</code>. Results come from <code>from sys import getsizeof as g; i = [None] * 1000; round((g(list(i)) / g(tuple(i)) - 1) * 100, 2)</code>. Creating a <code>tuple</code> takes about 4.17% more time than creating a <code>list</code> (with a 0.16% standard deviation). Results come from running <code>from timeit import timeit as t; round((t('tuple(i)', 'i = [None] * 1000') / t('list(i)', 'i = [None] * 1000') - 1) * 100, 2)</code> 30 times. My solution favors space over speed when the need for mutability is unknown.</span>
<span class="comment-copy">This was exactly what I needed - and thanks for explaining the downsides. As a beginner in Python, it's awesome to understand why a solution is the solution. Cheers!</span>
<span class="comment-copy">Think a bit more Corey. Do you really ever want your computer to read each line, without ever doing anything with these lines? Surely you can realize you always need to process them one way or another.</span>
<span class="comment-copy">You always need to do something with the lines. It can be as simple as printing the lines, or counting them. There is no value in having your process read the lines in memory, but not doing anything with it.</span>
<span class="comment-copy">You always need to do something with them. I think the point you are trying to make is that you might want to apply a function to all of them at once, rather than one by one. That is indeed the case sometimes. But it is very inefficient from a memory standpoint to do so, and prevents you from reading files if its footprint is larger than your Ram. That's why typically generic parsers operate in the way I described.</span>
<span class="comment-copy">@PierreOcinom that is correct. Given that the file is opened in read only mode, you couldn't modify the original file with the code above. To open a file for both reading and writing, use <code>open('file_path', 'r+')</code></span>
<span class="comment-copy">It might be fine in some cases, but this doesn't close the file, even after the loop has completed - <a href="http://stackoverflow.com/a/1832589/232593">stackoverflow.com/a/1832589/232593</a></span>
<span class="comment-copy">The <code>with</code> block closes the file automatically. No need for the final <code>fp.close()</code> line in that last example. See: <a href="https://repl.it/IMeA/0" rel="nofollow noreferrer">repl.it/IMeA/0</a></span>
<span class="comment-copy">Always care about closing the file!  Be a good resource citizen!</span>
<span class="comment-copy">All the work you're doing here is done by the Python <code>readlines()</code> method.</span>
<span class="comment-copy">At least for me with Python 3.7.0 it was <code>fp.readlines()</code> instead of <code>fp.read().readlines()</code>.</span>
<span class="comment-copy">is the <code>encoding="utf-8"</code> required?</span>
<span class="comment-copy">@Mausy5043 no, but when you read a text file, you can have some strange character (expecially in italian)</span>
<span class="comment-copy"><code>read().splitlines()</code> is provided to you by Python: it's simply <code>readlines()</code> (which is probably faster, as it is less wasteful).</span>
<span class="comment-copy">f.readlines() does the same.  no need to append to an empty list.</span>
<span class="comment-copy">You are right. This provides insight into a solution if you want to do something while you are reading in the lines. Like some strip/regex transformation.</span>
<span class="comment-copy">An answer like this has already existed for 3 years before you posted this.</span>
<span class="comment-copy">You Sr. are correct. Unsure why this is front page. <a href="https://stackoverflow.com/questions/3277503/in-python-how-do-i-read-a-file-line-by-line-into-a-list/3277512#3277512" title="in python how do i read a file line by line into a list">stackoverflow.com/questions/3277503/…</a></span>
<span class="comment-copy">Excellent answer!</span>
<span class="comment-copy">We already have 2 answers like this, posted 3 and 6 years before yours...</span>
<span class="comment-copy"><code>rstrip()</code> potentially strips <i>all</i> trailing whitespace, not just the <code>\n</code>; use <code>.rstrip('\n')</code>.</span>
<span class="comment-copy">The Pythonic way would be: <code>with open("filename") as f: lines = f.readlines()</code>.</span>
<span class="comment-copy">what does process(line) do? I get an error that there is not such variable defined. I guess something needs importing and I tried to import multiprocessing.Process, but that's not it I guess. Could you please elaborate? Thanks</span>
<span class="comment-copy"><code>process(line)</code> is a function that you need to implement to process the data. for example, instead of that line, if you use <code>print(line)</code>, it will print each line from the lines_buffer.</span>
<span class="comment-copy">f.readlines(buffersize) returns an immutable buffer. if you want to directly read into your buffer you need to use readinto() function. I will be much faster.</span>
<span class="comment-copy">python does have an array (see the standard library's <code>array</code> module), but the question asked for a list.</span>
<span class="comment-copy">You should use a <code>with</code> statement though.</span>
<span class="comment-copy">always close opened files or use <code>with</code> construct to do that for you</span>
