<div class="post-text" itemprop="text">
<p>How do I persist changes made within the same object inheriting from <code>TestCase</code> in unitttest?</p>
<pre><code>from unittest import TestCase, main as unittest_main


class TestSimpleFoo(TestCase):
    foo = 'bar'

    def setUp(self):
        pass

    def test_a(self):
        self.assertEqual(self.foo, 'bar')
        self.foo = 'can'

    def test_f(self):
        self.assertEqual(self.foo, 'can')


if __name__ == '__main__':
    unittest_main()
</code></pre>
<p>I.e.: I want those two tests above to pass</p>
</div>
<div class="post-text" itemprop="text">
<p>As some comments have echoed, structuring your tests in this manner is probably a design flaw in the tests themselves and you should consider restructuring them. However, if you want to do this and rely on the fact that the test runner you are using executes them in an alphabetical (seemingly) order then I suggest the following.</p>
<p>Similar to what @Matthias was saying but I would do one thing differently for the cases where you may decide to inherit from the class at a later date.</p>
<pre><code>from unittest import TestCase, main as unittest_main


class TestSimpleFoo(TestCase):
    foo = 'bar'

    def setUp(self):
        pass

    def test_a(self):
        self.assertEqual(self.__class__.foo, 'bar')
        self.__class__.foo = 'can'

    def test_f(self):
        self.assertEqual(self.__class__.foo, 'can')


if __name__ == '__main__':
    unittest_main()
</code></pre>
<p>The difference between this answer and @Matthias's answer you accepted is the explicit declaration of the class versus the lookup of said class reference. </p>
<pre><code>TestSimpleFoo vs self.__class__
</code></pre>
<p>I prefer the dynamicness so I can inherit the tests later and run both test classes back to back and not have any cross over between the two. Because if you would choose to inherit from this class, explicitly naming the class reference would cause both test classes to run against that reference rather than their own respective classes. </p>
</div>
<div class="post-text" itemprop="text">
<p>I like your own answer for the simplicity of it, but if you want to keep distinct unit tests:</p>
<p>Apparently unittest runs separate tests with fresh instances of the TestCase. Well, just bind the objects to be persisted to something else but self. For example:</p>
<pre><code>from unittest import TestCase, main as unittest_main


class TestSimpleFoo(TestCase):

    def setUp(self):
        pass

    def test_a(self):
        TestSimpleFoo.foo = 'can'

    def test_f(self):
        self.assertEqual(TestSimpleFoo.foo, 'can')


if __name__ == '__main__':
    unittest_main()
</code></pre>
<p>You might be interesed in setUpClass and tearDownClass too:
<a href="https://docs.python.org/3/library/unittest.html#setupclass-and-teardownclass">https://docs.python.org/3/library/unittest.html#setupclass-and-teardownclass</a></p>
<p>Also take care about the execution order of your unit tests:
<a href="https://docs.python.org/2/library/unittest.html#unittest.TestLoader.sortTestMethodsUsing">https://docs.python.org/2/library/unittest.html#unittest.TestLoader.sortTestMethodsUsing</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Couldn't figure it out; so ended up hacking it out with multiple non <code>test_</code> prefixed functions:</p>
<pre><code>def test_password_credentials_grant(self):
    for user in self.user_mocks:
        self.register(user)
        self.login(user)
        self.access_token(user, self.assertEqual)  # Ensures access_token is generated+valid
        self.logout(user)
        self.access_token(user, self.assertNotEqual)  # Ensures access_token is now invalid
        self.unregister(user)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Besides what others said, the data share among test methods shouldn't be implemented this way, use setup() is recommended. </p>
<p>The test method itself should be isolated. </p>
</div>
<span class="comment-copy">Unit tests should be independent. [In any case, <code>self.foo</code> refers to an <i>instance variable</i> while <code>foo = 'bar'</code> (where it is located) assigns a <i>class variable</i>.]</span>
<span class="comment-copy">I'm testing OAuth2; <code>login</code> sets an <code>access_token</code> which I require for the next few tests.</span>
<span class="comment-copy">Can't you create a <i>different</i> test-class with the appropriate <code>setUp</code> to mock the appropriate access_token? (Make the setUp call the OAuth as required; more of integration testing at this point .. but take it that the setUp <i>cannot be wrong</i>, or the other TestCase would have failed.)</span>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/3843171/unit-testing-with-dependencies-between-tests" title="unit testing with dependencies between tests">stackoverflow.com/questions/3843171/â€¦</a> - not really any answers, but some suggestions and links.</span>
<span class="comment-copy">Consider looking into <a href="https://stackoverflow.com/q/8389639/3357935"><code>setUpClass()</code></a>. It runs a single time when your class is called. You can use it to setup variables needed for multiple tests.</span>
<span class="comment-copy">Yeah, I've been using the whole <code>def test_0</code> syntax to overcome the sorting issues. Sure, will use <code>__class__</code>; which is also more concise =). Yes, I could restructure my tests; but would rather a cleaner test interface.</span>
<span class="comment-copy">Thanks, I am already using <code>@tearDownClass</code> for my <code>unregister</code> function. Interesting approach you're suggestion: will give it a go.</span>
<span class="comment-copy">You're not supposed to do this. What if your test runner decides to run tests in separate processes (for e.g. distributing load to multiple computers) ? There are certain assumptions that test runners make about unit test and you should not violate them. As Ned says, A T's answer is the right way to do it.</span>
<span class="comment-copy">I dont like this solution, it should not be necessary to structure your tests this way. I think the most viable solution is to restructure/design your tests, so they conform with the conseptional ideas of python unit testing.</span>
<span class="comment-copy">@brunsgaard I can relate. It's a workaround and as such not very beautiful. The underlying problem is that python unit testing doesn't support the concept of test sequences. Test sequences - of course - are only the second best solution to indepedent unit tests, but in the face of the trade-off between test run time and test maintainability a valid solution.</span>
<span class="comment-copy">@Matthias, You may take a look at <a href="http://pytest.org" rel="nofollow noreferrer">pytest.org</a>, I don't know it, but people are talking about it here at EuroPython. Maybe it will do something good for you :) Talk from yesterday <a href="https://www.youtube.com/watch?v=LdVJj65ikRY" rel="nofollow noreferrer">youtube.com/watch?v=LdVJj65ikRY</a></span>
<span class="comment-copy">This is the right way to do it.</span>
