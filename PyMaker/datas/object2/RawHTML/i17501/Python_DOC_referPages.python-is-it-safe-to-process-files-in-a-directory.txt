<div class="post-text" itemprop="text">
<p>(Python 3)</p>
<p>I have a process which drops inbound files into a directory (not written in Python).</p>
<p>A separate Python application periodically processes all files in the directory as follow:</p>
<pre><code>def getfilestobeprocessed(path):
    filestobeprocessed = []
    for dirpath, dirnames, filenames in os.walk(path):
        for filename in filenames:
            filestobeprocessed.append({ "filename": filename, "dirpath": dirpath })
    return filestobeprocessed
</code></pre>
<p>My concern is, what if the inbound process is half way through writing a large file.  What will my Python script do? Will it start to process the file when really it should only be processing files that have finished being written by the inbound processor? Should I be trying to detect whether or not files are open before I process them?</p>
<p>I would have considered using Pyinotify except that this guy criticises it <a href="http://www.serpentine.com/blog/2008/01/04/why-you-should-not-use-pyinotify/" rel="nofollow">http://www.serpentine.com/blog/2008/01/04/why-you-should-not-use-pyinotify/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>When you open (or rename, delete, ...) the file as part of your processing it, you will get a "file in use" error. On windows it is code 32. If and when you see this error, just don't process that file - it will be taken care of on the next go around.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use lock files. </p>
<p>So. When it's copying it use filename.lock and then on completing the copy rename it to the correct extension.</p>
<p>Then put a if statement like</p>
<pre><code>def getfilestobeprocessed(path):
    filestobeprocessed = []
    for dirpath, dirnames, filenames in os.walk(path):
        for filename in filenames:
            if !filename.endswith(.lock):
                filestobeprocessed.append({ "filename": filename, "dirpath": dirpath })
    return filestobeprocessed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps the OS can tell you whether another process has the file.</p>
<p>A pretty-good solution would be to decide that after, say, 60 seconds, if the file has not changed then whatever was writing to it is no longer doing so.  Have a look at <a href="http://docs.python.org/3/library/os.html#os.stat" rel="nofollow">http://docs.python.org/3/library/os.html#os.stat</a>.</p>
</div>
<span class="comment-copy">Unfortunately I have no control over the inbound processor - it just drops files into the target directory.</span>
