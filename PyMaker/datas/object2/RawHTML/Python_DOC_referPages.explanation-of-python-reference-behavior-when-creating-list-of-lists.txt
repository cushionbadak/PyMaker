<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly">List of lists changes reflected across sublists unexpectedly</a>
<span class="question-originals-answer-count">
                    12 answers
                </span>
</li>
</ul>
</div>
<p>When creating a new nested list the following way:</p>
<pre><code>test_list = [[""]]*5
</code></pre>
<p>unexpected behavior happens, appending to an index the following modifications happens:</p>
<pre><code>test_list[1].append(2)
[['', 2], ['', 2], ['', 2], ['', 2], ['', 2]]
</code></pre>
<p>when doing the following it works as I would expect:</p>
<pre><code>test_list[1] = test_list[1] + [0]
[[''], ['', 0], [''], [''], ['']]
</code></pre>
<p>but when using the += operator the same odd thing happens</p>
<pre><code>test_list[1] += [0]
[['', 0], ['', 0], ['', 0], ['', 0], ['', 0]]
</code></pre>
<p>when the list is defined as following: <code>[[""] for i in range(len(5))]</code> all the examples return the expected output. </p>
<p>What is going on? Is it some reference thing I am not understanding?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are creating a list that has five elements which point to the same list.</p>
<p>When you call <code>test_list[1].append(2)</code>, it appends number 2 to the list, which appends it to all lists.</p>
<p>When you call <code>test_list[1] = test_list[1] + [0]</code>, a new instance of a list is created, and is assigned to <code>test_list[1]</code>. Now in index 1 you have a different list than all other 4.</p>
<p>Here, <code>test_list[1] += [0]</code>, <code>+=</code> is translated to <code>test_list[1].append(0)</code>, which appends zero to all of the lists.</p>
<p>An example to understand <code>test_list[1] = test_list[1] + [0]</code>:</p>
<pre><code>lst = [0]
print(lst) 
# output: [0]

lst += [1]
print(lst) 
# output: [0, 1]

lst.append(2)
print(lst) 
# output: [0, 1, 2]

lst2 = lst + [3]
print(lst) 
# output: [0, 1, 2]
# the lst did not change!

print(lst2) 
# output: [0, 1, 2, 3]
# a new instance of a list which is not lst
</code></pre>
<p>Now, let's see the object ids of the elements: </p>
<pre><code>test_list = [[""]]*5
print(test_list)
# output: [[''], [''], [''], [''], ['']]

for i in range(5):
    object_id = id(test_list[i])
    print(object_id)
# output: 4405988168
# output: 4405988168
# output: 4405988168
# output: 4405988168
# output: 4405988168

test_list[1] = test_list[1] + [0]
print(test_list)
# output: [[''], ['', 0], [''], [''], ['']]

for i in range(5):
    object_id = id(test_list[i])
    print(object_id)
# output: 4405988168
# output: 4417503368     !!!!
# output: 4405988168
# output: 4405988168
# output: 4405988168
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By using <code>test_list = [[""]] * 5</code> you are creating 5 references to the same list. This means there is <strong>ONLY ONE ROW</strong> in the memory. </p>
<p>When you modify a row, if affects the row in memory, and since all other "rows" refer to it, they will simply use the list in memory which is up-to-date.</p>
<p><strong>This however creats a list of 5 lists in memory:</strong></p>
<pre><code>test_list = [[""] for i in range(len(5))]
</code></pre>
<p>===========================================================================</p>
<p>You could find an <a href="https://github.com/satwikkansal/wtfpython#-a-tic-tac-toe-where-x-wins-in-the-first-attempt" rel="nofollow noreferrer">example and explanation in wtfpython</a>:</p>
<pre><code># Let's initialize a row
row = [""]*3 #row i['', '', '']
# Let's make a board
board = [row]*3
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; board
[['', '', ''], ['', '', ''], ['', '', '']]
&gt;&gt;&gt; board[0]
['', '', '']
&gt;&gt;&gt; board[0][0]
''
&gt;&gt;&gt; board[0][0] = "X"
&gt;&gt;&gt; board
[['X', '', ''], ['X', '', ''], ['X', '', '']]
</code></pre>
<p><strong>Explanation:</strong></p>
<p>When we initialize <code>row</code> variable, this visualization explains what happens in the memory.</p>
<p><a href="https://i.stack.imgur.com/p0mv1.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/p0mv1.png"/></a></p>
<p>And when the <code>board</code> is initialized by multiplying the <code>row</code>, this is what happens inside the memory (each of the elements <code>board[0]</code>, <code>board[1]</code> and <code>board[2]</code> is a reference to the same list referred by <code>row</code>)</p>
<p><a href="https://i.stack.imgur.com/DNs8D.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/DNs8D.png"/></a></p>
<p>We can avoid this scenario here by not using <code>row</code> variable to generate <code>board</code>. (Asked in <a href="https://github.com/satwikkansal/wtfpython/issues/68" rel="nofollow noreferrer">this</a> issue).</p>
<pre><code>&gt;&gt;&gt; board = [['']*3 for _ in range(3)]
&gt;&gt;&gt; board[0][0] = "X"
&gt;&gt;&gt; board
[['X', '', ''], ['', '', ''], ['', '', '']]
</code></pre>
</div>
<span class="comment-copy">That's what I don't like most in languages like Java, Python, etc - They're using references implicitly. Of course, once you know that, you can handle it. But C++ makes it obvious - which I first didn't like, but now really appreciate.</span>
<span class="comment-copy">Be careful of this <i>gotcha</i> too: <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument">“Least Astonishment” and the Mutable Default Argument</a></span>
