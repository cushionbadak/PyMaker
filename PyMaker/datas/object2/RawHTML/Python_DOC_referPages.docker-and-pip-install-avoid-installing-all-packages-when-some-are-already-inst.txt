<div class="post-text" itemprop="text">
<p>I am using docker compose to build the stack of a Python project. This is a <code>dockerfile</code> snippet that handles the requirements.</p>
<pre><code># Requirements are installed here to ensure they will be cached.
COPY ./requirements /requirements
RUN pip install --no-cache-dir -r /requirements/production.txt \
    &amp;&amp; rm -rf /requirements
</code></pre>
<p>With that configuration I'm able to cache the requirements but when I modify <code>production.txt</code> (e.g. updating even a single package) Docker reinstalls everything all over again.</p>
<p>I know Docker needs to create a fresh container but is there a way to avoid reinstalling everything again but installing only what Is necessary?</p>
</div>
<div class="post-text" itemprop="text">
<p>In this case, no, there is not a way to avoid reinstalling everything in <code>production.txt</code>.</p>
<p>From <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" rel="nofollow noreferrer">official docs</a>, in the <code>Leverage build cache</code> section:</p>
<blockquote>
<p>For the ADD and COPY instructions, the contents of the file(s) in the
  image are examined and a checksum is calculated for each file. The
  last-modified and last-accessed times of the file(s) are not
  considered in these checksums. During the cache lookup, the checksum
  is compared against the checksum in the existing images. If anything
  has changed in the file(s), such as the contents and metadata, then
  the cache is invalidated</p>
</blockquote>
<p>Since you have changed <code>production.txt</code>, the cache is invalidated and docker starts from the previously valid layer and installs everything.</p>
<p>Now, if you have multiple <code>requirements.txt</code> files, you may be able to leverage some caching by doing separate steps of copy &amp; install:</p>
<pre><code>COPY requirements1.txt
RUN pip install --no-cache-dir -r requirements1.txt

COPY requirements2.txt
RUN pip install --no-cache-dir -r requirements2.txt
</code></pre>
<p>This could have other downsides, but it may allow you to partially reduce reinstall times by putting long-living packages that aren't likely to update in <code>requirements1.txt</code> and less stable ones in <code>requirements2.txt</code>. Changing <code>requirements2.txt</code> then would only cause those requirements to be reinstalled.</p>
</div>
<span class="comment-copy">Why not have the base image of the most common packages that do not need constant updates/install then specify only the that do require updates/reinstalls in requirements?</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/43017522/how-to-use-pip-to-install-pkg-from-requirement-file-without-reinstall">how to use pip to install pkg from requirement file without reinstall</a></span>
