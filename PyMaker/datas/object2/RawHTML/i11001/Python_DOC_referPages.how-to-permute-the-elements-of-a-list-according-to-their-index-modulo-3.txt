<div class="post-text" itemprop="text">
<p>I want to permute the elements of a list according to their index modulo 3, so for example the list:</p>
<pre><code>[0,1,2,3,4,5,6,7,8]
</code></pre>
<p>should be reordered into:</p>
<pre><code>[0,3,6,1,4,7,2,5,8]
</code></pre>
<p>and in general:</p>
<pre><code>[A0, A1, A2, A3, A4, A5, A6, A7, A8]
</code></pre>
<p>should become:</p>
<pre><code>[A0, A3, A6, A1, A4, A7, A2, A5, A8]
</code></pre>
<p>I have tried to use the following code:</p>
<pre><code>def arr_sort(arr, algo):
    arrtmp = arr

    arrlen = len(arr)

    if algo == 1:
        return arr

    if algo == 2:
        count = 0
        while count &lt; (arrlen - 1):
            for index, val in enumerate(arr):
                if index % 3 == 0:
                    arrtmp[count] = val
                    count += 1
            for index, val in enumerate(arr):
                if index % 3 == 1:
                    arrtmp[count] = val
                    count += 1
            for index, val in enumerate(arr):
                if index % 3 == 2:
                    arrtmp[count] = val
                    count += 1

    return arrtmp
</code></pre>
<p>It's not working properly, as <code>arr</code> gets changed throughout the while loop, and I can't really see why.
(also I know that I could do the "<code>f index % ...</code> bits in a for loop as well, but it should work anyways, right?)</p>
<p>Is there a pre-existing function that could do that instead?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are reordering on the modulo of <code>3</code>:</p>
<pre><code>l = [0,1,2,3,4,5,6,7,8]

l_sorted = sorted(l, key=lambda x: x%3)
print(l_sorted)
# [0, 3, 6, 1, 4, 7, 2, 5, 8]
</code></pre>
<p>If you're reordering on the index and not on the values, then something more detailed requiring <code>enumerate</code> would do that:</p>
<pre><code>l_sorted = [x[1] for x in sorted(enumerate(l), key=lambda x: x[0]%3)]
print(l_sorted)
# [0, 3, 6, 1, 4, 7, 2, 5, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another one based on index is </p>
<pre><code>l_sorted = sum([l[x::3] for x in range(3)],[])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let <code>a = [0,1,2,3,4,5,6,7,8]</code>.</p>
<p><code>a[::3]</code> will give you every third element: <code>[0, 3, 6]</code></p>
<p><code>a[n::3]</code> will give you every third element starting at <code>n</code>, so <code>a[1::3]</code> becomes <code>[1, 4, 7]</code> and <code>a[2::3]</code> becomes <code>[2, 5, 8]</code>.</p>
<p>Concatenate these lists with <code>+</code>: <code>a[0::3] + a[1::3] + a[2::3]</code> evaluates to <code>[0, 3, 6, 1, 4, 7, 2, 5, 8]</code>, as specified.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a generalized solution to chain a list together by grouping on some step. <a href="https://docs.python.org/3.4/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable</code></a> is used to chain the resulting groups from each step together. </p>
<pre><code>from itertools import chain

def step_chain(l, step_len):
    return chain.from_iterable(l[s::step_len] for s in range(step_len))
</code></pre>
<p><strong>Demo</strong>:</p>
<pre><code>&gt;&gt;&gt; l = [0, 1, 2, 3, 4, 5, 6, 7, 8]
&gt;&gt;&gt; list(step_chain(l, 2))
[0, 2, 4, 6, 8, 1, 3, 5, 7]
&gt;&gt;&gt; list(step_chain(l, 3))
[0, 3, 6, 1, 4, 7, 2, 5, 8]
</code></pre>
<p>If the step length does not fit nicely into the list, the additional elements are placed at the end of the new list, and if the step length is larger than the list then evidently the original list is returned. </p>
<pre><code>&gt;&gt;&gt; step_chain(l, 7)
[0, 7, 1, 8, 2, 3, 4, 5, 6]
&gt;&gt;&gt; step_chain(l, 100)
[0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<hr/>
<p><strong>Why your attempt doesn't work</strong></p>
<p>When you set <code>temp_arr = arr</code>, <code>temp_arr</code> is simply a <em>reference</em> to the same underlying (<em>mutable</em>) list as <code>arr</code>. Hence you are modifying it. You can think of <code>temp_arr</code> and <code>arr</code> as two "sticky-notes" attached to the same underlying list object, which will change accordingly. </p>
<p>If you <em>copy</em> your original list <code>arr</code> with the <a href="https://docs.python.org/3/library/functions.html#list" rel="nofollow"><code>list()</code></a> built-in </p>
<pre><code>arrtmp = list(arr)
</code></pre>
<p>your approach works for this particular case. </p>
</div>
<span class="comment-copy">Downvote: Please check at least the basic google results before asking here.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/19736234/reorder-python-list">Reorder Python List</a></span>
<span class="comment-copy"><code>random.shuffle</code> seems to do the trick. Either that, or I did not understand the question.</span>
<span class="comment-copy">Yeah, <a href="https://wiki.python.org/moin/HowTo/Sorting" rel="nofollow noreferrer"><code>list.sort()</code></a> among others. But what exactly is the sorting order for the first list?</span>
<span class="comment-copy">The desired transformation is quite clearly described, if you close voters would care to read the question, including the title.</span>
<span class="comment-copy">I think the desired ordering is based on the index, not value. I'd post that solution, but the question is apparently on hold.</span>
<span class="comment-copy">@MagnusHoff The problem is exactly what you said in your comment. You <b>think</b> that the OP meant something, but aren't sure at all. So you should <b>not</b> post an answer until the OP clarifies exactly what he's looking for.</span>
<span class="comment-copy">Exactly! Great, thanks!</span>
<span class="comment-copy">@MagnusHoff Thank you for clearing that up</span>
<span class="comment-copy">Ah thank you for the insight! I thought temp_arr = arr will create a new list, a copy. That actually explains another hickup in another part of my script :)</span>
