<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/21764770/typeerror-got-multiple-values-for-argument">TypeError: got multiple values for argument</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<pre><code>def f(a, b, *args):
    return (a, b, args)

f(a=3, b=5)  
(3, 5, ())
</code></pre>
<p>whereas:  </p>
<pre><code>f(a=3, b=5, *[1,2,3])  
TypeError: got multiple values for argument 'b'
</code></pre>
<p>Why it behaves like this?<br/>
Any particular reason?</p>
</div>
<div class="post-text" itemprop="text">
<p>In the documentation <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow">for calls:</a></p>
<blockquote>
<p>If the syntax <code>*expression</code> appears in the function call, expression must evaluate to an iterable. Elements from these iterables are treated as if they were additional positional arguments. For the call <code>f(x1, x2, *y, x3, x4)</code>, if <code>y</code> evaluates to a sequence <code>y1, ..., yM</code>, this is equivalent to a call with <code>M+4</code> positional arguments <code>x1, x2, y1, ..., yM, x3, x4</code>.</p>
</blockquote>
<p>And, this is followed by:</p>
<blockquote>
<p><em>A consequence of this is that although the <code>*expression</code> syntax may appear after explicit keyword arguments, it is processed <strong>before</strong> the keyword arguments</em> (and any <code>**expression arguments</code> â€“ see below).</p>
</blockquote>
<p>(emphasis mine)</p>
<p>So Python will first process the <code>*args</code> as positional arguments, assign a value to <code>b</code> and re-assign it with <code>b=5</code> resulting in an error for the keyword argument having multiple values. </p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is the keywords.  You are not allowed positional arguments after keyword arguments.</p>
<pre><code>f(3, 5, *[1,2,3])
</code></pre>
<p>works fine, in that it passes a <em>tuple</em> with the values 1,2,3.  The same as:</p>
<pre><code>f(3, 5, *(1,2,3))
</code></pre>
<p>Keywords must always come after positional arguments, so it is your function declaration which is incorrect:</p>
<pre><code>def f(*args, a, b):
    return (a, b, args)

print(f(a=3, b=5))
print(f(*[1,2,3], a=3, b=5))
</code></pre>
<p>Gives:</p>
<pre><code>(3, 5, ())
(3, 5, (1, 2, 3))
</code></pre>
</div>
<span class="comment-copy">Interesting, the exception gives "got multiple values for keyword argument 'a'" in python 2.7 and  "got multiple values for argument 'b'" in python 3.5</span>
<span class="comment-copy">@cdarke When using keyword arguments what happens is that python builds a <code>dict</code> to store those arguments. <code>dict</code>s don't have a reliable order. The difference in the error message reflects this: using python2.7 it happens that the hash make so that <code>a</code> is the first key to be iterated over while on python3.5 it happens to <code>b</code>. But it completely depends on how the dictionary is built etc.</span>
<span class="comment-copy">@Bakuriu:  I was aware of that, but I feel there should have been some effort to get a consistent and helpful error message, regardless of the internal implementation.  The "real" problem is using keywords before positional arguments, and that's the error that should have been detected and reported.</span>
<span class="comment-copy">@cdarke So you would like to get a <code>SyntaxError</code> whenever that syntax is used? This is inconsistent with most of python, where most errors are raised at runtime. Moreover there are cases where such calls would be fine, e.g. <code>f(a=3, b=5, *[])</code> isn't a problem. Also in the general case <code>f(**kwargs, *args)</code> is still fine if the arguments in <code>kwargs</code> and those in <code>args</code> don't overlap. Finally: python can never be sure which function is actually going to be called, so it's impossible to decide a priori if there is an overlap or not.</span>
