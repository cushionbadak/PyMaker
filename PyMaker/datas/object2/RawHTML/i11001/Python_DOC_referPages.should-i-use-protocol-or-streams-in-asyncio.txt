<div class="post-text" itemprop="text">
<p>I'm very new to <code>asyncio</code> and was wondering which API is better than the other in terms of better practice, protocol or streams?</p>
<p>To me, <code>protocol(callback based API)</code> seems easier to work with since there are already <code>connection_made</code> and <code>data_received</code> methods provided to you.  With <code>streams(coroutine based API)</code> you have to manage connections and read data yourself, but I feel like it utilizes concept of <code>coroutine</code> more, which seems a good thing to me.</p>
<p>this is how i listen to incoming data, feels awkward to me. I can also use <code>readeexactly</code> but sometimes it raises <code>IncompleteReadError</code>.</p>
<pre><code>message_body = b''
message_length = SOME_NUMBER
while True:
    while len(message_body) &lt; message_length:
        try:
            message_body_chunk = await reader.read(message_length - len(message_body))
        except Exception as e:
            self.logger.error(e)
            return
            if not message_body_chunk:
                return
            message_body += message_body_chunk
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/asyncio-stream.html#streams-coroutine-based-api" rel="nofollow">stream objects</a> are higher level and provide many useful methods:</p>
<ul>
<li>Several ways to read data: <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.read" rel="nofollow">reader.read, readline, readuntil, readexactly</a></li>
<li>Check if EOF has been reached: <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.at_eof" rel="nofollow">reader.ateof</a></li>
<li>Control write flow: <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.drain" rel="nofollow">writer.drain</a></li>
</ul>
<p>Like any abstraction, this comes at a cost: coroutine are a bit less reactive than callbacks. For instance <code>reader.read()</code> involves at least two event loop callbacks:</p>
<ul>
<li>When some data is received, a callback is triggered and <code>reader.feed_data</code> is called.</li>
<li>Then <code>feed_data</code> triggers another callback that restores the execution of <code>reader.read()</code>.</li>
</ul>
</div>
<span class="comment-copy">Also, an important point to note is that asyncio does not ensure that data_received in Protocol is always called with entire data. You may need to do your own buffer-management if the amount of data is large, or increase the buffer limit.</span>
<span class="comment-copy">@Zack This doesn't have much to do with asyncio, but rather TCP itself. TCP is <a href="https://stackoverflow.com/a/17446839/2846140">stream oriented</a>, so there is no such thing as the "entire data". It's up to the application layer to define a protocol with its own concept of packet (e.g. fixed length, ending with a specific separator, etc.). This is why the asyncio stream reader provides the readuntil and readexactly helpers.</span>
