<div class="post-text" itemprop="text">
<p>I have some python code,</p>
<pre><code> hash_object = hashlib.sha256(b'Hello World')
 hex_dig = hash_object.hexdigest()

 cipher = AES.new(hex_dig, AES.MODE_CBC, iv)
 plain = cipher.decrypt( cipher )
</code></pre>
<p>but, I have an error - ValueError: AES key must be either 16, 24, or 32 bytes long</p>
<p>But, I want 32bytes key, not 16bytes key.
I don't know why hash_val=hashfct.digest() is not 32bytes
Also, I tried "hash_val=hashfct.digest()[0:32]" but it is not work, too.</p>
<p>How can I get the 32byte long key?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should really consider a proper key derivation algorithm instead of rolling your own. <a href="https://en.wikipedia.org/wiki/PBKDF2" rel="nofollow noreferrer">PBKDF2</a> is one of the more common algorithms that should protect you from some of the usual mistakes. For example, in your case, it is very easy to brute force the password because you only have one round of hashing.</p>
<p>Here is some modified sample code from <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer">hashlib</a>:</p>
<pre><code>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; dk = hashlib.pbkdf2_hmac('sha256', b'password', b'salt', 100000)
&gt;&gt;&gt; dk[:32]
b'\x03\x94\xa2\xed\xe32\xc9\xa1&gt;\xb8.\x9b$c\x16\x04\xc3\x1d\xf9x\xb4\xe2\xf0\xfb\xd2\xc5I\x94O\x9dy\xa5'
</code></pre>
<p>You should also make sure <code>b'salt'</code> is random and different every time you generate a new key. For a cryptographically secure random function in Python, see <a href="https://stackoverflow.com/questions/20936993/how-can-i-create-a-random-number-that-is-cryptographically-secure-in-python">How can I create a random number that is cryptographically secure in python?</a></p>
<p>This is for Python 3, but should be simple enough to adjust for Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>you need to use the <code>digest</code> method</p>
<pre><code>hash_object = hashlib.sha256(b'Hello World')
hex_dig = hash_object.digest()

cipher = AES.new(hex_dig, AES.MODE_CBC, iv)
plain = cipher.decrypt( cipher )
</code></pre>
<p>I really don't know the reason but this works, because I had the same problem.</p>
</div>
<span class="comment-copy">The difference is that <code>hexdigest()</code> returns a string, while <code>digest()</code> returns raw bytes.  But still, use <code>pbkdf2_hmac</code> instead.</span>
<span class="comment-copy">Thanks for your input</span>
