<div class="post-text" itemprop="text">
<p>At the bottom of this question are a set of functions transcribed from a published neural-network model.  When I call <code>R</code>, I get the following error:</p>
<blockquote>
<p>RuntimeError: maximum recursion depth exceeded while calling a Python object</p>
</blockquote>
<p>Note that within each call to <code>R</code>, a recursive call to <code>R</code> is made for every other neuron in the network.  This is what causes the recursion depth to be exceeded.  Each return value for <code>R</code> depends on all the others (with the network involving <code>N = 512</code> total values.)  Does anyone have any idea what method should be used to compute the self-consistent solution for <code>R</code>?  Note that <code>R</code> itself is a smooth function.  I've tried treating this as a vector root-solving problem -- but in this case the 512 dimensions are not independent.  With so many degrees of freedom, the roots are never found (using the <code>scipy.optimize</code> functions).  Does Python have any tools that can help with this?  Maybe it would be more natural to solve <code>R</code> using something like Mathematica?  I don't know how this is normally done.</p>
<pre><code>"""Recurrent model with strong excitatory recurrence."""


import numpy as np


l = 3.14


def R(x_i):

    """Steady-state firing rate of neuron at location x_i.

    Parameters
    ----------
    x_i : number
      Location of this neuron.

    Returns
    -------
    rate : float
      Firing rate.

    """

    N = 512
    T = 1

    x = np.linspace(-2, 2, N)
    sum_term = 0
    for x_j in x:
        sum_term += J(x_i - x_j) * R(x_j)

    rate = I_S(x_i) + I_A(x_i) + 1.0 / N * sum_term - T

    if rate &lt; 0:
        return 0

    return rate


def I_S(x):
    """Sensory input.

    Parameters
    ----------
    x : number
      Location of this neuron.

    Returns
    -------
    float
      Sensory input to neuron at x.

    """
    S_0 = 0.46
    S_1 = 0.66
    x_S = 0
    sigma_S = 1.31
    return S_0 + S_1 * np.exp(-0.5 * (x - x_S) ** 2 / sigma_S ** 2)


def I_A(x):
    """Attentional additive bias.

    Parameters
    ----------
    x : number
      Location of this neuron.

    Returns
    -------
    number
      Additive bias for neuron at x.

    """
    x_A = 0
    A_1 = 0.089
    sigma_A = 0.35
    A_0 = 0
    sigma_A_prime = 0.87
    if np.abs(x - x_A) &lt; l:
        return (A_1 * np.exp(-0.5 * (x - x_A) ** 2 / sigma_A ** 2) +
                A_0 * np.exp(-0.5 * (x - x_A) ** 2 / sigma_A_prime ** 2))
    return 0


def J(dx):
    """Connection strength.

    Parameters
    ----------
    dx : number
      Neuron i's distance from neuron j.

    Returns
    -------
    number
      Connection strength.

    """
    J_0 = -2.5
    J_1 = 8.5
    sigma_J = 1.31
    if np.abs(dx) &lt; l:
        return J_0 + J_1 * np.exp(-0.5 * dx ** 2 / sigma_J ** 2)
    return 0


if __name__ == '__main__':

    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This recursion never ends since there is no termination condition before recursive call, adjusting maximum recursion depth does not help</p>
<pre><code>def R(x_i): 
   ...
   for x_j in x:
       sum_term += J(x_i - x_j) * R(x_j)
</code></pre>
<p>Perhaps you should be doing something like</p>
<pre><code># some suitable initial guess
state = guess

while True: # or a fixed number of iterations
   next_state = compute_next_state(state)

   if some_condition_check(state, next_state):
       # return answer
       return state 

   if some_other_check(state, next_state):
       # something wrong, terminate
      raise ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Change the maximum recursion depth using <code>sys.setrecursionlimit</code></p>
<pre><code>import sys
sys.setrecursionlimit(10000)

def rec(i):
    if i &gt; 1000:
        print 'i is over 1000!'
        return
   rec(i + 1)

rec(0)
</code></pre>
<p>More info: <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow">https://docs.python.org/3/library/sys.html#sys.setrecursionlimit</a>`</p>
</div>
<span class="comment-copy">You could rewrite the algorithm so it is iterative instead of recursive.</span>
<span class="comment-copy">I don't know your specific algorithm, but it has been proven that all recursive algorithm can be expressed iteratively. See this question for details: <a href="http://stackoverflow.com/questions/931762/can-every-recursion-be-converted-into-iteration" title="can every recursion be converted into iteration">stackoverflow.com/questions/931762/â€¦</a></span>
<span class="comment-copy">@spectras isn't that a bit like saying anything can in theory be computed using a turing machine?  it doesn't exactly suggest an implementable solution . . .</span>
<span class="comment-copy">What's your question then? Point you at an alternative algorithm? That's off topic here. Implement it for you? I'm afraid that's too broad a question for SO.</span>
<span class="comment-copy">thanks, yeah, this is on the right track for sure.  i'd imagine there must be formal proposals for optimal ways to achieve this sort of thing.  do you know what buzz words i might Google to find algorithms that might help me?  maybe there are optimization functions in scipy that would be appropriate here?</span>
<span class="comment-copy">i think standard root-solving methods would work here.  start w/ an array of 512 values (guesses).  instead of making recursive calls w/in <code>R</code>, use these values.  then take as my error the difference between <code>R</code>'s return values and the guess values.  continue guessing from there, finding values that minimize the error.</span>
<span class="comment-copy">i'll code this up.  if you don't mind my fleshing out your answer, i'll do that.  otherwise, i'll post my own.</span>
<span class="comment-copy">I think OP's algorithm does terminate because the <code>for</code> loops terminate. But it does something like <code>512**512</code> operations which is kinda steep for 21st century technologies.</span>
<span class="comment-copy">@tdelaney even if i did all those operations, though, would the code as written produce a sensible result?  i don't think it would.</span>
<span class="comment-copy">this strikes me as a naive answer, but i could be wrong about that.  it seems to me that, because every value of <code>R</code> depends on every other value, there is no way for the solution to be computed the way i've written the functions, no matter how deep i allow recursion to go.  is this suggestion coming from a place of understanding?</span>
<span class="comment-copy">just confirmed this proposal does not solve the problem.</span>
<span class="comment-copy">Some time of stopping condition such as <code>if i &gt; 1000</code> in the above sample code is needed in every recursive function, which is lacking in <code>R</code></span>
<span class="comment-copy">Every call to <code>R</code> will lead to 512 call to <code>R</code>. It's stuck in an infinite loop.</span>
<span class="comment-copy">ah, yes, true.  that is the problem.  thanks.  still, i see no solution.</span>
