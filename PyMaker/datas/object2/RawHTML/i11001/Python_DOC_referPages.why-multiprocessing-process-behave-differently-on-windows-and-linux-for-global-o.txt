<div class="post-text" itemprop="text">
<p>The following code has different output when running  on windows and linux (both with python2.7)</p>
<pre><code>'''import_mock.py'''
to_mock = None
</code></pre>
<pre class="lang-python prettyprint-override"><code>'''test.py'''
import import_mock
from multiprocessing import Process

class A(object):
    def __init__(self):
        self.a = 1
        self.b = 2
        self.c = 3

    def __getstate__(self):
        print '__getstate__'
        return { 'a': self.a, 'b': self.b,
                 'c':0 }

def func():
    import_mock.to_mock = 1
    a = A()
    return a

def func1(a):
    print a.a, a.b, a.c
    print import_mock.to_mock


if __name__ == '__main__':
    a = func()
    p = Process(target=func1, args=(a,))
    p.start()
    p.join()
</code></pre>
<p>On windows, the output is:</p>
<pre class="lang-none prettyprint-override"><code>__getstate__
1 2 0
None
</code></pre>
<p>Which is what I expected</p>
<p>On linux, it is:</p>
<pre class="lang-none prettyprint-override"><code>1 2 3
1
</code></pre>
<p>Which not clone the global object and the passed args.</p>
<p>My question is why they behave differently? And how to make the linux code behave the same as windows one?</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding to @Blckknght's answer:  on Windows, each process imports the original module "from scratch", while on Unix-y systems only the main process runs the whole module, while all other processes see whatever exists at the time <code>fork()</code> is used to create the new processes (no, <em>you're</em> not calling <code>fork()</code> yourself - <code>multiprocessing</code> internals call it whenever it creates a new process).</p>
<p>In detail, for your <code>import_mock</code>:</p>
<ul>
<li><p>On all platforms, the main process calls <code>func()</code>, which sets <code>import_mock.to_mock</code> to 1.</p></li>
<li><p>On Unix-y platforms, that's what all new processes see:  the <code>fork()</code> occurs after that, so 1 is the state all new processes inherit.</p></li>
<li><p>On Windows, all new processes run the entire module "from scratch".  So they each import their own, brand new version of <code>import_mock</code>.  Only the main process calls <code>func()</code>, so only the main process sees <code>to_mock</code> change to 1.  All other processes see the fresh <code>None</code> state.</p></li>
</ul>
<p>That's all expected, and actually easy to understand the second time ;-)</p>
<p>What's going on with passing <code>a</code> is subtler, because it depends more on <code>multiprocessing</code> implementation details.  The implementation <em>could</em> have chosen to pickle arguments on all platforms from the start, but it didn't, and now it's too late to change without breaking stuff on <em>some</em> platforms.</p>
<p>Because of copy-on-write <code>fork()</code> semantics, it wasn't <em>necessary</em> to pickle <code>Process()</code> arguments on Unix-y systems, and so the implementation never did.  However, without <code>fork()</code> it is necessary to pickle them on Windows - and so the implementation does.</p>
<p>Before Python 3.4, which allows you to force "the Windows implementation" (<code>spawn</code>) on all platforms, there's no mechanical way to avoid possible cross-platform surprises.</p>
<p>But in practice, I've rarely been bothered by this.  <em>Knowing</em> that, for example, multiprocessing can depend heavily on pickling, I stay completely clear of getting anywhere near playing tricks with pickles.  The only reason you had "a problem" passing an <code>A()</code> instance is that you are playing pickle tricks (via overriding the default <code>__getstate__()</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>On Linux (and other Unix-like OSs), Python's <code>multiprocessing</code> module using <code>fork()</code> to create new child processes that efficiently inherit a copy of the parent process's memory state. That means the interpreter doesn't need to pickle the objects that are being passed as the <code>Process</code>'s <code>args</code> since the child process will already have them available in their normal form.</p>
<p>Windows doesn't have a <code>fork()</code> system call however, so the <code>multiprocessing</code> module needs to do a bit more work to make the child-spawning process work. The <code>fork()</code>-based implementation came first, and the non-forking Windows implementation came later.</p>
<p>It's worth noting that the Python developers had often felt it was a bit of a misfeature for the creation of child processes to differ so much based on the platform you're running Python on. So in Python 3.4, a new system was added to allow you to <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="noreferrer">select the start method that you would prefer to use</a>. The options are <code>"fork"</code>, <code>"forkserver"</code> and <code>"spawn"</code>. The <code>"fork"</code> method remains the default on Unix-like systems (where it was the only implementation in earlier versions of Python). The <code>"spawn"</code> method is the default (and only) option on Windows, but now can be used on Unix-like systems too. The <code>"forkserver"</code> method is sort of a hybrid between the two (and only available on some Unix-like systems). You can read more about the differences between the methods in the documentation.</p>
</div>
<span class="comment-copy">Because things are implemented differently on the two OSs. The docs mention that on Windows many types from multiprocessing need to be picklable so that child processes can use them. The implication is that on other OSs they don't have to be. <a href="https://docs.python.org/2/library/multiprocessing.html#logging" rel="nofollow noreferrer">This section</a> on logging in the <code>multiprocessing</code> module's documentation may help with your specific problem.</span>
