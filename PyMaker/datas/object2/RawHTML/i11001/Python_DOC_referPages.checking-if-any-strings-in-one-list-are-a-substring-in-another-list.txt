<div class="post-text" itemprop="text">
<p>I know that if I just have two strings that checking using <code>x in y</code> will work.  And that if I just wanted to check if a string is in any of the strings in a list I'd just use a <code>for</code> loop for that.</p>
<p>But what is the most pythonic/efficient way to check if any of the strings in the first list are substrings of the strings in the second list?</p>
<p>An example would be:</p>
<pre><code>notPresent = []
present = []
listA = ['Rick', 'James']
listB = ['Rick', 'Ricky', 'Ryan', 'Jam', 'Jamesses', 'Jamboree']

notPresent = ['Ryan', 'Jam', 'Jamboree']
present = ['Rick', 'Ricky', 'Jamesses']
</code></pre>
<p>I'm going to use both <code>present</code> and <code>notPresent</code> words.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would say something like this:</p>
<pre><code>#python2
notPresent = set()
present = set()
listA = ['Rick', 'James']
listB = ['Rick', 'Ricky', 'Ryan', 'Jam', 'Jamesses', 'Jamboree']

#notPresent = ['Ryan','Jam','Jamboree']
#present = ['Rick','Ricky','Jamesses']

for b in listB:
  for a in listA:
    if a in b:
      present.add(b)
      break
  else:
    notPresent.add(b)

print(list(notPresent))
print(list(present))
</code></pre>
<p>So basically 2 for loops. And use sets instead of lists (fr uniqueness of values)...</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with <a href="https://docs.python.org/2/library/functions.html#any" rel="nofollow"><code>any</code></a> and a <a href="https://docs.python.org/2/library/functions.html#func-set" rel="nofollow"><code>set</code></a> comprehension:</p>
<pre><code>listA = ['Rick', 'James']
listB = ['Rick', 'Ricky', 'Ryan', 'Jam', 'Jamesses', 'Jamboree']

present = {i for i in listB if any(j in i for j in listA)}
notPresent = set(listB) - present  # difference of two sets 

print(present)
# {'Rick', 'Ricky', 'Jamesses'}

print(notPresent)
# {'Jamboree', 'Ryan', 'Jam'}
</code></pre>
<p><code>any</code> helps avoid running the entire length of the iteration after a match has been found, and with <code>set</code> you can generate the complementary set <code>notPresent</code> from the first.</p>
</div>
<div class="post-text" itemprop="text">
<p>the fastest way is probably to turn the first list into a set</p>
<pre><code>setA = set(listA)
</code></pre>
<p>then, for each string in <code>listB</code>, check if any of its substrings are in <code>setA</code>.</p>
<pre><code>def substrings(s):
    for i in range len(s)
        for j in range i
            yield s[i:j]

result = []
for s in listB:
    if any(substring in setA for substring in substrings(s)):
        result.append(s)
</code></pre>
</div>
<span class="comment-copy"><i>"check if any of"</i> - <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a>? Do you have current code that you think is unpythonic and/or inefficient?</span>
<span class="comment-copy">Any as in "any of the elements of the list".  I'm in the process of figuring out how to do this, not optimise existing code.  I'm guessing a for loop within a for loop.</span>
<span class="comment-copy">Yes, I understand, and I'm saying <i>there's a built-in function for that</i>. Follow the link and have a look!</span>
<span class="comment-copy">Did you downvote me because I awarded the answer to the person that gave it to me?  You don't provide any answer or assistance, and then downvote me and negatively comment the answerer?!?!</span>
<span class="comment-copy">1. I did provide assistance. 2. I didn't <i>"negatively comment the answerer"</i>, I gave them some constructive feedback. 3. Whether I or anyone else downvoted and why is pretty much none of your business. FWIW, I would have liked to have seen some <i>actual effort to implement this on your part</i>.</span>
<span class="comment-copy"><i>Why</i> would you say something like that? Could you add some explanation? One obvious issue is that you continue to scan <code>listA</code> even after the item is matched.</span>
<span class="comment-copy">I fixed the scanning after matching. The reason I would do it like this, is because it's a clear and readable aprach of the problem (scanning through a list by items of another list, looks like 2 for loops to me).  Given that you want to do something for every element of listB, after scannin listA, I found it clear to put the for loop of listB in the outer ring. And sets look more clear, since they only store a value ones and you want only the element once. However, with the break, lists work just as well (I assmume)...</span>
<span class="comment-copy">1. Please put that explanation <i>in the answer</i>. 2. That's a minimal fix, note that the <code>for: else:</code> construct would remove the (somewhat unpythonic) flag you have now.</span>
<span class="comment-copy">This actually delivered the correct result without the edit you made as well.  Cheers Sebastiaan.  I'll use the version with the break though.</span>
<span class="comment-copy">@mcleodx: great ;). Cheers to you too.</span>
<span class="comment-copy">remember to lowercase the strings first</span>
<span class="comment-copy">if you want to get more fancy, look up "suffix array datastructure"</span>
