<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/33824228/why-wont-dynamically-adding-a-call-method-to-an-instance-work">Why won't dynamically adding a `__call__` method to an instance work?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have a wrapper class similar to this (strongly simplified) example:</p>
<pre><code>class wrap(object):
    def __init__(self):
        self._data = range(10)

    def __getitem__(self, key):
        return self._data.__getitem__(key)
</code></pre>
<p>I can use it like this:</p>
<pre><code>w = wrap()
print w[2] # yields "2"
</code></pre>
<p>I thought I could optimize and get rid of one function call by changing to this:</p>
<pre><code>class wrap(object):
    def __init__(self):
        self._data = range(10)
        self.__getitem__ = self._data.__getitem__
</code></pre>
<p>However, I receive a</p>
<blockquote>
<p>TypeError: 'wrap' object does not support indexing</p>
</blockquote>
<p>for the <code>print w[2]</code> line with the latter version.</p>
<p>The direct call to the method, i.e., <code>print w.__getitem__(2)</code>, works in both cases...</p>
<p>Why does the assignment version not allow indexing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Special methods (essentially anything with two underscores on each end) have to be defined on the class. The <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow">internal lookup procedure</a> for special methods completely skips the instance dict. Among other things, this is so if you do</p>
<pre><code>class Foo(object):
    def __repr__(self):
        return 'Foo()'
</code></pre>
<p>the <code>__repr__</code> method you defined is only used for instances of <code>Foo</code>, and not for <code>repr(Foo)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can actually solve this by creating a new class for every type. If you want this to work transparently, <code>__new__</code> is the place for it.</p>
<pre><code>import weakref


class BigWrap(object):
    def __new__(cls, wrapped):
        wrapped_type = type(wrapped)
        print('Wrapping %s (%s)' % (wrapped, wrapped_type))
        # creates a new class, aka a new type
        wrapper_class = type(  # new_class = type(class name, base classes, class dict)
            '%s_%s_%d' % (cls.__name__, wrapped_type.__name__, id(wrapped)),  # dynamic class name
            (
                cls,  # inherit from wrap to have all new methods
                wrapped_type,  # inherit from wrap_type to have all its old methods
            ),
            {
                '__getitem__': wrapped.__getitem__,  # overwrite __getitem__ based on wrapped *instance*
                '__new__': wrapped_type.__new__,  # need to use wrapped_type.__new__ as cls.__new__ is this function
            })
        cls._wrappers[wrapped_type] = wrapper_class  # store wrapper for repeated use
        return cls._wrappers[wrapped_type](wrapped)

    # self is already an instance of wrap_&lt;type(wrapped)&gt;
    def __init__(self, wrapped):
        self.__wrapped__ = wrapped
</code></pre>
<hr/>
<p>Initial "solution":</p>
<pre><code>import weakref
class wrap(object):
  _wrappers = weakref.WeakValueDictionary()  # cache wrapper classes so we don't recreate them

  def __new__(cls, wrapped):
    wrapped_type = type(wrapped)
    print('Wrapping %s (%s)' % (wrapped, wrapped_type))
    try:
      return object.__new__(cls._wrappers[wrapped_type])  # need to use object.__new__ as cls.__new__ is this function
    except KeyError:
      print('Creating Wrapper %s (%s)' % (wrapped, wrapped_type))
    # creates a new class, aka a new type
    wrapper_class = type(  # class name, base classes, class dict
      '%s_%s' % (cls.__name__, wrapped_type.__name__),  # dynamic class name
      (cls,),  # inherit from wrap to have all its method
      {'__getitem__': wrapped_type.__getitem__})  # overwrite __getitem__ based on wrapped class
    cls._wrappers[wrapped_type] = wrapper_class  # store wrapper for repeated use
    return cls._wrappers[wrapped_type](wrapped)

  # self is already an instance of wrap_&lt;type(wrapped)&gt;
  def __init__(self, wrapped):
    self._data = wrapped
</code></pre>
<p>Be careful however! This will do what you want - use the wrapped class' <code>__getitem__</code>. However, this doesn't always make sense! For example, <code>list.__getitem__</code> is actually built into CPython's CAPI and not applicable to other types.</p>
<pre><code>foo = wrap([1,2,3])
print(type(foo))  # __main__.wrap_list
foo[2]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-31-82791be7104b&gt; in &lt;module&gt;()
----&gt; 1 foo[2]

TypeError: descriptor '__getitem__' for 'list' objects doesn't apply to 'wrap_list' object
</code></pre>
</div>
<span class="comment-copy">Pro tip: If you didn't know why this breaks, you shouldn't try optimizing it. Its overhead is probably not as significant as you think it is.</span>
<span class="comment-copy">But, If I hadn't tried, I wouldn't have learned how it works, which wouldn't have allowed me to do it. OTOH, if I had known it breaks, I'd not have tried it ... Also, you probably don't know, how significant I thought it to be.</span>
<span class="comment-copy">Note that you <i>can</i> actually solve this by creating a new class for every type. Basically you need a factory function for this. Which can be transparently implemented via <code>__new__</code>. It's some black magic, though... Of course I can just speculate how significant you think it its; for reference, you can safe roughly 0.1 usec per call.</span>
<span class="comment-copy">Care to write down some example code for that? And, please excuse my snarky comment, I meant to demonstrate that you are implying that learning how something works by breaking it is not a good strategy (which I think it is!) ...</span>
<span class="comment-copy">To be quite honest with you, I didn't know this was possible either, before your snark motivated me. See my answer below on how to do it (and why it's actually a bad idea for other reasons ^^). Keep up the good snark and never stop breaking things. ;)</span>
<span class="comment-copy">Ah! I see. Could you give a link to the documentation for this? And, I don't really see the connection between your first paragraph (which answers my question) and your example...</span>
<span class="comment-copy">@NichtJens: If special method lookup looked at the instance dict, then <code>repr(Foo)</code> would pick up the <code>Foo.__repr__</code> method you defined and use that. That's not what you want, because that method is only supposed to handle instances of <code>Foo</code>, not <code>Foo</code> itself.</span>
<span class="comment-copy">@NichtJens: <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">Here's</a> the documentation, which uses a similar example.</span>
<span class="comment-copy">Great... Solved in ~5minutes. Thanks!</span>
<span class="comment-copy">I see. So, even though we can trick the "special lookup" procedure into actually considering the wrapped's <code>__getitem__</code>, the trick does not work consistently. That's a little bit of a bummer... Apart from that, I feel your example might be re-written as a decorator, taking the to-be-wrapped methods as argument. But, because of the inconsistencies above, it's probably not worth it.</span>
<span class="comment-copy">@NichtJens Yeah, at least directly using the methods seems not to be worth it. The same approach could be used to dynamically change the inheritance of the wrapper - i.e. make it an actual subclass of the wrapped class.</span>
