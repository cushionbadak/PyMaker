<div class="post-text" itemprop="text">
<p>Consider this list:</p>
<pre><code>dates = [
    ('2015-02-03', 'name1'),
    ('2015-02-04', 'nameg'),
    ('2015-02-04', 'name5'),
    ('2015-02-05', 'nameh'),
    ('1929-03-12', 'name4'),
    ('2023-07-01', 'name7'),
    ('2015-02-07', 'name0'),
    ('2015-02-08', 'nameh'),
    ('2015-02-15', 'namex'),
    ('2015-02-09', 'namew'),
    ('1980-12-23', 'name2'),
    ('2015-02-12', 'namen'),
    ('2015-02-13', 'named'),
]
</code></pre>
<p>How can I identify those dates that are out of sequence. I don't care if they repeat, or skip, I just need the ones way out of line. Ie, I should get back:</p>
<pre><code>('1929-03-12', 'name4'),
('2023-07-01', 'name7'),
('2015-02-15', 'namex'),
('1980-12-23', 'name2'),
</code></pre>
<p>Namex is less obvious, but it's not in the general order of the list.</p>
<p>My simplistic start (which I have deleted to simplify the question) is obviously woefully incomplete.</p>
<hr/>
<p><strong>Update</strong>: Based on the comments, it seems an implementation of the <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" rel="nofollow noreferrer">Longest Increase Subsequence</a> (LIS) will get me started, a python implementation found here: </p>
<ul>
<li><a href="https://stackoverflow.com/a/9832414/1061836">https://stackoverflow.com/a/9832414/1061836</a></li>
<li><a href="https://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming">How to determine the longest increasing subsequence using dynamic programming?</a></li>
<li><a href="https://rosettacode.org/wiki/Longest_increasing_subsequence#Python" rel="nofollow noreferrer">https://rosettacode.org/wiki/Longest_increasing_subsequence#Python</a></li>
<li><a href="https://codereview.stackexchange.com/questions/10230/python-implementation-of-the-longest-increasing-subsequence">https://codereview.stackexchange.com/questions/10230/python-implementation-of-the-longest-increasing-subsequence</a></li>
</ul>
<p>Seems once I get the LIS, I can compare it to the original list and see where the gaps are... Fascinating. SO is the hive-mind of awesomeness.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Short answer, general solution</h2>
<p>Using my <a href="https://stackoverflow.com/a/38337443/1916449">answer to the "Longest increasing subsequence" question</a>, this could be implemented simply as:</p>
<pre><code>def out_of_sequence(seq):
  indices = set(longest_subsequence(seq, 'weak', key=lambda x: x[0], index=True))
  return [e for i, e in enumerate(seq) if i not in indices]
</code></pre>
<h2>Longer answer, specific solution</h2>
<p>Based on the <a href="https://codereview.stackexchange.com/q/10230/110989">question at Code Review</a> and a <a href="https://stackoverflow.com/a/21718032/1916449">question about non-decreasing sequences</a> (since that's what you're after), here's a solution to your problem:</p>
<pre><code>from bisect import bisect_right
from operator import itemgetter


def out_of_sequence(seq, key = None):
  if key is None: key = lambda x: x 

  lastoflength = [0] # end position of subsequence with given length
  predecessor = [None] # penultimate element of l.i.s. ending at given position

  for i in range(1, len(seq)):
    # find length j of subsequence that seq[i] can extend
    j = bisect_right([key(seq[k]) for k in lastoflength], key(seq[i]))
    # update old subsequence or extend the longest
    try: lastoflength[j] = i
    except: lastoflength.append(i)
    # record element preceding seq[i] in the subsequence for backtracking
    predecessor.append(lastoflength[j-1] if j &gt; 0 else None)

  indices = set()
  i = lastoflength[-1]
  while i is not None:
    indices.add(i)
    i = predecessor[i]

  return [e for i, e in enumerate(seq) if i not in indices]


print(*out_of_sequence(dates, itemgetter(0)), sep='\n')
</code></pre>
<p>Outputs:</p>
<pre><code>('1929-03-12', 'name4')
('2023-07-01', 'name7')
('2015-02-15', 'namex')
('1980-12-23', 'name2')
</code></pre>
<hr/>
<p>The <code>key</code> parameter (inspired by <a href="https://docs.python.org/3.5/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted</code></a> builtin) specifies a function of one argument that is used to extract a comparison key from each list element. The default value is <code>None</code> so the caller has a convenient way of saying "I want to compare the elements directly". If it is set to <code>None</code> we use <code>lambda x: x</code> as an <a href="https://en.wikipedia.org/wiki/Identity_function" rel="nofollow noreferrer">identity function</a>, so the elements are not changed in any way before the comparison.</p>
<p>In your case, you want to use the dates as keys for comparison, so we use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter(0)</code></a> as <code>key</code>. And <code>itemgetter(1)</code> would use the names as <code>key</code>, see:</p>
<pre><code>&gt;&gt;&gt; print(*map(itemgetter(1), dates))
name1 nameg name5 nameh name4 name7 name0 nameh namex namew name2 namen named
</code></pre>
<p>Using <code>itemgetter(k)</code> is equivalent to <code>lambda x: x[k]</code>:</p>
<pre><code>&gt;&gt;&gt; print(*map(lambda x: x[1], dates))
name1 nameg name5 nameh name4 name7 name0 nameh namex namew name2 namen named
</code></pre>
<p>Using it with <code>map</code> is equivalent to a generator expression:</p>
<pre><code>&gt;&gt;&gt; print(*(x[1] for x in dates))
name1 nameg name5 nameh name4 name7 name0 nameh namex namew name2 namen named
</code></pre>
<p>But if we used a similar list comprehension to pass the sequence to <code>out_of_sequence</code> we would get a different result from expected:</p>
<pre><code>&gt;&gt;&gt; print(*out_of_sequence([x[0] for x in dates]), sep='\n')
1929-03-12
2023-07-01
2015-02-15
1980-12-23
</code></pre>
<p>Likewise, if we compare the date-name pairs directly we get wrong results (because <code>'nameg'</code> compares greater to <code>'name5'</code>):</p>
<pre><code>&gt;&gt;&gt; print(*out_of_sequence(dates), sep='\n')
('2015-02-04', 'nameg')
('1929-03-12', 'name4')
('2023-07-01', 'name7')
('2015-02-15', 'namex')
('1980-12-23', 'name2')
</code></pre>
<p>Because we want to return dates and names, and we want to order by dates only, we need to pass a function that extracts dates using the <code>key</code> parameter.</p>
<p>An alternative would be to get rid of <code>key</code> and just write:</p>
<pre><code>j = bisect_right([seq[k][0] for k in lastoflength], seq[i][0])
</code></pre>
<p>But since this is stackoverflow, maybe one day another person will come by this answer and will need some other key extraction, therefore I decided to post the more general solution here.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will establish a new anchor_date for you if the current date is greater than the last good date.  </p>
<pre><code>import arrow

out_of_order = []
anchor_date = arrow.get(dates[0][0])
for dt, name in dates:
  if arrow.get(dt) &lt; anchor_date:
    out_of_order.append((dt, name))
  else:
    anchor_date = arrow.get(dt)
</code></pre>
</div>
<span class="comment-copy">How can we tell <code>namex</code> is out of order?</span>
<span class="comment-copy">Please define your "out of sequence" more precisely</span>
<span class="comment-copy">Compute the 'mean' and the standard deviation, find anything beyond two standard deviations?</span>
<span class="comment-copy">ok ok... quoted and de-typoed. Teach me to write hasty almost-code ;)</span>
<span class="comment-copy">Formulation of your problem reminds me of <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" rel="nofollow noreferrer">en.wikipedia.org/wiki/Longest_increasing_subsequence</a></span>
<span class="comment-copy">initial testing looking good! What was that edit just now?</span>
<span class="comment-copy">@Trees4theForest you can see all edits if you click the "edited X time ago" link. But in this case, I changed only some comments and variable names, nothing of real significance.</span>
<span class="comment-copy">been testing regularly, and it works -- awesome! For my understanding, what is the key=None arg (and subsequent lambda x: x) doing through this</span>
<span class="comment-copy">I've added an explanation to my answer.</span>
<span class="comment-copy">Hi @arekolek - I can't thank you enough for the work, and the explanation. However, I did just find one limitation:  If the first run of <i>out-of-sequence</i> items is longer than the first run of <i>in-sequence</i> items, then regardless of how many in-sequence items follow, the function returns that initial run of in-sequence items. IE 1,2,3,991,992,993,994,5,6,7,8,9,10,11... returns: 1,2,3</span>
