<div class="post-text" itemprop="text">
<p>I have a problem with my python script. I can't find a way to do a calculation for the first 15 rows only, then for the second 15 rows only, then for the third 15 rows only... The rows come from a txt file.</p>
<pre><code>with open('/Users/sammtt/data/test2.txt','r') as f:
for line in nonblank_lines(f):
    print(my_txt(line,0))
    print(my_txt(line,2))

    print(my_txt(line,6))
    print(my_txt(line,8))
</code></pre>
<p>Many thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use this <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">recipe</a> for <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> from the standard library:</p>
<pre><code>from itertools import zip_longest

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>Applying it to your code:</p>
<pre><code>with open('/Users/sammtt/data/test2.txt','r') as f:
    for chunk in grouper(nonblank_lines(f), 15):
        process_chunk(chunk)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code> on an integer division:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; f = range(0, 100)
&gt;&gt;&gt; for i, g in groupby(f, key=lambda x: x//15):
...     print(list(g))
...
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
[15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
[30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44]
[45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]
[60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74]
[75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>And in the case of your file object, you could use <code>enumerate</code> to step through the lines:</p>
<pre><code>with open('/Users/sammtt/data/test2.txt','r') as f:
    for i, group_of_15 in groupby(enumerate(nonblank_lines(f)), key=lambda x: x[0]//15):
        chunk = list(map(lambda x: x[1], group_of_15))
        do_something(chunk)
</code></pre>
</div>
<span class="comment-copy">Just append all the lines to a list and then do your calculations.</span>
<span class="comment-copy">Yes but how to skip every 15 rows, to have: the first list with the first 15 rows, the second list with 15 rows etc...</span>
<span class="comment-copy">What about using <code>enumerate</code>? if rowNum % 15  == 0 then next 15 rows.</span>
<span class="comment-copy">Thank you very much. I have an error saying NameError: name 'zip_longest' is not defined</span>
<span class="comment-copy">@sammtt: <code>zip_longest</code> needs to be imported from <code>itertools</code> (see the update).</span>
<span class="comment-copy">Thank you for this. However, I don't really understand how it works then. Is a chunk a box of 15 rows? How do I get the first row of the chunk? By setting nonblank_lines[0] for example?</span>
<span class="comment-copy">Yes, 15 rows/lines. <code>chunk[0]</code> should get you the first row.</span>
<span class="comment-copy">I did     for i, group_of_15 in groupby(enumerate(nonblank_lines(f)), key=lambda x: x[0]//15):         chunk = map(lambda x: x[1], group_of_15)         print(chunk[0])  But I get TypeError: 'map' object is not subscriptable</span>
<span class="comment-copy">@sammtt Ah, you should have added a python 3 tag to the question. I thought this was Python 2. I've updated the answer.</span>
<span class="comment-copy">I'm doing chunk[0] to get for example the first 15 rows, but it actually gets the first row of each 15 rows. How can I get just the first block (ie. the first 15 rows for example )?</span>
