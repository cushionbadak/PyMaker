<div class="post-text" itemprop="text">
<p>In Perl I can do:</p>
<pre><code>my ($x, $y) = split /:/, $str;
</code></pre>
<p>And it will work whether or not the string contains the pattern.</p>
<p>In Python, however this won't work:</p>
<pre><code>a, b = "foo".split(":")  # ValueError: not enough values to unpack
</code></pre>
<p>What's the canonical way to prevent errors in such cases?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're splitting into just two parts (like in your example) you can use <a href="https://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow noreferrer"><code>str.partition()</code></a> to get a guaranteed argument unpacking size of 3: </p>
<pre><code>&gt;&gt;&gt; a, sep, b = 'foo'.partition(':')
&gt;&gt;&gt; a, sep, b
('foo', '', '')
</code></pre>
<p><code>str.partition()</code> always returns a 3-tuple, whether the separator is found or not.</p>
<p>Another alternative for Python 3.x is to use <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">extended iterable unpacking</a>:</p>
<pre><code>&gt;&gt;&gt; a, *b = 'foo'.split(':')
&gt;&gt;&gt; a, b
('foo', [])
</code></pre>
<p>This assigns the first split item to <code>a</code> and the list of remaining items (if any) to <code>b</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you are on Python 3, it is easy.  PEP 3132 introduced a welcome simplification of the syntax when assigning to tuples - <em>Extended iterable unpacking</em>.  In the past, if assigning to variables in a tuple, the number of items on the left of the assignment must be exactly equal to that on the right.  </p>
<p>In Python 3 we can designate any variable on the left as a list by prefixing with an asterisk *.  That will grab as many values as it can, while still populating the variables to its right (so it need not be the rightmost item).  This avoids many nasty slices when we don't know the length of a tuple.</p>
<pre><code>a, *b = "foo".split(":")  
print("a:", a, "b:", b)
</code></pre>
<p>Gives:</p>
<pre><code>a: foo b: []
</code></pre>
<p>EDIT following comments and discussion:</p>
<p>In comparison to the Perl version, this is considerably different, but it is the Python (3) way.  In comparison with the Perl version, <code>re.split()</code> would be more similar, however invoking the RE engine for splitting around a single character is an unnecessary overhead.</p>
<p>With multiple elements in Python:</p>
<pre><code>s = 'hello:world:sailor'
a, *b = s.split(":")
print("a:", a, "b:", b)
</code></pre>
<p>gives:</p>
<pre><code>a: hello b: ['world', 'sailor']
</code></pre>
<p>However in Perl:</p>
<pre><code>my $s = 'hello:world:sailor';
my ($a, $b) = split /:/, $s;
print "a: $a b: $b\n";
</code></pre>
<p>gives:</p>
<pre><code>a: hello b: world
</code></pre>
<p>It can be seen that additional elements are ignored, or lost, in Perl.  That is fairly easy to replicate in Python if required:</p>
<pre><code>s = 'hello:world:sailor'
a, *b = s.split(":")
b = b[0]
print("a:", a, "b:", b)
</code></pre>
<p>So, <code>a, *b = s.split(":")</code> equivalent in Perl would be </p>
<pre><code>my ($a, @b) = split /:/, $s;
</code></pre>
<p>NB:  we shouldn't use <code>$a</code> and <code>$b</code> in general Perl since they have a special meaning when used with <code>sort</code>.  I have used them here for consistency with the Python example.</p>
<p>Python does have an extra trick up its sleeve, we can unpack to any element in the tuple on the left:</p>
<pre><code>s = "one:two:three:four"
a, *b, c = s.split(':')
print("a:", a, "b:", b, "c:", c)
</code></pre>
<p>Gives:</p>
<pre><code>a: one b: ['two', 'three'] c: four
</code></pre>
<p>Whereas in the Perl equivalent, the array (<code>@b</code>) is greedy, and the scalar <code>$c</code> is <code>undef</code>:</p>
<pre><code>use strict;
use warnings;

my $s = 'one:two:three:four';
my ($a, @b, $c) = split /:/, $s;
print "a: $a b: @b c: $c\n";
</code></pre>
<p>Gives:</p>
<pre><code>Use of uninitialized value $c in concatenation (.) or string at gash.pl line 8.
a: one b: two three four c: 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are always free to catch the exception.</p>
<p>For example:</p>
<pre><code>some_string = "foo"

try:
    a, b = some_string.split(":")
except ValueError:
    a = some_string
    b = ""
</code></pre>
<p>If assigning the whole original string to <code>a</code> and an empty string to <code>b</code> is the desired behaviour, I would probably use <code>str.partition()</code> as eugene y suggests. However, this solution gives you more control over exactly what happens when there is no separator in the string, which might be useful in some cases.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>split</code> will always return a list. <code>a, b = ...</code> will always expect list length to be two. You can use something like <code>l = string.split(':'); a = l[0]; ...</code>. </p>
<p>Here is a one liner: <code>a, b = (string.split(':') + [None]*2)[:2]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>How about using Regular Expressions:</p>
<pre><code>import re 
string = 'one:two:three:four'
</code></pre>
<p>in 3.X:</p>
<pre><code>a, *b = re.split(':', string)
</code></pre>
<p>in 2.X:</p>
<pre><code>a, b = re.split(':', string)[0], re.split(':', string)[1:]
</code></pre>
<p>This way you can also use regular expressions to split(i. e. \d)</p>
</div>
<span class="comment-copy">In Perl, what do <code>$x</code> and <code>$y</code> get if the string doesn't contain the pattern? Are both of them assigned the entire string, or does <code>$y</code> get null or something?</span>
<span class="comment-copy">@Don'tPanic: <code>$x</code> gets the whole string, <code>$y</code> is <code>undef</code> (which is similar to <code>None</code>, but subtly different).</span>
<span class="comment-copy">@jpmc26: in Perl it would ignore additional values.  But I doubt we really want to write a Perl emulator in python.</span>
<span class="comment-copy">@cdarke Of course we're not writing a Perl emulator, but we can't answer the question without knowing what the desired behavior is. An important aspect of the OP's code that they omit from the question is that the Python version would also fail if the string contained <i>multiple</i> colons. Anyway, <a href="http://perldoc.perl.org/functions/split.html" rel="nofollow noreferrer">the documentation</a> seems to contradict you. It looks like Perl returns a list, splitting at each occurrence of the pattern, the same as Python's <code>split</code> function. It also appears that Perl's <code>split</code> is accepting a regex.</span>
<span class="comment-copy">@jpmc26 A Perl list is not the same as a python list, it is closer to a tuple, except you can't have a variable of type list in perl, and you can't have  reference to one either.  A list in Perl is really only a syntactical device.  There is a discussion here:  <a href="http://friedo.com/blog/2013/07/arrays-vs-lists-in-perl" rel="nofollow noreferrer">friedo.com/blog/2013/07/arrays-vs-lists-in-perl</a>.  Yes, Perl's <code>split</code> is closer to <code>re.split</code> except there is extra magic for whitespace.</span>
<span class="comment-copy">I've been writing Python for years. YEARS. And this is the first time I've seen extended unpacking. This language is absolutely huge.</span>
<span class="comment-copy">How would it work if you put a variable to the right of <code>b</code>?</span>
<span class="comment-copy">@Panzercrisis it's robust - <code>a,*b,c = "foo:bar:baz:last".split(":")</code> gives <code>a="foo"</code> <code>b=["bar","baz"]</code> <code>c="last"</code> EDIT: It will die if you don't give it enough values for the definite things, i.e. the same statement with <code>"foo"</code> being split will <code>ValueError: not enough values to unpack (expected at least 2, got 1)</code></span>
<span class="comment-copy">@magu_ It does a different thing. <code>str.partition</code> performs only <i>one</i> split. So it's like passing <code>maxsplit=1</code>.</span>
<span class="comment-copy">@jpmc26: Not exactly. In Perl, if you assign the result of <code>split()</code> to two scalars you get either two strings, or a string and an <code>undef</code>, but never a string and array reference.</span>
<span class="comment-copy">@magu_ that's because Python 3 is more pythonic than Python 2 :)</span>
<span class="comment-copy">This would not work if the string contained <i>multiple</i> delimiters, e.g., <code>'a:b:c:d:e'</code></span>
