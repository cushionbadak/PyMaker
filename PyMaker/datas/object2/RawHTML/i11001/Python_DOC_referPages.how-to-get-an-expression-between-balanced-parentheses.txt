<div class="post-text" itemprop="text">
<p>Suppose I am given the following kind of string:</p>
<pre><code>"(this is (haha) a string(()and it's sneaky)) ipsom (lorem) bla"
</code></pre>
<p>and I want to extract substrings contained within a topmost layer of parentheses. I.e. I want to obtain the strings:<code>"this is (haha) a string(()and it's sneaky)"</code> and <code>"lorem"</code>.</p>
<p>Is there a nice pythonic method to do this? Regular expressions are <strong>not obviously</strong> up to this task, but maybe there is a way to get an xml parser to do the job? For my application I can assume the parentheses are well formed, i.e. not something like (()((). </p>
</div>
<div class="post-text" itemprop="text">
<p>This is a standard use case for a stack: You read the string character-wise and whenever you encounter an opening parenthesis, you push the symbol to the stack; if you encounter a closing parenthesis, you pop the symbol from the stack.</p>
<p>Since you only have a single type of parentheses, you don’t actually need a stack; instead, it’s enough to just remember how many open parentheses there are.</p>
<p>In addition, in order to extract the texts, we also remember where a part starts when a parenthesis on the first level opens and collect the resulting string when we encounter the matching closing parenthesis.</p>
<p>This could look like this:</p>
<pre><code>string = "(this is (haha) a string(()and it's sneaky)) ipsom (lorem) bla"

stack = 0
startIndex = None
results = []

for i, c in enumerate(string):
    if c == '(':
        if stack == 0:
            startIndex = i + 1 # string to extract starts one index later

        # push to stack
        stack += 1
    elif c == ')':
        # pop stack
        stack -= 1

        if stack == 0:
            results.append(string[startIndex:i])

print(results)
# ["this is (haha) a string(()and it's sneaky)", 'lorem']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure regex isn't good enough?</p>
<pre><code>&gt;&gt;&gt; x=re.compile(r'\((?:(?:\(.*?\))|(?:[^\(\)]*?))\)')
&gt;&gt;&gt; x.findall("(this is (haha) a string(()and it's sneaky)) ipsom (lorem) bla")
["(this is (haha) a string(()and it's sneaky)", '(lorem)']
&gt;&gt;&gt; x.findall("((((this is (haha) a string((a(s)d)and ((it's sneaky))))))) ipsom (lorem) bla")
["((((this is (haha) a string((a(s)d)and ((it's sneaky))", '(lorem)']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this isnt very "pythonic"...but </p>
<pre><code>def find_strings_inside(what_open,what_close,s):
    stack = []
    msg = []
    for c in s:
        s1=""
        if c == what_open:
           stack.append(c)
           if len(stack) == 1:
               continue
        elif c == what_close and stack:
           stack.pop()
           if not stack:
              yield "".join(msg)
              msg[:] = []
        if stack:
            msg.append(c)

x= list(find_strings_inside("(",")","(this is (haha) a string(()and it's sneaky)) ipsom (lorem) bla"))

print x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This more or less repeats what's already been said, but might be a bit easier to read:</p>
<pre><code>def extract(string):
    flag = 0
    result, accum = [], []
    for c in string:
        if c == ')':
            flag -= 1
        if flag:
            accum.append(c)
        if c == '(':
            flag += 1
        if not flag and accum:
            result.append(''.join(accum))
            accum = []
    return result

&gt;&gt; print extract(test)
["this is (haha) a string(()and it's sneaky)", 'lorem']
</code></pre>
</div>
<span class="comment-copy">I think you should define a function for this. In that function, traverse string and maintain a flag to check if you are within a topmost layer of parentheses. Using this method,you can get index if start and end and then you can extract string and concatenate to final answer</span>
<span class="comment-copy">Would this be considered a "pythonic" method? I would go about it by using a ctr which would increment on hitting '(' and decrement on hitting ')'. When it hits 0 after hitting at least 1 '(' you can take the substring between the initial and final positions and append it to a list.</span>
<span class="comment-copy">Hi utkarsh13. Thanks for that. It's more or less the solution I had in mind, but I was wondering if there was a faster was some functionality built into python that did it in a couple easy to read lines.</span>
<span class="comment-copy">@user177955 Quick and dirty: <code>print re.match(string.replace(")",").").replace("(",".("), string).groups()[0::4]</code>. Sorry I couldn't resist it: the string looked way too much like a regex, that I made it into a regex. :P That being said, you should really write your own stack or follow something like what utkarsh said.</span>
<span class="comment-copy">@SuperSaiyan Sure, for any string there exists an arbitrarily complicated RE that will do the job :-P</span>
<span class="comment-copy">yeah my answer ... is not quite as pretty .. nice work man</span>
<span class="comment-copy">@poke. Thanks for writting up utkarsh13 and  Vaibhav Bajaj's comments. I do have a mini question how does <code>for i,c in enumerate(string)</code> work?</span>
<span class="comment-copy">@user177955 Iterating over <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate(x)</code></a> will give you a two-tuple on each iteration with the index in addition to the value of the iterable. So instead of getting just every character from the string, we get the character paired with its index in the string.</span>
<span class="comment-copy">I didn't downvote. But regex is just not a tool for places where a stack is needed. I should be ashamed for having proposed the same in comments too (but it was just for fun ;))</span>
<span class="comment-copy">afaik there is some builtin regexp package (literally <code>import regexp</code> I think) that has extended support for things needing a stack .... afaik ... I still dont approve of regex for this solution imho)</span>
<span class="comment-copy">@JoranBeasley this is less of "you should use this blindly since it's regex and it's good" and more proof the statement "regular expressions are <b>obviously</b> not up to this task" is completely wrong, as they <i>can</i> do it.</span>
<span class="comment-copy">I can give you a string that breaks that regex im pretty sure ... the look ahead look around stuff makes it hard to guess (I certainly didnt downvote and if regex works then great :P)</span>
<span class="comment-copy">consider <code>"((((this is (haha) a string((a(s)d)and ((it's sneaky))))))) ipsom (lorem) bla"</code> ... unless you 100% know for sure the maximum nesting depth ... and even then the regex gets pretty ugly</span>
