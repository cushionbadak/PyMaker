<div class="post-text" itemprop="text">
<p>i have this problem where i sort a list based on randomness. how the algorithm works is two select a random number between 0 to N-1 (N is length of list) and swap with a iterating index.</p>
<p>i have two different algorithms like this.</p>
<pre><code>import random

def algo1(xx):
    for i in xrange(len(xx)):
        p = random.randrange(i, len(xx))  # random number between i and len(xx) - 1
        xx[i], xx[p] = xx[p], xx[i]
    return xx

def algo2(yy):
    for i in xrange(len(yy)):
        p = random.randrange(0, len(yy))  # random number between 0 and len(xx) - 1
        yy[i], yy[p] = yy[p], yy[i]
    return yy


k = range(5)
print algo1(k) 
print algo2(k)
</code></pre>
<p>here everything works fine. i print the return values from algo1 and algo2.</p>
<p>But when i store the return values in variables</p>
<pre><code>z1 = algo1(k)
z2 = algo2(k)
print z1
print z2
</code></pre>
<p>they both contain the same list. how many times i run they show the same return values</p>
<p>see this video <a href="https://www.youtube.com/watch?v=ZBjlnaCLKsQ&amp;feature=youtu.be" rel="nofollow">https://www.youtube.com/watch?v=ZBjlnaCLKsQ&amp;feature=youtu.be</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Your function alters <code>k</code> and returns a reference to it. There is no new <code>list</code> being created.</p>
<p>The difference in what you are seeing is:</p>
<ul>
<li><p>When you <strong>print</strong>, you show the <em>current state</em> of what <code>algoX</code> has returned (which is a reference to <code>k</code>).</p></li>
<li><p>When you <strong>assign</strong> the result, you set <code>z1</code> and <code>z2</code> to a reference of <code>k</code>, meaning <code>z1 is z2 is k</code>. And you only print after, when you finished manipulating <code>k</code>. That's why you see the <em>same result</em>, all theses 3 variables have the <em>same reference</em> to the same list.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You are modifying the list (I am assuming youâ€™re on python 2.7) in place. Thus, when you shuffle the <code>k</code> with <code>algo2</code>, you are also affecting <code>z1</code>. All three lists are really the same object. You need to create a list copy, for example <code>algo1(k[:])</code>.</p>
<p>I would also take a look at <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow"><code>random.shuffle</code></a>, which does pretty much the thing you want. Note that <code>random.shuffle</code> also modifies the input in place, so you will need <code>[:]</code> too.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you're passing, modifying and returning the same variable (list) <code>k</code> to both functions, you're modifying the same data each time.</p>
<p>Try using:</p>
<pre><code>print("z1", id(z1))
print("z2", id(z2))
print("k", id(k))
</code></pre>
<p>This will return the identity of the variable. You'll notice that z1, z2 and k all have the same identity.</p>
<p>In the first case, you're printing the output directly, before calling the next function. This is why you didn't notice this behaviour.</p>
<p>However, when you're assigning the return variable, saving it and then printing it, you'll notice the issue.</p>
<p>To resolve it, instead of modifying the list that you've passed into the function, create a new list inside of the function, assign the values to it and return that list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>z1 = algo1(k)
print z1
z2 = algo2(k)
print z2
print z1
print k
</code></pre>
<p>You are simply overwrite the same list. Google for "python Immutable vs Mutable types" to understand this behaviour.</p>
</div>
<span class="comment-copy">I don't understand what you are doing with range(5) being passed to your functions.  The for loop takes the length of range(5) which is just 5, so your loop could have been 'for i in xrange(5):`</span>
<span class="comment-copy">Move the print z1 between the calls and it works again ... no seriously, <code>assert id(z1) == id(z2)</code> will show, these names point to the same list, and thus only keep the last modification. Change the functions or wrap these in a list constructor like: <code>z1 = list(algo1(k))</code> or make a slice copy like <code>z1 = algo1(k)[:]</code> - these methods should all fix cause or symptom ;-)</span>
