<div class="post-text" itemprop="text">
<p>So I did a stupid thing, and forgot to explicitly type-convert some values I was putting into an SQLite database (using Python's SQLalchemy). The column was set up to store an <code>INT</code>, whereas the input was actually a <code>numpy.int64</code> dtype.</p>
<p>The values I am getting back out of the database look like:</p>
<p><code>b'\x15\x00\x00\x00\x00\x00\x00\x00'</code></p>
<p>It seems that SQLite has gone and stored the binary representation for these values, rather than the integer itself.</p>
<p>Is there a way to decode these values in Python, or am I stuck with loading all my data again (not a trivial exercise at this point)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/struct.html#struct.unpack" rel="nofollow"><code>struct.unpack()</code></a>:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; value = struct.unpack('&lt;q', b'\x15\x00\x00\x00\x00\x00\x00\x00')
&gt;&gt;&gt; value
(21,)
&gt;&gt;&gt; value[0]
21
</code></pre>
<p>That assumes that the data was stored little endian as specified by the <code>&lt;</code> in the <code>unpack()</code> format string, and that it is a signed "long long" (8 bytes) as specified by the <code>q</code>. If the data is big endian:</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;q', b'\x15\x00\x00\x00\x00\x00\x00\x00')
(1513209474796486656,)
</code></pre>
<p>I imagine that little endian is more likely to be correct in this case.</p>
<p>P.S. I have just confirmed that when a <code>numpy.int64</code> is inserted into a SQLite <code>int</code> field it can be retrieved using <code>struct.unpack()</code> as shown above.</p>
</div>
<span class="comment-copy">Thank you, that works a charm. The data was indeed little endian.</span>
