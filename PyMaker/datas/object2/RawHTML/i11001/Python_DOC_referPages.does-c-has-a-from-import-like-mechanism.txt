<div class="post-text" itemprop="text">
<p>I've read <a href="https://docs.python.org/3/reference/import.html" rel="nofollow">here</a> about importing a module in python. There is an option to not import a whole module (e.g. sys) and to only import a part of it (e.g. sys.argv). Is that possible in C? Can I include only the implementation of printf or any other function instead of the whole stdio.h library?</p>
<p>I ask this because it seems very inefficient to include a whole file where I need only several lines of code.</p>
<p>I understand that there is a possibility that including only the function itself won't work because it depends on other functions, other includes, defines, and globals. I only ask in order to use this for whole code blocks that contain all the data that are needed in order to execute.</p>
</div>
<div class="post-text" itemprop="text">
<p>C does not have anything that is equivalent to, or even similar to Python's "from ... import" mechanism.</p>
<blockquote>
<p>I ask this because it seems very inefficient to include a whole file where I need only several lines of code.</p>
</blockquote>
<p>Actually, what <em>normally</em> happens when you <code>#include</code> a file is that you import the declarations for macros, or functions declared somewhere else.  You don't import any executable code ... so the "unnecessary" inclusions have ZERO impact on runtime code size or efficiency.</p>
<p>If you <em>use</em> (i.e. "call") a macro, then that causes the macro body to expanded, which adds to the executable code size.  </p>
<p>If you call a function whose declaration you have included, that will add the code ... for the call statement itself.  The function does not expanded though.  Instead, an "external reference" is added to your ".o" file, which the loader resolves when you create the executable from the ".o" files and the dependent libraries.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python</strong>:  "<em>There is an option to not import a whole module</em>" : I think you misunderstand what is going on here.  When you specify the names to import, it means that only those <em>names</em> go into you namespace.  The "whole" module is compiled, and any code outside functions is run, even when you specify just one name.</p>
<p><strong>C</strong>:  I am going to assume that you are using an operating system like UNIX/Linux/OS X or Windows (the following does not apply to embedded systems).  </p>
<p>The closest C has to <code>import</code> is dynamic runtime linking.  That is not part of standard C, it is defined by the operating system.  So POSIX has one mechanism and Windows has another.  Most people call these library files "DLLs", but strictly speaking that is a Microsoft term, they are "shared objects" (.so) on UNIX type systems.</p>
<p>When a process attaches to a DLL or .so then it is "mapped" into the virtual memory of the process.  The detail here varies between operating systems, but essentially the code is split into "pages", the size of which varies, but 4kb for 32-bit systems and 16kb for 64-bit is typical.  Only those pages that are required are loaded into memory.  When a page is required then a so-called "page-fault" occurs and the operating system will get the page from either the executable file or the swap area (depending on the OS).</p>
<p>One of the advantages of this mechanism is that code pages can be shared between processes.  So if you have 50 processes all using the same DLL (like the C run-time library, for example), then only <em>one</em> copy is actually loaded into memory.  They all share the one set of pages (they can because they are read-only).  </p>
<p>There is no sharing mechanism like that in Python - unless the module is itself written in C and is a DLL (.pyd).</p>
<p>All this occurs without the knowledge of the program.</p>
<p>EDIT:  looking at other's answers I realise you might be thinking of the <code>#include</code> pre-processor directive to merge a header file into the source code.  Assuming these are standard header files, then they make no difference to the size of your executable, they should be "<em>idempotent</em>".  That is, they only contain information of use by the pre-processor, compiler, or linker.  If there are definitions in the header file that are not used there should be no side effect.</p>
<p>Linking libraries (-l directive to the compiler) that are not used will make the executable larger, which makes the page tables larger, but aside from that if they are not used then they shouldn't make any significant difference.  That is because of the on-demand page-loading described above (the concept was invented in the 1960s in Manchester UK).</p>
</div>
<span class="comment-copy">I don't follow - isn't it true that the .o file or the .exe file will be bigger when including stdio than if writing printf myself in the top of my file</span>
<span class="comment-copy">No.  It isn't true.  (Well, it might add some more symbols to the debugger symbol table, but that does not affect the executable code size.)</span>
<span class="comment-copy">The executable code size is not directly proportional to the amount of memory used.  Only the required pages are loaded into RAM, then again a tiny program can do <code>malloc</code> all over the place, and a recursive function can result in a huge call-stack.</span>
<span class="comment-copy">@cdarke - A program's runtime stack (and heap) storage usage is nothing to do with its code size.  The executable code size I am / we are talking about here is the memory used to hold the executable instructions.  Nothing else.  Sure, a program uses other kinds of memory ... but that is not relevant to what we are discussing here; i.e. the effects of a <code>#include</code> directive.</span>
<span class="comment-copy">Since you asked about <code>stdio.h</code>, that is part of the C run-time, which will be shared by other processes.  The '#include` directive is used by the preprocessor, it is totally irrelevant to the size of the executable and the amount of memory used at runtime.  Even if it did, the C runtime library will be shared - unless you are doing static linking (you don't mention what type of linking you are doing).  Even if you use static linking, then only those code pages required will be loaded into RAM, and that will vary depending on the load on the machine at runtime.</span>
<span class="comment-copy">@cdrake thanks for the python explanation. I indeed didn't understand correctly. About C: when including stdio.h - is it linked to my code? if so, won't it be more efficient (less page consumption) to write my own h file with minimal size?</span>
<span class="comment-copy">See my edit.  <code>stdio.h</code> is not a library, it is a header file that is merged into your source code.  The code itself is part of the C runtime library.  The sharing mechanism means that this will <i>probably</i> be already loaded and shared in virtual memory by a large number of other processes.  Writing your own smaller version will have no effect - and might well introduce new bugs.</span>
