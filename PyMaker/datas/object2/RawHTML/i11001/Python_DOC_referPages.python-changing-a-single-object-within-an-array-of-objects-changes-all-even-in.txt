<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/12791501/python-initializing-a-list-of-lists">Python initializing a list of lists [duplicate]</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I've got a one type of object, <code>data_entry</code>, that has a 2-dimensional array of other objects, <code>time_entry</code>.</p>
<p>Initialization of  time_entries the array within <code>data_entry</code> looks like this:</p>
<pre><code>[([time_entry()] * 12) for i in range(5)]
</code></pre>
<p>and initialization of the <code>data_entry</code> looks like this:</p>
<pre><code>thing = data_entry()
</code></pre>
<p>Now, I have a list of "things", each which contains it's own 2d array of <code>time_entry</code>s.</p>
<p>Each <code>time_entry</code> has a list as one of it's attributes, initialized like so:</p>
<pre><code>attributes = []
</code></pre>
<p>I modify attributes by extending it using <code>.extend()</code>.</p>
<p>However, the problem I run into when I do this is EVERY single <code>time_entry</code> object in EVERY single <code>data_entry</code> object gets extended.</p>
<p>I know problems like this can arise from improper initialization of objects, so I'm wondering if perhaps my object creations are poor or there  is another python quirk I am unaware of.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are performing the initialization on the class, it will affect all instances of the class. If that’s the case, this is not a result of it being in a list, but of it being on the class. For example:</p>
<pre><code>#!/usr/bin/python

class BedrockDenizen():
    attributes = []


wilma = BedrockDenizen()
fred = BedrockDenizen()

wilma.attributes.extend(['thin', 'smart'])
fred.attributes.extend(['fat', 'stupid'])

print 'Wilma:', wilma.attributes
print 'Fred:', fred.attributes
</code></pre>
<p>You will see that both Fred and Wilma are thin, smart, fat, and stupid.</p>
<blockquote>
<p>Wilma: ['thin', 'smart', 'fat', 'stupid']</p>
<p>Fred: ['thin', 'smart', 'fat', 'stupid']</p>
</blockquote>
<p>One way to fix this is to put the attribute creation into the <strong>init</strong> method, so that the attribute is per-instance:</p>
<pre><code>class BedrockDenizen():
    def __init__(self):
        self.attributes = []
</code></pre>
<p>With that change, only Wilma is thin and smart, and only Fred is fat and stupid.</p>
<blockquote>
<p>Wilma: ['thin', 'smart']</p>
<p>Fred: ['fat', 'stupid']</p>
</blockquote>
<p>You may also need to show us more code. @Bakuriu notes that the problem may be that you are only creating one instance, and he may be right. For example, if this is closer to your code:</p>
<pre><code>class BedrockDenizen():
    def __init__(self):
        self.attributes = []

neighborhood = [([BedrockDenizen()] * 2) for i in range(2)]

flintstones, rubbles = neighborhood
fred, wilma = flintstones

wilma.attributes.extend(['thin', 'smart'])
fred.attributes.extend(['fat', 'stupid'])

print 'Wilma:', wilma.attributes
print 'Fred:', fred.attributes
</code></pre>
<p>Then Fred and Wilma will continue to have the same attributes, because they aren’t really separate people. You may wish to use code more like this:</p>
<pre><code>class BedrockDenizen():
    def __init__(self):
        self.attributes = []

neighborhood = [[BedrockDenizen() for n in range(2)] for i in range(2)]

flintstones, rubbles = neighborhood
fred, wilma = flintstones

wilma.attributes.extend(['thin', 'smart'])
fred.attributes.extend(['fat', 'stupid'])

print 'Wilma:', wilma.attributes
print 'Fred:', fred.attributes
</code></pre>
<p>That depends on what your needs are, though, as it seems like an odd way of doing things without more info.</p>
</div>
<div class="post-text" itemprop="text">
<p>This sounds like your attributes all point to the same list object inside. Then you call extend on the <strong>same object</strong> every time and modify it.</p>
<p>This is a common issue and discussed at
<a href="https://docs.python.org/3/faq/programming.html#how-do-i-create-a-multidimensional-list" rel="nofollow noreferrer">https://docs.python.org/3/faq/programming.html#how-do-i-create-a-multidimensional-list</a> and <a href="https://stackoverflow.com/questions/7255383/python-list-append-behavior">Python list append behavior</a></p>
</div>
<span class="comment-copy">can you post a minimal working example?</span>
<span class="comment-copy">Also see <a href="http://stackoverflow.com/questions/240178/python-list-of-lists-changes-reflected-across-sublists-unexpectedly" title="python list of lists changes reflected across sublists unexpectedly">stackoverflow.com/questions/240178/…</a></span>
<span class="comment-copy">I am afraid the answer to that question solves a different problem.</span>
<span class="comment-copy">This is a <b>different, unrelated</b> issue. I don't see any <code>[object] * number</code> in this code which is what is causing OP's problems.</span>
<span class="comment-copy">@JerryStratton: No, <code>[object] * n</code> creates a list of <code>n</code> entries, all of which are the same object. It doesn't make new objects.</span>
<span class="comment-copy">Yea I think this might be right. Give it a try OP</span>
<span class="comment-copy">Yes, I was misreading your comment, @Bakuriu. But I still think that the OP’s problem occurs with the “extend”. I could be wrong, though. I’ve added a new option to the answer.</span>
<span class="comment-copy">This seems to have been the problem - attributes was was initialized within the class rather than in the constructor.  Thanks!</span>
