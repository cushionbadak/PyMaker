<div class="post-text" itemprop="text">
<p>I have a list of lists. Each sublist has a length that varies between 1 and 100. Each sublist contains a particle ID at different times in a set of data. I would like to form lists of all particle IDs at a given time. To do this I could use something like:</p>
<pre><code>    list = [[1,2,3,4,5],[2,6,7,8],[1,3,6,7,8]]
    list2 = [item[0] for item in list]
</code></pre>
<p>list2 would contain the first elements of each sublist in list. I would like to do this operation not just for the first element, but for every element between 1 and 100. My problem is that element number 100 (or 66 or 77 or whatever) does not exists for every sublist.</p>
<p>Is there some way of creating a lists of lists, where each sublist is the list of all particle IDs at a given time.</p>
<p>I have thought about trying to use numpy arrays to solve this problem, as if the lists were all the same length this would be trivial. I have tried adding -1's to the end of each list to make them all the same length, and then masking the negative numbers, but this hasn't worked for me so far. I will use the list of IDs at a given time to slice another separate array:</p>
<pre><code>    pos = pos[satIDs]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>lst = [[1,2,3,4,5],[2,6,7,8],[1,3,6,7,8]]
func =  lambda x: [line[x] for line in lst if len(line) &gt; x]

func(3)
[4, 8, 7]
func(4)
[5, 8]
</code></pre>
<p>--update--</p>
<pre><code>func =  lambda x: [ (line[x],i) for i,line in enumerate(lst) if len(line) &gt; x]
func(4)
[(5, 0), (8, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow"><code>itertools.zip_longest</code></a>. This will <code>zip</code> the lists together and insert <code>None</code> when one of the lists is exhausted.</p>
<pre><code>&gt;&gt;&gt; lst = [[1,2,3,4,5],['A','B','C'],['a','b','c','d','e','f','g']]    
&gt;&gt;&gt; list(itertools.zip_longest(*lst))
[(1, 'A', 'a'),
 (2, 'B', 'b'),
 (3, 'C', 'c'),
 (4, None, 'd'),
 (5, None, 'e'),
 (None, None, 'f'),
 (None, None, 'g')]
</code></pre>
<p>If you don't want the <code>None</code> elements, you can filter them out:</p>
<pre><code>&gt;&gt;&gt; [[x for x in sublist if x is not None] for sublist in itertools.zip_longest(*lst)]
[[1, 'A', 'a'], [2, 'B', 'b'], [3, 'C', 'c'], [4, 'd'], [5, 'e'], ['f'], ['g']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want it with a <code>one-line forloop</code> and in an <code>array</code> you can do this:</p>
<pre><code>list2 = [[item[i] for item in list if len(item) &gt; i] for i in range(0, 100)]
</code></pre>
<p>And if you want to know which id is from which list you can do this:</p>
<pre><code>list2 = [{list.index(item): item[i] for item in list if len(item) &gt; i} for i in range(0, 100)]
</code></pre>
<p>list2 would be like this:</p>
<pre><code>[{0: 1, 1: 2, 2: 1}, {0: 2, 1: 6, 2: 3}, {0: 3, 1: 7, 2: 6}, {0: 4, 1: 8, 2: 7},
 {0: 5, 2: 8}, {}, {}, ... ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could append <code>numpy.nan</code> to your short lists and afterwards create a numpy array</p>
<pre><code>import numpy
import itertools

lst = [[1,2,3,4,5],[2,6,7,8],[1,3,6,7,8,9]]
arr = numpy.array(list(itertools.izip_longest(*lst, fillvalue=numpy.nan)))
</code></pre>
<p>Afterwards you can use numpy slicing as usual.</p>
<pre><code>print arr
print arr[1, :]   # [2, 6, 3]
print arr[4, :]   # [5, nan, 8]
print arr[5, :]   # [nan, nan, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Approach #1</strong></p>
<p>One almost* vectorized approach could be suggested that goes along creating ID based on the new order and splitting, like so -</p>
<pre><code>def position_based_slice(L):

    # Get lengths of each element in input list
    lens = np.array([len(item) for item in L])

    # Form ID array that has *ramping* IDs within an element starting from 0
    # and restarts with a new element at 0
    id_arr = np.ones(lens.sum(),int)
    id_arr[lens[:-1].cumsum()] = -lens[:-1]+1

    # Get order maintained sorted indices for sorting flattened version of list
    ids = np.argsort(id_arr.cumsum(),kind='mergesort')

    # Get sorted version and split at boundaries decided by lengths of ids
    vals = np.take(np.concatenate(L),ids)
    cut_idx = np.where(np.diff(ids)&lt;0)[0]+1
    return np.split(vals,cut_idx)
</code></pre>
<p>*There is a loop comprehension involved at the start, but being meant to collect just the lengths of the input elements of the list, its effect on the total runtime should be minimal. </p>
<p>Sample run -</p>
<pre><code>In [76]: input_list = [[1,2,3,4,5],[2,6,7,8],[1,3,6,7,8],[3,2]]

In [77]: position_based_slice(input_list)
Out[77]: 
[array([1, 2, 1, 3]), # input_list[ID=0]
 array([2, 6, 3, 2]), # input_list[ID=1]
 array([3, 7, 6]),    # input_list[ID=2]
 array([4, 8, 7]),    # input_list[ID=3]
 array([5, 8])]       # input_list[ID=4]
</code></pre>
<p><strong>Approach #2</strong></p>
<p>Here's another approach that creates a <code>2D</code> array, which is easier to index and trace back to original input elements. This uses NumPy broadcasting alongwith boolean indexing. The implementation would look something like this -</p>
<pre><code>def position_based_slice_2Dgrid(L):

    # Get lengths of each element in input list
    lens = np.array([len(item) for item in L])

    # Create a mask of valid places in a 2D grid mapped version of list
    mask = lens[:,None] &gt; np.arange(lens.max())
    out = np.full(mask.shape,-1,dtype=int)
    out[mask] = np.concatenate(L)
    return out
</code></pre>
<p>Sample run -</p>
<pre><code>In [126]: input_list = [[1,2,3,4,5],[2,6,7,8],[1,3,6,7,8],[3,2]]

In [127]: position_based_slice_2Dgrid(input_list)
Out[127]: 
array([[ 1,  2,  3,  4,  5],
       [ 2,  6,  7,  8, -1],
       [ 1,  3,  6,  7,  8],
       [ 3,  2, -1, -1, -1]])
</code></pre>
<p>So, now each column of the output would correspond to your ID based outputting.</p>
</div>
<span class="comment-copy">Do you want to do this with one line for loop? or any for loop would do?</span>
<span class="comment-copy">Any loop will do, however the dataset is quite large so speed could be an issue.</span>
<span class="comment-copy">"masking the negative numbers, but this hasn't worked for me so far" - How didn't that work out for you?</span>
<span class="comment-copy">Excellent thanks, is there also a way to track which element in func(x) came from which list e.g. an addtional list which says that (for func(4)), 5 came from sublist 0 and 8 came from sublist 2?</span>
<span class="comment-copy">... what's the point of using a <code>lambda</code> and then assigning it to a name? Just use <code>def func(x): return [line [x] ...]</code>.</span>
<span class="comment-copy">@Jack updated. the first element in tuple is value and second is number of sublist</span>
<span class="comment-copy">@Bakuriu agree with you</span>
<span class="comment-copy">If I did a slice in this way, would I be able to tell which row each element in my sliced array had come from? I.e. would it keep the nans?</span>
<span class="comment-copy">Yes of course. whenever you run past the end of any of the lists that entry becomes a <code>nan</code>.</span>
<span class="comment-copy">But would I then be able to use the slice array, eg x = [nan,nan,9] to perform a slice of another array, data[x] - would this not give me an error? IndexError: arrays used as indices must be of integer (or boolean) type</span>
<span class="comment-copy">You are trying to use the resulting list as indices? Sorry I didn't read that in your post.</span>
