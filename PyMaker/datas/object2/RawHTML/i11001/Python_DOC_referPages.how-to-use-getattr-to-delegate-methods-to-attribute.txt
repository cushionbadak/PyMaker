<div class="post-text" itemprop="text">
<p>I have the following class:</p>
<pre><code>class MyInt:
    def __init__(self, v):
        if type(v) != int:
            raise ValueError('value must be an int')
        self.v = v

    def __getattr__(self, attr):
        return getattr(self.v, attr)

i = MyInt(0)
print(i + 1)
</code></pre>
<p>I get the error: <code>TypeError: unsupported operand type(s) for +: 'MyInt' and 'int'</code></p>
<p>Shouldn't <code>i.__add__(1)</code> be called? And shouldn't <code>__getattr__</code> be called when no such method is found in the <code>MyInt</code> class?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__getattr__</code> cannot be used to generate other magic methods. You'll need to implement all of them individually.</p>
<p>When the Python language internals look up magic methods like <code>__add__</code>, they completely bypass <code>__getattr__</code>, <code>__getattribute__</code>, and the instance dict. The lookup goes roughly like</p>
<pre><code>def find_magic_method(object, method_name):
    for klass in type(object).__mro__:
        if method_name in klass.__dict__:
            return klass.__dict__[method_name]
    raise AttributeError
</code></pre>
<p>If you want to see the exact lookup procedure, it's <code>_PyObject_LookupSpecial</code> in <a href="https://hg.python.org/cpython/file/2.7/Objects/typeobject.c#l1244" rel="nofollow"><code>Objects/typeobject.c</code></a>.</p>
<p>If you're wondering why Python does this, there are a lot of magic methods for which it would be really awkward or impossible to do what you were expecting. For example, Python couldn't possibly use <code>__getattribute__</code> to look up <code>__getattribute__</code>, as that would cause infinite recursion with no base case.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the <code>__getattribute__()</code> method even of the objectâ€™s metaclass</a></span>
<span class="comment-copy">The difference between the real lookup and that python code is that the above python code could be manipulated using meta-classes to provide a custom <code>__dict__</code>, while the real lookup bypasses even the metaclass and accesses the <code>__dict__</code> mapping via the direct field in the underlying C structure.</span>
<span class="comment-copy">That's a long file, could you give me a line number or function name please?</span>
<span class="comment-copy">@JonMcClung: The link goes right to the function, and I did say the function name is <code>_PyObject_LookupSpecial </code>. Most of the helpers it relies on are in the same file, so you should be able to find them with Ctrl-F.</span>
<span class="comment-copy">My bad. I scrolled around before it finished loading, causing it to end up in the wrong place.</span>
