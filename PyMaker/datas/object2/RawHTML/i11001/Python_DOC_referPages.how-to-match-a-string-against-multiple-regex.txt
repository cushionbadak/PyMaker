<div class="post-text" itemprop="text">
<p>At the moment I am using the below filter to increment elements in arr, given a list of strings as an argument, is there an efficient way to do this in python.I got millions of such lists to validate upon.</p>
<pre><code>  def countbycat(tempfilter):
        arr=[0,0,0,0,0]
        apattern,dpattern,mpattern,upattern,tpattern = re.compile("^[a]--*"),re.compile("^[d]--*"),re.compile("^[m]--*"),re.compile("^[u]--*"),re.compile("^[t]--*")
        for each in tempfilter:
            if upattern.match(each):
                 arr[0]+=1
            elif mpattern.match(each):
                 arr[1]+=1
            elif dpattern.match(each):
                 arr[2]=1
            elif apattern.match(each):
                 arr[3]+=1
            elif tpattern.match(each):
                 arr[4]+=1
        return arr  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the regular expressions given in the question, you can use following regular expression using character class:</p>
<pre><code>[admut]-
</code></pre>
<ul>
<li><code>[admut]</code> will match any of <code>a</code>, <code>d</code>, <code>m</code>, <code>u</code>, <code>t</code></li>
<li><code>^</code> can be omitted because <code>re.match</code> matches only at the beginning of the string.</li>
<li>removed <code>-*</code> because it's pointless; only one <code>-</code> is enough to check <code>-</code> appear after the <code>a/d/m/u/t</code>.</li>
</ul>
<p>And instead of using array, you can use a dictionary; no need to remember indexes:</p>
<pre><code>def countbycat(tempfilter):
    count = dict.fromkeys('admut', 0)
    pattern = re.compile("[admut]-")
    for each in tempfilter:
        if pattern.match(each):
            count[each[0]] += 1
    return count
</code></pre>
<p>Instead of <a href="https://docs.python.org/3/library/stdtypes.html#dict.fromkeys" rel="nofollow"><code>dict.fromkeys</code></a>, you can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use regex for this. You are checking for a very specific, fixed condition. Namely, <code>each[1] == '-'</code>  and <code>each[0] in 'admut'</code>. Both of these are <em>much</em> faster than regex. The later can also be used as a mapping.</p>
<pre><code>def countbycat(tempfilter):
  arr = [0, 0, 0, 0, 0]
  char_idx = {  # map admit to indices
    'u': 0,
    'm': 1,
    'd': 2,
    'a': 3,
    't': 4,
    }
  for each in tempfilter:
    if each[1] == '-':  # detect trailing -
      try:
        arr[char_idx[each[0]]] += 1  # increment position pointed to by admut
      except KeyError:  # each[0] not any of admut
        pass
  return arr  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your simple case, go for <a href="https://stackoverflow.com/a/38161411/3821804">falsetru's answer</a></p>
<p>In general case, you can combine your patterns into one regex (provided that your regexes doesn't contain capturing groups), and check which wart of regex matched:</p>
<pre><code>patterns = ["^[a]-+", "^[d]-+", "^[m]-+", "^[u]-+", "^[t]-+"]

complex_pattern = re.compile('|'.join(['(%s)' % i for i in patterns]))

# imperative way

arr = [0, 0, 0, 0, 0]

for each in tempfilter:
    match = complex_pattern.match(each)
    if match:
        arr[match.lastgroup + 1] += 1

return arr

# functional way

from collections import Counter

matches_or_none = (complex_pattern.match(each) for each in tempfilter)

return Counter(match.lastgroup + 1 for match in matches_or_none if match is not None)
</code></pre>
</div>
<span class="comment-copy">If you have millions of strings but only five regexes, you question should be "match multiple strings to a regex", not visa versa.</span>
<span class="comment-copy">You shouldn't use regex for this in the first place. It's not needed. Regular string comparisons and lookups give the same functionality.</span>
<span class="comment-copy">The <code>+</code> in the regex is pointless here, right?</span>
<span class="comment-copy">@StefanPochmann, I used <code>-+</code> instead of <code>--*</code> because it's shorter and more expressive than the other: Both will match one or more <code>-</code>.  (<code>--*</code>: match <code>-</code> and 0 or more <code>-</code>), (<code>-+</code>: match 1 or more <code>-</code>); both matches same things.</span>
<span class="comment-copy">Yeah I know. But that doesn't answer my question...</span>
<span class="comment-copy">I think you can safely remove the <code>+</code>. It doesn't do anything good here and only slows things down. And since this question is about efficiency...</span>
<span class="comment-copy">You can make it a bit faster by using <code>match = re.compile("[admut]-").match</code> and then <code>if match(each):</code>. I tested <code>timeit(lambda: pattern.match(each))</code> and <code>timeit(lambda: match(each))</code> and the latter was about 10% faster for the words I tested.</span>
<span class="comment-copy">How much faster?</span>
<span class="comment-copy"><code>each[1]</code> will raise <code>IndexError</code> if a <code>len(each) &lt;= 1</code>. <code>each[0]</code> .. same for empty string.</span>
<span class="comment-copy">@falstrue It will also raise <code>TypeError</code> if <code>each</code> is an integer. oO I'm assuming all of the possibly infinite cases of required input sanitization are performed.</span>
<span class="comment-copy">@StefanPochmann <code>each[1] == "-"</code> takes 0.0639 usec, <code>char_idx[each[0]]</code> takes 0.0672 usec, <code>pat.match(each)</code> (from <code>re.compile</code>) takes 1.41 usec. So, roughly 10 times faster. Tested with python3.4.3.</span>
<span class="comment-copy">If strings with length less than 2 are a concern, you can add check <code>len(each) &gt; 2</code>.</span>
<span class="comment-copy">For this simple case, there's no need to use regex at all. ;)</span>
