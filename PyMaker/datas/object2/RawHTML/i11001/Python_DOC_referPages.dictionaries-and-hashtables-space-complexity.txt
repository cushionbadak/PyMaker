<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/327311/how-are-pythons-built-in-dictionaries-implemented">How are Python's Built In Dictionaries Implemented</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I have some confusion over dictionaries and hash tables that I wanted to clarify .Suppose I have the current dictionary and the current output of the hashes of the current python run.</p>
<pre><code>Dict = dict()
print(hash('a'))
print(hash('b'))
print(hash('c'))
Dict['a'] = 1
Dict['b'] = 2
Dict['c'] = 3
print(Dict)
</code></pre>
<p>has the output of</p>
<pre><code>1714333803
1519074822
1245896149
{'a': 1, 'c': 3, 'b': 2}
</code></pre>
<p>So to my knowledge a hashtable is simply an array where the hash is the index of the hashtable. For instance, 'a' had a hash of 1714333803, therefore my hashtable index 1714333803 has a value of 'a'. So im confused how many indexes a hashtable has and how the hash function produces the answer? Does it use modulus and have a fixed range of indexes? Because the given print of the dictionary outputs <code>{'a': 1, 'c': 3, 'b': 2}</code>, but is it correct to assume that eventhough it outputs that, the dictionary is actually an array of atleast 1714333803 indexes, because that seems ridiculously overkill to contain 3 elements and not to mention how much of a waste of space it is. Also for the hashtable, what is in the indexes that has no value, null?</p>
</div>
<div class="post-text" itemprop="text">
<p>The actual size of the <code>dict</code> depends on the implementation, but in your case, it is probably 8. So, how does this work?</p>
<p>The working principle of a <code>dict</code> (or hash map in general) is to calculate a numerical hash for every key. In your case, that's <code>hash("a") == 1714333803</code>, for example. Now, the hash isn't used directly as an index. Instead, it is mapped to the size of the dictionary.</p>
<p>A simple method to do this is modulo (<code>%</code>). Let's say your <code>dict</code> is 8 in size. Then <code>hash("a") % 8 == 1714333803 % 8 == 3</code>. So your item is actually at the 4th position. By construction of the lookup algorithm, no item can ever have an index outside the array.</p>
<p>There are some more complex things here, like hash collisions. For example, if another item has hash <code>98499</code>, that <em>also</em> maps to <code>3</code>. There are collision resolution strategies which pick a different index in this case. They mostly try to uniformly walk the array in large strides.</p>
<p>So, why is your <code>dict</code> of size 8? Because that's the <a href="https://hg.python.org/releasing/2.7.9/file/tip/Objects/dictnotes.txt#l77" rel="nofollow noreferrer">default size in python</a>. Once your <code>dict</code> get's too small, it must be resized. In contrast to arrays, this is done before the <code>dict</code> is actually full - namely, at <a href="https://hg.python.org/releasing/2.7.9/file/tip/Objects/dictnotes.txt#l84" rel="nofollow noreferrer">two thirds filling</a>. This is done to reduce hash collisions - if your <code>dict</code> is 99% full, a collision is practically guaranteed. For a size 8 dict, you'd have to enter 5-6 items before it resizes, namely <a href="https://hg.python.org/releasing/2.7.9/file/tip/Objects/dictnotes.txt#l94" rel="nofollow noreferrer">doubles its capacity</a> to 16.</p>
<hr/>
<p>Note that <a href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation)" rel="nofollow noreferrer">CPython 3.6+</a> and <a href="https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html" rel="nofollow noreferrer">PyPy (for a long time)</a> use a <a href="https://mail.python.org/pipermail/python-dev/2012-December/123028.html" rel="nofollow noreferrer">two-stage data structure</a> for <code>dict</code>. The first stage is a hashtable, but the second stage is not. This splits up the key mapping (stage one) and data storage (stage two). The sparse first stage provides the index for the tightly packed second stage:</p>
<pre><code># based on Raymond Hettingers mail on python-dev
# the key mapping, using a hashtable
# indices[hash(key) % length] =&gt; data index
indices =  [None, None, None, 0, None, 2, 1, None]

# the data storage, packed in insertion order
# entries[index] =&gt; hash(key), key, value
entries =  [[1714333803, 'a', 1],
            [1519074822, 'b', 2],
            [1245896149, 'c', 3]]
</code></pre>
<p>This scheme is algorithmically more complex for lookups (due to the indirection) but less so for iteration (directly on the data storage) and more memory efficient. Only the index table is sparse and needs to be oversized. The data storage is exactly as large as needed, unless items are deleted.</p>
</div>
<span class="comment-copy">You can resize dynamically the array. However it will have to recalculate the hash for every key. This link looksinteresting <a href="http://www.laurentluce.com/posts/python-dictionary-implementation/" rel="nofollow noreferrer">laurentluce.com/posts/python-dictionary-implementation</a></span>
<span class="comment-copy">What do you mean by 'indexes that has no value, null'? Keys that don't have a hash? Or positions in the array that have not been filled?</span>
<span class="comment-copy">See this video, too: <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68" rel="nofollow noreferrer">youtube.com/watch?v=C4Kc8xzcA68</a></span>
<span class="comment-copy">Indeed, I think it is implemented using bitwise-and: <code>hash(key) &amp; of (size - 1)</code>, in effect, taking the "last" three bits (if size == 8), if I understand correctly.</span>
