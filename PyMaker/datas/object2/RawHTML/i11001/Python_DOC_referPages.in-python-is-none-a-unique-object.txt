<div class="post-text" itemprop="text">
<p>In my test code, why the <code>print</code> results for tuple and None are different? It seems that a, b point to the same object <code>None</code>, but c, d point to different objects, though their values are the same (both equal to <code>(a,b)</code>). </p>
<p>I know that <code>is</code> keyword checks for the object lying behind rather than just compares value like <code>==</code>. And here I use tuple because I think tuple is immutable so that at least it's not a matter of whether the object is mutable or immutable.</p>
<p>But why variables a, b don't create and point to two different <code>None</code> objects as c, d do to tuple?</p>
<pre><code>a=None
b=None
c=(1,2)
d=(1,2)
print(a is b)
print(c is d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/c-api/none.html" rel="nofollow"><code>None</code></a> is a singleton object: only one instance of it can ever exist. So objects referencing <code>None</code> will always have the same identity, and two or more of such objects will always pass the identity  (object equality) test:</p>
<pre><code>&gt;&gt;&gt; a = None
&gt;&gt;&gt; b = None
&gt;&gt;&gt; c = None
&gt;&gt;&gt; a is b is c
True
</code></pre>
<p>Same applies to <code>True</code> and <code>False</code></p>
<pre><code>&gt;&gt;&gt; d = True
&gt;&gt;&gt; (a is b is c) is d # proof of concept only
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/constants.html#None"><code>None</code> object is a singleton in python.</a> Hence the result. </p>
<p>Whereas for <code>c</code> and <code>d</code>, it creates separate tuples.</p>
<p>From your example:</p>
<pre><code>&gt;&gt;&gt; id(None)
4454442584
&gt;&gt;&gt; id(a)
4454442584
&gt;&gt;&gt; id(b)
4454442584
&gt;&gt;&gt; id(c)
4463917464
&gt;&gt;&gt; id(d)
4463865584
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The 'is' operator compares the objects behind the variables as you figured out.</p>
<pre><code>a=None
b=None
print(a is b)
&gt;True #both None are the same instanciations or objects
</code></pre>
<p>The None Object in Python is a singleton (<a href="https://docs.python.org/2/c-api/none.html" rel="nofollow">https://docs.python.org/2/c-api/none.html</a>) and therefore a singleton restricts the instantiation of a class to one object (<a href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="nofollow">https://en.wikipedia.org/wiki/Singleton_pattern</a>).</p>
</div>
<span class="comment-copy">Just for sure, for singleton object you said like None, True and False, basically <code>is</code> and <code>==</code> work exactly the same? Thanks BTW.</span>
<span class="comment-copy">For booleans, it is sufficient to use the <code>==</code> for testing (or the object itself) as objects have truthy and falsy values. <code>c = 1</code> will pass <code>c == True</code> (better to use c directly as in <code>if c: ...</code>) but not <code>c is True</code>. Be careful to only use <code>is</code> if and only if you intend to check identity not equality</span>
<span class="comment-copy">Wait, since when was <code>a is b is c</code> not parsed as <code>(a is b) is c</code>? I thought that only applied to the normal comparison operators. <b>edit:</b> <code>'a' in 'ab' in 'abc'</code> is valid too</span>
<span class="comment-copy">@Eric <a href="https://docs.python.org/3/library/stdtypes.html#comparisons" rel="nofollow noreferrer">comparisons</a> can be chained arbitrarily. Adding a grouping parenthesis forces the interpreter to evaluate the items in the <code>()</code> first then the others. One'll have to be more careful when adding parenthesis to chained comparisons.</span>
<span class="comment-copy">@MosesKoledoye: <code>in</code> is not in that list, yet still chains</span>
