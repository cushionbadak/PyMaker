<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/33983980/lambda-in-for-loop-only-takes-last-value">lambda in for loop only takes last value</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>So in the following code I establish a Notebook in tkinter. I pull strings from the list <strong>VARS</strong>["IMPS"] and create pages with them in a dictionary using the strings as keys and the Frames as values. </p>
<p>My issue comes in when I establish the buttons, the function the button activates just prints the impname. However, when the application is built the while the labels always have the correct content in them and "impname". The buttons across all of the pages of the notebook always print the last string in the list <strong>VARS</strong>["IMPS"]. Why is this happening?</p>
<pre><code>    Necromicon = ttk.Notebook(self)
    self.pages = {}
    for impname in __VARS__["IMPS"]:
        page = {}
        # Formate is Imp_acrobat.Imp()
        # impname is a string
        self.pages[impname] = page
        self.pages[impname]["Page"] = ttk.Frame(Necromicon)
        Necromicon.add(self.pages[impname]["Page"], text=impname[4:])
        x = ttk.Label(self.pages[impname]['Page'], text=impname)
        x.config(wraplength=175, font=SMALL_FONT)
        x.config(background='black', foreground='red')
        self.pages[impname]['Scroll'] = x
        self.pages[impname][impname + 'Button'] = tk.Button(
                self.pages[impname]['Page'],
                text='Activate',
                command=lambda: self.modload(self, controller, impname))
        self.pages[impname]['Scroll'].pack(fill="both", expand=True)
        self.pages[impname][impname + 'Button'].pack()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add to my previous answer, there is a Python FAQ about <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow">this issue</a>.</p>
<p>Your statement</p>
<pre><code>    self.pages[impname][impname + 'Button'] = tk.Button(
            self.pages[impname]['Page'],
            text='Activate',
            command=lambda: self.modload(self, controller, impname))
</code></pre>
<p>is equivalent to</p>
<pre><code>    def button_command(): return self.modload(self, controller, impname))
    self.pages[impname][impname + 'Button'] = tk.Button(
            self.pages[impname]['Page'],
            text='Activate',
            command=button_command)
</code></pre>
<p>Does this make it any clearer that each button_handler() does the same thing? 
In fact, I would advise revising your code to</p>
<pre><code>    def button_command(self=self, controller=controller, impname=impname):
        return self.modload(self, controller, impname))
    self.pages[impname][impname + 'Button'] = tk.Button(
            self.pages[impname]['Page'],
            text='Activate',
            command=button_command)
</code></pre>
<p>Now each button command is different because the default args are computed when the function is defined.  I nearer always define button commands before creating buttons.  Less confusing.</p>
</div>
