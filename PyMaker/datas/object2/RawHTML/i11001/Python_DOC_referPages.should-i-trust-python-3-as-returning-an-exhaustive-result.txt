<div class="post-text" itemprop="text">
<p>As you can read in "man python" :</p>
<blockquote>
<p>-3     Warn about Python 3.x incompatibilities that 2to3 cannot trivially fix.</p>
</blockquote>
<p>This command allready help me in the past to avoid incompatibility between
code for Python 2.x &amp; 3.x. </p>
<p>However, i don't have any warning for <a href="https://stackoverflow.com/questions/2233786/overriding-bool-for-custom-class">this</a> code.
Should I trust "python -3" as returning an exhaustive result ?</p>
<p>NB : Surprinsigly, there is no mention of this option <a href="https://docs.python.org/3/using/cmdline.html#using-on-general" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you should not treat that warning as exhaustive.  The following code behaves differently on python2.x and python3.x but emits no warnings:</p>
<pre><code>from __future__ import print_function

class test(object):
    def __nonzero__(self):
        return False

t = test()
if t:
    print('Hello')
</code></pre>
<p>(at least not as of python2.7.10 on OSX).  Ok, perhaps this code can be handled by 2to3 (it is) -- though I would still expect a warning based on the <a href="https://docs.python.org/2.7/using/cmdline.html#cmdoption-3" rel="nofollow noreferrer">official documentation</a>.</p>
<blockquote>
<p>Warn about Python 3.x possible incompatibilities by emitting a DeprecationWarning for features that are removed or significantly changed in Python 3.</p>
</blockquote>
<p>Here's an example of some code that <a href="https://stackoverflow.com/questions/5965874/python-3-writing-to-a-pipe"><em>isn't</em> handled by 2to3</a> but still no warning is emitted using the <code>-3</code> option:</p>
<pre><code>from __future__ import print_function

import subprocess

class Pipe(object):
    def __init__(self,openstr):
        self.gnu_process=subprocess.Popen(openstr.split(),
                                          stdin=subprocess.PIPE)

    def put_in_pipe(self,mystr):
        print(mystr, file=self.gnu_process.stdin)

if __name__=="__main__":
    print("This simple program just echoes what you say (control-d to exit)")
    p = Pipe("cat -")
    while True:
        try:
            inpt = raw_input()
        except EOFError:
            break
        print('putting in pipe:%s' % inpt)
        p.put_in_pipe(inpt)
</code></pre>
<p>The problem with this code is that in python3, my pipe expects a bytes object but it's getting a <code>str</code> (python2.x's unicode).</p>
</div>
<span class="comment-copy">Because that code isn't incompatible with 3.x. Unless you mean using <code>__nonzero__</code>? In which case, it's probably because it's looking for "incompatibilities that 2to3 cannot <b>trivially</b> fix" and that's a pretty trivial fix. It's unclear what code you're talking about.</span>
<span class="comment-copy">Your link goes to the Python 3 documentation. Python 3 doesn't have that flag. (Surprisingly, the <a href="https://docs.python.org/2/using/cmdline.html#cmdoption-3" rel="nofollow noreferrer">Python 2 documentation</a> doesn't mention the 2to3 caveat.)</span>
<span class="comment-copy">@user2357112 -- Yeah, I'm surprised by that too (which is why my initial answer had code that 2to3 handles trivially).</span>
<span class="comment-copy">I've added a <a href="http://bugs.python.org/issue27470" rel="nofollow noreferrer">bug</a> against the documentation.  Who knows how long it will be before they fix it (or if they do)... But at least it's there...</span>
