<div class="post-text" itemprop="text">
<p>Is there any argument or options to setup a timeout for Python's subprocess.Popen method?</p>
<p>Something like this:</p>
<p><code>subprocess.Popen(['..'], ..., timeout=20)</code> ?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would advise taking a look at the <a href="http://docs.python.org/2/library/threading.html#threading.Timer" rel="noreferrer">Timer class</a> in the threading module.  I used it to implement a timeout for a Popen.</p>
<p>First, create a callback:</p>
<pre><code>    def timeout( p ):
        if p.poll() is None:
            print 'Error: process taking too long to complete--terminating'
            p.kill()
</code></pre>
<p>Then open the process:</p>
<pre><code>    proc = Popen( ... )
</code></pre>
<p>Then create a timer that will call the callback passing the process to it.</p>
<pre><code>    t = threading.Timer( 10.0, timeout, [proc] )
    t.start()
    t.join()
</code></pre>
<p>Somewhere later in the program, you may want to add the line:</p>
<pre><code>    t.cancel()
</code></pre>
<p>Otherwise, the python program will keep running until the timer has finished running.</p>
<p>EDIT: I was advised that there is a race condition that the subprocess p may terminate between the p.poll() and p.kill() calls.  I believe the following code can fix that:</p>
<pre><code>    import errno

    def timeout( p ):
        if p.poll() is None:
            try:
                p.kill()
                print 'Error: process taking too long to complete--terminating'
            except OSError as e:
                if e.errno != errno.ESRCH:
                    raise
</code></pre>
<p>Though you may want to clean the exception handling to specifically handle just the particular exception that occurs when the subprocess has already terminated normally.</p>
</div>
<div class="post-text" itemprop="text">
<p>subprocess.Popen doesn't block so you can do something like this:</p>
<pre><code>import time

p = subprocess.Popen(['...'])
time.sleep(20)
if p.poll() is None:
  p.kill()
  print 'timed out'
else:
  print p.communicate()
</code></pre>
<p>It has a drawback in that you must always wait at least 20 seconds for it to finish.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import subprocess, threading

class Command(object):
    def __init__(self, cmd):
        self.cmd = cmd
        self.process = None

    def run(self, timeout):
        def target():
            print 'Thread started'
            self.process = subprocess.Popen(self.cmd, shell=True)
            self.process.communicate()
            print 'Thread finished'

        thread = threading.Thread(target=target)
        thread.start()

        thread.join(timeout)
        if thread.is_alive():
            print 'Terminating process'
            self.process.terminate()
            thread.join()
        print self.process.returncode

command = Command("echo 'Process started'; sleep 2; echo 'Process finished'")
command.run(timeout=3)
command.run(timeout=1)
</code></pre>
<p>The output of this should be:</p>
<pre><code>Thread started
Process started
Process finished
Thread finished
0
Thread started
Process started
Terminating process
Thread finished
-15
</code></pre>
<p>where it can be seen that, in the first execution, the process finished correctly (return code 0), while the in the second one the process was terminated (return code -15).</p>
<p>I haven't tested in windows; but, aside from updating the example command, I think it should work since I haven't found in the documentation anything that says that thread.join or process.terminate is not supported.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do </p>
<pre><code>from twisted.internet import reactor, protocol, error, defer

class DyingProcessProtocol(protocol.ProcessProtocol):
    def __init__(self, timeout):
        self.timeout = timeout

    def connectionMade(self):
        @defer.inlineCallbacks
        def killIfAlive():
            try:
                yield self.transport.signalProcess('KILL')
            except error.ProcessExitedAlready:
                pass

        d = reactor.callLater(self.timeout, killIfAlive)

reactor.spawnProcess(DyingProcessProtocol(20), ...)
</code></pre>
<p>using Twisted's asynchronous process API.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>A python subprocess auto-timeout is not built in, so you're going to have to build your own.</strong></p>
<p>This works for me on Ubuntu 12.10 running python 2.7.3</p>
<p>Put this in a file called test.py</p>
<pre><code>#!/usr/bin/python
import subprocess
import threading

class RunMyCmd(threading.Thread):
    def __init__(self, cmd, timeout):
        threading.Thread.__init__(self)
        self.cmd = cmd 
        self.timeout = timeout

    def run(self):
        self.p = subprocess.Popen(self.cmd)
        self.p.wait()

    def run_the_process(self):
        self.start()
        self.join(self.timeout)

        if self.is_alive():
            self.p.terminate()   #if your process needs a kill -9 to make 
                                 #it go away, use self.p.kill() here instead.

            self.join()

RunMyCmd(["sleep", "20"], 3).run_the_process()
</code></pre>
<p>Save it, and run it:</p>
<pre><code>python test.py
</code></pre>
<p>The <code>sleep 20</code> command takes 20 seconds to complete.  If it doesn't terminate in 3 seconds (it won't) then the process is terminated.</p>
<pre><code>el@apollo:~$  python test.py 
el@apollo:~$ 
</code></pre>
<p>There is three seconds between when the process is run, and it is terminated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, there isn't such a solution. I managed to do this using a threaded timer that would launch along with the process that would kill it after the timeout but I did run into some stale file descriptor issues because of zombie processes or some such.</p>
</div>
<div class="post-text" itemprop="text">
<p>No there is no time out. I guess, what you are looking for is to kill the sub process after some time. Since you are able to signal the subprocess, you should be able to kill it too.</p>
<p>generic approach to sending a signal to subprocess:</p>
<pre><code>proc = subprocess.Popen([command])
time.sleep(1)
print 'signaling child'
sys.stdout.flush()
os.kill(proc.pid, signal.SIGUSR1)
</code></pre>
<p>You could use this mechanism to terminate after a time out period.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.3, there is also a <code>timeout</code> argument to the blocking helper functions in the subprocess module.</p>
<p><a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow">https://docs.python.org/3/library/subprocess.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <a href="https://pypi.python.org/pypi/python-subprocess2" rel="nofollow">https://pypi.python.org/pypi/python-subprocess2</a> will extend the Popen module with two additional functions,</p>
<pre><code>Popen.waitUpTo(timeout=seconds)
</code></pre>
<p>This will wait up to  acertain number of seconds  for the process to complete,  otherwise return None</p>
<p>also,</p>
<pre><code>Popen.waitOrTerminate
</code></pre>
<p>This will wait up to a point, and then call .terminate(), then .kill(), one orthe other or some combination of both, see docs  for full details:</p>
<p><a href="http://htmlpreview.github.io/?https://github.com/kata198/python-subprocess2/blob/master/doc/subprocess2.html" rel="nofollow">http://htmlpreview.github.io/?https://github.com/kata198/python-subprocess2/blob/master/doc/subprocess2.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>For Linux, you can use a signal.  This is platform dependent so another solution is required for Windows.  It may work with Mac though.    </p>
<pre><code>def launch_cmd(cmd, timeout=0):
    '''Launch an external command

    It launchs the program redirecting the program's STDIO
    to a communication pipe, and appends those responses to
    a list.  Waits for the program to exit, then returns the
    ouput lines.

    Args:
        cmd: command Line of the external program to launch
        time: time to wait for the command to complete, 0 for indefinitely
    Returns:
        A list of the response lines from the program    
    '''

    import subprocess
    import signal

    class Alarm(Exception):
        pass

    def alarm_handler(signum, frame):
        raise Alarm

    lines = []

    if not launch_cmd.init:
        launch_cmd.init = True
        signal.signal(signal.SIGALRM, alarm_handler)

    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    signal.alarm(timeout)  # timeout sec

    try:
        for line in p.stdout:
            lines.append(line.rstrip())
        p.wait()
        signal.alarm(0)  # disable alarm
    except:
        print "launch_cmd taking too long!"
        p.kill()

    return lines        
launch_cmd.init = False
</code></pre>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/1191374/4279">subprocess with timeout</a></span>
<span class="comment-copy">This code has a race condition.</span>
<span class="comment-copy">Mike, could you elaborate or edit a fix above?  I've used similar code several times, and if there is an issue, I would definitely like to fix it.</span>
<span class="comment-copy"><code>print 'Error: process taking too long to complete--terminating'</code> can run even if it's a lie and your process terminates without you killing it (because it does it in the moments between your <code>poll</code> and <code>kill</code> calls).</span>
<span class="comment-copy">More importantly, if the subprocess terminates between those calls, p.kill() will raise an exception.</span>
<span class="comment-copy">PyCharm suggests its better to use <code>if p.poll() is None</code> than using the equality relation (==)</span>
<span class="comment-copy">This would freeze this process for 20 seconds. Is that acceptable?</span>
<span class="comment-copy">doesn't this kinda defeat the point of using a subprocess?</span>
<span class="comment-copy">seem it is! I think this is a little inconvenience of using subprocess.</span>
<span class="comment-copy">@aaronasterling: <code>Popen/sleep()</code> is a simple portable and efficient method to run an external never-ending program with a timeout. Though <code>p.communicate()</code> usage is problematic in this code (it might lead to loosing some of the output). See <a href="http://stackoverflow.com/q/4417962/4279">Stop reading process output in Python without hang?</a> question for an example when <code>Popen/sleep()</code> is useful.</span>
<span class="comment-copy">One could reduce the drawback by using something like: <code>wait = 0 while p.poll() is None and wait &lt; 15:                     wait += 1                     sleep(1)                 if p.poll() is None:                     p.kill()</code></span>
<span class="comment-copy">+1 This would be my solution.</span>
<span class="comment-copy">I experienced such a problem too with file descriptors on zombie processes.</span>
<span class="comment-copy">Sultan. It should be possible to correct those. I did manage to finally polish my application into something workable but it was not generic enough to publish.</span>
<span class="comment-copy">Is it universal sys.stdout.flush() for all apps using subprocess?</span>
<span class="comment-copy">This is pretty much like Abhishek's answer. He's using SIGKILL and you're using SIGUSR1. It has the same issues.</span>
<span class="comment-copy">Ok thanks guys!</span>
