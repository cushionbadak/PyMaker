<div class="post-text" itemprop="text">
<p>I am looking for an elegant way to slice a list <code>l</code> in python, given a list of ids <code>l_ids</code>.
For example, instead of writing </p>
<pre><code>new_list = [l[i] for i in l_ids] 
</code></pre>
<p>Write something like (Pseudo code):</p>
<pre><code>new_list = l[*l_ids] 
</code></pre>
<p>Is there a similar way to slice lists? </p>
<p>I have the feeling that someone have asked that already, but I couldn't find any reference for it.</p>
<p>EDIT: It is ok to assume that all the list items are of the same type</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow"><code>operator.itemgetter(*items)</code></a> like this:</p>
<pre><code>from operator import itemgetter

getter = itemgetter(*lst_ids)
new_list = list(getter(lst))
</code></pre>
<p>Also, note that I renamed <code>l</code> variable to <code>lst</code> because it is less ambiguous and <a href="https://www.python.org/dev/peps/pep-0008/#names-to-avoid" rel="nofollow">should be avoided</a>.</p>
<p>You can implicitly cast the tuple to a list using Python 3 unpacking, as @JonClements commented:</p>
<pre><code>*new_list, = getter(lst)
</code></pre>
<p>Finally, since Python 3.5, you can also use extended unpacking:</p>
<pre><code>new_list = [*getter(lst)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think importing anything is particularly elegant, or pythonic.</p>
<p>List comprehensions work, and I can't see a reason not to use them (or no good reason to import something to do the same thing):</p>
<pre><code>&gt;&gt;&gt; x = [3,5,7,0,1,4,2,6]
&gt;&gt;&gt; y = ['a','b','c','d','e','f','g','h']
&gt;&gt;&gt; nList = [y[i] for i in x]
&gt;&gt;&gt; nList
['d', 'f', 'h', 'a', 'b', 'e', 'c', 'g']
</code></pre>
<p>The list comprehension is doing the following:</p>
<pre><code>indexes = [3,5,7,0,1,4,2,6]
data = ['a','b','c','d','e','f','g','h']
nList = []
for index in indexes:
    nList += [data[index]]
</code></pre>
<p>The comprehension looks pretty pythonic and elegant to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3.5/library/operator.html" rel="nofollow">itemgetter</a></p>
<pre><code>from operator import itemgetter

l = ['a', 'b', 'c', 'd', 'e']
l_ids = [1, 2, 3]
list(itemgetter(*l_ids)(l))
</code></pre>
<blockquote>
<p>['b', 'c', 'd']</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I would go with <em>itemgetter</em> but you could also <em>map</em> <em>list.__getitem_</em>_:</p>
<pre><code>l = ['a', 'b', 'c', 'd', 'e']
l_ids = [1, 2, 3]

new = list(map(l.__getitem__, l_ids))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If all the list elements are of the same type, it is possible to use numpy:</p>
<pre><code>from numpy import *
new_list = array(l)[l_ids]
</code></pre>
</div>
<span class="comment-copy">itemgetter <a href="http://stackoverflow.com/questions/38276068/unpack-a-python-tuple-from-left-to-right/38276396#38276396" title="unpack a python tuple from left to right">stackoverflow.com/questions/38276068/â€¦</a></span>
<span class="comment-copy">If you're going to mention the extended unpacking in 3.5, don't forget that there's other unpacking that'll work in the 3 series (although it's not very pretty) <code>*new_lst, = getter(lst)</code> (and since <code>list()</code> will work across the board and says what it means - I'd stick with that anyway...)</span>
<span class="comment-copy">@JonClements Smart, thank you!</span>
<span class="comment-copy">If the author only need to create such a list once, I think list comprehension is perfectly fine, but <code>itemgetter()</code> it a elegant way if it needs to be repeated several times.</span>
<span class="comment-copy">@Delgan Ahh, good point. I guess if you have the same list of ids for multiple data lists, it's slower.</span>
<span class="comment-copy">I am not sure method with double leadind and trailing underscore should be used, it is reserved to Python internally, is not it?</span>
<span class="comment-copy">It is a matter of opinion, I and lots of other people often use the same logic to avoid having to use lambda calls with map, filters i.e some_set.__contains__ vs lambda st: x in st etc..</span>
<span class="comment-copy">If you are using numpy then it is quite a different question</span>
<span class="comment-copy">numpy is a package as operator (with itemgetter) is. I don't see a problem if it provides a useful and concise solution.</span>
