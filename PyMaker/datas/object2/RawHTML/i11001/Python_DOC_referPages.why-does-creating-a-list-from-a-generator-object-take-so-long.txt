<div class="post-text" itemprop="text">
<p>I was interested in when I should use a generator in a function, and when I should just use a list, so I did some tests with filter and list comprehensions. </p>
<pre><code>&gt;&gt;&gt; timeit.timeit('list(filter(lambda x: x%10, range(10)))')
3.281250655069016
&gt;&gt;&gt; timeit.timeit('[i for i in range(10) if i%10 != 0]')
2.6070076799951494
&gt;&gt;&gt; timeit.timeit('filter(lambda x: x%10, range(10))')
0.7457015149993822   
</code></pre>
<p>Then I tried with range(100):</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('list(filter(lambda x: x%10, range(100)))')
27.73180518404115
&gt;&gt;&gt; timeit.timeit('[i for i in range(100) if i%10 != 0]')
18.659852175973356
&gt;&gt;&gt; timeit.timeit('filter(lambda x: x%10, range(100))')
0.7294546449556947
</code></pre>
<p>Why does it take so much longer to make a list from the generator object than it does to simply create the list? If I needed to access that list more than once, would I just be better off using list comprehension rather than creating a list from the generator object?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two different issues that is evident from question</p>
<ol>
<li>From the minuscule timing data for the standalone filter call it is evident that you are using Python 3.x, as filter returns a generator like object. So theoretically nothing actually happens.<a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow">[1]</a></li>
<li>The first expression invokes a lambda, a function call which is always costly in Python. So, a List comprehension excels over a filter calling a lambda wrapped with a list build-in.<a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips#Re-map_Functions_at_runtime" rel="nofollow">[2]</a></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I will begin by answering your last question, yes you should use comprehensive list rather than <code>list</code> + <code>filter</code> combination since it's more pythonic and as you showed it, more efficient.</p>
<p>As for why it is more efficient, you have function call overhead (of the <code>lambda</code>) in the <code>filter</code> code that you don't have in the comprehension list.</p>
<p>Here is another timeit test to show you:</p>
<pre><code># First the sample with list &amp; filter, for comparison base
&gt;&gt;&gt; timeit.timeit('list(filter(lambda x: x%10, range(10)))')
10.984653161001916
# Then the quickest comprehension list
&gt;&gt;&gt; timeit.timeit('[i for i in range(10) if i%10]')
6.125996000002488
# And an hybrid, comprehension list using a call to previously defined lambda
&gt;&gt;&gt; timeit.timeit('[i for i in range(10) if l(i)]', setup="l=lambda x: x%10")
9.257114547002857
</code></pre>
<p>As you can see, most of the difference comes from function call overhead.</p>
<p>The last 1.7 unexplained seconds is probably due to the <code>filter</code> poping into <code>list</code> while comprehension list builds the values directly into the list</p>
</div>
<span class="comment-copy">@PadraicCunningham well, aren't all of them getting <code>next</code> being called multiple times? But yes, the more you call it, the longer it takes to complete iterating through the sequence.</span>
<span class="comment-copy">@Dandr√©, <code>[i for i in range(10) if i%10 != 0]</code>, where is the next call in relation to the list itself?</span>
<span class="comment-copy">@PadraicCunningham range() is a generator that has an implicit call <code>next</code></span>
<span class="comment-copy">On a sidenote, in <code>[i for i in range(100) if i%10 != 0]</code> the  <code>!= 0</code> is redundant. <code>if i%10</code> is quite enough and faster.</span>
<span class="comment-copy">@Tanmay: It is not a generator. Generators are a very specific type of iterator based on suspending and resuming execution of a Python function, created by either a generator expression or the use of <code>yield</code>. The term does not refer to arbitrary lazy iterables.</span>
