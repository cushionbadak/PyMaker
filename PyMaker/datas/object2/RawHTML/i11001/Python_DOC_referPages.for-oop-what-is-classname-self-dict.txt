<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; class A(object): pass
... 
&gt;&gt;&gt; A.__dict__
&lt;dictproxy object at 0x173ef30&gt;
&gt;&gt;&gt; A.__dict__.__dict__
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;fragment&gt;
AttributeError: 'dictproxy' object has no attribute '__dict__'
&gt;&gt;&gt; A.__dict__.copy()
{'__dict__': &lt;attribute '__dict__' of 'A' objects&gt; ... }
&gt;&gt;&gt; A.__dict__['__dict__']
&lt;attribute '__dict__' of 'A' objects&gt; # What is this object?
</code></pre>
<p>If I do <code>A.something = 10</code>, this goes into <code>A.__dict__</code>. What <strong><em>is</em></strong> this <code>&lt;attribute '__dict__' of 'A' objects&gt;</code> found in <code>A.__dict__.__dict__</code>, and when does it contain something?</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all <code>A.__dict__.__dict__</code> is  different from <code>A.__dict__['__dict__']</code>, and the former doesn't exist. The latter is the <code>__dict__</code> attribute that the instances of the class would have. It's a descriptor object that returns the internal dictionary of attributes for the specific instance. In short, the <code>__dict__</code> attribute of an object can't be stored in object's <code>__dict__</code>, so it's accessed through a descriptor defined in the class.</p>
<p>To understand this, you'd have to read the <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="noreferrer">documentation of the descriptor protocol</a>.</p>
<p>The short version:</p>
<ol>
<li>For an instance of class <code>A</code>, access to <code>instance.__dict__</code> is provided by <code>A.__dict__['__dict__']</code> which is the same as <code>vars(A)['__dict__']</code>.</li>
<li>For the class A, access to <code>A.__dict__</code> is provided by <code>type.__dict__['__dict__']</code> (in theory) which is the same as <code>vars(type)['__dict__']</code>.</li>
</ol>
<hr/>
<p>The long version:</p>
<p>Both classes and objects provide access to attributes both through the attribute operator (implemented via the class or metaclass's <code>__getattribute__</code>), and the <code>__dict__</code> attribute/protocol which is used by <code>vars(ob)</code>.</p>
<p>For normal objects, the <code>__dict__</code> object creates a separate <code>dict</code> object, which stores the attributes, and <code>__getattribute__</code> first tries to access it and get the attributes from there (before attempting to look for the attribute in the class by utilizing the descriptor protocol, and before calling <code>__getattr__</code>). The <code>__dict__</code> descriptor on the class implements the access to this dictionary.</p>
<ul>
<li><code>x.name</code> is equivalent to trying those in order: <code>x.__dict__['name']</code>, <code>type(x).name.__get__(x, type(x))</code>, <code>type(x).name</code></li>
<li><code>x.__dict__</code> does the same but skips the first one for obvious reasons</li>
</ul>
<p>As it's impossible for the <code>__dict__</code> of <code>instance</code> to be stored in <code>__dict__</code> of the instance, it is accessed through the descriptor protocol directly instead, and is stored in a special field in the instance.</p>
<p>A similar scenario is true for classes, although their <code>__dict__</code> is a special proxy object that pretends to be a dictionary (but might not be internally), and doesn't allow you to change it or replace it with another one. This proxy allows you, among all else, to access the attributes of a class that are specific to it, and not defined in one of its bases.</p>
<p>By default, a <code>vars(cls)</code> of an empty class carries three descriptors - <code>__dict__</code> for storing the attributes of the instances, <code>__weakref__</code> which is used internally by <code>weakref</code>, and the docstring of the class. The first two might be gone if you define <code>__slots__</code>. Then you wouldn't have <code>__dict__</code> and <code>__weakref__</code> attributes, but instead you'd have a single class attribute for each slot. The attributes of the instance then wouldn't be stored in a dictionary, and access to them will be provided by the respective descriptors in the class.</p>
<hr/>
<p>And lastly, the inconsistency that <code>A.__dict__</code> is different from <code>A.__dict__['__dict__']</code> is because the attribute <code>__dict__</code> is, by exception, <em>never</em> looked up in <code>vars(A)</code>, so what is true for it isn't true for practically any other attribute you'd use. For example, <code>A.__weakref__</code> is the same thing as <code>A.__dict__['__weakref__']</code>. If this inconsistency didn't exist, using <code>A.__dict__</code> would not work, and you'd have to always use <code>vars(A)</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Lets do some exploring!</p>
<pre><code>&gt;&gt;&gt; A.__dict__['__dict__']
&lt;attribute '__dict__' of 'A' objects&gt;
</code></pre>
<p>I wonder what that is?</p>
<pre><code>&gt;&gt;&gt; type(A.__dict__['__dict__'])
&lt;type 'getset_descriptor'&gt;
</code></pre>
<p>What attributes does a <code>getset_descriptor</code> object have?</p>
<pre><code>&gt;&gt;&gt; type(A.__dict__["__dict__"]).__dict__
&lt;dictproxy object at 0xb7efc4ac&gt;
</code></pre>
<p>By making a copy of that <code>dictproxy</code> we can find some interesting attributes, specifically <code>__objclass__</code> and <code>__name__</code>.</p>
<pre><code>&gt;&gt;&gt; A.__dict__['__dict__'].__objclass__, A.__dict__['__dict__'].__name__
(&lt;class '__main__.A'&gt;, '__dict__')
</code></pre>
<p>So <code>__objclass__</code> is a reference to <code>A</code> and <code>__name__</code> is just the string <code>'__dict__'</code>, name of an attribute perhaps?</p>
<pre><code>&gt;&gt;&gt; getattr(A.__dict__['__dict__'].__objclass__, A.__dict__['__dict__'].__name__) == A.__dict__
True
</code></pre>
<p>There we have it!  <code>A.__dict__['__dict__']</code> is an object that can refer back to <code>A.__dict__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>A.__dict__</code> is a dictionary storing <code>A</code> attributes, <code>A.__dict__['__dict__']</code> is the direct reference to that same <code>A.__dict__</code> attribute.</p>
<p><code>A.__dict__</code> contains a (kind-of) reference to itself. The "kind-of" part is why the expression <code>A.__dict__</code> returns a <code>dictproxy</code> instead of a normal <code>dict</code>.</p>
<pre><code>&gt;&gt;&gt; class B(object):
...     "Documentation of B class"
...     pass
...
&gt;&gt;&gt; B.__doc__
'Documentation of B class'
&gt;&gt;&gt; B.__dict__
&lt;dictproxy object at 0x00B83590&gt;
&gt;&gt;&gt; B.__dict__['__doc__']
'Documentation of B class'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try the following simple example to understand more of this:</p>
<pre><code>&gt;&gt;&gt; class A(object): pass
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; type(A)
&lt;type 'type'&gt;
&gt;&gt;&gt; type(a)
&lt;class '__main__.A'&gt;
&gt;&gt;&gt; type(a.__dict__)
&lt;type 'dict'&gt;
&gt;&gt;&gt; type(A.__dict__)
&lt;type 'dictproxy'&gt;
&gt;&gt;&gt; type(type.__dict__)
&lt;type 'dictproxy'&gt;
&gt;&gt;&gt; type(A.__dict__['__dict__'])
&lt;type 'getset_descriptor'&gt;
&gt;&gt;&gt; type(type.__dict__['__dict__'])
&lt;type 'getset_descriptor'&gt;
&gt;&gt;&gt; a.__dict__ == A.__dict__['__dict__'].__get__(a)
True
&gt;&gt;&gt; A.__dict__ == type.__dict__['__dict__'].__get__(A)
True
&gt;&gt;&gt; a.__dict__ == type.__dict__['__dict__'].__get__(A)['__dict__'].__get__(a)
True
</code></pre>
<p>From the above example, it seems that class objects attributes are stored by their class, class's attributes are stored by their class, which are metaclasses. This is also validated by:</p>
<pre><code>&gt;&gt;&gt; a.__dict__ == A.__getattribute__(a, '__dict__')
True
&gt;&gt;&gt; A.__dict__ == type.__getattribute__(A, '__dict__')
True
</code></pre>
</div>
<span class="comment-copy">A more suitable example variable would've been <code>ive</code>. At least it would've made this a more <code>A.__dict__['ive']</code> question ;) I'll see myself out</span>
<span class="comment-copy">Thanks for the detailed answer. Although I had to read it a few times, I think it has been a while since I learned so many new details of Python.</span>
<span class="comment-copy">PEP 252 says that <code>__objclass__</code> is the class that <i>defined</i> this attribute, not that is an attribute of that class. This makes your <code>getattr</code> example incorrect. A more correct one would be <code>getattr(A().__dict__['__dict__'].__objclass__, A.__dict__['__dict__'].__name__)</code></span>
<span class="comment-copy"><code>A.__dict__['__dict__']</code> isn't a reference to <code>A.__dict__</code>. It implements the <code>__dict__</code> attribute of the instances. To try this for yourself, <code>A.__dict__['__dict__'].__get__(A(), A)</code> returns the attributes of <code>A()</code>, while <code>A.__dict__['__dict__'].__get__(A, type)</code> fails.</span>
