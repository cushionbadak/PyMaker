<div class="post-text" itemprop="text">
<p>Apparently xrange is faster but I have no idea why it's faster (and no proof besides the anecdotal so far that it is faster) or what besides that is different about</p>
<pre><code>for i in range(0, 20):
for i in xrange(0, 20):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>range creates a list, so if you do <code>range(1, 10000000)</code> it creates a list in memory with <code>9999999</code> elements.</p>
<p><code>xrange</code> is a sequence object that  evaluates lazily.  </p>
<p>It should be added from @Thiago's hint, that in python3, range does the equivalent of python's xrange  </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>range creates a list, so if you do <code>range(1, 10000000)</code> it creates a list in memory with <code>9999999</code> elements.</p>
<p><code>xrange</code> <s>is a generator, so it</s> is a sequence object <s>is a</s> that  evaluates lazily.  </p>
</blockquote>
<p>This is true, but in Python 3, <code>.range()</code> will be implemented by the Python 2 <code>.xrange()</code>. If you need to actually generate the list, you will need to do:</p>
<pre><code>list(range(1,100))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Remember, use the <code>timeit</code> module to test which of small snippets of code is faster!</p>
<pre><code>$ python -m timeit 'for i in range(1000000):' ' pass'
10 loops, best of 3: 90.5 msec per loop
$ python -m timeit 'for i in xrange(1000000):' ' pass'
10 loops, best of 3: 51.1 msec per loop
</code></pre>
<p>Personally, I always use <code>.range()</code>, unless I were dealing with <em>really</em> huge lists -- as you can see, time-wise, for a list of a million entries, the extra overhead is only 0.04 seconds.  And as Corey points out, in Python 3.0 <code>.xrange()</code> will go away and <code>.range()</code> will give you nice iterator behavior anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>xrange</code> only stores the range params and generates the numbers on demand. However the C implementation of Python currently restricts its args to C longs:</p>
<pre><code>xrange(2**32-1, 2**32+1)  # When long is 32 bits, OverflowError: Python int too large to convert to C long
range(2**32-1, 2**32+1)   # OK --&gt; [4294967295L, 4294967296L]
</code></pre>
<p>Note that in Python 3.0 there is only <code>range</code> and it behaves like the 2.x <code>xrange</code> but without the limitations on minimum and maximum end points.</p>
</div>
<div class="post-text" itemprop="text">
<p>xrange returns an iterator and only keeps one number in memory at a time.  range keeps the entire list of numbers in memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do spend some time with the <a href="http://docs.python.org/lib/typesseq-xrange.html" rel="noreferrer">Library Reference</a>. The more familiar you are with it, the faster you can find answers to questions like this. Especially important are the first few chapters about builtin objects and types.</p>
<blockquote>
<p>The advantage of the xrange type is that an xrange object will always 
  take the same amount of memory, no matter the size of the range it represents. 
  There are no consistent performance advantages.</p>
</blockquote>
<p>Another way to find quick information about a Python construct is the docstring and the help-function:</p>
<pre><code>print xrange.__doc__ # def doc(x): print x.__doc__ is super useful
help(xrange)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am shocked nobody read <a href="https://docs.python.org/2/library/functions.html#xrange" rel="noreferrer">doc</a>:</p>
<blockquote>
<p>This function is very similar to <code>range()</code>, but returns an <code>xrange</code> object instead of a list. This is an opaque sequence type which yields the same values as the corresponding list, without actually storing them all simultaneously. The advantage of <code>xrange()</code> over <code>range()</code> is minimal (since <code>xrange()</code> still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the rangeâ€™s elements are never used (such as when the loop is usually terminated with <code>break</code>).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>range creates a list, so if you do range(1, 10000000) it creates a list in memory with 10000000 elements.
  xrange is a generator, so it evaluates lazily.</p>
</blockquote>
<p>This brings you two advantages:</p>
<ol>
<li>You can iterate longer lists without getting a <code>MemoryError</code>.</li>
<li>As it resolves each number lazily, if you stop iteration early, you won't waste time creating the whole list.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>It is for optimization reasons.</p>
<p>range() will create a list of values from start to end (0 .. 20 in your example). This will become an expensive operation on very large ranges.</p>
<p>xrange() on the other hand is much more optimised. it will only compute the next value when needed (via an xrange sequence object) and does not create a list of all values like range() does.</p>
</div>
<div class="post-text" itemprop="text">
<p>You will find the advantage of <code>xrange</code> over <code>range</code> in this simple example:</p>
<pre><code>import timeit

t1 = timeit.default_timer()
a = 0
for i in xrange(1, 100000000):
    pass
t2 = timeit.default_timer()

print "time taken: ", (t2-t1)  # 4.49153590202 seconds

t1 = timeit.default_timer()
a = 0
for i in range(1, 100000000):
    pass
t2 = timeit.default_timer()

print "time taken: ", (t2-t1)  # 7.04547905922 seconds
</code></pre>
<p>The above example doesn't reflect anything substantially better in case of <code>xrange</code>.</p>
<p>Now look at the following case where <code>range</code> is really really slow, compared to <code>xrange</code>.</p>
<pre><code>import timeit

t1 = timeit.default_timer()
a = 0
for i in xrange(1, 100000000):
    if i == 10000:
        break
t2 = timeit.default_timer()

print "time taken: ", (t2-t1)  # 0.000764846801758 seconds

t1 = timeit.default_timer()
a = 0
for i in range(1, 100000000):
    if i == 10000:
        break
t2 = timeit.default_timer() 

print "time taken: ", (t2-t1)  # 2.78506207466 seconds
</code></pre>
<p>With <code>range</code>, it already creates a list from 0 to 100000000(time consuming), but <code>xrange</code> is a generator and it only generates numbers based on the need, that is, if the iteration continues.</p>
<p>In Python-3, the implementation of the <code>range</code> functionality is same as that of <code>xrange</code> in Python-2, while they have done away with <code>xrange</code> in Python-3</p>
<p>Happy Coding!! </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>range():</strong> range(1, 10) returns a list from 1 to 10 numbers &amp; hold whole list in memory.</p>
<p><strong>xrange():</strong> Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand. For looping, this is lightly faster than range() and more memory efficient.
 xrange() object like an iterator and generates the numbers on demand.(Lazy Evaluation)</p>
<pre><code>In [1]: range(1,10)

Out[1]: [1, 2, 3, 4, 5, 6, 7, 8, 9]

In [2]: xrange(10)

Out[2]: xrange(10)

In [3]: print xrange.__doc__

xrange([start,] stop[, step]) -&gt; xrange object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>range(x,y)</code> returns a list of each number in between x and y if you use a <code>for</code> loop, then <code>range</code> is slower. In fact, <code>range</code> has a bigger Index range. <code>range(x.y)</code> will print out a list of all the numbers in between x and y</p>
<p><code>xrange(x,y)</code> returns <code>xrange(x,y)</code> but if you used a <code>for</code> loop, then <code>xrange</code> is faster. <code>xrange</code> has a smaller Index range. <code>xrange</code> will not only print out <code>xrange(x,y)</code> but it will still keep all the numbers that are in it.</p>
<pre><code>[In] range(1,10)
[Out] [1, 2, 3, 4, 5, 6, 7, 8, 9]
[In] xrange(1,10)
[Out] xrange(1,10)
</code></pre>
<p>If you use a <code>for</code> loop, then it would work</p>
<pre><code>[In] for i in range(1,10):
        print i
[Out] 1
      2
      3
      4
      5
      6
      7
      8
      9
[In] for i in xrange(1,10):
         print i
[Out] 1
      2
      3
      4
      5
      6
      7
      8
      9
</code></pre>
<p>There isn't much difference when using loops, though there is a difference when just printing it!</p>
</div>
<div class="post-text" itemprop="text">
<p>In python 2.x</p>
<p><strong>range(x)</strong> returns a list, that is created in memory with x elements.</p>
<pre><code>&gt;&gt;&gt; a = range(5)
&gt;&gt;&gt; a
[0, 1, 2, 3, 4]
</code></pre>
<p><strong>xrange(x)</strong> returns an xrange object which is a generator obj which generates the numbers on demand. they are computed during for-loop(Lazy Evaluation).</p>
<p>For looping, this is slightly faster than range() and more memory efficient.</p>
<pre><code>&gt;&gt;&gt; b = xrange(5)
&gt;&gt;&gt; b
xrange(5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When testing range against xrange in a loop (I know I should use <a href="http://docs.python.org/library/timeit.html" rel="noreferrer">timeit</a>, but this was swiftly hacked up from memory using a simple list comprehension example) I found the following:</p>
<pre><code>import time

for x in range(1, 10):

    t = time.time()
    [v*10 for v in range(1, 10000)]
    print "range:  %.4f" % ((time.time()-t)*100)

    t = time.time()
    [v*10 for v in xrange(1, 10000)]
    print "xrange: %.4f" % ((time.time()-t)*100)
</code></pre>
<p>which gives:</p>
<pre><code>$python range_tests.py
range:  0.4273
xrange: 0.3733
range:  0.3881
xrange: 0.3507
range:  0.3712
xrange: 0.3565
range:  0.4031
xrange: 0.3558
range:  0.3714
xrange: 0.3520
range:  0.3834
xrange: 0.3546
range:  0.3717
xrange: 0.3511
range:  0.3745
xrange: 0.3523
range:  0.3858
xrange: 0.3997 &lt;- garbage collection?
</code></pre>
<p>Or, using xrange in the for loop:</p>
<pre><code>range:  0.4172
xrange: 0.3701
range:  0.3840
xrange: 0.3547
range:  0.3830
xrange: 0.3862 &lt;- garbage collection?
range:  0.4019
xrange: 0.3532
range:  0.3738
xrange: 0.3726
range:  0.3762
xrange: 0.3533
range:  0.3710
xrange: 0.3509
range:  0.3738
xrange: 0.3512
range:  0.3703
xrange: 0.3509
</code></pre>
<p>Is my snippet testing properly? Any comments on the slower instance of xrange? Or a better example :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Some of the other answers mention that Python 3 eliminated 2.x's <code>range</code> and renamed 2.x's <code>xrange</code> to <code>range</code>. However, unless you're using 3.0 or 3.1 (which nobody should be), it's actually a somewhat different type.</p>
<p>As <a href="https://docs.python.org/3.1/library/stdtypes.html#range-type" rel="noreferrer">the 3.1 docs</a> say:</p>
<blockquote>
<p>Range objects have very little behavior: they only support indexing, iteration, and the <code>len</code> function.</p>
</blockquote>
<p>However, in 3.2+, <code>range</code> is a full sequenceâ€”it supports extended slices, and all of the methods of <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="noreferrer"><code>collections.abc.Sequence</code></a> with the same semantics as a <code>list</code>.<sup>*</sup></p>
<p>And, at least in CPython and PyPy (the only two 3.2+ implementations that currently exist), it also has constant-time implementations of the <code>index</code> and <code>count</code> methods and the <code>in</code> operator (as long as you only pass it integers). This means writing <code>123456 in r</code> is reasonable in 3.2+, while in 2.7 or 3.1 it would be a horrible idea.</p>
<hr/>
<p><sub>* The fact that <code>issubclass(xrange, collections.Sequence)</code> returns <code>True</code> in 2.6-2.7 and 3.0-3.1 is <a href="http://bugs.python.org/issue9213" rel="noreferrer">a bug</a> that was fixed in 3.2 and not backported.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>xrange() and range() in python works similarly as for the user , but the difference comes when we are talking about how the memory is allocated in using both the function.</p>
<p>When we are using range() we allocate memory for all the variables it is generating, so it is not recommended to use with larger no. of variables to be generated.</p>
<p>xrange() on the other hand generate only a particular value at a time and can only be used with the for loop to print all the values required.</p>
</div>
<div class="post-text" itemprop="text">
<p>range generates the entire list and returns it.  xrange does not -- it generates the numbers in the list on demand.</p>
</div>
<div class="post-text" itemprop="text">
<p>Read the following post for the comparison between range and xrange with graphical analysis.</p>
<p><a href="http://justindailey.blogspot.in/2011/09/python-range-vs-xrange.html" rel="nofollow">Python range Vs xrange</a></p>
</div>
<div class="post-text" itemprop="text">
<p>xrange uses an iterator (generates values on the fly), range returns a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>What?<br/>
<code>range</code> returns a static list at runtime.<br/>
<code>xrange</code> returns an <code>object</code> (which acts like a generator, although it's certainly not one) from which values are generated as and when required.</p>
<p>When to use which?  </p>
<ul>
<li>Use <code>xrange</code> if you want to generate a list for a gigantic range, say 1 billion, especially when you have a "memory sensitive system" like a cell phone.</li>
<li>Use <code>range</code> if you want to iterate over the list several times.</li>
</ul>
<p>PS: Python 3.x's <code>range</code> function == Python 2.x's <code>xrange</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>On a requirement for scanning/printing of 0-N items , range and xrange works as follows.</p>
<p>range() - creates a new list in the memory and takes the whole 0 to N items(totally N+1) and prints them.
xrange() - creates a iterator instance that scans through the items and keeps only the current encountered item into the memory , hence utilising same amount of memory all the time.</p>
<p>In case the required element is somewhat at the beginning of the list only then it saves a good amount of time and memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference decreases for smaller arguments to <code>range(..)</code> / <code>xrange(..)</code>:</p>
<pre><code>$ python -m timeit "for i in xrange(10111):" " for k in range(100):" "  pass"
10 loops, best of 3: 59.4 msec per loop

$ python -m timeit "for i in xrange(10111):" " for k in xrange(100):" "  pass"
10 loops, best of 3: 46.9 msec per loop
</code></pre>
<p>In this case <code>xrange(100)</code> is only about 20% more efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>Everyone has explained it greatly. But I wanted it to see it for myself. I use python3. So, I opened the resource monitor (in Windows!), and first, executed the following command first:</p>
<pre><code>a=0
for i in range(1,100000):
    a=a+i
</code></pre>
<p>and then checked the change in 'In Use' memory. It was insignificant.
Then, I ran the following code:</p>
<pre><code>for i in list(range(1,100000)):
    a=a+i
</code></pre>
<p>And it took a big chunk of the memory for use, instantly. And, I was convinced.
You can try it for yourself.</p>
<p>If you are using Python 2X, then replace 'range()' with 'xrange()' in the first code and 'list(range())' with 'range()'.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Range</strong> returns a <strong>list</strong> while <strong>xrange</strong> returns an <strong>xrange</strong> object which takes the same memory irrespective of the range size,as in this case,only one element is generated and available per iteration whereas in case of using range, all the elements are generated at once and are available in the memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>range :-range will populate everything at once.which means every number of the range will occupy the memory.</p>
<p>xrange :-xrange is something like generator ,it will comes into picture when you want the range of numbers but you dont want them to be stored,like when you want to use in for loop.so memory efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the help docs.</p>
<p>Python 2.7.12</p>
<pre><code>&gt;&gt;&gt; print range.__doc__
range(stop) -&gt; list of integers
range(start, stop[, step]) -&gt; list of integers

Return a list containing an arithmetic progression of integers.
range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.
When step is given, it specifies the increment (or decrement).
For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!
These are exactly the valid indices for a list of 4 elements.

&gt;&gt;&gt; print xrange.__doc__
xrange(stop) -&gt; xrange object
xrange(start, stop[, step]) -&gt; xrange object

Like range(), but instead of returning a list, returns an object that
generates the numbers in the range on demand.  For looping, this is 
slightly faster than range() and more memory efficient.
</code></pre>
<p>Python 3.5.2</p>
<pre><code>&gt;&gt;&gt; print(range.__doc__)
range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object

Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).

&gt;&gt;&gt; print(xrange.__doc__)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'xrange' is not defined
</code></pre>
<p>Difference is apparent. In Python 2.x, <code>range</code> returns a list, <code>xrange</code> returns an xrange object which is iterable.</p>
<p>In Python 3.x, <code>range</code> becomes <code>xrange</code> of Python 2.x, and <code>xrange</code> is removed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Additionally, if do <code>list(xrange(...))</code> will be equivalent to <code>range(...)</code>.</p>
<p>So <code>list</code> is slow.</p>
<p>Also <code>xrange</code> really doesn't fully finish the sequence</p>
<p>So that's why its not a list, it's a <code>xrange</code> object</p>
</div>
<div class="post-text" itemprop="text">
<p>See this <a href="http://avinashv.net/2008/05/pythons-range-and-xrange/" rel="nofollow noreferrer">post</a> to find difference between range and xrange:</p>
<p>To quote:</p>
<blockquote>
<p><code>range</code> returns exactly what you think: a list of consecutive
  integers, of a defined length beginning with 0. <code>xrange</code>, however,
  returns an <em>"xrange object"</em>, which acts a great deal like an iterator</p>
</blockquote>
</div>
<span class="comment-copy">xrange is nto exactly a generator but it evaluates lazily and acts like a generator.</span>
<span class="comment-copy"><code>xrange(x).__iter__()</code> is a generator.</span>
<span class="comment-copy">Why did they make xrange, rather than making range lazy?</span>
<span class="comment-copy">@RobertGrant, they did. In Python 3. (They couldn't do that in the Python 2.x line, since all changes must be backwards compatible.)</span>
<span class="comment-copy">@Ratul it means that each <code>i</code> is evaluated on demand rather than on initialization.</span>
<span class="comment-copy">I don't see that being a huge problem (regarding breaking existing applications) as range was mostly for generating indexes to be used in for loops as "for i in range(1, 10):"</span>
<span class="comment-copy">+1 Thanks for this answer, the information about Python 3 replacing range with xrange is very useful.  I actually told someone to use xrange instead or range and they said that it did not matter in python 3, so I google searched for more information and this answer came up :)</span>
<span class="comment-copy">+1 for timeit example. Note: to run in windows cmd it is needed to use double quote, i.e. ". So code will be <code>python -m timeit "for i in xrange(1000000):" " pass"</code></span>
<span class="comment-copy">The main benefit of xrange is memory, not time.</span>
<span class="comment-copy">+1 for the practical answer:  <b>use range unless huge</b>.  BTW they are conceptually identical, correct?  Oddly no answer spells that out.</span>
<span class="comment-copy">If xrange is faster and doesn't hog memory, why ever use range?</span>
<span class="comment-copy">I agree with your statement generally, but your evaluation is wrong: <code>the extra overhead is only 0.04 seconds</code> isnt the correct way to look at it, <code>(90.5-51.1)/51.1 = 1.771 times slower</code> is correct because it conveys that if this is the core loop of your program it can potentially bottleneck it. However, if this is a small part then 1.77x isnt much.</span>
<span class="comment-copy">interesting observation. thanks for passing that along.</span>
<span class="comment-copy"><code>xrange</code> does <i>not</i> return an iterator.</span>
<span class="comment-copy"><code>and only keeps one number in memory at a time</code> and where the rest are placed please guide me..</span>
<span class="comment-copy">@SIslam If it knows the start, end, and current, it can compute the next, one at a time.</span>
<span class="comment-copy">The library is good but it's not always so easy to get the answer to the question you have.</span>
<span class="comment-copy">Go to the library reference, hit ctrl+f, search for range and you will get two results.  It's not much effort to find the answer to this question.</span>
<span class="comment-copy">The library reference is not working. Can you please update it?</span>
<span class="comment-copy"><code>xrange()</code> isn't a generator. <code>xrange(n)</code>.__iter__()` is.</span>
<span class="comment-copy">Running a benchmark like this, one time, doesnt provide exact timing results. There is always a variance.. It could be either GC, or another process stealing the CPU... anything. That's why benchmarks are usually run 10-100-1000-...</span>
<span class="comment-copy">this is just a hasty snippet printout - I ran it a few times, but only up to around 100, and <code>xrange</code> seemed slightly quicker, although with Python 3 the comparison is now redundant.</span>
<span class="comment-copy">This is what <code>timeit</code> is for. It takes care of running many times, disabling GC, using the best clock instead of <code>time</code>, etc.</span>
<span class="comment-copy">Nice answer.  Happy I scrolled all the way down here.</span>
<span class="comment-copy"><code>xrange</code> does not return a generator object.</span>
<span class="comment-copy">If I understand correctly, that is how it is explained here(for Python 2.x): <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">wiki.python.org/moin/Generators</a></span>
<span class="comment-copy">Then the wiki is wrong. (I don't know who the "SH" is who added and signed that comment.) <a href="https://docs.python.org/2.7/library/stdtypes.html#xrange-type" rel="nofollow noreferrer">The official documentation</a> is right; you can test it yourself and see whether it's a generator or a sequence.</span>
<span class="comment-copy">ok. But it's still confusing after reading this: <a href="http://stackoverflow.com/questions/135041/should-you-always-favor-xrange-over-range#comment42311275_135041" title="should you always favor xrange over range%23comment42311275_135041">stackoverflow.com/questions/135041/â€¦</a></span>
<span class="comment-copy">The fun question is what to do when the interpreter disagrees with the official docs, or with a different interpreterâ€¦ But fortunately, that doesn't come up too oftenâ€¦</span>
<span class="comment-copy"><code>xrange</code> does not create an iterator instance. It creates an <code>xrange</code> object, which is iterable, but not an iteratorâ€”almost (but not quite) a sequence, like a list.</span>
<span class="comment-copy">I realize this is 5 years old, but that post is wrong about nearly everything. <code>xrange</code> is not an iterator. The list returned by <code>range</code> does support iteration (a list is pretty much the prototypical example of an iterable). The overall benefit of <code>xrange</code> is not "minimal". And so on.</span>
