<div class="post-text" itemprop="text">
<p>I have a script (Python) that uses subprocess to call another script. The parent script writes to the console and a log file at the same time (I used the code from the accepted answer to <a href="https://stackoverflow.com/questions/11325019/output-on-the-console-and-file-using-python/%20%22this%20link:">this question</a> to split the output), but the child process print statements are only going to stdout, not to the log file.</p>
<p>I do know why this is: the subprocess has stdout set to normal stdout, not the special tee object that the parent process has. I tried passing the tee object as an argument to the subprocess, but I learned the hard way that you cannot pass objects as arguments to subprocesses. My backup plan was to pass in the path string for the file to write to, and then have the subprocess make its own tee object with the same file. </p>
<p>My question is, if both processes are writing to the same file at the same time, will the output be messed up? I'm using open("file", 'w') in the parent process, and this is called first, and I'm using open("file", 'a') in the child process. Hypothetically, the file should contain the output of the print statements in the correct order, because appending to a file with 'a' means that the lines will always be added to what is currently the end of the file, will it not? Or are there rules about opening a file that prevent it from being opened by 2 processes at the same time?</p>
<p>POST_TEST: after doing some tests myself, I found the following:
-You are allowed to open("file", 'w') multiple times in a row
-You are allowed to open("file", 'w') and then open("file", 'a')
-In the first case, the child process overwrites the file completely.
-In the second case, the order is not correct, and some output seems to be lost.</p>
<p>My new question then, is what alternative solution should I use to write to a file from both the parent and child process at the same time, without getting lines out of order or overlapping?</p>
</div>
<div class="post-text" itemprop="text">
<p>Thank you <a href="https://stackoverflow.com/users/1491895/barmar">Bamar</a> for the suggestions: using 'a' for both the first and second open() works. If you need to do this for a file that already exists, you can use file.truncate() to empty the file before appending to it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Opening a file in <code>'w'</code> mode truncates the file (<a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">as documented</a>). Opening a file in <code>'a'</code> mode may work on <em>some</em> systems. <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html" rel="nofollow noreferrer">POSIX says for <code>O_APPEND</code> flag</a>:</p>
<blockquote>
<p>If set, the file offset shall be set to the end of the file prior to each write.</p>
</blockquote>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html" rel="nofollow noreferrer"><code>write()</code>s that are larger than <code>PIPE_BUF</code> may interleave</a>:</p>
<blockquote>
<p>POSIX.1-2008 does not say whether write requests for more than {PIPE_BUF} bytes are atomic, but requires that writes of {PIPE_BUF} or fewer bytes shall be atomic.</p>
</blockquote>
<hr/>
<blockquote>
<p><strong>Q:</strong> what alternative solution should I use to write to a file from both the parent and child process at the same time, without getting lines out of order or overlapping?</p>
</blockquote>
<p>Open the files using line-buffering mode (<code>1</code>), to flush the internal buffer at the end of each line -- it should preserve the approximate relative order of the lines. If lines are less than <code>PIPE_BUF</code> (4096 bytes on my system) then they should not "overlap".</p>
<hr/>
<p>The subprocess may write data to its standard output and your parent Python process may write it to a file in any order you like. See <a href="https://stackoverflow.com/q/25750468/4279">how <code>teed_call()</code> function is implemented</a>.</p>
</div>
<span class="comment-copy">Google "mutex".  A mutex is a MUTually EXclusive  lock on a resource, that avoids collisions when two processes use the same resource.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/489861/locking-a-file-in-python" title="locking a file in python">stackoverflow.com/questions/489861/locking-a-file-in-python</a></span>
<span class="comment-copy">The process that opens in <code>a</code> mode will always write at the end of the file. But the one that opens in <code>w</code> mode will not. You need to open them both in <code>a</code> mode.</span>
<span class="comment-copy">@JuanTomas I actually learned about mutexes last year in a C++ class, didn't think of using one here. Thanks for the tip</span>
<span class="comment-copy">Call <code>file.truncate()</code> after you open it in the parent process.</span>
<span class="comment-copy">It is not guaranteed that all writes are at the end on all systems if the file is opened in <code>'a'</code> mode. It is not guaranteed that larges <code>write()</code>s are atomic (the output from several processes may interleave).</span>
<span class="comment-copy">I don't mind the downvote but I would appreciate an explanation that would allow to make the answer better.</span>
<span class="comment-copy">I hate it when people downvote without saying why they're doing it</span>
