<div class="post-text" itemprop="text">
<p>Suppose I have an object of the structure:</p>
<pre><code>class Obj:
  def match(other):
    return check_match(self, other)
</code></pre>
<p>For example, <code>check_match</code> could check for overlap or for equality or for "is friend".</p>
<p>Now I'll have a list of those objects:</p>
<pre><code>objList = create_random_list_of_Obj()
</code></pre>
<p>Now, for each element which matches other elements, I d like to keep only one of those mutually matching elements.</p>
<p>Remark and clarification:
So far, the task is ambiguous: If A and B match, and B and C match, but A and C do not match, then we could keep A and C or we could keep B. It's not important, which decision the algorithm will take. <strong>The important thing is, that there are no matching elements in the final list.</strong> </p>
<p>Two questions:</p>
<ul>
<li><strong>What is the pythonic way to do so?</strong></li>
<li>Does this problem have a name?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<h2>Regarding: What is the pythonic way to do so?</h2>
<p>The pythonic way is to rename your <code>match</code> method to <code>__eq__</code>.</p>
<p>Then you can do things like <code>element in list</code> with your custom object.</p>
<p>A very pythonic way to make a list contain unique items is then:</p>
<pre><code>uniques = list(set(list_with_duplicates))
</code></pre>
<p><strong>Edit:</strong> <code>__ne__</code> is not needed and will default to <code>not __eq__()</code></p>
<h2>Does this problem have a name?</h2>
<p>One could look for "equivalence classes". </p>
<p>Some references:</p>
<ul>
<li>implementing <code>__eq__</code> in your own class: <a href="https://stackoverflow.com/questions/390250/elegant-ways-to-support-equivalence-equality-in-python-classes">Elegant ways to support equivalence ("equality") in Python classes</a> </li>
<li>stdlib docs on <code>__eq__</code>: <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#object.<strong>eq</strong></a></li>
<li>how <code>element in list</code> works behind the scenes: <a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow noreferrer">https://docs.python.org/3/reference/expressions.html#membership-test-details</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Python has a type of <code>contains</code> method that works with the following syntax: <code>if x in y:</code> Use it to determine if a list contains an obj</p>
<pre><code>a = ["a", "b", "c", "d", "d"]
b = ["c", "c", "d", "e", "f"]
c = []

for member in a:
  if member in b and member not in c:
    c.append(member)
</code></pre>
<p>Should result in <code>c = ["c", "d"]</code></p>
</div>
<span class="comment-copy">The idea with the set seems smart, at least for transitive a <code>match</code> (equality for example). I wonder what will happen, if <code>match</code> is not transitive: "is friend" for example. A can B friend with B, B can be friend with C, but A is not necessarily friend with C.</span>
<span class="comment-copy">@Michael The setup with set and <code>__eq__</code> still works, it would make sure that you only have one of {A,B} and one of {B,C}, but would allow both {A,C}. The outcome is not deterministic then, since if you start with {A,B,C} you can end with {A,C} or {B}. But on the other hand your questions is not deterministic if "is friend" is not transitive.</span>
<span class="comment-copy">I'm aware that the solution to the given task is not unique. Application will be the removal of overlapping objects (not transitive) as well as removal of equal elements in a list (transitive). The only constraint in both cases is the same: Have no matching pairs in the final list. But I see that the non-transitive case could be extended to a difficult task when more constraints would apply ("keep as many as possible", "loose no matching group"). Full-fledged graph theory problems...</span>
<span class="comment-copy">The way that you have interpreted this problem, there are better solutions. For instance, using set intersections, or a direct list comprehension.</span>
<span class="comment-copy">Sorry, no, this does NOT solve the given problem.</span>
