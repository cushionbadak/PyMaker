<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/2.7/library/itertools.html" rel="nofollow">itertools</a> python module implements some basic building blocks for iterators. As they say, "they form an iterator algebra". I was expecting, but I could not find a succinctly way of doing the following iteration using the module. Given a list of ordered real numbers, for example</p>
<pre><code>a = [1.0,1.5,2.0,2.5,3.0]
</code></pre>
<p>... return a new list (or just iterate) grouping by some <code>n</code> value, say <code>2</code></p>
<pre><code>b = [(1.0,1.5),(1.5,2.0),(2.0,2.5),(2.5,3.0)]
</code></pre>
<p>The way I found of doing this was as follows. First split the list in two, with evens and odds indexes:</p>
<pre><code>even, odds = a[::2], a[1::2]
</code></pre>
<p>Then construct the new list:</p>
<pre><code>b = [(even, odd) for even, odd in zip(evens, odds)]
b = sorted(b + [(odd, even) for even, odd in zip(evens[1:], odds)])
</code></pre>
<p>In essence, it is similar to a moving mean. </p>
<p><strong>Is there a succinctly way of doing this (with or without itertools)?</strong> </p>
<hr/>
<p>PS.:</p>
<p><strong>Application</strong></p>
<p>Imagine the <code>a</code> list as the set of timestamps of some events occurred during an experiment:</p>
<pre><code>timestamp       event
47.8            1a
60.5            1b
67.4            2a
74.5            2b
78.5            1a
82.2            1b
89.5            2a
95.3            2b
101.7           1a
110.2           1b
121.9           2a
127.1           2b

...
</code></pre>
<p>This code is being used to segment those events in accord with different temporal windows. Right now I am interested in the data between <code>2</code> successive events; 'n &gt; 2' would be used only for exploratory purposes.</p>
</div>
<div class="post-text" itemprop="text">
<p>For 2, you can just do</p>
<pre><code>b = zip(a, a[1:])  # or list(zip(...)) on Python 3 if you really want a list
</code></pre>
<p>For fixed n, the technique is similar:</p>
<pre><code># n = 4
b = zip(a, a[1:], a[2:], a[3:])
</code></pre>
<p>For variable n, you could zip a variable number of slices, or (especially if the window size is close to the size of <code>a</code>) you could use slicing to take windows directly:</p>
<pre><code>b = zip(*[a[i:] for i in xrange(n)])
# or
b = [tuple(a[i:i+n]) for i in xrange(len(a)-n+1)]
</code></pre>
<p>If <code>a</code> is not a list, you could generalize the <code>pairwise</code> recipe from the itertools docs:</p>
<pre><code>import copy
import itertools

def nwise(iterable, n):
    # Make n tees at successive positions along the iterable.
    tees = list(itertools.tee(iterable, 1))
    for _ in xrange(n-1):
        tees.append(copy.copy(tees[-1]))
        next(tees[-1])

    return zip(*tees)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is precisely what the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer"><code>pairwise</code> itertools recipe</a> is for, for <code>n=2</code> that is.  </p>
<pre><code>from itertools import tee

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)
</code></pre>
<p><strong>Demo</strong>:</p>
<pre><code>&gt;&gt;&gt; b = [1.0,1.5,2.0,2.5,3.0]
&gt;&gt;&gt; list(pairwise(b))
[(1.0, 1.5), (1.5, 2.0), (2.0, 2.5), (2.5, 3.0)]
</code></pre>
<p>If you are looking for variable group sizes, see <a href="https://stackoverflow.com/a/38151577/4686625">user2357112's answer</a> (I like the approach), or more generally you can implement a sliding window iterator and take slices <a href="https://stackoverflow.com/questions/6822725/rolling-or-sliding-window-iterator-in-python">of which there are many approaches</a>. </p>
<hr/>
<p>As an aside, a possibly poorly performing but amusing one-line window you could slice (<em>to control the overlap</em>) that isn't on the linked question would be this, using the new <code>yield from</code> syntax to combine generators. </p>
<pre><code>from itertools import tee, islice
def roll_window(it, sz):
    yield from zip(*[islice(it, g, None) for g, it in enumerate(tee(it, sz))])
</code></pre>
<p><strong>Demo</strong>:</p>
<pre><code>&gt;&gt;&gt; b = [1.0,1.5,2.0,2.5,3.0, 3.5, 4.0, 4.5]
&gt;&gt;&gt; list(islice(window(b, 3), None, None, 2))
[(1.0, 1.5, 2.0), (2.0, 2.5, 3.0), (3.0, 3.5, 4.0)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a generator:</p>
<pre><code>def groupListByN(lst, n):
  for i in range(len(a)-n+1):
    yield lst[i:i+n]

a = [1.0,1.5,2.0,2.5,3.0]
myDoubleList = [group for group in groupListByN(a, 2)]
myTripleList = [group for group in groupListByN(a, 3)]

print(myDoubleList)
print(myTripleList)
</code></pre>
<p>Result:</p>
<pre><code>[[1.0, 1.5], [1.5, 2.0], [2.0, 2.5], [2.5, 3.0]]
[[1.0, 1.5, 2.0], [1.5, 2.0, 2.5], [2.0, 2.5, 3.0]]
</code></pre>
<p>I think this solution is pretty succinct</p>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned, the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>pairwise</code> recipe</a> does overlapping pairs.</p>
<p>This recipe is also implemented in an external library, <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a>, among other helpful <a href="https://more-itertools.readthedocs.io/en/stable/api.html#windowing" rel="nofollow noreferrer">windowing tools</a>:</p>
<pre><code>import more_itertools as mit


a = [1.0, 1.5, 2.0, 2.5, 3.0]

list(mit.pairwise(a))
# [(1.0, 1.5), (1.5, 2.0), (2.0, 2.5), (2.5, 3.0)]

list(mit.windowed(a, n=2))
# [(1.0, 1.5), (1.5, 2.0), (2.0, 2.5), (2.5, 3.0)]

list(mit.stagger(a, offsets=(0, 1)))
# [(1.0, 1.5), (1.5, 2.0), (2.0, 2.5), (2.5, 3.0)]
</code></pre>
<p>Notice, with <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed" rel="nofollow noreferrer"><code>more_itertools.windowed</code></a>, you can control <code>n</code>, the size of the sliding window (and even the amount of overlap via a <code>step</code> parameter if needed).  This tool may be useful in you exploration.</p>
<p>Install this library via <code>&gt; pip install more_itertools</code>.</p>
</div>
<span class="comment-copy">@glibdud: Ah, you're right. The single tee is still wrapped in a one-element tuple.</span>
<span class="comment-copy">You second example should be <code>b = [tuple(a[i:i+n]) for i in xrange(len(a)-n+1)]</code>, unless I've overlooked something. It would seem that it is missing a <code>+1</code>.</span>
<span class="comment-copy">@RoadRunner: Yup, you're right. Fixed.</span>
