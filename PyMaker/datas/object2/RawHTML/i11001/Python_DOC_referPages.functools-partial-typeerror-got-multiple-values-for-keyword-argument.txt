<div class="post-text" itemprop="text">
<p>I am using the partial method from the functools module to map a function over a range of values:</p>
<pre><code>def basic_rule(p,b,vx=1,**kwargs):
    return (p / b) if vx != 0 else  0

def rule5(func,**kwargs):
    vals = map(functools.partial(func,**kwargs), range(1,kwargs['b']+1))
    return [x for i,x in enumerate(vals[:-1]) if x &gt;= vals[i+1]] == []

rule5(basic_rule,p=100,b=10000)
</code></pre>
<p>Here is the error I get on line 5:</p>
<pre><code>----&gt; return map(functools.partial(func,**kwargs), range(1,kwargs['b']+1))

TypeError: basic_rule() got multiple values for keyword argument 'p'
</code></pre>
<p>It looks like functools.partial is trying to assign the range to the argument p, even though I have already assigned a value to it. I'm trying to assign the range to the value of vx. Any idea how I can make that happen?</p>
<p>EDIT: Added a little bit of extra context to the code. Essentially what I'd like test 5 to do is ensure that the result of the function given to it increases as vt goes up, so that `func(vt=1) &lt; func(vt=2)... &lt; func(vt=n).</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow">functools.partial</a> generates a partial that stores the arguments receiveids in 2 properties:</p>
<ul>
<li><code>arguments</code> stores positional arguments</li>
<li><code>keywords</code> stores all keyword-based arguments</li>
</ul>
<p>So the partial can call original function exactly as was intended. In other words, when you call the resulting partial with one argument (let's say, 1) it would be the same as:</p>
<pre><code>original_func(1, **kwargs)
</code></pre>
<p>As your <code>kwargs</code> contains the first argument - and you're passing the "1" as a positional argument - you get the error.</p>
<p>I'm not sure if it's gonna work in this particular case, but one solution could be use <a href="https://docs.python.org/2/library/inspect.html#inspect.getargspec" rel="nofollow">inspect.getargspec</a> to extract arguments from <code>kwargs</code> that can be passed as positional arguments. In this case, the <code>rule5</code> function would be similar to:</p>
<pre class="lang-py prettyprint-override"><code>def rule5(func, **kwargs):
    # let's save 'b' argument because we'll need it in the range call
    b = kwargs['b']
    original_args = inspect.getargspec(func).args
    # extract from kwargs all arguments that can be passed as positional
    new_args = [kwargs.pop(key) for key in original_args if key in kwargs]
    # construct the partial passing as much positional arguments as possible
    fn = functools.partial(func, *new_args, **kwargs)
    # now map will pass the range result as the next positional argument
    vals = map(fn, range(1, b+1))
    return [x for i,x in enumerate(vals[:-1]) if x &gt;= vals[i+1]] == []
</code></pre>
</div>
<span class="comment-copy">What is the purpose of <code>**kwargs</code> in basic_rule?</span>
<span class="comment-copy">Why are you using <code>functools.partial()</code> instead of a lambda?</span>
<span class="comment-copy">Changing to <code>kwargs["p"] / kwargs["b"]  if vx != 0 else 0</code> and the function signature to <code>basic_rule(vx=1, **kwargs):</code> would avoid the  error but not sure what your end goal is</span>
<span class="comment-copy">@PadraicCunningham, I have multiple tests for each function (similar to rule5) which pass arguments into the inner function and test the output. The functions don't all have the same keyword arguments, so I used **kwargs to allow me to pass whichever arguments are needed for a function.</span>
<span class="comment-copy">@MoeChughtai, yes I think there might be, if you add what you want as output and why you may have better luck getting a good solution to your issue.</span>
