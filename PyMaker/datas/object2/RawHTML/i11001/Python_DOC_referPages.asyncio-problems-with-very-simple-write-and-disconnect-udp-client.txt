<div class="post-text" itemprop="text">
<p>I wanted to try out the new <code>asyncio</code> module from Python 3.5.1. Here's my test code:</p>
<pre><code>import asyncio

class EchoClientProtocol:
    def __init__(self, message, loop):
        self.message = message
        self.loop = loop
        self.transport = None

    def connection_made(self, transport):
        self.transport = transport
        print('Send:', self.message)
        self.transport.sendto(self.message.encode())
        self.transport.close()

    def datagram_received(self, data, addr):
        print("Received:", data.decode())

        print("Close the socket")
        #self.transport.close()

    def error_received(self, exc):
        print('Error received:', exc)

    def connection_lost(self, exc):
        print("Socket closed, stop the event loop")
        loop = asyncio.get_event_loop()
        loop.stop()

loop = asyncio.get_event_loop()
message = "Hello World!"
connect = loop.create_datagram_endpoint(
    lambda: EchoClientProtocol(message, loop),
    remote_addr=('127.0.0.1', 9999))
transport, protocol = loop.run_until_complete(connect)
loop.run_forever()
transport.close()
loop.close()
</code></pre>
<p>When I run this, the interpreter gives me:</p>
<pre><code>Traceback (most recent call last):
  File "C:\Users\oxygen\Documents\GitProjects\tests\python\udp\client.py", line
35, in &lt;module&gt;
    loop.run_forever()
  File "C:\Python35-32\lib\asyncio\base_events.py", line 295, in run_forever
    self._run_once()
  File "C:\Python35-32\lib\asyncio\base_events.py", line 1218, in _run_once
    event_list = self._selector.select(timeout)
  File "C:\Python35-32\lib\selectors.py", line 314, in select
    r, w, _ = self._select(self._readers, self._writers, [], timeout)
  File "C:\Python35-32\lib\selectors.py", line 305, in _select
    r, w, x = select.select(r, w, w, timeout)
OSError: [WinError 10038] an operation was attempted on something that is not a socket
</code></pre>
<p>I think this is caused by the sequence of <code>self.transport.sendto(self.message.encode())</code> and <code>self.transport.close()</code>. If I understand correctly, the <code>sendto</code> method is asynchronous and it actually gets invoked after I close the socket by calling the <code>close</code> method. Is there any way to solve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>DatagramTransport</code> (actually <code>_SelectorDatagramTransport</code>) schedules two actions on connection, the first one is <code>connection_made</code> from given protocol, the second is <code>_read_ready</code> (recvfrom) - in that order (<a href="https://github.com/python/asyncio/blob/master/asyncio/selector_events.py#L996" rel="nofollow">https://github.com/python/asyncio/blob/master/asyncio/selector_events.py#L996</a>).</p>
<p>Since you close transport on <code>connection_made</code>, the following action (<code>_read_ready</code>) fails. Remove <code>self.transport.close()</code> from there.</p>
<p>You might find interesting the asyncio <a href="https://github.com/python/asyncio/blob/master/examples/udp_echo.py" rel="nofollow">udp examples</a>.</p>
</div>
<span class="comment-copy">Hey, thanks for your comment! My code is actually pretty much an edited version of the example you linked.  Could you please provide some more help, on how to open the connection without the reading action? I would really like to just establish the connection, send data and close it. I was trying to find some help in the docs, and I found <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection" rel="nofollow noreferrer">this method</a>, would that help me?</span>
<span class="comment-copy">UDP is connectionless protocol (<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" rel="nofollow noreferrer">en.wikipedia.org/wiki/User_Datagram_Protocol</a>)</span>
