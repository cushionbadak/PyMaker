<div class="post-text" itemprop="text">
<p>Given a sequence of non-negative integers <code>a0,…,an−1,</code> find the maximum pairwise product, that is, the largest integer that can be obtained by multiplying two different elements from the sequence (or, more formally, <code>max0≤i≠j≤n−1aiaj</code>). Different elements here mean ai and aj with <code>i≠j</code> (it can be the case that <code>ai=aj</code>).</p>
<p>Input format</p>
<p>The first line of the input contains an integer n. The next line contains n non-negative integers <code>a0,…,an−1</code>.</p>
<p>Constraints</p>
<p><code>2≤n≤2⋅105; 0≤a0,…,an−1≤105</code>.</p>
<p>Output format</p>
<p>Output a single number — the maximum pairwise product.</p>
<p>This code works fine but sometimes when I run it it shows:</p>
<pre><code>Traceback (most recent call last):
  File "C:\Users\gauta\AppData\Local\Programs\Python\Python35\gen.py", line 26, in &lt;module&gt;
    print(max(c))
ValueError: max() arg is an empty sequence
</code></pre>
<p>It shows This Only when Total elements in list 'a' are 2 or 3.</p>
<p>How can I improve this code and fix that problem, and will this code show a time limit exceeded or integer overflow bug?</p>
<pre><code>import random  
import time  
b=time.time()  
a=list()  
c=list()   
n=random.randint(2,12)  
#appending random numbers in a list 'a'
g=1  
while(g&lt;=n): 
   a.append(random.randint(0,10))  
   g=g+1  
print(a)  
print("Total elements in the list= %s"%len(a))  
#Appending Done
for i in range(2,n):
    for j in range (2,n):               
       if a[i]*a[j]&gt;0:
           if a[i]!=a[j]:  
               m=a[i]*a[j]  
               c.append(m)   
           else:  
               continue  
      else:  
           continue  
print(max(c))  
time=time.time()-b  
print("%s"%(time.time()-b))  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code has two flaws:</p>
<ul>
<li><p>You run two loops with <code>range(2, n)</code>, but <code>n</code> randomly can be set to <code>2</code>. <code>range(2, 2)</code> is an <em>empty sequence</em>, so your loop body will not run and you end up with an empty list <code>c</code></p></li>
<li><p>You mask the name <code>time</code> by assigning the result of the <code>time.time() - b</code> expression to it. Any further attempts to access <code>time.time</code> will give you an <code>AttributeError</code> as a floating point object has no such attribute. Rename that variable.</p></li>
</ul>
<p>Next, you are using a O(N^2) approach; exponential growth in time used for every increase of the number of elements in <code>a</code>. This is certainly going to hit the time limits very quickly. All you need is to find the <em>two largest integers</em> in <code>a</code> and multiply those; this can be done in O(N) linear time. So if <code>len(a)</code> is 1000, your approach requires 1 million steps, while a linear time approach would only take 1000 steps.</p>
<p>The most efficient way to find K largest numbers in a sequence, is to use the <a href="https://docs.python.org/3/library/opertat" rel="nofollow"><code>heapq.nlargest()</code> function</a>, which finds those numbers in O(NlogK) time; for a fixed K=2, that makes this a O(N) linear time approach. You can use the <a href="https://docs.python.org/3/library/operator.html#operator.mul" rel="nofollow"><code>operator.mul()</code> function</a> to multiply the two integers found:</p>
<pre><code>import heapq
import operator

if len(a) &gt; 1:
    result = operator.mul(*heapq.nlargest(2, a))
elif a:
    result = a[0]  # only one number, it's the largest
else:
    result = None  # no numbers, no result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is not recommended to use variable name which are also the name of modules you are using </p>
<pre><code>import random  
import time  
b=time.time()  
a=list()  
c=list()   
n=random.randint(2,12)  
#appending random numbers in a list 'a'
g=1  
while(g&lt;=n):
    a.append(random.randint(0,10))
    g=g+1  
print(a)  
print("Total elements in the list= %s"%len(a))  
#Appending Done
for i in range(2,n):
    for j in range (2,n):
        if a[i]*a[j]&gt;0:
            if a[i]!=a[j]:  
                m=a[i]*a[j]  
                c.append(m)   
            else:  
                continue  
        else:  
            continue  
print(max(c))  
othertime=time.time()-b
print(type(othertime)) #here in this line you changed the time to float     value hence now onwards you can't use time module as you were using before hence i renamed time variable to other.   
print("%s" %(time.time()-b))  
</code></pre>
<p>By changing variable name time to other time you can use time module again so remember this thing in future never to name variables with other modules name or keywords name otherwise their behavior will get lost in your code.</p>
</div>
<span class="comment-copy"><code>time=time.time()-b</code> replaces the name <code>time</code>. This code <i>never</i> works.</span>
<span class="comment-copy">You are overwriting <code>time</code> in the line <code>time = time.time()-b</code>, just change to <code>t = time.time()-b</code> and <code>print(t)</code></span>
<span class="comment-copy">thanks this solves time problem .Any suggestion how can i make this code work more faster and free of integer overflow bug(if any)</span>
<span class="comment-copy">Very uninformative title, which doesn't help future searches. Perhaps 90% of threads could have that title. Please make it more specific.</span>
<span class="comment-copy">Thanks Martijn.I was not not aware of heapq and operator module, now i can use it in my code</span>
<span class="comment-copy">Thanks Rajan.I will rectify it</span>
<span class="comment-copy">This did not correct the random <code>ValueError</code> exception.</span>
