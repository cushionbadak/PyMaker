<div class="post-text" itemprop="text">
<p>I am defining a variable through an empty declaration:</p>
<pre><code>In [1]: a = bool()

In [2]: a
Out[2]: False
</code></pre>
<p>Is it possible to force an initialization of <code>True</code>?</p>
<hr/>
<p>Note: I know I can simply have <code>a = True</code> or <code>a = bool(True)</code> but I will be initializing several variables with specific types, something like</p>
<pre><code>x = dict()
for v in [('a', int), ('b', float), ('c', bool)]
    x[v[0]] = v[1]()
</code></pre>
<p>The defaults for <code>int</code>, <code>float</code>, etc. are OK, I would just prefer to specifically have a <code>bool</code> initialized as <code>True</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial</code></a> to customize your <code>bool</code>:</p>
<pre><code>from functools import partial

my_bool = partial(bool, 1)

print(my_bool())
# True
</code></pre>
<p>And you can use it in your code as:</p>
<pre><code>x = dict()
for v in [('a', int), ('b', float), ('c', my_bool)]
    x[v[0]] = v[1]()
</code></pre>
<p>You could also use a lambda (credit: @tobias_k):</p>
<pre><code>my_bool = lambda: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe a possible solution for you with the flexibility for other special default values</p>
<pre><code>typeDefaults = {bool: True}

for v in [('a', int), ('b', float), ('c', bool)]:
    x[v[0]] = typeDefaults[v[1]] if v[1] in typeDefaults else v[1]()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could map the types you want to change the default values for to your own functions:</p>
<pre><code>&gt;&gt;&gt; defaults = {bool: lambda: True}
&gt;&gt;&gt; x = {}
&gt;&gt;&gt; for k, v in [('a', int), ('b', float), ('c', bool)]:
...     x[k] = defaults.get(v, v)()
... 
&gt;&gt;&gt; x
{'a': 0, 'c': True, 'b': 0.0}
</code></pre>
<p>or using a dictionary comprehension:</p>
<pre><code>&gt;&gt;&gt; {k: defaults.get(v, v)() for k, v in [('a', int), ('b', float), ('c', bool)]}
{'a': 0, 'c': True, 'b': 0.0}
</code></pre>
</div>
<span class="comment-copy">Ah excellent - I did not know <code>partial</code>, very useful function. Thank you.</span>
<span class="comment-copy">Or a lambda: <code>my_bool = lambda: True</code></span>
<span class="comment-copy">@tobias_k I kept thinking of a work around with <code>bool</code>. Sleek! Thanks.</span>
<span class="comment-copy">You're going to be surprised if you try to do <code>my_bool(0)</code></span>
<span class="comment-copy">@eugeney I wouldn't call it a surprise. OP has a use case. And if one did that, it will break like every other function that does not take positional arguments.</span>
