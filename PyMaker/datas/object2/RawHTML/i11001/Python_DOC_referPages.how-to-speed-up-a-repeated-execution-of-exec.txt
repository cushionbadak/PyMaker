<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>for k in pool:
    x = []
    y = []

    try:
        exec(pool[k])
    except Exception as e:
        ...
    do_something(x)
    do_something_else(y)
</code></pre>
<p>where <code>pool[k]</code> is python code that will eventually append items to <code>x</code> and <code>y</code> (that's why I am using <code>exec</code> instead of <code>eval</code>).</p>
<p>I have tried already to execute the same code with pypy but for this particular block I don't get much better, that line with <code>exec</code> is still my bottleneck.</p>
<p>That said, my question is:
Is there a faster alternative to <code>exec</code>?</p>
<p>If not, do you have any workaround to get some speed up in such a case?</p>
<p><strong>--UPDATE--</strong></p>
<p><strong>To clarify</strong>, <code>pool</code> contains around one million keys, to each key it is associated a script (around 50 line of code). The inputs for the scripts are defined before the <code>for loop</code> and the outputs generated by a script are stored in <code>x</code> and <code>y</code>. So, each script has a line in the code stating <code>x.append(something)</code> and <code>y.append(something)</code>. The rest of the program will evaluate the results and score each script. Therefore, I need to loop over each script, execute it and process the results. The scripts are originally stored in different text files. <code>pool</code> is a dictionary obtained by parsing these files.</p>
<p>P.S.
Using the pre-compiled version of the code:</p>
<pre><code>for k in pool.keys():
    pool[k] = compile(pool[k], '&lt;string&gt;', 'exec')
</code></pre>
<p>I have got 5x speed increase, not much but it is something already. I am experimenting with other solutions...</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really need to execute some code in such manner, use compile() to prepare it.</p>
<p>I.e. do not pass raw Python code into exec but compiled object. Use compile() on your codes before to make them Python byte compiled objects.</p>
<p>But still, it'll make more sense to write a function that will perform what you need on an input argument i.e. pool[k] and return results that are corresponding to x and y.</p>
<p>If you are getting your code out of a file, you have also IO slowdowns
 to cope with. So it would be nice to have these files already compiled to *.pyc.</p>
<p>You may think about using execfile() in Python2.</p>
<p>An idea for using functions in a pool:</p>
<pre><code>template = """\
def newfunc ():
%s
    return result
"""

pool = [] # For iterating it will be faster if it is a list (just a bit)
# This compiles code as a real function and adds a pointer to a pool
def AddFunc (code):
    code = "\n".join(["    "+x for x in code.splitlines()])
    exec template % code
    pool.append(newfunc)

# Usage:
AddFunc("""\
a = 8.34**0.5
b = 8
c = 13
result = []
for x in range(10):
    result.append(math.sin(a*b+c)/math.pi+x)"""

for k in pool:
    x = pool[k]()
</code></pre>
</div>
<span class="comment-copy">I assume you know what you're doing and are fully aware of the potential <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">security risks of using <code>exec</code></a>... You can get some speedup if you <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow noreferrer"><code>compile</code></a> the code you pass to <code>exec</code>, especially if you are executing the same code multiple times. See <a href="http://stackoverflow.com/a/29456463/4014959">this answer</a> for a whole lot of info about <code>eval</code>, <code>exec</code>, and <code>compile</code>.</span>
<span class="comment-copy">I am aware of the security risks, I am just running code locally and is just a bunch of math formulas. I will check <code>compile</code>. Thanks.</span>
<span class="comment-copy">If <code>exec()</code> really is the bottleneck, avoid using it. Make <code>pool</code> a dictionary of functions that each contain the code you want executed, and then just call the proper one with <code>pool[k](x, y)</code>.</span>
<span class="comment-copy">The code does contains also if/else and other stuff, but more important, I get the code from a textfile, so I have it as string in the first place.</span>
<span class="comment-copy">Are you re-executing each item from pool, or are they just throw-away?</span>
<span class="comment-copy">x and y are lists, they store the some value that will be generated by the exec(code), so part of the code in it is x.append(something). I will try <code>exec(compile(code))</code></span>
<span class="comment-copy">Woops, sorry, saw wrong. Trouble with encoding. I thought there were ( ) instead of [ ].  Why aren't you x.append()-ing in the loop?</span>
<span class="comment-copy">@alec_djinn : There, i edited the A to correct the mistake. Sorry again.</span>
<span class="comment-copy">yes, I know that x and y are initialized to [] at every iteration, it's ok it's meant to do like that. Basically, pool contains lots of different math functions that are supposed to produce some results, the results are appended to x and y and then other code (<code>...</code>) will evaluate how good the results are etc etc... At every iteration a different set of functions are evaluated.</span>
<span class="comment-copy">Then I may recommend writing these as functions and saving pointers to these functions into pool. Then you can do pool["one_func"]() etc. etc. How do you generate these functions in advance is not important. You may still use exec but your functions will be global and only pointers passed through a loop. Very fast.</span>
