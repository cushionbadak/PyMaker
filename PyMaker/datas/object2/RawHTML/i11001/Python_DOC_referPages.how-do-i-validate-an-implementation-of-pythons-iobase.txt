<div class="post-text" itemprop="text">
<p>Is there an existing test suite I can make use of to test an implementation of <code>IOBase</code>? If possible, I would like to exhaustively test a new implementation, but there are a lot of tests that would need to be manually written.</p>
<p>For instance, say I have a non-seekable, non-writeable stream. I want to validate that my implementation of <code>read</code> is compliant and that all other methods raise the right kinds of errors. Such a class might look like this:</p>
<pre><code>import io


class NonSeekableReader(io.RawIOBase):
    def __init__(self, b=b''):
        super(NonSeekableReader, self).__init__()
        self._data = io.BytesIO(b)

    def seekable(self):
        return False

    def writable(self):
        return False

    def readable(self):
        return True

    def read(self, n=-1):
        return self._data.read(n)
</code></pre>
<p>Maybe read works as I initially expect, but maybe there are edge cases I would miss with a more complicated implementation. Experimentation has shown that the docs are at the very least confusing as to what expected behavior is.</p>
<p>Based on the <a href="https://docs.python.org/3/library/io.html#io.IOBase.writable" rel="nofollow">python docs</a> I can see that by defining <code>writeable</code> to return <code>False</code>, <code>write</code> should raise an <code>OSError</code> (in Python 3.5). This is actually not true, it will raise <code>NotImplementedError</code> when inheriting from <code>RawIOBase</code> or <code>AttributeError</code> when inheriting from <code>IOBase</code>. This behavior is not duplicated in <code>seekable</code>, i.e. calling <code>.tell()</code> raises the correct error. To fix the issue, I define <code>write</code> like so:</p>
<pre><code>def write(self, b):
    raise io.UnsupportedOperation("write")
</code></pre>
<p>It is worth noting that a file opened with <code>'r'</code> produces the expected error class.</p>
<p>Since there is no general guidance on implementing these interfaces (that I have found) beyond the linked doc page, I would not have necessarily even thought to check for the issue. A pre-existing test suite would have solved that problem. Or otherwise a description of the necessary tests or edge cases would have guided me around these issues.</p>
<p>Does such guidance exist somewhere that I simply have not yet found?</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><p>Python docs are the only official, authoritative source containing promises/guarantees about the stock implementation's behaviour - there's just nothing else officially published. If something is not documented, it <s>doesn't exist</s> should not be relied upon.</p>
<ul>
<li>There's a unit test for the <code>io</code> module, <code>test_io.py</code>, in the source repo (you can also choose to install the test suite with the interpreter). Do watch out for implementation-specific details depending on your answer in the next paragraph.

<ul>
<li>Also watch for details specific to the <code>io</code> implementation of the base classes: <a href="https://stackoverflow.com/users/1913824/andrea-corbellini">as Andrea Corbellini noted</a>, there is a spec for a base class and there is a spec for its derivative.</li>
</ul></li>
</ul></li>
<li><p>Some behaviour is implementation-specific and indeed differs between Python implementations (e.g. in IronPython, <code>sys.maxsize</code> is ridiculously large 'cuz there's no such mechanism in .NET and all strings are Unicode even though it implements Python 2).</p>
<ul>
<li>The question here is: is your target compilance with <em>specification</em> or with a <em>specific implementation?</em> The answer depends on how much (and how well- (or rather, badly, i.e. unportably) written) code you want to be compatible with.

<ul>
<li>Since we're talking about abstract classes here, there's no "specific implementation" really except the little default/non-abstract code in relevant entities. So the difference is rather small.</li>
</ul></li>
</ul></li>
<li><p>Now, there are indeed cases where the spec omits, or is vague on, some critical details (I've personally run into at least two cases in <code>ctypes</code>). That's because it's written as a user's rather than implementor's guide.</p>
<ul>
<li>There's nothing you can do here other than stick to the spec and fix things as you run into them. In vague cases, you can check the implementation but be sure to find out the <em>rationale</em> (what it is <em>conceptually intended</em> to do) to decide what is appropriate in your case. After all, if you're replacing an internal module, how can you know how much undocumented behaviour other internal modules rely upon?

<ul>
<li>To Python devs' credit, the latter cases should be extremely rare as they do honor the loose coupling principle and strive to stick to the spec (where there is a spec) in inter-module interactions.</li>
</ul></li>
</ul></li>
</ul>
</div>
<span class="comment-copy"><code>RawIOBase</code> and <code>IOBase</code> are <i>base</i> classes. It's your duty to write your concrete classes so that they are compliant</span>
<span class="comment-copy">Right, but I'm looking for more exacting guidance on how to verify that. There are non-obvious edge cases and potential issues with the mixins that I would like to avoid.</span>
<span class="comment-copy">Whoops, just realized I forgot to mark this as answered.</span>
