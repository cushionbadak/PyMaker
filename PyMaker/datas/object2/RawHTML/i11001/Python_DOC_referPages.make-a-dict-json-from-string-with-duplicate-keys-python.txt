<div class="post-text" itemprop="text">
<p>I have a string that could be parsed as a json or dict object. My string variable looks like this :</p>
<pre><code>    my_string_variable = "{
                            "a":1,
                            "b":{
                                 "b1":1,
                                 "b2":2
                             },  
                            "b": { 
                                "b1":3, 
                                "b2":2,
                                "b4":8
                             } 
                           }"
</code></pre>
<p>When I do <code>json.loads(my_string_variable)</code>, I have a dict but only the second value of the key "b" is kept, which is normal because a dict can't contain duplicate keys.</p>
<p>What would be the best way to have some sort of defaultdict like this :</p>
<pre><code>    result = {
               'a':1,
               'b': [{'b1':1,'b2':2}, { 'b1':3, 'b2':2,'b4':8 } ]
             }
</code></pre>
<p>I have already looked for similar questions but they all deal with dicts or lists as an input and then create defaultdicts to handle the duplicate keys.</p>
<p>In my case I have a string variable and I would want to know if there is a simple way to achieve this :)</p>
<p>Thank you ^^        </p>
</div>
<div class="post-text" itemprop="text">
<p>something like the following can be done.</p>
<pre><code>import json

def join_duplicate_keys(ordered_pairs):
    d = {}
    for k, v in ordered_pairs:
        if k in d:
           if type(d[k]) == list:
               d[k].append(v)
           else:
               newlist = []
               newlist.append(d[k])
               newlist.append(v)
               d[k] = newlist
        else:
           d[k] = v
    return d

raw_post_data = '{"a":1, "b":{"b1":1,"b2":2}, "b": { "b1":3, "b2":2,"b4":8} }'
newdict = json.loads(raw_post_data, object_pairs_hook=join_duplicate_keys)
print (newdict)
</code></pre>
<p>Please note that above code depends on value type, <code>if type(d[k]) == list</code>. So if original string itself gives a list then there could be some error handling required to make the code robust.</p>
</div>
<span class="comment-copy">take a look at this thread: <a href="http://stackoverflow.com/questions/5946236/how-to-merge-multiple-dicts-with-same-key" title="how to merge multiple dicts with same key">stackoverflow.com/questions/5946236/…</a> .it should help you get going</span>
<span class="comment-copy">There probably isn't. Having duplicate keys simply doesn't make sense for mappings. You'd require a custom parser that switches from single-value to multiple-value upon encountering a key again. You might be able to modify the <a href="https://docs.python.org/3/library/json.html#encoders-and-decoders" rel="nofollow noreferrer">JSON decoder</a> with some effort. Note that things get a lot easier if <i>all</i> keys have sequence values (even if they are just length 1).</span>
<span class="comment-copy">Looks more like a dupe: <code>object_pairs_hook</code>: <a href="http://stackoverflow.com/questions/14902299/json-loads-allows-duplicate-keys-in-a-dictionary-overwriting-the-first-value" title="json loads allows duplicate keys in a dictionary overwriting the first value">stackoverflow.com/questions/14902299/…</a></span>
<span class="comment-copy">@MosesKoledoye : I didn't know about object_pairs_hook, it solved my problem :D thanks</span>
<span class="comment-copy">Thank you ! This solved my problem ;)</span>
<span class="comment-copy">Maybe use <code>defaultdict(list)</code> instead of checking for type? Also removes the potential problem you're mentioning.</span>
