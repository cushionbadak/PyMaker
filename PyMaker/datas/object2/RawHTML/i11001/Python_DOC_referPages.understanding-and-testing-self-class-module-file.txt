<div class="post-text" itemprop="text">
<p>When reading a python-based software, I feel confused about a line of python code: <code>path = sys.modules[self.__class__.__module__].__file__</code>. </p>
<p>I can guess it was trying to return the file name in class file, but I'm not very clear about the exact usage of this.  I saved the related code segment into a file named <code>test.py</code> and I'm trying to test it by <code>python test.py</code>, but it does not print anything. How can I test this kind of file?</p>
<pre><code>import os
import sys

class testloadfile:
  def __init__(self, test_path=None):
     if test_path is None:
        path = sys.modules[self.__class__.__module__].__file__
        # print path
        path = os.path.abspath(os.path.join(path, os.pardir))
        # print path
        path = os.path.join(path, "test.r")
        print(path)
        test_path = path

    print("r file loaded")  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Classes in python have a <code>__module__</code> attribute which contains the name of the module in which the class was defined. Additionally, each module contains a <a href="https://docs.python.org/3.5/reference/import.html#__file__" rel="nofollow"><strong><code>__file__</code></strong></a> attribute which has the full path to the <code>.py</code> file. </p>
<p>He is trying to get the file path for the file in which the class was defined but he's not going the best way with doing it, ideally you could just index <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow"><strong><code>sys.modules</code></strong></a> by using <a href="https://docs.python.org/3.5/reference/import.html#__name__" rel="nofollow"><strong><code>__name__</code></strong></a>:</p>
<pre><code>path = sys.modules[__name__].__file__ 
</code></pre>
<p>instead of going through the class (i.e <code>self.__class__.__module__ == __name__</code>). Do note here that <code>if __name__ == "__main__"</code> this will fail because the <a href="https://docs.python.org/3.5/library/__main__.html#module-__main__" rel="nofollow"><code>__main__</code></a> module does not have a <code>__file__</code> attribute defined. You'll need to safeguard against it:</p>
<pre><code>path = sys.modules[__name__].__file__ if __name__ == "__main__" else __file__
</code></pre>
<p>where <code>if __name__ == "__main__"</code> then <code>__file__</code> will contain the path of the file being executed. </p>
<p>Next, add the usual clause in your script in order for it to initialize the object if the script is running as <code>__main__</code>:</p>
<pre><code>if __name__ == "__main__":
    testloadfile()  # initialize
</code></pre>
<p>Now, if you call it as the <code>__main__</code> script with:</p>
<pre><code>python -m test.py 
</code></pre>
<p>or if you <code>import</code> it, it will pickup the <code>__file__</code> attribute, print it and then print the file name.</p>
<p><strong>P.s</strong>: Fix the indentation in your final <code>print</code>.</p>
</div>
<span class="comment-copy">Offhand, I do not see here "any sort of <code>main</code> routine" that a <i>command-line(!)</i> execution of <code>python</code> would be expected to pick-up on. Here, you define "a class," and you define a constructor for that class, <i>and</i> it seems that you've also tossed-in a <code>print</code> statement, but I don't see anything here that tells <code>python</code> what is supposed to be done when this <code>.py</code> file is executed from the command line. Therefore, I'm not surprised that it does nothing. <b>:-)</b> "Go thee now, and take a look," at some existing Python <i>(library)</i> code. Notice what they do, and do thee likewise.</span>
<span class="comment-copy">That is really bizarre... It seems like <code>sys.modules[self.__class__.__module__].__file__</code> should just give you <code>__file__</code>...</span>
<span class="comment-copy">What is the proper indentation level of the final <code>print</code>? Is it part of the <code>class</code> definition or part of the <code>__init__()</code> methodâ€”because as posted it's an indentation error.</span>
<span class="comment-copy">@Mike: If the final <code>print()</code> is part of the <code>class</code> definition (and not part of the <code>__init__()</code> method), running the script will execute it when the class definition executes. Regardless, it looks like @mgilson is correct, it's just an convoluted way to get <code>__file__</code>.</span>
<span class="comment-copy">Yup ... think I agree with ye ...</span>
