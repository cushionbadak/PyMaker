<div class="post-text" itemprop="text">
<p>I'd like to create an Python class that superficially appears to be a subclass of another class, but doesn't actually inherit its attributes.</p>
<p>For instance, if my class is named <code>B</code>, I'd like <code>isinstance(B(), A)</code> to return <code>True</code>, as well as <code>issubclass(B, A)</code>, but I don't want <code>B</code> to have the attributes defined for A. Is this possible?</p>
<p><strong>Note</strong>: I don't control the implementation of <code>A</code>.</p>
<p><strong>Why I care</strong>: The module I'm working with checks that a passed object is a subclass of <code>A</code>. I want to define the necessary attributes in <code>B</code> without inheriting the superfluous attributes defined in <code>A</code> (whose implementation I do not control) because I'm using <code>__getattr__</code> to pass some attribute calls onto a wrapped class, and if these attributes are defined by inheritance from A, <code>__getattr__</code> won't be called.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python3, override the special method <code>__getattribute__</code>.  This gives you almost complete control over attribute lookups.  There are a few corner cases so check the docs carefully (it's section 3.3.2 of the Language Reference Manual).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/abc.html" rel="nofollow">abstract base classes</a> to make a semingly unrelated class <code>B</code> a subclass of <code>A</code> without inheriting from it:</p>
<pre><code>from abc import ABCMeta
class A (metaclass=ABCMeta):
    def foo (self):
        print('foo')

class B:
    def bar (self):
        print('bar')

A.register(B)
</code></pre>
<p>Then used, it gives the desired results and appears as a subtype without actually having any of the base typeâ€™s members:</p>
<pre><code>&gt;&gt;&gt; issubclass(B, A)
True
&gt;&gt;&gt; b = B()
&gt;&gt;&gt; isinstance(b, A)
True
&gt;&gt;&gt; b.foo()
Traceback (most recent call last):
  File "&lt;pyshell#16&gt;", line 1, in &lt;module&gt;
    b.foo()
AttributeError: 'B' object has no attribute 'foo'
</code></pre>
<hr/>
<blockquote>
<p>I'm using <code>__getattr__</code> to pass some attribute calls onto a wrapped class, and if these attributes are defined by inheritance from <code>A</code>, <code>__getattr__</code> won't be called.</p>
</blockquote>
<p><code>__getattr__</code> is not invoked for members which are found using the normal attribute resolution. You can use <code>__getattribute__</code> then instead.</p>
<p>However, if what you are doing is overwriting the behavior of the base class <code>A</code>, then I donâ€™t see why simply overwriting the methods is not an option:</p>
<pre><code>class A:
    def doSomething (self);
        print('Do not do this!')

class B:
    def __init__ (self, wrapper):
        self.wrapper = wrapper

    def doSomething (self):
        print('Doing something else instead!')
        self.wrapper.doSomething()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could implement <code>__getattribute__</code> to raise AttributeErrors for the attributes that are not in B:</p>
<pre><code>class A(object):
    def __init__(self):
        self.foo = 1

    def bar(self):
        pass

class B(A):
    def __init__(self):
        self.baz = 42

    def __getattribute__(self, attr):
        if attr in ('foo', 'bar'):
            raise AttributeError()
        return super(B, self).__getattribute__(attr)
</code></pre>
<p>I'm curious, why would you do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I hope this satisfies you (I think it's a bit <em>dirty</em> hack):</p>
<pre><code>class A:
    attribute = "Hello"
    pass

class B(A):
    def __getattribute__(self, name):
        if name == "__dict__":
            return super().__getattribute__(name)
        if name in type(self).__dict__:
            return type(self).__dict__[name]
        if name in self.__dict__:
            return self.__dict__[name]
        raise AttributeError("type object '{}' has no attribute '{}'".format(type(self).__name__, name))
</code></pre>
<p>Now let's test it:</p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.attribute
'Hello'
&gt;&gt;&gt; b = B()
&gt;&gt;&gt; b.attribute
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "file.py", line 13, in __getattribute__
    raise AttributeError("type object '{}' has no attribute '{}'".format(type(self).__name__, name))
AttributeError: type object 'B' has no attribute 'attribute'
</code></pre>
<p>Unfortunately class <code>B</code> itself inherited attributes so this happens:</p>
<pre><code>&gt;&gt;&gt; B.attribute
'Hello'
</code></pre>
<p>I hope it doesn't matters, if it does you need to use metaclasses (which can get quite nasty).</p>
</div>
<div class="post-text" itemprop="text">
<p>As long as you're defining attributes in the <code>__init__</code> method and you override that method, <code>B</code> will not run the code from <code>A</code>'s <code>__init__</code> and will thus not define attributes et al. Removing methods would be harder, but seem beyond the scope of the question.</p>
</div>
<span class="comment-copy">You might want to look at abstract base classes. Also, do you target python 2 or 3?</span>
<span class="comment-copy">Targeting Python 3.</span>
<span class="comment-copy">Btw. this turned out to be a <a href="http://meta.stackexchange.com/a/66378/141542">XY problem</a>. You should avoid asking to specifically for your single idea to solve your original problem and mention your original problem instead.</span>
<span class="comment-copy">@poke Yeah, I realized that myself. Sorry ðŸ˜¬</span>
<span class="comment-copy">Moreso than <code>__getattr__</code>? iirc, <code>__getattr__</code> won't be called if the attribute in question is already defined</span>
<span class="comment-copy"><code>__getattribute__</code>, unlike <code>__getattr__</code>, gets called for all defined and undefined attributes</span>
<span class="comment-copy">@LukeTaylor See <a href="http://stackoverflow.com/q/3278077/216074">this question</a>, <code>__getattribute__</code> is the hardcore way to stop access to members. That being said, this is not really a good solution, as you need to opt out of every member individually (and also prevent subtypes from actually redefining those members).</span>
<span class="comment-copy">@LukeTaylor: The task at hand specifically requires the class B to inherit from A, yet override all the attributes that are already defined by A.  Hence the use of <code>__getattribute__</code> instead of <code>__getattr__</code> is necessary.</span>
<span class="comment-copy">A is already defined in a library which I don't control. Thanks, though</span>
<span class="comment-copy">I'm working with a library that checks whether something is a subclass before it will do anything with it, so I need to trick it into thinking that something with all the necessary methods (but not the superfluous ones) is a subclass when it's not.</span>
<span class="comment-copy">@LukeTaylor In that case, why do you care whether those original members are actually there or not? If you are certain that they are not used (otherwise you couldnâ€™t safely expect it to work without those members), then they probably wonâ€™t hurt anyone just <i>being</i> there.</span>
<span class="comment-copy">@poke Because it <i>uses</i> them, but I'm implementing <code>__getattr__</code> to read them from a wrapped class. If the methods are defined, <code>__getattr__</code> isn't called.</span>
<span class="comment-copy">Wait, how does this help? Your <code>__getattribute__</code> implementation doesn't look like it changes anything over the default behavior...</span>
<span class="comment-copy">@LukeTaylor Paul Cornelius already answered how it works, I just gave example how to do it (not very practical, but good for example).</span>
<span class="comment-copy">Ok. Thanks a lot ;)</span>
<span class="comment-copy"><code>A</code> seems to be a thin wrapper around a C-implemented class, so overriding <code>__init__</code> does nothing.</span>
