<div class="post-text" itemprop="text">
<pre><code>print (re.split(r'[a-fA-F]','finqwenlaskdjriewasFSDFddsafsafasa',re.I|re.M))
print (re.split(r'[a-fA-Z]','finqwenlaskdjriewasFSDFddsafsafasa',re.I|re.M))
print (re.split(r'\d*','sdfsfdsfds123212fdsf2'))
print (re.split(r'\d','sdfsfdsfds123212fdsf2'))
print (re.split(r'\w+','dsfsf sdfdsf sdfsdf sfsfd'))

['', 'inqw', 'nl', 'sk', 'jri', 'w', 's', 'S', '', '', 'dsafsafasa']
['', 'inqw', 'nl', 'sk', 'jri', 'w', 's', '', '', '', 'ddsafsafasa']
['sdfsfdsfds', 'fdsf', '']
['sdfsfdsfds', '', '', '', '', '', 'fdsf', '']
['', ' ', ' ', ' ', '']
</code></pre>
<p>I think the output here are really weird. The pattern that split the string are turned to '' in the output list sometimes, but disappear other time.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The pattern that split the string are turned to <code>''</code> in the output list sometimes, but disappear other time.</p>
</blockquote>
<p>No, the pattern (or what it matched) is <strong>never</strong> included in your outputs there. Those <code>''</code> are what's <strong>between</strong> the matches. Because that's what <code>re.split</code> does. Your example:</p>
<pre><code>&gt;&gt;&gt; re.split(r'\d','sdfsfdsfds123212fdsf2')
['sdfsfdsfds', '', '', '', '', '', 'fdsf', '']
</code></pre>
<p>You're splitting by digits, and the substring <code>'123212'</code> has six digits, so there are five empty strings between them. That's why there are five empty strings in the output there.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, you're essentially providing the <em><code>maxsplit=10</code></em> argument instead of <code>flags=re.I|re.</code></p>
<p>Secondly, the separators are <em>not</em> turned into <code>''</code>; instead that is the string <em>between</em> the separators:</p>
<pre><code>&gt;&gt;&gt; re.split(r':', 'foo:bar::baz:')
['foo', 'bar', '', 'baz', '']
</code></pre>
<p>Notice the <code>''</code> between 2 separators, and also at the end.</p>
<p>The separators themselves are <em>not</em> in the result, unless your regular expression contains capturing groups (<code>(...)</code>):</p>
<pre><code>&gt;&gt;&gt; re.split(r'(:)', 'foo:bar::baz:')
['foo', ':', 'bar', ':', '', ':', 'baz', ':', '']
</code></pre>
<p>Third: even though <code>r'\d*'</code> would ordinarily match at the beginning of a string, end of string, <em>and</em> between each character, <strong>currently</strong> only non-zero-length matches are considered by <code>re.split</code>, thus that pattern behaving like <strong><code>r\d+</code></strong>. However such behaviour is subject to change in Python 3.6 and later, and emits a warning <code>FutureWarning: split() requires a non-empty pattern match.</code> on <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow">Python 3.5</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The output isn't weird, it's intentional. <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow">From the docs</a>:</p>
<blockquote>
<p>If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; re.split('(\W+)', '...words, words...')
['', '...', 'words', ', ', 'words', '...', '']
</code></pre>
<blockquote>
<p>That way, <strong>separator components are always found at the same relative indices</strong> within the result list.</p>
</blockquote>
<p>Emphasis added to point out why this is done. The same applies to "empty" sequences inside the string and non-capturing separators. Basically, there is content before and after a separator - even if the separator is not captured and either content is empty. The similar method <code>str.split</code> <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow">actually does the same</a>.</p>
<p>This allows you to always reconstruct the initial string if you know the separator. Capturing the separator and joining, or inserting the separator on joining is equivalent. <code>''.join(re.split('(%s)' % sep, ':::words::words:::')) == sep.join(re.split('%s' % sep, ':::words::words:::'))</code></p>
</div>
<span class="comment-copy">Why would you capture anything while splitting?</span>
<span class="comment-copy">@jonrsharpe That doesn't explain the <i>"The pattern that split the string are turned to <code>''</code>"</i> misunderstanding.</span>
<span class="comment-copy">In most cases you are splitting <i>on single characters</i>. Also both <code>re.I</code> and <code>re.M</code> are useless in the examples you have provided.</span>
<span class="comment-copy">As a rule of thumb, if something in python seems weird, you missed looking into the docs and finding the explicit, precise explanation for your issue right there. ;)</span>
<span class="comment-copy">@MisterMiyagi Well you went to the docs and looked up and posted something that doesn't even apply here (there are no capturing groups in those separators).</span>
