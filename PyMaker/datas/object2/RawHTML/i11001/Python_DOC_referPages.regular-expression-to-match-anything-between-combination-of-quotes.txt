<div class="post-text" itemprop="text">
<p>[<em>Follow up from my old <a href="https://stackoverflow.com/questions/37928695/regular-expression-to-match-anything-between-two-symbols">question</a> with better description and links</em>]</p>
<p>Trying to match any character (including newlines, tab characters, whitespaces, etc.) between two symbols, including those symbols.</p>
<p>For example:</p>
<blockquote>
<p>foobar89\n\nfoo\tbar; '''blah blah blah'8&amp;^"''' </p>
</blockquote>
<p>need to match </p>
<blockquote>
<p>''blah blah blah'8&amp;^"'''</p>
</blockquote>
<p>and </p>
<blockquote>
<p>fjfdaslfdj; '''blah\n blah\n\t\t blah\n'8&amp;^"''' </p>
</blockquote>
<p>need to match </p>
<blockquote>
<p>'''blah\n blah\n\t\t blah\n'8&amp;^"'''</p>
</blockquote>
<p>My Python code (taken and adapted from <a href="https://docs.python.org/3/library/re.html#writing-a-tokenizer" rel="nofollow noreferrer">here</a>) onto which I am testing the regexes :</p>
<pre><code>import collections
import re

Token = collections.namedtuple('Token', ['typ', 'value', 'line', 'column'])

def tokenize(code):
    token_specification = [
        ('BOTH',      r'([\'"]{3}).*?\2'), # for both triple-single quotes and triple-double quotes
        ('SINGLE',    r"('''.*?''')"),     # triple-single quotes 
        ('DOUBLE',    r'(""".*?""")'),     # triple-double quotes 
        # regexes which match OK
        ('COM',       r'#.*'),
        ('NEWLINE', r'\n'),           # Line endings
        ('SKIP',    r'[ \t]+'),       # Skip over spaces and tabs
        ('MISMATCH',r'.'),            # Any other character
    ]

    test_regexes = ['COM', 'BOTH', 'SINGLE', 'DOUBLE']

    tok_regex = '|'.join('(?P&lt;%s&gt;%s)' % pair for pair in token_specification)
    line_num = 1
    line_start = 0
    for mo in re.finditer(tok_regex, code):
        kind = mo.lastgroup
        value = mo.group(kind)
        if kind == 'NEWLINE':
            line_start = mo.end()
            line_num += 1
        elif kind == 'SKIP':
            pass
        elif kind == 'MISMATCH':
            pass
        else:
            if kind in test_regexes:
                print(kind, value)
            column = mo.start() - line_start
            yield Token(kind, value, line_num, column)

f = r'C:\path_to_python_file_with_examples_to_match'

with open(f) as sfile:
    content = sfile.read()

for t in tokenize(content):
    pass #print(t)
</code></pre>
<p>where the <code>file_with_examples_to_match</code> is:</p>
<pre><code>import csv, urllib

class Q():
    """
    This class holds lhghdhdf hgh dhghd hdfh ghd fh.
    """

    def __init__(self, l, lo, d, m):
        self.l= l
        self.lo= longitude
        self.depth = d
        self.m= m

    def __str__(self):
        # sdasda fad fhs ghf dfh
        d= self.d
        if d== -1:
            d= 'unknown'
        m= self.m
        if m== -1:
            d= 'unknown'

        return (m, d, self.l, self.lo)

foobar89foobar; '''blah qsdkfjqsv,;sv
                   vqùlvnqùv 
                   dqvnq
                   vq
                   v

blah blah'8&amp;^"'''
fjfdaslfdj; '''blah blah
     blah
    '8&amp;^"'''
</code></pre>
<p>From <a href="https://stackoverflow.com/a/37929017/6167676">this answer</a>, I try <code>r"('''.*?''')|"r'(""".*?""")</code> to match both cases of triple single-quotes and triple double-quotes without success. Same when trying <code>r'([\'"]{3}).*?\2')</code>.</p>
<p>I have set up an <a href="https://regex101.com/r/pF3uX1/2" rel="nofollow noreferrer">online</a> regex tester where some of the regexes do match as they are supposed to but when in the code above they fail.</p>
<p>I am interested in gaining understanding in Python's regular expressions so I would appreciate both a solution (perhaps a valid regex to do the desired matching on my code) and a brief explanation so I can see my shortcomings.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're probably missing flags to make <code>.</code> match newline also</p>
<pre><code>re.finditer(tok_regex, code, flags = re.DOTALL)
</code></pre>
<p>In this case the output is</p>
<pre><code>('BOTH', '"""\n    This class holds lhghdhdf hgh dhghd hdfh ghd fh.\n    """')
('COM', '# sdasda fad fhs ghf dfh\n        d= self.d\n        if d== -1:\n            d= \'unknown\'\n        m= self.m\n        if m== -1:\n            d= \'unknown\'\n\n        return (m, d, self.l, self.lo)\n\nfoobar89foobar; \'\'\'blah qsdkfjqsv,;sv\n                   vq\xc3\xb9lvnq\xc3\xb9v \n                   dqvnq\n                   vq\n                   v\n\nblah blah\'8&amp;^"\'\'\'\nfjfdaslfdj; \'\'\'blah blah\n     blah\n    \'8&amp;^"\'\'\'')
</code></pre>
<p><code>COM</code> is now matching way too much, since <code>.</code> now gets everything to the end of file. If we modify this pattern a bit to make it less greedy</p>
<pre><code>('COM',       r'#.*?$')
</code></pre>
<p>we can now use <code>re.MULTILINE</code> to make it match less</p>
<pre><code>re.finditer(tok_regex, code, flags = re.DOTALL | re.MULTILINE)
</code></pre>
<p>The output now is</p>
<pre><code>('BOTH', '"""\n    This class holds lhghdhdf hgh dhghd hdfh ghd fh.\n    """')
('COM', '# sdasda fad fhs ghf dfh')
('BOTH', '\'\'\'blah qsdkfjqsv,;sv\n                   vq\xc3\xb9lvnq\xc3\xb9v \n                   dqvnq\n                   vq\n                   v\n\nblah blah\'8&amp;^"\'\'\'')
('BOTH', '\'\'\'blah blah\n     blah\n    \'8&amp;^"\'\'\'')
</code></pre>
<p>If you definitely don't want to use flags, you can use a kind of 'hack' to do without <code>.</code>, since this metacharacter matches almost everything, except newlines. You can create a match group, which would match everything but one symbol, which is highly unlikely to be present in files you would parse. For example, you could use a character with an ASCII code 0. Regex for such character would be <code>\x00</code>, the corresponding pattern <code>[^\x00]</code> would match every symbol (even newlines), except symbol with ASCII code 0 (that's why it's a hack, you aren't able to match every symbol without flags). You'll need to keep initial regex for <code>COM</code>, and for <code>BOTH</code> it would be</p>
<pre><code>('BOTH',      r'([\'"]{3})[^\x00]*?\2')
</code></pre>
<p>Highly recommended for working with regex are online tools which explain them, like <a href="https://regex101.com/" rel="nofollow noreferrer">regex101</a></p>
<p>For more complex cases of quote matching you'll need to write a parser.  See for example this <a href="https://softwareengineering.stackexchange.com/questions/166454/can-the-csv-format-be-defined-by-a-regex">Can the csv format be defined by a regex?</a> and this <a href="https://softwareengineering.stackexchange.com/questions/113237/when-you-should-not-use-regular-expressions">When you should NOT use Regular Expressions?</a>.</p>
</div>
<span class="comment-copy">I think I am failing to understand what you are looking for. Due to the greedy nature of python regexes, '.*' should capture anything between two  apostrophes, including any apostrophes. What exactly is the issue?</span>
<span class="comment-copy">@JasonBray The issue is that I trying to match anything between 3 consecutive double quotes or 3 consecutive single quotes. When I use the regexes <code>r"('''.*?''')"</code>, <code>r'(""".*?""")'</code>, <code>r'([\'"]{3}).*?\2')</code> even though the online regex testers show that these regexes do match as desired, when they are used in the code in my description they do not match. Looking for understanding why.</span>
<span class="comment-copy">I understand why regexes are not suitable for this kind of problem and that indeed a parser is more suitable (excellent links by the way). However, this is more an approach/exercise for me to get an exact feel of the limitations of regexes. For this case, a good-enough regex which will match anything between 3 single or double quotes is my goal.</span>
<span class="comment-copy">That is perfect. I could have never thought that the <code>flags</code> were the solution. I wonder if besides modifying <code>COM</code> to be less greedy, other regexes require similar modification as well. e.g. if I also had <code>('NUMBER',   r'\d+(\.\d*)?')</code> or <code>('ID',       r'[A-Za-z]+')</code> would they also require modification to be less greedy?</span>
<span class="comment-copy">@nk-fford <code>[^*]</code> and <code>.</code> are different in that the first group matches everything (including newlines) except <code>*</code>, and <code>.</code> matches almost every symbol, but not newline by default. In theory you can replace <code>.</code> with a negative group which uses a single symbol which would never appear in the text, however, it would make you regex less readable</span>
<span class="comment-copy">@nk-fford well, that's more of a hack than a proper solution, but assuming we don't ever get \x00 in text regex for <code>BOTH</code> would be <code>r'([\'"]{3})[^\x00]*?\2'</code> and for <code>COM</code> <code>r'#.*'</code>. This way it works without any flags set and provide the last output in the answer</span>
<span class="comment-copy">@nk-fford included hack description in the answer with more explanation what <code>[^\x00</code>] is</span>
