<div class="post-text" itemprop="text">
<p>I have to make sure that an email address that is inputted is valid. An email address must:</p>
<ul>
<li><p>Start with a string of alphanumeric characters</p></li>
<li><p>followed by the <code>@</code> symbol</p></li>
<li><p>another string of alphanumeric characters</p></li>
<li><p>followed by a <code>.</code></p></li>
<li><p>then a string of alphanumeric characters.</p></li>
</ul>
<p>For example, <code>a@b.c</code> and <code>ab23@f45.d3</code> are both valid, but <code>@bc.d</code> and <code>123.c@cvb</code> are not valid. How would I program something that would make sure the input follows this order?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/re.html" rel="nofollow">Regular Expression</a></p>
<p>An example:</p>
<pre><code>import re
if re.search(r'[\w.-]+@[\w.-]+.\w+', email):
    do stuff
else
    do other stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would split the string at the <em>@</em> character into two new strings and check if the string to the left of <em>@</em> only contains alphanumeric characters. Then I would split the string on the right at the <em>.</em> character and check if both left and right string contain only alphanumeric characters.</p>
<pre><code>def test(email):
    left, right = email.split('@')  # 'abc123@mail1.com' -&gt; left = 'abc123', right = 'mail1.com'
    if not left.isalnum():  # If characters to the left of '@' is not alphanumeric or is empty, return False.
        return False

    left, rest = right.split('.')  # 'mail1.com' -&gt; left = 'mail1, right = 'com'
    if not (left.isalnum() and rest.isalnum()):  # If characters to the left and right of '.' is not alphanumeric or is empty, return False.
        return False

    return True  # If it haven't returned False, return True.


# To test if it works as you intended. It works for the cases you provided.
while True:
    print(test(input('Email: ')))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is my take on this:</p>
<pre><code>def email_valid(email_str):
    if email_str.count('@') != 1 or email_str.count('.') != 1:
        return False
    if len(min(email_str.split('@'))) == 0 or len(min(email_str.split('@')[1].split('.'))) == 0:
        return False
    parts = email_str.split('@')[1].split('.') + [email_str.split('@')[0]]
    return True if all(x.isalnum() for x in parts) else False

check = False
while not check:
    check = email_valid(input('Please provide an email:\t'))

print('Email accepted!')
</code></pre>
<p>Checks to make sure <code>'@', '.'</code> can be found exactly once in the provided string and the string parts before and after them are alphanumeric &amp; non empty.</p>
<hr/>
<p>However, the rules implemented here are not the rules generally applied to email accounts. For a list of those, see <a href="https://en.wikipedia.org/wiki/Email_address" rel="nofollow">the <em>syntax</em> paragraph of this article</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another non-regex way to do it:</p>
<pre><code>def validate_email(email):
    user, sep, domain = email.partition('@')
    parts = [user]
    parts.extend(domain.split('.'))
    return len(parts) == 3 and all(part.isalnum() for part in parts)

&gt;&gt;&gt; for email in 'a@b.c', 'ab23@f45.d3', 'a_b@p_q.com', '@bc.d', '123.c@cvb', '', '@', 'a@b@c', '@.', 'abc&amp;**&amp;@test.com':
...     print(validate_email(email)) 
True
True
False
False
False
False
False
False
False
False
</code></pre>
<p>The domain part of the email address is restricted to two parts separated by a <code>.</code>. Valid email domains can have at least three parts so, if you want to support that, remove the <code>len(parts) == 3</code> test.</p>
<hr/>
<p>And here is a regex pattern that works:</p>
<pre><code>import re

def validate_email(email):
    return re.match(r'[a-zA-Z\d]+@[a-zA-Z\d]+\.[a-zA-Z\d]+$', email) != None

&gt;&gt;&gt; for email in 'a@b.c', 'ab23@f45.d3', 'a_b@p_q.com', '@bc.d', '123.c@cvb', '', '@', 'a@b@c', '@.', 'abc&amp;**&amp;@test.com':
...     print(validate_email(email)) 
True
True
False
False
False
False
False
False
False
False
</code></pre>
<p>You can't use <code>\w</code> in the pattern because this will match the underscore character and this is not normally considered alphanumeric. The <code>$</code> is required at the end of the pattern to ensure that the last segment of the email address ends with alphanumeric characters only. With out this extraneous invalid characters appearing at the end of the string after a sequence of valid characters will match.</p>
<p>In this case I'd opt for the first method using just basic string functions because it is (arguably) easier to read and maintain than a regex.</p>
</div>
<span class="comment-copy">just build a regex to validate it, keep asking for input until it sattisfies the regex</span>
<span class="comment-copy">use Google <code>python regex email</code> and you find: <a href="http://stackoverflow.com/questions/8022530/python-check-for-valid-email-address" title="python check for valid email address">stackoverflow.com/questions/8022530/â€¦</a></span>
<span class="comment-copy">Note that your current definition does not actually match all valid email addresses. Also you apparently haven't written anything, so maybe start there.</span>
<span class="comment-copy">if you wanna be serious about that, you have to implement that: <b><a href="https://en.wikipedia.org/wiki/Email_address" rel="nofollow noreferrer">en.wikipedia.org/wiki/Email_address</a></b> See the Syntax paragraph</span>
<span class="comment-copy">Why, yes you're right. I haven't written anything because I don't know how to do it, which is why I posted it on here? Damn, this community is vicious.</span>
<span class="comment-copy">Thanks, this works, but I've cut the search down to this: re.search(r'[\w]@[\w].[\w]',email) and it still works. It seems like a shorter way to write it, is it still as good?</span>
<span class="comment-copy">@MCSH: For matching the OP's restricted requirements the suggested pattern is wrong,  It accepts periods and hypens in the first and second segments so email addresses such as <code>a....---.@b....c.d.a.s</code> would be accepted. <code>\w</code> also accepts the underscore character <code>_</code>, and potentially others when <code>re.UNICODE</code> is set. Furthermore <code>re.search()</code> will match anywhere within the given string, so <code>#*&amp;^812a....---.@b....c.d.a.s()()*&amp;</code> will match. Use <code>^</code> and <code>$</code> at the beginning and ends of the pattern to match from the start to the end of the address, or use <code>re.match()</code> with the pattern ending in <code>$</code>.</span>
<span class="comment-copy">@Pelican: You need to specify repetition within the pattern, i.e. <code>[\w]+</code> where the <code>+</code> says "one or more" of the previous pattern. <code>\w</code> also matches underscore so you can't use that; use <code>[a-zA-Z\d]+</code> instead. The <code>.</code> needs to be escaped so that it is considered a literal <code>.</code> and not match any single character. Finally, anchor the search with <code>^</code> and <code>$</code> so that extraneous characters before and after the address don't cause a match. The pattern should be: <code>r'^[a-zA-Z\d]+@[a-zA-Z\d]+\.[a-zA-Z\d]+$'</code>. See <a href="http://stackoverflow.com/a/38318090/21945">my answer</a> for code, and non-regex alternative</span>
<span class="comment-copy">I think that you meant <code>all()</code>, not <code>any()</code>. The checks that at least one part is alphanumeric, but other parts could contain invalid characters, e.g. <code>123.c@cvb</code> is considered valid, as is <code>ab_()@x.com</code> which is clearly invalid.</span>
<span class="comment-copy">@mhawke indeed. I will edit that, thanks!!</span>
