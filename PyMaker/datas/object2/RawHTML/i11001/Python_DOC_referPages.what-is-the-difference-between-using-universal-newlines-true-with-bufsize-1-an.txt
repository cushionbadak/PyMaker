<div class="post-text" itemprop="text">
<p>I am trying to read the output of a subprocess called from Python. To do this I am using Popen (because I do not think it is possible to pipe stdout if using subprocess.call).</p>
<p>As of now I have two ways of doing it which, in testing, seem to provide the same results.  The code is as follows:</p>
<pre><code>with Popen(['Robocopy', source, destination, '/E', '/TEE', '/R:3', '/W:5', '/log+:log.txt'], stdout=PIPE) as Robocopy:
    for line in Robocopy.stdout:
        line = line.decode('ascii')
        message_list = [item.strip(' \t\n').replace('\r', '') for item in line.split('\t') if item != '']
        print(message_list[0], message_list[0])
    Robocopy.wait()
    returncode = Robocopy.returncode
</code></pre>
<p>and</p>
<pre><code>with Popen(['Robocopy', source, destination, '/E', '/TEE', '/R:3', '/W:5', '/log+:log.txt'], stdout=PIPE, universal_newlines=True, bufsize=1) as Robocopy:
    for line in Robocopy.stdout:
        message_list = [item.strip() for item in line.split('\t') if item != '']
        print(message_list[0], message_list[2])
    Robocopy.wait()
    returncode = Robocopy.returncode
</code></pre>
<p>The first method does not include universal_newlines=True, as the documentation states this is <a href="https://docs.python.org/3/library/subprocess.html?highlight=subprocess" rel="nofollow">only usable if universal_newlines=True i.e., in a text mode</a>.</p>
<p>The second version does include universal_newlines and therefore I specify a bufsize.</p>
<p>Can somebody explain the difference to me?  I can't find the article but I did read about issues with an overflowing buffer causing some sort of issue and thus the importance of using <code>for line in stdout</code>.</p>
<p>Additionally, when looking at the output, not specifying universal_newlines makes stdout a <code>bytes</code> object - but I am not sure what difference that makes if I just decode the bytes object with <code>ascii</code> (in terms of new lines and tabs) compared universal_newlines mode.  </p>
<p>Lastly, setting the <code>bufsize</code> to <code>1</code> makes the output "line-buffered" but I am not sure what that means.  I would appreciate an explanation about how these various elements tie together.  Thanks</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What is the difference between using universal_newlines=True (with bufsize=1) and using default arguments with Popen</p>
</blockquote>
<p>The default values are: <strong><em><code>universal_newlines=False</code></em></strong> (meaning input/output is accepted as <strong>bytes</strong>, not Unicode strings plus the <a href="https://docs.python.org/3/glossary.html#term-universal-newlines" rel="nofollow noreferrer">universal newlines mode</a> handling (hence the name of the parameter. Python 3.7 provides  <code>text</code> alias that might be more intuitive here) is disabled -- you get binary data as is (unless POSIX layer on Windows messes it up) and <strong><em><code>bufsize=-1</code></em></strong> (meaning the streams are fully buffered -- the default buffer size is used).</p>
<p><code>universal_newlines=True</code> uses <code>locale.getpreferredencoding(False)</code> character encoding to decode bytes (that  may be different from <code>ascii</code> encoding used in your code).</p>
<p>If <code>universal_newlines=False</code> then <code>for line in Robocopy.stdout:</code> iterates over <code>b'\n'</code>-separated lines. If the process uses non-ascii encoding e.g., UTF-16 for its output then even if <code>os.linesep == '\n'</code> on your system; you may get a wrong result. If you want to consume text lines, use the text mode: pass <code>universal_newlines=True</code> or use <code>io.TextIOWrapper(process.stdout)</code> explicitly.</p>
<blockquote>
<p>The second version does include universal_newlines and therefore I specify a bufsize.</p>
</blockquote>
<p>In general, It is not necessary to specify <code>bufsize</code> if you use <code>universal_newlines</code> (you may but it is not required). And you don't need to specify <code>bufsize</code> in your case. <code>bufsize=1</code> enables line-bufferred mode (the input buffer is flushed automatically on newlines if you would write to <code>process.stdin</code>) otherwise it is equivalent to the default <code>bufsize=-1</code>.</p>
</div>
<span class="comment-copy">So the default value of <code>bufsize=-1</code> seems like it could cause an issue.  Fully buffering the stream could cause some sort of blocking correct?  And if it is not specified (in universal_newlines mode) again don't I create the possibility of blocking because of a full buffer?</span>
<span class="comment-copy">@Startec: no. There is no blocking issue here (regardless of <code>universal_newlines</code>, <code>bufsize</code> values). Where do you get these ideas? If you have an issue with some specific code then ask the question about this specific code.</span>
<span class="comment-copy">My apologies, my confusion came from the documentation for subprocess (i.e. <code>Do not use stdout=PIPE or stderr=PIPE with this function. The child process will block if it generates enough output to a pipe to fill up the OS pipe buffer as the pipes are not being read from. )</code>  But I now see that is for subprocess.call.  Thanks for your clear answer - it addresses my question(s)</span>
<span class="comment-copy">@Startec: yes. if you don't read from <code>process.stdout</code> pipe (when <code>stdout=PIPE</code>) then the child process may block i.e., OS pipe buffer may be finite (at least on some systems) and therefore as soon as the child process fills it; it won't be able to write anymore (untill you drain the buffer by reading from your end of the pipe). Note: OS pipe buffer is <b>outside</b> your parent Python script; it has nothing to do with <code>bufsize</code> (that control the buffer <b>inside</b> the parent Python script), <a href="http://stackoverflow.com/a/31953436/4279">look at the picture</a></span>
