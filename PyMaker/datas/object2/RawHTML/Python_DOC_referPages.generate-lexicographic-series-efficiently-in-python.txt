<div class="post-text" itemprop="text">
<p>I want to generate a lexicographic series of numbers such that for each number the sum of digits is a given constant. It is somewhat similar to 'subset sum problem'. For example if I wish to generate 4-digit numbers with sum = 3 then I have a series like:</p>
<p>[3 0 0 0]</p>
<p>[2 1 0 0]</p>
<p>[2 0 1 0]</p>
<p>[2 0 0 1]</p>
<p>[1 2 0 0] ... and so on.</p>
<p>I was able to do it successfully in Python with the following code:</p>
<pre><code>import numpy as np

M = 4 # No. of digits
N = 3 # Target sum

a = np.zeros((1,M), int)
b = np.zeros((1,M), int)

a[0][0] = N
jj = 0

while a[jj][M-1] != N:
    ii = M-2
    while a[jj][ii] == 0:
          ii = ii-1
    kk = ii
    if kk &gt; 0:
       b[0][0:kk-1] = a[jj][0:kk-1]
    b[0][kk] = a[jj][kk]-1
    b[0][kk+1] = N - sum(b[0][0:kk+1])
    b[0][kk+2:] = 0
    a = np.concatenate((a,b), axis=0)
    jj += 1

for ii in range(0,len(a)):
    print a[ii]

print len(a)
</code></pre>
<p>I don't think it is a very efficient way (as I am a Python newbie). It works fine for small values of M and N (&lt;10) but really slow beyond that. I wish to use it for M ~ 100 and N ~ 6. How can I make my code more efficient or is there a better way to code it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Very effective algorithm adapted from Jorg Arndt book "Matters Computational"<br/>
(Chapter <code>7.2 Co-lexicographic order for compositions into exactly k parts</code>)</p>
<pre><code>n = 4
k = 3

x = [0] * n
x[0] = k

while True:
    print(x)
    v = x[-1]
    if (k==v ):
        break
    x[-1] = 0
    j = -2
    while (0==x[j]):
        j -= 1
    x[j] -= 1
    x[j+1] = 1 + v

[3, 0, 0, 0]
[2, 1, 0, 0]
[2, 0, 1, 0]
[2, 0, 0, 1]
[1, 2, 0, 0]
[1, 1, 1, 0]
[1, 1, 0, 1]
[1, 0, 2, 0]
[1, 0, 1, 1]
[1, 0, 0, 2]
[0, 3, 0, 0]
[0, 2, 1, 0]
[0, 2, 0, 1]
[0, 1, 2, 0]
[0, 1, 1, 1]
[0, 1, 0, 2]
[0, 0, 3, 0]
[0, 0, 2, 1]
[0, 0, 1, 2]
[0, 0, 0, 3]
</code></pre>
<p>Number of compositions and time on seconds for plain Python (perhaps numpy arrays are faster) for n=100, and k = 2,3,4,5 (2.8 ghz Cel-1840)</p>
<pre><code>2  5050 0.040000200271606445
3  171700 0.9900014400482178
4  4421275 20.02204465866089
5  91962520 372.03577995300293
I expect time  2 hours for 100/6 generation
</code></pre>
<p>Same with numpy arrays (<code>x = np.zeros((n,), dtype=int)</code>) gives <strong>worse</strong> results - but perhaps because I don't know how to use them properly</p>
<pre><code>2  5050 0.07999992370605469
3  171700 2.390003204345703
4  4421275 54.74532389640808
</code></pre>
<p>Native code (this is Delphi, C/C++ compilers might optimize better) generates 100/6 <strong>in 21 seconds</strong> </p>
<pre><code>3  171700  0.012
4  4421275  0.125
5  91962520  1.544
6  1609344100 20.748
</code></pre>
<p>Cannot go sleep until all measurements aren't done :)</p>
<p>MSVS VC++:  <strong>18 seconds</strong>! (O2 optimization)</p>
<pre><code>5  91962520 1.466
6  1609344100 18.283
</code></pre>
<p>So 100 millions variants per second. 
A lot of time is wasted for checking of empty cells (because fill ratio is small). Speed described by Arndt is reached on higher k/n ratios  and is about 300-500 millions variants per second: </p>
<pre><code>n=25, k=15 25140840660 60.981  400 millions per second
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My recommendations:</p>
<ol>
<li>Rewrite it as a generator utilizing <code>yield</code>, rather than a loop that concatenates a global variable on each iteration.</li>
<li>Keep a running sum instead of calculating the sum of some subset of the array representation of the number.</li>
<li>Operate on a single instance of your working number representation instead of splicing a copy of it to a temporary variable on each iteration.</li>
</ol>
<p>Note no particular order is implied.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have a better solution using itertools as follows,</p>
<pre><code>from itertools import product
n = 4 #number of elements
s = 3 #sum of elements
r = []
for x in range(n):
    r.append(x)
result = [p for p in product(r, repeat=n) if sum(p) == s]
print(len(result))
print(result)
</code></pre>
<p>I am saying this is better because it took 0.1 secs on my system, while your code with numpy took 0.2 secs. </p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/H5Gn8.png"/></p>
<p><img alt="enter link description here" src="https://i.stack.imgur.com/jhl46.png"/></p>
<p>But as far as n=100 and s=6, this code takes time to go through all the combinations, I think it will take days to compute the results.</p>
</div>
<span class="comment-copy">Have a look at <a href="https://en.m.wikipedia.org/wiki/Composition_(combinatorics)" rel="nofollow noreferrer">integer composition</a></span>
<span class="comment-copy">The given link has very useful information, however, it does not help in refining the algorithm.</span>
<span class="comment-copy">Ran your code for n=100 and k=6, its takes time in this algorithm as well, may be days</span>
<span class="comment-copy">@MBo I find this algorithm to be really fast and efficient. Perfect!</span>
<span class="comment-copy">@Shoyeb Sheikh Do you know how many compositions with such parameters do exist? Any algorithm generating trillions of variants requires a lot of time. Described approach is very optimized - being implemented in C, it generates 300 millions variants per second (not counting output or writing - the most time consuming part)</span>
<span class="comment-copy">@MBo well that was a part of question lol I didn't add anything to it, 300 millions per sec is very efficient though, Great !</span>
<span class="comment-copy">@Shoyeb Sheikh Yes, I noticed that author supposes to get a lot of variants - it is possible to calculate them, but it is rather hard to store and use such huge amount of data</span>
<span class="comment-copy">Actually I want to improve the way algorithm is coded (or code a more efficient algorithm) to compute <i>just the required</i> combinations. As far as I understand your code checks <i>all possible combinations</i> against the given sum. Can you time both the codes for M=10, N=3 as well?</span>
<span class="comment-copy">Its been an hour of so for M=10 and N=3 and its still running, I think MBo has a better answer there.</span>
<span class="comment-copy">Did you check the timing with my code as well?</span>
<span class="comment-copy">Nope you check it and let us know</span>
<span class="comment-copy">Ok, I did that. It took less than a second.</span>
