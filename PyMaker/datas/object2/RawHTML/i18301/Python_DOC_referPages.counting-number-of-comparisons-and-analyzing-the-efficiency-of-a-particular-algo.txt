<div class="post-text" itemprop="text">
<pre><code>def three_way_merge(L1,L2,L3):
    L = []
    i1 = 0
    i2 = 0
    i3 = 0
    done1 = False
    done2 = False
    done3 = False
    while not (done1 and done2 and done3):
        if not done1 and (done2 or L1[i1] &lt; L2[i2]) and (done3 or L1[i1] &lt; L3[i3]):
            L.append(L1[i1])
            i1 += 1
            done1 = i1 &gt;= len(L1)
        elif not done2 and (done3 or L2[i2] &lt; L3[i3]):
            L.append(L2[i2])
            i2 += 1
            done2 = i2 &gt;= len(L2)
        else:
            L.append(L3[i3])
            i3 += 1
            done3 = i3 &gt;= len(L3)
    return L
</code></pre>
<p>I want to count the worst possible number of comparisons for this algorithm I found, because I have an exam coming up in my algorithms class and I wish to be able to do this kind of analysis. My thought was to write a program that creates many random examples of this "worst case" (which I am guessing is something of the type: <code>L1 = [9,10,11], L2 = [6,7,8], L3 = [3,4,5]</code>, where all the lists are sorted but <code>L3</code> and <code>L2</code> have strictly smaller values than <code>L1</code>, etc.) and then every time I do any comparison I increment a counter and return the final count, and then try to figure out some kind of pattern in the outputs, but this seems to be an inefficient way to go about this.</p>
<p>Is there a way to count this in a similar fashion to the analysis of the classic merge in merge sort?</p>
</div>
<div class="post-text" itemprop="text">
<p>As a general rule, generating random input is not a good way to figure out worst-case running time.  For example, quicksort runs in O(n log n) on average, but in the worst case it runs in O(n^2).  However, even if you generated a huge number of random samples, for moderately large n you would never come anywhere close to the worst case.  Instead, try and construct a worst-case input manually. </p>
<p>In this case, it seems that the worst case, assuming that each array has length N, occurs if </p>
<pre><code>L1 = (N,2N,2N+1,...,3N-3,3N)
L2 = (N+1,N+2,...,2N-1,3N-1)
L3 = (1,2,...,N-1,3N-2)
</code></pre>
<p>To see why, trace the execution of the algorithm.  The first thing that happens is that the first N-1 elements of <code>L3</code> will get added to <code>L</code>.  Each of these iterations of the loop will have 3 comparisons: two in the first <code>if</code> statement and one in the second.  Note that we need <code>L1[1]&lt;L2[1]</code> otherwise it will skip the second comparison in the first <code>if</code></p>
<p>Next will be the element <code>L[1]=N</code>, which takes one comparison only.</p>
<p>After this come the first N-1 elements of <code>L[2]</code>, each of which will require two comparisons, one to <code>L1</code> and one to <code>L3</code>.  </p>
<p>Next come the next N-2 elements from <code>L1</code>, with one comparison each.</p>
<p>At this point there is only one element left in each list.  <code>L3</code> gets picked first, with 3 comparisons, and then one comparison for <code>L2</code>, and that's it.</p>
<p>The total is </p>
<pre><code>(N-1)*(3+2+1)+3+1 = 6N - 2
</code></pre>
<p>I think this is the worst case, but you might be able to squeeze one more out of it somewhere.  Also, I may have made a mistake, in which case somebody here will probably catch it.  The next thing you should do is try to actually prove that this is the worst-case running time.</p>
<p>PS This algorithm is not optimal for merging three lists.  Picking the smallest element from the front of the three lists should only require 2 comparisons at most, not 3.  If you find that <code>L2&lt;L1</code> and <code>L1&lt;L3</code> then it's not necessary to compare <code>L2</code> and <code>L3</code> since you already know that <code>L2</code> is smaller. </p>
<p>On edit: it shouldn't be too hard to prove that this is actually the worst case.  Assuming none of the lists are empty, the number of comparisons per iteration is:</p>
<ul>
<li>3 if L3 is smallest and L1 &lt; L2</li>
<li>2 if L2 is smallest </li>
<li>1 if L1 is smallest</li>
</ul>
<p>That right there gives you an upper bound of N*6, since each list can only be the smallest N times.  So completing a proof just requires examining what happens at the end where the lists become empty.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you said the worst scenario is to have the L3 (or L2) with all smaller numbers than L1, because the IF clause will fail and it will perform elif section computing more comparations.</p>
<p>Inside the first IF (and assuming we will count as an individual comparation each checking of boolean values, like done1, done2, etc.) and having into account that logical expressions ussually are computed in a lazy way, then the worst case is to never reach done1 = true before  the others (that is guaranteed as L1 has bigger values than L2 and L3), done2 neither reach true (can be guaranteed having bigger values in L2 than in L3) so the L1[i1] &lt; L2[i2] is computed in every steps.</p>
<p>When L3 is finished, and each cycle enters in the IF section and only 4 comparations are performed because done3 is true, and thanks to the lazyness the last comparation is not computed. The same applies when entering the elif section only 2 comparations are performed.</p>
<p>When L2 is finished, only 3 comparations are perfomed in the IF clause (as done2 and done3 are true)</p>
<p>So, having this configuration (L1 &gt;&gt; L2 &gt;&gt; L3) this algorithm will perform:</p>
<p>Len(L3) * (3 (the while clause) + 5 (the IF clause) + 3 (the elif section) + 1 (the done3 calulation)) + 
Len(L2) * (3 (the while clause) + 4 (the IF clause) + 2 (the elif section) + 1 (the done2 calulation)) + 
Len(L1) * (3 (the while clause) + 3 (the IF clause) + 1 (the done1 calulation)) </p>
<p>so the final count is</p>
<p>Len(L3) * 12 + Len(L2) * 10 + Len(L1) * 7</p>
<p>The computational Order is the same in any case of ordering of the 3 arrays, the Order is Len(3) + Len(2) + Len(1)</p>
</div>
<span class="comment-copy">you should Codify programming terms in text using <code>&lt;code&gt; code-expression&lt;/code&gt;</code> or <code>`code expression`</code></span>
<span class="comment-copy">Why do you need a program to find it? If each list is size N, you will do (3N + 1N) = 4N comparisons in the worst case. If L3 has all the smallest numbers, you will do three comparisons per number until the list is over. Then if L2 has the next smallest, you will just do the one comparison in the first if statement. After that, you won't do any more comparisons. If the done statements count as comparisons as well, add in another 3N.</span>
<span class="comment-copy">Hint: Count how many increments you do on <code>i1</code>, <code>i2</code> and <code>i3</code>.</span>
<span class="comment-copy">Is there a way to do it mathematically?</span>
<span class="comment-copy">In real life you would use <a href="http://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow noreferrer"><code>heapq.merge</code></a> instead of writing your own.</span>
