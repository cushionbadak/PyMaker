<div class="post-text" itemprop="text">
<p>My objective is to use Python to send an e-mail to a Gmail user that has an inline image. It is not possible to host this image online and then link to it through a <code>href</code>, due to the sensitive nature of the images (data from my work). </p>
<p>I've tried encoding the <code>base64</code> version into a <code>HTML</code> then sending th is <code>HTML</code>, but this is well known to not work. I then noticed that in Gmail you can drag and drop an image into the send box and it will show up inline in the receiving end. Given this I then tried to send an e-mail from Python with the image as an attachment. This is seen in the below code, but unfortunately the image doesn't show up inline. </p>
<p>My question is then: <strong>How to send the image such that it shows up inline?</strong> </p>
<pre><code>import smtplib
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email import Encoders
import os

gmail_user = "user1@gmail.com"
gmail_pwd = "pass"

to = "user2@gmail.com"
subject = "Report"
text = "Picture report"
attach = 'TESTING.png'

msg = MIMEMultipart()

msg['From'] = gmail_user
msg['To'] = to
msg['Subject'] = subject

msg.attach(MIMEText(text))

part = MIMEBase('application', 'octet-stream')
part.set_payload(open(attach, 'rb').read())
Encoders.encode_base64(part)
part.add_header('Content-Disposition',
   'attachment; filename="%s"' % os.path.basename(attach))
msg.attach(part)

mailServer = smtplib.SMTP("smtp.gmail.com", 587)
mailServer.ehlo()
mailServer.starttls()
mailServer.ehlo()
mailServer.login(gmail_user, gmail_pwd)
mailServer.sendmail(gmail_user, to, msg.as_string())
# Should be mailServer.quit(), but that crashes...
mailServer.close()
</code></pre>
<p>When I send the inline image to myself manually this is what the "original email" looks like:</p>
<pre><code>  Content-Type: multipart/related; boundary=047d7bd761fe73e03304e7e02237

--047d7bd761fe73e03304e7e02237
Content-Type: multipart/alternative; boundary=047d7bd761fe73e03004e7e02236

--047d7bd761fe73e03004e7e02236
Content-Type: text/plain; charset=ISO-8859-1

[image: Inline images 1]

--047d7bd761fe73e03004e7e02236
Content-Type: text/html; charset=ISO-8859-1

&lt;div dir="ltr"&gt;&lt;img alt="Inline images 1" src="cid:ii_141810ee4ae92ac6" height="400" width="534"&gt;&lt;br&gt;&lt;/div&gt;

--047d7bd761fe73e03004e7e02236--
--047d7bd761fe73e03304e7e02237
Content-Type: image/png; name="Testing.png"
Content-Transfer-Encoding: base64
Content-ID: &lt;ii_141810ee4ae92ac6&gt;
X-Attachment-Id: ii_141810ee4ae92ac6
</code></pre>
<p>When I send it to myself through Python as an attachment it is very different:</p>
<pre><code>Content-Type: multipart/mixed; boundary="===============6881579935569047077=="
MIME-Version: 1.0
(.... some stuff deleted here)
--===============6881579935569047077==
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

See attachment for report.
--===============6881579935569047077==
Content-Type: application/octet-stream
MIME-Version: 1.0
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="TESTING.png"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems that following the gmail email template works:</p>
<pre><code>* multipart/alternative
  - text/plain
  - multipart/related
    + text/html
      &lt;img src="cid:msgid"/&gt;
    + image/png
      Content-ID: &lt;msgid&gt;
</code></pre>
<p>Based on the example from <a href="https://docs.python.org/3/library/email.examples.html#email-examples" rel="noreferrer"><code>email</code>  module docs</a>:</p>
<pre><code>#!/usr/bin/env python3
import html
import mimetypes
from email.headerregistry import Address
from email.message import EmailMessage
from email.utils import make_msgid
from pathlib import Path

title = 'Picture report…'
path = Path('TESTING.png')
me = Address("Pepé Le Pew", *gmail_user.rsplit('@', 1))

msg = EmailMessage()
msg['Subject'] = 'Report…'
msg['From'] = me
msg['To'] = [me]
msg.set_content('[image: {title}]'.format(title=title))  # text/plain
cid = make_msgid()[1:-1]  # strip &lt;&gt;    
msg.add_alternative(  # text/html
    '&lt;img src="cid:{cid}" alt="{alt}"/&gt;'
    .format(cid=cid, alt=html.escape(title, quote=True)),
    subtype='html')
maintype, subtype = mimetypes.guess_type(str(path))[0].split('/', 1)
msg.get_payload()[1].add_related(  # image/png
    path.read_bytes(), maintype, subtype, cid="&lt;{cid}&gt;".format(cid=cid))

# save to disk a local copy of the message
Path('outgoing.msg').write_bytes(bytes(msg))
</code></pre>
<p>To send <code>msg</code> via gmail:</p>
<pre><code>import smtplib
import ssl

with smtplib.SMTP('smtp.gmail.com', timeout=10) as s:
    s.starttls(context=ssl.create_default_context())
    s.login(gmail_user, gmail_password)
    s.send_message(msg)
</code></pre>
<h3>Python 2/3 compatible version</h3>
<pre><code>* multipart/related
  - multipart/alternative
    + text/plain
    + text/html
      &lt;div dir="ltr"&gt;&lt;img src="cid:ii_xyz" alt="..."&gt;&lt;br&gt;&lt;/div&gt;
  - image/jpeg
    Content-ID: &lt;ii_xyz&gt;
</code></pre>
<p>Based on <a href="http://code.activestate.com/recipes/473810-send-an-html-email-with-embedded-image-and-plain-t/" rel="noreferrer">Send an HTML email with embedded image and plain text alternate</a>:</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
import cgi
import uuid
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text      import MIMEText
from email.mime.image     import MIMEImage
from email.header         import Header    

img = dict(title=u'Picture report…', path=u'TESTING.png', cid=str(uuid.uuid4()))

msg = MIMEMultipart('related')
msg['Subject'] = Header(u'Report…', 'utf-8')
msg['From'] = gmail_user
msg['To'] = ", ".join([to])
msg_alternative = MIMEMultipart('alternative')
msg.attach(msg_alternative)
msg_text = MIMEText(u'[image: {title}]'.format(**img), 'plain', 'utf-8')
msg_alternative.attach(msg_text)

msg_html = MIMEText(u'&lt;div dir="ltr"&gt;'
                     '&lt;img src="cid:{cid}" alt="{alt}"&gt;&lt;br&gt;&lt;/div&gt;'
                    .format(alt=cgi.escape(img['title'], quote=True), **img),
                    'html', 'utf-8')
msg_alternative.attach(msg_html)

with open(img['path'], 'rb') as file:
    msg_image = MIMEImage(file.read(), name=os.path.basename(img['path']))
    msg.attach(msg_image)
msg_image.add_header('Content-ID', '&lt;{}&gt;'.format(img['cid']))
</code></pre>
<p>To send <code>msg</code> via gmail:</p>
<pre><code>import ssl

s = SMTP_SSL('smtp.gmail.com', timeout=10,
             ssl_kwargs=dict(cert_reqs=ssl.CERT_REQUIRED,
                             ssl_version=ssl.PROTOCOL_TLSv1,
                             # http://curl.haxx.se/ca/cacert.pem
                             ca_certs='cacert.pem')) 
s.set_debuglevel(0)
try:
    s.login(gmail_user, gmail_pwd)
    s.sendmail(msg['From'], [to], msg.as_string())
finally:
    s.quit()
</code></pre>
<p><code>SMTP_SSL</code> is optional, you could use <code>starttls</code> method from your question instead:</p>
<pre><code>import smtplib
import socket
import ssl
import sys

class SMTP_SSL(smtplib.SMTP_SSL):
    """Add support for additional ssl options."""
    def __init__(self, host, port=0, **kwargs):
        self.ssl_kwargs = kwargs.pop('ssl_kwargs', {})
        self.ssl_kwargs['keyfile'] = kwargs.pop('keyfile', None)
        self.ssl_kwargs['certfile'] = kwargs.pop('certfile', None)
        smtplib.SMTP_SSL.__init__(self, host, port, **kwargs)

    def _get_socket(self, host, port, timeout):
        if self.debuglevel &gt; 0:
            print&gt;&gt;sys.stderr, 'connect:', (host, port)
        new_socket = socket.create_connection((host, port), timeout)
        new_socket = ssl.wrap_socket(new_socket, **self.ssl_kwargs)
        self.file = getattr(smtplib, 'SSLFakeFile', lambda x: None)(new_socket)
        return new_socket
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you need to add the following lines:</p>
<pre><code>from email.mime.image import MIMEImage

body = MIMEText('&lt;p&gt;Test Image&lt;img src="cid:testimage" /&gt;&lt;/p&gt;', _subtype='html')
msg.attach(body)


img = MIMEImage(image.read(), 'jpeg')
img.add_header('Content-Id', '&lt;testimage&gt;')
msg.attach(img)
</code></pre>
<p><code>testimage</code> should be replaced with a unique identifier</p>
</div>
<span class="comment-copy">I know I'm late to the party, but I put together a easy mailing class for stuff like this, since myself I need to use it every now and then <a href="http://datamakessense.com/easy-scheduled-emailing-with-python-for-typical-bi-needs/" rel="nofollow noreferrer">datamakessense.com/…</a></span>
<span class="comment-copy">How would I add text in the same e-mail as the image?</span>
<span class="comment-copy">Look at the MimeText calls in the code: they add plain text and HTML bodies in the first argument. You may write whatever you like there</span>
<span class="comment-copy">(you're missing an <code>import os</code>)</span>
<span class="comment-copy">@ABM: do you see <code># -*- coding: utf-8 -*-</code> at the top? (the code works with <code>'…'</code> on both Python 2 and 3)</span>
<span class="comment-copy">Using the python3 version of the code I get the mail but the image doesn't show up, I just get the alternate. Anyone else has this issue?</span>
