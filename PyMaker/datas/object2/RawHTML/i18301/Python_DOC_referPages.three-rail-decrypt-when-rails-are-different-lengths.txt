<div class="post-text" itemprop="text">
<p>Im having a ton of trouble trying to figure out how to get my decrypt function to work. It works in ideal cases where the msg is divisible by 3, but after that i am totally lost. I have a vague idea of what i have to do because i was able to get this to work with two rails, but there are more possibilities with three rails. Im quite lost :( Also all those print statements are just to try and help me figure out what is going on. </p>
<pre><code>import sys

def main():
    plaintext="abcdefgh"
    print(threeRailEncrypt(plaintext))
    print(threeRailDecrypt(threeRailEncrypt(plaintext)))


def threeRailEncrypt(plaintext):
    ciphertext=""
    rail1=""
    rail2=""
    rail3=""

    for i in range(len(plaintext)):
        if i%3 == 0:
            rail1=rail1+plaintext[i]
        elif i%3 == 1:
            rail2=rail2+plaintext[i]
        else:
            rail3=rail3+plaintext[i]

    ciphertext=rail1+rail2+rail3

    return(ciphertext)

def threeRailDecrypt(msg):
    if len(msg)%3==0:
        third=len(msg)//3
        print(third)
        rail1=msg[:third]
        rail2=msg[third:third*2]
        rail3=msg[third*2:]
        print(rail1,rail2,rail3)
        dm=""
        for i in range(third):
            dm=dm+rail1[i]
            dm=dm+rail2[i]
            dm=dm+rail3[i]
    else:
        third=(len(msg)//3)+1
        print(third)
        rail1=msg[:third]
        rail2=msg[third:third*2]
        rail3=msg[third*2:]
        print(rail1,rail2,rail3)
        dm=""
        for i in range(third):
            dm=dm+rail1[i]
            print(dm)
            dm=dm+rail2[i]
            print(dm)
            dm=dm+rail3[i]
            print(dm)
            if  len(rail2)&gt;len(rail3):
                dm=dm+rail2[-1]
        return(dm)
main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can slice strings (or any other sequence) using a stride; you can select every 3rd character with that:</p>
<pre><code>def threeRailEncrypt(plaintext):
    return plaintext[::3] + plaintext[1::3] + plaintext[2::3]
</code></pre>
<p>To reverse the trend, slice up the ciphertext into three chunks and use <a href="http://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow"><code>itertools.zip_longest()</code></a> to recombine them again:</p>
<pre><code>from itertools import zip_longest, chain

def threeRailDecrypt(ciphertext):
    stride, remainder = divmod(len(ciphertext), 3)
    # how large was each of the three sections?
    sizes = [stride] * 3
    for i in range(remainder):
        sizes[i] += 1
    # slice ciphertext up into 3 sections again
    pos = 0
    pieces = []
    for s in sizes:
        pieces.append(ciphertext[pos:pos + s])
        pos += s
    # recombine the triplets
    return ''.join(chain.from_iterable(zip_longest(*pieces, fillvalue='')))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; threeRailEncrypt('Foo bar baz and all')
'F raa lob znaoab dl'
&gt;&gt;&gt; threeRailDecrypt(threeRailEncrypt('Foo bar baz and all'))
'Foo bar baz and all'
</code></pre>
<p>The last part without <code>zip_longest</code> would be:</p>
<pre><code># recombine the triplets
plaintext = []
for i in range(len(parts[0])):
    for part in parts:
        try:
            plaintext.append(part[i])
        except IndexError:  # part too short
            pass
return ''.join(plaintext)
</code></pre>
</div>
<span class="comment-copy">I havent learned about izip_longest in class so i dont think i can use that method.</span>
<span class="comment-copy">@user2807779: the alternative is to loop over <code>range(len(pieces[0]))</code> and use that as an index into each of the 3 pieces.</span>
<span class="comment-copy">^ can you explain this a little more? how do i get pieces? also what does the 0 value do?</span>
<span class="comment-copy">@user2807779: see the update; <code>pieces[0]</code> is the first of the three ciphertext chunks.</span>
<span class="comment-copy">the second method also seems to be using commands i have not learned, do you know of any others?</span>
