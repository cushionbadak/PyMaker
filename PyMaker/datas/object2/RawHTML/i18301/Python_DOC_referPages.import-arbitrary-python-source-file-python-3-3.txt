<div class="post-text" itemprop="text">
<p>How can I import an arbitrary python source file (whose filename could contain any characters, and does not always ends with <code>.py</code>) in <strong>Python 3.3+</strong>?</p>
<p>I used <a href="http://docs.python.org/3/library/imp.html#imp.load_module"><code>imp.load_module</code></a> as follows:</p>
<pre><code>&gt;&gt;&gt; import imp
&gt;&gt;&gt; path = '/tmp/a-b.txt'
&gt;&gt;&gt; with open(path, 'U') as f:
...     mod = imp.load_module('a_b', f, path, ('.py', 'U', imp.PY_SOURCE))
...
&gt;&gt;&gt; mod
&lt;module 'a_b' from '/tmp/a-b.txt'&gt;
</code></pre>
<p>It still works in Python 3.3, but according to <code>imp.load_module</code> documentation, it is deprecated:</p>
<blockquote>
<p><em>Deprecated since version 3.3</em>: Unneeded as loaders should be used to
  load modules and find_module() is deprecated.</p>
</blockquote>
<p>and <code>imp</code> module documentation recommends to use <code>importlib</code>:</p>
<blockquote>
<p><strong>Note</strong> New programs should use importlib rather than this module.</p>
</blockquote>
<p>What is the proper way to load an arbitrary python source file in Python 3.3+ without using the deprecated <code>imp.load_module</code> function?</p>
</div>
<div class="post-text" itemprop="text">
<p>Found a solution from <a href="http://hg.python.org/cpython/file/436b606ecfe8/Lib/test/test_importlib/source/test_file_loader.py#l56" rel="noreferrer"><code>importlib</code> test code</a>.</p>
<p>Using <a href="http://docs.python.org/3/library/importlib.html#importlib.machinery.SourceFileLoader" rel="noreferrer">importlib.machinery.SourceFileLoader</a>:</p>
<pre><code>&gt;&gt;&gt; import importlib.machinery
&gt;&gt;&gt; loader = importlib.machinery.SourceFileLoader('a_b', '/tmp/a-b.txt')
&gt;&gt;&gt; mod = loader.load_module()
&gt;&gt;&gt; mod
&lt;module 'a_b' from '/tmp/a-b.txt'&gt;
</code></pre>
<p><strong>NOTE</strong>: only works in <em>Python 3.3+</em>.</p>
<p><strong>UPDATE</strong> <a href="https://docs.python.org/3.4/library/importlib.html#importlib.abc.Loader.load_module" rel="noreferrer"><code>Loader.load_module</code></a> is deprecated since Python 3.4. Use <a href="https://docs.python.org/3.4/library/importlib.html#importlib.abc.Loader.exec_module" rel="noreferrer"><code>Loader.exec_module</code></a> instead:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; import importlib.machinery
&gt;&gt;&gt; loader = importlib.machinery.SourceFileLoader('a_b', '/tmp/a-b.txt')
&gt;&gt;&gt; mod = types.ModuleType(loader.name)
&gt;&gt;&gt; loader.exec_module(mod)
&gt;&gt;&gt; mod
&lt;module 'a_b'&gt;
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; import importlib.machinery
&gt;&gt;&gt; import importlib.util
&gt;&gt;&gt; loader = importlib.machinery.SourceFileLoader('a_b', '/tmp/a-b.txt')
&gt;&gt;&gt; spec = importlib.util.spec_from_loader(loader.name, loader)
&gt;&gt;&gt; mod = importlib.util.module_from_spec(spec)
&gt;&gt;&gt; loader.exec_module(mod)
&gt;&gt;&gt; mod
&lt;module 'a_b' from '/tmp/a-b.txt'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Shorter version of @falsetrue 's solution:</p>
<pre><code>&gt;&gt;&gt; import importlib.util
&gt;&gt;&gt; spec = importlib.util.spec_from_file_location('a_b', '/tmp/a-b.py')
&gt;&gt;&gt; mod = importlib.util.module_from_spec(spec)
&gt;&gt;&gt; spec.loader.exec_module(mod)
&gt;&gt;&gt; mod
&lt;module 'a_b' from '/tmp/a-b.txt'&gt;
</code></pre>
<p>I tested it with Python 3.5 and 3.6.  </p>
<p>According to the comments, it does not work with arbitrary file extensions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Similar to @falsetru but for <strong>Python 3.5+</strong> and accounting for what <a href="https://docs.python.org/3/library/importlib.html#importlib.util.module_from_spec" rel="noreferrer">the <code>importlib</code> doc</a> states on using <code>importlib.util.module_from_spec</code> over <code>types.ModuleType</code>:</p>
<blockquote>
<p>This function [<code>importlib.util.module_from_spec</code>] is preferred over using <code>types.ModuleType</code> to create a new
  module as spec is used to set as many import-controlled attributes on
  the module as possible.</p>
</blockquote>
<p>We are able to import any file with <code>importlib</code> alone by modifying the <code>importlib.machinery.SOURCE_SUFFIXES</code> list.</p>
<pre class="lang-py prettyprint-override"><code>import importlib

importlib.machinery.SOURCE_SUFFIXES.append('') # empty string to allow any file
spec = importlib.util.spec_from_file_location(module_name, file_path)
module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(module)
# if desired: importlib.machinery.SOURCE_SUFFIXES.pop()
</code></pre>
</div>
<span class="comment-copy">Can I ask why you are doing this? I'm the maintainer of importlib and I have been trying to get answers from folks as to why they use <code>imp.load_module()</code> over a straight import statement. Do you expect to import the module by name later (e.g. <code>import a_b</code>)? Do you care that any custom importers won't be used in this approach? Do you expect the module to be full-featured (e.g. define <code>__name__</code> and <code>__loader__</code>)?</span>
<span class="comment-copy">@BrettCannon, A third-party program regularly (once a hour) modify a text file that contains python statements (mainly <code>THIS='blah'</code> like lines). The name of the file is not ended with <code>.py</code>. My program read that file.</span>
<span class="comment-copy">@BrettCannon, I'm not aware of custom importers. I don't care the module to be full-featured.</span>
<span class="comment-copy">IOW using Python as a really simple data structure format. Thanks for the info!</span>
<span class="comment-copy">@BrettCannon — I just ran into a case where I needed to import some Python code from within a directory which was named as a version number (e.g., "v1.0.2").  While possible, it would be highly undesirable to rename the directory.  I wound up using stefan-scherfke's solution below.</span>
<span class="comment-copy">Downvoter: How can I improve the answer? If you have a better way to accomplish what I want, please let me know.</span>
<span class="comment-copy">There's a helpful warning that <code>load_module</code> ignores via <code>warnings.catch_warnings</code>. If you instead use <code>mod = imp.load_source('a_b', '/tmp/a-b.txt')</code>, it raises the following warning (use <code>-Wall</code>): <code>DeprecationWarning: imp.load_source() is deprecated; use importlib.machinery.SourceFileLoader(name, pathname).load_module() instead</code>.</span>
<span class="comment-copy">@eryksun, You're right. Thank you for the comment. BTW, Python 3.4(rc1) does not display the alternative usage unlike Python 3.3.x.</span>
<span class="comment-copy">What's the difference between the first and the second example at the bottom?</span>
<span class="comment-copy">@MatthewD.Scholefield ways to get module objects are different. Using Module type directly or using utility.</span>
<span class="comment-copy"><code>importlib.util.spec_from_file_location(..)</code> returns <code>None</code> for me; causing an exception for the following <code>importlib.util.module_from_spec(..)</code> call. (See <a href="https://i.imgur.com/ZjyFhif.png" rel="nofollow noreferrer">i.imgur.com/ZjyFhif.png</a>)</span>
<span class="comment-copy"><code>importlib.util.spec_from_file_location</code> works for known file name extensions (<code>.py</code>, <code>.so</code>, ..), but not for others (<code>.txt</code>...)</span>
<span class="comment-copy">Oh, I’m using it only with Python files but modified my example to look like the one above and did not test it … I updated it.</span>
<span class="comment-copy">Interestingly enough, while this hack of appending the empty string to the list of source suffixes works great for importing renamed Python source modules, the equivalent for importing renamed extension modules does not work... That is, using <code>importlib.machinery.EXTENSION_SUFFIXES.append('')</code> still makes <code>importlib.util.spec_from_file_location</code> return None.</span>
<span class="comment-copy">presumably, <code>importlib.util.spec_from_file_location</code> should still work with extensions if you specify a loader</span>
