<div class="post-text" itemprop="text">
<p>I have a list made of lists(tuples?), and they follow the form below</p>
<pre><code>[(2,1),(3,0),(4,3),(5,2),(9,2),(7,4)]
</code></pre>
<p>I need to identify the element that satisfies the criteria listed:</p>
<ol>
<li>Has the highest 2nd(?) value. For example, in the above example, the output would be 7.</li>
<li><p>In the event of ties, the element with the lowest 1st(?) value. For example:</p>
<pre><code>[(5,1),(4,2),(1,2),(9,3),(8,3)]
</code></pre>
<p>This would return 8; 9 and 8 both have the highest 2nd(?) value and so in the tie-break, 8 is lower than 9, so 8 wins.</p></li>
</ol>
<p>*I put ?s where my terminology may be wrong but hopefully my post will be readable</p>
</div>
<div class="post-text" itemprop="text">
<p><s>Just sort it by the second then the -first element:</s></p>
<pre><code>&gt;&gt;&gt; lst=[(8,4),(2,1),(3,0),(4,3),(5,2),(9,2),(7,4)]
&gt;&gt;&gt; sorted(lst, key=lambda x: (x[1], -x[0]))[-1]
(7, 4)
</code></pre>
<p></p></div>
<div class="post-text" itemprop="text">
<p>Implement your own sorter:</p>
<pre><code>&gt;&gt;&gt; l=[(5,1),(4,2),(1,2),(9,3),(8,3)]
&gt;&gt;&gt; def sorter(t1, t2):
...     # if the second elements are equal sort based on the first
...     if t1[1] == t2[1]:
...             # positive return means higher value
...             return t1[0] - t2[0]
...     return t2[1] - t1[1]
... 
&gt;&gt;&gt; l.sort(sorter) # in place
&gt;&gt;&gt; l
[(8, 3), (9, 3), (1, 2), (4, 2), (5, 1)]
&gt;&gt;&gt; l[0]
(8, 3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also do this in one pass through the list, without having to sort it:</p>
<pre><code>l = [(2,1),(3,0),(4,3),(5,2),(9,2),(7,4)]

def max_second_val(lst):

    max = lst[0]    #Take first tuple to be the max

    for tup in lst:                # As you iterate through the tuples...
        if tup[1] == max[1]:       # If the 2nd elem of the current tuple is equal
            if tup[0] &lt; max[0]:    # to 2nd elem of curr max, and the first elem of curr
                max = tup          # tuple is smaller, take this to be the new max
        elif tup[1] &gt; max[1]:      # Otherwise, if 2nd elem of curr tuple is bigger than
            max = tup              # curr max, take this to be the new max

    return max
</code></pre>
</div>
<span class="comment-copy">I tried this for [(5,1),(4,2),(1,2),(9,3),(8,3)] by substituting lst in your sorted() and it returned (9,3) where it should return (8,3)</span>
<span class="comment-copy">@NoobCoder: works here: <a href="http://ideone.com/oF1Vbq" rel="nofollow noreferrer">ideone.com/oF1Vbq</a></span>
<span class="comment-copy">Tried it again in the codecademy labs editor, I must have made a mistake somewhere. Just so I understand what you are doing, what does the key=lambda: (x[1], -x[0]))[-1] part do?</span>
<span class="comment-copy">@NoobCoder: That might be my fault actually, because the first version I've posted had a bug - you were too quick with your testing. ;) <code>key</code> is a <a href="http://docs.python.org/3/howto/sorting.html#key-functions" rel="nofollow noreferrer">key function</a></span>
<span class="comment-copy">@NoobCoder: <code>x[1]</code> is the second value. <code>x[0]</code> is the first value. <code>-x[0]</code> is the first value negated. Applying that key function to each of the values gives you <code>(4,-8)</code>, then <code>(1,-2)</code>, and so on. So, sorting with that key function will give you your pairs sorted by the second value, falling back to the first value in reverse, exactly as you asked.</span>
<span class="comment-copy">Good idea, although in python it's <code>max(key=...)</code>.</span>
