<div class="post-text" itemprop="text">
<p>I'm referring to the <a href="http://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> from the <code>collections</code> module, which is an ordered dictionary.</p>
<p>If it has the added functionality of being orderable, which I realize may often not be necessary but even so, are there any downsides? Is it slower? Is it missing any functionality? I didn't see any missing methods.</p>
<p>In short, why <em>shouldn't</em> I always use this instead of a normal dictionary?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>OrderedDict</code> is a subclass of <code>dict</code>, and needs more memory to keep track of the order in which keys are added.  This isn't trivial.  The implementation adds a second <code>dict</code> under the covers, and a doubly-linked list of all the keys (that's the part that remembers the order), and a bunch of weakref proxies.  It's not a <strong>lot</strong> slower, but at least doubles the memory over using a plain <code>dict</code>.</p>
<p>But if it's appropriate, use it!  That's why it's there :-)</p>
<h2>How it works</h2>
<p>The base dict is just an ordinary dict mapping keys to values - it's not "ordered" at all.  When a <code>&lt;key, value&gt;</code> pair is added, the <code>key</code> is appended to a list.  The list is the part that remembers the order.</p>
<p>But if this were a Python list, <strong>deleting</strong> a key would take <code>O(n)</code> time twice over:  <code>O(n)</code> time to find the key in the list, and <code>O(n)</code> time to remove the key from the list.</p>
<p>So it's a doubly-linked list instead.  That makes deleting a key constant (<code>O(1)</code>) time.  But we still need to find the doubly-linked list node belonging to the key.  To make that operation <code>O(1)</code> time too, a second - hidden - dict maps keys to nodes in the doubly-linked list.</p>
<p>So adding a new <code>&lt;key, value&gt;</code> pair requires adding the pair to the base dict, creating a new doubly-linked list node to hold the key, appending that new node to the doubly-linked list, and mapping the key to that new node in the hidden dict.  A bit over twice as much work, but still <code>O(1)</code> (expected case) time overall.</p>
<p>Similarly, deleting a key that's present is also a bit over twice as much work but <code>O(1)</code> expected time overall:  use the hidden dict to find the key's doubly-linked list node, delete that node from the list, and remove the key from both dicts.</p>
<p>Etc.  It's quite efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>multithreading</strong></p>
<p>if your dictionary is accessed from multiple threads without a lock, especially as a synchronisation point.</p>
<p>vanilla dict operations are atomic, and any type extended in Python is not.</p>
<p>In fact, I'm not even certain OrderedDict is thread-safe (without a lock), although
I cannot discount the possibility that it was very carefully coded and satisfies definition of reentrancy.</p>
<p><strong>lesser devils</strong></p>
<p>memory usage if you create tons of these dictionaries</p>
<p>cpu usage if all your code does is munge these dictionaries</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>why shouldn't I always use this instead of a normal dictionary</p>
</blockquote>
<p>In Python 2.7, <strong>normal <code>OrderedDict</code> usage will create reference cycles</strong>. So any use of <code>OrderedDict</code> requires the garbage collector to be enabled in order to free the memory. Yes, the garbage collector is on by default in cPython, but disabling it <a href="https://engineering.instagram.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172" rel="nofollow noreferrer">has its uses</a>.</p>
<p>e.g. With cPython 2.7.14</p>
<pre><code>from __future__ import print_function

import collections
import gc

if __name__ == '__main__':
    d = collections.OrderedDict([('key', 'val')])
    gc.collect()
    del d
    gc.set_debug(gc.DEBUG_LEAK)
    gc.collect()
    for i, obj in enumerate(gc.garbage):
        print(i, obj)
</code></pre>
<p>outputs</p>
<pre><code>gc: collectable &lt;list 00000000033E7908&gt;
gc: collectable &lt;list 000000000331EC88&gt;
0 [[[...], [...], 'key'], [[...], [...], 'key'], None]
1 [[[...], [...], None], [[...], [...], None], 'key']
</code></pre>
<p>Even if you just create an empty <code>OrderedDict</code> (<code>d = collections.OrderedDict()</code>) and don't add anything to it, or you explicitly try to clean it up by calling the <code>clear</code> method (<code>d.clear()</code> before <code>del d</code>), you will still get one self-referencing list:</p>
<pre><code>gc: collectable &lt;list 0000000003ABBA08&gt;
0 [[...], [...], None]
</code></pre>
<p>This seems to have been the case since <a href="https://github.com/python/cpython/commit/2039753a9ab9d41375ba17877e231e8d53e17749#diff-52502c75edd9dd62aa7a817dbab542d2" rel="nofollow noreferrer">this commit</a> removed the <code>__del__</code> method in order to prevent the potential for <code>OrderedDict</code> to cause uncollectable cycles, which are arguably worse. As noted in the changelog for that commit:</p>
<blockquote>
<p><a href="https://bugs.python.org/issue9825" rel="nofollow noreferrer">Issue #9825</a>: removed __del__ from the definition of collections.OrderedDict.
  This prevents user-created self-referencing ordered dictionaries from
  becoming permanently uncollectable GC garbage.  The downside is that
  removing __del__ means that the internal doubly-linked list has to wait for
  GC collection rather than freeing memory immediately when the refcnt drops
  to zero.</p>
</blockquote>
<hr/>
<p>Note that in Python 3, the <a href="https://github.com/python/cpython/commit/fa11db0a02f22f8141206102efc21b125989364d#diff-52502c75edd9dd62aa7a817dbab542d2" rel="nofollow noreferrer">fix</a> for the same issue was made differently and uses weakref proxies to avoid cycles:</p>
<blockquote>
<p>Issue #9825: Using __del__ in the definition of collections.OrderedDict made
  it possible for the user to create self-referencing ordered dictionaries
  which become permanently uncollectable GC garbage. Reinstated the Py3.1
  approach of using weakref proxies so that reference cycles never get created
  in the first place.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.7, all dictionaries are guaranteed to be ordered. The Python contributors determined that switching to making <code>dict</code> ordered would not have a negative performance impact. I don't know how the performance of <code>OrderedDict</code> compares to <code>dict</code> in Python &gt;= 3.7, but I imagine they would be comparable since they are both ordered.</p>
<p>See also:</p>
<ul>
<li><a href="https://stackoverflow.com/q/50872498/247696">Will OrderedDict become redundant in Python 3.7</a>?</li>
</ul>
</div>
<span class="comment-copy">In addition, many packages return dicts and using them alongside OrderedDict will likely mess up the order anyway.</span>
<span class="comment-copy">My question is, <i>why use an OrderedDict</i>? Why would you need an ordered dictionary?</span>
<span class="comment-copy">I'd use OrderedDict ONLY for output formatting. Are there any other uses I'm missing?</span>
<span class="comment-copy">@Haidro, <a href="http://docs.python.org/3/library/inspect.html#inspect.Signature.parameters" rel="nofollow noreferrer">an example</a> from the standard library.</span>
<span class="comment-copy">If your only purpose for OrderedDict is for formatting output (presumably sorting keys), just use <code>for key in sorted(dictvar): print (key, dictvar[key])</code>. OrderedDict preserves order of insertion, not order of keys.</span>
<span class="comment-copy">@GrijeshChauhan, I read the source code - I'm a core Python developer, so that's how I answer most questions <b>I</b> have - LOL ;-)  You can find the code in <code>Lib/collections/__init__.py</code> in your Python source tree.</span>
<span class="comment-copy">Wait...YOU'RE THE GUY WHO WROTE TIMSORT!!! Unexpected descent from python heaven to answer my lowly question. THANKS!</span>
<span class="comment-copy">LOL!  You're very welcome, @Aerovistae - it was a worthy question ;-)</span>
<span class="comment-copy">I find when I tell people "you can find the code in your Python source tree" they never look, but when I <a href="http://hg.python.org/cpython/file/3.3/Lib/collections/__init__.py#!19" rel="nofollow noreferrer">link to the hg repo</a> they sometimes do. (Usually only when reading the source leads them to a question that's over my head.)</span>
<span class="comment-copy">@GrijeshChauhan Go to your python interpreter, type <code>import this</code> then press enter, the guy who wrote it, is the guy who answered this question.</span>
