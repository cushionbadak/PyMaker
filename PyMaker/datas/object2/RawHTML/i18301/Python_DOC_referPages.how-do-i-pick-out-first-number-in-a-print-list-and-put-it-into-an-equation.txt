<div class="post-text" itemprop="text">
<p>I have a program that works on a logfile to narrow it down to two items. That is as far as I have gotten and that is where my program stops, shown below. But I need to put the first of the two items into an equation and put the second item into a different equation. How can I do that?</p>
<pre><code>import pylab  
from pylab import *  
from numpy import *  
from collections import Counter  

list_of_files=[('logfile.txt', 'F')]  
datalist = [( pylab.loadtxt(filename), label ) for filename, label in list_of_files]  
for data, label in datalist:    

      print [k for k,v in Counter(data[:,1]).items() if v&gt;1 and 1500&lt;=k&lt;2200]
</code></pre>
<p>When I run above program it will print something like  <code>[1685, 1650]</code> </p>
<p>So I now need to add onto above program so that it automatically puts the first number, 1685, into an equation and then put the second number, 1650, into a different equation and print the results.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't pick out a value from something you printed. Once you print it, it's forgotten.</p>
<p>You have to <em>store</em> the thing in a variable. Then you can pick it out easily.</p>
<p>For example, instead of this:</p>
<pre><code>print [k for k,v in Counter(data[:,1]).items() if v&gt;1 and 1500&lt;=k&lt;2200]
</code></pre>
<p>Do this:</p>
<pre><code>thingies = [k for k,v in Counter(data[:,1]).items() if v&gt;1 and 1500&lt;=k&lt;2200]
print thingies
print first_equation(thingies[0])
print second_equation(thingies[1])
</code></pre>
<hr/>
<p>You're using a <code>Counter</code> to build your results. A <code>Counter</code>, like a <code>dict</code>, has no order.* If you add <code>a</code>, then <code>b</code>, then <code>c</code>, you might get back <code>a</code>, then <code>c</code>, then <code>b</code>, or any of the other 5 permutations.</p>
<p>If you need to preserve the original order, you have to take care of that manually. You can do that by using a separate "key list", iterating <code>k in keylist</code> instead of <code>k, v in counter.items()</code>, and using <code>counter[k]</code> in place of <code>v</code>. Or, more simply, just build an <code>OrderedCounter</code> out of <code>OrderedDict</code> and <code>Counter</code> (as shown in the <a href="http://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes" rel="nofollow">recipes</a> in the docs), and use that:</p>
<pre><code>thingies = [k for k,v in OrderedCounter(data[:,1]).items() if v&gt;1 and 1500&lt;=k&lt;2200]
</code></pre>
<p>On the other hand, if you need the end results in some <em>sorted</em> order, you can just sort them after the fact:</p>
<pre><code>thingies = sorted(k for k,v in Counter(data[:,1]).items() if v&gt;1 and 1500&lt;=k&lt;2200)
</code></pre>
<p>In your case, you want "the higher value number is [0]", which sounds like you want them sorted, but in reverse order. So:</p>
<pre><code>thingies = sorted((k for k,v in Counter(data[:,1]).items() if v&gt;1 and 1500&lt;=k&lt;2200),
                  reverse=True)
</code></pre>
<hr/>
<p>* Of course this isn't really true; they do have <em>some</em> order. But the order is generally not useful, and not worth knowing about, beyond the fact that iterating the same dict repeatedly with no changes in between will always get the same order.</p>
</div>
<span class="comment-copy">Standard warning for beginners: don't do <code>from X import *</code>, especially not with <code>numpy</code> and <code>pylab</code>.  This will replace certain built-in functions (<code>any</code> and <code>all</code>, for example) with <code>numpy</code>'s functions of the same names, which have dangerously different behaviour in certain circumstances.  The standard abbreviation is <code>import numpy as np</code> and then use <code>np.loadtxt</code>, or if you insist you could do <code>from numpy import loadtxt</code> and then use <code>loadtxt</code>.</span>
<span class="comment-copy">It's even more from to do <code>from X import *</code> when <code>X</code> is a dynamically-generated bindings library like the ones that gobj and pyobjc create; <code>from Cocoa import *</code> scans the entire Objective-C runtime few a few dozen seconds before giving you a few thousand namesâ€¦</span>
<span class="comment-copy">@DSM In general I agree, but there are times when one is writing a dedicated, 10-20 line script to parse a file and plot it's data when doing <code>from pylab import *</code> won't do any damage.  In fact, I'm pretty sure <code>pylab</code> was intended for this purpose (since it's supposed to turn python into a free MATLAB replacement).  But, if I had to make a black and white statement I would favor not doing it as you say.</span>
<span class="comment-copy">@SethMMorton: I'd say it doesn't do any damage <i>if you know why you shouldn't be doing it</i>.</span>
<span class="comment-copy">@DSM Knowledge is power!</span>
<span class="comment-copy">Thank you abarnert. I already tried your program and it works great!  Rico</span>
<span class="comment-copy">Well, after running program a few more times I notice that sometimes the two numbers are listed backwards, which then causes equations to give erroneous results. The higher value number always comes first during the test and it should always be the [0] number.</span>
<span class="comment-copy">So, how can I make sure the higher value number is [0] and the lower value number [1]?</span>
<span class="comment-copy">@Rico: I'll update the answer to explain.</span>
