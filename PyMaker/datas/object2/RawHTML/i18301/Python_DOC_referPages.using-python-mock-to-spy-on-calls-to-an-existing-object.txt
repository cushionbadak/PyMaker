<div class="post-text" itemprop="text">
<p>I'm using the Python mock module for tests. I would like to replace an active object with a mock, and automatically have all calls made to the mock object forwarded to the original object. I think this is called a "Spy" in standard testing terminology. At the moment I'm doing inside a test:</p>
<pre><code># Insert a mock replacement
orig_active_attr = server.active_attr
server.active_attr = mock.Mock()

# Set up side effects to 'proxy' to the original object
server.active_attr.meth1.side_effect = orig_active_attr.meth1
server.active_attr.meth2.side_effect = orig_active_attr.meth2

# Call the method being tested
server.method_being_tested()

# Assert stuff on the mock.
server.active_attr.meth2.assert_called_once()
</code></pre>
<p>It would be nice if all method calls on the mock could be forwarded to the live object automatically without the boilerplate.</p>
</div>
<div class="post-text" itemprop="text">
<p>I seem to have stumbled across the solution:</p>
<pre><code>import mock

class A(object):
    def meth(self, a):
        return a
a = A()
ma = mock.Mock(wraps=a)
</code></pre>
<p>Seems to work okay for functions, methods and properties, but not for class or instance attributes.</p>
<p>See <a href="https://docs.python.org/3/library/unittest.mock.html#the-mock-class" rel="nofollow noreferrer">the documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>patch.object(wraps=obj_instance)</code> as suggested in <a href="http://wesmckinney.com/blog/spying-with-python-mocks/" rel="nofollow noreferrer">Spying on instance methods with Python's mock module</a>.</p>
<p>For example:</p>
<pre><code>from mock import patch

class Foo(object):
    def bar(self, x, y):
        return x + y + 1

def test_bar():
    foo = Foo()
    with patch.object(foo, 'bar', wraps=foo.bar) as wrapped_foo:
        foo.bar(1, 2)
        wrapped_foo.assert_called_with(1, 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a simple function to iterate through all the method and configure your mock</p>
<pre><code>import inspect 

def spy_mock(instance):
    members = inspect.getmembers(instance, inspect.ismethod)
    attrs = {'%s.side_effect' % k:v for k,v in members}
    return mock.Mock(**attrs)

server.active_attr = spy_mock(server.active_attr)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's how to mock only <code>datetime.date.today()</code>, forwarding the rest of <code>datetime</code> calls to the <code>datetime</code> module:</p>
<pre><code>from unittest import mock, TestCase

import foo_module

class FooTest(TestCase):

    @mock.patch(f'{foo_module.__name__}.datetime', wraps=datetime)
    def test_something(self, mock_datetime):
        # mock only datetime.date.today()
        mock_datetime.date.today.return_value = datetime.datetime(2019, 3, 15)
        # other calls to datetime functions will be forwarded to original datetime
</code></pre>
<p><code>foo_module</code> imports <code>datetime</code> and uses many other <code>datetime</code> functions besides <code>date.today</code>.</p>
</div>
<span class="comment-copy">&gt; It would be nice if all method calls on the mock could be forwarded to the live object automatically without the boilerplate. ----  no it wouldn't. a mock would not be a mock if it's <i>actually</i> performing the behavior you want to mock.</span>
<span class="comment-copy">Semantics I guess, what I'm looking for here is called a Spy, but the library that does it is called mock. Or at least that is how I understand it :)</span>
<span class="comment-copy">Will not work for class methods.</span>
<span class="comment-copy">It isn't clear how to use these modified methods that you're spying on. Could you show an example?</span>
