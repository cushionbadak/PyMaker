<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/operator.html" rel="nofollow">operator</a> module makes it easy to avoid unnecessary functions and lambdas
in situations like this:</p>
<pre><code>import operator

def mytest(op, list1, list2):
    ok = [op(i1, i2) for i1, i2 in zip(list1, list2)]
    return all(ok)

mytest(operator.eq, [1, 2, 3], [1, 2, 3])         # True
mytest(operator.add, [-1, 2, -3], [1, -2, 33])    # False
</code></pre>
<p>Well, now I need to do <code>i1 and i2</code>, but to my surprise, I can't find <code>and</code> in the operator module!  And the same applies to <code>or</code>!  I know, <code>and</code> is not exactly <em>operator</em>, it's a <em>keyword</em>, but <code>not</code>, along with <code>is</code> and even <code>del</code>, are all keywords and all are included.</p>
<p>So what's the story?  Why are they missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because you cannot convert boolean operators into python functions. Functions always evaluate their arguments, and boolean operators do not. Adding <code>and</code> and <code>or</code> to the operators module would also require adding a special kind of functions (like lisp "macros") that evaluate their arguments on demand. Obviously, this is not something python designers ever wanted. Consider:</p>
<pre><code>if obj is not None and obj.is_valid():
    ....
</code></pre>
<p>you cannot write this in a functional form. An attempt like</p>
<pre><code>  if operator.xyz(obj is not None, obj.is_valid()) 
</code></pre>
<p>will fail if <code>obj</code> is actually <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can write these yourself, but you'll need to pass a function (e.g. lambda) for the second argument to prevent it from being evaluated at call time, assuming that the usual short-circuiting behavior is important to you.</p>
<pre><code>def func_or(val1, fval2):
    return val1 or fval2()

def func_and(val1, fval2):
    return val1 and fval2()
</code></pre>
<p>Usage:</p>
<pre><code>func_or(False, lambda: True)
func_and(True, lambda: False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason there's no <code>operator.and</code> is that <code>and</code> is a keyword, so that would be a <code>SyntaxError</code>. </p>
<p>As tgh435 explained, the reason there's no renamed <code>and</code> function in <code>operator</code> is that it would be misleading: a function call always evaluates its operands, but the <code>and</code> operator doesn't. (It would also be an exception to an otherwise consistent and simple rule.)</p>
<hr/>
<p>In your case, it looks like you don't actually care about short-circuiting at all, so can build your own version trivially:</p>
<pre><code>def and_(a, b):
    return a and b
</code></pre>
<p>Or, if you're just using it once, even inline:</p>
<pre><code>mytest(lambda a, b: a and b, [-1, 2, -3], [1, -2, 33])
</code></pre>
<hr/>
<p>In some cases, it's worth looking at <code>all</code> (and, for <code>or</code>, <code>any</code>). It is effectively short-circuited <code>and</code> expanded to arbitrary operands. Of course it has a different API than the <code>operator</code> functions, taking a single iterable of operands instead of two separate operands. And the way it short-circuits is different; it just stops iterating the iterable, which only helps if you've set things up so the iterable is only evaluating things as needed. So, it's usually not usable as a drop-in replacementâ€”but it's sometimes usable if you refactor your code a bit.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>and</code> and <code>or</code> syntaxes cannot directly be mapped to functions. These syntaxes are lazy evaluated: If the result of the left part of the expression allows to know the value of the whole expression, the right part is skipped. Since they introduce flow control, their behavior cannot be reproduced using an operator.
To reduce confusion, python have chosen to simply not provide these methods.</p>
<p>georg gives a good example of a situation where <code>and</code> laziness matters:</p>
<pre><code> if obj is not None and obj.is_valid():
     ...
</code></pre>
<p>Now, if you don't need lazy evaluation, you can use abarnert's answer implementation:</p>
<pre><code>def and_(a, b):
    return a and b

def or_(a, b):
    return a or b
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; or_(False, True)
&gt;&gt;&gt; and_(True, False)
</code></pre>
<p>If you need lazy evaluation, you can use kindall's answer implementation:</p>
<pre><code>def func_or(val1, fval2):
    return val1 or fval2()

def func_and(val1, fval2):
    return val1 and fval2()
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; func_or(False, lambda: True)
&gt;&gt;&gt; func_and(True, lambda: False)
</code></pre>
<p>Note:
As mentioned in the comments, the functions <code>operator.and_</code> and <code>operator.or_</code> correspond to the bitwise operators <code>&amp;</code> and <code>|</code>. See: <a href="https://docs.python.org/3/library/operator.html#mapping-operators-to-functions" rel="nofollow noreferrer">https://docs.python.org/3/library/operator.html#mapping-operators-to-functions</a></p>
<p>Note that the names <code>operators.and</code> and <code>operators.or</code> aren't used: <code>and</code> and <code>or</code> are Python keywords so it would be a syntax error.</p>
</div>
<span class="comment-copy">operator.and_ and operator.or_ are both there. Same goes for the other keyword operators, you need the _.</span>
<span class="comment-copy"><code>operator.and_</code> and <code>operator.or_</code> are the bitwise operators <code>&amp;</code> and <code>|</code>, not the logical <code>and</code> and <code>or</code>.</span>
<span class="comment-copy">As a side note, you don't really need <code>ok</code> to be a list here. If <code>list1</code> and <code>list2</code> can be very large, especially if it's likely that a false will show up pretty early in the list, you'd be much better off with a generator expression rather than a listcomp (and, if you're using 2.x, <code>itertools.izip</code> instead of <code>zip</code>).</span>
<span class="comment-copy">In many cases, you're looking for something that's just like <code>and</code> or <code>or</code>, but doesn't short-circuit. In that case, you can just write a one-liner function (out of line, or as a lambda) and use that. The reason it isn't included in <code>operator</code> is that it's not the same as <code>and</code> (because it doesn't short-circuit), meaning (a) it might mislead people into thinking it is, and (b) it would spoil the nice clean design of "operators map to <code>operator</code> functions exactly".</span>
