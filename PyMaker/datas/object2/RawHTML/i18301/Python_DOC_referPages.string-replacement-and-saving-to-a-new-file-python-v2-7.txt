<div class="post-text" itemprop="text">
<p>I am trying to replace all lines of a certain format with a blanks in a file i.e. replace a line of number/number/number (like a date) and number:number (like a time)  with "". I want to read from the old file and then save the scrubbed version as a new file. </p>
<p>This is the code I have so far (I know it is way off):</p>
<pre><code>old_file = open("old_text.txt", "r")
new_file = open("new_text.txt", "w")

print (old_file.read())

for line in old_file.readlines():
    cleaned_line = line.replace("%/%/%", "")
    cleaned_line = line.replace("%:%", "")
    new_file.write(cleaned_line)

old_file.close
new_file.close
</code></pre>
<p>Thank you for your help,
Ben</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, there are some indentation issues, where the <code>for</code> loop was indented for no reason. Secondly as soon as you <code>read</code> the file you have seeked to the end, so there are no more lines to read. Lastly, the <code>with</code> command allows you to open a file and declare its variable name, and allow it to close due to error or reading to the end without having to worry about closing it manually.</p>
<p>To perform the actual logic, however, you probably want to use a <a href="http://en.wikipedia.org/wiki/Regular_expression" rel="nofollow">regular expression</a>. You can use <code>re.search()</code> to find the pattern</p>
<ul>
<li><code>\d+:\d+</code> for any number of Digits , a colon and any number of Digits</li>
<li><code>\d+\/\d+\/d+</code> for three lots of any number of digits, with a literal <code>/</code> between them.</li>
</ul>
<p>The code you want is closer to this:</p>
<pre><code>import re
with open("old_text.txt", "r") as oldfile, open("new_text.txt", "w") as new_file:
    for line in old_file:
        # This will match if this pattern is anywhere in the line
        if re.search("\d+:\d+", line) is not None:
            line = ""
        # This will match if this pattern is anywhere in the line
        if re.search("\d+\/\d+\/d+", line) is not None:
            line = ""
        new_file.write(line)
</code></pre>
<p>If you only want to match at the beginning of the line, <a href="http://docs.python.org/2/library/re.html#re.match" rel="nofollow"><code>re.match()</code></a> will probably be a better choice.</p>
<p>Here we declare a block with our two files, loop through the <code>old_file</code>, clean each line and write to the <code>new_file</code>. Once the end of the <code>old_file</code> is reached all the files are cleanly closed. If either file is not found, or an error occurs, the with block catches these and releases everything nicely.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I am trying to replace all lines of a certain format with a blanks in a file i.e. replace a line of number/number/number (like a date) and number:number (like a time) with "".</p>
</blockquote>
<p>You can't use <code>str.replace</code> to match a pattern or format, only a literal string.</p>
<p>To match a pattern, you need some kind of parser. For patterns like this, the regular expression engine built into the standard library as <a href="http://docs.python.org/3/library/re.html" rel="nofollow"><code>re</code></a> is more than powerful enoughâ€¦ but you will need to learn how to write regular expressions for your patterns. The reference docs and <a href="http://docs.python.org/3/howto/regex.html#regex-howto" rel="nofollow">Regular Expression HOWTO</a> are great if you already know the basics; if not, you should search for a tutorial elsewhere.</p>
<p>Anyway, here's how you'd do this (fixing a few other things along the way, most of them explained by Lego Stormtroopr):</p>
<pre><code>import re

with open("old_text.txt") as old_file, open("new_text.txt", "w") as new_file:
    for line in old_file:
        cleaned_line = re.sub(r'\d+/\d+/\d+', '', line)
        cleaned_line = re.sub(r'\d+:\d+', '', cleaned_line)
        new_file.write(cleaned_line)
</code></pre>
<p>Also, note that I used <code>cleaned_line</code> in the second <code>sub</code>; just using <code>line</code> again, as in your original code, means we lose the results of the first substitution.</p>
<p>Without knowing the exact definition of your problem, I can't promise that this does exactly what you want. Do you want to blank all lines that <em>contain</em> the pattern number/number/number, blank out all lines that are nothing <em>but</em> that pattern, blank out just that pattern and leave the rest of the line alone? All of those things are doable, and pretty easy, with <code>re</code>, but they're all done a little differently.</p>
<hr/>
<p>If you want to get a little trickier, you can use a single <code>re.sub</code> expression to replace all of the matching lines with blank lines at once, instead of iterating them one at a time. That means a slightly more complicated regexp vs. slightly simpler Python code, and it means probably better performance for mid-sized files but worse performance (and an upper limit) for huge files, and so on. If you can't figure out how to write the appropriate expression yourself, and there's no performance bottleneck to fix, I'd stick with explicit looping.</p>
</div>
<span class="comment-copy">change <code>old_file.close</code> to <code>old_file.close()</code> same for new_file</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/9282967/how-to-open-a-file-using-the-open-with-statement">This question on the <code>with</code> command will be handy</a></span>
<span class="comment-copy">You don't need <code>old_file.readlines():</code> in your for loop. You can just do <code>for line in old_file:</code> To be honest, before I read your code, I never even knew <code>readlines</code> even existed.</span>
<span class="comment-copy">@ShashankGupta actually, in that code, <code>readlines</code> (or <code>for line in file</code>) won't do anything, as the <code>file.read()</code> call has seeked to the end of file. Meaning there is nothing to iterate over.</span>
<span class="comment-copy">@ShashankGupta: Half the tutorials out there teach people to use <code>readlines</code>. And I have no idea why. If it were up to me, <code>readlines</code> without a <code>hint</code> argument would have been scrapped in 3.x, instead of just making the note about it being unnecessary slightly more prevalent in the file object docs (which nobody knows how to find in 3.x anyway).</span>
<span class="comment-copy">The <code>readlines()</code> isn't adding anything here except for performance problems; just do <code>for line in old_file:</code>.</span>
<span class="comment-copy">More importantly, I don't think this actually solves the OP's problem. From his description, he's hoping to match all lines with the format number/number/number, not all lines with the literal string <code>%/%/%</code>, and that's the part he doesn't know how to do.</span>
<span class="comment-copy">@abarnert Updated to include the number matching logic.</span>
<span class="comment-copy">@ShashankGupta: Using a <code>with</code> for a pair of matching input and output files is a pretty common and accepted idiom in Python. In fact, it's the main rationale for adding the multi-context <code>with</code> statement tothe language.</span>
<span class="comment-copy">@ShashankGupta I'm doing things <b><code>with</code></b> these two files simultaneously. Why shouldn't they be together?</span>
<span class="comment-copy">I am looking to blank out all lines that contain strings of the format number/number/number or number:number completly. I believe I can work out what to do from your and Lego Stormtroopr's answers. Thanks for the quick replies.</span>
