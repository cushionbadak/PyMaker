<div class="post-text" itemprop="text">
<p>I am trying to use the <code>multiprocessing</code> package for <code>Python</code>. In looking at tutorials, the clearest and most straightforward technique seems to be using <code>pool.map</code>, which allows the user to easily name the number of processes and pass <code>pool.map</code> a function and a list of values for that function to distribute across the CPUs. The other technique that I have come across is <a href="http://toastdriven.com/blog/2008/nov/11/brief-introduction-multiprocessing/" rel="nofollow noreferrer">using queues</a> to manage a pool of workers. This <a href="https://stackoverflow.com/a/8533626/2327821">answer</a> does an excellent job explaining the difference between <code>pool.map</code>, <code>pool.apply</code>, and <code>pool.apply_async</code>, but what are the advantages and disadvantages of using <code>pool.map</code> versus using queues like in this <a href="http://toastdriven.com/blog/2008/nov/11/brief-introduction-multiprocessing/" rel="nofollow noreferrer">example</a>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>pool.map</code> technique is a "subset" of the technique with queues. That is, without having <code>pool.map</code> you can easily implement it using <code>Pool</code> and <code>Queue</code>. That said, using queues gives you much more flexibility in controlling your pool processes, i.e. you can make it so that particular types of messages are read only once per processes' lifetime, control the pool processes' shutdown behaviour, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're really looking for the "clearest and most straightforward technique", using <a href="http://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor" rel="nofollow"><code>concurrent.futures.ProcessPoolExecutor</code></a> is probably the easiest way. It has a <code>map</code> method as well as some other primitives that make it very usable. It is also compatible with <code>Queue</code>s.</p>
</div>
<span class="comment-copy">Does <code>pool.map</code> automatically shut down the processes when it completes?</span>
<span class="comment-copy">From the docs: <code>When the pool object is garbage collected terminate() will be called immediately.</code>. But i wouldn't rely on it - it'd better if you had ensured the pool has closed at the end of your app. Otherwise, you might end up with some zombies left in your system. As for <code>pool.map</code> - no, it doesn't shut down the processes. The processes live as long as their pool unless closed or orphaned.</span>
<span class="comment-copy">very easy and intuitive library.</span>
