<div class="post-text" itemprop="text">
<p>I am having a hard time keeping track of the tiles generated by <code>getAdjacentTiles(..)</code>. I have identified the performance issue of my A* implementation below is that I do not keep track of the tiles that have seen before, every call to <code>getAdjacentTiles</code> returns new tiles (<code>Node</code>'s) and not any of the tiles in <code>openSet</code> or <code>closedSet</code>. I decided to use a list of Node objects as all of the tiles created so far, and pass that to <code>getAdjacentTiles</code> to determine if a tile it produces has already been visited. </p>
<p>My problem is, that I cannot seem to keep track of these tiles properly. Whenever my A* needs to take more than about 4 movements to get to the <code>end</code> location it craps out. Which I am sure has to do with how I am trying to keep track of the tiles (again <code>Node</code>'s that have been visited) I would have to suspect the issue is with my knowledge of python, am I allowed to do <code>.apped(tile)</code> like I do in <code>getAdjacentTiles(...)</code> when looping through the <code>allTiles</code> set?</p>
<p><a href="https://stackoverflow.com/questions/19125808/python-review-and-speed-up-a-algorithm?noredirect=1#comment28286863_19125808">Here's a link to the question that led me to this one</a></p>
<p>The error generated (sometimes, only when the A* path is longer than about 3 steps..)</p>
<pre><code>File "P3.py", line 67, in aStar
 openSet.remove(curNode) 
KeyError: &lt;__main__.Node instance at 0xa39edcc&gt;
</code></pre>
<p>Source</p>
<pre><code>  #Perform an A* search to find the best path to the dirt
  def aStar(self, current, end):
    openSet = set()
    openHeap = []
    closedSet = set()
    allTiles = set()
    curNode = Node(0, current, self.manHatDist(current, end))
    openSet.add(curNode)
    allTiles.add(curNode)
    openHeap.append((curNode.cost,curNode))
    while openSet:
      curNode = heapq.heappop(openHeap)[1]
      if curNode.pos == end:
          return self.getDirections(curNode)
      openSet.remove(curNode)
      closedSet.add(curNode)
      adjNodes = self.getAdjacentNodes(curNode.pos, allTiles)
      for tile in adjNodes:
        t = tile
        if t not in closedSet:
          cost = (curNode.cost - self.manHatDist(curNode.pos, end) 
                  + self.euclidDist(curNode.pos, current)
                  + self.manHatDist(t.pos, end))
          if t not in openSet or cost &lt; t.cost:
            t.parent = curNode
            t.cost = cost
            openSet.add(t)
            heapq.heappush(openHeap, (cost,t))
        allTiles.add(t)
    return []

  #Get the moves made to get to this endNode
  def getDirections(self, endNode):
    moves = []
    tmpNode = endNode
    while tmpNode.parent is not None:
      moves.append(tmpNode.value)
      tmpNode = tmpNode.parent
    moves.reverse()
    return moves

  #Return all possible moves from given tile as Node objects
  def getAdjacentNodes(self, curPos, allTiles):
    allMoves = ['North','South','East','West']
    posMoves = []
    for direction in allMoves:
      if(self.canMove(direction, curPos)):
        posMoves.append(Node(direction, self.getLocIfMove(curPos, direction)))
    retNodes = []
    for posLocNode in posMoves:
      set = False
      for tile in allTiles:
        if(posLocNode.pos == tile.pos):
          set = True
          retNodes.append(tile)
      if(not set):
        retNodes.append(posLocNode)
    return retNodes
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's fire up the interactive interpreter and see what we can find. (You didn't give the name of your class in the question, so I've called it <code>Search</code>.)</p>
<pre><code>&gt;&gt;&gt; Search().aStar((0,0), (2,2))
Traceback (most recent call last):
  ...
  File "q19128695.py", line 25, in aStar
    openSet.remove(curNode)
KeyError: &lt;__main__.Node instance at 0x104895518&gt;
</code></pre>
<p>OK, the first problem is that these <code>Node</code> instances are not self-explanatory. We can't do anything with "Node instance at 0x104895518", so let's add a <code>__repr__</code> method to the <code>Node</code> class:</p>
<pre><code>def __repr__(self):
    return 'Node({0.value}, {0.pos}, {0.cost})'.format(self)
</code></pre>
<p>and try again:</p>
<pre><code>&gt;&gt;&gt; Search().aStar((0,0), (2,2))
Traceback (most recent call last):
  ...
  File "q19128695.py", line 25, in aStar
    openSet.remove(curNode)
KeyError: Node(East, (1, 2), 3.41421356237)
</code></pre>
<p>OK, that's more informative. Let's fire up the <a href="http://docs.python.org/3/library/pdb.html" rel="nofollow">Python debugger</a> and do a <a href="http://docs.python.org/3/library/pdb.html#pdb.pm" rel="nofollow">postmortem</a>:</p>
<pre><code>&gt;&gt;&gt; import pdb
&gt;&gt;&gt; pdb.pm()
&gt; q19128695.py(25)aStar()
-&gt; openSet.remove(curNode)
(Pdb) openSet
set([Node(North, (2, -1), 6.0), Node(East, (2, 2), 4.65028153987), 
     Node(West, (-1, 1), 5.0), Node(North, (0, -1), 5.0),
     Node(South, (1, 3), 6.65028153987), Node(South, (0, 3), 6.0), 
     Node(East, (3, 0), 6.0), Node(West, (-1, 0), 5.0),
     Node(North, (1, -1), 5.0), Node(East, (3, 1), 6.65028153987),
     Node(West, (-1, 2), 6.0)])
(Pdb) closedSet
set([Node(0, (0, 0), 4), Node(South, (2, 1), 3.41421356237),
     Node(East, (1, 1), 3.0), Node(South, (0, 1), 3.0),
     Node(East, (2, 0), 3.0), Node(East, (1, 0), 3.0),
     Node(East, (1, 2), 3.41421356237), Node(South, (0, 2), 3.0)])
(Pdb) curNode
Node(East, (1, 2), 3.41421356237)
(Pdb) curNode in closedSet
True
</code></pre>
<p>So the node has already been closed. How could this have happened? Well, it could happen if the node had been added to <code>openSet</code> and <code>openHeap</code> twice. It would then be popped from <code>openHeap</code> twice (because heaps can have multiple identical items), but it can only be removed from <code>openSet</code> once. The code in question looks like this:</p>
<pre><code>if t not in openSet or cost &lt; t.cost:
    t.parent = curNode
    t.cost = cost
    openSet.add(t)
    heapq.heappush(openHeap, (cost,t))
</code></pre>
<p>The first problem with this, is that you push the pair <code>(cost, t)</code> even though you've gone to the trouble to give your <code>Node</code> objects <code>__lt__</code> and <code>__gt__</code> methods. Instead, just push <code>t</code> onto the heap:</p>
<pre><code>heapq.heappush(openHeap, t)
</code></pre>
<p>This requires a couple of changes elsewhere: instead of</p>
<pre><code>openHeap.append((curNode.cost,curNode))
while openSet:
    curNode = heapq.heappop(openHeap)[1]
</code></pre>
<p>you'll have to write</p>
<pre><code>openHeap = [curNode]
while openSet:
    curNode = heapq.heappop(openHeap)
</code></pre>
<p>Now, the second problem (which is my faultâ€”sorry), is that if <code>t</code> is already in <code>openSet</code> then we shouldn't add it to the heap again. Instead, we should re-heapify:</p>
<pre><code>t_open = t in openSet
if not t_open or cost &lt; t.cost:
    t.parent = curNode
    t.cost = cost
    if t_open:
        heapq.heapify(openHeap)
    else:
        openSet.add(t)
        heapq.heappush(openHeap, t)
</code></pre>
<p>Going back to the debugger output, recall this:</p>
<pre><code>(Pdb) curNode
Node(East, (1, 2), 3.41421356237)
</code></pre>
<p>That <code>3.41421356237</code> should be worrying you: shouldn't the cost always be an integer? It looks as though the cost calculation is still wrong. It says:</p>
<pre><code>    cost = (curNode.cost
            - self.manHatDist(curNode.pos, end) 
            + self.euclidDist(curNode.pos, current)
            + self.manHatDist(t.pos, end))
</code></pre>
<p>but that third line should say:</p>
<pre><code>            + self.euclidDist(curNode.pos, t.pos)
</code></pre>
<p>So, with all those fixes in place, let's try again:</p>
<pre><code>&gt;&gt;&gt; Search().aStar((0,0), (2,2))
['North', 'North', 'East', 'East']
</code></pre>
<h3>Replies to comments</h3>
<ol>
<li><p>"How did you call <code>Search().aStar(...)</code> from the interpreter?" I ran the interpreter and then typed in that line of code at the interpreter prompt. <a href="http://docs.python.org/3/tutorial/interpreter.html" rel="nofollow">See the tutorial</a>.</p></li>
<li><p>"So the Euclidean distance will always be one." Yes, if you're searching for paths in a uniform-cost grid, then the Euclidean distance between neighbours will always be the same.</p></li>
<li><p>"Now that I think about it, <code>curNode.cost - self.manHatDist(curNode.pos, end)</code> is always equal to zero." That's not right. In your implementation, the <code>cost</code> of a search node is (i) the cost of reaching that node from the start, <em>plus</em> (ii) an admissible estimate of the cost of reaching the end from that node. So if you subtract the admissible estimate then you should get back to (i) again.</p></li>
</ol>
</div>
<span class="comment-copy">Can you print <code>openSet</code> on each step?</span>
<span class="comment-copy">Why is there a capital H in <code>manHatDist</code>?</span>
<span class="comment-copy">Its Man Hatten Island... Its German for "man has that island", traces back to when George Washington bought Louisiana territory and as a present to the German's let them name the Island (the most prominent land mass of the Louisiana purchase) ///jk//// I'm not sure why I capitalized it.</span>
<span class="comment-copy">Thank you, how did you call <code>Search().aStar(..)</code> from the interpreter? // You just taught me debugging in python, thank you. // I see now what you meant in the linked post in my question above, <code>self.euclidDist(curNode.pos, t.pos)</code> will always be equal to one, t is always and only a node either NSEW of the <code>curNode</code>; so the euclidean distance will always be one. // Well I guess now that I think about it <code>curNode.cost - self.manHatDist(curNode.pos, end)</code> is always equal to zero. I think I got tripped up with heuristics and admissibility. //</span>
<span class="comment-copy">See updated answer.</span>
