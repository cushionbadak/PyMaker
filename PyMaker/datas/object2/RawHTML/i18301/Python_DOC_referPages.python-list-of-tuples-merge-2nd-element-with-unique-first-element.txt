<div class="post-text" itemprop="text">
<p>Given a list of tuples like so:</p>
<pre><code>a = [ ( "x", 1, ), ( "x", 2, ), ( "y", 1, ), ( "y", 3, ), ( "y", 4, ) ]
</code></pre>
<p>What would be the easiest way to filter for unique first element and merge the second element.  An output like so would be desired.</p>
<pre><code>b = [ ( "x", 1, 2 ), ( "y", 1, 3, 4 ) ]
</code></pre>
<p>Thanks,</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="http://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code></a>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(tuple)
&gt;&gt;&gt; a = [('x', 1), ('x', 2), ('y', 1), ('y', 3), ('y', 4)]
&gt;&gt;&gt; for tup in a:
...     d[tup[0]] += (tup[1],)
...
&gt;&gt;&gt; [tuple(x for y in i for x in y) for i in d.items()]
[('y', 1, 3, 4), ('x', 1, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; a = [("x", 1,), ("x", 2,), ("y", 1,), ("y", 3,), ("y", 4,)]
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for k, v in a:
...     d.setdefault(k, [k]).append(v)
&gt;&gt;&gt; b = map(tuple, d.values())
&gt;&gt;&gt; b
[('y', 1, 3, 4), ('x', 1, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what I came up with:</p>
<pre><code>[tuple(list(el) + [q[1] for q in a if q[0]==el]) for el in set([q[0] for q in a])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to previous answers, another one-liner:</p>
<pre><code>&gt;&gt;&gt; a = [ ( "x", 1, ), ( "x", 2, ), ( "y", 1, ), ( "y", 3, ), ( "y", 4, ) ]
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [(key,) + tuple(elem for _, elem in group) for key, group in groupby(a, lambda pair: pair[0])]
[('x', 1, 2), ('y', 1, 3, 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way is by using <em>list comprehension</em> expression with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> , <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> and <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> as:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby, chain
&gt;&gt;&gt; from operator import itemgetter

&gt;&gt;&gt; my_list = [ ( "x", 1, ), ( "x", 2, ), ( "y", 1, ), ( "y", 3, ), ( "y", 4, ) ]

&gt;&gt;&gt; [set(chain(*i)) for _, i in groupby(sorted(my_list), key=itemgetter(0))]
[set(['x', 2, 1]), set(['y', 1, 3, 4])]
</code></pre>
<p><strong>Note:</strong> <code>set</code> are unordered in nature, so they won't preserve the position of elements. Do not use <code>set</code> if the position matters. </p>
</div>
<span class="comment-copy">Does order matter?</span>
