<div class="post-text" itemprop="text">
<p>Would you know by any chance how to get rid on the bytes identifier in front of a string in a Python's list, perhaps there is some global setting that can be amended?</p>
<p>I retrieve a query from the Postgres 9.3, and create a list form that query. It looks like Python 3.3 interprets records in columns that are of type <code>char(4)</code> as if the they are bytes strings, for example: </p>
<pre><code>Funds[1][1]
b'FND3'
Funds[1][1].__class__
&lt;class 'bytes'&gt;
</code></pre>
<p>So the implication is:</p>
<pre><code>Funds[1][1]=='FND3'
False
</code></pre>
<p>I have some control over that database so I could change the column type to <code>varchar(4)</code>, and it works well:</p>
<pre><code>Funds[1][1]=='FND3'
True
</code></pre>
<p>But this is only a temporary solution. 
The little b  makes my life a nightmare for the last two days ;), and I would appreciate your help with that problem.</p>
<p>Thanks and Regards
Peter</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to either manually implement <code>__str__</code>/<code>__repr__</code> or, if you're willing to take the risk, do some sort of Regex-replace over the string.</p>
<p>Example <code>__repr__</code>:</p>
<pre><code>def stringify(lst):
    return "[{}]".format(", ".join(repr(x)[1:] if isinstance(x, bytes) else repr(x) for x in lst))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>b</code> isn't part of the string, any more than the quotes around it are; they're just part of the representation when you print the string out. So, you're chasing the wrong problem, one that doesn't exist.</p>
<p>The problem is that the byte string <code>b'FND3'</code> is not the same thing as the string <code>'FND3'</code>. In this particular example, that may seem silly, but if you might ever have any non-ASCII characters anywhere, it stops being silly.</p>
<p>For example, the string <code>'é'</code> is the same as the byte string <code>b'\xe9'</code> in Latin-1, and it's also the same as the byte string <code>b'\xce\xa9'</code> in UTF-8. And of course <code>b'\xce\a9'</code> is the same as the string <code>'Ã©'</code> in Latin-1.</p>
<p>So, you have to be explicit about what encoding you're using:</p>
<pre><code>Funds[1][1].decode('utf-8')=='FND3'
</code></pre>
<hr/>
<p>But why is PostgreSQL returning you byte strings? Well, that's what a char column is. It's up to the Python bindings to decide what to do with them. And without knowing which of the multiple PostgreSQL bindings you're using, and which version, it's impossible to tell you what to do. But, for example, in <a href="http://initd.org/psycopg/docs/usage.html#strings-adaptation" rel="nofollow">recent-ish psycopg</a>, you just have to set an <code>encoding</code> in the connection (e.g., <code>conn.set_client_encoding('UTF-8')</code>; in older versions you had to register a standard typecaster and do some more stuff; etc.; in py-postgresql you have to register <code>lambda s: s.decode('utf-8')</code>; etc.</p>
</div>
<span class="comment-copy">The <code>b</code> isn't part of the string, any more than the quotes around it are; they're just part of the representation when you print the string out. So, you're chasing the wrong problem, one that doesn't exist.</span>
<span class="comment-copy">Also, you probably want to read the <a href="http://docs.python.org/3/howto/unicode.html" rel="nofollow noreferrer">Unicode HOWTO</a> to understand why we have separate bytes and str types, etc.</span>
<span class="comment-copy">Problem is solved now, thank you All for your quick responses and great help!</span>
