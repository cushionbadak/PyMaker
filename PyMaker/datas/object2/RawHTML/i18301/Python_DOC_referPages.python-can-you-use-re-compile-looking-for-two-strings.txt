<div class="post-text" itemprop="text">
<p>I am using python 2.7 and have a this in my code: <code>regexp = re.compile('ttp_ws_sm_(\d)_')</code></p>
<p>That searches in my loop for different characters as in my sample (after the third underscore). I need to also do the same for strings like <code>'ttpv1_(\d+)_'</code></p>
<p>The two things I have tried are:</p>
<pre><code>regexp = re.compile('ttp_ws_sm_(\d)_' or 'ttpv1_(\d+)_')
</code></pre>
<p>and</p>
<pre><code>name = ('ttp_ws_sm_(\d+)_' or 'ttpv1_(\d+)_')
regexp = re.compile(name)
</code></pre>
<p>Here's some example data:</p>
<pre><code>sample filheader row
date,ttp_ws_sm_001_01, , , , , , , , , , , ,117
date,ttp_ws_sm_001_blank, , , , , , , , , , , ,31
date,ttp_ws_sm_045_01, , , , , , , , , , , ,145
date,ttp_ws_sm_045_blank, , , , , , , , , , , ,55
date,ttp_ws_sm_057_blank, , , , , , , , , , , ,98
date,ttpv1_001_, , , , , , , , , , , ,67
date,ttpv1_001_01, , , , , , , , , , , ,67*e is 
</code></pre>
<p>complete code is:</p>
<pre><code>from collections import defaultdict

import sys
import csv
import re
import os

#variables
output_path = '\\\\Isfs\\data$\\GIS Carto\TTP_Draw_Count'
source = '\\\\Isfs\\data$\\GIS Carto\TTP_Draw_Count'
name = ('ttp_ws_sm_(\d+)_' or 'ttpv1_(\d+)_')

def main():
    result = defaultdict(int)
    regexp = re.compile(name)

    with open(os.path.join(source, 'TTP_13_08.csv'), 'r') as f:
        rows = csv.reader(f)

        for row in rows:
            match = regexp.search(row[1])
            if match:
                result[match.group(1)] += int(row[13])

    for key, value in result.items():

         print ("Club %s %s" % (key, value))

if __name__ == '__main__':
    main()
</code></pre>
<p>If I don't use name and just put either of both strings in the compile statement I only return one set of totals. I need to have both sets combine and print for "001", '045'</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand you correctly, you want a regex that matches either <code>'ttp_ws_sm_(\d+)_'</code> or <code>'ttpv1_(\d+)_'</code>?</p>
<p>You can use the <a href="http://docs.python.org/3/howto/regex.html#more-metacharacters" rel="noreferrer">pipe character <code>|</code></a>:</p>
<pre><code>re.compile(r'(?:ttp_ws_sm|ttpv1)_(\d+)_')
</code></pre>
<p><code>?:</code> makes the first group <a href="http://docs.python.org/3/howto/regex.html#non-capturing-and-named-groups" rel="noreferrer">non-capturing</a>.</p>
<pre><code>&gt;&gt;&gt; pattern = re.compile(r'(?:ttp_ws_sm|ttpv1)_(\d+)_')
&gt;&gt;&gt; pattern.match('ttpv1_001_').group(1)
'001'
&gt;&gt;&gt; pattern.match('ttp_ws_sm_045_blank').group(1)
'045'
</code></pre>
<hr/>
<p><code>'ttp_ws_sm_(\d+)_' or 'ttpv1_(\d+)_'</code> doesn't work because it is actually the same as <code>'ttp_ws_sm_(\d+)_'</code>.  See Max's answer for an explanation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should read a Python book. You have some severe misunderstandings of the language.</p>
<pre><code>'ttp_ws_sm(\d+)_' or 'ttpv1_(\d+)_'
</code></pre>
<p>is a Boolean expression. Python interprets nonempty strings as truthy so it interprets this as (true thing or true thing). When the first part of a Boolean or is true, Python doesn't even look at the second part and just returns the first. Look:</p>
<pre><code>('foo' or 'bar') == 'foo'
&gt;&gt;&gt; True
</code></pre>
<p>That's why it (accidentally) works inside <code>re.compile</code>. Passing a Boolean expression to <code>re.compile</code> doesn't really make sense.</p>
<p>Secondly it's not clear what you're even trying to accomplish here. A single regexp might not be appropriate or could require different capture groups.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; line = 'date,ttp_ws_sm_001_01, , , , , , , , , , , ,117 date,ttp_ws_sm_001_blank, , , , , , , , , , , ,31 date,ttp_ws_sm_045_01, , , , , , , , , , , ,145 date,ttp_ws_sm_045_blank, , , , , , , , , , , ,55 date,ttp_ws_sm_057_blank, , , , , , , , , , , ,98 date,ttpv1_001_, , , , , , , , , , , ,67 date,ttpv1_001_01, , , , , , , , , , , ,67*e'
&gt;&gt;&gt; name = re.compile(r'(?:ttp_ws_sm\d+_)|(?:ttpv1_\d+_)')
&gt;&gt;&gt; name.findall()
&gt;&gt;&gt; ['ttp_ws_sm_001', 'ttp_ws_sm_045', 'ttp_ws_sm_045', 'ttp_ws_sm_057', 'ttpv1_001_', 'ttpv1_001_']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Read the doc:</h2>
<blockquote>
<p>'|'<br/>
  A|B, where A and B can be arbitrary REs, creates a regular
  expression that will match either A or B.<br/>
<a href="http://docs.python.org/2/library/re.html#regular-expression-syntax" rel="nofollow">http://docs.python.org/2/library/re.html#regular-expression-syntax</a></p>
</blockquote>
<h2>Read the doc:</h2>
<blockquote>
<p>csv.reader(csvfile, dialect='excel', **fmtparams)<br/>
   (...)<br/>
  If csvfile is
  a file object, it must be opened with the ‘b’ flag on platforms where
  that makes a difference.<br/>
<a href="http://docs.python.org/2/library/csv.html#module-csv" rel="nofollow">http://docs.python.org/2/library/csv.html#module-csv</a></p>
</blockquote>
</div>
<span class="comment-copy">Please format your sample data so that it is readable and clarify the question to explicitly identify your desired result.</span>
<span class="comment-copy">And a minor point: you're not correctly escaping backslashes in <code>output_path</code> and <code>source</code>. You got lucky because <code>\T</code> is not a valid escape sequence.</span>
<span class="comment-copy">Actually I meant to take the output path out. That is something else I will tackle later.</span>
<span class="comment-copy">I tried it and didn't get my desired total. Seems it is only going through the first string (ttp_ws_sm_(\d+) and not total the rows with ttpv1.</span>
<span class="comment-copy">I guess that's because the digits in <code>ttpv1_(\d+)_</code> are <code>.group(2)</code> now (which is clearly not what you want). I'll update my answer.</span>
<span class="comment-copy">This question can be closed. Using regexp = re.compile(r'(?:ttp_ws_sm|ttpv1)_(\d+)_')   worked perfectly.</span>
<span class="comment-copy">@MikeHirschmann A better regex pattern is <code>ttp(?:_ws_sm|v1)_(\d+)_</code></span>
<span class="comment-copy">I am searching for answers in two books - Learning Python and Python Phrasebook. I am also doing a couple of online tutorials. I am learning python on the fly and it just hasn't sunk in since this is my first coding attempt. The code works fine if I just look for the string. Just trying to look for both.</span>
<span class="comment-copy">I should re-emphasize: read <b>a</b> Python book. Grabbing pieces from a bunch of different sources to solve your immediate problem when you've never coded before is going to give you a patchy, confusing understanding of the language.</span>
<span class="comment-copy"><code>There's probably some "grouping" syntax that doesn't have the side-effect of making it a "group" in the return from findall.</code> - Yes there is, it's <code>(?:blabla)</code> :)</span>
<span class="comment-copy">Thanks @flornquake.  I've edited my response.</span>
