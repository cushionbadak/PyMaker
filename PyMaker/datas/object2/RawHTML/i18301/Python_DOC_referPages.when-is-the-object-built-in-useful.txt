<div class="post-text" itemprop="text">
<p>I'm trying to figure out what I would use the <code>object()</code> built-in function for. It takes no arguments, and returns a "featureless object" of the type that is common to all Python classes, and has all the methods that are common to all Python classes.</p>
<p>To quote Jack Skellington, <a href="http://docs.python.org/3/library/functions.html#object" rel="noreferrer">WHAT. IS. THIS?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Even if you do not need to program with it, <code>object</code> serves a purpose: it is the common class from which all other objects are derived. It is the last class listed by the <code>mro</code> (<a href="http://www.python.org/2.3/mro.html" rel="nofollow noreferrer">method resolution order</a>) method. We need a name and object for this concept, and <code>object</code> serves this purpose.</p>
<p>Another use for <code>object</code> is to create <a href="http://books.google.com/books?id=1Shx_VXS6ioC&amp;pg=PT770&amp;lpg=PT770&amp;dq=python%20sentinel%20threading&amp;source=bl&amp;ots=BC85aBVdQ6&amp;sig=EC97ajU1m96pCqaG9av7JO1u5wQ&amp;hl=en&amp;sa=X&amp;ei=0Ug-UrqPLbi34AO3qoGQBA&amp;ved=0CGIQ6AEwCQ#v=onepage&amp;q=python%20sentinel%20threading&amp;f=false" rel="nofollow noreferrer">sentinels</a>.</p>
<pre><code>sentinel = object()
</code></pre>
<p>This is often used in multithreaded programming -- passed through queues -- to <a href="https://stackoverflow.com/a/18770670/190597">signal a termination event</a>. We might not want to send <code>None</code> or any other value since the queue handler may need to interpret those values as arguments to be processed. We need some unique value that no other part of the program may generate.</p>
<p>Creating a sentinel this way provides just such a unique object that is sure not to be a normal queue value, and thus can be tested for and used as a signal for some special event. There are other possibilities, such as creating a class, or class instance, or a function, but all those alternatives are bigger, more resource heavy, and not as pithy as <code>object()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is most useful if you are overriding the dot (especially <code>__setattr__</code>), it allows you to break recursion.  For example:</p>
<pre><code>class SomeClass(object):
    def __setattr__(self, name, value):
        if name not in ('attr1', 'attr2', 'attr3', 'attr4'):
            object.__setattr__(self, name, value)
        else:
            do_something_else()
</code></pre>
</div>
<span class="comment-copy">It isn't intended to be used as a function; it's intended to be used a a base class.</span>
<span class="comment-copy">In python 3? Why? What would I gain from that? Classes inherit those methods automatically, no?</span>
<span class="comment-copy">I find it hilarious how in the documentation link that you give, it has some hyperlinked text which recursively points to itself.</span>
<span class="comment-copy">Welcome to Stack Exchange! Here's your <a href="http://stackexchange.com/sites">carnival event guide</a></span>
<span class="comment-copy">I'd generally avoid calling methods on <code>object</code> directly, in favor of using <code>super()</code> instead. One reason is that it allows cooperative multiple inheritance. The <code>object</code> class will still be involved of course, since it's the final base class that the <code>super()</code> calls will eventually reach, but you don't need to name it explicitly.</span>
<span class="comment-copy">@Blckknght I generally agree with you on that, however, in the case of breaking recursion, I am usually also trying to break the recursion caused by a super-class (isn't working with frameworks fun?).  This is the one use case where I (in general) explicitly use object.</span>
<span class="comment-copy">@Tritium21: I'm not entirely sure I understand. Do you mean that you'd use <code>object.__setattr__</code> instead of <code>super().__setattr__</code> when the alternative case (<code>do_something_else</code> in your example) is already a call to <code>super().__setattr__</code> and that's what you're trying to skip? If so, that makes sense, but I wouldn't call it recursion (which I'd take to mean a function calling itself, not calling a superclass method of the same name). If <code>super().__setattr__</code> calls <code>self.__setattr__</code> then it would be infinitely recursive without your override, which seems like a bug in the superclass.</span>
<span class="comment-copy">indeed, the case I work with (an internal project) do_something_else() would also include a call to super-class' setattr.  Even when it doesn't I call on object if nothing but out of habit.</span>
