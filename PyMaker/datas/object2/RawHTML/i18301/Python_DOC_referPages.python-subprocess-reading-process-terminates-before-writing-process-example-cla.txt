<div class="post-text" itemprop="text">
<p>Code snippet from: <a href="http://docs.python.org/3/library/subprocess.html#replacing-shell-pipeline" rel="nofollow">http://docs.python.org/3/library/subprocess.html#replacing-shell-pipeline</a></p>
<pre><code>output=`dmesg | grep hda`
# becomes
p1 = Popen(["dmesg"], stdout=PIPE)
p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
output = p2.communicate()[0]
</code></pre>
<p>Question: I do not quite understand why this line is needed: <code>p1.stdout.close()</code>?
What if by doing this p1 stdout is closed even before it is completely done outputting data and p2 is still alive ? Are we not risking that by closing <code>p1.stdout</code> so soon? How does this work?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>p1.stdout.close()</code> closes Python's <em>copy</em> of the file descriptor. <code>p2</code> already has that descriptor open (via <code>stdin=p1.stdout</code>), so closing Python's descriptor doesn't affect <code>p2</code>. However, now that pipe end is only opened once, so when it closes (e.g. if <code>p2</code> dies), <code>p1</code> will see the pipe close and will get <code>SIGPIPE</code>.</p>
<p>If you didn't close <code>p1.stdout</code> in Python, and <code>p2</code> died, <code>p1</code> would get no signal because Python's descriptor would be holding the pipe open.</p>
</div>
<div class="post-text" itemprop="text">
<p>Pipes are external to processes (its an operating system thing) and are accessed by processes using read and write handles. Many processes can have handles to the pipe and can read and write in all sorts of disastrous ways if not managed properly. Pipes close when all handles to the pipes are closed.</p>
<p>Although process execution works differently in Linux and Windows, Here is basically what happens (I'm going to get killed on this!)</p>
<pre><code>p1 = Popen(["dmesg"], stdout=PIPE)
</code></pre>
<p>Create pipe_1, give a write handle to dmesg as its stdout, and return a read handle in the parent as p1.stdout. You now have 1 pipe with 2 handles (pipe_1 write in dmesg, pipe_1 read in the parent).</p>
<pre><code>p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
</code></pre>
<p>Create pipe_2. Give grep a write handle to pipe_2 and a copy of the read handle to pipe_1. You now have 2 pipes and 5 handles (pipe_1 write in dmesg, pipe_1 read and pipe_2 write in grep, pipe_1 read and pipe_2 read in the parent).</p>
<pre><code>p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
</code></pre>
<p>Notice that pipe_1 has two read handles. You want grep to have the read handle so that it reads dmesg data. You don't need the handle in the parent any more. Close it so that there is only 1 read handle on pipe_1. If grep dies, its pipe_1 read handle is closed, the operating system notices there are no remaining read handles for pipe_1 and gives dmesg the bad news.</p>
<pre><code>output = p2.communicate()[0]
</code></pre>
<p>dmesg sends data to stdout (the pipe_1 write handle) which begins filling pipe_1. grep reads stdin (the pipe_1 read handle) which empties pipe_1. grep also writes stdout (the pipe_2 write handle) filling pipe_2. The parent process reads pipe_2... and you got yourself a pipeline!</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/6046779/explain-example-from-python-subprocess-module">Explain example from python subprocess module</a></span>
<span class="comment-copy">Rats! I had to write a long answer and lost out. Yours is nice too (smile).</span>
<span class="comment-copy">does not make sense to me. What do you mean : "read end is duplicated in the child" ? Can you talk in terms of p1 stdout and p2 stdin ?</span>
<span class="comment-copy">Sorry about that, I'll expand the answer.</span>
