<div class="post-text" itemprop="text">
<p>When using <code>try</code> and <code>except</code> for error handling, does it matter whether you explicitly call <code>finally</code> or if you simply go to a new line that is dedented from the exception code? For example, is there any circumstance under which the two functions below will produce different results?</p>
<pre><code>#Function 1 with finally
def final(x):
    try:
        print(x*x)

    except:
        print("Error")

    finally:
        print("End Function")


#Function 2 with new line dedent
def dedent(x):
    try:
        print(x*x)

    except:
        print("Error")

    print("End Function")
</code></pre>
<p><strong>Update:</strong>
Thanks for the explanation of <code>finally</code> running even if there is an error in the <code>except</code> block. One additional thing I wanted to point out is that the <code>finally</code> block will run even if you return an object within the except block. For example, function 3 below will print even after the <code>return</code> while function 4 will not.</p>
<pre><code>#Function 3 with finally
def final(x):
    try:
        print(x*x)

    except:
        return 3

    finally:
        print("End Function 3")


#Function 4 with new line dedent
def dedent(x):
    try:
        print(x*x)

    except:
        return 3

    print("End Function 4")

test1 = final('test')
test2 = dedent('test')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is the error in the <code>except</code> block that's been mentioned already:</p>
<pre><code>def final(x):
    try:
        print(x*x)

    except:
        print("Error")
        damnit

    finally:
        print("End Function")

def dedent(x):
    try:
        print(x*x)

    except:
        print("Error")
        damnit

    print("End Function")

try:
    final("a")
except Exception as e:
    print("There was an error:", e)
#&gt;&gt;&gt; Error
#&gt;&gt;&gt; End Function
#&gt;&gt;&gt; There was an error: global name 'damnit' is not defined

try:
    dedent("a")
except Exception as e:
    print("There was an error:", e)
#&gt;&gt;&gt; Error
#&gt;&gt;&gt; There was an error: global name 'damnit' is not defined
</code></pre>
<p>There's also <code>return</code> behaviour:</p>
<pre><code>def final(x):
    try:
        print(x*x)

    except:
        print("Error")
        return "Return inside"

    finally:
        print("End Function")
        return "Return outside"

def dedent(x):
    try:
        print(x*x)

    except:
        print("Error")
        return "Return inside"

    print("End Function")
    return "Return outside"

try:
    final("a")
except Exception as e:
    print("There was an error:", e)
#&gt;&gt;&gt; Error
#&gt;&gt;&gt; End Function
#&gt;&gt;&gt; 'Return outside'

try:
    dedent("a")
except Exception as e:
    print("There was an error:", e)
#&gt;&gt;&gt; Error
#&gt;&gt;&gt; 'Return inside'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="http://www.python.org/dev/peps/pep-0341/" rel="nofollow" title="PEP 431">PEP 341</a>:</p>
<blockquote>
<pre><code>try:
    block-1 ...
except Exception1:
    handler-1 ...
except Exception2:
    handler-2 ...
else:
    else-block
finally:
    final-block
</code></pre>
<p>The code in block-1 is executed. If the code raises an exception, the
  various except blocks are tested: if the exception is of class
  Exception1, handler-1 is executed; otherwise if it's of class
  Exception2, handler-2 is executed, and so forth. If no exception is
  raised, the else-block is executed.</p>
<p>No matter what happened previously, the final-block is executed once
  the code block is complete and any raised exceptions handled. Even if
  there's an error in an exception handler or the else-block and a new
  exception is raised, the code in the final-block is still run.</p>
</blockquote>
<p>So as Martjin said, the code in finally will be executed even if the <code>except</code> raises another another error.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first version will still run the <code>finally:</code> suite even when the <code>except</code> handler raises a <em>new</em> exception. In the second version, the final <code>print()</code> will <em>not</em> be executed in that case:</p>
<pre><code>&gt;&gt;&gt; def print(*args, **kw):
...     if not args or args[0] != 'End Function':
...         raise ValueError("Only print End Function!")
...     __builtins__.print(*args, **kw)
... 
&gt;&gt;&gt; final(0)
End Function
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 3, in final
  File "&lt;stdin&gt;", line 3, in print
ValueError: Only print End Function!

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in final
  File "&lt;stdin&gt;", line 3, in print
ValueError: Only print End Function!
&gt;&gt;&gt; dedent(0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 3, in dedent
  File "&lt;stdin&gt;", line 3, in print
ValueError: Only print End Function!

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in dedent
  File "&lt;stdin&gt;", line 3, in print
ValueError: Only print End Function!
</code></pre>
<p>Note that the <em>first</em> thing printed in <code>final(0)</code> is <code>End Function</code>; no such text is printed for <code>dedent(0)</code>.</p>
<p>You never need to explicitly execute a <code>finally:</code> suite; it is <strong>always</strong> run, even if you were to exit the function early with <code>return</code>, or break out of a loop with <code>break</code> or use <code>continue</code> to skip the rest of the loop body:</p>
<pre><code>&gt;&gt;&gt; while True:
...     try:
...         print("In an infinite loop?")
...         break
...     finally:
...         print("Executed before the loop ends")
... 
In an infinite loop
Executed before the loop ends
</code></pre>
<p>Quoting from the <a href="http://docs.python.org/3/reference/compound_stmts.html#the-try-statement" rel="nofollow"><code>try</code> statement documentation</a>:</p>
<blockquote>
<p>If <code>finally</code> is present, it specifies a ‘cleanup’ handler. The <code>try</code> clause is executed, including any <code>except</code> and <code>else</code> clauses. If an exception occurs in any of the clauses and is not handled, the exception is temporarily saved. The <code>finally</code> clause is executed. If there is a saved exception it is re-raised at the end of the <code>finally</code> clause.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>When a <code>return</code>, <code>break</code> or <code>continue</code> statement is executed in the <code>try</code> suite of a <code>try</code>...<code>finally</code> statement, the <code>finally</code> clause is also executed ‘on the way out.’</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The difference is clear if exceptions are raised all over the place.</p>
<p>If only the try block raises an error then they are the same.</p>
<pre><code>#Function 1 with finally
def final(x):
    try:
        print(x*x)
        raise Exception
    except:
        print("Error")    
    finally:
        print("End Function")


#Function 2 with new line dedent
def dedent(x):
    try:
        print(x*x)
        raise Exception
    except:
        print("Error")    
    print("End Function")

final(10)
dedent(10)
</code></pre>
<p>However. If the except block also raises an error, then the finally block is guaranteed to run.</p>
<pre><code>#Function 1 with finally
def final(x):
    try:
        print(x*x)
        raise Exception
    except:
        print("Error")
        raise Exception
    finally:
        print("This will be printed")

#Function 2 with new line dedent
def dedent(x):
    try:
        print(x*x)
        raise Exception
    except:
        print("Error")
        raise Exception
    print("This will not be printed")
final(10)
dedent(10)
</code></pre>
</div>
<span class="comment-copy">Your example is very trivial to understand the usage. Look at this example: <a href="http://stackoverflow.com/a/11552007/1628832">stackoverflow.com/a/11552007/1628832</a></span>
<span class="comment-copy">Thanks for pointing out the <code>return</code> behavior, I just noticed that as well while playing with my code.</span>
