<div class="post-text" itemprop="text">
<p>I'm fairly new to actual programming languages, and Python is my first one. I know my way around Linux a bit, enough to get a summer job with it (I'm still in high school), and on the job, I have a lot of free time which I'm using to learn Python.</p>
<p>One thing's been getting me though. What exactly is different in Python when you have expressions such as</p>
<pre><code>x.__add__(y) &lt;==&gt; x+y
x.__getattribute__('foo') &lt;==&gt; x.foo
</code></pre>
<p>I know what methods do and stuff, and I get what they do, but my question is: How are those double underscore methods above different from their simpler looking equivalents?</p>
<p>P.S., I don't mind being lectured on programming history, in fact, I find it very useful to know :) If these are mainly historical aspects of Python, feel free to start rambling.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, power for the programmer is good, so there should be a way to customize behaviour. Like operator overloading (<code>__add__</code>, <code>__div__</code>, <code>__ge__</code>, ...), attribute access (<code>__getattribute__</code>, <code>__getattr__</code> (those two are differnt), <code>__delattr__</code>, ...) etc. In many cases, like operators, the usual syntax maps 1:1 to the respective method. In other cases, there is a special procedure which at some point involves calling the respective method - for example, <code>__getattr__</code> is only called if the object doesn't have the requested attribute and <code>__getattribute__</code> is not implemented or raised AttributeError. And some of them are really advanced topics that get you deeeeep into the object system's guts and are rarely needed. So no need to learn them all, just consult the reference when you need/want to know. Speaking of reference, <a href="http://docs.python.org/reference/datamodel.html#special-method-names" rel="noreferrer">here it is</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the creator of Python <a href="http://python-history.blogspot.com/2009/02/adding-support-for-user-defined-classes.html" rel="noreferrer">explaining it</a>:</p>
<blockquote>
<p>... rather than devising a new syntax for
  special kinds of class methods (such
  as initializers and destructors), I
  decided that these features could be
  handled by simply requiring the user
  to implement methods with special
  names such as <code>__init__</code>, <code>__del__</code>, and
  so forth. This naming convention was
  taken from C where identifiers
  starting with underscores are reserved
  by the compiler and often have special
  meaning (e.g., macros such as
  <code>__FILE__</code> in the C preprocessor).</p>
</blockquote>
<p>...</p>
<blockquote>
<p>I also used this technique to allow
  user classes to redefine the behavior
  of Python's operators. As previously
  noted, Python is implemented in C and
  uses tables of function pointers to
  implement various capabilities of
  built-in objects (e.g., “get
  attribute”, “add” and “call”). To
  allow these capabilities to be defined
  in user-defined classes, I mapped the
  various function pointers to special
  method names such as <code>__getattr__</code>,
  <code>__add__</code>, and <code>__call__</code>. There is a
  direct correspondence between these
  names and the tables of function
  pointers one has to define when
  implementing new Python objects in C.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>When you start a method with two underscores (and no trailing underscores), Python's <a href="http://docs.python.org/reference/expressions.html#atom-identifiers" rel="noreferrer">name mangling</a> rules are applied. This is a way to loosely simulate the <code>private</code> keyword from other OO languages such as C++ and Java. (Even so, the method is still technically not private in the way that Java and C++ methods are private, but it is "harder to get at" from outside the instance.)</p>
<p>Methods with two leading and two trailing underscores are considered to be "built-in" methods, that is, they're used by the interpreter and are generally the concrete implementations of overloaded operators or other built-in functionality.</p>
</div>
<div class="post-text" itemprop="text">
<p>They are used to specify that the Python interpreter should use them in specific situations.</p>
<p>E.g., the <code>__add__</code> function allows the <code>+</code> operator to work for custom classes. Otherwise you will get some sort of not defined error when attempting to add. </p>
</div>
<div class="post-text" itemprop="text">
<p>From an historical perspective, leading underscores have often been used as a method for indicating to the programmer that the names are to be considered internal to the package/module/library that defines them.  In languages which do not provide good support for private namespaces, using underscores is a convention to emulate that.  In Python, when you define a method named '__foo__' the maintenance programmer knows from the name that something special is going on which is not happening with a method named 'foo'.  If Python had choosen to use 'add' as the internal method to overload '+', then you could never have a class with a method 'add' without causing much confusion.  The underscores serve as a cue that some magic will happen. </p>
</div>
<div class="post-text" itemprop="text">
<p>A number of other questions are now marked as duplicates of this question, and at least two of them ask what either the <code>__spam__</code> methods are called, or what the convention is called, and none of the existing answers cover that, so:</p>
<p>There actually is no official name for either. </p>
<p>Many developers unofficially call them "dunder methods", for "Double UNDERscore". </p>
<p>Some people use the term "magic methods", but that's somewhat ambiguous between meaning dunder methods, special methods (see below), or something somewhere between the two.</p>
<hr/>
<p>There <em>is</em> an official term "special attributes", which overlaps closely but not completely with dunder methods. The <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow">Data Model</a> chapter in the reference never quite explains what a special attribute is, but the basic idea is that it's at least one of the following:</p>
<ul>
<li>An attribute that's provided by the interpreter itself or its builtin code, like <code>__name__</code> on a function.</li>
<li>An attribute that's part of a protocol implemented by the interpreter itself, like <code>__add__</code> for the <code>+</code> operator, or <code>__getitem__</code> for indexing and slicing.</li>
<li>An attribute that the interpreter is allowed to look up specially, by ignoring the instance and going right to the class, like <code>__add__</code> again.</li>
</ul>
<p>Most special attributes are methods, but not all (e.g., <code>__name__</code> isn't). And most use the "dunder" convention, but not all (e.g., the <code>next</code> method on iterators in Python 2.x).</p>
<p>And meanwhile, most dunder methods are special attributes, but not all—in particular, it's not that uncommon for stdlib or external libraries to want to define their own protocols that work the same way, like the <a href="https://docs.python.org/3/library/pickle.html#pickling-class-instances" rel="nofollow"><code>pickle</code></a> protocol.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>[Speculation]</em> Python was influenced by <a href="http://algol68.sourceforge.net" rel="nofollow">Algol68</a>, <a href="https://www.linkedin.com/redirect?url=http%3A%2F%2Fpython-history%2Eblogspot%2Ecom%2Eau%2F2009%2F04%2Forigins-of-pythons-functional-features%2Ehtml&amp;urlhash=hkao&amp;_t=tracking_disc" rel="nofollow">Guido</a> possibly used Algol68 at the <a href="http://en.wikipedia.org/wiki/University_of_Amsterdam" rel="nofollow">University of Amsterdam</a> where Algol68 has a similar "<a href="http://en.wikipedia.org/wiki/Stropping_%28syntax%29#Examples_of_different_ALGOL_68_styles" rel="nofollow">stropping regime</a>" called "Quote stropping". In Algol68 the <strong>operators, types and keywords</strong> <em>can</em> appear in a different typeface (usually **<strong>bold</strong>**, or <em>__underlined</em>__), in sourcecode files this typeface is achieved with quotes, e.g. 'abs' (quoting similar to quoting in '<a href="http://en.wikipedia.org/wiki/Lightweight_markup_language#Text_formatting" rel="nofollow">wikitext</a>')</p>
<h2>Algol68 ⇒ Python (Operators mapped to member functions)</h2>
<ul>
<li>'and' ⇒ __and__</li>
<li>'or' ⇒ __or__</li>
<li>'not' ⇒ not</li>
<li>'entier' ⇒ __trunc__</li>
<li>'shl' ⇒ __lshift__</li>
<li>'shr' ⇒ __rshift__</li>
<li>'upb' ⇒ __sizeof__</li>
<li>'long' ⇒ __long__</li>
<li>'int' ⇒ __int__</li>
<li>'real' ⇒ __float__</li>
<li>'format' ⇒ __format__</li>
<li>'repr' ⇒ __repr__</li>
<li>'abs' ⇒ __abs__</li>
<li>'minus' ⇒ __neg__</li>
<li>'minus' ⇒ __sub__</li>
<li>'plus' ⇒ __add__</li>
<li>'times' ⇒ __mul__</li>
<li>'mod' ⇒ __mod__</li>
<li>'div' ⇒ __truediv__</li>
<li>'over' ⇒ __div__</li>
<li>'up' ⇒ __pow__</li>
<li>'im' ⇒ imag</li>
<li>'re' ⇒ real</li>
<li>'conj' ⇒ conjugate</li>
</ul>
<p>In Algol68 these were refered to as <strong>bold names</strong>, e.g. <strong>abs</strong>, but "under-under-abs" __abs__ in python.</p>
<p>My 2 cents:  ¢ So sometimes — like a ghost — when you cut and paste python classes into a wiki you will magically reincarnate Algol68's <strong>bold</strong> keywords. ¢</p>
</div>
<span class="comment-copy">You can find some information here: <a href="http://docs.python.org/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer">docs.python.org/reference/…</a></span>
<span class="comment-copy">+1 I don't know why people are downvoting this.</span>
<span class="comment-copy">You're pretty good at explaining things, thanks! One question though, can you name a common case (perhaps a link to a code example) where these double underscore methods do something different than the operators?</span>
<span class="comment-copy">Huh? The special methods that are operators are just called right away (afaik). Of course there are many others that don't represent operators, like the <code>__getattribute__</code> we both already named or <code>__enter__</code>/<code>__exit__</code> for with statements (<code>with open("file") as f: do_stuff(f)</code>). In these cases, there are some more complex rules, and the documentation knows them better than I.</span>
<span class="comment-copy">Ah, I see. This stuff's still a bit confusing to me, but you really helped clear most of it up. Thank you, delnan.</span>
<span class="comment-copy">@S.Lott: Wat? It's right there, the last three words.</span>
<span class="comment-copy">Too hidden.  Should have been first or more prominent.</span>
<span class="comment-copy">That's good to know, but Python is my first programming language. I don't know what "private" is or name mangling, as delnan posted in a comment below. Thanks though, this answer will be much better for me once I do.</span>
<span class="comment-copy">From what I hear, you don't typically use the <code>__</code> lead to do private, but rather you use it when your function might step on the namespace of another. With that in mind, I've seen people say to use a single underscore to mark it as an "implementation detail".</span>
<span class="comment-copy">Nice and concise. Where else might they show up commonly in Python besides custom classes?</span>
