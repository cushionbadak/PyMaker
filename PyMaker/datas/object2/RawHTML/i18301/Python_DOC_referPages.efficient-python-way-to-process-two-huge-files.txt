<div class="post-text" itemprop="text">
<p>I am working on a problem where I have to find if a number falls within a certain range. However, the problem is complicated due to the fact that the files I am dealing with have hundreds of thousands of lines. </p>
<p>Below I try to explain the problem in as simple a language as possible. </p>
<p>Here is a brief description of my input files :</p>
<p>File <strong>Ranges.txt</strong> has some ranges whose min and max are tab separated.</p>
<pre><code>10 20
30 40
60 70
</code></pre>
<p>This can have about 10,000,000 such lines with ranges. </p>
<p><strong>NOTE:</strong> The ranges <strong>never</strong> overlap. </p>
<p>File <strong>Numbers.txt</strong> has a list of numbers and some values associated with each number. </p>
<pre><code>12 0.34
22 0.14
34 0.79
37 0.87
</code></pre>
<p>And so on. Again there are hundreds of thousands of such lines with numbers and their associated values.</p>
<p>What I wish to do is take every number from <strong>Numbers.txt</strong> and check if it falls within any of the ranges in <strong>Ranges.txt</strong>. </p>
<p>For all such numbers that fall within a range, I have to get a mean of their associated values (ie a mean per range). </p>
<p>For eg. in the example above in <strong>Numbers.txt</strong>, there are two numbers 34 and 37 that fall within the range 30-40 in <strong>Ranges.txt</strong>, so for the range 30-40 I have to calculate the mean of the associated values of 34 and 37. (i.e mean of 0.79 and 0.87), which is 0.82</p>
<p>My final output file should be the <strong>Ranges.txt</strong> but with the mean of the associated values of all numbers falling within each range. Something like :</p>
<p><strong>Output.txt</strong></p>
<pre><code>10 20 &lt;mean&gt;
30 40 0.82
60 70 &lt;mean&gt;
</code></pre>
<p>and so on.</p>
<p>Would appreciate any help and ideas on how this can be written efficiently in Python. </p>
</div>
<div class="post-text" itemprop="text">
<p>Obviously you need to run each line from Numbers.txt against each line from Ranges.txt.</p>
<p>You could just iterate over Numbers.txt, and, for each line, iterate over Ranges.txt. But this will take forever, reading the whole Ranges.txt file millions of times.</p>
<p>You could read both of them into memory, but that will take a lot of storage, and it means you won't be able to do any processing until you've finished reading and preprocessing both files.</p>
<p>So, what you want to do is read Ranges.txt into memory once and store it as, say, a list of pairs of ints instead, but read Numbers.txt lazily, iterating over the list for each number.</p>
<p>This kind of thing comes up all the time. In general, you want to make the bigger collection into the outer loop, and make it as lazy as possible, while the smaller collection goes into the inner loop, and is pre-processed to make it as fast as possible. But if the bigger collection can be preprocessed more efficiently (and you have enough memory to store it!), reverse that.</p>
<hr/>
<p>And speaking of preprocessing, you can do a lot better than just reading into a list of pairs of ints. If you sorted Ranges.txt, you could find the closest range without going over by bisecting then just check that (18 steps), instead of checking each range exhaustively (100000 steps).</p>
<p>This is a bit of a pain with the stdlib, because it's easy to make off-by-one errors when using <a href="http://docs.python.org/3/library/bisect.html" rel="nofollow"><code>bisect</code></a>, but there are plenty of ActiveState recipes to make it easier (including one <a href="http://code.activestate.com/recipes/577197-sortedcollection/" rel="nofollow">linked from the official docs</a>), not to mention third-party modules like <a href="https://pypi.python.org/pypi/blist/" rel="nofollow"><code>blist</code></a> or <a href="https://pypi.python.org/pypi/bintrees/" rel="nofollow"><code>bintrees</code></a> that give you a sorted collection in a simple OO interface.</p>
<hr/>
<p>So, something like this pseudocode:</p>
<pre><code>with open('ranges.txt') as f:
    ranges = sorted([map(int, line.split()) for line in f])
range_values = {}
with open('numbers.txt') as f:
    rows = (map(int, line.split()) for line in f)
    for number, value in rows:
        use the sorted ranges to find the appropriate range (if any)
        range_values.setdefault(range, []).append(value)
with open('output.txt') as f:
    for r, values in range_values.items():
        mean = sum(values) / len(values)
        f.write('{} {} {}\n'.format(r[0], r[1], mean))
</code></pre>
<hr/>
<p>By the way, if the parsing turns out to be any more complicated than just calling <code>split</code> on each line, I'd suggest using the <code>csv</code> module… but it looks like that won't be a problem here.</p>
<hr/>
<p>What if you can't fit Ranges.txt into memory, but can fit Numbers.txt? Well, you can sort that, then iterate over Ranges.txt, find all of the matches in the sorted numbers, and write the results out for that range.</p>
<p>This is a bit more complicated, because it you have to bisect_left and bisect_right and iterate everything in between. But that's the only way in which it's any harder. (And here, a third-party class will help even more. For example, with a <code>bintrees.FastRBTree</code> as your sorted collection, it's just <code>sorted_number_tree[low:high]</code>.)</p>
<hr/>
<p>If the ranges can overlap, you need to be a bit smarter—you have to find the closest range without going over the start, and the closest range without going under the end, and check everything in between. But the main trick there is the exact same one used for the last version. The only other trick is to keep two copies of ranges, one sorted by the start value and one by the end, and you'll need to have one of them be a map to indices in the other instead of just a plain list.</p>
</div>
<div class="post-text" itemprop="text">
<p>The naive approach would be to read Numbers.txt into some structure in number order, then read each line of Ranges, us a binary search to find the lowest number in the range, and the read through the numbers higher than that to find all those within the range, so that you can produce the corresponding line of output.</p>
<p>I assume the problem is that you can't have all of Numbers in memory.</p>
<p>So you could do the problem in phases, where each phase reads a portion of Numbers in, then goes through the process outlined above, but using an annotated version of Ranges, where each line includes the COUNT of the values so far that has produced that mean, and will write a similarly annotated version.</p>
<p>Obviously, the initial pass will not have an annotated version of Ranges, and the final pass will not produce one.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like your data in both the files are already sorted.  If not, first sort them by an external tool or using Python.</p>
<p>Then, you can go through the two files in parallel.  You read a number from the <code>Numbers.txt</code> file, and see if it is in a range in <code>Ranges.txt</code> file, reading as many lines from that file as needed to answer that question.  Then read the next number from <code>Numbers.txt</code>, and repeat.  The idea is similar to merging two sorted arrays, and should run in <code>O(n+m)</code> time, <code>n</code> and <code>m</code> are the sizes of the files.  If you need to sort the files, the run time is <code>O(n lg(n) + m lg(m))</code>.  Here is a quick program I wrote to implement this:</p>
<pre><code>import sys
from collections import Counter

class Gen(object):
    __slots__ = ('rfp', 'nfp', 'mn', 'mx', 'num', 'd', 'n')
    def __init__(self, ranges_filename, numbers_filename):
        self.d = Counter() # sum of elements keyed by range
        self.n = Counter() # number of elements keyed by range 

        self.rfp = open(ranges_filename)
        self.nfp = open(numbers_filename)
        # Read the first number and the first range values
        self.num = float(self.nfp.next()) # Current number
        self.mn, self.mx = [int(x) for x in self.rfp.next().split()] # Current range

    def go(self):
        while True:
            if self.mx &lt; self.num:
                try:
                    self.mn, self.mx = [int(x) for x in self.rfp.next().split()]
                except StopIteration:
                    break
            else:   
                if self.mn &lt;= self.num &lt;= self.mx:
                    self.d[(self.mn, self.mx)] += self.num
                    self.n[(self.mn, self.mx)] += 1
                try:
                    self.num = float(self.nfp.next())
                except StopIteration:
                    break
        self.nfp.close()
        self.rfp.close()
        return self.d, self.n

def run(ranges_filename, numbers_filename):
    r = Gen(ranges_filename, numbers_filename)
    d, n = r.go()
    for mn, mx in sorted(d):
        s, N = d[(mn, mx)], n[(mn, mx)]
        if s:
            av = s/N
        else:
            av = 0
        sys.stdout.write('%d %d %.3f\n' % (mn, mx, av))
</code></pre>
<p>On files with 10,000,000 numbers in each of the files, the above runs in about 1.5 minute on my computer without the output part.</p>
</div>
<span class="comment-copy">What have you tried?  I would think you should open the files, convert them into lists, parse them, then output to output.txt.</span>
<span class="comment-copy">I have tried doing that, however that is slow since there are millions of such lines in each of the two files. I also tried using "continue" when a number is found to fall within a given range so that other numbers are skipped and the process becomes faster, however that is still very slow.</span>
<span class="comment-copy">Are both files sorted? Can the ranges overlap?  If they can, then what is the desired result?  Merge ranges first?  Assign the number to all the ranges that it occurs in?</span>
<span class="comment-copy">The ranges never overlap. Even if the other file is read line by line, it will still be very slow, since for any given range, you would be checking every line from the other file.</span>
<span class="comment-copy">In your examples, both input files are sorted.  Is that generally true?  If not, make it true ;-)  That is, sort both files first.  Then you can read both simultaneously, line by line, and do the whole job in one pass.</span>
<span class="comment-copy">For the binary search, check <a href="http://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">bisect</a>.</span>
<span class="comment-copy">Not sure why I made a class for this but hopefully you get the idea :-).</span>
