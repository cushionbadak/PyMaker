<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/8220801/how-to-use-timeit-module">How to use timeit module</a>
<span class="question-originals-answer-count">
                    14 answers
                </span>
</li>
</ul>
</div>
<p>I'd like to measure the time of running for two codes, I tried looking up the python documentation for timeit, but I didn't really understand. 
Could someone explain in a more beginner-level vocabulary? </p>
</div>
<div class="post-text" itemprop="text">
<p><em>Note:</em> Copied to <a href="https://stackoverflow.com/questions/8220801/how-to-use-timeit-module/">How to use timeit module</a>.</p>
<p>I'll let you in on a secret: the best way to use <code>timeit</code> is on the command line.</p>
<p>On the command line, <code>timeit</code> does proper statistical analysis: it tells you how long the shortest run took. This is good because <em>all</em> error in timing is positive. So the shortest time has the least error in it. There's no way to get negative error because a computer can't ever compute faster than it can compute!</p>
<p>So, the command-line interface:</p>
<pre><code>%~&gt; python -m timeit "1 + 2"
10000000 loops, best of 3: 0.0468 usec per loop
</code></pre>
<p>That's quite simple, eh?</p>
<p>You can set stuff up:</p>
<pre><code>%~&gt; python -m timeit -s "x = range(10000)" "sum(x)"
1000 loops, best of 3: 543 usec per loop
</code></pre>
<p>which is useful, too!</p>
<p>If you want multiple lines, you can either use the shell's automatic continuation or use separate arguments:</p>
<pre><code>%~&gt; python -m timeit -s "x = range(10000)" -s "y = range(100)" "sum(x)" "min(y)"
1000 loops, best of 3: 554 usec per loop
</code></pre>
<p>That gives a setup of</p>
<pre><code>x = range(1000)
y = range(100)
</code></pre>
<p>and times</p>
<pre><code>sum(x)
min(y)
</code></pre>
<hr/>
<p>If you want to have longer scripts you might be tempted to move to <code>timeit</code> inside a Python script. I suggest avoiding that because the analysis and timing is simply better on the command line. Instead, I tend to make shell scripts:</p>
<pre><code> SETUP="

 ... # lots of stuff

 "

 echo Minmod arr1
 python -m timeit -s "$SETUP" "Minmod(arr1)"

 echo pure_minmod arr1
 python -m timeit -s "$SETUP" "pure_minmod(arr1)"

 echo better_minmod arr1
 python -m timeit -s "$SETUP" "better_minmod(arr1)"

 ... etc
</code></pre>
<p>This can take a bit longer due to the multiple initialisations, but normally that's not a big deal.</p>
<hr/>
<p>But what if you <em>want</em> to use <code>timeit</code> inside your module?</p>
<p>Well, the simple way is to do:</p>
<pre><code>def function(...):
    ...

timeit.Timer(function).timeit(number=NUMBER)
</code></pre>
<p>and that gives you cumulative (<em>not</em> minimum!) time to run that number of times.</p>
<p>To get a good analysis, use <code>.repeat</code> and take this min:</p>
<pre><code>min(timeit.Timer(function).repeat(repeat=REPEATS, number=NUMBER))
</code></pre>
<p>You should normally combine this with <code>functools.partial</code> instead of <code>lambda: ...</code> to lower overhead. Thus you could have something like:</p>
<pre><code>from functools import partial

def to_time(items):
    ...

test_items = [1, 2, 3] * 100
times = timeit.Timer(partial(to_time, test_items)).repeat(3, 1000)

# Divide by the number of repeats
time_taken = min(times) / 1000
</code></pre>
<hr/>
<p>You can also do:</p>
<pre><code>timeit.timeit("...", setup="from __main__ import ...", number=NUMBER)
</code></pre>
<p>which would give you something closer to the <em>interface</em> from the command-line, but in a much less cool manner. The <code>"from __main__ import ..."</code> lets you use code from your main module inside the artificial environment created by <code>timeit</code>.</p>
<p>It's worth noting that this is a convenience wrapper for <code>Timer(...).timeit(...)</code> and so isn't particularly good at timing. I personally far prefer using <code>Timer</code> as I've shown above.</p>
<hr/>
<h3>Warnings</h3>
<p>There are a few caveats with <code>timeit</code> that hold everywhere.</p>
<ul>
<li><p>Overhead is not accounted for. Say you want to time <code>x += 1</code>, to find out how long addition takes:</p>
<pre><code>&gt;&gt;&gt; python -m timeit -s "x = 0" "x += 1"
10000000 loops, best of 3: 0.0476 usec per loop
</code></pre>
<p>Well, it's <em>not</em> 0.0476 Âµs. You only know that it's <em>less</em> than that. All error is positive.</p>
<p>So try and find <em>pure</em> overhead:</p>
<pre><code>&gt;&gt;&gt; python -m timeit -s "x = 0" ""      
100000000 loops, best of 3: 0.014 usec per loop
</code></pre>
<p>That's a good <strong>30%</strong> overhead just from timing! This can massively skew relative timings. But you only really cared about the <em>adding</em> timings; the look-up timings for <code>x</code> also need to be included in overhead:</p>
<pre><code>&gt;&gt;&gt; python -m timeit -s "x = 0" "x"
100000000 loops, best of 3: 0.0166 usec per loop
</code></pre>
<p>The difference isn't much larger, but it's there.</p></li>
<li><p>Mutating methods are dangerous.</p>
<pre><code>python -m timeit -s "x = [0]*100000" "while x: x.pop()"
10000000 loops, best of 3: 0.0436 usec per loop
</code></pre>
<p>But that's <em>completely wrong!</em> <code>x</code> is the empty list after the first iteration. You'll need to reinitialize:</p>
<pre><code>&gt;&gt;&gt; python -m timeit "x = [0]*100000" "while x: x.pop()"
100 loops, best of 3: 9.79 msec per loop
</code></pre>
<p>But then you have lots of overhead. Account for that separately.</p>
<pre><code>&gt;&gt;&gt; python -m timeit "x = [0]*100000"                   
1000 loops, best of 3: 261 usec per loop
</code></pre>
<p>Note that subtracting the overhead is reasonable here <em>only because</em> the overhead is much a small-ish fraction of the time.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I find IPython's %timeit and %%timeit magic functions to be easier to use than timeit.timeit (particularly when using the ipython notebook). A couple of examples <a href="http://ipython.org/ipython-doc/stable/interactive/tutorial.html" rel="nofollow">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; "-".join(str(n) for n in range(100))
'0-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-22-23-24-25-26-27-28-29-30-31-32-33-34-35-36-37-38-39-40-41-42-43-44-45-46-47-48-49-50-51-52-53-54-55-56-57-58-59-60-61-62-63-64-65-66-67-68-69-70-71-72-73-74-75-76-77-78-79-80-81-82-83-84-85-86-87-88-89-90-91-92-93-94-95-96-97-98-99'
&gt;&gt;&gt; 
</code></pre>
<p>Suppose that's the command you'd like to run.<br/>
Import <code>timeit</code>. Make the command a string, add how many times you'd like to run it.  </p>
<pre><code>&gt;&gt;&gt; timeit.timeit('"-".join(str(n) for n in range(100))', number=100)
0.011214537887298093
</code></pre>
<p><a href="http://docs.python.org/2/library/timeit.html" rel="nofollow">Documentation</a><br/>
Is this doc really incomprehensible? I find it lucid clear.</p>
</div>
<span class="comment-copy">See also: <a href="http://docs.python.org/3/library/profile.html" rel="nofollow noreferrer">cProfile</a></span>
<span class="comment-copy">what i mean is: I don't understand how to use it for my own type of funtion code</span>
