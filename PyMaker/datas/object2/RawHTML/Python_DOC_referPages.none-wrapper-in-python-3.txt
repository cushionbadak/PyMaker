<div class="post-text" itemprop="text">
<p>I need to create a wrapper for each type, like int, float, list, etc. The reason I need to do this is that a have to add an additional property to them. With normal data types it is quite easy, I just subclass them and add the property:</p>
<pre><code>class IntWrapper(int):        
    def __init__(self, value):
        super().__init__()  
</code></pre>
<p>And then:</p>
<pre><code>my_int = IntWrapper(1)
setattr(my_int, 'my_prop', 'foo')
my_int.my_prop  #  prints 'foo'
my_int  #  prints 1
my_int + 1  #  prints 2
</code></pre>
<p>So far, so good... now, I know there are good reasons for the NoneType not being allowed to be subclassed. I have read <a href="https://stackoverflow.com/q/17424516/3154357">How to inherit from Python None</a> and I see that most people don't see the point. Still, I need to somehow "fake" an object that behaves exactly in the same way like the IntWrapper from above. I don't require it to return 'NoneType' when typing <code>type(NoneWrapper)</code>, so it does not have to be a perfect clone. But I want it to return a real <code>None</code> (literally nothing) when just typing the object name:</p>
<pre><code>my_none = NoneWrapper(None)
my_none  #  prints empty line
</code></pre>
<p>From the above mentioned post I've seen that people might suggest a custom exception but that is not a solution for me in this case. Is there a way to build a NoneWrapper that behaves exactly like the IntWrapper with respect to its own type?</p>
<p><strong>EDIT:</strong>
Since it seems to be of high interest WHY this is needed, I will give the full context:
I am building a configuration parser which basically makes the content of a JSON configuration file available as object chain (similar to Javascript objects with dot separator). This config object behaves very similar to a dictionary but has some additional advantages like backlinks. I can look at any configuration option and trace back the path to the root node it is attached to. </p>
<p>So, when parsing the dictionary (which stems from the JSON file) recursively, it builds the object chain. Once it detects a type or constant at a leaf position of that dictionary, it adds this wrapper as a last element in the chain. The backlink property is needed on all wrappers, also None.</p>
</div>
<div class="post-text" itemprop="text">
<p>All the functions/methods in python returns None if 'return' isn't declared or just returning that object directly.
If you want to not see any value as a return you haven't to use print for display. </p>
</div>
<span class="comment-copy">This object is not going to behave like <code>None</code> in any useful way, beyond perhaps having the same <code>bool</code> output. The primary use of <code>None</code> is for its identity, which your object cannot share.</span>
<span class="comment-copy">What's the reason of creating this type of wrapper?</span>
<span class="comment-copy">Why do you need to annotate <code>None</code> with additional attributes? Can't you use an external structure, that you relate to each object via weak references, perhaps?</span>
<span class="comment-copy">@Steve: nope, they'd have to subclass <code>type(None)</code>, which also resists subclassing. They'd have the same problem with <code>bool</code>. Both types explicitly forbid subclassing because there should only ever be the 3 instances <code>False</code>, <code>True</code> and <code>None</code>, and subclassing would allow you to bypass that restriction.</span>
<span class="comment-copy">@loxosceles: Ok, that requirement cannot be met, period. The <code>if a is None</code> test does what <code>is</code> is for: test for identity. And there is only one <code>None</code>.</span>
