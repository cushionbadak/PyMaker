<div class="post-text" itemprop="text">
<p>I have a relatively large dictionary. How do I know the size? well when I save it using <code>cPickle</code> the size of the file will grow approx. 400Mb. <code>cPickle</code>  is supposed to be much faster than <code>pickle</code> but loading and saving this file just takes a lot of time. I have a Dual Core laptop 2.6 Ghz with 4GB RAM on a Linux machine. Does anyone have any suggestions for a faster saving and loading of dictionaries in python? thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/library/pickle.html#data-stream-format">  protocol=2 option</a> of cPickle. The default protocol (0) is much slower, and produces much larger files on disk.</p>
<p>If you just want to work with a larger dictionary than memory can hold, the <a href="http://docs.python.org/library/shelve.html">shelve</a> module is a good quick-and-dirty solution. It acts like an in-memory dict, but stores itself on disk rather than in memory. shelve is based on cPickle, so be sure to set your protocol to anything other than 0.</p>
<p>The advantages of a database like <a href="http://docs.python.org/library/sqlite3.html">sqlite</a> over cPickle will depend on your use case. How often will you write data? How many times do you expect to read each datum that you write? Will you ever want to perform a search of the data you write, or load it one piece at a time?</p>
<p>If you're doing write-once, read-many, and loading one piece at a time, by all means use a database. If you're doing write once, read once, cPickle (with any protocol other than the default protocol=0) will be hard to beat. If you just want a large, persistent dict, use shelve.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Sqlite</h2>
<p>It might be worthwhile to store the data in a <a href="http://www.sqlite.org/" rel="nofollow">Sqlite</a> database.  Although there will be some development overhead when refactoring your program to work with Sqlite, it also becomes much easier and performant to query the database.  </p>
<p>You also get transactions, atomicity, serialization, compression, etc. for free.  </p>
<p>Depending on what version of Python you're using, you might already have sqlite built-in.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may test to  compress your dictionnary (with some restrictions see : <a href="https://stackoverflow.com/questions/3006727/load-a-pickle-file-from-a-zipfile">this post</a>) it will be efficient if the disk access is the bottleneck.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know it's an old question but just as an update for those who still looking for an answer to this question: 
The <code>protocol</code> argument has been updated in python 3 and now there are even faster and more efficient options (i.e. <code>protocol=3</code> and <code>protocol=4</code>) which might not work under python 2. 
You can read about it more in the <a href="https://docs.python.org/3/library/pickle.html#data-stream-format" rel="nofollow noreferrer">reference</a>.</p>
<p>In order to always use the best protocol supported by the python version you're using, you can simply use <code>pickle.HIGHEST_PROTOCOL</code>. The following example is taken from the <a href="https://docs.python.org/3/library/pickle.html#examples" rel="nofollow noreferrer">reference</a>:</p>
<pre><code>import pickle
# ...
with open('data.pickle', 'wb') as f:
    # Pickle the 'data' dictionary using the highest protocol available.
    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That is a lot of data...
What kind of contents has your dictionary? If it is only primitive or fixed datatypes, maybe a real database or a custom file-format is the better option?</p>
</div>
<span class="comment-copy">What are the keys and values in your dictionary?  Aribitrary Python data types?</span>
<span class="comment-copy">would it be possible to use sqlite instead, so that you don't have to load the entire thing in memory?</span>
<span class="comment-copy">Set the   protocol argument of cPickle to 2</span>
<span class="comment-copy">@Sven: the keys are tuples with varying number of members from 2 to 5. and the members are string that are encoded in utf-8</span>
<span class="comment-copy">I have the same problem. My dictionary is greater than 16GB. Why is shelve a "dirty" solution?</span>
