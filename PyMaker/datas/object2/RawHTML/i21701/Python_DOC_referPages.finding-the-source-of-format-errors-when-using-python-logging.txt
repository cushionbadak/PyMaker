<div class="post-text" itemprop="text">
<p>When I have lots of different modules using the standard python logging module, the following stack trace does little to help me find out where, exactly, I had a badly formed log statement:</p>
<pre><code>Traceback (most recent call last):
  File "/usr/lib/python2.6/logging/__init__.py", line 768, in emit
    msg = self.format(record)
  File "/usr/lib/python2.6/logging/__init__.py", line 648, in format
    return fmt.format(record)
  File "/usr/lib/python2.6/logging/__init__.py", line 436, in format
    record.message = record.getMessage()
  File "/usr/lib/python2.6/logging/__init__.py", line 306, in getMessage
    msg = msg % self.args
TypeError: not all arguments converted during string formatting
</code></pre>
<p>I'm only starting to use python's logging module, so maybe I am overlooking something obvious. I'm not sure if the stack-trace is useless because I am using greenlets, or if this is normal for the logging module, but any help would be appreciated. I'd be willing to modify the source, anything to make the logging library actually give a clue as to where the problem lies.</p>
</div>
<div class="post-text" itemprop="text">
<p>The logging module is designed to stop bad log messages from killing the rest of the code, so the <code>emit</code> method catches errors and passes them to a method <code>handleError</code>. The easiest thing for you to do would be to temporarily edit <code>/usr/lib/python2.6/logging/__init__.py</code>, and find <code>handleError</code>. It looks something like this:</p>
<pre><code>def handleError(self, record):
    """
    Handle errors which occur during an emit() call.

    This method should be called from handlers when an exception is
    encountered during an emit() call. If raiseExceptions is false,
    exceptions get silently ignored. This is what is mostly wanted
    for a logging system - most users will not care about errors in
    the logging system, they are more interested in application errors.
    You could, however, replace this with a custom handler if you wish.
    The record which was being processed is passed in to this method.
    """
    if raiseExceptions:
        ei = sys.exc_info()
        try:
            traceback.print_exception(ei[0], ei[1], ei[2],
                                      None, sys.stderr)
            sys.stderr.write('Logged from file %s, line %s\n' % (
                             record.filename, record.lineno))
        except IOError:
            pass    # see issue 5971
        finally:
            del ei
</code></pre>
<p>Now temporarily edit it. Inserting a simple <code>raise</code> at the start should ensure the error gets propogated up your code instead of being swallowed. Once you've fixed the problem just restore the logging code to what it was.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than editing installed python code, you can also find the errors like this:</p>
<pre><code>    def handleError(record):
        raise RuntimeError(record)
    handler.handleError = handleError
</code></pre>
<p>where handler is one of the handlers that is giving the problem. Now when the format error occurs you'll see the location.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not really an answer to the question, but hopefully it will be other beginners with the logging module like me.</p>
<p>My problem was that I replaced all occurrences of print with logging.info , 
so a valid line like <code>print('a',a)</code> became <code>logging.info('a',a)</code> (but it should be <code>logging.info('a %s'%a)</code> instead. </p>
<p>This was also hinted in <a href="https://stackoverflow.com/questions/13459085/how-to-traceback-logging-errors">How to traceback logging errors?</a> , but it doesn't come up in the research</p>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively you can create a formatter of your own, but then you have to include it everywhere.</p>
<pre><code>class DebugFormatter(logging.Formatter):
    def format(self, record):
        try:
            return super(DebugFormatter, self).format(record)
        except:
            print "Unable to format record"
            print "record.filename ", record.filename
            print "record.lineno ", record.lineno
            print "record.msg ", record.msg
            print "record.args: ",record.args
            raise


FORMAT = '%(levelname)s %(filename)s:%(lineno)d  %(message)s'
formatter = DebugFormatter(FORMAT)
handler = logging.StreamHandler()
handler.setLevel(logging.DEBUG)
handler.setFormatter(formatter)
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(handler)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Had same problem</strong>
Such a Traceback arises due to the wrong format name. So while creating a format for a log file, check the format name once in python documentation: "<a href="https://docs.python.org/3/library/logging.html#formatter-objects" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html#formatter-objects</a>"</p>
</div>
<span class="comment-copy">Well, it's a horrible way to do it. Nevertheless, it's an approach worth remembering for those cases where editing the library is completely impossible, so +1.</span>
<span class="comment-copy">@porgarmingduod: Monkey-patching may not be great, but it is no way more horrible than manipulating the source of the standard library. Monkey-patching will affect everything else in the same process, but the direct editing of the library will affect everything else on the same system.</span>
<span class="comment-copy">new syntax in python 3.6:  <code>logging.info(f'a {a}')</code></span>
<span class="comment-copy">thanks, I hadn't looked into it! <a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow noreferrer">python.org/dev/peps/pep-0498</a></span>
