<div class="post-text" itemprop="text">
<p>If you follow the simple <code>configure</code> -&gt; <code>make</code> -&gt; <code>make install</code> process for compiling python from source code, you end up with a very large install that includes a whole lot of files that are not necessary for a functional python environment.  eg: All <code>.py</code> files are left in the installation (not just the <code>.pyc</code> or <code>.pyo</code> files), all the unit tests are carried over for each library in the lib folders, man pages are included, etc.</p>
<p>Is there a canned way (make option?) to ignore or strip out the 'unnecessary' files during the install process so you are left with a minimalist, but fully functional, python distribution?</p>
<p>If no pre-made procedure, what files can be stripped out, while being certain that the installation will still work on the machine it was installed?</p>
</div>
<div class="post-text" itemprop="text">
<p>It may be instructive to look at Debian's <code>python2.7-minimal</code> package (<code>apt-get source python2.7-minimal</code>).  When in doubt, always look to see what others, especially the experts, are doing...</p>
<p>From <code>debian/rules</code> there:</p>
<pre><code>: # Move the binary and the minimal libraries into $(p_min).
dh_installdirs -p$(p_min) \
        etc/$(PVER) \
        usr/bin \
        usr/include/$(PVER) \
        usr/share/man/man1 \
        $(scriptdir)/lib-dynload \
        $(scriptdir)/config
DH_COMPAT=2 dh_movefiles -p$(p_min) --sourcedir=$(d) \
        usr/bin/python$(VER) \
        usr/share/man/man1/python$(VER).1 \
        $(foreach i,$(MIN_MODS),$(scriptdir)/$(i).py) \
        $(foreach i,$(MIN_PACKAGES),$(scriptdir)/$(i)) \
        $(foreach i,$(MIN_ENCODINGS),$(scriptdir)/$(i)) \
        $(scriptdir)/config/Makefile \
        usr/include/$(PVER)/pyconfig.h \
        $(scriptdir)/site.py
</code></pre>
<p>The <code>MIN_*</code> variables are parsed out from <code>README.Debian.in</code>, which of course doubles as the package <code>README</code> but also thus becomes the authority on which modules to include.</p>
<p>Interesting stuff, I'd never looked at this before now.  As for your question, the answer does seem that no, there isn't really a minimal target included in Python, but perhaps you could take the same approach Debian does to achieve your aims.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no such option - and it is a good thing keeping the installation as it is (perhaps you can chop of the test files manually). The .py files are handy for debugging. Apart from that: you really want to keep the full installation as it is. Dealing with stripped down Python installations as we see it on various Linux distributions is often a pain in the <em>*</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Such options (if they exist in the software itself) are usually found in the <code>configure</code> script. Check <code>configure -h</code>.</p>
<p>Alternatively, you could try removing <code>.py</code> files if an identically named <code>.pyc</code> file exists. You can also remove the <code>.pyo</code> files. Removing <code>.py</code> and <code>.pyo</code> files would save 72396 kB under <code>/usr/local/lib/python2.7</code> (that's around 47%) on my Python 2.7.3 installation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Note Python has built‑in modules, the Python executable, standalone, will work fine. You may remove any unneeded modules, it's just up to you (or someone else) to determine which ones won't be required. Be aware of each module dependencies though.</p>
<p>Some modules are built‑in and so always there. To get the list of built‑in modules, dump the content of <a href="https://docs.python.org/3/library/sys.html#sys.builtin_module_names" rel="nofollow">sys.builtin_module_names</a>.</p>
<p>Ex, with a standalone Python 3.4.1 executable, compiled on an Ubuntu platform:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; for m in sys.builtin_module_names: print(m)
</code></pre>
<p>This tells:</p>
<ul>
<li><code>_ast</code></li>
<li><code>_codecs</code></li>
<li><code>_collections</code></li>
<li><code>_functools</code></li>
<li><code>_imp</code></li>
<li><code>_io</code></li>
<li><code>_locale</code></li>
<li><code>_operator</code></li>
<li><code>_sre</code></li>
<li><code>_stat</code></li>
<li><code>_string</code></li>
<li><code>_symtable</code></li>
<li><code>_thread</code></li>
<li><code>_tracemalloc</code></li>
<li><code>_warnings</code></li>
<li><code>_weakref</code></li>
<li><code>atexit</code></li>
<li><code>builtins</code></li>
<li><code>errno</code></li>
<li><code>faulthandler</code></li>
<li><code>gc</code></li>
<li><code>itertools</code></li>
<li><code>marshal</code></li>
<li><code>posix</code></li>
<li><code>pwd</code></li>
<li><code>signal</code></li>
<li><code>sys</code></li>
<li><code>xxsubtype</code></li>
<li><code>zipimport</code></li>
</ul>
<p>There are private modules, while still 13 public modules. All is built in the Python executable, standalone.</p>
<p>As already mentioned, you can remove any <code>*.pyc</code> and <code>*.pyo</code> files, as for a module to work, all is required, is the <code>*.py</code> files.</p>
</div>
<span class="comment-copy">I don't think so. The only one I know is <code>make altinstall</code> that omits the symlink to the base name <code>python</code>.</span>
<span class="comment-copy">I've been rooting through the Makefile and trying all the options (like <code>altinstall</code>, <code>libinstall</code>, etc) and can't figure out the right combination... if it exists!  <code>clean</code> and <code>distclean</code> have some of the right logic (rm'ing <code>.py</code> files, for example), but not seemingly applicable to the installation dir.  Strangely, I can't find any docs on <code>altinstall</code> and the like anywhere at all (there are a zillion in there).</span>
<span class="comment-copy">Thanks - I did not know about the <code>-minimal</code> packages in debian.  I'll have to dig into that since, at the moment, I haven't a clue how to parse that!  I've looked into <a href="http://www.tinypy.org" rel="nofollow noreferrer">tinypy</a> and <a href="http://www.portablepython.com/" rel="nofollow noreferrer">portable python</a>, but their aims are different.</span>
<span class="comment-copy">Thanks, zigg - giving you the bounty for pointing me at the <code>minimal</code> packages.  I never did decipher the <code>debian/rules</code>, but with the awareness of these packages I was able to get some hints from the stripped down file lists which are easily available <a href="http://packages.debian.org/sid/python2.7-minimal" rel="nofollow noreferrer">at this page</a>.  For others landing here, be careful that the intent of the <code>minimal</code> packages is for severely limited boot process scripts, so there are <i>many</i> missing and essential modules (like <code>os</code>!).</span>
<span class="comment-copy">Although I generally agree, there are several cases where drive space is at a minimum and the extra 40 MB or so (I forget exactly how much it is after stripping it out by hand) really needs to be eliminated.  eg: embedded systems, or something like <a href="http://tinycorelinux.com/" rel="nofollow noreferrer">TinyCore Linux</a> (where the whole OS is &lt; 10 MB).  With options like <code>libinstall</code> already buried in the make file, having a combo that strips off unnecessary items seems like it should exist.</span>
<span class="comment-copy">This answer is not true. The <code>encodings</code>, <code>_bootlocale</code> and possibly <code>site</code> modules are needed to start up.</span>
