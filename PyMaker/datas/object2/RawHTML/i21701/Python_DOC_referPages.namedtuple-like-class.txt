<div class="post-text" itemprop="text">
<p>I find myself writing this class often in my python code when I need a quick single use class.</p>
<pre><code>class Struct(object):
   def __init__( self, **kwargs ):
      for k in kwargs:
         setattr(self,k,kwargs[k])
</code></pre>
<p>The basic idea is so I can do quick things like this:</p>
<pre><code>foo = Struct( bar='one', baz=1 )
print foo.bar
foo.baz += 1
foo.novo = 42 # I don't do this as often.
</code></pre>
<p>Of course this doesn't scale well and adding methods is just insane, but even so I have enough data-only throw-away classes that I keep using it.</p>
<p>This is what I thought <a href="http://docs.python.org/library/collections.html#collections.namedtuple" rel="noreferrer">namedtuple</a> was going to be.  But the namedtuple's syntax is large and unwieldy.</p>
<p>Is there something in the standard library I haven't found yet that does this as well or better?</p>
<p>Is this bad bad style? or does it have some hidden flaw?</p>
<h3>update</h3>
<p>Two concrete example to show why I don't just use a dict.  Both of these examples <em>could</em> be done with a dict but it obviously non-idiomatic.</p>
<pre><code>#I know an order preserving dict would be better but they don't exist in 2.6.
closure = Struct(count=0)
def mk_Foo( name, path ):
   closure.count += 1
   return (name, Foo( name, path, closure.count ))

d = dict([
   mk_Foo( 'a', 'abc' ),
   mk_Foo( 'b', 'def' ),
   # 20 or so more
   ] )


@contextmanager
def deleter( path ):
   control = Struct(delete=True,path=path)
   try:      
      yield control
   finally:
      if control.delete:
         shutil.rmtree(path)

with deleter( tempfile.mkdtemp() ) as tmp:
   # do stuff with tmp.path

   # most contexts don't modify the delete member
   # but occasionally it's needed
   if keep_tmp_dir:
      tmp.delete = False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a python recipe for this (It just updates the instance's dict instead of calling setattr)
<a href="http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/?in=user-97991">Recipe 52308</a></p>
<pre><code>class Bunch(object):
    def __init__(self, **kwds):
        self.__dict__.update(kwds)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From Python 3.3 and afterwards, you can use <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">types.SimpleNamespace</a>:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; foo = types.SimpleNamespace(bar='one', baz=1)
&gt;&gt;&gt; print(foo.bar)
one
&gt;&gt;&gt; foo.baz += 1
&gt;&gt;&gt; foo.novo = 42
</code></pre>
<p>The builtin type is roughly equivalent to the following code:</p>
<pre><code>class SimpleNamespace:

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def __repr__(self):
        keys = sorted(self.__dict__)
        items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
        return "{}({})".format(type(self).__name__, ", ".join(items))

    def __eq__(self, other):
        return self.__dict__ == other.__dict__
</code></pre>
<p><strong>update</strong></p>
<p>Starting with Python 3.7, you can use the <em>dataclass</em> module:</p>
<pre><code>from dataclasses import dataclass, field

@dataclass
class Struct:
    bar: str = field(default='one')
    baz: int = field(default=1)
</code></pre>
<p>You can use this as follows:</p>
<pre><code>foo = Struct( bar='one', baz=1 )
print(foo.bar)
foo.baz += 1
foo.novo = 42
</code></pre>
<p>By default, it incorporates equality testing and a nice looking repr:</p>
<pre><code>&gt;&gt;&gt; foo == Struct(bar='one', baz=2)
True
&gt;&gt;&gt; foo
Struct(bar='one', baz=2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class t(dict):

   def __init__(self, **kwargs):
      for key, value in kwargs.items():
         dict.__setitem__(self, key, value)
   def __getattr__(self, key):
      return dict.__getitem__(self, key)
   def __setattr__(self, key, value):
      raise StandardError("Cannot set attributes of tuple")      
   def __setitem__(self, key, value):
      raise StandardError("Cannot set attributes of tuple")      
   def __delitem__(self, key):
      raise StandardError("Cannot delete attributes of tuple")

point = t(x=10, y=500, z=-50)
print point.x        # 10
print point.y        # 500
print point['z']     # -50
print point          # {'z': -50, 'y': 500, 'x': 10}
point.x = 100        # StandardError: cannot set attributes of tuple
point.y += 5         # StandardError: cannot set attributes of tuple
point.z = -1         # StandardError: cannot set attributes of tuple

def hypo(x, y, z):
   return (x**2 + y**2 + z**2)**0.5

print hypo(point)    # TypeError: unsupported operand type(s)
print hypo(**point)  # 502.593274925   

for k in point.items():
   print k           # ('y', 500)
                     # ('x', 10)
                     # ('z', -50)

for k in point.keys():
   print k           # x
                     # y
                     # z

for k in point.values():
   print k           # 500
                     # 10
                     # -50

print len(point)     # 3

print dict(point)    # {'y': 500, 'x': 10, 'z': -50}
</code></pre>
<p>This is my solution to this problem. Beautiful syntax, immutable (at least without resorting to some nasty object.<strong>setattr</strong>() gymnastics), lightweight and pretty-printable. Although there is nothing you can do with this that you cannot do with a dict, </p>
<pre><code>point = t(x=10, y=20, z=30)
d = point.x ** 2 + point.y ** 2 + point.z ** 2
</code></pre>
<p>has a really nice symmetry with</p>
<pre><code>point = (10, 20, 30)
d = point[0] ** 2 + point[1] ** 2 + point[2] ** 2
</code></pre>
<p>and overall is just so much cleaner than</p>
<pre><code>point = {'x': 10, 'y': 20, 'z': 30}
d = point['x'] ** 2 + point['y'] ** 2 + point['z'] ** 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you have is a perfectly reasonable prototype, but you're right that it doesn't scale.</p>
<p>If you like using them, but want to have a path to better code later, here's what I'd suggest:</p>
<ul>
<li><p>every time you do that, subclass Structure:</p>
<p><code>class Control(Structure): pass</code></p></li>
<li><p>later, when you want a "real" class, replace the superclass with something like <a href="https://secure.sabren.com/trac/workshop/browser/trunk/code/strongbox.py" rel="nofollow">strongbox.Strongbox</a> (<a href="https://secure.sabren.com/trac/workshop/browser/trunk/specs/strongbox.spy" rel="nofollow">example usage</a>) that provides that same constructor and attribute interface, but constrains which slots you can fill in.</p></li>
</ul>
<p>A discipline like this only costs you one extra line up front, and won't break your code if you want more power later.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may want to look at <a href="http://code.activestate.com/recipes/576555-records/" rel="nofollow">Records</a> by <a href="http://code.activestate.com/recipes/users/2591466/" rel="nofollow">George Sakkis</a>.  It has worked well for me as a "mutable named tuple."</p>
</div>
<span class="comment-copy">What's wrong with just using a dict? x = {'baz':1} x['baz'] += 1</span>
<span class="comment-copy"><code>namedtuple</code> is a <code>tuple</code> so you can't change its contents.</span>
<span class="comment-copy">@JochenRitzel, you can call <code>_replace</code> . for example: <code>p = Point(x=11, y=22)</code> ... <code>p._replace(x=33)</code> ... <code>Point(x=33, y=22)</code></span>
<span class="comment-copy">Check out this <a href="http://stackoverflow.com/a/11578092/355230">answer</a> to a similar question.</span>
<span class="comment-copy">Worth checking out: <a href="https://pypi.python.org/pypi/recordtype/" rel="nofollow noreferrer">pypi.python.org/pypi/recordtype</a></span>
<span class="comment-copy">One limit with this is it doesn't work when <code>__slots__</code> are used.</span>
<span class="comment-copy">Whoa!  Using <code>exec</code> seems a bit extreme compared to the simple Bunch recipe.</span>
