<div class="post-text" itemprop="text">
<p>I want to mock out methods on any instance of some class in the production code in order to facilitate testing. Is there any library in Python which could facilitate this?</p>
<p>Basically, I want to do the following, but in Python (the following code is Ruby, using the Mocha library):</p>
<pre><code>  def test_stubbing_an_instance_method_on_all_instances_of_a_class
    Product.any_instance.stubs(:name).returns('stubbed_name')
    assert_equal 'stubbed_name', SomeClassThatUsesProduct.get_new_product_name
  end
</code></pre>
<p>The important thing to note from above is that I need to mock it out on the class level, since I'm actually need to mock out methods on an instance created by the thing I'm testing.</p>
<p>Use Case:</p>
<p>I have a class <code>QueryMaker</code> which calls a method on an instance of <code>RemoteAPI</code>. I want to mock out the <code>RemoteAPI.get_data_from_remote_server</code> method to return some constant. How do I do this inside a test without having to put a special case within the <code>RemoteAPI</code> code to check for what environment it's running in.</p>
<p>Example of what I wanted in action:</p>
<pre><code># a.py
class A(object):
    def foo(self):
        return "A's foo"

# b.py
from a import A

class B(object):
    def bar(self):
        x = A()
        return x.foo()

# test.py
from a import A
from b import B

def new_foo(self):
    return "New foo"

A.foo = new_foo

y = B()
if y.bar() == "New foo":
    print "Success!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Easiest way is probably to use a class method. You really should use an instance method, but it's a pain to create those, whereas there's a built-in function that creates a class method. With a class method, your stub will get a reference to the class (rather than the instance) as the first argument, but since it's a stub this probably doesn't matter. So:</p>
<pre><code>Product.name = classmethod(lambda cls: "stubbed_name")
</code></pre>
<p>Note that the signature of the lambda must match the signature of the method you're replacing. Also, of course, since Python (like Ruby) is a dynamic language, there is no guarantee that someone won't switch out your stubbed method for something else before you get your hands on the instance, though I expect you will know pretty quickly if that happens.</p>
<p>Edit: On further investigation, you can leave out the <code>classmethod()</code>:</p>
<pre><code>Product.name = lambda self: "stubbed_name"
</code></pre>
<p>I was trying to preserve the original method's behavior as closely as possible, but it looks like it's not actually necessary (and doesn't preserve the behavior as I'd hoped, anyhow).</p>
</div>
<div class="post-text" itemprop="text">
<p>Needing to mock out methods when testing is very common and there are lots of tools to help you with it in Python. The danger with "monkey patching" classes like this is that if you don't <em>undo</em> it afterwards then the class has been modified for all other uses throughout your tests.</p>
<p>My library mock, which is one of the most popular Python mocking libraries, includes a helper called "patch" that helps you to safely patch methods or attributes on objects and classes during your tests.</p>
<p>The mock module is available from:</p>
<p><a href="http://pypi.python.org/pypi/mock" rel="noreferrer">http://pypi.python.org/pypi/mock</a></p>
<p>The patch decorator can be used as a context manager or as a test decorator. You can either use it to patch out with functions yourself, or use it to automatically patch with Mock objects that are very configurable.</p>
<pre><code>from a import A
from b import B

from mock import patch

def new_foo(self):
    return "New foo"

with patch.object(A, 'foo', new_foo):
    y = B()
    if y.bar() == "New foo":
        print "Success!"
</code></pre>
<p>This handles the unpatching for you automatically. You could get away without defining the mock function yourself:</p>
<pre><code>from mock import patch

with patch.object(A, 'foo') as mock_foo:
    mock_foo.return_value = "New Foo"

    y = B()
    if y.bar() == "New foo":
        print "Success!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know Ruby quite well enough to tell exactly what you're trying to do, but check out the <a href="http://docs.python.org/reference/datamodel.html#object.__getattr__" rel="nofollow"><code>__getattr__</code></a> method. If you define it in your class, Python will call it when code tries to access any attribute of your class that isn't otherwise defined. Since you want it to be a method, it will need to create a method on the fly that it returns.</p>
<pre><code>&gt;&gt;&gt; class Product:
...     def __init__(self, number):
...         self.number = number
...     def get_number(self):
...         print "My number is %d" % self.number
...     def __getattr__(self, attr_name):   
...         return lambda:"stubbed_"+attr_name
... 
&gt;&gt;&gt; p = Product(172)
&gt;&gt;&gt; p.number
172
&gt;&gt;&gt; p.name()
'stubbed_name'
&gt;&gt;&gt; p.get_number()
My number is 172
&gt;&gt;&gt; p.other_method()
'stubbed_other_method'
</code></pre>
<p>Also note that <code>__getattr__</code> needs to <em>not</em> use any other undefined attributes of your class, or else it will be infinitely recursive, calling <code>__getattr__</code> for the attribute that doesn't exist.</p>
<pre><code>...     def __getattr__(self, attr_name):   
...         return self.x
&gt;&gt;&gt; p.y
Traceback (most recent call last):
#clipped
RuntimeError: maximum recursion depth exceeded while calling a Python object
</code></pre>
<p>If this is something you only want to do from your test code, not the production code, then put your normal class definition in the production code file, then in the test code define the <code>__getattr__</code> method (unbound), and then bind it to the class you want:</p>
<pre><code>#production code
&gt;&gt;&gt; class Product:
...     def __init__(self, number):
...         self.number = number
...     def get_number(self):
...         print "My number is %d" % self.number
...         

#test code
&gt;&gt;&gt; def __getattr__(self, attr):
...     return lambda:"stubbed_"+attr_name
... 
&gt;&gt;&gt; p = Product(172)
&gt;&gt;&gt; p.number
172
&gt;&gt;&gt; p.name()
Traceback (most recent call last):
  File "&lt;interactive input&gt;", line 1, in &lt;module&gt;
AttributeError: Product instance has no attribute 'name'
&gt;&gt;&gt; Product.__getattr__ = __getattr__
&gt;&gt;&gt; p.name()
'stubbed_name'
</code></pre>
<p>I'm not sure how this would react with a class that was already using <code>__getattribute__</code> (as opposed to <code>__getattr__</code>, <code>__getattribute__</code> is called for all attributes whether or not they exist).</p>
<p>If you only want to do this for specific methods that already exist, then you could do something like:</p>
<pre><code>#production code
&gt;&gt;&gt; class Product:
...     def __init__(self, number):
...         self.number = number
...     def get_number(self):
...         return self.number
...     
&gt;&gt;&gt; p = Product(172)
&gt;&gt;&gt; p.get_number()
172

#test code
&gt;&gt;&gt; def get_number(self):
...     return "stub_get_number"
... 
&gt;&gt;&gt; Product.get_number = get_number
&gt;&gt;&gt; p.get_number()
'stub_get_number'
</code></pre>
<p>Or if you really wanted to be elegant, you could create a wrapper function to make doing multiple methods easy:</p>
<pre><code>#test code
&gt;&gt;&gt; import functools
&gt;&gt;&gt; def stubber(fn):
...     return functools.wraps(fn)(lambda self:"stub_"+fn.__name__)
... 
&gt;&gt;&gt; Product.get_number = stubber(Product.get_number)
&gt;&gt;&gt; p.get_number()
'stub_get_number'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Mock is the way to do it, alright.
It can be a bit tricky to make sure you're patching the instance method on any instances created from the class.</p>
<pre><code># a.py
class A(object):
    def foo(self):
        return "A's foo"

# b.py
from a import A

class B(object):
    def bar(self):
        x = A()
        return x.foo()

# test.py
from a import A
from b import B
import mock

mocked_a_class = mock.Mock()
mocked_a_instance = mocked_a_class.return_value
mocked_a_instance.foo.return_value = 'New foo'

with mock.patch('b.A', mocked_a_class):  # Note b.A not a.A
    y = B()
    if y.bar() == "New foo":
        print "Success!"
</code></pre>
<p>Referenced in the <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">docs</a>, at the para starting "To configure return values on methods of instances on the patched class..."</p>
</div>
<span class="comment-copy">I'm not exactly following how this works. Does this satisfy my use case?</span>
<span class="comment-copy">It should; your use case is pretty much the same as your example. Basically, by changing the definition of the method on the class, you are changing its definition on all the instances as well. The <code>classmethod</code> function creates a wrapper that basically turns the function into a method, and the <code>lambda</code> defines the function to simply return a static string.</span>
<span class="comment-copy">... but see my edit.</span>
<span class="comment-copy">Alright - I have to experiment with this, but I'm a little hazy on how exactly things get set up when you import. If I import <code>RemoteAPI</code> and then replace one of the methods, then <code>QueryMaker</code> imports <code>RemoteAPI</code> during it's normal execution, which version of <code>RemoteAPI</code> is <code>QueryMaker</code> using? My version or the original?</span>
<span class="comment-copy">Also note that any instances of <code>Product</code> created before redefining <code>Product.name</code> will also be "updated" as well to have the new method as well, which is probably what you want anyways. In addition, this method won't preserve the original function's name and docstring.</span>
<span class="comment-copy">Ahh - thanks. I looked at <code>mock</code>, but I didn't see any obvious examples where it was used to patch things that are getting imported elsewhere. +1</span>
<span class="comment-copy">Just be careful with direct monkey patching in your tests, it an easily break things. mock.patch can be used for patching things in any namespace - either objects in the current namespace (with <code>patch.object</code>) or in another namespace specified by name: <code>patch('mymodule.myclass')</code>.</span>
<span class="comment-copy">The important thing to know is that if you are patching by name then you patch the name in the module it is <i>used</i>, not in the module it is defined. e.g. if I wanted to patch the use of <code>SomeClass</code> in module <code>foo</code>, even where <code>SomeClass</code> is defined in module <code>bar</code> but is imported into <code>foo</code>, then what you patch is <code>foo.SomeClass</code> and <i>not</i> <code>bar.SomeClass</code>. For patching a class method it doesn't matter so much as the class <i>object</i> will be the same object in both modules. For other things it matters very much.</span>
<span class="comment-copy">Shouldn't the test case be calling Y.foo() == "New foo" ??  This is the example in the mock documentation for patch.object:  @patch.object(SomeClass, 'class_method')</span>
<span class="comment-copy">This is the most confusing code sample I've ever come across.  There is no way that B == A and foo == bar.  Yet the two are used interchangeably in this example.</span>
<span class="comment-copy">The goal of this exercise is to avoid modifying any of the production code just for the sake of being able to test it. I'm pretty sure what you're suggesting doesn't accomplish that.</span>
<span class="comment-copy">If that's what you want to do, I'm pretty sure you can define it as an unbound function in your test code, then bind it to the class from your test code via <code>Product.__getattr__ = fn_name</code></span>
<span class="comment-copy">I understand what <code>__getattr__</code> is used for, and I don't really understand why you think it would be useful. I need to replace a method that's <i>already</i> defined on the class I need to mock the method on.</span>
<span class="comment-copy">@Jamie Check the last two examples in my answer, the edit shows how to replace specific methods. Like I said, I don't really know Ruby, so when you mentioned mocking out methods and creating stubs, I thought you were trying to create test stubs for all your methods to facilitate writing unit tests. I see now that it's a specific method you want to replace, so the last two examples should show how to do that.</span>
