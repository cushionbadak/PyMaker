<div class="post-text" itemprop="text">
<p>I've searched and this seems to be a simple question without a simple answer.</p>
<p>I have the file <code>a/b/c.py</code> which would be called with <code>python -m a.b.c</code>. I would like to obtain the value <code>a.b.c</code> in the module level.</p>
<pre><code>
USAGE = u'''\
Usage:
    python -m %s -h
''' % (what_do_i_put_here,)
</code></pre>
<p>So when I receive the <code>-h</code> option, I display the <code>USAGE</code> without the need to actually write down the actual value in each and every script.</p>
<p>Do I really need to go through <code>inspect</code> to get the desired value?</p>
<p>Thanks.</p>
<p><strong>EDIT:</strong> As said, there are answers (I've searched), but not simple answers. Either use <code>inspect</code>, use of <code>traceback</code>, or manipulate <code>__file__</code> and <code>__package__</code> and do some substring to get the answer. But nothing as simple as if I had a class in the module, I could just use <code>myClass.__module__</code> and I would get the answer I want. The use of <code>__name__</code> is (unfortunately) useless as it's always <code>__main__</code>.</p>
<p>Also, this is in python 2.6 and I cannot use any other versions.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works for me:</p>
<pre><code>__loader__.fullname
</code></pre>
<p>Also if I do python -m b.c from a\ I get 'b.c' as expected.</p>
<p>Not entirely sure what the __loader__ attribute is so let me know if this is no good.</p>
<p><strong>edit</strong>: It comes from PEP 302: <a href="http://www.python.org/dev/peps/pep-0302/">http://www.python.org/dev/peps/pep-0302/</a></p>
<p>Interesting snippets from the link:</p>
<blockquote>
<p>The load_module() method has a few responsibilities that it must
     fulfill <em>before</em> it runs any code:</p>
<p>...</p>
<ul>
<li>It should add an __loader__ attribute to the module, set to the
   loader object.  This is mostly for introspection, but can be used
   for importer-specific extras, for example getting data associated
   with an importer.</li>
</ul>
</blockquote>
<p>So it looks like it should work fine in all cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you're actually looking for the <code>__name__</code> special variable. From the <a href="http://docs.python.org/tutorial/modules.html" rel="noreferrer">Python documentation</a>:</p>
<blockquote>
<p>Within a module, the module’s name (as a string) is available as the value of the global variable <code>__name__</code>.</p>
</blockquote>
<p>If you run a file directly, this name will <code>__main__</code>. However, if you're in a module (as in the case where you're using the -m flag, or any other import), it will be the complete name of the module.</p>
</div>
<div class="post-text" itemprop="text">
<p>When run with -m, <code>sys.path[0]</code> contains the full path to the module.  You could use that to build the name.</p>
<p>source: <a href="http://docs.python.org/using/cmdline.html#command-line" rel="noreferrer">http://docs.python.org/using/cmdline.html#command-line</a></p>
<p>Another option may be the <code>__package__</code> built in variable which is available within modules.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only way is to do path manipulation with os.getcwd(), os.path, <strong>file</strong> and whatnot, as you mentioned.</p>
<p>Actually, it could be a good patch to implement for optparse / argparse (which currently replace "%prog" in the usage string with os.path.basename(sys.argv[0]) -- you <em>are</em> using optparse, right? -- ), i.e. another special string like %module.</p>
</div>
<div class="post-text" itemprop="text">
<p>Can't see why there is such a restriction as "python -m a.b.c". Of course, the actual module could be inside some zip or whatever, but I'd rather simplified the whole approach with a wrapper script, which makes sure execution happens in the right context, with right python instance.</p>
<p>The wrapper can contain as little as:</p>
<pre><code>import sys
__import__(sys.argv[1])
</code></pre>
<p>Then you can use your favorite method to get the module name for usage.</p>
<p>back to the original requirement. If I understood correctly, the idea is that someone runs a python file in some sub-sub-directory to find out from usage message that it is really a module of some.mega.package.</p>
<p>I think, there is no reliable, generic way to determine if one wants to run c, b.c or a.b.c module, without some file system analysis with certain heuristics (say, finding all __init__.py in the outer directories till the points there are no more __init__.py), and even with the analysis its not 100%.</p>
</div>
<div class="post-text" itemprop="text">
<p>you should hardcode <code>a.b.c</code> in your help, if you distribute the package as such then that's the way to call it regardless of where <code>a</code> is located in the filesystem, as long as it's on the PYTHONPATH it'll be imported.</p>
</div>
<div class="post-text" itemprop="text">
<p>Number of options are there to get the path/name of the current module.</p>
<p>First be familiar with the use of <strong>__file__</strong> in Python, <a href="https://stackoverflow.com/questions/9271464/what-does-the-file-variable-mean-do">Click here to see the usage</a>.</p>
<p>It holds the name of currently loaded <strong>module</strong>. </p>
<p>Check/Try the following code, it will work on both <strong>Python2</strong> &amp; <strong>Python3</strong>.</p>
<pre><code># module_names.py 

import os

print (__file__)
print (os.path.abspath(__file__))
print (os.path.realpath(__file__))
</code></pre>
<p><strong>Output</strong> on MAC OS X:</p>
<pre><code>MacBook-Pro-2:practice admin$ python module_names.py 
module_names.py
/Users/admin/projects/Python/python-the-snake/practice/module_names.py
/Users/admin/projects/Python/python-the-snake/practice/module_names.py
</code></pre>
<p>So here we got the name of <strong>current module name</strong> and its <strong>absolute path</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why does nobody mentioned the <code>.__module__</code>?</p>
<p>When doing a <code>self.__module__</code> you will get the module path.
You can also do this outside of the class:</p>
<pre><code>Class A:
   self.__module__  # gets module.filename

def get_module():
    A.__module__ # also gets module.filename
</code></pre>
</div>
<span class="comment-copy">Does this thread help you? <a href="http://stackoverflow.com/questions/247770/retrieving-python-module-path" title="retrieving python module path">stackoverflow.com/questions/247770/…</a></span>
<span class="comment-copy">There are multiple candidates for duplicates: <a href="http://stackoverflow.com/questions/4288905/how-do-you-show-the-path-of-the-current-running-python-module" title="how do you show the path of the current running python module">stackoverflow.com/questions/4288905/…</a>, <a href="http://stackoverflow.com/questions/1450478/how-do-i-get-the-name-of-a-running-python-script" title="how do i get the name of a running python script">stackoverflow.com/questions/1450478/…</a></span>
<span class="comment-copy">I think this is not a duplicate: The, in the previous comments, referenced issues aim to get the path of the executing file on the file system whereas the PO wants to get the current python <a href="http://docs.python.org/py3k/tutorial/modules.html#packages" rel="nofollow noreferrer">package</a> +  <a href="http://docs.python.org/py3k/tutorial/modules.html" rel="nofollow noreferrer">module</a></span>
<span class="comment-copy">For me it needs to be <code>__loader__.name</code>.  See doc at <a href="https://docs.python.org/3/library/importlib.html#importlib.abc.FileLoader" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">__name__ will be "main" if it is called with the "-m" flag.</span>
<span class="comment-copy">Thanks I edited my question to specify that I know how to manipulate to get the answer, I was hoping for an easier way without having to validate it myself.</span>
<span class="comment-copy">You meant <code>sys.argv[0]</code>.</span>
<span class="comment-copy">I'm still actually using a company package that still use getopt. Module was created back in 2006-2007?</span>
<span class="comment-copy">I changed my company policy to stop putting scripts in /usr/local/bin that was complicate to clean up or was hard to find who's from what project. So we now keep the utility scripts within their own package.</span>
<span class="comment-copy">This defies the purpose of my need. The problem of hardcoding is always if I change the name of my file, I need to remember to change the help text.</span>
<span class="comment-copy">if you change the name of the file all the imports will break so the help text is the lesser of your problems.</span>
<span class="comment-copy">The script being the entry point, it is not imported by other modules so this problem doesn't apply.</span>
<span class="comment-copy">that contradicts your original question, in fact if that's the case <code>__name__ == "__main__"</code> works as usual.</span>
<span class="comment-copy">Sorry to disagree. I don't see how changing the name of my current file will break imports in it. I've been developing for 5 years and changing the name of an entry point (scripts) never broke any of the imports in it. If you have a concrete example, please enlighten me. If you are referring to "relative" imports, I NEVER use them.</span>
<span class="comment-copy">Already mentioned in the question.</span>
<span class="comment-copy">Thanks for your comment and downvote. I didn't read your edit so I guess it's fair..</span>
