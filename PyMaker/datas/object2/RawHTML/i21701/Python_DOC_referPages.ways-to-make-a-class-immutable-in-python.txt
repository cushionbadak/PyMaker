<div class="post-text" itemprop="text">
<p>I'm doing some distributed computing in which several machines communicate under the assumption that they all have identical versions of various classes. Thus, it seems to be good design to make these classes immutable; not in the sense that it must thwart a user with bad intentions, just immutable enough that it is never modified by accident.</p>
<p>How would I go about this? For example, how would I implement a metaclass that makes the class using it immutable after it's definition?</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     __metaclass__ = ImmutableMetaclass
&gt;&gt;&gt; A.something = SomethingElse # Don't want this
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.something = Whatever # obviously, this is still perfectly fine.
</code></pre>
<p>Alternate methods is also fine, such as a decorator/function that takes a class and returns an immutable class.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the old trick of using <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow"><code>__slots__</code></a> does not fit you, this, or some variant of thereof can do: 
simply write the <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow"><code>__setattr__</code></a> method of your metaclass to be your guard. In this example, I prevent new attributes of being assigned, but allow modification of existing ones:</p>
<pre><code>def immutable_meta(name, bases, dct):
    class Meta(type):
        def __init__(cls, name, bases, dct):
            type.__setattr__(cls,"attr",set(dct.keys()))
            type.__init__(cls, name, bases, dct)

        def __setattr__(cls, attr, value):
            if attr not in cls.attr:
                raise AttributeError ("Cannot assign attributes to this class")
            return type.__setattr__(cls, attr, value)
    return Meta(name, bases, dct)


class A:
    __metaclass__ = immutable_meta
    b = "test"

a = A()
a.c = 10 # this works
A.c = 20 # raises valueError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't waste time on immutable classes.</p>
<p>There are things you can do that are far, far simpler than messing around with trying to create an immutable object.</p>
<p>Here  are five separate techniques.  You can pick and choose from among them.  Any one will work.  Some combinations will work, also.</p>
<ol>
<li><p>Documentation.  Actually, they won't forget this.  Give them credit.</p></li>
<li><p>Unit test.  Mock your application objects with a simple mock that handles <a href="https://docs.python.org/2/reference/datamodel.html#object.__setattr__" rel="nofollow"><code>__setattr__</code></a> as an exception.  Any change to the state of the object is a fail in the unit test.  It's easy and doesn't require any elaborate programming.</p></li>
<li><p>Override <code>__setattr__</code> to raise an exception on every attempted write.</p></li>
<li><p><a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow"><code>collections.namedtuple</code></a>.  They're immutable out of the box. </p></li>
<li><p><a href="https://docs.python.org/2/library/collections.html#collections.Mapping" rel="nofollow"><code>collections.Mapping</code></a>.  It's immutable, but you do need to implement a few methods to make it work.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you don't mind reusing someone else's work:</p>
<p><a href="http://packages.python.org/pysistence/" rel="nofollow">http://packages.python.org/pysistence/</a></p>
<p>Immutable persistent (in the functional, not write to desk sense) data structures.</p>
<p>Even if you don't use them as is, the source code should provide some inspiration. Their expando class, for example, takes an object in it's constructor and returns an immutable version of it.</p>
</div>
<span class="comment-copy">@porgarmingduod: Please elaborate more what you actually mean by <code>immutable enough that it is never modified by accident</code>. Thanks</span>
<span class="comment-copy">@eat: Since I am making a system where <b>instances</b> of classes are magically distributed, a programmer may forget that the actual classes aren't. When variables are thrown around in the heat of some complex coding, I want an exception thrown if anyone ever tries to assign something to an immutable class. As for the <code>accident</code> part, all I meant is that the solution doesn't have to prevent a moron from trying to pry apart the internals of the solution.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python">How to make an immutable object in Python?</a></span>
<span class="comment-copy">@eat: The fact that your comment starts with "no offense" does not mitigate the fact that I find your <code>import this</code> answer offensive.</span>
<span class="comment-copy">@eat: What is not to understand about the question? Is it unclear that I am asking about a way to make assigning to/deleting attributes from a class raise an exception? I understand that there may exist objections as to whether such functionality is the right solution, but that is not part of the question. I could write a lengthy defense as to why I think it is. Or I could fail. But the question remains <b>how to make an immutable class</b>.</span>
<span class="comment-copy">Note that you can still do <code>type.__setattr__(A, 'c', 10)</code> and then <code>A.c</code> exists. This doesn't truly make it immutable, but in most cases it will be "good enough" immutability.</span>
<span class="comment-copy">The most correct work-around would be <code>object.__setattr__</code> - it is the setattr on the class itself, not of its type that matters. The <code>type.__setattr__</code> works due it being the same as object's. But indeed - in pure Python it is most likely impossible to avoid work arounds to any such restriction one can come up with - and it is on the "Pythonic" way of being that it should be that way.</span>
<span class="comment-copy">Actually, you cannot call <code>object</code>'s <code>__setattr__</code> on a object that inherits from <code>type</code>. If you try <code>object.__setattr__(A, 'c', 10)</code> you get an error: "<code>TypeError: can't apply this __setattr__ to type object</code>".</span>
<span class="comment-copy">Indeed - I had not noticed that.</span>
<span class="comment-copy">I copy, pasted. and ran this code, and it does not raise a valueError in Python 3.7. Adding print(A.c) at the bottom produces "20".</span>
<span class="comment-copy">@S.Lott: Surely there are more solid ways, such as overriding the dictproxy used by classes? But I haven't done such things before, hence the question. An additional note: I think you could have spared the comments on why not to do this, as that aspect is surely given enough attention in the comments for the original question.</span>
<span class="comment-copy">@porgarmingduod: This is an answer, not more comments.  It stands alone.  Other people with the same question aren't going to thread through the comments.  There is no "more solid way".  It's a waste of brain calories.  Programmers aren't stupid, forgetful, accident-prone, or sociopathic.  Build your app.  Get it to work.  Raise exceptions.  That's the Pythonic way to do it.</span>
<span class="comment-copy">@S.Lott: Well, I guess you are allowed to interpret my question as "How can I make an immutable class, or, alternatively, can anyone tell me why I shouldn't?". Maybe I will have more luck with "How can I make an immutable class if we take for granted that I actually have a good reason to do this." I may not get any answers, but I'd take that any day over someone telling me I do not know what I want, repeatedly, even after I explicitly ask for an answer to the actual question on hand.</span>
<span class="comment-copy">@S.Lott: Where did I demand you do anything for me? Implying I am demanding anything from you is pretty irrational; you cannot possibly find any basis to make that claim in anything I have said. And I have long since conceded that I what I am trying to do may not be a good idea. I am not even trying to defend that point. I am merely tryint to defend the actual question, which is very specific and can be answered. You made your point about "this may be a stupid idea" in the initial comments. Also, kudos for referring to your own opinions as "we". Are you the python community consensus?</span>
<span class="comment-copy">It can be very instructive for learning about Python's data model to practice with immutable classes. Understanding why <code>object.__setattr__</code> or <code>type.__setattr__</code> can still bypass most home brewed attempts is a good learning experience. It's a shame that you choose the approach of hearing a question where someone says "I want to do X" and you just reply "Stop wanting to do X". Wanting to do X can be very useful, if only just for pedagogy, and the answer space is not a good location for your personal normative judgement of the question's premise. Make a comment. Or, better, just ignore it.</span>
<span class="comment-copy">Unfortunately, the <code>expando</code> class isn't immutable. I made the same mistake reading the documentation, but the package only supplies immutable list and dict. Reading the source, I quickly realized the <code>expando</code> class is simply a class that allows you to make copies of a class with changes - it does not however <b>prevent</b> changes.</span>
<span class="comment-copy">Good spot, I had missed that.</span>
