<div class="post-text" itemprop="text">
<p>How would I create a random, 16-character base-62 salt in python? I need it for a protocol and I'm not sure where to start. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
&gt;&gt;&gt; chars=[]
&gt;&gt;&gt; for i in range(16):
    chars.append(random.choice(ALPHABET))

&gt;&gt;&gt; "".join(chars)
'wE9mg9pu2KSmp5lh'
</code></pre>
<p>This should work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't use UUIDs, they are unique, not random: <a href="https://stackoverflow.com/q/3596598/1224926">Is using a CreateUUID() function as salt a good idea?</a></p>
<p>Your salts should use a cryptographically secure random numbers, in python 2.4+, os.urandom is the source of these (if you have a good timing source).</p>
<pre><code># for some given b62encode function

salt = b62encode(os.urandom(16))
</code></pre>
<p>you could also use a generator from <a href="http://www.mindrot.org/projects/py-bcrypt/" rel="nofollow noreferrer">bcrypt</a> or other awesome crypto/hashing library that is well known and vetted by the people much more expert than I am.</p>
<pre><code>import bcrypt
salt = bcrypt.gensalt()
# will be 29 chars you can then encode it however you want.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>These days there is an official <code>mksalt</code> method in the <code>crypt</code> module.
It does not give you a simple 16 char long string but adds <code>$digit$</code> in front required by most hashing functions anyway. If you are hashing passwords this is probably much safer to use.</p>
<pre><code>import crypt
crypt.mksalt(crypt.METHOD_SHA512)
</code></pre>
<p>Generates outputs like the following:</p>
<pre><code>$6$wpg9lx1sVFNFSCrP
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>old question, new solution with <a href="https://docs.python.org/3/library/secrets.html" rel="nofollow noreferrer">secrets</a></p>
<pre><code>import secrets

random_string = secrets.token_hex(8)
</code></pre>
<p>will produce a 16-character random string</p>
</div>
<div class="post-text" itemprop="text">
<p>in base64:</p>
<pre><code>import random, base64, struct
rand_float = random.SystemRandom().random()
salt = base64.b64encode((struct.pack('!d', rand_float)))
</code></pre>
<p>this will be 12 chars</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random
import string

def get_salt(size=16, chars=None):
    if not chars:
        chars = ''.join(
            [string.ascii_uppercase, 
             string.ascii_lowercase, 
             string.digits]
        )
    return ''.join(random.choice(chars) for x in range(size))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I kind of like:</p>
<pre><code>import md5, uuid
m = md5.md5()
m.update(uuid.uuid4())
print m.digest()[:16]
</code></pre>
<p>That will be very, very random.</p>
</div>
<span class="comment-copy">Nice answer, but the last 4 lines can be done more idiomatically with just <code>''.join(random.choice(ALPHABET) for i in range(16))</code></span>
<span class="comment-copy">@ScottGriffiths I wouldn't say that it is more idiomatic because it is a one liner...  It is a nice one line though, so awesome :)</span>
<span class="comment-copy">How about <code>''.join(chr(random.randint(32,126)) for i in range(16))</code>?</span>
<span class="comment-copy">Ah, sorry, not base62.</span>
<span class="comment-copy">Also see secrets.choice (in 3.6+) for a cryptographically secure version, replacing random.choice in the example.</span>
<span class="comment-copy">It gives me an error:  ImportError: No module named bcrypt</span>
<span class="comment-copy">pip install bcrypt should remove the error... show that the bcrypt package is not installed in your computer ---  anurageldorado</span>
<span class="comment-copy">Your base_64 example does not work. A hash may contain <code>[./a-zA-Z0-9]</code>, yours will additionally contain <code>+</code>, <code>=</code> and <code>\n</code>.</span>
<span class="comment-copy">@cdauth given that I misread the question to begin with (base 62 was asked for), I've since updated this to reflect this.  I assume that their exists an encoding function though - easy enough to find one of those on SO.</span>
<span class="comment-copy">Not present in python 2.7</span>
<span class="comment-copy">Did you mean <code>m.update(str(uuid.uuid4()))</code>? And also <code>m.hexdigest()[:16]</code>? But still, that wouldn't be in <code>base62</code> right?</span>
<span class="comment-copy">Sorry, you're right about the code.  I figure since my solution uses a subset of the base62 characters it might work for the original poster.</span>
