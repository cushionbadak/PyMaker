<div class="post-text" itemprop="text">
<p>I'm writing an AI state space search algorithm, and I have a generic class which can be used to quickly implement a search algorithm. A subclass would define the necessary operations, and the algorithm does the rest. </p>
<p>Here is where I get stuck: I want to avoid regenerating the parent state over and over again, so I have the following function, which returns the operations that can be legally applied to any state: </p>
<pre><code>def get_operations(self, include_parent=True):
    ops = self._get_operations()
    if not include_parent and self.path.parent_op:
        try:
            parent_inverse = self.invert_op(self.path.parent_op)
            ops.remove(parent_inverse)
        except NotImplementedError:
            pass
    return ops
</code></pre>
<p>And the invert_op function throws by default. </p>
<p>Is there a faster way to check to see if the function is not defined than catching an exception? </p>
<p>I was thinking something on the lines of checking for present in dir, but that doesn't seem right. hasattr is implemented by calling getattr and checking if it raises, which is not what I want. </p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, use <code>getattr()</code> to get the attribute, and <code>callable()</code> to verify it is a method:</p>
<pre><code>invert_op = getattr(self, "invert_op", None)
if callable(invert_op):
    invert_op(self.path.parent_op)
</code></pre>
<p>Note that <code>getattr()</code> normally throws exception when the attribute doesn't exist. However, if you specify a default value (<code>None</code>, in this case), it will return that instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>It works in both Python 2 and Python 3</p>
<pre><code>hasattr(connection, 'invert_opt')
</code></pre>
<p><code>hasattr</code> returns <code>True</code> if connection object has a function <code>invert_opt</code> defined. Here is the documentation for you to graze</p>
<p><a href="https://docs.python.org/2/library/functions.html#hasattr" rel="noreferrer">https://docs.python.org/2/library/functions.html#hasattr</a>
<a href="https://docs.python.org/3/library/functions.html#hasattr" rel="noreferrer">https://docs.python.org/3/library/functions.html#hasattr</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a faster way to check to see if the function is not defined than catching an exception?</p>
</blockquote>
<p>Why are you against that? In most Pythonic cases, it's better to ask forgiveness than permission. ;-)</p>
<blockquote>
<p>hasattr is implemented by calling getattr and checking if it raises, which is not what I want.</p>
</blockquote>
<p>Again, why is that? The following is quite Pythonic:</p>
<pre><code>    try:
        invert_op = self.invert_op
    except AttributeError:
        pass
    else:
        parent_inverse = invert_op(self.path.parent_op)
        ops.remove(parent_inverse)
</code></pre>
<p>Or,</p>
<pre><code>    # if you supply the optional `default` parameter, no exception is thrown
    invert_op = getattr(self, 'invert_op', None)  
    if invert_op is not None:
        parent_inverse = invert_op(self.path.parent_op)
        ops.remove(parent_inverse)
</code></pre>
<p>Note, however, that <code>getattr(obj, attr, default)</code> is basically implemented by catching an exception, too. There is nothing wrong with that in Python land!</p>
</div>
<div class="post-text" itemprop="text">
<p>I like Nathan Ostgard's answer and I up-voted it.  But another way you could solve your problem would be to use a memoizing decorator, which would cache the result of the function call.  So you can go ahead and have an expensive function that figures something out, but then when you call it over and over the subsequent calls are fast; the memoized version of the function looks up the arguments in a dict, finds the result in the dict from when the actual function computed the result, and returns the result right away.</p>
<p>Here is a recipe for a memoizing decorator called "lru_cache" by Raymond Hettinger.  A version of this is now standard in the functools module in Python 3.2.</p>
<p><a href="http://code.activestate.com/recipes/498245-lru-and-lfu-cache-decorators/" rel="nofollow">http://code.activestate.com/recipes/498245-lru-and-lfu-cache-decorators/</a></p>
<p><a href="http://docs.python.org/release/3.2/library/functools.html" rel="nofollow">http://docs.python.org/release/3.2/library/functools.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The responses herein check if a string is the name of an attribute of the object. An extra step (using callable) is needed to check if the attribute is a method.</p>
<p>So it boils down to: what is the fastest way to check if an object obj has an attribute attrib. The answer is</p>
<pre><code>'attrib' in obj.__dict__
</code></pre>
<p>This is so because a dict hashes its keys so checking for the key's existence is fast.</p>
<p>See timing comparisons below.</p>
<pre><code>&gt;&gt;&gt; class SomeClass():
...         pass
...
&gt;&gt;&gt; obj = SomeClass()
&gt;&gt;&gt;
&gt;&gt;&gt; getattr(obj, "invert_op", None)
&gt;&gt;&gt;
&gt;&gt;&gt; %timeit getattr(obj, "invert_op", None)
1000000 loops, best of 3: 723 ns per loop
&gt;&gt;&gt; %timeit hasattr(obj, "invert_op")
The slowest run took 4.60 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 674 ns per loop
&gt;&gt;&gt; %timeit "invert_op" in obj.__dict__
The slowest run took 12.19 times longer than the fastest. This could mean that an intermediate result is being cached.
10000000 loops, best of 3: 176 ns per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like anything in Python, if you try hard enough, you can get at the guts and do something really nasty. Now, here's the nasty part:</p>
<pre><code>def invert_op(self, op):
    raise NotImplementedError

def is_invert_op_implemented(self):
    # Only works in CPython 2.x of course
    return self.invert_op.__code__.co_code == 't\x00\x00\x82\x01\x00d\x00\x00S'
</code></pre>
<p>Please do us a favor, just keep doing what you have in your question and <strong>DON'T</strong> ever use this unless you are on the PyPy team hacking into the Python interpreter. What you have up there is Pythonic, what I have here is pure <strong>EVIL</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>While checking for attributes in __dict__ property is really fast, you cannot use this for methods, since they do not appear in __dict__ hash. You could however resort to hackish workaround in your class, if performance is that critical:</p>
<pre><code>class Test():
    def __init__():
        # redefine your method as attribute
        self.custom_method = self.custom_method

    def custom_method(self):
        pass
</code></pre>
<p>Then check for method as:</p>
<pre><code>t = Test()
'custom_method' in t.__dict__
</code></pre>
<p>Time comparision with <code>getattr</code>:</p>
<pre><code>&gt;&gt;%timeit 'custom_method' in t.__dict__
55.9 ns ± 0.626 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

&gt;&gt;%timeit getattr(t, 'custom_method', None)
116 ns ± 0.765 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
<p>Not that I'm encouraging this approach, but it seems to work.</p>
<p>[EDIT] Performance boost is even higher when method name is not in given class:</p>
<pre><code>&gt;&gt;%timeit 'rubbish' in t.__dict__
65.5 ns ± 11 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

&gt;&gt;%timeit getattr(t, 'rubbish', None)
385 ns ± 12.9 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
</div>
<span class="comment-copy">Something sounds broken, but I can't quite put my finger on it...</span>
<span class="comment-copy"><i>"hasattr is implemented by calling getattr and checking if it raises, which is not what I want."</i> Why not? Why do you care what the implementation does?</span>
<span class="comment-copy"><code>has_op = lambda obj, op: callable(getattr(obj, op, None))</code></span>
<span class="comment-copy">Try: <code>hasattr(connection, 'invert_opt')</code>.</span>
<span class="comment-copy">Note also that the implementation of <code>getattr</code> in this case catches an exception silently and returns the default value instead, just like <code>hasattr</code> does, which the OP was for some reason against.</span>
<span class="comment-copy">What if the function is not in that class, but on the parent class?. In this case I get a True, even when the children never implement that function (using hasattr)</span>
<span class="comment-copy">Although the code is appreciated, it should always have an accompanying explanation. This doesn't have to be long but it is expected.</span>
<span class="comment-copy">good one, you can point to an article though it would not hurt :)</span>
<span class="comment-copy">This also returns True if connection has an attribute <code>connection.invert_opt = 'foo'</code>.</span>
<span class="comment-copy">This will be true if the method raises any exception. You should also check to see if <code>co_names</code> is equal to <code>('NotImplementedError',)</code>.  I am not sure if this makes it more or less evil, however.</span>
<span class="comment-copy"><code>__dict__</code> could be overridden. It cannot be trusted.</span>
