<div class="post-text" itemprop="text">
<p>What is the correct way to make my PyQt application quit when killed from the console (Ctrl-C)?</p>
<p>Currently (I have done nothing special to handle unix signals), my PyQt application ignores SIGINT (Ctrl+C). I want it to behave nicely and quit when it is killed. How should I do that?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><a href="http://docs.python.org/library/signal.html" rel="noreferrer">17.4. signal — Set handlers for asynchronous events</a></p>
<p>Although Python signal handlers are called asynchronously as far as the Python user is concerned, they can only occur between the “atomic” instructions of the Python interpreter. This means that signals arriving during long calculations implemented purely in C (such as regular expression matches on large bodies of text) may be delayed for an arbitrary amount of time.</p>
</blockquote>
<p>That means Python cannot handle signals while the Qt event loop is running. Only when the Python interpreter run (when the QApplication quits, or when a Python function is called from Qt) the signal handler will be called.</p>
<p>A solution is to use a QTimer to let the interpreter run from time to time.</p>
<p>Note that, in the code below, if there are no open windows, the application will quit after the message box regardless of the user's choice because QApplication.quitOnLastWindowClosed() == True. This behaviour can be changed.</p>
<pre><code>import signal
import sys

from PyQt4.QtCore import QTimer
from PyQt4.QtGui import QApplication, QMessageBox

# Your code here

def sigint_handler(*args):
    """Handler for the SIGINT signal."""
    sys.stderr.write('\r')
    if QMessageBox.question(None, '', "Are you sure you want to quit?",
                            QMessageBox.Yes | QMessageBox.No,
                            QMessageBox.No) == QMessageBox.Yes:
        QApplication.quit()

if __name__ == "__main__":
    signal.signal(signal.SIGINT, sigint_handler)
    app = QApplication(sys.argv)
    timer = QTimer()
    timer.start(500)  # You may change this if you wish.
    timer.timeout.connect(lambda: None)  # Let the interpreter run each 500 ms.
    # Your code here.
    sys.exit(app.exec_())
</code></pre>
<p>Another possible solution, <a href="https://stackoverflow.com/a/6072360/286655">as pointed by LinearOrbit</a>, is <code>signal.signal(signal.SIGINT, signal.SIG_DFL)</code>, but it doesn't allow custom handlers.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you simply wish to have ctrl-c close the application - without being "nice"/graceful about it - then from <a href="http://www.mail-" rel="noreferrer">http://www.mail-</a><a href="http://www.mail-archive.com/pyqt@riverbankcomputing.com/msg13758.html" rel="noreferrer">archive.com/pyqt@riverbankcomputing.com/msg13758.html</a>, you can use this:</p>
<pre><code>import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)

import sys
from PyQt4.QtCore import QCoreApplication
app = QCoreApplication(sys.argv)
app.exec_()
</code></pre>
<p>Apparently this works on Linux, Windows and OSX - I have only tested this on Linux so far (and it works).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><a href="https://docs.python.org/3/library/signal.html" rel="noreferrer">18.8.1.1. Execution of Python signal handlers</a></p>
<p>A Python signal handler does not get executed inside the low-level (C) signal handler. Instead, the low-level signal handler sets a flag which tells the virtual machine to execute the corresponding Python signal handler at a later point(for example at the next bytecode instruction). This has consequences:<br/>
  [...]<br/>
  A long-running calculation implemented purely in C (such as regular expression matching on a large body of text) may run uninterrupted for an arbitrary amount of time, regardless of any signals received. The Python signal handlers will be called when the calculation finishes.</p>
</blockquote>
<p>The Qt event loop is implemented in C(++). That means, that while it runs and no Python code is called (eg. by a Qt signal connected to a Python slot), the signals are noted, but the Python signal handlers aren't called.</p>
<p><strong>But</strong>, since Python 2.6 and in Python 3 you can cause Qt to run a Python function when a signal with a handler is received using <a href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" rel="noreferrer"><code>signal.set_wakeup_fd()</code></a>.</p>
<p>This is possible, because, contrary to the documentation, the low-level signal handler doesn't only set a flag for the virtual machine, but it may also write a byte into the file descriptor set by <code>set_wakeup_fd()</code>. Python 2 writes a NUL byte, Python 3 writes the signal number.</p>
<p>So by subclassing a Qt class that takes a file descriptor and provides a <code>readReady()</code> signal, like e.g. <code>QAbstractSocket</code>, the event loop will execute a Python function every time a signal (with a handler) is received causing the signal handler to execute nearly instantaneous without need for timers:</p>
<pre><code>import sys, signal, socket
from PyQt4 import QtCore, QtNetwork

class SignalWakeupHandler(QtNetwork.QAbstractSocket):

    def __init__(self, parent=None):
        super().__init__(QtNetwork.QAbstractSocket.UdpSocket, parent)
        self.old_fd = None
        # Create a socket pair
        self.wsock, self.rsock = socket.socketpair(type=socket.SOCK_DGRAM)
        # Let Qt listen on the one end
        self.setSocketDescriptor(self.rsock.fileno())
        # And let Python write on the other end
        self.wsock.setblocking(False)
        self.old_fd = signal.set_wakeup_fd(self.wsock.fileno())
        # First Python code executed gets any exception from
        # the signal handler, so add a dummy handler first
        self.readyRead.connect(lambda : None)
        # Second handler does the real handling
        self.readyRead.connect(self._readSignal)

    def __del__(self):
        # Restore any old handler on deletion
        if self.old_fd is not None and signal and signal.set_wakeup_fd:
            signal.set_wakeup_fd(self.old_fd)

    def _readSignal(self):
        # Read the written byte.
        # Note: readyRead is blocked from occuring again until readData()
        # was called, so call it, even if you don't need the value.
        data = self.readData(1)
        # Emit a Qt signal for convenience
        self.signalReceived.emit(data[0])

    signalReceived = QtCore.pyqtSignal(int)

app = QApplication(sys.argv)
SignalWakeupHandler(app)

signal.signal(signal.SIGINT, lambda sig,_: app.quit())

sys.exit(app.exec_())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found a way to do this. The idea is to force qt to process events often enough and in a python callabe to catch the SIGINT signal.</p>
<pre><code>import signal, sys
from PyQt4.QtGui import QApplication, QWidget # also works with PySide

# You HAVE TO reimplement QApplication.event, otherwise it does not work.
# I believe that you need some python callable to catch the signal
# or KeyboardInterrupt exception.
class Application(QApplication):
    def event(self, e):
        return QApplication.event(self, e)

app = Application(sys.argv)

# Connect your cleanup function to signal.SIGINT
signal.signal(signal.SIGINT, lambda *a: app.quit())
# And start a timer to call Application.event repeatedly.
# You can change the timer parameter as you like.
app.startTimer(200)

w = QWidget()
w.show()
app.exec_()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the standard python unix signals handling mechanism:</p>
<pre><code>import signal 
import sys
def signal_handler(signal, frame):
        print 'You pressed Ctrl+C!'
        sys.exit(0)
signal.signal(signal.SIGINT, signal_handler)
print 'Press Ctrl+C'
while 1:
        continue
</code></pre>
<p>where in <code>signal_handler</code> you can free all resources (close all db sessions etc) and gently close your appliction.</p>
<p>Code example taken from <a href="http://www.linuxjournal.com/article/3946?page=0,1" rel="nofollow" title="here">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think I have a simpler solution:</p>
<pre><code>import signal
import PyQt4.QtGui

def handleIntSignal(signum, frame):
    '''Ask app to close if Ctrl+C is pressed.'''
    PyQt4.QtGui.qApp.closeAllWindows()

signal.signal(signal.SIGINT, handleIntSignal)
</code></pre>
<p>This just tells the application to try to close all windows if ctrl+c is pressed. If there is an unsaved document, your app should pop up a save or cancel dialog box as if it were exited.</p>
<p>You may also need to connect the QApplication signal lastWindowClosed() to the slot quit() to get the application to actually exit when the windows are closed.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer from Artur Gaspar worked for me when the terminal window was in focus, but would not work when the GUI was in focus.  In order to get my GUI to close (which inherits from QWidget) I had to define the following function in the class:</p>
<pre><code>def keyPressEvent(self,event):
    if event.key() == 67 and (event.modifiers() &amp; QtCore.Qt.ControlModifier):
        sigint_handler()
</code></pre>
<p>Checking to make sure that the event key is 67 makes sure that 'c' was pressed.  Then checking the event modifiers determines whether ctrl was being pressed when 'c' was released.</p>
</div>
<span class="comment-copy">I've never understood why almost every python script in the world stops with a control+c except for pyqt apps. No doubt there is a  sound reason for that, but in the end it's very annoying.</span>
<span class="comment-copy">@tokland : let's solve this once for all :)</span>
<span class="comment-copy">it appears to a design problem: <a href="http://www.mail-archive.com/pyqt@riverbankcomputing.com/msg13757.html" rel="nofollow noreferrer">mail-archive.com/pyqt@riverbankcomputing.com/msg13757.html</a>. Any solution involving exceptions or similar just feels hacky :-(</span>
<span class="comment-copy">you can use Ctrl + \ to kill the app from the terminal.</span>
<span class="comment-copy">Doesn't seem to work... Qt seems to catch the exception before I can.</span>
<span class="comment-copy">Your second solution works ... kinda. When I press Ctrl-C, the application doesn't terminate immediately like is expected, but waits until focus is restored to the application.</span>
<span class="comment-copy">Anyways, thanks for your answer, I'll try to ask a more specific question if nobody gives a better answer.</span>
<span class="comment-copy">@static_rtti The third solution works.</span>
<span class="comment-copy">Thanks! Seems a bit overkill, though :) I guess I'll ask the PyQt guys directly if your solution is really the only one :)</span>
<span class="comment-copy">This work, but be aware it will bypass any cleaning you wish to do such as calls in finally blocks.</span>
<span class="comment-copy">Unfortunately, this doesn't work on windows as there is no <code>socket.socketpair</code>. (I tried <code>backports.socketpair</code>, but this doesn't work either).</span>
<span class="comment-copy">On Windows sockets and other file-like handles seem to be handled separately, so you probably need another construct that doesn't use sockets. I don't use Windows, so I can't test what would work. As of Python 3.5 sockets seem to be supported (see <a href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" rel="nofollow noreferrer">docs.python.org/3/library/signal.html#signal.set_wakeup_fd</a> ).</span>
<span class="comment-copy">I'm getting <code>ValueError: the fd 10 must be in non-blocking mode</code> when trying this with Python 3.5.3 on macOS.</span>
<span class="comment-copy"><code>self.wsock.setblocking(False)</code> fixes the problem mentioned in my previous commend.</span>
<span class="comment-copy">I connected it like this to get a return code too <code>signal.signal(signal.SIGINT, lambda *a: app.exit(-2))</code></span>
<span class="comment-copy">That doesn't really solve my problem, because I'd like to at least have a handle on my main window in the handler. In your example, you don't...</span>
<span class="comment-copy">If you place this after the app and main window are created, but before you call app._exec(), it does indeed have a handle on your app and main window.</span>
<span class="comment-copy">i haven't tested your solution, but I'm pretty sure it suffers from the same problem of one of the solution above:</span>
<span class="comment-copy">The signal will not be caught before control returns to the python interpreter, ie. before the application returns from sleep; which means the application will have to wait to regain focus to exit. Unacceptable for me.</span>
<span class="comment-copy">After some reflection, I think I will implement Arthur Gaspar's last solution, with a system to easily disable it when debugging.</span>
