<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/4938723/what-is-the-correct-way-to-make-my-pyqt-application-quit-when-killed-from-the-co">What is the correct way to make my PyQt application quit when killed from the console (Ctrl-C)?</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>Why doesn't <kbd>Ctrl</kbd>+<kbd>C</kbd> work to break a Python program that uses PyQt?  I want to debug it and get a stack trace and for some reason, this is harder to do than with C++!</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>CTRL+C causes a signal to be sent to
  the process. Python catches the
  signal, and sets a global variable,
  something like CTRL_C_PRESSED = True.
  Then, whenever the Python interpreter
  gets to execute a new opcode, it sees
  the variable set and raises a
  KeybordInterrupt.</p>
<p>This means that CTRL+C works only if
  the Python interpreter is spinning. If
  the interpreter is executing an
  extension module written in C that
  executes a long-running operation,
  CTRL+C won't interrupt it, unless it
  explicitly "cooperates" with Python.
  Eg: time.sleep() is theoretically a
  blocking operation, but the
  implementation of that function
  "cooperates" with the Python
  interpreter to make CTRL+C work.</p>
<p>This is all by design: CTRL+C is meant
  to do a "clean abort"; this is why it
  gets turned into an exception by
  Python (so that the cleanups are
  executed during stack unwind), and its
  support by extension modules is sort
  of "opt-in". If you want to totally
  abort the process, without giving it a
  chance to cleanup, you can use CTRL+.</p>
<p>When Python calls QApplication::exec()
  (the C++ function), Qt doesn't know
  how to "cooperate" with Python for
  CTRL+C, and this is why it does not
  work. I don't think there's a good way
  to "make it work"; you may want to see
  if you can handle it through a global
  event filter.
  â€”  Giovanni Bajo</p>
</blockquote>
<p>Adding this to the main program solved the problem.</p>
<pre><code>import signal

signal.signal(signal.SIGINT, signal.SIG_DFL)
</code></pre>
<p>I'm not sure what this has to do with the explanation.</p>
</div>
<div class="post-text" itemprop="text">
<p>I agree with Neil G, and would add this:</p>
<p>If you do <em>not</em> call QApplication.exec_() to start the event loop, and instead execute your program in an interactive python shell (using python -i), then pyqt will automatically process events whenever the interactive prompt is waiting, and Ctrl-C should again behave as expected. This is because the Qt event loop will be sharing time with the python interpreter, rather than running exclusively, allowing the interpreter a chance to catch those interrupts. </p>
</div>
<span class="comment-copy">Which OS are you using?</span>
<span class="comment-copy">You should have used Google ;-) <a href="http://www.mail-archive.com/pyqt@riverbankcomputing.com/msg13757.html" rel="nofollow noreferrer">Your problem explained with solution</a></span>
<span class="comment-copy">@A A - Nice! I thought it was a Ctrl+C versus Ctrl+D situation.</span>
<span class="comment-copy">@Wooble, thanks, I think it's a duplicate.</span>
<span class="comment-copy">I have no idea what this does, but it does work perfectly! EDIT: Read a bit about it <a href="https://docs.python.org/3/library/signal.html" rel="nofollow noreferrer">here</a> so it says, that SIGINT (=Ctrl+C) should do the default action (=quit).</span>
