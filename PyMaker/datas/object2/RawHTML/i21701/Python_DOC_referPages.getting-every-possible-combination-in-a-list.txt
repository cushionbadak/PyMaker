<div class="post-text" itemprop="text">
<p>suppose I had something like this:</p>
<pre><code>L1=['cat', 'dog', 'fish', 'rabbit', 'horse', 'bird', 'frog', 'mouse'...]

for x in L1:
    input1= open('file_%s'%(x), 'r')
    file1= pickle.load(input1)
    for x in L1:
        input2= open('file_%s'%(x), 'r')
        file2= pickle.load(input2)
</code></pre>
<p>and I wanted to get every combination of files without repeating combinations that have already been done (once cat_dog is done do not do dog_cat again).  Is there a way I could do this?  My real list is in alphabetical order, if that makes any difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can also do it as a generator:</p>
<pre><code>L1=['cat', 'dog', 'fish', 'rabbit', 'horse', 'bird', 'frog', 'mouse']
tuples = [(x,y) for x in L1 for y in L1 if x != y]
for entry in tuples:
    if (entry[1], entry[0]) in tuples:
        tuples.remove((entry[1],entry[0]))
for pair in tuples:
    input1= open('file_%s'%(pair[0]), 'r')
    file1= pickle.load(input1)
    input2= open('file_%s'%(pair[1]), 'r')
    file2= pickle.load(input2)
</code></pre>
<p>After the first loop, the contents of <code>tuples</code> is:</p>
<pre><code>('cat', 'dog')
('cat', 'fish')
('cat', 'rabbit')
('cat', 'horse')
('cat', 'bird')
('cat', 'frog')
('cat', 'mouse')
('dog', 'fish')
('dog', 'rabbit')
('dog', 'horse')
('dog', 'bird')
('dog', 'frog')
('dog', 'mouse')
('fish', 'rabbit')
('fish', 'horse')
('fish', 'bird')
('fish', 'frog')
('fish', 'mouse')
('rabbit', 'horse')
('rabbit', 'bird')
('rabbit', 'frog')
('rabbit', 'mouse')
('horse', 'bird')
('horse', 'frog')
('horse', 'mouse')
('bird', 'frog')
('bird', 'mouse')
('frog', 'mouse')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In reality what you're asking how to do is produce all combinations of <strong>two</strong> items taken in the list of names (as opposed to <strong>all</strong> the possible combination of them). </p>
<p>That means you can use the built-in <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations()</code></a> generator function to easily (and efficiently) generate pairs of the names you want with no repeats:</p>
<pre><code>L1 = ['cat', 'dog', 'fish', 'rabbit', 'horse', 'bird', 'frog', 'mouse']

for pair in combinations(L1, 2):
    print(pair)
    input1 = open('file_%s' % pair[0], 'r')
    input2 = open('file_%s' % pair[1], 'r')
</code></pre>
<p>Pairs processed:</p>
<pre class="lang-none prettyprint-override"><code>('cat', 'dog')
('cat', 'fish')
('cat', 'rabbit')
('cat', 'horse')
('cat', 'bird')
('cat', 'frog')
('cat', 'mouse')
('dog', 'fish')
('dog', 'rabbit')
('dog', 'horse')
('dog', 'bird')
('dog', 'frog')
('dog', 'mouse')
('fish', 'rabbit')
('fish', 'horse')
('fish', 'bird')
('fish', 'frog')
('fish', 'mouse')
('rabbit', 'horse')
('rabbit', 'bird')
('rabbit', 'frog')
('rabbit', 'mouse')
('horse', 'bird')
('horse', 'frog')
('horse', 'mouse')
('bird', 'frog')
('bird', 'mouse')
('frog', 'mouse')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about <a href="http://docs.python.org/library/itertools.html#itertools.combinations" rel="noreferrer">itertools.combinations</a>?</p>
<p>Usage example:</p>
<pre><code>&gt;&gt;&gt; list(itertools.combinations([1, 2, 3, 4, 5, 6], 2))
[(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (2, 4), (2, 5), (2, 6), (3, 4),
(3, 5), (3, 6), (4, 5), (4, 6), (5, 6)]
</code></pre>
<p>First argument is an iterable, second is <code>r</code>, length of subsequences returned.</p>
<p>You can then concatenate the results with ease using map or a comprehension:</p>
<pre><code>map(lambda x: x[0] + "_" + x[1], itertools.combinations(["cat", "dog", "fish"], 2)))
</code></pre>
<p><code>x</code> in the lambda is a <code>r</code>-sized tuple. </p>
<p>Result of the above would be:</p>
<pre><code>['cat_dog', 'cat_fish', 'dog_fish']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools
import cPickle

def unique_pairs(lst):
    return itertools.combinations(lst, 2)

FNAME = "file_{0}".format
def load_pickle(fname):
    with open(fname) as inf:
        return cPickle.load(inf)

def naive_method(lst):
    # load each file every time it is requested
    for x,y in unique_pairs(lst):
        input1 = load_pickle(FNAME(x))
        input2 = load_pickle(FNAME(y))
        # do something with input1 and input2

def better_method(lst):
    # if you have enough memory for it!
    dat = [load_pickle(FNAME(i)) for i in lst]
    for x,y in unique_pairs(range(len(lst))):
        input1 = dat[x]
        input2 = dat[y]
        # do something with input1 and input2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's <a href="http://docs.python.org/library/itertools.html#itertools.combinations" rel="nofollow">itertools</a> that can perform combinations and permutations (you'd want the former). As far as I can tell, you can't really specify the output format, so you'd get "catdog" as output, but the doc page gives you an idea of how the combinations function works, so you can adapt it to build what you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative for combination creation, with no module import. Similar to @Nate's answer, but marginally less complex, creating a copy with single items and reducing on the fly (rather than generating a list of pairs and reducing by list search):</p>
<pre><code>L1 = ['cat', 'dog', 'fish', 'rabbit', 'horse', 'bird', 'frog', 'mouse']
Laux = L1[:]

pairs = []
for a in L1:
    Laux.remove(a)
    for b in Laux:
        pairs += [(a,b)]
</code></pre>
</div>
<span class="comment-copy">This has been asked plenty of times so will probably get closed. import itertools; itertools.combinations(['cat', 'dog', 'fish'], 2)</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/464864/python-code-to-pick-out-all-possible-combinations-from-a-list">Python code to pick out all possible combinations from a list?</a></span>
<span class="comment-copy">this is perfect, just what i needed thank you @Nate!</span>
<span class="comment-copy">This is not a great way to do it. Look at the itertools solution! Itertools avoids having to generate the complete list up front - in this implementation, the tuples list is n^2 items long. The itertools solution doesn't need to store the list.</span>
