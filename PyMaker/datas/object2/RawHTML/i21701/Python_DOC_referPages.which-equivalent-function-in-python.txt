<div class="post-text" itemprop="text">
<p>I need to setup environment by running <code>which abc</code> command.
Is there a Python equivalent function of the <strong><code>which</code></strong> command?
This is my code.</p>
<pre class="lang-py prettyprint-override"><code>cmd = ["which","abc"]
p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
res = p.stdout.readlines()
if len(res) == 0: return False
return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is <a href="https://docs.python.org/3.5/distutils/apiref.html#module-distutils.spawn" rel="noreferrer"><code>distutils.spawn.find_executable()</code></a> on Python 2.4+</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is an older question, but if you happen to be using Python 3.3+ you can use <code>shutil.which(cmd)</code>. You can find the documentation <a href="https://docs.python.org/3/library/shutil.html?highlight=.which#shutil.which">here</a>. It has the advantage of being in the standard library.</p>
<p>An example would be like so:</p>
<pre><code>&gt;&gt;&gt; import shutil
&gt;&gt;&gt; shutil.which("bash")
'/usr/bin/bash'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's not a command to do that, but you can iterate over <code>environ["PATH"]</code> and look if the file exists, which is actually what <code>which</code> does.</p>
<pre><code>import os

def which(file):
    for path in os.environ["PATH"].split(os.pathsep):
        if os.path.exists(os.path.join(path, file)):
                return os.path.join(path, file)

    return None
</code></pre>
<p>Good luck!</p>
</div>
<div class="post-text" itemprop="text">
<p>(<a href="https://stackoverflow.com/questions/775351/os-path-exists-for-files-in-your-path">Similar question</a>)</p>
<p>See the Twisted implementation: <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.2.0/twisted/python/procutils.py" rel="nofollow noreferrer">twisted.python.procutils.which</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could try something like the following:</p>
<pre><code>import os
import os.path
def which(filename):
    """docstring for which"""
    locations = os.environ.get("PATH").split(os.pathsep)
    candidates = []
    for location in locations:
        candidate = os.path.join(location, filename)
        if os.path.isfile(candidate):
            candidates.append(candidate)
    return candidates
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you use <code>shell=True</code>, then your command will be run through the system shell, which will automatically find the binary on the path:</p>
<pre><code>p = subprocess.Popen("abc", stdout=subprocess.PIPE, shell=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the equivalent of the which command, which not only checks if the file exists, but also whether it is executable:</p>
<pre><code>import os

def which(file_name):
    for path in os.environ["PATH"].split(os.pathsep):
        full_path = os.path.join(path, file_name)
        if os.path.exists(full_path) and os.access(full_path, os.X_OK):
            return full_path
    return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a one-line version of earlier answers:</p>
<pre><code>import os
which = lambda y: next(filter(lambda x: os.path.isfile(x) and os.access(x,os.X_OK),[x+os.path.sep+y for x in os.getenv("PATH").split(os.pathsep)]),None)
</code></pre>
<p>used like so:</p>
<pre><code>&gt;&gt;&gt; which("ls")
'/bin/ls'
</code></pre>
</div>
<span class="comment-copy">Even in the shell itself, <code>which</code> itself is not a good choice for detecting if a command is installed. <a href="http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script/677212#677212">Reference</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/377017/test-if-executable-exists-in-python">Test if executable exists in Python?</a></span>
<span class="comment-copy">+1, this is cool and part of the standard library! Be aware that it's very limited on Windows - it doesn't parse PATHEXT, instead it assumes it should be searching for a '.exe' extension (missing batch files etc)</span>
<span class="comment-copy">Works perfectly, worth its place in Google results.</span>
<span class="comment-copy">Beware it doesn't check whether file is executable.</span>
<span class="comment-copy">Exactly, this is not equivalent to the which command.</span>
<span class="comment-copy">This didn't work for me on 2.7 or 3.6. It gave an error that the spawn module wasn't found.</span>
<span class="comment-copy">You want to be cautious making assumptions about the pathsep character.</span>
<span class="comment-copy">and path separator, but this is just a quirk to make a point. Good luck!</span>
<span class="comment-copy">use <code>os.path.sep</code> instead of <code>/</code> and <code>os.pathsep</code> instead of <code>:</code></span>
<span class="comment-copy">Do not use '+', use os.path.join. See more up-voted answers for a stdlib implementation (distutils) and a more platform-independent from the Twisted project.</span>
<span class="comment-copy">thanks for os.path.join. The twisted implementation is completely isolated, doesn't seem to have any inter-dependency with the rest of the project, so as an implementation it is much better (than mine at least)</span>
<span class="comment-copy">This is much better!!</span>
<span class="comment-copy">That is pretty nice.</span>
<span class="comment-copy">Thanks, I'll use it.</span>
<span class="comment-copy">The thing with that is it requires installing the Twisted module, which has the potential to be painful on Windows (even with Christoph Gohlke's wheels).</span>
<span class="comment-copy">You need to take <code>PATHEXT</code> into account as well</span>
<span class="comment-copy">On a Windows machine I suspect that you would likely look for the exact name of the file, as opposed to assuming the extensions. With that being said it wouldn't be hard to add an inner loop that iterates over the members of PATHEXT.</span>
<span class="comment-copy">Even without <code>shell=True</code> it is looked up in path, but it does not help if you want to find which of the possible commands exists.</span>
<span class="comment-copy">This doesn't seem to work in Python2, <code>TypeError: list object is not an iterator</code>.</span>
