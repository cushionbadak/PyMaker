<div class="post-text" itemprop="text">
<p>I am getting <code>new_tag</code> from a form text field with <code>self.response.get("new_tag")</code> and <code>selected_tags</code> from checkbox fields with </p>
<pre><code>self.response.get_all("selected_tags")
</code></pre>
<p>I combine them like this:</p>
<pre><code>tag_string = new_tag
new_tag_list = f1.striplist(tag_string.split(",") + selected_tags)
</code></pre>
<p>(<code>f1.striplist</code> is a function that strips white spaces inside the strings in the list.)</p>
<p>But in the case that <code>tag_list</code> is empty (no new tags are entered) but there are some <code>selected_tags</code>, <code>new_tag_list</code> contains an empty string <code>" "</code>.</p>
<p>For example, from <code>logging.info</code>:</p>
<pre><code>new_tag
selected_tags[u'Hello', u'Cool', u'Glam']
new_tag_list[u'', u'Hello', u'Cool', u'Glam']
</code></pre>
<p>How do I get rid of the empty string?</p>
<p>If there is an empty string in the list:</p>
<pre><code>&gt;&gt;&gt; s = [u'', u'Hello', u'Cool', u'Glam']
&gt;&gt;&gt; i = s.index("")
&gt;&gt;&gt; del s[i]
&gt;&gt;&gt; s
[u'Hello', u'Cool', u'Glam']
</code></pre>
<p>But if there is no empty string:</p>
<pre><code>&gt;&gt;&gt; s = [u'Hello', u'Cool', u'Glam']
&gt;&gt;&gt; if s.index(""):
        i = s.index("")
        del s[i]
    else:
        print "new_tag_list has no empty string"
</code></pre>
<p>But this gives:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;pyshell#30&gt;", line 1, in &lt;module&gt;
    if new_tag_list.index(""):
        ValueError: list.index(x): x not in list
</code></pre>
<p>Why does this happen, and how do I work around it?</p>
</div>
<div class="post-text" itemprop="text">
<h2>1) Almost-English style:</h2>
<p>Test for presence using the <code>in</code> operator, then apply the <code>remove</code> method.</p>
<pre class="lang-py prettyprint-override"><code>if thing in some_list: some_list.remove(thing)
</code></pre>
<p>The <code>remove</code>method will remove only the first occurrence of <code>thing</code>, in order to remove all occurrences you can use <code>while</code> instead of <code>if</code>.</p>
<pre class="lang-py prettyprint-override"><code>while thing in some_list: some_list.remove(thing)    
</code></pre>
<ul>
<li>Simple enough, probably my choice.for small lists (can't resist one-liners)</li>
</ul>
<h2>2) <a href="http://docs.python.org/glossary.html#term-duck-typing" rel="noreferrer">Duck-typed</a>, <a href="http://docs.python.org/glossary.html#term-eafp" rel="noreferrer">EAFP</a> style:</h2>
<p>This shoot-first-ask-questions-last attitude is common in Python. Instead of testing in advance if the object is suitable, just carry out the operation and catch relevant Exceptions:</p>
<pre class="lang-py prettyprint-override"><code>try:
    some_list.remove(thing)
except ValueError:
    pass # or scream: thing not in some_list!
except AttributeError:
    call_security("some_list not quacking like a list!")
</code></pre>
<p>Off course the second except clause in the example above is not only of questionable humor but totally unnecessary (the point was to illustrate duck-typing for people not familiar with the concept).</p>
<p>If you expect multiple occurrences of thing:</p>
<pre class="lang-py prettyprint-override"><code>while True:
    try:
        some_list.remove(thing)
    except ValueError:
        break
</code></pre>
<ul>
<li>a little verbose for this specific use case, but very idiomatic in Python.</li>
<li>this performs better than #1</li>
<li><a href="http://www.python.org/dev/peps/pep-0463/" rel="noreferrer">PEP 463</a> proposed a shorter syntax for try/except simple usage that would be handy here, but it was not approved.</li>
</ul>
<p>However, with <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="noreferrer">contextlib's suppress() contextmanager</a> (introduced in python 3.4) the above code can be simplified to this:</p>
<pre class="lang-py prettyprint-override"><code>with suppress(ValueError, AttributeError):
    some_list.remove(thing)
</code></pre>
<p>Again, if you expect multiple occurrences of thing:</p>
<pre class="lang-py prettyprint-override"><code>with suppress(ValueError):
    while True:
        some_list.remove(thing)
</code></pre>
<h2>3) Functional style:</h2>
<p>Around 1993, Python got <code>lambda</code>, <code>reduce()</code>, <code>filter()</code> and <code>map()</code>, courtesy of a <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29" rel="noreferrer">Lisp</a> hacker who missed them and submitted working patches*. You can use <code>filter</code> to remove elements from the list:</p>
<pre class="lang-py prettyprint-override"><code>is_not_thing = lambda x: x is not thing
cleaned_list = filter(is_not_thing, some_list)
</code></pre>
<p>There is a shortcut that may be useful for your case: if you want to filter out empty items (in fact items where <code>bool(item) == False</code>, like <code>None</code>, zero, empty strings or other empty collections), you can pass None as the first argument:</p>
<pre class="lang-py prettyprint-override"><code>cleaned_list = filter(None, some_list)
</code></pre>
<ul>
<li><strong>[update]</strong>: in Python 2.x, <code>filter(function, iterable)</code> used to be equivalent to <code>[item for item in iterable if function(item)]</code> (or <code>[item for item in iterable if item]</code> if the first argument is <code>None</code>); in Python 3.x, it is now equivalent to <code>(item for item in iterable if function(item))</code>. The subtle difference is that filter used to return a list, now it works like a generator expression - this is OK if you are only iterating over the cleaned list and discarding it, but if you really need a list, you have to enclose the <code>filter()</code> call with the <code>list()</code> constructor.</li>
<li>*These Lispy flavored constructs are considered a little alien in Python. Around 2005, <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="noreferrer">Guido was even talking about dropping <code>filter</code></a> - along with companions <code>map</code> and <code>reduce</code> (they are not gone yet but <code>reduce</code> was moved into the <a href="http://docs.python.org/2/library/functools.html#functools.reduce" rel="noreferrer">functools</a> module, which is worth a look if you like <a href="http://en.wikipedia.org/wiki/Higher-order_function" rel="noreferrer">high order functions</a>).</li>
</ul>
<h2>4) Mathematical style:</h2>
<p><a href="http://en.wikipedia.org/wiki/List_comprehension" rel="noreferrer">List comprehensions</a> became the preferred style for list manipulation in Python since introduced in version 2.0 by <a href="http://www.python.org/dev/peps/pep-0202/" rel="noreferrer">PEP 202</a>. The rationale behind it is that List comprehensions provide a more concise way to create lists in situations where <code>map()</code> and <code>filter()</code> and/or nested loops would currently be used.</p>
<pre class="lang-py prettyprint-override"><code>cleaned_list = [ x for x in some_list if x is not thing ]
</code></pre>
<p>Generator expressions were introduced in version 2.4 by <a href="http://www.python.org/dev/peps/pep-0289/" rel="noreferrer">PEP 289</a>. A generator expression is better for situations where you don't really need (or want) to have a full list created in memory - like when you just want to iterate over the elements one at a time. If you are only iterating over the list, you can think of a generator expression as a <a href="http://en.wikipedia.org/wiki/Lazy_evaluation" rel="noreferrer">lazy evaluated</a> list comprehension:</p>
<pre class="lang-py prettyprint-override"><code>for item in (x for x in some_list if x is not thing):
    do_your_thing_with(item)
</code></pre>
<ul>
<li>See <a href="http://python-history.blogspot.com.br/2010/06/from-list-comprehensions-to-generator.html" rel="noreferrer">this Python history blog</a> post by <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" rel="noreferrer">GvR</a>.</li>
<li>This syntax is inspired by the <a href="http://en.wikipedia.org/wiki/Set-builder_notation" rel="noreferrer">set-builder notation</a> in math.</li>
<li>Python 3 has also <a href="http://www.python.org/dev/peps/pep-3100/#id103" rel="noreferrer">set</a> and <a href="http://www.python.org/dev/peps/pep-0274/" rel="noreferrer">dict comprehensions</a>.</li>
</ul>
<h2>Notes</h2>
<ol>
<li>you may want to use the inequality operator <code>!=</code> instead of <code>is not</code> (<a href="https://stackoverflow.com/q/2209755/">the difference is important</a>)</li>
<li>for critics of methods implying a list copy: contrary to popular belief, generator expressions are not always more efficient than list comprehensions - please profile before complaining</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<pre><code>try:
    s.remove("")
except ValueError:
    print "new_tag_list has no empty string"
</code></pre>
<p>Note that this will only remove one instance of the empty string from your list (as your code would have, too). Can your list contain more than one?</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>index</code> doesn't find the searched string, it throws the <code>ValueError</code> you're seeing. Either 
catch the ValueError:</p>
<pre><code>try:
    i = s.index("")
    del s[i]
except ValueError:
    print "new_tag_list has no empty string"
</code></pre>
<p><strong>or</strong> use <code>find</code>, which returns -1 in that case.</p>
<pre><code>i = s.find("")
if i &gt;= 0:
    del s[i]
else:
    print "new_tag_list has no empty string"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Eek, don't do anything that complicated : )</p>
<p>Just <code>filter()</code> your tags.  <code>bool()</code> returns <code>False</code> for empty strings, so instead of</p>
<pre><code>new_tag_list = f1.striplist(tag_string.split(",") + selected_tags)
</code></pre>
<p>you should write</p>
<pre><code>new_tag_list = filter(bool, f1.striplist(tag_string.split(",") + selected_tags))
</code></pre>
<p>or better yet, put this logic inside <code>striplist()</code> so that it doesn't return empty strings in the first place.</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding this answer for completeness, though it's only usable under certain conditions.</p>
<p>If you have very large lists, removing from the end of the list avoids CPython internals having to <code>memmove</code>, for situations where you can re-order the list. It gives a performance gain to remove from the end of the list, since it won't need to <code>memmove</code> <em>every</em> item after the one your removing - back one step <sup>(1)</sup>.<br/>
For one-off removals the performance difference may be acceptable, but if you have a large list and need to remove many items - you will likely notice a performance hit.</p>
<p>Although admittedly, in these cases, doing a full list search is likely to be a performance bottleneck too, unless items are mostly at the front of the list.</p>
<p>This method can be used for more efficient removal,<br/>as long as re-ordering the list is acceptable. <sup>(2)</sup></p>
<pre><code>def remove_unordered(ls, item):
    i = ls.index(item)
    ls[-1], ls[i] = ls[i], ls[-1]
    ls.pop()
</code></pre>
<p>You may want to avoid raising an error when the <code>item</code> isn't in the list.</p>
<pre><code>def remove_unordered_test(ls, item):
    try:
        i = ls.index(item)
    except ValueError:
        return False
    ls[-1], ls[i] = ls[i], ls[-1]
    ls.pop()
    return True
</code></pre>
<hr/>
<ol>
<li>While I tested this with CPython, its quite likely most/all other Python implementations use an array to store lists internally. So unless they use a sophisticated data structure designed for efficient list re-sizing, they likely have the same performance characteristic.</li>
</ol>
<blockquote>
<p>A simple way to test this, compare the speed difference from removing from the front of the list with removing the last element:</p>
<pre><code>python -m timeit 'a = [0] * 100000' 'while a: a.remove(0)'
</code></pre>
<p>With:</p>
<pre><code>python -m timeit 'a = [0] * 100000' 'while a: a.pop()'
</code></pre>
<p><em>(gives an order of magnitude speed difference where the second example is faster with CPython and PyPy).</em></p>
</blockquote>
<ol start="2">
<li>In this case you might consider using a <code>set</code>, especially if the list isn't meant to store duplicates.<br/>In practice though you may need to store mutable data which can't be added to a <code>set</code>. Also check on btree's if the data can be ordered.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Here's another one-liner approach to throw out there:</p>
<pre><code>next((some_list.pop(i) for i, l in enumerate(some_list) if l == thing), None)
</code></pre>
<p>It doesn't create a list copy, doesn't make multiple passes through the list, doesn't require additional exception handling, and returns the matched object or None if there isn't a match. Only issue is that it makes for a long statement.</p>
<p>In general, when looking for a one-liner solution that doesn't throw exceptions, next() is the way to go, since it's one of the few Python functions that supports a default argument.</p>
</div>
<div class="post-text" itemprop="text">
<p>All you have to do is this</p>
<pre><code>list = ["a", "b", "c"]
    try:
        list.remove("a")
    except:
        print("meow")
</code></pre>
<p>but that method has an issue. You have to put something in the except place
so i found this:</p>
<pre><code>list = ["a", "b", "c"]
if "a" in str(list):
    list.remove("a")
</code></pre>
</div>
<span class="comment-copy">@Zeynel: <a href="http://docs.python.org/library/stdtypes.html#mutable-sequence-types" rel="nofollow noreferrer">docs.python.org/library/stdtypes.html#mutable-sequence-types</a></span>
<span class="comment-copy">May I suggest omitting the AttributeError handling in (2)? It's distracting and not handled in the other sections (or other parts of the same section). Worse, someone might copy that code not realizing they're overly aggressively suppressing exceptions. The original question assumes a list, the answer should too.</span>
<span class="comment-copy">Is find() a list attribute? I am getting: <code>&gt;&gt;&gt; s [u'Hello', u'Cool', u'Glam'] &gt;&gt;&gt; i = s.find("")  Traceback (most recent call last):   File "&lt;pyshell#42&gt;", line 1, in &lt;module&gt;     i = s.find("") AttributeError: 'list' object has no attribute 'find'</code></span>
<span class="comment-copy">Time Pietscker's <code>remove()</code> approach is much more direct: it directly shows what the code is meant to do (there is indeed no need for an intermediate index <code>i</code>).</span>
<span class="comment-copy">@Zeynel no, it should be in every Python, see <a href="http://docs.python.org/library/string.html#string.find" rel="nofollow noreferrer">docs.python.org/library/string.html#string.find</a> . But as EOL pointed out, simply using remove is waaay better.</span>
<span class="comment-copy">Thanks! All good answers but I think I will be using this. This is my <code>striplist</code> function, how do I incorporate your solution: def striplist(l):     """strips whitespaces from strings in a list l"""     return([x.strip() for x in l])</span>
<span class="comment-copy">@Zeynel: sure.  You could either put a test inside your list comprehension like this: <code>[x.strip() for x in l if x.strip()]</code> or use Python's built-in <code>map</code> and <code>filter</code> functions like this: <code>filter(bool, map(str.strip, l))</code>.  If you want to test it out, evaluate this in the interactive interpreter: <code>filter(bool, map(str.strip, ['  a', 'b  ', '  c  ', '', '  ']))</code>.</span>
<span class="comment-copy">Filter has a shortcut for this case (evaluating the element in Boolean context): using <code>None</code> instead of <code>bool</code> for the first argument is enough.</span>
<span class="comment-copy">really useful remark about using sets</span>
<span class="comment-copy">You shouldn't overwrite the <a href="https://docs.python.org/2/library/functions.html" rel="nofollow noreferrer">list</a> built-in. And the converting to a string is not needed in the 2nd snippet.</span>
