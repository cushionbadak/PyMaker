<div class="post-text" itemprop="text">
<p>I am using a simple unit test based test runner to test my Django application.</p>
<p>My application itself is configured to use a basic logger in settings.py using:</p>
<pre><code>logging.basicConfig(level=logging.DEBUG)
</code></pre>
<p>And in my application code using:</p>
<pre><code>logger = logging.getLogger(__name__)
logger.setLevel(getattr(settings, 'LOG_LEVEL', logging.DEBUG))
</code></pre>
<p>However, when running unittests, I'd like to disable logging so that it doesn't clutter my test result output. Is there a simple way to turn off logging in a global way, so that the application specific loggers aren't writing stuff out to the console when I run tests?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>logging.disable(logging.CRITICAL)
</code></pre>
<p>will disable all logging calls with levels less severe than or equal to <code>CRITICAL</code>. Logging can be re-enabled with</p>
<pre><code>logging.disable(logging.NOTSET)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you are in Django, you could add these lines to your settings.py:</p>
<pre><code>import sys
import logging

if len(sys.argv) &gt; 1 and sys.argv[1] == 'test':
    logging.disable(logging.CRITICAL)
</code></pre>
<p>That way you don't have to add that line in every setUp() on your tests. :)</p>
<p>You could also do a couple of handy changes for your test needs this way.</p>
<p>There is another "nicer" or "cleaner" way to add specifics to your tests and that is making your own test runner.</p>
<p>Just create a class like this:</p>
<pre><code>import logging

from django.test.simple import DjangoTestSuiteRunner
from django.conf import settings

class MyOwnTestRunner(DjangoTestSuiteRunner):
    def run_tests(self, test_labels, extra_tests=None, **kwargs):

        # Don't show logging messages while testing
        logging.disable(logging.CRITICAL)

        return super(MyOwnTestRunner, self).run_tests(test_labels, extra_tests, **kwargs)
</code></pre>
<p>And now add to your settings.py file:</p>
<pre><code>TEST_RUNNER = "PATH.TO.PYFILE.MyOwnTestRunner"
#(for example, 'utils.mytest_runner.MyOwnTestRunner')
</code></pre>
<p>This lets you do one really handy modification that the other approach doesn't, which is to make Django just tests the applications that you want. You can do that by changing the test_labels adding this line to the test runner:</p>
<pre><code>if not test_labels:
    test_labels = ['my_app1', 'my_app2', ...]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like Hassek's custom test runner idea.  It should be noted that <code>DjangoTestSuiteRunner</code> is no longer the default test runner in Django 1.6+, it has been replaced by the <code>DiscoverRunner</code>.  For default behaviour, the test runner should be more like:</p>
<pre><code>import logging

from django.test.runner import DiscoverRunner

class NoLoggingTestRunner(DiscoverRunner):
    def run_tests(self, test_labels, extra_tests=None, **kwargs):

        # disable logging below CRITICAL while testing
        logging.disable(logging.CRITICAL)

        return super(NoLoggingTestRunner, self).run_tests(test_labels, extra_tests, **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a simple way to turn off logging in a global way, so that the application specific loggers aren't writing stuff out to the console when I run tests?</p>
</blockquote>
<p>The other answers prevent "writing stuff out to the console" by globally setting the logging infrastructure to ignore anything. This works but I find it too blunt an approach. My approach is to perform a configuration change which does only what's needed to prevent logs to get out on the console. So I add a <a href="https://docs.python.org/3/library/logging.html#filter-objects" rel="noreferrer">custom logging filter</a> to my <code>settings.py</code>:</p>
<pre><code>from logging import Filter

class NotInTestingFilter(Filter):

    def filter(self, record):
        # Although I normally just put this class in the settings.py
        # file, I have my reasons to load settings here. In many
        # cases, you could skip the import and just read the setting
        # from the local symbol space.
        from django.conf import settings

        # TESTING_MODE is some settings variable that tells my code
        # whether the code is running in a testing environment or
        # not. Any test runner I use will load the Django code in a
        # way that makes it True.
        return not settings.TESTING_MODE
</code></pre>
<p>And I <a href="https://docs.djangoproject.com/en/stable/topics/logging/#topic-logging-parts-filters" rel="noreferrer">configure the Django logging</a> to use the filter:</p>
<pre><code>LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'testing': {
            '()': NotInTestingFilter
        }
    },
    'formatters': {
        'verbose': {
            'format': ('%(levelname)s %(asctime)s %(module)s '
                       '%(process)d %(thread)d %(message)s')
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'filters': ['testing'],
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'foo': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': True,
        },
    }
}
</code></pre>
<p>End result: when I'm testing, nothing goes to the console, but everything else stays the same.</p>
<h3>Why Do This?</h3>
<p>I design code that contains logging instructions that are triggered only in specific circumstances and that should output the exact data I need for diagnosis if things go wrong. Therefore I <em>test</em> that they do what they are supposed to do and thus completely disabling logging is not viable for me. I don't want to find once the software is in production that what I <em>thought</em> would be logged is not logged.</p>
<p>Moreover, some test runners (Nose, for instance) will capture logs during testing and output the relevant part of the log together with a test failure. It is useful in figuring out why a test failed. If logging is completely turned off, then there's nothing that can be captured.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is some pretty and clean method to suspend logging in tests with <code>unittest.mock.patch</code> method.</p>
<p><strong>foo.py</strong>:
</p>
<pre><code>import logging


logger = logging.getLogger(__name__)

def bar():
    logger.error('There is some error output here!')
    return True
</code></pre>
<p><strong>tests.py</strong>:
</p>
<pre><code>from unittest import mock, TestCase
from foo import bar


class FooBarTestCase(TestCase):
    @mock.patch('foo.logger', mock.Mock())
    def test_bar(self):
        self.assertTrue(bar())
</code></pre>
<p>And <code>python3 -m unittest tests</code> will produce no logging output.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've found that for tests within <code>unittest</code> or similar a framework, the most effective way to safely disable unwanted logging in unit tests is to enable/disable in the <code>setUp</code>/<code>tearDown</code> methods of a particular test case.  This lets one target specifically where logs should be disabled.  You could also do this explicitly on the logger of the class you're testing.</p>
<pre><code>import unittest
import logging

class TestMyUnitTest(unittest.TestCase):
    def setUp(self):
        logging.disable(logging.CRITICAL)

    def tearDown(self):
        logging.disable(logging.NOTSET)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes you want the logs and sometimes not. I have this code in my <code>settings.py</code></p>
<pre><code>import sys

if '--no-logs' in sys.argv:
    print('&gt; Disabling logging levels of CRITICAL and below.')
    sys.argv.remove('--no-logs')
    logging.disable(logging.CRITICAL)
</code></pre>
<p>So if you run your test with the <code>--no-logs</code> options you'll get only the <code>critical</code> logs:</p>
<pre><code>$ python ./manage.py tests --no-logs
&gt; Disabling logging levels of CRITICAL and below.
</code></pre>
<p>It's very helpful if you want speedup the tests on your continuous integration flow.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am using a simple method decorator to disable logging only in a particular test method.</p>
<pre><code>def disable_logging(f):

    def wrapper(*args):
        logging.disable(logging.CRITICAL)
        result = f(*args)
        logging.disable(logging.NOTSET)

        return result

    return wrapper
</code></pre>
<p>And then I use it as in the following example:</p>
<pre><code>class ScenarioTestCase(TestCase):

    @disable_logging
    test_scenario(self):
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In my case I have a settings file  <code>settings/test.py</code> created specifically for testing purposes, here's what it looks like:</p>
<pre><code>from .base import *

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'test_db'
    }
}

PASSWORD_HASHERS = (
    'django.contrib.auth.hashers.MD5PasswordHasher',
)

LOGGING = {}
</code></pre>
<p>I put an environment variable <code>DJANGO_SETTINGS_MODULE=settings.test</code> to <code>/etc/environment</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want it repeatedly turn it on/off in setUp() and tearDown() for unittest (don't see the reason for that), you could just do it once per class:</p>
<pre class="lang-py prettyprint-override"><code>    import unittest
    import logging

    class TestMyUnitTest(unittest.TestCase):
        @classmethod
        def setUpClass(cls):
            logging.disable(logging.CRITICAL)
        @classmethod
        def tearDownClass(cls):
            logging.disable(logging.NOTSET)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have different initaliser modules for test, dev and production then you can disable anything or reddirect it in the initialser. I have local.py, test.py and production.py that all inherit from common.y</p>
<p>common.py does all the main config including this snippet :</p>
<pre><code>LOGGING = {
'version': 1,
'disable_existing_loggers': False,
'formatters': {
    'django.server': {
        '()': 'django.utils.log.ServerFormatter',
        'format': '[%(server_time)s] %(message)s',
    },
    'verbose': {
        'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'
    },
    'simple': {
        'format': '%(levelname)s %(message)s'
    },
},
'filters': {
    'require_debug_true': {
        '()': 'django.utils.log.RequireDebugTrue',
    },
},
'handlers': {
    'django.server': {
        'level': 'INFO',
        'class': 'logging.StreamHandler',
        'formatter': 'django.server',
    },
    'console': {
        'level': 'DEBUG',
        'class': 'logging.StreamHandler',
        'formatter': 'simple'
    },
    'mail_admins': {
        'level': 'ERROR',
        'class': 'django.utils.log.AdminEmailHandler'
    }
},
'loggers': {
    'django': {
        'handlers': ['console'],
        'level': 'INFO',
        'propagate': True,
    },
    'celery.tasks': {
        'handlers': ['console'],
        'level': 'DEBUG',
        'propagate': True,
    },
    'django.server': {
        'handlers': ['django.server'],
        'level': 'INFO',
        'propagate': False,
    },
}
</code></pre>
<p>Then in test.py I have this:</p>
<pre><code>console_logger = Common.LOGGING.get('handlers').get('console')
console_logger['class'] = 'logging.FileHandler
console_logger['filename'] = './unitest.log
</code></pre>
<p>This replaces the console handler with a FileHandler and means still get logging but I do not have to touch the production code base.</p>
</div>
<span class="comment-copy">How did you enable logging whilst running tests? and why aren't you using django LOGGING?</span>
<span class="comment-copy">This may be obvious but I find it helpful to sometimes state the obvious for the benefit of other readers: You would put the call to <code>logging.disable</code> (from the accepted answer) at the top of <code>tests.py</code> in your application that is doing the logging.</span>
<span class="comment-copy">I ended up putting the call in setUp() but your point is well taken.</span>
<span class="comment-copy">in the setUp() method of your test, or in the actual test that generates the log messages that you want to hide.</span>
<span class="comment-copy">And in your <code>tearDown()</code> method: <code>logging.disable(logging.NOTSET)</code> puts the logging back in place neatly.</span>
<span class="comment-copy">Putting it in the <b>init</b>.py of the <code>tests</code> module is very useful.</span>
<span class="comment-copy">Sure - putting it in settings.py would make it global.</span>
<span class="comment-copy">for Django 1.6+ please check @alukach answer.</span>
<span class="comment-copy">Sometimes in unit tests, I want to assert that an error was logged thus this method is not ideal.  Still, it <i>is</i> a good answer.</span>
<span class="comment-copy">I found your solution after trying a lot of things. However I am not able to set the variable TEST_RUNNER in settings as its not able to import the module where the test_runner file is.</span>
<span class="comment-copy">Sounds like an import issue. Are you setting TEST_RUNNER to a string path to the runner (not the actual Python module)?  Also, where is your runner located? I have mine in a separate app named <code>helpers</code>, which only has utils that don't import from anywhere else within the project.</span>
<span class="comment-copy">"Any test runner I use will load the Django code in a way that makes it True." Interesting... How?</span>
<span class="comment-copy">I have a <code>test_settings.py</code> file which sits next to my project's <code>settings.py</code>. It is set to load <code>settings.py</code> and make some changes like set <code>TESTING_MODE</code> to <code>True</code>. My test runners are organized so that <code>test_settings</code> is the module loaded for the Django project settings. There are many ways this can be done. I usually go with setting the environment variable <code>DJANGO_SETTINGS_MODULE</code> to <code>proj.test_settings</code>.</span>
<span class="comment-copy">This is awesome and does exactly what I want.  Hides the logging during unittests until something fails -- then Django Nose picks up the output and prints it with the failure.  Perfect.  Combine it with  <a href="http://stackoverflow.com/a/6960879/2077386">this</a> to determine whether unit testing is active.</span>
