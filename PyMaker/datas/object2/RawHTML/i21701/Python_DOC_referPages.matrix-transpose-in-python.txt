<div class="post-text" itemprop="text">
<p>I am trying to create a matrix transpose function for python but I can't seem to make it work.
Say I have </p>
<pre><code>theArray = [['a','b','c'],['d','e','f'],['g','h','i']]
</code></pre>
<p>and I want my function to come up with</p>
<pre><code>newArray = [['a','d','g'],['b','e','h'],['c', 'f', 'i']]
</code></pre>
<p>So in other words, if I were to print this 2D array as columns and rows I would like the rows to turn into columns and columns into rows.</p>
<p>I made this so far but it doesn't work</p>
<pre><code>def matrixTranspose(anArray):
    transposed = [None]*len(anArray[0])
    for t in range(len(anArray)):
        for tt in range(len(anArray[t])):
            transposed[t] = [None]*len(anArray)
            transposed[t][tt] = anArray[tt][t]
    print transposed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 2:</p>
<pre><code>&gt;&gt;&gt; theArray = [['a','b','c'],['d','e','f'],['g','h','i']]
&gt;&gt;&gt; zip(*theArray)
[('a', 'd', 'g'), ('b', 'e', 'h'), ('c', 'f', 'i')]
</code></pre>
<p>Python 3:</p>
<pre><code>&gt;&gt;&gt; [*zip(*theArray)]
[('a', 'd', 'g'), ('b', 'e', 'h'), ('c', 'f', 'i')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; theArray = [['a','b','c'],['d','e','f'],['g','h','i']]
&gt;&gt;&gt; [list(i) for i in zip(*theArray)]
[['a', 'd', 'g'], ['b', 'e', 'h'], ['c', 'f', 'i']]
</code></pre>
<p>the list generator creates a new 2d array with list items instead of tuples.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your rows are not equal you can also use <code>map</code>:</p>
<pre><code>&gt;&gt;&gt; uneven = [['a','b','c'],['d','e'],['g','h','i']]
&gt;&gt;&gt; map(None,*uneven)
[('a', 'd', 'g'), ('b', 'e', 'h'), ('c', None, 'i')]
</code></pre>
<p>Edit: In Python 3 the functionality of <code>map</code> changed, <code>itertools.zip_longest</code> can be used instead:<br/>
  Source: <a href="http://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="noreferrer">What’s New In Python 3.0</a></p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; uneven = [['a','b','c'],['d','e'],['g','h','i']]
&gt;&gt;&gt; list(itertools.zip_longest(*uneven))
[('a', 'd', 'g'), ('b', 'e', 'h'), ('c', None, 'i')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Much easier with numpy:</p>
<pre><code>&gt;&gt;&gt; arr = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; arr
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; arr.T
array([[1, 4, 7],
       [2, 5, 8],
       [3, 6, 9]])
&gt;&gt;&gt; theArray = np.array([['a','b','c'],['d','e','f'],['g','h','i']])
&gt;&gt;&gt; theArray 
array([['a', 'b', 'c'],
       ['d', 'e', 'f'],
       ['g', 'h', 'i']], 
      dtype='|S1')
&gt;&gt;&gt; theArray.T
array([['a', 'd', 'g'],
       ['b', 'e', 'h'],
       ['c', 'f', 'i']], 
      dtype='|S1')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your original code was that you initialized <code>transpose[t]</code> at every element, rather than just once per row:</p>
<pre><code>def matrixTranspose(anArray):
    transposed = [None]*len(anArray[0])
    for t in range(len(anArray)):
        transposed[t] = [None]*len(anArray)
        for tt in range(len(anArray[t])):
            transposed[t][tt] = anArray[tt][t]
    print transposed
</code></pre>
<p>This works, though there are more Pythonic ways to accomplish the same things, including @J.F.'s <code>zip</code> application.</p>
</div>
<div class="post-text" itemprop="text">
<p>To complete J.F. Sebastian's answer, if you have a list of lists with different lengths, check out <a href="http://code.activestate.com/recipes/410687-transposing-a-list-of-lists-with-different-lengths/" rel="nofollow noreferrer">this great post from ActiveState</a>. In short:</p>
<blockquote>
<p>The built-in function zip does a similar job, but truncates the result
  to the length of the shortest list, so some elements from the original
  data may be lost afterwards. </p>
</blockquote>
<p>To handle list of lists with different lengths, use:</p>
<pre><code>def transposed(lists):
   if not lists: return []
   return map(lambda *row: list(row), *lists)

def transposed2(lists, defval=0):
   if not lists: return []
   return map(lambda *row: [elem or defval for elem in row], *lists)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The "best" answer has already been submitted, but I thought I would add that you can use nested list comprehensions, as seen in the <a href="http://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions" rel="nofollow">Python Tutorial</a>.  </p>
<p>Here is how you could get a transposed array:</p>
<pre><code>def matrixTranspose( matrix ):
    if not matrix: return []
    return [ [ row[ i ] for row in matrix ] for i in range( len( matrix[ 0 ] ) ) ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one will preserve rectangular shape, so that subsequent transposes will get the right result:</p>
<pre><code>import itertools
def transpose(list_of_lists):
  return list(itertools.izip_longest(*list_of_lists,fillvalue=' '))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def matrixTranspose(anArray):
  transposed = [None]*len(anArray[0])

  for i in range(len(transposed)):
    transposed[i] = [None]*len(transposed)

  for t in range(len(anArray)):
    for tt in range(len(anArray[t])):            
        transposed[t][tt] = anArray[tt][t]
  return transposed

theArray = [['a','b','c'],['d','e','f'],['g','h','i']]

print matrixTranspose(theArray)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>#generate matrix
matrix=[]
m=input('enter number of rows, m = ')
n=input('enter number of columns, n = ')
for i in range(m):
    matrix.append([])
    for j in range(n):
        elem=input('enter element: ')
        matrix[i].append(elem)

#print matrix
for i in range(m):
    for j in range(n):
        print matrix[i][j],
    print '\n'

#generate transpose
transpose=[]
for j in range(n):
    transpose.append([])
    for i in range (m):
        ent=matrix[i][j]
        transpose[j].append(ent)

#print transpose
for i in range (n):
    for j in range (m):
        print transpose[i][j],
    print '\n'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a=[]
def showmatrix (a,m,n):
    for i in range (m):
        for j in range (n):
            k=int(input("enter the number")
            a.append(k)      
print (a[i][j]),

print('\t')


def showtranspose(a,m,n):
    for j in range(n):
        for i in range(m):
            print(a[i][j]),
        print('\t')

a=((89,45,50),(130,120,40),(69,79,57),(78,4,8))
print("given matrix of order 4x3 is :")
showmatrix(a,4,3)


print("Transpose matrix is:")
showtranspose(a,4,3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def transpose(matrix):
   x=0
   trans=[]
   b=len(matrix[0])
   while b!=0:
       trans.append([])
       b-=1
   for list in matrix:
       for element in list:
          trans[x].append(element)
          x+=1
       x=0
   return trans
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def transpose(matrix):
    listOfLists = []
    for row in range(len(matrix[0])):
        colList = []
        for col in range(len(matrix)):
            colList.append(matrix[col][row])
    listOfLists.append(colList)

    return listOfLists
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>`</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>def transpose(m):
    return(list(map(list,list(zip(*m)))))</code></pre>
</div>
</div>
</p>
<p>`This function will return the transpose</p>
</div>
<div class="post-text" itemprop="text">
<p>Python Program to transpose matrix:</p>
<pre><code>row,col = map(int,input().split())
matrix = list()

for i in range(row):
    r = list(map(int,input().split()))
    matrix.append(r)

trans = [[0 for y in range(row)]for x in range(col)]

for i in range(len(matrix[0])):
    for j in range(len(matrix)):
        trans[i][j] = matrix[j][i]     

for i in range(len(trans)):
    for j in range(len(trans[0])):
        print(trans[i][j],end=' ')
    print(' ')
</code></pre>
</div>
<span class="comment-copy">if you're going to iterate through the results, <code>izip</code> from <code>itertools</code> can save memory for large arrays.</span>
<span class="comment-copy">How would you have it return a list for the sub lists? Like <code>[['a', 'b', 'g'], ['d', 'e', 'h'], ['c', 'f', 'i']]</code> instead of <code>[('a', 'd', 'g'), ('b', 'e', 'h'), ('c', 'f', 'i')]</code>?</span>
<span class="comment-copy">@acollection_: <code>map(list, zip(*theArray))</code>.</span>
<span class="comment-copy">Why the asterisk?</span>
<span class="comment-copy">@jfs: Any particular reason you rolled back the answer to a state that only supports Python 2?</span>
<span class="comment-copy">This is the way to go if you want to assign the result to a variable (as opposed to, e.g., iterating over it directly) — assuming you want lists instead of tuples, as mentioned.</span>
<span class="comment-copy">Another option (as implied by the comments in the accepted answer) would be: <code>list(map(list, zip(*theArray)))</code></span>
<span class="comment-copy">@pbfy0 Maybe <code>lambda *x:x</code> will work in place of <code>None</code></span>
<span class="comment-copy">That's good catch. However, matrices doesn't have lists with different lengths.</span>
<span class="comment-copy">It depends on how they are stored.</span>
<span class="comment-copy">Welcome on SO, please explain your code.</span>
<span class="comment-copy">Its a simple implementation for a transpose, though there are libraries like mentioned in other answers are also available.</span>
