<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/4152376/how-to-get-the-n-next-values-of-a-generator-in-a-list-python">How to get the n next values of a generator in a list (python)</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>With <a class="post-tag" href="/questions/tagged/linq" rel="tag" title="show questions tagged 'linq'">linq</a> I would</p>
<pre><code>var top5 = array.Take(5);
</code></pre>
<p>How to do this with Python?</p>
</div>
<div class="post-text" itemprop="text">
<h1>Slicing a list</h1>
<pre><code>top5 = array[:5]
</code></pre>
<ul>
<li>To slice a list, there's a simple syntax: <code>array[start:stop:step]</code></li>
<li>You can omit any parameter. These are all valid: <code>array[start:]</code>, <code>array[:stop]</code>, <code>array[::step]</code></li>
</ul>
<h1>Slicing a generator</h1>
<pre><code> import itertools
 top5 = itertools.islice(my_list, 5) # grab the first five elements
</code></pre>
<ul>
<li><p>You can't slice a generator directly in Python. <a href="http://docs.python.org/library/itertools.html#itertools.islice" rel="noreferrer"><code>itertools.islice()</code></a> will wrap an object in a new slicing generator using the syntax <code>itertools.islice(generator, start, stop, step)</code></p></li>
<li><p>Remember, slicing a generator will exhaust it partially. If you want to keep the entire generator intact, perhaps turn it into a tuple or list first, like: <code>result = tuple(generator)</code></p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

top5 = itertools.islice(array, 5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In my taste, it's also very concise to combine 'zip()' with 'xrange(n)' (or 'range(n)' in Python3), which works nice on generators as well and seems to be more flexible for changes in general.</p>
<pre><code># Option #1: taking the first n elements as a list
[x for _, x in zip(xrange(n), generator)]

# Option #2, using 'next()' and taking care for 'StopIteration'
[next(generator) for _ in xrange(n)]

# Option #3: taking the first n elements as a new generator
(x for _, x in zip(xrange(n), generator))

# Option #4: yielding them by simply preparing a function
# (but take care for 'StopIteration')
def top_n(n, generator):
    for _ in xrange(n): yield next(generator)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@Shaikovsky's answer is excellent (<em>â€¦and heavily edited since I posted this answer</em>), but I wanted to clarify a couple of points.</p>
<p><code>[next(generator) for _ in range(n)]</code></p>
<p>This is the most simple approach, but throws <code>StopIteration</code> if the generator is prematurely exhausted.</p>
<hr/>
<p>On the other hand, the following approaches return <strong>up to</strong> <code>n</code> items which is arguably preferable in most circumstances:</p>
<p>List:
<code>[x for _, x in zip(range(n), records)]</code></p>
<p>Generator:
<code>(x for _, x in zip(range(n), records))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The answer for how to do this can be found <a href="https://stackoverflow.com/questions/4152376/how-to-get-the-n-next-values-of-a-generator-in-a-list-python">here</a></p>
<pre><code>&gt;&gt;&gt; generator = (i for i in xrange(10))
&gt;&gt;&gt; list(next(generator) for _ in range(4))
[0, 1, 2, 3]
&gt;&gt;&gt; list(next(generator) for _ in range(4))
[4, 5, 6, 7]
&gt;&gt;&gt; list(next(generator) for _ in range(4))
[8, 9]
</code></pre>
<p>Notice that the last call asks for the next 4 when only 2 are remaining.  The use of the <code>list()</code> instead of <code>[]</code> is what gets the comprehension to terminate on the <code>StopIteration</code> exception that is thrown by <code>next()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do you mean the <em>first</em> N items, or the N <em>largest</em> items?</p>
<p>If you want the first:</p>
<pre><code>top5 = sequence[:5]
</code></pre>
<p>This also works for the largest N items, assuming that your sequence is sorted in descending order. (Your LINQ example seems to assume this as well.)</p>
<p>If you want the largest, and it isn't sorted, the most obvious solution is to sort it first:</p>
<pre><code>l = list(sequence)
l.sort(reverse=True)
top5 = l[:5]
</code></pre>
<p>For a more performant solution, use a min-heap (thanks Thijs):</p>
<pre><code>import heapq
top5 = heapq.nlargest(5, sequence)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <code>itertools</code> you will obtain another generator object so in most of the cases you will need another step the take the first N elements (<code>N</code>). There are at least two simpler solutions (a little bit less efficient in terms of performance but very handy) to get the elements ready to use from a <code>generator</code>:</p>
<p>Using list comprehension:</p>
<pre><code>first_N_element=[generator.next() for i in range(N)]
</code></pre>
<p>Otherwise:</p>
<pre><code>first_N_element=list(generator)[:N]
</code></pre>
<p>Where <code>N</code> is the number of elements you want to take (e.g. N=5 for the first five elements).</p>
</div>
<div class="post-text" itemprop="text">
<p>This should work</p>
<pre><code>top5 = array[:5] 
</code></pre>
</div>
<span class="comment-copy">It is confusing that this question was asked for both lists and generators, these should have been separate questions</span>
<span class="comment-copy">Also note that <code>itertools.islice</code> will return a generator.</span>
<span class="comment-copy">The question was "generator or list". These have two different answers. <code>islice</code> is the wrong answer for a list, but the right answer for a generator. I cleaned up the answer a bit to make this more clear.</span>
<span class="comment-copy">GOOD Strategy..</span>
<span class="comment-copy">"If you want to keep the entire generator intact, perhaps turn it into a tuple or list first" -&gt; won't that exhaust the generator fully, in the process of building up the tuple / list?</span>
<span class="comment-copy">@lucid_dreamer yes, but then you have a new data structure (tuple/list) that you can iterate over as much as you like</span>
<span class="comment-copy">This also has the nice property of returning the entire array when you have None in place of 5.</span>
<span class="comment-copy">and if you want to take the five that follows each time you can use: iter(array) instead of array.</span>
<span class="comment-copy">note that if your generator exhausts this will not make an error, you will get a many elements as the generator had left, less than your request size.</span>
<span class="comment-copy">This is the approach used in the following: <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">Itertools recipes</a> <code>def take(n, iterable): return list(islice(iterable, n))</code></span>
<span class="comment-copy">Could those few people downvoting this answer please explain why?</span>
<span class="comment-copy">def take(num,iterable): return([elem for _ , elem in zip(range(num), iterable)])</span>
<span class="comment-copy">Above code: Loop over an iterable which could be a generator or list and return up to n elements from iterable. In case n is greater or equal to number of items existing in iterable then return all elements in iterable.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/a/4152713/5353461">Caveats on some python versions</a></span>
<span class="comment-copy">wouldn't the smaller come first?</span>
<span class="comment-copy">Erm, whoops. Will fix.</span>
<span class="comment-copy">+1 for answering despite the obvious ambiguity of the question</span>
<span class="comment-copy"><code>import heapq; top5 = heapq.nlargest(5, iterable)</code></span>
<span class="comment-copy">use <i>sequence</i> instead of <i>iterable</i>. Some <i>iterables</i> do not support indexing. Every <i>sequence</i> is an <i>iterable</i>, but some <i>iterables</i> are not sequences.</span>
