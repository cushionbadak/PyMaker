<div class="post-text" itemprop="text">
<p>I am trying to call my class file from another file, instantiate the object (which works) - and then fire one of the functions in my 2nd file (which doesnt work).</p>
<p>I get an error when I try and call one of the functions in the second file. I think I understand why that happens, as the instance was created in file 1, and that file 1 doesnt have access to the
method from the second file (create_account). But is there any way around it?</p>
<p>I can get it to work if I add the class definitions in the second file. But I was thinking my design would be better if I keep them in the first file</p>
<p>The error would be for example -</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "C:\Users\hassy\Google Drive\Python\bnk\bank_account\database.py", line 130, in &lt;module&gt;
    obj1.Database.create_account("Frank Sanchez", 135063543, 2380, 100, 'bank_account')
AttributeError: 'BankAccount' object has no attribute 'Database'
</code></pre>
<hr/>
<pre><code>class BankAccount:
    def __init__(self, name, social, account_number, balance, acctype):
        self.name = name
        self.social = social
        self.account_number = account_number
        self.balance = balance
        self.acctype = acctype


class CreditCard(BankAccount):
    def __init__(self, name, social, account_number, balance, acctype, card_no, credit_score=None, credit_limit=None):
        super().__init__(name, social, account_number, balance, acctype)
        self.card_no = card_no
        self.credit_score = credit_score
        self.credit_limit = credit_limit

class SavingsAccount(BankAccount):
    def __init__(self, name, social, account_number, balance, acctype, rate=None):
        super().__init__(name, social, account_number, balance, acctype)
        self.rate = None
</code></pre>
<p>Database file (second file) -</p>
<pre><code>import sqlite3
import secrets
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import send_email
#import account
from account import BankAccount
from account import CreditCard

conn = sqlite3.connect('bank_account.db')
c = conn.cursor()



def create_account(self, name, social, account_number, balance, acctype, card_no=None, credit_score=None, credit_limit=None):
    """ create different accounts based on account type passed in """

    with conn:

        if acctype == 'bank_account':
            c.execute("INSERT INTO {} VALUES (:name, :social, :account_number, :balance, :pin)".format(acctype),
                      {'name':name, 'social': social,'account_number': account_number, 'balance':balance, 'pin':''})
            print("New account: {} has been created, acc # is: {}".format(acctype, account_number))

        elif acctype == 'savings_account':
            c.execute("INSERT INTO {} VALUES (:name, :social, :account_number, :balance, :rate)".format(acctype),
                  {'name':name, 'social': social,'account_number': account_number, 'balance':balance, 'rate':''})
            print("New account: {} has been created, acc # is: {}".format(acctype, account_number))

        elif acctype == 'credit_card':
            c.execute("INSERT INTO credit_card VALUES (:name, :social, :account_number, :balance, :card_no,:credit_score, :credit_limit, :pin)",
              {'name':name, 'social': social,'account_number': account_number, 'balance':balance, 'card_no'
               :card_no, 'credit_score':credit_score, 'credit_limit':credit_limit, 'pin':'' })
            print("New account: {} has been created, acc # is: {}".format(acctype, account_number))
    conn.commit()

def get_account(self,account_number, acctype):
    """ Show all rows in DB for the the account type passed in """
    with conn:
        account_find = c.execute("SELECT * from {} WHERE account_number=:account_number".format(acctype),
                                 {'account_number':account_number})
        account_found = c.fetchone()
        if not account_found:
            print("No {} matching that number could be found".format(acctype))
        else:
            print("Account type: {} exists!".format(acctype))
            print(account_found)
    return(account_found)

def get_balance(self, account_number, acctype):
    """ get balance from account """
    with conn:
        balance = c.execute("SELECT balance from {} WHERE account_number=:account_number".format(acctype),
                            {'account_number':account_number})
        balance = c.fetchone()
        print("The balance for account number: {} is ${}".format(account_number, balance[0]))
        notif_set = BankAccount.get_notif(self, account_number, acctype)
        if notif_set is None:
            print("No notifications are set for this user")
        else:
            notif_balance = notif_set[4]
            name = notif_set[0]
            if notif_balance == 1:
                notify = send_email.send_email(account_number, acctype, 'Balance', balance, balance, name)

    return(balance[0])


def deposit(self, account_number, acctype, amount):
    """ Deposit funds into the account number + acctype for the account passed in """
    with conn:

        account_found = BankAccount.get_account(self, account_number, acctype)
        if account_found:
            existing_bal = account_found[3]
            c.execute("""UPDATE {} SET balance=balance +:amount
                    WHERE account_number =:account_number""".format(acctype),
                      {'account_number':account_number, 'amount':amount})
            new_bal = existing_bal + (int(amount))
            print("${} has been deposited to account {} and the new balance is ${}".format(amount, account_number, existing_bal + (int(amount))))

           # Check email configurations are turned on for deposits
            notif_set = notifications.get_notif(self, account_number, acctype)
            if notif_set is None:
                print("No notifications are set for this user")
            else:
                notif_deposits = notif_set[5]
                name = notif_set[0]
                if notif_deposits == 1:
                    notify = send_email.send_email(account_number, acctype, 'Deposit', amount, new_bal, name)


def withdraw(self, account_number, acctype, amount):
    """ withdraw funds from the bank account number passed in """
    with conn:

        account_found = BankAccount.get_account(self, account_number, acctype)
        existing_bal = account_found[3]

        if account_found:
            c.execute("""UPDATE bank_account SET balance=balance -:amount
                    WHERE account_number =:account_number""",
                      {'account_number':account_number, 'amount':amount})
            new_bal = existing_bal - (int(amount))
            conn.commit()
            print("${} has been withdrawn from account {} and the new balance is ${}".format(amount, account_number, existing_bal - (int(amount))))

            notif_set = BankAccount.get_notif(self, account_number, acctype)
            if notif_set is None:
                print("No notifications have been set for this acct")
            else:
                notif_withdraw = notif_set[7]
                name = notif_set[0]
                if notif_withdraw == 1:
                    notify = send_email.send_email(account_number, acctype, 'Withdraw', amount, new_bal, name)
        else:
            print("Withdrawl notifications have been turned off")
        if account_found and new_bal &lt; 0 and notif_set is not None:
            notify_o = send_email.send_email(account_number, acctype, 'Overdraft', amount, new_bal, name)
        conn.commit()


if __name__ == '__main__':
    obj1 = BankAccount("Frank Sanchez", 135063543, 2380, 100, 'bank_account')
    obj1.Database.create_account("Frank Sanchez", 135063543, 2380, 100, 'bank_account')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p> I think I understand why that happens, as the instance was created in file 1, and that file 1 doesnt have access to the method from the second file (create_account).</p>
</blockquote>
<p>That's not exactly the issue - it's not that the instance does not have access to the method because it is in another file, but rather that the method is defined for a different class altogether.</p>
<p>When you write <code>obj1 = BankAccount()</code>, you put the reference to a <code>BankAccount</code> instance into the variable <code>obj1</code>. Then when you write <code>obj1.Database. ...</code> Python tries to access a method called <code>Database</code> from your <code>obj1</code>, i.e. a <code>BankAccount</code>. Since you did not define a method called <code>Database</code> on your <code>BankAccount</code> class back at file 1, the error is thrown.</p>
<p>If you want to create interactions between instances of different classes, you need to "connect" them somehow. Normally this is done by either passing an instance of an object A to a method called on an <em>instance of a different object B</em>, or by explicitly creating an instance of an object A inside the method of an object B. Consider this example that shows this:</p>
<pre><code>class Account:
    pass

class Database:
    def __init__(self):
        self.accounts = []

    def add_account(self, acc):
        if not isinstance(acc, Account):
            raise TypeError("bad input")
        self.accounts.append(acc)

    def create_default_account(self)
        default_account = Account()
        self.accounts.append(default_account)

account = Account()
db = Database()

# passes an Account object as an argument to 
# a Database object method call
db.add_account(account)

# calls a Database object method which internally 
# creates and processes an Account object
db.create_default_account()        
</code></pre>
<p>Note that this example code is written on a single file, but it would work just as well on two separate files as long as the corresponding imports are properly done.</p>
</div>
<span class="comment-copy">It will be helpful to understand better if you could include the code for  BankAccount.Database() too in your question</span>
<span class="comment-copy">edited, and added, that 2nd file I referred to is the database file</span>
<span class="comment-copy">Your <code>BankAccount</code> class has no attribute named 'Database' — exactly what the error says. <code>obj1</code> is an instance of that class.</span>
<span class="comment-copy">You are performing obj1.Database.create_account(). But obj1 is an object of BankAccount class, so it can only access the methods of BankAccount. There is no method called Database() inside that class, it has only the init method, that is why you are getting the error.</span>
<span class="comment-copy">I understand that...I am trying to find a workaround so that I can instantiate the class from one file, and then use the methods in a second file to make the call to the database</span>
