<div class="post-text" itemprop="text">
<p>I have a file called foobar (without .py extension). In the same directory I have another python file that tries to import it:</p>
<pre><code>import foobar
</code></pre>
<p>But this only works if I rename the file to foobar.py. Is it possible to import a python module that doesn't have the .py extension?</p>
<p>Update: the file has no extension because I also use it as a standalone script, and I don't want to type the .py extension to run it. </p>
<p>Update2: I will go for the symlink solution mentioned below.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>imp.load_source</code> function (from the <code>imp</code> module), to load a module dynamically from a given file-system path.</p>
<pre><code>foobar = imp.load_source('foobar', '/path/to/foobar')
</code></pre>
<p>This <a href="https://stackoverflow.com/questions/301134/dynamic-module-import-in-python">SO discussion</a> also shows some interesting options.</p>
</div>
<div class="post-text" itemprop="text">
<p>Like others have mentioned, you could use imp.load_source, but it will make your code more difficult to read.  I would really only recommend it if you need to import modules whose names or paths aren't known until run-time.</p>
<p>What is your reason for not wanting to use the .py extension?  The most common case for not wanting to use the .py extension, is because the python script is also run as an executable, but you still want other modules to be able to import it.  If this is the case, it might be beneficial to move functionality into a .py file with a similar name, and then use <code>foobar</code> as a wrapper.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>imp.load_source(module_name, path)</code> should do or you can do the more verbose <code>imp.load_module(module_name, file_handle, ...)</code> route if you have a file handle instead</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution for Python 3.4+:</p>
<pre><code>from importlib.util import spec_from_loader, module_from_spec
from importlib.machinery import SourceFileLoader 

spec = spec_from_loader("foobar", SourceFileLoader("foobar", "/path/to/foobar"))
foobar = module_from_spec(spec)
spec.loader.exec_module(foobar)
</code></pre>
<p>Using <a href="https://docs.python.org/3/library/importlib.html#importlib.util.spec_from_loader" rel="noreferrer"><code>spec_from_loader</code></a> and explicitly specifying a <a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.SourceFileLoader" rel="noreferrer"><code>SourceFileLoader</code></a> will force the <a href="https://docs.python.org/3/library/importlib.html#module-importlib.machinery" rel="noreferrer">machinery</a> to load the file as source, without trying to figure out the type of the file from the extension. This means that you can load the file even though it is not listed in <a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.SOURCE_SUFFIXES" rel="noreferrer"><code>importlib.machinery.SOURCE_SUFFIXES</code></a>.</p>
<p>If you want to keep importing the file by name after the first load, add the module to <code>sys.modules</code>:</p>
<pre><code>sys.modules['foobar'] = foobar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you install the script with package manager (deb or alike) another option would be to use setuptools:</p>
<blockquote>
<p>"...there’s no easy way to have a script’s filename match local conventions on both Windows and POSIX platforms. For another, you often have to create a separate file just for the “main” script, when your actual “main” is a function in a module somewhere... setuptools fixes all of these problems by automatically generating scripts for you with the correct extension, and on Windows it will even create an .exe file..."</p>
</blockquote>
<p><a href="https://pythonhosted.org/setuptools/setuptools.html#automatic-script-creation" rel="nofollow">https://pythonhosted.org/setuptools/setuptools.html#automatic-script-creation</a></p>
</div>
<span class="comment-copy">I'm intrigued. Why do you have a python file without the <code>py</code> extension?</span>
<span class="comment-copy">Sometimes it's nice to use python for configuration files (extension as .conf) or to denote a special type of file. In my case, it'd be more of a convenience for an Administrator.</span>
<span class="comment-copy">I have a file with configuration that is used both as a python file and as a bash script. I gave it a <code>pysh</code> extension...</span>
<span class="comment-copy">If that is configuration related things, I recommend using <code>ConfigParser</code>. <a href="https://wiki.python.org/moin/ConfigParserExamples" rel="nofollow noreferrer">wiki.python.org/moin/ConfigParserExamples</a></span>
<span class="comment-copy">@voyager One reason is python scripts with .cgi extensions instead of .py extension</span>
<span class="comment-copy">Fixed. [it is more constructive to suggest an Edit, though]</span>
<span class="comment-copy">but again section is required as I understood from &gt;&gt;&gt; foobar = imp.load_source('','credentials')     [default] NameError: name 'default' is not defined</span>
<span class="comment-copy">What is the use of the first argument <code>'foobar'</code> if it is assigned in the return value?</span>
<span class="comment-copy">@AnmolSinghJaggi It sets the module <code>__name__</code> property; normally that's determined from the filename, but since you're using a non-standard filename (which might not even contain any valid python identifier at all), you have to specify the module name. The variable name in which you store a reference to the created module object is irrelevant, much as if you <code>import foo.bar as baz</code> the module referenced by the variable <code>baz</code> will still have its original <code>__name__</code>.</span>
<span class="comment-copy">This has been deprecated since 3.4. Any idea how to import from a file without the .py extension in 3.4+?</span>
<span class="comment-copy">Or instead of wrapping, just symlink foobar.py to foobar (assuming you aren't on Windows)</span>
<span class="comment-copy">@whaley, yeah, that would be much cleaner.  You could use a .bat for windows to accomplish the same thing.</span>
<span class="comment-copy">I've got a neat use case - a readme file, with examples in it, which I'd like doctest to validate. I'm hoping to make a doctest markdown doc that works...</span>
<span class="comment-copy">And the answer is (for that use case) - use doctest.loadfile!</span>
<span class="comment-copy">The issue with wrappers is that if someone naively copies just the wrapper to a <code>bin/</code> directory, the program won't work when run from the path.</span>
<span class="comment-copy">That module needs a <code>foobar = importlib.nice_import('foobar')</code> helper desperately.</span>
<span class="comment-copy">@Ciro. It already has that. I don't think that <code>/some/arbitrary/file.weird_extension</code> qualifies as "nice". That being said, I've started using python code for all my configuration files once I discovered this. It's just so convenient.</span>
