<div class="post-text" itemprop="text">
<p>I tried to use the property definition from PythonDecoratorLibrary (example 3).
=&gt; <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Property_Definition" rel="nofollow">https://wiki.python.org/moin/PythonDecoratorLibrary#Property_Definition</a></p>
<pre><code>import sys
def property(function):
  keys = 'fget', 'fset', 'fdel'
  [...]
</code></pre>
<p>After additionally importing sys I get this error:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in Angle
  File "&lt;stdin&gt;", line 12, in property
TypeError: property() got an unexpected keyword argument 'doc'
</code></pre>
<p>Line 12 is: function() because of the sys import :)</p>
<p>My python version is 3.4.1 on Windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all: That is <em>one ugly way</em> to allow for local functions to define the 3 property functions.</p>
<p>The sample decorator <em>masks the <code>property</code> built-in</em>, but then tries to use it still to produce the <code>property</code> object. Oops.</p>
<p>You can still access the orginal built-in with:</p>
<pre><code>import builtins

def property(function):
    keys = 'fget', 'fset', 'fdel'
    func_locals = {'doc':function.__doc__}
    def probe_func(frame, event, arg):
        if event == 'return':
            locals = frame.f_locals
            func_locals.update(dict((k, locals.get(k)) for k in keys))
            sys.settrace(None)
        return probe_func
    sys.settrace(probe_func)
    function()
    return builtins.property(**func_locals)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow"><code>builtins</code> module</a> lets you access the builtins even when a local name has overridden it.</p>
<p>I've updated the wiki page to reflect this.</p>
</div>
<div class="post-text" itemprop="text">
<p>The example is relying on the built-in <code>property</code> function, while also naming itself <code>property</code>:</p>
<pre><code>def property(function):
    keys = 'fget', 'fset', 'fdel'
    func_locals = {'doc':function.__doc__}
    def probe_func(frame, event, arg):
        if event == 'return':
            locals = frame.f_locals
            func_locals.update(dict((k, locals.get(k)) for k in keys))
            sys.settrace(None)
        return probe_func
    sys.settrace(probe_func)
    function()
    return property(**func_locals)  # This is supposed to be the built-in property
</code></pre>
<p>So it ends up calling itself (which doesn't take a <code>doc</code> keyword argument), instead of the built-in <code>property</code> (which takes a <code>doc</code> keyword argument). So yes, the example is broken. The function it's calling <code>property</code> should be named something else, or it should save a reference to the built-in <code>property</code> and call that internally.</p>
<p><strong>Edit:</strong> Using <code>builtins.property</code> is obviously much nicer than saving a reference to <code>property</code> before masking it. So go with that.</p>
</div>
<span class="comment-copy">Stated in another way just remove the property function definition since it is a built in function</span>
<span class="comment-copy">What other way(s) would you advice to use to implement a property in python3? I don't consider PythonDecoratorLibrary (example 1) and the builtin property decorator as very nice ways :)</span>
<span class="comment-copy">@Paebbels: just sticking with the <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>property</code> decorator syntax</a> (e.g. <code>@property</code>, then <code>@foo.setter</code>, etc.); in the long run, using the widespread best practice is going to lead to more maintainable and readable code, as you don't have to keep re-learning whatever alternative method you thought more readable at the time of implementation.</span>
