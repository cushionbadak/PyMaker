<div class="post-text" itemprop="text">
<p>i wish to find longest common substring of 2 given strings recursively .i have written this code but it is too inefficient .is there a way i can do it in O(m*n) here m an n are respective lengths of string.here's my code:</p>
<pre><code>def lcs(x,y):
    if len(x)==0 or len(y)==0:
       return " "
    if x[0]==y[0]:
       return x[0] + lcs(x[1:],y[1:])
    t1 = lcs(x[1:],y)
    t2 = lcs(x,y[1:])
    if len(t1)&gt;len(t2):
        return t1
    else:
        return t2
x = str(input('enter string1:'))
y = str(input('enter string2:'))
print(lcs(x,y))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to <a href="http://en.wikipedia.org/wiki/Memoization" rel="nofollow">memoize</a> your recursion. Without that, you will end up with an exponential number of calls since you will be repeatedly solving the same problem over and over again. To make the memoized lookups more efficient, you can define your recursion in terms of the suffix lengths, instead of the actual suffixes.</p>
<p>You can also find the <a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Code_for_the_dynamic_programming_solution" rel="nofollow">pseudocode</a> for the DP on Wikipedia.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a naive non-recursive solution which uses the <code>powerset()</code> recipe from <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code></a>:</p>
<pre><code>from itertools import chain, combinations, product


def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))


def naive_lcs(a, b):
    return ''.join(max(set(powerset(a)) &amp; set(powerset(b)), key=len))
</code></pre>
<p>It has problems:</p>
<pre><code>&gt;&gt;&gt; naive_lcs('ab', 'ba')
'b'
&gt;&gt;&gt; naive_lcs('ba', 'ab')
'b'
</code></pre>
<p>There can be more than one solution for some pairs of strings, but my program picks one arbitrarily.</p>
<p>Also, since <em>any</em> of the combinations can be the longest common one, and since calculating these combinations takes O(2 ^ n) time, this solution doesn't compute in O(n * m) time. With Dynamic Programming and memoizing OTOH we can find a <a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Solution_for_two_sequences" rel="nofollow">solution</a> that, in theory, should perform better:</p>
<pre><code>from functools import lru_cache


@lru_cache()
def _dynamic_lcs(xs, ys):
    if not (xs and ys):
        return set(['']), 0
    elif xs[-1] == ys[-1]:
        result, rlen = _dynamic_lcs(xs[:-1], ys[:-1])
        return set(each + xs[-1] for each in result), rlen + 1
    else:
        xlcs, xlen = _dynamic_lcs(xs, ys[:-1])
        ylcs, ylen = _dynamic_lcs(xs[:-1], ys)
        if xlen &gt; ylen:
            return xlcs, xlen
        elif xlen &lt; ylen:
            return ylcs, ylen
        else:
            return xlcs | ylcs, xlen


def dynamic_lcs(xs, ys):
    result, _ = _dynamic_lcs(xs, ys)
    return result


if __name__ == '__main__':
    seqs = list(powerset('abcde'))
    for a, b in product(seqs, repeat=2):
        assert naive_lcs(a, b) in dynamic_lcs(a, b)
</code></pre>
<p><code>dynamic_lcs()</code> also solves the problem that some pairs strings can have multiple common longest sub-sequences. The result is the set of these, instead of one string. Finding the set of all common sub-sequences though <a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#cite_note--3" rel="nofollow">is still of exponential complexity</a>.</p>
<p>Thanks to Pradhan for reminding me of Dynamic Programming and memoization.</p>
</div>
<span class="comment-copy">What do you mean "too inefficient"? Does it take too long? Use up too much memory? If it works, consider <a href="http://codereview.stackexchange.com">codereview.stackexchange.com</a></span>
<span class="comment-copy">takes too time for strings of large lengths.</span>
<span class="comment-copy">It is also incorrect.</span>
<span class="comment-copy">it works properly . only the time complexity is high.</span>
<span class="comment-copy">Take a look at this: <a href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Longest_common_substring#Python" rel="nofollow noreferrer">en.wikibooks.org/wiki/Algorithm_Implementation/Strings/â€¦</a></span>
<span class="comment-copy">An exponential search space doesn't necessarily preclude a polynomial time solution. Indeed, there exists an O(nm) <a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Solution_for_two_sequences" rel="nofollow noreferrer">algorithm</a> for a pair of strings. It is a classic example of recursion/dynamic programming/memoization - take your pick.</span>
<span class="comment-copy">@Pradhan: Please see my edit.</span>
