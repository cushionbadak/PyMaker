<div class="post-text" itemprop="text">
<p>I have following simple Python 3.4 script:</p>
<pre><code>LISTEN_PORT = 7000

class MyHandler(http.server.SimpleHTTPRequestHandler):

    def do_GET(self):
        print("DO GET")
        self.send_response(200, "OK")



def run():

    handler = MyHandler
    print("Server Started")
    httpd = socketserver.TCPServer(("0.0.0.0", LISTEN_PORT), handler)

    try:
        print("serving at port", LISTEN_PORT)
        httpd.serve_forever()
    except KeyboardInterrupt:
        httpd.socket.close()


run()
</code></pre>
<p>When I call from android:</p>
<pre><code>final StringRequest request = new StringRequest(Request.Method.GET, context.getString(R.string.domain)+"/", new Response.Listener&lt;String&gt;() {
        @Override
        public void onResponse(String s) {

        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError volleyError) {

            Log.e(TAG, "Can not send token" + volleyError);
            Toast.makeText(context, "Can not send", Toast.LENGTH_LONG).show();
        }
    });

    Volley.newRequestQueue(context).add(request);
</code></pre>
<p><strong>Android:</strong>
I see <code>Toast</code> "Can not send" and on logcat console I have following information:</p>
<pre><code>06-27 18:05:16.332  28946-28946/com.example.code E/NETWORK_CONNECTOR﹕ Can not send token Code:com.android.volley.NoConnectionError: java.io.EOFException
</code></pre>
<p><strong>Python:</strong></p>
<pre><code>192.168.12.246 - - [27/Jun/2014 18:15:55] "GET / HTTP/1.1" 200 -
DO GET
</code></pre>
<p>What is wrong with Python script?</p>
</div>
<div class="post-text" itemprop="text">
<p>What is wrong with python script ?</p>
<p>it would somehow work with python3.0-3.2 but won't work with python3.3+</p>
<p>from <a href="https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler.send_response" rel="nofollow">send_response documentation</a></p>
<blockquote>
<p>Changed in version 3.3: Headers are stored to an internal buffer and end_headers() needs to be called explicitly.</p>
</blockquote>
<p>in the current setup the header part of http answer is simply not sent.</p>
<p>so the right way to do it in python3.3+ is </p>
<pre><code>def do_GET(self):

    print("DO GET")
    self.send_response(200, "OK")
    self.end_headers()

    self.wfile.write(b"Response body\n") #optional
</code></pre>
<p>but there is several thing which could be improved in your script</p>
<ul>
<li>use http.server.BaseHTTPRequestHandler instead of http.server.SimpleHTTPRequestHandler because SimpleHTTPRequestHandler add some magic to BaseHTTPRequestHandler to process GET and <strong>HEAD</strong> request. as you override do_GET, you replace the behavior of SimpleHTTPRequestHandler but as you don't do it for do_HEAD, your server would answer to HEAD requests as it would be SimpleHTTPRequestHandler which is not a good idea</li>
<li>httpd.server_close() instead httpd.socket.close() even if that don't change thing too much as it is basically a noop in the current python</li>
</ul>
<p>adding an import at top of the script and voilà a full working script</p>
<pre><code>import http.server
LISTEN_PORT = 7000

class MyHandler(http.server.BaseHTTPRequestHandler):

    def do_GET(self):

        print("DO GET")
        self.send_response(200, "OK")
        self.end_headers()

        self.wfile.write(b"Response body\n") #optional


def run():

    handler = MyHandler
    print("Server Started")
    httpd = http.server.HTTPServer(("0.0.0.0", LISTEN_PORT), handler)

    try:
        print("serving at port", LISTEN_PORT)
        httpd.serve_forever()
    except KeyboardInterrupt:
        httpd.server_close()


if __name__ == "__main__":
    run()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems like the response may be incomplete due to EOF Exception.
Try to change your do_GET to the following:</p>
<pre><code>self.send_response(200)
self.end_headers()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is not related to Android (hint: you may check your server from simple web browser).
According to protocol specification HTTP server must start its response with line</p>
<pre><code>HTTP/&lt;version&gt; &lt;code&gt; &lt;optional message&gt;
</code></pre>
<p>Then server sends other headers, blank line and optional binary body (in some cases).
It turns out that status message behaves like a header although it is not explicitly exposed in documentation. Since that you have to call <code>end_headers()</code> after <code>send_response()</code>.</p>
<p>Just add it to your code.</p>
<pre><code>def do_GET(self):
    print("DO GET")
    self.send_response(200, "OK")
    self.end_headers()
    # Send optional body in HTML, XML, JSON, binary data, etc.
    self.wfile.write(bytes('&lt;html&gt;&lt;body&gt;Hello!&lt;/body&gt;&lt;/html&gt;', 'utf-8'))
</code></pre>
<p>If you add the body you may enter in browser <code>http://localhost:7000</code> and see hello message. After that re-check server from your Andriod application.</p>
<p>Also change <code>http.server.SimpleHTTPRequestHandler</code> to <code>http.server.BaseHTTPRequestHandler</code>, latter is enough in your case.</p>
</div>
<span class="comment-copy">Is your device and server in the same network? Can you access your endpoint from your device's browser?</span>
