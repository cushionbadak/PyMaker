<div class="post-text" itemprop="text">
<p>How do I serialise a Python <code>Enum</code> member to JSON, so that I can deserialise the resulting JSON back into a Python object?  </p>
<p>For example, this code:</p>
<pre><code>from enum import Enum    
import json

class Status(Enum):
    success = 0

json.dumps(Status.success)
</code></pre>
<p>results in the error:</p>
<pre><code>TypeError: &lt;Status.success: 0&gt; is not JSON serializable
</code></pre>
<p>How can I avoid that?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to encode an arbitrary <code>enum.Enum</code> member to JSON and then decode
it as the same enum member (rather than simply the enum member's <code>value</code> attribute), you can do so by writing a custom <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" rel="noreferrer"><code>JSONEncoder</code></a> class, and a decoding function to pass as the <code>object_hook</code> argument to <a href="https://docs.python.org/3/library/json.html#json.load" rel="noreferrer"><code>json.load()</code></a> or <a href="https://docs.python.org/3/library/json.html#json.loads" rel="noreferrer"><code>json.loads()</code></a>:</p>
<pre><code>PUBLIC_ENUMS = {
    'Status': Status,
    # ...
}

class EnumEncoder(json.JSONEncoder):
    def default(self, obj):
        if type(obj) in PUBLIC_ENUMS.values():
            return {"__enum__": str(obj)}
        return json.JSONEncoder.default(self, obj)

def as_enum(d):
    if "__enum__" in d:
        name, member = d["__enum__"].split(".")
        return getattr(PUBLIC_ENUMS[name], member)
    else:
        return d
</code></pre>
<p>The <code>as_enum</code> function relies on the JSON having been encoded using <code>EnumEncoder</code>, or something which behaves identically to it.</p>
<p>The restriction to members of <code>PUBLIC_ENUMS</code> is necessary to avoid a maliciously crafted text being used to, for example, trick calling code into saving private information (e.g. a secret key used by the application) to an unrelated database field, from where it could then be exposed (see <a href="http://chat.stackoverflow.com/transcript/message/35999686#35999686">http://chat.stackoverflow.com/transcript/message/35999686#35999686</a>).</p>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; data = {
...     "action": "frobnicate",
...     "status": Status.success
... }
&gt;&gt;&gt; text = json.dumps(data, cls=EnumEncoder)
&gt;&gt;&gt; text
'{"status": {"__enum__": "Status.success"}, "action": "frobnicate"}'
&gt;&gt;&gt; json.loads(text, object_hook=as_enum)
{'status': &lt;Status.success: 0&gt;, 'action': 'frobnicate'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The correct answer depends on what you intend to do with the serialized version.</p>
<p>If you are going to unserialize back into Python, see <a href="https://stackoverflow.com/a/24482806/208880">Zero's answer</a>.</p>
<p>If your serialized version is going to another language then you probably want to use an <code>IntEnum</code> instead, which is automatically serialized as the corresponding integer:</p>
<pre><code>from enum import IntEnum
import json

class Status(IntEnum):
    success = 0
    failure = 1

json.dumps(Status.success)
</code></pre>
<p>and this returns:</p>
<pre><code>'0'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this is old but I feel this will help people. I just went through this exact problem and discovered if you're using string enums, declaring your enums as a subclass of <code>str</code> works well for almost all situations:</p>
<pre><code>import json
from enum import Enum

class LogLevel(str, Enum):
    DEBUG = 'DEBUG'
    INFO = 'INFO'

print(LogLevel.DEBUG)
print(json.dumps(LogLevel.DEBUG))
print(json.loads('"DEBUG"'))
print(LogLevel('DEBUG'))
</code></pre>
<p>Will output:</p>
<pre><code>LogLevel.DEBUG
"DEBUG"
DEBUG
LogLevel.DEBUG
</code></pre>
<p>As you can see, loading the JSON outputs the string <code>DEBUG</code> but it is easily castable back into a LogLevel object. A good option if you don't want to create a custom JSONEncoder.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/24481852/serialising-an-enum-member-to-json#comment86718365_24482131">This was buried in the comments for another answer</a>, but it was exactly what is needed to just serialize a string enum's value:</p>
<pre><code>from enum import EnumMeta
import json

class Status(EnumMeta):
    success = "win"
    failure = "lose"

json.dumps(Status.success)
</code></pre>
<p>returns:</p>
<pre><code>'win'
</code></pre>
<p>Warning: you lose the ability iterate over the enum if you do this.</p>
<pre><code>[x for x in Status] # TypeError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I liked Zero Piraeus' answer, but modified it slightly for working with the API for Amazon Web Services (AWS) known as Boto.</p>
<pre><code>class EnumEncoder(json.JSONEncoder):
def default(self, obj):
    if isinstance(obj, Enum):
        return obj.name
    return json.JSONEncoder.default(self, obj)
</code></pre>
<p>I then added this method to my data model:</p>
<pre><code>    def ToJson(self) -&gt; str:
        return json.dumps(self.__dict__, cls=EnumEncoder, indent=1, sort_keys=True)
</code></pre>
<p>I hope this helps someone.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using <code>jsonpickle</code> the easiest way should look as below.</p>
<pre class="lang-py prettyprint-override"><code>from enum import Enum
import jsonpickle


@jsonpickle.handlers.register(Enum, base=True)
class EnumHandler(jsonpickle.handlers.BaseHandler):

    def flatten(self, obj, data):
        return obj.value  # Convert to json friendly format


if __name__ == '__main__':
    class Status(Enum):
        success = 0
        error = 1

    class SimpleClass:
        pass

    simple_class = SimpleClass()
    simple_class.status = Status.success

    json = jsonpickle.encode(simple_class, unpicklable=False)
    print(json)

</code></pre>
<p>After Json serialization you will have as expected <code>{"status": 0}</code> instead of </p>
<pre><code>{"status": {"__objclass__": {"py/type": "__main__.Status"}, "_name_": "success", "_value_": 0}}
</code></pre>
</div>
<span class="comment-copy">@ZeroPiraeus: Just stumbled across this.  I had no idea I had answered that many!  :)</span>
<span class="comment-copy">works very well, thanks</span>
<span class="comment-copy">Thanks, Zero!  Nice example.</span>
<span class="comment-copy">If you have your code in a module(enumencoder.py, for example), you must import the class that you parse from JSON to dict. For example, in this case, you must import the class <i>Status</i> in the module enumencoder.py.</span>
<span class="comment-copy">My concern was not about malicious calling code, but malicious requests to a web server. As you mentioned, the private data could be exposed in a response, or it could be used to manipulate code flow. Thank you for updating your answer. It would be even better if the main code example was secure though.</span>
<span class="comment-copy">@JaredDeckard my apologies, you were right, and I was wrong. I've updated the answer accordingly. Thanks for your input! This has been educational (and chastening).</span>
<span class="comment-copy">I like to  unserialize back into Python</span>
<span class="comment-copy">@AShelly: The question was tagged with <code>Python3.4</code>, and this answer is 3.4+ specific.</span>
<span class="comment-copy">Perfect. If you Enum is a string, you would use <code>EnumMeta</code> instead of <code>IntEnum</code></span>
<span class="comment-copy">@bholagabbar: No, you would use <code>Enum</code>, possibly with a <code>str</code> mixin -- <code>class MyStrEnum(str, Enum): ...</code></span>
<span class="comment-copy">@bholagabbar, interesting.  You should post your solution as an answer.</span>
<span class="comment-copy">This is excellent. So nice and simple...</span>
