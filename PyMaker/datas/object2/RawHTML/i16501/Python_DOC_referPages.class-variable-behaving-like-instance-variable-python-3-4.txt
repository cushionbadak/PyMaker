<div class="post-text" itemprop="text">
<p>Python 3.4.0a1<br/>
Windows 8.1</p>
<p>Class Created:  </p>
<pre><code>class Bank(object):  
    bankrupt = False  
</code></pre>
<p>Command entered in IDLE <code>__main__</code> with the following results:</p>
<pre><code>&gt;&gt;&gt; a = Bank()
&gt;&gt;&gt; b = Bank()
&gt;&gt;&gt; a.bankrupt
False
&gt;&gt;&gt; b.bankrupt
False
&gt;&gt;&gt; b.bankrupt = True
&gt;&gt;&gt; b.bankrupt
True
&gt;&gt;&gt; a.bankrupt
False
</code></pre>
<h3>Expected output:</h3>
<p>I expected a.bankrupt to change to True when I changed b.bankrupt since the variable bankrupt is defined for the entire class and not for a single instance (with <code>self.bankrupt</code>) Why is this not happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>You assigned to a new attribute to the instance instead. To change a class attribute, assign directly to the class.</p>
<p>When looking up an attribute on an instance, look-up 'falls through' to the class, then to the base classes. This is how all class attributes, including methods, are found.</p>
<p>But when <em>assigning</em>, this happens directly on the instance. Otherwise you could never assign per-instance values, you'd only ever assign back to the class. Assigning to <code>a.bankrupt</code> or <code>b.bankrupt</code> will add an attribute to the instance, if it wasn't already there to begin with. To Python, there is no difference between using <code>self.bankrupt = True</code> in a method, or to using <code>a.bankrupt = True</code> from the 'outside' to assign to an attribute.</p>
<p>Just assign to the class attribute directly (from a method or from 'outside'):</p>
<pre><code>Bank.bankrupt = True
</code></pre>
<p>Note that the same fall-through on read, assignment on write rules apply to base classes; looking up an attribute on a class looks to the base classes if the attribute is not found on the class directly, but setting an attribute on a class do so directly, and not affect attributes on the bases.</p>
<p>For the nitty gritty details, see the <em>Custom classes</em> and <em>Class instances</em> sections of the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow">Python datamodel</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>b.bankrupt = True</code> you create an instance variable that shadows the class-level variable.</p>
<p>If you want to change the class variable use</p>
<pre><code>Bank.bankrupt = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After assignment to instance variable it is created if it was not before. And next time You try to access it You got it from instance <code>__dict__</code>. </p>
<pre><code>&gt;&gt;&gt; class A:
...     foo = 'b'
...     bar = []
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; b = A()
&gt;&gt;&gt; a.__dict__
{}
&gt;&gt;&gt; a.foo = 'c'
&gt;&gt;&gt; a.foo
'c'
&gt;&gt;&gt; a.__dict__
{'foo': 'c'}
</code></pre>
<p>This is why You have different values for <code>a.foo</code> and <code>b.foo</code>
Meanwhile If You modify variable (not reassign it) You will got result which You have described.</p>
<pre><code>&gt;&gt;&gt; a.bar.append(1)
&gt;&gt;&gt; b.bar
[1]
&gt;&gt;&gt; a.bar
[1]
&gt;&gt;&gt; a.__dict__
{'foo': 'c'}
</code></pre>
<p>In this case instance variable was not created.</p>
</div>
<span class="comment-copy">From a modelling perspective, shouldn't individual <code>Bank</code> instances be able to go <code>bankrupt</code> separately?</span>
<span class="comment-copy">So there is now both an instance variable for <code>b</code> and a class variable called <code>bankrupt</code>?</span>
<span class="comment-copy">Yes, you have both.</span>
<span class="comment-copy">Note that when you use <code>__slots__</code> on the class <i>no <code>__dict__</code> is used</i>.</span>
<span class="comment-copy">Thanks - this was good insight for me as a python novice</span>
