<div class="post-text" itemprop="text">
<p><strong>input t1</strong><br/>
P95P,71655,LINC-JP,pathogenic<br/>
P95P,71655,LINC-JP,pathogenic<br/>
P71P,71655,LINC-JP,pathogenic<br/>
P71P,71655,LINC-JP,pathogenic<br/></p>
<p><strong>output <em>op</em></strong><br/>
P95P,71655,LINC-JP,pathogenic<br/>
P71P,71655,LINC-JP,pathogenic<br/></p>
<p><strong>myCode</strong></p>
<pre><code>def dup():
    fi=open("op","a")
    l=[];final="";
    q=[];dic={};
    for i in open("t1"):
        k=i.split(",")
        q.append(k[1])
        q.append(k[0])
        if q in l:
            pass
        else:
            final= final + i.strip() + "\n"
            fi.write(str(i.strip()))
            fi.write("\n")
        l.append(q)
        q=[]
        #print i.strip()
    fi.close()
    return final.strip()    
d=dup()
</code></pre>
<p>In the above input line1,2 and line 3,4 are duplicates. Hence in output these duplicates are removed  the entries in my input files are around 10^7.</p>
<p><strong>Why is my code running since past 24 hrs for an input of 76Mb file.</strong> Also it has yet to complete one iteration of entire input file.It works fine for small files.<br/>
Can anyone please point out the reason for this long time.How can I optimize my program ? <br/>thnx</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not clear why you're building a huge string (<code>final</code>) that holds the same thing the file does, or what <code>dic</code> is for. In terms of performance, you can look up <code>x in y</code> much faster if <code>y</code> is a <code>set</code> than if <code>y</code> is a <code>list</code>. Also, a minor point; shorter variable names don't improve performance, so use good ones instead. I would suggest:</p>
<pre><code>def deduplicate(infile, outfile):
    seen = set()
    #final = []
    with open(outfile, "a") as out, open(infile) as in_:
        for line in in_:
            check = tuple(line.split(",")[:2])
            if check not in seen:
                #final.append(line.strip())
                out.write(line) # why 'strip' the '\n' then 'write' a new one?
                seen.add(check)
    #return "\n".join(final)
</code></pre>
<p>If you do really need final, make it a list until the last moment (see commented-out lines) - gradual string concatenation means the creation of lots of unnecessary objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're using an O(n<sup>2</sup>) algorithm, which scales poorly for larger files:</p>
<pre><code>for i in open("t1"):  # linear pass of file takes O(n) time
    ...
    if q in l:  # linear pass of list l takes O(n) time
        ...
    ...
</code></pre>
<p>You should consider using a <a href="https://docs.python.org/2/tutorial/datastructures.html#sets">set</a> (i.e. make <code>l</code> a <code>set</code>) or <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby"><code>itertools.groupby</code></a> if duplicates will always be next to each other. These approaches will be O(n).</p>
</div>
<div class="post-text" itemprop="text">
<p>if you have access to a Unix system, <code>uniq</code> is a nice utility that is made for your problem.</p>
<pre><code>uniq input.txt output.txt
</code></pre>
<p>see <a href="https://www.cs.duke.edu/csl/docs/unix_course/intro-89.html">https://www.cs.duke.edu/csl/docs/unix_course/intro-89.html</a></p>
<p>I know this is a <code>Python</code> question, but sometimes <code>Python</code> is not the tool for the task.
And you can always embed a system call in your python script.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple things that you are doing very inefficiently. The largest is that you made <code>l</code> a list, so the line <code>if q in l</code> has to search through everything in the list already in order to check if q matches it. If you make l a <a href="https://docs.python.org/2/library/stdtypes.html#set" rel="nofollow">set</a>, the membership check can be done using a hash calculation and array lookup, which take the same (small) amount of time no matter how much you add to the set (though it will cause <code>l</code> not to be read in the order that it was written).</p>
<p>Other little speedups that you can do include:</p>
<ul>
<li>Using a tupple <code>(k[1], k[0])</code> instead of a list for <code>q</code>.</li>
<li>You are writing your output file <code>fi</code> every loop. Your OS will try to batch and background the writes, but it may be faster to just do one big write at the end. I am not sure on this point but try it.</li>
</ul>
</div>
<span class="comment-copy">Have you considered making <code>l</code> a <code>set</code> instead of a <code>list</code>? Membership checking would be <code>O(1)</code> instead of <code>O(len(l))</code>. Also, don't <code>append</code> (or <code>add</code> if you use a <code>set</code>) to <code>l</code> in the <code>if q in l:</code> case.</span>
<span class="comment-copy">@jonrsharpe what if file is bigger say 1 gb. does set works?</span>
<span class="comment-copy">Will duplicates always be next to each other?</span>
<span class="comment-copy">@sundarnatarajСундар what do you mean <i>"does set works"</i>? If you have enough system memory, it shouldn't be a problem. The lookup performance is based on hashing, so would remain at <code>O(1)</code>.</span>
<span class="comment-copy">final is used for returning the non-duplicates to another file for analysis</span>
<span class="comment-copy">@diablo8226 why not do that file writing in this function too?</span>
<span class="comment-copy">yea i wish i had done that but i cant kill the execution now.But i will keep that in mind next time.</span>
<span class="comment-copy">how to correctly determine the complexity of any code ? I estimated my code to be of O(N) complexity since it has one iteration. Are there any tutorials for specifically determining the algo complexity ? thnx</span>
<span class="comment-copy">@diablo8226 It's not necessarily a trivial task. In your specific case, it's O(n^2) because on each iteration of the outer loop, you have to perform another O(n) operation by looping over <code>l</code> (this is O(n) because <code>l</code> will presumably grow to be proportional to n in size). Note that n here is the length of your file in lines.</span>
<span class="comment-copy">thts the first cmd i tried but to no avail...</span>
<span class="comment-copy">what system are you using ?</span>
<span class="comment-copy">I am using ubuntu OS</span>
<span class="comment-copy">but then you should have <code>uniq</code> available</span>
<span class="comment-copy">uea i have but uniq didnt work on the data..i mean it didnt weed out the duplicates. i used <code>uniq -u "file_name"</code></span>
<span class="comment-copy">writing to "fi" is to play safe.Suppose, my system gets accidentally shut-down or if i have to restart it.If i write the non-duplicates in  "fi" then next time while running the program i don't have to give the entire input again.</span>
