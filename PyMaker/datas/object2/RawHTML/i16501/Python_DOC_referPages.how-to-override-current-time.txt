<div class="post-text" itemprop="text">
<p>I am writing an application which makes use of the current time (via <code>datetime.datetime.now()</code>) </p>
<p>Is there a way, for debugging purposes, to override this call so that it returns a specific timestamp?</p>
<p>As a fallback I could write a function which would be called instead of <code>datetime.datetime.now()</code> and return whatever is needed (the actual current time in producton and the required test time when debugging) but there may be a more pythonic way to perform these kind of actions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Broadly, your options are:</p>
<ul>
<li>Use the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><code>unittest.mock</code> library</a>, which can replace the function on the fly with a dummy function that always gives the same results (or use another mocking library that does the same thing).  This means you don't have to modify your function; however, reasonable people can disagree on whether monkey patching with mock is good practice, even for debugging.  I think this is the most widely used solution to this problem in Python.</li>
<li>Modify your function to do something different depending on its environment (the actual environment variables on your system, or global state, or something else).  This is the easiest way, but also the crudest and most fragile way, so you'll have to be sure to change it back after your debugging is finished.</li>
<li>Modify your function to accept a function itself as a parameter, and pass in <code>datetime.datetime.now</code> as that function in normal operation, but pass in something different (for instance a <a href="https://github.com/alex/pretend" rel="nofollow">stub</a>) for testing.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="http://www.voidspace.org.uk/python/mock/" rel="nofollow">mock</a> library to mock the <code>datetime.datetime.now()</code> usage:</p>
<pre><code>import mock

def my_test():
    my_mock = mock.Mock(return_value=your_desired_timestamp)

    with mock.patch('mymodule.datetime.datetime.now', my_mock):
        # Here, all calls to `datetime.datetime.now` referenced by `datetime.datetime`
        # defined in `my_module` will be mocked to return `your_desired_timestamp`.
</code></pre>
</div>
<span class="comment-copy">You can always create your own timestamp, with <code>datetime.datetime(year, month, day, hour, minute, second)</code>, is this what you need?</span>
<span class="comment-copy">@BurhanKhalid: no. I mentioned in my question that I can write a function which replaces <code>datetime.datetime.now()</code> and returns whatever is needed. But I want to keep <code>datetime.datetime.now()</code> in the code and override it elsewhere in the code.</span>
<span class="comment-copy">@WoJ alternatively, change your design to not call <code>now()</code> within your functions/methods, and have the caller responsible for passing the time.  This essentially uses a core idea from functional programming - <a href="https://docs.python.org/2/howto/functional.html" rel="nofollow noreferrer">there is even an article about functional programming</a> on the Python site.  This is mostly the reason: "Functions donâ€™t depend on system state that needs to be replicated before running a test; instead you only have to synthesize the right input and then check that the output matches expectations."</span>
<span class="comment-copy">You can't mock datetime (and date/time for that matter) methods, as explained here: <a href="http://stackoverflow.com/a/4482067/1497947">stackoverflow.com/a/4482067/1497947</a></span>
