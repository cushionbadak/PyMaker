<div class="post-text" itemprop="text">
<p>I am trying to use the <code>multiprocessing</code> packages for python. However, when I try to define a pool in IDLE it silently crashes (no error message or traceback, IDLE just closes). On the other hand, this same script has no problem running when executed from the terminal. What gives? I am using python 2.7 on Ubuntu 12.04.</p>
<pre><code>import multiprocessing
from multiprocessing import Pool

def myfunc(x):
    return x*x

cpu_count = int(multiprocessing.cpu_count() - 1)
pool = Pool(processes = cpu_count) #Crashes here in IDLE
resultlist = pool.map(myfunc, range(10))
pool.close()
print(resultlist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem <em>is</em> your code: it is missing the <code>if __name__ == '__main__':</code> guard clause that is an essential part of <em>every</em> working example in the multiprocessing doc chapter, as it keeps each subprocess from running the start and finish code.  Running the following in Idle (or without Idle, in a console)</p>
<pre><code>import multiprocessing
from multiprocessing import Pool

def myfunc(x):
    return x*x

if __name__ == '__main__':
    cpu_count = int(multiprocessing.cpu_count() - 1)
    pool = Pool(processes = cpu_count) #Crashes here in IDLE
    resultlist = pool.map(myfunc, range(10))
    pool.close()
    print(resultlist)
</code></pre>
<p>almost immediately prints</p>
<pre><code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>If you run your original code in a console (or with Idle started in the console), you will see an endless stream of error messages as each process starts up more processes.</p>
<p>Edit: the above behavior is on Windows 10</p>
<p>I suggest you ignore opinions and decide for yourself what tools you want to use, based on current and real facts.  Try to use the latest bugfix release of whatever Python version you use.  For Idle in particular, there have been many fixes in the last 2 years after a couple of years or so of stagnation.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/a/2806280/110707">stackoverflow.com/a/2806280/110707</a> may be helpful.</span>
<span class="comment-copy">So it's not me, it's <code>multiprocessing</code> and <code>IDLE</code>? I guess I've never noticed this before because I tend to have print statements in the subprocess that I want to see and that I knew IDLE would not print with its global lock so I guess I've always run scripts with multiprocessing from the terminal. But really??? IDLE cannot handle multiprocessing??? So stupid.</span>
<span class="comment-copy">idle is not a good ide ... you should switch to something else really ...</span>
<span class="comment-copy">@JoranBeasley suggestions?</span>
<span class="comment-copy">I like pycharm ... but almost anything is better than idle imho (ninja, Eclipse+pydev, etc)</span>
<span class="comment-copy">Um, meanwhile <code>if __name__ == '__main__':</code> is best practice, this is not the cause. Because of <a href="https://docs.python.org/3/reference/import.html#import-hooks" rel="nofollow noreferrer">import caching</a>, <code>import this; import this;import this</code> only prints a message <i>once</i>. Furthermore, I could not reproduce the stream of error messages you described.</span>
<span class="comment-copy">@TheMatt Import caching only applies within a process.  Each new process re-executes the module code.  It least it does on Windows. The behavior I described is on Windows.  I just re-verified running in the console without IDLE,  and added a note to my answer, which should have been there originally.  I have to close the window to stop the stream of messages.</span>
<span class="comment-copy">Interesting. I am on MacOS and running <a href="https://gist.github.com/TheGreatKetchup/e75353aaa3006ee9d1711f9f1a32cc92" rel="nofollow noreferrer">this code</a> which makes a gui whenever the code is imported. Running the code from the command line only creates one message at the beginning. But more interesting <code>import pool_test</code> hangs and can't be ctrl-c'ed. So I do suppose that Windows, Mac, and Ubuntu are all handling this in very different ways. (On ubuntu the window closes, on Mac idle remains but you need to restart to get a prompt back). So it seems you have the correct cause on windows, but sadly it does not translate.</span>
