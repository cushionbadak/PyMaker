<div class="post-text" itemprop="text">
<p>I am using <code>imp.find_module</code> and then <code>imp.load_module</code> to load <code>'example'</code>, now I want to make a list of just the functions in <code>example.py</code> that are functions of <code>Class A</code> but I can't seem to find a <code>getattr</code> attribute that is unique to Classes which would filter out all other methods in <code>dir(example)</code>.</p>
<pre><code>for i in dir(example):
    if hasattr(getattr(example, i), &lt;some_attribute&gt;):
        print i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you search for existing solution, use builtin <a href="https://docs.python.org/2/library/inspect.html#inspect.isclass" rel="nofollow"><code>inspect</code></a> module, it has plenty of functions to test for specific types, <a href="https://docs.python.org/2/library/inspect.html#inspect.isclass" rel="nofollow"><code>isclass</code></a> for your case:</p>
<pre><code>import inspect

class Foo(object):
    pass

if inspect.isclass(Foo):
   print("Yep, it's class")
</code></pre>
<p>However, if you want to get into depths, there are few other approaches.</p>
<ol>
<li><p>In Python everything is an instance of something. Classes are not an exclusion, they are instances of <em>metaclasses</em>. In Python 2 there are two kinds of classes — old-style (<code>class Foo: pass</code>) and new-style (<code>class Foo(object): pass</code>). Old-style classes are instances of <code>classobj</code>, visible as <code>types.ClassType</code>, while new-style classes are instances of <code>type</code>, which itself is both function and metaclass at the same time (callable metaclass to be strict). In Python 3, there are only new-style classes, always derived from <code>object</code> (which in turn is instance of <code>type</code>).</p>
<p>So, you can check if <code>Foo</code> is class, by issuing if it's an instance of metaclass producing classes:</p>
<pre><code>class Foo(object):
    pass

if isinstance(Foo, type):
    print("Yep, it's new-style class")
</code></pre>
<p>Or for old-style:</p>
<pre><code>import types

class Foo:
    pass

if isinstance(Foo, types.ClassType):
    print("Yep, it's old-style class")
</code></pre></li>
<li><p>You can also take a look at <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow">data model</a> and <a href="https://docs.python.org/3/library/stdtypes.html#class.__bases__" rel="nofollow">list of class-specific magic fields</a>.</p></li>
</ol>
</div>
<span class="comment-copy">Btw, "module method" is wrong term. Method is always function, and what you are accessing are module attributes. All methods are attributes (initially), not all attributes are methods.</span>
<span class="comment-copy">Also, using <code>dir()</code> anywhere except interactive prompt is considered bad practice, because it's slow and inconsistent. If you need to access list of attributes for some reason, iterate over <code>__dict__</code> or <code>__slots__</code>.</span>
<span class="comment-copy">Found that isinstance(getattr(V, i), (type, types.ClassType)) seems to work as well - but now I'm having a second problem. Suppose there is an imported Class in example from another library, how do I get only local Classes?</span>
<span class="comment-copy">It's another question, please post link to it here and I will post an answer there — for the order's sake.</span>
<span class="comment-copy">Limited to a 90 minute timer on asking questions i guess, I'll post later.</span>
<span class="comment-copy">Well, in short, there is no 100% way to determine where did class came from, because of reasons. But for cases where class is defined by class keyword, there is <code>__module__</code> field, which is string name of module containing definition. Please note there may be name clash (<code>foo.Foo</code> and <code>bar.foo.Foo</code> are different classes from different modules, but <code>__module__</code> will be <code>foo</code> in both cases, AFAIK), as well <code>__module__</code> may be None (for dynamic and builtin classes).</span>
<span class="comment-copy">Caveat here is that class reference may be reassigned. <code>Foo</code> is defined in module <code>bar</code>, but module <code>buzz</code> internally imports <code>bar</code> and exports <code>Foo</code> again. So <code>buzz.Foo.__module__</code> will be (surprize!) <code>'bar'</code>, not <code>'buzz'</code>, as one may expect. Deal with it or redesign your application (because if you need this kind of info, you're almost 100% doing either something crazy or something horribly wrong).</span>
