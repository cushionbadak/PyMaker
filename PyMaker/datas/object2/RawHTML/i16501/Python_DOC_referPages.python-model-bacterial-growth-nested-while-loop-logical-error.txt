<div class="post-text" itemprop="text">
<p>I have to model bacterial growth as a function of optical density. The problem is simple: for every hour specified by the user, the OD in each cell in a table increases by 5%; when the cell reaches an OD of 1.0, the excess is distributed to cells N,E,S and W of the overflowing cell. If they are all at 1.0, no more growth takes place. The table of ODs is square and can be of any dimensions, it does not wrap around.</p>
<p>In the code below:</p>
<p>array3 is the initial table of ODs and length is the amount of rows and columns. I know that I am making a logical error in the nested while loop, because only the first row updates, and only once:</p>
<pre><code>elapsed=0
i=0
j=0
hours = input('how many hours do you want to run the experiment for?\n')
increase = 1.05

while elapsed &lt;= hours:
    while i&lt;length:
        while j&lt;length:
            if array3[i, j]&lt;1.0:
                array3[i, j]*=increase
                j+=1
            if array3[i, j]&gt;=1.0:
                array3[i, j]=1.0
                excess=((array3[i, j]*increase)-1)/4
                array3[(i-1), j]+=excess
                array3[(i+1), j]+=excess
                array3[i, (j-1)]+=excess
                array3[i, (j+1)]+=excess
                j+=1
        i+=1
    elapsed+=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As already pointed out in the comments, the problem is that you increase the counter variables in the loops, but you do not reset them to their original values before the next iteration. Adding <code>i = 0</code> just before <code>while i&lt;length</code> (and similar for <code>j</code>) would solve your problem, but I'd recommend to use <code>for</code> loops instead, looping over the <code>range</code> of values the variables should take.</p>
<pre><code>for elapsed in range(hours):
    for i, j in itertools.product(range(length), repeat=2):
        if array3[i, j] &lt; 1.0:
            array3[i, j] = min(1.0, array3[i, j] * increase)
        else:
            excess = ((array3[i, j] * increase) - 1) / 4
            for di, dj in [(+1,0), (-1,0), (0,+1), (0,-1)]:
                if 0 &lt;= i+di &lt; length and 0 &lt;= j+dj &lt; length:
                    array3[i+di, j+dj] = min(1.0, array3[i+di, j+dj] + excess)
</code></pre>
<p>As you can see, I've made a few more alterations:</p>
<ul>
<li><a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> is very useful, e.g. for iterating over the product of two variables, like <code>i</code> and <code>j</code> </li>
<li>you can use the <code>min</code> builtin function to cap the growth at <code>1.0</code></li>
<li>looping over all the 'deltas' for <code>i</code> and <code>j</code> instead of having the same code for all 4 neighbors</li>
</ul>
</div>
<span class="comment-copy">You have to reset <code>i</code> and <code>j</code> after the loops. Or better use <code>for</code> loops.</span>
<span class="comment-copy">You're trying to write C code in Python. Write Python code instead; you'll be much happier. <code>range()</code> would be a good thing to use.</span>
<span class="comment-copy">for the second row inner loop variable <code>j</code> still equal <code>length</code> because of this loop body will not run anymore. The same for second hour and forth.</span>
