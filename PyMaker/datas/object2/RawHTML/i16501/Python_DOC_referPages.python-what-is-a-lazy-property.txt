<div class="post-text" itemprop="text">
<p>While looking through the webapp2 documentation online, I found information on the decorator<code>webapp2.cached_property</code> (which can be found at <a href="https://webapp-improved.appspot.com/api/webapp2.html#webapp2.cached_property" rel="nofollow">https://webapp-improved.appspot.com/api/webapp2.html#webapp2.cached_property</a>). </p>
<p>In the documentation, it says:</p>
<blockquote>
<p>A decorator that converts a function into a lazy property.</p>
</blockquote>
<p>My question is:</p>
<ol>
<li>What is a lazy property?</li>
</ol>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>It is a <code>property</code> decorator that gets out of the way after the first call. It allows you to auto-cache a computed value.</p>
<p>The <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">standard library <code>@property</code> decorator</a> is a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">data descriptor object</a> and is <em>always</em> called, even if there is an attribute on the instance of the same name.</p>
<p>The <code>@cached_property</code> decorator on the other hand, <em>only</em> has a <code>__get__</code> method, which means that it is not called if there is an attribute with the same name already present. It makes use of this by setting an attribute with the same name on the instance on the first call.</p>
<p>Given a <code>@cached_property</code>-decorated <code>bar</code> method on an instance named <code>foo</code>, this is what happens:</p>
<ul>
<li><p>Python resolves <code>foo.bar</code>. No <code>bar</code> attribute is found on the instance.</p></li>
<li><p>Python finds the <code>bar</code> descriptor on the class, and calls <code>__get__</code> on that.</p></li>
<li><p>The <code>cached_property</code> <code>__get__</code> method calls the decorated <code>bar</code> method.</p></li>
<li><p>The <code>bar</code> method calculates something, and returns the string <code>'spam'</code>.</p></li>
<li><p>The <code>cached_property</code> <code>__get__</code> method takes the return value and sets a new attribute <code>bar</code> on the instance; <code>foo.bar = 'spam'</code>.</p></li>
<li><p>The <code>cached_property</code> <code>__get__</code> method returns the <code>'spam'</code> return value.</p></li>
<li><p>If you ask for <code>foo.bar</code> again, Python finds the <code>bar</code> attribute on the instance, and uses that from here on out.</p></li>
</ul>
<p>Also see the <a href="https://github.com/mitsuhiko/werkzeug/blob/0e1b8c4fe598725b343085c5a9a867e90b966db6/werkzeug/utils.py#L35-L73" rel="nofollow noreferrer">source code for the original Werkzeug implementation</a>:</p>
<blockquote>
<pre><code># implementation detail: this property is implemented as non-data
# descriptor.  non-data descriptors are only invoked if there is
# no entry with the same name in the instance's __dict__.
# this allows us to completely get rid of the access function call
# overhead.  If one choses to invoke __get__ by hand the property
# will still work as expected because the lookup logic is replicated
# in __get__ for manual invocation.
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Thank you very much for this explanation. You have explained this concept clearly so that even a novice, such as myself, can understand.</span>
