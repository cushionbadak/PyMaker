<div class="post-text" itemprop="text">
<p>I have to read a text file into Python. The file encoding is:</p>
<pre><code>file -bi test.csv 
text/plain; charset=us-ascii
</code></pre>
<p>This is a third-party file, and I get a new one every day, so I would rather not change it. The file has non ascii characters, such as Ö, for example. I need to read the lines using python, and I can afford to ignore a line which has a non-ascii character.</p>
<p>My problem is that when I read the file in Python, I get the UnicodeDecodeError when reaching the line where a non-ascii character exists, and I cannot read the rest of the file.</p>
<p>Is there a way to avoid this. If I try this:</p>
<pre><code>fileHandle = codecs.open("test.csv", encoding='utf-8');
try:
    for line in companiesFile:
        print(line, end="");
except UnicodeDecodeError:
    pass;
</code></pre>
<p>then when the error is reached the for loop ends and I cannot read the remaining of the file. I want to skip the line that causes the mistake and go on. I would rather not do any  changes to the input file, if possible.</p>
<p>Is there any way to do this?
Thank you very much.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your file doesn't appear to use the UTF-8 encoding. It is important to use the correct codec when opening a file.</p>
<p>You <em>can</em> tell <a href="https://docs.python.org/3/library/functions.html#open"><code>open()</code></a> how to treat decoding errors, with the <code>errors</code> keyword:</p>
<blockquote>
<p><em>errors</em> is an optional string that specifies how encoding and decoding errors are to be handled–this cannot be used in binary mode. A variety of standard error handlers are available, though any error handling name that has been registered with <code>codecs.register_error()</code> is also valid. The standard names are:</p>
<ul>
<li><code>'strict'</code> to raise a <code>ValueError</code> exception if there is an encoding error. The default value of <code>None</code> has the same effect.</li>
<li><code>'ignore'</code> ignores errors. Note that ignoring encoding errors can lead to data loss.</li>
<li><code>'replace'</code> causes a replacement marker (such as '?') to be inserted where there is malformed data.</li>
<li><code>'surrogateescape'</code> will represent any incorrect bytes as code points in the Unicode Private Use Area ranging from U+DC80 to U+DCFF. These private code points will then be turned back into the same bytes when the <code>surrogateescape</code> error handler is used when writing data. This is useful for processing files in an unknown encoding.</li>
<li><code>'xmlcharrefreplace'</code> is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference <code>&amp;#nnn;</code>.</li>
<li><code>'backslashreplace'</code> (also only supported when writing) replaces unsupported characters with Python’s backslashed escape sequences.</li>
</ul>
</blockquote>
<p>Opening the file with <code>'ignore'</code> or <code>'replace'</code> will then let you read the file without exceptions being raised.</p>
</div>
<span class="comment-copy">Why are you using <code>codecs.open()</code> in Python 3? <code>open()</code> handles UTF-8 <b>just fine</b>.</span>
<span class="comment-copy">I also tried using open, I get the same error</span>
<span class="comment-copy">Do you know what encoding the file is really using? It's clearly not <code>us-ascii</code> as shown by the <code>file</code> output, since it contains non-ascii characters.</span>
<span class="comment-copy">@Chicoscience: I wasn't addressing your problem; I was puzzled as to why you were using <code>codecs.open()</code> here, as it is inferior to <code>open()</code>.</span>
<span class="comment-copy">Not a problem, Martijn, thanks! Dano, that is strange to me as well, the encoding says ascii but it is clearly not ascii</span>
<span class="comment-copy">I tried to find an alternate solution by catching the decoding exceptions themselves. Unfortunately it appears (in Python 2 at least) that the decoding occurs <i>before</i> line endings are detected, so you don't get consistent results - you might lose more than one line, or you might get hung on the same buffer forever.</span>
<span class="comment-copy">This does NOT work in python 2.x.</span>
<span class="comment-copy">@AndrejGajduk: no, it doesn't and it was never intended to. The question concerns Python 3. In Python 2 you <i>can</i> use <code>io.open()</code> however (which is basically the same function).</span>
