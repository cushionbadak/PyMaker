<div class="post-text" itemprop="text">
<p>OK so my actual code is somewhat elaborate but I am illustrating the problem that I am having with the following example code:</p>
<p>I have a class that has a list as one of its instance variable. I want the class to be an iterable and return the next element in the list  when next is called in the for loop.</p>
<p>So I have as follows:</p>
<pre><code>class SimplaWannaBeIteratable(object):
    def __init__(self, list_to_iter, **kwargs)
        self._list = list_to_iter
        self._item = None
        #... other code to initialize
    def __iter__(self):
        return self
    def next(self):
        self._item= next(self._list)
        return self._item
    def current(self):
        #So that other uses cases have the access to the current member
        return self._current
</code></pre>
<p>However if I do the following: </p>
<pre><code> iter_item = SimplaWannaBeIteratable([1,2,3,4,5])
 for item in iter_item:
    return item
</code></pre>
<p>I get: </p>
<hr/>
<blockquote>
<p>list object is not an iterator.</p>
</blockquote>
<p>If I change the next as follows:</p>
<pre><code>def next(self):
    self._item= next(iter((self._list)))
    return self._item
</code></pre>
<p>I get infinite output.</p>
<p>Can anyone tell me what I need to do to accomplish the task I want to do and why the code above is not working? 
From what I understand every time next is called the iterator object associated with the list is called and its next is return. so why can't my list find its iterator?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need an iterator to iterator over a list.  A list itself is not an iterator so you cannot call <code>next()</code> on it.</p>
<pre><code>class SimplaWannaBeIteratable(object):
    def __init__(self, list_to_iter, **kwargs):
        self._list = list_to_iter
        self._item = None
    def __iter__(self):
        self._iter = iter(self._list) # create/initialize the iterator
        return self
    def __next__(self): # using the Python 3.x name
        self._item = next(self._iter) # use the iterator
        return self._item
    # ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are calling <code>next</code> on <code>self._list</code>, which is a list, not an iterator.  <code>next</code> only advances iterators, it does not set up an iterator from an iterable.</p>
<pre><code>def __init__(self, ...):
    # ...
    self._iterator = iter(self._list)

def next(self):
    self._item = next(self._iterator)
    return self._item
</code></pre>
<p>Regarding your edit, you are getting an infinite recursion because you are calling next on a fresh iterator each time, rather than the same iterator.  So you are losing the state of the iterator.  Again, see my example above, which sets up the iterator once.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow"><code>__next__</code> special method</a> that you are trying to implement is used to control iteration over a container-like class at each progressive step.  If you do not need this functionality and simply want to make your class iterable, omit the method and return <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow"><code>iter(self._list)</code></a> from <code>__iter__</code>:</p>
<pre><code>class SimplaWannaBeIteratable(object):
    def __init__(self, list_to_iter, **kwargs):
        self._list = list_to_iter
        self._item = None

    def __iter__(self):
        return iter(self._list)

    def current(self):
        return self._current
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; iter_item = SimplaWannaBeIteratable([1,2,3,4,5])
&gt;&gt;&gt; for item in iter_item:
...     item
...
1
2
3
4
5
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">If the list items will be changing, you'll have to use a different approach to go through the values. e.g., maintaining an index which your iterator is currently on and accessing the index'th value in the list and incrementing. It all depends on how you intend to use it.</span>
<span class="comment-copy"><code>__next__()</code> is for Python 3.x: <a href="http://legacy.python.org/dev/peps/pep-3114/" rel="nofollow noreferrer">legacy.python.org/dev/peps/pep-3114</a></span>
<span class="comment-copy">Thanks @Jeff Mercado. Would it still work if the list items change i.e. if I add more items on the list would this items be iterated when I later do a for</span>
<span class="comment-copy">@sharth: True, however he didn't specify version so I will assume Python 3.x.</span>
<span class="comment-copy">@JeffMercado: That's certainly fair.</span>
