<div class="post-text" itemprop="text">
<p>In lisp I used to do things like that, knowing it won't crash:</p>
<pre><code> [3]&gt; (mapcar #'+ '(1 2 3) '(1 2))
(2 4)
</code></pre>
<p>The equivalent in python seems to crash:</p>
<pre><code>&gt;&gt;&gt; map(lambda x,y : x + y, [1,2,3], [1,2])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1, in &lt;lambda&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'
</code></pre>
<p>Is there a function in python that works like the lisp version on not-equal length lists? Or, is there a way to change the behavior of map? </p>
</div>
<div class="post-text" itemprop="text">
<p>This problem is suitable for Python 2.x (thanks to @user2357112). The documentation for <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> in Python 3.x says:</p>
<blockquote>
<p>The iterator stops when the shortest input iterable is exhausted. </p>
</blockquote>
<p>So, in Python 3.x you could just use <code>map</code>:</p>
<pre><code>In [1]: list(map(lambda a, b: a + b, [1, 2, 3], [1, 2]))
Out[1]: [2, 4]
</code></pre>
<hr/>
<p>But the documentation for <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> in Python 2.x says:</p>
<blockquote>
<p>If one iterable is shorter than another it is assumed to be extended
  with None items.</p>
</blockquote>
<p>So, you should firstly <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> these lists:</p>
<pre><code>In [2]: map(sum, zip([1, 2, 3], [1, 2]))
Out[2]: [2, 4]
</code></pre>
<p>Because <code>zip</code> will truncate returned list to the length of the shortest argument sequence (as said in documentation)</p>
<p>You could also define your own function <code>zip_with</code> (<a href="https://stackoverflow.com/a/22355166/1532460">example from this answer</a>):</p>
<pre><code>import itertools

def zip_with(f, *coll):
    return itertools.starmap(f, itertools.izip(*coll))
</code></pre>
<p>Example of usage:</p>
<pre><code>In [3]: list(zip_with(operator.add, [1, 2, 3], [1, 2]))
Out[3]: [2, 4]
</code></pre>
</div>
<span class="comment-copy">+1, edited your answer with more information.</span>
<span class="comment-copy">@Tichodroma, thank you</span>
<span class="comment-copy">Note that the argument unpacking in <code>lambda (x, y): x + y</code> doesn't work in Python 3. <a href="http://legacy.python.org/dev/peps/pep-3113/" rel="nofollow noreferrer">It messed with introspection and wasn't used much.</a> That makes the transformation a bit messier in Python 3. Fortunately, Python 3's <code>map</code> already does what you want.</span>
<span class="comment-copy">The documentation you're linking is for the Python 3 version of <code>map</code>, where none of this is necessary.</span>
<span class="comment-copy">@user2357112, yes, thank you, I'm working on edit</span>
