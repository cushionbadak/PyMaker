<div class="post-text" itemprop="text">
<p>I have a list of X thread (potentially more than 100)
I want to run no more than five at the same time.</p>
<p>I came up with this :</p>
<pre><code>import os
from os import listdir
from os.path import isfile, join
import shutil
import Image
import math
import threading

CAMERA_NUMBER = 21 #there is 21 cameras, from 1 to 21
ORDERED_SCAN_OUTPUT_FOLDER = "scanData"
PRETTY_PRINT_OUTPUT_FOLDER = "preview"
ROTATION_ANGLE = 90
RATIO = 0.4
IMAGE_PER_ROW = 7
MAX_THREAD = 5

def getNumberOfScanToProcess(absolute_folder):
    folder_list = get_all_folders_from(absolute_folder)
    return len(folder_list)

    """ you have a thread list and you only want to run them 5 by 5, use this """
def runThreadListBlockByBlock(thread_list, number_of_simultanious_thread):
    print ""
    print "lauching thread list by run of " + str(number_of_simultanious_thread) + " Thread(s)"
    thread_counter = 0
    initial_count = 0
    for thread_id in range(0, len(thread_list)):
        print "lauching thread " + str(thread_id)
        thread_list[thread_id].start()
        thread_counter = thread_counter+1
        if initial_count+number_of_simultanious_thread == thread_counter:
            for thread_number in range(initial_count, thread_counter):
                print "waiting for thread " + str(thread_number)
                thread_list[thread_number].join()
            initial_count = thread_counter

class prettyPrintThread(threading.Thread):
    def __init__(self, folder_to_process, ratio, rotation_angle, image_per_row, output_folder, thread_id):
        super(prettyPrintThread, self).__init__()
        self.ratio = ratio
        self.rotation_angle = rotation_angle
        self.image_per_row = image_per_row
        self.output_folder = output_folder
        self.thread_id = thread_id
        self.folder_to_process = folder_to_process

    def run(self):
        pretty_print(self.folder_to_process, self.ratio, self.rotation_angle, self.image_per_row, self.output_folder, self.thread_id)

script_absolute_folder = os.path.abspath(os.getcwd())
stored_scan_absolute_folder = join(script_absolute_folder, ORDERED_SCAN_OUTPUT_FOLDER)
scan_count = getNumberOfScanToProcess(stored_scan_absolute_folder)

thread_list = []
#Making the thread list
for thread_number in range(0, scan_count):
    print "preparing thread number " + str(thread_number)
    thread_list.append(prettyPrintThread(join(ORDERED_SCAN_OUTPUT_FOLDER, str(thread_number).zfill(4)), RATIO, ROTATION_ANGLE, IMAGE_PER_ROW, PRETTY_PRINT_OUTPUT_FOLDER, 1))
#launch 5 thread, wait for them to finish then launch the 5 other and so on.
runThreadListBlockByBlock(thread_list, MAX_THREAD)
</code></pre>
<p>But the problem is that it wait that the 5 threads are finished,
I could launch an other thread as soon as one of them has finished.</p>
<p>Is there a way like event/listener in java to raise some kind of
flag when a thread is finished?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to do this is probably to use a <a href="https://docs.python.org/2/library/threading.html#semaphore-objects" rel="nofollow">Semaphore</a> object. Create a Semaphore with an initial value of five then have your main thread (the one that controls the others) call the Semaphore's <code>acquire()</code> method (presumably in a loop) before starting a thread. This will block when five threads have been started.</p>
<p>The threads should call the Semaphore's <code>release()</code> method when they are done, and this will wake up the main thread by allowing it's <code>acquire()</code> call to proceed, whereupon it will start another thread, and so on until there's nothing left to do.</p>
<p>Once you have finished starting threads do be careful to <code>join()</code> with the final threads to ensure they terminate before exiting the main thread.</p>
<p>A BoundedSemaphore would also allow you to detect errors where the thread was released more than it was acquired.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>ThreadPoolExecutor</code> from <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow">concurrent.futures</a> library (it has been backported to Python 2.7).</p>
<p>The usage is moreless as follows:</p>
<pre><code>executor = ThreadPoolExecutor(max_workers=5)

futures = [
    executor.submit(callable_which_gets_the_job_done, some_argument=foo)
    for foo in bar
]

for foo, future in zip(bar, futures):
    print "callable_which_gets_the_job_done(some_argument=%s) returned %s" % (
        foo, 
        future.result(),
    )
</code></pre>
<p>Executor will run <code>callable_which_gets_the_job_than(some_argument=foo)</code> with <code>foo</code> values from <code>bar</code>. Each call will be in a separate thread, the number of threads running at the same time will not exceed 5.</p>
</div>
<span class="comment-copy">This looks cool =D I'm going to try that, I'll post the code when it works, thanks!</span>
<span class="comment-copy">Your solution looks fine too but the semaphore object sound more fun</span>
<span class="comment-copy">In fact it's very likely that the <code>ThreadPoolExecutor</code> is using a semaphore under the covers. My answer may explain things better, but I suspect this is the engineering solution and have upvoted accordingly.</span>
