<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/reference/datamodel.html#object.__ne__" rel="nofollow">Python docs</a>: "when defining <code>__eq__()</code>, one should also define <code>__ne__()</code> so that the operators will behave as expected". </p>
<p>However, it appears that Python computes <code>__ne__</code> as <code>not __eq__</code> automatically:</p>
<pre><code>In [8]: class Test:
    def __eq__(self, other):
        print("calling __eq__")
   ...:         return isinstance(other, Test)
   ...:

In [9]: a = Test()

In [10]: b = Test()

In [11]: a == b
calling __eq__
Out[11]: True

In [12]: a != b
calling __eq__
Out[12]: False

In [13]: a == 1
calling __eq__
Out[13]: False

In [14]: a != 1
calling __eq__
Out[14]: True
</code></pre>
<p>So what's the point of defining <code>__ne__</code> if it's just going to be <code>return not self.__eq__(other)</code>? And furthermore, where is this behavior actually documented?</p>
<p><strong>EDIT</strong></p>
<p>Apparently it matters that I am using Python 3. In Python 2, I get</p>
<pre><code>In [1]: class Test(object):
   ...:     def __eq__(self, other):
   ...:         print("calling __eq__")
   ...:         return isinstance(other, Test)
   ...:

In [2]: a = Test()

In [3]: b = Test()

In [4]: a == b
calling __eq__
Out[4]: True

In [5]: a != b
Out[5]: True

In [6]: a == 1
calling __eq__
Out[6]: False

In [7]: a != 1
Out[7]: True
</code></pre>
<p>But the docs I referenced are the Python 3 docs. Were they just not updated?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 changed behaviour for the <code>==</code> case, see <a href="https://docs.python.org/3/whatsnew/3.0.html#operators-and-special-methods">Python 3, What's New</a>:</p>
<blockquote>
<p><code>!=</code> now returns the opposite of <code>==</code>, unless <code>==</code> returns <code>NotImplemented</code>.</p>
</blockquote>
<p>It was deemed <a href="http://hg.python.org/cpython/annotate/834da52eb2a4/Objects/typeobject.c#l2317">a useful change</a>.</p>
<p>The fact that the documentation has not been updated is indeed a <a href="http://bugs.python.org/issue4395">long standing bug</a>.</p>
<p><em>However</em>, as a comment on the report points out, if you inherit from a class that already has defined <code>__ne__</code>, overriding just <code>__eq__</code> is not enough and you'll also have to override the <code>__ne__</code> method.</p>
</div>
<span class="comment-copy">As a guess (and as such not an answer), you might want to define something e.g. <code>Rect() == Square() # True</code>, <code>Square() == Rect() # False</code> which is why they suggest you define both "so that the operators will behave as expected"</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/4352244/python-implementing-ne-operator-based-on-eq">Related question and a possible duplicate</a></span>
<span class="comment-copy">as far as I know these two methods are independent and overriding one of them doesn't mean overriding of other.</span>
<span class="comment-copy">@oleg see my top example. Overriding <code>__eq__</code> <i>does</i> implicitly define <code>__ne__</code>, at least in Python 3.</span>
<span class="comment-copy">It seems that if you do not define <code>__ne__</code> it uses <code>not</code> <code>__eq__</code>. But The truth of <code>x==y</code> does not imply that <code>x!=y</code> is false. That's why you should define both.</span>
