<div class="post-text" itemprop="text">
<p>This is more of a conceptual question. I recently saw a piece of code in Python (it worked in 2.7, and it might also have been run in 2.5 as well) in which a <code>for</code> loop used the same name for both the list that was being iterated over and the item in the list, which strikes me as both bad practice and something that should not work at all.</p>
<p>For example:</p>
<pre><code>x = [1,2,3,4,5]
for x in x:
    print x
print x
</code></pre>
<p>Yields:</p>
<pre><code>1
2
3
4
5
5
</code></pre>
<p>Now, it makes sense to me that the last value printed would be the last value assigned to x from the loop, but I fail to understand why you'd be able to use the same variable name for both your parts of the <code>for</code> loop and have it function as intended. Are they in different scopes? What's going on under the hood that allows something like this to work?</p>
</div>
<div class="post-text" itemprop="text">
<p>What does <code>dis</code> tell us:</p>
<pre><code>Python 3.4.1 (default, May 19 2014, 13:10:29)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.40)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; dis("""x = [1,2,3,4,5]
... for x in x:
...     print(x)
... print(x)""")

  1           0 LOAD_CONST               0 (1)
              3 LOAD_CONST               1 (2)
              6 LOAD_CONST               2 (3)
              9 LOAD_CONST               3 (4)
             12 LOAD_CONST               4 (5)
             15 BUILD_LIST               5
             18 STORE_NAME               0 (x)

  2          21 SETUP_LOOP              24 (to 48)
             24 LOAD_NAME                0 (x)
             27 GET_ITER
        &gt;&gt;   28 FOR_ITER                16 (to 47)
             31 STORE_NAME               0 (x)

  3          34 LOAD_NAME                1 (print)
             37 LOAD_NAME                0 (x)
             40 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             43 POP_TOP
             44 JUMP_ABSOLUTE           28
        &gt;&gt;   47 POP_BLOCK

  4     &gt;&gt;   48 LOAD_NAME                1 (print)
             51 LOAD_NAME                0 (x)
             54 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             57 POP_TOP
             58 LOAD_CONST               5 (None)
             61 RETURN_VALUE
</code></pre>
<p>The key bits are sections 2 and 3 - we load the value out of <code>x</code> (<code>24 LOAD_NAME 0 (x)</code>) and then we get its iterator (<code>27 GET_ITER</code>) and start iterating over it (<code>28 FOR_ITER</code>).  Python <em>never goes back to load the iterator again</em>. </p>
<p><em>Aside:</em> It wouldn't make any sense to do so, since it already has the iterator, and as <a href="https://stackoverflow.com/a/24690950/135978">Abhijit points out in his answer</a>, <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">Section 7.3 of Python's specification</a> actually requires this behavior).</p>
<p>When the name <code>x</code> gets overwritten to point at each value inside of the list formerly known as <code>x</code> Python doesn't have any problems finding the iterator because it never needs to look at the name <code>x</code> again to finish the iteration protocol.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using your example code as the core reference</p>
<pre><code>x = [1,2,3,4,5]
for x in x:
    print x
print x
</code></pre>
<p>I would like you to refer the section <a href="https://docs.python.org/2/reference/compound_stmts.html#the-for-statement" rel="noreferrer">7.3. The for statement</a> in the manual</p>
<p><strong>Excerpt 1</strong></p>
<blockquote>
<p>The expression list is evaluated once; it should yield an iterable
  object. An iterator is created for the result of the expression_list.</p>
</blockquote>
<p>What it means is that your variable <code>x</code>, which is a symbolic name of an object <code>list</code> : <code>[1,2,3,4,5]</code> is evaluated to an iterable object. Even if the variable, the symbolic reference changes its allegiance, as the <a href="https://docs.python.org/2/reference/expressions.html#grammar-token-expression_list" rel="noreferrer">expression-list</a> is not evaluated again, there is no impact to the iterable object that has already been evaluated and generated.</p>
<p><strong>Note</strong></p>
<ul>
<li>Everything in Python is an Object, has an Identifier, attributes and methods. </li>
<li>Variables are Symbolic name, a reference to one and only one object at any given instance.</li>
<li>Variables at run-time can change its allegiance i.e. can refer to some other object. </li>
</ul>
<p><strong>Excerpt 2</strong></p>
<blockquote>
<p>The suite is then executed once for each item provided by the
  iterator, in the order of ascending indices.</p>
</blockquote>
<p>Here the suite refers to the iterator and not to the expression-list. So, for each iteration, the iterator is executed to yield the next item instead of referring to the original expression-list. </p>
</div>
<div class="post-text" itemprop="text">
<p>It is necessary for it to work this way, if you think about it. The expression for the sequence of a <code>for</code> loop could be anything:</p>
<pre><code>binaryfile = open("file", "rb")
for byte in binaryfile.read(5):
    ...
</code></pre>
<p>We can't query the sequence on each pass through the loop, or here we'd end up reading from the <em>next</em> batch of 5 bytes the second time. Naturally Python must in some way store the result of the expression privately before the loop begins.</p>
<hr/>
<blockquote>
<p>Are they in different scopes?</p>
</blockquote>
<p>No. To confirm this you could keep a reference to the original scope dictionary (<a href="https://docs.python.org/2/library/functions.html#locals" rel="nofollow noreferrer">locals()</a>) and notice that you are in fact using the same variables inside the loop:</p>
<pre><code>x = [1,2,3,4,5]
loc = locals()
for x in x:
    print locals() is loc  # True
    print loc["x"]  # 1
    break
</code></pre>
<hr/>
<blockquote>
<p>What's going on under the hood that allows something like this to
  work?</p>
</blockquote>
<p><a href="https://stackoverflow.com/a/24690060/933416">Sean Vieira</a> showed exactly what is going on under the hood, but to describe it in more readable python code, your <code>for</code> loop is essentially equivalent to this <code>while</code> loop:</p>
<pre><code>it = iter(x)
while True:
    try:
        x = it.next()
    except StopIteration:
        break
    print x
</code></pre>
<p>This is different from the traditional indexing approach to iteration you would see in older versions of Java, for example:</p>
<pre><code>for (int index = 0; index &lt; x.length; index++) {
    x = x[index];
    ...
 }
</code></pre>
<p>This approach would fail when the item variable and the sequence variable are the same, because the sequence <code>x</code> would no longer be available to look up the next index after the first time <code>x</code> was reassigned to the first item.</p>
<p>With the former approach, however, the first line (<code>it = iter(x)</code>) requests an <a href="https://docs.python.org/2/glossary.html#term-iterator" rel="nofollow noreferrer">iterator object</a> which is what is actually responsible for providing the next item from then on. The sequence that <code>x</code> originally pointed to no longer needs to be accessed directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's the difference between a variable (x) and the object it points to (the list). When the for loop starts, Python grabs an internal reference to the object pointed to by x. It uses the object and not what x happens to reference at any given time.</p>
<p>If you reassign x, the for loop doesn't change. If x points to a mutable object (e.g., a list) and you change that object (e.g., delete an element) results can be unpredictable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically, the for loop takes in the list <code>x</code>, and then, storing that as a temporary variable, <strong>re</strong>assigns a <code>x</code> to each value in that temporary variable. Thus, <code>x</code> is now the last value in the list.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; [x for x in x]
[1, 2, 3]
&gt;&gt;&gt; x
3
&gt;&gt;&gt; 
</code></pre>
<hr/>
<p>Just like in this:</p>
<pre><code>&gt;&gt;&gt; def foo(bar):
...     return bar
... 
&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; for x in foo(x):
...     print x
... 
1
2
3
&gt;&gt;&gt; 
</code></pre>
<p>In this example, <code>x</code> is stored in <code>foo()</code> as <code>bar</code>, so although <code>x</code> is being reassigned, it still exist(ed) in <code>foo()</code> so that we could use it to trigger our <code>for</code> loop.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>x</code> no longer refers to the original <code>x</code> list, and so there's no confusion. Basically, python remembers it's iterating over the original <code>x</code> list, but as soon as you start assigning the iteration value (0,1,2, etc) to the name <code>x</code>, it no longer refers to the original <code>x</code> list. The name gets reassigned to the iteration value.</p>
<pre><code>In [1]: x = range(5)

In [2]: x
Out[2]: [0, 1, 2, 3, 4]

In [3]: id(x)
Out[3]: 4371091680

In [4]: for x in x:
   ...:     print id(x), x
   ...:     
140470424504688 0
140470424504664 1
140470424504640 2
140470424504616 3
140470424504592 4

In [5]: id(x)
Out[5]: 140470424504592
</code></pre>
</div>
<span class="comment-copy">As an interesting thought experiment: define a function printAndReturn that takes an argument, prints it, and returns is.  Then in <code>for i in printAndReturn [1,2,3,4,5] â€¦</code>, how many times should <code>[1,2,3,4,5]</code> be printed?</span>
<span class="comment-copy">A note on scope, since no one else directly mentioned it:  Python has function-level scoping, but nothing like C's block-level scoping.  So the inside and the outside of the <code>for</code> loop have the same scope.</span>
<span class="comment-copy">I corrected the title of the question, as is was a bit misleading. Just because something is bad practice it does not mean it does not work. It may just be that it is more prone to error, or difficult to read/maintain, etc.</span>
<span class="comment-copy">Thank you. I completely agree that it was a bad title, I just didn't know what to name it initially.</span>
<span class="comment-copy">this works in php also <code>for ($x as $x)</code> but is ugly code IMO</span>
<span class="comment-copy">"Python never goes back to load the iterator again (it wouldn't make any sense to do so, since it already has the iterator)." This describes the behavior that you observe in the disassembly, but it doesn't say whether that <i>has</i> to be the case or not;  <a href="http://stackoverflow.com/a/24690950/1281433">Abhijit's answer</a> cites the manual where this is actually specified.</span>
<span class="comment-copy">Actually, in the last example, I don't think <code>x</code> is being reassigned. A local variable <code>bar</code> is created in <code>foo</code> and assigned the value of <code>x</code>. <code>foo</code> then returns that value in the form of an object that is used in the <code>for</code> condition. Thus, the variable <code>x</code> never was reassigned in the second example. I agree with the first one though.</span>
<span class="comment-copy">@Tonio <code>x</code> is still the iteration variable though and thus takes a new value for each loop. After the loop, <code>x</code> is equal to <code>3</code> in both cases.</span>
<span class="comment-copy">@PeterGibson You are absolutely right, it slipped past my attention.</span>
<span class="comment-copy">If it were a "a new variable" inside the loop, then how come after the loop <code>x</code> holds <code>3</code> and <code>not </code>[1,2,3]`?</span>
<span class="comment-copy">@JoshuaTaylor In python the loop index variable is lexically scoped to the block in which the for loop occurred.</span>
<span class="comment-copy">It doesn't so much make a copy of the range list (as changes to the list would still produce undefined behavior in the iteration). <code>x</code> just stops referring to the range list and is instead assigned the new iteration values. The range list still exists intact. If you look at the value of <code>x</code> after the loop, it will be <code>4</code></span>
<span class="comment-copy">yes, you appear to have the right of it</span>
<span class="comment-copy">"x no longer refers to the original x" <code>x</code> never referred to <code>x</code>;  <code>x</code> referred to a sequence.  Then it referred to <code>1</code>, then to <code>2</code>, etc.</span>
