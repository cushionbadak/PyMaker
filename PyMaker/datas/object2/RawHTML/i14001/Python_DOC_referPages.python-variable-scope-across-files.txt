<div class="post-text" itemprop="text">
<p>I know that it's possible to share a global variable across modules in Python. However, I would like to know the extent to which this is possible and why. For example, </p>
<p>global_mod.py</p>
<pre><code>x = None
</code></pre>
<p>mid_access_mod.py</p>
<pre><code>from global_mod import *

class delta:
    def __init__(self):
        print x
</code></pre>
<p>bot_modif_mod.py</p>
<pre><code>import mid_access_mod
import global_mod

class mew:
    def __init__(self):
        global_mod.x = 5

def main():
    m = mew()
    d = mid_access_mod.delta()
</code></pre>
<p>This prints None, even though all the modules are sharing the global variable x. Why is this the case? It seems like x is evaluated at mid_access_mod.py before it is assigned in bot_modif_mod.py by mew().</p>
</div>
<div class="post-text" itemprop="text">
<p>This happens because you are using immutable values (ints and None), and importing variables is like passing things by value, not passing things by reference.</p>
<p>If you made global_mod.x a list, and manipulated its first element, it would work as you expect.</p>
<p>When you do <code>from global_mod import x</code>, you are creating a name <code>x</code> in your module with the same value as <code>x</code> has in <code>global_mod</code>.  For things like functions and classes, this works as you would expect, because people (generally) don't re-assign to those names later.</p>
<p>As Alex points out, if you use <code>import global_mod</code>, and then <code>global_mod.x</code>, you will avoid the problem.  The name you define in your module will be <code>global_mod</code>, which always refers to the module you want, and then using attribute access to get at <code>x</code> will get you the latest value of <code>x</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>from whatever import *</code> is <strong>not</strong> a good idiom to use in your code -- it's intended for use, if ever, in an interactive session as a shortcut to save some typing.  It basically "snapshots" all names from the module at that point in time -- if you ever rebind any of those names, the snapshot will have grown stale and all sort of problems will ensue.  And that's only the beginning of the inextricable mess you're signing up for by using the wretched <code>from ... import *</code> construct.</p>
<p>Want my advice?  Forget you ever heard about that construct existing and never, ever use it again.  Use <code>import global_mod as m</code> and always use thereafter <strong>qualified</strong> names such as <code>m.x</code> -- qualified names are <strong>so</strong> much handier and more powerful in Python, than mere barenames, that it ain't even funny.  (The <code>as m</code> part of the <code>import</code> statement is totally optional and basically exists for conciseness purposes, or sometimes to work around some issues with name clashes; use it when and if you find it handy, since it has no downsides, but don't feel forced or even urged to use if when you don't feel it's necessary).</p>
</div>
<div class="post-text" itemprop="text">
<p>I modified the example to use a list for x, and list assigns (x[0] = ..) as suggested in the top answer, and the print returned the same initial value (None)..This verifies that the "from global_mod import *" is a copy regardless of mutable or not. </p>
<p>As suggested in the comment "import global_mod" works, if "print global_mod.x = is then used in mid_access_mod.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Ned Batchelder mentioned, only the values are shared and not the actual object. If you want to share an object by reference, then you are probably looking <code>Thread-Local Data</code>.</p>
<p>Eg:</p>
<pre><code>import threading

g = threading.local()
g.population = '7 Billion'
</code></pre>
<p>Now, whenever you want to access or change the variable g.population, you will get an updated value of it, provided it is the same thread you are trying to access it from.</p>
<p>Read more in the Python documentation:<a href="https://docs.python.org/3/library/threading.html#thread-local-data" rel="nofollow">https://docs.python.org/3/library/threading.html#thread-local-data</a></p>
</div>
<div class="post-text" itemprop="text">
<p>To solve this problem, just change <code>from global_mod import *</code> to <code>import global_mod</code>.</p>
<p>And the new <strong>mid_access_mod.py</strong> will be:</p>
<pre><code>import global_mod

class delta:
    def __init__(self):
        print global_mod.x
</code></pre>
<p>The reason for that could be found <a href="https://stackoverflow.com/questions/710551/import-module-or-from-module-import#19185936">here</a>.</p>
<blockquote>
<p>Due to the way references and name binding works in Python, if you want to update some symbol in a module, say foo.bar, from outside that module, and have other importing code "see" that change, you have to import foo a certain way.</p>
</blockquote>
</div>
<span class="comment-copy">I think your answer here is misleading. The issue not primarily one arising from the use of mutable or immutable types, but rather of using <code>from modulename import *</code> instead of <code>import modulename</code>. If you take emish's code and change global_mod.py to be <code>x = ['starting list']</code> and then change the reassignment in bot_modif_mod.py to <code>global_mod.x = ['new list']</code> you'll find that this prints "['starting list']". The real issue, as Alex Martinelli states is that <code>from modulename import *</code> snapshots. I hope other users aren't similarly confused as I was.</span>
<span class="comment-copy">I believe that what @Ned is tying to say is that, given that <code>x= ['starting list']</code>, one should edit the value by doing <code>x[0] = 'new value'</code>, rather than assigning the value to be a completely new list (<code>x = ['new list']</code>)</span>
