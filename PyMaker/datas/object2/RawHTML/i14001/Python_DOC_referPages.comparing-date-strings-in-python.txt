<div class="post-text" itemprop="text">
<pre><code>&gt;&gt; a ='2009-05-10'
&gt;&gt;&gt; b ='2009-06-10'
&gt;&gt;&gt; a &gt; b
False
&gt;&gt;&gt; a &lt; b
True
&gt;&gt;&gt; type(a)
&lt;class 'str'&gt;
&gt;&gt;&gt; c = '2009-06-09'
&gt;&gt;&gt; b &lt; c
False
&gt;&gt;&gt; b &gt; c
True
&gt;&gt;&gt; c ='2008-07'
&gt;&gt;&gt; b &gt; c
True
&gt;&gt;&gt; a &gt; c
True
</code></pre>
<p>I tried to compare dates in python3 without using a library and it seems to be working correctly. 
Is this the real case? Does python really understands that these strings are dates and comparing them according to date format or is something else is going on behind the scenes ?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, there is no spacial thing behind this behavior. As a matter of fact, Python compares the strings lexicographicaly and in this case it works, but it's not the right way to go, because it can also accepts the wrong dates!</p>
<p>Here is a <strong>Counterexample</strong>:</p>
<pre><code>&gt;&gt;&gt; a ='2009-33-10'
&gt;&gt;&gt; b ='2009-11-1'
&gt;&gt;&gt; a&gt;b
True
</code></pre>
<p>As a proper way for dealing with dates you should use <a href="https://docs.python.org/3/library/datetime.html" rel="noreferrer"><code>datetime</code></a> module which has a lot of tools for working with date objects.</p>
<p>You can convert your strings to date object with <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime" rel="noreferrer"><code>datetime.datetime.strptime</code></a> and then you can use basic arithmetic operation to compare your date objects, as they've been supported already by this module.</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/6930M.png"/> </p>
</div>
<span class="comment-copy">If you pick a sensible date format like that, the standard lexicographical sorting of strings works as if it knew they were dates; it <b>doesn't</b>, though.</span>
<span class="comment-copy">If Python simply analyzed your string contents to figure out what they represented, why would it have a built-in <a href="https://docs.python.org/2/library/datetime.html" rel="nofollow noreferrer">datetime</a> module?</span>
<span class="comment-copy">Yup. Things are clear now. Thanks.</span>
<span class="comment-copy">That is why <a href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow noreferrer">ISO 8601</a> has <code>YYYYMMDD</code> and lets <a href="https://en.wikipedia.org/wiki/Lexicographical_order" rel="nofollow noreferrer">lexicographical sorting</a> take care of the rest. The dates are not parsed or validated.</span>
<span class="comment-copy">Yes this ISO‑8601 (YYYY‑MM‑DD) <a href="https://developers.facebook.com/docs/marketing-api/dynamic-product-ads/product-catalog" rel="nofollow noreferrer">developers.facebook.com/docs/marketing-api/dynamic-product-ads/…</a></span>
<span class="comment-copy">@Kasramvd there is no problem with your explanation. However, is the context of when datetime strings are uniformly formatted (so that your example doesn't apply) and were formatted directed from the datetime objects, then the direct datetime string comparison is actually a nice perk of Python3!</span>
<span class="comment-copy">@Devy Indeed, in that case you can. But, basically you better to not do that (cause generally it's not guaranteed to always receive a consistent format) unless it can gives you a significant change in performance.</span>
