<div class="post-text" itemprop="text">
<p>Does anyone have an example on how to do a multipart post in Python 3.4 without using a 3rd party library like requests?  </p>
<p>I am having issues porting my old Python 2 code to Python 3.4.</p>
<p>Here is the python 2 encoding code:</p>
<pre><code>def _encode_multipart_formdata(self, fields, files):
    boundary = mimetools.choose_boundary()
    buf = StringIO()
    for (key, value) in fields.iteritems():
        buf.write('--%s\r\n' % boundary)
        buf.write('Content-Disposition: form-data; name="%s"' % key)
        buf.write('\r\n\r\n' + self._tostr(value) + '\r\n')
    for (key, filepath, filename) in files:
        if os.path.isfile(filepath):
            buf.write('--%s\r\n' % boundary)
            buf.write('Content-Disposition: form-data; name="%s"; filename="%s"\r\n' % (key, filename))
            buf.write('Content-Type: %s\r\n' % (self._get_content_type3(filename)))
            file = open(filepath, "rb")
            try:
                buf.write('\r\n' + file.read() + '\r\n')
            finally:
                file.close()
    buf.write('--' + boundary + '--\r\n\r\n')
    buf = buf.getvalue()
    content_type = 'multipart/form-data; boundary=%s' % boundary
    return content_type, buf
</code></pre>
<p>The I figured out I can replace the mimetools.choose_boundary() with the following:</p>
<pre><code>import email.generator
print (email.generator._make_boundary())
</code></pre>
<p>For the _get_content_type3() method, I am doing the following:</p>
<pre><code>def _get_content_type(self, filename):
        return mimetypes.guess_type(filename)[0] or 'application/octet-stream'
</code></pre>
<p>When I change the StringIO to BytesIO in using Python3.4, the data never seems to be put into the POST method.</p>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <code>email.generator._make_boundary()</code> would work:</p>
<pre><code>import email.generator
import io
import shutil

def _encode_multipart_formdata(self, fields, files):
    boundary = email.generator._make_boundary()
    buf = io.BytesIO()
    textwriter = io.TextIOWrapper(
        buf, 'utf8', newline='', write_through=True)

    for (key, value) in fields.items():
        textwriter.write(
            '--{boundary}\r\n'
            'Content-Disposition: form-data; name="{key}"\r\n\r\n'
            '{value}\r\n'.format(
                boundary=boundary, key=key, value=value))

    for (key, filepath, filename) in files:
        if os.path.isfile(filepath):
            textwriter.write(
                '--{boundary}\r\n'
                'Content-Disposition: form-data; name="{key}"; '
                'filename="{filename}"\r\n'
                'Content-Type: {content_type}\r\n\r\n'.format(
                    boundary=boundary, key=key, filename=filename,
                    content_type=self._get_content_type3(filename)))
            with open(filepath, "rb") as f:
                shutil.copyfileobj(f, buf)
            textwriter.write('\r\n')

    textwriter.write('--{}--\r\n\r\n'.format(boundary))
    content_type = 'multipart/form-data; boundary={}'.format(boundary)
    return content_type, buf.getvalue()
</code></pre>
<p>This uses a <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow"><code>io.TextIOWrapper()</code> object</a> to make header formatting and encoding easier (<code>bytes</code> objects don't support formatting operations; you'll have to wait for Python 3.5 which adds <code>%</code> support).</p>
<p>If you insist on using the <code>email</code> package for the whole job, take into account that you'll need twice the memory; once to hold the <code>email.mime</code> objects, and again to hold the written result:</p>
<pre><code>from email.mime import multipart, nonmultipart, text
from email.generator import BytesGenerator
from email import policy
from io import BytesIO

def _encode_multipart_formdata(self, fields, files):
    msg = multipart.MIMEMultipart('form-data')

    for (key, value) in fields.items():
        part = text.MIMEText(value)
        part['Content-Disposition'] = 'form-data; name="{}"'.format(key)
        msg.attach(part)

    for (key, filepath, filename) in files:
        if os.path.isfile(filepath):
            ct = self._get_content_type3(filename)
            part = nonmultipart.MIMENonMultipart(*ct.split('/'))
            part['Content-Disposition'] = (
                'form-data; name="{}"; filename="{}"'.format(
                    key, filename))
            with open(filepath, "rb") as f:
                part.set_payload(f.read())
            msg.attach(part)

    body = BytesIO()
    generator = BytesGenerator(
        body, mangle_from_=False, policy=policy.HTTP)
    generator.flatten(msg)
    return msg['content-type'], body.getvalue().partition(b'\r\n\r\n')[-1]
</code></pre>
<p>The result is otherwise basically the same, with the addition of some <code>MIME-Version</code> and <code>Content-Transfer-Encoding</code> headers.</p>
</div>
<span class="comment-copy">Hint: See how requests does it and then do that.</span>
<span class="comment-copy">@IanAuld are you serious?  no help at all?</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/1270518/4279">Python standard library to POST multipart/form-data encoded data</a>. See also, <a href="https://github.com/shazow/urllib3/blob/21a288be4487040c6e21e27cec025b74d2a83152/urllib3/filepost.py#L58-L93" rel="nofollow noreferrer"><code>urllib3.filepost</code></a>. Both provide solutions that work on Python 2 and 3</span>
<span class="comment-copy">There are <code>poster</code> (pure Python, standalone, no Python 3 support?), <code>urllib3.filepost</code> (may depend on other parts), distutils' upload_file` (specialized to upload files to pypi), <code>MultipartPostHandler</code> (Python 2), patches for <a href="http://bugs.python.org/issue3244" rel="nofollow noreferrer">"multipart/form-data encoding" Python issue</a>.</span>
<span class="comment-copy">@J.F.Sebastian: but the OP asked for a no-3rd-party library solution, so now we have another one.</span>
<span class="comment-copy">I'm just surprised that there is no <code>multipart_encode()</code> equivalent somewhere in <code>email.mime</code> package in stdlib.</span>
<span class="comment-copy">@J.F.Sebastian: there is, but it is <a href="https://hg.python.org/cpython/file/1cae77f873af/Lib/email/generator.py#l252" rel="nofollow noreferrer">rather buried</a>; you need to build a tree of <code>Message</code> objects, and the resulting generated message contains a complete email structure, not just the encoded multipart body. You then have to remove the extra headers again.</span>
<span class="comment-copy">@MartijnPieters - thank you, I'm going to test this now!</span>
