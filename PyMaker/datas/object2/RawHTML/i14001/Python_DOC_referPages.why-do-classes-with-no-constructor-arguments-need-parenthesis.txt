<div class="post-text" itemprop="text">
<p>I started off learning programming/OOP in PHP. To the best of my knowledge of best practices in PHP, you can instantiate a class without parenthesis if it does not take any arguments.</p>
<p>Such as </p>
<pre><code>$class = new Class;
</code></pre>
<p>As opposed to:</p>
<pre><code>$class = new Class();
</code></pre>
<p>I am starting to expand my skills into python and wasted about 5 hours yesterday trying to figure out why a function wouldn't pass an argument even though it was ridiculously simple. My Code:</p>
<pre><code>class MainViewWidgets(MainViewContainer):

    def __init__(self):
        # instantiating like this prevents MainViewController.getHeaderItems from returning the arg passed to it, however the code still "works" in some sense
        self.controller = MainViewController 

        #this works
        self.controller = MainViewController()

    def createHeaderOptionCheckbox(self, pane):
        self.header_string = StringVar()
        header_checkbox = ttk.Checkbutton(pane, text='Data Contains Headers', variable=self.header_string, onvalue='headers', offvalue='keys')
        self.header_string.trace('w', self.headerOptionCheckboxChanged)
        return header_checkbox

    def headerOptionCheckboxChanged(self, *args):
        print(self.header_string.get())
        #will print "headers" or "keys" on checkbox toggle
        print(self.controller.getHeaderItems(self.header_string.get()))
        #prints "default"

class MainViewController:

    def __init__(self):
        self.CheckFile = CheckFile()
        get_config = GetConfiguration('config.ini')
        self.config_file = get_config.getProperty('directory', 'input_file')
        self.csv = CSVReader(self.config_file)
        self.chosen_index = None

    def getHeaderItems(self, header='default'):
        return header
</code></pre>
<p>Can someone please help me understand why in Python you need to instantiate a class with parenthesis even if there are no constructor arguments other than <code>self</code>. Also, why did the <code>MainViewController</code> still kind of work, but it did not behave as I wanted it to? As in it was loaded, and the functions "did things", but it would not seem to accept arguments. Is there any advantages of instantiating a class without its parenthesis?</p>
<p>Please note, I do not need help getting this code to work, I just want to understand why this happens.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Can someone please help me understand why in Python you need to instantiate a class with parenthesis even if there are no constructor arguments other than self.</p>
</blockquote>
<p>The reason is simple: when you instantiate an object, you are actually <em>calling</em> its class (which is itself an object), and you call objects using <code>()</code>. </p>
<p>In python, <em>everything is a first-class object</em>, even classes (and functions!) themselves. In order for a class to be a first class object, it follows that the class needs its own class (<a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">metaclass</a>) to define its behavior. We call the class of a class "metaclass" so as to avoid confusion when talking about classes and classes of classes. </p>
<p>To answer the second part of your question: "things" were happening when you used <code>MainViewController</code> instead of <code>MainViewController()</code> because <code>MainViewController</code> <em>is a full-fledged object</em>, just like any other object. </p>
<p>So you might ask: what is the class - actually the metaclass - of the <code>MainViewController</code> object? </p>
<hr/>
<p>As you know, you can create a class like this: </p>
<pre><code>class MyClass: 
    pass
</code></pre>
<p>When you do this, you are in actuality creating a new instance of the <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer">metaclass known as <code>type</code></a>. </p>
<p>Note that you can create the same class this way; there is literally no difference between the below and the above: </p>
<pre><code>MyClass = type('MyClass', (object,), {}) 
</code></pre>
<hr/>
<p>The <code>type</code> metaclass is the base metaclass of all classes. All python "new style classes" (not so "new" anymore since they were implemented in python 2.1, I believe) are of the class <code>type</code>:</p>
<pre><code>print(type(MyClass)) # type
print(type(list)) # type
print(type(int)) # type
# Note that above, type is being used as a "function" (it's really just a callable)
</code></pre>
<p>Interestingly enough, <code>type</code> is even its own metaclass:</p>
<pre><code>print(type(type)) # type
</code></pre>
<p>So to reiterate: the class <code>MyClass</code> is actually an instantiation of <code>type</code>. It follows, then, that <em>calling</em> the class results in running the <code>__call__</code> method of its metaclass. </p>
<p>When you do: </p>
<pre><code>obj = MyClass()
</code></pre>
<p>...you are <em>calling</em> <code>MyClass</code>, which results (in the background) in running the method <code>type.__call__()</code>. </p>
<p>This is the case with all user defined classes, btw; if you include the <code>__call__</code> method in your class, your class is callable, and the <code>__call__</code> method is executed when you call class instances: </p>
<pre><code>class MyCallable():
    def __call__(self):
        print("You rang?") 

my_instance = MyCallable()
my_instance() # You rang?
</code></pre>
<p>You can see this in action. If you create your own metaclass by subclassing <code>type</code>, you can cause things to happen when an instance of the class based on your custom metaclass is created. For example: </p>
<pre><code>class MyMeta(type):
    def __call__(self, *args, **kwargs):
        print "call: {} {} {}".format(self, args, kwargs)
        return super().__call__(*args, **kwargs)

# Python 3: 

class MyClass(metaclass = MyMeta):
    pass

# Python 2: 

class MyClass():
    __metaclass__ = MyMeta
    pass
</code></pre>
<p>Now when you do <code>MyClass()</code>, you can see that the <code>__call__</code> method of <code>MyMeta</code> happens before anything else (including before <code>__new__</code> AND before <code>__init__</code>). </p>
</div>
<div class="post-text" itemprop="text">
<p>Because function calls require <code>()</code>. When you do <code>MyClass()</code>, you are calling <code>MyClass</code>. The expression <code>MyClass</code> evaluates to the class itself, which is an object.</p>
</div>
<span class="comment-copy">Because it is the way Python syntax is defined.</span>
<span class="comment-copy">try <code>merp = MainViewController; print(merp())</code> :P</span>
<span class="comment-copy">The long and short of it is you can pass around classes just as well as you can pass around class instances. So <code>self.controller = MainViewController</code> assigns the <code>class</code> MainViewController to self.controller. If you wanted an instance, you need the parens.</span>
<span class="comment-copy">Thank you, that definitely clears it up for me.</span>
<span class="comment-copy">You can even <a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">get real meta</a> with python</span>
<span class="comment-copy">This is true, and informative, but not really an answer.</span>
<span class="comment-copy">I chose to focus on the first question since it seemed to be the main concern.</span>
