<div class="post-text" itemprop="text">
<p>I have written a Sudoku solver for very easy Sudoku problems in Python. How it works is by checking each empty square, and if there is only one possible number that is legal, then replace the empty square with that number. Once it has gone through the whole puzzle, if there are still more than 1 empty squares, it calls itself again with the new puzzle. The part where I am having problems is I want the solver to check at the end of each call if the puzzle is the same as it was at the beginning of the call, and if it has not changed that means that all remaining empty squares have more than 1 possible value, and therefore the solver should return False to indicate that the solver isn't capable of solving that particular puzzle. However, when I tried to implement this, the Solver only goes through the puzzle once and returns False. Here is my code:</p>
<pre><code>def Solver(puzzle):

    oldpuzzle = puzzle
    count = 0

    for row in range(9):

        for col in range(9):
            if puzzle[row][col] == '0':
                possible, numpossible = getPossible(puzzle, row, col)

                if numpossible == 1:
                    puzzle[row][col] = possible[0]
        count += puzzle[row].count('0')

    if count &gt; 0:
        if oldpuzzle == puzzle:
            return False
        else:
            Solver(puzzle)
    else:
        return True
</code></pre>
<p>The getPossible() function returns a list of possible values and the length of the list.</p>
<p>Here is the main() function:</p>
<p><pre>def main():</pre></p>
<code>puzzle = [
['0','2','0','1','7','8','0','3','0'],
['0','4','0','3','0','2','0','9','0'],
['1','0','0','0','0','0','0','0','6'],
['0','0','8','6','0','3','5','0','0'],
['3','0','0','0','0','0','0','0','4'],
['0','0','6','7','0','9','2','0','0'],
['9','0','0','0','0','0','0','0','2'],
['0','8','0','9','0','1','0','6','0'],
['0','1','0','4','3','6','0','5','0']
]

if Solver(puzzle):
    print "Solved!"
    for row in puzzle:
        print ' '.join(row)
else:
    print "Failed!"
</code></div>
<div class="post-text" itemprop="text">
<p>Your problem is that the line:</p>
<pre><code>oldpuzzle = puzzle
</code></pre>
<p>Makes a <strong>reference</strong> to <code>puzzle</code> called <code>oldpuzzel</code> <strong>not</strong> a copy so they are always the same - you need to either copy the <code>puzzle</code> to <code>oldpuzzle</code> with <code>copy.copy</code> or more simply set a flag:</p>
<pre><code>def Solver(puzzle):
   Changed = False
</code></pre>
<p>and in the:</p>
<pre><code>          if numpossible == 1:
               Changed = True
</code></pre>
<p>Then check changed if it is False return it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are setting the reference of <code>puzzle</code> to <code>oldpuzzle</code> , hence if you do any changes to <code>puzzle</code> , it will reflect in <code>oldpuzzle</code> as well. and <code>puzzle</code> would always be equal to <code>oldpuzzle</code>.</p>
<p>I do not think you need to set the puzzle to old puzzle (or you need to save the complete puzzle at the start).</p>
<p>According to the logic, the number of <code>0</code> cells would never increase and a cell that is marked non-zero previously would never become marked <code>0</code> .</p>
<p>Hence you can just store the count of <code>0</code>s at the start, and then at the end check if the count of <code>0</code>s has changed or not, if it has then good, otherwise return False.</p>
<p>Example code -</p>
<pre><code>def Solver(puzzle):

    oldcount = sum(1 for row in puzzle for cell in row if cell == '0')
    count = 0

    for row in range(9):

        for col in range(9):
            if puzzle[row][col] == '0':
                possible, numpossible = getPossible(puzzle, row, col)

                if numpossible == 1:
                    puzzle[row][col] = possible[0]
        count += puzzle[row].count('0')

    if count &gt; 0:
        if oldcount == count:
            return False
        else:
            Solver(puzzle)
    else:
        return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>if oldpuzzle == puzzle</code> will always be true because when <code>oldpuzzle</code> is created it doesn't become a copy of the puzzle list but rather a duplicate. This means that if you change <code>puzzle</code> then <code>oldpuzzle</code> will also change.</p>
<pre><code>list1 = [1, 2, 3]
list2 = list1
list1[0] = 4
print(list2)
# this will print [4, 2, 3]
</code></pre>
<p>One way to make <code>oldpuzzle</code> a copy of <code>puzzle</code> is to use the copy library. In this case it is required to make a deep copy of <code>puzzle</code> because it is a list with list in it. One way to do this is to use the <a href="https://docs.python.org/3/library/copy.html?highlight=copy#copy.deepcopy" rel="nofollow">deep copy function from the copy library</a>. So the function would look something like this:</p>
<pre><code>from copy import deepcopy # at the top of the document

def Solver(puzzle):

    oldpuzzle = deepcopy(puzzle)
    count = 0

    # ... and then the rest
</code></pre>
</div>
<span class="comment-copy">Looks like <code>getPossible()</code> might be returning something other than <code>1</code> for <code>numpossible</code>, which would mean that <code>puzzle</code> doesn't get modified.</span>
<span class="comment-copy">I don't think that's the case, because if i remove the if statement at the very end and just let the Solver recurse infinitely and I add a print statement every time, you can see that it does change the puzzle. Also, I have already been able to solve some easy puzzles with this program, I am just having problems with the harder puzzles</span>
<span class="comment-copy">Ahh, I see, I was thinking it might have been something like that but I wasn't sure how to check.</span>
