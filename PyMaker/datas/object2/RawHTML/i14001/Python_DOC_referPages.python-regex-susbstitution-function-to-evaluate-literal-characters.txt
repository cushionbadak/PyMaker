<div class="post-text" itemprop="text">
<p>I am developing an application where I need to search and substitute strings in a body of text.</p>
<p>I came across <a href="https://stackoverflow.com/questions/13814330/string-replacement-with-dictionary-complications-with-punctuation">this SO post</a> and have been using the 3rd answer as the basis of my function.</p>
<p>My code looks like:</p>
<pre><code>subs_dict = {
    "INT.": "Internet",
    ...
}

def substitutions(self, text):
    return re.sub(
        r'\b' + '|'.join(subs_dict.keys())
        + r'\b', lambda m: subs_dict[m.group(0)],
        text
    )
</code></pre>
<p>However, this gets tripped up by text such as <code>"The INTREPID explorer"</code> which fails with a <code>Key Error</code> for <code>INTR</code>.</p>
<p>The problem is that in the comparison "INT." gets interpreted as "INT" and any other character as the period is special.</p>
<p>I have temporarily fixed the issue using this modified code:</p>
<pre><code>def substitutions(text):
    return re.sub(
        r'\b' + '|'.join(subs_dict.keys()).replace('.', [.])
        + r'\b', lambda m: subs_dict[m.group(0)],
        text
    )
</code></pre>
<p>Which allows the period to be evaluated literally but maintains the integrity of the dict keys (as opposed to using "INT[.]" as the key which will fail.</p>
<p>However, this has a bad smell to it and of course only takes care of the period, and not any other special characters.</p>
<p>So, I guess my question would be if there is a better way which works and evaluates any special characters literally.</p>
</div>
<div class="post-text" itemprop="text">
<p>The cleaner way would be to escape the actual strings, with <a href="https://docs.python.org/3/library/re.html#re.escape" rel="nofollow"><code>re.escape</code></a> before you join them, like this</p>
<pre><code>r'\b' + '|'.join(map(re.escape, subs_dict)) + r'\b'
</code></pre>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; subs_dict = {"INT.": "Internet"}
&gt;&gt;&gt; def substitutions(text):
...     return re.sub(r'\b' + '|'.join(map(re.escape, subs_dict)) + r'\b',
...                   lambda m: subs_dict[m.group(0)], text)
... 
&gt;&gt;&gt; substitutions("The INTREPID explorer")
'The INTREPID explorer'
&gt;&gt;&gt; substitutions("The INT.EPID explorer")
'The InternetEPID explorer'
</code></pre>
</div>
<span class="comment-copy">By the way, if you really do need the <code>\b</code> assertions, then I think you need to add brackets. I don't know Python very well; but in all the regex flavours I know, <code>|</code> is a low-precedence operator, so the expression above would be equivalent to <code>(?:\bINT.)|...</code>. You probably wanted <code>\b(?:Int.|...)\b</code>. And if you do make this change then you probably can't just write <code>r'\b(?:' + ...</code>, because <code>\b(:</code> isn't a valid regex; you might have to write <code>r'\b' + ('(:' + '|'.join(subs_dict.keys()).replace('.', [.]) + ')') + r'\b'</code>. And also make the change suggested by thefourtheye, of course.</span>
<span class="comment-copy">Oh thanks, that does seem better. One issue I'm still having is with trailing spaces. For example where, "The INT.EPID explorer" will get substituted, "The INT. EPID explorer" won't.</span>
<span class="comment-copy">Just remove the <code>\b</code>s and try</span>
