<div class="post-text" itemprop="text">
<pre><code># -*- coding: utf-8 -*-
class tA():
    def __init__(self):
        print 'AAA'

    def __del__(self):
        print 'BBB'

class tC(tA):
    def __init__(self, a, b=0):
        tA.__init__(self)
        self.b=b             # 1. del this ok

class tD(tC):
    def __init__(self):
        a=1
        #tC.__init__(self, a)             # 2. use this ok
        tC.__init__(self, a, self.func)   # 3. use this not ok
        #tC.__init__(self, a, 3)          # 4. use this ok

    def func(self, pos):
        pass
if __name__ == '__main__':
    tD()
</code></pre>
<p>why there is no  'BBB' output?</p>
<p>if I del zhe #1 , the output is ok</p>
<p>if I use #2 or #4, the output is ok</p>
<p>if I use #3, the output has no  'BBB'? </p>
</div>
<div class="post-text" itemprop="text">
<p>Because your <code>'BBB'</code> is printed with the finalizer of your class (<code>__del__</code> function). And finalizers are run when the garbage collector collects your object.</p>
<p>Python uses a double strategy for garbage collection: reference counting and cycle detection. Objects whose reference count reaches 0 are collected immediately, but if they participate in a cycle, then their count will never reach 0. Then the GC cycle detection routine, that is called periodically, will eventually detect it and release all the dangling objects.</p>
<p>In your particular code, case #3 creates a reference cycle: <code>self.b</code> is a reference to <code>self.func</code>. But the GC cycle detection is never run because the program ends before it has any chance.</p>
<p>But even if the GC is run, objects with finalizers have special rules. From the <a href="https://docs.python.org/2/library/gc.html" rel="nofollow">documentation</a>:</p>
<blockquote>
<p><strong>Objects that have <code>__del__()</code> methods and are part of a reference cycle cause the entire reference cycle to be uncollectable</strong>, including objects not necessarily in the cycle but reachable only from it. Python doesn’t collect such cycles automatically because, in general, it isn’t possible for Python to guess a safe order in which to run the <code>__del__()</code> methods.</p>
</blockquote>
<p>Also, from <a href="https://docs.python.org/3/library/gc.html" rel="nofollow">here</a></p>
<blockquote>
<p>Changed in version 3.4: Following PEP 442, objects with a <code>__del__()</code> method don’t end up in <code>gc.garbage</code> anymore.</p>
</blockquote>
<p>So, it looks like, in Python before 3.4, in classes with finalizers, you have to break the  cycles manually:</p>
<blockquote>
<p>If you know a safe order, you can force the issue by examining the garbage list, and explicitly breaking cycles due to your objects within the list. Note that these objects are kept alive even so by virtue of being in the garbage list, so they should be removed from garbage too. For example, after breaking cycles, do <code>del gc.garbage[:]</code> to empty the list.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>func</code> is a bound method and as such indirectly references the object it is bound to, which means you're creating a reference cycle.</p>
<p>You can verify this by doing:</p>
<pre><code>...

if __name__ == '__main__':
    import sys
    print(sys.getrefcount(tD()))
</code></pre>
<p>which should print <code>1</code> in your cases #2 and #4, and <code>2</code> in case #3.</p>
<p>The documentation of <a href="https://docs.python.org/2/reference/datamodel.html?#object.__del__" rel="nofollow"><code>__del__</code></a> has a note about reference cycles:</p>
<blockquote>
<p>[...] Some common situations that may prevent the reference count of an object from going to zero include: circular references between objects (e.g., a doubly-linked list or a tree data structure with parent and child pointers); a reference to the object on the stack frame of a function that caught an exception (the traceback stored in sys.exc_traceback keeps the stack frame alive); or a reference to the object on the stack frame that raised an unhandled exception in interactive mode (the traceback stored in sys.last_traceback keeps the stack frame alive)<br/>
  [...]<br/>
  Circular references which are garbage are detected when the option cycle detector is enabled (it’s on by default), but can only be cleaned up if there are no Python-level <code>__del__()</code> methods involved.</p>
</blockquote>
<p>Basically, this means that if you have a <code>__del__</code> method, it prevents objects containing a reference cycle to be cleanded up.</p>
</div>
<span class="comment-copy">Can you edit your quesiton to explain your use case and what you want to have happen here?</span>
<span class="comment-copy">if you run zhe code above, you can not see  'BBB'  ouput by  function <b>del</b> ?</span>
<span class="comment-copy">As mata &amp; rodrigo say, you're creating a reference cycle. BTW, since you're using Python 2, you should write <code>class tA(object)</code>, so that <code>tA</code> is a new-style class.</span>
<span class="comment-copy">yes, you are right! thank you for you advise!</span>
<span class="comment-copy">you are right !! Thank you very much !!  i've never thought this!! you are a good person !!</span>
<span class="comment-copy">Hi @王王王 if this or any answer has solved your question please consider <a href="http://meta.stackexchange.com/q/5234/179419">accepting it</a> by clicking the check-mark. This indicates to the wider community that you've found a solution and gives some reputation to both the answerer and yourself. There is no obligation to do this.</span>
<span class="comment-copy">you are right !! Thank you very much !!</span>
