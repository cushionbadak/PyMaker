<div class="post-text" itemprop="text">
<p>I was reading about python's random module in standard library. It amazes me that when I set the seed and produce a few random numbers:</p>
<pre><code>random.seed(1)
for i in range(5):
    print random.random()
</code></pre>
<p>The numbers produced are exactly the same as the sample in the article. I think it's safe to say the algorithm is deterministic when the seed is set.</p>
<p>And when the seed is not set, the standard library seeds with <code>time.time()</code>.
Now suppose an online service use <code>random.random()</code> to generate a captcha code, can a hacker use the same random generator to reproduce the captcha easily?</p>
<ol>
<li>Let's assume the hacker knows about the algorithm to convert random number to captcha code. Otherwise, it seems quite impossible.</li>
<li>Since random.seed() is called when the module is imported, I assume for a web application, the time used as the seed is around the time the request is sent (within a few seconds), it won't be hard to caliberate with a few tries?</li>
</ol>
<p>Am I worrying too much, or is this a real vulnerability?</p>
</div>
<div class="post-text" itemprop="text">
<p>It shouldn't surprise you that the sequence is deterministic after seeding.  That's the whole point of seeding.  <code>random.random</code> is known as a PRNG, a <strong>pseudo-</strong> random number generator.  This is not unique to Python, every language's simple random source is deterministic in this way.</p>
<p>And yes, people who are genuinely concerned about security will worry that an attacker could reproduce the sequence. That's why other sources of randomness are available, like <code>os.urandom</code>, but they are more expensive.</p>
<p>But the problem is not as bad as you say: for a web request, typically a process handles more than one request, so the module is initialized at some unknown point in the past, not when the web request was received.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Almost all module functions depend on the basic function random(), which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely <strong>unsuitable for cryptographic purposes</strong>.</p>
</blockquote>
<p>See <a href="https://stackoverflow.com/a/20937025/429555">this answer</a> for secure random.</p>
</div>
<div class="post-text" itemprop="text">
<p>The existing answers are great, but I'll just add a few points. </p>
<p><strong>Update:</strong></p>
<p>Actually, if you don't supply a seed, the random number generator is seeded with random bits from the system random source, it only falls back to using the system time as a seed if the OS doesn't have a random source. Also note that recent versions of Python can use an improved seeding scheme. From <a href="https://docs.python.org/3/library/random.html#random.seed" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p><strong>random.seed(a=None, version=2)</strong></p>
<p>Initialize the random number generator.</p>
<p>If <code>a</code> is omitted or <code>None</code>, the current system time is used. If
  randomness sources are provided by the operating system, they are used
  instead of the system time (see the <code>os.urandom()</code> function for
  details on availability).</p>
<p>If <code>a</code> is an int, it is used directly.</p>
<p>With version 2 (the default), a str, bytes, or bytearray object gets
  converted to an int and all of its bits are used.</p>
<p>With version 1 (provided for reproducing random sequences from older
  versions of Python), the algorithm for str and bytes generates a
  narrower range of seeds.</p>
<p><em>Changed in version 3.2</em>: Moved to the version 2 scheme which uses all of the bits in a string seed.</p>
</blockquote>
<hr/>
<p>Generating a CAPTCHA code is not a high-security application compared to say, generating secret cryptographic keys, especially keys that are intended to be used multiple times. As a corollary, the amount of entropy required to generate a CAPTCHA code is smaller than what's required for a cryptographic key. </p>
<p>Bear in mind that the system time used to seed <code>random</code> is (probably) not the system time in seconds - it's more likely to be the time in microseconds, or even nanoseconds, so it's not easy for an attacker to figure the seed out from a brute-search, apart from the considerations mentioned by Ned.</p>
<p>Here's a quick demo, running on Python 2.6.6 on a 2GHz Linux system. </p>
<pre><code>#!/usr/bin/env python
''' random seeding demo'''

from __future__ import print_function
import time
from random import seed, randint, random

def rf():
    return randint(10, 99)

def put_time():
    print('%.15f' % time.time())

r = range(10)
a = []

put_time()
for i in r:
    seed()
    a.append([rf() for j in r])
put_time()

for row in a:
    print(row)
</code></pre>
<p><strong>Typical output</strong></p>
<pre><code>1436617059.071794986724854
1436617059.074091911315918
[95, 25, 50, 75, 80, 38, 21, 26, 85, 82]
[75, 96, 14, 13, 76, 53, 94, 68, 80, 66]
[79, 33, 65, 86, 12, 32, 80, 83, 36, 42]
[28, 47, 62, 21, 52, 30, 54, 62, 22, 28]
[22, 40, 71, 36, 78, 64, 17, 33, 99, 43]
[81, 15, 32, 15, 63, 57, 83, 67, 12, 62]
[22, 56, 54, 55, 51, 56, 34, 56, 94, 16]
[64, 82, 37, 80, 70, 91, 56, 41, 55, 12]
[47, 37, 64, 14, 69, 65, 42, 17, 22, 17]
[43, 43, 73, 82, 61, 55, 32, 52, 86, 74]
</code></pre>
<p>As you can see, less than 3 milliseconds elapse between the start of the outer loop &amp; its end, but all of the lists in <code>a</code> are quite different. </p>
<p>Note that the seed passed to <code>random.seed()</code> can be any hashable object, and when you pass it a non-integer (eg a <code>float</code> like the system time), it first gets hashed to create an integer. </p>
<p>Still, there's no need to merely use the system time as the seed: you can use <code>SystemRandom</code> / <code>os.urandom()</code> to get the seed. That way, the seed is more unpredictable, but you get the speed of Mersenne Twister; <code>SystemRandom</code> is a little slower than Mersenne Twister because it has to make system calls. However, even <code>urandom</code> isn't totally safe.</p>
<p>From the GNU <a href="http://linux.die.net/man/4/urandom" rel="nofollow noreferrer">urandom man page</a>:</p>
<blockquote>
<p>The random number generator gathers environmental noise from device
  drivers and other sources into an entropy pool. The generator also
  keeps an estimate of the number of bits of noise in the entropy pool.
  From this entropy pool random numbers are created. </p>
<p>When read, the /dev/random device will only return random bytes
  within the estimated number of bits of noise in the entropy pool.
  /dev/random should be suitable for uses that need very high quality
  randomness such as one-time pad or key generation. When the entropy
  pool is empty, reads from /dev/random will block until additional
  environmental noise is gathered. </p>
<p>A read from the /dev/urandom device will not block waiting for more
  entropy. As a result, if there is not sufficient entropy in the
  entropy pool, the returned values are theoretically vulnerable to a
  cryptographic attack on the algorithms used by the driver. Knowledge
  of how to do this is not available in the current unclassified
  literature, but it is theoretically possible that such an attack may
  exist. If this is a concern in your application, use /dev/random
  instead.  </p>
<p><strong>Usage</strong></p>
<p>If you are unsure about whether you should use
  /dev/random or /dev/urandom, then probably you want to use the latter.
  As a general rule, /dev/urandom should be used for everything except
  long-lived GPG/SSL/SSH keys.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/2/library/random.html#random.SystemRandom" rel="nofollow">Python documentation</a> has this to say:</p>
<blockquote>
<p><strong>Warning</strong> 
  The pseudo-random generators of this module should not be used for
  security purposes. Use os.urandom() or SystemRandom if you require a
  cryptographically secure pseudo-random number generator.</p>
</blockquote>
<p>So, using it for CAPTCHA is not likely to be a good idea. </p>
</div>
<span class="comment-copy">Thanks for the code and references! Very informational.</span>
