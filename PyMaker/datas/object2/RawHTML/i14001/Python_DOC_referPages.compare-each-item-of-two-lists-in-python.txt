<div class="post-text" itemprop="text">
<p>For example, suppose <code>list_1 = [a,b,c]</code> and <code>list_2 = [m,n,o]</code>. I want to compare each item from one list to the other, for example, create an output list such that </p>
<p><code>[a == m, a == n, a == o, b == m, b == n, b == o...]</code></p>
<p>For simplicity I'm using the <code>==</code> operation but this could also be a summation, e.g. </p>
<p><code>[a + m, a + n, a + o, b + m...]</code></p>
<p>I know how I could do this with two loops, but I'm wondering a lambda function with <code>map()</code> or list comprehensions could be used? I've searched online but only found one-to-one comparisons of list items, e.g. <code>map(lambda x,y: x + y, list_1, list_2)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html?highlight=product#itertools.product" rel="noreferrer">itertools.product()</a> can generate all combinations for you:</p>
<pre><code>import itertools
list_1 = [1,5,4]
list_2 = [2,3,4]
# using list comprehensions
comparisons = [a == b for (a, b) in itertools.product(list_1, list_2)]
sums = [a + b for (a, b) in itertools.product(list_1, list_2)]
# using map and lambda
comparisons = map(lambda (a, b): a == b, itertools.product(list_1, list_2))
sums = map(lambda (a, b): a + b, itertools.product(list_1, list_2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get all the permutations of elements with a list comprehension:</p>
<pre><code>[a == b for a in list_1 for b in list_2]
</code></pre>
<p>Functionality is the same as the nested for loops:</p>
<pre><code>list_3 = []
for a in list_1:
    for b in list_2:
        list_3.append(a == b)  # Or a + b, etc.
</code></pre>
<p>Functional implementation is a bit more confusing:</p>
<pre><code>list_3 = map(lambda x: map(lambda y: y == x, list_2), list_1)
</code></pre>
<p>This creates a list of lists, however, so you'd want to flatten it with any of the techniques described <a href="https://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python">here</a></p>
<pre><code>sum(list_3, [])
</code></pre>
<p>Or use <code>itertools.product</code> as suggested by @bereal.</p>
</div>
<div class="post-text" itemprop="text">
<p>For python 3.x - Yes you can do this with <code>map</code> function and <code>itertools.product</code> function and <code>lambda</code> expression -</p>
<pre><code>&gt;&gt;&gt; lst1 = [1,5,4]
&gt;&gt;&gt; lst2 = [2,3,4]
&gt;&gt;&gt; lst3 = list(map(lambda x: x[0] == x[1] , itertools.product(lst1,lst2)))
&gt;&gt;&gt; lst3
[False, False, False, False, False, False, False, False, True]
</code></pre>
<p>For Python 2.x you can use same expression, just <code>map</code> function in Python 2.x returns a list so the <code>list(...)</code> is not required.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to apply an operator on pairs from the <a href="https://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow">cartesian product</a> of two lists. Let's say op defines the operation you want to apply to the two items, e.g:</p>
<pre><code>op = lambda x, y: x == y
</code></pre>
<p>and have two lists</p>
<pre><code>a = [1, 2, 3]
b = [2, 3, 4]
</code></pre>
<p>You can apply op on all pairs as a list comprehension as follows:</p>
<pre><code>c = [op(x, y) for y in b for x in a]
</code></pre>
<p>To use the map function you first need to create the cartesian product using <a href="https://docs.python.org/3.1/library/itertools.html#itertools.product" rel="nofollow">itertools.product</a>. This effectively creates a double loop over the elements of both list just like the list comprehension. You will need to adjust the op definition slightly for this since it will only receive one argument consisting of the tuple (x, y). For example:</p>
<pre><code>op2 = lambda t: t[0] == t[1]
d = map(op2, itertools.product(a, b))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this:</p>
<pre><code>list_1 = [1,2,3]
list_2 = [1,4,6]
is_it_equal_function = lambda x:x in list_1
is_it_equal_list = map(is_it_equal_function, list_2)
</code></pre>
<p>It will return:</p>
<pre><code>[True, False, False]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If we like the idea of vectorization, we could try numpy:</p>
<pre><code>import numpy as np
list_1 = ['a','b','c']
list_2 = ['m','n','o']
l1 = np.array(list_1)
l2 = np.array(list_2)
l1 == l2
</code></pre>
</div>
<span class="comment-copy">This doesn't work as I expect</span>
<span class="comment-copy">Thanks to everyone for the the excellent answers, I chose this as the best because of it's conciseness and use of examples</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> is nice, too.</span>
<span class="comment-copy">@bereal didn't know about that one, nice suggestion.</span>
<span class="comment-copy">Out of curiosity, what does <code>map</code> return in Python 3 that you have to add the explicit casting?</span>
<span class="comment-copy">Question seems to be asking for a list with 9 elements (all possible combinations), not three?</span>
<span class="comment-copy">The OP wants to compare each element of <code>lst1</code> with each element of <code>lst2</code>, so should be 9.</span>
<span class="comment-copy">@JesseMu Sorry read the question wrongly, have fixed it to use <code>itertools.product</code> instead of <code>zip</code></span>
<span class="comment-copy">@SuperBiasedMan zip returns an iterator in Python 3 , not a list.</span>
<span class="comment-copy">Thanks for pointing out the correct terminology, this is a product operation</span>
<span class="comment-copy">I suggest making sure your code block is indented by <i>exactly</i> 4 spaces, as any more will cause the Python interpreter to complain about unexpected indent if the code is copy-pasted into it (which is the case right now).</span>
<span class="comment-copy">@celticminstrel thanks. Corrected it.</span>
