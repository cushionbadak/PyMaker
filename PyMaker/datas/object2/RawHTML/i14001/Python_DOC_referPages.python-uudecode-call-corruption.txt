<div class="post-text" itemprop="text">
<p>I am working on extracting PDFs from SEC filings. They usually come like this:</p>
<p><a href="http://www.sec.gov/Archives/edgar/data/1508677/000000000014050442/0000000000-14-050442.txt" rel="nofollow">SEC Filing Example</a></p>
<p>For whatever reason when I save the raw PDF to a .text file, and then try to run </p>
<p><code>uudecode -o output_file.pdf input_file.txt</code></p>
<p>from the python <code>subprocess.call()</code> function or any other python function that allows commands to be executed from the command line, the PDF files that are generated are corrupted. If I run this same command from the command line directly there is no corruption.</p>
<p>When taking a closer look at the PDF file being output from the python script, it looks like the file ends prematurely. Is there some sort of output limit when executing a command line command from python?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>This script worked fine for me running under Python 3.4.1 on Fedora 21 x86_64 with uudecode 4.15.2:</p>
<pre><code>import subprocess
subprocess.call("uudecode -o output_file.pdf input_file.txt", shell=True)
</code></pre>
<p>Using the linked SEC filing (length: 173,141 B; sha1: <code>e4f7fa2cbb3422411c2f2968d954d6bb9808b884</code>), the decoded PDF (length: 124,557 B; sha1: <code>1676320e1d9923e14d19451c16688198bc93ca0d</code>) appears correct when viewed.</p>
<p>There may be something else in your environment causing the problem.  You may want to add additional details to your question.</p>
<blockquote>
<p>Is there some sort of output limit when executing a command line command from python?</p>
</blockquote>
<p>If by "output limit" you mean the size of the file being written by <code>uudecode</code>, then no.  The only type of "output limit" you need to worry about when using the <code>subprocess</code> module is when you pass <code>stdout=PIPE</code> or <code>stderr=PIPE</code> when creating a child process.  If the child process writes enough data to either of these streams, and your script does not regularly drain them, the child process will block (see the <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow"><code>subprocess</code></a> module documentation).  In my test, <code>uudecode</code> wrote nothing to <code>stdout</code> or <code>stderr</code>.</p>
</div>
<span class="comment-copy">what happens if you run: <code>python -muu -d input_file.txt output_file.pdf</code> from the command line?</span>
<span class="comment-copy">@J.F.Sebastian When I ran that in the command line it worked. But as soon as I put it into my code like this :  <code>subprocess.call([ "python", "-muu", "-d", input_file.txt, output_file.pdf])</code>  I have the same issue</span>
<span class="comment-copy">don't run it as a subprocess inside your Python script, you could import it instead: <a href="https://docs.python.org/3/library/uu.html#uu.decode" rel="nofollow noreferrer"><code>import uu; uu.decode('input_file.txt', 'output_file.pdf')</code></a> (Note: the quotes around the filenames are not optional; they create a string object in Python). Or (better) pass open binary file objects e.g., created using <code>input_file = open('input_file.txt', 'rb'); output_file = open('output_file.pdf', 'wb')</code></span>
<span class="comment-copy">Thank you for your response. I am using Python 2.7.3, Ubuntu precise (12.04.5 LTS), uudecode 4.11. I may try updating to uudecode 4.15 to see if that helps my issue.  edit: <b>I dont think python 2.7 can update to uudecode 4.1</b></span>
<span class="comment-copy">Can you check the return value of <code>subprocess.call()</code> in your script?</span>
