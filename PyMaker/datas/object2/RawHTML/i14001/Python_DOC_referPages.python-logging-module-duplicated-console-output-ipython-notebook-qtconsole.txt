<div class="post-text" itemprop="text">
<p>I am trying to play with python <code>logging</code> module but get a bit confused here. Below is a standard script to create a <code>logger</code> first, and then create and add a <code>file handler</code> and <code>console handler</code> to the <code>logger</code>. </p>
<pre><code>import logging

logger = logging.getLogger('logging_test')
logger.setLevel(logging.DEBUG)

print(len(logger.handlers))  # output: 0

# create file handler which logs even debug messages
fh = logging.FileHandler('/home/Jian/Downloads/spam.log', mode='w')
fh.setLevel(logging.DEBUG)

# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# create formatter and add it to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
fh.setFormatter(formatter)

# add the handlers to logger
logger.addHandler(ch)
logger.addHandler(fh)

print(len(logger.handlers))  # output: 2

# write some log messages
logger.debug('debug message')
logger.info('info message')
logger.warn('warn message')
logger.error('error message')
logger.critical('critical message')
</code></pre>
<p>I run this on a newly started kernel. <code>file handler</code> works as expected. But in the console output, I've got some sort of duplicated messages:</p>
<pre><code>2015-07-14 10:59:26,942 - logging_test - DEBUG - debug message
DEBUG:logging_test:debug message
2015-07-14 10:59:26,944 - logging_test - INFO - info message
INFO:logging_test:info message
2015-07-14 10:59:26,944 - logging_test - WARNING - warn message
WARNING:logging_test:warn message
2015-07-14 10:59:26,945 - logging_test - ERROR - error message
ERROR:logging_test:error message
2015-07-14 10:59:26,946 - logging_test - CRITICAL - critical message
CRITICAL:logging_test:critical message
</code></pre>
<p>I suppose those log messages with time stamps are from the user-defined <code>console handler</code>, but where are the duplicated messages come from? Can I get rid of them, say, keep only every other line? Any help is appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>The issue has been raised <a href="https://github.com/ipython/ipython/issues/8282" rel="nofollow">here</a>.</p>
<p><em>The observation is the following: In normal python, or the IPython console, there is no handler to the root logger installed until the root logger itself is used to issue a log message:</em></p>
<pre><code>In [1]: import logging

In [2]: logging.getLogger().handlers
Out[2]: []

In [3]: logging.warn('Something happened!')
WARNING:root:Something happened!

In [4]: logging.getLogger().handlers
Out[4]: [&lt;logging.StreamHandler at 0x42acef0&gt;]
</code></pre>
<p>However, in the IPython notebook, there is the default stderr root logger installed right away:</p>
<pre><code>In [1]: import logging

In [2]: logging.getLogger().handlers
Out[2]: [&lt;logging.StreamHandler at 0x35eedd8&gt;]
</code></pre>
<p><em>Maybe I'm missing something, but I think that in the notebook, there should no handler be installed automatically, for a number of reasons:</em></p>
<ol>
<li>It would make the default logging configuration consistent between standard python, the IPython console and the IPython notebook.</li>
<li>As soon as the user writes a log message with the root logger, the handler gets installed automatically, and therefore log messages are not easily missed.</li>
<li>With the current behaviour, a library that configures a child logger, and a handler for that child logger, might easily spam the notebook with debug messages that are supposed to only go in a log file (or elsewhere). For example, astropy seems to have such an issue, and I'm running into the same issue with my own library. The problem is that for such a library, there is no "clean" way around this. The library could remove the handler of the root logger when it is imported, which is hack-y. It could set its own logger's <code>propagate</code> attribute to <code>False</code>, so that the log messages are not propagated to the root logger, but this not only disables debug output from going into the notebook, but also more severe messages. Also, it prevents users from actually capturing all log output if they want to.</li>
</ol>
<p>An alternative might be to add a configuration option that specifies a log level for the automatically added stream handler, so that it becomes possible to ignore less severe messages from showing up in the notebook automatically. But this would still make the behaviour different between IPython console and IPython notebook.</p>
<p>The only downside I see with making sure there is no default handler set is that some libraries/notebooks in use might rely on this behaviour and actively work around it, for example by disabling their own handlers if they detect that they are running in the ipython notebook. Such cases would likely break with such a change.</p>
<p>So setting <code>logger.propagate</code> to <code>False</code> or using <code>reload(logging)</code> will prevent duplicate output but depending on will have side effects.</p>
<p>Note that <code>reload</code> is not available in newer version of python (3.4, maybe earlier). From 3.1 onwards see <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow">importlib.reload</a></p>
</div>
<div class="post-text" itemprop="text">
<p>When you perform  </p>
<pre><code># create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
</code></pre>
<p>Your are creating another StreamHandler. 
To solve your problem you should capture the StreamHandler from iPython:</p>
<pre><code>import logging

handlers = logging.getLogger().handlers
for h in handlers:
    if isinstance(h, logging.StreamHandler):
        handler_console = h
        break
</code></pre>
<p>If it does not exists you create your own:</p>
<pre><code>if handler_console is None:
    handler_console = logging.StreamHandler()
</code></pre>
<p>Finally format (set other properties) as desired:</p>
<pre><code>if handler_console is not None:
    # first we need to remove to avoid duplication
    logging.getLogger().removeHandler(handler_console)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler_console.setFormatter(formatter)
    # then add it back
    logger.addHandler(handler_console)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution is:</p>
<pre><code>import logging

logger = logging.getLogger()
logger.propagate = False
</code></pre>
</div>
<span class="comment-copy">What environment are you running in? PyCharm, Eclipse, WingIDE, IDLE?</span>
<span class="comment-copy">@PeterWood just a plain IPython notebook. tried on both py2.7 and py3.4. OS Ubuntu.</span>
<span class="comment-copy">The notebook is causing the issue, code runs fine in pycharm and ipython itself</span>
<span class="comment-copy">Works using  ipython directly for me, try adding a <code>reload(logging)</code> after the import in notebook</span>
<span class="comment-copy">Will do when I get back on laptop, basically the issue is ipython use the logging module, if you run <code>import logging;logging.getLogger().handlers</code> in the notebook when you start it you will see a fh already in use</span>
<span class="comment-copy">For me, the default <code>StreamHandler</code> is also present for the IPython Qt console, while it is absent for the normal ipython launched from the command line.</span>
<span class="comment-copy">I tried, but it doesn't work. More easy solution is to set: "logger.propagate = False" after "logger = logging.getLogger()"</span>
<span class="comment-copy">Didn't work for me, so I used <code>logger.handlers.pop() </code> in python 2.7, does the trick</span>
