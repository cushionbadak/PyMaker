<div class="post-text" itemprop="text">
<p>In Python 3.x, say a variable contains a very long list. Once I know I no longer need this list, does setting the variable to None free up the memory?</p>
<p>This is what I mean:</p>
<pre><code>a = [x for x in range(10**10)]
a = None
</code></pre>
<p>I know that the example above could use an iterator instead, but let's assume the list actually contains relevant data.</p>
</div>
<div class="post-text" itemprop="text">
<p>It decrements the list's reference count, and if it becomes zero, GC will eventually collect the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>In CPython (the standard Python interpreter), reference counting is the primary means of automatic memory management. Which means that the memory used by an object is immediately freed when there are no references to it. In your example, if the list has only the name <code>a</code>, then the memory it uses is freed immediately when <code>a</code> is set to <code>None</code> (or any other value, in fact). You can also <code>del a</code> to remove the name entirely, to similar effect. Not only the list but all its contents (assuming there are no other references to individual items) are freed.</p>
<p>There are a couple of caveats. First, if an object contains a reference to itself, or to another object that refers back to the first object (etc.) its reference count never reaches zero even when all its names are deleted, so it won't be freed automatically by this process.</p>
<pre><code> a = [x for x in range(10**10)]
 a.append(a)
 a = None
</code></pre>
<p>In this case, the list named <code>a</code> contains a reference to itself, so the last line does not free the memory used by the list, because its reference count does not reach zero when that happens. Python has a garbage collector that is run periodically to find and free such structures that refer only to themselves (or cyclic structures that mutually refer to each other) and that cannot be reached from any namespace.</p>
<p>The other caveat is that freed memory is made available again for use by your Python script, but it may not be released back to the operating system immediately, or ever.</p>
<p>Finally, some objects are never freed: small integers (range -5 to 255), interned strings, empty tuples. These objects are the same instance any time you use them (instead of creating new instances) so they are kept around.</p>
<p>Other Python implementations may use other memory management strategies. Jython runs on the Java virtual machine and uses the JVM's memory management; ditto for IronPython and the Microsoft .NET CLR.</p>
</div>
<span class="comment-copy"><code>pow(10,10)</code>, it's really a long list.</span>
<span class="comment-copy">Setting variable to <code>None</code> doesn't immediately free memory. But eventually garbage collector will do the job</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/gc.html#gc.collect" rel="nofollow noreferrer"><code>gc.collect()</code></a> - this might help</span>
<span class="comment-copy">If you have other references to a then no</span>
<span class="comment-copy">Is it possible to set the reference count directly?</span>
<span class="comment-copy">You can only try to unbind all existing names that refer to the object you want to be collected and then wait for GC to do its job.</span>
<span class="comment-copy">Thanks for the detailed explanation. So if I understand correctly, as long as the list never references itself, it will be useful to set it None or delete it to free up the memory.</span>
<span class="comment-copy">Pretty much, yep!</span>
