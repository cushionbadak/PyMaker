<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/9284350/why-does-1-in-1-0-true-evaluate-to-false">Why does (1 in [1,0] == True) evaluate to False? [duplicate]</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>Why is it that these statements work as expected when brackets are used:</p>
<pre><code>&gt;&gt;&gt; (True is False) == False
True

&gt;&gt;&gt; True is (False == False)
True
</code></pre>
<p><strong>But</strong> it returns <code>False</code> when there are no brackets?</p>
<pre><code>&gt;&gt;&gt; True is False == False
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on python <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence"><em>documentation</em></a> about operator precedence :</p>
<blockquote>
<p>Note that comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right <strong>chaining</strong> feature as described in the Comparisons section.</p>
</blockquote>
<p>So actually you have a chained statement like following :</p>
<pre><code>&gt;&gt;&gt; (True is False) and (False==False)
False
</code></pre>
<p>You can assume that the central object will be shared between 2 operations and other objects (False in this case).</p>
<p>And note that its also true for all Comparisons, including membership tests and identity tests operations which are following operands :</p>
<pre><code>in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==
</code></pre>
<p>Example :</p>
<pre><code>&gt;&gt;&gt; 1 in [1,2] == True
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python has a unique transitive property when it comes to the comparison operators. It will be easier to see in a simpler case.</p>
<pre><code>if 1 &lt; x &lt; 2:
    # Do something
</code></pre>
<p>This does what it looks like. It checks if 1 &lt; x and if x &lt; 2. The same thing is happening in your non-parenthesized code.</p>
<pre><code>&gt;&gt;&gt; True is False == False
False
</code></pre>
<p>It is checking whether True is False <strong>and</strong> False == False, only one of which is true.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a double inequality which gets expanded as <code>(True is False) and (False == False)</code>. See for instance <a href="https://stackoverflow.com/questions/12658197/what-is-the-operator-precedence-when-writing-a-double-inequality-in-python-expl">What is the operator precedence when writing a double inequality in Python (explicitly in the code, and how can this be overridden for arrays?)</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python interprets multiple (in)equalities the way you would expect in Math:</p>
<p>In Math <code>a = b = c</code> mean all <code>a = b</code>, <code>b = c</code> and <code>a = c</code>.</p>
<p>So <code>True is False == False</code> means <code>True == False</code> and <code>False == False</code> and <code>True == False</code>, which is <code>False</code>.</p>
<p>For boolean constants, <code>is</code> is equivalent to <code>==</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python performs chaining if it encounters operators of same precedence when evaluating an expression.</strong></p>
<blockquote>
<p>comparisons, including tests, which all have the same precedence
  <strong>chain</strong> from left to right</p>
</blockquote>
<p>The below mentioned operators have the same precedence.</p>
<pre><code>in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, !=, ==
</code></pre>
<p>So, when Python tries to evaluate the expression <code>True is False == False</code>, it encounters the operators <code>is</code> and <code>==</code>  which have the same precedence, so it performs chaining from left to right.</p>
<p>So, the expression <code>True is False == False</code> is actually evaluated as:</p>
<pre><code>(True is False) and (False == False)
</code></pre>
<p>giving <code>False</code> as the output.</p>
</div>
<span class="comment-copy">Apparently you got into one of the few dark corners of Python syntax (i.e. places where the result is quite surprising).</span>
<span class="comment-copy">Ahhh! I've used <code>1 &lt; x &lt; 2</code> and just thought it was a special case, I didn't realise that it applied to other operators too.</span>
<span class="comment-copy">So in short, this is a bug? It seems very counter-intuitive.</span>
<span class="comment-copy">In other hand, you can write <code>0 &lt; 0.25 &lt; 0.5</code> which would give a weird result in other languages.</span>
<span class="comment-copy">No, it isn't a bug - it's the intended operation of the language surprising you</span>
<span class="comment-copy">Actually, <code>a is b == c</code> only means <code>(a is b) and (b == c)</code>: <code>a</code> and <code>c</code> are not compared. Consider <code>0.0 == 0 is 0</code>.</span>
<span class="comment-copy">@Mauris I meant that a is b and b is c implies a is c. I was only giving a simple way to determine the result not how its processed</span>
