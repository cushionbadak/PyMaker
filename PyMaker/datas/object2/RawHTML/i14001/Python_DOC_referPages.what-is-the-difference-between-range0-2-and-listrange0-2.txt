<div class="post-text" itemprop="text">
<p>Need to understand the difference between <code>range(0,2)</code> and <code>list(range(0,2))</code>, using python2.7</p>
<p>Both return a list so what exactly is the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x ,</p>
<p><code>range(0,3)</code> returns a class of immutable iterable objects that lets you iterate over them, it does not produce lists, and they do not store all the elements in the range in memory, instead they produce the elements on the fly (as you are iterating over them) , whereas <code>list(range(0,3))</code> produces a list (by iterating over all the elements and appending to the list internally) .</p>
<p>Example -</p>
<pre><code>&gt;&gt;&gt; range(0,3)
range(0, 3)
&gt;&gt;&gt; list(range(0,3))
[0, 1, 2]
</code></pre>
<p>Ideally, if you only want to iterate over that range of values , <code>range(0,3)</code> would be faster than <code>(list(range(0,3))</code> because the latter has the overhead of producing a list before you start iterating over it.</p>
<p>In Python 2.x , <code>range(0,3)</code> produces an list, instead we also had an <code>xrange()</code> function that has similar behavior of <code>range()</code> function from Python 3.x (xrange was renamed to range in Python 3.x)</p>
<p>For Python 3.5, From the <a href="https://docs.python.org/3/library/stdtypes.html#ranges" rel="noreferrer">documentation</a> - </p>
<blockquote>
<p>Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices</p>
</blockquote>
<p>So you can do things like -</p>
<pre><code>&gt;&gt;&gt; range(0,10)[5]
5
&gt;&gt;&gt; range(0,10)[3:7]
range(3, 7)
&gt;&gt;&gt; 5 in range(6,10)
False
&gt;&gt;&gt; 7 in range(1,8)
True
</code></pre>
<p>And all of these are constant time operations , as can be seen from this test -</p>
<pre><code>In [11]: %timeit a = xrange(0,1000000)[1000]
1000000 loops, best of 3: 342 ns per loop

In [12]: %timeit a = xrange(0,1000000)[10000]
1000000 loops, best of 3: 342 ns per loop

In [13]: %timeit a = xrange(0,1000000)[100000]
1000000 loops, best of 3: 342 ns per loop

In [14]: %timeit a = xrange(0,1000000)[999999]
1000000 loops, best of 3: 342 ns per loop

In [15]: %timeit a = xrange(0,10000000)[9999999]
1000000 loops, best of 3: 339 ns per loop

In [16]: %timeit a = xrange(0,1000000000000)[9999999999]
1000000 loops, best of 3: 341 ns per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what version of Python you are using.</p>
<p>In Python 2.x, <a href="https://docs.python.org/2/library/functions.html#range"><code>range()</code></a> returns a list, so they are equivalent.</p>
<p>In Python 3.x, <a href="https://docs.python.org/3/library/functions.html#func-range"><code>range()</code></a> returns an immutable sequence type, you need <code>list(range(0,2))</code> to get a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Both commands return list in Python2.x . But in Python3.x range is an immutable sequence and doesnot return list. It is used for iterations ad loops</p>
</div>
<div class="post-text" itemprop="text">
<p>In python3.x, range has its own type</p>
<pre><code>&gt;&gt;&gt; range(1)
range(0, 1)
&gt;&gt;&gt; type(range(1))
&lt;class 'range'&gt;
</code></pre>
<p>So if you want to use range() in a for loop, its fine. However you can't use it <code>purely</code> as a list object. You need to convert it to list to do that.</p>
<p>Python2 Example:</p>
<pre><code>&gt;&gt;&gt; L = range(10)
&gt;&gt;&gt; L[::-1]
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>
<p>Python3 Example:</p>
<pre><code>&gt;&gt;&gt; L = range(10)
&gt;&gt;&gt; L[::-1]
range(9, -1, -1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Basically, the difference is that <code>range(0, 2)</code> is a generator function and <code>list(range(0, 2))</code> is an actual list. </p>
<p>A generator function is used in loops. For example, a generator function of a file will read a very large file line by line. </p>
<pre><code>def gen():
    for line in open("hugefile.csv", "r"):
        yield line #Gives back the line every time it is read, but forgets that line after

for line in gen():
    print(line)
</code></pre>
<p>This will print every line without overloading the RAM of the computer because you are only reading one by one in both functions. However, if we do something like </p>
<pre><code>def readEntireFile():
    return [line for line in open("hugefile.csv", "r")] #Python has lazy ways of making lists, this is the same as returning a list with all the lines in the file

for line in readEntireFile():
    print(line)
</code></pre>
<p>The second part looks the same, but it is not. Originally, we were looping over every line in the file and moving on to the next line once we were done with it. Over here, Python has a list of ALL the lines :/, imagine doing that with a 10GB file! Your code would crash. </p>
<p>Now, let's go back to range() and list(range())</p>
<p>Doing <code>for x in range(0, 6):</code> makes us go to the next number in the range and completely forget about the previous (Screw grammar). </p>
<p>However, doing <code>for x in list(range(0, 6)):</code> keeps the entire list of numbers in the memory and is the same as doing </p>
<pre><code>numlist = [x for x in range(6)]
for x in numlist:
    print(x)
</code></pre>
<p>When you need the entire list of data in your code, use the list method. But, when you only need one piece of data at a time (easiest example, copying a file in chunks), use a generator function to save space. You could copy every 1 million lines of a file using only 54 mb (assuming you don't have insanely long lines). However, if we have a tiny 2kb file, we can just copy that thing without a generator. It's not worth the time and is slower in this case. </p>
</div>
<span class="comment-copy">So in Python 3 is <code>range(x,y)</code> something akin to a generator? Just something I've been wondering ever since I first saw this behavior...</span>
<span class="comment-copy">Intentional for now , because the online interpreter I used for getting the timeit example is Python 2.7 , so I used xrange instead of range . But it should not matter because Python 3's range is Python 2.x's xrange()</span>
<span class="comment-copy">Ok I figured it was something like that.  Just wanted to make sure it was intentional.</span>
<span class="comment-copy">Actually <code>range</code> does not return a generator , its an immutable object.  Try doing <code>next(range(0,5))</code> . You will understand.</span>
<span class="comment-copy">@AnandSKumar Corrected now.</span>
<span class="comment-copy">You can slice a range - <code>&gt;&gt;&gt; range(0,3)[1:3] range(1, 3)</code></span>
<span class="comment-copy">As @AnandSKumar points out in his answer, python3 <code>range()</code> is a sequence type and has the same operations as lists and tuples (except concat and repetition) <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">@Anand, you are right about the slicing that it does work on it. I have updated my answer on what i meant. Thanks!</span>
