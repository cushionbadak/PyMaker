<div class="post-text" itemprop="text">
<p>I have a recursive function defined in a class. All the function does is parses text files, does some calculation and stores it in HDF5 files. It does not return anything.</p>
<p>Running it on one core is very slow. So I tried to use python's <code>multiprocessing</code> module. I am creating 4 processes and calling the same function inside a for loop with different arguments.</p>
<pre><code>def main():

    f = FileIO() # class which does all the parsing and writing

    start_node = '2'
    maxDepth = 6

    procs = []

    start = time.time()    
    print "Entering for loop"
    for i in xrange(4):
        p = Process(target = f.read_and_write, args = (node+str(i), maxDepth))
        p.start()
        procs.append(p)


    print "Exited for loop"
    for process in procs:
       process.join()

    end = time.time()

    print "Done in ", end - start, "seconds"

if __name__ == '__main__':
    main()
</code></pre>
<p>the reading and writing operations are done successfully and correctly. The only problem is my program does not exit. After printing <code>Entering for loop</code> I see nothing in console. From <code>htop</code> I can see the four cores have stopped working. But My program does not exit.</p>
<p>I don't know how to approach debugging this as I am new to using this <code>multiprocessing</code> module. My codes are logically correct and working just fine without using the <code>multiprocessing</code> module.</p>
<ul>
<li>How do I check the process status?</li>
<li>How do I know where the code is stuck?</li>
</ul>
<p>I am using <code>Python 2.7.10</code> | <code>Anaconda 2.1.0 (64-bit)</code> | <code>ubuntu 14.04 LTS</code></p>
<p>Any help on how to debug this kind problem is welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you should make sure that the processes will be finished. If they go into a wait state, then they will never be finished.</p>
<p>Second, even if those processes finish eventually, you might encounter forever waits, due to issues, like not getting the answer or the likes of that. You can pass a parameter to the <code>join</code> method, denoting the timeout. That would make sure that your main process will not wait forever.</p>
</div>
<span class="comment-copy">What is happening in <code>f.read_and_write()</code>? Have you confirmed that execution is actually reaching the end of that function?</span>
<span class="comment-copy">Its a recursive function which calls itself thousands of times. I don't know how to check whether execution is actually reaching the end of that function.</span>
<span class="comment-copy">If there is no <code>return</code> statement in a function it returns <code>none</code> once its job is done. What exactly happens when a process is finished? does it return anything or send some kind of signal?</span>
<span class="comment-copy">When such a process is finished, you need to call task_done (<a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.JoinableQueue.task_done" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>) "If a join() is currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received for every item that had been put() into the queue)."</span>
<span class="comment-copy">I seemed like the problem was with my IDE (spyder). Thanks for the help.</span>
<span class="comment-copy">@LajosArpad What are the parameter join takes? Does it takes time in seconds?</span>
<span class="comment-copy">@Leo as far as I know it is measured in seconds.</span>
