<div class="post-text" itemprop="text">
<p>I had this code:</p>
<pre><code>def test(variable, customCode = ""):

    if variable &gt; 1:
        print("&gt;1")

    if customCode != "":
        exec(customCode)

    if foo == 1:
        print("Success")

numb = 12
code = "if variable &gt; 1: foo = 1"

test(numb, code)
</code></pre>
<p>Which, when executed, gives this error:</p>
<p><img alt="Error 1" src="https://i.stack.imgur.com/KuVtS.png"/></p>
<p>So, then, I added <code>foo = 0</code> at the beginning of the code, and got this output:</p>
<p><img alt="Issue 2" src="https://i.stack.imgur.com/b5WT2.png"/></p>
<p>Now, obviously, it should also be outputting <code>Success</code>, but it isn't.</p>
<p>What's the issue?</p>
<p>Using Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct way is to pass a dict to exec in python 3 and lookup by key, in python2 your code would work as is because exec is a statement as opposed to a function in python3:</p>
<pre><code>def test(variable, customCode = ""):
    d = {"variable":variable}
    if customCode != "":
        exec(customCode, d)
    if d["foo"] == 1:
        print("Success")

numb = 12
code = "if  variable &gt; 1: foo = 1"

test(numb, code)
</code></pre>
<p>Output:</p>
<pre><code>In [13]: numb = 12

In [14]: code = "if  variable &gt; 1: foo = 1"

In [15]: test(numb, code)
Success
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow">exec</a></p>
<blockquote>
<p>Note The default locals act as described for function locals() below: modifications to the default locals dictionary should not be attempted. Pass an explicit locals dictionary if you need to see effects of the code on locals after function exec() returns.</p>
</blockquote>
<p>You also need to catch the case where your <code>if  variable &gt; 1</code> is False as you will never exec the code so foo will never be added.</p>
</div>
<div class="post-text" itemprop="text">
<p>Reading @Padraic Cunningham's post gave me an idea, which worked as a solution:</p>
<p>It's simple: instead of just doing <code>: foo = 1</code>, do <code>: global foo; foo = 1</code>.</p>
<p>Changed code:</p>
<pre><code>def test(variable, customCode = ""):

    if variable &gt; 1:
        print("&gt;1")

    if customCode != "":
        exec(customCode)

    if foo == 1:
        print("Success")

numb = 12
code = "if variable &gt; 1: global foo; foo = 1"

test(numb, code)
</code></pre>
<p>The issue is that <code>exec()</code> is a function rather than a statement in Python 3, so <code>foo</code> was being used as a local variable. (Source: @Padraic Cunningham)</p>
</div>
<span class="comment-copy">The code executes fine, with <code>&gt;1</code> then a line break and <code>Success</code>.</span>
<span class="comment-copy">@l'L'l, are you using python3?</span>
<span class="comment-copy">@PadraicCunningham, I tried both <code>2.7.6</code> and <code>3.4.3</code> (in Python3 it failed miserably),  sorry I didn't mention that. Your answer got me curious â€” would that be considered a form of scoping?</span>
<span class="comment-copy">@l'L'l, basically yes, unless we pass our own dict locals() gets used, any changes to it won't be reflected outside the scope of the exec. <a href="https://docs.python.org/3.5/library/functions.html#locals" rel="nofollow noreferrer">docs.python.org/3.5/library/functions.html#locals</a></span>
<span class="comment-copy">Okay, your answer led me to my solution, which I am about to post. Thanks.</span>
<span class="comment-copy">After a couple of years of never accepting a solution (I have no idea why), I think your answer is better than mine, so I'm giving you the check.</span>
