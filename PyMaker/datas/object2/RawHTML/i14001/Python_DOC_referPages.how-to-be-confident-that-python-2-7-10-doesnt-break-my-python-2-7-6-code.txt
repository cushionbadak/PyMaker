<div class="post-text" itemprop="text">
<p>To simplify my work I want to migrate from Python 2.7.6 To Python 2.7.9/2.7.10.</p>
<p>I need to justify that my Python 2.7.10 Will not break my software "working" with Python 2.7.6</p>
<p>I followed the steps describe in <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow">porting python 2 to python 3</a></p>
<ul>
<li>Increase my test coverage from 0 to 40%</li>
<li>run pylint (no critical bug)</li>
<li>Learn the differences between Python 2.7.10 And 2.7.6 &lt; I read the release notes</li>
</ul>
<p>I can't be sure 100% that my code will not break, but how can I be confident? </p>
<p>For example, should I have to look at all the <strong>Core and Builtins bugs</strong> fixed between 2.7.6 And 2.7.10 And search into my code if we use those methods? </p>
<p>Does exists a better strategy?</p>
<p>100% code coverage is a good solution, but it <strong>may</strong> be harder to obtain than 50% coverage + 100% code using modified methods between 2.7.6 And 2.7.10 Are tested.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is a very minor Python update that almost certainty won't break anything, even the without the above mentioned steps (Python 2 to Python 3 migration is a different matter entirely).</p>
<p>As to proving it, well, no amount of statical checking and reading the release notes with help, since all it will tell you, is that almost certainly it is backward compatible (which is the initial guess anyway).</p>
<p>A possible approach would be to reproduce your production environment with Python 2.7.10 in a virtual machine (valgrind, etc can help there) and check if everything runs as expected. No way around running it to be 100% sure. </p>
<p>Increasing coverage is a good idea. By itself though, even full coverage run with Python 2.7.6, doesn't tell you whether it will break with Python 2.7.10 or not.</p>
</div>
<div class="post-text" itemprop="text">
<p>My answer does not apply only to Python, but to software development in general.</p>
<p>First of all, as someone already stated, Python 2.7.10 is "just" <a href="https://hg.python.org/cpython/raw-file/15c95b7d81dc/Misc/NEWS" rel="nofollow">a bug fixing release</a> - this means that all regression tests are passing and that no backward incompatible changes are included. This also guarantees that a function signature does not change, therefore your code is likely to be working. Due to Python source code high coverage, it's also possible to say that even if a bug fix might have introduced a bug, this had been covered with regression tests - so either the bug is new or it was not covered by regression tests (the first does not imply the second).</p>
<p>In addition, having 100% coverage is technically not always possible - 90-95% is generally the way to go. And if that's not enough, you might try different scenarios on a local environment as suggested by rth.</p>
<p>However, consider going through your libraries/modules imported and check if they all support Python 2.7.10. If not, it doesn't mean that your project won't work, but it could happen that if you are using some low-level C libraries they might break - so be careful especially there.</p>
<p>In general, I suggest you to go through <a href="https://hg.python.org/cpython/raw-file/15c95b7d81dc/Misc/NEWS" rel="nofollow">the changes</a> and through the imported libraries. Adding coverage is always good - not just to update to a new version - so I join other users in saying that you should definitely increase your coverage.</p>
</div>
<div class="post-text" itemprop="text">
<p>As stated in the <a href="https://docs.python.org/devguide/devcycle.html" rel="nofollow">dev-cycle</a> presentation:</p>
<blockquote>
<p>To clarify terminology, Python uses a major.minor.micro nomenclature
  for production-ready releases. So for Python 3.1.2 final, that is a
  major version of 3, a minor version of 1, and a micro version of 2.</p>
<ul>
<li>new major versions are exceptional; they only come when strongly incompatible changes are deemed necessary, and are planned very long
  in advance;</li>
<li>new minor versions are feature releases; they get released roughly every 18 months, from the current in-development branch;</li>
<li>new micro versions are bugfix releases; they get released roughly every 6 months, although they can come more often if necessary; they
  are prepared in maintenance branches</li>
</ul>
</blockquote>
<p>This means that updating from a <em>micro version</em> to another shouldn't (in theory) break anything.
It's the same for <em>minor versions</em>, which should only add features that are backward compatible.</p>
<p>Considering how widely used python is, you can be sure that many tests are made to ensure that this is respected.<br/>
However, there is no guarantee, but the whole point of <em>micro versions</em> is bugfixing, not introducing new bugs.</p>
</div>
<span class="comment-copy">Why don't you run it and find out?</span>
<span class="comment-copy">Who do you need to convince? Why 2.7.6. is the status quo?</span>
<span class="comment-copy">If you have no tests how can you be sure it wasn't broken to start with?</span>
<span class="comment-copy">Let's be honest here: there is an application size threshold after which you will never be 100% sure that <b>any</b> change won't break the app. But increasing test coverage to 100% will help a lot. Beside that @jonrsharpe is right: you have to run it and find out.</span>
<span class="comment-copy">I agree with @PeterWood; if you don't have the test coverage (whether on line count or over the features supported) to be sure it's working on 2.7.10, <i>how do you know it's working on 2.7.6?</i></span>
<span class="comment-copy">100% is good, but it may be harder to obtain than 50% coverage + 100% code using modified methods between 2.7.6 and 2.7.10 are tested ?</span>
