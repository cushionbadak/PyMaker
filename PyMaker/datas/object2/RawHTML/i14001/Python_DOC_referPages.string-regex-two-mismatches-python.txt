<div class="post-text" itemprop="text">
<p>How can I extend the code below to allow me to explore all instances where I have 2 mismatches or less between my substring and the parent string?</p>
<p>Substring: <code>SSQP</code></p>
<p>String-to-match-to: <code>SSPQQQQPSSSSQQQSSQPSPSQSSQPSSQPPSSSSQPSPSQSSQPSSSSQPSPSQSSQPSSSSQPSPSQ</code></p>
<p>Here is an example where only one possible mismatch is incorporated:</p>
<pre><code>&gt;&gt;&gt; s = 'SSPQQQQPSSSSQQQSSQPSPSQSSQPSSQPPSSSSQPSPSQSSQPSSSSQPSPSQSSQPSSSSQPSPSQ'
&gt;&gt;&gt; re.findall(r'(?=(SSQP|[A-Z]SQP|S[A-Z]QP|SS[A-Z]P|SSQ[A-Z]))', s)
['SSQQ', 'SSQP', 'SSQP', 'SSQP', 'SSQP', 'SSQP', 'SSQP', 'SSQP', 'SSQP']
</code></pre>
<p>Obviously, incorporating the <em>possibility</em> of two mismatches in the code above would require a lot of brute-force typing of all the possible combinations.</p>
<p>How can I extend this code (or refactor this code) to explore the possibility of two mismatches?  </p>
<p>Furthermore, I want to modify my output so that I get the numeric index returned (not <code>SSQQ</code> or <code>SSQP</code>) of the exact position the substring matched the string.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You don't have to use <code>re</code> here you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools</code></a> module instead and save a lot of memory.</p>
<p>You can first extract all sub-strings with length 4 then compare them with your <code>substring</code> and just select those that have less that 2 difference with your <code>substring</code> :</p>
<pre><code>from itertools import izip,islice,tee

def sub_findre(s,substring,diffnumber):
    sublen=len(substring)
    zip_gen=(izip(substring,islice(s,i,i+sublen)) for i in xrange(len(s)))
    for z in zip_gen:
        l,z=tee(z)
        if sum(1 for i,j in l if i==j)&gt;=sublen-diffnumber:
            new=izip(*z)
            next(new)
            yield ''.join(next(new))
</code></pre>
<p>Demo:    </p>
<pre><code>s='SSPQQQQPSSSSQQQSSQPSPSQSSQPSSQPPSSSSQPSPSQSSQPSSSSQPSPSQSSQPSSSSQPSPSQ'

substring='SSQP'
print list(sub_findre(s,substring,2))

['SSPQ', 'SPQQ', 'QQQP', 'SSSS', 'SSSQ', 'SSQQ', 'SQQQ', 'SSQP', 'PSQS', 'SSQP', 'SSQP', 'SQPP', 'SSSS', 'SSSQ', 'SSQP', 'PSQS', 'SSQP', 'SSSS', 'SSSQ', 'SSQP', 'PSQS', 'SSQP', 'SSSS', 'SSSQ', 'SSQP', 'PSQ']
</code></pre>
<p>If you want to return the indices you need to put the indices in <code>izip</code> which you can use <code>itertools.repeat()</code> to repeat the index with the length of <code>substring</code> :</p>
<pre><code>from itertools import izip,islice,tee,repeat

def sub_findre(s,substring,diffnumber):
    sublen=len(substring)
    zip_gen=(izip(substring,islice(s,i,i+sublen),repeat(i,sublen)) for i in xrange(len(s)))
    for z in zip_gen:
        l,z=tee(z)
        if sum(1 for i,j,_ in l if i==j)&gt;=sublen-diffnumber:
            new=izip(*z)
            next(new)
            next(new)
            yield next(new)[0]
</code></pre>
<p>Demo:</p>
<pre><code>print list(sub_findre(s,substring,2))
[0, 1, 4, 8, 9, 10, 11, 15, 20, 23, 27, 28, 32, 33, 34, 39, 42, 46, 47, 48, 53, 56, 60, 61, 62, 67]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The combinatorial explosion is not <em>that</em> bad for two mismatches out of four.</p>
<p>First, observe that you can omit <code>SSQP</code> itself, since it's covered by all of the more lenient cases.</p>
<pre><code>re.findall(r'(?=([A-Z]SQP|S[A-Z]QP|SS[A-Z]P|SSQ[A-Z]))', s)
</code></pre>
<p>So, the number of cases is</p>
<pre><code>               4!
C(4, 1) = ––––––––––––– = 4
          1! * (4 - 1)!
</code></pre>
<p>For up to two mismatches, the number of cases is</p>
<pre><code>               4!
C(4, 2) = ––––––––––––– = 6
          2! * (4 - 2)!
</code></pre>
<p>Namely,</p>
<pre><code>re.findall('(?=(SS..|S.Q.|S..P|.SQ.|.S.P|..QP))', s)
</code></pre>
<p>(To simplify the illustration, I've taken the liberty of writing <code>.</code> instead of <code>[A-Z]</code>.)</p>
<hr/>
<p>To get the positions of the matches instead of the text of the matches:</p>
<pre><code>[match.start(0) for match in re.finditer('(?=(SS..|S.Q.|S..P|.SQ.|.S.P|..QP))', s)]
</code></pre>
</div>
<span class="comment-copy">Indeed, regular expressions are just the wrong tool to use altogether. For 2 mistakes out of 20, there would be 190 alternates in the pattern.</span>
<span class="comment-copy">Can you return index numbers, similar to <code>match.start(0)</code> technique of 200_success?</span>
<span class="comment-copy">@warship Checkout the edit!</span>
<span class="comment-copy">@Kasra Accepted!  Do you mind if in the next few days I upload an algorithm I'm currently developing to solve this problem as well?  I think I may have an alternate solution using a different technique than the very interesting technique you use here.</span>
<span class="comment-copy">@warship mm Ok, i'll try ;) but still i think may answer can be optimized,using generators is very efficient way in terms of memory use, although its very faster than regex, I think using a data structure like dictionary can be better since it use hash-table and you can get more speed from.</span>
<span class="comment-copy">I see what you're doing, but I have substrings as large as 10 sometimes 20 letters, sometimes more, it's very hard for me to scale using the <code>re</code> module.  Perhaps there is something else I can use besides for regular expressions?  I like your wording of "combinatorial explosion" though, I will put that terminology in my arsenal :-)</span>
<span class="comment-copy">Then why did you ask the question for C(4,2) instead of what you actually wanted? How many mistakes out of 20 are you talking about?</span>
<span class="comment-copy">0, 1, or 2 mistakes in a substring of length 20 are possible.  Writing such a thing out combinatorially is a royal pain.  In the OP, I simply wanted to provide a MWE.</span>
