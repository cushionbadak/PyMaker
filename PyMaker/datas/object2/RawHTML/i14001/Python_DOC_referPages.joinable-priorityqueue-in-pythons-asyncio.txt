<div class="post-text" itemprop="text">
<p>As per the <a href="https://docs.python.org/3/library/asyncio-queue.html" rel="nofollow">documentation</a>, there are several implementations of Queues. The ones I'm interested in are the JoinableQueue and the PriorityQueue, as I'd like to have a joinable queue with priorities. </p>
<p>It appears that I can only get one of the functionalities in the lower versions. I.e. in 3.5 I can make the distinciton with Queue (which is joinable) and PriorityQueue, but in python below 3.5 there is JoinableQueue and PriorityQueue (see example below).</p>
<p>Is it possible to combine them to get a general way to get a joinable PriorityQueue in 3.4?</p>
<pre><code>try:
    # Python 3.4.
    from asyncio import JoinableQueue as Queue # joinable
    from asyncio import PriorityQueue          # I assume this one is not joinable
except ImportError:
    # Python 3.5.
    from asyncio import Queue                  # standard joinable
    from asyncio import PriorityQueue          # I assume this is the one I want
</code></pre>
<p>Another approach would be to somehow perhaps influence Queue?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because of the way <code>JoinableQueue</code> and <code>PriorityQueue</code> are implemented, you can get a <code>JoinablePriorityQueue</code> by subclassing both via multiple inheritance, as long as you list <code>JoinableQueue</code> first.</p>
<p>The reason this works is that <code>PriorityQueue</code> is very simply implemented:</p>
<pre><code>class PriorityQueue(Queue):
    """A subclass of Queue; retrieves entries in priority order (lowest first).

    Entries are typically tuples of the form: (priority number, data).
    """

    def _init(self, maxsize):
        self._queue = []

    def _put(self, item, heappush=heapq.heappush):
        heappush(self._queue, item)

    def _get(self, heappop=heapq.heappop):
        return heappop(self._queue)
</code></pre>
<p>While <code>JoinableQueue</code> is more complicated, the only method both it and <code>PriorityQueue</code> implement is <code>_put</code>, and crucially, <code>JoinableQUeue</code> calls <code>super()._put(..)</code> in its own <code>put</code> implementation, which means it will cooperate with <code>PriorityQueue</code> properly.</p>
<p>Here's an example demonstrating that it works:</p>
<pre><code>from asyncio import PriorityQueue, JoinableQueue
import asyncio
import random

class JoinablePriorityQueue(JoinableQueue, PriorityQueue):
    pass


@asyncio.coroutine
def consume(q):
    while True:
        a = yield from q.get()
        print("got a {}".format(a))
        if a[1] is None:
            q.task_done()
            return
        asyncio.sleep(1)
        q.task_done()

@asyncio.coroutine
def produce(q):
    for i in range(10):
        yield from q.put((random.randint(0,10), i))
    yield from q.put((100, None)) # Will be last
    asyncio.async(consume(q))
    print("waiting...")
    yield from q.join()
    print("waited")

loop = asyncio.get_event_loop()
q = JoinablePriorityQueue()
loop.run_until_complete(produce(q))
</code></pre>
<p>Output:</p>
<pre><code>waiting...
got a (1, 2)
got a (2, 1)
got a (4, 4)
got a (5, 0)
got a (6, 8)
got a (6, 9)
got a (8, 3)
got a (9, 5)
got a (9, 7)
got a (10, 6)
got a (100, None)
waited
</code></pre>
</div>
<span class="comment-copy">I was hoping for a way to get your attention, knowing you were involved with aio :)</span>
<span class="comment-copy">@PascalvKooten I didn't develop any of the core <code>asyncio</code> code, just a third-party module (<code>aioprocessing</code>) that's built on top it. That and I've answered lots of questions about it here on SO. <a href="http://stackoverflow.com/users/3454879/andrew-svetlov">Andrew Svetlov</a>, who also answers lots of questions on asyncio here, did develop some of the core code, I believe.</span>
