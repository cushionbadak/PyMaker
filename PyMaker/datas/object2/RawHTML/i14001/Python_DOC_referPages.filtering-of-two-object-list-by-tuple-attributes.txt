<div class="post-text" itemprop="text">
<p>I have two list objects and I want only those elements in list1 with attribute tuples that match a tuple attribute in list2:</p>
<pre><code>list1= [ojec1, objec2, objec3,....]

list2=[fig1,fig2,fig3,...]

for i in range (len(list1)):
  for j in range (len(list2)):
    if (list1[i].attr1==list2[j].attr1 &amp; list1[i].attr2==list2[j].attr2):
      ...
</code></pre>
<p>is there a faster way??</p>
</div>
<div class="post-text" itemprop="text">
<p>Your original code takes <code>O(N**2)</code> steps (<a href="https://en.wikipedia.org/wiki/Time_complexity" rel="nofollow">quadratic time</a>) to find the matching elements due to the nested <code>for</code> loops.</p>
<p>It also uses <code>range(len(...))</code> and numeric indices, which can be cleaned up by just iterating over the elements! (see the <a href="http://lignos.org/py_antipatterns/" rel="nofollow">first example here</a> for an explanation)</p>
<p>Also, for "logical and" you need to use the <code>and</code> operator, not <code>&amp;</code> (as Kasra said it is for "bitwise AND").</p>
<p>So, to make this cleaner and more efficient (<code>O(N)</code>, linear time), I would do the following:</p>
<ul>
<li>loop over the two lists</li>
<li>make a tuple of the attributes you care to match on</li>
<li>use a dictionary to keep track of all the objects with matching tuples</li>
</ul>
<p>Here is the code:</p>
<pre><code>class Something(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __repr__(self):
        return "Something(%s, %s)" % (self.a, self.b)

l1 = [Something(1,1), Something(1,2), Something(1,3)]
l2 = [Something(1,2), Something(2,2), Something(3,2)]

matches = {}
for obj in l1 + l2:
    k = (obj.a, obj.b)
    if k not in matches:
        matches[k] = []
    matches[k].append(obj)

for m in matches:
    if len(matches[m]) &gt; 1:
        print "Match:", matches[m]
</code></pre>
<p>Output:</p>
<pre><code>Match: [Something(1, 2), Something(1, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all <code>&amp;</code> is bit-wise and for a logical and you need to use <code>and</code>.Then you don't need to use <code>len</code> and and extra indexing in a for loop to loop over the items of an iterable you can simply do:</p>
<pre><code>for i in list1:
  for j in list2:
</code></pre>
<p>But here as a more efficient way you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> to get all pairs between your list items and check the condition.</p>
<pre><code>from itertools import product

for i,j in product(list1,list2):
    if (i.attr1==j.attr1 and i.attr2==j.attr2):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If list 2 and list 1 both have size n, then this would take O(n) on average and O(n^2) worst case.</p>
<pre><code>from collections import namedtuple


def main():
    # Item can be any class of your choice.
    # For simplcity I just used a named tuple.
    Item = namedtuple("item", ["a", "b"])

    l1 = [Item(1,1), Item(1,2), Item(1,2), Item(2, 2), Item(1,3)]
    l2 = [Item(1,2), Item(2,2), Item(3,2)]

    # O(n) time on average and O(n^2) worst case to create a set
    attributes_of_l2 = {(item.a, item.b) for item in l2}

    # Checking match is O(1) (average case, O(n) worst case)
    # Therefore, this takes O(n) time on average and O(n^2) worst case.
    items_to_keep = [item for item in l1 if (item.a, item.b) in attributes_of_l2]

    print(items_to_keep)


if __name__ == '__main__':
    main()
</code></pre>
<p>Output:</p>
<p><code>[item(a=1, b=2), item(a=1, b=2), item(a=2, b=2)]</code></p>
<p>See <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">https://wiki.python.org/moin/TimeComplexity</a> for time complexity of checking if an item is in a set.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to improve the runtime is by optimizing match ops of attributes.</p>
<p>Iterate list1 and store its attribute in a hash as a key. Iterate list2 and lookup the attribute key in the earlier hash and do your thing. </p>
</div>
<span class="comment-copy">As I said already here you have <code>for obj in l1 + l2</code> which is O(2N) and and <code>for m in matches</code> which is O(X) and <code>len(matches[m])</code> within preceding loop that makes it O(X**2) also you have another extra blocks and its not pythonic at all.</span>
<span class="comment-copy"><code>O(2N)</code> + <code>O(X)</code> is still <code>O(N)</code>. <code>len</code> is <code>O(1)</code> (<a href="http://stackoverflow.com/a/1115329">source</a>), so the loop is not <code>O(X**2)</code>. The overall complexity of this solution is <code>O(N)</code>. As for being pythonic, I agree your solution is more elegant, but at the cost of efficiency. I would definitely make the "less pythonic code" tradeoff for changing an <code>O(N**2)</code> algorithm to <code>O(N)</code>.</span>
<span class="comment-copy">Just move this code into a helper function to keep the ugliness somewhere contained :)</span>
<span class="comment-copy">Yep O(2N) + O(X) is still O(N), and the <code>len</code> in python is O(1) but by <code>len(matches[m])</code> I meant the indexing takes O(x) :-D . anyway it was a good suggestion ;)</span>
<span class="comment-copy">I have the problem that the Attribute names differ from the the Objectlists: tuple1 = (obj.face,obj.label) and tuple2 = (obj.face,obj.elementLabel). Is there still a way?</span>
<span class="comment-copy">Using itertools.product will take O(N**2) steps like the original code. See my answer for a linear solution.</span>
<span class="comment-copy">@StevenKryskalla The original code is not  O(N**2) at all, but <code>product</code> is O(N**2) and is more efficient in terms of memory use, also you can not get the product between 2 list faster than this.  and in your code you have <code>for obj in l1 + l2:</code> which is O(2N) and and <code>for m in matches</code> which is O(X) and <code>len(matches[m])</code> within preceding loop that makes it O(X**2) also you have another extra blocks and its not pythonic at all.</span>
<span class="comment-copy">Time complexity is O(m+n). Time to add List1 attributes in hash + Time to iterate List2 and lookup its element attributes in hash.</span>
