<div class="post-text" itemprop="text">
<p>This question is very much related to <a href="https://stackoverflow.com/questions/7928044/how-to-properly-terminate-a-qthread-from-a-gui-application">this one</a>, which doesn't have a solution, but it is not exactly the same.</p>
<p>I would like to ask if there is a way of launching a background task in PyQt, and be able to <code>kill</code> it by pressing a button. </p>
<p>My problem is that I have an user interface and some external (3rd party) functions that take a while to compute. In order to not frozen the user interface while the task are computing, I run them on the background using <code>QThread</code> and synchronize the UI when they finish using <code>signals</code>. </p>
<p>However, I would like to add the option for the external user to press a button and cancel the current task (because the task is not needed/desired anymore).</p>
<p>Something that to me looks as simple as a <code>kill -9 *task*</code> in linux, is quite hard/ofuscated to obtain in Qt.</p>
<p>Right now I'm using custom Qthreads of the form of:</p>
<pre><code>mythread = Mythread()
mythread.finished.connect(mycallback)
mythread.start()
</code></pre>
<p>Where <code>Mythread</code> inherits <a href="http://pyqt.sourceforge.net/Docs/PyQt4/qthread.html" rel="nofollow">QThread</a> overriding the <code>run</code> method.</p>
<p>In the user interface, there is one button that tries to kill that thread by either using:</p>
<pre><code>mythread.exit(0)
mythread.quit()
mythread.terminate()
</code></pre>
<p>None of them works... I'm aware that the documentation states that the <code>terminate</code> method does have weird behaviours...</p>
<p>So the question is.. I'm facing this problem wrong? How to kill a QThread? If is not possible, is there any alternative to this?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>It is a very common mistake to try to kill a thread in the way you are suggesting.</p>
<p>For some reason, many people fail to realise that it's the <em>long-running task</em> that needs to be stopped - not the thread. You put the task in the thread because it was blocking the GUI. But that situation doesn't magically change because you moved it to a different thread. It will block <em>that</em> thread in exactly the same way unless you do something to stop it. Once you've stopped it, the thread can just finish normally (i.e. its <code>run()</code> method will exit).</p>
<p>A common way to control a long-running task is via a simple flag:</p>
<pre><code>class Thread(QThread):
    def stop(self):
        self._flag = False

    def run(self):
        self._flag = True
        for item in get_items():
            process_item(item)
            if not self._flag:
                break
        else:
            self._flag = False
</code></pre>
</div>
<span class="comment-copy">Do you keep a reference to the thread in a member variable of UI class or in a local variable?</span>
<span class="comment-copy">@qurban Yes I do. That's not the problem. The problem is that currently <code>QThread</code> doesn't have a killing mechanism.</span>
<span class="comment-copy">Please post the minimal working code, so that I can debug it. I always used to kill the <code>QThread</code> using <code>terminate</code> method and it always worked. I have gotten no idea why this is not working in your case.</span>
<span class="comment-copy">The problem I'm facing is that my <code>run</code> methods calls 3rd party libraries, say <code>scikits-learn</code> trying to learn a classifier, which could take minutes to hours. So my run could look like <code>self.classifier.train(self.X)</code>. In this case, which is the best alternative to run it as a thread/subprocess and be able to kill it?</span>
<span class="comment-copy">@imaluengo. If you can't control the long-running task, then you should use <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="nofollow noreferrer">multiprocessing</a>, rather than threads.</span>
<span class="comment-copy">Thank you! I'll give it a try and come back.</span>
