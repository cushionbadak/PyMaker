<div class="post-text" itemprop="text">
<p>If I tell Python v. 3.4.3,  <code>round(2.5)</code>, then it outputs <code>2</code>. If I tell it <code>round(1.5)</code> then it outputs 2 as well, though. Similarly, <code>round(3.5)</code> gives <code>4</code>, while <code>round(4.5)</code> gives <code>4</code> as well. I need Python to round with <em>consistency</em>, though. Specifically, it needs to round anytime I input a number halfway between two integers. So <code>round(1.5) = 1</code> and <code>round(2.5) = 2</code>, while <code>round(1.6) = 2</code> and such, as usual.</p>
<p>How can I resolve this?</p>
<p>EDIT: I've already read the documentation for the <code>round</code> function and understand that this is its intended behavior. My question is, how can I alter this behavior, because for my purposes I need 1.5 round down.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/2/library/functions.html#round" rel="nofollow">round docs</a> do address the peculiaries of rounding floating point numbers.</p>
<p>You can use the <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow">decimal</a> library to achieve what you want.</p>
<pre><code>from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_DOWN

round(2.675, 2)
# output: 2.67

Decimal('2.675').quantize(Decimal('1.11'), rounding=ROUND_HALF_UP)
# output: 2.68

Decimal('2.5').quantize(Decimal('1.'), rounding=ROUND_HALF_DOWN)
# output: 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your want "round down", and you are getting "round to even". Just do it manually by doing</p>
<pre><code>ceil(x - 0.5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 uses a different rounding behaviour compared to Python 2: it now uses so-called "banker's rounding" (<a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even" rel="nofollow">Wikipedia</a>): when the integer part is odd, the number is rounded away from zero; when the integer part is even, is it rounded towards zero.</p>
<p>The reason for this is to avoid a bias, when all values at .5 are rounded away from zero (and then e.g. summed).</p>
<p>This is the behaviour you are seeing, and it is in fact consistent. It's perhaps just different than what you are used to.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is documented pretty well. According to the <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow">Python docs for <code>round</code></a>:</p>
<blockquote>
<p>Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See <a href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow">Floating Point Arithmetic: Issues and Limitations</a> for more information</p>
</blockquote>
<p>In specific, this is a side-effect of how computers handle floating-point numbers in general.</p>
<p>If you need more precision, including different rounding, I suggest you check out <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow">the Python Decimal module</a>. Specifically of interest, they have the ability to control <a href="https://docs.python.org/3/library/decimal.html#rounding-modes" rel="nofollow">rounding modes</a>. Looks like you might want <code>decimal.ROUND_HALF_DOWN</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe I have the answer to all the rounding errors people have been encountering.  I have wrote my own method, which functions same as the "round" but actually looks at the last digit and rounds from there case by case.  There is no converting a decimal to binary.  It can handle any amount of numbers behind the decimal and it also takes scientific notation (as outputted by floats).  It also doesn't require any imports!  Let me know if you catch any cases that don't work!</p>
<pre><code>def Round(Number,digits = 0):
Number_Str = str(Number)
if "e" in Number_Str:
    Number_Str = "%.10f" % float(Number_Str)
if "." in Number_Str:   #If not given an integer
    try:
        Number_List = list(Number_Str)  #All the characters in Number in a list
        Number_To_Check = Number_List[Number_List.index(".") + 1 + digits]  #Gets value to be looked at for rounding.      
        if int(Number_To_Check) &gt;= 5:
            Index_Number_To_Round = Number_List.index(".") + digits
            if Number_List[Index_Number_To_Round] == ".":
                Index_Number_To_Round -= 1
            if int(Number_List[Index_Number_To_Round]) == 9:
                Number_List_Spliced = Number_List[:Number_List.index(".")+digits]
                for index in range(-1,-len(Number_List_Spliced) - 1,-1):
                    if Number_List_Spliced[index] == ".":
                        continue
                    elif int(Number_List_Spliced[index]) == 9:
                        Number_List_Spliced[index] = "0"
                        try:
                            Number_List_Spliced[index-1]
                            continue
                        except IndexError:
                            Number_List_Spliced.insert(0,"1")
                    else:
                        Number_List_Spliced[index] = str(int(Number_List_Spliced[index])+1)
                        break
                FinalNumber = "".join(Number_List_Spliced)
            else:
                Number_List[Index_Number_To_Round] = str(int(Number_List[Index_Number_To_Round])+1)
                FinalNumber = "".join(Number_List[:Index_Number_To_Round + 1])
            return float(FinalNumber)
        else:
            FinalNumber = "".join(Number_List[:Number_List.index(".") + 1 + digits])
            return float(FinalNumber)
    except IndexError:
        return float(Number)
else:   #If given an integer
    return float(Number)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 provides rounding methods defined in the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point#Rounding_rules" rel="nofollow noreferrer">IEEE Standard for Floating-Point Arithmetic (IEEE 754)</a>, the default rounding<sup>[1]</sup> is directed to the nearest number and minimizing cumulative errors.</p>
<p>In IEEE 754, there are 5 methods defined, two for rounding <strong>to nearest</strong> (Python provides the first one by <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer"><code>round</code></a>) and three methods that are <strong>explicitly directed</strong> (Python has <code>trunc</code>, <code>ceil</code>, and <code>floor</code> in its <code>Math</code> module).</p>
<p>You obviously need a directed rounding and there is a way to tell this Python, you have just to choose.</p>
<hr/>
<p><sup>[1]</sup> Since the representation of floating point numbers in computers is limited, rounding is not as trivial as you might think, you'll be surprised! I recommend a careful read of <a href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow noreferrer">15. Floating Point Arithmetic: Issues and Limitations</a> in the python 3 documentation.</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior">Python 3.x rounding behavior</a></span>
<span class="comment-copy">Note that this is not entirely a duplicate: the OP is mostly confused by the way Python 3 rounds, not by how it has changed from Python 2.</span>
<span class="comment-copy">This is an important observation for most Python newcomers. Though surprising at first, Python 3 rounds much <a href="http://stackoverflow.com/a/40376443/2932052">more consistent than you might think</a>.</span>
<span class="comment-copy">Good answer to the update question, I'd like to upvote it, but I find a word about the original topic missing for that.</span>
<span class="comment-copy">It's not really a matter of getting used to it. For my applications, I actually <i>need</i> it to always round numbers like 1.5, 2.5, 3.5, ... down. Is there a way to modify the <code>round</code> function to do this?</span>
<span class="comment-copy">@JamesPirlman If you need specific behaviors when dealing with non-integer numbers, you really need to use the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">Decimal module</a>, like I and others have mentioned. This is not about <code>round</code> in specific, but how computers handle floating point numbers in general. <a href="http://stackoverflow.com/a/31258564/2194039">See my answer</a>.</span>
<span class="comment-copy"><i><code>so-called "bankes's rounding"</code></i> should better be replaced by something that is more precise for this context, it's defined in IEEE-754, Wikipedia says <i><code>This is the default rounding mode used in IEEE 754 computing functions and operators (see also Nearest integer function).</code></i></span>
