<div class="post-text" itemprop="text">
<p>I want to be able to set environment variables in my Django app for tests to be able to run. For instance, my views rely on several API keys.</p>
<p>There are ways to <a href="https://docs.djangoproject.com/en/1.8/topics/testing/tools/#overriding-settings" rel="noreferrer">override settings during testing</a>, but I don't want them defined in <code>settings.py</code> as that is a security issue. </p>
<p>I've tried in my setup function to set these environment variables, but that doesn't work to give the Django application the values.</p>
<pre><code>class MyTests(TestCase):
    def setUp(self):
        os.environ['TEST'] = '123'  # doesn't propogate to app
</code></pre>
<p>When I test locally, I simply have an <code>.env</code> file I run with </p>
<pre><code>foreman start -e .env web
</code></pre>
<p>which supplies <code>os.environ</code> with values. But in Django's <code>unittest.TestCase</code> it does not have a way (that I know) to set that. </p>
<p>How can I get around this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>test.support.EnvironmentVarGuard</code> is an internal API that might be changed from version to version with breaking (backward incompatible) changes. <strong>In fact, the entire <code>test</code> package is internal use only.</strong> It was explicitly stated on the test package documentation page that it's for internal testing of core libraries and NOT a public API. (see links below)</p>
<p>You should use <a href="https://docs.python.org/3.4/library/unittest.mock.html#patch-dict" rel="noreferrer"><code>patch.dict()</code></a> in python's standard lib <code>unittest.mock</code>. It can be used as a context manager, decorator or class decorator.  See example code below copied from the official Python documentation.</p>
<pre><code>import os
from unittest.mock import patch
with patch.dict('os.environ', {'newkey': 'newvalue'}):
    print(os.environ['newkey'])  # should print out 'newvalue'
    assert 'newkey' in os.environ  # should be True
assert 'newkey' not in os.environ  # should be True
</code></pre>
<p>Update: for those who doesn't read the documentation thoroughly and might have missed the note, read more <code>test</code> package notes at</p>
<p><a href="https://docs.python.org/2/library/test.html" rel="noreferrer">https://docs.python.org/2/library/test.html</a> or </p>
<p><a href="https://docs.python.org/3/library/test.html" rel="noreferrer">https://docs.python.org/3/library/test.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As @schillingt noted in the comments, <a href="https://docs.python.org/2/library/test.html#test.test_support.EnvironmentVarGuard" rel="noreferrer">EnvironmentVarGuard</a> was the correct way. </p>
<pre><code>from test.test_support import EnvironmentVarGuard # Python(2.7 &lt; 3)
from test.support import EnvironmentVarGuard # Python &gt;=3
from django.test import TestCase

class MyTestCase(TestCase):
    def setUp(self):
        self.env = EnvironmentVarGuard()
        self.env.set('VAR', 'value')

    def test_something(self):
        with self.env:
            # ... perform tests here ... #
            pass
</code></pre>
<p>This correctly sets environment variables for the duration of the context object <code>with</code> statement. </p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>EnvironmentVarGuard</code> is not a good solution as it fails in some environments and works in others. see example below.</p>
<p><a href="https://i.stack.imgur.com/EhyX8.png" rel="nofollow noreferrer"><img alt="Python3.6 environment on gitlab ci" src="https://i.stack.imgur.com/EhyX8.png"/></a></p>
<p>A better solution is what was suggested by <a href="https://stackoverflow.com/users/1748754/erewok">erewok</a> that requires making use of the <code>unittest.mock</code> in python3.</p>
<p>Assuming using unittest</p>
<pre><code>from unittest.mock import patch
class TestCase(unittest.TestCase):

    def setUp(self):
        self.env = patch.dict('os.environ', {'hello':'world'})

    def test_scenario_1(self):
        with self.env:
            self.assertEqual(os.environ.get('hello'), 'world')
</code></pre>
<p>```</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are loading your environment variables in Django's <code>settings.py</code> file like this: </p>
<pre><code>import os
ENV_NAME = os.environ.get('ENV_NAME', 'default')
</code></pre>
<p>You could use this:  </p>
<pre><code>from django.test import TestCase, override_settings

@override_settings(ENV_NAME="super_setting")
def test_...(self):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use <code>py.test</code> as my test runner, and it allows you to create a <code>pytest.ini</code> file in which you can specify a particular settings file to use while running tests.</p>
<p>See documentation on this here:</p>
<p><a href="http://pytest-django.readthedocs.org/en/latest/configuring_django.html#pytest-ini-settings" rel="nofollow">http://pytest-django.readthedocs.org/en/latest/configuring_django.html#pytest-ini-settings</a></p>
<p>I recommend py.test in general as a test runner, because it supports different types of test classes and even simple functions, and it's pretty easy to set up fixtures or other code that runs before and after tests.</p>
</div>
<div class="post-text" itemprop="text">
<p>Old question, but it turned up in a Google search and neither of the existing answers are suitable. If you're using pytest, env vars can be set/restored using <a href="http://doc.pytest.org/en/latest/monkeypatch.html" rel="nofollow">pytest's monkeypatching functionality</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Initially, my env variable <code>PARTNER_CODE</code> was set to <code>wow</code>.</p>
<p>I could able to change the env variable using the following:</p>
<pre><code>from test.support import EnvironmentVarGuard
with EnvironmentVarGuard() as env:
   env['PARTNER_CODE'] = 'sos'
</code></pre>
<p>Now my env variable <code>PARTNER_CODE</code> says <code>sos</code>.</p>
</div>
<span class="comment-copy">Have you tried using <a href="https://docs.python.org/2/library/test.html#test.test_support.EnvironmentVarGuard" rel="nofollow noreferrer">EnvironmentVarGuard</a>?</span>
<span class="comment-copy">Yes, that was the right answer!</span>
<span class="comment-copy">@seb in the link you provided, it's anchored to <code>class test.test_support.EnvironmentVarGuard</code>, in other words, it's part of the <code>test</code> package, which is a regression test package for <b>Python</b>. And then scroll your page ALL THE WAY UP, read the note in the second line right after the title: <i>Note The test package is meant for internal use by Python only. It is documented for the benefit of the core developers of Python. Any use of this package outside of Python’s standard library is discouraged as code mentioned here can change or be removed without notice between releases of Python.</i></span>
<span class="comment-copy">Throws an import error.    Additionally, the documentation for EnvironmentVarGuard states: "Warning The test package is meant for internal use by Python only. It is documented for the benefit of the core developers of Python. Any use of this package outside of Python’s standard library is discouraged as code mentioned here can change or be removed without notice between releases of Python."</span>
<span class="comment-copy">python 3 moved it to <code>from test.support import EnvironmentVarGuard</code>. However, if you'd rather not depend on internal-use-only code, you could copy the <a href="https://github.com/python/cpython/blob/2.7/Lib/test/test_support.py#L957-L1001" rel="nofollow noreferrer">python 2.7 implementation of EnvironmentVarGuard</a> into your own code -- it's pretty straightforward.</span>
<span class="comment-copy">This is how to change <code>settings.py</code> files, not environment variables. My API calls, for example to AWS, etc are made with constructors that look for environment variables, not django settings.</span>
<span class="comment-copy">You said, "There are ways to override settings during testing, but I don't want them defined in settings.py as that is a security issue." I fail to see how defining variables in a settings file that is used <i>only</i> by your test runner is a security issue.</span>
<span class="comment-copy">I should have been clearer. There are two issues. 1) security, not committing credentials, 2) my workflow with <code>boto</code> and other APIs usings environment variables so I'd like to be able to use those. I was just drawing the analogy with settings.py</span>
<span class="comment-copy">Your tests are going to use actual API keys and credentials? They're actually going to communicate with third-party APIs?</span>
<span class="comment-copy">Yes, absolutely. It's rather hard to test whether an S3 bucket is writeable, etc without using API credentials.</span>
