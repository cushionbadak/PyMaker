<div class="post-text" itemprop="text">
<p>First of all, I am really new to this. I've been reading up on some tutorials over the past days, but now I've hit a wall with what I want to achieve.</p>
<p>To give you the long version: I have multiple files in a directory, all of which contain information in certain lines (23-26). Now, the code would have to find and open all files (naming pattern: <code>*.tag</code>) and then copy lines 23-26 to a new single file. (And add a new line after each new entry...). Optionally it would also remove a specific part from each line that I do not need:</p>
<p></p></div>
<div class="post-text" itemprop="text">
<p>Without importing anything but <code>os</code>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3
import os
# set the directory, the outfile and the tag below
dr = "/path/to/directory"; out = "/path/to/newfile"; tag = ".txt"

for f in [f for f in os.listdir(dr) if f.endswith(".txt")]:
    open(out, "+a").write(("").join([l for l in open(dr+"/"+f).readlines()[22:25]])+"\n")
</code></pre>
<h3>What it does</h3>
<p>It does exactly as you describe, it: </p>
<ul>
<li>collects a defined region of lines from all files (that is: of a defined extension) in a directory</li>
<li>pastes the sections into a new file, separated by a new line</li>
</ul>
<h3>Explanation</h3>
<pre><code>[f for f in os.listdir(dr) if f.endswith(".tag")]
</code></pre>
<p>lists all files of the specific extension in your directory,</p>
<pre><code>[l for l in open(dr+"/"+f).readlines()[22:25]]
</code></pre>
<p>reads the selected lines of the file</p>
<pre><code>open(out, "+a").write()
</code></pre>
<p>writes to the output file, creates it if it does not exist.</p>
<h3>How to use</h3>
<ul>
<li>Copy the script into an empty file, save it as <code>collect_lines.py</code></li>
<li>set in the head section the directory with your files, the path to the new file and the extension</li>
<li><p>run it with the command:</p>
<pre><code>python3 /path/to/collect_lines.py
</code></pre></li>
</ul>
<h3>The verbose version, with explanation</h3>
<p>If we "decompress" the code above, this is what happens:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3
import os
#--- set the path to the directory, the new file and the tag below
dr = "/path/to/directory"; out = "/path/to/newfile"; tag = ".txt"
#---

files = os.listdir(dr)
for f in files:
    if f.endswith(tag):
        # read the file as a list of lines
        content = open(dr+"/"+f).readlines()
        # the first item in a list = index 0, so line 23 is index 22
        needed_lines = content[22:25]
        # convert list to string, add a new line
        string_topaste = ("").join(needed_lines)+"\n"
        # add the lines to the new file, create the file if necessary
        open(out, "+a").write(string_topaste)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can look at the <a href="https://docs.python.org/2/library/glob.html" rel="nofollow">glob</a> module , it gives a list of filenames that match the pattern you provide it , please note this pattern is not regex , it is shell-style pattern (using shell-style wildcards).</p>
<p>Example of glob - </p>
<pre><code>&gt;&gt;&gt; import glob
&gt;&gt;&gt; glob.glob('*.py')
['a.py', 'b.py', 'getpip.py']
</code></pre>
<p>You can then iterate over each of the file returned by the <code>glob.glob()</code> function.</p>
<p>For each file you can do that same thing you are doing right now.</p>
<p>Then when writing files, you can use <code>str.find()</code> to find the first instance of the string <code>C12b2</code> and then use slicing to remove of the part you do not want.</p>
<p>As an example -</p>
<pre><code>&gt;&gt;&gt; s = "asdbcdasdC12b2jhfasdas"
&gt;&gt;&gt; s[s.find("C12b2"):]
'C12b2jhfasdas'
</code></pre>
<p>You can do something similar for each of your lines , please note if the usecase if that only some lines would have <code>C12b2</code> , then you need to first check whether that string is present in the line, before doing the above slicing. Example -</p>
<pre><code>if 'C12b2' in text:
    text = text[text.find("C12b2"):]
</code></pre>
<p>You can do above before writing the line into the output file.</p>
<p>Also, would be good to look into the <a href="http://preshing.com/20110920/the-python-with-statement-by-example/" rel="nofollow"><code>with</code></a> statement , you can use it for openning files, so that it will automatically handle closing the file, when you are done with the processing.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>realines</code> and <code>writelines</code> using <code>a</code> and <code>b</code> as line bounds for the slice of lines to write:</p>
<pre><code>with open('oldfile.txt', 'r') as old:
    lines = old.readlines()[a:b]

with open('newfile.txt', 'w') as new:
    new.writelines(lines)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="https://docs.python.org/3.4/library/glob.html" rel="nofollow"><code>glob</code> package</a> you can get a list of all <code>*.tag</code> files:</p>
<pre><code>import glob
# ['1.tag', '2.tag', 'foo.tag', 'bar.tag']
tag_files = glob.glob('*.tag')
</code></pre>
<p>If you open your file using the <a href="https://docs.python.org/3.4/reference/compound_stmts.html#the-with-statement" rel="nofollow"><code>with</code> statement</a>, it is being closed automatically afterwards:</p>
<pre><code>with open('file.tag') as in_file:
    # do something
</code></pre>
<p>Use <code>readlines()</code> to read your entire file into a list of lines, which can then be sliced:</p>
<pre><code>lines = in_file.readlines()[22:26]
</code></pre>
<p>If you need to skip everything before a specific pattern, use <a href="https://docs.python.org/3.4/library/stdtypes.html#str.split" rel="nofollow"><code>str.split()</code></a> to separate the string at the pattern and take the last part:</p>
<pre><code>pattern = 'C12b2'
clean_lines = [line.split(pattern, 1)[-1] for line in lines]
</code></pre>
<p>Take a look at this example:</p>
<pre><code>&gt;&gt;&gt; lines = ['line 22', 'line 23', 'Foobar: C12b2 line 24']
&gt;&gt;&gt; pattern = 'C12b2'
&gt;&gt;&gt; [line.split(pattern, 1)[-1] for line in lines]
['line 22', 'line 23', ' line 24']
</code></pre>
</div>
<span class="comment-copy">What else do you want to do besides getting lines?</span>
<span class="comment-copy">I must admit, when I first read your question, my thoughts were "do you <i>have</i> to use python?" Because if I had your problem, I'd probably try to do the file manipulation with sed and just pipe the lines I wanted python to deal with to python.</span>
<span class="comment-copy">What you are describing is actually easier with <code>awk</code> if you are on a *nix type system.</span>
<span class="comment-copy">Your second requirement: "everything before C12b2 (or similar) would need to be removed" would need some further explanation/specification of the string.</span>
<span class="comment-copy">the string to be removed would like the following: &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;. it is repeated at the beginning of every new line.</span>
<span class="comment-copy">thanks for an explanation that even a newb can understand!;) the code works just fine. now I only have to find out how I can remove part of a string that is being copied over into the new file. thus far I have: "pattern = '&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;'  lines = content[22:27]	 	 clean_lines = [line.split(pattern, 1)[-1] for line in lines]". It doesn't really do anything though. "str.strip([chars])" probably wont help here either because then I would have to define the string before or after the unwanted part (?).</span>
<span class="comment-copy">@Jonnecy could you describe the pattern? for specifically <code>C12b2</code> I had it in my code, until I read: <code>(or similar) </code> :)</span>
<span class="comment-copy">here is an example line: &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;C13b2. now, I need the c13b2 (or anything that comes after that first pattern, i.e. I cannot specify what is supposed to remain) to remain, and the pattern &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt; (which is repeated at the beginning of each new line in the output file) to be removed.</span>
<span class="comment-copy">@Jonnecy I have to run now, will add additional info :)</span>
<span class="comment-copy">thank for the explanation! about that "c12b2" part: that was only an example, the problem is that in fact I do not know what each line from 23-26 actually contains (except for the strings that I want removed).</span>
<span class="comment-copy">You want everything before the string you have removed right?</span>
<span class="comment-copy">here's an example: if one of the extracted (or to be extracted) lines looks like the following: &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;C13b2   then I would want everything in front of the C13b2 (which is always going to be the pattern &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;) to be removed from each line. however, what comes after that pattern is always going to be different, so I cannot specify that beforehand in the code.</span>
<span class="comment-copy">That is what my code does.</span>
<span class="comment-copy">ok, then that was just my incompetence;P thanks for the code and the explanations;)</span>
<span class="comment-copy">that sounds interesting! but how would I implement that if lines that I want to extract look like the following: "&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;{London, British Library, Cotton Caligula A ix, The Owl and the Nightingale, language 1=} &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;C13b2 &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;390 262 N &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;{=Central Worcs=} &lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;{=Sample tagged: fols. 233r-239v line 13; 240r line 6-241v line 15,}".  --------&gt; "&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="list"&gt;" is always at the beginning of a new line.</span>
<span class="comment-copy">thanks for the suggestions! can this code already be used as is, or do I have to add/modify anything ? currently it returns a SyntaxError in line 8 (there is no line 8).</span>
<span class="comment-copy">How did you attempt to run this code? These snippets still need to be placed together: Generate your list of <code>*.tag</code> files (first block), iterate over it (<code>for fname in tag_files:</code>), open the file (second block), read and "clean" the lines (third and fourth block) and save the <code>clean_lines</code> list to a file using <a href="https://docs.python.org/3/library/io.html#io.IOBase.writelines" rel="nofollow noreferrer"><code>writelines()</code></a></span>
<span class="comment-copy">hm, the problem with generating a list of all *.tag files is that it doesn't really make it much easier as there are dozens of hundreds of these. I have found a way of extracting the relevant lines; what is left now is removing the unwanted strings from each extracted line. those strings always follow the same pattern (i.e. they are always the same), however, whatever follows after that string is not something I can specify beforehand. it would simply have to find all instances of that string and remove it.</span>
<span class="comment-copy">you can generate the list of tag files using <code>glob.glob('*.tag')</code>, no manual work required :-)  -  For the removal of the unwanted string take a look at the example I've added to the answer</span>
