<div class="post-text" itemprop="text">
<p>I have a list of namedtuples named <code>Books</code> and am trying to increase the <code>price</code> field by 20% which does change the value of <code>Books</code>. I tried to do:</p>
<pre><code>from collections import namedtuple
Book = namedtuple('Book', 'author title genre year price instock')
BSI = [
       Book('Suzane Collins','The Hunger Games', 'Fiction', 2008, 6.96, 20),
       Book('J.K. Rowling', "Harry Potter and the Sorcerer's Stone", 'Fantasy', 1997, 4.78, 12)]
for item in BSI:
    item = item.price*1.10
print(item.price)
</code></pre>
<p>But I keep getting :</p>
<pre><code> Traceback (most recent call last):
 print(item.price)
 AttributeError: 'float' object has no attribute 'price'
</code></pre>
<p>I understand that I cannot set the fields in a namedtuple. How do I go about updating <code>price</code>?</p>
<p>I tried to make it into a function:</p>
<pre><code>def restaurant_change_price(rest, newprice):
    rest.price = rest._replace(price = rest.price + newprice)
    return rest.price

print(restaurant_change_price(Restaurant("Taillevent", "French", "343-3434", "Escargots", 24.50), 25))
</code></pre>
<p>but I get an error with replace saying:</p>
<pre><code> rest.price = rest._replace(price = rest.price + newprice)
 AttributeError: can't set attribute
</code></pre>
<p>Can someone let me know why this is happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>Named tuples are <strong>immutable</strong>, so you cannot manipulate them.</p>
<h2>Right way of doing it:</h2>
<p>If you want something <strong>mutable</strong>, you can use <a href="https://pypi.python.org/pypi/recordtype" rel="noreferrer"><code>recordtype</code></a>.</p>
<pre><code>from recordtype import recordtype

Book = recordtype('Book', 'author title genre year price instock')
books = [
   Book('Suzane Collins','The Hunger Games', 'Fiction', 2008, 6.96, 20),
   Book('J.K. Rowling', "Harry Potter and the Sorcerer's Stone", 'Fantasy', 1997, 4.78, 12)]

for book in books:
    book.price *= 1.1
    print(book.price)
</code></pre>
<p><strong>PS:</strong> You may need to <code>pip install recordtype</code> if you don't have it installed.</p>
<h2>Bad way of doing it:</h2>
<p>You may also keep using <code>namedtuple</code> with using the <a href="https://docs.python.org/2/library/collections.html#collections.somenamedtuple._replace" rel="noreferrer"><code>_replace()</code></a> method.</p>
<pre><code>from collections import namedtuple

Book = namedtuple('Book', 'author title genre year price instock')
books = [
   Book('Suzane Collins','The Hunger Games', 'Fiction', 2008, 6.96, 20),
   Book('J.K. Rowling', "Harry Potter and the Sorcerer's Stone", 'Fantasy', 1997, 4.78, 12)]

for i in range(len(books)):
    books[i] = books[i]._replace(price = books[i].price*1.1)
    print(books[i].price)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This looks like a task for Python's data analysis library, <a href="http://pandas.pydata.org/pandas-docs/stable/index.html" rel="nofollow">pandas</a>. It's really, really easy to do this sort of thing:</p>
<pre><code>In [6]: import pandas as pd
In [7]: df = pd.DataFrame(BSI, columns=Book._fields)
In [8]: df
Out[8]: 
           author                                  title    genre  year  \
0  Suzane Collins                       The Hunger Games  Fiction  2008   
1    J.K. Rowling  Harry Potter and the Sorcerers Stone  Fantasy  1997   

   price  instock  
0   6.96       20  
1   4.78       12  

In [9]: df['price'] *= 100
In [10]: df
Out[10]: 
           author                                  title    genre  year  \
0  Suzane Collins                       The Hunger Games  Fiction  2008   
1    J.K. Rowling  Harry Potter and the Sorcerer's Stone  Fantasy  1997   

   price  instock  
0    696       20  
1    478       12  
</code></pre>
<p>Now isn't that just much, much better than labouring with <code>namedtuple</code>s?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python &gt;= 3.7 you can use <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclass</a> decorator with the new variable annotations feature to produce mutable record types:</p>
<pre><code>from dataclasses import dataclass


@dataclass
class Book:
    author: str
    title: str
    genre: str
    year: int
    price: float
    instock: int


BSI = [
    Book("Suzane Collins", "The Hunger Games", "Fiction", 2008, 6.96, 20),
    Book(
        "J.K. Rowling",
        "Harry Potter and the Sorcerer's Stone",
        "Fantasy",
        1997,
        4.78,
        12,
    ),
]

for item in BSI:
    item.price *= 1.10
    print(f"New price for '{item.title}' book is {item.price:,.2f}")
</code></pre>
<p>Output:</p>
<pre><code>New price for 'The Hunger Games' book is 7.66
New price for 'Harry Potter and the Sorcerer's Stone' book is 5.26
</code></pre>
</div>
<span class="comment-copy">sorry.. It was supposed to be BSI not Books.. I edited the question.</span>
<span class="comment-copy">@LeonSurrao I updated the post with <code>_replace()</code> method as you wish.</span>
<span class="comment-copy">I don't understand the python community... That <code>namedtuple._replace()</code> is pretty idiomatic in functional languages, why is that "private" here!? It really shouldn't be a bad way to do it, it's certainly better than to convert to mutable madness</span>
<span class="comment-copy">Instead of <code>rest.price = rest._replace(price = rest.price + newprice)</code>, do <code>rest = rest._replace(price = rest.price + newprice)</code>. Note that <code>_replace()</code> returns you a new instance of <code>namedtuple</code>.</span>
<span class="comment-copy">@progo,<code>_replace</code> is actually not "private" or internal. based on <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">this</a> doc: <i>To prevent conflicts with field names, the method and attribute names start with an underscore.</i></span>
<span class="comment-copy">Is there a way to achieve the same using the _replace method?</span>
