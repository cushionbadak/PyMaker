<div class="post-text" itemprop="text">
<p>i've this implementation of singleton pattern in python, but i've noticed
that the <strong>init</strong> is called, uselessly, everytime i call MyClass, despite the same instance is returned.</p>
<p>How can i avoid it?</p>
<pre><code>class Test(object):
    def __init__(self, *args, **kwargs):
        object.__init__(self, *args, **kwargs)

class Singleton(object):
  _instance = None

  def __new__(cls):
    if not isinstance(cls._instance, cls):
        cls._instance = object.__new__(cls)
    return cls._instance

class MyClass(Singleton):
    def __init__(self):
        print("should be printed only 1 time")
        self.x=Test()
        pass

a = MyClass() # prints: "should be printed only 1 time"
b = MyClass() # prints ( again ): "should be printed only 1 time"

print(a,b) # prints: 0x7ffca6ccbcf8 0x7ffca6ccbcf8
print(a.x,b.x) # prints: 0x7ffca6ccba90 0x7ffca6ccba90
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>__new__</code> doesn't return an object, it returns an unitialized object on which <code>__init__</code> is called afterwards.</p>
<p>You can't avoid that at all. What you can do is the following(using metatypes):</p>
<pre><code>class Singleton(type):
    def __init__(self, name, bases, mmbs):
        super(Singleton, self).__init__(name, bases, mmbs)
        self._instance = super(Singleton, self).__call__()

    def __call__(self, *args, **kw):
        return self._instance

class Test(metaclass = Singleton):
    # __metaclass__ = Singleton # in python 2.7
    def __init__(self, *args, **kw):
        print("Only ever called once")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another simple, but totally viable way to implement what you want, which doesn't require super or meta classes, is to just make your class a Python module, which are essentially Singleton objects.</p>
<p>Here's what I mean:</p>
<p><code>myclass.py</code>:</p>
<pre><code>class Test(object):
    pass

class MyClass(object):
    def __init__(self):
        print("in MyClass.__init__, should be printed only 1 time")
        self.x = Test()

    def __call__(self, *args, **kwargs):
        classname = type(self).__name__
        return globals()[classname]

MyClass = MyClass()
</code></pre>
<p><code>client.py</code>:</p>
<pre><code>from myclass import MyClass

a = MyClass()
b = MyClass()

print(a, b)
print(a.x, b.x)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>in MyClass.__init__, should be printed only 1 time
&lt;myclass.MyClass object at 0x02200B30&gt; &lt;myclass.MyClass object at 0x02200B30&gt;
&lt;myclass.Test object at 0x02200C10&gt; &lt;myclass.Test object at 0x02200C10&gt;
</code></pre>
<p>It's possible to derive a subclass from MyClass, but you'd have to do it something like this:</p>
<pre><code>class Derived(type(MyClass)):
    def __init__(self):
        print("in Derived.__init__, should be printed only 1 time")

Derived = Derived()
</code></pre>
<p>Afterwards you could add this to 'client.py':</p>
<pre><code>from myclass import Derived

a = Derived()
b = Derived()

print(a,b)
print(a.x,b.x)  # AttributeError: 'Derived' object has no attribute 'x'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__init__</code>, if implemented, is <em>always</em> called on whatever gets returned by <code>__new__</code>; in general, you should be implementing one or the other, not both. You could implement <code>__new__</code> on <code>MyClass</code>, instead, and initialise the <code>x</code> attribute only if it doesn't already exist:</p>
<pre><code>class MyClass(Singleton):

    def __new__(cls):
        inst = super(MyClass, cls).__new__(cls)
        if not hasattr(inst, 'x'):
            print("should be printed only 1 time")
            inst.x = Test()
        return inst
</code></pre>
<p>In use:</p>
<pre><code>&gt;&gt;&gt; a = MyClass()
should be printed only 1 time
&gt;&gt;&gt; b = MyClass()
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a.x is b.x
True
</code></pre>
</div>
<span class="comment-copy">Because <code>__init__</code> is <i>always</i> called, if implemented, on whatever <code>__new__</code> returns - why don't you do the initialisation in <code>__new__</code> when <code>cls._instance is None</code>?</span>
<span class="comment-copy">cls._instance is never None if you must call super().__new__ to create the instance as first thing in <b>new</b> of child class. I need the created instance to set an instance variable</span>
<span class="comment-copy">@jonrsharpe: An instance's <code>__init__</code> is <i>not</i> always called, it depends on the type of what <code>__new__</code> returns. From the <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__new__#object.__new__" rel="nofollow noreferrer">docs</a>: "If <code>__new__()</code> does not return an instance of <i>cls</i>, then the new instance’s <code>__init__()</code> method will not be invoked."</span>
<span class="comment-copy">@martineau good to know, thanks - in general, though, wouldn't <code>__new__</code> be returning a <code>cls</code> instance?</span>
<span class="comment-copy">@jonrsharpe: Sure, but "in general" isn't the same thing as an emphasized "always". In fact, I've seen designs that utilize this fact, although I don't see how it helps with this particular question.</span>
<span class="comment-copy">So where should i've to put the constructor for your Test class? inside <b>new</b> ?</span>
<span class="comment-copy">@Joseph if you do it this way you can implement <code>__init__</code> in <code>Test</code> and it will only be called once.</span>
<span class="comment-copy">@Joseph, with this, you can code <code>Test</code> without worrying that the constructor is called twice :) Updated the answer</span>
<span class="comment-copy">AWESOME! thanks :)</span>
<span class="comment-copy">there are so many singleton implementations for Python, this was the only one that worked without editing. Super thanks!</span>
<span class="comment-copy">Wow. Think outside the box. But you can't inherit from the class anymore</span>
<span class="comment-copy">@WorldSEnder: I believe you're mistaken—it's quite possible to derive a subclass from the class as shown and the end of my (updated) answer.</span>
<span class="comment-copy">it's a sort of workaround because if i've another class that extends MyClass, that must call the super().__new__() and then change x in constructor, i should write ugly code to implement an exclusive constructor for this second class with singleton. I think this pattern cannot be implemented in this way in python ( but i've read it in many books)</span>
