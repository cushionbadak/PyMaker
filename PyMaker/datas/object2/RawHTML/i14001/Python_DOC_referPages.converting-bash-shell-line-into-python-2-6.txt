<div class="post-text" itemprop="text">
<p>I am relatively new to programming especially in BASH and python, as well as this site. Sorry for multiple posts!
I am trying to get this line into python. I have tried os.popen.
Are there any other ways you guys can think of how to do it. I am limited to python v2.6 and cannot upgrade to a newer version, otherwise I would know how to do it in 3.whatever. 
Thanks!</p>
<pre><code> sample1=($(/bin/cat /proc/meminfo | egrep 'MemTotal|MemFree|Cached|SwapTotal|SwapFree|AnonPages|Dirty|Writeback|PageTables|HugePages_' | awk ' { print $2} ' | pr -t -T --columns=15 --width=240))
</code></pre>
<p>This is what I have in python but it isn't working. Any one have any idea how to rearrange it so it would be the same as the line in BASH.
I know these shouldn't be elif. Honestly i'm stumped and don't know where to go from here.</p>
<pre><code>lst = []  #
inFile = open('/proc/meminfo')  # open file
line = inFile.readline()
sample1 = {}  # 
while(line):  # 
    if line.find('MemTotal'):
        line = line.split()
        sample1['MemTotal'] = line[1]
    elif line.find('MemFree'):
            line = line.split()
            sample1['MemFree'] = line[1]
    elif line.find(line, 'Cached'):
            line = line.split()
            sample1['Cached'] = line[1]
    elif line.find(line, 'SwapTotal'):
            line = line.split()
            sample1['SwapTotal'] = line[1]
    elif line.find(line, 'SwapFree'):
            line = line.split()
            sample1['SwapFree'] = line[1]
    elif line.find(line, 'AnonPages'):
            line = line.split()
            sample1['AnonPages'] = line[1]
    elif line.find(line, 'Dirty'):
            line = line.split()
            sample1['Dirty'] = line[1]
    elif line.find(line, 'Writeback'):
            line = line.split()
            sample1['WriteBack'] = line[1]
    elif line.find(line, 'PageTables'):
            line = line.split()
            sample1['PageTables'] = line[1]
    elif line.find(line, 'HugePages_'):
            line = line.split()
            sample1['HugePages'] = line[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should run the bash command from python by piping the output through <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen" rel="nofollow">subprocess.Popen</a> and work for python2.6:</p>
<pre><code>from subprocess import Popen, PIPE
p1 = Popen(["cat","/proc/meminfo"], stdout=PIPE)
p2 = Popen(["egrep", 'MemTotal|MemFree|Cached|SwapTotal|SwapFree|AnonPages|Dirty|Writeback|PageTables|HugePages_' ], stdin=p1.stdout, stdout=PIPE)
p1.stdout.close()  
p3 = Popen(["awk","{ print $2}"],stdin=p2.stdout,stdout=PIPE)
p2.stdout.close()
p4 = Popen(["pr", "-t", "-T", "--columns=15", "--width=240"],stdin=p3.stdout,stdout=PIPE)
p3.stdout.close()

output = p4.communicate()
print(output[0])
</code></pre>
<p>The output from my system is:</p>
<pre><code>16341932    4484840     5105220     0       8388604     8388604     108     0       5106832     78100       0       0       0       0       0
</code></pre>
<p>You can also open the file with python and pass the file object to the first process:</p>
<pre><code>from subprocess import Popen,PIPE,STDOUT
with open("/proc/meminfo") as f:
    p1 = Popen(["egrep", 'MemTotal|MemFree|Cached|SwapTotal|SwapFree|AnonPages|Dirty|Writeback|PageTables|HugePages_' ], stdin=f, stdout=PIPE)
    p2 = Popen(["awk","{ print $2}"],stdin=p1.stdout,stdout=PIPE)
    p1.stdout.close()
    p3 = Popen(["pr", "-t", "-T", "--columns=15", "--width=240"],stdin=p2.stdout,stdout=PIPE)
    p2.stdout.close()

output = p3.communicate()
print(output[0])
</code></pre>
<p>A pure python solution using <code>str.find</code> to mimic egrep  finding lines that contain any of the substrings from pre in the file and using <code>str.rsplit</code> to get the second column i.e the digits:</p>
<pre><code>pre = ('MemTotal', 'MemFree', 'Cached', 'SwapTotal', 'SwapFree', 'AnonPages', 'Dirty', 'Writeback', 'PageTables', 'HugePages_')
with open("/proc/meminfo") as f:
    out = []
    for line in f: 
        # if line.find(p) is not -1 we have a match
        if any(line.find(p) != -1 for p in pre):
            # split twice from the end on whitespace and get the second column
            v = line.rsplit(None, 2)[1]
            out.append(v)
   print("  ".join(out))
</code></pre>
<p>Output:</p>
<pre><code>16341932   4507652   5128624   0   8388604   8388604   48   0   5059044   78068   0   0   0   0   0
</code></pre>
<p>Using <a href="https://docs.python.org/2/library/functions.html#any" rel="nofollow">any</a> in the above code will lazily evaluate and short circuit on a match, if there is no match it will evaluate to False so nothing gets added.</p>
<p>Staying truer to egrep we can use <a href="https://docs.python.org/2/library/re.html#search-vs-match" rel="nofollow">re.search</a> compiling the patterns/substrings to check for:</p>
<pre><code>import  re
r = re.compile(r"MemTotal|MemFree|Cached|SwapTotal|SwapFree|AnonPages|Dirty|Writeback|PageTables|HugePages_")
with open("/proc/meminfo") as f:
    out =[]
    for line in f:
        if r.search(line):
            v = line.rsplit(None, 2)[1]
            out.append(v)
print("  ".join(out))
</code></pre>
<p>Output:</p>
<pre><code>16341932   4507596   5128952   0   8388604   8388604   0   16788   5058092   78464   0   0   0   0   0
</code></pre>
<p>And python being python we can put all the logic in a single list comp to get the data:</p>
<pre><code>pre = ('MemTotal', 'MemFree', 'Cached', 'SwapTotal', 'SwapFree', 'AnonPages', 'Dirty', 'Writeback', 'PageTables', 'HugePages_')
with open("/proc/meminfo") as f:
    out = [line.rsplit(None, 2)[1] for line in f if r.search(line)]
print("   ".join(out))
</code></pre>
<p>Output:</p>
<pre><code>16341932   4443796   5133420   0   8388604   8388604   120   0   5118004   78572   0   0   0   0   0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This gives the same output, but using built-in Python features instead of shelling out for everything:</p>
<pre><code>columns = [
    'MemTotal', 'MemFree', 'Cached', 'SwapTotal', 'SwapFree', 'AnonPages',
    'Dirty', 'Writeback', 'WritebackTmp', 'PageTables', 'HugePages_Free',
    'HugePages_Rsvd', 'HugePages_Surp', 'HugePages_Total'
]
stats = {}
with open('/proc/meminfo') as infile:
    for line in infile:
        line = line.split()
        stats[line[0][:-1]] = line[1]

values = [stats[key] for key in columns]
print '\t'.join(values)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something along this line perhaps:</p>
<pre><code>desiredTags = [ 'MemTotal', 'MemFree', 'Cached', 'SwapCached', 'SwapTotal',
                'SwapFree', 'AnonPages', 'Dirty', 'Writeback', 'PageTables',
                'HugePages_Total', 'HugePages_Free', 'HugePages_Rsvd',
                'HugePages_Surp' ]
stats = []
with open('/proc/meminfo') as fd:
    for line in fd:
        fields = line.strip().split()
        # strip off the colon from the first field
        if fields[0][:-1] in desiredTags:
            stats.append(fields[1])

print ' '.join(stats)
</code></pre>
<p>Not sure I got the list of desired tags exactly right - feel free to amend those as necessary.</p>
</div>
<span class="comment-copy">You can run the commands by piping with subprocess.Popen</span>
<span class="comment-copy">I don't know whether this is the problem or not, but I noticed that you're using <code>find()</code>. When no matches are found, it returns <code>-1</code>, not <code>0</code>. Your program will do the <code>line = line.split()...</code> etc. when there's no match, and fail to do it when the match is found at the beginning of the string. Instead, use <code>if line.find(thestring) + 1:</code>. This will turn a failed search into a falsey value and all successful searches into a truthy value.</span>
<span class="comment-copy">First suggestion: separate the repetitive code into a function, then call it with the arguments.  Second suggestion: use the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code></a> module for matching lines, similar to using <code>grep</code> in your shell code.</span>
<span class="comment-copy">I'd also suggest inspecting and understanding each step of the shell pipeline in separation and similarly creating the Python code in steps. By the way: Do not waste your time on learning Python 2.6! Python 3 has been out for a few years and is stable now, use that!</span>
<span class="comment-copy">This is a good answer for showing, literally, how to convert the shell to python.  The shell code is essentially just running several other programs, using pipes, and so is the python code in this answer.</span>
<span class="comment-copy">@dsh, yes cheers, there are many ways to do it and more efficient ways but I tried to stay as close to the OP's code as possible.</span>
<span class="comment-copy">these are great, thanks. this is way more efficient and more susceptible to manipulate for prior functions.</span>
<span class="comment-copy">This is similar to my answer. Change <code>desiredTags</code> to a tuple, replace all the <code>HugePages_</code> entries with the original <code>HugePages_</code> string, and make your conditional to <code>if fields[0][:-1].startswith(desiredTags)</code> and it'd be almost exactly like his code.</span>
<span class="comment-copy">@KirkStrauser if I were changing anything I would be making it a set but this would not work as egrep will look for substring matches, <code>SwapCached</code> does not exist in the OP's original code so it would be missed using in.</span>
<span class="comment-copy">@twalberg, you can pass a tuple to str.startswith with multiple substrings to check, I originally had it in my code until I realised SwapCached would be missed</span>
<span class="comment-copy">@PadraicCunningham Yep... I missed the "change it to a tuple" bit... It won't work with a list, though...</span>
<span class="comment-copy">@PadraicCunningham Ah, yes, good catch... Fixed</span>
