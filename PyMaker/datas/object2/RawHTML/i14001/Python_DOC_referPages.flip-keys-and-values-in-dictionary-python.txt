<div class="post-text" itemprop="text">
<p>I have a dictionary called z that looks like this</p>
<hr/>
<p>{0: [0.28209479177387814, 0.19947114020071635, 0.10377687435514868, 0.07338133158686996], 
-1: [0.28209479177387814, 0.19947114020071635, 0.10377687435514868, 0.07338133158686996]}.</p>
<p>I want to flip the values and keys to have </p>
<p>{0.28209479177387814:0, 0.19947114020071635:0, 0.10377687435514868:0, 0.07338133158686996:0, 
0.28209479177387814:-1, 0.19947114020071635:-1, 0.10377687435514868:-1, 0.07338133158686996:-1}</p>
<p>The piece of code that seems to work is :</p>
<pre><code>for a in z:
     newdict=dict.fromkeys(z[a],a)
</code></pre>
<p>but it only works for one of the keys in z and returns this:</p>
<p>{0.28209479177387814: -1, 0.07338133158686996: -1, 0.10377687435514868: -1, 0.19947114020071635: -1}</p>
<p>what am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't have duplicate keys in a dictionary, but you can pair them together using tuples in a meaningful way.</p>
<pre><code>from itertools import product, chain

tuples = chain.from_iterable(product(vs, [k]) for k, vs in orig_dict.items())
# note this is identical to:
# # tuples = []
# # for k, vs in orig_dict.items():
# #     for tup in [(v, k) for v in vs]:
# #         tuples.append(tup)
</code></pre>
<p>That will produce:</p>
<pre><code>[(0.28209479177387814, 0), (0.19947114020071635, 0),
 (0.10377687435514868, 0), (0.07338133158686996, 0),
 (0.28209479177387814, -1), (0.19947114020071635, -1),
 (0.10377687435514868, -1), (0.07338133158686996, -1)]
</code></pre>
<p>Now if you really wanted something interesting, you could sort that and group it together.</p>
<pre><code>from itertools import groupby

groups = groupby(sorted(tuples), key=lambda kv: kv[0])
</code></pre>
<p>That creates something like:</p>
<pre><code>[(0.07338133158686996, [(0.07338133158686996, 0,
                         0.07338133158686996, -1] ),
 ... ]
</code></pre>
<p>You could toss those into a dict by doing:</p>
<pre><code>final_dict = {k: [v[1] for v in vs] for k, vs in groups}
</code></pre>
<p>Which should finally give:</p>
<pre><code>{0.07338133158686996: [0, -1],
 ... }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you have already seen in the comments on your question, Python dictionaries cannot have duplicate keys, since there would be uncertainty as to a correct single value given a key</p>
<p>This could be fixed by having parallel structure to the first, so instead of <code>{value:key}</code>, it would be <code>{value:[key1, key2]}</code>. The code to generate it would be:</p>
<pre><code>new = {}
for key, value in z.items():
  if not value in new:
    new[value] = []
  new[value].append(key)
</code></pre>
<p>See Adam Smith's answer for more details. </p>
</div>
<div class="post-text" itemprop="text">
<p>Easiest way to flip key value in a dict is using dict comprehension, which looks like this: <code>{value: key for key, value in ORIGINAL_DICT.items()}</code>. Full example:</p>
<pre><code>REGION_PREFIX = {
    'AB': 'Alberta',
    'BC': 'British Columbia',
    'IN': 'International',
    'MB': 'Manitoba',
    'NB': 'New Brunswick',
    'NL': 'Newfoundland',
    'NS': 'Nova Scotia',
    'NU': 'Nunavut',
    'NW': 'Northwest Territories',
    'ON': 'Ontario',
    'PE': 'Prince Edward Island',
    'QC': 'Quebec',
    'SK': 'Saskatchewan',
    'US': 'United States',
    'YK': 'Yukon',
}

REGION_PREFIX2 = {value: key for key, value in REGION_PREFIX.items()}
</code></pre>
<p>And your output is this:</p>
<pre><code>{'Alberta': 'AB', 'British Columbia': 'BC', 'International': 'IN', 'Manitoba': 'MB', 'New Brunswick': 'NB', 'Newfoundland': 'NL', 'Nova Scotia': 'NS', 'Nunavut': 'NU', 'Northwest Territories': 'NW', 'Ontario': 'ON', 'Prince Edward Island': 'PE', 'Quebec': 'QC', 'Saskatchewan': 'SK', 'United States': 'US', 'Yukon': 'YK'}
</code></pre>
<p>Cheers!</p>
</div>
<span class="comment-copy">keys have to be distinct, sorry.</span>
<span class="comment-copy">Consider what it would mean to ask your desired inverted dictionary for a value <code>z[0.28209479177387814]</code>. Which value should it give you? <code>0</code> or <code>-1</code>?</span>
<span class="comment-copy">I'm sorry I don't understand. What do you mean distinct? 0 is distinct from -1, isn't it?</span>
<span class="comment-copy">And <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">here is some documentation about unique dictionary keys</a>.</span>
<span class="comment-copy">The <i>keys</i> have to be distinct. In the output dictionary, <code>0</code> and <code>-1</code> are <i>not</i> keys, they're values. The keys are the long floating-point numbers.</span>
<span class="comment-copy">I think the first part is what I want, but when I try the code, it returns "itertools.chain object at 0x10db527d0" instead of what you've shown</span>
<span class="comment-copy">@kiprin629 that's because it returns a generator whose values are listed above. If you actually need the list for something (and keep in mind I <i>VERY MUCH</i> doubt that you do), you can do <code>tuples = list(chain.from_iterable( ... ))</code></span>
<span class="comment-copy">I've avoided the use of lists here. The next <code>groupby</code> step also produces a generator (of generators). Using lists when you're just trying to transform data wastes a good deal of memory, depending on how large your dataset is.</span>
<span class="comment-copy">I'm very new to Python (as you can tell), so I'm not really familiar with generators. Do you know where I can find more on that?</span>
<span class="comment-copy">@kiprin629 well if you google "python generator" you get <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">wiki.python.org/moin/Generators</a> which is probably a good place to start ;). Ultimately you can think of generators as a type of iterable that only works once. They're one-time-use, but the dividends they pay are in RAM!</span>
<span class="comment-copy">Or you can be lazy and use collections.defaultdict with a default of <code>list</code> :P</span>
<span class="comment-copy">@NightShadeQueen or you can be lazy and use <code>new.setdefault(value, []).append(key)</code> :)</span>
<span class="comment-copy">I like the code you have suggested; however, I would like to group each element in the value lists with the key to make a set of data points</span>
<span class="comment-copy">@kiprin629 if you just need a set of data points, you want a list of tuples, not a dictionary. See the first part of my answer.</span>
