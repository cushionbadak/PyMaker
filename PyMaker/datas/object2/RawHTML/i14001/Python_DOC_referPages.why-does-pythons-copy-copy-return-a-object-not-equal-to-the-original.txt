<div class="post-text" itemprop="text">
<p>In Python, if I copy a list or a dictionary, the copied instance is equal to the original:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a = {"a":1, "b":2}
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a == b
True
</code></pre>
<p>But if I copy an object, the result is not equal to the original:</p>
<pre><code>&gt;&gt;&gt; class MyClass():
...     def __init__(self, name):
...             self._name= name
...
&gt;&gt;&gt; a = MyClass('a')
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a == b
False
</code></pre>
<p>Why?</p>
</div>
<div class="post-text" itemprop="text">
<p>Equality in Python for objects is checked by calling the <code>__eq__()</code> function.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; class CA:
...     def __eq__(self, other):
...             print("Equals")
...             return True
...
&gt;&gt;&gt; c = CA()
&gt;&gt;&gt; b = CA()
&gt;&gt;&gt; c == b
Equals
True
</code></pre>
<p>That is because <code>list</code> equality is dependent on the elements and not the actual memory location (reference) where the list is stored, that is, they can be two different list references, but if they have the same elements in the same order, the lists are equal.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; l = [1,2]
&gt;&gt;&gt; l1 = [1,2]
&gt;&gt;&gt; id(l)
2830504
&gt;&gt;&gt; id(l1)
2831864
&gt;&gt;&gt; l == l1
True
</code></pre>
<p>But custom class, you have not overwritten <code>__eq__()</code>, hence it would call the <code>__eq__()</code> of the parent class, which is <code>object</code>, and that checks equality based on the reference.</p>
<p>And when you do <code>copy.copy()</code> it does shallow copying, that is, it creates a new instance the object with all its members (attributes, etc.) remaining the same. Hence, they are unequal (as they are different references/different instances).</p>
<p>If you want your <code>MyClass</code> to check equality based on <code>self._name</code>, you will have to overwrite the <code>__eq__()</code> function for that.</p>
<p>You can find more information about comparisons <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow">here</a>.</p>
</div>
<span class="comment-copy">Related: <i><a href="http://stackoverflow.com/questions/2612802/how-to-clone-or-copy-a-list-in-python?lq=1">How to clone or copy a list in Python?</a></i> (not a duplicate, but perhaps it exists somewhere?).</span>
<span class="comment-copy">I think this is not the answer to this question at all, since OP's question is about copying the classes and instances not <code>==</code> operation!</span>
<span class="comment-copy">His question is - <code>list instances created using copy.copy are equal</code> - but custom classes are not, thats what i have answered, and the OP has accepted it, if you think you have a better answer go at it</span>
<span class="comment-copy">@Kasra And I have explained in the answer - <code>when you do copy.copy() it does shallow copying, that is the new object is a new reference</code> - and the reason for <code>not equality</code> is not having the <code>__eq__()</code> , function. Can you explain how this is not the answer?</span>
<span class="comment-copy">I would add to @AnandSKumar's answer the definition of what <code>copy.copy()</code> does for lists, dictionaries and custom classes: for all of them, it creates a new instance of the object, with exactly the same properties (like the elements in the list, or the name in <code>MyClass</code>), but in a new reference. Then it all depends on the <code>__eq__</code> function.</span>
