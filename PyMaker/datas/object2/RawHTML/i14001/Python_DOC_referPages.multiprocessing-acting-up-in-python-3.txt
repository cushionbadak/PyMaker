<div class="post-text" itemprop="text">
<p>I was messing around with a zip file cracker and decided to use the multiprocessing module to speed the process up. It was a complete pain since it was my first time using the module and I don't even fully understand it yet.  However, I got it to work.</p>
<p>The problem is that it doesn't complete the word list; it just stops at random puts during the word list, and if the password is found it continues to go through the word list instead of just stopping the process.</p>
<p>Does anyone know why it's exhibiting this behaviour?</p>
<p><strong>Source Code For ZipFile Cracker</strong></p>
<pre><code>#!/usr/bin/env python3

import multiprocessing as mp
import zipfile # Handeling the zipfile
import sys # Command line arguments, and quiting application
import time # To calculate runtime

def usage(program_name):
    print("Usage: {0} &lt;path to zipfile&gt; &lt;dictionary&gt;".format(program_name))
    sys.exit(1)

def cracker(password):
    try:
        zFile.extractall(pwd=password)
        print("[+] Password Found! : {0}".format(password.decode('utf-8')))
        pool.close()
    except:
        pass

def main():
    global zFile
    global pool

    if len(sys.argv) &lt; 3:
        usage(sys.argv[0])

    zFile = zipfile.ZipFile(sys.argv[1])

    print("[*] Started Cracking")

    startime = time.time()
    pool = mp.Pool()

    for i in open(sys.argv[2], 'r', errors='ignore'):
        pswd = bytes(i.strip('\n'), 'utf-8')
        pool.apply_async(cracker, (pswd,))

    print (pswd)
    runtime =  round(time.time() - startime, 5)
    print ("[*] Runtime:", runtime, 'seconds')
    sys.exit(0)

if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an implementation of the advice from <a href="https://stackoverflow.com/a/31350837/4279">@phihag's</a> and <a href="https://stackoverflow.com/a/31351538/4279">@Equality 7-2521's answers</a>:</p>
<pre><code>#!/usr/bin/env python3
"""Brute force zip password.

Usage: brute-force-zip-password &lt;zip archive&gt; &lt;passwords&gt;
"""
import sys
from multiprocessing import Pool
from time import monotonic as timer
from zipfile import ZipFile

def init(archive): # run at the start of a worker process
    global zfile
    zfile = ZipFile(open(archive, 'rb')) # open file in each process once

def check(password):
    assert password
    try:
        with zfile.open(zfile.infolist()[0], pwd=password):
            return password # assume success
    except Exception as e:
        if e.args[0] != 'Bad password for file':
            # assume all other errors happen after the password was accepted
            raise RuntimeError(password) from e

def main():
    if len(sys.argv) != 3:
        sys.exit(__doc__) # print usage

    start = timer()
    # decode passwords using the preferred locale encoding
    with open(sys.argv[2], errors='ignore') as file, \
         Pool(initializer=init, initargs=[sys.argv[1]]) as pool: # use all CPUs
        # check passwords encoded using utf-8
        passwords = (line.rstrip('\n').encode('utf-8') for line in file)
        passwords = filter(None, passwords) # filter empty passwords
        for password in pool.imap_unordered(check, passwords, chunksize=100):
            if password is not None:  # found
                print("Password: '{}'".format(password.decode('utf-8')))
                break
        else:
            sys.exit('Unable to find password')
    print('Runtime: %.5f seconds' % (timer() - start,))

if __name__=="__main__":
    main()
</code></pre>
<p>Note:</p>
<ul>
<li>each worker process has its own <code>ZipFile</code> object and the zip file is opened once per process: it should make it more portable (Windows support)  and improve time performance</li>
<li>the content is not extracted: <code>check(password)</code> tries to open and immediately closes an archive member on success: it is safer and it should improve time performance (no need to create directories, etc)</li>
<li>all errors except <code>'Bad password for file'</code> while decrypting the archive member are assumed to happen <em>after</em> the password is accepted: the rational is to avoid silencing unexpected errors -- each exception should be considered individually</li>
<li><code>check(password)</code> expects nonempty passwords</li>
<li><code>chunksize</code> parameter may drastically improve performance</li>
<li>a rare <code>for</code>/<code>else</code> syntax is used, to report cases when the password is not  found</li>
<li>the <code>with</code>-statement calls <code>pool.terminate()</code> for you</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You are terminating your program too early. To test this out, add a harmless <code>time.sleep(10)</code> in the <code>cracker</code> method and observe your program still terminating within a second.</p>
<p>Call <a href="https://docs.python.org/dev/library/multiprocessing.html#multiprocessing.pool.Pool.join" rel="nofollow"><code>join</code></a> to wait for the pool to finish:</p>
<pre><code>pool = mp.Pool()
for i in open(sys.argv[2], 'r', errors='ignore'):
    pswd = bytes(i.strip('\n'), 'utf-8')
    pool.apply_async(cracker, (pswd,))

pool.close()  # Indicate that no more data is coming
pool.join()   # Wait for pool to finish processing

runtime =  round(time.time() - startime, 5)
print ("[*] Runtime:", runtime, 'seconds')
sys.exit(0)
</code></pre>
<p>Additionally, once you find the right password, calling <code>close</code> just indicates that no more future tasks are coming - all tasks already submitted will still be done. Instead, call <a href="https://docs.python.org/dev/library/multiprocessing.html#multiprocessing.pool.Pool.terminate" rel="nofollow"><code>terminate</code></a> to kill the pool without processing any more tasks.</p>
<p>Furthermore, depending on the implementation details of <code>multiprocessing.Pool</code>, the global variable <code>pool</code> may not be available when you need it (and its value isn't serializable anyways). To solve this problem, you can use a callback, as in</p>
<pre><code>def cracker(password):
    try:
        zFile.extractall(pwd=password)
    except RuntimeError:
        return
    return password

 def callback(found):
     if found:
         pool.terminate()
 ...
 pool.apply_async(cracker, (pswd,), callback=cb)
</code></pre>
<p>Of course, since you now look at the result all the time, <code>apply</code> is not the right way to go. Instead, you can write your code using <a href="https://docs.python.org/dev/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered" rel="nofollow"><code>imap_unordered</code></a>:</p>
<pre><code>with open(sys.argv[2], 'r', errors='ignore') as passf, \
         multiprocessing.Pool() as pool:
     passwords = (line.strip('\n').encode('utf-8') for line in passf)
     for found in pool.imap_unordered(cracker, passwords):
         if found:
             break
</code></pre>
<p>Instead of using globals, you may also want to open the zip file (and create a <code>ZipFile</code> object) in each process, by using an <a href="https://docs.python.org/dev/library/multiprocessing.html#multiprocessing.pool.Pool" rel="nofollow"><code>initializer</code></a> for the pool. Even better (and way faster), forgo all of the I/O in the first place and read just the bytes you need once and then pass them on to the children.</p>
</div>
<div class="post-text" itemprop="text">
<p>phihag's answer is the correct solution.</p>
<p>I just wanted to provide an additional detail regarding calling <code>terminate()</code> when you've found the correct password.  The <code>pool</code> variable in <code>cracker()</code> was not defined when I ran the code.  So trying to invoke it from there simply threw an exception:</p>
<pre><code>NameError: name 'pool' is not defined
</code></pre>
<p>(My <code>fork()</code> experience is weak, so I don't completely understand why the global <code>zFile</code> is copied to the child processes successfully while <code>pool</code> is not. Even if it were copied, it would not be the same <code>pool</code> in the parent process, right?  So any methods invoked on it would have no effect on the <em>real</em> pool in the parent process.  Regardless, I prefer <a href="https://docs.python.org/3/library/multiprocessing.html#all-start-methods" rel="nofollow">this</a> advice listed within the <code>multiprocessing</code> module's <em>Programming guidelines</em> section: <strong>Explicitly pass resources to child processes</strong>.)</p>
<p>My suggestion is to make <code>cracker()</code> return the password if it is correct, otherwise return <code>None</code>.  Then pass a callback to <code>apply_async()</code> that records the correct password, as well as terminating the pool.  Here's my take at modifying your code to do this:</p>
<pre><code>#!/usr/bin/env python3

import multiprocessing as mp
import zipfile # Handeling the zipfile
import sys # Command line arguments, and quiting application
import time # To calculate runtime
import os

def usage(program_name):
    print("Usage: {0} &lt;path to zipfile&gt; &lt;dictionary&gt;".format(program_name))
    sys.exit(1)

def cracker(zip_file_path, password):
    print('[*] Starting new cracker (pid={0}, password="{1}")'.format(os.getpid(), password))

    try:
        time.sleep(1) # XXX: to simulate the task taking a bit of time
        with zipfile.ZipFile(zip_file_path) as zFile:
            zFile.extractall(pwd=bytes(password, 'utf-8'))
        return password
    except:
        return None

def main():
    if len(sys.argv) &lt; 3:
        usage(sys.argv[0])

    print('[*] Starting main (pid={0})'.format(os.getpid()))

    zip_file_path = sys.argv[1]
    password_file_path = sys.argv[2]
    startime = time.time()
    actual_password = None

    with mp.Pool() as pool:
        def set_actual_password(password):
            nonlocal actual_password
            if password:
                print('[*] Found password; stopping future tasks')
                pool.terminate()
                actual_password = password

        with open(password_file_path, 'r', errors='ignore') as password_file:
            for pswd in password_file:
                pswd = pswd.strip('\n')
                pool.apply_async(cracker, (zip_file_path, pswd,), callback=set_actual_password)

        pool.close()
        pool.join()

    if actual_password:
        print('[*] Cracked password: "{0}"'.format(actual_password))
    else:
        print('[*] Unable to crack password')
    runtime =  round(time.time() - startime, 5)
    print("[*] Runtime:", runtime, 'seconds')
    sys.exit(0)

if __name__ == "__main__":
    main()
</code></pre>
</div>
<span class="comment-copy">Thank you, your help is appreciated</span>
<span class="comment-copy">Sorry to bother you but the script u wrote works fine with small word lists but with large word lists this error is raised:     RuntimeError: File &lt;zipfile.ZipInfo object at 0x02734510&gt; is encrypted, password required for extraction any thoughts?</span>
<span class="comment-copy">The same error is now raised for any word list.</span>
<span class="comment-copy">@NightHawk: the code works as is. I've tested it with millions passwords. Make sure you haven't deleted <code>pwd=</code> part.</span>
<span class="comment-copy">I created a new file and copy and pasted the code you shared with me. Here is a screenshot highlighting the 'pwd=' bit and the error i get in the terminal. <a href="https://www.dropbox.com/s/i5xvtnbwl5nv0rx/Screen%20Shot%202015-07-11%20at%204.10.34%20AM.png?dl=0" rel="nofollow noreferrer">dropbox.com/s/i5xvtnbwl5nv0rx/…</a> Thanks again and sorry for being annoying &lt;3 Note: the word list I used is just 500 words.</span>
<span class="comment-copy">Thanks phihag, multiprocessing now works fine thanks to you but i ran into another problem. When I run the application a strange error is raised saying that zFile is not defined even thou I made it as a global variable and when I try to pass the zFile object to cracker the function doesn't even run. I would appreciate your help.  Thanks in advance.</span>
<span class="comment-copy">@NightHawk: Please see my answer, specifically the advice to <i>explicitly pass resources to child processes</i>.</span>
<span class="comment-copy">@NightHawk I've amended my answer as well, with more of an explanation. See the other answers for the full code.</span>
<span class="comment-copy">I keep getting random errors when i use bigger word lists. one of them is: zlib.error: Error -3 while decompressing data: invalid distance too far back</span>
<span class="comment-copy">Thank you, your help is appreciated</span>
