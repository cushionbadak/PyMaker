<div class="post-text" itemprop="text">
<p>If I do this:</p>
<pre><code>&gt;&gt;&gt; False in [False, True]
True
</code></pre>
<p>That returns <code>True</code>. Simply because <code>False</code> is in the list.</p>
<p>But if I do:</p>
<pre><code>&gt;&gt;&gt; not(True) in [False, True]
False
</code></pre>
<p>That returns <code>False</code>. Whereas <code>not(True)</code> is equal to <code>False</code>:</p>
<pre><code>&gt;&gt;&gt; not(True)
False
</code></pre>
<p>Why?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Operator precedence</strong> <sup><a href="https://docs.python.org/2/reference/expressions.html#operator-precedence">2.x</a>, <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence">3.x</a></sup>. The precedence of <code>not</code> is lower than that of <code>in</code>. So it is equivalent to:</p>
<pre><code>&gt;&gt;&gt; not (True in [False, True])
False
</code></pre>
<p>This is what you want:</p>
<pre><code>&gt;&gt;&gt; (not True) in [False, True]
True
</code></pre>
<hr/>
<p>As @Ben points out: It's recommended to never write <code>not(True)</code>, prefer <code>not True</code>. The former makes it look like a function call, while <code>not</code> is an operator, not a function.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><code>not x in y</code></strong> is evaluated as <strong><code>x not in y</code></strong></p>
<p>You can see exactly what's happening by disassembling the code.  The first case works as you expect:</p>
<pre><code>&gt;&gt;&gt; x = lambda: False in [False, True]
&gt;&gt;&gt; dis.dis(x)
  1           0 LOAD_GLOBAL              0 (False)
              3 LOAD_GLOBAL              0 (False)
              6 LOAD_GLOBAL              1 (True)
              9 BUILD_LIST               2
             12 COMPARE_OP               6 (in)
             15 RETURN_VALUE
</code></pre>
<p>The second case, evaluates to <code>True not in [False, True]</code>, which is <code>False</code> clearly:</p>
<pre><code>&gt;&gt;&gt; x = lambda: not(True) in [False, True]
&gt;&gt;&gt; dis.dis(x)
  1           0 LOAD_GLOBAL              0 (True)
              3 LOAD_GLOBAL              1 (False)
              6 LOAD_GLOBAL              0 (True)
              9 BUILD_LIST               2
             12 COMPARE_OP               7 (not in)
             15 RETURN_VALUE        
&gt;&gt;&gt; 
</code></pre>
<p>What you wanted to express instead was <code>(not(True)) in [False, True]</code>, which as expected is <code>True</code>, and you can see why:</p>
<pre><code>&gt;&gt;&gt; x = lambda: (not(True)) in [False, True]
&gt;&gt;&gt; dis.dis(x)
  1           0 LOAD_GLOBAL              0 (True)
              3 UNARY_NOT           
              4 LOAD_GLOBAL              1 (False)
              7 LOAD_GLOBAL              0 (True)
             10 BUILD_LIST               2
             13 COMPARE_OP               6 (in)
             16 RETURN_VALUE        
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Operator precedence. <code>in</code> binds more tightly than <code>not</code>, so your expression is equivalent to <code>not((True) in [False, True])</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's all about <a href="https://docs.python.org/2/reference/expressions.html" rel="noreferrer">operator precedence</a> (<code>in</code> is stronger than <code>not</code>). But it can be easily corrected by adding parentheses at the right place:</p>
<pre><code>(not(True)) in [False, True]  # prints true
</code></pre>
<p>writing:</p>
<pre><code>not(True) in [False, True]
</code></pre>
<p>is the same like:</p>
<pre><code>not((True) in [False, True])
</code></pre>
<p>which looks if <code>True</code> is in the list and returns the "not" of the result.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is evaluating as <code>not True in [False, True]</code>, which returns <code>False</code> because <code>True</code> is in <code>[False, True]</code> </p>
<p>If you try </p>
<pre><code>&gt;&gt;&gt;(not(True)) in [False, True]
True
</code></pre>
<p>You get the expected result.</p>
</div>
<div class="post-text" itemprop="text">
<p>Alongside the other answers that mentioned the precedence of <code>not</code> is lower than <code>in</code>, actually your statement is equivalent to :</p>
<pre><code>not (True in [False, True])
</code></pre>
<p>But note that if you don't separate your condition from the other ones, python will use 2 roles (<code>precedence</code> or <code>chaining</code>) in order to separate that, and in this case python used precedence. Also, note that if you want to separate a condition you need to put all the condition in parenthesis not just the object or value :</p>
<pre><code>(not True) in [False, True]
</code></pre>
<hr/>
<p>But as mentioned, there is another modification by python on operators that is <strong>chaining</strong>:</p>
<p>Based on python <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer"><em>documentation</em></a> :</p>
<blockquote>
<p>Note that comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right <strong>chaining</strong> feature as described in the Comparisons section.</p>
</blockquote>
<p>For example the result of following statement is <code>False</code>:</p>
<pre><code>&gt;&gt;&gt; True == False in [False, True]
False
</code></pre>
<p>Because python will chain the statements like following :</p>
<pre><code>(True == False) and (False in [False, True])
</code></pre>
<p>Which exactly is <code>False and True</code> that is <code>False</code>. </p>
<p>You can assume that the central object will be shared between 2 operations and other objects (False in this case).</p>
<p>And note that its also true for all Comparisons, including membership tests and identity tests operations which are following operands :</p>
<pre><code>in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==
</code></pre>
<p>Example :</p>
<pre><code>&gt;&gt;&gt; 1 in [1,2] == True
False
</code></pre>
<p>Another famous example is number range :</p>
<pre><code>7&lt;x&lt;20
</code></pre>
<p>which is equal to :</p>
<pre><code>7&lt;x and x&lt;20   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's see it as a collection containment checking operation: <code>[False, True]</code> is a list containing some elements.</p>
<p>The expression <code>True in [False, True]</code> returns <code>True</code>, as <code>True</code> is an element contained in the list.</p>
<p>Therefore, <code>not True in [False, True]</code> gives the "boolean opposite", <code>not</code> result of the above expression (without any parentheses to preserve precedence, as <code>in</code> has greater precedence than <code>not</code> operator).
Therefore, <code>not True</code> will result <code>False</code>.</p>
<p>On the other hand, <code>(not True) in [False, True]</code>, is equal to <code>False in [False, True]</code>, which is <code>True</code> (<code>False</code> is contained in the list).</p>
</div>
<div class="post-text" itemprop="text">
<p>To clarify on some of the other answers, adding parentheses <em>after</em> a unary operator does not change its precedence. <code>not(True)</code> does not make <code>not</code> bind more tightly to <code>True</code>. It's just a redundant set of parentheses around <code>True</code>. It's much the same as <code>(True) in [True, False]</code>. The parentheses don't do anything.  If you want the binding to be more tight, you have to put the parentheses around the whole expression, meaning both the operator and the operand, i.e., <code>(not True) in [True, False]</code>.</p>
<p>To see this another way, consider </p>
<pre><code>&gt;&gt;&gt; -2**2
-4
</code></pre>
<p><code>**</code> binds more tightly than <code>-</code>, which is why you get the negative of two squared, not the square of negative two (which would be positive four). </p>
<p>What if you did want the square of negative two? Obviously, you'd add parentheses:</p>
<pre><code>&gt;&gt;&gt; (-2)**2
4
</code></pre>
<p>However, it's not reasonable to expect the following to give <code>4</code></p>
<pre><code>&gt;&gt;&gt; -(2)**2
-4
</code></pre>
<p>because <code>-(2)</code> is the same as <code>-2</code>. The parentheses do absolutely nothing. <code>not(True)</code> is exactly the same. </p>
</div>
<span class="comment-copy">related <a href="http://stackoverflow.com/questions/31354429/why-is-true-is-false-false-false-in-python/31354514#31354514" title="why is true is false false false in python">stackoverflow.com/questions/31354429/â€¦</a></span>
<span class="comment-copy">your parentheses are confusing in <code>not(True) in [False, True]</code></span>
<span class="comment-copy">@Texom512: I would also recommend never writing <code>not(True)</code>; prefer <code>not True</code>. The first makes it look like a function call, which is where your confusion came from; if <code>not</code> was a function, then <code>not(True) in ...</code> couldn't possibly be <code>not ((True) in ...)</code>. You have to know it's an operator (or you end up in situations like this), so you should write it like an operator, not disguise it as a function.</span>
<span class="comment-copy">Also, if you're going to use spacing to indicate precedence for the benefit of the reader, first make sure you're right. It's probably OK to write <code>a + b*c + d</code>, it's very bad to write <code>a+b * c+d</code>. So <code>not(True)</code> is bad by that measure too.</span>
<span class="comment-copy">Actually, <b>never</b> write <code>not True</code>. Write <code>False</code> instead.</span>
<span class="comment-copy">Presumably in real life you wouldn't be writing <code>not True</code>, you'd be writing something like <code>not myfunc(x,y,z)</code> where <code>myfunc</code> is some function that returns <code>True</code> or <code>False</code>.</span>
<span class="comment-copy">@BenC.R.Leggiero That's what I did in <a href="http://stackoverflow.com/revisions/31421411/1">the original answer</a>, and others have corrected it. The current version is clear enough for me, I don't think it's hard to understand without the redundant parentheses, since the key problem has been pointed out, understanding the rest is a programmer's basic skill.</span>
<span class="comment-copy">There is always a guy with <code>dis</code> but this is a very valuable answer because it shows that actually <code>not in</code> is used</span>
<span class="comment-copy">Bytecode is an implementation detail of the CPython interpreter.  This is a CPython answer to a Python question, in fact it can be better answered from the language reference directly.</span>
<span class="comment-copy">@wim I would argue that the bytecode implementation is not as important as the actual disassembly. Other implementations are guaranteed to generate something functionally identical, so understanding one disassembly offers enough insight to understand the "why" and not the lowlevel "how".</span>
