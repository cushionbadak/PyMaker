<div class="post-text" itemprop="text">
<p>I have a bunch of coroutines that doing some work </p>
<pre><code>@asyncio.coroutine
def do_work():
    global COUNTER
    result = ...
    if result.status == 'OK':
        COUNTER += 1
</code></pre>
<p>and another one </p>
<pre><code>COUNTER = 0
@asyncio.coroutine
def display_status():
    while True:
        print(COUNTER)
        yield from asyncio.sleep(1)
</code></pre>
<p>which have to display how many coroutines have finished their work. How to properly implement this task? Following solution doesn't work</p>
<pre><code>@asyncio.coroutine
def spawn_jobs():
    coros = []
    for i in range(10):
        coros.append(asyncio.Task(do_work()))
    yield from asyncio.gather(*coros)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.create_task(display_status())
    loop.run_until_complete(spawn_jobs())
    loop.close()
</code></pre>
<p>I expect that counter will be printed to the console every second no matter what do_work() coroutines do. But I have just two outputs: 0 and after a few seconds repeating 10.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But I have just two outputs: 0 and after a few seconds repeating 10.</p>
</blockquote>
<p>I can't reproduce it. If I use:</p>
<pre><code>import asyncio
import random

@asyncio.coroutine
def do_work():
    global COUNTER
    yield from asyncio.sleep(random.randint(1, 5))
    COUNTER += 1
</code></pre>
<p>I get the output like this:</p>
<pre><code>0
0
4
6
8
Task was destroyed but it is pending!
task: &lt;Task pending coro=&lt;display_status() running at most_wanted.py:16&gt; wait_for=&lt;Future pending cb=[Task._wakeup()] created at ../Lib/asyncio/tasks.py:490&gt; created at most_wanted.py:27&gt;
</code></pre>
<p>The infinite loop in <code>display_status()</code> causes the warning at the end. To avoid the warning; exit the loop when all tasks in the batch are done:</p>
<pre><code>#!/usr/bin/env python3
import asyncio
import random
from contextlib import closing
from itertools import cycle

class Batch:
    def __init__(self, n):
        self.total = n
        self.done = 0

    async def run(self):
        await asyncio.wait([batch.do_work() for _ in range(batch.total)])

    def running(self):
        return self.done &lt; self.total

    async def do_work(self):
        await asyncio.sleep(random.randint(1, 5)) # do some work here
        self.done += 1

    async def display_status(self):
        while self.running():
            await asyncio.sleep(1)
            print('\rdone:', self.done)

    async def display_spinner(self, char=cycle('/|\-')):
        while self.running():
            print('\r' + next(char), flush=True, end='')
            await asyncio.sleep(.3)

with closing(asyncio.get_event_loop()) as loop:
    batch = Batch(10)
    loop.run_until_complete(asyncio.wait([
        batch.run(), batch.display_status(), batch.display_spinner()]))
</code></pre>
<h3>Output</h3>
<pre><code>done: 0
done: 2
done: 3
done: 4
done: 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Solution using <code>threading</code> module</p>
<pre><code>SHOW_STATUS = True
def display_status_sync():
    while SHOW_STATUS:
        print(S_REQ)
        time.sleep(1)

if __name__ == '__main__':
    new_thread = threading.Thread(target=display_status_sync)
    new_thread.start()
    loop.run_until_complete(spawn_jobs())
    SHOW_STATS = False
    new_thread.join()
    loop.close()
</code></pre>
<p>But I want to achieve similar functionality using asyncio coroutines. Is it possible to do that?</p>
</div>
<span class="comment-copy">One of possible options is to add print(COUNTER) into <code>do_work()</code> function, but I want printing <code>COUNTER</code> every second and not after finishing piece of work</span>
<span class="comment-copy">"doesn't work" is not very specific. What do you expect to happen? What happens instead?</span>
<span class="comment-copy">don't put additional info in the comments, <a href="https://stackoverflow.com/posts/31342858/edit">edit</a> your question instead.</span>
<span class="comment-copy">unrelated: use <code>asyncio.create_task()</code> instead of <code>asyncio.Task()</code>. Moreover, you could don't need neither  in this case: <code>yield from asyncio.wait([do_work() for _ in range(10)])</code> works as is.</span>
<span class="comment-copy">The problem was in using synchronous code inside <code>do_work()</code>. I use synchronous calls <code>r = requests.get('http://httpbin.org/get')</code> so them block my displaying status coroutine. Seems like I need to switch to the aiohttp for making requests.</span>
<span class="comment-copy">When I insert <code>r = yield from aiohttp.request('POST', 'http://httpbin.org/post', data=data)</code> instead of <b>sleep()</b> I can just do less than 512 batch jobs. Otherwise I have an error: <code>RuntimeError: Event loop is closed</code>. Is that <i>aiohttp</i> restriction or something else?</span>
<span class="comment-copy">@MostWanted: you should ask a separate question. <a href="http://stackoverflow.com/help/mcve">Provide a <i>minimal</i> but complete code example</a>, enable <a href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-debug-mode" rel="nofollow noreferrer"><code>asyncio</code> debug mode</a>, include the full traceback. My guess, you need something like <code>result = yield from r.json()</code> to read the response.</span>
<span class="comment-copy">Also I can use <code>loop.run_in_executor(None, display_status_sync)</code> instead of creating threads. That will produce the same effect.</span>
