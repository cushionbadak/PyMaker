<div class="post-text" itemprop="text">
<p>Desktop.zip contains multiple text files. fun.py is a python program which will print the name of text files from zip and also the number of lines in each file. Everything is okay up to here. But, It will also import this output in a single CSV file. Code :- </p>
<pre><code>import zipfile, csv

file = zipfile.ZipFile("Desktop.zip", "r")
inputcsv = input("Enter the name of the CSV file: ")
csvfile = open(inputcsv,'a')

#list file names
for name in file.namelist():
    print (name)

# do stuff with the file object
for name in file.namelist():
    with open(name) as fh:
        count = 0
        for line in fh:
            count += 1
        print ("File " + name + "line(s) count = " + str(count))

        b = open(inputcsv, 'w')
        a = csv.writer(b)

        data = [name, str(count)]
        a.writerows(data)


file.close()
</code></pre>
<p>I am expecting output in CSV file like :- </p>
<pre><code>test1.txt, 25
test2.txt, 10
</code></pre>
<p>But I am getting this output in CSV file :- </p>
<pre><code>t,e,s,t,1,.,t,x,t
2,5
t,e,s,t,2,.,t,x,t
1,0
</code></pre>
<p>Here, test1.txt and test2.txt are the files in Desktop.zip, and 25 and 10 is the number of lines of those files respectively.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code in your question has multiple issues, as others have pointed out. The two primary ones are that you're recreating the csv file over and over again for each archive member being processed, and then secondly, are passing <code>csvwriter.writerows()</code> the wrong data. It interprets each item in the list you're passing as a separate row to be added to the csv file. </p>
<p>One way to fix that would be to only open the csv file once, before entering a <code>for</code> loop which counts the line in each member of the archive and writes one row to it at time with a call to <code>csvwriter.writerow()</code>.</p>
<p>A slightly different way, shown below, does use <code>writerows()</code> but passes it <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow">generator expression</a> that processes the each member one-the-fly instead of calling <code>writerow()</code> repeatedly. It also processes each member incrementally, so it doesn't need to read the whole thing into memory at one time and then split it up in order to get a line count.</p>
<p>Although you didn't indicate what version of Python you're using, from the code in your question, I'm guessing it's Python 3.x, so the answer below has been written and tested with that (although it wouldn't be hard to make it work in Python 2.7).</p>
<pre><code>import csv
import zipfile

input_zip_filename = 'Desktop.zip'
output_csv_filename = input("Enter the name of the CSV file to create: ")

# Helper function.    
def line_count(archive, filename):
    ''' Count the lines in specified ZipFile member. '''
    with archive.open(filename) as member:
        return sum(1 for line in member)

with zipfile.ZipFile(input_zip_filename, 'r') as archive:

    # List files in archive.
    print('Members of {!r}:'.format(input_zip_filename))
    for filename in archive.namelist():
        print('  {}'.format(filename))

    # Create csv with filenames and line counts.
    with open(output_csv_filename, 'w', newline='') as output_csv:
        csv.writer(output_csv).writerows(
            # generator expression
            [filename, line_count(archive, filename)]  # contents of one row
                for filename in archive.namelist())
</code></pre>
<p>Sample format of content in csv file created:</p>
<pre class="lang-none prettyprint-override"><code>test1.txt,25
test2.txt,10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>writerows</code> takes an iterable of row-representing iterables. You’re passing it a single row, so it interprets each character of each column as a cell. You don’t want that. Use <code>writerow</code> rather than <code>writerows</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I saw a number of issues:</p>
<ul>
<li>You should open the csv file only once, before the for loop. Open it inside the for loop will override the information from previous loop iteration</li>
<li><strong>icktoofay</strong> pointed out that you should use <code>writerow</code>, not <code>writerows</code></li>
<li><code>file</code> is a reserve word, you should not use it to name your variable. Besides, it is not that descriptive</li>
<li>You seem to get the file names from the archive, but open the file from the directory (not the ones inside the archive). These two sets of files might not be identical.</li>
</ul>
<p>Here is my approach:</p>
<pre><code>import csv
import zipfile

with open('out.csv', 'wb') as file_handle:
    csv_writer = csv.writer(file_handle)

    archive = zipfile.ZipFile('Desktop.zip')
    for filename in archive.namelist():
        lines = archive.open(filename).read().splitlines()
        line_count = len(lines)
        csv_writer.writerow([filename, line_count])
</code></pre>
<p>My approach has a couple of issues, which might or might not matter:</p>
<ul>
<li>I assume files in the archive to be text file</li>
<li>I open, read, and split lines in one operation. This might not work well for very large files</li>
</ul>
</div>
<span class="comment-copy">The code in your question could not possibly have generated the csv file you say it did.</span>
