<div class="post-text" itemprop="text">
<p>I'd like to symmetrically permute a sparse matrix, permuting rows and columns in the same way. For example, I would like to rotate the rows and columns, which takes:</p>
<pre><code> 1     2     3
 0     1     0
 0     0     1
</code></pre>
<p>to </p>
<pre><code> 1     0     0
 0     1     0
 2     3     1
</code></pre>
<p>In Octave or MATLAB, one can do this concisely with matrix indexing:</p>
<pre><code>A = sparse([1 2 3; 0 1 0; 0 0 1]);
perm = [2 3 1];
Aperm = A(perm,perm);
</code></pre>
<p>I am interested in doing this in Python, with NumPy/SciPy. Here is an attempt:</p>
<pre><code>#!/usr/bin/env python
import numpy as np
from scipy.sparse import csr_matrix

row = np.array([0, 0, 0, 1, 2])
col = np.array([0, 1, 2, 1, 2])
data = np.array([1, 2, 3, 1, 1])
A = csr_matrix((data, (row, col)), shape=(3, 3))

p = np.array([1, 2, 0])

#Aperm = A[p,p]            # gives [1,1,1], the permuted diagonal
Aperm = A[:,p][p,:]        # works, but more verbose
</code></pre>
<p>Is there a cleaner way to accomplish this sort of symmetric permutation of a matrix? </p>
<p>(I'm more interested in concise syntax than I am in performance)</p>
</div>
<div class="post-text" itemprop="text">
<p>In MATLAB</p>
<pre><code>A(perm,perm)
</code></pre>
<p>is a block operation.  In <code>numpy</code> <code>A[perm,perm]</code> selects elements on the diagonal.</p>
<pre><code>A[perm[:,None], perm]
</code></pre>
<p>is the block indexing.  The MATLAB diagonal requires something like <code>sub2ind</code>. What's concise in one is more verbose in the other, and v.v.</p>
<p>Actually <code>numpy</code> is using the same logic in both cases.  It 'broadcasts' one index against the other,  A <code>(n,)</code> against <code>(n,)</code> in the diagonal case, and <code>(n,1)</code> against <code>(1,n)</code> in the block case.  The results are <code>(n,)</code> and <code>(n,n)</code> shaped.</p>
<p>This <code>numpy</code> indexing works with sparse matrices as well, though it isn't as fast.    It actually uses matrix multiplication to do this sort of indexing - with an 'extractor' matrix based on the indices (maybe 2, <code>M*A*M.T</code>).</p>
<hr/>
<p>MATLAB's documentation about a permutation matrix:</p>
<p><a href="https://www.mathworks.com/help/matlab/math/sparse-matrix-operations.html#f6-13070" rel="nofollow noreferrer">https://www.mathworks.com/help/matlab/math/sparse-matrix-operations.html#f6-13070</a></p>
</div>
