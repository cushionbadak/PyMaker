<div class="post-text" itemprop="text">
<p>I'd like to (PGP/GPG) sign python code. Yes, I have read <a href="https://stackoverflow.com/questions/261638/how-do-i-protect-python-code">this</a> and many other sites that talk about <em>protecting</em> and <em>obfuscating</em> python code - this all is <strong>not</strong> what I want. I DON'T want to obfuscate code.
I want customers and users to see the code, they could modify code, copy it and make derivative work, I'd like to have the software under the GPLv3.
But I want to have plugins that are "signed", so they can be kind of <strong>trusted</strong> during execution.</p>
<p>Is this possible in Python? Can I import a library after checking its gpg signing?
What would be easy: check the gpg signing of a file, and then load it via import, else raise an exception. But this only would be possible for single-file-imports, not directory python modules.</p>
<p>It is clear that, if the customer changes the GPG key in the program, or deletes some lines himself in the checking algorithm, all is gone - but this is not the problem.
He could do anything he wants - but this would be silly.
What he wants is trustworthiness.
I want to let him add a third party plugin by copying it into a "plugins" directory, and have the program check the plugin for "trustworthiness" - and then import it.
(So he <em>could</em> run plugins that are <em>not</em> signed, but with his own risk.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <a href="http://docs.python.org/3/reference/import.html" rel="noreferrer"><code>import</code> mechanism</a> already provide all the tools necessary to achieve what you want. You can install different kinds of <a href="http://docs.python.org/3/reference/import.html#import-hooks" rel="noreferrer"><code>import</code> hooks</a> in order to support what you want.</p>
<p>In particular you'll probably find convenient to install a <a href="http://docs.python.org/3/reference/import.html#the-meta-path" rel="noreferrer">meta path hook</a> that searches for "signed modules" and returns a <a href="http://docs.python.org/3/reference/import.html#loaders" rel="noreferrer"><code>Loader</code></a> that is able to perform the imports from this signed format.</p>
<p>A very simple and convenient format for your signed plug-ins would be a <code>zip</code> archive containing:</p>
<ol>
<li>The code of the plug-in in the form of modules/packages</li>
<li>A PGP signature of the above code</li>
</ol>
<p>In this way:</p>
<ul>
<li>Your loader should unpack the zip, and check the signature. If it matches then you can safely load the plug-in, if it doesn't match you should ask the user to trust the plug-in (or not and abort)</li>
<li>If the user wants to modify the plug-in it can simply unpack the <code>zip</code> archive and modify it as he wishes.</li>
<li>Imports from <code>zip</code> archives are already implemented in the <a href="http://docs.python.org/2/library/zipimport.html" rel="noreferrer"><code>zipimport</code></a> module. This means that you don't have to rewrite a loader from scratch.</li>
</ul>
<p>Actually if you want to reduce the code for the hooks to the minimum you'd simply need to verify the signature and then add the path to the <code>zip</code> archive into <code>sys.path</code>, since python already handles imports from <code>zip</code> archive even without explicitly using <code>zipimport</code>.</p>
<p>Using this design you just have to install these hooks and then you can <code>import</code> the plug-in as if they were normal modules and the verification etc. will be done automatically.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is an old post, but we've developed a new solution. We were confronted with the same challenge -- to distribute python source code, but to prevent hackers from tampering with the code.  The solution we developed was to create a custom loader for our application using signet <a href="http://jamercee.github.io/signet/" rel="nofollow">http://jamercee.github.io/signet/</a>.  </p>
<p>What signet does is scans your script and it's dependencies creating sha1 hashes. It embeds these hashes into a custom loader which you deliver to your customer with your script. Your customers run the loader which re-verifies the hashes before it transfers control to your script for normal execution. If there's been tampering it emits an error message, and refuses to run the tampered code.</p>
<p>Signet is multiplatform and runs on windows, unix, linux, freebsd, etc... If you deploy to windows, the loader building process can even apply your company code certificate for 100% verification of your code. It also does PE verification.</p>
<p>The code is fully open source including the c++ source code to the default loader template. You can extend the loader to do additional verifications and even take actions if it detects code tampering (like undoing the tampering...).</p>
</div>
<span class="comment-copy">I believe you should carefully check <a href="http://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">the <code>import</code> system</a> of python since it allows you to write custom <a href="http://www.python.org/dev/peps/pep-0302/" rel="nofollow noreferrer">import hooks</a>. What I'd do: provide the plug-ins as <code>zip</code> files containing the modules/packages <i>and</i> the signature. Then the import would first check the signature, and if it is correct it could decompress the archive into a temporary directory and import the modules from there (<a href="http://docs.python.org/2/library/zipimport.html" rel="nofollow noreferrer">or directly from the <code>zip</code></a>). Users can unzip the archive and modify it.</span>
<span class="comment-copy">@Bakuriu great comment and that should be an answer.</span>
<span class="comment-copy">That's what I thought earlier, too, using a zip file. This would be one of my features: download a signed zip/other "plugin package" file from a dedicated server, check gpg, unpack it. Ok, so the "installation" into the dedicated "plugins" dir should be done by the software too, then the problem would be solved if I understood correctly. Being admin on the system circumvents this by changing the code as root anyway. And I did not know about import hooks, thanks very much.</span>
<span class="comment-copy">oh, and @Bakuriu, could you post that as "answer" as well, so I can mark it as right answer? If you want you can just more or less copy'n'paste the text from your comment above.</span>
<span class="comment-copy">Thanks @Bakuriu, this was <i>exactly</i> what I needed.</span>
<span class="comment-copy">Hm. SHA1 is a cryptographic checksum, no signing. Anyone could build the same checksum and place it into the software, right? You have to ship the checksum WITH your "plugin" - but what does an attacker prevent to modify the plugin code, and rebuild the checksum? A Checksum only prevents accidental code change (by download error e.g.) - but not tampering. What would be needed there is an asymetric key like GPG. The software knows about the public key, and the plugin is signed using the private one. This can't be changed by an attacker. Linux packages (rpm/deb) are signed this way.</span>
<span class="comment-copy">Code signing prevents tampering of the loader (on windows), which is included with Signet (<a href="http://jamercee.github.io/signet/signet.command.sign_code.html" rel="nofollow noreferrer">jamercee.github.io/signet/signet.command.sign_code.html</a>). The loader invokes WinVerifyTrust function to confirm the loader binary signature matches the signers signature before invoking the script. There are no universal solutions to this on Linux yet (but we're still looking).</span>
<span class="comment-copy">Might be worth a check to this link as well <a href="http://jamercee.github.io/signet/index.html#code-signing" rel="nofollow noreferrer">jamercee.github.io/signet/index.html#code-signing</a></span>
<span class="comment-copy">Hm. An "universal" solution would be public key signing. I need this to run in Linux...</span>
<span class="comment-copy">To the best of my knowledge, there no 'cert store' on linux. Without it there's no way to authenticate the chain of trust. A hacker could strip your cert, insert their own self-signed cert (even fake your org name), and it would fool everyone. The closest we've found is signelf (<a href="http://sourceforge.net/projects/signelf/" rel="nofollow noreferrer">sourceforge.net/projects/signelf</a>), but without a means to authenticate the chain, it's not any better than just relying on code hashes. Of course, if you know a way around this -- I'd love to know about it so we could fold this into signet ASAP !</span>
