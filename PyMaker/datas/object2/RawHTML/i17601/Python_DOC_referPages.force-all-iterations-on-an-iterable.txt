<div class="post-text" itemprop="text">
<p>I've written a for-loop using map, with a function that has a side-effect. Here's a minimal working example of what I mean:</p>
<pre><code>def someFunc(t):
    n, d = t
    d[n] = str(n)

def main():
    d = {}
    map(somefunc, ((i,d) for i in range(10**3)))
    print(len(d))
</code></pre>
<p>So it's clear that <code>someFunc</code>, which is mapped onto the non-negative numbers under 1000, has the side-effect of populating a dictionary, which is later used for something else.</p>
<p>Now, given the way that the above code has been structured, the expected output of <code>print(len(d))</code> is <code>0</code>, since <code>map</code> returns an iterator, and not a list (unlike python2.x). So if I really want to see the changes applied to <code>d</code>, then I would have to iterate over that map object until completion. One way I could do so is:</p>
<pre><code>d = {}
for i in map(somefunc, ((i,d) for i in range(10**3))):
    pass
</code></pre>
<p>But that doesn't seem very elegant. I could call <code>list</code> on the map object, but that would require O(n) memory, which is inefficient. Is there a way to force a full iteration over the map object?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't want to do this (run a <code>map()</code> just for the side effects), but there is a <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> <code>consume</code> recipe</a> that applies here:</p>
<pre><code>from collections import deque

deque(map(somefunc, ((i,d) for i in range(10**3))), maxlen=0)
</code></pre>
<p>The <a href="http://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow"><code>collections.deque()</code> object</a>, configured to a maximum size of 0, consumes the <code>map()</code> iterable with no additional memory use. The <code>deque</code> object is <a href="http://hg.python.org/cpython/file/9fe32328a573/Modules/_collectionsmodule.c#l279" rel="nofollow">specifically optimized</a> for this use-case.</p>
</div>
<span class="comment-copy">That's just brilliant!</span>
<span class="comment-copy">What makes you think no additional memory is used?  I believe deque is implemented as a doubly linked list behind the scenes.  It probably doesn't exist long in most python runtimes, but it should increase memory for a while.</span>
<span class="comment-copy">@dstromberg: I think he meant that it's constant space, as opposed to the bigger, linear space problem that I mentioned</span>
<span class="comment-copy">@dstromberg Because the <code>maxlen</code> is zero, no entries are added to the deque. The only thing that's allocated is the wrapper which would contain the root of the doubly linked list. In CPython, this is <a href="http://hg.python.org/cpython/file/967f368b7f75/Modules/_collectionsmodule.c#l306" rel="nofollow noreferrer">special cased</a> to be even faster, but a general-purpose implementation wouldn't allocate any intermediate nodes either.</span>
<span class="comment-copy">@dstromberg: because the queue is configured with length zero it consumes all items without storing anything.</span>
