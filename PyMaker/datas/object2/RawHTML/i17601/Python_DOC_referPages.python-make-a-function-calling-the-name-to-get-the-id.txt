<div class="post-text" itemprop="text">
<p>Sorry new to python, was trying to make a func when I say getID('foo'), it'll return me the id #. </p>
<pre><code>info = {1:   {'desc': 'one',    'length': 1, 'id': 1,    'weight': '4',  'name': 'foo'}, 
       506:  {'desc': 'two',    'length': 2, 'id': 506,  'weight': '32', 'name': 'bar'}, 
       1156: {'desc': 'Three.', 'length': 3, 'id': 1156, 'weight': '64', 'name': 'too'}}
</code></pre>
<p>This is what I have but it doesn't get me what I wanted. Any help would be great thanks</p>
<pre><code>def GetID(name):

    for v in info.values():
        for k in v.keys():
            if k == name:
                return(v[id])
            else:
                return "wrong name"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the right data structure would make this a lot easier—and, assuming you're calling <code>GetID</code> more than a handful of times, also a lot faster. (In general, when you find it too complicated to extract the information you want from your data, the answer is usually to change the data structure.)</p>
<p>If you had a dictionary that mapped each <code>name</code> to the <code>id</code>, you could just do this:</p>
<pre><code>def GetID(name):
    return name_to_id.get(name, "wrong name")
</code></pre>
<p>If you've never seen the <code>d.get(key, default)</code> before, it's equivalent to <code>d[key]</code>, except that if the key isn't present, you get <code>default</code> instead of raising a <code>KeyError</code>.</p>
<hr/>
<p>So, how do you build that dictionary? Well, you already know how to iterate over your existing dictionary explicitly, so let's do it that way:</p>
<pre><code>name_to_id = {}
for v in info.values():
    name_to_id[v['name']] = v['id']
</code></pre>
<p>If you want to make it more concise:</p>
<pre><code>name_to_id = {v['name']: v['id'] for v in info.values()}
</code></pre>
<p>Either way, you're just looping over the dictionary one time, to set up the <code>name_to_id</code> mapping, instead of every time you need to look up a name. And it's a simpler loop. </p>
<p>And it means that each name lookup is now incredibly simple and incredibly fast.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><code>ie_info</code> does not match global variable <code>info</code>.</li>
<li>Quote <code>id</code>: <code>v['id']</code>
<ul>
<li>without quote, <code>id</code> references <a href="http://docs.python.org/3/library/functions.html#id" rel="nofollow"><code>id</code> function</a>.</li>
</ul></li>
<li>You don't need to iterate all dictionary entries to check <code>name</code> key, value.
<ul>
<li>Just use <code>dict['name']</code>, <code>dict['id']</code></li>
</ul></li>
</ol>
<hr/>
<pre><code>&gt;&gt;&gt; info = {1:   {'desc': 'one',    'length': 1, 'id': 1,    'weight': '4',  'name': 'foo'},
...        506:  {'desc': 'two',    'length': 2, 'id': 506,  'weight': '32', 'name': 'bar'},
...        1156: {'desc': 'Three.', 'length': 3, 'id': 1156, 'weight': '64', 'name': 'too'}}
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; def GetID(name):
...     for v in info.values():
...         if v['name'] == name:
...             return(v['id'])
...     return 'wrong name'
...
&gt;&gt;&gt; GetID('foo')
1
&gt;&gt;&gt; GetID('who')
'wrong name'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def GetID(name):
    return [x['id'] for x in info.values() if x['name'] == name]
</code></pre>
<p>that's how you're not looping on all keys but take only the one you want</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd call <code>next</code> on a generator that yields what you want; you can specify a "default" value if the generator is exhausted without yielding a result:</p>
<pre><code>next((i for i,d in info.items() if d['name'] == 'foo'), 'wrong name')
Out[22]: 1

next((i for i,d in info.items() if d['name'] == 'baz'), 'wrong name')
Out[23]: 'wrong name'
</code></pre>
<p>(using python 3 syntax here, use <code>iteritems</code> instead of <code>items</code> in python 2)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def GetID(name):

    for v in info.values(): # your variable is called info not ie_info
        for k in v.keys():
            if k == 'name':
                return(v['id']) # you were missing the quotes around id
            else:
                return "wrong name"
</code></pre>
</div>
<span class="comment-copy">at least one sane answer...</span>
<span class="comment-copy">This nicely explains everything that makes the OP's code fail, except that <code>name</code> has the same problem as <code>id</code>, and you apparently fixed it without noticing or mentioning it. :)</span>
<span class="comment-copy">Technicalkly, Python's doing the looping for you. It will also return a list not an object</span>
<span class="comment-copy">right, I was referring the second (inner loop) that has to be avoided</span>
<span class="comment-copy">I this would be a lot clearer to a novice as two lines that one—create the genexpr, then <code>next</code> it. Also, you're returning the key that the subdict is stored under, but the OP wants the <code>id</code> value of the subject. They happen to be the same in his example, but who knows if we can rely on that?</span>
<span class="comment-copy">Yeah being a bit lazy here.  I didn't really look at his data structure, it really needs some work.</span>
<span class="comment-copy">You also need to quote <code>'name'</code>.</span>
