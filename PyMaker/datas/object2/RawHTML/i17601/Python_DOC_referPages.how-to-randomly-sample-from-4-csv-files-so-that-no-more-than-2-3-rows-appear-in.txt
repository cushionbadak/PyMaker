<div class="post-text" itemprop="text">
<p>Hi I'm very new to python and trying to create a program that takes a random sample from a CSV file and makes a new file with some conditions. What I have done so far is probably highly over-complicated and not efficient (though it doesn't need to be).   </p>
<p>I have 4 CSV files that contain 264 rows in total, where each full row is unique, though they all share common values in some columns. 
csv1 = 72 rows, csv2 = 72 rows, csv3 = 60 rows, csv4 = 60 rows. I need to take a random sample of 160 rows which will make 4 blocks of 40, where in each block 10 must come from each csv file. The tricky part is that no more than 2 or 3 rows from the same CSV file can appear in order in the final file. </p>
<p>So far I have managed to take a random sample of 40 from each CSV (just using <code>random.sample</code>) and output them to 4 new CSV files. Then I split each csv into 4 new files each containing 10 rows so that I have each in a separate folder(1-4). So I now have 4 folders each containing 4 csv files. Now I need to combine these so that rows that came from the original CSV file don't repeat more than 2 or 3 times and the row order will be as random as possible. This is where I'm completely lost, I'm presuming that I should combine the 4 files in each folder (which I can do) and then re-sample or shuffle in a loop until the conditions are met, or something to that effect but I'm not sure how to proceed or am I going about this in the completely wrong way. Any help anyone can give me would be greatly appreciated and I can provide any further details that are necessary. </p>
<pre><code>var_start = 1
total_condition_amount_start = 1
    while (var_start &lt; 5):
    with open("condition"+`var_start`+".csv", "rb") as population1:
            conditions1 = [line for line in population1]
            random_selection1 = random.sample(conditions1, 40)
            with open("./temp/40cond"+`var_start`+".csv", "wb") as temp_output:
                temp_output.write("".join(random_selection1))
            var_start = var_start + 1



while (total_condition_amount_start &lt; total_condition_amount):

    folder_no = 1
    splitter.split(open("./temp/40cond"+`total_condition_amount_start`+".csv", 'rb'));

    shutil.move("./temp/output_1.csv", "./temp/block"+`folder_no`+"/output_"+`total_condition_amount_start`+".csv")
    folder_no = folder_no + 1
    shutil.move("./temp/output_2.csv", "./temp/block"+`folder_no`+"/output_"+`total_condition_amount_start`+".csv")
    folder_no = folder_no + 1
    shutil.move("./temp/output_3.csv", "./temp/block"+`folder_no`+"/output_"+`total_condition_amount_start`+".csv")
    folder_no = folder_no + 1
    shutil.move("./temp/output_4.csv", "./temp/block"+`folder_no`+"/output_"+`total_condition_amount_start`+".csv")

    total_condition_amount_start = total_condition_amount_start + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should probably try using the CSV built in lib: <a href="http://docs.python.org/3.3/library/csv.html" rel="nofollow">http://docs.python.org/3.3/library/csv.html</a></p>
<p>That way you can handle each file as a list of dictionaries, which will make your task a lot easier. </p>
<pre><code>from random import randint, sample, choice


def create_random_list(length):
    return [randint(0, 100) for i in range(length)]

# This should be your list of four initial csv files
# with the 264 rows in total, read with the csv lib
lists = [create_random_list(264) for i in range(4)]

# Take a randomized sample from the lists
lists = map(lambda x: sample(x, 40), lists)

# Add some variables to the
lists = map(lambda x: {'data': x, 'full_count': 0}, lists)


final = [[] for i in range(4)]
for l in final:
    prev = None
    count = 0
    while len(l) &lt; 40:
        current = choice(lists)

        if current['full_count'] == 10 or (current is prev and count == 3):
            continue
        # Take an item from the chosen list if it hasn't been used 3 times in a
        # row or is already used 10 times. Append that item to the final list

        total_left = 40 - len(l)
        maxx = 0
        for i in lists:
            if i is not current and 10 - i['full_count'] &gt; maxx:
                maxx = 10 - i['full_count']

        current_left = 10 - current['full_count']
        max_left = maxx + maxx/3.0

        if maxx &gt; 3 and total_left &lt;= max_left:
            # Make sure that in te future it can still be split in to sets of
            # max 3
            continue

        l.append(current['data'].pop())
        count += 1
        current['full_count'] += 1

        if current is not prev:
            count = 0
            prev = current

    for li in lists:
        li['full_count'] = 0
</code></pre>
</div>
<span class="comment-copy">Can you hold the entire data in memory? Because you don't really need to work with files, it'll be easier and faster if you just read all the data from each of the 4 files and mix that up, then write to output files.</span>
<span class="comment-copy">I attempted that initially, but as i said i'm very new to this and this was just easier in my head to visualise as i could see and check my output files to make sure things were working as they should.</span>
<span class="comment-copy">OK I get it. What IDE are you using? There are some that would let you do this with things kept in the memory, e.g. Spyder (which is what I like to use).   I'm not sure if I get your problem but would it be possible to just put all the rows together like so: <code>rowF1, rowF2, rowF3, rowF4, rowF1, rowF2...</code> (alternating lines from all files) and then just select some of those? That way you'll never have 2 or more rows from the same file one after another.</span>
<span class="comment-copy">I'm using Komodo, for no particular reason though. The problem with that is that this csv file is the input for a psychology experiment, so if more than 3 of the same condition appear the likelihood of them responding the same for the 4th condition even if it is different increase and can skew the data (this chance increase the more rows are the same). With what you have suggested something similar could occur as they would fall into a pattern of responding and again skew the data.</span>
<span class="comment-copy">For better visualization of nested lists use <code>pprint</code> <a href="http://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer">docs.python.org/3/library/pprint.html</a></span>
<span class="comment-copy">I have tried methods using the csv lib, what i posted is only what i got working the way i wanted it to, in my editor i have another 100+ lines of commented out code from different things i've been trying. I can use the csv lib to open the files and write new ones, but i'm not sure how to make the end file not have the repeating lines. I'm not tied to what i have written but i'm not sure how to go about solving my problem. Any other way that it could be done i'm open to, but my lack of knowledge is limiting the direction i should take. Do you think it is possible to do this with the csv lib?</span>
<span class="comment-copy">You are probably better off suffering lists, than creating temporary files. I will try to create a simple script that does what you want.</span>
<span class="comment-copy">Thanks, that would be amazing if you get a chance, this forum is amazingly helpful.</span>
<span class="comment-copy">I edited my answer to contain the code</span>
<span class="comment-copy">Thanks for the code, with a bit of editing and messing around i've managed to get it working with my data. Thanks and if you're ever in Ireland I owe you some pints.</span>
