<div class="post-text" itemprop="text">
<p>I want to execute a script inside a subdirectory/superdirectory (I need to be inside this sub/super-directory first). I can't get <code>subprocess</code> to enter my subdirectory:</p>
<pre><code>tducin@localhost:~/Projekty/tests/ve$ python
Python 2.7.4 (default, Sep 26 2013, 03:20:26) 
[GCC 4.7.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.getcwd()
'/home/tducin/Projekty/tests/ve'
&gt;&gt;&gt; subprocess.call(['cd ..'])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python2.7/subprocess.py", line 524, in call
    return Popen(*popenargs, **kwargs).wait()
  File "/usr/lib/python2.7/subprocess.py", line 711, in __init__
    errread, errwrite)
  File "/usr/lib/python2.7/subprocess.py", line 1308, in _execute_child
    raise child_exception
OSError: [Errno 2] No such file or directory
</code></pre>
<p>Python throws OSError and I don't know why. It doesn't matter whether I try to go into an existing subdir or go one directory up (as above) - I always end up with the same error.</p>
</div>
<div class="post-text" itemprop="text">
<p>What your code tries to do is call a program named <code>cd ..</code>. What you want is call a command named <code>cd</code>.</p>
<p>But <code>cd</code> is a shell internal. So you can only call it as</p>
<pre><code>subprocess.call('cd ..', shell=True) # pointless code! See text below.
</code></pre>
<p><strong>But it is pointless to do so.</strong> As no process can change another process's working directory (again, at least on a UNIX-like OS, but as well on Windows), this call will have the subshell change its dir and exit immediately.</p>
<p>What you want can be achieved with <code>os.chdir()</code> or with the <code>subprocess</code> named parameter <code>cwd</code> which changes the working directory immediately before executing a subprocess.</p>
<p>For example, to execute <code>ls</code> in the root directory, you either can do</p>
<pre><code>wd = os.getcwd()
os.chdir("/")
subprocess.Popen("ls")
os.chdir(wd)
</code></pre>
<p>or simply</p>
<pre><code>subprocess.Popen("ls", cwd="/")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To run <code>your_command</code> as a subprocess in a different directory, pass <code>cwd</code> parameter, as <a href="https://stackoverflow.com/a/21407005/4279">suggested in @wim's answer</a>:</p>
<pre><code>import subprocess

subprocess.check_call(['your_command', 'arg 1', 'arg 2'], cwd=working_dir)
</code></pre>
<p>A child process can't change its parent's working directory (<a href="https://stackoverflow.com/q/2375003/4279">normally</a>). Running <code>cd ..</code> in a child shell process using subprocess won't change your parent Python script's working directory i.e., <a href="https://stackoverflow.com/a/21406995/4279">the code example in @glglgl's answer is wrong</a>. <code>cd</code> is a shell builtin (not a separate executable), it can change the directory only in the <em>same</em> process.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use an absolute path to the executable, and use the <code>cwd</code> kwarg of <code>Popen</code> to set the working directory.  See the <a href="http://docs.python.org/2/library/subprocess.html#popen-constructor" rel="noreferrer">docs</a>.</p>
<blockquote>
<p>If cwd is not None, the child’s current directory will be changed to
  cwd before it is executed. Note that this directory is not considered
  when searching the executable, so you can’t specify the program’s path
  relative to cwd.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Another option based on this answer: <a href="https://stackoverflow.com/a/29269316/451710">https://stackoverflow.com/a/29269316/451710</a></p>
<p>This allows you to execute multiple commands (e.g <code>cd</code>) in the same process.</p>
<pre><code>import subprocess

commands = '''
pwd
cd some-directory
pwd
cd another-directory
pwd
'''

process = subprocess.Popen('/bin/bash', stdin=subprocess.PIPE, stdout=subprocess.PIPE)
out, err = process.communicate(commands.encode('utf-8'))
print(out.decode('utf-8'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>subprocess.call</code> and other methods in the <code>subprocess</code> module have a <code>cwd</code> parameter.</p>
<p>This parameter determines the working directory where you want to execute your process.</p>
<p>So you can do something like this:</p>
<pre><code>subprocess.call('ls', shell=True, cwd='path/to/wanted/dir/')
</code></pre>
<p>Check out docs <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="noreferrer">subprocess.popen-constructor</a></p>
</div>
<span class="comment-copy">What happens if use <code>os.chdir()</code> instead.</span>
<span class="comment-copy"><code>cd</code> usually also exists as a binary, not only a shell built-in. The real problem of the OP was that he was calling a binary <code>cd ..</code>, yes. (And your third paragraph would have been his next problem, so good answer.)</span>
<span class="comment-copy">@LeonWeber How should <code>cd</code> be able to work as a binary? It cannot chante its parent's working dir.</span>
<span class="comment-copy">I was talking about Linux. Good point though. I was wondering myself, and here’s the answer: <code>/usr/bin/cd</code> consists of <code>builtin cd "$@"</code> — so it just calls the shell built-in <code>cd</code> as well.</span>
<span class="comment-copy">@The_Diver That's why <code>cd</code> must be implemented as internal shell command. There's no other way to do it. Internal shell commands are executed within the same process as the shell. What I meant by subshell is the shell executed for <code>shell=True</code>. It gets the command to be executed, executes that and exits.</span>
<span class="comment-copy">I think an example or two of your suggested approach would be useful.</span>
<span class="comment-copy">It depends on if another subprocess is supposed to be executed. If so, your way is the right one. But for only having the own program acting inside a different directory, that won't help.</span>
<span class="comment-copy">What do you mean it won't help?  This is the one obvious way to do it.</span>
<span class="comment-copy">No, as it just changes the cwd of the process I am going to launch, such as <code>subprocess.call(['ls', '-l'], cwd='/')</code>. This changes the cwd to <code>/</code> and then runs <code>ls</code> with <code>-l</code> as argument. But if I want to do <code>os.chdir('/')</code> and then <code>open('etc/fstab', 'r')</code>, I cannot replace <code>os.chdir()</code> with anything about <code>subprocess.XXX(cwd='/')</code> as it won't help, as said. These are two complete different scenarios.</span>
<span class="comment-copy">That's why my answer says to use an absolute path to the executable, did you miss that part?</span>
<span class="comment-copy">No, I didn't. I think I give up. If I want to change the current working directory and open a file, <i>I have no executable.</i> It is a completely different situation. BTW: There is no need to use an absolute path if I use <code>cwd=</code> as intended. I can as well do <code>subprocess.call(['bin/ls', '-l'], cwd='/')</code>.</span>
<span class="comment-copy">This is just a roundabout and inefficient way to do <code>shell=True, executable='/bin/bash'</code></span>
