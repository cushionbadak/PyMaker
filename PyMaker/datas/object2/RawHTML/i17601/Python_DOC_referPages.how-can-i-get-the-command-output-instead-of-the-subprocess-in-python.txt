<div class="post-text" itemprop="text">
<p>If I do like:</p>
<pre><code>x = subprocess.Popen(["nosetests",      
"TestStateMachine.py:FluidityTest.test_it_has_an_initial_state", "-v"], 
stdout=subprocess.PIPE)
</code></pre>
<p>I have the output from my command executed:</p>
<pre><code>test_it_has_an_initial_state (TestStateMachine.FluidityTest) ... ok

----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
</code></pre>
<p>But if call <em>x.communicate()</em> for example I got:</p>
<pre><code>('', None)
</code></pre>
<p>How can I save that message in a variable, for example?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is almost certainly that your command is writing to stderr as well as to stdout, and you're only capturing stdout.</p>
<p>If you want to merge the two together into one string, do this:</p>
<pre><code>x = subprocess.Popen(["nosetests",
                      "TestStateMachine.py:FluidityTest.test_it_has_an_initial_state", 
                      "-v"], 
                     stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

out_and_err, _ = x.communicate()
</code></pre>
<p>If you want to get them as separate strings:</p>
<pre><code>x = subprocess.Popen(["nosetests",
                      "TestStateMachine.py:FluidityTest.test_it_has_an_initial_state", 
                      "-v"], 
                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)

out, err = x.communicate()
</code></pre>
<hr/>
<p>This is explained under <a href="http://docs.python.org/3/library/subprocess#frequently-used-arguments" rel="nofollow">Frequently Used Arguments</a>:</p>
<blockquote>
<p><em>stdin</em>, <em>stdout</em> and <em>stderr</em> specify the executed program’s standard input, standard output and standard error file handles, respectively. Valid values are… Additionally, <em>stderr</em> can be <code>STDOUT</code>, which indicates that the stderr data from the child process should be captured into the same file handle as for <em>stdout</em>.</p>
</blockquote>
<p>However, if you'd never heard of standard error before, it's understandable that you wouldn't have gone looking for this… The docs assume you know the basic C/POSIX model of separate output and error pipes for every program.</p>
<hr/>
<p>As a side note, if all you want to run is run a program and get its output, merging its stderr in with its stdout, you don't need to create a <code>Popen</code> and call <code>communicate</code> on it; just use <code>check_output</code>:</p>
<pre><code>out_and_err = subprocess.check_output([… args …], stderr=subprocess.STDOUT)
</code></pre>
</div>
<span class="comment-copy">The title is a bit confused. It's not that the command subprocess (or the <code>subprocess</code> module) is stealing its own output from you; it's that neither the subprocess nor you is stealing its output, so that output goes straight to your own output, as if you'd been <code>print</code>ing it.</span>
