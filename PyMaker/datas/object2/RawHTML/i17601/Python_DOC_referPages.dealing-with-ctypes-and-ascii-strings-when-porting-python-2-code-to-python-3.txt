<div class="post-text" itemprop="text">
<p>I got fed up last night and started porting PyVISA to <a href="https://en.wikipedia.org/wiki/History_of_Python#Version_3.0" rel="nofollow">Python 3</a> (progress here: <a href="https://github.com/thevorpalblade/pyvisa" rel="nofollow">https://github.com/thevorpalblade/pyvisa</a>).</p>
<p>I've gotten it to the point where everything works, as long as I pass device addresses (well, any string really) as an <a href="http://en.wikipedia.org/wiki/ASCII" rel="nofollow">ASCII</a> string rather than the default unicode string (For example, <br/>
HP = vida.instrument(b"GPIB::16") works, whereas
HP = vida.instrument("GPIB::16") does not, raising a ValueError.</p>
<p>Ideally, the end user should not have to care about string encoding.
Any suggestions as to how I should approach this? Something in the ctypes type definitions perhaps?</p>
<p>As it stands, the relevant ctypes type definition is:</p>
<pre><code>ViString = _ctypes.c_char_p
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>ctypes</code>, like most things in Python 3, intentionally doesn't automatically convert between unicode and bytes. That's because in most use cases, that would just be asking for the same kind of mojibake or <code>UnicodeEncodeError</code> disasters that people switched to Python 3 to avoid.</p>
<p>However, when you know you're only dealing with pure ASCII, that's another story. You have to be explicit—but you can factor out that explicitness into a wrapper.</p>
<hr/>
<p>As explained in <a href="http://docs.python.org/3/library/ctypes.html#specifying-the-required-argument-types-function-prototypes" rel="nofollow">Specifying the required argument types (function prototypes)</a>, in addition to a standard <code>ctypes</code> type, you can pass any class that has a <code>from_param</code> classmethod—which normally returns an instance of some type (usually the same type) with an <code>_as_parameter_</code> attribute, but can also just return a native <code>ctypes</code>-type value instead.</p>
<pre><code>class Asciifier(object):
    @classmethod
    def from_param(cls, value):
        if isinstance(value, bytes):
            return value
        else:
            return value.encode('ascii')
</code></pre>
<p>This may not be the exact rule you want—for example, it'll fail on <code>bytearray</code> (just as <code>c_char_p</code> will) even though that could be converted quietly to <code>bytes</code>… but then you wouldn't want to implicitly convert an <code>int</code> to <code>bytes</code>. Anything, whatever rule you decide on should be easy to code.</p>
<hr/>
<p>Here's an example (on OS X; you'll obviously have to change how <code>libc</code> is loaded for linux, Windows, etc., but you presumably know how to do that):</p>
<pre><code>&gt;&gt;&gt; libc = CDLL('libSystem.dylib')
&gt;&gt;&gt; libc.atoi.argtypes = [Asciifier]
&gt;&gt;&gt; libc.atoi.restype = c_int
&gt;&gt;&gt; libc.atoi(b'123')
123
&gt;&gt;&gt; libc.atoi('123')
123
&gt;&gt;&gt; libc.atoi('１２３') # Unicode fullwidth digits
ArgumentError: argument 1: &lt;class 'UnicodeEncodeError'&gt;: 'ascii' codec can't encode character '\uff10' in position 0: ordinal not in range(128)
&gt;&gt;&gt; libc.atoi(123)
ArgumentError: argument 1: &lt;class 'AttributeError'&gt;: 'int' object has no attribute 'encode'
</code></pre>
<p>Obviously you can catch the exception and raise a different one if those aren't clear enough for your use case.</p>
<p>You can similarly write a <code>Utf8ifier</code>, or an <code>Encodifier(encoding, errors=None)</code> class factory, or whatever else you need for some particular library and stick it in the <code>argtypes</code> the same way.</p>
<hr/>
<p>If you also want to auto-decode return types, see <a href="http://docs.python.org/3/library/ctypes.html#return-types" rel="nofollow">Return types</a> and <a href="http://docs.python.org/3/library/ctypes.html#ctypes._FuncPtr.errcheck" rel="nofollow"><code>errcheck</code></a>.</p>
<hr/>
<p>One last thing: When you're sure the data are <em>supposed</em> to be UTF-8, but you want to deal with the case where they aren't in the same way Python 2.x would (by preserving them as-is), you can even do that in 3.x. Use the aforementioned <code>Utf8ifier</code> as your argtype, and a decoder errcheck, and use <a href="http://www.python.org/dev/peps/pep-0383/" rel="nofollow"><code>errors=surrogateescape</code></a>. See <a href="http://pastebin.com/i1NwwQvZ" rel="nofollow">here</a> for a complete example.</p>
</div>
<span class="comment-copy">@eryksun: I generally show the <code>LoadLibrary</code> call in examples because that's what the first non-Windows example in the docs does and I don't want to explain irrelevant stuff. But now that I think about it, that's kind of silly, especially since the very next line shows the simpler example. Thanks!</span>
<span class="comment-copy">I do like this approach, but I was hoping for a solution that didn't require per-function code. This is more elegant than inserting <code>value = value.encode('ascii')</code> in every function definition, but I still wonder if I could do better by altering the ctypes definition itself? Rather than  <code>ViString = _ctypes.c_char_p</code>  something like  <code>ViString = _ctypes.my_type</code>  where my_type inherits from c_char_p but encodes as ascii first?</span>
<span class="comment-copy">@MatthewLawson: I'm not sure I understand what you're asking. What is <code>ViString</code>? It appears to be just another name for the <code>c_char_p</code> type, so… how are you using that? More importantly: You <i>should</i> be setting the <code>argtypes</code> for every C function that you use via ctypes (otherwise, things will <i>often</i> happen to work, when there aren't too many args, and they'll all exactly the same size as int, and you're lucky… which is usually not good enough). So, how is it any harder to put <code>Asciifier</code> or whatever there than <code>ctypes.c_char_p</code>?</span>
<span class="comment-copy">@MatthewLawson: Actually, looking at <a href="https://github.com/thevorpalblade/pyvisa/blob/master/pyvisa/vpp43.py" rel="nofollow noreferrer">your code on github</a>, what you use <code>ViString</code> for <i>is</i> to set <code>argtypes</code> (via a <code>__set_argument_types</code> wrapper method) on your ctypes functions, and in the <code>get_attribute</code>/<code>set_attribute</code> functions (which don't actually use the value, just check whether it's the value you stored), so… can't you just <code>ViString = Asciifier</code> and change nothing else? (You might also be using it in other places; I didn't download and ack your code or anything…)</span>
<span class="comment-copy">This library (the VISA library) requires all of its own custom types (bleh), so we need to define these custom Vi types to pass to the library. In this case, yeah, viString is just defined as c_char_p.   __set_argument_types() is currently used on every function to set the expected argument types for each function, for example:  <code>self.__set_argument_types("viFindRsrc", [ViSession, ViString, ViPFindList, ViPUInt32, ViAChar])</code> Where, for example, ViSession is (in other code) just defined as a ViString...  Your solution may be the best way to go, I'm just still looking for a lazier way.</span>
