<div class="post-text" itemprop="text">
<p>I have just tried using struct.pack in Python for the first time, and I don't understand its behaviour when I am mixing types</p>
<p>When I am trying to pack a single char and nothing else, it works as expected, i.e.</p>
<pre><code>struct.pack("b",1)
</code></pre>
<p>gives <code>'\x01'</code>. But as soon as I try to mix in data of a different type, the char is padded to be as long as this type, e.g.</p>
<pre><code>struct.pack("bi",1,1)
</code></pre>
<p>gives <code>'\x01\x00\x00\x00\x01\x00\x00\x00'</code>.</p>
<p>Is this standard behaviour, and why? Is there a way around it?</p>
<p><strong>Edit</strong></p>
<p>More simply put:</p>
<pre><code>&gt;&gt;&gt; struct.calcsize("b")
1
&gt;&gt;&gt; struct.calcsize("i")
4
&gt;&gt;&gt; struct.calcsize("bi")
8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>struct.pack</code> is usually used to access memory structures, not files. In memory, accessing data which occupies several bytes at an odd/unaligned address can cause exceptions or performance loss.</p>
<p>That's why compilers align the data (usually on a 4 or 8 byte boundary) and <a href="http://www.python.org/doc//current/library/struct.html">the <code>struct</code> module</a> in Python does the same.</p>
<p>To disable this, you can use the first character of the format string to set the byte order and alignment. In your case, try <code>struct.pack("=bi",1,1)</code></p>
<p>If you don't specify anything, then an implicit <code>@</code> which means "native byte order, size and alignment". <a href="http://www.python.org/doc//current/library/struct.html">See the documentation for other options</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/struct#byte-order-size-and-alignment" rel="nofollow">Yes, it is.</a></p>
<blockquote>
<p>By default, C types are represented in the machine’s native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler).</p>
</blockquote>
<p>If you don't want alignment, just specify a byte order by starting your format string with <code>'='</code>, <code>'&lt;'</code>, or <code>'&gt;'</code> (same as <code>'!'</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="http://docs.python.org/3/library/struct.html" rel="nofollow">manual</a>:</p>
<blockquote>
<p>By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct.</p>
</blockquote>
<p><code>i</code> is a 4-byte integer which will be placed on its own <em>word</em>. As such, anything next to it, that doesn’t fill a word, will be padded to do that. You can override this behavior by specifying a <a href="http://docs.python.org/3/library/struct.html#byte-order-size-and-alignment" rel="nofollow">byte order</a> without native alignment.</p>
<p>That’s why—with more complex structs—the ordering of the things inside matters a lot.</p>
<p>See also the <a href="http://en.wikipedia.org/wiki/Data_structure_alignment" rel="nofollow">Wikipedia article</a> on the topic.</p>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="http://docs.python.org/2/library/struct.html" rel="nofollow noreferrer">the documentation for struct</a>; in particular it says</p>
<blockquote>
<p>By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct.</p>
</blockquote>
<p>And see e.g. this Stack Overflow question for C struct memory layout: <a href="https://stackoverflow.com/questions/2748995/c-struct-memory-layout">C struct memory layout?</a></p>
<p>In short, the integer is 4 bytes and therefore it must start at a multiple of 4. If you change the order of b and i around, the problem should't arise.</p>
</div>
<span class="comment-copy">And surprisingly: <code>struct.calcsize('d')</code> → 8, <code>struct.calcsize('bd')</code> ­­→ 16.  Alignment and padding seems to be depending on the other types.  That's not intuitive, even if you expect alignment. EDIT: Ah, I see, the size of the <code>'d'</code> is 8, and that determines where it can start (at multiples of 8), hence the padding.</span>
<span class="comment-copy">@Alfe Exactly, that’s why <code>struct.calcsize('db')</code> is 9 (note that in C, it would usually be 12 as words need to be filled completely).</span>
<span class="comment-copy">Yes, @poke, nice notion to swap the two elements to display that the padding does not belong to the byte but to the double.</span>
