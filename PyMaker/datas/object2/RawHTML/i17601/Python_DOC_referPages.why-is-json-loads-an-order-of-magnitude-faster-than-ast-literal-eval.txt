<div class="post-text" itemprop="text">
<p>After answering a question about <a href="https://stackoverflow.com/q/21222702/343834">how to parse a text file containing arrays of floats</a>, I ran the following benchmark:</p>
<pre><code>import timeit
import random

line = [random.random() for x in range(1000)]
n = 10000

json_setup = 'line = "{}"; import json'.format(line)
json_work = 'json.loads(line)'
json_time = timeit.timeit(json_work, json_setup, number=n)
print "json: ", json_time

ast_setup = 'line = "{}"; import ast'.format(line)
ast_work = 'ast.literal_eval(line)'
ast_time = timeit.timeit(ast_work, ast_setup, number=n)
print "ast: ", ast_time

print "time ratio ast/json: ", ast_time / json_time
</code></pre>
<p>I ran this code several times and consistently got this kind of results:</p>
<pre><code>$ python json-ast-bench.py 
json: 4.3199338913
ast: 28.4827561378
time ratio ast/json:  6.59333148483
</code></pre>
<p>So it appears that <a href="http://docs.python.org/2/library/json.html" rel="nofollow noreferrer"><code>json</code></a> is almost an order of magnitude faster than <a href="http://docs.python.org/2/library/ast.html" rel="nofollow noreferrer"><code>ast</code></a> for this use case.</p>
<p>I had the same results with both Python 2.7.5+ and Python 3.3.2+.</p>
<p><strong>Questions:</strong></p>
<ol>
<li>Why is json.loads so much faster ? <a href="https://stackoverflow.com/q/12735106/343834">This question</a> seems to imply that ast is more flexible regarding the input data (double or single quotes)</li>
<li>Are there use cases where I would prefer to use <code>ast.literal_eval</code> over <code>json.loads</code> although it's slower ?</li>
</ol>
<p><strong>Edit:</strong> Anyway if performance matters, I would recommend using <a href="https://github.com/esnme/ultrajson" rel="nofollow noreferrer">UltraJSON</a> (just what I use at work, ~4 times faster than json using the same mini-benchmark).</p>
</div>
<div class="post-text" itemprop="text">
<p>The two functions are parsing entirely different languages—JSON, and Python literal syntax.* As <a href="http://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>literal_eval</code></a> says:</p>
<blockquote>
<p>The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and <code>None</code>.</p>
</blockquote>
<p><a href="http://www.json.org" rel="nofollow">JSON</a>, by contrast, only handles double-quoted JavaScript string literals (not quite identical to Python's**), JavaScript numbers (only int and float***), objects (roughly equivalent to dicts), arrays (roughly equivalent to lists), JavaScript booleans (which are different from Python's), and <code>null</code>.</p>
<p>The fact that these two languages happen to have some overlap doesn't mean they're the same language.</p>
<hr/>
<blockquote>
<p>Why is <code>json.loads</code> so much faster ?</p>
</blockquote>
<p>Because Python literal syntax is a more complex and powerful language than JSON, it's likely to be slower to parse. And, probably more importantly, because Python literal syntax is not intended to be used as a data interchange format (in fact, it's specifically <em>not</em> supposed to be used for that), nobody is likely to put much effort into making it fast for data interchange.****</p>
<blockquote>
<p>This question seems to imply that ast is more flexible regarding the input data (double or single quotes)</p>
</blockquote>
<p>That, and raw string literals, and Unicode vs. bytes string literals, and complex numbers, and sets, and all kinds of other things JSON doesn't handle.</p>
<blockquote>
<p>Are there use cases where I would prefer to use ast.literal_eval over json.loads although it's slower ?</p>
</blockquote>
<p>Yes. When you want to parse Python literals, you should use <code>ast.literal_eval</code>. (Or, better yet, re-think your design so you don't want to parse Python literals…)</p>
<hr/>
<p>* This is a bit of a vague term. For example, <code>-2</code> is not a <a href="http://docs.python.org/3/reference/lexical_analysis.html#literals" rel="nofollow">literal</a> in Python, but an operator expression, but <a href="http://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>literal_eval</code></a> can handle it. And of course tuple/list/dict/set displays are not literals, but <code>literal_eval</code> can handle them—except that comprehensions are also displays, and <code>literal_eval</code> cannot handle them. Other functions in the <code>ast</code> module can help you find out what really is and isn't a literal—e.g., <code>ast.dump(ast.parse("expr"))</code>.</p>
<p>** For example, <code>"\q"</code> is an error in JSON.</p>
<p>*** Technically, JSON only handles one "number" type, which is floating-point. But Python's <code>json</code> module parses numbers with no decimal point or exponent as integers, and the same is true in many other languages' JSON modules.</p>
<p>**** If you missed Tim Peters's comment on the question: "<code>ast.literal_eval</code> is so lightly used that nobody felt it was worth the time to work (&amp; work, &amp; work) at speeding it. In contrast, the JSON libraries are routinely used to parse gigabytes of data."</p>
</div>
<span class="comment-copy">The JSON grammar is simpler than the Python grammar; the latter supports many different forms of string literals, for example.</span>
<span class="comment-copy">Ok, I was just surprised that you would recommend ast to parse arrays of float while they made me think of JSON. Thanks for your answer !</span>
<span class="comment-copy">Grammar complexity is a red herring here - yes, Python's literal grammar is more complex, but these things were all designed to be parsed correctly in one pass without backtracking.  The real reason is that <code>ast.literal_eval</code> is so lightly used that nobody felt it was worth the time to work (&amp; work, &amp; work) at speeding it.  In contrast, the JSON libraries are routinely used to parse gigabytes of data.</span>
<span class="comment-copy">@MaximeR.: because the format was probably saved as <code>str(python_list)</code> rather than JSON; JSON just didn't spring to mind immediately.</span>
<span class="comment-copy">@MaximeR.: There aren't any other "general-purpose helper" type functions there; the rest of the module is all about parsing the full Python grammar into parse trees. Which is very cool, and worth learning—if you've ever wondered how Python parses <code>-2</code> or <code>1+2j</code> or <code>[i+1 for i in range(5)]</code>, just feed it to <code>ast.dump(ast.parse(s))</code>.</span>
<span class="comment-copy">What makes you say tuples/lists/dicts/sets are not literals?</span>
<span class="comment-copy">@BrenBarn: The reference documentation on literals that I linked to. A display is an <a href="http://docs.python.org/3/reference/expressions.html#atoms" rel="nofollow noreferrer">enclosure</a>, which is a different kind of atom from a literal.</span>
<span class="comment-copy">@BrenBarn: PS, although I linked to Python 3 docs, all of the same things are true in 2.x, except that comprehensions were not a kind of display until… 2.6, I think.</span>
<span class="comment-copy">Thanks for your detailed answer :) Also thanks @BrenBarn because I was going to ask for the definition of Python literals!</span>
<span class="comment-copy">@MaximeR.: Do you think that needs to be explained more prominently in the answer? The fact that two out of two people looking for that information missed it probably isn't a great sign…</span>
