<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3387691/how-to-perfectly-override-a-dict">How to “perfectly” override a dict?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>I attempted to implement a mapping in Python by using the abstract base class, MutableMapping, but I got an error on instantiation. How would I go about making a working version of this dictionary that would emulate the builtin <code>dict</code> class, in as many ways as possible, to be clear, with <strong>Abstract Base Classes</strong>?</p>
<pre><code>&gt;&gt;&gt; class D(collections.MutableMapping):
...     pass
... 
&gt;&gt;&gt; d = D()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Can't instantiate abstract class D with abstract methods __delitem__, __getitem__, __iter__, __len__, __setitem__
</code></pre>
<p>A good answer will demonstrate how to make this work, specifically without subclassing <code>dict</code> (<a href="https://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries-in-python/19829714#19829714">a concept that I am quite familiar with</a>).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>How would I implement a dict with Abstract Base Classes?</strong></p>
<p>A good answer will demonstrate how to make this work, specifically
  without subclassing dict.</p>
</blockquote>
<p>Here's the error message: <code>TypeError: Can't instantiate abstract class D with abstract methods __delitem__, __getitem__, __iter__, __len__, __setitem__</code></p>
<p>It turns out that one must implement them to use the Abstract Base Class (ABC), <code>MutableMapping</code>.</p>
<h2>Implementation</h2>
<p>So I implement a mapping that works like a dict in most respects that uses the object's attribute reference dict for the mapping. (Delegation is not the same as inheritance, so we'll just delegate to the instance <code>__dict__</code>, we could use any other ad-hoc mapping, but you don't seem to care about that part of the implementation. It makes sense to do it this way in Python 2, because MutableMapping doesn't have <code>__slots__</code> in Python 2, so you're creating a <code>__dict__</code> either way. In Python 3, you could avoid dicts altogether by setting <code>__slots__</code>.)</p>
<pre><code>import collections

class D(collections.MutableMapping):
    '''
    Mapping that works like both a dict and a mutable object, i.e.
    d = D(foo='bar')
    and 
    d.foo returns 'bar'
    '''
    # ``__init__`` method required to create instance from class.
    def __init__(self, *args, **kwargs):
        '''Use the object dict'''
        self.__dict__.update(*args, **kwargs)
    # The next five methods are requirements of the ABC.
    def __setitem__(self, key, value):
        self.__dict__[key] = value
    def __getitem__(self, key):
        return self.__dict__[key]
    def __delitem__(self, key):
        del self.__dict__[key]
    def __iter__(self):
        return iter(self.__dict__)
    def __len__(self):
        return len(self.__dict__)
    # The final two methods aren't required, but nice for demo purposes:
    def __str__(self):
        '''returns simple dict representation of the mapping'''
        return str(self.__dict__)
    def __repr__(self):
        '''echoes class, id, &amp; reproducible representation in the REPL'''
        return '{}, D({})'.format(super(D, self).__repr__(), 
                                  self.__dict__)
</code></pre>
<h2>Demonstration</h2>
<p>And to demonstrate the usage:</p>
<pre><code>&gt;&gt;&gt; d = D((e, i) for i, e in enumerate('abc'))
&gt;&gt;&gt; d
&lt;__main__.D object at 0x7f75eb242e50&gt;, D({'b': 1, 'c': 2, 'a': 0})
&gt;&gt;&gt; d.a
0
&gt;&gt;&gt; d.get('b')
1
&gt;&gt;&gt; d.setdefault('d', []).append(3)
&gt;&gt;&gt; d.foo = 'bar'
&gt;&gt;&gt; print(d)
{'b': 1, 'c': 2, 'a': 0, 'foo': 'bar', 'd': [3]}
</code></pre>
<p>And for ensuring the dict API, lesson learned is that you can always check for <code>collections.MutableMapping</code>:</p>
<pre><code>&gt;&gt;&gt; isinstance(d, collections.MutableMapping)
True
&gt;&gt;&gt; isinstance(dict(), collections.MutableMapping)
True
</code></pre>
<p>And while a dict is always going to be an instance of a MutableMapping due to registration on collections import, the reverse is not always true:</p>
<pre><code>&gt;&gt;&gt; isinstance(d, dict)
False
&gt;&gt;&gt; isinstance(d, (dict, collections.MutableMapping))
True
</code></pre>
<p>After performing this exercise, it is clear to me that using Abstract Base Classes provides only the guarantee of a standard API for users of the class. In this case, users assuming a MutableMapping object will be guaranteed the standard API for Python.</p>
<h2>Caveats:</h2>
<p>The <code>fromkeys</code> class constructor method is not implemented.</p>
<pre><code>&gt;&gt;&gt; dict.fromkeys('abc')
{'b': None, 'c': None, 'a': None}
&gt;&gt;&gt; D.fromkeys('abc')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: type object 'D' has no attribute 'fromkeys'
</code></pre>
<p>One could mask the builtin dict methods like <code>get</code> or <code>setdefault</code></p>
<pre><code>&gt;&gt;&gt; d['get'] = 'baz'
&gt;&gt;&gt; d.get('get')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object is not callable
</code></pre>
<p>It's fairly simple to unmask again:</p>
<pre><code>&gt;&gt;&gt; del d['get']
&gt;&gt;&gt; d.get('get', 'Not there, but working')
'Not there, but working'
</code></pre>
<p>But I wouldn't use this code in production.</p>
<hr/>
<p>Demonstration without a dict, Python 3:</p>
<pre><code>&gt;&gt;&gt; class MM(MutableMapping):
...   __delitem__, __getitem__, __iter__, __len__, __setitem__ = (None,) *5
...   __slots__ = ()
...
&gt;&gt;&gt; MM().__dict__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'MM' object has no attribute '__dict__'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>At the Least</strong></p>
<p>You need to implement in your subclass, all the abstract methods that you inherit from MutableMapping</p>
<pre><code>class D(MutableMapping):
    def __delitem__(self):
        '''
         Your Implementation for deleting the Item goes here
        '''
        raise NotImplementedError("del needs to be implemented")
    def __getitem__(self):
        '''
         Your Implementation for subscripting the Item goes here
        '''
        raise NotImplementedError("obj[index] needs to be implemented")
    def __iter__(self):
        '''
         Your Implementation for iterating the dictionary goes here
        '''
        raise NotImplementedError("Iterating the collection needs to be implemented")
    def __len__(self):
        '''
         Your Implementation for determing the size goes here
        '''
        raise NotImplementedError("len(obj) determination needs to be implemented")
    def __setitem__(self):
        '''
         Your Implementation for determing the size goes here
        '''
        raise NotImplementedError("obj[index] = item,  needs to be implemented")


&gt;&gt;&gt; D()
&lt;__main__.D object at 0x0258CD50&gt;
</code></pre>
<p><strong>Moreover</strong></p>
<p>You need to provide a data structure to store your mapping (hash, AVL, Red Black), and a way to construct your Dictionary</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to demonstrate this without actually using a <code>dict</code> anywhere is probably to implement something dead simple, very different from <code>dict</code>, and not completely useless. Like a fixed-sized mapping of fixed-size <code>bytes</code> to same-fixed-size <code>bytes</code>. (You might use this for, e.g., a routing table—it'll be much more compact than a <code>dict</code> mapping unpacked keys to unpacked values, although obviously at the cost of speed and flexibility.)</p>
<p>A hash table is just an array of <code>(hash, key, value)</code> tuples. Since the whole point of this is packing data in, we cram those into a <code>struct</code>, meaning we can just use a big <code>bytearray</code> for storage. To mark a slot empty, we set its hash value to <code>0</code>—which means we need to "escape" any real <code>0</code> by turning it into a <code>1</code>, which is stupid, but simpler to code. We'll also use the dumbest possible <code>probe</code> algorithm for simplicity.</p>
<pre><code>class FixedHashTable(object):
    hashsize = 8
    def __init__(self, elementsize, size):
        self.elementsize = elementsize
        self.size = size
        self.entrysize = self.hashsize + self.elementsize * 2
        self.format = 'q{}s{}s'.format(self.elementsize, self.elementsize)
        assert struct.calcsize(self.format) == self.entrysize
        self.zero = b'\0' * self.elementsize
        self.store = bytearray(struct.pack(self.format, 0,
                                           self.zero, self.zero)
                               ) * self.size
    def hash(self, k):
        return hash(k) or 1
    def stash(self, i, h, k, v):
        entry = struct.pack(self.format, h, k, v)
        self.store[i*self.entrysize:(i+1)*self.entrysize] = entry
    def fetch(self, i):
        entry = self.store[i*self.entrysize:(i+1)*self.entrysize]
        return struct.unpack(self.format, entry)
    def probe(self, keyhash):
        i = keyhash % self.size
        while True:
            h, k, v = self.fetch(i)
            yield i, h, k, v
            i = (i + 1) % self.size
            if i == keyhash % self.size:
                break
</code></pre>
<p>As the error message says, you need to provide implementations for the abstract methods <code>__delitem__</code>, <code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code>, and <code>__setitem__</code>. However, a better place to look is <a href="http://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow">the docs</a>, which will tell you that if you implement those five methods (plus any other methods required by the base classes, but as you can see from the table there are none), you'll get all the other methods for free. You may not get the most efficient possible implementations of all of them, but we'll come back to that.</p>
<p>First, let's deal with <code>__len__</code>. Normally people expect this to be O(1), which means we need to keep track of it independently, updating it as needed. So:</p>
<pre><code>class FixedDict(collections.abc.MutableMapping):
    def __init__(self, elementsize, size):
        self.hashtable = FixedHashTable(elementsize, size)
        self.len = 0
</code></pre>
<p>Now, <code>__getitem__</code> just probes until it finds the desired key or reaches the end:</p>
<pre><code>    def __getitem__(self, key):
        keyhash = self.hashtable.hash(key)
        for i, h, k, v in self.hashtable.probe(keyhash):
            if h and k == key:
                return v
</code></pre>
<p>And <code>__delitem__</code> does the same thing, except it empties out the slot if found, and updates <code>len</code>.</p>
<pre><code>    def __delitem__(self, key):
        keyhash = self.hashtable.hash(key)
        for i, h, k, v in self.hashtable.probe(keyhash):
            if h and k == key:
                self.hashtable.stash(i, 0, self.hashtable.zero, self.hashtable.zero)
                self.len -= 1
                return
        raise KeyError(key)
</code></pre>
<p><code>__setitem__</code> is a bit trickier—if found, we have to replace the value in the slot; if not, we have to fill an empty slot. And here we have to deal with the fact that the hash table may be full. And of course we have to take care of <code>len</code>:</p>
<pre><code>    def __setitem__(self, key, value):
        keyhash = self.hashtable.hash(key)
        for i, h, k, v in self.hashtable.probe(keyhash):
            if not h or k == key:
                if not h:
                    self.len += 1
                self.hashtable.stash(i, keyhash, key, value)
                return
        raise ValueError('hash table full')
</code></pre>
<p>And that leaves <code>__iter__</code>. Just as with a <code>dict</code>, we don't have any particular order, so we can just iterate the hash table slots and yield all the non-empty ones:</p>
<pre><code>def __iter__(self):
    return (k for (h, k, v) in self.hashtable.fetch(i)
            for i in range(self.hashtable.size) if h)
</code></pre>
<p>While we're at it, we might as well write a <code>__repr__</code>. Note that we can use the fact that we get <code>items</code> for free:</p>
<pre><code>def __repr__(self):
    return '{}({})'.format(type(self).__name__, dict(self.items()))
</code></pre>
<p>However, note that the default <a href="http://hg.python.org/cpython/file/3.3/Lib/collections/abc.py#l416" rel="nofollow"><code>items</code></a> just creates an <code>ItemsView(self)</code>, and if you track that through the source, you'll see that it iterates <code>self</code> and looks up each value. You can obviously do better if the performance matters:</p>
<pre><code>def items(self):
    pairs = ((k, v) for (h, k, v) in self.hashtable.fetch(i)
             for i in range(self.hashtable.size) if h)
    return collections.abc.ItemsView._from_iterable(pairs)
</code></pre>
<p>And likewise for <code>values</code>, and possibly other methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>The whole idea of an abstract base class is that it has some members, (pure virtual members in C++ terms), that your code has to supply - in C++ these are the Pure Virtual members and other Virtual members you <strong>may</strong> override.</p>
<p>Python differs from C++ in that all members of all classes are Virtual and may be overridden, (and you can add members to all classes and instances) but Abstract Base classes have some required missing classes these are the equivent to the C++ pure virtual.</p>
<p>Having got that out of the way you just need to supply the missing members to be able to create an instance of your derived class.  </p>
<p>For an example of the sort of thing you are trying to do see the accepted answer <a href="https://stackoverflow.com/questions/3387691/python-how-to-perfectly-override-a-dict">here</a> but rather than use a dict within the class you will have to provide the methods that it provides yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>MutableMapping</code> as base class you should create this methods yourself in your class: <code>__delitem__, __getitem__, __iter__, __len__, __setitem__</code>.</p>
<p>To create custom dict class you can derive it from dict:</p>
<pre><code>&gt;&gt;&gt; class D(dict):
...     pass
... 
&gt;&gt;&gt; d = D()
&gt;&gt;&gt; d
{}
</code></pre>
</div>
<span class="comment-copy">Maybe <a href="http://docs.python.org/2/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a> would be of some use here, otherwise you still instantiate <code>__dict__</code>, as I understand it.</span>
<span class="comment-copy">@AaronHall: Well, yes, but so what? You're not using it to implement the mutable mapping methods. And even if you use slots, you've still got a <code>__dict__</code>, because <code>MutableMapping</code> has one.</span>
<span class="comment-copy">I'm looking at the source, can you show me how it does? <a href="http://hg.python.org/cpython/file/1166b3321012/Lib/_collections_abc.py" rel="nofollow noreferrer">hg.python.org/cpython/file/1166b3321012/Lib/_collections_abc.py</a></span>
<span class="comment-copy">@AaronHall: The <i>class</i> <code>MutableMapping</code> has a <code>__dict__</code>. Therefore your class does as well. The only way to avoid that is with a custom metaclass (and obviously <code>ABCMeta</code> doesn't do that). So, even if you use <code>__slots__</code>, you're still creating a dictionary just by defining your class. Which is completely irrelevant, but only in the same way that <code>__slots__</code> is completely irrelevant in the first place. Who cares that dict objects are getting created? None of them are being used to implement <code>MutableMapping</code>'s methods, which is what the OP is asking for.</span>
<span class="comment-copy">@AaronHall: In particular, what you asked for is how to emulate a <code>dict</code> with ABCs and without subclassing <code>dict</code>. This is not like your own answer, where you emulated a <code>dict</code> by delegating to your <code>__dict__</code> (which, besides not really answering your question, has some obvious negative side effects); I'm emulating a <code>dict</code> without delegating to anything, by implementing it from scratch.</span>
<span class="comment-copy">GREP for ListBasedSet on the collections page, <a href="http://docs.python.org/2/library/collections.html" rel="nofollow noreferrer">docs.python.org/2/library/collections.html</a> I'm specifically asking for examples on how to do that to create a working mapping.</span>
<span class="comment-copy">@AaronHall See the link I just added.</span>
<span class="comment-copy">Here's the title, I don't think I'm miscommunicating: "How would I implement a dict with <b>Abstract Base Classes</b> in Python?" There's absolutely no way I'll accept this answer.</span>
<span class="comment-copy">@AaronHall you already did this and got error. And error say that your class missing this methods. Read some docs about abstract base classes</span>
<span class="comment-copy">I think this answer I gave on subclassing dict demonstrates my familiarity with it, I specifically did not intend to subclass dict for the purposes of this question. <a href="http://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries-in-python/19829714#19829714" title="what is the best way to implement nested dictionaries in python">stackoverflow.com/questions/635483/…</a></span>
