<div class="post-text" itemprop="text">
<p>I'm trying to add a directory where I can throw some pyc files and call them from my script. </p>
<p>Basically it's an independent python script with a bunch of def's in it,
I want the name of the pyc file to be the command executed.
so far this works ok except for one thing, my GUI buttons are calling defs as they are
and python doesn't recognize them since the name space is wrong.</p>
<p>How can I import it in from the script as if it was imported like :</p>
<blockquote>
<p>from Module import as *</p>
</blockquote>
<p>I'm running this code to load it in:</p>
<pre><code>def importModule(ModPath):
    fullModName= ModPath.split('\\')[-1]
    commandtorun=fullModName.split('.')[0]

    mod_name,file_ext = os.path.splitext(os.path.split(ModPath)[-1])
    if file_ext.lower() == '.py':
        py_mod = imp.load_source(mod_name, ModPath)
    elif file_ext.lower() == '.pyc':
        py_mod = imp.load_compiled(mod_name, ModPath)

    exec "from %s import *"%(commandtorun)
    exec "%s()" % (commandtorun)
</code></pre>
<p>i know i can write : module.somefunction() , but that's not what i need... 
i need the "module" to work independently.. </p>
<p>Please help, this is driving me crazy, python is such an awesome language I cant believe you can't source a script from within a script and have it work.
please advise. </p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>You could use a (rare-in-Python) semicolon in your <code>exec</code> call to make one <code>exec</code> out of the two you have</li>
<li>You might want to take a look at <code>import_module(name, package)</code> in <a href="http://docs.python.org/3/library/importlib.html" rel="nofollow">importlib</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>AFAIK <code>exec</code> has it's own variable scope, thereby importing your script into a scope that is immediately destroyed. You could either pass in dicts for the globals and locals or avoid <code>exec</code> completely, which would be my suggestion. Why don't you just use <code>from ... import *</code> directly?</p>
<p>If you place an <code>__init__.py</code> file in the directory, you can use <code>from folder.script import *</code> and if the folder is not in your current working directory or your path, you</p>
<ol>
<li>are probably doing something wrong, you should have one project directory (that can of course have subdirectories) where your code is; or create multiple modules that you install seperately and make sure the ones you need are in your path</li>
<li><p>can add any directory to your path, so you  can import modules directly from it with</p>
<pre><code>import sys
sys.path.append("/path/to/directory")
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you want to auto-exec a def inside an already imported module, you can do it more simply with the <a href="http://docs.python.org/2.6/library/inspect.html" rel="nofollow">inspect module</a>:</p>
<pre><code>import inspect
def auto_exec (module):
    for fn_name, fn in inspect.getmembers(module, isfunction):
        if fn_name == module.__name__:  fn()
</code></pre>
<p>However that's a <strong>bandaid on the real problem.</strong></p>
<p>Popping things into the global namespace is an invitation to problems because there is now way to be sure that the function named X you're calling from the global space is the X you want - lots of different modules use similar function names and without namespaces you can't be sure you're getting what you want. It's like <em>voluntarily</em> embracing Javascript style global bugs.  </p>
<p>It sounds like you're calling the scripts mel-style with strings?  Don't.  In python you want to use 'import' to initialize modules and make them available, and it's fine to import the same module multiple times in multiple places.  You want to do it without the * so you keep things in predictable order: This is fine python but would be impossible with * imports:</p>
<pre><code> import legs
 import arms

 legs.rig(cmds.ls("*leg"))
 arms.rig(cmds.ls("*arm"))
</code></pre>
<p>As for calling the functions in GUI, the global namespace only matters if you're trying to call the function with strings. Pass in the python functions directly as functions:</p>
<pre><code> def example(*args):
     print args

 b = cmds.button("test", c= example) # this could also be "somemodule.example" if you import somemodule
</code></pre>
<p>As long as example is defined at the time you create the button, this works without any global namespace monkeying. It's very common to manage this using a class so that the callback goes to a class function: that makes it really easy to manage what's going on.</p>
<p>BTW, If you need to pass arguments to the gui calls, the cheap way to do this is to use <a href="http://docs.python.org/2.6/library/functools.html" rel="nofollow">functools.partial</a> which is designed for bundling args and callables just this way:</p>
<pre><code>from functools import partial
import my_module 

# somewhere in gui

my_button = cmds.button ("test", c = partial(my_module.my_function, "this works"))
</code></pre>
<p>There's a <a href="http://tech-artists.org/forum/showthread.php?2861-Seeing-root-space-python-instances-from-another-class-instance" rel="nofollow">bunch of discussion</a> on this problem over at <a href="http://tech-artists.org/forum/showthread.php?3292-maya-python-UI-acessing-controls-from-external-functions" rel="nofollow">Tech-Artists.org</a></p>
</div>
<span class="comment-copy">Don't "source" pyc files if such can be avoided. Consider them an artifact of a particular implementation.</span>
<span class="comment-copy">didn't get that... sorry ..</span>
<span class="comment-copy">You can pass exec the local scope with the locals and globals parameters.</span>
<span class="comment-copy">That's what I thought - and it confirms my theory, but I still think you shouldn't need <code>exec</code> to import modules. That's why I pointed out another way to do it.</span>
<span class="comment-copy">can <code>__init__.py</code> be a <code>__init__.pyc</code> as well? its the same file as my script.pyc just rename it yea?</span>
<span class="comment-copy">It can be <code>__init__.pyc</code> as well, it is however meant to do initialization of stuff in your module. You don't need this functionality here. Just create an empty Python file, leave the scrypt the way it is and you're good to go.</span>
<span class="comment-copy">OK, I cant use <code>from ... import *</code> as it gives this error: <code>import * only allowed at module level</code>,Thats why i used the exec option, as it allowed me to run it, ill try the <code>__init__</code> way . hope it works.. brb</span>
