<div class="post-text" itemprop="text">
<p>I am playing with concurrent.futures.ThreadPoolExecutor to see if I can squeeze more work out of my quad-core processor (with 8 logical cores). So I wrote the following code:</p>
<pre><code>from concurrent import futures

def square(n):
    return n**2

def threadWorker(t):
    n, d = t
    if n not in d:
        d[n] = square(n)

def master(n, numthreads):
    d = {}
    with futures.ThreadPoolExecutor(max_workers=numthreads) as e:
        for i in e.map(threadWorker, ((i, d) for i in range(n))):
            pass  # done so that it actually fetches each result. threadWorker has its own side-effects on d
    return len(d)

if __name__ == "__main__":
    print('starting')
    print(master(10**6, 6))
    print('done')
</code></pre>
<p>The interesting thing is that the same functionality, when written in a for-loop takes about a second:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for i in range(10**6):
...     if i not in d: d[i] = i**2
</code></pre>
<p>... while the threadpool code takes well over 10 seconds. Now I know that it's using at least 4 threads because I see the processor load on each of my cores. But even with shared memory (I can understand why processes might take a while, due to memory copying), I feel that this disparity in runtime is far too huge.</p>
<p>Does anyone have any ideas as to why this might take so long? It seems that a simple squaring operation, which is indeed highly parallelizable, should really not take so long. Could it perhaps be due to the population of the dictionary (if so, what is causing the slowdown there?)?</p>
<p><strong>Technical details</strong>:</p>
<ul>
<li>Python 3.3.3</li>
<li>quad-core (8 logical cores with hypertheading) CPU</li>
<li>MAC OSX 10.9.1 (Mavericks)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I've not yet tried futures, but I believe it's thread-based, so this probably applies:
<a href="http://www.youtube.com/watch?v=ph374fJqFPE" rel="nofollow">http://www.youtube.com/watch?v=ph374fJqFPE</a></p>
<p>In short, I/O bound workloads thread well in CPython, but CPU-bound workloads do not.  And if you mix I/O bound and CPU-bound threads in the same process, that doesn't thread well either.</p>
<p>If that's the problem, I'd suggest increasing the size of your work chunks (just squaring a number is pretty small), and using <a href="http://docs.python.org/2/library/multiprocessing.html" rel="nofollow">multiprocessing</a>.  Multiprocessing is thread-like, but it uses multiple processes with shared memory, and tends to give looser coupling between program components than threading anyway.</p>
<p>That, or switch to Jython or IronPython; these reputedly thread well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're using async threads to try and make CPU-bound work concurrent?  I wouldn't recommend it.  Use processes instead, otherwise the GIL will slow things down more and more as the size of your thread pool increases.</p>
<p>[Edit 1] </p>
<p>Similar question with references to the GIL explanation from David Beazly (sp?).  </p>
<p><a href="https://stackoverflow.com/q/6821477/86263">Python code performance decreases with threading</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python has the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow">global interpreter lock</a> which doesn't let execute Python code of the same process in different threads simultaneously.
To achieve true parallel execution you have to use multiple processes (easy to switch to <a href="http://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow"><code>ProcessPoolExecutor</code></a>) or native (non-Python, e.g. C) code.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Threads have overhead</h3>
<p>Contrary to other answers, I'll claim that the main culprit here isn't the GIL (though that is an issue) but rather the overhead to using threads.</p>
<p>The overhead to spawning and switching between system level threads is small (less than 1ms) but still likely overwhelms the cost of squaring a single integer.  Ideally you want to break your computation into larger pieces (perhaps square one million integers) when using parallelism of any sort.</p>
<h3>Bypass the GIL</h3>
<p>You can bypass the GIL if you use the numeric Python stack (NumPy/Pandas/C/Fortran/Cython/Numba).  For example the following function would square an array of numbers and release the GIL.</p>
<pre><code>import numpy as np
x = np.array(my_list)

import numba

@numba.jit(nogil=True)
def square(x):
    for i in range(len(x)):
        x[i] = x[i]**2
    return x
</code></pre>
<p>Or alternatively most numpy operations release the GIL</p>
<pre><code>x = x**2
</code></pre>
<h3>Memory bottleneck</h3>
<p>No system will be able to use multiple cores while just squaring integers.  Your CPUs are able to square integers far faster than your memory hierarchy is able to deliver them.</p>
</div>
<span class="comment-copy">two comments: 1) threading won't help performance here because GIL, as the answers below state; 2) interprocess communication isn't cheap (and can get <i>really</i> complicated).  It is instead best to write your workers to <i>completely avoid</i> shared state - instead of passing around a <code>dict</code> that they're all writing to, just have each return a <code>dict</code>.  Or something along those lines.</span>
<span class="comment-copy">I understand that multiprocessing has a queue, which is shared memory among processes. Is there a structure that works like queue, but is a dictionary instead?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/6832554/python-multiprocessing-how-do-i-share-a-dict-among-multiple-processes" title="python multiprocessing how do i share a dict among multiple processes">stackoverflow.com/questions/6832554/â€¦</a></span>
<span class="comment-copy">ProcessPoolExecutor takes very long as well. I had to manually kill after about 10 seconds</span>
<span class="comment-copy">Oh, @inspectorG4dget... I think you're doing it wrong. I'm pretty sure this <code>map</code> must not have side effects. Do you realize that you're copying this dictionary between processes every single time? No wonder it's slower...</span>
<span class="comment-copy">D'Oh! I keep forgetting that XD</span>
