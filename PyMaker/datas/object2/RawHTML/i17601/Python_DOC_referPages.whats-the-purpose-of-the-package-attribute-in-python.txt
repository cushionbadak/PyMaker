<div class="post-text" itemprop="text">
<p>All I want to know is <strong>what exactly does <code>__package__</code> mean</strong>? Didn't find any explanation in the official doc, even on SO.</p>
<p>If you could provide some examples I would be very happy.</p>
</div>
<div class="post-text" itemprop="text">
<p>See the <a href="http://www.python.org/dev/peps/pep-0366/" rel="noreferrer">PEP 366</a> and <a href="http://docs.python.org/3/reference/import.html" rel="noreferrer">import system reference documentation</a>:</p>
<blockquote>
<p>The major proposed change is the introduction of a new module level attribute, <code>__package__</code>. When it is present, relative imports will be based on this attribute rather than the module <code>__name__</code> attribute.</p>
</blockquote>
<p>and</p>
<blockquote>
<ul>
<li>The module’s <code>__package__</code> attribute should be set. Its value must be a string, but it can be the same value as its <code>__name__</code>. If the attribute is set to <code>None</code> or is missing, the import system will fill it in with a more appropriate value. When the module is a package, its <code>__package__</code> value should be set to its <code>__name__</code>. When the module is not a package, <code>__package__</code> should be set to the empty string for top-level modules, or for submodules, to the parent package’s name. See <a href="http://www.python.org/dev/peps/pep-0366/" rel="noreferrer">PEP 366</a> for further details.</li>
</ul>
</blockquote>
<p>So, for a module located in <code>foo/bar/baz.py</code>, <code>__name__</code> is set to <code>foo.bar.baz</code>, and <code>__package__</code> is set to <code>foo.bar</code>, while <code>foo/bar/__init__.py</code> will have <code>foo.bar</code> for both the <code>__name__</code> and <code>__package__</code> attributes.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>All I want to know is what exactly does <code>__package__</code> mean</h2>
</blockquote>
<p>It is the mechanism that enables explicit relative imports.</p>
<p>There are three possible categories of values for <code>__package__</code></p>
<ul>
<li>A package name (a string)</li>
<li>An empty string</li>
<li>None</li>
</ul>
<h3>Package Name</h3>
<p>That is, if a module is in a package, <code>__package__</code> is set to the package name to enable explicit relative imports. <a href="https://docs.python.org/3/reference/import.html#__package__" rel="noreferrer">Specifically:</a></p>
<blockquote>
<p>When the module is a package, its <code>__package__</code> value should be set to its <code>__name__</code>. When the module is not a package, <code>__package__</code> should be set [...] for submodules, to the parent package’s name.</p>
</blockquote>
<h3>Empty String</h3>
<p>If a module is at root, or top-level, that is, the current module is imported with</p>
<pre><code>import current_module
</code></pre>
<p>or when a top-level module is run as the entry point as with:</p>
<pre><code>$ python -m current_module
</code></pre>
<p>then <code>__package__</code> is an empty string. Or as the <a href="https://docs.python.org/3/reference/import.html#__package__" rel="noreferrer">documentation says</a>:</p>
<blockquote>
<p>When the module is not a package, <code>__package__</code> should be set to the empty string for top-level modules...</p>
</blockquote>
<h3>None</h3>
<p>If a module/script is run by filename, <a href="https://www.python.org/dev/peps/pep-0366/" rel="noreferrer"><code>__package__</code> is None</a>:</p>
<blockquote>
<p>When the main module is specified by its filename, then the <code>__package__</code> attribute will be set to None.</p>
</blockquote>
<h2>Evidence</h2>
<p>First, let's create a file structure with noisy debugging - using Python 3.6:</p>
<pre><code>text = "print(f'{__name__}, __file__: {__file__}, __package__: {repr(__package__)}')"

from pathlib import Path
Path('foo.py').write_text(text)
Path('package').mkdir()
Path('package/__init__.py').write_text(text)
Path('package/__main__.py').write_text(text)
Path('package/bar.py').write_text(text)

# and include a submodule with a relative import:
Path('package/baz.py').write_text(text + '\nfrom . import bar')
</code></pre>
<p>Now we see that foo.py executed as a module has an empty string for <code>__package__</code>, while the script executed by file name as the entry point has <code>None</code>:</p>
<pre><code>$ python -m foo
__main__, __file__: ~\foo.py, __package__: ''
$ python foo.py
__main__, __file__: foo.py, __package__: None
</code></pre>
<p>When we execute a package as a module for the entry point, its <code>__init__.py</code> module runs, then its <code>__main__.py</code> runs:</p>
<pre><code>$ python -m package
package, __file__: ~\package\__init__.py, __package__: 'package'
__main__, __file__: ~\package\__main__.py, __package__: 'package'
</code></pre>
<p>Similarly, when we execute a submodule as a module for the entry point, the <code>__init__.py</code> module runs, then it runs:</p>
<pre><code>$ python -m package.bar
package, __file__: ~\package\__init__.py, __package__: 'package'
__main__, __file__: ~\package\bar.py, __package__: 'package'
</code></pre>
<p>Finally, we see that the explicit relative import, the entire reason for having <code>__package__</code>, (which happens last here) is enabled:</p>
<pre><code>$ python -m package.baz
package, __file__: ~\package\__init__.py, __package__: 'package'
__main__, __file__: ~\package\baz.py, __package__: 'package'
package.bar, __file__: ~\package\bar.py, __package__: 'package'
</code></pre>
<p><sub>Note, in the output, I have substituted <code>~</code> for the parent directories.</sub></p>
</div>
<span class="comment-copy">Martijn, than you for your answer, but would you mind to give an example of the problem when the <code>__package__</code> attribute is really usefull?</span>
<span class="comment-copy">@Andrei: the PEP I link to addresses this specifically, but it allows you to detect when a module file in a package is executed directly (with <code>python /modulename.py</code>) and adjust for that situation.</span>
<span class="comment-copy">I was reading PEP but didn't quite understand how it would be used, mainly because the default behavior of the  <code>__name__.rpartition('.')[0]</code> line is not entirely clear to me, just as the interaction of the <code>__name__</code> and <code>__package__</code> attributes and the base paths used for importing module from other folders within project. In fact I have a module accessing behavior from the main entry point I am happy about and that I don't want to break but I would also like to use modules deeper in the folder tree as primary access points for some applications, which I currently have trouble with.</span>
<span class="comment-copy">The <code>str.rpartition()</code> call splits on the last <code>.</code> and returns the first half; so <code>foo.bar.baz.eggs</code> splits off to <code>foo.bar.baz</code>. The rest is too broad to go into in comments.</span>
