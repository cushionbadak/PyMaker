<div class="post-text" itemprop="text">
<p>The problem I am tackle with is to find the first occurrence node in its inorder traversal in a BST. 
The code I have is given below</p>
<pre><code>def Inorder_search_recursive(node,key):
    if not node:
        return None
    InOrder_search_recursive(node.lChild)
    if node.value==key:
        return node
    InOrder_search_recursive(node.rChild)
</code></pre>
<p>This code always return None, what's wrong with it. I think I've return node when I find a node with value k. Why cannot python pass this node???Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>When you call yourself recursively, like this:</p>
<pre><code>InOrder_search_recursive(node.lChild)
</code></pre>
<p>That's just a normal function call, like any other. It just calls the function and gets back a result. It doesn't automatically <code>return</code> the value from that function, or do anything else.</p>
<p>So, you do the left-subtree search, ignore the results, then go on to check <code>node.value == key</code>, and, if that fails, you do the right-subtree search, again ignore the results, and fall off the end of the function, meaning you return <code>None</code>.</p>
<p>To make this work, you need to <code>return</code> the value you got back. But, of course, only if it's <code>not None</code>. </p>
<p>Also, you forgot to pass the <code>key</code> argument down to the recursive call, so you're just going to get a <code>TypeError</code>. (I'm guessing your real code doesn't have this problem, but since you didn't show us your real code, or a working example, I can't be sureâ€¦)</p>
<p>So:</p>
<pre><code>def Inorder_search_recursive(node, key):
    if not node:
        return None
    result = InOrder_search_recursive(node.lChild, key)
    if result is not None:
        return result
    if node.value==key:
        return node
    return InOrder_search_recursive(node.rChild, key)
</code></pre>
<p>(You don't need the <code>not None</code> check for the right-side search, because if it returns <code>None</code>, we have nothing else to try and are just going to return <code>None</code> anyway.)</p>
</div>
<div class="post-text" itemprop="text">
<p>My other answer gives the novice-friendly solution, but if you want more powerful and concise answer:</p>
<pre><code>def Inorder_search_recursive_all(node, key):
    if not node:
        return
    yield from InOrder_search_recursive(node.lChild, key)
    if node.value==key:
        yield node
    yield from InOrder_search_recursive(node.rChild, key)
</code></pre>
<p>This generates <em>all</em> matches in the tree, in order. And it gives them to you as an iterator, so if you just want the first, you can stop as soon as you find one, with no wasted work:</p>
<pre><code>def Inorder_search_recursive(node, key):
    return next(Inorder_search_recursive_all(node, key), None)
</code></pre>
<p>The tutorial section on <a href="http://docs.python.org/3/tutorial/classes.html#iterators" rel="nofollow">Iterators</a> and the following section on Generators explains most of how this works. The only missing bit is an explanation of <code>yield from</code>, which is explained in <a href="http://www.python.org/dev/peps/pep-0380/" rel="nofollow">PEP 380</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since your problem is <code>to find the first occurrence node in its inorder traversal</code>, you should 1) traverse the tree in-order and 2) stop when you find the first occurrence.</p>
<pre><code>def search(node, key):
    if node is None:
        return None
    # Search the left subtree and return early if key is found
    n = search(node.lChild, key)
    if n is not None:
        return n
    # Check middle and return early if key is found
    if node.value == key:
        return node
    # Search right subtree
    return search(node.rChild, key)
</code></pre>
</div>
<span class="comment-copy">If this is a binary search tree, you'll probably get much better results with an actual binary search instead of a sequential search.</span>
<span class="comment-copy">Yes you are right, I just figured it out, we could first locate that value with value key first. We could use BST's property to save a lot of time. And then search its left-subtree. And return immediately if its left-subtree has a node with value key as well.</span>
