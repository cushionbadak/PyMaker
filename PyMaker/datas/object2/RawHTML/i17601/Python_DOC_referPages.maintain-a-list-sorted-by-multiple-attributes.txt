<div class="post-text" itemprop="text">
<pre><code>ss = [(0,'bb','jj'), (1,'aa','mm'), (2,'aa','kk'),(3,'bb','ee'),(4,'gg','ff')]

for x in ss:
    pp = &lt;somthing&gt;
</code></pre>
<p>Using Python, is it possible to insert from ss into pp and maintain pp sorted by two attributes, let's say by the
2nd then 3rd position in order to have the following result (both attributes ascending):</p>
<pre><code>pp = [(2, 'aa', 'kk'), (1, 'aa', 'mm'), (3, 'bb', 'ee'), (0, 'bb', 'jj'), (4, 'gg', 'ff')]
</code></pre>
<p>Or (both attributes descending):</p>
<pre><code>pp = [(4, 'gg', 'ff'), (0, 'bb', 'jj'), (3, 'bb', 'ee'), (1, 'aa', 'mm'), (2, 'aa', 'kk')]
</code></pre>
<p>I don't want to use the following two statments after the loop which already do the job:</p>
<pre><code>pp = sorted(ss, key = operator.itemgetter(1, 2))
pp = sorted(ss, key = operator.itemgetter(1, 2), reverse=True)
</code></pre>
<p>Because i am dealing with a very long list and i already have the loop which i want to reuse for sorting as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use binary search during every insertion.</p>
<pre><code>ss = [(0,'bb','jj'), (1,'aa','mm'), (2,'aa','kk'),(3,'bb','ee'),(4,'gg','ff')]

l = []

def insert_sort(l, e, compare):
    lo = 0
    hi = len(l)
    while lo &lt; hi:
        mid = (lo+hi) / 2
        if compare(e, l[mid]):
            lo = mid + 1
        else: 
            hi = mid
    l.insert(lo, e)

ascend_list = []
descend_list = []

for i in ss:
    insert_sort(ascend_list, i, lambda x, y: x[1:] &gt;= y[1:])

for i in ss:
    insert_sort(descend_list, i, lambda x, y: x[1:] &lt; y[1:])

print ascend_list
print descend_list
</code></pre>
</div>
<span class="comment-copy">Take a look at the <a href="http://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">bisect</a> module.</span>
<span class="comment-copy">Append the new elements to <code>pp</code> in your loop (or just write <code>pp.extend(ss)</code>), then call <code>pp.sort</code> with the same arguments as the calls to <code>sorted</code> that you don't want to do. Thank to Timsort, this is the efficient way to maintain a sorted list in Python.</span>
<span class="comment-copy">Hmm, just realised that you don't keep the original contents of <code>pp</code>. Then ignore the part about <code>extend</code>. I don't understand why you wouldn't want to use the <code>sorted</code> lines. Regardless of the size of the list, <code>sorted</code> is an efficient way to create a sorted copy of it. You will <i>not</i> get better performance by repeatedly inserting each element into its correct place. That's called "insertion sort", and if it was a good sorting algorithm then <code>sorted</code> would probably use it. For large lists it isn't good.</span>
<span class="comment-copy">I would use a priority queue implemented with <code>heapq</code> module functions. But it would require extra work because your sort criterion ain't trivial. Take a look at this: <a href="http://docs.python.org/2/library/heapq.html#priority-queue-implementation-notes" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a></span>
<span class="comment-copy">@falsetru Thanks for suggestion.</span>
