<div class="post-text" itemprop="text">
<p>For example, if I give a string <code>'aaaaaabbbbcccc'</code> and <code>n = 2</code>, it should return <code>[('a',6),('b',4)]</code>. I have tried it in this way:</p>
<pre><code>def top_chars(word, n):
    list1=list(word)
    list3=[]
    list2=[]
    list4=[]
    set1=set(list1)
    list2=list(set1)
    def count(item):
        count=1
        for x in word:
            if x in word:
               count+=item.count(x)
               list3.append(count)
               return count
    list2.sort(key=count)
    list3.sort()
    list4=list(zip(list2,list3))
    list4.reverse()
    list4.sort(key=lambda list4: ((-list4[1]),(list4[0])), reverse=True)
    return list4[0:n]
</code></pre>
<p>But for <code>top_chars ("app", 1)</code> it was returning the output <code>[('p', 1)]</code>, in which the count is wrong.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you want to do this without using <a href="http://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>, let’s go through your code for a bit first:</p>
<pre><code>list1=list(word)
set1=set(list1)
list2=list(set1)
</code></pre>
<p>Apart from the very non-descriptive names (which you should avoid), you can essentially compact that to <code>characters = list(set(word))</code> to get a list of all characters in the word without duplicates. As <code>word</code> is a string, calling <code>set()</code> on it will automatically iterate the string character by character.</p>
<p>Next, in your <code>count</code> function you check <code>if x in word</code> although you are explicitely interating over the <code>x in word</code>. So whatever <code>x</code> will be, it will always be in <code>word</code>. So you can leave that check out. And then, when you actually increase the count, you increment it by the occurences of <code>x</code>—which are all characters in the original word—inside of the passed <code>item</code>. As you use the function as a sortkey for the list of (unique) characters of the word, you will essentially count the occurences of <em>every character</em> of the word in the single-character string which represents the current unique character. So with both <code>item</code> and <code>x</code> being a single character, you actually increment the <code>count</code> by one, if <code>x == item</code>—albeit in a very weird way. And next—still within the loop over the original characters—you append that count to <code>list3</code> and return the count.</p>
<p>So what happened so far? You looked at the <em>very first character</em> of <code>word</code> and checked if <code>item</code> equals the character. If that’s the case, you increment <code>count</code> from <code>1</code> to <code>2</code>, otherwise you leave it at <code>1</code>. And then you just keep that <code>count</code> and return from the function. As such, you never actually look at the other characters of the word, which explains why your count is always 1 or 2.</p>
<p>If you kept the loop running, and only returned (and appended the count) afterwards then it works correctly (i.e. remove two indentation levels from those two lines). However, as you start with <code>count = 1</code>, you’re always one too many, so you should start at 0.</p>
<p>Moving on, you now sort both <code>list2</code> and <code>list3</code> so by the same values so they line up. By construction of the lists, this luckily works, but it still is somewhat weird. You then zip the <em>sorted</em> lists up and reverse the order. And then you do something which I don’t really understand: You take the list which is already reverse-sorted by the character count, and sort it <em>reversed</em> by the <em>negative</em> count. Reverse-sorting the negative count is essentially normal-sorting by the positive count; so you sort it ascending. This will give you the inverse result of what you want, and isn’t actually necessary either, as the list is already sorted after being zipped.</p>
<p>Anyway, there is quite a lot to improve with your code. First of all, even if you are not using a counter, you should still use a dictionary to store the counts. I assume that you may not use a <code>defaultdict</code> either, so we’ll just build the functionality on our own. Instead of creating a list of all the characters in the word and then counting how often that character occurs in the word, we will just loop <em>once</em> through the word and keep note of every character we see:</p>
<pre><code>counts = {}
for character in word:
    # if we haven’t seen the character yet, we need to
    # initialize it in our dictionary first (this is
    # essentially what defaultdict does)
    if character not in counts:
        counts[character] = 0

    # we have seen `character` once more, so increment count
    counts[character] += 1
</code></pre>
<p>This is already all we need to do to actually <em>count</em> the characters. For that example word, we would now get this as our dictionary: <code>{'b': 4, 'c': 4, 'a': 6}</code>.</p>
<p>So now, we just need to find the <code>n</code> biggest elements from there. Your <code>zip</code> idea was actually quite good for this; so let’s create a list of tuples from the dict which we can then sort:</p>
<pre><code>countsList = list(counts.items())

# sort the list in reverse by the second element
countsList.sort(key=lambda x: (x[1], x[0]), reverse=True)
</code></pre>
<p>And now we already have our final list ready, which we then can get the first <code>n</code> elements from to get our result, <code>[('a', 6), ('c', 4)]</code>.</p>
<p>In total, this is what our function looks like:</p>
<pre><code>def top_words (word, n):
    counts = {}
    for character in word:
        if character not in counts:
            counts[character] = 0
        counts[character] += 1

    countsList = list(counts.items())
    countsList.sort(key=lambda x: (x[1], x[0]), reverse=True)
    return countsList[:n]
</code></pre>
<p>Used like this, and compared to <code>collections.Counter</code>:</p>
<pre><code>&gt;&gt;&gt; top_words('aaaaaabbbbcccc', 2)
[('a', 6), ('c', 4)]
&gt;&gt;&gt; top_words('app', 1)
[('p', 2)]

&gt;&gt;&gt; Counter('aaaaaabbbbcccc').most_common(2)
[('a', 6), ('b', 4)]
&gt;&gt;&gt; Counter('app').most_common(1)
[('p', 2)]
</code></pre>
</div>
<span class="comment-copy">Please add a tag for the language you're using. "generating" is not very helpful.</span>
