<div class="post-text" itemprop="text">
<pre><code>total = sum([float(item) for item in s.split(",")])


total = sum(float(item) for item in s.split(","))
</code></pre>
<p>Source: <a href="https://stackoverflow.com/a/21212727/1825083">https://stackoverflow.com/a/21212727/1825083</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The first one uses a <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> to build a list of all of the float values.</p>
<p>The second one uses a <a href="http://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow">generator expression</a> to build a generator that only builds each float value as requested, one a time. This saves a lot of memory when the list would be very large.</p>
<p>The generator expression may also be either faster (because it allows work to be pipelined, and avoids memory allocation times) or slower (because it adds a bit of overhead), but that's usually not a good reason to choose between them. Just follow this simple rule of thumb:</p>
<p>If you need a list (or, more likely, just something you can store, loop over multiple times, print out, etc.), build a list. If you just need to loop over the values, don't build a list.</p>
<p>In this case, obviously, you don't need a list, so leave the square brackets off.</p>
<hr/>
<p>In Python 2.x, there are some other minor differences; in 3.x, a list comprehension is actually defined as just calling the <code>list</code> function on a generator expression. (Although there is a minor bug in at least 3.0-3.3 which you will only find if you go looking for it very hardâ€¦)</p>
</div>
<div class="post-text" itemprop="text">
<p>The first one makes a list while the second one is a generator expression. Try them without the <code>sum()</code> function call.</p>
<pre><code>In [25]: [float(a) for a in s.split(',')]
Out[25]: [1.23, 2.4, 3.123]

In [26]: (float(a) for a in s.split(','))
Out[26]: &lt;generator object &lt;genexpr&gt; at 0x0698EF08&gt;

In [27]: m = (float(a) for a in s.split(','))

In [28]: next(m)
Out[28]: 1.23

In [29]: next(m)
Out[29]: 2.4

In [30]: next(m)
Out[30]: 3.123
</code></pre>
<p>So, the first expression creates the whole list in memory first and then computes the sum whereas the second one just gets the next item in the expression and adds it to its current total. (More memory efficient)</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have said, the first creates a list, while the second creates a generator that generates all the values. The reason you might care about this is that creating the list puts all the elements into memory at once, whereas with the generator, you can process them as they are generated without having to store them all, which might matter for very large amounts of data.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first one creates a list, and the sums the numbers in the list. It is a list comprehension inside a sum</p>
<p>The second one computes each item in turn and adds it to a running total, and returns that running total as the sum, when all items are exhausted. This is a generator comprehension.<br/>
It does not create a list at all, which means that it doesn't take extra time to allocate memory for a list and populate it. This also means that it has a better space complexity, as it only uses constant space (for the call to <code>float</code>; aside from the call to <code>split</code>, which both line do)</p>
</div>
<span class="comment-copy">I don't know if it's worth mentioning in an answer <code>str.join</code> and the handful of other functions that will accept an iterator, but immediately call <code>list()</code> on it. So I'll just mention it here in a comment.</span>
<span class="comment-copy">Curious about the bug now. :P</span>
<span class="comment-copy">@SukritKalra: I'll give you a hint: Try calling functions that <code>raising StopIteration</code> and <code>raise GeneratorExit</code> from various places in the comprehension.</span>
<span class="comment-copy">@SukritKalra: If you give up, see <a href="http://stupidpythonideas.blogspot.com/2013/06/can-you-optimize-listgenexp.html" rel="nofollow noreferrer">this blog post</a>. I'm not 100% sure the example I gave there is the only difference; I'm am pretty sure that the patch suggested at the end eliminates not only that difference, but any other undiscovered differences. (My goal, by the way, was to experiment with a peephole optimizer for code that makes sequences directly out of genexprs, and I got sidetracked.)</span>
<span class="comment-copy">Thanks! This will make a good read. :)</span>
