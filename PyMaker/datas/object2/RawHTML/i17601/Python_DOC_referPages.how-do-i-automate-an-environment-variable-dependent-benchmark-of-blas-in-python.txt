<div class="post-text" itemprop="text">
<p>I need some help in figuring out how to automate a benchmark effort in python.  </p>
<p>I'm testing the effects of threading on a BLAS library calls through numpy in python.  In a linux environment, threading in OpenBLAS is controlled through the environment variable <code>OMP_NUM_THREADS</code>.  I want to do a test where I increment <code>OMP_NUM_THREADS</code> from 1 to a max value, time a routine at each thread count, and then finally manipulate the aggregate timing for all thread counts. </p>
<p>The issue is the following.  Environment variables can be set in python, but they only affect subprocesses or subshells.  So I can correctly run my benchmark with the following driver code:</p>
<pre><code>#!/usr/bin/env python                                                                                                     # driver script for thread test
import os

thread_set =[1,2,4,8,16]
for thread in thread_set:

    os.environ['OMP_NUM_THREADS']='{:d}'.format(thread)
    os.system("echo $OMP_NUM_THREADS")
    os.system("numpy_test")
</code></pre>
<p>and numpy_test script:</p>
<pre><code>#!/usr/bin/env python
#timing test for numpy dot product (using OpenBLAS)                                                      
#based on http://stackoverflow.com/questions/11443302/compiling-numpy-with-openblas-integration
import sys
import timeit

setup = "import numpy; x = numpy.random.random((1000,1000))"
count = 5

t = timeit.Timer("numpy.dot(x, x.T)", setup=setup)
dot_time = t.timeit(count)/count
print("dot: {:7.3g} sec".format(dot_time))
</code></pre>
<p>but analyzing this is a very manual process.  </p>
<p>In particular, I can't return the value <code>dot_time</code> from <code>numpy_test</code> up to my outer wrapper routine, so I can't analyze the results of my test in any automated fashion.  As an example, I'd like to plot <code>dot_time</code> vs number of threads, or evaluate whether <code>dot_time</code>/number of threads is constant.  </p>
<p>If I try to do a similar test entirely within a python instance by defining a python test function (avoiding the <code>os.system()</code> approach above), and then running the test function within the <code>thread in thread_set</code> loop, then all instances of the test function inherit the same value for <code>OMP_NUM_THREADS</code> (that of the parent python shell).  So this test fails:</p>
<pre><code>#!/usr/bin/env python
#attempt at testing threads that doesn't work
#(always uses inherited value of OMP_NUM_THREADS)
import os

import sys
import timeit

def test_numpy():
    setup = "import numpy; x = numpy.random.random((1000,1000))"
    count = 5

    t = timeit.Timer("numpy.dot(x, x.T)", setup=setup)
    dot_time = t.timeit(count)/count
    print("dot: {:7.3g} sec".format(dot_time))
    return dot_time

thread_set =[1,2,4,8,16]
for thread in thread_set:
    os.environ['OMP_NUM_THREADS']='{:d}'.format(thread)
    os.system("echo $OMP_NUM_THREADS")
    time_to_run = test_numpy()
    print(time_to_run)
</code></pre>
<p>This fails in that every instance of <code>thread</code> takes the same time, as <code>test_numpy()</code> always inherits the value of <code>OMP_NUM_THREADS</code> in the parent environment rather than the value set through <code>os.environ()</code>.  If something like this worked however, it would be trivial to do the analysis I need to do.</p>
<p>In the real test, I'll be running over a few 1000 permutations, so automation is key.  Given that, I'd appreciate an answer to any of these questions:</p>
<ol>
<li><p>How would you return a value (<code>dot_time</code>) from a subprocess like this?  Is there a more elegant solution than reading/writing a file?</p></li>
<li><p>Is there a better way to structure this sort of (environment variable dependent) test?</p></li>
</ol>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like this:</p>
<pre><code>import subprocess

os.environ['OMP_NUM_THREADS'] = '{:d}'.format(thread)
proc = subprocess.Popen(["numpy_test"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
stdout, stderr = proc.communicate()
</code></pre>
<p>Then you'll have the output of the the <code>numpy_test</code> script in stdout. In general I believe <code>subprocess.call</code> and <code>subprocess.Popen</code> are prefered over <code>os.system</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to get the output from the subprocess, use <a href="http://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow">subprocess.check_output</a>, e.g. replace </p>
<pre><code>os.system("numpy_test")
</code></pre>
<p>with</p>
<pre><code>dot_output = subprocess.check_output(["numpy_test"])
dot_time = ... # extract time from dot_output
</code></pre>
</div>
<span class="comment-copy">This works, paired with some string parsing.  A note from doing the implementation: typo in <code>proc.comunicate()</code> should be <code>proc.communicate()</code>.</span>
