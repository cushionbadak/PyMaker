<div class="post-text" itemprop="text">
<p>I need to determine the download or upload speed of a client PC during a FTP using ftp.retrbinary command.  How do I determine the speed in Mbps of each block download?</p>
<pre><code>def download_file(block):
    global sizeWritten
    start_time = time.mktime(time.localtime())
    file.write(block)
    end_time = time.mktime(time.localtime())
    os.system('CLS')
    sizeWritten += len(block)
    percentComplete = sizeWritten / totalSize
    percentComplete = round((percentComplete*100),1)

    # if totalTime != 0:
        # throughput=sizeWritten/totalTime
        # throughput=throughput/(1024*1024)
        # throughput=throughput*8
        # throughput=round(throughput,3)
        # print(throughput, "MBPS")
    print (percentComplete, "% complete")

try:
    file = open('100file.zip', "wb")
    print("File opened")
    ftp.retrbinary("RETR " + '100file.zip' ,download_file)
    print("Download Successful!")
except:
    print("Error")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get the time at which the transfers starts by calling, e.g., <code>datetime.datetime.now()</code> before the transfer.</p>
<p>You can get the time at which the transfer ends by calling it again after the transfer.</p>
<p>If you subtract these, you get the time the download took. If you're using <code>datetime</code> objects, this is a <code>timedelta</code>.</p>
<p>And you can get the number of bytes downloaded or uploaded either by, e.g., <code>stat</code>ing the file after transfer.</p>
<p>So:</p>
<pre><code>bytespersec = bytestransfered / (endtime - starttime).totalseconds()
</code></pre>
<p>If you want to get the speed <em>while the transfer is still ongoing</em>, you can't use the simple "upload a whole file in one go" commands, but almost any FTP library—including the stdlib's <code>ftplib</code>—will have a callback-driven or yield-driven API, or a way to supply your own file-like object, or some other way to "hook" the reading/writing of the local file. So, you can just do this exact same computation each time your hook gets called, using the current time and the total bytes so far (which you can keep track of) instead of at the end.</p>
<p>If you want that, your next question will probably be, "how do I get the % done?" You can ask the server for the file size before download (via your favorite FTP library's wrapper around the <code>SIZE</code> command), and <code>stat</code> the local file before upload, and then each time your hook gets called, you just divide bytes so far by total size. (You may also want to write fallback code for servers that don't handle <code>SIZE</code> by doing a <code>LIST</code> and attempting to parse the two most typical formats. Or your FTP library may already have a way to do that.)</p>
<hr/>
<p>Based on your example code, you've almost got things right, but there's a problem:</p>
<pre><code>def download_file(block):
    global sizeWritten
    start_time = time.mktime(time.localtime())
    file.write(block)
    end_time = time.mktime(time.localtime())
    # ...
</code></pre>
<p>You're just counting the time since the start of writing the current block of data to the disk. If you want time for each chunk, count from the end of one block to the end of the next; if you want average time so far, count from the start of the entire process. Either way, that means you need somewhere to store <code>start_time</code> between calls. Since you're already using a global variable for <code>sizeWritten</code>, you can just do the same here:</p>
<pre><code>def download_file(block):
    global sizeWritten
    global start_time
    file.write(block)
    end_time = time.mktime(time.localtime())
    # ...

try:
    file = open('100file.zip', "wb")
    sizeWritten = 0
    start_time = time.mktime(time.localtime())
</code></pre>
<p>If you want time/block, just add another <code>start_time = time.mktime(time.localtime())</code> at the end of the callback function. If you want <em>both</em>, just create two variables, <code>block_start_time</code> and <code>overall_start_time</code> and only reset <code>block_start_time</code> at the end of the callback function.</p>
<hr/>
<p>As a side note: You never <code>close</code> the file. This means there's no guarantee that the last block of data will ever get flushed to disk. It will <em>usually</em> work (at least with CPython), but occasionally you'll end up with truncated files. Always <code>close</code> anything you <code>open</code>, especially in write mode—or, better yet, use a <code>with</code> statement, as explained in <a href="http://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow">the tutorial</a>.</p>
<p>Also, hiding the details of exceptions makes your code hard to debug, and harder for an end user to use. For example, whether your internet connection is down, the remote file is missing, or you don't have write access to the local file, it's all going to just show up as "Error". At least print the <code>Exception</code> or its <code>repr</code>, like this:</p>
<pre><code>except Exception as e:
    print "Error:", repr(e)
</code></pre>
</div>
<span class="comment-copy">This is the route I have been following thank you!  However, for the callback function I cannot find the places to put the start time and end time.  I assumed that I would put them before and after the file.write(block), however they turn out to be the same value.  Where does the block actually start and finish writing?</span>
<span class="comment-copy">@ChanceB: You need to store the start time for the whole process somewhere outside the callback—an instance attribute, a closure variable, or a global variable. Now that you've edited code into your question, I can edit an example into my answer.</span>
<span class="comment-copy">@abarnert I have the similar question here but I am trying to monitor the upload ftp speed then calculate the average upload speed. I encounter a problem that I do not see the same upload speed as I used other ftp software.</span>
<span class="comment-copy">Based on this answer and other info I found I wrote these python scripts to measure network latency and download/upload bandwidth doing multiiple tests and save results to a csv file, along some stats (max, min, avg, median speeds and standard deviation), that could be used or checked out as an example.  <a href="https://github.com/juanluisbaptiste/network-tests" rel="nofollow noreferrer">github.com/juanluisbaptiste/network-tests</a></span>
