<div class="post-text" itemprop="text">
<p>Is there any performance difference between this:</p>
<pre><code>for item in collection:
    if item == badItem:
        break
    else
        doFunction(item)
</code></pre>
<p>And this:</p>
<pre><code>for item in collection:
    if item == badItem:
        break
    doFunction(item)
</code></pre>
<p>Assume I'm doing this a couple hundred million times so any performance difference will help.</p>
<p>EDIT:
I'm not actually implementing this based off the results of this question, I'm just wondering theoretically what is faster. I'm just curious.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here are dis'es of both versions, side by side:</p>
<pre>
 0 SETUP_LOOP              40 (to 43)      |  0 SETUP_LOOP              40 (to 43)
 3 LOAD_GLOBAL              0 (collection) |  3 LOAD_GLOBAL              0 (collection)
 6 GET_ITER                                |  6 GET_ITER            
 7 FOR_ITER                32 (to 42)      |  7 FOR_ITER                32 (to 42)
10 STORE_FAST               0 (item)       | 10 STORE_FAST               0 (item)
                                           | 
13 LOAD_FAST                0 (item)       | 13 LOAD_FAST                0 (item)
16 LOAD_GLOBAL              1 (badItem)    | 16 LOAD_GLOBAL              1 (badItem)
19 COMPARE_OP               2 (==)         | 19 COMPARE_OP               2 (==)
22 POP_JUMP_IF_FALSE       29              | 22 POP_JUMP_IF_FALSE       29
                                           | 
25 BREAK_LOOP                              | 25 BREAK_LOOP          
26 JUMP_ABSOLUTE            7              | 26 JUMP_FORWARD             0 (to 29)
                                           | 
29 LOAD_GLOBAL              2 (doFunction) | 29 LOAD_GLOBAL              2 (doFunction)
32 LOAD_FAST                0 (item)       | 32 LOAD_FAST                0 (item)
35 CALL_FUNCTION            1              | 35 CALL_FUNCTION            1
38 POP_TOP                                 | 38 POP_TOP             
39 JUMP_ABSOLUTE            7              | 39 JUMP_ABSOLUTE            7
42 POP_BLOCK                               | 42 POP_BLOCK           
43 LOAD_CONST               0 (None)       | 43 LOAD_CONST               0 (None)
46 RETURN_VALUE                            | 46 RETURN_VALUE        
</pre>
<p>As you can see, the only difference is <code>JUMP_ABSOLUTE</code> (with <code>else</code>) vs. <code>JUMP_FORWARD</code> (without it). Since both opcodes are immediately after <code>BREAK_LOOP</code>, they won't run in any case, so both versions are fully equivalent.</p>
<p>That said, an <code>else</code> after a breaking statement (<code>break/continue/return</code>) is usually considered a code smell (and takes an extra useless line).</p>
<p>If you're interested in maximal performance, it might be worth considering <code>.index</code> or <code>itertools.takewhile</code> instead of a plain loop with <code>if</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This sounds like pre-mature optimization: <strong>Don't do it.</strong></p>
<p>You should make your program work correctly before you try to optimize it, if you even have to.</p>
<p>If your finished app turns out to be slower than you need, then <strong>measure, measure, measure</strong>.  Use a profiling tool.  The parts that are slow will probably surprise you.  Don't waste time fixing parts that aren't provably slow.</p>
<p>But back to the first point: <strong>Don't try to optimize a program that isn't feature-complete.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>As Grant Birchmeier said: measure, measure, measure.</p>
<p>On my box using <code>Python 3.3.1 (default, Apr 17 2013, 22:30:32) [GCC 4.7.3] on linux</code> I get these results:</p>
<pre><code>testA 0.7911653139999544
testB 0.7868194140028208
testC 0.7771379340010753
</code></pre>
<p>Using:</p>
<pre><code>collection = [random.randint (1, 10000000) for _ in range (10000000) ]
badItem = 0
collection [5000000] = 0

def doFunction (item): pass

def testA ():
    for item in collection:
        if item == badItem: break
        else: doFunction (item)

def testB ():
    for item in collection:
        if item == badItem: break
        doFunction (item)

def testC ():
    badIndex = collection.index (badItem)
    for item in collection [:badIndex]:
        doFunction (item)
</code></pre>
<p><strong>YMMV.</strong> I am just comparing ints and no real world data. I have no idea how costly is your <code>__eq__</code>, what <code>doFunction</code> does, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/21268488/2069350">Grant's answer</a> has it right: if you're concerned about performance, first get the code running, then <a href="http://docs.python.org/3/library/profile.html" rel="nofollow noreferrer"><strong>measure</strong></a> what needs to be improved, and finally improve that stuff. </p>
<p>For posterity, here are my timing results. The short answer: there's no real difference, even over billions of iterations.</p>
<pre><code>With Else:
min: 0.001327058799944325
max: 0.0037289344766406884
mean: 0.002665085947631951

Without Else:
min: 0.0013189987034252226
max: 0.003550914613782652
mean: 0.002147321588495288
</code></pre>
<p>And the code:</p>
<pre><code>C:\&gt;python
Python 3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; else_version = timeit.repeat('for i in c:\n\tif i == 0: break\n\telse:i += 1','import random;c=[random.randint(0,1) for _ in range(1000000)]', number = 10000, repeat=10)
&gt;&gt;&gt; nelse_version = timeit.repeat('for i in c:\n\tif i == 0: break\n\ti += 1','import random;c=[random.randint(0,1) for _ in range(1000000)]', number = 10000, repeat=10)
&gt;&gt;&gt; min(else_version)
0.001327058799944325
&gt;&gt;&gt; max(else_version)
0.0037289344766406884
&gt;&gt;&gt; sum(else_version)/10
0.002665085947631951
&gt;&gt;&gt;
&gt;&gt;&gt; min(nelse_version)
0.0013189987034252226
&gt;&gt;&gt; max(nelse_version)
0.003550914613782652
&gt;&gt;&gt; sum(nelse_version)/10
0.002147321588495288
&gt;&gt;&gt;
</code></pre>
<hr/>
<p>Whatever the cost of having the <code>else</code> statement might actually be, it's clearly dwarfed by any actual operations you're doing (such as your <code>__eq__</code> implementation, or what your actual <code>doFunction</code> is, or even just other stuff happening on your machine).</p>
</div>
<span class="comment-copy"><a href="http://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">Only one way to find out!</a></span>
<span class="comment-copy">Checkout the <code>timeit</code> module, or <code>iPython</code>'s magic <code>%timeit</code> to work this out yourself.</span>
<span class="comment-copy">try timing yours vs <code>[doFunction(item) for item in collection]</code></span>
<span class="comment-copy">I think the second option is better since it is implied that you want to do an action unless there is a bad item.  I highly doubt an extra word adds any more execution time...</span>
<span class="comment-copy">Worrying about performance differences in minuscle details like these is comparable to worrying about the carbon footprint of the bonfire at your yearly camping trip. Technically it's nonzero, and I suppose there are a few rare cases where it's significant, but by and large there are a million more important contributors in your total carbon footprint, and even after you optimized all those, what's left to optimize is rarely ever worth the effort.</span>
<span class="comment-copy">"and takes an extra useless line"...  As well as an extra level of indentation!</span>
<span class="comment-copy">Although very true in many circumstances, in this specific case there's nothing to measure - both versions generate essentially the same opcode.</span>
<span class="comment-copy">@volcano - He asked directly about performance implications, and that's the part I was focusing on.  I agree with you that useless code is useless.</span>
<span class="comment-copy">@volcano Style is not the same as performance, and the question asked specifically about the latter.</span>
<span class="comment-copy">@thg435 - I agree with you, and that's cool work you did in your answer.  But the very fact that he's comparing these two approaches means he's thinking about optimization way before its needed.</span>
<span class="comment-copy">@volcano - I'm not going to play point-counterpoint with you so you can come up with contrived counterexamples against my generalized non-specific advice.  Good day.</span>
<span class="comment-copy">How did you measure (<code>timeit</code> or something else), for the record? Also, are the differences repeatable or just noise?</span>
<span class="comment-copy"><code>for f in (testA, testB, testC): print (f.__name__, timeit.timeit (f, number = 1) )</code></span>
<span class="comment-copy">That's an awful way to use <code>timeit</code>. Measuring only one run provides zero safeguard against the various kinds of noise. If it takes too long to run thousands of times, make the benchmark smaller (but still representative). If you can't make it smaller, at least run it a few times.</span>
<span class="comment-copy">@delnan Feel free to do so.</span>
