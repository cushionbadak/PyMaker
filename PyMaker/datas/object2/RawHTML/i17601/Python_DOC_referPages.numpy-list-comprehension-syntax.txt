<div class="post-text" itemprop="text">
<p>I'd like to be able to use list comprehension syntax to work with NumPy arrays easily.</p>
<p>For instance, I would like something like the below obviously wrong code to just reproduce the same array.</p>
<pre><code>&gt;&gt;&gt; X = np.random.randn(8,4)
&gt;&gt;&gt; [[X[i,j] for i in X] for j in X[i]]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: arrays used as indices must be of integer (or boolean) type
</code></pre>
<p>What is the easy way to do this, to avoid using <code>range(len(X)</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you should not be using NumPy arrays as lists of lists.</p>
<p>Second, let's forget about NumPy; your listcomp doesn't make any sense in the first place, even for lists of lists.</p>
<p>In the inner comprehension, <code>for i in X</code> is going to iterate over the rows in X. Those rows aren't numbers, they're lists (or, in NumPy, 1D arrays), so <code>X[i]</code> makes no sense whatsoever. You may have wanted <code>i[j]</code> instead.</p>
<p>In the outer comprehension, <code>for j in X[i]</code> has the same problem, but is has an even bigger problem: there is no <code>i</code> value. You have a comprehension looping over each <code>i</code> <em>inside</em> this comprehension.</p>
<p>If you're confused by a comprehension, write it out as an explicit <code>for</code> statement, as explained in the tutorial section on <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">List Comprehensions</a>:</p>
<pre><code>tmp = []
for j in X[i]:
    tmp.append([X[i,j] for i in X])
</code></pre>
<p>… which expands to:</p>
<pre><code>tmp = []
for j in X[i]:
    tmp2 = []
    for i in X:
        tmp2.append(X[i,j])
    tmp.append(tmp2)
</code></pre>
<p>… which should make it obvious what's wrong here.</p>
<hr/>
<p>I think what you wanted was:</p>
<pre><code>[[cell for cell in row] for row in X]
</code></pre>
<p>Again, turn it back into explicit <code>for</code> statements:</p>
<pre><code>tmp = []
for row in X;
    tmp2 = []
    for cell in row:
        tmp2.append(cell)
    tmp.append(tmp2)
</code></pre>
<p>That's obviously right.</p>
<p>Or, if you really want to use indexing (but you don't):</p>
<pre><code>[[X[i][j] for j in range(len(X[i]))] for i in range(len(X))]
</code></pre>
<hr/>
<p>So, back to NumPy. In NumPy terms, that last version is:</p>
<pre><code>[[X[i,j] for j in range(X.shape[1])] for i in range(x.shape[0])]
</code></pre>
<p>… and if you want to go in column-major order instead of row-major, you can (unlike with a list of lists):</p>
<pre><code>[[X[i,j] for i in range(X.shape[0])] for j in range(x.shape[1])]
</code></pre>
<p>… but that will of course transpose the array, which isn't what you wanted to do.</p>
<p>The one thing you <em>can't</em> do is mix up column-major and row-major order in the same expression, because you end up with nonsense.</p>
<hr/>
<p>Of course the <em>right</em> way to make a copy of an array is to use the <code>copy</code> method:</p>
<pre><code>X.copy()
</code></pre>
<p>Just as the right way to transpose an array is:</p>
<pre><code>X.T
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easy way is to not do this. Use numpy's implicit vectorization instead. For example, if you have arrays A and B as follows:</p>
<pre><code>A = numpy.array([[1, 3, 5],
                 [2, 4, 6],
                 [9, 8, 7]])
B = numpy.array([[5, 3, 5],
                 [3, 5, 3],
                 [5, 3, 5]])
</code></pre>
<p>then the following code using list comprehensions:</p>
<pre><code>C = numpy.array([[A[i, j] * B[i, j] for j in xrange(A.shape[1])]
                 for i in xrange(A.shape[0])])
</code></pre>
<p>can be much more easily written as</p>
<pre><code>C = A * B
</code></pre>
<p>It'll also run much faster. Generally, you will produce faster, clearer code if you don't use list comprehensions with numpy than if you do.</p>
<p>If you really want to use list comprehensions, standard Python list-comprehension-writing techniques apply. Iterate over the elements, not the indices:</p>
<pre><code>C = numpy.array([[a*b for a, b in zip(a_row, b_row)]
                 for a_row, b_row in zip(A, B)]
</code></pre>
<p>Thus, your example code would become</p>
<pre><code>numpy.array([[elem for elem in x_row] for x_row in X])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option (though not necessarily performant) is to rethink your problem as a map instead of a comprehension and write a ufunc:</p>
<p><a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html" rel="nofollow">http://docs.scipy.org/doc/numpy/reference/ufuncs.html</a></p>
<p>You can call functional-lite routines like:</p>
<p><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_over_axes.html" rel="nofollow">http://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_over_axes.html</a>
<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html" rel="nofollow">http://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html</a></p>
<p>Etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do you mean following?</p>
<pre><code>&gt;&gt;&gt; [[X[i,j] for j in range(X.shape[1])] for i in range(X.shape[0])]
[[0.62757350000000001, -0.64486080999999995, -0.18372566000000001, 0.78470704000000002],
 [1.78209799, -1.336448459999999 9, -1.3851422200000001, -0.49668994],
 [-0.84148266000000005, 0.18864597999999999, -1.1135151299999999, -0.40225053999999 999],
 [0.93852824999999995, 0.24652238000000001, 1.1481637499999999, -0.70346624999999996],
 [0.83842508000000004, 1.0058 697599999999, -0.91267403000000002, 0.97991269000000003],
 [-1.4265273000000001, -0.73465904999999998, 0.6684284999999999 8, -0.21551155],
 [-1.1115614599999999, -1.0035033200000001, -0.11558254, -0.4339924],
 [1.8771354, -1.0189299199999999, - 0.84754008000000003, -0.35387946999999997]]
</code></pre>
<p>Using <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.copy.html" rel="nofollow"><code>numpy.ndarray.copy</code></a>:</p>
<pre><code>&gt;&gt;&gt; X.copy()
array([[ 0.6275735 , -0.64486081, -0.18372566,  0.78470704],
       [ 1.78209799, -1.33644846, -1.38514222, -0.49668994],
       [-0.84148266,  0.18864598, -1.11351513, -0.40225054],
       [ 0.93852825,  0.24652238,  1.14816375, -0.70346625],
       [ 0.83842508,  1.00586976, -0.91267403,  0.97991269],
       [-1.4265273 , -0.73465905,  0.6684285 , -0.21551155],
       [-1.11156146, -1.00350332, -0.11558254, -0.4339924 ],
       [ 1.8771354 , -1.01892992, -0.84754008, -0.35387947]])
</code></pre>
</div>
<span class="comment-copy">X[i,j] is syntactic sugar for X[i][j] in NumPy</span>
<span class="comment-copy">Don't do this! It defeats the entire purpose of using NumPy.</span>
<span class="comment-copy">And (even if you fix it), this won't reproduce the array, it will produce a list of lists instead.</span>
<span class="comment-copy">X[i,j] is not syntactic sugar. For x[i,j] the value is retrieved directly. x[i][j] get's the i'th row, and then the j'th element of that row. So it takes more time.</span>
<span class="comment-copy">Are you trying to do something with the entries, such as square them? The question might make more sense in that case.</span>
<span class="comment-copy">Note: for efficiency, if you will not use the list any longer, you might want to use <code>np.asarray()</code> instead of <code>np.array()</code>. It's the same function with <code>copy=False</code>.</span>
<span class="comment-copy">@RicardoCruz: It's going to copy either way. <code>asarray</code> can only avoid a copy if the input is already an array.</span>
<span class="comment-copy">@user237112, Oh, thanks for pointing that out. I didn't know that.</span>
<span class="comment-copy">He says he's trying to produce the exact same shape he started with, so it's not even <code>transpose</code>, it's just <code>copy</code>.</span>
<span class="comment-copy">@abarnert, Thank you for comment. I updated the answer.</span>
