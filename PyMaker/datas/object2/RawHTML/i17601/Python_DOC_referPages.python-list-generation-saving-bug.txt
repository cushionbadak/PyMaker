<div class="post-text" itemprop="text">
<p>I am trying to make program that prints all the possible combinations for <code>a</code> to <code>zzz</code>. I tried to add a save state feature, and it works fine but there is this bug.</p>
<p>Let's say I interrupted the program when it printed something like <code>e</code>. When I execute the program again, it works fine until <code>z</code> but after <code>z</code> instead of printing <code>aa</code> it prints <code>ba</code> and continues from <code>ba</code>. This happens right after it prints <code>zz</code> too. it prints <code>baa</code> instead of <code>aaa</code>. How can I fix this?</p>
<p>Here is what I did so far:</p>
<pre><code> import pickle,os,time

 alphabet="abcdefghijklmnopqrstuvwxyz"
 try:
     if os.path.isfile("save.pickle")==True:
         with open("save.pickle","rb") as f:
             tryn=pickle.load(f)
         for i in range(3):
             a=[x for x in alphabet]
             for j in range(i):
                 a=[x+i for x in alphabet for i in a]
             b=a[tryn:]
             for k in b:
                 print(k)
                 time.sleep(0.01)
                 tryn+=1
     else:
         tryn=0
         for i in range(3):
             a=[x for x in alphabet]
             for j in range(i):
                 a=[x+i for x in alphabet for i in a]
             for k in a:
                 print(k)
                 tryn+=1
                 time.sleep(0.01)
 except KeyboardInterrupt:
     with open("save.pickle","wb") as f:
         pickle.dump(tryn,f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using python2, or python3 as the tag suggests, this exists in the standard library already. See itertools, <a href="http://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow">product py2</a>, and <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow">product py3</a>, for a simple way to solve this problem.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>  for i in range(3):
   a=[x for x in alphabet]
   for j in range(i):
    a=[x+i for x in alphabet for i in a]
   b=a[tryn:]
</code></pre>
<p>Here's your bug. You skip the first <code>tryn</code> strings of every length, rather than just the first <code>tryn</code> strings. This would be easier to recognize in the output if it weren't for the following:</p>
<pre><code>   for k in b:
    print(k)
    time.sleep(0.01)
    tryn+=1
</code></pre>
<p>You modify <code>tryn</code>, the number of things you're skipping. When you print out length-2 strings, you skip a number of them equal to the number of length-1 strings. When you print out length-3 strings, you skip a number of them equal to the number of length-2 strings. If <code>tryn</code> were bigger than the number of length-1 strings, you would skip even more.</p>
</div>
<div class="post-text" itemprop="text">
<p>your problem is almost certainly here:</p>
<pre><code>a=[x for x in alphabet]
for j in range(i):
    a=[x+i for x in alphabet for i in a]
</code></pre>
<p>Perhaps you shouldn't assign the in-loop value to a, but instead use a different name? Otherwise, you are changing what you use every time through the loop....</p>
<p>Edit: More detail. So, technically user2357112's answer is more correct, but I'm amending mine. The initial answer was just from a quick reading, so the other answer is close to the original intent. But, the original version is inefficient (for more reasons than not using product :), since you are generating the inner loops more than once. So let's walk through why this is a bad idea, as an educational exercise:</p>
<p>Initial algorithm:</p>
<pre><code>for i in range(n):
    assign a to alphabet
    for j in range(i): 
        i times, we rewrite a to be all combinations of the current set against the alphabet.
</code></pre>
<p>Note that for this algorithm, to generate the length(n) product, we have to generate all previous products length(n-1), length(n-2), ..., length(1). But you aren't saving those.</p>
<p>You'd be better off doing something like this:</p>
<pre><code>sum_list = alphabet[:]
#get a copy
product_list = alphabet[:]
#Are we starting at 0, or 1? In any case, skip the first, since we preloaded it
for i in range(1, n):
    # Your existing list comprehension was equivalent here, and could still be used
    # it MIGHT be faster to do '%s%s'%(x,y) instead of x+y... but maybe not
    # with these short strings
    # This comprehension takes the result of the last iteration, and makes the next iteration
    product_list = [x+y for x,y in product(product_list, alphabet)]
    # So product list is JUST the list for range (n) - i.e. if we are on loop 2, this
    # is aaa...zzz. But you want all lengths together. So, as you go, add these
    # sublists to a main list.
    sum_list.extend(product_list)
</code></pre>
<p>Overall, you are doing a lot less work.</p>
<p>Couple other things:</p>
<ul>
<li>You're using i as a loop variable, then re-using it in the loop comprehension. This is conflicting, and probably not working the way you'd expect.</li>
<li>If this is to learn how to write save/restore type apps... it's not a good one. Note that the restore function is re-calculating every value to be able to get back where it left off - if you could rewrite this algorithm to write more information out to the file (such as the current value of <code>product_list</code>) and make it more generator-like, then it will actually work more like a real-world example.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Here is how I would suggest solving this problem in Python.  I didn't implement the save state feature; this sequence is not a really long one and your computer should be able to produce this sequence pretty fast, so I don't think it is worth the effort to try to make it cleanly interruptable.</p>
<pre><code>import itertools as it

def seq(alphabet, length):
    for c in range(1, length+1):
        for p in it.product(alphabet, repeat=c):
            yield ''.join(p)

alphabet="abcdefghijklmnopqrstuvwxyz"

for x in seq(alphabet, 3):
    print(x)
</code></pre>
<p>If you really wanted to, you could make a one-liner using <code>itertools</code>.  I think this is too hard to read and understand; I prefer the above version.  But this does work and will be somewhat faster, due to the use of <code>itertools.chain</code> and <code>itertools.imap()</code> rather than a Python <code>for</code> loops.</p>
<pre><code>import itertools as it

def seq(alphabet, length):
    return it.imap(''.join, it.chain.from_iterable(it.product(alphabet, repeat=c) for c in range(1, length+1)))

alphabet="abcdefghijklmnopqrstuvwxyz"

for x in seq(alphabet, 3):
    print(x)
</code></pre>
<p>In Python 3.x you could just use <code>map()</code> rather than <code>itertools.imap()</code>.</p>
</div>
<span class="comment-copy">Use deeper indents. 4 spaces is the recommended size. This is very hard to read.</span>
<span class="comment-copy"><code>permutations</code> is the wrong function. <code>product</code> is what you're looking for.</span>
<span class="comment-copy">+1 It's fun to deal with the bare code but we should always remember the standard library has a lot of juice to be squeezed.</span>
<span class="comment-copy">Ah yeah, if you're wanting repeated characters as you'd clearly said that's the function you'd want. With this though you're still going to need one loop to up the desired length of returned combinations.</span>
<span class="comment-copy">i dont think thats the problem since the output is always the same: "ba" even if i interrupted at a OR z. though if you really think this is the problem, can you give me some hints or something?</span>
<span class="comment-copy">@user3220419: That's explained in the second half of the answer. As for hints, skip the first <code>tryn</code> of the complete sequence. You could do this by building one big list of all the strings and then slicing that.</span>
<span class="comment-copy">can you show me a example? i have tried that actually, but it always says that its not defined even if its defined</span>
<span class="comment-copy">Actually, now that I've looked at it more, I think i see what you are trying to do. Try replacing <code>a=[x+i for x...</code> with <code>a.extend([x+i for x...</code> and see if that helps.</span>
<span class="comment-copy">it works, corley! thanks! can you explain what this does though?</span>
<span class="comment-copy">@user3220419: That modification does not do what you think it does. It happened to introduce a bug that partially counteracts your existing bug; you're still skipping the first <code>tryn</code> strings each time around, but now the list has <code>tryn</code> junk elements in front before what you want to print. There are still problems; I believe you'll go through the length-2 strings twice.</span>
<span class="comment-copy">yeah, i think it's still not really correct... it looks like this is sort of a recursive loop which summation. which is fine as an exercise. note that it's also using i as a loop variable (<code>for i in range(3)</code>) and also in the list comprehension, which is conflicting. However, in the interest of explaining the algorithm, i'll add some detail.</span>
