<div class="post-text" itemprop="text">
<p>I have a simple Python (3.3) application in which the processing time between iterations gets longer over each iteration. I believe I've isolated the problem to the <code>bytes()</code> function, as you will see below. The code looks like it would be constant, n-time complexity. However, when run it actually shoots up to about n^2-time. I am providing two blocks of code. The first block is the offending block, which feels something like n^2-time complexity. The second block is a small refactor that removes <code>bytes()</code> from handling the input. Here's the first block:</p>
<pre><code>import hashlib
def gethash(data):
  return hashlib.sha1(data).hexdigest()
body = b"blob 5\01234"

for i in range(1, 100000):
  hashout = gethash(body+bytes(i))
  if(i%1000==0):
    print(".")
</code></pre>
<p>(Linux <code>time</code> utility output for this block): real 0m12.742s - user 0m12.188s - sys 0m0.536s</p>
<p>And here's the second block, refactored to exclude the use of <code>bytes()</code> and which has a constant processing time between iterations (n-time complexity, as seems correct):</p>
<pre><code>import hashlib
def gethash(data):
  return hashlib.sha1(data.encode('utf-8')).hexdigest()
body = "blob 5\01234"

for i in range(1, 100000):
  hashout = gethash(body+str(i))
  if(i%1000==0):
    print(".")
</code></pre>
<p>(Linux <code>time</code> utility output for this block): real 0m0.305s - user 0m0.296s - sys 0m0.008s</p>
<p>I am using Linux Mint 16 (kernel 3.11.0-12-generic on x86_64) with Python 3.3.2. I have simplified this code greatly to be more expressive of the central issue. I primarily use Python 3 and can write somewhat non-trivial applications in Python, but I cannot claim to have a Pythonic mindset. Being mindful of this, I've tried to run both of these code blocks in Python 2.7.5, and they both iterate "normally" for a constant amount of time (n-time complexity). I don't know enough about that version and its functions to know if this is meaningful. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>bytes(i)</code> creates an <code>i</code>-length <code>bytes</code> object full of zeros. See the <a href="http://docs.python.org/3/library/functions.html#bytearray" rel="nofollow"><code>bytearray</code></a> documentation; constructor arguments for <code>bytes</code> are interpreted the same way.</p>
<p>To fix this, encode a string:</p>
<pre><code>  hashout = gethash(body+str(i).encode('utf-8'))
</code></pre>
<p>I've picked UTF-8 because you did, but the proper encoding may depend on the context you want to use it in.</p>
</div>
<span class="comment-copy">So then <code>bytes(3)</code> doesn't do what I think it does, which would be converting integer <code>3</code> into its byte-representation? It initializes a zeroed 3-length list. As you can see in my original question, I already had solved the "problem" in the source, but what then should I use to return a byte-representation of an integer without initializing a huge list?</span>
<span class="comment-copy">@L0j1k: By "byte-representation", do you mean <code>b"3"</code> or <code>b"\x03"</code>? If you want the first thing, the code is in the answer.</span>
