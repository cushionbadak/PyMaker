<div class="post-text" itemprop="text">
<p>I want to compile python code for target 2.7 from a 3.2 script. </p>
<p>Below works fine for compiling. But on execution I obviously get a "Bad magic number error" because compile &amp; target python versions are different.</p>
<pre><code>for fn in os.listdir(source):
    srcfile = ...
    ...
    destfile = ... + ".pyc"
    #print(srcfile, destfile)
    py_compile.compile(srcfile, destfile)   # &lt;-- 
</code></pre>
<p>Is it possible without executing 2.7 python from within 3.2? Is there a way to mention target version?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>The CPython binary can't cross-compile for a different Python version.  You are probably best off by forking out to a Python interpreter with the desired target version and using the <a href="http://docs.python.org/3.3/library/compileall.html" rel="nofollow">compileall</a> module directly from the command-line.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/library/functions.html#compile" rel="nofollow"><code>compile</code></a> function, modules like <a href="http://docs.python.org/3/library/compileall.html" rel="nofollow"><code>compileall</code></a> and <a href="http://docs.python.org/3/library/ast.html" rel="nofollow"><code>ast</code></a>, etc. all just expose the parser and compiler that are baked into each Python version. Python 3.2 doesn't have a compiler for 2.7 code.</p>
<p>And if you were expecting to compile 3.2 code into 2.7 bytecode… that's not even possible, in general, so obviously Python 3.2 can't do it.</p>
<p>You could try to port all of the 2.7 compiler machinery to Python—PyPy would be a good source to start from—and then run that under 3.2. But that's a lot of work just to avoid installing Python 2.7 alongside 3.2.</p>
</div>
<span class="comment-copy">Why do you want to do this?</span>
<span class="comment-copy">Python 2.7 is embedded in a C++ product. But build process exists in 3.2. Now, the python code (2.7) that ships with the product must be compiled so that end users don't easily read/change it. Hope that answers.</span>
<span class="comment-copy">This doesn't answer why you don't want to fork out to Python 2.7.</span>
<span class="comment-copy">How are you building the embedded C++ product without having Python 2.7 already on the build machines?</span>
<span class="comment-copy">@sambha: Where does that <code>python27.dll</code> come for, or the header and config files used to build your embedded app, if not from Python 2.7?</span>
<span class="comment-copy">Forking 2.7 from 3.2 seems to be the only solution.</span>
