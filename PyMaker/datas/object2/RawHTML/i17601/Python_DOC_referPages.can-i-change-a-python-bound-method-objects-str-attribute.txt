<div class="post-text" itemprop="text">
<p>I would like to change the <code>__str__()</code> attribute of one of my class's <strong>methods</strong>.</p>
<p>(Note: Not to be confused with "trying to change the method <code>__str__()</code>".)</p>
<p>I have a class, MyClass, which has a method 'some_method'.  I can change the way MyClass displays itself by:</p>
<pre><code>class MyClass():
    def __init__(self): pass
    def some_method(self): pass
    def __str__(self): return "I'm an instance of MyClass!"
</code></pre>
<p>When I instantiate and print MyClass:</p>
<pre><code>print(my_class)
</code></pre>
<p>I get:</p>
<p><code>I'm an instance of MyClass!</code></p>
<p>When I</p>
<pre><code>print(my_class.some_method)
</code></pre>
<p>I get:</p>
<p><code>&lt;bound method my_class.some_method of &lt;gumble margle object at mumble-jumble&gt;&gt;</code></p>
<p>I would like to see instead:</p>
<p><code>some_method in the instance my_class you Dope!</code></p>
<p>I've tried overriding the <strong>str</strong> method of <code>some_method</code>:</p>
<pre><code>def some_method(self):
    def __str__(self):
        return "You dope!"
</code></pre>
<p>But no love.</p>
<p>Attempting to brute-force it in IPython proved no better:</p>
<pre><code>my_class.some_method.__str__ = lambda: "You Dope!"
</code></pre>
<p>gave</p>
<p><code>AttributeError: 'method' object attribute '__str__' is read-only</code></p>
<p>Is there an easy way to do this programmatically (preferrably in Python 3)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll need to use a custom class instead of a class function:</p>
<pre><code>class CustomFunction(object):
    def __init__(self, name):
        self.name = name

    def __call__(func, self):
        # This is the actual function
        pass

    def __get__(func, instance=None, type_=None):
        class CustomMethod(object):
            def __init__(self, instance, type_):
                self.im_self = instance
                self.im_class = type_
            def __call__(self, *args, **kw):
                return func(self.im_self, *args, **kw)
            def __str__(self):
                return '{} in the instance {} you Dope!'.format(func.name, self.im_self)

        return CustomMethod(instance, type_)
</code></pre>
<p>then use this in your class:</p>
<pre><code>class MyClass():
    def __init__(self): pass

    some_method = CustomFunction('some_method')
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; print MyClass().some_method
some_method in the instance &lt;__main__.MyClass instance at 0x106b5ccb0&gt; you Dope!
</code></pre>
<p>This works because functions are <a href="http://docs.python.org/2/howto/descriptor.html">descriptors</a>; they return methods when their <code>__get__</code> method is called.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just add <code>@toStr("This is %s You Dope! :P")</code> above the method.</p>
<pre><code>class MyClass():
    @toStr("This is %s You Dope! :P")
    def some_method(self):
        print("method is doing something... Here is an attrbute... "+str(self.kk))
    def __str__(self): return "I'm an instance of MyClass!"
    def __init__(self):
        self.some_method.real_self = self
        self.kk = [":D"]
c = MyClass()
print(c)
c.some_method()
print(c.some_method)
</code></pre>
<p>Output:</p>
<pre><code>I'm an instance of MyClass!
method is doing something... Here is an attrbute... [':D']
This is some_method You Dope! :P
</code></pre>
<hr/>
<p>Add the following somewhere above the class (perhaps a separate file) to create the annotation:</p>
<pre><code>def toStr(str):
    def decorator(f):
        class _temp:
            def __call__(self, *args, **kwargs):
                return f(self.real_self, *args, **kwargs)
            def __str__(self):
                return str%f.__name__
        return _temp()
    return decorator
</code></pre>
<hr/>
<p>Note that <code>self.some_method.real_self = self</code> is needed in <code>__init__</code> to ensure that the right <code>self</code> gets passed to the wrapped method.</p>
</div>
<div class="post-text" itemprop="text">
<p>I faced this same problem and I wasn't happy with either of the solutions here.  Martijn's solution using descriptors is the right approach, but it is not as elegant as a solution that provides a decorator (and some of the choices of argument names as well as the structure of his solution is unnecessarily confusing).  Navin's solution is not a good approach as it requires manually setting "real_self"; this is precisely the purpose of descriptors.  Here I wanted to override __repr__ instead of __str__, but that's just a detail, the solution is the same.</p>
<p>Here is my decorator which returns a descriptor solution:</p>
<pre><code>from functools import update_wrapper

# the usual outer function to allow the decorator to accept an argument
def custom_repr(repr_text):
    # the decorator itself
    def method_decorator(method):

        # Wrap the method in our own descriptor.
        class CustomReprDescriptor(object):

            def __get__(self, instance, owner):
                # Return our wrapped method when we call instance.method
                # This class encapsulates the method
                class MethodWrapper(object):
                    # Callable with custom __repr__ method
                    # Capture the instance and owner (type) from the __get__ call
                    def __init__(self):
                        self.im_self = instance
                        self.im_class = owner
                        self.im_func = method

                    # Call the wrapped method using the captured instance
                    def __call__(self, *args, **kwargs):
                        return self.im_func(self.im_self, *args, **kwargs)

                    # Capture the custom __repr__ text from the decorator call
                    def __repr__(self):
                        return repr_text
                # The call to __get__ returns our wrapped method with custom __repr__
                return update_wrapper(MethodWrapper(), method)
        # The decorator returns our custom descriptor
        return CustomReprDescriptor()
    return method_decorator

class TestClass(object):

    @custom_repr("Test of custom repr.")
    def re_repr_method(self):
        print "Called re-repred method."

tc = TestClass
tc.re_repr_method()
print "rc.re_repr_method.__name__ = " + tc.re_repr_method.__name__
print repr(tc.re_repr_method)
</code></pre>
<p>Output:</p>
<pre><code>Called re-repred method.
rc.re_repr_method.__name__ = re_repr_method
Test of custom repr.
</code></pre>
<p>The key to understanding all of this is that when you write a method in a class declaration in python, you are not doing anything special - merely defining a function in the namespace of that class.  However, then some syntactic sugar kicks in (or at least I believe this happens): Python then wraps that method inside a descriptor, which handles calling that function with the instance of the class as the self argument.  So, all we need to do is take this step ourselves; rather than let Python convert our class-level function into a method, just wrap it ourselves in a descriptor whose __get__ method returns a callable whose __call__ method calls the function we want as our method, but which has a __repr__ method of our choosing.</p>
</div>
<span class="comment-copy">Dumb question: do python methods even have attributes?  I for one wasn't aware that a python method is an object ... is it?</span>
<span class="comment-copy">@GreenAsJade: everything's an object. That doesn't mean the language makes it <i>easy</i> set set attributes, though.</span>
<span class="comment-copy">@GreenAsJade As they say, everything is an object. Yes, a bound method is an obect and <a href="http://docs.python.org/3/library/stdtypes.html#methods" rel="nofollow noreferrer">has attributes</a>.</span>
<span class="comment-copy">As for the question, I don't think you can set attributes on bound method objects. You can, however, wrap the function in a descriptor that constructs a custom bound-method-like object (with any methods you want) in place of the built-in bound method type.</span>
<span class="comment-copy">If you want <code>print [x.some_method, x.another_method]</code> to work right, you'll need to override <code>__repr__</code> instead. In that case, I recommend keeping the <code>&lt;&gt;</code> around the string.</span>
<span class="comment-copy">In this case, is "some_method" a class variable of MyClass?</span>
<span class="comment-copy">@GreenAsJade: all regular methods are class attributes too; I just produced a custom one.</span>
<span class="comment-copy">This implementation is weird. It took me quite a while to understand what you were doing with the <code>func</code> and <code>self</code> arguments. I'd find a decorator-based implementation much clearer.</span>
<span class="comment-copy">It'd be great (educational) if you would post an example, @user2357112....</span>
<span class="comment-copy">@Martijn It seems to me it isn't the 1st time I see you writing that <i>"functions are descriptors"</i>. But I don't feel this to be correct. It is true that if <code>foo</code> is a function, <code>hasattr(foo.__class__,'__get__')</code> is True. However, this doesn't make of <code>foo</code> a descriptor because: 1/ a descriptor is an instance of a descriptor-defining class, 2/ this instance must be defined as an attribute in an owner class. Said shortly, a descriptor is an object that can be accessed through a dot notation. So free functions outside any class rigourously aren't descriptors. Do you see things like that or not?</span>
<span class="comment-copy">In <code>f(self, *args, **kwargs)</code> you're actually passing <code>_temp</code>'s instance to <code>f</code>.</span>
<span class="comment-copy">This is definitely looking good.  I like the decorator definition being in another file.  I can hide it in a library away from users.  Is there a way to have the decorator automatically extract the method name, rather than passing it manually to the decorator?</span>
<span class="comment-copy">@JS. Yes, I have modified it to use the method's <code>__name__</code> to generate the string.</span>
<span class="comment-copy">This implementation doesn't work. The method receives the wrong value for <code>self</code>.</span>
<span class="comment-copy">@user2357112 It now used the correct <code>self</code></span>
