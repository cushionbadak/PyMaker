<div class="post-text" itemprop="text">
<p>I run my Python script with</p>
<pre><code>python3.7 -m opencryptobot.START -lvl 20
</code></pre>
<p><code>opencryptobot</code> is a folder here and <code>START</code> is a module. At some point I'd like to restart the script with this code:</p>
<pre><code>os.execl(sys.executable, sys.executable, *sys.argv)
</code></pre>
<p>I use this code because it worked perfectly for my other scripts that I don't execute with the <code>-m</code> argument. So the above code will be executed at some point and then I get this error:</p>
<pre><code>ModuleNotFoundError: No module named 'opencryptobot'
</code></pre>
<p>Which sounds correct since <code>opencryptobot</code> is just a folder and not a module. I played around with various versions of <code>os.exec</code> to see if I’m able to restart it but nothing really works.</p>
<p>So my question is, how can I restart my script if I run it the way I do?</p>
<p>This is a minimal version of my folder structure:</p>
<pre><code>.
├── LICENSE
├── Pipfile
├── Pipfile.lock
├── README.md
├── opencryptobot
│   ├── START.py
│   ├── config.py
│   ├── constants.py
│   ├── database.py
│   ├── emoji.py
│   ├── plugin.py
│   ├── plugins
│   │   ├── about.py
│   │   ├── admin.py
│   │   └── alltimehigh.py
│   ├── ratelimit.py
│   ├── telegrambot.py
│   └── utils.py
└── start.sh
</code></pre>
<p>I execute <code>START</code> from the root folder.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sys.argv</code> does <strong>not</strong> start with <code>-m opencryptobot.START</code>. The module name is removed from the <code>sys.argv</code> list altogether while resolving the <code>opencryptobot.START</code> module filename (<code>sys.argv</code> is set to <code>['-m', '-lvl', '20']</code> until there is a filename) and then <code>'-m'</code> is replaced with the full filename of the module.</p>
<p>From the <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m" rel="nofollow noreferrer"><code>-m</code> switch documentation</a>:</p>
<blockquote>
<p>If this option is given, the first element of <code>sys.argv</code> will be the full path to the module file (while the module file is being located, the first element will be set to <code>"-m"</code>).</p>
</blockquote>
<p>In effect, Python is simulating running a script, as if you ran <code>python /path/to/opencrytobot/START.py ...</code>; only the <code>__package__</code> context is kept so you can still use package-relative imports such as <code>from . import ...</code>.</p>
<p>So to <em>recreate</em> your original command-line, use <code>'-m', __spec__.name, *sys.argv[1:]</code> as the argument list beyond <code>sys.executable</code>:</p>
<pre><code>os.execl(sys.executable, sys.executable, '-m', __spec__.name, *sys.argv[1:])
</code></pre>
<p>You can't use <code>__name__</code>, unfortunately, as that has been set to <code>'__main__'</code> when using <code>-m</code>. However, the <a href="https://docs.python.org/3/reference/import.html#main-spec" rel="nofollow noreferrer"><code>__spec__</code> object set on your module</a> does know what the full qualified name is for the current module, so we can re-use that here.</p>
<p>Note that even though there is no <code>__init__.py</code> file in <code>opencryptobot</code>, by using <code>-m</code> you are telling Python that <code>opencryptobot</code> is really an <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages" rel="nofollow noreferrer">implicit namespace package</a>. If that wasn't the intention here, then <em>don't use <code>-m</code> to load your script</em>.</p>
<p>Demo:</p>
<pre><code>$ ls -1 opencryptobot/
START.py
$ cat opencryptobot/START.py
import sys
import os

if __name__ == '__main__':
    print('Running as the __main__ script')
    print('sys.argv:', sys.argv)
    print('__spec__.name:', __spec__.name)

    if 'restarted' not in sys.argv:
        print('Respawning:')
        # add an extra command-line option to stop respawning a second time
        os.execl(sys.executable, sys.executable, '-m', __spec__.name, *sys.argv[1:], 'restarted')
$ python3.7 -m opencryptobot.START -lvl 20
Running as the __main__ script
sys.argv: ['/.../opencryptobot/START.py', '-lvl', '20']
__spec__.name: opencryptobot.START
Respawning:
Running as the __main__ script
sys.argv: ['/.../opencryptobot/START.py', '-lvl', '20', 'restarted']
__spec__.name: opencryptobot.START
</code></pre>
</div>
<span class="comment-copy">Thanks for this Martijn and sorry for wasting your time with this but it doesn't work. There is no error but the script will not be started again. The script just exits and i'm back at the command line.</span>
<span class="comment-copy">@Endogen: we already have a weird situation here, as your claim that <code>START</code> is a <i>class</i>, not a module. Can you please, in your question, add a clear illustration of what files you have and minimal contents of those files to help me reproduce your issue here?</span>
<span class="comment-copy">@Endogen: I have no issue making this work with <code>START.py</code> being a file inside an otherwise empty <code>opencryptobot</code> directory (Python 3 treats that as a namespace package, you shouldn't really use it that way).</span>
<span class="comment-copy">Ah ok, so it works if i add the Python extension? I will try that. Please see the link in my edited question for the current folder structure</span>
<span class="comment-copy">@Endogen: no, put that tree <i>in your question</i>, and make it a minimal example.</span>
