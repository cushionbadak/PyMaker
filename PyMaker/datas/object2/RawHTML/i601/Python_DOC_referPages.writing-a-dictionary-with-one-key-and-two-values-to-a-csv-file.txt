<div class="post-text" itemprop="text">
<p>I have a dictionary that has one key and two values.  I want to write a dictionary to a csv file, and sorted according to one of the values.  I also want each value to have its own column in the csv file. 
I can't seem to do it. </p>
<pre><code>sorted_combined = sorted(combined.items(), key = lambda kv: kv[1][1])
with open('output.csv', 'wb') as output:
   writer = csv.writer(output)
   writer.writerow(["Subject", "Sij", "gij"])
for key, value in sorted_combined.iteritems():
   writer.writerow(k, sorted_combined[k])
</code></pre>
<p>I know some people have said to try 
writer.writerow([k] + sorted_combined)
or 
writer.writerow(key, *value)</p>
<p>and neither one works. The error messages I get are: cannot concatenate tuple. </p>
<p>What I expect to get is the following: </p>
<pre><code> Subject     Sij      gij
 sub001_01   6578     18
 sub992_03   3820     5
</code></pre>
<p>*****EDIT*******
This is what my sorted_combined looks like.. however the (1,6) for instance you see at the end it not a tuple anymore it's a string.  When naming the dictionary key, each tuple was converted to a string.</p>
<p>[('network6_QNS_0045_01_(1, 6)', (0.0, 0.0)), ('network6_QNS_0045_01_(1, 4)', (0.0, 0.0)), ('network6_QNS_0045_01_(0, 6)', (0.0, 0.0)), ('network6_QNS_0045_01_(2, 5)', (0.0, 0.0)), ('network6_QNS_0045_01_(1, 7)', (0.0, 0.0)), ('network6_QNS_0045_01_(1, 5)', (0.0, 0.0)), ('network6_QNS_0045_01_(1, 3)', (0.0, 0.0)), ('network6_QNS_0045_01_(5, 6)', (0.0, 0.0)), ('network6_QNS_0045_01_(3, 5)', (0.0, 0.0)), ('network6_QNS_0045_01_(2, 6)', (743466.0, 18.387329999999999)), ('network6_QNS_0045_01_(5, 7)', (142774.0, 18.769649999999999)), ('network6_QNS_0045_01_(0, 5)', (232822.0, 20.160640000000001)), ('network6_QNS_0045_01_(3, 6)', (780163.0, 24.748139999999999)), ('network6_QNS_0045_01_(2, 3)', (199652.0, 26.635860000000001)), ('network6_QNS_0045_01_(4, 7)', (2248433.0, 27.278729999999999)), ('network6_QNS_0045_01_(3, 4)', (922289.0, 27.979320000000001)), ('network6_QNS_0045_01_(1, 2)', (396823.0, 29.924759999999999)), ('network6_QNS_0045_01_(4, 6)', (2897317.0, 30.266200000000001)), ('network6_QNS_0045_01_(0, 4)', (520923.0, 31.040569999999999)), ('network6_QNS_0045_01_(4, 5)', (6358.0, 32.68)), ('network6_QNS_0045_01_(2, 4)', (3622715.0, 35.321170000000002)), ('network6_QNS_0045_01_(2, 7)', (364815.0, 37.499250000000004)), ('network6_QNS_0045_01_(0, 1)', (145240.0, 38.878059999999998)), ('network6_QNS_0045_01_(0, 7)', (224456.0, 46.5182)), ('network6_QNS_0045_01_(0, 3)', (1692.0, 56.884950000000003)), ('network6_QNS_0045_01_(6, 7)', (280955.0, 57.616190000000003)), ('network6_QNS_0045_01_(3, 7)', (2012.0, 71.302719999999994)), ('network6_QNS_0045_01_(0, 2)', (1660.0, 84.085009999999997))]</p>
</div>
<div class="post-text" itemprop="text">
<p>I edited my answer, you are not using a dictionary. You have a list of tuples.</p>
<pre><code>import csv 
with open('output.csv', 'wb') as f:
    writer = csv.writer(f)
    writer.writerow(['Subject', 'Sij', 'gij'])
    for row in sorted_combined:
        l = [row[0]]
        l.append(row[0][1])
        l.append(row[1][1])
        writer.writerow(l)
</code></pre>
<p>Just like you had in your original try, csv.writer is the way to go</p>
</div>
<div class="post-text" itemprop="text">
<p>You can generate a list, flatten it and simply write it using <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">CSV</a>. I don't know if there is a shorter way, though.</p>
<pre><code>import csv

my_dict = {"sub001_01": [6578,18], "sub992_03": [3820,5]}

with open('my_file.csv', 'w') as f:
    w=csv.writer(f)
    w.writerow(["Subject", "Sij", "gij"])
    for i in list(my_dict.items()):
        #We first make a list like: ['test', 1, 2, 3]
        list1=[a for a in i]
        list_final=[]
        list_final.append(i[0])
        for c in list1[1]:
            list_final.append(c)
        #We use writerow() to write our new list
        w.writerow(list_final)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Subject,Sij,gij
sub001_01,6578,18
sub992_03,3820,5
</code></pre>
<p>To use '\t' instead of commas, <strong>just specify the delimiter</strong></p>
<pre><code>w=csv.writer(f,delimiter="\t")
</code></pre>
<p>Which will produce:</p>
<pre><code>Subject Sij gij
sub001_01   6578    18
sub992_03   3820    5
</code></pre>
<p>P.S: This is for Python 3.X</p>
<p>Edit: Forgot to mention that this is a universal loop that can handle more than 2 values. You can use it with other dictionaries (with lists containing multiple values) as well.</p>
</div>
<span class="comment-copy">I keep getting this error: "TypeError: list indices must be integers, not tuple" at this line of code:   f.write(', '.join([str(x) for x in sorted_combined[key]]))</span>
<span class="comment-copy">can you print what your values in the sorted_combined dictionary look like</span>
<span class="comment-copy">I just edited my answer. You are not using a dictionary, so you have positional indices instead of keys</span>
<span class="comment-copy">To make it tab separated, just change commas to <code>\t</code>, as suggested by Batuhan</span>
<span class="comment-copy">ah yes, csv.writer is the way to go to avoid this, edited my answer</span>
<span class="comment-copy">thanks, I was just wondering how I could get it in the format I showed above.  In a table, with each value having it's own column instead of being separated by commas.</span>
<span class="comment-copy">Very easy :) Just add delimiter="\t" to csv.writer() || w=csv.writer(f,delimiter="\t")</span>
