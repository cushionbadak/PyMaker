<div class="post-text" itemprop="text">
<p>I am trying to know how many bundles of '1' are there in a String which will only consist of <code>1</code>s and <code>0</code>s.</p>
<blockquote>
<p>For example,</p>
<p>For <code>1011011</code>, the number bundles of '1' will be <code>3</code> since bundles are <code>1</code>, <code>11</code>, <code>11</code> excepting <code>0</code>s.</p>
<p>For <code>11101110101</code>, it will be <code>4</code> as well since the bundles are <code>111</code>, <code>111</code>, <code>1</code>, <code>1</code>. </p>
</blockquote>
<p>Is there any Pythonic and concise way of solving this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is easy.    </p>
<pre><code>import re
string = "11101110101"
bundles = re.findall(r'1+',string)
</code></pre>
<p>Use a greedy search to search the longest sequence of <code>1's</code>. Now, <code>re.findall</code>, greedily searches the whole string, and return a list. This list will contain all the occurrences of 1, which contains groups of 1's.
If you want to print total number of bundles, use this:  </p>
<p><code>print(len(bundles))</code><br/>
Output:<br/>
<code>4</code></p>
</div>
<div class="post-text" itemprop="text">
<p>here is how you do it.
split the string by 0 and then remove empty elements from returned list and then print the length of list</p>
<pre><code>string = '0000'
x = string.split('0')
while "" in x:
    x.remove('')
print(len(x))
</code></pre>
<p>another approach would be using loop comprehension to remove empty.</p>
<pre><code>string = '0000'
x = string.split('0')
x = [y for y in x if y != ""]
print(len(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><strong><code>itertools.groupby</code></strong></a> and use <code>'0'</code> as the splitting character:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby

&gt;&gt;&gt; s = '11101110101'
&gt;&gt;&gt; sum(1 for k, g in groupby(s, '0'.__eq__) if not k)
4
</code></pre>
<p>It's not particularly pretty, but it works.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>String which will only consist of 1s and 0s</strong></p>
<pre><code>s = raw_input("Enter: ")
print(len([i for i in s.split("0") if i!=""]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simplest way (to type) is this:</p>
<pre><code>s = "11101110101"
print( zip("0"+s,s).count( ('0','1') ) )
</code></pre>
<p>Explaining why it works is a little more complicated, but good practice for programming in general. Each of the bundles of 1s starts with the substring "01" except for the case where the string starts with a one. If you only count these pairs of adjacent characters then you count the bundles exactly.</p>
<p>Zipping a string with the-string-offset-by-one will give all of the pairs of characters, e.g.</p>
<pre><code>&gt;&gt;&gt; s="111001101011"
&gt;&gt;&gt; print( zip(s,s[1:]) )
[('1', '1'), ('1', '1'), ('1', '0'), ('0', '0'), ('0', '1'), ('1', '1'), ('1', '0'), ('0', '1'), ('1', '0'), ('0', '1'), ('1', '1')]
</code></pre>
<p>All that is left to do is fix the corner case where it may start with a '1' by adding an extra '0' to the beginning.</p>
<p>Enjoy.</p>
</div>
<span class="comment-copy">in last example would't it be 4?</span>
<span class="comment-copy">@PriteshThaker Thank you for the correction :) I have edited :)</span>
<span class="comment-copy">doesn't work for the case, when <code>x = "00000"</code></span>
<span class="comment-copy">thanks for pointing out, i have edited my code</span>
<span class="comment-copy">What if the string has repeated zeroes? E.g. <code>10110011</code></span>
<span class="comment-copy">Now, check my submitted code again and tell me ,if you find any fail test case.</span>
<span class="comment-copy">I think itâ€™s your job to test your own code</span>
<span class="comment-copy">Ok, thank you very much</span>
