<div class="post-text" itemprop="text">
<p>I'm working with generators-as-coroutines as described in the excellent triplet of presentations by David Beazley (at <a href="http://www.dabeaz.com/coroutines/" rel="nofollow noreferrer">http://www.dabeaz.com/coroutines/</a>) and I can't figure out how to type the decorator <code>consumer</code>.  Here's what I have so far:</p>
<pre><code>from typing import Any, Callable, Generator, Iterable

ArbGenerator = Generator[Any, Any, Any]

def consumer(fn: ❓) -&gt; ❓:
    @wraps(fn)
    def start(*args: Any) -&gt; ArbGenerator:
        c = fn(*args)
        c.send(None)
        return c
return start
</code></pre>
<p>Example of use, kind of abridged:</p>
<pre><code>@consumer
def identity(target: ArbGenerator) -&gt; ArbGenerator:
    while True:
        item = yield
        target.send(item)

@consumer
def logeach(label: Any, target: ArbGenerator) -&gt; ArbGenerator:
    while True:
        item = yield
        print(label, item)
        target.send(item)

pipeline = identity(logeach("EXAMPLE", some_coroutine_sink()))
</code></pre>
<p>Bold <code>❓</code> marks where I'm unsure - and I'm also unsure about the type I defined <code>ArbGenerator</code>.  (Problem is, without the (decorator) function <code>consumer</code> itself typed, I'm not sure <code>mypy</code> is analyzing any generator function with that decorator so that's why I'm unsure about <code>ArbGenerator</code>.)</p>
<p>I'm interested in the tightest type, something better than <code>Any</code>, so that when I compose chains of these coroutines <code>mypy</code> will give me nice warnings if the chain isn't set up right.</p>
<p>(Python 3.5 if it matters.)</p>
</div>
<div class="post-text" itemprop="text">
<p>As a more specific way, here are few things you can do:</p>
<ol>
<li><p>Use <code>Callable</code> type instead of question marks.</p></li>
<li><p>Use <code>typing.Coroutine</code> for <code>targets</code> and drop the <code>ArbGenerator</code>.</p></li>
<li><p>Coroutines return a generator and the return type could be a <code>Generator</code> or one of its supertypes </p></li>
</ol>
<p>The reason that you should use callable instead of question marks is that <code>fn</code> is supposed to be a callable object at first and that's why you're wrapping it with a decorator. The <code>Coroutine</code> will be created after calling the object and the return type is/should be obviously a callable object as well.</p>
<pre><code>from typing import Any, Callable,Generator, Coroutine
from functools import wraps


def consumer(fn: Callable) -&gt; Callable:
    @wraps(fn)
    def start(*args: Any) -&gt; Coroutine:
        c = fn(*args)  # type: Coroutine
        c.send(None)
        return c
    return start


@consumer
def identity(target: Coroutine) -&gt; Generator:
    while True:
        item = yield
        target.send(item)

@consumer
def logeach(label: Any, target: Coroutine) -&gt; Generator:
    while True:
        item = yield
        print(label, item)
        target.send(item)
</code></pre>
<p><em>Note</em>: As it's also mentioned in documentation, if you want to use a more precise syntax for annotating the generator type you can use the following syntax:</p>
<pre><code>Generator[YieldType, SendType, ReturnType]
</code></pre>
<p>Read more: <a href="https://docs.python.org/3/library/typing.html#typing.Generator" rel="nofollow noreferrer">https://docs.python.org/3/library/typing.html#typing.Generator</a></p>
</div>
<span class="comment-copy">I tend to treat explicit typing as optional, and that seems to be the most generous application of typing in the Python community. In this case it seems that <i>any</i> typing is probably more painful for the (future) programmer than duck typing alone, so I would omit it.</span>
<span class="comment-copy">@AdamSmith - TBH I thought that that (omitting explicit typing) was the pythonic philosophy - so I was somewhat surprised when at my new job (where I'm relatively new to Python) that type hints even existed and that my colleagues are using it heavily.</span>
<span class="comment-copy">That's great news for you! I'm interested to see a good solution here, and since both strong explicit typing and coroutines are areas of weakness for me, I'm watching this question with bated breath :)</span>
<span class="comment-copy">@davidbak Why don't you use <code>typing.Coroutine</code>?</span>
<span class="comment-copy">@Kasrâmvd - Thank you. For some reason I thought <code>Coroutine</code> was specific to async.</span>
<span class="comment-copy">For some reason I thought <code>Coroutine</code> was specific to async.  Now, I had been running <code>mypy --strict</code> but this solution almost works with <code>mypy --strict --allow-any-generics</code> to have the non-specific <code>Callable</code> and <code>Coroutine</code> and <code>Generator</code>: I edited it to hint <code>c</code> in the wrapped <code>start</code> inside of <code>consumer, needed to avoid an error at </code>return c` which was <code>Any</code> is not a <code>Coroutine</code>.</span>
<span class="comment-copy">I guess I'm wondering why the return type from the coroutines isn't <code>Coroutine</code> since they clearly are (<code>yield</code> on RHS of assignment)?</span>
<span class="comment-copy">@davidbak Because they don't return a <code>Coroutine</code>. In fact, they return <code>None</code> (Python abstraction for the absence of any object). However, if you want to make the generator's typing more precise you can use <code>Generator[YieldType, SendType, ReturnType]</code> syntax. Read more here <a href="https://docs.python.org/3/library/typing.html#typing.Generator" rel="nofollow noreferrer">docs.python.org/3/library/typing.html#typing.Generator</a></span>
