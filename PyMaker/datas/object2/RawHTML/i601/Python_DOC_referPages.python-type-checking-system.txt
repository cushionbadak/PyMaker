<div class="post-text" itemprop="text">
<p>I am trying to make custom type system in Python. Following is the code.</p>
<pre><code>from inspect import Signature, Parameter

class Descriptor():
    def __init__(self, name=None):
        self.name = name

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

    def __get__(self, instance, cls):
        return instance.__dict__[self.name]

class Typed(Descriptor):
    ty = object
    def __set__(self, instance, value):
        if not isinstance(value, self.ty):
            raise TypeError('Expected %s' %self.ty)
        super().__set__(instance, value)

class Integer(Typed):
    ty = int

class Float(Typed):
    ty = float

class String(Typed):
    ty = str

class Positive(Descriptor):
    def __set__(self, instance, value):
        if value &lt; 0:
            raise ValueError('Expected &gt;= 0')
        super().__set__(instance, value)

class PosInteger(Integer, Positive):
    pass

class Sized(Descriptor):
    def __init__(self, *args, maxlen, **kwargs):
        self.maxlen = maxlen
        super().__init__(*args, **kwargs)

    def __set__(self, instance, value):
        if len(value) &gt; self.maxlen:
            raise ValueError('TooBig')
        super().__set__(instance, value)

class SizedString(String, Sized):
    pass

def make_signature(names):
    return Signature([Parameter(name, Parameter.POSITIONAL_OR_KEYWORD) for name in names])

class StructMeta(type):

    def __new__(cls, name, bases, clsdict):
        fields = [key for key, value in clsdict.items() if isinstance(value, Descriptor)]

        for name in fields:
            #print(type(clsdict[name]))
            clsdict[name].name = name

        clsobj = super().__new__(cls, name, bases, clsdict)
        sig = make_signature(fields)
        setattr(clsobj, '__signature__', sig)
        return clsobj

class Structure(metaclass = StructMeta):
    def __init__(self, *args, **kwargs):
        bound = self.__signature__.bind(*args, **kwargs)
        for name, value in bound.arguments.items():
            setattr(self, name, value)
</code></pre>
<p>Using the above type system, I got rid of all the boilerplate code and  duplicate code that I would have to write in classes (mostly inside init) for checking types, validating values etc.</p>
<p>By using the code above, my classes would look as simple as this</p>
<pre><code>class Stock(Structure):
        name =  SizedString(maxlen=9)
        shares =  PosInteger()
        price = Float()

 stock = Stock('AMZN', 100, 1600.0)
</code></pre>
<p>Till here things work fine. Now I want to extend this type checks functionality and create classes holding objects of another classes. For example price is now no longer a Float but its of type Price (i.e. another class Price).</p>
<pre><code>class Price(Structure):
    currency = SizedString(maxlen=3)
    value = Float() 

class Stock(Structure):
    name =  SizedString(maxlen=9)
    shares =  PosInteger()
    price = Price() # This won't work. 
</code></pre>
<p>This won't work because line "price = Price()" will make call to constructor of Price and would expect currency and value to be passed to the constructor because Price is a Structure and not a Descriptor. It throws "TypeError: missing a required argument: 'currency'".  </p>
<p>But I want it to work and make it look like above because at the end of the day Price is also a type just like PosInteger but at the same time it has to be Structure too. i.e. Price should be inheriting from Structure but at the same time it has to be a descriptor too. </p>
<p>I can make it work by defining another class say "PriceType"</p>
<pre><code>class Price(Structure):
    currency = SizedString(maxlen=3)
    value = Float()

class PriceType(Typed):
    ty = Price

class Stock(Structure):
    name =  SizedString(maxlen=9)
    shares =  PosInteger()
    price = PriceType()

stock = Stock('AMZN', 100, Price('INR', 2400.0))
</code></pre>
<p>But this looks a bit weird - Price and PriceType as two difference classes. Can someone help me understand if I can avoid creating PriceType class? </p>
<p>I am also losing out on a functionality to provide default values to fields. </p>
<p>For example, how can I keep default value of share field in Stock to 0 or default value of currency field in Price to 'USD'? i.e. something like below.</p>
<pre><code>class Stock:
    def __init__(name, price, shares=0)

class Price
    def __init__(value, currency = 'USD')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A quick thing to do there is to have a simple function that will build the "PriceType" (and equivalents) when you declare the fields.</p>
<p>Since uniqueness of the descriptor classes themselves is not needed, and the relatively long time a class takes to be created is not an issue, since fields in a body class are only created at program-load time, you should be fine with:</p>
<pre><code>def typefield(cls, *args, extra_checkers = (), **kwargs):
    descriptor_class = type(
        cls.__name__,
        (Typed,) + extra_checkers,
        {'ty': cls}
    )
    return descriptor_class(*args, **kwargs)
</code></pre>
<p>And now, code like this should just work:</p>
<pre><code>class Stock(Structure):
    name =  SizedString(maxlen=9)
    shares =  PosInteger()
    price = typefield(Price, "price")
</code></pre>
<p>(Also, note that Python 3.6+ have the <code>__set_name__</code> method incorporated into the <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor protocol</a> - if you use this, you won't need to pass the field name as a parameter to the default descriptor <code>__init__</code>, and type field names twice)</p>
<p><strong>update</strong></p>
<p>In your comment, you seam to implicate want your <code>Structure</code> classes to work themselves as descriptors - that would not work well - the descriptors <code>__get__</code> and <code>__set__</code> methods are class methods - you want the fields to be populated with actual instances of your structures.</p>
<p>What can be done is to move the <code>typefield</code> method above to a class method in Structure, have it annotate the default parameters your want, and create a new intermediate descriptor class for these kind of fields that will automatically create an instance with the default values when it is read. Also, <code>ty</code> can simply be an instance attribute in the descriptor, so no need to create dynamic classes for the fields:</p>
<pre><code>class StructField(Typed):
    def __init__(self, *args, ty=None, def_args=(), def_kw=None, **kw):
        self.def_args = def_args
        self.def_kw = def_kw or {}
        self.ty = ty
        super().__init__(*args, **kw)
    def __get__(self, instance, owner):
         if self.name not in instance.__dict__:
              instance.__dict__[self.name] = self.ty(*self.def_args, **self.def_kw)
         return super().__get__(instance, owner)


    ...

    class Structure(metaclass=StructMeta):
        ...
        @classmethod
        def field(cls, *args, **kw):  
         # Change the signature if you want extra parameters 
         # for the field, like extra validators, and such
            return StructField(ty=cls, def_args=args, def_kw=kw)

...

class Stock(Structure):
    ...
    price = Price.field("USD", 20.00)
</code></pre>
</div>
<span class="comment-copy">How is it not working? Does it shows an error message?</span>
<span class="comment-copy">@yorodm I have updated the question with the reason of why it is not working and what error this code is throwing.</span>
<span class="comment-copy">If this is for anything other than just the practice of it, python actually already has type checking and annotation capability. It is primarily for helping you write code as it is ignored at runtime, but it can be helpful in providing the ability to do static type checking.</span>
<span class="comment-copy">(I removed the "python-internals" tag since it is used for discussions about how cPython specifically implements some feature - i.e. discussion about the code of the Python runtime itself)</span>
<span class="comment-copy">Typechecking is done statically in Python, and is a work in (heavy) progress since Python 3.5 - it uses the <code>annotations</code> syntax introduced with Python3 and an external utility (mypy) to perform the type-check in the source code (not at run time). You'd have to re-write some of the above code to make use of annotations to specify the fields types (and change the metaclass to fill the <code>ty</code> attribute in the descriptors based on that). In that way you could benefit from the static-type checking tool stack - check <a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow noreferrer">python.org/dev/peps/pep-0484</a>  and <a href="http://mypy-lang.org/" rel="nofollow noreferrer">mypy-lang.org</a></span>
<span class="comment-copy">Thanks for the answer, these two ways "typefield", "PosInteger" still look counter-intuitive. Cant we somehow merge Price and typefield?</span>
<span class="comment-copy">Also if you can comment on the second aspect, i.e. how can I provide default values to the fields. Details are in the last section of the question. Obviously if you have time :)</span>
