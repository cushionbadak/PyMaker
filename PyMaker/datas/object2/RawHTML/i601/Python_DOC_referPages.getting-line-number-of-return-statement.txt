<div class="post-text" itemprop="text">
<p>Is there a way to get the line number of the statement returned by a Python function programmatically? Let's consider the following example:</p>
<pre><code>def foo(i: int) -&gt; str:
    if i == 1:
        return 'he'
    elif i == 2:
        return 'ha'
    return 'he'
</code></pre>
<p>If 1 or 3 is entered, the function will return <code>'he'</code>. However I won't know which <code>return 'he'</code> is actually executed unless I can step through the code.</p>
<p>My application allows users to enter business rules in Python from the GUI and let them test the rules themselves. As my application is not able to step through code (it delegates the task of execution to a stand-alone python engine and expects a string or an exception.) I want to find a way to get the returned line number so that I can highlight the corresponding line on the GUI editor.</p>
<p>A dirty way of doing it would be to have the function returning a tuple of line number and string, but ideally I would like to spare the users from the pain of doing so.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/bdb.html" rel="nofollow noreferrer"><code>bdb</code></a> module lets you inspect each frame right before it returns, so you should be able to retrieve the <code>f_lineno</code> of foo's final return at that point. Example:</p>
<pre><code>from bdb import Bdb
class ReturnWatcher(Bdb):
    def __init__(self):
        self.last_encountered_return_line = None
        super().__init__()
    def user_return(self, frame, return_value):
        self.last_encountered_return_line = frame.f_lineno

def foo(i):
    if(i==1):
        return 'he'
    elif(i==2):
        return 'ha'
    return 'he'

x = ReturnWatcher()
x.runcall(foo, 1)
print("Last return statement executed on line", x.last_encountered_return_line)
x.runcall(foo, 2)
print("Last return statement executed on line", x.last_encountered_return_line)
x.runcall(foo, 3)
print("Last return statement executed on line", x.last_encountered_return_line)
</code></pre>
<p>Result:</p>
<pre><code>Last return statement executed on line 11
Last return statement executed on line 13
Last return statement executed on line 14
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can ask Python to inform you of any returns by using <a href="https://docs.python.org/3/library/sys.html#sys.settrace" rel="nofollow noreferrer"><code>sys.settrace()</code></a>; this is a hook function that Python will call when certain events occur, and is how typical debuggers and profilers hook into Python.</p>
<p>The function that you register with <code>sys.settrace()</code> will be called for <em>call</em> events only, whenever Python enters a new local scope (for function calls, class bodies, and comprehensions and generator expressions). You can then return <code>None</code> (don't trace this local scope), or a trace function that'll be used for <em>line</em>, <em>exception</em> or <em>return</em> events within that scope. In Python 3.7, you can set options on the frame object to further control at what level of detail your per-scope trace function is called; you can disable per-line events or even enable per-opcode events.</p>
<p>You can use it to record <em>return</em> events like so; I use one trace method for both <em>call</em> and <em>return</em> events:</p>
<pre><code>import inspect
import sys

class ReturnLines:
    def __init__(self):
        self.returns = []
        self._old_trace = None

    def start(self):
        self._old_trace = sys.gettrace()
        sys.settrace(self.trace)

    def stop(self):
        sys.settrace(self._old_trace)

    def __enter__(self):
        self.start()
        return self.returns

    def __exit__(self, *exc):
        self.stop()

    def trace(self, frame, event, arg):
        filename = None
        if frame is not None:
            filename = inspect.getsourcefile(frame)
        if event == 'call':
            if filename == __file__:
                # skip ourselves
                return
            try:
                # Python 3.7+: only trace exceptions and returns for this call
                frame.f_trace_lines = False
            except AttributeError:
                pass
            return self.trace
        elif event == 'return':
            self.returns.append((filename, frame.f_lineno, arg))
</code></pre>
<p>Put that into a separate module and use the object like a context manager:</p>
<pre><code>from return_recorder import ReturnLines

with ReturnLines() as return_lines:
    # run the code you want to trace
    # ...
</code></pre>
<p>The context manager gives you access to the list object it adds returns to (as <code>(filename, linenumber, returned_object)</code> tuples), so you could access the return information as you execute code inside the context manager:</p>
<pre><code>&gt;&gt;&gt; from return_recorder import ReturnLines
&gt;&gt;&gt; def foo(i: int) -&gt; str:
...     if i == 1:
...         return 'he'
...     elif i == 2:
...         return 'ha'
...     return 'he'
...
&gt;&gt;&gt; with ReturnLines() as return_lines:
...     for i in range(3):
...         foo(i)
...         print(f'&lt;-- i={i}, returned at line {return_lines[-1][1]}')
...
'he'
&lt;-- i=0, returned at line 6
'he'
&lt;-- i=1, returned at line 3
'ha'
&lt;-- i=2, returned at line 5
&gt;&gt;&gt; for filename, lineno, returned in return_lines:
...     print(f'{filename}:{lineno}:{returned!r}')
...
None:6:'he'
None:3:'he'
None:5:'ha'
</code></pre>
<p>For the interactive interpreter, the filename is <code>None</code>.</p>
<p>The <code>bdb</code> module, underpinning Kevin’s answer, builds on top of <code>sys.set_trace()</code>but doesn’t disable line tracing on Python 3.7+. And as a generic debugger framework, it adds a higher overhead per trace event. This translates to slower execution of the code you are instrumenting. </p>
</div>
<span class="comment-copy">@zvone: the short answer is actually <i>"Yes"</i>. The long answer to your long question is: <i>because that's what an IDE GUI for Python code ideally should be able to do, show users what their code is doing to aid in development</i>.</span>
<span class="comment-copy">It works! Many thanks for your help Kevin :)</span>
<span class="comment-copy">Hi Martijn, many thanks for your in depth explanation!</span>
<span class="comment-copy">@user2136168: Glad to have been of help! Feel free to <a href="http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work">accept one of the answers here</a> if you feel it was useful to you. :-) Pick the one you feel most helped you, or none, the choice is yours.</span>
