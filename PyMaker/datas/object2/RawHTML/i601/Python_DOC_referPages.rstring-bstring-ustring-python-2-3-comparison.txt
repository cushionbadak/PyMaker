<div class="post-text" itemprop="text">
<p>I already know <code>r"string"</code> in Python 2.7 often used for regex patterns. I also have seen <code>u"string"</code> for, I think, Unicode strings. Now with Python 3 we see <code>b"string"</code>.</p>
<p>I have searched for these in different sources / questions, such as <a href="https://stackoverflow.com/questions/2592764/what-does-a-b-prefix-before-a-python-string-mean">What does a b prefix before a python string mean?</a>, but it's difficult to see the big picture of all these <strong>strings with prefixes</strong> in Python, especially with Python 2 vs 3.</p>
<p><strong>Question: would you have a rule of thumb to remember the different types of strings with prefixes in Python?</strong> (or maybe a table with a column for Python 2 and one for Python 3?)</p>
<p><sup>NB: I have read a few questions+answers but I haven't found an easy to remember comparison with all prefixes / Python 2+3</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>From the python docs for literals: <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals</a></p>
<blockquote>
<p>Bytes literals are always prefixed with 'b' or 'B'; they produce an
  instance of the bytes type instead of the str type. They may only
  contain ASCII characters; bytes with a numeric value of 128 or greater
  must be expressed with escapes.</p>
<p>Both string and bytes literals may optionally be prefixed with a
  letter 'r' or 'R'; such strings are called raw strings and treat
  backslashes as literal characters. As a result, in string literals,
  '\U' and '\u' escapes in raw strings are not treated specially. Given
  that Python 2.x’s raw unicode literals behave differently than Python
  3.x’s the 'ur' syntax is not supported.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>A string literal with 'f' or 'F' in its prefix is a formatted string
  literal; see Formatted string literals. The 'f' may be combined with
  'r', but not with 'b' or 'u', therefore raw formatted strings are
  possible, but formatted bytes literals are not.</p>
</blockquote>
<p>So:</p>
<ul>
<li><strong>r</strong> means <strong>raw</strong></li>
<li><strong>b</strong> means <strong>bytes</strong></li>
<li><strong>u</strong> means <strong>unicode</strong></li>
<li><strong>f</strong> means <strong>format</strong></li>
</ul>
<p>The <strong>r</strong> and <strong>b</strong> were already available in Python 2, as such in many other languages (they are very handy sometimes).</p>
<p>Since the strings literals were not unicode in Python 2, the u-strings were created to offer support for internationalization. As of Python 3, u-strings are the default strings, so "..." is semantically the same as u"...".</p>
<p>Finally, from those, the f-string is the only one that isn't supported in Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><strong>u-strings</strong> if for unicode in python 2. Most probably you should forget this, if you're working with modern applications — default strings in python 3 is all unicode, and if you're migrating from python 2, you'll most probably use <code>from __future__ import unicode_literals</code>, which makes [almost] the same for python 2</li>
<li><p><strong>b-strings</strong> is for raw bytes — have no idea of <em>text</em>, rather just stream of bytes. Rarely used as input for your source, most often as result of network or low-level code — reading data in binary format, unpacking archives, working with encryption libraries.</p>
<p>Moving from/to b-string to <code>str</code> done via <code>.encode</code> &amp; <code>.decode</code></p></li>
<li><p><strong>r-strings</strong> is not specifically for regex, this is "raw" string. Unlike regular string literals, r-string doesn't give any special meaning for escape characters. I.e. normal string <code>abc\n</code> is 4 characters long, last char is "newline" special character. To provide it in literal, we're using escaping with <code>\</code>. For raw strings, <code>r'abc\n'</code> is 5-length string, last two characters is literally <code>\</code> and <code>n</code>. Two places to see raw strings often: </p>
<ul>
<li><p>regex patterns — to not mess escaping with actual special characters in patters</p></li>
<li><p>file path notations for windows systems, as windows family uses <code>\</code> as delimeter, normal string literals will look like <code>'C:\\dir\\file'</code>, or <code>'\\\\share\\dir'</code>, while raw would be nicer: <code>r'C:\dir\file'</code> and <code>r'\\share\dir'</code> respectively</p></li>
</ul></li>
<li><p>One more notable is <strong>f-strings</strong>, which came to life with python 3.6 as simple and powerful way of formatting strings: </p>
<ul>
<li><code>f'a equals {a} and b is {b}'</code> will substitute variables <code>a</code> and <code>b</code> in runtime.</li>
</ul></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>There are really only two types of string (or string-like object) in Python.</p>
<p>The first is 'Unicode' strings, which are a sequence of characters.
The second is bytes (or 'bytestrings'), which are a sequence of bytes.</p>
<p>The first is a series of letter characters found in the Unicode specification.
The second is a series of integers between 0 and 255 that are usually rendered to text using some assumed encoding such as ASCII or UTF-8 (which is a specification for encoding Unicode characters in a bytestream).</p>
<p>In Python 2, the default <code>"my string"</code> is a bytestring.
The prefix 'u' indicates a 'Unicode' string, e.g. <code>u"my string"</code>.</p>
<p>In Python 3, 'Unicode' strings became the default, and thus <code>"my string"</code> is equivalent to <code>u"my string"</code>.
To get the old Python 2 bytestrings, you use the prefix b"my string" (not in the oldest versions of Python 3).</p>
<p>There are two further prefixes, but they do not affect the type of string object, just the way it is interpreted.
The first is 'raw' strings which do not interpret escape characters such as \n or \t. For example, the raw string <code>r"my_string\n"</code> contains the literal backslash and 'n' character, while <code>"my_string\n"</code> contains a linebreak at the end of the line.</p>
<p>The second was introduced in the newest versions of Python 3: formatted strings with the prefix 'f'. In these, curly braces are used to show expressions to be interpreted. For example, the string in:</p>
<pre><code>my_object = 'avocado'
f"my {0.5 + 1.0, my_object} string"`
</code></pre>
<p>will be interpreted to <code>"my (1.5, avocado) string"</code> (where the comma created a tuple). This interpretation happens immediately when the code is read; there is nothing special subsequently about the string.</p>
<p>And finally, you can use the multiline string notation:</p>
<pre><code>"""this is my
multiline
string"""`
</code></pre>
<p>with 'r' or 'f' specifiers as you wish.</p>
<p>In Python 2, if you have used no prefix or only an 'r' prefix, it is a bytestring, and if you have used a 'u' prefix it is a Unicode string.</p>
<p>In Python 3, if you have used no prefix or only a combination of 'r', 'f' and 'u', it is a Unicode string. If you have used a 'b' prefix it is a bytestring. Using both 'b' and 'u' is obviously not allowed.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what I observed (seems confirmed by other answers):</p>
<pre><code>Python 2                       Python 3

-----------------------------------------------

"hello"                        b"hello
b"hello"            &lt;=&gt;    
&lt;type 'str'&gt;                   &lt;class 'bytes'&gt;

-----------------------------------------------

u"hello"            &lt;=&gt;        "hello"
                               u"hello"
&lt;type 'unicode'&gt;               &lt;class 'str'&gt;
</code></pre>
</div>
<span class="comment-copy">Euhm, <code>r"string"</code> doesn't mean regex does it? It stands for "raw string". <code>u"string"</code> stands for unicode string and <code>b"string"</code> stands for bytes "string". It's in the documentation. A rule of thumb is, the letter equals the name of the representation. u for unicode. b for bytes and r for raw. You get used to it after using them more than twice I'd say. And is a different between python2/python3.</span>
<span class="comment-copy">@Torxed Yes, but these are different for Python 2 and 3, etc. and having an easy-to-refer-to comparison table would be super useful.</span>
<span class="comment-copy">@Torxed We often have <code>u"string"</code> with Python 2.7, and <code>"string"</code> in Python 3 when running the same code, so it would make sense to have a definitive comparison table showing the different cases and the different versions 2 vs 3. It would be much easier than reading the Py2 doc, reading the Py3 doc, then reading a few questions+answers + figure out where are exactly the differences between 2 and 3.</span>
<span class="comment-copy">There's to much to go through in order to make a complete list of differences. And deciding what's important in a cheat sheet and what is not - is up to every person. Create one for yourself, that is written in a way that you'll understand and feel it's useful. They already <a href="https://wiki.python.org/moin/Python2orPython3" rel="nofollow noreferrer">go through</a> the changes and why they were made. There's hundreds of articles describing the changes on their forums/mailing lists and documentation site. Every different aspect is written in the docs on every function/definition so people know what "the old syntax" was.</span>
<span class="comment-copy">Thanks! Can you just add which ones are available on 2, and which ones are available on 3? It could also be interesting to add the default for both i.e. what is <code>"string"</code> equivalent to in 2 vs 3?</span>
<span class="comment-copy">You are welcome! Is the edit clear?</span>
<span class="comment-copy">Thanks! So <code>u"hello"</code> in Py2.7 is strictly equivalent to <code>"hello"</code> in Py3?</span>
<span class="comment-copy">Yes. And even in python 2, you can do <code>from __future__ import unicode_literals</code>, and all <code>'hello'</code> in that module will equivalent to <code>u'hello'</code>. Tho, "strictly" has a vague meaning. Type name is different, some methods may differ, but we're comparing different major version of language, so... mostly they're interchangeble</span>
<span class="comment-copy">Thank you for this answer! So as a rule of thub, Py2's <code>u"hello"</code> = Py3's <code>"hello"</code> and Py2's <code>"hello"</code> = Py3's <code>b"hello"</code>, right?</span>
<span class="comment-copy">Yes.  The 'u' prefix is not supported in Python 3.0 to 3.2, but was re-introduced in Python 3.3.  The 'b' prefix is also supported in Python 2.6 and 2.7 (but is ignored) - it is included to allow compatibility with Python 3.  The 'f' prefix was only introduced in Python 3.6 and likely to be further improved to remove some limitations.</span>
