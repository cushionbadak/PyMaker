<div class="post-text" itemprop="text">
<p>I am a learner in nested loops in python.</p>
<p>Below I have written my code. I want to make my code simpler, since when I run the code it takes so much time to produce the result.</p>
<p>I have a list which contains 1000 values:</p>
<pre><code>Brake_index_values = [ 44990678,  44990679,  44990680,  44990681,  44990682,  44990683,
             44997076,  44990684,  44997077,  44990685,
            ...
             44960673,   8195083,   8979525, 100107546,  11089058,  43040161,
             43059162, 100100533,  10180192,  10036189]
</code></pre>
<p>I am storing the element no 1 in another list</p>
<pre><code>original_top_brake_index = [Brake_index_values[0]]
</code></pre>
<p>I created a temporary list called temp and a numpy array for iteration through Loop:</p>
<pre><code>temp =[]
arr = np.arange(0,1000,1)
</code></pre>
<p>Loop operation:</p>
<pre><code>for i in range(1, len(Brake_index_values)):
    if top_15_brake &lt;= 15:
        a1 = Brake_index_values[i]
        #a2 = Brake_index_values[j]
        a3 = arr[:i]
        for j in a3:
            a2 = range(Brake_index_values[j] - 30000, Brake_index_values[j] + 30000)
            if a1 in a2:
                pass
            else:
                temp.append(a1)
        if len(temp)== len(a3):
            original_top_brake_index.append(a1)
            top_15_brake += 1
            del temp[:]
        else:
            del temp[:]
            continue
</code></pre>
<p>I am comparing the <code>Brake_index_values[1]</code> element available between the range of 30000 before and after <code>Brake_index_values[0]</code> element, that is `range(Brake_index_values[0]-30000, Brake_index_values[0]+30000).</p>
<p>If the <code>Brake_index_values[1]</code> available between the range, I should ignore that element and go for the next element <code>Brake_index_values[2]</code> and follow the same process as before for <code>Brake_index_values[0]</code> &amp; <code>Brake_index_values[1]</code></p>
<p>If it is available, store the Value, in <code>original_top_brake_index</code> thorough append operation. </p>
<p>In other words :</p>
<p>(Lets take 3 values a,b &amp; c. I am checking whether the value b is in range between (a-30000 to a+30000). Possibility 1: If b is in between (a-30000 to a+30000) , neglect that element (Here I am storing inside a temporary list). Then the same process continues with c (next element) Possibility 2: If b is not in b/w those range put b in another list called original_top_brake_index
(this another list is the actual result what i needed)</p>
<p>The result I get:</p>
<p>It is working, but it takes so much time to complete the operation and sometimes it shows MemoryError.</p>
<p>I just want my code to work simpler and efficient with simple operations.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this code (with numpy):    </p>
<pre><code>import numpy as np
original_top_brake_index = [Brake_index_values[0]]
top_15_brake = 0
Brake_index_values = np.array(Brake_index_values)
for i, a1 in enumerate(Brake_index_values[0:]):
    if top_15_brake &gt; 15:
        break
    m = (Brake_index_values[:i] - a1)
    if np.logical_or(m &gt; 30000, m &lt; - 30000).all():
        original_top_brake_index.append(a1)
        top_15_brake += 1
</code></pre>
<p>Note: you can probably make it even more efficient, but this already should reduce the number of operations significantly (and doesn't change much the logic of your original code)</p>
</div>
<div class="post-text" itemprop="text">
<p>We can use the <code>bisect</code> module to shorten the elements we actually have to lookup by finding the smallest element that's greater or less than the current value. We will use recipes from <a href="https://docs.python.org/3/library/bisect.html#searching-sorted-lists" rel="nofollow noreferrer">here</a></p>
<p>Let's look at this example:</p>
<pre><code>from bisect import bisect_left, bisect_right

def find_lt(a, x):
    'Find rightmost value less than x'
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    return

def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    return

vals = [44990678,  44990679,  44990680,  44990681,  44990682, 589548954, 493459734, 3948305434, 34939349534]

vals.sort()  # we have to sort the values for bisect to work
passed = []
originals = []

for val in vals:
    passed.append(val)
    l = find_lt(passed, val)
    m = find_gt(passed, val)
    cond1 = (l and l + 30000 &gt;= val)
    cond2 = (m and m - 30000 &lt;= val)
    if not l and not m:
        originals.append(val)
        continue
    elif cond1 or cond2:
        continue
    else:
        originals.append(val)
</code></pre>
<p>Which gives us:</p>
<pre><code>print(originals)

[44990678, 493459734, 589548954, 3948305434, 34939349534]
</code></pre>
<p>There might be another, more mathematical way to do this, but this should at least simplify your code.</p>
</div>
<span class="comment-copy">so if I understand correctly, each subsequent element has to check if it falls within <code>+/- 30000</code> of all the previous elements before it?</span>
<span class="comment-copy">Yes you are right ....@aws_apprentice</span>
<span class="comment-copy">@aws_apprentice Thank yout for the answer, but it doesn't satisfy my requirement.</span>
<span class="comment-copy">@aws_apprentice Thank yout for the answer, but it doesn't satisfy my requirement. for example : val[6] must be added to my originals list. Reason : val[6]  is not available between +/-3e4 for the Values 44990678 &amp; 589548954. So it must be added to originals.</span>
<span class="comment-copy">Thank you for the answer, but it doesn't satisfy my requirement. for example : val[6] must be added to originals list. Reason : val[6]  is not available between +/- 3e4 for the Values 44990678 &amp; 589548954. So it must be added to originals.</span>
<span class="comment-copy">@esakkiponraj.e please check the answer now</span>
