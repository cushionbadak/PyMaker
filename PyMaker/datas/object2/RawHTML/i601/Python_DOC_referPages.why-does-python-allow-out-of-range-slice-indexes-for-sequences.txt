<div class="post-text" itemprop="text">
<p>So I just came across what seems to me like a strange Python feature and wanted some clarification about it.  </p>
<p>The following array manipulation somewhat makes sense:</p>
<pre><code>p = [1,2,3]
p[3:] = [4] 
p = [1,2,3,4]
</code></pre>
<p>I imagine it is actually just appending this value to the end, correct?<br/>
Why can I do this, however?  </p>
<pre><code>p[20:22] = [5,6]
p = [1,2,3,4,5,6]
</code></pre>
<p>And even more so this:  </p>
<pre><code>p[20:100] = [7,8]
p = [1,2,3,4,5,6,7,8]
</code></pre>
<p>This just seems like wrong logic. It seems like this should throw an error! </p>
<p>Any explanation?<br/>
-Is it just a weird thing Python does?<br/>
-Is there a purpose to it?<br/>
-Or am I thinking about this the wrong way?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Part of question regarding out-of-range indices</h2>
<p>Slice logic automatically clips the indices to the length of the sequence.</p>
<p>Allowing slice indices to extend past end points was done for convenience.  It would be a pain to have to range check every expression and then adjust the limits manually, so Python does it for you.</p>
<p>Consider the use case of wanting to display no more than the first 50 characters of a text message.</p>
<p>The easy way (what Python does now):</p>
<pre><code>preview = msg[:50]
</code></pre>
<p>Or the hard way (do the limit checks yourself):</p>
<pre><code>n = len(msg)
preview = msg[:50] if n &gt; 50 else msg
</code></pre>
<p>Manually implementing that logic for adjustment of end points would be easy to forget, would be easy to get wrong (updating the 50 in two places), would be wordy, and would be slow.  Python moves that logic to its internals where it is succint, automatic, fast, and correct.  This is one of the reasons I love Python :-)</p>
<h2>Part of question regarding assignments length mismatch from input length</h2>
<p>The OP also wanted to know the rationale for allowing assignments such as <code>p[20:100] = [7,8]</code> where the assignment target has a different length (80) than the replacement data length (2).</p>
<p>It's easiest to see the motivation by an analogy with strings.  Consider, <code>"five little monkeys".replace("little", "humongous")</code>.  Note that the target "little" has only six letters and "humongous" has nine.  We can do the same with lists:</p>
<pre><code>&gt;&gt;&gt; s = list("five little monkeys")
&gt;&gt;&gt; i = s.index('l')
&gt;&gt;&gt; n = len('little')
&gt;&gt;&gt; s[i : i+n ] = list("humongous")
&gt;&gt;&gt; ''.join(s)
'five humongous monkeys'
</code></pre>
<p>This all comes down to convenience.  </p>
<p>Prior to the introduction of the <em>copy()</em> and <em>clear()</em> methods, these used to be popular idioms:</p>
<pre><code>s[:] = []           # clear a list
t = u[:]            # copy a list
</code></pre>
<p>Even now, we use this to update lists when filtering:</p>
<pre><code>s[:] = [x for x in s if not math.isnan(x)]   # filter-out NaN values
</code></pre>
<p>Hope these practical examples give a good perspective on why slicing works as it does.  </p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="noreferrer">documentation</a> has your answer:</p>
<blockquote>
<p><code>s[i:j]</code>: slice of <code>s</code> from <code>i</code> to <code>j</code> (note (4))</p>
<p>(4) The slice of <code>s</code> from <code>i</code> to <code>j</code> is defined as the sequence of items
  with index <code>k</code> such that <code>i &lt;= k &lt; j</code>. <strong>If <code>i</code> or <code>j</code> is greater than</strong>
<strong><code>len(s)</code>, use <code>len(s)</code></strong>. If <code>i</code> is omitted or <code>None</code>, use <code>0</code>. If <code>j</code>
  is omitted or <code>None</code>, use <code>len(s)</code>. If <code>i</code> is greater than or equal to
  <code>j</code>, the slice is empty.</p>
</blockquote>
<p>The <a href="https://docs.python.org/3/library/exceptions.html#IndexError" rel="noreferrer">documentation of <code>IndexError</code></a> confirms this behavior:</p>
<blockquote>
<p>exception <code>IndexError</code></p>
<p>Raised when a sequence subscript is out of range. (<strong>Slice indices are silently truncated to fall in the allowed range;</strong> if an index is
  not an integer, <code>TypeError</code> is raised.)</p>
</blockquote>
<p>Essentially, stuff like <code>p[20:100]</code> is being reduced to <code>p[len(p):len(p]</code>. <code>p[len(p):len(p]</code> is an empty slice at the end of the list, and assigning a list to it will modify the end of the list to contain said list. Thus, it works like appending/extending the original list.</p>
<p>This behavior is the same as what happens when you assign a list to an empty slice <em>anywhere</em> in the original list. For example:</p>
<pre><code>In [1]: p = [1, 2, 3, 4]

In [2]: p[2:2] = [42, 42, 42]

In [3]: p
Out[3]: [1, 2, 42, 42, 42, 3, 4]
</code></pre>
</div>
<span class="comment-copy">In other languages I always end up writing this kind of stuff all over the place: <code>if i &gt; sequence.length(): return sequence.slice(0, sequence.length()) else sequence.slice(0, n)</code> This is exactly the same as just using <code>sequence[:n]</code> in Python it saves you an if statement and 2 calls to <code>length</code>.</span>
<span class="comment-copy">BTW. You can look at slices as "sets". So <code>p[20:22]</code> is a sequence of all elements with indices between 20 and 22. The empty set is a valid set. That is way different than saying <code>p[20]</code> which asserts the existence of element with index 20. Hence the difference in range-checking between looking up an element vs a slice reflects the two different meanings.</span>
<span class="comment-copy">I think this a broader question about why adding sequences in slices of sequences that are of different length is allowed in Python and what are its benefits. The other question does not address at all the assignment part of this question. It just talks about the slicing.</span>
<span class="comment-copy">"Even now, we use this to update lists when filtering <i>[example using <code>s[:]</code>]</i>" â€” Could you expand on why you'd use <code>s[:] =</code> there, instead of just <code>s =</code>? I've never seen anyone use <code>s[:] =</code> in the context of a line such as what you wrote there. Good answer otherwise!</span>
<span class="comment-copy">@Quuxplusone: Slice assignment <i>mutates</i> the list already referenced by <code>s</code>; using <code>s =</code> <i>re-binds</i> <code>s</code> to refer to a new list. If the list can be reached via multiple names, and you want the mutation to be visible to all the names, slice assignment is what you want. Also, if <code>s</code> were global, reassigning <code>s</code> would require a <code>global</code> declaration, but slice assignment would have a similar effect even without the <code>global</code> statement.</span>
<span class="comment-copy">I don't think OP is asking how slicing works, he's asking for the rationale behind the design choice.</span>
<span class="comment-copy">@Primusa - I believe they're asking <i>both</i>.  This explains the <i>how</i>, which is good to know because it explains why the behavior isn't broken.  The <i>why</i> is probably buried in the depths of one of the mailing lists somewhere.</span>
<span class="comment-copy">Good answer but this doesn't explain why the new numbers get appended to the end of the list.</span>
<span class="comment-copy">@Atirag I added a small blurb about it for completeness.</span>
<span class="comment-copy">@Atirag Indexing is very different from slicing; indexing always refers to values.</span>
