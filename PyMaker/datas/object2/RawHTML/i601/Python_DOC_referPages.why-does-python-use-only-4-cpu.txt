<div class="post-text" itemprop="text">
<p>I have a Python script that counts the occurrences of every k-long substring in a very large text. This is how it does it, after having stored and deduplicated the substrings:</p>
<pre><code>counts = {}
for s in all_substrings:
    counts[s] = full_text.count(s)
</code></pre>
<p>I was surprised to see that this script uses only 4% CPU on average. I have a 4-core, 8-thread CPU, but no core is used at more than single-digit percentages. I would have expected the script to use 100% of one core, since it doesn't do IO.</p>
<p>Why does it use so little computing power, and how can I improve that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your snippet is likely a memory bandwidth limited program. You do next to no computation in that loop. However most cpu monitoring programs report 100% for a program that just accesses memory. I am puzzled too.</p>
<p>If you want to see more of what is happening i recommend you play with the excellent <a href="http://www.brendangregg.com/perf.html" rel="nofollow noreferrer">perf tool in linux</a>.</p>
<p>You could start by looking at page faults</p>
<pre><code># Sample page faults with stack traces, until Ctrl-C:
perf record -e page-faults -ag
</code></pre>
</div>
<span class="comment-copy">If the text is stored in memory then look at the paging/swapping.</span>
<span class="comment-copy">The execution of computation-bound pure Python code is limited to a single thread via the global interpreter lock (GIL). If you want your code to be parallel you have to write it yourself (and there is plenty of option out there to do so). In your specific case, I would look into <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a>.</span>
<span class="comment-copy">@cdarke I have 16GB RAM and half of it is free, would it make sense for the system to swap the data my script is constantly working on?</span>
<span class="comment-copy">@norok2 It's not even using 5% of a single core, so I don't think parallelizing would be the solution.</span>
<span class="comment-copy">Not directly related to your question, but I suspect gathering a list of substrings and calling <code>count</code> with each of them might be slower than just composing a Counter of all the slices of the text, i.e. <code>counts = collections.Counter(s[i:i+k] for i in range(len(s)-k-1))</code>. If there are few duplicates among substrings, then your current approach is O(len(full_text)^2). Looping over slices is O(len(full_text)).</span>
<span class="comment-copy">Thank you for the recommendation. Is there an equivalent on Windows?</span>
<span class="comment-copy">I only know of <a href="https://en.wikipedia.org/wiki/VTune" rel="nofollow noreferrer">en.wikipedia.org/wiki/VTune</a> which costs a lot of moneys</span>
