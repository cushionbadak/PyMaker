<div class="post-text" itemprop="text">
<p>I read about the repr() function in python . I thought of experimenting something and thought of evaluating the output of repr() inside the object itself to see what it leads to . 
So I wrote the following code :</p>
<pre><code>class no : 
      def __init__(self,a) :
          self.a = a
          self.b = eval(repr(self))

k = no(2) 
print(k.b.a)
</code></pre>
<p>I expected that by the time <strong>init</strong> gets called  the object would already have been created .  So thought of creating a new object of the same class inside one already created object . </p>
<p>However , in the line  :</p>
<pre><code>k = no(2)
</code></pre>
<p>I am getting a run-time error stating :</p>
<pre><code>Traceback (most recent call last):
  File "classofpy.txt", line 54, in &lt;module&gt;
    k = no(2)
  File "classofpy.txt", line 52, in __init__
    self.b = eval(repr(self))
  File "&lt;string&gt;", line 1
    &lt;__main__.no object at 0x0385F690&gt;
    ^
</code></pre>
<p>However , I cannot understand as to why it is complaining of non-existence of an object when by the time <strong>init</strong> is being called the object would already have gotten created . </p>
<p>However on replacing :</p>
<pre><code>self.b = eval(repr(self))
</code></pre>
<p>by </p>
<pre><code>self.b = self
</code></pre>
<p>everything is working fine . </p>
<p>What might be the reason behind this behavior ? Although semantically both </p>
<pre><code>self.b = self 
</code></pre>
<p>and
    self.b = eval(repr(self))</p>
<p>mean the same . I guess I might be wrong in terms of detailing  here like , 
self.b = eval(repr(self)) might be meaning something else in terms of memory layout and might not mean the same as creating a replica object , but that kind of is what I am posting this question for . </p>
<p>So why is </p>
<pre><code>self.b = eval(repr(self))
</code></pre>
<p>yielding a run-time error ?</p>
<p>(Additionally , it would be quite insightful to know how language designers think about permitting or restricting such kind of assignments )</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>If you want anything like this to work, you need to define <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer">a <code>__repr__</code></a> that produces a valid, <code>eval</code>uable string. The default <code>repr</code>, as you've seen, just produces <code>&lt;qualified.classname object at 0xmemoryaddress&gt;</code>, which isn't valid Python code, and thus can't be <code>eval</code>-ed. </li>
<li>This is an insane design even if you do that, because even if you can <code>eval</code> yourself, you've just created an infinite loop, where each instance tries to create an identical sub-instance, which creates an identical sub-instance, which creates an identical sub-instance, etc., etc., ad infinitum.</li>
</ol>
<p>Don't do this. Feel free to define a useful <code>__repr__</code>, but don't try <code>eval</code>ing it in your own <code>__init__</code>.</p>
<p>To be clear, <code>self.b = self</code> is <em>not</em> the same thing as <code>self.b = eval(repr(self))</code>. The former is just creating a reference cycle (a problem in its own right in some contexts, but generally not fatal). The latter is creating a brand new object based on the current object, which, given the current object is in the process of being constructed, would be a bad idea in many contexts even if it didn't lead to infinitely recursive object construction.</p>
</div>
<span class="comment-copy">The traceback would normally come with the exception thrown, but I can't see that here. Did you miss it out? Can you add it to the question?</span>
<span class="comment-copy">@useless : It says , SyntaxError: invalid syntax...I guess this is what you were looking for .</span>
<span class="comment-copy">Yes, you should always include the <i>complete</i> error message in your question. It doesn't cost anything and is generally more useful for the reader.</span>
<span class="comment-copy">@Useless : So what does it suggest in this context ?</span>
<span class="comment-copy">It happened inside the eval, so it suggests the input to that is not valid (has a syntax error). So, the next step would be to print the result of repr so you can see what eval is trying to evaluate. Of course, the answer by ShadowRanger is correct, but these are the basic steps I'd expect someone to take before asking a question.</span>
<span class="comment-copy">Not a design , but was just thinking what happens if I do something like this . But why the inifinite loop , <b>init</b> gets called only once right , it's the <b>new</b> which will be getting called if at all ?</span>
<span class="comment-copy">Why the run-time error but ?</span>
<span class="comment-copy">Within <code>__init__</code>, you are evaluating to create a new object (which in turn will invoke its own <code>__init__</code> &amp; so on) which is similar to current one. This will result into stackoverflow perhaps.</span>
<span class="comment-copy">@KanishkViman: The run-time error is because the <code>repr</code> is garbage. Try running an actual <code>repr</code> of a custom class's instance without defining a useful <code>__repr__</code> and look at the resulting string; it's not valid Python code. And no, creating an instance executes both <code>__new__</code> and <code>__init__</code>, so the loop will in fact be infinite.</span>
<span class="comment-copy">yes both of them get called , but <b>init</b>  gets called post creation of object . But  if i write a print statement inside <b>init</b> and do something like self.b = b , the print statement gets printed only once ..</span>
