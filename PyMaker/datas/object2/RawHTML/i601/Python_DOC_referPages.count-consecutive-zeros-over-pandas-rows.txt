<div class="post-text" itemprop="text">
<p>Having the following <code>pd.DataFrame</code></p>
<pre><code>pd.DataFrame({'2010':[0, 45, 5], '2011': [12, 56, 0], '2012': [11, 22, 0], '2013': [0, 5, 0], '2014': [0, 0, 0]})

  2010 2011 2012 2013 2014
1  0    12   11   0    0
2  45   56   22   5    0
3  5    0    0    0    0
</code></pre>
<p>I would like to count the consecutive zeros over rows</p>
<pre><code>1 [1, 2]
2 [1]
3 [4]
</code></pre>
<p>Looking for different efficient ways</p>
</div>
<div class="post-text" itemprop="text">
<p>For efficiency, I would suggest going pure NumPy way -</p>
<pre><code>def islandlen_perrow(df, trigger_val=0):
    a=df.values==trigger_val
    pad = np.zeros((a.shape[0],1),dtype=bool)
    mask = np.hstack((pad, a, pad))
    mask_step = mask[:,1:] != mask[:,:-1]
    idx = np.flatnonzero(mask_step)
    island_lens = idx[1::2] - idx[::2]
    n_islands_perrow = mask_step.sum(1)//2
    out = np.split(island_lens,n_islands_perrow[:-1].cumsum())
    return out
</code></pre>
<p>Sample run -</p>
<pre><code>In [69]: df
Out[69]: 
   2010  2011  2012  2013  2014
0     0    12    11     0     0
1    45    56    22     5     0
2     5     0     0     0     0

In [70]: islandlen_perrow(df, trigger_val=0)
Out[70]: [array([1, 2], dtype=int64), array([1], dtype=int64), array([4], dtype=int64)]

In [76]: pd.Series(islandlen_perrow(df, trigger_val=0))
Out[76]: 
0    [1, 2]
1       [1]
2       [4]
dtype: object
</code></pre>
<p>Timings on larger array -</p>
<pre><code>In [77]: df = pd.DataFrame(np.random.randint(0,4,(1000,1000)))

In [78]: from itertools import groupby

# @Daniel Mesejo's soln
In [79]: def count_zeros(x):
    ...:     return [sum(1 for _ in group) for key, group in groupby(x, key=lambda i: i == 0) if key]

In [80]: %timeit df.apply(count_zeros, axis=1)
1 loop, best of 3: 228 ms per loop

# @coldspeed's soln-1
In [84]: %%timeit
    ...: v = df.stack()
    ...: m = v.eq(0)
    ...: 
    ...: (m.ne(m.shift())
    ...:   .cumsum()
    ...:   .where(m)
    ...:   .dropna()
    ...:   .groupby(level=0)
    ...:   .apply(lambda x: x.value_counts(sort=False).tolist()))
1 loop, best of 3: 516 ms per loop

# @coldspeed's soln-2
In [88]: %%timeit
    ...: v = df.stack()
    ...: m = v.eq(0)
    ...: (m.ne(m.shift())
    ...:   .cumsum()
    ...:   .where(m)
    ...:   .dropna()
    ...:   .groupby(level=0)
    ...:   .value_counts(sort=False)
    ...:   .groupby(level=0)
    ...:   .apply(list))
1 loop, best of 3: 343 ms per loop

# @jpp's soln
In [90]: %timeit [[len(list(grp)) for flag, grp in groupby(row, key=bool) if not flag] \
    ...:                 for row in df.values]
1 loop, best of 3: 334 ms per loop

# @J. Doe's soln
In [94]: %%timeit
    ...: data = df
    ...: data_transformed = np.equal(data.astype(int).values.tolist(), 0).astype(str)
    ...: pd.DataFrame(data_transformed).apply(lambda x: [i.count('True') for i in ''.join(list(x)).split('False') if i], axis=1)
1 loop, best of 3: 519 ms per loop

# From this post
In [89]: %timeit pd.Series(islandlen_perrow(df, trigger_val=0))
100 loops, best of 3: 9.8 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> with a list comprehension:</p>
<pre><code>from itertools import groupby

df['counts'] = [[len(list(grp)) for flag, grp in groupby(row, key=bool) if not flag] \
                for row in df.values]

print(df)

   2010  2011  2012  2013  2014  counts
0     0    12    11     0     0  [1, 2]
1    45    56    22     5     0     [1]
2     5     0     0     0     0     [4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're interested in a pure pandas/numpy solution... you can do this with <code>groupby</code> and <code>value_counts</code>:</p>
<pre><code>v = df.stack()
m = v.eq(0)

(m.ne(m.shift())
  .cumsum()
  .where(m)
  .dropna()
  .groupby(level=0)
  .apply(lambda x: x.value_counts(sort=False).tolist()))

0    [1, 2]
1       [1]
2       [4]
dtype: object
</code></pre>
<p>Or, avoiding the <code>lambda</code>,</p>
<pre><code>(m.ne(m.shift())
  .cumsum()
  .where(m)
  .dropna()
  .groupby(level=0)
  .value_counts(sort=False)
  .groupby(level=0)
  .apply(list))

0    [1, 2]
1       [1]
2       [4]
dtype: object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a>:</p>
<pre><code>import pandas as pd

from itertools import groupby


def count_zeros(x):
    return [sum(1 for _ in group) for key, group in groupby(x, key=lambda i: i == 0) if key]


df = pd.DataFrame({'2010':[0, 45, 5], '2011': [12, 56, 0], '2012': [11, 22, 0], '2013': [0, 5, 0], '2014': [0, 0, 0]})

result = df.apply(count_zeros, axis=1)
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>0    [1, 2]
1       [1]
2       [4]
dtype: object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One method is to transform the values to boolean values, and splitting the string by <code>False</code> values</p>
<pre><code>data_transformed = np.equal(data.astype(int).values.tolist(), 0).astype(str)
pd.DataFrame(data_transformed).apply(lambda x: [i.count('True') for i in ''.join(list(x)).split('False') if i], axis=1)
</code></pre>
</div>
