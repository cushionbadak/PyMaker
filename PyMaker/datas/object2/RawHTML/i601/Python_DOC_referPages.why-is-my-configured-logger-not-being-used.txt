<div class="post-text" itemprop="text">
<p>Reading the logging HOWTO (<a href="https://docs.python.org/3/howto/logging.html" rel="nofollow noreferrer">https://docs.python.org/3/howto/logging.html</a>) I came away under the impression that if I configured a logger, then I could subsequently request my logger from the factory via <code>logging.getLogger()</code> and python would know how to get the right logger (the one I configured) and everything would just auto-work, i.e. I wouldn't need to pass the configured logger instance around my code, I could just ask for it wherever I needed it. Instead, I'm observing something different.</p>
<p>File <code>log_tester.py</code>:</p>
<pre><code>from util.logging_custom import SetupLogger
import logging
import datetime

def test():
    logger = logging.getLogger()
    logger.debug("In test()")

def main():
    logger = SetupLogger("logger_test")
    logger.setLevel(logging.DEBUG)
    logger.info(f"now is {datetime.datetime.now()}", )
    logger.debug("In main()")
    test()


if __name__ == '__main__':
    main()
</code></pre>
<p>File <code>util/logging_custom.py</code>:</p>
<pre><code>import os
import time
import logging
from logging.handlers import RotatingFileHandler

def SetupLogger(name_prefix):
    if not os.path.exists("log"):
        os.makedirs("log")

    recfmt = logging.Formatter('%(asctime)s.%(msecs)03d %(levelname)s %(message)s')

    handler = RotatingFileHandler(time.strftime(f"log/{name_prefix}.log"),maxBytes=5000000, backupCount=10)
    handler.setFormatter(recfmt)
    handler.setLevel(logging.DEBUG)

    logger = logging.getLogger(f"{name_prefix} {__name__}")
    logger.addHandler(handler)

    return logger
</code></pre>
<p>When I run this code only the debug statement that is in <code>main()</code> ends up in the log file. The debug statement from <code>test()</code> ends up I'm not sure where exactly.</p>
<p>Contents of <code>log/logger_test.log</code>:</p>
<pre><code>2019-02-07 09:14:39,906.906 INFO now is 2019-02-07 09:14:39.906848
2019-02-07 09:14:39,906.906 DEBUG In main()
</code></pre>
<p>My expectation was that <code>In test()</code> would also show up in my log file. Have I made some assumptions about how python logging works that are untrue? How do I make it so that all of the logging in my program (which has many classes and modules) goes to the same configured logger? Is that possible without passing around a logger instance everywhere, after it's created in <code>main()</code>?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>getLogger</code> function will return a the logger by its name (kind of a singleton): </p>
<ul>
<li>if it doesn't exist, it creates it</li>
<li>If it already exist, it returns it</li>
</ul>
<p>Then what you could do is:</p>
<p><em>util/logging_custom.py</em></p>
<pre><code>def SetupLogger(logger_name, level=logging.INFO):
    if not os.path.exists("log"):
        os.makedirs("log")

    recfmt = logging.Formatter('%(asctime)s.%(msecs)03d %(levelname)s %(message)s')
    handler = RotatingFileHandler(time.strftime(f"log/{logger_name}.log"),maxBytes=5000000, backupCount=10)
    handler.setFormatter(recfmt)
    handler.setLevel(level)

    logger = logging.getLogger(logger_name)
    logger.addHandler(handler)

    # no need to return the logger, I would even advice not to do so
</code></pre>
<p><em>log_tester.py</em></p>
<pre><code>from util.logging_custom import SetupLogger
import logging
import datetime

logger = SetupLogger("logger_test", logging.DEBUG)  # you only need to run this once, in your main script.
logger = logging.getLogger("logger_test")

def test():
    logger.debug("In test()")

def main():
    logger.info(f"now is {datetime.datetime.now()}", )
    logger.debug("In main()")
    test()

if __name__ == '__main__':
    main()
</code></pre>
<p><em>any_other.py</em></p>
<pre><code>import logging
logger = logging.getLogger("logger_test")  # this will return the logger you already instantiate in log_tester.py

logger.info("that works!")
</code></pre>
<p><strong>Update</strong></p>
<p>To set the level and the handling of the <strong>root logger</strong> instead of the one you setted up, use <code>logging.getLogger()</code> without passing any name:</p>
<pre><code>root_logger = logging.getLogger()
root_logger.addHandler(your_handler)
root_logger.setLevel(logging.DEBUG)

root_logger.info("hello world")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the docs:</p>
<blockquote>
<p>Multiple calls to getLogger() with the same name will return a
  reference to the same logger object.</p>
</blockquote>
<p>Your assumptions are quite correct. The problem here is the way you are calling <code>getLogger()</code> in <code>test()</code>. You should be passing the name you used in <code>SetupLogger()</code>'s <code>getLogger()</code> i.e. <code>logger = logging.getLogger(f"{name_prefix} {__name__}")</code>.</p>
</div>
<span class="comment-copy">Thank you. But I think this assumes that everywhere in my code now I need to know the name of the logger that has been configured in main(). This seems rather inflexible, some of my modules may be included from multiple programs and won't know ahead of time what the name of logger is. I was under the impression that there is some sort of logging hierarchy that python uses and it bubbles up to the root. So if I configure a logger in my main program then sub-module code that uses logging will know to bubble up looking for the right config.</span>
<span class="comment-copy">There is, you can also configure the level and handling of the <code>root</code> logger by using <code>getLogger()</code> without any name, see <a href="https://docs.python.org/3.7/library/logging.html#logging.getLogger" rel="nofollow noreferrer">there</a></span>
<span class="comment-copy">Just add a <code>FileHandler</code> to the root logger and it will log every logger instantiated in your program, whatever their name is</span>
<span class="comment-copy">Ah, ok. That's the culprit I think <code>logger = logging.getLogger(f"{name_prefix} {__name__}")</code> in my setup, configures a specific logger rather than the root logger, so loggers elsewhere don't know to use it. Just replace with <code>logger = logging.getLogger()</code> in the setup so that the root logger is configured and I'm peachy. Thanks! Maybe edit your main answer to refer to the root logger and I will accept it?</span>
<span class="comment-copy">I updated my answer</span>
<span class="comment-copy">How does that work for logging in other modules? It seems from the docs that python should auto-magically know that I configured a file logger at some higher level and defer to that configuration.</span>
