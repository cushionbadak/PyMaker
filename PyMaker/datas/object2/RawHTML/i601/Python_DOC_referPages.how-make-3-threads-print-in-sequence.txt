<div class="post-text" itemprop="text">
<p>I need make 3 threads for printing a semaphore colors: red, yellow and green on this order, and after that, each tread must sleep for N seconds randomly.
Each color must be printed for one thread, and all this process must repeat N times. </p>
<p>I've tried move the lock.acquire() and lock.release() to out of the for loop but does not work =(</p>
<pre><code>from termcolor import colored
import threading
import time
from random import randrange


def threadRed(n, lock, tempo):
    for i in range(n):
        lock.acquire()
        print(colored("red", 'grey', 'on_red', attrs=['dark', 'bold']))
        print(colored("I'm going to sleep for %d seconds," % tempo, 'red'))
        time.sleep(tempo)
        lock.release()


def threadYellow(n, lock, tempo):
    for i in range(n):
        lock.acquire()
        print(colored("yellow", 'grey', 'on_yellow', attrs=['dark', 'bold']))
        print(colored("I'm going to sleep for %d seconds," % tempo, 'yellow'))
        time.sleep(tempo)
        lock.release()


def threadGreen(n, lock, tempo):
    for i in range(n):
        lock.acquire()
        print(colored("green", 'grey', 'on_green', attrs=['dark', 'bold']))
        print(colored("I'm going to sleep for %d seconds," % tempo, 'green'))
        time.sleep(tempo)
        lock.release()


lock = threading.Lock()
repeticoes = 5
tempo = randrange(1, 11)
t_red = threading.Thread(target=threadRed, args=(repeticoes, lock, tempo))
tempo = randrange(1, 11)
t_yellow = threading.Thread(target=threadYellow, args=(repeticoes, lock, tempo))
tempo = randrange(1, 11)
t_green = threading.Thread(target=threadGreen, args=(repeticoes, lock, tempo))

t_red.start()
t_yellow.start()
t_green.start()
t_red.join()
t_yellow.join()
t_green.join()
</code></pre>
<p>Briefly my code is printing that: </p>
<p><img alt="actual result" src="https://i.imgur.com/foVPtQU.png"/></p>
<p>but I need this to be the displayed result:</p>
<p><img alt="expected result" src="https://i.imgur.com/quu5Azw.png"/></p>
</div>
<div class="post-text" itemprop="text">
<p>Okay, you're desired output would kill the whole point of <code>multi-threading</code>.</p>
<p><strong>Why?</strong></p>
<blockquote>
<p>A thread has a beginning, an execution sequence, and a conclusion. It
  has an instruction pointer that keeps track of where within its
  context it is currently running.</p>
</blockquote>
<p>Continuing from that, the point in your question would be running the multiple threads concurrently, regardless of the fact which <code>function</code> executes first.</p>
<p>What you're trying is:</p>
<p>Running the threads in a sequential manner, regardless of which thread completes first, that is so not <code>multi-threading</code>. Above that, your using <code>lock.acquire() and lock.release()</code> inside each function to <em>take the soul out of multi-threading</em></p>
<p>Answer:
if you really want the threads to run in sequential manner, you should not be acquiring and releasing the threads inside the functions,</p>
<p>A little change:</p>
<pre><code>from termcolor import colored
import threading
import time
from random import randrange


def threadRed(n, tempo):
    for i in range(n):
        # lock.acquire()
        print(colored("red", 'grey', 'on_red', attrs=['dark', 'bold']))
        print(colored("I'm going to sleep for %d seconds," % tempo, 'red'))
        time.sleep(tempo)
        # lock.release()


def threadYellow(n, tempo):
    for i in range(n):
        # lock.acquire()
        print(colored("yellow", 'grey', 'on_yellow', attrs=['dark', 'bold']))
        print(colored("I'm going to sleep for %d seconds," % tempo, 'yellow'))
        time.sleep(tempo)
        # lock.release()


def threadGreen(n, tempo):
    for i in range(n):
        # lock.acquire()
        print(colored("green", 'grey', 'on_green', attrs=['dark', 'bold']))
        print(colored("I'm going to sleep for %d seconds," % tempo, 'green'))
        time.sleep(tempo)
        # lock.release()


lock = threading.Lock()
repeticoes = 5
lock.acquire()
tempo = randrange(1, 11)
t_red = threading.Thread(target=threadRed, args=(repeticoes, tempo))
tempo = randrange(1, 11)
t_yellow = threading.Thread(target=threadYellow, args=(repeticoes, tempo))
tempo = randrange(1, 11)
t_green = threading.Thread(target=threadGreen, args=(repeticoes, tempo))
lock.release()
t_red.start()
t_yellow.start()
t_green.start()
t_red.join()
t_yellow.join()
t_green.join()
</code></pre>
<p>OUTPUT:</p>
<pre><code>red
I'm going to sleep for 6 seconds,
yellow
I'm going to sleep for 4 seconds,
green
I'm going to sleep for 4 seconds,
yellow
I'm going to sleep for 4 seconds,
green
I'm going to sleep for 4 seconds,
red
I'm going to sleep for 6 seconds,
yellow
I'm going to sleep for 4 seconds,
green
I'm going to sleep for 4 seconds,
red
I'm going to sleep for 6 seconds,
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't try to use <code>threading.Lock()</code>.  A <code>lock</code> object is only meant to be used for mutual exclusion (i.e., to prevent two or more threads from accessing the same data at the same time.)  It is not intended for communication <em>between</em> threads.</p>
<p>IMO, the best way to do this would be to use three <code>Semaphore</code> instances.  Python has a class, <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore" rel="nofollow noreferrer"><code>asyncio.Semaphore</code></a>, but I'm a little puzzled by the words "not thread safe" in its documentation. I have never used that class, but it <em>looks</em> like the semaphores from other language libraries which are intended for signalling between threads.</p>
<p>A semaphore is like a blocking queue that contains zero or more <em>permits</em>. The permits are abstract; they don't actually exist. The semaphore merely keeps a count of how many of them it is supposed to "contain" at any given moment in time. </p>
<p>A caller can attempt to <code>acquire()</code> a permit, which will decrement the count and immediately return if the count was greater than zero, or which will wait until some other thread <code>release()</code>s a permit otherwise.</p>
<p>So here's how you would use it:</p>
<p>Make three empty semaphores (count == 0), one for each of your threads, and give each thread a reference to its own semaphore, and also, to the next thread's semaphore.  Then each thread should loop:</p>
<pre><code>for i in range(n):
    self.my_semaphore.acquire()        # thread waits here until signalled.
    print( ... )
    self.next_guys_semaphore.release() # signals the next guy.
</code></pre>
<p>After your main thread has created the three semaphores and the three worker threads, nothing will happen because all three workers will be waiting in <code>acquire()</code>.  So then, the last thing the main thread needs to do is <code>red_worker_semaphore.release()</code>, and then they should start running, one-by-one, in the proper order.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>I made it!</strong></p>
<p>Thanks for everyone tips! but I remake all my code usingo threading.Lock() and threading.Event() and work's fine!</p>
<pre><code>from termcolor import colored
import threading
import time
from random import randrange


lock = threading.Lock()
event = threading.Event()


def printThread(color):
    duration = randrange(1, 11)
    print(colored(color, 'grey', 'on_'+color, attrs=['dark', 'bold']))
    print(colored("I'm going sleep for %d seconds!," % duration, color))
    time.sleep(duration)

def threadRed(n):
    for i in range(n):
        lock.acquire()
        printThread("red")
        lock.release()
        event.set()
        event.wait()
        event.clear()


def threadYellow(n):
    for i in range(n):
        lock.acquire()
        printThread("yellow")
        lock.release()
        event.set()
        event.wait()
        event.clear()


def threadGreen(n):
    for i in range(n):
        lock.acquire()
        printThread("green")
        lock.release()
        event.set()
        event.wait()
        event.clear()



loop_count = 5

t_red = threading.Thread(target=threadRed, args=(loop_count,))

t_yellow = threading.Thread(target=threadYellow, args=(loop_count,))

t_green = threading.Thread(target=threadGreen, args=(loop_count,))


t_red.start()
t_yellow.start()
t_green.start()
t_red.join()
t_yellow.join()
t_green.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>That is another version of the same code, but using pure semaphore, instead events</strong></p>
<pre><code>from termcolor import colored
import threading
import time
from random import randrange


semaforo1 = threading.Semaphore()
semaforo2 = threading.Semaphore()
semaforo3 = threading.Semaphore()



def printThread(color):
    duration = randrange(1, 11)
    print(colored(color, 'grey', 'on_'+color, attrs=['dark', 'bold']))
    print(colored("I'm going sleep for %d seconds!," % duration, color))
    time.sleep(duration)

def threadRed(n):
    semaforo2.acquire()
    semaforo3.acquire()
    for i in range(n):
        semaforo1.acquire()
        printThread("red")
        #semaforo1.release()
        semaforo2.release()


def threadYellow(n):
    for i in range(n):
        semaforo2.acquire()
        printThread("yellow")
        semaforo3.release()



def threadGreen(n):
    for i in range(n):
        semaforo3.acquire()
        printThread("green")
        semaforo1.release()




loop_count = 5

t_red = threading.Thread(target=threadRed, args=(loop_count,))

t_yellow = threading.Thread(target=threadYellow, args=(loop_count,))

t_green = threading.Thread(target=threadGreen, args=(loop_count,))


t_red.start()
t_yellow.start()
t_green.start()
t_red.join()
t_yellow.join()
t_green.join()
</code></pre>
</div>
<span class="comment-copy">Sorry, I forgot to change two variables for English: "Tempo" = Time.  And "Repeticoes" = repeats</span>
<span class="comment-copy">Thanks bro, but It's almost that, I need the output to be ALWAYS: red, yellow, and green. at all times  in your output, after the first loop the next color printed was yellow instead red =/</span>
<span class="comment-copy">Another point is the second thread, yellow, just can be started after the first thread, red, finish his sleep time.  And the third thread, green, after the finish of the sleep time of yellow Thread.</span>
<span class="comment-copy">It may "kill the whole point of multi-threading," but it also is a very common homework assignment. I don't know what book it originally came from, but it teaches the newbies <i>how</i> to coordinate the activities of two or more threads even if it doesn't give them a ghost of a clue about when or why to coordinate them.</span>
<span class="comment-copy">Solomon Slow that is EXACTLY my problem.</span>
