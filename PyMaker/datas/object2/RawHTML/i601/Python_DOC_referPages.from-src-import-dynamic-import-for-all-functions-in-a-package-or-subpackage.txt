<div class="post-text" itemprop="text">
<p><strong>Goal:</strong><br/>
I want to be able to dynamically import all functions in a sub-package with 'a direct call'</p>
<p><strong>Usage:</strong><br/>
my project: </p>
<pre><code>project/
|-- main.py
|-- src/
|---- __init__.py
|---- foo.py
|---- bar.py 
</code></pre>
<p><code>foo.py</code> has just one function: </p>
<pre><code>def foo_funct(): 
    print("foo")
</code></pre>
<p><code>bar.py</code> has just one function: </p>
<pre><code>def bar_funct():
    print("bar")
</code></pre>
<p>and finally <code>main.py</code>: </p>
<pre><code>from src import * 
(...)
foo_funct()
bar_funct()
(...)
</code></pre>
<p><strong>Comments:</strong> </p>
<ol>
<li><p>if my <code>__init__.py</code> is something like this</p>
<pre><code>import os 
__all__ = [i.replace(".py", "") for i in os.listdir(os.getcwd()+"/src/") if "__" not in i]
</code></pre>
<p>I will be able to call <code>foo.foo_funct()</code> or <code>bar.bar_funct()</code> but not <code>foo_funct()</code> or <code>bar_funct()</code></p></li>
<li><p>if my <code>__init__.py</code> is something like this:</p>
<pre><code>from src.foo import *
from src.bar import *
</code></pre>
<p>I will be able to call <code>foo_funct()</code> or <code>bar_funct()</code> but for each new sub package I will have to modify my <code>__init__.py</code></p></li>
<li><p>Assuming that <code>from src import *</code> is not the most pythonic method, and assuming that it could be very dangerous to have direct calls due to possible naming conflicts such as <code>a.tree_funct()</code> and <code>b.tree_funct()</code>,  is there any method to reach my goal?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Personally, I prefer to keep things explicit, and just import names that are part of the package API into <code>__init__</code> explicitly. Your project won't change so rapidly that dynamically importing everything into the <code>__init__.py</code> is going to be a time saver.</p>
<p>But if you want to do this, then you have a few options here. If you need to support Python versions older than 3.7, then you can update the package namespace by poking at the <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow noreferrer"><code>globals()</code> dictionary</a>. List all <code>.py</code> files and import them using <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer"><code>importlib.import_module()</code></a> (or with <a href="https://docs.python.org/3/library/functions.html#__import__" rel="nofollow noreferrer"><code>__import__()</code></a> if you need to support Python versions before 2.7):</p>
<pre><code>__all__ = []

def _load_all_submodules():
    from pathlib import Path
    from importlib import import_module

    g = globals()
    package_path = Path(__file__).resolve().parent
    for pyfile in package_path.glob('*.py'):
        module_name = pyfile.stem
        if module_name == '__init__':
            continue
        module = import_module(f'.{module_name}', __package__)
        names = getattr(
            module, '__all__', 
            (n for n in dir(module) if n[:1] != '_'))
        for name in names:
            g[name] = getattr(module, name)
            __all__.append(name)

_load_all_submodules()
del _load_all_submodules
</code></pre>
<p>The above keeps the namespace clean; after the <code>_load_all_submodules()</code> function has run it is removed from the package. It uses the <code>__file__</code> global to determine the current path and finds any sibling <code>.py</code> files from there.</p>
<p>If you only need to support Python 3.7 and up, you can define <a href="https://docs.python.org/3.7/whatsnew/3.7.html#pep-562-customization-of-access-to-module-attributes" rel="nofollow noreferrer">module-level <code>__getattr__()</code> and <code>__dir__()</code> functions</a> to implement dynamic lookups.</p>
<p>Using those hooks in your package <code>__init__.py</code> file could look like:</p>
<pre><code>def _find_submodules():
    from pathlib import Path
    from importlib import import_module

    package_path = Path(__file__).resolve().parent
    return tuple(p.stem for p in package_path.glob('*.py') if p.stem != '__init__')

__submodules__ = _find_submodules()
del _find_submodules


def __dir__():
    from importlib import import_module
    names = []
    for module_name in __submodules__:
        module = import_module(f'.{module_name}', __package__)
        try:
            names += module.__all__
        except AttributeError:
            names += (n for n in dir(module) if n[:1] != '_')
    return sorted(names)


__all__ = __dir__()


def __getattr__(name):
    from importlib import import_module
    for module_name in __submodules__:
        module = import_module(f'.{module_name}', __package__)
        try:
            # cache the attribute so future imports don't call __getattr__ again
            obj = getattr(module, name)
            globals()[name] = obj
            return obj
        except AttributeError:
            pass
    raise AttributeError(name)
</code></pre>
</div>
