<div class="post-text" itemprop="text">
<p>I am running my AWS EC2 instance and when I try to run my web app, MyCoolApp.py I get the following error:</p>
<pre><code>Traceback (most recent call last):   
File "MyCoolApp.py", line 9, in &lt;module&gt;
    import boto3
ImportError: No module named boto3
</code></pre>
<p>This is after I try to start my application which I do, and used to do before I made this latest change with the following command:</p>
<pre><code>[ec2-user@ip-XXX-XXX-XXX-XXX CoolApp]$ sudo python MyCoolApp.py
</code></pre>
<p>As you can guess I am trying to import Boto3 for use and I do that in the my python application with the following code at the top of my program:</p>
<pre><code>from werkzeug.security import check_password_hash, generate_password_hash
from datetime import datetime
import time, os, random, json
import urllib
import boto3
</code></pre>
<p>Lastly, because I know you are going to ask this, YES I already installed Boto3 and when I run pip freeze I can see it. This is the output below:</p>
<pre><code>[ec2-user@ip-XXX-XXX-XXX-XXX CoolApp]$ pip freeze
alembic==0.9.9
aws-cfn-bootstrap==1.4
awscli==1.15.83
Babel==0.9.4
backports.ssl-match-hostname==3.4.0.2
blinker==1.4
boto==2.48.0
boto3==1.9.87
botocore==1.12.87
chardet==2.0.1
click==6.7
cloud-init==0.7.6
colorama==0.2.5
configobj==4.7.2
docutils==0.14
ecdsa==0.11
Flask==1.0.2
Flask-Login==0.4.1
Flask-Mail==0.9.1
Flask-Migrate==2.1.1
Flask-Mobility==0.1.1
Flask-SQLAlchemy==2.3.2
futures==3.2.0
hibagent==1.0.0
iniparse==0.3.1
itsdangerous==0.24
Jinja2==2.10
jmespath==0.9.3
jsonpatch==1.2
jsonpointer==1.0
kitchen==1.1.1
lockfile==0.8
Mako==1.0.7
MarkupSafe==1.0
mysql-connector-python==8.0.11
paramiko==1.15.1
PIL==1.1.6
pip-tools==3.3.2
ply==3.4
protobuf==3.5.2.post1
pyasn1==0.1.7
pycrypto==2.6.1
pycurl==7.19.0
pygpgme==0.3
pyliblzma==0.5.3
pystache==0.5.3
python-daemon==1.5.2
python-dateutil==2.7.3
python-editor==1.0.3
pyxattr==0.5.0
PyYAML==3.10
requests==1.2.3
rsa==3.4.1
s3transfer==0.1.13
simplejson==3.6.5
six==1.11.0
SQLAlchemy==1.2.7
urlgrabber==3.10
urllib3==1.24.1
virtualenv==15.1.0
Werkzeug==0.14.1
yum-metadata-parser==1.1.4
</code></pre>
<p>Now because I suspect that someone will be suggesting this I am just going to head this off now. I have these packages all installed globally to my --user. I am NOT using a virtual environment, yes I know I should be but I didn't think that I was going to need one because everything runs on the one server. Yes I acknowledge that this might be a mistake and I use them everywhere else but thats not the point here if I could get some help with this error that would be great. It starts on my local machine and works just fine it is just when I try to run it on my server it fails.</p>
<p>Lastly, if this is due to a conflict with packages on my server it would be great if someone could help me figure out how to remove them, instructions would be appreciated as I am on AWS AMI Linux. </p>
</div>
<div class="post-text" itemprop="text">
<p>So with the details as provide in the question, we have the scenario where a Python script and the environment it will be executed at has:</p>
<ol>
<li>Dependency on some packages;</li>
<li>No virtualenv is used, but the Python user install directory (as the <code>ec2-user</code> user) is used instead for simplicity for the installation of the script's dependencies;</li>
<li>The script however requires root privileges to run (due to the <a href="https://unix.stackexchange.com/questions/16564/why-are-the-first-1024-ports-restricted-to-the-root-user-only">usage of low ports</a>, with the elevated permission achieved via <code>sudo</code> (as the <code>root</code> user).</li>
</ol>
<p>Naturally, running a script as <code>root</code> while the dependencies were installed local to a user other than <code>root</code> will mean that none of the dependencies will actually be accessible by that script.  As the dependencies are installed under the <a href="https://docs.python.org/3/library/site.html#site.USER_BASE" rel="nofollow noreferrer"><code>site.USER_BASE</code></a> for the <code>ec2-user</code>, in order for the script to be able to import its dependency while being executed under the <code>root</code> user, the location may be defined using the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONUSERBASE" rel="nofollow noreferrer"><code>PYTHONUSERBASE</code></a>  environment variable.</p>
<p>To achieve that while using <code>sudo</code>, try:</p>
<pre><code>$ sudo PYTHONUSERBASE=/home/ec2-user/.local python MyCoolApp.py
</code></pre>
<p>If that works, great, we can move onto a more cleaner approach if desired, as this approach can potentially result in situations where the <code>ec2-user</code> user cannot remove files from their <code>.local</code> directory, as files like <code>.pyc</code> files will be written into there as the root.</p>
<p>A number of approaches can be done:</p>
<ol>
<li>Laziest manner: <code>sudo pip</code>, install packages globally; comes with all the problems of having globally available python packages.</li>
<li>Use <code>sudo pip --user</code> instead - only local to the root user.</li>
<li><a href="https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux">A number of approaches at the OS level that is available on Linux may be attempted</a></li>
<li>Use virtualenv, and start the Python script (with <code>sudo</code> as <code>root</code>) using the <code>env/bin/python</code> created by virtualenv.  Example (uses <code>/var/tmp/env</code> as the base for demonstration):</li>
</ol>
<pre><code>$ virtualenv /var/tmp/env
Using base prefix '/usr'
New python executable in /var/tmp/env/bin/python3.6
Also creating executable in /var/tmp/env/bin/python
Installing setuptools, pip, wheel...done.
$ . /var/tmp/env/bin/activate
(env) $ pip install -r requirements.txt
...
(env) $ deactivate
$ sudo /var/tmp/env/bin/python MyCoolApp.py
</code></pre>
<p>Finally, it may be beneficial to <a href="https://stackoverflow.com/questions/2699907/dropping-root-permissions-in-python">drop root privileges back to the original user</a> (or another limited user) after the port has been opened, to improve the security situation of the runtime environment.</p>
</div>
<span class="comment-copy">You ran the script using <code>sudo</code> but <code>pip freeze</code> without, and you noted that you ran <code>pip install</code> with <code>--user</code> flag.  Did you <code>pip install --user</code> as root (i.e. with <code>sudo</code>) or your local <code>ec2-user</code>?</span>
<span class="comment-copy">Are you using Python 2 or Python 3? Ensure calling <code>pip</code> and your script happens with the same Python version.</span>
<span class="comment-copy">@Dunedan I am using Python 2.7.</span>
<span class="comment-copy">@metatoaster I am not totally sure here what you are asking but I think this is your answer. I ran the following code to install <code>pip install --user -r requirements.txt</code>    I was not able to run anything with <code>pip</code> and <code>sudo</code> to work in the same line so I used the <code>--user</code> flag to do the install.</span>
<span class="comment-copy">So when you ran <code>sudo python MyCoolApp.py</code>, it will not have access to the packages installed with <code>pip install --user</code>, as the packages are installed local to <code>ec2-user</code> (as per the <code>ec2-user@ip-...</code> prompt included in your logs).  The act of <code>sudo</code> runs the script as the <code>root</code> user thus it won't have access to your <code>ec2-user</code> user-local Python packages.</span>
