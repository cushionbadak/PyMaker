<div class="post-text" itemprop="text">
<p>There are many suggestions but I can't make it stick. The closest solution I have below. The data is like:</p>
<pre><code>my_list = ([1, [2, 3], 4, [5, [6 , [], [8, 9]], 10]], 8)
</code></pre>
<p>and a function</p>
<pre><code>def convert(G, l, d):
    z = []
    if isinstance(x, list):
        print(x)
        z.append(convert(G, x, d))
    else:
        print(x)
        z.append([v[d] for n,v in G.nodes(data=True) if n == l])
    return z
</code></pre>
<p>execution:</p>
<pre><code>print(convert(G, my_list, "name"))
</code></pre>
<p>It gives empty array but print(x) gets the source as is. I'm close I guess. The problem is I don't know how to pass <code>l</code> at <code>if n == l</code> as a integer not list.</p>
<p><strong>EDIT</strong></p>
<p>Outpit:
<code>(['a', ['b', 'c'], 'd', ['e', ['f' , [], ['g', 'h']], 'j']], 'g)</code>
in the same format (nested). The custom function just takes each element (int) and returns its attribute from dict (letter). </p>
<p>Another try:</p>
<pre><code>my_list = ([1, [2, 3], 4, [5, [6 , [], [8, 9]], 10]], 8)
z = []
def convert(G, l, d):
    z.append([convert(G, x, d) if isinstance(x, list) else [v[d] for n,v in G.nodes(data=True) if n == x]])
    return z

z = convert(G, my_`list, "name")
print(z)
</code></pre>
<p>This part is a custom function:</p>
<pre><code>[v[d] for n,v in G.nodes(data=True) if n == l]
</code></pre>
<p>so G can be whatever. You can take it as <code>[...]</code></p>
<p>For example: <code>G.nodes = {0: {'name': 'a'}, 1: {'name': 'b'}, 2: {'name': 'c'}, 3: {'name': 'd'}}</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It seems like you are looking for a kind of <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> function that works for nested lists. Try this:</p>
<pre><code>def deepmap(f, lst):
    return [deepmap(f, x) if isinstance(x, list) else f(x) for x in lst]
</code></pre>
<p>This will convert the outer <code>tuple</code> to another <code>list</code>, though. If you need that to be a tuple, or if there can be more tuples within, it should not be too hard to extend that function accordingly. Example:</p>
<pre><code>&gt;&gt;&gt; my_list = ([1, [2, 3], 4, [5, [6 , [], [8, 9]], 10]], 8)
&gt;&gt;&gt; deepmap(str, my_list)
[['1', ['2', '3'], '4', ['5', ['6', [], ['8', '9']], '10']], '8']
</code></pre>
<p>In your case, the mapping function <code>f</code> might be something like this, not entirely sure though. (You might also want to change your <code>G.nodes</code> data structure so you don't have to iterate all the items but can access item <code>x</code> directly.)</p>
<pre><code>f = lambda x: next(v[d] for n,v in G.nodes(data=True) if n == x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simplified version, following your structure, might look like this:</p>
<pre><code>def v(x):
    return x + 1

def convert(l):
    z = []
    for x in l:
        if isinstance(x, list):
            z.append(convert(x))
        else:
            z.append(v(x))
    return z
</code></pre>
<p>This results in the expected nesting:</p>
<pre><code>&gt;&gt;&gt; convert([[1, [2, 3], 4, [5, [6 , [], [8, 9]], 10]], 8])
[[2, [3, 4], 5, [6, [7, [], [9, 10]], 11]], 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You just need to make a recursive function to do the convert:</p>
<pre><code>my_list = ([1, [2, 3], 4, [5, [6 , [], [8, 9]], 10]], 8)
mapping = {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h', 9: 'i', 10: 'j'}

def convert(inlist):
    def transform(x):
        if isinstance(x, list):
            return convert(x)
        else:
            return mapping.get(x)
    return [transform(x) for x in inlist]
print(convert(my_list))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Define a custom mapper</p>
<pre><code>import string
def mapper(item):
    if not isinstance(item,list):
        return d[item]
    else:
        return [mapper(i) for i in item]

d=dict(zip(range(1, len(string.ascii_lowercase) + 1), string.ascii_lowercase))
</code></pre>
<p>Mapping dict will look like this</p>
<blockquote>
<p>{1: 'a',  2: 'b',  3: 'c',  4: 'd',  5: 'e',  6: 'f',  7: 'g',  8:
  'h',  9: 'i',  10: 'j',  11: 'k',  12: 'l',  13: 'm',  14: 'n',  15:
  'o',  16: 'p',  17: 'q',  18: 'r',  19: 's',  20: 't',  21: 'u',  22:
  'v',  23: 'w',  24: 'x',  25: 'y',  26: 'z'}</p>
</blockquote>
<pre><code>my_list = ([1, [2, 3], 4, [5, [6 , [], [8, 9]], 10]], 8)
tuple([mapper(i) for i in my_list])
</code></pre>
<p>You can also use <code>map</code> function with custom mapper</p>
<pre><code>tuple(map(mapper,my_list))
</code></pre>
<p>Output</p>
<pre><code>(['a', ['b', 'c'], 'd', ['e', ['f', [], ['h', 'i']], 'j']], 'h')
</code></pre>
</div>
<span class="comment-copy">what's your expected outcome for the given data?</span>
<span class="comment-copy">Can you make sure you've included an <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>? For example, what's <code>G</code>? As @Peter.k mentioned, what do you expect the output to be?</span>
<span class="comment-copy">So you want a <code>map</code> function for nested lists?</span>
<span class="comment-copy">Yes. This solution works as well. Just needed to pass <code>d</code> argument to <code>deepmap</code> and <code>lambda</code> the rest is as is.</span>
<span class="comment-copy">Yes, thanks. This is oke. I forgot to iterate <code>for x in l:</code>.</span>
