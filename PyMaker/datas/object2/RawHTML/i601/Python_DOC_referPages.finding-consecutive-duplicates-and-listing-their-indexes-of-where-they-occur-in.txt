<div class="post-text" itemprop="text">
<p>I have a list in python for example:</p>
<pre><code>mylist = [1,1,1,1,1,1,1,1,1,1,1,
        0,0,1,1,1,1,0,0,0,0,0,
        1,1,1,1,1,1,1,1,0,0,0,0,0,0]
</code></pre>
<p>my goal is to find where there are five or more zeros in a row and then list the indexes of where this happens, for example the output for this would be:</p>
<pre><code>[17,21][30,35]
</code></pre>
<p>here is what i have tried/seen in other questions asked on here:</p>
<pre><code>def zero_runs(a):
    # Create an array that is 1 where a is 0, and pad each end with an extra 0.
    iszero = np.concatenate(([0], np.equal(a, 0).view(np.int8), [0]))
    absdiff = np.abs(np.diff(iszero))
    # Runs start and end where absdiff is 1.
    ranges = np.where(absdiff == 1)[0].reshape(-1, 2)
    return ranges

    runs = zero_runs(list)
</code></pre>
<p>this gives output:</p>
<pre><code>[0,10]
[11,12]
...
</code></pre>
<p>which is basically just listing indexes of all duplicates, how would i go about separating this data into what i need</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a>, it will identify the contiguous groups in the list:</p>
<pre><code>from itertools import groupby

lst = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]

groups = [(k, sum(1 for _ in g)) for k, g in groupby(lst)]

cursor = 0
result = []
for k, l in groups:
    if not k and l &gt;= 5:
        result.append([cursor, cursor + l - 1])
    cursor += l

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[17, 21], [30, 35]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your current attempt is very close.  It returns all of the runs of consecutive zeros in an array, so all you need to accomplish is adding a check to filter runs of less than 5 consecutive zeros out.</p>
<hr/>
<pre><code>def threshold_zero_runs(a, threshold):
    iszero = np.concatenate(([0], np.equal(a, 0).view(np.int8), [0]))
    absdiff = np.abs(np.diff(iszero))
    ranges = np.where(absdiff == 1)[0].reshape(-1, 2)

    m = (np.diff(ranges, 1) &gt;= threshold).ravel()
    return ranges[m] 
</code></pre>
<p></p>
<pre><code>array([[17, 22],
       [30, 36]], dtype=int64)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>shift</code> operator on the array.  Compare the shifted version with the original.  Where they do <em>not</em> match, you have a transition.  You then need only to identify adjacent transitions that are at least 5 positions apart.</p>
<p>Can you take it from there?</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way using <code>itertools.groupby</code> and <code>enumerate</code>.</p>
<p>First find the zeros and the indices:</p>
<pre><code>from operator import itemgetter
from itertools import groupby

zerosList = [
    list(map(itemgetter(0), g)) 
    for i, g in groupby(enumerate(mylist), key=itemgetter(1)) 
    if not i
]
print(zerosList)
#[[11, 12], [17, 18, 19, 20, 21], [30, 31, 32, 33, 34, 35]]
</code></pre>
<p>Now just filter <code>zerosList</code>:</p>
<pre><code>runs = [[x[0], x[-1]] for x in zerosList if len(x) &gt;= 5]
print(runs)
#[[17, 21], [30, 35]]
</code></pre>
</div>
<span class="comment-copy">this is the kind of problem where there should be a much more elegant numpy solution</span>
