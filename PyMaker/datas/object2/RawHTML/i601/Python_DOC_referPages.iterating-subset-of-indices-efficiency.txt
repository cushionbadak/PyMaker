<div class="post-text" itemprop="text">
<p>I'm trying to iterate through a subset of elements in a list based on another list of indices. </p>
<p>The shortest / most pythonic way seems like it would use list comprehension to the effect of:</p>
<pre><code>    for elt in [lst[idx] for idx in idxs]:
        elt.do_stuff()
        elt.do_more_stuff()
</code></pre>
<p>But I can't shake the feeling that if I'm going to be looping this a lot, rebuilding the list comprehension every time might be expensive and I should spend the extra line to just write:</p>
<pre><code>    for idx in indxs:
        elt = lst[idx]
        elt.do_stuff()
        elt.do_more_stuff()
</code></pre>
<p>Can someone who knows more about python and its relative efficiencies / inefficiencies way in on the actual computational cost difference between these approaches? I know, I know both ways could probably work fine, but once I started wondering about the difference it got me curious.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your second loop is fine, but your first loop can be made to work without building a temporary <code>list</code> by just using <a href="https://docs.python.org/3/glossary.html#term-generator-expression" rel="nofollow noreferrer">a generator expression</a>:</p>
<pre><code>for elt in (lst[idx] for idx in idxs):
    elt.do_stuff()
    elt.do_more_stuff()
</code></pre>
<p>or (probably slightly faster if there are a lot of indices) by (ab?)using <code>map</code>:</p>
<pre><code>for elt in map(lst.__getitem__, idxs):
    elt.do_stuff()
    elt.do_more_stuff()
</code></pre>
<p>In both cases (at least on Py3 where <code>map</code> returns an iterator, not a new <code>list</code>), the effect is to lazily look up each index as the next <code>elt</code> is requested; it's not eagerly making a <code>list</code> before the loop even begins.</p>
<p>There is one other option that you might consider if you're going to be looking up the same set of indices repeatedly (that is, <code>idxs</code> doesn't change). You could create an <code>operator.itemgetter</code> once up front, and use that. It would operate eagerly (like the <code>list</code> comprehension), but it would:</p>
<ol>
<li>Return a <code>tuple</code> instead of a <code>list</code> (slightly more memory efficient and with better memory locality, but usually not a meaningful difference)</li>
<li>Push the building of said <code>tuple</code>, start to finish, down to the C layer, where a <code>list</code> comprehension, while using specialized bytecodes, still has to do all of its work in the regular interpreter, which at least on CPython is slower than most work pushed to C</li>
</ol>
<p>For that approach, you'd do:</p>
<pre><code># Done once up front
from operator import itemgetter
getidxs = itemgetter(*idxs)  # Note: Will fail if idxs is not at least length 2; won't return tuple when getting one item

# Done every time
for elt in getidxs(lst):
    elt.do_stuff()
    elt.do_more_stuff()
</code></pre>
<p>You'd need to profile to determine:</p>
<ol>
<li>Whether any of this optimization is actually needed</li>
<li>Which solution makes the most sense for you (eager solutions like <code>itemgetter</code> and the listcomp use more memory, but might run faster; lazy solutions have fixed and small memory overhead, but might run a titch slower)</li>
</ol>
</div>
<span class="comment-copy">The second one will be as efficient as anything else you might get as a suggestion</span>
<span class="comment-copy">@smac89: Agreed. I offered options, but I'd default to the second solution and only consider a switch if profiling showed it was the key chokepoint and one of my other solutions actually showed an improvement (unlikely to be a major improvement).</span>
