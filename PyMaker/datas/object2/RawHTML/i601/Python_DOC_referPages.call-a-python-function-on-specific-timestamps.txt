<div class="post-text" itemprop="text">
<p>I am trying to send a query to an API every full minute because the API updates its data every minute and I want the updated data ASAP. 
It is important that the timing is very precise, I want to run everything continuously in the end.</p>
<p>this is vaguely what I am trying to do:</p>
<pre><code>import time, sched

time = 1549667056000  # starting timestamp

def get_data():  # function to get some data from the API via requests
    #gets the Data

while true:
    s.scheduler(time)
    s.run(get_data())  # gets the data on the specified time(stamp)
    time = time + 60000  # adds 1 minute to the timestamp
</code></pre>
<p>Can somebody help me with this?
Or is there a even smarter way of getting data from a REST Api exactly every full minute?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/asyncio-task.html#sleeping" rel="nofollow noreferrer">asyncio.sleep</a></p>
<p>For Python &lt; 3.7</p>
<pre><code>import asyncio

def get_data():
    print("Getting data")

async def main():
    while true:
        get_data()
        await asyncio.wait(MINUTE)

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
<p>For Python 3.7+</p>
<pre><code>import asyncio

def get_data():
    print("Getting data")

async def main():
    while true:
        get_data()
        await asyncio.wait(60)

#This is the only thing that changes
asyncio.run(main)
</code></pre>
<p><strong>edit</strong></p>
<p>As per your comment, if you're really worried about making sure this gets called every 60 seconds.</p>
<p>You could implement a way to take the time before <code>get_data</code> is called and subtract that from 60, just need to make sure if <code>get_data</code> does take over 60 secs to wait 0 secs or not at all.</p>
<p>Something like this for your <code>main()</code> should work:</p>
<pre><code>#make sure to:
import time

async def main():
    while true:
        t = time.time()
        get_data()
        time_diff = int(time.time() - t)
        await asyncio.wait(max(60 - time_diff, 0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to everyone for helping out.</p>
<p><a href="https://stackoverflow.com/a/25251804/9025949">This Answer</a> worked for me pretty well in the end:</p>
<pre><code>import time
starttime = time.time()
while True:
  print(time.time())
  time.sleep(60.0 - ((time.time() - starttime) % 60.0))
</code></pre>
<p>I let it run over night, there was no shift overtime. The time between the executions is exactly 60, no matter how long the code in the loop takes to execute.</p>
</div>
<span class="comment-copy">What about using <a href="https://en.wikipedia.org/wiki/Cron" rel="nofollow noreferrer">cron</a>?</span>
<span class="comment-copy">As far as I know I can only start an entire python process with corn, not a function. I have to load a tensorflow model later on, which takes time that I dont have in this scenario. So I'd like to load the Model and feed it the Data every minute.</span>
<span class="comment-copy">Thx for the answer. The problem is that the API request takes some time, so I have this time + the 60 seconds which will drag the whole "schedule" behind (so I have 61 secs instead of 60 at every iteration), which leads to the problem that I do not meet the next full minute.</span>
<span class="comment-copy">That shouldn't really matter much at all because every <i>roughly</i> 60 seconds you're getting the newest data, but if you insist I edited my answer with a way to do that.</span>
