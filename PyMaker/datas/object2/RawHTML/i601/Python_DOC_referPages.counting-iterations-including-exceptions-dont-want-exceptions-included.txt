<div class="post-text" itemprop="text">
<p>I am working through the Python for Everybody book (Py4E). A problem there is a problem asks </p>
<blockquote>
<p>Write a program which repeatedly reads numbers until the user enters "Done". Once "done" is entered, print out the total, count, and average of the numbers.
  If the user enters anything other than a number, detect their mistake using try
    and except and print an error message and skip to the next number.</p>
</blockquote>
<p>The problem is the "count" includes entries other than a number. I would like to know how to write the code to avoid this. The code I wrote to solve the problem is below. </p>
<p>I have tried relocating the <code>except</code> above the <code>counter</code> variable, and a few other indentation manipulations. Also have tried to use the <code>int()</code> function on <code>read_num</code>. </p>
<pre><code>tally=0
counter = 0
while True:

    read_num = input("please provide a number... ")
    try:
        if read_num=='Done' or read_num =='done':
            break
        else:
            counter = int(counter)+1
            tally = int(tally) + int(read_num)
            avg = tally/counter
    except:
        print("Enter a number... ")

print("total is: " + str(tally))
print("the total number of enteries was: " + str(counter))
print("the average number entered was: " + str(avg)) 
</code></pre>
<p>The expected result is that when a number is not entered, the <code>try</code> block is bypassed and the <code>except</code> block is activated, thereby avoiding the additional cycle in <code>counter</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Hey you are actually pretty close.  You are incrementing your count <strong>before</strong> you parse it into an int (which raises the valueError exception on things other than numbers).  Ideally you want to increment your counter once you know the read_num can be pared into an int, not before.</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that you are thinking of the <code>try</code> block like a transaction. With a transaction-based approach, if an exception is hit in the block, all of the code executed in that block would be rolled back.</p>
<p>In reality, python executes each line in the try block and only jumps to the except block if and when an exception is hit. This means changes made by successful lines of code are kept.</p>
<p><code>counter = int(counter) + 1</code> is always going to be successful - since counter is already an integer. This line executes successfully, and then the exception is caught on the next line. Either move the first line below the second, or move this outside the try block completely and include an <code>else</code> block. The <code>else</code> block only executes if the <code>try</code> is successful (Best practice is to only include the line where you'd be expecting the exception in the try block):</p>
<pre><code>tally=0
counter = 0
avg = 0
while True:
    read_num = input("please provide a number... ")
    if read_num=='Done' or read_num =='done':
        break
    else:
        try:
            tally = int(tally) + int(read_num)
        except:
            print("Enter a number... ")
        else:
            counter = int(counter)+1

if counter &gt; 0:
    avg = tally/counter

print("total is: " + str(tally))
print("the total number of enteries was: " + str(counter))
print("the average number entered was: " + str(avg)) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am leaving this, in case anyone else comes across this (it seems to be a popular class/book)</p>
<p>I included avg = 0 as a flag so if done is entered at the first input, there isn't an error by trying to divide by zero.  </p>
<p>Also, included <code>read_num == int(read_num)</code> prior to the <code>counter = counter + 1</code> to throw the exception before it the program reached the counter. </p>
<pre><code>tally = 0
counter = 0
avg = 0

while True:

    read_num = input("please provide a number... ")
    try:
        if read_num=='Done' or read_num =='done':
            break
        else:
            read_num == int(read_num)
            counter = int(counter)+1
            tally = int(tally) + int(read_num)
            avg = tally/counter
    except:
        print("Enter a number....")

print("total is: " + str(tally))
print("the total number of enteries was: " + str(counter))
print("the average number entered was: " + str(avg))
</code></pre>
</div>
<span class="comment-copy">You probably shouldn't be using a bare except statement which will catch all Exceptions not just the one you anticipate which is a <code>ValueError</code>. <a href="https://docs.python.org/3/tutorial/errors.html#errors-and-exceptions" rel="nofollow noreferrer">docs.python.org/3/tutorial/errors.html#errors-and-exceptions</a></span>
<span class="comment-copy"><a href="https://stackoverflow.com/help/someone-answers">What should I do when someone answers my question?</a></span>
<span class="comment-copy"><code>Best practice is to only include the line where you'd be expecting the exception in the try block.</code>  Thanks!! This actually helped clean up the code a lot.</span>
<span class="comment-copy">Why are you recomputing the average at every iteration?</span>
<span class="comment-copy">@MadPhysicist - Good point. Corrected</span>
