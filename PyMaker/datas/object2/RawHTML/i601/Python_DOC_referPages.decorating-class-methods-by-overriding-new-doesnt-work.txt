<div class="post-text" itemprop="text">
<p>I want to decorate all the methods of my class. I have written a sample small decorator for illustration purpose here.</p>
<p>Decorator:</p>
<pre><code>def debug(func):
    msg = func.__name__

    @wraps(func)
    def wrapper(*args, **kwargs):
        print(msg)
        return func(*args, **kwargs)
    return wrapper 

def debugmethods(cls):
    for key, val in vars(cls).items():
        if callable(val):
            setattr(cls, key, debug(val))
    return cls
</code></pre>
<p>Now I want to decorate all the methods of my class. One simple way is to use @debugmethods annotation on top of my class but I am trying to understand two other different approaches for doing so.</p>
<p>a) Overriding <code>__new__</code></p>
<pre><code>class Spam:
    def __new__(cls, *args, **kwargs):
        clsobj = super().__new__(cls)
        clsobj = debugmethods(clsobj)
        return clsobj

    def __init__(self):
        pass

    def foo(self):
        pass

    def bar(self):
        pass

spam = Spam()
spam.foo()
</code></pre>
<p>b) Writing metaclass</p>
<pre><code>class debugmeta(type):
    def __new__(cls, clsname, bases, clsdict):
        clsobj = super().__new__(cls, clsname, bases, clsdict)
        clsobj = debugmethods(clsobj)
        return clsobj

class Spam(metaclass = debugmeta):     
    def foo(self):
        pass

    def bar(self):
        pass

spam = Spam()
spam.foo()
</code></pre>
<p>I am not sure </p>
<ol>
<li>Why " a) overriding <code>__new__</code> " doesn't work ?</li>
<li>Why signature of method <code>__new__</code> is different in metaclass? </li>
</ol>
<p>Can someone help me understand what am I missing here.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You appear to be confused between <code>__new__</code> and metaclasses. <code>__new__</code> is called to create a new object (an instance from a class, a class from a metaclass), it is not a 'class created' hook.</p>
<p>The normal pattern is:</p>
<ul>
<li><code>Foo(...)</code> is translated to <code>type(Foo).__call__(Foo, ...)</code>, see <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">special method lookups</a> for why that is. The <code>type()</code> of a class is it's metaclass.</li>
<li><p>The standard <code>type.__call__</code> implementation used when <code>Foo</code> is a custom Python class will call <code>__new__</code> to create a new instance, then call the <code>__init__</code> method on that instance if the result is indeed an instance of the <code>Foo</code> class:</p>
<pre><code>def __call__(cls, *args, **kwargs):  # Foo(...) -&gt; cls=Foo
    instance = cls.__new__(cls, *args, **kwargs)  # so Foo.__new__(Foo, ...)
    if isinstance(instance, cls):
        instance.__init__(*args, **kwargs)        # Foo.__init__(instance, ...)
    return instance
</code></pre>
<p>So <code>Foo.__new__</code> is not called when the <code>Foo</code> class itself is created, only when <em>instances</em> of <code>Foo</code> are created.</p></li>
</ul>
<p>You don't usually need to use <code>__new__</code> in classes, because <code>__init__</code> suffices to initialise the attributes of instances. But for <em>immutable</em> types, like <code>int</code> or <code>tuple</code>, you can only use <code>__new__</code> to prepare the new instance state, as you can't alter the attributes of an immutable object once it is created. <code>__new__</code> is also helpful when you want change what kinds of instances <code>ClassObj()</code> produce (such as creating singletons or producing specialised subclasses instead).</p>
<p>The same <code>__call__</code> -&gt; <code>__new__</code> and maybe <code>__init__</code> process applies to metaclasses. A <code>class Foo: ...</code> statement is implemented by calling the metaclass to create a class object, passing in 3 arguments: the class name, the class bases, and the class body, as a dictionary usually. With <code>class Spam(metaclass = debugmeta): ...</code>, that means <code>debugmeta('Spam', (), {...})</code> is called, which means <code>debugmeta.__new__(debugmeta, 'Spam', (), {...})</code> is called.</p>
<p>Your first attempt <em>a</em>, setting <code>Spam.__new__</code> doesn't work, because you are <em>not creating a class object</em> there. Instead, <code>super().__new__(cls)</code> creates an empty <code>Spam()</code> <em>instance</em> with no attributes, so <code>vars()</code> returns an empty dictionary and <code>debugmethods()</code> ends up doing nothing.</p>
<p>If you want to hook into class creation, then you want a metaclass.</p>
</div>
<span class="comment-copy">A metaclass creates classes, a class creates instances. The <code>__new__</code> method signatures reflect this.</span>
<span class="comment-copy">Makes sense. You mean to say there is <code>__new__</code> method from metaclass also getting called in a)? If yes then when does that <code>__new__</code> gets called and who is making that call?</span>
<span class="comment-copy">No, <code>__new__</code> in <code>a)</code> is called to create an <i>instance</i> of the <code>Spam</code> class. <code>super().__new__()</code> returns that instance. You don't have a class there.</span>
<span class="comment-copy">This is an amazing explanation. Thanks a lot for the detailed write-up, this clears my doubt.</span>
