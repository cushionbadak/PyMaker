<div class="post-text" itemprop="text">
<p>This may be a stupid question, but I don't get in Python how we can use object that we did not some define or imported.</p>
<p>Consider the following example, using Python's <a href="https://docs.python.org/2/library/datetime.html" rel="nofollow noreferrer">datetime</a> module:</p>
<pre><code>from datetime import date

date1 = date(2019,1,1)
date2 = date(2019,1,5)

type(date2-date1) #&lt;class 'datetime.timedelta'&gt;
type(date2)       #&lt;class 'datetime.date'&gt;
</code></pre>
<p>Then <code>date2-date1</code> is of <code>timedelta</code> class, even though we haven't imported this.</p>
<p>(I could probably also cook up other examples, where we obtain objects, even though we haven't defined them.)</p>
<p>How can this be?      </p>
<p>Should I think about these new objects that pop up simply as pieces in memory that are being returned by other functions, that, even though we haven't defined them, contain "in themselves" enough information so that the Python interpreter can meaningfully apply the <code>type()</code> and other functions to them?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are incorrectly assuming that <code>import</code> limits what is loaded into memory. <code>import</code> limits what <strong>names are bound in your module globals</strong>. </p>
<p>The whole module is still loaded, as are dependencies of that module. Just because <em>your namespace</em> doesn't bind a reference to the <code>datetime.timedelta</code> object doesn't mean it is not available to the <code>datetime</code> module.</p>
<p>See the <a href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="nofollow noreferrer"><code>import</code> statement documentation</a>:</p>
<blockquote>
<p>The <code>from</code> form uses a slightly more complex process:</p>
<ol>
<li>find the module specified in the <code>from</code> clause, loading and initializing it if necessary;</li>
<li>for each of the identifiers specified in the <code>import</code> clauses:
  
  <ol>
<li>check if the imported module has an attribute by that name</li>
<li>if not, attempt to import a submodule with that name and then check the imported module again for that attribute</li>
<li>if the attribute is not found, <code>ImportError</code> is raised.</li>
<li>otherwise, a reference to that value is stored in the local namespace, using the name in the as clause if it is present, otherwise using the attribute name</li>
</ol></li>
</ol>
</blockquote>
<p>So loading and initialising of modules is a separate step, <em>executed once</em> per module. The second step binds names in your namespace. </p>
<p><code>from datetime import date</code> makes sure the <code>datetime</code> module is loaded, then finds <code>datetime.date</code> and adds <code>date = datetime.date</code> to <em>your</em> namespace.</p>
<p>If you want to see what modules are loaded, check out the <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code> mapping</a>. That's the location that the <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer"><code>import</code> statement machinery checks</a> to see if a given module has been loaded yet.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from datetime import date
</code></pre>
<p>Date is importing timedelta somewhere, as it might be a dependency, even if you don't see it.</p>
</div>
<span class="comment-copy">Thanks! SE still makes me wait 9 minutes until I can accept your answer :) But in the meantime, for the fun of it, let me ask: Is it somehow possible to coax my code into defining an object, storing it somewhere, and then loading it by a different Python script, so that I actually end up with an object during runtime for which there is no definition earlier in my Python script?</span>
<span class="comment-copy">Analogy being <code>import datetime</code>, <code>date = datetime.date</code>, <code>del datetime</code></span>
<span class="comment-copy">@Ayxan Ah, but then I lost the reference to my object. I would like to still be able to reference it, but the object not being defined earlier, just being some area of my memory that's occupied (I'm not sure if it makes any sense what I'm asking, I'm just trying to formalize a vague understanding I have of the inner workings of the Python interpreter).</span>
<span class="comment-copy">@Ayxan: sorta-kinda-not-really, because that'd has to assume that the name <code>datetime</code> was not already bound to something else. <code>date = __import__('datetime', fromlist=['date']).date</code> comes closer.</span>
<span class="comment-copy">@G.Anderson: and that's the pure-Python implementation, in the vast majority of installations all those names are clobbered by the <code>from _datetime import *</code> further down to load the <a href="https://github.com/python/cpython/blob/master/Modules/_datetimemodule.c" rel="nofollow noreferrer">C-defined extension</a>, where <a href="https://github.com/python/cpython/blob/master/Modules/_datetimemodule.c#L3039-L3064" rel="nofollow noreferrer"><code>date_subtract()</code></a> calls <a href="https://github.com/python/cpython/blob/master/Modules/_datetimemodule.c#L1018-L1049" rel="nofollow noreferrer"><code>new_delta()</code></a> to create the <code>timedelta</code> instance.</span>
<span class="comment-copy">+1. Do you know if there is a way highlight all depedencies that are being imported when I import a given module?</span>
<span class="comment-copy">@l7ll7: that's a lot more complex than you'd want think about. You could snapshot <code>sys.modules</code> (which would only give you <i>not yet loaded</i> dependencies) or replace <code>bltins.__import__</code> with a wrapper function that tracks what is being imported (but that won't track extension modules loading more modules).</span>
<span class="comment-copy">@MartijnPieters Wow, ok, I'll save that then for a later SE question at a later time, when I know more about Python...</span>
