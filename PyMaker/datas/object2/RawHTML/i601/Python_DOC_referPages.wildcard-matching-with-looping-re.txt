<div class="post-text" itemprop="text">
<p>I'm trying to improve the matching expression of this code so that it matches spaces before or after the string and also ignores the case. The goal is to output the shortened state abbreviation.</p>
<pre><code>import re
s = "new South Wales "
for r in (("New South Wales", "NSW"), ("Victoria", "VIC"), ("Queensland", "QLD"), ("South Australia", "SA"), ("Western Australia", "WA"), ("Northern Territory", "NT"), ("Tasmania", "TAS"), ("Australian Capital Territory", "ACT")):
    s = s.replace(*r)
    output = {'state': s}
    print (output)
</code></pre>
<p>I've figured out the regex to do this (see <a href="https://regex101.com/r/EwvuHA/18" rel="nofollow noreferrer">here</a>):</p>
<pre><code>(?i)(?&lt;!\S)New South Wales(?!\S)
</code></pre>
<p>which will match with or without spaces on either side of string and also ignores case. Can anyone help me update my original code to include the new regex?</p>
</div>
<div class="post-text" itemprop="text">
<p>If I were you I would just strip() the string before passing it in and use something like <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer">re.sub()</a> where we can tell it to ignore the case using '<em>flags=re.IGNORECASE</em>' like below. </p>
<pre><code>import re

s = "  new South Wales ".strip()
for r in (("New South Wales", "NSW"), ("Victoria", "VIC"), ("Queensland", "QLD"), ("South Australia", "SA"), ("Western Australia", "WA"), ("Northern Territory", "NT"), ("Tasmania", "TAS"), ("Australian Capital Territory", "ACT")):
    _regex = '{0}|{1}'.format(r[0], r[1])
    if re.match(_regex, s, flags=re.IGNORECASE):
        subbed_string = re.sub(r[0], r[1], s, flags=re.IGNORECASE)
        print({'state': subbed_string.upper()})
</code></pre>
<p>Additionally I have added in a check for a match before trying to substitute in the value. Otherwise you could output the wrong result. For example:</p>
<blockquote>
<p>(('Tasmania', 'TAS'){'state': 'new South Wales'})</p>
</blockquote>
</div>
<span class="comment-copy">I think this question would be more clear with sample input and sample desired output. It's obvious enough what it would do with input that matched your strings exactly, but what do you want it to do if it does match spaces before and after.</span>
<span class="comment-copy">Yes, good idea. Sample inputs are: "NSW" "New South Wales" " new south wales " "New south wales". Desired output is always the shortened form e.g. "NSW". Same idea for the other states.</span>
<span class="comment-copy">I should have explained that sometimes s="NSW" and in those cases we would still output that. It seems the above does not handle that scenario. Any ideas?</span>
<span class="comment-copy">@Neil It's just a case of adding an or to the regex to check 'New South Wales|NSW'. Built in the code like this: <code>_regex = '{0}|{1}'.format(r[0], r[1])</code>. Then we just convert the result to upper() for consistency.</span>
