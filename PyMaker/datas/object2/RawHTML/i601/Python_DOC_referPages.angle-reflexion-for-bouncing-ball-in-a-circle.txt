<div class="post-text" itemprop="text">
<p>I am making a game with some bouncing elements IN a circle (I use pygame) ,
My elements have 2 attributes  , one for the angle and one for the speed
Here is how elements moves :</p>
<pre><code>mvx = math.sin(self.angle) * self.speed  
mvy = -math.cos(self.angle) * self.speed  
self.x += mvx  
self.y += mvy
</code></pre>
<p>My problem is this : I know the angle at the top (99.6°) , I have the collision point (x and y ) , but I'm unable to find the angle at the bottom(42.27°)
Does someones can make a relation between the first angle and the second ? </p>
<p>Picture is better ...<br/>
<a href="https://i.stack.imgur.com/2lOLn.png" rel="nofollow noreferrer"><img alt="" src="https://i.stack.imgur.com/2lOLn.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend do calculate the <a href="https://en.wikipedia.org/wiki/Reflection_(mathematics)" rel="nofollow noreferrer">reflection</a> vector to the incident vector on the circular surface.<br/>
In the following formula <code>N</code> is the normal vector of the circle, <code>I</code> is the incident vector (the current direction vector of the bouncing ball) and <code>R</code> is the reflection vector (outgoing direction vector of the bouncing ball):</p>
<pre class="lang-none prettyprint-override"><code>R = I - 2.0 * dot(N, I) * N.
</code></pre>
<p>Use the <a href="https://www.pygame.org/docs/ref/math.html#pygame.math.Vector2.normalize" rel="nofollow noreferrer"><code>pygame.math.Vector2</code></a>.</p>
<p>To calculate the normal vector, you' ve to know the "hit" point (<code>dvx</code>, <code>dvy</code>) and the center point of the circle (<code>cptx</code>, <code>cpty</code>): </p>
<pre class="lang-py prettyprint-override"><code>circN = (pygame.math.Vector2(cptx - px, cpty - py)).normalize()
</code></pre>
<p>Calculate the reflection:</p>
<pre class="lang-py prettyprint-override"><code>vecR = vecI - 2 * circN.dot(vecI) * circN
</code></pre>
<p>The new angle can be calculated by <a href="https://docs.python.org/3/library/math.html" rel="nofollow noreferrer"><code>math.atan2(y, x)</code></a>:</p>
<pre><code>self.angle  = math.atan2(vecR[1], vecR[0])
</code></pre>
<p>Code listing:</p>
<pre class="lang-py prettyprint-override"><code>import math
import pygame
</code></pre>
<pre class="lang-py prettyprint-override"><code>px = [...] # x coordinate of the "hit" point on the circle
py = [...] # y coordinate of the "hit" point on the circle

cptx = [...] # x coordinate of the center point of the circle
cpty = [...] # y coordinate of the center point of the circle

circN = (pygame.math.Vector2(cptx - px, cpty - py)).normalize()
vecI  = pygame.math.Vector2(math.cos(self.angle), math.sin(self.angle))
vecR  = vecI - 2 * circN.dot(vecI) * circN

self.angle = math.pi + math.atan2(vecR[1], vecR[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The inner angles of a triangle need to sum up to <code>180°</code>. Also, the angle <code>99.96°</code> is supplementary to the triangle's angle next to it (calling it by <code>A</code>), i.e. <code>99.96° + A = 180°</code> so <code>A = 180° - 99.96°</code>. Calling of <code>B = 42.27°</code> the bottom angle. And for the last angle <code>C</code>, we can use that it is opposed by the vertex with the other angle that is equal to <code>2 * 28.85 = 57.7°</code>.
Then:</p>
<pre><code>A + B + C = 180°

180° - 99.96° + 42.27°  + 2 * 28.85° = 180°

180° - 99.96° + 42.27°  + 2 * 28.85° = 180°

-99.96° + 42.27°  + 2 * 28.85° = 0°

42.27°  + 2 * 28.85° = 99.96°

B + C = Top angle
</code></pre>
<p>P.S.: I know that the values are not exactly equal, but it must be because of the decimal places rounding</p>
</div>
<span class="comment-copy">what about just <code>a1 = a2 + a3</code>? <code>a1 = 42.27 + 28.85*2</code></span>
<span class="comment-copy">Thank's a lot ! It works ! I just add PI to the last angle to change his direction      self.angle = math.pi + math.atan2(vecR[1], vecR[0])</span>
