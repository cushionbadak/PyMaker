<div class="post-text" itemprop="text">
<p>I'm trying to exploit buffer and my code with <strong>python 3</strong> looks like this:</p>
<pre><code>python3 -c "print ('A' * 44 + '\xcb\x85\x04\x08')" | ./vuln
</code></pre>
<p>Or another way with <strong>2.7</strong>:</p>
<pre><code>python2.7 -c "print 'A' * 44 + '\xcb\x85\x04\x08'" | ./vuln
</code></pre>
<p>But in this case only 2.7 works fine, so I tried to check hex:</p>
<p><strong>python2.7 -c "print 'A' * 44 + '\xcb\x85\x04\x08'" | hexdump</strong><br/>
0000020 4141 4141 4141 4141 4141 4141 85cb 0804<br/>
0000030 000a                                  </p>
<p><strong>python3 -c "print ('A' * 44 + '\xcb\x85\x04\x08')" | hexdump</strong><br/>
0000020 4141 4141 4141 4141 4141 4141 8bc3 85c2<br/>
0000030 0804 000a                              </p>
<p>It doesn't depend on the system (I've tried on ubuntu and arch), doesn't depend on terminal (also tried different ones)<br/>
Looks like python 3 adds something and changes the memory but why and is it really normal?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, strings and ranges of bytes are one and the same. This gave problems with non-ASCII strings so they changed it in Python 3. In Python 3 there is a <code>bytes</code> type, which is the one you want. The easiest way to construct a bytes string is to prepend the literal with a <code>b</code>:</p>
<pre><code>b'A' * 44 + b'\xcb\x85\x04\x08'
</code></pre>
<p>However, you can't print a <code>bytes</code> directly like in Python 2. Python 3 will give a nice representation of your bytes, like this:</p>
<pre><code>b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xcb\x85\x04\x08'
</code></pre>
<p>Obviously this is all ASCII and not the bytes you want. To write bytes directly to stdout, use sys.stdout.buffer.write:</p>
<pre><code>python3 -c "import sys;sys.stdout.buffer.write(b'A' * 44 + b'\xcb\x85\x04\x08')"
</code></pre>
<p>Note that this doesn't write the newline at the end:</p>
<pre><code>0000020 41 41 41 41 41 41 41 41 41 41 41 41 cb 85 04 08
</code></pre>
<p>This may seem all a bit of a hassle for outputting some bytes, especially compared to Python 2. This is because Python 3 really improved the way human readable text is output. One consequence of this is that it is harder to print bytes without any encoding, since this is normally incorrect when outputting text.</p>
</div>
<div class="post-text" itemprop="text">
<p>My guess is the 000a and 0804 000a are end-of-string and carriage return characters. I looked them up in the ASCII table.</p>
<pre><code>ASCII descriptions of the following hex values:
0a = LF -&gt; Newline.
00 = NULL
08 = backspace
04 = end of transmission
</code></pre>
<p>Why Python introduces these backspace and EOT chars is unclear to me. Try the python format function to format it to characters.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/howto/pyporting.html#text-versus-binary-data" rel="nofollow noreferrer">docs.python.org/3/howto/pyporting.html#text-versus-binary-data</a></span>
