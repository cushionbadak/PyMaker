<div class="post-text" itemprop="text">
<p>I have a data structure below which I use to keep track of certain data from a video game.</p>
<pre><code>values = {
    'kills': None,
    'assists': None,
    'deaths': None,
    'minutes': None,
    'seconds': None,
}
</code></pre>
<p>Depending on what data I have available I fill up the <code>values</code> as I go. But, all the attributes are optional and could be <code>None</code>. Ex. <code>kills</code> could be <code>12</code> or <code>None</code>. It all depends on what data I had available in that moment. I could make this a bit better by having an object to store the data, but I'll still have the issue of these optional values.</p>
<p>What's the best way to deal with optionals like this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your instincts were right.  There's no need to store all possible options.  Just store the ones that are applicable.</p>
<h2>Solution 1: Use get() instead of storing Nones</h2>
<p>Usually, we don't store all the possible <em>None</em> values in a dictionary.  Just fill in the the non-None values and use the <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><em>dict.get()</em></a> method for fetch values:</p>
<pre><code>&gt;&gt;&gt; options = {'weapon': 'dagger'}
&gt;&gt;&gt; print(options.get('weapon'))
dagger
&gt;&gt;&gt; print(options.get('food'))
None
</code></pre>
<h2>Solution 2: Counter defaults to zero for numeric data</h2>
<p>If the values are all numeric, consider using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter()</a> which lets optional entries default to zero:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; options = Counter(kills=4, deaths=2)
&gt;&gt;&gt; options['kills']
4
&gt;&gt;&gt; options['deaths'] += 1
&gt;&gt;&gt; options['deaths']
3
&gt;&gt;&gt; options['assists']
0
</code></pre>
<h2>Solution 3: getattr() for optional data in instances or classes</h2>
<p>The <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">getattr()</a> function lets you specific default values for attribute lookup when using instances or classes.  The instance approach is especially helpful for tracking data for each player:</p>
<pre><code>&gt;&gt;&gt; anka = Player()
&gt;&gt;&gt; vlad = Player()
&gt;&gt;&gt; anka.hits = 5
&gt;&gt;&gt; vlad.assists = 2
&gt;&gt;&gt; print(getattr(anka, 'hits', None))
5
&gt;&gt;&gt; print(getattr(vlad, 'hits', None))
None
</code></pre>
<h2>Solution 4: For known defaults, use a ChainMap</h2>
<p>The <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer">ChainMap</a> class lets you link pairs of dictionaries together to treat them as a single entity.</p>
<pre><code>&gt;&gt;&gt; from collections import ChainMap
&gt;&gt;&gt; defaults = ChainMap(dict(kills=0, assists=0, location='start', status='alive'))
&gt;&gt;&gt; anka = defaults.new_child()
&gt;&gt;&gt; vlad = defaults.new_child()
&gt;&gt;&gt; anka['hits'] = 5
&gt;&gt;&gt; vlad['assists'] = 2
&gt;&gt;&gt; anka['hits']
5
&gt;&gt;&gt; vlad['location']
'start'
</code></pre>
<p>This last solution lets you organize all possible defaults in one place, while letting instances store only the data that is needed.  It also provids simple dictionary access so there is no need for <em>get()</em> or <em>getattr()</em> for every lookup.</p>
<p>Hope one of these solutions is a good fit for your problem :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you simply never want to initialize the keys until you have to, you can use defaultdict from the collections package to insert new keys on the fly without the need of initially setting the key value pair.</p>
<pre><code>from collections import defaultdict

values = defaultdict(int)

values['seconds'] += 1
values['assists'] += 1
</code></pre>
</div>
<span class="comment-copy">Where does the problem come in?</span>
<span class="comment-copy">At the moment, I am working on a program where I retrieve data from a game via computer vision. So, sometimes I may never detect the # of kills, so it'd stay None, and sometimes I do detect it. Same for all the other attributes.</span>
<span class="comment-copy">That still just sounds like a description of what happens, not a problem. Sometimes it’s <code>None</code>, sometimes it’s not. What about this causes an issue?</span>
<span class="comment-copy">This looks fine to me. Start with a dict with all 'None' values, then run through the logic to change each value if it is applicable. Or use the <code>defaultDict</code> as mentioned in the other answers.</span>
<span class="comment-copy">The main issue for me arises when I want to parse the values dictionary now. I essentially need to keep track of the names of the attributes all over my code. So, if I decide to add a new attribute or change the name of an existing attribute it turns out to be a massive pain.</span>
<span class="comment-copy">I've thought about this and it works well! But, I feel that it lacks some structure and clarity since all the attributes are not declared in one place. Instead, the attributes are stored as you go depending on what is available. Is there perhaps a way the attributes can be stored in one place to maintain clarity?</span>
<span class="comment-copy">It depends on the context. I use the <code>dict.get()</code> method frequently if the dict is only meant to pass values around e.g. into a function. However it might not be applicable if you instead want to dict to be a more permanent value storage location.</span>
<span class="comment-copy">I thought about this as well, but the dictionary itself can have values that are bool, int, and string.</span>
<span class="comment-copy">@farza what is your end goal? It sounds like you could just initialize a empty dictionary (a = {}) and add whatever keys you need to it when and if you need them?</span>
