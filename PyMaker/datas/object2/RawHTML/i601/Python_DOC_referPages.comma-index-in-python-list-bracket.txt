<div class="post-text" itemprop="text">
<p>example is below. What is this? A comma is in the python list-bracket. How can I understand this?</p>
<p><code>id(x[i,j]) == id(x[i][j])</code> shows True. </p>
<p>So, <code>x[i,j]</code> is always same at <code>x[i][j]</code>?</p>
<p>or, <code>x[i,j]</code> is actually same as <code>x[(i,j)]</code>? index is tuple. </p>
<pre><code>import numpy as np
x = np.random.random((64,3,32,10))
for i in range(x.shape[0]):
    for j in range(x.shape[1]):
        print(x[i,j])
</code></pre>
<p>======<br/>
 I guess 
this is numpy's special implementation. Numpy overwrites "_getitem__" function for using tuple index. </p>
<p>I tried it for<br/>
1) basic python<br/>
2) overwrite "_getitem__ " and<br/>
3) basic numpy.</p>
<p>1) shows error. "TypeError: list indices must be integers or slices, not tuple"<br/>
2) has....no problem if I implemented right.<br/>
3) just works well.</p>
<p>So, I guess numpy developers did implemented their "<em>getitem</em>" function for tuple, and it works same arr[x,y,z] == arr[x][y][z].</p>
</div>
<div class="post-text" itemprop="text">
<p>While numpy behaves the same way with the two, they are technically different.</p>
<p>You can see the difference by implementing <code>__getitem__</code> yourself:</p>
<pre><code>class GetitemTest(object):
    def __getitem__(self, item):
        print("getting: %r" %(item, ))
        return self
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; x = GetitemTest()
&gt;&gt;&gt; x[1,2]
getting: (1, 2)
&lt;__main__.GetitemTest object at 0x10bb6d810&gt;

&gt;&gt;&gt; x[1][2]
getting: 1
getting: 2
&lt;__main__.GetitemTest object at 0x10bb6d810&gt;
</code></pre>
<p>Notice that <code>x[1,2]</code> only calls <code>__getitem__</code> once, but <code>x[1][2]</code> calls it twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is Numpy special ability.<br/>
<a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.indexing.html" rel="nofollow noreferrer">Numpy official docs</a><br/>
"Unlike lists and tuples, numpy arrays support multidimensional indexing for multidimensional arrays. That means that it is not necessary to separate each dimension’s index into its own set of square brackets."</p>
<pre><code>&gt;&gt;&gt; x.shape = (2,5) # now x is 2-dimensional
&gt;&gt;&gt; x[1,3]
8
&gt;&gt;&gt; x[1,-1]
9
</code></pre>
</div>
<span class="comment-copy">That is an indexing operation. <code>x[i, j]</code> -&gt; <code>x.__getitem__((i, j))</code> "x[i,j] is alway same at x[i][j]?" No, not necessarily.</span>
<span class="comment-copy">Dont base conclusions off of <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id()</code></a> It is a method to check if two references point to the same object. In case of numpy, where the core arrays are "outsourced" to C, the python just has a reference which stays true for all indices.</span>
<span class="comment-copy">@ParitoshSingh "the python just has a reference which stays true for all indices" huh?</span>
<span class="comment-copy">@ParitoshSingh: That's not how the ID values or the references work. What's going on is that the lifetimes of the wrapper objects are non-overlapping, so Python is free to reuse the memory. (In this particular case, the wrapper objects are derived from the same array cell and contain the same value, but that turns out to have no effect at all on how things work out.)</span>
<span class="comment-copy"><a href="https://ideone.com/7ItVIK" rel="nofollow noreferrer">If you keep the wrapper objects alive</a>, the allocator can't reuse the same memory, and you end up with different ID values.</span>
<span class="comment-copy">So, tuple list-index only allowed when it(gettiem fun) overwrite or re-implement for using tuple index?</span>
<span class="comment-copy">from your answer, I find reference document. <a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.indexing.html" rel="nofollow noreferrer">link</a>. "Unlike lists and tuples, numpy arrays support multidimensional indexing for multidimensional arrays. That means that it is not necessary to separate each dimension’s index into its own set of square brackets." thank you.</span>
