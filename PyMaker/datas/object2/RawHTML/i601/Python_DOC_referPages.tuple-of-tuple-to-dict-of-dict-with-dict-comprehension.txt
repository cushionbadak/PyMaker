<div class="post-text" itemprop="text">
<p>Is it possible to convert a tuple of tuples like this:</p>
<pre><code>l = (("a","aa",1),("a","bb",2),("a","cc",1),("b","ee",9),("b","gg",2))
</code></pre>
<p>to a dict of dicts like this:</p>
<pre><code>{"a":{"aa":1,"bb":2,"cc":1}  "b": {"ee":9,"gg":2}}
</code></pre>
<p>using a dict comprehension like this:</p>
<pre><code>r = {? for a,b,c in l}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a> with a dictionary comprehension:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

l = (("a", "aa", 1), ("a", "bb", 2), ("a", "cc", 1), ("b", "ee", 9), ("b", "gg", 2))

first = itemgetter(0)
result = {key: {inner: value for _, inner, value in groups} for key, groups in groupby(l, key=first)}

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'b': {'gg': 2, 'ee': 9}, 'a': {'cc': 1, 'bb': 2, 'aa': 1}}
</code></pre>
<p>As mentioned by @juanpa.arrivillaga if the input is not sorted by the first element of each tuple, you need to sort it, for that you can do: <code>l = sorted(l, key=first)</code> before using the dictionary comprehension.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby

l = (("a","aa",1),("a","bb",2),("a","cc",1),("b","ee",9),("b","gg",2))

print({x: {z[1]: z[2] for z in y} for x, y in groupby(sorted(l, key=lambda x: x[0]), lambda x: x[0])})
# {'a': {'aa': 1, 'bb': 2, 'cc': 1}, 'b': {'ee': 9, 'gg': 2}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you enjoy abusing <code>built-ins</code> for not their intended purpose? I would honestly use the other answers here but this is also another way to do this.</p>
<pre><code>from collections import defaultdict

d = defaultdict(dict)

any(d[x[0]].update({x[1]: x[-1]}) for x in l)

print(d)

defaultdict(dict, {'a': {'aa': 1, 'bb': 2, 'cc': 1}, 'b': {'ee': 9, 'gg': 2}})
</code></pre>
<p>Using <code>any</code> will return a <code>boolean</code> which clearly is not the intended purpose here hence why I recommend other answers listed.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion, Daniel Mesejo's answer nailed it.  That answer is based on <code>groupby</code>, but functionally speaking, <code>groupby</code> is a form of <code>reduce</code>.   So, for variety, I'll offer here a solution with <code>functools.reduce</code> (which also uses <code>defaultdict</code>):</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; l = (("a","aa",1),("a","bb",2),("a","cc",1),("b","ee",9),("b","gg",2))
&gt;&gt;&gt; def update_and_return(acc, up):
...     acc[up[0]][up[1]] = up[2]
...     return acc
... 
&gt;&gt;&gt; reduce(update_and_return, l, defaultdict(dict))
defaultdict(&lt;type 'dict'&gt;, {'a': {'aa': 1, 'cc': 1, 'bb': 2}, 'b': {'ee': 9, 'gg': 2}})
</code></pre>
<p>Even though this isn't a dictionary comprehension solution, I hope it will provide more context for someone wanting to understand the computation required to answer the question.</p>
</div>
<span class="comment-copy">Personally, I would argue itâ€™s better to use a for loop and a few more lines to ease readability and complexity.</span>
<span class="comment-copy">You will have to sort first</span>
<span class="comment-copy">You need to sort first</span>
<span class="comment-copy">groupby does not work unless it is sorted first</span>
<span class="comment-copy">@aws_apprentice, Missed that <code>key</code> can come anywhere in list. Thanks.</span>
<span class="comment-copy">Don't use update to update a single key-value pair</span>
<span class="comment-copy">juanpa.arrivillaga: thanks, edited as per your suggestion</span>
