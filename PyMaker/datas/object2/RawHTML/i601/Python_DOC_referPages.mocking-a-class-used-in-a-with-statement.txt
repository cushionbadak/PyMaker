<div class="post-text" itemprop="text">
<p>I have a class which has an <code>__exit__</code> and <code>__enter__</code> function so that I can use it in a with statement, e.g.:</p>
<pre><code>with ClassName() as c:
    c.do_something()
</code></pre>
<p>I am now trying to write a unit test to test this.   Basically, I am trying to test that <code>do_something()</code> has only been called once.   </p>
<p>An example (which I called <code>testmocking1</code>):</p>
<pre><code>class temp:
    def __init__(self):
        pass

    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass

    def test_method(self):
        return 1


def fun():
    with temp() as t:
        return t.test_method()
</code></pre>
<p>And my test:</p>
<pre><code>import unittest
import test_mocking1
from test_mocking1 import fun
import mock
from mock import patch

class MyTestCase(unittest.TestCase):
    @patch('test_mocking1.temp', autospec = True)
    def test_fun_enter_called_once(self, mocked_object):
        fun()
        mocked_object.test_method.assert_called_once()

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>So I would expect this to pass, because the test_method has been called exactly once in the function <code>fun()</code>.   But the actual result that I get is:</p>
<pre><code>======================================================================
FAIL: test_fun_enter_called_once (__main__.MyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "&lt;path_to_virtual_env&gt;\lib\site-packages\mock\mock.py", line 1305, in patched
    return func(*args, **keywargs)
  File "&lt;File_with_test&gt;", line 11, in test_fun_enter_called_once
mocked_object.test_method.assert_called_once()
  File "&lt;path_to_virtual_env&gt;\lib\site- 
packages\mock\mock.py", line 915, in assert_called_once
    raise AssertionError(msg)
AssertionError: Expected 'test_method' to have been called once. Called 0 times.
</code></pre>
<p>How do I test whether a function in a class which is created using a <code>with</code> statement has been called (either once or multiple times), and (related) how do I set the results of those calls (using <code>.side_effect</code> or <code>.return_value</code>)?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>with</code> statement takes whatever <code>__enter__</code> returns to bind to the name in the <code>as &lt;name&gt;</code> part. You bound it to <code>t</code>:</p>
<pre><code>with temp() as t:
    t.test_method()
</code></pre>
<p>Note that <code>temp()</code> is called, so the <code>with</code> statement starts with <code>temp.return_value</code>. <code>t</code> is not <code>temp.return_value</code> either, it is whatever <code>temp().__enter__()</code> returns, so you need to use the return value for that call:</p>
<pre><code>entered = mocked_object.return_value.__enter__.return_value
entered.test_method.assert_called_once()
</code></pre>
<p>Extending on this, if you want to alter what <code>test_method()</code> returns, do so on the return value of <code>mocked_object.return_value.__enter__.return_value</code>.</p>
<p>You can always print out the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.mock_calls" rel="nofollow noreferrer"><code>mock_calls()</code> attribute</a> of your object to see what has happened to it:</p>
<pre><code>&gt;&gt;&gt; from test_mocking1 import fun
&gt;&gt;&gt; from mock import patch
&gt;&gt;&gt; with patch('test_mocking1.temp', autospec = True) as mocked_object:
...     fun()
...
&gt;&gt;&gt; print(mocked_object.mock_calls)
[call(),
 call().__enter__(),
 call().__enter__().test_method(),
 call().__exit__(None, None, None)]
&gt;&gt;&gt; mocked_object.return_value.__enter__.return_value.test_method.called
True
&gt;&gt;&gt; mocked_object.return_value.__enter__.return_value.test_method.call_count
1
</code></pre>
<p>Note that your actual implementation of <code>temp.__enter__()</code> returns <code>None</code>, so without mocking your <code>fun()</code> function fails with an attribute error.</p>
</div>
<span class="comment-copy">Edited so that i have an actual return value for future reference.</span>
