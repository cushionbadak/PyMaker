<div class="post-text" itemprop="text">
<p>I know if I had two lists of, say integers, I could simply do <code>list(set(list1) &amp; set(list2))</code> to get the intersection. However, in my two lists, I have mutable objects, namely <code>Node</code>s. Node is a class that can be initialized with a value.</p>
<p>Without having to do a double for-loop, is there any way to get the intersection of two lists based on their ids? I'm looking for something similar to <code>list(set(list1) &amp; set(list2))</code>.</p>
<p><strong>Update</strong>: By id I am referring to the built-in <code>id()</code> function in Python which returns the address of where the object is stored in memory. </p>
<p>So, I'm asking what is the Intersection of say, <code>[Node1, Node2, Node3]</code> and <code>[Node100, Node2, Node3]</code>. Obviously I can't use the set intersection method above. I need to identify they are the same by accessing memory. If I can't try to identify them based on their value attribute because they may Node1 may have the same value as Node100, but they are not the same objects in memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no need to intersect two sets. In this case you can just check if the <code>id()</code> exists in another set.</p>
<pre><code>set2 = {id(n) for n in list2}
result = [n for n in list1 if id(n) in set2]
</code></pre>
<p>The complexity of this code is <code>O(n1 + n2)</code>. I'll explain this in following equivalent but more readable code:</p>
<pre><code>set2 = {id(n) for n in list2}  # O(n2)
result = []
for n in list1:  # O(n1)
    if id(n) in set2:  # O(1)
        result.append(n)  # O(1)
</code></pre>
<p>In total it's <code>O(n1 + n2)</code>.</p>
<hr/>
<p>There is also an alternative solution if you can make change to the <code>Node</code> class by just defining the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code></a> method.</p>
<pre><code>class Node:
    ...

    def __hash__(self):
        return id(self)

    def __eq__(self, another):
        return id(self) == id(another)


list1 = [...]
list2 = [...]

result = set(list1) &amp; set(list2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution you suggested will work.</p>
<pre><code>class Node:
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return "Node {}".format(self.value)

nodes1 = [Node(1), Node(2), Node(3)]
nodes2 = nodes1[:2] + [Node(4)]

common_nodes = set(nodes1) &amp; set(nodes2)

print(common_nodes) # {Node 2, Node 1}
</code></pre>
<p>The reason this works is because despite being mutable, an instance of a class for which you did not define <code>__hash__</code> or <code>__eq__</code> will be hashed and compared by its <code>id</code> by default because it inherits those methods from <code>object</code>.</p>
<p>You can check this is true with the following experiment.</p>
<pre><code>&gt;&gt;&gt; obj = object()
&gt;&gt;&gt; hash(obj)
155115580943
&gt;&gt;&gt; id(obj)
2481849295088
&gt;&gt;&gt; id(obj) // 16 == hash(obj)
True
</code></pre>
</div>
<span class="comment-copy">What do you mean "based on their ids"? Is the id an attribute of <code>Node</code> object?</span>
<span class="comment-copy">By 'id' do you mean references to the same objects which may appear in both <code>list1</code> and <code>list2</code>?</span>
<span class="comment-copy">@Primusa. Why did you delete your answer?</span>
<span class="comment-copy">@MadPhysicist Philip has a much better answer. there's no point for me to keep mine up; I upvote his answer and move on.</span>
<span class="comment-copy">To be sure as is not clear to me: do you want to keep in your final list two Nodes with the same value if they are not the same object in memory or not?</span>
<span class="comment-copy">I mean the python <code>id</code> built-in function, not my attribute</span>
<span class="comment-copy">Also, this is just a for loop</span>
<span class="comment-copy">@MadPhysicist well you have to convert list to set first. Internally the <code>set()</code> initializer will also walk through the whole list (and I think it counts a loop).</span>
<span class="comment-copy">@AlanH. This is not just a for loop. The set construction is O(n2), and the loop is O(n1). This makes it O(n1+n2), not O(n1*n2). For comparable list sizes, you end up with O(n) instead of O(n^2). And you can trivially replace n.id with id(n)</span>
<span class="comment-copy">@MadPhysicist Can you explain more as to why it's O(list1 + list2)? If I have a for loop, and for each iteration, I have to create a set of <code>k</code> elements, isn't that just multiplying the run-times?</span>
