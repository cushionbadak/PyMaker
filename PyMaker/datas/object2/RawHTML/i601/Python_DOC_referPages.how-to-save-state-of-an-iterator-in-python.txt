<div class="post-text" itemprop="text">
<p>I have a very big iterator. due to lack of resources (Network, Memory and Time), It's not possible for me to execute my program at one step.</p>
<p>So I thought it would be nice if I run my program till 10000th element in iterator and then save its state. next time I run program it continues from 10001st element in iterator.</p>
<p>here is the code I use:</p>
<pre><code>import itertools
import requests

POSSIBLE_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
URL = "URL?key={code}"

all_possible = itertools.combinations_with_replacement(POSSIBLE_CHARS, 29)
counter = itertools.count(start=1)

for c in all_possible:
    print("Try {}:".format(next(counter)), c)

    c_url = URL.format(code=c)
    resp = requests.get(c_url)
    if resp.status_code == 200:
        print("C found:", c)

        with open(c+".gif", 'b') as f:
            f.write(resp.content)
</code></pre>
<p>this <a href="https://stackoverflow.com/questions/21594302/is-there-a-way-to-remember-the-position-in-a-python-iterator">link</a> shows how to continue iterator inside a single execution. but what I want is to stop program and execute again.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>So I thought it would be nice if I run my program till 10000th element in iterator and then save its state. next time I run program it continues from 10001st element in iterator.</p>
</blockquote>
<p>You're in luck, because <code>itertools.combinations_with_replacement</code> objects have APIs allowing to set state. This is used by the <a href="https://docs.python.org/3/library/copy.html#module-copy" rel="nofollow noreferrer"><code>copy</code></a> module in Python, but there is no reason you can't also hook in.</p>
<p>For example the 10,001<sup>th</sup> item would be this:</p>
<pre><code>&gt;&gt;&gt; all_possible = itertools.combinations_with_replacement(POSSIBLE_CHARS, 29)
&gt;&gt;&gt; for i in range(10_000): 
...     next(all_possible) 
...
&gt;&gt;&gt; "".join(next(all_possible))
'aaaaaaaaaaaaaaaaaaaaaaaaaafwI'
</code></pre>
<p>To "fast-forward" to this item in a fresh instance, it would be:</p>
<pre><code>&gt;&gt;&gt; new_iterator = itertools.combinations_with_replacement(POSSIBLE_CHARS, 29)
&gt;&gt;&gt; state = (0,)*26 + (5, 22, 33)
&gt;&gt;&gt; new_iterator.__setstate__(state)
&gt;&gt;&gt; "".join(next(new_iterator))
'aaaaaaaaaaaaaaaaaaaaaaaaaafwI'
&gt;&gt;&gt; "".join(next(new_iterator))
'aaaaaaaaaaaaaaaaaaaaaaaaaafwJ'
&gt;&gt;&gt; new_iterator.__setstate__(state)  # bonus: rewind iterator!
&gt;&gt;&gt; "".join(next(new_iterator))
'aaaaaaaaaaaaaaaaaaaaaaaaaafwI'
</code></pre>
<p>To understand why the combination 10,001 corresponds to some tuple of length 29 like (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 22, 33), I invite you to browse the CPython sources <a href="https://github.com/python/cpython/blob/3.7/Modules/itertoolsmodule.c#L2571-L2598" rel="nofollow noreferrer">to see how combinations objects allow themselves to be statefully copied</a> and also the relevant section of the <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer"><code>pickle</code> docs</a>.</p>
<p>If you don't require security against erroneous or maliciously constructed data, then you might consider to simply pickle such iterators to file rather than hook into the <code>__setstate__</code> method manually.</p>
</div>
<span class="comment-copy">Thank you. I thinks its 10000 not 10_000 in loop.</span>
<span class="comment-copy">@Javadmk That's a new feature in Python 3.6 to make large <code>int</code> literals easier to read; see <a href="https://www.python.org/dev/peps/pep-0515/" rel="nofollow noreferrer">python.org/dev/peps/pep-0515</a>.</span>
