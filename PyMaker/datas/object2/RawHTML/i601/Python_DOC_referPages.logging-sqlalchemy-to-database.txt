<div class="post-text" itemprop="text">
<p>I'm coding a small application which is supposed to log everything to a database using sqlalchemy.
Inspired by this:</p>
<p><a href="https://stackoverflow.com/questions/2314307/python-logging-to-database">python logging to database</a></p>
<p>and this:</p>
<p><a href="https://docs.pylonsproject.org/projects/pyramid-cookbook/en/latest/logging/sqlalchemy_logger.html" rel="nofollow noreferrer">https://docs.pylonsproject.org/projects/pyramid-cookbook/en/latest/logging/sqlalchemy_logger.html</a>
I came up with a solution that works fine for all log messages of all involved libraries besides those generated by sqlalchemy (!) itself. </p>
<p>Here is a minimal example, reproducing my problem:</p>
<pre><code>import logging
import datetime
from sqlalchemy import Column, DateTime, String, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()


 # define table
class TblLog(Base):
    __tablename__ = 'Tbl_Log'

    LOG_TIME = Column(DateTime, primary_key=True)
    LOG_NAME = Column(String(100))
    LOG_LEVEL = Column(String(100))
    LOG_MSG = Column(String(2000))

    def __init__(self, time, name, lvl, msg):
        self.LOG_TIME = time
        self.LOG_NAME = name
        self.LOG_LEVEL = lvl
        self.LOG_MSG = msg

# custom log handler that emits to the database
class DatabaseHandler(logging.Handler):

    def __init__(self, session):
        super().__init__()
        self.session = session
        self.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        self.setLevel(logging.DEBUG)

    def emit(self, record):

        self.format(record)

        log_time = datetime.datetime.strptime(record.__dict__['asctime'], "%Y-%m-%d %H:%M:%S,%f")

        log_record = TblLog(log_time, record.__dict__['name'], record.__dict__['levelname'], record.__dict__['message'])

        self.session.add(log_record)
        self.session.commit()
</code></pre>
<p>testing this with sqlalchemy (!) logs enabled: </p>
<pre><code>if __name__ == '__main__':
    # simple logging config
    logging.basicConfig(
        format='%(asctime)s : %(name)s : %(levelname)s : %(message)s',
        level=logging.DEBUG,
    )
    logger_sqlalchemy = logging.getLogger('sqlalchemy')
    logger_sqlalchemy.setLevel(logging.INFO)


    # test with sqlite in memory database
    DB_STRING = 'sqlite:///:memory:'
    engine = create_engine(DB_STRING, echo=False)
    Base.metadata.create_all(engine)
    Session = sessionmaker()
    session = Session(bind=engine)

    # adding custom handler:
    logger_sqlalchemy.addHandler(DatabaseHandler(session))

    logger_sqlalchemy.info('this is a test message')
</code></pre>
<p>This raises </p>
<blockquote>
<p>AttributeError: 'NoneType' object has no attribute 'set'</p>
</blockquote>
<p>I can paste the whole traceback if necessary. I suspect that the issue arises
because the  TblLog(...) call produces a log record and thus the handler emits records to itself?! </p>
<p>What would be the best solution for this problem, i.e. can I write sqlalchemy log messages to a database using sqlalchemy in the handler??</p>
<p>I'm kind of stuck here, thanks for any help...  </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I suspect that the issue arises because the TblLog(...) call produces
  a log record and thus the handler emits records to itself?!</p>
</blockquote>
<p>That's not the immediate issue. The reason for the failure is that SQLAlchemy is emitting log messages while it is configuring the mapper, the first of those is sent before <code>TblLog</code>'s mapper is fully configured and hence, your error. </p>
<p>If you add a <code>StreamHandler</code> to your <code>logger_sqlalchemy</code> instance <strong>before</strong> the <code>DatabaseHandler</code> you'll be able to see the log messages <code>logger_sqlalchemy</code> is receiving right up to the crash. The log message that's tripping it up is <code>(TblLog|Tbl_Log) _post_configure_properties() started</code>, which is coming from the <a href="https://github.com/sqlalchemy/sqlalchemy/blob/2eb3f211dae1188a6c1b3664f612f4628fd7b9a9/lib/sqlalchemy/orm/mapper.py#L1932" rel="nofollow noreferrer"><code>_post_configure_properties()</code></a> method. The docstring for that method includes:</p>
<blockquote>
<p>This is a deferred configuration step which is intended to execute
  once all mappers have been constructed.</p>
</blockquote>
<p>So that's a clue that the config of the mapper for <code>TblLog</code> isn't finished.</p>
<p>If you then, remove the <code>DatabaseHandler</code> from the logger and just leave the <code>StreamHandler</code> you'll see what that method goes on to do (I also removed your <code>basicConfig()</code> for clarity):</p>
<pre><code>(TblLog|Tbl_Log) _post_configure_properties() started
# this is where your code crashed originally
(TblLog|Tbl_Log) initialize prop LOG_TIME
(TblLog|Tbl_Log) initialize prop LOG_NAME
(TblLog|Tbl_Log) initialize prop LOG_LEVEL
(TblLog|Tbl_Log) initialize prop LOG_MSG
(TblLog|Tbl_Log) _post_configure_properties() complete
</code></pre>
<p>So as you can see, some initialisation of the column descriptors seems to be happening after that first log message is emitted. Which is why you get the error, the ORM isn't ready by the time you're trying to use it.</p>
<p>You could instantiate a dummy <code>TblLog</code> instance to force the mapper to configure before you add the handler, e.g.:</p>
<pre><code># ensure TblLog mapper configured
TblLog(time=None, name=None, lvl=None, msg=None)
logger_sqlalchemy.addHandler(DatabaseHandler(session))
logger_sqlalchemy.info('this is a test message')
</code></pre>
<p>But you'll then encounter a new problem: SQLAlchemy emits logs throughout the flush/commit process. So then as the first log message is flushed to the datbase it generates a new log message which itself generates a new log message etc etc..... infinite recursion.</p>
<p>So my answer to:</p>
<blockquote>
<p>What would be the best solution for this problem, i.e. can I write
  sqlalchemy log messages to a database using sqlalchemy in the
  handler??</p>
</blockquote>
<p>The answer would be no, if you are trying to also capture sqlalchemy logging the logging.</p>
<p>Some possible solutions:</p>
<ul>
<li>Don't use SQLAlchemy to write the log messages to the database. Assuming that you use SQLAlchemy in other parts of your application, use the dpapi client direcly to write the logs to the db and explicitly don't write the client's log messages to the database (otherwise you'll end up with the same recursion issue). </li>
<li>send your log messages to a webservice using a <a href="https://docs.python.org/3/library/logging.handlers.html#httphandler" rel="nofollow noreferrer"><code>HTTPHandler</code></a> which writes the log messages to a database.</li>
<li>Have sqlalchemy log to a file, while everything else logs to the database. You could even setup a cron job to periodically write the sqlalchemy logs from the file to the database in a separate process.</li>
<li><a href="https://en.wikipedia.org/wiki/Logging_as_a_service" rel="nofollow noreferrer">Logging as a service</a></li>
</ul>
</div>
