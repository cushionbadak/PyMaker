<div class="post-text" itemprop="text">
<p>I have a class based decorator. The problem is that I need to be able to have access to wraped function args and kwargs but now I can't and I don't understand why. It should be easy but it's not for me.</p>
<pre><code>class limit:
    def __call__(self, fn):
        @wraps(fn)
        # the idea to use signature like (request, *args, **kwargs) is bad. I must accept *args and **kwargs only 
        def wrapper(*args, **kwargs):
             # pdb breakpoint is here
             user = kwargs.get('user') or kwargs.get('request').user // ERROR

             return fn(*args, **kwargs)

        return wrapper
</code></pre>
<p>Let's have a look at pdb. That's ****CENSORED**** crazy.</p>
<pre><code>(Pdb) args
args = (&lt;User: dua&gt;,)
kwargs = {}
(Pdb) kwargs
{}
(Pdb) args.args
args = (&lt;User: dua&gt;,)
kwargs = {}
(Pdb) args.args.args.args
args = (&lt;User: dua&gt;,)
kwargs = {}
(Pdb) args.get('user')
args = (&lt;User: dua&gt;,)
kwargs = {}
(Pdb) type(args)
&lt;class 'tuple'&gt;
(Pdb) 
</code></pre>
<p>The question is how can I get access to args, kwargs and treat args as list and kwargs as dict.</p>
<p>P.S. I don't know why it args and kwargs looks like that. Why they do look like that?</p>
<hr/>
<p>As mentioned at the answer <code>args</code> is command of pdb. User <code>repr(args)</code> to see args.</p>
<p>Next question is possible signatures of function: 
1) def fn(request, ...) 
2) def fn(self, a, b, c, etc, user) 
3) def fn(user) </p>
<p>Are there a way to deal with all of them with one decorator? </p>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>pdb</code> output is not really relevant, <a href="https://docs.python.org/3/library/pdb.html#pdbcommand-args" rel="nofollow noreferrer"><code>args</code></a> here acts like interactive pdb command.</p>
<p>For the sake of simplicity, either use <code>repr(args)</code> or temporary rename <code>*args</code> argument</p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up with this solution:</p>
<pre><code>def wrapper(*args, **kwargs):
    user = None
    fn_signature_args = inspect.getfullargspec(fn).args
    # looking for a user in kwargs
    if 'user' in kwargs:
    user = kwargs['user']
    # looking for a user as positional argument
    elif 'user' in fn_signature_args:
    index = fn_signature_args.index('user')
    user = args[index]
    # looking for a user as self or request attribute
    elif fn_signature_args[0] in ('request', 'self'):
    user = args[0].user
</code></pre>
</div>
<span class="comment-copy">Thanks for your help! Can I make wrapper accept only **kwargs (do not use *args)? I must have access to arguments but signature of decorated functions can change. That's why I need params as a dict.</span>
<span class="comment-copy">You may, but generally it's bad idea, because of decorators idea â€” you don't know function signature in advance. Even in your debugging session, your decorated function passes <code>User</code> as positional argument</span>
<span class="comment-copy">Are there a way to pass positional argument to kwargs dict? Because <code>def wrapper(**kwargs):</code> gives an error(tries to pass positional arguments and fails).</span>
<span class="comment-copy">There's no clear way to do it. Once you'll try implementing it <i>assuming</i> you can, you'll see why. If caller passes positional argument, how could you access it via <code>kwargs</code>? There's no name for 'em</span>
<span class="comment-copy">@Slam One could inspect the signature of the function to get the names for the positional arguments. This would fail for functions that don't provide the argument names in their signature.</span>
