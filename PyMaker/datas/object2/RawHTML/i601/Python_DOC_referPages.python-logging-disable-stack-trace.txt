<div class="post-text" itemprop="text">
<p>Is there a simple way to disable the logging of an exception stack trace in Python 3, either in a <code>Handler</code> or <code>Formatter</code>? </p>
<p>I need the stack trace in another <code>Handler</code>, so setting <code>exc_info=False</code>, in the call to the <code>Logger</code> is not an option. Is there a simpler way than just defining my own <code>Formatter</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest option to disable <em>per handler</em> traceback output is to add a custom <a href="https://docs.python.org/3/library/logging.html#logging.Filter" rel="nofollow noreferrer"><code>logging.Filter</code> subclass</a> that alters the record object (rather than filter out records).</p>
<p>The filter simply has to set <code>exc_text</code> on records to a string, replacing the <code>None</code> default:</p>
<pre><code>class SetTracebackCacheFilter(logging.Filter):
    """Set the exception cache text on log records to a specific value"""
    def __init__(self, exc_text):
        self.exc_text = exc_text
    def filter(self, record):
        record.exc_text = self.exc_text
        return True
</code></pre>
<p>and <a href="https://docs.python.org/3/library/logging.html#logging.Handler.addFilter" rel="nofollow noreferrer">add that filter on your handler</a>, setting the cached text to an empty string:</p>
<pre><code># do not display tracebacks in messages handled with this handler,
# by setting the traceback cache to an empty string:
handler_with_no_tracebacks.addFilter(SetTracebackCacheFilter(''))
</code></pre>
<p>This works because the <a href="https://docs.python.org/3/library/logging.html#logging.Formatter.format" rel="nofollow noreferrer"><code>Formatter.format()</code> method</a> explicitly documents <code>LogRecord.exc_text</code> as the attribute in which a formatted traceback is cached:</p>
<blockquote>
<p>Note that the formatted exception information is cached in attribute <code>exc_text</code>. This is useful because the exception information can be pickled and sent across the wire, but you should be careful if you have more than one <code>Formatter</code> subclass which customizes the formatting of exception information. In this case, you will have to clear the cached value after a formatter has done its formatting, so that the next formatter to handle the event doesnâ€™t use the cached value but recalculates it afresh.</p>
</blockquote>
<p>The above filter uses this to prevent traceback text from being generated altogether. Every time a message is passed to the handler, the above filter is called to see if the handler will want to process the record instance, and we 'cache' an empty exception text.</p>
<p><strong>However</strong>, handlers do not copy log records, and any other handler that is passed the same log record <em>later on</em> will also ignore formatting the traceback. So you also need to configure the next handler listed in the <code>logger.handlers</code> list directly after the handler with the above filter:</p>
<pre><code>idx = logger.handlers.index(handler_with_no_tracebacks)
if len(logger.handlers) &gt;= idx:
    # clear the traceback text cache again for further handlers
    logger.handlers[idx + 1].addFilter(SetTracebackCacheFilter(None))
</code></pre>
<p>If you anyone wanted to disable <strong>all</strong> traceback outputs, everywhere, then perhaps adding a custom filter to all handlers or loggers becomes tedious. In that case another option is to register a custom record factory with the <a href="https://docs.python.org/3/library/logging.html#logging.setLogRecordFactory" rel="nofollow noreferrer"><code>logging.setLogRecordFactory()</code> function</a>; just set the <code>exc_text</code> attribute on records to an empty string:</p>
<pre><code>record_factory = logging.getLogRecordFactory()

def clear_exc_text(*args, **kwargs):
    record = record_factory(*args, **kwargs)
    record.exc_text = ''
    return record

logging.setLogRecordFactory(clear_exc_text)
</code></pre>
<p>Note that the default factory is just the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" rel="nofollow noreferrer"><code>logging.LogRecord</code> class</a>, but the above function does its best to work with any already-set custom factory.</p>
<p>Neither the filter nor the custom record factory are not clearing the <code>exc_info</code> tuple, so you can still access this somewhere else.</p>
<p>Of course, you can also create your own <code>Handler</code> subclass where the <a href="https://docs.python.org/3/library/logging.html#logging.Handler.handle" rel="nofollow noreferrer"><code>Handler.handle()</code></a> sets and clears the <code>exc_text</code> attribute:</p>
<pre><code>class NoTracebackHandler(logging.Handler):
    def handle(self, record):
        old, record.exc_text = record.exc_text, ''
        try:
            super().handle(record)
        finally:
            record.exc_text = old
</code></pre>
</div>
