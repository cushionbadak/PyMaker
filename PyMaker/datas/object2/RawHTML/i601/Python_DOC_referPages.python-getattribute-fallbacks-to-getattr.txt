<div class="post-text" itemprop="text">
<p>I have a situation, where <strong>getattribute</strong> fallbacks to <strong>getattr</strong> and then again <strong>getattribute</strong> gets called.</p>
<p>How current <strong>getattribute</strong> gets called again? I am confused.</p>
<pre><code>class Count(object):

    def __init__(self,mymin,mymax):
        self.mymin=mymin
        self.mymax=mymax
        self.current=None

    def __getattr__(self, item):
            print("akhjhd")
            self.__dict__[item]=0
            return 0

    def __getattribute__(self, item):
        print("this is called first")
        if item.startswith('cur'):
            print("this raised an error")
            raise AttributeError
        print("This will execute as well")
        return object.__getattribute__(self,item)


obj1 = Count(1,10)
print(obj1.mymin)
print(obj1.mymax)
print(obj1.current)
</code></pre>
<p>Console Output:</p>
<pre><code>this is called first
This will execute as well
1
this is called first
This will execute as well
10
this is called first
this raised an error
akhjhd
this is called first
This will execute as well
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><code>getattr</code> is called because <code>getattribute</code> raises <code>AttributeError</code></li>
<li><code>self.__dict__</code> invokes the "second" call to <code>getattribute</code></li>
</ul>
<p>Clean the code and add <code>print(item)</code> to make this clearer:</p>
<pre><code>class Count(object):
    def __init__(self):
        self.current = None

    def __getattr__(self, item):
        print("in getattr")
        self.__dict__[item] = 0
        return 0

    def __getattribute__(self, item):
        print(item)
        print("in __getattribute__ 1")
        if item.startswith('cur'):
            print("starts with 'cur'")
            raise AttributeError
        print("in __getattribute__ 2")
        return object.__getattribute__(self, item)


obj1 = Count()
print(obj1.current)
</code></pre>
<p>Outputs</p>
<pre><code>current
in __getattribute__ 1
starts with 'cur'
in getattr
__dict__
in __getattribute__ 1
in __getattribute__ 2
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to consult with python <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Data model</a></p>
<p>Excerpts for <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><strong>getattribute</strong></a>:</p>
<blockquote>
<p>Called unconditionally to implement attribute accesses for instances of the class. If the class also defines <strong>getattr</strong>(), the latter will not be called unless <strong>getattribute</strong>() either calls it explicitly or raises an AttributeError.</p>
</blockquote>
<p>I see in your code:</p>
<pre><code>if item.startswith('cur'):
    print("this raised an error")
    raise AttributeError
</code></pre>
<p>So I think you did it intentionally</p>
</div>
<span class="comment-copy"><code>getattr</code> is called because <code>getattribute</code> raises <code>AttributeError</code></span>
<span class="comment-copy">agreed, but again __ getattribute__ called, how come?</span>
<span class="comment-copy">Because <code>self.__dict__</code> invokes it the second time</span>
<span class="comment-copy">I added an answer with an example</span>
<span class="comment-copy">oic......thanks DeepSpace</span>
<span class="comment-copy">This explains clean and clear.</span>
<span class="comment-copy">If I don't have <b>getattr</b> method and return in <b>getattribute</b>, why first print in <b>getattribute</b> gets printed again and again (mean recursion of <b>getattribute</b>)......How that is getting called more than once?</span>
<span class="comment-copy">@Pravin I can't reproduce this behavior. If I comment out <code>getattr</code> then the <code>AttributeError</code> from <code>getattribute</code> propagates.</span>
