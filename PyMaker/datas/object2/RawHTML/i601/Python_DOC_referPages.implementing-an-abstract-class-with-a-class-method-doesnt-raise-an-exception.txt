<div class="post-text" itemprop="text">
<p>I am attempting to implement a method as both an abstract method and as a class method but it doesn't feel like any of the benefits of an abstract class are gained when doing so.</p>
<p>For example:</p>
<pre><code>from abc import ABC, abstractmethod

class BasePipeline(ABC):

    @classmethod
    @abstractmethod
    def consume_frame(cls):
        pass

    @abstractmethod
    def consume_frame_two(self):
        pass

class AnotherSubclass(BasePipeline):

    @classmethod
    def does_nothing(cls):
        a = 1 + 1

# Call it. 
AnotherSubclass.consume_frame()
</code></pre>
<p>This doesn't raise any exception and does not error out. I'd expect for it to say something along the lines of: <code>consume_frame_two is not implemented</code> and <code>consume_frame is not implemented</code>. </p>
<p>Not sure what the intended behavior is or if I'm just doing something wrong. I'd like for <code>AnotherSubclass.consume_frame()</code> to raise an exception if it isn't properly implemented as a class method. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your code doesn't try to create an instance of the <code>AnotherSubclass</code> class. All it does is access the implementation of a <code>classmethod</code> that is marked as abstract. Python's ABC abstract classes are not intended to prevent that kind of access.</p>
<p>The <code>abc</code> module is intended to help you define a <em>protocol</em> or <em>interface</em>, a base class that sets expectations as to what attributes must be present on concrete objects that should be considered the same.</p>
<p>To that end, all that you can do with an <code>ABC</code> subclass is prevent instances to be created of any class in the class hierarchy that has at least one <code>abstractmethod</code> or <code>abstractproperty</code> attribute. From the <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer"><code>@abc.abstractmethod()</code> documentation</a>:</p>
<blockquote>
<p>A class that has a metaclass derived from <code>ABCMeta</code> cannot be instantiated unless all of its abstract methods and properties are overridden.</p>
</blockquote>
<p>Any <code>abstractmethod</code>-decorated method can <em>still be called</em>; there is no mechanism to prevent this and it is actually a specific goal of the module that concrete implementations can use <code>super().name()</code> to access the implementation of an <code>abstractmethod</code> object. From the same source:</p>
<blockquote>
<p>The abstract methods can be called using any of the normal ‘super’ call mechanisms</p>
</blockquote>
<p>and</p>
<blockquote>
<p><strong>Note</strong>: Unlike Java abstract methods, these abstract methods may have an implementation. This implementation can be called via the <code>super()</code> mechanism from the class that overrides it. This could be useful as an end-point for a super-call in a framework that uses cooperative multiple-inheritance.</p>
</blockquote>
<p>Any other attributes of the class can be used just the same as on other classes, including <code>classmethod</code> objects.</p>
<p>Under the covers, each <code>ABCMeta</code> metaclass gives each class you create with it a <code>__abstractmethods__</code> attribute, which is a <code>frozenset</code> object with the names of any attribute on the class that has the <code>__isabstractmethod__</code> attribute set to <code>True</code>, subclasses only have to use the same name as a parent abstract method object, setting it to an attribute that doesn't have <code>__isabstractmethod__</code> set to true to remove that name from the set for that class. Python will then raise an exception when you try to create an instance of a class whose <code>__abstractmethods__</code> is not empty.</p>
<p>If you need to lock down your class definitions further, then you'll have to come up with our own metaclass or other mechanism to implement those rules. For example, you could wrap <code>classobject</code> attributes in your own <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor object</a> that prevents calling a classmethod bound to a class with a non-empty <code>__abstractmethods__</code> attribute.</p>
</div>
<span class="comment-copy">ABCs only check if the <i>name</i> is present on the subclass. No assertions are made about <i>anything else</i>, not the type of object, not the argument count, not anything else. It only prevents you from creating instances of classes that still have <i>some</i> <code>abstractmethod</code> objects.</span>
