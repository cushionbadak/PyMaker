<div class="post-text" itemprop="text">
<p>I wrote a class that can handle integers with arbitrary precision (just for learning purposes). The class takes a string representation of an integer and converts it into an instance of <code>BigInt</code> for further calculations.</p>
<p>Often times you need the numbers <strong>Zero</strong> and <strong>One</strong>, so I thought it would be helpfull if the class could return these. I tried the following:</p>
<pre><code>class BigInt():
    zero = BigInt("0")

    def __init__(self, value):
        ####yada-yada####
</code></pre>
<p>This doesn't work. Error: "name 'BigInt' is not defined"</p>
<p>Then I tried the following:</p>
<pre><code>class BigInt():

    __zero = None

    @staticmethod
    def zero():
        if BigInt.__zero is None:
            BigInt.__zero = BigInt('0')
        return BigInt.__zero


    def __init__(self, value):
        ####yada-yada####
</code></pre>
<p>This actually works very well. What I don't like is that <code>zero</code> is a method (and thus has to be called with <code>BigInt.zero()</code>) which is counterintuitive since it should just refer to a fixed value.</p>
<p>So I tried changing <code>zero</code> to become a property, but then writing <code>BigInt.zero</code> returns an instance of the class <code>property</code> instead of <code>BigInt</code> because of the decorator used. That instance cannot be used for calculations because of the wrong type.</p>
<p>Is there a way around this issue?</p>
</div>
<div class="post-text" itemprop="text">
<p>A static property...? We call a static property an "attribute". This is not Java, Python is a dynamically typed language and such a construct would be really overcomplicating matters.</p>
<p>Just do this, setting a class attribute:</p>
<pre><code>class BigInt: 
    def __init__(self, value): 
        ... 

BigInt.zero = BigInt("0")
</code></pre>
<p>If you want it to be entirely encapsulated in the class block, do it using a class decorator (but be aware that's just a more fancy way of writing the same thing).</p>
<pre><code>def add_zero(cls):
    cls.zero = cls("0")
    return cls

@add_zero
class BigInt:
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The question is contradictory: <code>static</code> and <code>property</code> don't go together in this way.  Static <em>attributes</em> in Python are simply ones that are only assigned once, and the language itself includes a very large number of these.  (<em>Most</em> strings are interred, all integers &lt; a certain value are pre-constructed, etc.  E.g. <a href="https://docs.python.org/3/library/string.html" rel="nofollow noreferrer">the <code>string</code> module</a>.). Easiest approach is to statically assign the attributes after construction as wim illustrates:</p>
<pre class="lang-py prettyprint-override"><code>class Foo:
    ...

Foo.first = Foo()
...
</code></pre>
<p>Or, as he further suggested, using a class decorator to perform the assignments, which is functionally the same as the above.  A decorator is, effectively, a function that is given the "decorated" function as an argument, and must return a function to effectively replace the original one.  This may be the original function, say, modified with some annotations, or may be an entirely different function.  The original (decorated) function may or may not be called as appropriate for the decorator.</p>
<pre class="lang-py prettyprint-override"><code>def preload(**values):
    def inner(cls):
        for k, v in values.items():
            setattr(cls, k, cls(v))

        return cls

    return inner
</code></pre>
<p>This can then be used dynamically:</p>
<pre class="lang-py prettyprint-override"><code>@preload(zero=0, one=1)
class Foo:
    ...
</code></pre>
<p>If the purpose is to save some time on common integer values, a <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> mapping integers to constructed <code>BigInt</code>s could be useful as a form of caching and streamlined construction / singleton storage.  (E.g. <code>BigInt.numbers[27]</code>)</p>
<p>However, the problem of utilizing <code>@property</code> at the class level intrigued me, so I did some digging.  It is entirely possible to make use of "<a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol objects</a>" (which the <code>@property</code> decorator returns) at the class level if you punt the attribute up the object model hierarchy, to the metaclass.</p>
<pre class="lang-py prettyprint-override"><code>class Foo(type):
    @property
    def bar(cls):
        print("I'm a", cls)
        return 27

class Bar(metaclass=Foo):
    ...

&gt;&gt;&gt; Bar.bar
I'm a &lt;class '__main__.Bar'&gt;
&lt;&lt;&lt; 27
</code></pre>
<p>Notably, this attribute is not accessible from instances:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; Bar().bar
AttributeError: 'Bar' object has no attribute 'bar'
</code></pre>
<p>Hope this helps!</p>
</div>
<span class="comment-copy">Can't you create a class, that inherits that class. And thus instanciating your subclass it can return itself with a active instance of parent with <code>"0"</code> as value? <code>class initator(BigInt): def __init__(self): super(initator, self).__init__("8")</code>.</span>
<span class="comment-copy">I'd generally agree, <code>static</code> in combination with <code>property</code> is just an attribute of fixed value.  However, the more general issue of having real <code>@property</code> properties (descriptor protocol attributes) at the class level is intriguing, and should be accomplishable by assigning such a descriptor object to the metaclass.  (I have not tested this, though.  It'd also make it only accessible from the class level, not instance level.)</span>
<span class="comment-copy">Thank you! Didn't think it was <b>this</b> obvious, but coming from other languages the python approach is sometimes hard to understand. Can you explain how it would work with a decorator? I tried the following which results in a recursion depth error: <code>def big_int_decorator(cl):     def wrapper(*args):         value = cl(*args)         value.z = BigInt("0")         return value     return wrapper</code></span>
<span class="comment-copy">@MichaelG.  edited with the decorator example.</span>
<span class="comment-copy">@wim Thanks alot!</span>
<span class="comment-copy">What you describing with the metaclass stuff is more like a property for a classmethod than a property for a staticmethod. This practice and all the associated pitfalls are discussed in detail over here: <a href="https://stackoverflow.com/q/128573/674039">Using property() on classmethods</a></span>
<span class="comment-copy">@wim There are 14 answers to that question, top answer mentions Python 2.2 (beyond ancient) and doesn't provide full functionality (no setters/deleters), second most voted answer <i>does</i> mention metaclasses, doesn't point out important issue of access via instances, a number utilize <code>@property</code> w/ access from the instance, which is explicitly the opposite of what I'm going for here, etc. Are there specific notes of caution you can point at?  (Though yes, this is technically more of a property <code>classmethod</code> than <code>staticmethod</code>.)</span>
<span class="comment-copy">The <a href="https://stackoverflow.com/a/1383402/674039">currently top-voted</a> answer is broken, for reasons discussed in the comments there. This <a href="https://stackoverflow.com/a/39542816/674039">2016 answer</a> looks good.</span>
