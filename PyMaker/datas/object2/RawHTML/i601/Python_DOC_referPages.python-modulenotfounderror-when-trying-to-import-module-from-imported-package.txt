<div class="post-text" itemprop="text">
<p>I'm using Python 3.7.1 on macOS Mojave Version 10.14.1</p>
<p>This is my directory structure:</p>
<pre><code>man/                          
  Mans/                  
          man1.py
  MansTest/
          SoftLib/
                  Soft/
                      SoftWork/
                              manModules.py
          Unittests/
                    man1test.py
</code></pre>
<p><code>man1.py</code> contains the following <em>import</em> statement, <strong>which I do not want to change</strong>:</p>
<pre><code>from Soft.SoftWork.manModules import *
</code></pre>
<p><code>man1test.py</code> contains the following <em>import</em> statements:</p>
<pre><code>from ...MansTest.SoftLib import Soft
from ...Mans import man1
</code></pre>
<p>I need the second <em>import</em> in <code>man1test.py</code> because <code>man1test.py</code> needs access to a function in <code>man1.py</code>.</p>
<p>My rationale behind the first import (<em>Soft</em>) was to facilitate the aforementioned <em>import</em> statement in <code>man1.py</code>.</p>
<p>Contrary to my expectation, however, the <em>import</em> statement in <code>man1.py</code> gives rise to:</p>
<pre><code>ModuleNotFoundError: No module named 'Soft'
</code></pre>
<p>when I run</p>
<pre><code>python3 -m man.MansTest.Unittests.man1test
</code></pre>
<p>from a directory above <em>man/</em>.</p>
<p>Is there any way to resolve this error without changing the <em>import</em> statement in <code>man1.py</code> <strong>and</strong> without adding anything to <em>sys.path</em>?</p>
<p>Edit: <code>python3 -m man.ManTest.Unittests.man1test</code> from the original version of the question changed to <code>python3 -m man.MansTest.Unittests.man1test</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of <em>confusing</em> requirements with your setup but I'll try to give you what you want.</p>
<p><strong>FIRST</strong>, if you want to be able to access <em>man1.py</em> from <em>man1test.py</em> AND <em>manModules.py</em> from <em>man1.py</em>, you need to properly setup your files as <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">packages and modules</a>.</p>
<blockquote>
<p>Packages are a way of structuring Python’s module namespace by using
  “dotted module names”. For example, the module name <code>A.B</code> designates a
  submodule named <code>B</code> in a package named <code>A</code>.</p>
<p>...</p>
<p>When importing the package, Python searches through the directories on
  <code>sys.path</code> looking for the package subdirectory.</p>
<p>The <code>__init__.py</code> files are required to make Python treat the
  directories as containing packages; this is done to prevent
  directories with a common name, such as <code>string</code>, from unintentionally
  hiding valid modules that occur later on the module search path.</p>
</blockquote>
<p>You need to set it up to something like this:</p>
<pre><code>man
|- __init__.py
|- Mans
   |- __init__.py
   |- man1.py
|- MansTest
   |- __init.__.py
   |- SoftLib
      |- Soft
         |- __init__.py
         |- SoftWork
            |- __init__.py
            |- manModules.py
      |- Unittests
         |- __init__.py
         |- man1test.py
</code></pre>
<p><strong>SECOND</strong>, for the "<code>ModuleNotFoundError: No module named 'Soft'</code>" error caused by <code>from ...Mans import man1</code> in <em>man1test.py</em>, the documented solution to that is to add <em>man1.py</em> to <code>sys.path</code> since <em>Mans</em> is outside the <em>MansTest</em> package. See <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">The Module Search Path</a> from the Python documentation. But if you don't want to modify <code>sys.path</code> directly, you can also modify <code>PYTHONPATH</code>:</p>
<blockquote>
<p><code>sys.path</code> is initialized from these locations:</p>
<ul>
<li>The directory containing the input script (or the current directory when no file is specified). </li>
<li><code>PYTHONPATH</code> (a list of directory names, with the same syntax as the shell variable <code>PATH</code>). </li>
<li>The installation-dependent default.</li>
</ul>
</blockquote>
<p><strong>THIRD</strong>, for <code>from ...MansTest.SoftLib import Soft</code> which you said "<em>was to facilitate the aforementioned import statement in man1.py</em>", that's now how imports work. If you want to import <em>Soft.SoftLib</em> in <em>man1.py</em>, you have to setup <em>man1.py</em> to find <em>Soft.SoftLib</em> and import it there directly.</p>
<p>With that said, here's how I got it to work.</p>
<p>man1.py:</p>
<pre><code>from Soft.SoftWork.manModules import *
# no change to import statement but need to add Soft to PYTHONPATH

def foo():
    print("called foo in man1.py")
    print("foo call module1 from manModules: " + module1())
</code></pre>
<p>man1test.py</p>
<pre><code># no need for "from ...MansTest.SoftLib import Soft" to facilitate importing..
from ...Mans import man1

man1.foo()
</code></pre>
<p>manModules.py</p>
<pre><code>def module1():
    return "module1 in manModules"
</code></pre>
<p>Terminal output:</p>
<pre><code>$ python3 -m man.MansTest.Unittests.man1test
Traceback (most recent call last):
  ...
    from ...Mans import man1
  File "/temp/man/Mans/man1.py", line 2, in &lt;module&gt;
    from Soft.SoftWork.manModules import *
ModuleNotFoundError: No module named 'Soft'
$ PYTHONPATH=$PYTHONPATH:/temp/man/MansTest/SoftLib
$ export PYTHONPATH
$ echo $PYTHONPATH
:/temp/man/MansTest/SoftLib
$ python3 -m man.MansTest.Unittests.man1test
called foo in man1.py
foo called module1 from manModules: module1 in manModules 
</code></pre>
<hr/>
<p>As a suggestion, maybe re-think the purpose of those <em>SoftLib</em> files. Is it some sort of "bridge" between <em>man1.py</em> and <em>man1test.py</em>? The way your files are setup right now, I don't think it's going to work as you expect it to be. Also, it's a bit confusing for the code-under-test (<em>man1.py</em>) to be importing stuff from under the test folder (<em>MansTest</em>).</p>
</div>
<span class="comment-copy">Is it <code>ManTest</code> or <code>MansTest</code>? I wonder what else is wrong with the examples you have provided to put me off even wondering what the real problem is?</span>
<span class="comment-copy">@barny It's  <code>MansTest</code>, not <code>ManTest</code>. Thanks for pointing it out. I made the correction.</span>
<span class="comment-copy">You can hack <code>__path__</code> of imported modules. It's not <code>sys.path</code> but is it OK for you?</span>
<span class="comment-copy">Thank you for the elaborate answer. I am currently busy with a different project and haven't had time to implement your solution, which is why I haven't marked the answer as "accepted" yet. I did upvote it, but it's not going to show because I am new here and have less than 15 reputations.  In any case, in reference to how you got it to work, is there an alternative to modifying PYTHONPATH? I want to solve this problem without modifying any "path" so the code can be transported as it is and used by others without making any modification to their "paths". Thanks again!</span>
<span class="comment-copy">@strangeloop Hmm.. I don't think there is any other way. If you read the Python docs for the <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">the Module Search Path</a>, that's how the interpreter finds the files you <code>import</code>. If you want to make the code portable and avoid others doing extra steps, you can modify <code>sys.path</code> internally inside <i>man1test.py</i>, <b>before</b> you import <i>man1.py</i>. The path modification will only take effect until your program is running, it's not going to affect your user's env. The user just needs to make sure the folders are copied correctly.</span>
