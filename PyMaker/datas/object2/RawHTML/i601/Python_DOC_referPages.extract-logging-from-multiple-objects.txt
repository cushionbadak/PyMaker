<div class="post-text" itemprop="text">
<p>I'm having an issue configuring logging for multiple objects.</p>
<p>Presently, I have two classes representing a <code>server</code> and a <code>coordinator</code>. These are composed such that a <code>coordinator</code> has a <code>server</code> as in instance variable. </p>
<p>See below:</p>
<pre><code>class Coordinator(object):
    def __init__(self):
        self.scheduler = asyncio.get_event_loop()
        self.server = Server(..)


class Server(object):
    def __init__(self, scheduler, host, port):

        ...

        # Configure WebSocket logging
        self.logger = logging.getLogger('websockets')
        self.logger.setLevel(logging.DEBUG)
        self.logger.addHandler(logging.StreamHandler())

        ...
</code></pre>
<p>Before I added the <code>coordinator</code> class the logging in the <code>server</code> class was able to extract the websockets values and display the output. </p>
<p>This no longer works. How can I resolve this issue, and add an additional logger to the <code>Coordinator</code> class?</p>
<p>I'm using python 3.6.8</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>It's unclear from your code snippet exactly how you intend for your classes to be initialized (order, how many copies, etc).  My guess would be your issue is you are trying to configure a separate stream handler for each class logger.</p>
<p>In general to use python logging you want to do the following:</p>
<p><strong>1) Configure logging near your main entry point</strong></p>
<p>This consists of setting up any handlers to control where the log messages will go and what levels of messages.  The easiest way to do this is call <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">logging.basicConfig(..)</a>.  You want to ensure this is done once and only once.  Also you want it to happen before any of your logging calls, so typically this will be one of the first things in your main(..) function.</p>
<p><strong>2) Create and use loggers at their location</strong></p>
<p>You can create as many loggers as you want and give them whatever name you want.  Creating one per module using <code>log = logging.getLogger(__name__)</code> is a good way to start, but you can do per class instead if you prefer.</p>
<p><strong>Example:</strong></p>
<pre><code>import logging


class Coordinator(object):
    def __init__(self):
        self.logger = logging.getLogger('Coordinator')
        self.server = Server()

    def do_whatever(self):
        self.logger.warn("In coordinator")
        self.server.do_whatever()


class Server(object):
    def __init__(self):
        self.logger = logging.getLogger('Server')

    def do_whatever(self):
        self.logger.warn("in server")


if __name__ == '__main__':
    # Logs to stderr by default all messages DEBUG or higher
    logging.basicConfig(level=logging.DEBUG)

    # Set the logging level specifically for the websockets log object
    logging.getLogger('websockets').setLevel(logging.INFO)

    c = Coordinator()
    c.do_whatever()
</code></pre>
<p>Which logs to stderr:</p>
<pre><code>WARNING:Coordinator:In coordinator
WARNING:Server:in server
INFO:websockets:...whatever this library logs...
</code></pre>
</div>
<span class="comment-copy">Thank you for your answer. I need to get the logs from the <a href="https://websockets.readthedocs.io/en/stable/cheatsheet.html#debugging" rel="nofollow noreferrer">websocket</a>. How can I achieve this with your code?</span>
<span class="comment-copy">Ah I see now, I didn't fully understand your question.  I'll add to my example, but if you want to change the logging level for just a specific logger (like one in a library) you can do that like they show in their example.  You should still leave the config of the handlers to the top of your main function.</span>
<span class="comment-copy">Thank you very much Ryan</span>
