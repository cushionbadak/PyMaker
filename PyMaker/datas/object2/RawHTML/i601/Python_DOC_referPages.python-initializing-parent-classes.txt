<div class="post-text" itemprop="text">
<p>I am trying to figure how to use super() to initialize the parent class one by one based on condition. </p>
<pre><code>class A:
    def __init__(self, foo):
        self.foo = foo

class B:
    def __init__(self, bar):
        self.bar == bar

class C(A,B):
    def __init__(self):
        #Initialize class A first.
        #Do some calculation and then initialize class B 
</code></pre>
<p>How do I use super() in <code>class C</code> such that it only initializes <code>class A</code> first, then I do some calc and call super() to initialize <code>class B</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot do what you ask for in <code>C.__init__</code>, as <code>super</code> doesn't give you any control over which specific inherited methods get called, only the order in which they are called, and that is controlled entirely by the order in which the parent classes are listed.</p>
<p>If you use <code>super</code>, you need to use it consistently in <em>all</em> the classes. (That's why it's called <em>cooperative</em> inheritance.) Note this means that <code>C</code> cannot inject any code between the calls to <code>A.__init__</code> and <code>B.__init__</code>.</p>
<p><code>__init__</code> is particularly tricky to implement correctly when using <code>super</code>, because a rule of <code>super</code> is that you have to expected arbitrary arguments to be passed, yet <code>object.__init__()</code> doesn't take any arguments. You need each additional argument to be "owned" by a particular root class that is responsible for removing it from the argument list.</p>
<pre><code>class A:
    def __init__(self, foo, **kwargs):
        # A "owns" foo; pass everything else on
        super().__init__(**kwargs)
        self.foo = foo

class B:
    def __init__(self, bar, **kwargs):
        # B "owns" bar; pass everything else on
        super().__init__(**kwargs)
        self.bar = bar

class C(A,B):
    def __init__(self):
        # Must pass arguments expected by A and B
        super().__init__(foo=3, bar=9)
</code></pre>
<p>The MRO for <code>C</code> is <code>[A, B, object]</code>, so the call tree looks something like this:</p>
<ol>
<li><code>C.__init__</code> is called with no arguments</li>
<li><code>super()</code> resolves to <code>A</code>, so <code>A.__init__</code> is called with <code>foo=3</code> and <code>bar=9</code>.</li>
<li>In <code>A.__init__</code>, <code>super()</code> resolves to <code>B</code>, so <code>B.__init__</code> is called with <code>bar=9</code>.</li>
<li>In <code>B.__init__</code>, <code>super()</code> resolves to <code>object</code>, so <code>object.__init__</code> is called with no arguments (<code>kwargs</code> being empty)</li>
<li>Once <code>object.__init__</code> returns, <code>self.bar</code> is set to <code>bar</code></li>
<li>Once <code>B.__init__</code> returns, <code>self.foo</code> is set to <code>foo</code></li>
<li>Once <code>A.__init__</code> returns, <code>C.__init__</code> finishes up</li>
</ol>
<hr/>
<p>OK, the first sentence isn't entirely true. Since neither <code>A</code> nor <code>B</code>, as currently written, use <code>super</code>, you <em>might</em> be able to assume that an appropriate use of <code>super</code> will simply call one parent function and immediately return.</p>
<pre><code>class A:
    def __init__(self, foo):
        self.foo = foo

class B:
    def __init__(self, bar):
        self.bar == bar

class C(A,B):
    def __init__(self):
        super(A, self).__init__(foo=3)
        # Do some calculation
        super(B, self).__init__(bar=9)
</code></pre>
<p>I'm not entirely certain, though, that this doesn't introduce some hard-to-predict bugs that could manifest with other subclasses of <code>A</code>, <code>B</code>, and/or <code>C</code> that attempt to use <code>super</code> properly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can actually refer the base classes explicitly:</p>
<pre><code>class A:
    def __init__(self, foo):
        self.foo = foo

class B:
    def __init__(self, bar):
        self.bar == bar

class C(A,B):
    def __init__(self):
        A.__init__(self, 'foovalue')
        # Do some calculation
        B.__init__(self, 'barvalue')
</code></pre>
</div>
<span class="comment-copy">The biggest misunderstanding about <code>super().foo()</code> is that it isn't just a shortcut for <code>for cls in parent_classes: cls.foo(self)</code>.</span>
<span class="comment-copy">Thanks Philip, but I am trying to figure how would I achieve this with <code>super()</code></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code> returns a proxy object</a> that allows you to make method calls to the parent classes by the order defined in <code>__mro__</code> attribute. Since you want to explicitly initialize <code>class A</code> and <code>class B</code>, the only way is to call each initializer method explicitly - you need to tell Python which initializer you want to call.</span>
