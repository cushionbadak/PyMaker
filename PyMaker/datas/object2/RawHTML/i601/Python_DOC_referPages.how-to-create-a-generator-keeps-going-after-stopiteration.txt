<div class="post-text" itemprop="text">
<p>If I have multiple iterables as argument, and is there any way to keep the code going after one of the list raise StopIteration?</p>
<p>I cannot use any slicing, len(), or any itertools.</p>
<p>This is what I have tried so far, and I know it is totally wrong but I just cannot figure this out.</p>
<pre><code>def together(*args):
    iterator = [iter(item) for item in args]
    my_list = []

    while True:
            for i in iterator:
                try:
                    lst.append(next(i))
                    print(next(i))
                except StopIteration:
                    return
            if '__next__' == None:
                yield tuple(None)
            else:
                yield tuple(my_list)
            my_list = []
</code></pre>
<p>Here is my current result, iter do store b,g,i but it only prints out first list:</p>
<pre><code>[('a', 'f', 'h')]
</code></pre>
<p>Whats the best way to get a result like this?
Resutls are tuples in a list, and when argument iterables runs out then it get replaced with Nones.</p>
<pre><code>[('a', 'f', 'h'), ('b', 'g', 'i'), ('c', None, 'j'), ('d', None, 'k'), ('e', None, None)]
</code></pre>
<p>I know the StopIteration error rises after the ('b','g','i'), but is there any way to ignore and keep going with different list?</p>
<p>And input looks like:</p>
<pre><code>[v for v in together(disguise('abcde'), disguise('fg'), disguise('hijk'))]
</code></pre>
<p>disguise function looks like:</p>
<pre><code>def disguise(items):
    for v in items:
        yield v
</code></pre>
<p>Any suggestion or help will be appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the second parameter of <code>next</code> to let <code>next</code> return a default value instead of raising a <code>StopIteration</code> exception when a given iterator is exhausted:</p>
<pre><code>def together(*seqs):
    seqs = list(map(iter, seqs))
    while True:
        group = tuple(next(seq, None) for seq in seqs)
        if all(i is None for i in group):
            return
        yield group
</code></pre>
<p>so that:</p>
<pre><code>list(together('abcde', 'fg', 'hijk'))
</code></pre>
<p>returns:</p>
<pre><code>[('a', 'f', 'h'), ('b', 'g', 'i'), ('c', None, 'j'), ('d', None, 'k'), ('e', None, None)]
</code></pre>
</div>
<span class="comment-copy">what's disguise? can you just provide the input as a normal list please</span>
<span class="comment-copy">What is <code>myzip</code> here?</span>
<span class="comment-copy">Input is yield value. I just edited the question for both, thanks!</span>
<span class="comment-copy">You say "I cannot use any slicing, len(), or any itertools." Why not?</span>
<span class="comment-copy">Is it HW? Because looking at the python implementation of <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> would be very illustrative of certain subtle aspects of implementing this correctly</span>
<span class="comment-copy">You should probably explicitly call <code>iter</code> on each of the args passed in, then it would work on any iterable not just iterators. Also, <code>any(group)</code> is potentially a bug, if the iterators produce falsy values</span>
<span class="comment-copy">In your solution the input sequences/iterators should not contain <code>None</code> otherwise <code>together</code> could prematurely terminate. However, since this is a toy problem I don't think this matters that much.</span>
