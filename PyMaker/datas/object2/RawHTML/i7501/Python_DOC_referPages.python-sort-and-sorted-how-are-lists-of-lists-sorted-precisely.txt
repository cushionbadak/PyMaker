<div class="post-text" itemprop="text">
<p>What is the precise rule used in Python in order to sort lists where
the elements are lists? Can this be expressed as a 'key' or 'cmp' 
function? The problems comes from the fact that there are two things
to consider: <em>length</em> and values at their <em>position</em>. </p>
<pre><code>sorted([
   [ 0, 1, 2, 3 ],  # 1st line: longer list
   [ 0, 1 ],        # 2nd line: shorter list
   [ 0, 2 ]         # 3rd line: suspected last
])
</code></pre>
<p>Is it safe to assume that the second line will sort before the first?
Is it safe to assume that the third line will sort always last?</p>
<p>Note, this is <em>not about stability</em>! The specific case above behaves
that way as described. But, can the rules there be considered to
be general? What are the precise rules which python applies here?</p>
<p>Relying on the following definition <a href="https://en.wikipedia.org/wiki/Lexicographical_order#Motivation_and_definition" rel="nofollow noreferrer">Lexicographical Order</a> (Thanks to Ashniwi):</p>
<blockquote>
<p>To compare sequences of different lengths, the shorter sequence is
  usually padded at the end with enough "blanks" (a special symbol that
  is treated as smaller than every element of A). This way of comparing
  sequences of different lengths is always used in dictionaries.
  However, in combinatorics, another convention is frequently used,
  whereby a shorter sequence is always smaller than a longer sequence.
  This variant of the lexicographical order is sometimes called shortlex
  order.</p>
</blockquote>
<p>Is Python using '<em>shortlex order</em>'. Where is proof for that assumption,
beyond practical examples?</p>
</div>
<div class="post-text" itemprop="text">
<p>Quoting from <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>In particular, tuples and lists are compared lexicographically by
  comparing corresponding elements. This means that to compare equal,
  every element must compare equal and the two sequences must be of the
  same type and have the same length.</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/expressions.html#value-comparisons" rel="nofollow noreferrer">Lexicographical comparison between built-in collections works as follows</a>:</p>
<ul>
<li>For two collections to compare equal, they must be of the same type, have the same length, and each pair of corresponding elements must compare equal (for example, <code>[1,2] == (1,2)</code> is false because the type is not the same).</li>
<li>Collections that support order comparison are ordered the same as their first unequal elements (for example, <code>[1,2,x] &lt;= [1,2,y]</code> has the same value as <code>x &lt;= y</code>). If a corresponding element does not exist, the shorter collection is ordered first (for example, <code>[1,2] &lt; [1,2,3]</code> is true).</li>
</ul>
<p>The basic comparison done for lists can be expressed using this function:</p>
<pre><code>def cmp(list_1, list_2):
    length_1 = len(list_1)
    length_2 = len(list_2)
    min_length = min(length_1, length_2)

    # Compare individual items till there's a different item found
    for i in xrange(min_length):
        if list_1[i] &gt; list_2[i]:
            return 1
        elif list_1[i] &lt; list_2[i]:
            return -1

    # All items were same so far, let's compare sizes.
    if length_1 &gt; length_2:
        return 1
    elif length_1 &lt; length_2:
        return -1
    elif length_1 == length_2:
        return 0
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; lst = [[ 0, 1, 2, 3 ], [ 0, 1 ], [ 0, 2 ]]
&gt;&gt;&gt; print sorted(lst) == sorted(lst, cmp=cmp)
True
</code></pre>
<p>Related <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c#L2341" rel="nofollow noreferrer">CPython code for reference</a>:</p>
<pre><code>/* Search for the first index where items are different */
for (i = 0; i &lt; Py_SIZE(vl) &amp;&amp; i &lt; Py_SIZE(wl); i++) {
    int k = PyObject_RichCompareBool(vl-&gt;ob_item[i],
                                     wl-&gt;ob_item[i], Py_EQ);
    if (k &lt; 0)
        return NULL;
    if (!k)
        break;
}

if (i &gt;= Py_SIZE(vl) || i &gt;= Py_SIZE(wl)) {
    /* No more items to compare -- compare sizes */
    Py_ssize_t vs = Py_SIZE(vl);
    Py_ssize_t ws = Py_SIZE(wl);
    int cmp;
    PyObject *res;
    switch (op) {
    case Py_LT: cmp = vs &lt;  ws; break;
    case Py_LE: cmp = vs &lt;= ws; break;
    case Py_EQ: cmp = vs == ws; break;
    case Py_NE: cmp = vs != ws; break;
    case Py_GT: cmp = vs &gt;  ws; break;
    case Py_GE: cmp = vs &gt;= ws; break;
    default: return NULL; /* cannot happen */
    }
    if (cmp)
        res = Py_True;
    else
        res = Py_False;
    Py_INCREF(res);
    return res;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By default, <code>sorted</code> uses the <code>__lt__</code> method of the items that are compared. And lists with comparable elements are compared lexicographically, according to the Python documentation. So yes, the language guarantees that in the shorter string will be sorted before the longer string.</p>
</div>
<span class="comment-copy">You can specify your own rule to sort lists in list with the <code>key</code> keyword argument in <code>sorted</code> or <code>list.sort</code>. The value of the parameter is a function which accept a single parameter(each element in the list) and return a sort value of each element. You can use <code>len</code> as the <code>key</code> to sort by length of list in the list.</span>
<span class="comment-copy">I think so... this is the default list ordering, i.e. lexicographically.</span>
<span class="comment-copy">There may be a default, although it's better to specify the sort parameter when possible (in case in future releases the default changes). Refer to stamaimer's comment.</span>
<span class="comment-copy">@ChickenFeet while I would agree with your comment in general, I doubt such a well established default will ever change... Or if you are that paranoid, you should also redefine ordering for ints too in case later versions decide that -3 &gt; 7... :)</span>
<span class="comment-copy">I would consider your answer the to be the most logical. However, I am having trouble to see a proof for that. Could you elaborate?</span>
<span class="comment-copy">@Frank-ReneSchäfer Proof as in? You could use the function with <code>cmp</code> parameter available Python2's sorted function.</span>
<span class="comment-copy">One might use your 'cmp', correct. But if the default behavior would be equivalent, it is likely to be more efficient. Your reference to the docs comments on identity not on order.</span>
<span class="comment-copy">@Frank-ReneSchäfer Docs have not mentioned identity anywhere, identity is a different thing than equality. As per docs the comparison is done lexicographically, <a href="https://en.wikipedia.org/wiki/Lexicographical_order#Motivation_and_definition" rel="nofollow noreferrer">from Wikipedia</a>: <i>Given two different sequences of the same length, a1a2...ak and b1b2...bk, the first one is smaller than the second one for the lexicographical order, if ai&lt;bi (for the order of A), for the first i where ai and bi differ.</i></span>
<span class="comment-copy">@Frank-ReneSchäfer My <code>cmp</code> function is only to show how lists are compared internally, I never said that you should use it in your actual code. You can though use it to see if you're getting same output as provided by default list of lists sorting.</span>
