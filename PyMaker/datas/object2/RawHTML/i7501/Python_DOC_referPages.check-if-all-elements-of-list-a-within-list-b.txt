<div class="post-text" itemprop="text">
<p>I have done my research, however all these techniques return true, i need them to return false.</p>
<pre><code>print set([2, 2]).issubset([2, 3, 3]) #returns True
print set([2, 3, 3]).issuperset(set([2, 2])) #returns True
print all(x in {2, 3, 3} for x in [2, 2]) #returns True
print set([2, 2]) &lt;= set([2, 3, 3]) #returns True
</code></pre>
<p>The lists I'm comparing have duplicate numbers</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>list.count</code> inside of the <code>all</code> function:</p>
<pre><code>all(l1.count(i) &lt;= l2.count(i) for i in set(l1))
</code></pre>
<p>For every element in <code>l1</code>, this will check if there is at least as many ocurences in <code>l2</code>.
If any element of <code>l1</code> appears fewer times in <code>l2</code>, then the <code>all</code> function will return <code>False</code>.
The conversion of <code>l1</code> into a <code>set</code> prevents the number of iterations from increasing when <code>l1</code> consists in a large number of the same value.</p>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; f = lambda l1, l2: all(l1.count(i) &lt;= l2.count(i) for i in set(l1))
&gt;&gt;&gt; f([2, 2], [2, 3, 3])
False
&gt;&gt;&gt; f([2, 2], [2, 2, 3])
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm still uncertain what you're really asking. Let's go with:</p>
<pre><code>A = [2,2]
B = [2,3,3]
</code></pre>
<p>And the question being if you can make A by choosing without replacement out of B. That is, not only should the items in A be a subset of those in B, there must be at least as many of each in B as there are in A. </p>
<p>One way to test this is using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a>:</p>
<pre><code>from collections import Counter
countsA = Counter(A)
countsB = Counter(B)
difference = countsA - countsB # any extra items in A
print difference, not difference
</code></pre>
<p>Output: <code>Counter({2: 1}) False</code></p>
<p>Since collections are true if they contain anything, we can negate it for the <code>False</code> value you asked for. This difference can also be used to show exactly which items A had that couldn't be taken out of B, in this case 1 count of the item 2. </p>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>a = [2, 2]
b = [2, 3, 3]

from collections import Counter as cC

fa = cC(a)
print(fa)  # Counter({2: 2})
fb = cC(b)
print(fb)  # Counter({3: 2, 2: 1})

test = all(fa[entry] &lt;= fb.get(entry, -1e+30) for entry in fa)

print(test)  # False
</code></pre>
<p>Or according to what @ChrisRand said in the comments:</p>
<pre><code>test = fa - fb == {}
print(test)  # False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just look for an implementation of a <a href="https://pypi.python.org/pypi/multiset" rel="nofollow noreferrer">multiset</a>. It should pass (most of) your test cases. </p>
</div>
<div class="post-text" itemprop="text">
<p>Mathematically answers by python functions are correct. It seems you also want to check the the number of elements. So, a user defined function will look like</p>
<pre><code>def compare(listsuper,listsub):
   stat=None
   for element in listsuper:
       if listsuper.count(element)==listsub.count(element):
          pass
       else:
          stat=False
   if stat==None:
       for element in listsub:
           if element in listsub and element in listsuper:
               pass
           else:
               stat=False
   if stat==None:
       stat=True
   return stat
print compare([2,3,3],[2, 2])
</code></pre>
<p>Hope this function works as you want</p>
</div>
<span class="comment-copy">Perhaps you're looking for <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>(acts as a multiset).</span>
<span class="comment-copy">You haven't labeled your lists. All those tests work, at potentially different efficiency, but I can't tell if you're testing what you think you are. Is your issue that you want them to hold at least as many of each item as the other collection?</span>
<span class="comment-copy">Conversion to <code>set</code> removes duplicates and that is why they return <code>True</code>. Compare them as <code>list</code>s; that is without converting.</span>
<span class="comment-copy"><code>sorted(lst1) == sorted(lst2)</code> ?</span>
<span class="comment-copy">@Chris_Rands They can also be sub<code>list</code>s.. Why <code>==</code>?</span>
<span class="comment-copy">I suggest changing <code>for i in l1</code> to <code>for i in set(l1)</code>. Otherwise, for items that appear multiple times in <code>l1</code>, it will be checked multiple times. If <code>l1</code> consists only of a single value, this has cubic rather than quadratic time.</span>
<span class="comment-copy">@JimOldfield That's a good point, I edited this.</span>
<span class="comment-copy">Although even with that change, Ev. Kounis answer is even better as it is linear rather than quadratic.</span>
<span class="comment-copy"><code>Counter</code>s support subtraction</span>
<span class="comment-copy">"Both inputs and outputs may be zero or negative." <a href="https://docs.python.org/3/library/collections.html#collections.Counter.subtract" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">While that is true for <code>update</code> and <code>subtract</code>, it is not so for <code>-</code> (under mathematical operations, a few paragraphs down).</span>
<span class="comment-copy">Agreed @YannVernier  .</span>
<span class="comment-copy"><code>Counter({3: 2, 2: 1}) - Counter({2: 2})</code> -&gt; <code>Counter({3: 2})</code> and not <code>Counter({3: 2, 2: -1})</code></span>
