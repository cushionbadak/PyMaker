<div class="post-text" itemprop="text">
<p>I have a class called <code>Time</code>, and I need to implement a <code>Frequency</code> class. How can I implement dividing <code>int</code>s or <code>float</code>s by an instance of <code>Time</code> to get an instance of <code>Frequency</code> ?</p>
<p>I already know about <code>__div__</code>, <code>__truediv__</code>, <code>__floordiv__</code> and other Python special methods, and I already use them in my code to divide instances of classes by numbers or instances of other classes, but I cannot find a way to divide a number by an instance of my class.</p>
<p>Is it possible to implement dividing a number by an instance of a class in Python ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__rtruediv__</code> method is what you're looking for.
When <code>x / y</code> is executed, if <code>type(x)</code> does not implement a <code>__div__(self, other)</code> method where <code>other</code> can be of class <code>type(y)</code>, then <code>type(y).__rtruediv__(y, x)</code> is executed, and its result is returned.</p>
<p>Usage:</p>
<pre><code>class Foo:
    def __init__(self, x):
        self.x = x

    def __truediv__(self, other):
        return self.x / other

    def __rtruediv__(self, other):
        return other / self.x
</code></pre>
<pre><code>&gt;&gt;&gt; f = Foo(10)    
&gt;&gt;&gt; f / 10
1.0
&gt;&gt;&gt; 10 / f
1.0</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes. You just have to make sure that <code>Time.__rtruediv__()</code> returns a <code>Frequency</code> instance when it receives a float or integer.</p>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; 100 / Time(2)
Frequency(50.0)
&gt;&gt;&gt; 2.5 / Time(5)
Frequency(0.5)
</code></pre>
<p>Implementation: </p>
<pre><code>class Time:
  def __init__(self, value):
    self.value = value

  def __rtruediv__(self, other):
    if not isinstance(other, (int, float)):
      return NotImplemented
    return Frequency(other / self.value)

class Frequency:
  def __init__(self, value):
    self.value = value

  def __repr__(self):
    return '{}({})'.format(self.__class__.__name__, self.value)
</code></pre>
<p>The python docs contains a full example on <a href="https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations" rel="noreferrer">implementing the arithmetic operations</a> for your custom classes.</p>
<p>The proper way to handle incompatible types is to return the special value <code>NotImplemented</code>. </p>
<blockquote>
<p><a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="noreferrer"><strong>NotImplemented</strong></a></p>
<p>Special value which should be returned by the binary
  special methods (e.g. <code>__eq__()</code>, <code>__lt__()</code>, <code>__add__()</code>, <code>__rsub__()</code>, etc.)
  to indicate that the operation is not implemented with respect to the
  other type</p>
</blockquote>
<p>Suppose you try to use a unsupported complex number, returning <code>NotImplemented</code> will eventually cause a <code>TypeError</code> with a correct error message. (at least in python 3)</p>
<pre><code>&gt;&gt;&gt; 100j / Time(2)

Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for /: 'complex' and 'Time'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you need to implement <code>__rtruediv__</code> and<code>__rfloordiv__</code>.</p>
<p>from <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer">the documentation</a></p>
<pre><code>object.__radd__(self, other)
object.__rsub__(self, other)
object.__rmul__(self, other)
object.__rmatmul__(self, other)
object.__rtruediv__(self, other)
object.__rfloordiv__(self, other)
object.__rmod__(self, other)
object.__rdivmod__(self, other)
object.__rpow__(self, other)
object.__rlshift__(self, other)
object.__rrshift__(self, other)
object.__rand__(self, other)
object.__rxor__(self, other)
object.__ror__(self, other)
</code></pre>
<blockquote>
<p>These methods are called to implement the binary arithmetic operations
  (+, -, *, @, /, //, %, divmod(), pow(), **, &lt;&lt;, &gt;&gt;, &amp;, ^, |) with
  reflected (swapped) operands. These functions are only called if the
  left operand does not support the corresponding operation [3] and the
  operands are of different types. [4] For instance, to evaluate the
  expression x - y, where y is an instance of a class that has an
  <code>__rsub__()</code> method, <code>y.__rsub__(x)</code> is called if <code>x.__sub__(y)</code> returns NotImplemented.</p>
</blockquote>
</div>
<span class="comment-copy">Having a different class for every type of quantity sounds like a road to madness... How are you handling mismatches between units?</span>
<span class="comment-copy">I use <code>isinstance</code>, and I only had to implement Time and Frequency.</span>
