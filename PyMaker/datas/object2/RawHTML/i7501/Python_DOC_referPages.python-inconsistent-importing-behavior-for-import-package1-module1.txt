<div class="post-text" itemprop="text">
<p>I was assuming that statements of the form</p>
<p><code>import package1.module1</code></p>
<p>were <strong>only</strong> for <em>packages</em> and <em>modules</em>, but <strong>not</strong> for an <em>object</em> in a module, so for instance if <code>module1</code> contains <code>variable1</code>, I am not able to do</p>
<p><code>import package1.module1.variable1</code></p>
<p>Here's the perceived inconsistency: assume that <code>module1</code> and <code>variable1</code> have the same name, for instance let's say both are called <code>module1</code>. And, in the <code>__init__.py</code> of <code>package1</code> I have</p>
<p><code>from .module1 import module1</code></p>
<p>then doing</p>
<p><code>import package1.module1</code></p>
<p>will import the <em>object</em> <code>module1</code>, not the <em>module</em> <code>module1</code>.
This <strong>only</strong> works if <code>module1</code> is the same name for both the <em>object</em> and the <em>module</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The official explanation can be found in the <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>The import statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an ImportError exception is raised.</p>
</blockquote>
<p>It seems that <code>import</code> appears to think the object <code>module1</code> from the module <code>module1</code> is a module, which is why the <code>import package1.module1</code> works but yields the object instead.</p>
<p>As far as a workaround goes, if you try the <code>from _ import _ as x</code>, that will rename the attribute and get around the name shadowing. It should yield the result you're looking for - a path import of the module <code>module1</code> (since Python will see type <code>&lt;module&gt;</code>) and not an object import of the variable <code>module1</code>.</p>
<p>Here is some code output to help illustrate things more clearly:</p>
<pre><code>&gt;&gt;&gt; import package1.module1
&gt;&gt;&gt; print(package1.module1)
&lt;module 'package1.module1' from 'package1/module1.pyc'&gt;
&gt;&gt;&gt; from package1.module1 import module1
&gt;&gt;&gt; print(module1)
1
&gt;&gt;&gt; from package1 import m
&gt;&gt;&gt; print(m)
1
</code></pre>
<p>Here I did <code>from module1 import module1 as m</code> in the <code>__init__.py</code> of <code>package1</code> and I set the <code>module1</code> variable to 1 in <code>module1.py</code>.</p>
</div>
<span class="comment-copy">I'm sorry but this doesn't answer the question. I'm specifically asking for statements of the form "import package1.module1".</span>
<span class="comment-copy">Sure, I updated my answer - hope that makes things clearer.</span>
<span class="comment-copy">I appreciate you trying to make it clearer, but what you're saying ("Python will (I believe) first look for any objects called module1 contained in the attributes of package1. If it cannot find any, then it interprets the import as a path") is incorrect. You can test this by having any variable in module1 and try importing it with "import package1.module1.variable1". It will not work.</span>
<span class="comment-copy">You're right, I misspoke. In your original setup, <code>module1</code> is an object in <code>project1</code>'s attributes (you can call <code>dir(package1)</code> after importing the package to see this. But the type of the object is not <code>&lt;module&gt;</code> but rather <code>&lt;int&gt;</code> (as in the case in my example). The name shadowing is to blame I believe. Updated my answer.</span>
<span class="comment-copy">Found a better explanation in the docs and revised my answer accordingly.</span>
