<div class="post-text" itemprop="text">
<p>I have the following program and the variable(dictionary) in question is <strong>player_info</strong> that stores player information (name and goals). In order to solve the error that results currently, I simply need to make player_info a <strong>global variable</strong>, but I was wondering if stackoverflow experts could suggest or discuss the possibility of alternate ways of solving this problem <strong>WITHOUT the use of global variables.</strong> </p>
<p><strong>Code</strong></p>
<pre><code>#FOOTBALL COACH app

#The program allows a user to enter a number of players (their names and goals scored) and then search for a player, returning their average goals for the three matches


import sys 
def main():
 mainmenu()

def mainmenu():

  print("=====WELCOME to the MAIN MENU=============")
  print("""
  1..........Add New Players &amp; Goals
  2..........Search by Players
  3..........Quit

  =========================================
  """)

  choice=int(input("Enter choice:"))
  if choice==1:
    addplayers()
  elif choice==2:
    searchplayer(player_info)
  elif choice==3:
    sys.exit()
  else:
    print("You must make a valid choice - 1, 2 or 3")


def addplayers():


  player_info= {} #create a dictionary that stores the player name: player goals

  num_players = int(input("Please enter number of players you wish to enter:"))
  print ("You are entering %s players" %num_players)
  player_data = ['Match 1 goals : ', 'Match 2 goals : ', 'Match 3 goals : ']
  for i in range(0,num_players):
      player_name = input("Enter Player Name :")
      player_info[player_name] = {}
      for entry in player_data:
          player_info[player_name][entry] = int(input(entry)) #storing the marks entered as integers to perform arithmetic operations later on.


  mainmenu()


def searchplayer():  
   print("===============SEARCH by player: Calculate average goals==================")
   name = input("Player name : ")
   if name in player_info.keys():
     #print student_info
      print ("Average player goals : ", str(sum(player_info[name].values())/3.0))
   else:
      print("Please enter a valid player name:")

main()
</code></pre>
<p>As mentioned, I am aware that re-writing this in the addplayer() sub would fix the problem:</p>
<pre><code>global player_info
player_info = {} #create a dictionary that stores the player name: player goals
</code></pre>
<p>...I am looking for ways to solve the problem WITHOUT the use of global variables. </p>
<p>Update:</p>
<p>One answer below using return player_info is what I would like to go with, but it doesn't quite work yet. Also, I need to return to the main menu each time a player is added, not quite sure how to do this, without a mainmenu call each time. Any suggestions? <a href="https://repl.it/JRl5/1" rel="nofollow noreferrer">https://repl.it/JRl5/1</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>return</code> inside your function to avoid using global variables. A simple example is shown below:</p>
<pre><code>def addplayers():

    player_info= {} 

    name = input("Enter Name: ")
    test = int(input("Enter a number: "))

    player_info[name] = test

    return player_info


player_info = addplayers()
</code></pre>
<p>If you then wanted to use this in another function you would just pass in the dictionary as an argument to that function:</p>
<pre><code>def searchplayers(player_info):

    print (player_info)
</code></pre>
<p>Note: An interesting answer on "<a href="https://stackoverflow.com/questions/19158339/why-are-global-variables-evil">Why are global variables evil?</a>"</p>
<p>Edit:</p>
<p>Your <code>addplayers()</code> was calling <code>mainmenu()</code> which itself was being calling within <code>mainmenu()</code>. This is a recursive function and it might be best to avoid these unless there's a good reason for having it. I would put the contents of <code>mainmenu</code> inside a <code>while</code> loop until some condition is met. The complete code is shown below (I have removed the <code>main</code> function as it wasn't really doing anything):</p>
<pre><code>def mainmenu():

    stop = False

    while stop == False:

        print("=====WELCOME to the MAIN MENU=============")
        print("""
        1..........Add New Players &amp; Goals
        2..........Search by Players
        3..........Quit

        =========================================
        """)

        choice=int(input("Enter choice:"))
        if choice==1:
            player_info = addplayers()
        elif choice==2:
            searchplayer(player_info)
        elif choice==3:
            print ("Exit the main menu")
            stop = True
        else:
            print("You must make a valid choice - 1, 2 or 3")


def addplayers():


    player_info= {} #create a dictionary that stores the player name: player goals

    num_players = int(input("Please enter number of players you wish to enter:"))
    print ("You are entering %s players" %num_players)
    player_data = ['Match 1 goals : ', 'Match 2 goals : ', 'Match 3 goals : ']

    for i in range(0,num_players):
        player_name = input("Enter Player Name :")
        player_info[player_name] = {}

        for entry in player_data:
            player_info[player_name][entry] = int(input(entry)) #storing the marks entered as integers to perform arithmetic operations later on.

    return player_info


def searchplayer(player_info):  
    print("===============SEARCH by player: Calculate average goals==================")
    name = input("Player name : ")
    if name in player_info.keys():
        #print student_info
        print ("Average player goals : ", str(sum(player_info[name].values())/3.0))
    else:
        print("Please enter a valid player name:")


mainmenu()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Store everything related to the game in a data structure, for example a dictionary, and pass it along in all functions where it can be updated as needed. Write a function "newgame" that creates this structure and initialises it.</p>
<p>In a way, this is object-oriented programming without using Python's syntax for classes and objects. Probably, you will learn these later in your class / tutorial.</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, it is always possible to avoid using global variables. Secondly, global variables are possibly a misnomer in Python; <code>global</code> stores the variable in the local globals, which is typically the local module. That avoids a large part of the problem languages like C have with globals, in that they collide; Python has a namespace per module. For a simple script, where there is only one context, that might be fine. </p>
<p>Another namespace you might use is that of a particular object, using a class. This might look like:</p>
<pre><code>class Game:
    def mainmenu(self,...):
        self.addplayers()
    def addplayers(self):
        self.player_info = {}
</code></pre>
<p>With that sort of code, whoever instantiates <code>Game</code> can make multiple instances, each passed as <code>self</code> when used. This is in large part syntactic sugar for a similar form of mutable state passing:</p>
<pre><code>def mainmenu():
    state={}
    addplayers(state)
def addplayers(state):
    state['player_info'] = {}
</code></pre>
<p>For some forms of programming, immutable state is far preferable (in particular, multithreading where data is shared, or to keep a log where you can undo steps). That's done similarly but you make a new state for each call:</p>
<pre><code>def mainmenu():
    state = {}
    state = addplayers(state)
def addplayers(oldstate):
    newstate = oldstate.copy()
    newstate['player_info'] = {}
    return newstate
</code></pre>
<p>Python isn't designed for this and doesn't really have a mode to keep you from inadvertently modifying mutable types. Some types can be converted to similar types that are immutable, like <code>frozenset</code> or <code>tuple</code>. </p>
<p>One of the weirder hacks we can do is calling a Python function with a different set of globals than it normally has. This can be abused to take your existing functions, <code>global</code> statements and all, and have them use a different variable:</p>
<pre><code>fakeglobals = mainmenu.__globals__.copy()
exec(addplayers.__code__, fakeglobals)
</code></pre>
<p>Your original code has calls back and forth between functions, though, and each of those will reset their globals per that <code>__globals__</code> attribute. </p>
<p>Your code also implements a loop using tail recursion. This is not optimized in Python and will run out of stack space eventually. In languages where tail recursion is optimized, you can pass along state as arguments continously and need not return it. </p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/simple_stmts.html#grammar-token-return_stmt" rel="nofollow noreferrer"><code>return</code></a> the dictionary</span>
<span class="comment-copy">Thank you - as a valid learning question, I'm not sure why this question was downvoted!!!!! :(</span>
<span class="comment-copy">I didn't downvote, but there is a quite a lot of code in your question. You could have probably made it a bit shorter with a small bit of code which reproduces the issue you are having rather than posting all of it.</span>
<span class="comment-copy">Can I ask what player_info=addplayers() does please?</span>
<span class="comment-copy"><code>addplayers()</code> is the function we have defined. As there is a return statement within the function itself we need to create a variable outside of the function which will be equal to whatever was returned when we call this function.</span>
<span class="comment-copy">okay - I just tried it and it doesn't quite work. player_info=addplayers() ...is this to be declared outside the function as you have shown?</span>
