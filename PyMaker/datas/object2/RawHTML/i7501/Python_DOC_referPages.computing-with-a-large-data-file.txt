<div class="post-text" itemprop="text">
<p>I have a very large (say a few thousand) list of partitions, something like:</p>
<pre><code>[[9,0,0,0,0,0,0,0,0], 
[8,1,0,0,0,0,0,0,0], 
..., 
[1,1,1,1,1,1,1,1,1]]
</code></pre>
<p>What I want to do is apply to each of them a function (which outputs a small number of partitions), then put all the outputs in a list and remove duplicates. </p>
<p>I am able to do this, but the problem is that my computer gets very slow if I put the above list directly into the python file (esp. when scrolling). What is making it slow? If it is memory being used to load the whole list, </p>
<p>Is there a way to put the partitions in another file, and have the function just read the list term by term? </p>
<p>EDIT: I am adding some code. My code is probably very inefficient because I'm quite an amateur. So what I really have is a list of lists of partitions, that I want to add to:</p>
<pre><code>listofparts3 = [[[3],[2,1],[1,1,1]],
[[6],[5,1],...,[1,1,1,1,1,1]],...]

def addtolist3(n):
    a=int(n/3)-2
    counter = 0
    added = []
    for i in range(len(listofparts3[a])):
        first = listofparts3[a][i]
        if len(first)&lt;n:
            for i in range(n-len(first)):
                first.append(0)
        answer = lowering1(fock(first),-2)[0]
        for j in range(len(answer)):
            newelement = True
            for k in range(len(added)):
                if (answer[j]==added[k]).all():
                    newelement = False
                    break
            if newelement==True:
                added.append(answer[j])
        print(counter)
        counter = counter+1
    for i in range(len(added)):
        added[i]=partition(added[i]).tolist()
    return(added)
</code></pre>
<p>fock, lowering1, partition are all functions in earlier code, they are pretty simple functions. The above function, say addtolist(24), takes all the partition of 21 that I have and returns the desired list of partitions of 24, which I can then append to the end of listofparts3.</p>
</div>
<div class="post-text" itemprop="text">
<p>A few thousand partitions uses only a modest amount of memory, so that likely isn't the source of your problem.</p>
<p>One way to speed-up function application is to use <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><em>map()</em></a> for Python 3 or <a href="https://docs.python.org/2.7/library/itertools.html#itertools.imap" rel="nofollow noreferrer"><em>itertools.imap()</em></a> from Python 2.</p>
<p>The fastest way to eliminate duplicates is to feed them into a Python <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer"><em>set()</em></a> object.</p>
</div>
<span class="comment-copy">what is the size of your file?</span>
<span class="comment-copy">About 1 MB in plain text.</span>
<span class="comment-copy">that shouldnt be making your computer slow. Please post code.</span>
<span class="comment-copy">I have added some code. I think it's just having the list in the python file itself which is slowing stuff down though. Mainly it gets slow when I try to scroll through the part of the file which contains the long lists.</span>
<span class="comment-copy">Are you be any chance opening the large content in a .py file in your text editor? If so there is a better way</span>
<span class="comment-copy">would <code>set()</code> be faster than <code>dict()</code>? genuinely curious :)</span>
<span class="comment-copy">@pyjg Most likely sets would be faster.  Essentially, dicts and sets are both hash tables under-the-hood, however, sets are not burdened by 1) needing to store the value field associated with each key, and 2) needing to preference the common use case of small dicts for keyword arguments and instance dicts.  Sets are specialized for uniquification and fast membership testing, and so they tend to be a little better at those tasks than dicts which have to serve other use cases.  That said, different use cases and examples tend to touch different "sweet spots" for each container.</span>
<span class="comment-copy">got it, thanks a lot!</span>
