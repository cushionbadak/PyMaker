<div class="post-text" itemprop="text">
<p>Since version 3.4, Python <a href="https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests" rel="nofollow noreferrer">supports a simple subtest syntax when writing unittests</a>. A simple example could look like this:</p>
<pre><code>import unittest

class NumbersTest(unittest.TestCase):

    def test_successful(self):
        """A test with subtests that will all succeed."""
        for i in range(0, 6):
            with self.subTest(i=i):
                self.assertEqual(i, i)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>When running the tests, the output will be</p>
<pre><code>python3 test_foo.py --verbose
test_successful (__main__.NumbersTest)
A test with subtests that will all succeed. ... ok

----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p>However, in my real world use cases, the subtests will depend on a more complex iterable and check something which is very different for each subtest. Consequently, I would rather have each subtest counted and listed as a separated test case in the output (<code>Ran 6 tests in ...</code> in this example) to get the full picture.</p>
<p>Is this somehow possible with the plain <code>unittest</code> module in Python? <a href="http://nose.readthedocs.io/en/latest/writing_tests.html#test-generators" rel="nofollow noreferrer">The nose test generator feature</a> would output each test separately but I would like to stay compatible with the standard library if possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could subclass <code>unittest.TestResult</code>:</p>
<pre><code>class NumbersTestResult(unittest.TestResult):
    def addSubTest(self, test, subtest, outcome):
        # handle failures calling base class
        super(NumbersTestResult, self).addSubTest(test, subtest, outcome)
        # add to total number of tests run
        self.testsRun += 1
</code></pre>
<p>Then in <code>NumbersTest</code> override the <code>run</code> function:</p>
<pre><code>def run(self, test_result=None):
    return super(NumbersTest, self).run(NumbersTestResult())
</code></pre>
<p>Sorry I cannot test this in a fully working environment right now, but this should do the trick.</p>
</div>
