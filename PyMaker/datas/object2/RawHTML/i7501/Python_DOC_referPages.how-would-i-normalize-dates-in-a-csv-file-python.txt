<div class="post-text" itemprop="text">
<p>I have a CSV file with a field named  <code>start_date</code> that contains data in a variety of formats.</p>
<p>Some of the formats include e.g., <code>June 23, 1912</code> or <code>5/11/1930</code> (month, day, year). But not all values are valid dates.</p>
<p>I want to add a <code>start_date_description</code> field adjacent to the <code>start_date</code> column to filter invalid date values into. Lastly, normalize all valid date values in start_date to ISO 8601 (i.e., <code>YYYY-MM-DD</code>). </p>
<p>So far I was only able to load the start_date into my file, I am stuck and would appreciate ant help. Please, any solution especially without using a library would be great!</p>
<pre><code>import csv

date_column = ("start_date")
f = open("test.csv","r")
csv_reader = csv.reader(f)

headers = None
results = []
for row in csv_reader:
    if not headers:
        headers = []
        for i, col in enumerate(row):
           if col in date_column:
            headers.append(i)
    else:
        results.append(([row[i] for i in headers]))

print results
</code></pre>
<p><a href="https://i.stack.imgur.com/xTQOD.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/xTQOD.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>One way is to use <code>dateutil</code> module, you can parse data as follows:</p>
<pre><code>from dateutil import parser
parser.parse('3/16/78')
parser.parse('4-Apr') # this will give current year i.e. 2017
</code></pre>
<p>Then parsing to your format can be done by</p>
<pre><code>dt = parser.parse('3/16/78')
dt.strftime('%Y-%m-%d')
</code></pre>
<p>Suppose you have table in dataframe format, you can now define parsing function and apply to column as follows:</p>
<pre><code>def parse_date(start_time):
    try:
        return parser.parse(x).strftime('%Y-%m-%d')
    except:
        return ''
df['parse_date'] = df.start_date.map(lambda x: parse_date(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Question</strong>: ... add a start_date_description ... normalize ... to ISO 8601</p>
</blockquote>
<p>This reads the File <code>test.csv</code> and validates the Date String in Column <code>start_date</code> with Date Directive Patterns and returns a 
<code>dict{description, ISO}</code>.  The returned <code>dict</code> is used to update the current Row <code>dict</code> and the updated Row <code>dict</code> is writen to the File <code>test_update.csv</code>.</p>
<p><strong>Put this in a NEW Python File and run it!</strong></p>
<p>A missing valid Date Directive Pattern could be simple added to the Array.  </p>
<blockquote>
<p>Python Â» 3.6 Documentation: <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior" rel="nofollow noreferrer">8.1.8. strftime() and strptime() Behavior</a> </p>
</blockquote>
<pre><code>from datetime import datetime as dt
import re

def validate(date):
    def _dict(desc, date):
        return {'start_date_description':desc, 'ISO':date}

    for format in [('%m/%d/%y','Valid'), ('%b-%y','Short, missing Day'), ('%d-%b-%y','Valid'),
                   ('%d-%b','Short, missing Year')]: #, ('%B %d. %Y','Valid')]:
        try:
            _dt = dt.strptime(date, format[0])
            return _dict(format[1], _dt.strftime('%Y-%m-%d'))
        except:
            continue

    if not re.search(r'\d+', date):
        return _dict('No Digit', None)

    return _dict('Unknown Pattern', None)

with open('test.csv') as fh_in, open('test_update.csv', 'w') as fh_out:
    csv_reader = csv.DictReader(fh_in)
    csv_writer = csv.DictWriter(fh_out,
                                fieldnames=csv_reader.fieldnames +
                                           ['start_date_description', 'ISO'] )
    csv_writer.writeheader()

    for row, values in enumerate(csv_reader,2):
        values.update(validate(values['start_date']))

        # Show only Invalid Dates
        if any(w in values['start_date_description'] 
               for w in ['Unknown', 'No Digit', 'missing']):

            print('{:&gt;3}: {v[start_date]:13.13} {v[start_date_description]:&lt;22} {v[ISO]}'.
                  format(row, v=values))

        csv_writer.writerow(values)
</code></pre>
<blockquote>
<p><strong>Output</strong>:</p>
<pre><code>start_date    start_date_description ISO
June 23. 1912 Valid                  1912-06-23
12/31/91      Valid                  1991-12-31
Oct-84        Short, missing Day     1984-10-01
Feb-09        Short, missing Day     2009-02-01
10-Dec-80     Valid                  1980-12-10
10/7/81       Valid                  1981-10-07
Facere volupt No Digit               None
... (omitted for brevity)
</code></pre>
</blockquote>
<p><strong><em>Tested with Python: 3.4.2</em></strong></p>
</div>
<span class="comment-copy">Perhaps the <a href="https://dateparser.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>dateparser</code> module</a> could help here if you don't know the exact formats of the dates you're receiving</span>
<span class="comment-copy">How would run your example to be evaluated by the whole csv file?</span>
<span class="comment-copy">I update the my solution. Let me know if it works for you. I assume that your dataframe has <code>start_date</code> as a column</span>
<span class="comment-copy">I ran your code and it didn't work, it continues to say "_data" is not defined. I placed your code directly below mines, then ran it. Any suggestions?</span>
<span class="comment-copy">The file name is on the image I uploaded, should i change _data to the file name ?</span>
<span class="comment-copy">I ran it again and only what you placed in sDate was printed to the console, the actual file wasn't evaluated.</span>
