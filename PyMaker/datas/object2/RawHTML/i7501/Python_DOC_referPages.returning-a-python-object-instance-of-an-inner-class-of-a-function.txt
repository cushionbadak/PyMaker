<div class="post-text" itemprop="text">
<p>I wrote a function in Python that is supposed to work similar to a factory in Java, as it instances the correct class for the given parameters and returns this instance. </p>
<p>A minimal example with only one class inside the function would be this:</p>
<pre><code>def create_object(param):

    class SpecialClass(ParentClass):
        def func(self, param):
            doSomething()

    class_instance = SpecialClass(param)
    return class_instance
</code></pre>
<p>I can flawlessly use this object when I call this function from outside. Coming from a Java background, I assume this has something to do with the dynamic typing in Python but I'm still not sure why this actually works. Isn't the scope where that class is known just within the function itself? </p>
</div>
<div class="post-text" itemprop="text">
<p>To answer your question, you have returned an object and Python will let you use it regardless of where the original class was defined. There are no private classes in Python and functions themselves are objects, so basically when you return the object, everything outside of that function sees the object as an instance of <code>create_object.SpecialClass</code>.</p>
<p>In practice though factories are not something that you make in Python. You should be using a class method that will simply return an instance of the class. You can read more about it here: <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#classmethod</a></p>
<p>If you're confused just google <code>python classmethod decorator</code> and there are some good Stackoverflow explanations of how to use them.</p>
</div>
<div class="post-text" itemprop="text">
<p>Excuse my terrible Java, but I can't see how your Python code is any different from this:</p>
<pre><code>class NestedScope {
    public static void main(String[] args) {
      OuterClass oc = new OuterClass();
      oc.bar().foo();
    }
}

class OuterClass {
  class InnerClass {
    public void foo() {
        System.out.println("in here");
    }
  }
  public InnerClass bar() {
    return new InnerClass();
  }
}
</code></pre>
<p>Here in the main class I reference the object of class InnerClass without that class ever being in scope, and I can successfully call its <code>foo()</code> method.</p>
</div>
<span class="comment-copy">Your question is not clear. Why <i>wouldn't</i> it work? And why should this have anything to do with dynamic typing?</span>
<span class="comment-copy">Yea, what does it have to do with dynamic typing? Also, @DanielRoseman, he means that in Java, the scope of the class and objects inside a function is only on thr inside...but Florian says that it doesn't seem to be the case here</span>
<span class="comment-copy">I still can't see what this has to do with scope. You return an object from the function, and that object can be passed wherever you like, even in Java.</span>
<span class="comment-copy">@AakashVerma I don't understand the point with <code>import</code>.</span>
<span class="comment-copy">I mentioned dynamic typing because Java would already tell me it doesn't even know what that object I'm declaring is. So if I received this returned object I would have to declare its type in Java, this is where it already fails. That's what I meant. That's also what I meant in terms of "scope", as no other class could actually use this object in Java as long as it is of a type the other classes don't understand or know.</span>
<span class="comment-copy">That's not what he has asked. He wants to know it worked what he did, that is, using an object of an inner class whose scope is limited. Why the behaviour?</span>
<span class="comment-copy">@AakashVerma, I have updated to explain that but I am still keeping the discouragement from making factories as it is unpythonic</span>
<span class="comment-copy">I was half expecting to hear this and I'm actually glad you told me. I will see if I can change my code to be as readable as it is now while getting rid of the factory function. As for the rest, I think this answers my question. Thanks!</span>
<span class="comment-copy">There are no private classes in Java too. If you have to make a class private, it must be inside another class. Function being an object in python makes it so different from Java.</span>
<span class="comment-copy">If I'm getting the difference right, you wouldn't be able to directly call foo() though without your indirection through that method. That is because you can't declare an object of type InnerClass if your NestedScope class just doesn't know it. For that, you would have to import the InnerClass as well. However, in python I didn't (and I suppose I can't?) even import that class within my function.  So yes, I do see a difference.</span>
<span class="comment-copy">Your code is <a href="https://ideone.com/eOE5iW" rel="nofollow noreferrer">here</a>and it works but it's totally different from what we were talking about. Creating objects of a class, which is inside a function of the outer class, outside the function is just not the case depicted by your code. It cannot happen, man. Your code is about creating and returning an object of the inner class through a function when the class is not inside some function in the same upper class. and not creating on the outside, the object of a class present inside a function.</span>
<span class="comment-copy">If you have to create the object of a class inside the function, you need to create it inside the same function and you cannot pass it around. Maybe use that inner class to create a getter to a field of the outer class and then create an object and call the getter. All this happens inside the function in which inner class is present.</span>
