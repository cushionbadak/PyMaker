<div class="post-text" itemprop="text">
<p>Python 3's default hashing function(s) isn't deterministic (hash(None) varies from run to run), and doesn't even make a best effort to generate unique id's with high probability (hash(-1)==hash(-2) is True).</p>
<p>Is there some other hash function that works well as a checksum (i.e. negligible probability of two data structures hashing to the same value, and returns the same result each run of python), and supports all of python's built-in datatypes, including None?</p>
<p>Ideally it would be in the standard library. I can pickle the object or get a string representation, but that seems unnecessarily hacky, and string representations of floats are probably very bad checksums.</p>
<p>I found the cryptographic hashes (md5,sha256) in the standard library, but they only operate on bytestrings. </p>
<p>Haskell seems to get this ~almost right in their standard library... but "Nothing::Maybe Int" and 0 both hash to 0, so it's not perfect there either.</p>
</div>
<div class="post-text" itemprop="text">
<p><del>You can use any hash from <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer">hashlib</a> on a <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">pickled</a> object.</del>
<a href="http://www.aminus.org/blogs/index.php/2007/11/03/pickle_dumps_not_suitable_for_hashing?blog=2" rel="nofollow noreferrer">pickle.dumps not suitable for hashing</a>.</p>
<p>You can use sorted-keys <code>json</code> with <code>hashlib</code>.</p>
<pre><code>hashlib.md5(json.dumps(data, sort_keys=True)).hexdigest()
</code></pre>
<p>Taken from: <a href="https://stackoverflow.com/a/10288255/3858507">https://stackoverflow.com/a/10288255/3858507</a>, according to AndrewWagner's comment.</p>
<p>By the way and <em>only for reference</em> as this causes <strong>security vulnerabitilies</strong>, the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="nofollow noreferrer">PYTHONHASHSEED</a> environment variable can be used to disable randomization of hashes throughout your application.</p>
</div>
<span class="comment-copy">In Python 2, hashing is deterministic. It was made to introduce some random factor after a security exploit using many known hash collisions, for example to a server, as a denial of service attack. See <a href="http://www.ocert.org/advisories/ocert-2011-003.html" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">Hmm. <code>hash(-1)</code> being <code>-2</code> is really strange. From -100,000,000 to 100,000,000, that's the only int whose hash value differs from itself. Weird. I wonder how/why they did that.</span>
<span class="comment-copy">@StefanPochmann In the CPython source, returning <code>-1</code> is reserved for errors, so <code>-1</code> is converted to <code>-2</code> for returning the hash.</span>
<span class="comment-copy">@Artyer Yeah, I just found <a href="https://stackoverflow.com/questions/10130454/why-do-1-and-2-both-hash-to-2-in-cpython" title="why do 1 and 2 both hash to 2 in cpython">stackoverflow.com/questions/10130454/…</a></span>
<span class="comment-copy">@Stefan, thanks for finding the reason. It sounds pretty silly to break hash, but I'm not familiar with the cPython code. Seems like at the C level, hash should be using a function argument, not the return value, to return the result. At least they didn't apply this logic to the math functions!</span>
<span class="comment-copy">Thanks! I'll try it out. Is pickle a pure function of your data structure? Or is it sticking python version strings, timestamps, etc... in the serialized data?</span>
<span class="comment-copy">I get different results for <code>hashlib.md5(pickle.dumps({0, 8})).hexdigest()</code> and <code>hashlib.md5(pickle.dumps({8, 0})).hexdigest()</code>.</span>
<span class="comment-copy">Yes I tested it now too. The problem is that the pickle output itself changes because of the hash randomization. You could use <code>json.dumps</code> if it suits your needs; it supports dicts but not sets.</span>
<span class="comment-copy">@nitzpo Are you sure the hash randomization is the reason? Shouldn't that only apply to different runs of the Python script? I get a difference even if I do them in a single expression: <code>pickle.dumps({0, 8}) == pickle.dumps({8, 0})</code> gives me <code>False</code>.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/5417949/computing-an-md5-hash-of-a-data-structure" title="computing an md5 hash of a data structure">stackoverflow.com/questions/5417949/…</a></span>
