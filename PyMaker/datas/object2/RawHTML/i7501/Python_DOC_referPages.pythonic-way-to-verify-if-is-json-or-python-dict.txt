<div class="post-text" itemprop="text">
<p>I need to verify if 'info' is a json file or a python dict. Given the fact that the json file and the python dict has the same structure I wrote this code to parse both and save their content in a variable but I think there is a pythonic and more efficient code. </p>
<pre><code>import json

class LoadInfo(object):
def __init__(self, info=None):
    if info:
        try:
            self.config= json.loads(info)
        except ValueError:
            print('Load Python Dict')
            try:
                if isinstance(info, dict):
                    self.config= info
            except ValueError:
                print('Json or python dict config is needed')
    else:
        raise Exception('Json or python dict config is needed')

info  = LoadInfo('path/to/json_file') #should work
info_dict = dict('A'=1, 'B'=2, 'C'=3)
info2 = LoadInfo(info_dict) #Also should work
</code></pre>
<p>Anyone has more ideias?</p>
</div>
<div class="post-text" itemprop="text">
<p>First things first, don't just <code>raise Exception</code>; that's far too general, be as specific as you can about what has gone wrong. In this case, it's that the user hasn't provided the <code>info</code> parameter. Two problems with that:</p>
<ol>
<li><p>You should test for <code>None</code> by identity, not truthiness (otherwise e.g. <code>{}</code> would be an exception, which may not be what you actually want): <code>if info is not None:</code>.</p></li>
<li><p>If it's a required parameter, <em>why give it a default value?!</em></p></li>
</ol>
<p>Revision 1:</p>
<pre><code>import json

class LoadInfo(object):

    def __init__(self, info):
        try:
            self.config = json.loads(info)
        except ValueError:
            print('Load Python Dict')
            try:
                if isinstance(info, dict):
                    self.config = info
            except ValueError:
                print('python dict config is needed')
</code></pre>
<p><em>(Note minor <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">style guide</a> tweaks.)</em></p>
<hr/>
<p>Next, there's really no need to provide this kind of polymorphism by allowing either a dictionary or a JSON string as the argument. As in the second case you're just parsing it to the first case, make that a class method, which is the common alternate constructor pattern in Python.</p>
<p>Revision 2:</p>
<pre><code>import json

class LoadInfo(object):

    def __init__(self, info):
        try:
            if isinstance(info, dict):
                self.config = info
        except ValueError:
            print('python dict config is needed')

    @classmethod
    def from_json(cls, info):
        return cls(json.loads(info))
</code></pre>
<hr/>
<p>Which part of:</p>
<pre><code>if isinstance(info, dict):
    self.config = info
</code></pre>
<p>do you expect to raise a <code>ValueError</code>? And why, in the case where it's not an acceptable type of input, would you want to just <code>print</code> something and let the program continue? Note that where you're checking types, it's better to use the <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">ABCs</a>.</p>
<p>Revision 3:</p>
<pre><code>from collections.abc import Mapping
import json

class LoadInfo(object):

    def __init__(self, info):
        if not isinstance(info, Mapping):
            raise TypeError('mapping config is needed')
        self.config = info

    @classmethod
    def from_json(cls, info):
        return cls(json.loads(info))
</code></pre>
<hr/>
<p>But actually, you're suggesting that it be loaded from a file, not the JSON string as your current code implies (you provide <code>'path/to/json_file'</code> not <code>'{"foo": "bar"}'</code> - it's not clear what you expected <code>json.loads</code> to make of that). So you need to handle that file.</p>
<p>Revision 4:</p>
<pre><code>from collections.abc import Mapping
import json

class LoadInfo(object):

    def __init__(self, info):
        if not isinstance(info, Mapping):
            raise TypeError('mapping config is needed')
        self.config = info

    @classmethod
    def from_json_file(cls, filename):
        with open(filename) as json_file:
            return cls(json.load(json_file))  # note 'load' not 'loads'
</code></pre>
<hr/>
<p>Now your examples become:</p>
<pre><code>info = LoadInfo.from_json_file('path/to/json_file')
info_dict = dict(A=1, B=2, C=3)  # note you shouldn't use quotes for keys here
info2 = LoadInfo(info_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to open a file object at first if you pass a file and it will be better to separate file and string arguments:</p>
<pre><code>import os
import json

class LoadInfo(object):
    def __init__(self, info=None, file=None):
        if file and os.path.exists(file):
            with open(file) as f:
                data = f.read()
            try:
                self.config = json.loads(data)
            except ValueError:
                raise ValueError('Load JSON file error')
        elif info:
            if isinstance(info, dict):
                self.config = info
            elif isinstance(info, str):
                try:
                    self.config = json.loads(info)
                except ValueError:
                    raise ValueError('Load JSON string error')
        else:
            raise ValueError('Load config error')
</code></pre>
<p>I would split it into two methods:</p>
<pre><code>class LoadInfo(object):
    def load_from_file(self, file):
        with open(file) as f:
            data = f.read()
        self.config = json.loads(data)

    def load_from_str(self, info):
        if isinstance(info, dict):
           self.config = info
        elif isinstance(info, str):
            self.config = json.loads(info)
        else:
            raise ValueError('Load config error')
</code></pre>
<p>But actually, it's more pythonic to use ducktyping style. </p>
</div>
<span class="comment-copy">IMO you should restructure your code. Why can't you simply load the data outside <code>LoadInfo</code> class and pass the result to it? Why <code>LoadInfo</code> should accept two different types under one param?</span>
<span class="comment-copy">Why would you write code that either takes a dictionary or a JSON string? I would write a classmethod <code>def from_json(cls, info): return cls(json.loads(info))</code>. That way you only deal with the dictionary case in <code>__init__</code>. Also you should never just <code>raise Exception:</code>; if the <code>info</code> parameter is required, <i>don't give it a default value</i>.</span>
