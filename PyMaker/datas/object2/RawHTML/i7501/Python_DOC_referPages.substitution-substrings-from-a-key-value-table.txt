<div class="post-text" itemprop="text">
<p>Given a multi-char to single char string translation table:</p>
<pre><code>&gt;&gt;&gt; telex_mappings
{'eer': 'ể', 'awj': 'ặ', 'Dd': 'Đ', 'Ooj': 'Ộ', 'oox': 'ỗ', 'Aas': 'Ấ', 'Eej': 'Ệ', 'awx': 'ẵ', 'eef': 'ề', 'oo': 'ô', 'aas': 'ấ', 'Aax': 'Ẫ', 'owr': 'ở', 'Uws': 'Ớ', 'Awj': 'Ặ', 'Oor': 'Ổ', 'Awf': 'Ằ', 'ows': 'ớ', 'aaj': 'ậ', 'Owj': 'Ợ', 'aa': 'â', 'eex': 'ễ', 'Oox': 'Ỗ', 'Owr': 'Ở', 'awf': 'ằ', 'Aa': 'Â', 'aw': 'ă', 'awr': 'ẳ', 'uwj': 'ợ', 'uwx': 'ỡ', 'owj': 'ợ', 'Awx': 'Ẵ', 'Uwr': 'Ở', 'Aaj': 'Ậ', 'Eex': 'Ễ', 'Awr': 'Ẳ', 'Uw': 'Ư', 'Eef': 'Ề', 'aaf': 'ầ', 'Aws': 'Ắ', 'ees': 'ế', 'Ee': 'Ê', 'Ow': 'Ơ', 'Ees': 'Ế', 'Owx': 'Ỡ', 'Eer': 'Ể', 'Aar': 'Ẩ', 'Oo': 'Ô', 'uwf': 'ờ', 'uw': 'ư', 'uws': 'ớ', 'owx': 'ỡ', 'ow': 'ơ', 'aar': 'ẩ', 'eej': 'ệ', 'oof': 'ờ', 'ee': 'ê', 'uwr': 'ở', 'Aw': 'Ă', 'ooj': 'ộ', 'Aaf': 'Ầ', 'aax': 'ẫ', 'Oof': 'Ờ', 'oor': 'ổ', 'aws': 'ắ', 'Oos': 'Ớ', 'Uwf': 'Ờ', 'Uwx': 'Ỡ', 'dd': 'đ', 'oos': 'ố', 'Uwj': 'Ợ'}

&gt;&gt;&gt; telex_mappings['eef']
'ề'
&gt;&gt;&gt; telex_mappings['aaf']
'ầ'
&gt;&gt;&gt; telex_mappings['uw']
'ư'
</code></pre>
<p>And the input string:</p>
<pre><code>&gt;&gt;&gt; s = 'Nguyeefn Traafn Anh Thuw'
</code></pre>
<p>The desired function would be something like:</p>
<pre><code>&gt;&gt;&gt; func('Nguyeefn Traafn Anh Thuw')
'Nguyên Trân Anh Thư'
</code></pre>
<p>I've tried:</p>
<pre><code>&gt;&gt;&gt; s = 'Nguyeefn Traafn Anh Thuw'
&gt;&gt;&gt; for k,v in telex_mappings.items():
...     s = s.replace(k, v)
... 
&gt;&gt;&gt; s
'Nguyền Trâfn Anh Thư'
</code></pre>
<p>But we see that there is a key for 'aa' which causes the replacement to take place first before 'aaf'. Ideally, the longer keys should be replaced first. </p>
<p><strong>How should the replacement be such that it's possible to substitute substrings from a key-value table starting from the longest key onwards?</strong></p>
<p><strong>Is there some sort of regex methods instead of iterating through all key-value pairs in the mapping?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a possible regex solution:</p>
<pre><code>import re

pattern= '|'.join(re.escape(word) for word in sorted(telex_mappings, key=len, reverse=True))
result= re.sub(pattern, lambda match:telex_mappings[match.group()], s)
</code></pre>
<p>This sorts the dictionary keys by length, then creates a regex pattern of the form <code>key1|key2|key3|...</code>, and finally substitutes all occurrences of this pattern with the corresponding dict value.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sort <code>telex_mappings</code> keys by length descending:</p>
<pre><code>for k in sorted(telex_mappings, key=len, reverse=True):
    s = s.replace(k, telex_mappings[k])
</code></pre>
</div>
<span class="comment-copy">Would <code>lambda match: telex_mappings[match.group(0)]</code> be the same?</span>
<span class="comment-copy">@alvas <a href="https://docs.python.org/3/library/re.html#re.match.group" rel="nofollow noreferrer">Yes, it defaults to <code>group(0)</code>.</a></span>
<span class="comment-copy">Thans @Rawing! Then I guess <code>telex_mapping.get(m.group(0), m.group(0))</code> would be good to avoid the KeyError =)</span>
<span class="comment-copy">I don't see how this could ever produce a KeyError. The regex pattern is created from the dict keys after all.</span>
<span class="comment-copy">Ah, yes yes, it's different from retrieving a separate hand-written regex! Thanks again!!</span>
<span class="comment-copy">You can drop <code>.keys()</code></span>
<span class="comment-copy">@MosesKoledoye Right, thanks.</span>
