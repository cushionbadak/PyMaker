<div class="post-text" itemprop="text">
<p>I have some sets I would like to take the Cartesian product of, which is working well. However, I want to remove all elements of this new set which are identical under a permutation of the elements.</p>
<p>For example, take the following code:</p>
<pre><code>import itertools as ittools
x = 2
y = 3
z = 5

flist = list(ittools.product([x,y,z],repeat=3))

for f in flist:
    print reduce(lambda a,b: a*b, f)
</code></pre>
<p>This code find the Cartesian product of the set {2,3,5} and returns the product of all three components of each element in the resulting set. However, some numbers appear multiple times, i.e. 12 can be written as 2*2*3, 2*3*2, or 3*2*2. I would like to remove all but one instance of these duplicates. </p>
<p>I know that this fundamentally a combinatorics problem, but this seems like there is probably a nice solution in Python that doesn't involve doing an extra pass over the list like I did here to compute some identifier for each element of the Cartesian product.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer"><code>combinations_with_replacement</code></a>, not <code>product</code>:</p>
<pre><code>itertools.combinations_with_replacement([x, y, z], 3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <code>dict</code> to map each unique product to the most recently seen tuple.</p>
<pre><code>d = {reduce(operator.mul, f): f for f in flist}
</code></pre>
<p>If you would need to treat tuples that aren't permutations of each other as distinct elements, you'll need a more complicated key that incorporates a canonical representation of the tuple.</p>
<pre><code>from operator import mul
d = {(tuple(sorted(f)), reduce(mul, f)): f for f in flist}
</code></pre>
<p>Actually, once you do that, you don't need to map the tuple/product pair to a tuple; you can just maintain a set of pairs:</p>
<pre><code>d = {(tuple(sorted(f)), reduce(mul, f)) for f in flist}
</code></pre>
<p>In any case, retrieving just the tuples is as simple as</p>
<pre><code>tuples = d.values()  # In the first two cases
tuples = {x for x,y in d} # In the third case
</code></pre>
</div>
<span class="comment-copy">I will give this a shot when I get home. From the function name this sounds like you might be right, it's what I want.</span>
<span class="comment-copy">This is precisely the type of solution I was looking for.</span>
<span class="comment-copy">But this still uses all of the tuples.</span>
<span class="comment-copy">Oops, I meant to use the product as the key, so that later tuples with the same product would replace the previously seen tuples.</span>
<span class="comment-copy">I had imagined that was what you meant, but this would give wrong results when non-matching combinations give the same product e.g. <code>product([1,2,3,4], repeat=3)</code> , <code>(1,3,4)</code> and <code>(2,2,3)</code>.</span>
<span class="comment-copy">Good point. It's not clear if the user wants to treat, say, <code>(1,4,6)</code> and <code>(2,3,4)</code> from <code>product(range(1,7), repeat=4)</code> as equivalent or not. (I clearly interpreted them as being equivalent.). One could use <code>(frozenset(f), reduce(mul, f))</code> as the key instead.</span>
<span class="comment-copy">Ok. However, the <code>frozenset</code> will take out dupes. Sorry for being pedantic.</span>
