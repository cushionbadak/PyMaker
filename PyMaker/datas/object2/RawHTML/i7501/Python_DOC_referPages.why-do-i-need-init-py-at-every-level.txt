<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/448271/what-is-init-py-for">What is __init__.py for?</a>
<span class="question-originals-answer-count">
                    10 answers
                </span>
</li>
</ul>
</div>
<p>Given that I have the following directory structure with <code>.</code> being the current working directory</p>
<pre><code>.
\---foo
    \---bar
        \---__init__.py
        \---baz.py
</code></pre>
<p>When I run <code>python -c "import foo.bar.baz"</code> I get</p>
<pre><code>Traceback (most recent call last):
  File "&lt;string&gt;", line 1
ImportError: No module named foo.bar.baz
</code></pre>
<p>If I <code>echo "" &gt; foo/__init__.py</code>, the above command works.</p>
<p>Am I doing something wrong or do I  misunderstand the point of <code>__init__.py</code>?  I thought it was to stop modules existing where they shouldn't, e.g. a directory named <code>string</code>, but if you replace <code>foo</code> with <code>string</code> in my example, I'm seemingly forced to create the module that should never be used, just so I can reference a file deeper in the hierarchy.</p>
<p><strong>Update</strong></p>
<p>I'm working with a build system that's generating the <code>__init__.py</code>'s for me and is enforcing the directory structure and while I could mess with the hierarchy, I'd prefer to just add the <code>__init__.py</code> myself. To change the question slightly, why do I need a python package at every level instead of just at the top? Is it just a rule that you can only import modules from the python path or from a chain of packages off of the python path?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, this file is required if you want directory to be treated as module.</p>
<blockquote>
<p>The <code>__init__.py</code> files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, <code>__init__.py</code> can just be an empty file, but it can also execute initialization code for the package or set the <code>__all__</code> variable, described later.</p>
</blockquote>
<p><a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/modules.html#packages</a></p>
<p>I try to create non-empty <code>__init__.py</code>. You have great possibility to document module, to get rid of the nested imports for users/developers by providing the most useful objects(classes/functions) at the first level... ...actually to be as simple in use as possible in contrast to - let's say - the java imports</p>
<p><strong>Edit after question update</strong></p>
<p>The default importers/finders (examine the <code>sys.meta_path</code>) are:</p>
<ol>
<li><a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.BuiltinImporter" rel="nofollow noreferrer">BuiltinImporter</a> - searches for/loads built-in modules</li>
<li><a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.FrozenImporter" rel="nofollow noreferrer">FrozenImporter</a> - searches for/loads frozen modules (e.g. *.pyc)</li>
<li><a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder" rel="nofollow noreferrer">PathFinder</a> - the one you are interested in, allow to search for/load modules based on file system</li>
</ol>
<p>The third is the <code>__init__.py</code> thing (actually FrozenImporter as well). </p>
<p>The<code>PathFinder</code> searches for module in paths from <code>sys.path</code> (and in <code>__path__</code> defined in packages). The module could be either standalone python file (if it is in the root of searched path) or directory with <code>__init__.py</code>.</p>
<p>Referring to your example:</p>
<pre><code>foo/
  bar/
    __init__.py
    baz.py
</code></pre>
<ul>
<li><p>If you create <code>_init__.py</code> in <code>foo/</code>, <code>foo.bar.baz</code> will be available (as you said).</p></li>
<li><p>If you add <code>foo/</code> to <code>sys.path</code> or pass it through <code>PYTHONPATH=foo/</code>, <code>bar.baz</code> will be available (note without parent module foo).</p></li>
<li><p>If you write your own <a href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder" rel="nofollow noreferrer">finder</a> (and Loader) you can load for example any file you want despite where it is. That gives you great power. For example take a look on <a href="https://github.com/drathier/stack-overflow-import" rel="nofollow noreferrer"><code>stack-overflow-import</code></a>, exposes code based on SO's search results.</p></li>
</ul>
</div>
<span class="comment-copy">Indeed you do... You can do <code>import bar.baz</code>, that's valid. But <code>foo</code> isn't recognised as a package until it has <code>__init__.py</code>.</span>
<span class="comment-copy">Yup, <code>__init__.py</code> says "you can import me"</span>
<span class="comment-copy">The question is different because I'm not asking how a <code>__init__.py</code> creates a module. It's more asking about what makes a module importable. Can you only import a module via a chain of packages off of a directory on the python path or can you import a module via a chain of packages <i>and directories</i>?</span>
<span class="comment-copy">And what is the need to have a <b>init</b>.py at every level of the folder hierarchy! that is so unpythonic!</span>
