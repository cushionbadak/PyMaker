<div class="post-text" itemprop="text">
<p>For example, is there a way to sort the following:</p>
<pre><code>model_1_depth/depth_w/read/_79__cf__79
model_2_depth/depth_w/read/_73__cf__73
model_3_depth/depth_w/read/_67__cf__67
model_4_depth/depth_w/read/_61__cf__61
model_5_depth/depth_w/read/_55__cf__55
model_6_depth/depth_w/read/_49__cf__49
model_7_depth/depth_w/read/_43__cf__43
model_8_depth/depth_w/read/_37__cf__37
model_9_depth/depth_w/read/_31__cf__31
model_10_depth/depth_w/read/_25__cf__25
model_11_depth/depth_w/read/_19__cf__19
model_12_depth/depth_w/read/_13__cf__13
model_13_depth/depth_w/read/_7__cf__7
model_13_point/weights/read/_4__cf__4
model_12_point/weights/read/_10__cf__10
model_11_point/weights/read/_16__cf__16
model_10_point/weights/read/_22__cf__22
model_9_point/weights/read/_28__cf__28
model_8_point/weights/read/_34__cf__34
model_7_point/weights/read/_40__cf__40
model_6_point/weights/read/_46__cf__46
model_5_point/weights/read/_52__cf__52
model_4_point/weights/read/_58__cf__58
model_3_point/weights/read/_64__cf__64
model_2_point/weights/read/_70__cf__70
model_1_point/weights/read/_76__cf__76
model_0/weights/read/_82__cf__82
</code></pre>
<p>using only the integer that comes after "model"? I have tried to capture only these integers using <code>re.sub("_", "", re.sub(r'[^\w]', '', key[6:8]))</code> to get the integers to sort, but I'm unable to use the sorted result to locate back the original strings since there will be some duplicates, like '1' belongs to both <code>model_1_point/weights/read/_76__cf__76</code> and <code>model_1_depth/depth_w/read/_79__cf__79</code> and it won't be possible to distinguish the two.</p>
<p>Is there an elegant way to do this?</p>
<p>EDIT: To clarify, the following strings are in a dictionary, and I'm wanting to sort such that 1 is the smallest and 13 is the largest.</p>
</div>
<div class="post-text" itemprop="text">
<p>a version using regex:</p>
<pre><code>rgx = re.compile('model_(?P&lt;number&gt;\d+)')
srtd = sorted(mods, key=lambda x: int(rgx.match(x).group('number')))
</code></pre>
<p>the regular expression <code>model_(?P&lt;number&gt;\d+)</code> captures the numbers <code>\d+</code> (greedy) after the string <code>model_</code>. in the <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>key</code> of <code>sorted</code></a> this is then converted to an <code>int</code>.</p>
<p>i assumed your input is in a list called <code>mods</code> of the form:</p>
<pre><code>mods = [
    'model_1_depth/depth_w/read/_79__cf__79',
    'model_2_depth/depth_w/read/_73__cf__73',
    'model_3_depth/depth_w/read/_67__cf__67',
    'model_4_depth/depth_w/read/_61__cf__61',
    ...
    ]
</code></pre>
<p>if it is just the string you presented you'd have somehow bring it into this form.</p>
<hr/>
<p>a little less verbose (no named group) the very same could be achieved like this:</p>
<pre><code>rgx = re.compile('model_(\d+)')
srtd = sorted(mods, key=lambda x: int(rgx.match(x).group(1)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given this input:</p>
<pre><code>my_text = '''model_1_depth/depth_w/read/_79__cf__79
model_2_depth/depth_w/read/_73__cf__73
model_3_depth/depth_w/read/_67__cf__67
model_4_depth/depth_w/read/_61__cf__61
model_5_depth/depth_w/read/_55__cf__55
model_6_depth/depth_w/read/_49__cf__49
model_7_depth/depth_w/read/_43__cf__43
model_8_depth/depth_w/read/_37__cf__37
model_9_depth/depth_w/read/_31__cf__31
model_10_depth/depth_w/read/_25__cf__25
model_11_depth/depth_w/read/_19__cf__19
model_12_depth/depth_w/read/_13__cf__13
model_13_depth/depth_w/read/_7__cf__7
model_13_point/weights/read/_4__cf__4
model_12_point/weights/read/_10__cf__10
model_11_point/weights/read/_16__cf__16
model_10_point/weights/read/_22__cf__22
model_9_point/weights/read/_28__cf__28
model_8_point/weights/read/_34__cf__34
model_7_point/weights/read/_40__cf__40
model_6_point/weights/read/_46__cf__46
model_5_point/weights/read/_52__cf__52
model_4_point/weights/read/_58__cf__58
model_3_point/weights/read/_64__cf__64
model_2_point/weights/read/_70__cf__70
model_1_point/weights/read/_76__cf__76
model_0/weights/read/_82__cf__82'''
</code></pre>
<p>You can do the following:</p>
<pre><code>my_text = my_text.split('\n')

b = sorted(my_text, key=lambda x: int(x.split('/')[0].split('_')[1]))
my_text_out = '\n'.join(b)
print(my_text_out)
</code></pre>
<p>Which results in this:</p>
<pre><code>model_0/weights/read/_82__cf__82
model_1_depth/depth_w/read/_79__cf__79
model_1_point/weights/read/_76__cf__76
model_2_depth/depth_w/read/_73__cf__73
model_2_point/weights/read/_70__cf__70
model_3_depth/depth_w/read/_67__cf__67
model_3_point/weights/read/_64__cf__64
model_4_depth/depth_w/read/_61__cf__61
model_4_point/weights/read/_58__cf__58
model_5_depth/depth_w/read/_55__cf__55
model_5_point/weights/read/_52__cf__52
model_6_depth/depth_w/read/_49__cf__49
model_6_point/weights/read/_46__cf__46
model_7_depth/depth_w/read/_43__cf__43
model_7_point/weights/read/_40__cf__40
model_8_depth/depth_w/read/_37__cf__37
model_8_point/weights/read/_34__cf__34
model_9_depth/depth_w/read/_31__cf__31
model_9_point/weights/read/_28__cf__28
model_10_depth/depth_w/read/_25__cf__25
model_10_point/weights/read/_22__cf__22
model_11_depth/depth_w/read/_19__cf__19
model_11_point/weights/read/_16__cf__16
model_12_depth/depth_w/read/_13__cf__13
model_12_point/weights/read/_10__cf__10
model_13_depth/depth_w/read/_7__cf__7
model_13_point/weights/read/_4__cf__4
</code></pre>
<p>But as I said in the comments, a regex solution feels more appropriate here.</p>
</div>
<span class="comment-copy">are these strings in a <code>list</code> or something?</span>
<span class="comment-copy">If the problem you're having is that that is not a list, you can make it one by doing <code>your_string.split()</code></span>
<span class="comment-copy"><code>b = sorted(a, key=lambda x: int(x.split('/')[0].split('_')[1]))</code> but I would prefer a <code>re</code>gex solution.</span>
<span class="comment-copy">Thanks for your answer, it works too! The regex solution I believe is this: <code>sorted(dictionary, key=lambda key: int(re.sub("_", "", re.sub(r'[^\w]', '', key[6:8]))))</code>, which I modified slightly from someone else who posted earlier on by adding an int in front of it (don't know where his answer went). Thank you all for the quick response.</span>
