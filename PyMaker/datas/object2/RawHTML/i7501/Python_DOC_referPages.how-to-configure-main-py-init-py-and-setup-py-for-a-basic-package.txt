<div class="post-text" itemprop="text">
<h2>Background:</h2>
<p>I have a directory structure like so: </p>
<pre><code>Package/
    setup.py
    src/
        __init__.py
        __main__.py 
        code.py
</code></pre>
<p>I want to be able to run the code in a lot of different ways. </p>
<ol>
<li><p><code>pip install Package</code> and then <code>python</code> and then <code>from Package import *</code></p></li>
<li><p><code>python -m Package</code> which should do the thing in <code>__main__.py</code></p></li>
<li><p><code>python __main__.py</code> which should also do the thing in <code>__main__.py</code> but this time, we assume you've downloaded source rather than <code>pip installing</code>. </p></li>
</ol>
<p>Now I've gotten the first two to work, but with a messy setup: </p>
<p><strong>setup.py:</strong> </p>
<pre><code>setup(
    name='Package',
    packages=['Package'],
    package_dir={'Package': 'src'},
    ...
    entry_points={ 'console_scripts': ['Package = src.__main__:main' ] }
</code></pre>
<p><strong>__init__.py:</strong></p>
<pre><code>from Package.code import .......
</code></pre>
<p><strong>__main__.py:</strong></p>
<pre><code>from . import .......
</code></pre>
<p>What would make more sense to me would be in both cases to write</p>
<pre><code>from code import ........
</code></pre>
<p>but that gives me import errors. </p>
<h1>Question:</h1>
<p>Is the way I have it really the only way? </p>
<p>And most importantly, how do I support the third use case? Right now, <code>python __main__.py</code> throws</p>
<pre><code>File "__main__.py", line 10, in &lt;module&gt;
    from . import code
ImportError: cannot import name 'class defined in code.py'
</code></pre>
<h2>Notes:</h2>
<p>I have read </p>
<ul>
<li><a href="https://chriswarrick.com/blog/2014/09/15/python-apps-the-right-way-entry_points-and-scripts/" rel="noreferrer">https://chriswarrick.com/blog/2014/09/15/python-apps-the-right-way-entry_points-and-scripts/</a></li>
<li><a href="http://setuptools.readthedocs.io/en/latest/setuptools.html" rel="noreferrer">http://setuptools.readthedocs.io/en/latest/setuptools.html</a></li>
<li>The many questions here that look like this one but don't answer my question above.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You have almost everything you need (even a bit more)! I'd go with the following setup:</p>
<p><strong>code.py</strong>:</p>
<pre><code>foo = 1
</code></pre>
<p><strong>__init__.py:</strong></p>
<pre><code>from .code import foo
</code></pre>
<p>Doing a relative import here because <code>__init__.py</code> will be used when importing the whole package. Note that we explicitly mark the import as relative by using the <code>.</code>-syntax because this is required for Python 3 (and in Python 2 if you did <code>from __future__ import absolute_import</code>).</p>
<p><strong>__main__.py:</strong></p>
<pre><code>from Package import foo

print('foo = ', foo)
</code></pre>
<p>This is the package's main script and so we use an absolute <code>import</code> statement. By doing so we assume that the package has been installed (or at least has been put on the path); and that is the way packages should be dealt with! You might think that this conflicts with your third use case but actually there is no reason <em>not</em> to <code>pip install</code> when dealing with a package. And it really isn't a big deal (especially when using a <a href="https://virtualenv.pypa.io/en/stable/" rel="noreferrer"><code>virtualenv</code></a>)!</p>
<p>If your concern is to tinker with the source files and readily observe the changes by running the <code>__main__.py</code> file then you can simply install the package using the <code>-e</code> ("editable") switch: <code>pip install -e .</code> (assuming you are in directory <code>Package</code>). With your current directory structure, however, this won't work because the <code>-e</code> switch will place an <code>egg-link</code> to the directory containing the <code>setup.py</code> file; this directory does not contain a package named <code>Package</code> but <code>src</code> instead (I have <a href="https://stackoverflow.com/q/45139571/3767239">a question about that</a>).</p>
<p>Instead, if you follow the convention to name the root directory of a package's source after the package itself (that is <code>Package</code> for your example) then installing with <code>-e</code> is not a problem: Python <em>does find</em> the required package <code>Package</code> in the corresponding directory:</p>
<pre><code>$ tree Package/
Package/
├── setup.py
└── Package   &lt;-- Renamed "src" to "Package" because that's the package's name.
    ├── code.py
    ├── __init__.py
    └── __main__.py
</code></pre>
<p>This also lets you omit the extra definition of <code>package_dir={'Package': 'src'}</code> in <code>setup.py</code>.</p>
<p><strong>A note about <code>setup.py</code></strong>: For the three use cases which you've specified there is no need to define an entry point. That is you can skip the line <code>entry_points={ 'console_scripts': ['Package = src.__main__:main' ] }</code>. By shipping a <code>__main__.py</code> module <code>python -m Package</code> will readily execute the code in this module. You can also add an extra if-clause:</p>
<pre><code>def main():
    print('foo = ', foo)

if __name__ == '__main__':
    main()
</code></pre>
<p>The entry point on the other hand lets you directly execute the code in <code>__main__.main</code> from the CLI; that is running <code>$ Package</code> will execute the corresponding code.</p>
<h1>Recap</h1>
<p>The bottom line is that I'd always use <code>pip install</code> when dealing with packages. And why not, especially if you've already created a <code>setup.py</code> file? If changes to the package are to be applied "in real-time" then you can install with the <code>-e</code> switch (this might require a renaming of the <code>src</code> folder, see above). So your third use case would read as "Download the source and <code>pip install (-e) Package</code> (within a virtualenv); then you can run <code>python __main__.py</code>".</p>
<hr/>
<h1>Edit</h1>
<h2>Run <code>__main__.py</code> without <code>pip install</code></h2>
<p>If you don't want to install the package via pip but still be able to run the <code>__main__.py</code> script, I'd still go with the above setup. Then we need to make sure that the <code>from Package import ...</code> statement(s) are still succeeding and this can be achieved by extending the import path (note that the this requires the <code>src</code> directory to be renamed to the package's name!).</p>
<h3>Modify <code>PYTHONPATH</code></h3>
<p>For Linux bash you can set the Pythonpath as follows:</p>
<pre><code>export PYTHONPATH=$PYTHONPATH:/path/to/Package
</code></pre>
<p>Or if you're in the same directory as <code>__main__.py</code>:</p>
<pre><code>export PYTHONPATH=$PYTHONPATH:`cd ..; pwd`
</code></pre>
<p>Of course there are different ways for different operating systems.</p>
<h3>Extend the path in <code>__main__.py</code></h3>
<p>You (or rather your colleague) could add the following lines to the top of the script (before the <code>from Package import ...</code> statements):</p>
<pre><code>import sys
sys.path.append('/path/to/Package')
</code></pre>
<h3>Extend the path in <code>sitecustomize.py</code></h3>
<p>You can place a module named <a href="https://docs.python.org/3/library/site.html" rel="noreferrer"><code>sitecustomize.py</code></a> in the <code>lib/python3.5/site-packages/</code> directory of your Python installation which contains the following lines:</p>
<pre><code>import sys
sys.path.append('/path/to/Package')
</code></pre>
<h3>Create a separate, top-level <code>main.py</code> script</h3>
<p>So you'd have the following layout:</p>
<pre><code>$ tree Package/
Package/
├── main.py   &lt;-- Add this file.
├── setup.py
└── src
    ├── code.py
    ├── __init__.py
    └── __main__.py
</code></pre>
<p>where <code>main.py</code> contains</p>
<pre><code>import src.__main__
</code></pre>
<p>Now <code>__main__.py</code> is treated as a part of the <code>src</code> package and the relative import will work.
Instead of running <code>python src/__main__.py</code> you would run <code>python main.py</code> now.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>from code import .........</code> fails because there is no Python package installed on your system named <code>code</code>. There is a Python <em>module</em> on your system named <code>code</code>, but in your import statement you don't specify the package that your <code>code</code> module can be found in.</p>
<p>The purpose of the <code>__init__.py</code> file that you have in <code>src/</code> tells Python that the <code>src/</code> directory should be treated a Python package, with its contents as the modules within the package. Since <code>code.py</code> is located in <code>src/</code> along with your <code>__init__.py</code> file, your <code>code</code> module is located in your <code>src</code> package.</p>
<p>Now that you know which package your <code>code</code> module can be found in, you can import stuff from it with:</p>
<pre><code>from src.code import .........
</code></pre>
<p>Also, as a side note: The <code>__init__.py</code> does its job just by being present in your <code>src/</code> directory, so it doesn't even need to contain any code. For that reason it's generally a good idea to leave the <code>__init__.py</code> file blank.</p>
</div>
<div class="post-text" itemprop="text">
<p>I often use this setup because it works better with <code>python setup.py develop</code></p>
<pre><code>Package_root/
    setup.py
    src/
        Package/
            __init__.py
            __main__.py 
            code.py
</code></pre>
<p>It's probably not (yet) the detailed answer you're expecting but I think it's worth trying for the three use cases.</p>
<pre><code>setup( ...
    package_dir = {'': 'src'},
    entry_points = {'console_scripts': ['Package = Package.__main__:main'],},
    packages = find_packages(exclude=["Package.egg_info",]),
...)
</code></pre>
</div>
<span class="comment-copy"><code>from code import</code> is implicit relative import which is not recommended (and doesn't work in Python 3). Either use absolute import or explicit relative import.</span>
<span class="comment-copy">@phd could you elaborate a little bit as to what each of those are?</span>
<span class="comment-copy">Absolute import means to use full path: <code>from Package.somemodule.submodule import</code> even inside Package or somemodule. Relative import is to import from neighbours without using full path. <code>from code import</code> is implicit rel. import because it looks like absolute but really is relative. Relative import was the default mode in Python 2 but its implicit mode is now forbidden in Python 3 (default is now abs. import). Explicit relative import is <code>from .code import</code> — see the dot in <code>.code</code>? It means "import from the current module".</span>
<span class="comment-copy">Got it, so now we should always do <code>from Package.somemodule.submodule import</code> ?</span>
<span class="comment-copy">This is what PEP8 recommends (though officialy PEP8 is only for stdlib).</span>
<span class="comment-copy">I'm accepting this answer because it's the most complete and thorough. Thanks for your answer a_guest! I'm only bummed there's no easy way to clone the repo (instead of pip installing) and running main.py directly -- one of my colleagues was hoping to use the code that way... I might put a try-except block at the top of the file for importing, but that feels icky...</span>
<span class="comment-copy">@AlexLenail Now I understand a bit better what you need the third use case for. I made an edit to my answer which contains a few suggestions on how to run <code>__main__.py</code> without having done <code>pip install</code> beforehand. They are based on extending the import path with the directory in which the source folder is located (they require the <code>src</code> directory to be renamed to the package's name). No changes to the actual code are required though. On the other hand I'd expect the repo to contain the <code>setup.py</code> file and you can <code>pip install</code> from that file. So it really isn't that difficult.</span>
<span class="comment-copy">Thanks a_guest! I appreciate your taking the time to help a ton!</span>
<span class="comment-copy">Hi @MatTheWhale! Thanks for answering here. Unfortunately, I'm not sure you've answered my question about <code>__main__.py</code>, specifically, how to support the third use case, which probably requires something to replace <code>from . import ....</code>. Also, leaving <code>__init__.py</code> blank for this package doesn't work when other folks install the package.</span>
<span class="comment-copy">@MatTheWhale I cannot follow your argumentation; <code>code</code> is located in the <i>directory</i> <code>src</code> but the package's name is <code>Package</code>, so I don't see how <code>from src.code import ...</code> would help. Also "the purpose" of an <code>__init__.py</code> is much different in Python 2 than in Python 3, and I don't agree that "it's generally a good idea to leave the <code>__init__.py</code> file blank" - there are many cases where <code>__init__.py</code> is actively used; just imagine making contents available at the package level.</span>
