<div class="post-text" itemprop="text">
<p>I am trying to implement a Gaussian filter. For this I am using a kernel 3x3 and an array of an image.The problem I am having is defining a sub-matrix 3x3 for each [i, j] element of the array. I wrote the details inside the code.</p>
<pre><code>import numpy as np
import scipy
from scipy import misc
import matplotlib.pyplot as plt


imagen = scipy.misc.imread("C:\\Users\\Reymi\\Downloads\\imagen.png") #importing image of original size (1929, 1280)

imagen_real = scipy.pad(array=imagen, pad_width=[1, 1], mode='constant', constant_values=0) #add 1 column and 1 row of zeros to avoid the kernel of going outside the array. size is (1931, 1282)

imagen_nueva = np.empty((1931, 1282)) #the new image. the same size as the image I will filter

(dim_x,dim_y)=np.shape(imagen_real)


ker1 = np.array([[1/16, 1/8, 1/16],   #3x3 kernel
                [1/8, 1/4, 1/8],
                [1/16, 1/8, 1/16]])

def multiplicar_entero():

    global imagen_nueva
    for i in range(1,dim_x): #the range starts from 1 to avoid the column and row of zeros, and ends before the last col and row of zeros
        for j in range(1,dim_y):
            imagen_entry = np.empty((3, 3))      #Main problem here: how do I define a 3x3 matrix for each entry?
            valor = np.sum(imagen_entry*ker1)    #Matrix 3x3 is filled with the elements around each [i, j] entry of the array
            imagen_real[i, j] = valor
            imagen_nueva = np.append(imagen_real[i, j], (1931, 1282)) #This is supposed to each new [i, j] entry to the new image

print("La imagen con el blur effect es la siguiente:\n")

multiplicar_entero()   #calls function


plt.imshow(imagen_nueva)  #Show new image
plt.gray()
plt.show()
</code></pre>
<p>Sorry for the long code. And thanks for any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few issues with your code as is:</p>
<ul>
<li>You are using an image we don't have access to. Always use freely available images in examples so we can run the code. I used <code>scipy.misc.ascent</code> here.</li>
<li>Don't use global variables unless you really have to.</li>
<li>Always code in english with english variable names and english comments. It makes reviews like this much easier.</li>
</ul>
<p>I did some fixes to your code below, and I guess you can see how I solved your problem. Specifically you want to use <code>:</code> indexing which allows you extract subsets of an array and use <code>array[i, j]</code> to assign the result:</p>
<pre><code>import numpy as np
import scipy
from scipy import misc
import matplotlib.pyplot as plt

imagen = scipy.misc.ascent()  # Freely available image

(dim_x, dim_y) = np.shape(imagen)

ker1 = np.array([[1/16, 1/8, 1/16],   #3x3 kernel
                [1/8, 1/4, 1/8],
                [1/16, 1/8, 1/16]])

def multiplicar_entero(imagen):
    imagen_nueva = np.zeros(imagen.shape) #the new image. the same size as the image I will filter
    for i in range(1,dim_x-1): #the range starts from 1 to avoid the column and row of zeros, and ends before the last col and row of zeros
        for j in range(1,dim_y-1):
            imagen_entry = imagen[i-1:i+2, j-1:j+2]
            valor = np.sum(imagen_entry*ker1)    #Matrix 3x3 is filled with the elements around each [i, j] entry of the array
            imagen_nueva[i, j] = valor
    return imagen_nueva

imagen_nueva = multiplicar_entero(imagen)

plt.imshow(imagen_nueva)  #Show new image
plt.gray()
plt.show()
</code></pre>
</div>
<span class="comment-copy">Could you please post the question you're asking more clearly? As I got it, are you trying to implement a convolution operator yourself?</span>
<span class="comment-copy">Yes. A function for the convolution</span>
<span class="comment-copy">Are you aware that <a href="https://docs.scipy.org/doc/scipy-0.16.1/reference/generated/scipy.ndimage.filters.gaussian_filter.html" rel="nofollow noreferrer"><code>scipy.ndimage</code> has a Gaussian filter</a>? And does that <code>np.append</code> call even work? It doesn't seem to do at all like what you're expecting it to do.</span>
<span class="comment-copy">Here are two good tutorials for <a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html" rel="nofollow noreferrer">Multidimensional image processing</a> and <a href="https://docs.scipy.org/doc/scipy/reference/tutorial/signal.html" rel="nofollow noreferrer">Signal Processing</a>, both of which can potentially help you with Gaussian filter. Be careful though since their algorithms are slightly different from yours.</span>
<span class="comment-copy">Just want to point out that it's a great point for "Don't use global variables unless you really have to". This answer, however, implicitly uses <code>dim_x</code>,  <code>dim_y</code> and <code>ker1</code> as <a href="https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="nofollow noreferrer">global variables</a> which may not be necessarily "have to".</span>
