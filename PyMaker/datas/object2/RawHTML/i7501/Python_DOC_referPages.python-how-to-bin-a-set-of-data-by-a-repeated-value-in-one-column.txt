<div class="post-text" itemprop="text">
<p>Say, I have a numpy array like this:</p>
<pre><code>import numpy as np

x= np.array(
    [[100, 14, 12, 15],
    [100, 21, 16, 11],
    [100, 19, 10, 13],
    [160, 24, 15, 12],
    [160, 43, 12, 65],
    [160, 17, 53, 23],
    [300, 15, 17, 11],
    [300, 66, 23, 12],
    [300, 44, 70, 19]])
</code></pre>
<p>The original array is much bigger, so my question is if there's a way to bin or group rows based on the value on column 1?
for example:</p>
<pre><code>{'100': [[14, 12, 15], [21, 16, 11], [19, 10, 13]],
,'160': [[24, 15, 12], [43, 12, 65], [17, 53, 23]],
,'300': [[15, 17, 11], [66, 23, 12], [44, 70, 19]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you tagged this as <a class="post-tag" href="/questions/tagged/pandas" rel="tag" title="show questions tagged 'pandas'">pandas</a>, you might want to do it using <code>DataFrame</code>'s <a href="https://pandas.pydata.org/pandas-docs/stable/groupby.html" rel="nofollow noreferrer"><code>groupby()</code> functionality</a>. You'd create a <code>DataFrame</code> from your original array</p>
<pre><code>import pandas as pd
df = pd.DataFrame(x)
</code></pre>
<p>and group by the first column; then you can iterate over the resulting <code>GroupBy</code> object to get the groups of the frame which have all the same result in the first column.</p>
<pre><code>{key: group for key, group in df.groupby(0)}
</code></pre>
<p>Of course, in this snippet <code>group</code> includes the first column. You can strip it out using indexing:</p>
<pre><code>{key: group.iloc[:,1:] for key, group in df.groupby(0)}
</code></pre>
<p>and if you would like to convert the sub-frames back into Numpy arrays, use <code>group.iloc[:,1:].values</code> instead. (If you want them as lists of lists, as indicated in your question, it shouldn't be hard to write a function to make that conversion, but it'll probably be more efficient to keep it in Pandas or at least Numpy if you can.)</p>
<p>An alternative is to use the OG <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby()</code> from <code>itertools</code></a> which lets you avoid Pandas (if you have some reason for doing so) and use a plain old iterative approach.</p>
<pre><code>import itertools as it
{key: list(map(list, group))
    for key, group in it.groupby(x, lambda row: row[0])}
</code></pre>
<p>This, again, includes the key in the resulting rows, but you can trim it out using indexing</p>
<pre><code>{key: list(map(lambda a: list(a)[1:], group))
    for key, group in it.groupby(x, lambda row: row[0])}
</code></pre>
<p>You can make the code a tad cleaner by using the <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.groupby_transform" rel="nofollow noreferrer"><code>groupby_transform()</code> function from the more-itertools module</a> (which is not included in the standard Python library):</p>
<pre><code>import more_itertools as mt
{key: list(group) for key, group in mt.groupby_transform(
    x, lambda row: row[0], lambda row: list(row[1:])
)}
</code></pre>
<hr/>
<p><sup>Disclosure: I contributed the <code>groupby_transform()</code> function to more-itertools</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>We are talking about large dataset, so we might need the performance, as also we have the input data as a NumPy array. Listed in this post are two NumPy approaches.</p>
<p><strong>Approach #1</strong></p>
<p>Here's one approach using <code>np.unique</code> to get the row indices separating groups and then using a loop comprehension to get the dictionary output -</p>
<pre><code>unq, idx = np.unique(x[:,0], return_index=1)
idx1 = np.r_[idx,x.shape[0]]
dict_out = {unq[i]:x[idx1[i]:idx1[i+1],1:] for i in range(len(unq))}
</code></pre>
<p>This assumes the first column to be sorted as stated in the question title - <code>...repeated value in one column</code>. If that's not the case, we need to use <code>x[:,0].argsort()</code> to sort the rows of <code>x</code> and then proceed.</p>
<p>Sample input, output -</p>
<pre><code>In [41]: x
Out[41]: 
array([[100,  14,  12,  15],
       [100,  21,  16,  11],
       [100,  19,  10,  13],
       [160,  24,  15,  12],
       [160,  43,  12,  65],
       [160,  17,  53,  23],
       [300,  15,  17,  11],
       [300,  66,  23,  12],
       [300,  44,  70,  19]])

In [42]: dict_out
Out[42]: 
{100: array([[14, 12, 15],
        [21, 16, 11],
        [19, 10, 13]]), 160: array([[24, 15, 12],
        [43, 12, 65],
        [17, 53, 23]]), 300: array([[15, 17, 11],
        [66, 23, 12],
        [44, 70, 19]])}
</code></pre>
<p><strong>Approach #2</strong></p>
<p>Here's another getting rid of <code>np.unique</code> for further performance boost -</p>
<pre><code>idx1 = np.concatenate(([0],np.flatnonzero(x[1:,0] != x[:-1,0])+1, [x.shape[0]]))
dict_out = {x[i,0]:x[i:j,1:] for i,j in zip(idx1[:-1], idx1[1:])}
</code></pre>
<hr/>
<p><strong>Runtime test</strong></p>
<p>Approaches -</p>
<pre><code># @COLDSPEED's soln
from collections import defaultdict
def defaultdict_app(x):
    data = defaultdict(list)
    for l in x:
        data[l[0]].append(l[1:])

# @David Z's soln-1
import pandas as pd
def pandas_groupby_app(x):
    df = pd.DataFrame(x)
    return {key: group.iloc[:,1:] for key, group in df.groupby(0)}

# @David Z's soln-2
import itertools as it
def groupby_app(x):
    return {key: list(map(list, group)) for key, group in \
                        it.groupby(x, lambda row: row[0])}

# Proposed in this post    
def numpy_app1(x):
    unq, idx = np.unique(x[:,0], return_index=1)
    idx1 = np.r_[idx,x.shape[0]]
    return {unq[i]:x[idx1[i]:idx1[i+1],1:] for i in range(len(unq))}

# Proposed in this post    
def numpy_app2(x):
    idx1 = np.concatenate(([0],np.flatnonzero(x[1:,0] != x[:-1,0])+1, [x.shape[0]]))
    return {x[i,0]:x[i:j,1:] for i,j in zip(idx1[:-1], idx1[1:])}
</code></pre>
<p>Timings -</p>
<pre><code>In [84]: x = np.random.randint(0,100,(10000,4))

In [85]: x[:,0].sort()

In [86]: %timeit defaultdict_app(x)
    ...: %timeit pandas_groupby_app(x)
    ...: %timeit groupby_app(x)
    ...: %timeit numpy_app1(x)
    ...: %timeit numpy_app2(x)
    ...: 
100 loops, best of 3: 4.43 ms per loop
100 loops, best of 3: 15 ms per loop
100 loops, best of 3: 12.1 ms per loop
1000 loops, best of 3: 310 µs per loop
10000 loops, best of 3: 75.6 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can group your data with the <code>collections.defaultdict</code> and a loop.</p>
<pre><code>from collections import defaultdict

data = defaultdict(list)
for l in x:
    data[l[0]].append(l[1:])

print(dict(data))
</code></pre>
<p>Output:</p>
<pre><code>{100: [[14, 12, 15], [21, 16, 11], [19, 10, 13]],
 160: [[24, 15, 12], [43, 12, 65], [17, 53, 23]],
 300: [[15, 17, 11], [66, 23, 12], [44, 70, 19]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you want like this</p>
<p><strong>After Edit</strong></p>
<pre><code>ls_dict={}
for ls in x:
    key=ls[0]
    value=[ls[1:]]
    if key in ls_dict:
        value = ls[1:]
        ls_dict[key].append(value)
    else:
        value = [ls[1:]]
        ls_dict[key]=value
print(ls_dict)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{100: [[14, 12, 15], [21, 16, 11], [19, 10, 13]], 160: [[24, 15, 12], [43, 12, 65], [17, 53, 23]], 300: [[15, 17, 11], [66, 23, 12], [44, 70, 19]]}
</code></pre>
</div>
<span class="comment-copy">What are you going to do with the result?  That will likely determine which method for creating and storing the groups is most effective.</span>
<span class="comment-copy">Is the first column necessarily sorted?</span>
<span class="comment-copy">If it's pre-sorted, it's possible <code>unq = np.array(set(x[:, 0]))</code> and <code>idx1=np.r_[np.searchsorted(x, unq), x.shape[0]]</code> in <code>numpy_app1</code> might be faster.  Or just doing <code>searchsorted</code> instead of returning <code>idx</code> from <code>np.unique</code> (which I think is the slow bit).</span>
<span class="comment-copy">@DanielF Yeah, Approach #2 explicitly leverages that sorted nature and proved to be much more efficient than with <code>np.unique</code>. I rolled out <code>np.unique</code> version with the intention of a compact code.</span>
<span class="comment-copy">Thanks a lot, it worked.</span>
<span class="comment-copy">if this or any answer has solved your question please consider <a href="https://meta.stackexchange.com/q/5234/179419">accepting it</a> by clicking the check-mark. This indicates to the wider community that you've found a solution and gives some reputation to both the answerer and yourself.</span>
<span class="comment-copy">@Jelmed12 What he said. :)</span>
<span class="comment-copy">@Brad Solmon Thanks. I got your point and edit my answer.</span>
