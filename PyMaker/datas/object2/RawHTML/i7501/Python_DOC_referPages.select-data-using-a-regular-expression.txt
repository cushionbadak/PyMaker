<div class="post-text" itemprop="text">
<p>I have a dataframe like this</p>
<pre><code>import pandas as pd

df = pd.DataFrame({'a': ['abc', 'r00001', 'r00010', 'rfoo', 'r01234', 'r1234'], 'b': range(6)})

        a  b
0     abc  0
1  r00001  1
2  r00010  2
3    rfoo  3
4  r01234  4
5   r1234  5
</code></pre>
<p>I now want to select all columns of this dataframe where the entries in column <code>a</code> start with <code>r</code> followed by five numbers.</p>
<p><a href="https://stackoverflow.com/questions/17957890/pandas-select-from-dataframe-using-startswith">From here</a> I learned how one would do this if it started just with <code>r</code> without the numbers:</p>
<pre><code>print df.loc[df['a'].str.startswith('r'), :]

        a  b
1  r00001  1
2  r00010  2
3    rfoo  3
4  r01234  4
5   r1234  5
</code></pre>
<p>Something like this</p>
<pre><code>print df.loc[df['a'].str.startswith(r'[r]\d{5}'), :]
</code></pre>
<p>does of course not work. How would one do this properly?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Option 1</strong><br/>
<em><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.match.html#pandas.Series.str.match" rel="nofollow noreferrer"><code>pd.Series.str.match</code></a></em> </p>
<pre><code>df.a.str.match('^r\d{5}$')

1     True
2     True
3    False
4     True
5    False
Name: a, dtype: bool
</code></pre>
<p>Use it as a filter</p>
<pre><code>df[df.a.str.match('^r\d{5}$')]

        a  b
1  r00001  1
2  r00010  2
4  r01234  4
</code></pre>
<hr/>
<p><strong>Option 2</strong><br/>
<em>Custom list comprehension using string methods</em> </p>
<pre><code>f = lambda s: s.startswith('r') and (len(s) == 6) and s[1:].isdigit()
[f(s) for s in df.a.values.tolist()]

[False, True, True, False, True, False]
</code></pre>
<p>Use it as a filter</p>
<pre><code>df[[f(s) for s in df.a.values.tolist()]]

        a  b
1  r00001  1
2  r00010  2
4  r01234  4
</code></pre>
<hr/>
<p><strong>Timing</strong> </p>
<pre><code>df = pd.concat([df] * 10000, ignore_index=True)

%timeit df[[s.startswith('r') and (len(s) == 6) and s[1:].isdigit() for s in df.a.values.tolist()]]
%timeit df[df.a.str.match('^r\d{5}$')]
%timeit df[df.a.str.contains('^r\d{5}$')]

10 loops, best of 3: 22.8 ms per loop
10 loops, best of 3: 33.8 ms per loop
10 loops, best of 3: 34.8 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.contains.html#pandas.Series.str.contains" rel="nofollow noreferrer"><code>str.contains</code></a> and pass a regex pattern:</p>
<pre><code>In[112]:
df.loc[df['a'].str.contains(r'^r\d{5}')]

Out[112]: 
        a  b
1  r00001  1
2  r00010  2
4  r01234  4
</code></pre>
<p>Here the pattern evaluates to <code>^r</code> - start with character r, and then <code>\d{5}</code> looks for 5 digits</p>
<p><code>startswith</code> looks for a character pattern, not a regex pattern which is why it fails</p>
<p>Regarding the difference between <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.contains.html#pandas.Series.str.contains" rel="nofollow noreferrer"><code>str.contains</code></a> and <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.match.html#pandas.Series.str.match" rel="nofollow noreferrer"><code>str.match</code></a>, they are analagous but <code>str.contains</code> uses <code>re.search</code> whilst <code>str.match</code> uses <code>re.match</code> which is more strict, see the <a href="https://docs.python.org/3/library/re.html#search-vs-match" rel="nofollow noreferrer">docs</a>.</p>
<p><strong>edit</strong></p>
<p>To answer your comment add <code>$</code> so that it matches a specific number of characters, see <a href="https://stackoverflow.com/questions/14590008/regular-expression-to-match-exact-number-of-characters">related</a>:</p>
<pre><code>In[117]:
df = pd.DataFrame({'a': ['abc', 'r000010', 'r00010', 'rfoo', 'r01234', 'r1234'], 'b': range(6)})
df

Out[117]: 
         a  b
0      abc  0
1  r000010  1
2   r00010  2
3     rfoo  3
4   r01234  4
5    r1234  5


In[118]:
df.loc[df['a'].str.match(r'r\d{5}$')]

Out[118]: 
        a  b
2  r00010  2
4  r01234  4
</code></pre>
</div>
<span class="comment-copy">That works, upvoted.</span>
<span class="comment-copy">As <code>str.match</code> is using <code>re.match</code> the pattern could be changed to <code>'r\d{5}'</code> as by default it matches from the beginning of the string</span>
<span class="comment-copy">Not part of the original post, but how would one now exclude the ones that have more than 5 numbers (or any other characters)?</span>
<span class="comment-copy">@Cleb I've updated my post</span>
<span class="comment-copy">I find it depressing to see list comprehension outperforming the supposed vectorised pandas methods, useful to add the timings</span>
<span class="comment-copy">That works, upvoted.</span>
<span class="comment-copy">Not part of the original post, but how would one now exclude the ones that have more than 5 numbers (or any other characters)?</span>
<span class="comment-copy"><code>r'^r\d{5}$</code> should handle this</span>
<span class="comment-copy">Not an issue, glad I can help and add some explanations that are useful</span>
<span class="comment-copy">@Cleb <b>1</b> I don't mean to speak for EdChum, but I'm fairly confident that he'd share my sentiment.  And that sentiment is, I know very well that his answer is every bit as good as mine and that you can only pick one... I'm ok with the outcome either way.  <b>2</b> I've added timings to my post, I have <b>zero</b> expectations that <code>match</code> would work any faster that <code>contains</code>.  My timings validate that.</span>
