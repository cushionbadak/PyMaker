<div class="post-text" itemprop="text">
<p>I'm working on a class representing on object with numerous associated data. I'm storing these data in a dictionary class attribute called <em>metadata</em>. A representation could be:</p>
<pre><code>{'key1':slowToComputeValue, 'key2':evenSlowerToComputeValue}
</code></pre>
<p>The calculating of the values is in some cases <strong>very</strong> slow, so what I want to do is, using "getter" functions, first try and get the value from the <em>metadata</em>  dict. Only on a KeyError (i.e. when the getter tries to get a value for a key which doesn't exist yet) should the value be calculated (and added to the dictionary for fast access next time the getter is called).</p>
<p>I began with a simple:</p>
<pre><code>try:
    return self.metadata[requested_key]
except KeyError:
    #Implementation of function
</code></pre>
<p>As there are many getters in the class, I started thought that these first 3 lines of code could be handled by a decorator. However I'm having problems making this work. The problem is that I need to pass the metadata dictionary from the class instance to the decorator. I've found several tutorials and posts like <a href="https://stackoverflow.com/questions/10176226/how-to-pass-extra-arguments-to-python-decorator">this</a> one which show that it is possible to send a parameter to an enclosing function but the difficulty I'm having is sending a class instantiation attribute metadata to it (if I send a string value it works).</p>
<p>Some example code from my attempt is here:</p>
<pre><code>def get_existing_value_from_metadata_if_exists(metadata):
    def decorator(function):
        @wraps(function)
        def decorated(*args, **kwargs):
            function_name = function.__name__
            if function_name in metadata.keys():
                return metadata[function_name]
            else:
                function(*args, **kwargs)
        return decorated
    return decorator

class my_class():
    @get_existing_value_from_metadata_if_exists(metadata)
    def get_key1(self):
        #Costly value calculation and add to metadata

    @get_existing_value_from_metadata_if_exists(metadata)
    def get_key2(self):
        #Costly value calculation and add to metadata

    def __init__(self):
        self.metadata = {}
</code></pre>
<p>The errors I'm getting are generally self not defined but I've tried various combinations of parameter placement, decorator placement etc. without success.</p>
<p>So my questions are:</p>
<ol>
<li>How can I make this work?</li>
<li>Are decorators a suitable way to achieve what I'm trying to do?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Yes, a decorator is a good use case for this. Django for example has something similar already included with it, it's called <a href="https://docs.djangoproject.com/en/1.11/ref/utils/#django.utils.functional.cached_property" rel="nofollow noreferrer"><code>cached_property</code></a>.</p>
<p>Basically all it does is that when the property is accessed first time it will store the data in instance's dict(<code>__dict__</code>) by the same name as the function. When we fetch the same property later on it simple fetches the value from the instance dictionary.</p>
<p>A <code>cached_property</code> is a <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="nofollow noreferrer">non-data descriptor</a>. Hence once the key is set in instance's dictionary, the access to property would always get the value from there.</p>
<pre><code>class cached_property(object):
    """
    Decorator that converts a method with a single self argument into a
    property cached on the instance.

    Optional ``name`` argument allows you to make cached properties of other
    methods. (e.g.  url = cached_property(get_absolute_url, name='url') )
    """
    def __init__(self, func, name=None):
        self.func = func
        self.__doc__ = getattr(func, '__doc__')
        self.name = name or func.__name__

    def __get__(self, instance, cls=None):
        if instance is None:
            return self
        res = instance.__dict__[self.name] = self.func(instance)
        return res
</code></pre>
<p>In your case:</p>
<pre><code>class MyClass:
    @cached_property
    def key1(self):
        #Costly value calculation and add to metadata

    @cached_property
    def key2(self):
        #Costly value calculation and add to metadata

    def __init__(self):
        # self.metadata not required
</code></pre>
<hr/>
<p>Use the <code>name</code> argument to convert an existing method to cached property.</p>
<pre><code>class MyClass:
    def __init__(self, data):
        self.data = data

    def get_total(self):
        print('Processing...')
        return sum(self.data)

    total = cached_property(get_total, 'total')
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; m = MyClass(list(range(10**5)))

&gt;&gt;&gt; m.get_total()
Processing...
4999950000

&gt;&gt;&gt; m.total
Processing...
4999950000

&gt;&gt;&gt; m.total
4999950000

&gt;&gt;&gt; m.data.append(1000)

&gt;&gt;&gt; m.total  # This is now invalid
4999950000

&gt;&gt;&gt; m.get_total()  # This still works
Processing...
4999951000

&gt;&gt;&gt; m.total
4999950000
</code></pre>
<p>Based on the example above we can see that we can use <code>total</code> as long as we know the internal data hasn't been updated yet, hence saving processing time. But it doesn't make <code>get_total()</code> redundant, as it can get the correct total based on the data.</p>
<p>Another example could be that our public facing client was using something(say <code>get_full_name()</code>) as method so far but we realised that it would be more appropriate to use it as a property(just <code>full_name</code>), in that case it makes sense to keep the method intact but mark it as deprecated and start suggesting the users to use the new property from now on.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way to go about this is to use class "properties" like so:</p>
<pre><code>class MyClass():
    def __init__():
        self._slowToComputeValue = None
    @property
    def slowToComputeValue(self):
        if self._slowToComputeValue is None:
            self._slowToComputeValue = self.ComputeValue()
        return self._slowToComputeValue
    def ComputeValue(self):
        pass
</code></pre>
<p>Now you can access this as though it were a class attribute:</p>
<pre><code>myclass = MyClass()
print(myclass.slowToComputeValue)
</code></pre>
</div>
<span class="comment-copy">Do you want the data to persist even between different instances of <code>my_class</code>?</span>
<span class="comment-copy">No - each instance is related to an audio file. So each instance would have its own set of attributes.</span>
<span class="comment-copy">Wow what kind of magic is this... It works but I'm still trying to get my head around it. Could you add an example of using the name kwarg?</span>
<span class="comment-copy">@user3535074 What do you mean by "name kwarg"?</span>
<span class="comment-copy">The 'name=None' part of -&gt; def __init__(self, func, name=None)</span>
<span class="comment-copy">@user3535074 updated.</span>
<span class="comment-copy">Great answer - thanks a lot.</span>
