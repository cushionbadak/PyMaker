<div class="post-text" itemprop="text">
<p>I got stuck in piping the output of one script into another script (both are python).</p>
<p>This <a href="https://stackoverflow.com/questions/37847232/how-do-i-pipe-output-from-one-python-script-as-input-to-another-python-script?newreg=3739a1c4d947435c8c53542aaf5180d3">question</a> is very similar but (1) it does not provide an answer (2) there is a slight difference in mine. So, I thought opening a new question would be better.</p>
<p>Here is the problem.<br/>
Both scripts are almost identical:</p>
<p><strong>receiver.py</strong></p>
<pre><code>import sys
import time

for line in sys.stdin:
    sys.stdout.write(line)
    sys.stdout.flush()
    time.sleep(3)
</code></pre>
<p><strong>replicator.py</strong></p>
<pre><code>import sys
import time

for line in sys.stdin:
    sys.stderr.write(line)
    sys.stderr.flush()
    time.sleep(3)
</code></pre>
<p>When I am executing these scripts in <em>bash</em> or <em>cmd</em> one by one, everything is fine. Both examples below are working and I see the input text in the output:</p>
<p><strong>Works:</strong> (One line of output appears each 3 seconds)</p>
<pre><code>cat data.txt | python receiver.py
cat data.txt | python replicator.py
</code></pre>
<p>But once I pipe from one script to another script they stop working:</p>
<p><strong>Doesn't work:</strong> (Nothing appears until the end of file is being reached)</p>
<pre><code>cat data.txt | python receiver.py | python replicator.py
</code></pre>
<p>Then when I pipe the first script to another tool it works again!</p>
<p><strong>Works:</strong></p>
<pre><code>cat data.txt | python receiver.py | cat -n
cat data.txt | python replicator.py | cat -n
</code></pre>
<p>And finally when I remove the blocking sleep() function it starts to work again:</p>
<p><strong>Removing the timer:</strong></p>
<pre><code>time.sleep(0)
</code></pre>
<p><strong>Now it works:</strong></p>
<pre><code>cat data.txt | python receiver.py | python replicator.py
</code></pre>
<p>Does anybody know what is wrong with my piping?
I am not looking for alternative ways to do it. I just want to learn what is happening here.</p>
<h1>UPDATE</h1>
<p>Based on the comments, I refined the examples.<br/>
Now both scripts not only print out the content of <code>data.txt</code>, but also add a time-stamp to each line.</p>
<p><strong>receiver.py</strong></p>
<pre><code>import sys
import time
import datetime

for line in sys.stdin:
    sys.stdout.write(str(datetime.datetime.now().strftime("%H:%M:%S"))+'\t')
    sys.stdout.write(line)
    sys.stdout.flush()
    time.sleep(1)
</code></pre>
<p><strong>data.txt</strong></p>
<pre><code>Line-A
Line-B
Line-C
Line-D
</code></pre>
<p><strong>The result</strong></p>
<pre><code>$&gt; cat data.txt
Line-A
Line-B
Line-C
Line-D

$&gt; cat data.txt | python receiver.py
09:05:44        Line-A
09:05:45        Line-B
09:05:46        Line-C
09:05:47        Line-D

$&gt; cat data.txt | python receiver.py | python receiver.py
09:05:54        09:05:50        Line-A
09:05:55        09:05:51        Line-B
09:05:56        09:05:52        Line-C
09:05:57        09:05:53        Line-D

$&gt; cat test.log | python receiver.py | sed -e "s/^/$(date +"%H:%M:%S") /"
09:17:55        09:17:55        Line-A
09:17:55        09:17:56        Line-B
09:17:55        09:17:57        Line-C
09:17:55        09:17:58        Line-D

$&gt; cat test.log | python receiver.py | cat | python receiver.py
09:36:21        09:36:17        Line-A
09:36:22        09:36:18        Line-B
09:36:23        09:36:19        Line-C
09:36:24        09:36:20        Line-D
</code></pre>
<p>As you see when I am piping the output of python script to itself, the second script waits until the first one is finished. Then it starts to digest the data.</p>
<p>However, when I am using another tool (<code>sed</code> in this example), the tool receives the data immediately. Why it is happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is due to <em>the internal buffering</em> in <strong>File Objects</strong> (<code>for line in sys.stdin</code>).</p>
<p>So, if we fetch <em>line by line</em>:</p>
<pre><code>import sys
import time
import datetime

while True:
    line = sys.stdin.readline()
    if not line:
       break
    sys.stdout.write(str(datetime.datetime.now().strftime("%H:%M:%S"))+'\t')
    sys.stdout.write(line)
    sys.stdout.flush()
    time.sleep(1)
</code></pre>
<p>The code will work as expected:</p>
<pre><code>$ cat data.txt | python receiver.py |  python receiver.py
09:43:46        09:43:46        Line-A
09:43:47        09:43:47        Line-B
09:43:48        09:43:48        Line-C
09:43:49        09:43:49        Line-D
</code></pre>
<p><a href="https://docs.python.org/2/using/cmdline.html#cmdoption-u" rel="nofollow noreferrer"><strong>Documentation</strong></a></p>
<blockquote>
<p>... Note that there is internal buffering in file.readlines() and File
  Objects (<strong>for line in sys.stdin</strong>) which is not influenced by this
  option. To work around this, you will want to use file.readline()
  inside a while 1: loop.</p>
</blockquote>
<p><strong>NOTE</strong>: The <code>File Object</code> thing was fixed in <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-u" rel="nofollow noreferrer">Python 3</a> </p>
</div>
<span class="comment-copy">What do you mean by "Doesn't work"? What exactly happens in this case?</span>
<span class="comment-copy">@Chris_Rands, it does not show any output until the first script finishes its job and then the output appears on the screen all at once. The expected behavior is to print 1 line of text each 3 seconds. -Question updated.</span>
<span class="comment-copy">When you pipe the output the next script waits for it. It has to do with linux not with python. The quedtion is, why do you have to pipe anyway? Why not create a simple python functions and call them?</span>
<span class="comment-copy">@ImanolLuengo, Exactly my question is here. What is happening behind the scene that helps a tool like <code>cat</code> to work but prevents my script from functioning. As I mentioned in the question I just want to learn how it works. And another point is that this is not only about Linux, I also tested it on <b>Windows</b>. It shows the same behavior.</span>
<span class="comment-copy">But this won't terminate the script when EOF is reached.</span>
<span class="comment-copy">Thank you @klashxx, it actually solved the problem. Just for my understanding: How does using a <code>while 1:</code> loop, flush the <code>file.readlines()</code> internal buffer?</span>
<span class="comment-copy">@Dark - it doesn't, it's just in the way <code>readline()</code> works - it reads the stream until it encounters a <code>\n</code> at which point the buffer is returned. On the other hand, <code>for line in handle</code> expects the handle to be an iterable and Pyhon waits a long while before before it start sending individual elements (i.e. waits for the buffer to be filled). This behavior has been fixed but it still is a safer option to just use <code>readlines()</code> when reading from STDIN. (btw. you don't need <code>-u</code> at all, nor would it help you here as you're flushing your STDOUT/STDERR immediately anyway)</span>
<span class="comment-copy">@zwer, Now I got it. Thank you. The point which I didn't understand was the <code>iterable</code> assumption of <code>for line in handle</code>. In my idea, <code>for line in handle</code> was equal to <code>file.readlines()</code>. I will also avoid using -u in this particular case.</span>
