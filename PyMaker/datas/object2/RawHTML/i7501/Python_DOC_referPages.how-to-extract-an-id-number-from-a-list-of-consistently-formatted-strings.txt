<div class="post-text" itemprop="text">
<p>I'm working with a set of data that has names and usernames combined in one string. For example, if a user was named "John Smith" and his ID number was 1234567, the string would be "John Smith --- 1234567". The strings are consistently formatted in such a way that it is always:</p>
<pre><code>NAME [space] 3 HYPHENS [space] ID number
</code></pre>
<p>I am trying to find a way to pull ID numbers out of these strings. I found that doing something like this:</p>
<pre><code>foo = "John Smith --- 1234567"

bar = [str(s) for s in foo.split() if s.isdigit()]
</code></pre>
<p>I get a list like this ['1234567']. This will work for my needs, but I'm wondering if there's a more "Pythonic"/clean way to do this? Is there a way to just get and int of the ID number returned, as opposed to a list with a string in it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use regex for this case</p>
<pre><code>import re
foo = "John Smith --- 1234567"
id = re.search(r'\d+',foo).group()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your problem correctlyâ€¦:</p>
<pre><code>id = int(foo.split(' --- ')[-1])
</code></pre>
<p>First, your <code>foo</code> is split into a list two parts - before and after <code>---</code> - then the last element of this list, which obviously should be the ID, is converted to int.</p>
</div>
<div class="post-text" itemprop="text">
<p>Appropriate use of regular expressions is "Pythonic":</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; data = "John Smith --- 1234567"
&gt;&gt;&gt; idtext = re.match(r'.* --- (\d+)$', data).group(1)
&gt;&gt;&gt; int(idtext)
1234567
</code></pre>
<p>The regex asks for any sequence, followed by your " --- " marker, followed by digits and then the end of the line. That may be too restrictive, or not restrictive enough, depending on the actual data.</p>
<p>Whether that's appropriate for your situation, and whether you want any error handling to cover possible unexpected conditions, is your call.  Note also <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer">re.findall()</a> which would let you do this on input that had many of these lines, all at once.</p>
<p>As Brian M. Sheldon commented, using a string split() (or rsplit(), if you're looking for something at the end instead) is also "Pythonic" when it's appropriate, and that would look something like this:</p>
<pre><code>&gt;&gt;&gt; data = "John Smith --- 1234567"
&gt;&gt;&gt; idtext = data.rsplit(' --- ', 1)[1]
&gt;&gt;&gt; int(idtext)
1234567
</code></pre>
<p>I showed the regex version first because in my experience, doing this on one line probably means you have a bunch of lines and going from the one-liner to using re.findall() makes this a bit simpler than having to iterate over the lines manually (using a for loop or generator or such) and apply the split to each one.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about:</p>
<pre><code>bar = [int(s) for s in foo.split() if s.isdigit()]
</code></pre>
<p>instead?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>filter</code> and <code>str.isdigit</code>:</p>
<pre><code>''.join(list(filter(str.isdigit, foo)))
</code></pre>
</div>
<span class="comment-copy">This regex assumes no numbers in the names/usernames.</span>
<span class="comment-copy">This is the best answer in my opinion, but you should probably explain what the code is actually doing.</span>
<span class="comment-copy">While I agree that an appropriate regex is pythonic, if the text is consistently formatted as mentioned, splitting on <code>" --- "</code> and taking the last value is both pythonic and quicker than a regex.</span>
<span class="comment-copy">Also this regex could probably be improved, it takes a minimum of  18 steps for a 1 digit ID and 24 steps for a 7 digit ID as in the example.  By contrast <code>"--- (\d+)$"</code> takes only 9 steps regardless of ID length.</span>
<span class="comment-copy">@Brian, the re.match() routine is anchored to the start of text. To get rid of the .* part you'd need to use re.search() instead.</span>
<span class="comment-copy">Very true, but I find myself using <code>re.search</code> way more often than <code>re.match</code> unless the pattern really is at the beginning of the string.</span>
<span class="comment-copy">@Brian, that's perfectly reasonable. For my part, I like to be quite explicit about what I'm actually skipping, even if it's just "anything". I figure it makes my code more readable.</span>
<span class="comment-copy">or <code>bar = [int(s[-1]) for s in foo.split()]</code></span>
<span class="comment-copy">@Michael instead split on the actual delimiter <code>foo.split(" --- ")</code></span>
<span class="comment-copy">This is a heavy-handed approach in my opinion.  I think splitting on the delimiter is the better option.</span>
