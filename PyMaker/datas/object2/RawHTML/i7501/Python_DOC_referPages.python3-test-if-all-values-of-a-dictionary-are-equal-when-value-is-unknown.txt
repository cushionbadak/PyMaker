<div class="post-text" itemprop="text">
<p>I have a 2 dictionaries: 
the values in each dictionary <em>should</em> all be equal.<br/>
<strong>BUT</strong> I don't know what that number will be...</p>
<pre><code>dict1 = {'xx':A, 'yy':A, 'zz':A}
dict2 = {'xx':B, 'yy':B, 'zz':B}
</code></pre>
<p><strong>N.B.</strong> A does not equal B<br/>
<strong>N.B.</strong> Both A and B are actually strings of decimal numbers (e.g. '-2.304998') as they have been extracted from a text file  </p>
<p>I want to create another dictionary - that effectively summarises this data - but only if all the values in each dictionary are the same.<br/>
i.e.  </p>
<pre><code>summary = {}
if dict1['xx'] == dict1['yy'] == dict1['zz']:
    summary['s'] = dict1['xx']
if dict2['xx'] == dict2['yy'] == dict2['zz']:
    summary['hf'] = dict2['xx']
</code></pre>
<p>Is there a neat way of doing this in one line?   </p>
<p>I know it is possible to create a dictionary using comprehensions<br/>
<code>summary = {k:v for (k,v) in zip(iterable1, iterable2)}</code><br/>
but am struggling with both the underlying for loop and the if statement...</p>
<p>Some advice would be appreciated. </p>
<p>I have seen <a href="https://stackoverflow.com/questions/35253971/how-to-check-if-all-values-of-a-dictionary-are-0-in-python">this question</a>, but the answers all seem to rely on already knowing the value being tested (i.e. are all the entries in the dictionary equal to a known number) - unless I am missing something. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>set</code>s are a solid way to go here, but just for code golf purposes here's a version that can handle non-hashable dict values:</p>
<pre><code>expected_value = next(iter(dict1.values())) # check for an empty dictionary first if that's possible
all_equal = all(value == expected_value for value in dict1.values())
</code></pre>
<p><code>all</code> terminates early on a mismatch, but the set constructor is well enough optimized that I wouldn't say that matters without profiling on real test data. Handling non-hashable values is the main advantage to this version.</p>
</div>
<div class="post-text" itemprop="text">
<p>While we can use <code>set</code> for this, doing so has a number of inefficiencies when the input is large. It can take memory proportional to the size of the input, and it always scans the whole input, even when two distinct values are found early. Also, the input has to be hashable.</p>
<p>For 3-key dicts, this doesn't matter much, but for bigger ones, instead of using <code>set</code>, we can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a> and see if it produces multiple groups:</p>
<pre><code>import itertools

groups = itertools.groupby(dict1.values())

# Consume one group if there is one, then see if there's another.
next(groups, None)
if next(groups, None) is None:
    # All values are equal.
    do_something()
else:
    # Unequal values detected.
    do_something_else()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this would be to leverage <code>set</code>. You know a <code>set</code> of an iterable has a length of 1 if there is only one value in it:</p>
<pre><code>if len(set(dct.values())) == 1:
    summary[k] = next(iter(dct.values()))
</code></pre>
<p>This of course, only works if the values of your dictionary are hashable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Except for readability, I don't care for all the answers involving set or .values. All of these are <em>always</em> O(N) in time and memory. In practice it can be faster, although it depends on the distribution of values.</p>
<p>Also because set employs hashing operations, you may also have a hefty large constant multiplier to your time cost. And your values have to hashable, when a test for equality is all that's needed.</p>
<p>It is <em>theoretically</em> better to take the first value from the dictionary and search for the first example in the remaining values that is not equal to.
<em>set</em> might be quicker than the solution below because its workings are may reduce to C implementations.</p>
<pre><code>def all_values_equal(d):
    if len(d)&lt;=1: return True # Treat len0 len1 as all equal
    i = d.itervalues()
    firstval = i.next()
    try:
        # Incrementally generate all values not equal to firstval
        # .next raises StopIteration if empty.
        (j for j in i if j!=firstval).next()
        return False
    except StopIteration:
        return True

print all_values_equal({1:0, 2:1, 3:0, 4:0, 5:0}) # False
print all_values_equal({1:0, 2:0, 3:0, 4:0, 5:0}) # True
print all_values_equal({1:"A", 2:"B", 3:"A", 4:"A", 5:"A"}) # False
print all_values_equal({1:"A", 2:"A", 3:"A", 4:"A", 5:"A"}) # True
</code></pre>
<p>In the above:</p>
<pre><code>(j for j in i if j!=firstval)
</code></pre>
<p>is equivalent to:</p>
<pre><code>def gen_neq(i, val):
    """
    Give me the values of iterator i that are not equal to val
    """
    for j in i:
        if j!=val:
            yield j
</code></pre>
</div>
<span class="comment-copy">What do you mean, values are unknown? So you could be comparing <code>Foo()</code> and <code>12345.35</code>?</span>
<span class="comment-copy">I will always be compring a (strings of) decimal number(s) - i just don't know what that number is/will be (i.e. its numeric value)</span>
<span class="comment-copy">@user2696225 - if you're looking at string representations of decimal numbers, watch out for strings that are different but represent the same number, eg "10.0" vs "10.000".</span>
<span class="comment-copy"><code>all</code> is definitely better than <code>set</code>. In the worst case (all values are equal) then both are O(n). In the best case (when all values are different) then <code>all</code> is O(1) and <code>set</code> is still O(n). Further, with regards to memory, <code>all</code> is O(1) in the worst case whereas <code>set</code> is O(n). Finally <code>all</code> is more semantically obvious than <code>set</code> -- ie. "all" is in the question title whereas "set" isn't.</span>
<span class="comment-copy">You're right about the computational complexity, but I've been surprised in the past by how fast <code>set(iterable)</code> can be compared to more explicit logic. Testing on one host I have access to, a worst-case comparison (all values equal) takes about 2.5x as long: <code>timeit.timeit('set(test_dict.values())', setup='test_dict={x: 0 for x in range(100000)}', number=1000)</code> took ~2.34s vs <code>timeit.timeit('set(test_dict.values())', setup='test_dict={x: 0 for x in range(100000)}', number=1000)</code> at ~6.13s. Best case, where the early termination matters more, is a different story.</span>
<span class="comment-copy">Same host, best case takes about 1ms using <code>all</code> compared to ~4.57s for <code>set</code>, so it's a clear winner there. Sticking in one non-0 value at position 50,000 still lets <code>set</code> win, ~2.48s for <code>set</code> compared to ~3.92s for <code>all</code>. So a) it probably doesn't matter and readability counts for more and b) if it does, you have to measure on real data.</span>
<span class="comment-copy">Argh, copy/paste fail in my comment above and I'm past the edit window. The second test, at 6.13s, was <code>timeit.timeit('all(x == 0 for x in test_dict.values())', setup='test_dict={x: 0 for x in range(100000)}', number=1000)</code>.</span>
<span class="comment-copy">The question is tagged Python 3, so <code>values()</code> is a view and requires constant memory.</span>
<span class="comment-copy">But set(d.values()) is O(N) in at least time. And possibly memory.</span>
<span class="comment-copy">Only one of the other answers is using <code>set</code>, though.</span>
<span class="comment-copy">I see 4 answers. 2 use sets.</span>
<span class="comment-copy">One was deleted a while ago.</span>
