<div class="post-text" itemprop="text">
<p>I'm trying to make a set which will have all the words the user queried from a string.</p>
<pre><code># Step 1: Read the string
instr = 'Lorem ipsum dolor sit amet, unde curabitur nonummy nonummy, cras dui eget, accumsan placerat nibh cumque vel augue, vitae laoreet at. Urna feugiat. Ut ante neque duis neque metus lectus. Neque rutrum tortor adipiscing omnis neque urna, diam vivamus. Pulvinar quis id, porta class felis enim vulputate, tempus arcu, sit porta. Nec praesent orci in, orci id duis purus ultrices, non sit vel. Cras ipsum nibh nulla suspendisse neque, mi dis, vestibulum a ipsum, morbi a curabitur porttitor sodales sit nullam, mus tristique feugiat vel per orci. Lacus elit molestie quam, ac nibh nulla in faucibus quis volutpat. Congue cum massa. Convallis in ultricies eget velit, erat elit eleifend.'

text_lowercase = instr.lower()
# Turn them in to set. Easy enough
all_words = set(text_lowercase)

# Step 2: Compare with the user's words:
all_words &amp; user_words
# And those are the user's words that exist in the text.
</code></pre>
<h1>Here's my question</h1>
<p>Suppose the user queries for terms like <code>lor*</code> , or <code>con*</code>.
I want to be able to add to my <code>set</code> every word that start's with <code>lor</code> or <code>con</code>. From a quick pass, I see that there are words like <code>Congue</code>, <code>Convallis</code>. So these 2 should be added to the set.                                                             <br/></p>
</div>
<div class="post-text" itemprop="text">
<p>You could just replace the <code>*</code> with e.g. <code>\w*</code> and use a pattern like <code>con*</code> itself as a regular expression to search for.</p>
<pre><code>&gt;&gt;&gt; word = "con*"
&gt;&gt;&gt; re.findall(word.replace("*", "\w*"), instr.lower())
['congue', 'convallis']
&gt;&gt;&gt; word = "*val*is"
&gt;&gt;&gt; re.findall(word.replace("*", "\w*"), instr.lower())
['convallis']
</code></pre>
<p>You might also enclose the result of <code>word.replace</code> in <code>\b...\b</code> or <code>^...$</code> (when matching individual words in the split sentence) to account for word boundaries.</p>
<pre><code>&gt;&gt;&gt; word = "l*"
&gt;&gt;&gt; re.findall(r"\b%s\b" % word.replace("*", "\w*"), instr.lower())
['lorem', 'laoreet', 'lectus', 'lacus']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need a regex for this, you can use a list comprehension with <code>str.startswith()</code>:</p>
<pre><code>[w for w in instr.split() if w.lower().startswith(('lor', 'con'))]
# ['Lorem', 'Congue', 'Convallis']
</code></pre>
<p>Or since your prefixes are always the same length, a simple <code>in</code> check:</p>
<pre><code>[w for w in instr.split() if w[:3].lower() in {'lor', 'con'}]
</code></pre>
</div>
<span class="comment-copy">Have you tried printing <code>all_words</code>? I don't think it's doing what you are expecting.</span>
<span class="comment-copy">What have you tried so far? You should post more of your code to show your effort, otherwise it looks like you want the community to do your homework. Have a look at the python string functions <code>split</code> and <code>startswith</code>.</span>
<span class="comment-copy">Yeah, you probably need to split that string before changing it to a set to accomplish what you're intending. But in general, the answer to your question is to learn how to use the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regex library</a></span>
