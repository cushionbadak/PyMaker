<div class="post-text" itemprop="text">
<p>Unsure of the Python convention for type hinting instance variables - I've been doing them within the <code>__init__</code> constructor arguments like seen here:</p>
<pre><code>class LoggedVar(Generic[T]):
    def __init__(self, value: T, name: str, logger: Logger) -&gt; None:
        self.name = name
        self.logger = logger
        self.value = value`
</code></pre>
<p>link to above code snippet: <a href="https://docs.python.org/3/library/typing.html#user-defined-generic-types" rel="noreferrer">https://docs.python.org/3/library/typing.html#user-defined-generic-types</a></p>
<p>But I also see the PEP conventions of annotating instance variables as such(snippet below) and then also doing type hinting within the <code>__init__</code> arguments:</p>
<pre><code>class BasicStarship:
    captain: str = 'Picard'               # instance variable with default
    damage: int                           # instance variable without default
    stats: ClassVar[Dict[str, int]] = {}  # class variable`

    def __init__(self, damage: int, captain: str = None):
        self.damage = damage
        if captain:
            self.captain = captain  # Else keep the default
</code></pre>
<p>Lastly, later on in the PEP526 article they say one can do the following for convenience and convention:</p>
<pre><code>class Box(Generic[T]):
    def __init__(self, content):
        self.content: T = content
</code></pre>
<p>url to two above code snippets:
<a href="https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations" rel="noreferrer">https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations</a></p>
<p>So is one of these conventions better / more widely accepted than the others that I should try to stick to (better readability etc..)?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend using the first version, where you assign types to your <code>__init__</code> method's parameters, for most circumstances.</p>
<p>That particular method has the least amount of redundancy while still allowing type checkers to verify that you're calling that <code>__init__</code> method correctly elsewhere in your code.</p>
<p>I would recommend using either the second or third version, where you explicitly annotate your fields (inside or outside <code>__init__</code>) when your <code>__init__</code> method has grown complex enough to the point where one or more of the following apply:</p>
<ol>
<li>It's no longer so straightforward what exactly your fields are to begin with</li>
<li>There's no longer a one-to-one mapping between your parameters and your fields</li>
<li>You have complex initialization logic that obscures how your fields are being assigned.</li>
</ol>
<p>However, it was unclear to me whether the second or third version was preferred -- I personally prefer the third version because it's more conceptually cleaner and doesn't seem to mix the notion of instance vs class attributes, but I can't deny the second version looks cleaner. </p>
<p>I asked about it on the 'typing' gitter channel, and got the following response from Guido (who, on the off-chance you didn't know, made Python and is currently working on mypy and typing related stuff):</p>
<blockquote>
<p>There seem to be strong opinions either way. I do indeed prefer putting attribute annotations in the class body rather than sprinkling them throughout <code>__init__</code> and other methods. I also think that with PEP 526 this will be the future (also with things like class-based NamedTuple declarations and possibly <a href="https://github.com/ericvsmith/dataclasses" rel="nofollow noreferrer">https://github.com/ericvsmith/dataclasses</a>).</p>
</blockquote>
<p>(<a href="https://gitter.im/python/typing?at=595f9f5b2723db8d5ee9c892" rel="nofollow noreferrer">link to quote</a>)</p>
<p>So, it seems like the second version is recommended over the third, and that defining classes in that manner will become more deeply integrated into the Python language itself at some point in the future!</p>
<p><strong>Edit:</strong> <a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer">PEP 557, data classes</a> was <a href="https://mail.python.org/pipermail/python-dev/2017-December/151034.html" rel="nofollow noreferrer">recently accepted</a> and appears to be on-track (?) to be included with Python 3.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd stick with what you're doing in LoggedVar, it follows the same rules as everywhere else in Python so less confusion all round. </p>
<p>The BasicStarShip class changes the scope of the variables by moving them out of the __init__ function. With captain declared there BasicStarShip.captain will return 'Picard'. </p>
<p>The PEP526 annotations are nice to read, but it's a new rule for one specific case, the __init__ function. From the <strong>Zen of Python</strong>: <em>"Special cases aren't special enough to break the rules."</em></p>
</div>
<span class="comment-copy">I was unaware of PEP 526 until now; thank you.</span>
<span class="comment-copy">why are <code>captain</code> and <code>damage</code> instance variables in the second example? Aren't they class variables as well? Or is the fact, that they are altered in the init method making them instance variables? If I would have a list, and would alter it with <code>list.append()</code> that alteration would be shared over all instances, so it would still be a class variable.</span>
