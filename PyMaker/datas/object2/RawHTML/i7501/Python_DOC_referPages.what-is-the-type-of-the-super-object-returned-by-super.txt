<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3.6/library/functions.html#super" rel="nofollow noreferrer">here</a>:</p>
<blockquote>
<pre><code>super( [ type [ , object-or-type ]] )
</code></pre>
<p>Return a proxy object that delegates method calls to a parent or sibling class of <code>type</code>. This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by <code>getattr()</code> except that the <code>type</code> itself is skipped.</p>
<p>If the second argument is omitted, the super object returned is
  unbound. </p>
<p>If the second argument is an object, <code>isinstance(obj, type)</code> must be
  true. </p>
<p>If the second argument is <strong>a type</strong>, <code>issubclass(type2, type)</code> must be
  true (this is useful for classmethods).</p>
</blockquote>
<ol>
<li><p>If I am correct, a type is a class, and a class is a type. A class
is an object, so a type is also an object.  Why does the quote
distinguish the two cases when the second argument being an object 
when it is a type?</p></li>
<li><p>When the second argument is a type, why is <code>issubclass(type2, type)</code>
required to be true?</p></li>
<li><p>What is the type of the super object    returned by <code>super</code> in each of the three cases respectively? Or how do you determine the type of the super object returned by <code>super</code>?</p>
<p>When the second argument is an object, because "The search order is same as that used by <code>getattr()</code> except that the <code>type</code> itself is skipped", I guessed that the type of the superobject returned by <code>super</code> function should be a subclass of any ancestry class of the first argument <code>type</code>, but I found that it is actually not by testing with <code>issubclass</code>. So did I misunderstand something?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be confusing the word <code>type</code> with the <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type()</code></a> built-in. Here they simply references the first argument passed into <code>super()</code>.</p>
<p>What the documentation tells you is that <em>if</em> you pass in two arguments, then the second argument <em>either</em> has to be an instance of the first argument, <em>or</em> it has to be a subclass. In other words, either <code>isinstance(first_argument, second_argument)</code> or <code>issubclass(first_argument, second_argument)</code> must be true. <em>There is no other meaning here</em>.</p>
<p>Just like <code>int()</code> or <code>str()</code> or any of the other built-in types, the type of the object returned by calling <code>super()</code> <em>is that type</em>. There are no separate types returned for different arguments. See the <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Objects/typeobject.c#L7314-L7704" rel="nofollow noreferrer">C source code defining the object</a>.</p>
<p>The <code>super()</code> object implements a <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Objects/typeobject.c#L7361-L7434" rel="nofollow noreferrer"><code>__getattribute__</code> hook</a> that implements specific attribute behaviour. The documentation tells you that the <em>rules</em> for attribute lookups are the same as for <code>getattr()</code> (but with the documented MRO skip), but that does <em>not</em> mean that <code>super()</code> returns an ancestor class.</p>
<p>What actually happens is that <code>super().__getattribute__</code> takes the MRO of the second argument (either <code>type(instance).__mro__</code> or <code>cls.__mro__</code>, depending on wether <code>isinstance()</code> or <code>issubclass()</code> was true), find the first argument in that sequence and start testing for attributes after that. Because the MRO is scanned for the (type of) the second argument first, it does have to be findable, which is why the constraints are what they are. </p>
<p>In Pure Python, this is what <code>super()</code> does (simplified to focus on just the two argument behaviour):</p>
<pre><code>def _supercheck(type_, obj):
    try:
        if issubclass(obj, type_):
            return obj
    except TypeError:
        # obj is not a type so issubclass throws a TypeError
        pass
    if isinstance(obj, type_):
        return type(obj)
    raise TypeError(
        "super(type, obj): obj must be an instance or subtype of type")


class super_:
    def __init__(self, type_, obj):
        # simplified for the two-argument case
        self.type_ = type_
        self.obj = obj
        self.obj_type = _supercheck(type_, obj)

    def __getattribute__(self, name):
        if name == '__class__':
            # __class__ should always come from this object, not
            # the represented MRO.
            return super().__getattribute__(name)

        # avoid infinite recursion issues
        sd = super().__getattribute__('__dict__')
        starttype = sd['obj_type']
        type_ = sd['type_']
        obj = sd['obj']

        mro = iter(starttype.__mro__)

        # skip past the start type in the MRO
        for tp in mro:
            if tp == type_:
                break

        # Search for the attribute on the remainder of the MRO
        for tp in mro:
            attrs = vars(tp)
            if name in attrs:
                res = attrs[name]
                # if it is a descriptor object, bind it
                descr = getattr(type(res), '__get__', None)
                if descr is not None:
                    res = descr(
                        res,
                        None if obj is starttype else obj,
                        starttype)
                return res

        return super().__getattribute__(name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>just for the point 3 about the type super in the 3 cases (2 first are similar):</p>
<pre><code>class A(object):
    def sup(self):
        return (super(A, self))

class A1(object):
    def sup(self):
        return (super())


class B(object):      
    def sup(self):
        return (super(B))  

class C(A):
    def sup(self):
        return (super(A,C))      

a = A()
a_sup = a.sup()
print(type(a_sup))  #&lt;class 'super'&gt;
print(a_sup.__doc__)  #The most base type
print(a_sup.__self__)  #&lt;__main__.A object at 0x7f9d0d2d8668&gt;
print(a_sup.__self_class__) #&lt;class '__main__.A'&gt;
print(a_sup.__thisclass__)  #&lt;class '__main__.A'&gt;

print()  
a1 = A1()
a_sup = a1.sup()
print(type(a_sup))  #&lt;class 'super'&gt;
print(a_sup.__doc__)  #The most base type
print(a_sup.__self__)  #&lt;__main__.A1 object at 0x7f9d0d2d86d8&gt;
print(a_sup.__self_class__) #&lt;class '__main__.A1'&gt;
print(a_sup.__thisclass__) #&lt;class '__main__.A1'&gt;

print()    
b = B()
b_sup = b.sup()
print(type(b_sup))  #&lt;class 'super'&gt;
print(b_sup.__doc__) 
'''
super() -&gt; same as super(__class__, &lt;first argument&gt;)
super(type) -&gt; unbound super object
super(type, obj) -&gt; bound super object; requires isinstance(obj, type)
super(type, type2) -&gt; bound super object; requires issubclass(type2, type)
Typical use to call a cooperative superclass method:
class C(B):
    def meth(self, arg):
        super().meth(arg)
This works for class methods too:
class C(B):
    @classmethod
    def cmeth(cls, arg):
        super().cmeth(arg)
'''        

print(b_sup.__self__)  #None
print(b_sup.__self_class__)  #None
print(b_sup.__thisclass__)  #&lt;class '__main__.B'&gt;

print()
c=C()
c_sup = c.sup()
print(type(c_sup))  #&lt;class 'super'&gt;
print(c_sup.__doc__) #The most base type
print(c_sup.__self__) #&lt;class '__main__.C'&gt;
print(c_sup.__self_class__) #&lt;class '__main__.C'&gt;
print(c_sup.__thisclass__) #&lt;class '__main__.A'&gt;
</code></pre>
</div>
<span class="comment-copy"><code>type</code> here references the <i>argument name</i>, not the <code>type()</code> built-in.</span>
<span class="comment-copy">Does "type" in "If the second argument is a type" mean a specific type?</span>
<span class="comment-copy">The extent of its documentation is what you already found.</span>
<span class="comment-copy">It's right there, in your link. The contents of your link constitute the entire documentation of the <code>super</code> type. There is no further documentation.</span>
<span class="comment-copy">@Tim: The docs list it as a function, but it's a type. I didn't say it was particularly satisfying documentation.</span>
<span class="comment-copy">Thanks. I am missing something here, and wondering what "the type of the object returned by calling <code>super()</code> is that type" mean? What is the type of <code>super(cls1, cls2)</code>?</span>
<span class="comment-copy">@Tim <code>&lt;type 'super'&gt;</code>. It's a proxy object, a lot like the <code>super_</code> Python class I show in my answer.</span>
<span class="comment-copy">Does proxy object mean proxy design pattern?</span>
<span class="comment-copy">Yes, it is an example of the design pattern.</span>
<span class="comment-copy">Thanks. i am interested in the relation between type <code>super</code>, <code>type</code> and <code>object</code>. It is obvious that <code>super</code> must be an instance of <code>type</code>, and a subclass of <code>object</code>. Is there more relation between them?</span>
<span class="comment-copy"><code>isinstance(a_sup, object)</code>  ==&gt;  True,  <code>isinstance(a_sup, type)</code> ==&gt; False, <code>issubclass(type(a_sup), type)</code> ==&gt; False</span>
<span class="comment-copy">@Tim: no, <code>super()</code> is <i>not</i> an instance of the first argument. Why should it be?</span>
