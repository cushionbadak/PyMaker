<div class="post-text" itemprop="text">
<p>I have created a list in Python</p>
<pre><code>&gt;&gt;&gt; my_list = [1, 2, 3, 4]
</code></pre>
<p>Now if I want to delete the list, I would like to use the <code>del</code> operator like</p>
<pre><code>&gt;&gt;&gt; del my_list
</code></pre>
<p>This works fine and is probably the general way of using it. But somewhere I stumbled upon an unusual syntax</p>
<pre><code>&gt;&gt;&gt; del[my_list]
</code></pre>
<p>And this does the same thing! And now I am kind of confused how del actually works. I can understand the previous syntax with <code>del</code> being a built-in statement, but the second syntax looks like an indexing to me.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>del</code> takes a <em>target list</em> of names, see the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-del-statement" rel="noreferrer">reference documentation</a>:</p>
<blockquote>
<pre><code>del_stmt ::=  "del" target_list
</code></pre>
</blockquote>
<p>Just like for <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="noreferrer">assignments</a> and <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="noreferrer"><code>for</code> loops</a>, a target list includes using <code>[...]</code> and <code>(...)</code> list and tuple syntax:</p>
<pre><code>del (foo, bar)
del [spam, ham, eggs]
</code></pre>
<p>So you are not subscripting <code>del</code>, you are deleting a list of names.</p>
<p>You can even nest them:</p>
<pre><code>del (foo, [ham, eggs])
</code></pre>
<p>It was simpler to re-use an existing grammar rule than to strictly limit the syntax to a comma-separated list of names.</p>
<p>The full grammar definition is:</p>
<blockquote>
<pre><code>target_list     ::=  target ("," target)* [","]
target          ::=  identifier
                     | "(" [target_list] ")"
                     | "[" [target_list] "]"
                     | attributeref
                     | subscription
                     | slicing
                     | "*" target
</code></pre>
</blockquote>
<p>so <code>del *names</code> is technically valid too, but the compiler special-cases that last option to be a <code>SyntaxError</code> anyway:</p>
<pre><code>&gt;&gt;&gt; foo = None
&gt;&gt;&gt; del *foo
  File "&lt;stdin&gt;", line 1
SyntaxError: can't use starred expression here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not indexing.</p>
<p>When <code>del</code>eting things, you can specify more than one thing to delete at a time:</p>
<pre><code>del a, b
</code></pre>
<p>You can also surround the deletion targets with brackets or parentheses:</p>
<pre><code>del [a, b]
del (a, b)
</code></pre>
<p>And you can do that even if there's only one deletion target:</p>
<pre><code>del [a]
</code></pre>
<p>This behavior is mostly mirroring that of assignment, where the optional brackets or parentheses are useful for nested unpacking:</p>
<pre><code>nested_tup = (1, (2, 3))
[a, [b, c]] = nested_tup
</code></pre>
<p>While you're technically allowed to do something like <code>del [a, [b, c]]</code>, it's equivalent to <code>del a, b, c</code>.</p>
</div>
<span class="comment-copy"><code>del[my_list]</code> is <code>del [my_list]</code> is a target list.</span>
<span class="comment-copy">This isn't indexing, this is constructing a list and then deleting it, but I believe when you construct an iterable in the delete command, it deletes everything within the iterable.</span>
