<div class="post-text" itemprop="text">
<p>I have a text file which looks like this:</p>
<ul>
<li>l\u00f6yt\u00e4\u00e4</li>
</ul>
<p>but all unicode chars need to be replaced with corresponding characters and should look like this:</p>
<ul>
<li>l√∂yt√§√§</li>
</ul>
<p>the problem is that I do not want to replace all unicode codes by myself, what is the most efficient way to do this automatically?
my code looks like this right now but it needs to be refined for sure!(the code is in Python3)</p>
<pre><code>import io
input = io.open("input.json", "r", encoding="utf-8")
output = io.open("output.txt", "w", encoding="utf-8")
with input, output:
    # Read input file.
    file = input.read()
    file = file.replace("\\u00e4", "√§")
    # I think last line is the same as line below:
    # file = file .replace("\\u00e4", u"\u00e4")
    file = file.replace("\\u00c4", "√Ñ")
    file = file.replace("\\u00f6", "√∂")
    file = file.replace("\\u00d6", "√ñ")
    .
    .
    . 
    # I cannot put all codes in unicode here manually!
    .
    .
    .
    # writing output file
    output.write(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just decode the JSON <em>as JSON</em>, and then write out a new JSON document without ensuring the data is ASCII safe:</p>
<pre><code>import json

with open("input.json", "r", encoding="utf-8") as input:
    with open("output.txt", "w", encoding="utf-8") as output:
        document = json.load(input)
        json.dump(document, output, ensure_ascii=False)
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/json.html#json.dump" rel="nofollow noreferrer"><code>json.dump()</code> documentation</a>:</p>
<blockquote>
<p>If <em>ensure_ascii</em> is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If <em>ensure_ascii</em> is false, these characters will be output as-is.</p>
</blockquote>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; print(json.loads(r'"l\u00f6yt\u00e4\u00e4"'))
l√∂yt√§√§
&gt;&gt;&gt; print(json.dumps(json.loads(r'"l\u00f6yt\u00e4\u00e4"')))
"l\u00f6yt\u00e4\u00e4"
&gt;&gt;&gt; print(json.dumps(json.loads(r'"l\u00f6yt\u00e4\u00e4"'), ensure_ascii=False))
"l√∂yt√§√§"
</code></pre>
<p>If you have extremely large documents, you <em>could</em> still process them textually, line by line, but use regular expressions to do the replacements:</p>
<pre><code>import re

unicode_escape = re.compile(
    r'(?&lt;!\\)'
    r'(?:\\u([dD][89abAB][a-fA-F0-9]{2})\\u([dD][c-fC-F][a-fA-F0-9]{2})'
    r'|\\u([a-fA-F0-9]{4}))')
def replace(m):
    return bytes.fromhex(''.join(m.groups(''))).decode('utf-16-be')

with open("input.json", "r", encoding="utf-8") as input:
    with open("output.txt", "w", encoding="utf-8") as output:
        for line in input:
            output.write(unicode_escape.sub(replace, line))
</code></pre>
<p>This however fails if your JSON has embedded JSON documents in strings or if the escape sequence is preceded by an <em>escaped</em> backslash.</p>
</div>
<span class="comment-copy">use encoding = "UTF-16", or "UTF-16LE", should do the trick.</span>
<span class="comment-copy">@AndoJurai: no, it does <i>not</i> do the trick. The data contains JSON escape sequences, not UTF-16 data.</span>
<span class="comment-copy">OK, thanks, I learned something. I merely expected a well known standard to abide by rules of usual encoding. Funny it has it's own encoding for unusual character. Can't it be processed through the "encoding" parameter given adequate input, or is your proposed solution the only one?</span>
<span class="comment-copy">great, thx for ur good solution ;-) but can u think of any other way that does not need to process the textual files? or maybe processing them faster? I did what you said and since I am doing this on really large json files , its too slow.</span>
<span class="comment-copy">@Pedram: I added a line-by-line replacement  option. It'll work <i>up to a point</i>.</span>
<span class="comment-copy">Are you sure the line-by-line solution works properly with characters that require surrogate points? Eg. "ü•ù", which is represented in JSON as <code>"\\ud83e\\udd5d"</code>. (Or is that what you mean by "up to a point"?)</span>
<span class="comment-copy">@lenz: Yeah, that's one of them. You'd have to add a separate regex that's applied first that looks for surrogate pairs and decodes that as a series of UTF-16 bytes.</span>
<span class="comment-copy">@lenz: updated to handle surrogates.</span>
