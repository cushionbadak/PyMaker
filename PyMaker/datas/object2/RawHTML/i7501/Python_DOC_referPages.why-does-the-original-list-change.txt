<div class="post-text" itemprop="text">
<p>Running this:</p>
<pre><code>a = [[1], [2]]
for i in a:
    i *= 2
print(a)
</code></pre>
<p>Gives</p>
<pre><code>[[1, 1], [2, 2]]
</code></pre>
<p>I would expect to get the original list, as happens here:</p>
<pre><code>a = [1, 2]
for i in a:
    i *= 2
print(a)
</code></pre>
<p>Which gives:</p>
<pre><code>[1, 2]
</code></pre>
<p>Why is the list in the first example being modified?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using <a href="https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow noreferrer"><em>augmented assignment</em> statements</a>. These operate on the object named on the left-hand side, giving that object the opportunity to update <em>in-place</em>:</p>
<blockquote>
<p>An augmented assignment expression like x += 1 can be rewritten as x = x + 1 to achieve a similar, but not exactly equal effect. In the augmented version, x is only evaluated once. <strong>Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.</strong></p>
</blockquote>
<p>(bold emphasis mine).</p>
<p>This is achieved by letting objects implement <code>__i[op]__</code> methods, for <code>=*</code> that's the <a href="https://docs.python.org/3/reference/datamodel.html#object.__imul__" rel="nofollow noreferrer"><code>__imul__</code> hook</a>:</p>
<blockquote>
<p>These methods are called to implement the augmented arithmetic assignments (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>@=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, <code>**=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>). <strong>These methods should attempt to do the operation in-place (modifying <code>self</code>) and return the result (which could be, but does not have to be, <code>self</code></strong>).</p>
</blockquote>
<p>Using <code>*=</code> on a list multiplies <em>that list object</em> and returns the same list object (<code>self</code>) to be 'assigned' back to the same name.</p>
<p>Integers on the other hand are immutable objects. Arithmetic operations on integers return <em>new</em> integer objects, so <code>int</code> objects do not even implement the <code>__imul__</code> hook; Python has to fall back to executing <code>i = i * 3</code> in that case. </p>
<p>So for the first example, the code:</p>
<pre><code>a = [[1], [2]]
for i in a:
    i *= 2
</code></pre>
<p>really does this (with the loop unrolled for illustration purposes):</p>
<pre><code>a = [[1], [2]]
i = a[0].__imul__(2)  # a[0] is altered in-place
i = a[1].__imul__(2)  # a[1] is altered in-place
</code></pre>
<p>where the <code>list.__imul__</code> method applies the change to the list object itself, <em>and</em> returns the reference to the list object.</p>
<p>For integers, this is executed instead:</p>
<pre><code>a = [1, 2]
i = a[0] * 2  # a[0] is not affected
i = a[1] * 2  # a[1] is not affected
</code></pre>
<p>So now the <em>new</em> integer objects are assigned to <code>i</code>, which is independent from <code>a</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason your results are different for each example is because <strong>list are mutable</strong>, <strong>but integers are not</strong>.</p>
<p>That means when you you modify an integer object in place, the operator must return a new integer object. However, since list are mutable, the changes are simply added to already existing list object.</p>
<p>When you used <code>*=</code> in the for-loop in the first example, Python modify the already existing list. But when you used <code>*=</code> with the integers, a new integer object had to be returned.</p>
<p>This can also be observed with a simple example:</p>
<pre><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; b = [1]
&gt;&gt;&gt; 
&gt;&gt;&gt; id(a)
1505450256
&gt;&gt;&gt; id(b)
52238656
&gt;&gt;&gt; 
&gt;&gt;&gt; a *= 1
&gt;&gt;&gt; b *= 1
&gt;&gt;&gt; 
&gt;&gt;&gt; id(a)
1505450256
&gt;&gt;&gt; id(b)
52238656
&gt;&gt;&gt;
</code></pre>
<p>As you can see above, the memory address for <code>a</code> changed when we multiplied it in-place. So <code>*=</code> returned a new object. But the memory for the list did not change. That means <code>*=</code> modified the list object in-place.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first case your <code>i</code> in the <code>for</code> loop is a <code>list</code>. So you're telling python hey, take the <code>ith</code> list and repeat it twice. You're basically repeating the list 2 times, this is what the <code>*</code> operator does to a list.<br/>In the second case your <code>i</code> is a value, so you're applying <code>*</code> to a value, not a list.  </p>
</div>
<span class="comment-copy">Because you multiplied the nested list objects, which are mutable and are <i>updated in-place</i>. The second example multiplied integers, which are immutable, so can't be updated in-place and a new integer is returned.</span>
<span class="comment-copy">@MartijnPieters That they are mutable is clear, that they are updated in-place needs explanation</span>
<span class="comment-copy">@mpf82 not duplicate: I need to know what in-place updating means</span>
<span class="comment-copy">Test the following: <code>for i in a: print(hex(id(i)))</code>, notice the addresses. Now do this: <code>for i in a: i *= 2; print(hex(id(i)))</code>. Compare the addresses. You will realize that in the case where the elements are immutable (integers), the addresses change, whereas in the case where the elements are mutable (lists) the addresses are the same. That's why the elements are modified in one case but not the other: when mutable the same object is returned, when immutable, it's a copy in a different address, so modifying it will not modify the original.</span>
<span class="comment-copy">Lists are mutable; ints are not. The <code>*=</code> operator on a list mutates the list. The <code>*=</code> operator on an int returns a new int (which is assigned the the variable on the left side of the operator).</span>
<span class="comment-copy">Amazing, thanks!</span>
<span class="comment-copy">I do not need to know what those operations do. I need to know why the original list is modified.</span>
<span class="comment-copy">@dangonfast Then why are you asking this question? Perhaps there's a larger overarching reason you're trying to do this that you need answered?</span>
<span class="comment-copy">@J0hn I never asked what the operations do, just why the list is modified. The operation is completely irrelevant to the question.</span>
<span class="comment-copy">I see your point now, and I think the answer you're looking for can be found in Martijn Pieters and dabadaba comments.</span>
