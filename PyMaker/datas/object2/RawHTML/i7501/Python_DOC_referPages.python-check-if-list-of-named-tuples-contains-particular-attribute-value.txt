<div class="post-text" itemprop="text">
<p>I have a list of named tuples:</p>
<pre><code>from collections import namedtuple

T = namedtuple('T', ['attr1', 'attr2', 'attr3', 'attr4'])
t1 = T('T1', 1, '1234', 'XYZ')
t2 = T('T2', 2, '1254', 'ABC')
t3 = T('T2', 2, '1264', 'DEF')
l = [t1, t2, t3]
</code></pre>
<p>I want to check if an element exists in the list <code>T</code> where <code>attr1 = 'T2'</code>.</p>
<p>Checking if the list contains such an element by doing:</p>
<pre><code>any(x for x in l if x.attr1 == 'T2')
</code></pre>
<p>only returns the information whether such a namedtuple is in the list or not.<br/>
I would like to also pop this namedtuple from the list.<br/>
One way of doing it is:</p>
<pre><code>if any(x for x in l if x.attr1 == 'T2'):
   result = [x for x in l if x.attr1 == 'T2'].pop()
</code></pre>
<p>However, I don't like this solution, since I'm looping over the list <code>l</code> twice.</p>
<p>Is there any better/more-elegant way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about an old-school for loop? Simple, elegant, and you loop only once.</p>
<pre><code>for x in l:
    if x.attr1 == 'T2':
        break

result = x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need one item and don't necessarily want to pop, you can use <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> with your existing generator expression:</p>
<pre><code>result = next(x for x in l if x.attr1 == 'T2')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or you can use <code>next</code>:</p>
<pre><code>try:
    result = next(t for t in l if t.attr1 == 'T2')
except StopIteration:
    result = None

result
# T(attr1='T2', attr2=2, attr3='1254', attr4='ABC')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If it is allowed to get the result as an array:</p>
<pre><code>result = filter(lambda x: x.attr1 == 'T2', l)
</code></pre>
<p>Or if you just want to get one then:</p>
<pre><code>result = filter(lambda x: x.attr1 == 'T2', l).pop()
</code></pre>
</div>
<span class="comment-copy">Not directly an answer, but the usual <code>any</code> expression for testing the existence of such an element would be <code>any(x.attr1 == 'T2' for x in l)</code>, not what you have. What you're doing is unintentionally relying on the fact that your namedtuples are considered true when treated as booleans. In fact, the genexp you've written is more appropriate for extracting a matching namedtuple than for testing existence!</span>
<span class="comment-copy">Same as <code>result = next((t for t in l if t.attr1 == 'T5'), None)</code>, only longer. Using bare <code>except</code> is a bad idea, too.</span>
<span class="comment-copy">@Psidom I downvoted it mainly because your answer was teaching bad practice (bare <code>except</code>).</span>
