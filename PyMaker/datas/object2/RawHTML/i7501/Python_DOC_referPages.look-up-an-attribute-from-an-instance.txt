<div class="post-text" itemprop="text">
<p>From Python in a Nutshell</p>
<blockquote>
<p><strong>Getting an attribute from an instance</strong></p>
<p>When you use the syntax  <code>x.name</code>  to refer to an attribute of
  instance  <code>x</code>  of class  <code>C</code> , the lookup proceeds in three steps:</p>
<ol>
<li><p><em>When  <code>name</code>  is found in  <code>C</code>  (or in one of  <code>C</code>’s ancestor classes) as the name of an overriding descriptor  <code>v</code>  (i.e., 
  <code>type(v)</code>  supplies methods  <code>__get__</code> and  <code>__set__</code> )</em></p>
<p>• <em>The value of  <code>x.name</code>  is the result of  <code>type(v).__get__(v, x, C)</code></em></p></li>
<li><p>Otherwise, when  <code>name</code>  is a key in  <code>x.__dict__</code></p>
<p>• <code>x.name</code>  fetches and returns the value at  <code>x.__dict__['name']</code></p></li>
<li><p>Otherwise,  <code>x.name</code>  delegates the lookup to  <code>x</code>’s class (according to the same two-step lookup used for  <code>C.name</code>, as just
  detailed)</p>
<p>• <em>When a descriptor  <code>v</code>  is found, the overall result of the
  attribute lookup is, again,  <code>type(v).__get__(v, x, C)</code></em></p>
<p>• When  a  nondescriptor  value  <code>v</code>   is  found,  the  overall 
  result  of  the  attribute lookup is just  <code>v</code></p></li>
</ol>
<p>When these lookup steps do not find an attribute, Python raises an  <code>AttributeError</code> exception. However, for lookups of  <code>x.name</code> , when  <code>C</code>  defines or inherits the special
  method  <code>__getattr__</code> , Python calls  <code>C.__getattr__(x,'name')</code>  rather than raising
  the exception. It’s then up to  <code>__getattr__</code>  to either return a suitable value or raise
  the appropriate exception, normally  <code>AttributeError</code> .</p>
</blockquote>
<ol>
<li><p>Are step 1 and the first part of step 3 the same? If yes, why does the same step appear twice?</p></li>
<li><p>Do they both happen <em>"when <code>name</code> is found in <code>C</code> (or in one of <code>C</code>’s ancestor classes) as the name of an overriding descriptor  <code>v</code>"</em>?</p></li>
</ol>
<hr/>
<blockquote>
<pre><code>__getattribute__(self, name) 
</code></pre>
<p>At every request to access attribute <code>x.y</code>, Python calls
  <code>x.__getattribute__('y')</code>, which must get and return the attribute
  value or else raise <code>AttributeError</code>. The normal semantics of
  attribute access (using <code>x.__dict__</code>, <code>C.__slots__</code>, <code>C</code>’s class
  attributes, <code>x.__getattr__</code>) are all due to <code>object.__getattribute__</code>.
  When class <code>C</code> overrides <code>__getattribute__</code>, it must implement all of
  the attribute access semantics it wants to offer. Most often, the most
  convenient way to implement attribute access semantics is by
  delegating (e.g., calling <code>object.__getattribute__(self, ...)</code> as part
  of the operation of your override of <code>__getattribute__</code>).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Are step 1 and the first part of step 3 the same? If yes, why the same step appear twice?</p>
</blockquote>
<p>Step 1 requires both <code>__get__</code> and <code>__set__</code> (although actually, either <code>__set__</code> or <code>__delete__</code> along with <code>__get__</code> would trigger it). Step 3 happens unconditionally if the attribute isn't found through steps 1 or 2.</p>
<blockquote>
<p>Do they both happen "when  name is found in  C (or in one of  C’s ancestor classes) as the name of an overriding descriptor  v"?</p>
</blockquote>
<p>No. An "overriding descriptor" triggers step 1; another kind of descriptor or a non-descriptor will only be considered in step 3. (The official Python docs don't use the term "overriding descriptor"; they refer to a descriptor with <code>__set__</code> or <code>__delete__</code> as a "data descriptor", and if a data descriptor has <code>__get__</code>, the <code>__get__</code> will take priority over an object found in an instance dict.)</p>
</div>
<span class="comment-copy">Thanks. What do "overriding" and "nonoverriding" mean when they qualify "descriptor"?</span>
<span class="comment-copy">@Tim: They're just referring to whether it overrides a value found in the instance dict.</span>
<span class="comment-copy">Thanks. (1) Is "either <code>__set__</code> or <b><code>__delete__</code></b> along with <code>__get__</code> would trigger it" mentioned in some documents?  (2) In " if a data descriptor has <code>__get__</code>, the <code>__get__</code> will take priority over an object found in an instance dict", do you mean <code>__set__</code> instead of <code>__get__</code>?</span>
<span class="comment-copy">@Tim: <a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#invoking-descriptors</a>, and no, I mean <code>__get__</code>.</span>
<span class="comment-copy">From the same docs link: "In general, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol: <code>__get__()</code>, <code>__set__()</code>, and <code>__delete__()</code>. If <b>any</b> of those methods are defined for an object, it is said to be a descriptor."</span>
