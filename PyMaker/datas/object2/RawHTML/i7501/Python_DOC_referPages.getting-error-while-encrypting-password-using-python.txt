<div class="post-text" itemprop="text">
<p>I am getting the following error while encrypting the password using <code>bz2</code> module using Python. Here I am saving that encrypted value inside DB. </p>
<p>Error:</p>
<pre><code>ProgrammingError at /signsave/
You must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings.
Request Method: POST
Request URL:    http://127.0.0.1:8000/signsave/
Django Version: 1.11.2
Exception Type: ProgrammingError
Exception Value:    
You must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings.
</code></pre>
<p>I am explaining my code below.</p>
<pre><code>def signsave(request):
    """This function helps to save signup data"""

    if request.method == 'POST':
        name = request.POST.get('uname')
        password = request.POST.get('pass')
        con_pass = request.POST.get('conpass')
        new_pass = bz2.compress(password) 
        if password == con_pass:
            passw = User(
                uname=name,
                password=new_pass,
                raw_password=password,
            )
            passw.save()
            message = "Registered successfully"
            return render(request, 'bookingservice/login.html', {'msg': message})
        else:
            message = "The password did not match "
            return render(request, 'bookingservice/signup.html', {'msg': message})
</code></pre>
<p>Here when I am trying to save the encrypted value those errors are coming. </p>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't use <code>bz2</code> for anything but compression. Use built-in <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer"><code>hashlib</code></a> module instead.</p>
<p>Replace <code>bz2.compress(password</code> with <code>hashlib.sha256(str.encode(password)).digest()</code>. You'll get a SHA256 hash of your password string, which you can check against other string's hashes, proving their validity.</p>
</div>
<span class="comment-copy">bz2 is a compression algorithm not an encryption algorithm. The passwords are effectively still stored in plaintext.</span>
<span class="comment-copy">I think the problem is mostly that you use bz2 to compress (not encrypt) password. Passwords are usually hashed, then salted instead. This is a "destructive" process, as in once the password is processed, you can check easily if another input matches the password, but it is close to impossible to recover the password. Compression is a definitive no, encryption could be ok, hashing + salting is the recommended way</span>
<span class="comment-copy">Can you give any idea about easy encryption algorithm.</span>
<span class="comment-copy">@AnthonyRossi "hashing, then salting" is no longer sufficient. This is not secure, <b>do not do this</b>.</span>
<span class="comment-copy">Iterate over an HMAC with a random salt for about a 100ms duration and save the salt with the hash. Use a function such as <code>PBKDF2</code>, <code>Rfc2898DeriveBytes</code>, <code>Bcrypt</code> or similar functions. <code>PBKDF2</code> is the NIST approved method for password verifiers. The point is to make the attacker spend a lot of time finding passwords by brute force.</span>
<span class="comment-copy">This is <b>not secure</b>, do not do this. Just using a hash function is not sufficient and just adding a salt does little to improve the security. See the comment to the question for more information.</span>
