<div class="post-text" itemprop="text">
<p>I have command line arguments in a string and I need to split it to feed to <code>argparse.ArgumentParser.parse_args</code>.</p>
<p>I see that <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">the documentation</a> uses <code>string.split()</code> plentifully. However in complex cases, this does not work, such as</p>
<pre><code>--foo "spaces in brakets"  --bar escaped\ spaces
</code></pre>
<p>Is there a functionality to do that in python?</p>
<p>(<em>A similar question for java was asked <a href="https://stackoverflow.com/questions/29162368/how-to-split-string-to-arguments-like-shell">here</a></em>).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what <a href="https://docs.python.org/3/library/shlex.html#shlex.split" rel="noreferrer"><code>shlex.split</code> was created for</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're parsing a windows-style command line, then <code>shlex.split</code> doesn't work correctly - calling <code>subprocess</code> functions on the result will not have the same behavior as passing the string directly to the shell.</p>
<p>In that case, the most reliable way to split a string like the command-line arguments to python is... to pass command line arguments to python:</p>
<pre class="lang-py prettyprint-override"><code>import sys
import subprocess
import shlex
import json  # json is an easy way to send arbitrary ascii-safe lists of strings out of python

def shell_split(cmd):
    """
    Like `shlex.split`, but uses the Windows splitting syntax when run on Windows.

    On windows, this is the inverse of subprocess.list2cmdline
    """
    if os.name == 'posix':
        return shlex.split(cmd)
    else:
        # TODO: write a version of this that doesn't invoke a subprocess
        if not cmd:
            return []
        full_cmd = '{} {}'.format(
            subprocess.list2cmdline([
                sys.executable, '-c',
                'import sys, json; print(json.dumps(sys.argv[1:]))'
            ]), cmd
        )
        ret = subprocess.check_output(full_cmd).decode()
        return json.loads(ret)
</code></pre>
<p>One example of how these differ:</p>
<pre class="lang-py prettyprint-override"><code># windows does not treat all backslashes as escapes
&gt;&gt;&gt; shell_split(r'C:\Users\me\some_file.txt "file with spaces"', 'file with spaces')
['C:\\Users\\me\\some_file.txt', 'file with spaces']

# posix does
&gt;&gt;&gt; shlex.split(r'C:\Users\me\some_file.txt "file with spaces"')
['C:Usersmesome_file.txt', 'file with spaces']

# non-posix does not mean Windows - this produces extra quotes
&gt;&gt;&gt; shlex.split(r'C:\Users\me\some_file.txt "file with spaces"', posix=False)
['C:\\Users\\me\\some_file.txt', '"file with spaces"']  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://github.com/pallets/click/blob/master/click/parser.py#L97" rel="nofollow noreferrer"><code>split_arg_string</code></a> helper function from the <a href="http://click.pocoo.org/" rel="nofollow noreferrer"><code>click</code></a> package:</p>
<pre><code>import re

def split_arg_string(string):
    """Given an argument string this attempts to split it into small parts."""
    rv = []
    for match in re.finditer(r"('([^'\\]*(?:\\.[^'\\]*)*)'"
                             r'|"([^"\\]*(?:\\.[^"\\]*)*)"'
                             r'|\S+)\s*', string, re.S):
        arg = match.group().strip()
        if arg[:1] == arg[-1:] and arg[:1] in '"\'':
            arg = arg[1:-1].encode('ascii', 'backslashreplace') \
                .decode('unicode-escape')
        try:
            arg = type(string)(arg)
        except UnicodeError:
            pass
        rv.append(arg)
    return rv
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; print split_arg_string('"this is a test" 1 2 "1 \\" 2"')
['this is a test', '1', '2', '1 " 2']
</code></pre>
<p>The <code>click</code> package is starting to dominate for command-arguments parsing, but I don't think it supports parsing arguments from string (only from <code>argv</code>). The helper function above is used only for <code>bash</code> completion.</p>
<p><strong>Edit</strong>: I can nothing but recommend to use the <a href="https://docs.python.org/3/library/shlex.html#shlex.split" rel="nofollow noreferrer"><code>shlex.split()</code></a> as suggested in the answer by @ShadowRanger. The only reason I'm not deleting this answer is because it provides <em>a little bit faster splitting</em> then the full-blown pure-python tokenizer used in <code>shlex</code> (around 3.5x faster for the example above, 5.9us vs 20.5us). However, this shouldn't be a reason to prefer it over <code>shlex</code>.</p>
</div>
<span class="comment-copy">what should be the ouput exactly of <code>argparse.ArgumentParser.parse_args</code></span>
<span class="comment-copy">You need to show us a full program that demonstrates the specific problem you are having, with example input that triggers it.</span>
<span class="comment-copy">Nice! And it's available since Python 2.3.</span>
<span class="comment-copy">Does <code>shlex.split</code> have an issue with escaped quote marks? e.g <code>--foo "bar\"baz"</code></span>
<span class="comment-copy">@user1735003: Yes, though it would usually be the shell handling this for you (<code>shlex</code> follows mostly the same rules as <code>sh</code> shell rules). But if you have a constructed command line like that, it's fine with it, that's the whole point of <code>shlex</code>: <code>shlex.split(r'--foo "bar\"baz"')</code> produces <code>['--foo', 'bar"baz']</code>. The <code>argparse</code> docs are <a href="https://bugs.python.org/issue20598" rel="nofollow noreferrer">being lazy</a> when they use <code>str.split</code> instead of <code>shlex.split</code> (or explicit lists); they were going for brevity, but without the mental load of requiring <code>shlex</code> knowledge.</span>
<span class="comment-copy">This works great for POSIX systems, but doesn't help if you want to split arguments from a windows format.</span>
<span class="comment-copy">@Eric: Given there is no single Windows format (Windows executables receive the raw string and parse it themselves), and that the question was about parsing a string for <code>argparse</code> to work with (which has a fixed behavior regardless of OS), your comment doesn't seem particularly relevant to this case.</span>
