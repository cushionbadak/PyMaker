<div class="post-text" itemprop="text">
<p>I am curious how often a file would actually be loaded into memory when its needed from a module.  Here is the scenario:</p>
<p><em>lookup.py</em></p>
<pre><code>import json

mapping_dict = json.load(open('map.json'))

def map_file(file_name):
    return(mapping_dict[file_name])

def other_function():
    --do something--
</code></pre>
<p><em>main.py</em></p>
<pre><code>import lookup

--something something--

for f in files:
    print(lookup.map_file(f))
</code></pre>
<p>So my question is how many times is mapping_dict from lookup.py loaded?  Once upon the initial import?  Every time map_file is called? Every time any function in lookup.py is called (map_file and other_function in this case).</p>
<p>Some combination of the above? </p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure if the other answers are terribly clear about this, so let me post something else that may (or may not) help. Here is what effectively happens, under normal circumstances, when you import a module:</p>
<ul>
<li>Python looks in <code>sys.modules</code> (which is basically a <code>dict</code>) for an entry with the name of the module being imported. If it finds something, it takes that object, creates a variable corresponding to the module's name, and assigns the object to the variable.</li>
<li>If it doesn't find an object in <code>sys.modules</code>, it creates an object to represent that module and puts it in <code>sys.modules</code> under the appropriate name. Then it looks up the file that contains the module's source code, runs that file as a Python script (ish), and then scoops up all the variable definitions that exist afterward and assigns them as attributes of the new module object.</li>
</ul>
<p>Note that this means the code in the file only gets executed once, when the module is first imported.</p>
<p>Let's see how this works in practice, in your example. Python is happily running the code in <code>main.py</code> and it encounters</p>
<pre><code>import lookup
</code></pre>
<p>"OK (says Python), let's go to <code>sys.modules</code> and see if anything is stored under the name <code>lookup</code>. [...checking...] No, there is nothing stored under that name. Time to find <code>lookup.py</code> (using <code>sys.path</code>)."</p>
<p>Python creates a new, empty module object and puts it in <code>sys.modules</code> under the name <code>lookup</code>. Then it opens the file <code>lookup.py</code> and starts running code from it.</p>
<pre><code>import json
</code></pre>
<p>Python now looks in <code>sys.modules</code> under the name <code>json</code>. It will go through this whole procedure recursively, but I'll skip going into details and just jump ahead to where we have a fully loaded module object in <code>sys.modules</code> under the key <code>json</code>. Then Python assigns that object to the name <code>json</code> in the current scope (effectively, it does <code>json = sys.modules['json']</code>).</p>
<pre><code>mapping_dict = json.load(open('map.json'))
</code></pre>
<p>Python now loads the JSON file. I'm skipping over most of the details, but it involves accessing the <code>json</code> variable in the current scope (which, remember, refers to a module object) and taking the <code>load</code> attribute of that object, and then calling it. The thing that comes out of that call gets put into another variable in the current scope, <code>mapping_dict</code>.</p>
<pre><code>def map_file(file_name):
    return(mapping_dict[file_name])
</code></pre>
<p>Python now sees <code>def</code> and temporarily stops <em>executing</em>; instead, it reads a block of code, compiles it into bytecode, and sticks that bytecode into a function object. That function object gets assigned to the variable <code>map_file</code> in the current scope. Then, back to executing.</p>
<pre><code>def other_function():
    --do something--
</code></pre>
<p>Again, Python stops <em>executing</em> and reads a block of code, compiles it into bytecode, and sticks that bytecode into a function object which gets assigned to the variable <code>other_function</code>.</p>
<p>Now we are at the end of the file <code>lookup.py</code>. We have four variables in the current scope: <code>json</code>, <code>mapping_dict</code>, <code>map_file</code>, and <code>other_function</code>. Python assigns these four variables as attributes of the module object. Remember, the module object is stored in <code>sys.modules</code> under the key <code>lookup</code>, so now <code>sys.modules['lookup']</code> is an object with the four attributes <code>json</code>, <code>mapping_dict</code>, <code>map_file</code>, and <code>other_function</code>.</p>
<p>Time to go back to <code>main.py</code>, where we are still finishing up the <code>import lookup</code> statement. The last thing this statement does is to assign the value of <code>sys.modules['lookup']</code> to a variable in the current scope called <code>lookup</code>. (Effectively, <code>lookup = sys.modules['lookup']</code>.) Again, that object has four attributes, as previously described.</p>
<p>Moving on to</p>
<pre><code>for f in files:
    print(lookup.map_file(f))
</code></pre>
<p>On each iteration through that loop, Python accesses the <code>lookup</code> variable, which refers to a module object, then accesses the <code>map_file</code> attribute of that object, which is a function object that basically just contains a bunch of bytecode. Python then calls the function object, which actually executes the bytecode - and remember, this is the code that was inside the <code>def map_file(...)</code> definition, which was <em>not</em> executed at the time the <code>lookup</code> module was loaded. Only now does it get executed.</p>
<p>All that code does is access <code>mapping_dict[file_name]</code> and return it. <code>mapping_dict</code> is simply a variable that refers to an existing object; presumably a <code>dict</code>. So accessing <code>mapping_dict[file_name]</code> simply checks in the <code>dict</code> to see if it has an entry with key corresponding to the value of <code>file_name</code>, and if so, returns it. Accessing this entry doesn't open any files or do anything complicated. In particular, it does <em>not</em> run <code>json.load(open('map.json'))</code>, because that bit of code is not part of the function. That bit of code was run long ago, when <code>lookup</code> was imported, and was not saved for running again, so it will not run again under normal circumstances.</p>
</div>
<div class="post-text" itemprop="text">
<p>Each module is loaded only once. The import statement first checks if the module exists in <code>sys.modules</code>, if it is, it just performs a dictionary lookup. If the item is not found, it loads the module. You can force module re-importation using <code>reload</code> (Python-2 only) or by deleting the entry in <code>sys.modules</code> (this is a bit of a hack).</p>
<pre><code>In [1]: import sys as s1

In [2]: s1.modules['sys']
Out[2]: &lt;module 'sys' (built-in)&gt;

In [3]: del s1.modules['sys']

In [4]: id(s1)            # different than s2 and s3
Out[4]: 140359411362736

In [5]: import sys as s2  # same as s3

In [6]: id(s2)
Out[6]: 140359175854240

In [7]: s1 == s2
Out[7]: False

In [8]: s2
Out[8]: &lt;module 'sys' (built-in)&gt;

In [9]: import sys as s3

In [10]: id(s3)
Out[10]: 140359175854240
</code></pre>
<p>Please note that reloading a given module will not reload any of the libraries it imports (Python2-only below, in Python3, you can use <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">importlib.reload</a>):</p>
<pre><code>&gt;&gt;&gt; import sysconfig
&gt;&gt;&gt; s = reload(sysconfig)
&gt;&gt;&gt; id(sysconfig) == id(s)
False
&gt;&gt;&gt; id(sysconfig.sys) == id(s.sys)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As answered in the comments, but I'll expand a bit on it to really show why.</p>
<p>The question is, how many times do we load the JSON file (line 3 from <code>lookup.py</code>)</p>
<p>When <code>lookup</code> is imported, assuming there is no <code>if __name__ == 'main'</code> guard around it, <code>mapping_dict</code> (an object) is set to the contents of the json file. As well, the functions defined are each set assigned to a function object. You can test this by typing the function name without the parentheses at the end. You should see a memory pointer corresponding to the object</p>
<p>From there on, unless lookup.py is re-imported, mapping_dict is never reassigned or updated. Referencing the functions references the objects they were assigned to.</p>
</div>
<span class="comment-copy">Exactly once (initial import)</span>
<span class="comment-copy">initial import evaluates the file (module), it doesn't execute functions but they are loaded, however declarations like <code>a=100</code>  or calls to functions (<code>print('something')</code>) are executed</span>
<span class="comment-copy">@PRMoureu That's not quite correct. Every code that is in the module level (read as "outside a function / class") is executed upon importing the module, regardless of being assignments or execution of functions</span>
<span class="comment-copy">Thanks.  This helps me understand what is happening in the background the best.</span>
<span class="comment-copy">I dont quite understand the entirety of that, but it seems like its only loaded once, which means continued references to it wont negatively impact performance, which was my concern.</span>
<span class="comment-copy">@tormond, unless you explicitly <b>try</b> to import it more than once, each module or package is imported only once. So yes, you are correct.</span>
