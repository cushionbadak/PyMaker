<div class="post-text" itemprop="text">
<p>I need to optimize this code, that basically checks if every character of string <code>s1</code> is contained in <code>s2</code>, taking in consideration doubles.</p>
<pre><code>s1, s2 = list(s1), list(s2)
for s in s2:
    if s in s1:
        s1.remove(s)
    else:
        return False
return True
</code></pre>
<p>I did some research on <code>map</code>, iterators and generators, and I'm sure in one or more of these there is a solution, but right now I'm pretty confused and frustrated (I'm very new to python, just a couple weeks), so maybe you can help me understand what's the best strategy in this case. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> that will handle duplicated characters correctly:</p>
<pre class="lang-py prettyprint-override"><code>from collections import Counter
c1 = Counter(s1)
c2 = Counter(s2)
return all(c2[c]&gt;=c1[c] for c in c1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can count the number of occurrences of each character in both strings. You also don't need to make either string a list: strings are their own iterators.</p>
<p>First, create a <code>set</code> as sets have an average lookup of <code>O(1)</code>.
Then, iterate through the set and get the counts of each character. If any counts aren't equal, <code>return False</code>. It also scales much better as the size of the string grows, than your current solution:</p>
<pre><code>s1 = 'Stack Overflow'
s2 = 'woltk fcrSeavO'

def equal_chars(s1, s2):
    chars = set(s2)
    for char in chars:
        if s1.count(char)!= s2.count(char):
            return False
    return True

print(equal_chars(s1, s2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hmm... you could keep <code>s1</code> and <code>s2</code> as strings and then use the <code>replace</code> function:</p>
<pre><code>for c in s2:
    if c in s1:
        s1 = s1.replace(c, '', 1)
    else:
        return False

return True
</code></pre>
<p><code>str.replace(.., .., 1)</code> removes <em>only the first</em> occurrence of that character.</p>
</div>
<div class="post-text" itemprop="text">
<p>A slight adjustment on Adrien's great answer which is (maybe?) more efficient:</p>
<pre><code>from collections import Counter

s1 = "hello"
s2 = "helo"

def count_chars(s1,s2):
    c2 = Counter(s2)
    for k,v in Counter(s1).items():
        if c2[k] &lt; v:
            return False
    return True

print (count_chars(s1,s2))
</code></pre>
<p>result:</p>
<pre><code>False
</code></pre>
</div>
<span class="comment-copy">I'm not sure if this is the case. The <code>s1.remove(s)</code> is there only to avoid errors on duplicate chars. For example if <code>s1='aabcd'</code> and <code>s2='aaa'</code> will return <code>True</code> while it is false. How a list1 - list2 would help me? If I've got this wrong please explain me</span>
<span class="comment-copy">It is not clear what exactly your expected output is. Please show a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">Don't know the implementation of <code>in</code> in python, wouldn't this code lead to O(n^2) worst case?  nlogn solution would be to sort and check if they are equal.</span>
<span class="comment-copy">You don't want to use <code>&gt;=</code>, you only want <code>==</code>. Other than that, good answer!</span>
<span class="comment-copy">This is a good one, thanks! Is not <code>c2[c]&gt;=c1[c]</code> but <code>c1[c]&gt;=c2[c]</code> but yeah, great answer</span>
<span class="comment-copy">@NoticeMeSenpai If s1 and s2 should contain exactly the same characters, then you're right, <code>==</code> should be used.  Otherwise, we may argue that it is not necessary to read s2 completely, and we could optimize further (especially if s2 is significantly longer than s1).</span>
<span class="comment-copy">@AdrienMatissart what precisely happens if c2[c] doesn't exist? does it break and return False at that point or does it create c2[c] and set it to 0?</span>
<span class="comment-copy">Counter values defaults to 0. See the second block on <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.Counter</a></span>
<span class="comment-copy">I cannot use <code>str.replace</code> because it removes all occurrences, while I need to handle duplicates correctly</span>
<span class="comment-copy">@AndTuf Edited.</span>
<span class="comment-copy">Oh, my bad then, good to know</span>
