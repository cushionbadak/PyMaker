<div class="post-text" itemprop="text">
<p>I am loading data(20 elements) to another file on load...here I want to sort these 20 elements according to timestamp I am using in list element.     </p>
<pre><code>import json
from collections import OrderedDict
import datetime
import os

if os.path.exists("qwerty.json"):
    record = json.load(open("qwerty.json", "r"), object_pairs_hook=OrderedDict)
else:
    record = OrderedDict({})

fo = open("foo.txt", "wb")
abc = list(record.items())[:20] 
print(abc)

command = ""
while command != 'exit':
    command = input('Enter a command(options: create,read,save): ')
    if command == "create":
        name = input('Enter name of the Student:')
        p = input('Student ID: ')
        a = input('Class: ')
        n = input('Marks: ')
        time = datetime.datetime.now().isoformat()

        record[name] = {'Student ID:': p, 'Class:': a, 'Marks': n, 'time': time }

    elif command == 'read':
        z = json.load(open("qwerty.json", "r"), object_pairs_hook=OrderedDict)
        print(z)

    elif command == 'save':
        json.dump(record, open('qwerty.json', "w"))

fo.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Trivia:</h2>
<p>Since you're using an <code>OrderedDict</code> - your records are already sorted by timestamp (to be honest - they're not, but recordses order is preserved).</p>
<p>The only unexpected behaviour with your code - when you "create" (overwrite) existed one student in line:</p>
<pre><code>record[name] = {'Student ID:': p, 'Class:': a, 'Marks': n, 'time': time }
</code></pre>
<p>And <code>if name in record:</code> already - order is broken, so your idea about sorting isn't a meaningless, but I think, that it's better and more rational to just be sure of the recordses order, than sort records each time.</p>
<h2>Workaround:</h2>
<p>Square brackets after variable name means that this object is <em>subscriptable</em> (for e.g. tuple, list, dict, string and many more). <em>Subscriptable</em> means that this object at least implements the <code>__getitem__()</code> method (and <code>__setitem__()</code> in your case).</p>
<p>First method handles case, when you're trying to pull something from <em>subscriptable</em> object (by index/key/anything) and the second one - when you're trying to overwrite something.</p>
<p>And I suggest to implement such a feature with custom class:</p>
<pre><code>class OrderedTimeDict(OrderedDict):
    def __setitem__(self, key, value):
        if key in self:
            # if key is already exist - move it to the end
            self.move_to_end(key)
        # standard behaviour
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<p>and in your code just use this ordered dictionary instead of base ordered!</p>
<h2>Conclusion:</h2>
<p><em>Pros</em>: No need to sort things, because we keep desired order.</p>
<p><em>Cons</em>: If you're already has "unordered" data - you need to sort it once.</p>
<p>To sort ordered dict by time stamp you can use this function:</p>
<pre><code>def sort_by_timestamp(dict):
    return OrderedDict(sorted(dict.items(), key=lambda get_time_stamp: get_time_stamp[1]['time']))
</code></pre>
<h2>References:</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/216972/in-python-what-does-it-mean-if-an-object-is-subscriptable-or-not">In Python, what does it mean if an object is subscriptable or not?</a></li>
<li><a href="https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes" rel="nofollow noreferrer">OrderedDict Examples and Recipes</a></li>
</ul>
</div>
<span class="comment-copy">And your question isâ€¦?</span>
