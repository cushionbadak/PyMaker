<div class="post-text" itemprop="text">
<p>I have the following C++ class :</p>
<p>.H</p>
<pre><code>class ALabSet: public LabSet {
public:
    PyObject *m_obj;

    ALabSet(PyObject *obj);

    virtual ~ALabSet();

    PyObject *GetPyObj();

};
</code></pre>
<p>.CPP</p>
<pre><code>ALabSet::ALabSet(PyObject *obj): LabSet() {

    this-&gt;m_obj = obj;
    // Provided by "cyelp_api.h"
    if (import_cyelp()) {
    } else {
        Py_XINCREF(this-&gt;m_obj);
    }

}


ALabSet::~ALabSet() {
    Py_XDECREF(this-&gt;m_obj);
}


PyObject *ALabSet::GetPyObj() {
    return this-&gt;m_obj;
}
</code></pre>
<p>I exposed it as follows with Cython :</p>
<pre><code>cdef extern from "adapter/ALabSiteSetsManager.h" namespace "elps" :
    cdef cppclass ALabSet:
        ALabSet(PyObject *)

        PyObject *GetPyObj()



cdef class PyLabSet:
    cdef ALabSet *thisptr

    def __cinit__(self):
       self.thisptr = new ALabSet(&lt;PyObject *&gt;self)

    def __dealloc__(self):
       print "delete from PY !"
       if self.thisptr:
           del self.thisptr
</code></pre>
<p>My problem is that I can't figure out how to get the destructor called from Python. The following does exactly nothing :</p>
<pre><code>a_set = PyLabSet()
del a_set
</code></pre>
<p>I can't find similar issues on the web. Does any of you has an idea of is appening to me here ?</p>
<p>I'm I missing something about reference counting management, or ...</p>
<p>Thanks a lot</p>
</div>
<div class="post-text" itemprop="text">
<p><code>del a_set</code> removes a reference to the object (the local variable). There's still another reference, in the C++ object. This is known as a reference cycle. The cycle GC <em>could</em> collect this after a while. However, there is no guarantee when (or even <strong>if</strong>) this happens, so you should not rely on it<sup>1</sup>.</p>
<p>For example, reference cycles containing pure Python objects with a <a href="http://docs.python.org/3/reference/datamodel.html#object.__del__" rel="nofollow noreferrer"><code>__del__</code></a> special method <a href="https://docs.python.org/3/library/gc.html#gc.garbage" rel="nofollow noreferrer">are documented</a> to not be freed <em>at all</em>:</p>
<blockquote>
<p>Changed in version 3.4: Following PEP 442, objects with a <code>__del__()</code> method donâ€™t end up in <code>gc.garbage</code> anymore.</p>
</blockquote>
<p>I don't know whether <a href="http://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#finalization-method-dealloc" rel="nofollow noreferrer">Cython's implementation of <code>__dealloc__</code></a> triggers this behavior, but as outlined before, destruction isn't deterministic anyway. If you want to free some resource (e.g. a block of memory that isn't a Python object, a file, a connection, a lock, etc.) you should expose an explicit way of doing so manually (cf. the <code>close</code> methods of various objects). Context managers can simplify client code doing this.</p>
<p>Disclaimer: Almost all of this is CPython-specific.</p>
<p><sup>1</sup> Some people prefer thinking of GC as an abstraction that simulates availability of infinite memory, rather than something that destroys unreachable objects. With this approach, it becomes quite obvious that destruction is not deterministic and not even guaranteed.</p>
</div>
<span class="comment-copy">You are creating a reference cycle I think, in <code>self.thisptr = new ALabSet(&lt;PyObject *&gt;self)</code> you are increasing the reference count of your class.</span>
<span class="comment-copy">Yep, magic you ! I removed the additional Py_XINCREF s, and it did the trick. Good thinking. Thanks. Now I do not remember well what I was doing in my constructor. Need to have a look at "import_cyelp()" which is apparently generated by Cython, but I don't know what it does anymore ?</span>
<span class="comment-copy">I encountered a similar issue, because I was creating cyclic references. Solved it by using <a href="https://docs.python.org/3.7/library/weakref.html#weakref.proxy" rel="nofollow noreferrer"><code>weakref.proxy</code></a>, which is nicely described <a href="https://pymotw.com/2/weakref/" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">Relevant: <a href="https://stackoverflow.com/q/9449489/1959808">stackoverflow.com/q/9449489/1959808</a></span>
<span class="comment-copy">Ok, thank for the useful information. I aware of the non-deterministic behaviour, but I had a huge memory leak because the I was creating twice the reference for each object as @Wessie suggested...</span>
<span class="comment-copy">@Golgauth Actually, in most cases being silent about a reference to "break" a cycle is wrong. It means the reference won't keep the object alive, so it may disappear under your feet, and unlike weak references (which are the proper solution if you care enough) you aren't told when it happens and have no way of checking validity of the reference. In your specific case it <i>might</i> be okay, as the lifetimes of the two objects seem to be completely identical. Still, be <i>very</i> careful with this. Keeping the reference cycle (or using a weakref) and offering an explicit disposal mechanism is better.</span>
<span class="comment-copy">Yes your right. I can see that now. When I am using directly the returned object from python (without storing it in a variable - ex : Count(GetPyLabSet()), where GetPyLabSet() returns a PyLabSet object), it's been freed already. It gives a nice crash. It seems that my only alternative is to keep my previous Py_XINCREF and create an additional function to explicitely call Py_XDECREF... Unless one of you has a 3rd solution to my problem. Thanks again.</span>
<span class="comment-copy">I am using <code>PyWeakref_NewRef</code> when keeping the reference to the object, and finally the dealloc is called :) like this <code>this-&gt;m_obj = PyWeakref_NewRef(obj, NULL);</code> I still do the <code>Py_XINCREF</code>.</span>
<span class="comment-copy">just one more thing, for extension classes have to have <code>cdef object __weakref__</code> in the class so that we could create a weakref.</span>
