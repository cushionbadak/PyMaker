<div class="post-text" itemprop="text">
<p><strong>EDIT:</strong> This question is about <em>why</em> the behavior is what it is, not <em>how</em> to get around it, which is what the alleged duplicate is about.</p>
<hr/>
<p>I've used the following notation to create lists of a certain size in different cases. For example:</p>
<pre><code>&gt;&gt;&gt; [None] * 5
[None, None, None, None, None]
&gt;&gt;&gt;
</code></pre>
<p>This appears to work as expected and is shorter than:</p>
<pre><code>&gt;&gt;&gt; [None for _ in range(5)]
[None, None, None, None, None]
&gt;&gt;&gt;
</code></pre>
<p>I then tried to create an list of lists using the same approach:</p>
<pre><code>&gt;&gt;&gt; [[]] * 5
[[], [], [], [], []]
&gt;&gt;&gt;
</code></pre>
<p>Fair enough. It seems to work as expected.</p>
<p>However, while going through the debugger, I noticed that <em>all</em> the sub-list buckets had the same value, even though I had added only a <em>single</em> item. For example:</p>
<pre><code>&gt;&gt;&gt; t = [[]] * 5
&gt;&gt;&gt; t
[[], [], [], [], []]
&gt;&gt;&gt; t[1].append(4)
&gt;&gt;&gt; t
[[4], [4], [4], [4], [4]]
&gt;&gt;&gt; t[0] is t[1]
True
&gt;&gt;&gt;
</code></pre>
<p>I was not expecting all top-level array elements to be references to a <em>single</em> sub-list; I expected 5 <em>independent</em> sub-lists.</p>
<p>For that, I had to write code like so:</p>
<pre><code>&gt;&gt;&gt; t = [[] for _ in range(5)]
&gt;&gt;&gt; t
[[], [], [], [], []]
&gt;&gt;&gt; t[2].append(4)
&gt;&gt;&gt; t
[[], [], [4], [], []]
&gt;&gt;&gt; t[0] is t[1]
False
&gt;&gt;&gt;
</code></pre>
<p>I'm clearly missing something, probably a historical fact or simply a different way in which the consistency here is viewed.</p>
<p>Can someone explain <em>why</em> two different code snippets that one would reasonably expect to be equivalent to each other actually end up implicitly producing different and non-obvious (IMO) results, especially given Python's zen of always being <em>explicit</em> and <em>obvious</em>?</p>
<p>Please note that I'm already aware of <a href="https://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly">this question</a>, which is different to what I'm asking.</p>
<p>I'm simply looking for a detailed explanation/justification. If there're historical, technical, and/or theoretical reasons for this behavior, then please be sure to include a reference or two.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do the following:</p>
<pre><code>[[]]*n
</code></pre>
<p>You are <em>first creating a list</em>, then using the <code>*</code> operator with an <code>int</code> <code>n</code>. This takes whatever objects are in your list, and creates n- many repetitions of it. </p>
<p>But since in Python, explicit is better than implicit, you don't <em>implicitly make a copy of those objects</em>. Indeed, this is consistent with the semantics of Python. </p>
<p><strong>Try to name a single case where Python <em>implicitly</em> makes a copy.</strong></p>
<p>Furthermore, it is consistent with the addition on the list:</p>
<pre><code>l = [1, [], 'a']

l2 = l + l + l

l[1].append('foo')

print(l2)
</code></pre>
<p>And the output:</p>
<pre><code>[1, ['foo'], 'a', 1, ['foo'], 'a', 1, ['foo'], 'a']
</code></pre>
<p>Now, as noted in the comments, coming from C++ it makes sense that the above would be surprising, but if one is used to Python, the above is what one would <em>expect</em>.</p>
<p>On the other hand:</p>
<pre><code>[[] for _ in range(5)]
</code></pre>
<p>Is a list comprehension. It is equivalent to:</p>
<pre><code>lst = []
for _ in range(5):
    lst.append([])
</code></pre>
<p>Here, clearly, every time you are in the loop you create a new list. That is how literal syntax works.</p>
<p>As an aside, I almost never use the <code>*</code> operator on lists, except for one particular idiom I am fond of:</p>
<pre><code>&gt;&gt;&gt; x = list(range(1, 22))
&gt;&gt;&gt; it_by_three = [iter(x)]*3
&gt;&gt;&gt; for a,b,c in zip(*it_by_three):
...    print(a, b, c)
...
1 2 3
4 5 6
7 8 9
10 11 12
13 14 15
16 17 18
19 20 21
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For cpython, the relevant part of the source code is in the function <code>list_repeat</code> in <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c#L512" rel="nofollow noreferrer">listobject.c</a>. An enlightening snippet is repeated below, with my added comments:</p>
<pre class="lang-c prettyprint-override"><code>np = (PyListObject *) PyList_New(size);  // make a new PyListObject

/* some code omitted */

items = np-&gt;ob_item;          // grabs the list of pointers of the *new* object
if (Py_SIZE(a) == 1) {        // this is the case for a 1-element list being multiplied
    elem = a-&gt;ob_item[0];     // grabs the pointer of the element of the *original* object
    for (i = 0; i &lt; n; i++) {
        items[i] = elem;      // assigns the original pointer to the new list
        Py_INCREF(elem);
    }
    return (PyObject *) np;
}
</code></pre>
<p>Since a <code>PyListObject</code> is mainly a <code>Vector</code> containing a list of pointers to the list elements, it is simple to assign these points as elements to the new <code>PyListObject</code>. </p>
<p>On the contrary, imagine the code if the object located at each pointer needed to be copied. It would be more complex and there would be a noticable performance hit. However, I'm not going to speculate in regards to the motivation of this design decision.</p>
</div>
<span class="comment-copy">There is definitely an answer for this....can't seem to find it. But this is well explained in quite a few places.</span>
<span class="comment-copy">@idjaw well, honestly, I'm torn on this one. I had originally made it a dupe target of that well-known one, but reopened it upon further consideration. The dupe target asks " Can someone please explain what's going on, and how to get around it?" But the OP already <i>knows</i> what's going on, and how to get around it. Their question is <i>why are these two approaches not semantically equivalent</i>.</span>
<span class="comment-copy">"especially given Python's zen of always being explicit and obvious" - well, the problem there is that as far as Python is concerned, you <i>were</i> explicit about what Python should do. You just didn't understand what you were telling it to do. While they could have made things even more explicit, splitting everything newbies might expect to make a copy into separate copy and no-copy versions, it'd get really cumbersome to explicitly write <code>x nc= [1, 2, 3]</code> or <code>y nc= [[None] nc* 4] c* 5</code> all the time, and it'd be a pretty major design change to make copying so fundamental.</span>
<span class="comment-copy"><code>[[]] * 4</code> just sees that the object it's multiplying by 4 is a 1-element list. It doesn't have any idea how to build copies of generic list elements, it can't reevaluate the <code>[]</code> expression because it doesn't see that expression, and special-casing specific types of list elements to make copies of them would be inconsistent. Without inconsistency or a substantial language redesign, the only option <code>*</code> has is to copy references instead of objects.</span>
<span class="comment-copy">@ray I also notice you've been using the term "array". But these are <i>not arrays</i>. They are <i>lists</i>. Yes, deep down inside there is a C array of Py_Object pointers, but that is an implementation detail. They are much more hefty data structures than mere arrays. They are heterogenous, resizable lists with amortized constant time <code>.append</code> and constant time indexing...</span>
<span class="comment-copy">Since you are trying to explain <i>why</i>, I think it should be a good idea to go into details on how <code>list.__mul__</code> has been implemented, and the reasoning behind why it was not implemented for other mutable structures like the set and list.</span>
<span class="comment-copy">This answer merely explains what the code means. I already know this. This does not really address my question, unfortunately.</span>
<span class="comment-copy">@ray the Crux of the answer is in the italicized text, but to reiterate: in Python, explicit is better than implicit, you don't implicitly make a copy of those objects.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ I actually don't think the details of how it is implemented really matter. The question is one of design choices. My answer boils down to "because Python never implicitly makes a copy, and this behavior is <i>consistent</i> with the semantics of the language".</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ furthermore, it is implemented for <i>sequence types</i> wherin it makes sense, mutable or immutable. So, it works for the immutable <code>str</code>, <code>bytes</code>, and <code>tuple</code> as well as the mutable <code>bytearray</code>. It doesn't work for non-sequence types. And it doesn't work for at least one sequence type where you couldn't really do it, i.e. <code>range</code></span>
<span class="comment-copy">That's a good find. I had searched for PEPs or something that would explain why the design decision was made. The one I came across was <a href="https://www.python.org/dev/peps/pep-0209/" rel="nofollow noreferrer">PEP-209</a>, but it's not relevant to my question. Have you searched for and/or seen discussions about this elsewhere (e.g. mailing list, etc)? You said: <i>"imagine the code if the object located at each pointer needed to be copied"</i>. It seems speculative; after all, it seems easy to "imagine" something along the following lines: <code>items[i] = Py_Copy(elem);</code></span>
<span class="comment-copy">@ray: Judging by your tag history, you're used to C++, where copying is one of the most fundamental operations in the entire language. In Python's language design, copying is extremely far from a fundamental operation. There is no C-level copying interface. There is no function to test whether an object is copyable. Objects almost never attempt to make copies of other objects, only of themselves. Assignment doesn't copy, parameter passing and return values don't make copies, and there's no concept of copy initialization. There's a <code>copy</code> module, but [cont]</span>
<span class="comment-copy">[cont] it's not used much in the stdlib, mostly in test code, and almost always with objects of a known type already known to be copyable. In C++, it would be reasonable and expected for a container to assume its elements are copyable and to make implicit copies. In Python, such an assumption is unreasonable.</span>
<span class="comment-copy">@user2357112 Judging from your comment (i.e. <i>"no C-level copying interface ... no function to test ... an object is copyable"</i>), it's either out of convenience (i.e. simpler to implement) or an intentional design decision (i.e. more likely given the absence of C functions to check for those things). OTOH, the <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">copy</a> module exists, which allows <code>deepcopy</code>ing. Your comment seems to imply that <code>copy.deepcopy</code> <i>must</i> rely on a pure Python implementation, since there's "no way" to test an object for whether it can be copied natively; can you clarify?</span>
<span class="comment-copy">@ray: <code>copy.deepcopy</code> does use a pure-Python implementation, which you can see <a href="https://github.com/python/cpython/blob/master/Lib/copy.py" rel="nofollow noreferrer">here</a>, but it could have been written as a C extension module that does the same thing. While we're talking, I should point out that some of the fallbacks it tries aren't very safe, so it's <a href="http://ideone.com/tTvBa8" rel="nofollow noreferrer">prone to failure</a> for even fairly simple self-referential structures.</span>
