<div class="post-text" itemprop="text">
<p>I have this dictionary:</p>
<pre><code>n ={'b': [['a'], ['c']], 'a': [['c', 'b'], ['c']], 'c': [['b']]}
</code></pre>
<p>and require the following output:     </p>
<pre><code>n ={'b': ['a', 'c'], 'a': ['c', 'b'], 'c': ['b']}
</code></pre>
<p>I tried to use <code>itertools</code> and <code>join</code> but couldn't get it to work, can anyone help out?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>chain.from_iterable</code></a> from <code>itertools</code> to combine these:</p>
<pre><code>from itertools import chain

from_it = chain.from_iterable
{k: list(from_it(i)) for k, i in n.items()}
</code></pre>
<p>If you require unique values in the lists (which according to the title you don't), you can additionally wrap the result of <code>from_it</code> in a <code>set</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I would iterate the dict and ignore the irrelevant list.</p>
<p>For uniqueness you can cast each inner_list to a <code>set</code></p>
<pre><code>n ={'b': [['a', 'b'], ['c']], 'a': [['c', 'b'], ['c']], 'c': [['b']]}

new_n = {}

for k,v in n.items():
  n[k] = [inner_item for item in v for inner_item in item]

print (n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>from itertools import chain

n ={'b': [['a'], ['c']], 'a': [['c', 'b'], ['c']], 'c': [['b']]}

new_n = {a:list(set(chain(*[i[0] if len(i) == 1 else i for i in b]))) for a, b in n.items()}
</code></pre>
<p>Output:</p>
<pre><code>{'a': ['c', 'b'], 'c': ['b'], 'b': ['a', 'c']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A one liner solution(and not recommended) to this is :</p>
<pre><code>{key: list(set([item for subarr in value for item in subarr])) for key, value in n.items()}
</code></pre>
<p>It is much harder to read though. If you really do not want to import anything, you can write a helper function.</p>
<pre><code>def flat_and_unique_list(list_of_lists):
    return list(set([item for sub_list in list_of_lists for item in sub_list]))

{key: flat_and_unique_list(value) for key, value in n.items()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution with <code>sum</code>:</p>
<pre><code>&gt;&gt;&gt; {k: sum(v, []) for k, v in n.items()}
{'a': ['c', 'b', 'c'], 'b': ['a', 'c'], 'c': ['b']}
</code></pre>
<blockquote>
<pre><code>sum(iterable, start=0, /)
</code></pre>
<p>Return the sum of a 'start' value (default: 0) plus an iterable of numbers</p>
</blockquote>
<p>Therefore, using an empty list as start value works.</p>
<p>Remove multiplies using without preserving order using <code>set</code>:</p>
<pre><code>&gt;&gt;&gt; {k: list(set(sum(v, []))) for k, v in n.items()}
{'a': ['c', 'b'], 'b': ['a', 'c'], 'c': ['b']}
</code></pre>
</div>
<span class="comment-copy"><code>{k: list(set(chain.from_iterable(i))) for k, i in n.items()}</code> if you need unique values or <code>{k: list(chain.from_iterable(i)) for k, i in n.items()}</code> if you don't.</span>
<span class="comment-copy">Great, this works perfect.</span>
