<div class="post-text" itemprop="text">
<p>Here the <code>SMS_Store</code> inherits the <code>Message</code>, but every time I call the parent method there is the error:</p>
<p><code>NoneType object does not have attribute 'read_message'</code>.</p>
<p>and also the object stored in the list returns a <code>None</code> value??</p>
<pre><code>class Message():

    def __init__(self, from_number, time_arrived, text_of_sms):
        self.has_been_viewed=False
        self.from_number= from_number
        self.time_arrived = time_arrived
        self.text_of_sms = text_of_sms

    def getTime(self):
        return self.time_arrived

    def getText(self):
        return self.text_of_sms

    def setView(self):
        self.has_been_viewed = True

    def check_read(self):
        return self.has_been_viewed


class SMS_Store(Message):

    def __init__(self):
        self.list_=[]

    def add_new_arrivals(self,from_number, time_arrived, text_of_sms):
        self.list_.append(Message.__init__(self,from_number,time_arrived,text_of_sms))

    def message_count(self):
        return len(self.list_)

    def get_unread_index(self):
        unread =[]
        for i in range(len(self.list_)):
            if(super(SMS_Store,self).check_read() == False):
                unread.append(i)
        return unread

    def read_message(self,index):
        self.list_[index].getText()

    def delete(self,ints):
        a = int(ints)
        self.list_.pop(a)

    def clear():
        for i in list:
            self.list_.pop(i)

inbox = SMS_Store()
inbox.add_new_arrivals(12,9,'some nights i stay up')
inbox.add_new_arrivals(12,5,'cashing in my bad luck')
inbox.add_new_arrivals(14,7,'somenights i call it a draw')
inbox.add_new_arrivals(56,0,'somenights i wish that my lips could built a castle.')
inbox.read_message(0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's unclear where that error could be coming from since <code>read_message()</code> is only called by the <code>inbox.read_message(0)</code> statement at the end of your code, which wouldn't produce it (although the return value of the <code>read_message()</code> method <strong>is</strong> always <code>None</code>, since there's no explicit <code>return</code> statement in it).</p>
<p>Regardless, to answer the titular question, to do that explicitly you would use the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code></a> methodâ€”but that's not the problem here which is that the <code>SMS_Store</code> class shouldn't be a subclass of <code>Message</code> at all, since it's not a specialization of the <code>Message</code> class...rather it's a <em>container</em> of <code>Message</code> instances.</p>
<p>Below is reworked version of your code that shows how to separate these two classes and get most if not all of the methods working. It also now mostly follows <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8 - Style Guide for Python Code</a> recommendations.</p>
<pre><code>class Message:
    def __init__(self, from_number, time_arrived, text_of_sms):
        self.has_been_viewed = False
        self.from_number = from_number
        self.time_arrived = time_arrived
        self.text_of_sms = text_of_sms

    def get_time(self):
        return self.time_arrived

    def get_text(self):
        return self.text_of_sms

    def set_viewed(self):
        self.has_been_viewed = True

    def check_read(self):
        return self.has_been_viewed


class SMS_Store:
    def __init__(self):
        self.list_ = []

    def add_new_arrival(self, from_number, time_arrived, text_of_sms):
        self.list_.append(Message(from_number, time_arrived, text_of_sms))

    def message_count(self):
        return len(self.list_)

    def get_unread_index(self):
        unread = []
        for (i, message) in enumerate(self.list_):
            if not message.check_read():
                unread.append(i)
        return unread

    def read_message(self, index):
        message_text = self.list_[index].get_text()
        self.list_[index].set_viewed()
        return message_text

    def delete(self, index):
        self.list_.pop(index)

    def clear():
        self.list_.clear()

inbox = SMS_Store()

inbox.add_new_arrival(12, 9, 'some nights i stay up')
inbox.add_new_arrival(12, 5, 'cashing in my bad luck')
inbox.add_new_arrival(14, 7, 'somenights i call it a draw')
inbox.add_new_arrival(56, 0, 'somenights i wish that my lips could built a castle.')

print(inbox.get_unread_index())  # -&gt; [0, 1, 2, 3]
print(inbox.read_message(0))     # -&gt; some nights i stay up
print(inbox.get_unread_index())  # -&gt; [1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't use inheritance in this case. Here's corrected version (also fixed code style):</p>
<pre><code>class Message:
    def __init__(self, from_number, time_arrived, text_of_sms):
        self.has_been_viewed = False
        self.from_number = from_number
        self.time_arrived = time_arrived
        self.text_of_sms = text_of_sms

    def get_time(self):
        return self.time_arrived

    def get_text(self):
        return self.text_of_sms

    def set_view(self):
        self.has_been_viewed = True

    def check_read(self):
        return self.has_been_viewed


class SMSStore:
    def __init__(self):
        self._list = []

    def add_new_arrivals(self, from_number, time_arrived, text_of_sms):
        self._list.append(Message(from_number, time_arrived, text_of_sms))

    def message_count(self):
        return len(self._list)

    def get_unread_index(self):
        return list(filter(lambda m: not m.check_read(), self._list))

    def read_message(self, index):
        return self._list[index].get_text()

    def delete(self, index):
        a = int(index)
        self._list.pop(a)

    def clear(self):
        self._list = []

inbox = SMSStore()
inbox.add_new_arrivals(12, 9, 'some nights i stay up')
inbox.add_new_arrivals(12, 5, 'cashing in my bad luck')
inbox.add_new_arrivals(14, 7, 'somenights i call it a draw')
inbox.add_new_arrivals(56, 0, 'somenights i wish that my lips could built a castle.')
print(inbox.read_message(0))
</code></pre>
</div>
<span class="comment-copy">Why are you overwriting <code>__init__()</code>?</span>
<span class="comment-copy">You shouldn't inherit <code>SMS_Store</code> from <code>Message</code> if you use it for storing a list of instances of <code>Message</code></span>
<span class="comment-copy">Why are you calling <code>Message.__init__()</code> explicitly to create instances of the parent class instead of just using <code>Message()</code>?</span>
<span class="comment-copy"><code>SMS_Store</code> isn't a kind of <code>Message</code>, it's a container of instances of them (i.e. it <i>has</i> one or more instances of them), therefore it shouldn't be a subclass.</span>
<span class="comment-copy">@martineau It made sense when you said it like that. Now, i know clearly  what i should've done. thanks you very much.</span>
<span class="comment-copy">This is exactly what i was trying to do with my code.oh, this is just beautiful. thank you sir. thanks a million sir..</span>
<span class="comment-copy">masair: That's good to hear and in that case.please accept my answer. (See <a href="http://stackoverflow.com/help/someone-answers"><i>What should I do when someone answers my question?</i></a>)</span>
<span class="comment-copy">I was really confused why the objects were returning None value. thank you for that explanation too</span>
<span class="comment-copy">masair: Once again, you're welcome. Try not to stay up too late... <code>;-)</code></span>
<span class="comment-copy">thanks man. and eh sorry for the code style , my first question as you could guess. but out of my curiosity, why can't i use inheritance in this case ...</span>
<span class="comment-copy">and thank again!</span>
<span class="comment-copy">Because it has no sense: you have a message, and a list of messages. This list is neither message nor kind of message.</span>
