<div class="post-text" itemprop="text">
<p>I want to be able to create objects based on an enumeration class, and use a dictionary. Something like this:</p>
<pre><code>class IngredientType(Enum):
    SPAM        = auto() # Some spam
    BAKE_BEANS  = auto() # Baked beans
    EGG         = auto() # Fried egg

class Ingredient(object):
    pass    
class Spam(Ingredient):
    pass
class BakedBeans(Ingredient):
    pass
class Egg(Ingredient):
    pass


class IngredientFactory(object):
    """Factory makes ingredients"""

    choice = {
        IngredientType.SPAM: IngredientFactory.MakeSpam,
        IngredientType.BAKED_BEANS: IngredientFactory.MakeBakedBeans,
        IngredientType.EGG: IngredientFactory.MakeEgg
    }

    @staticmethod
    def make(type):
        method = choice[type]
        return method()

    @staticmethod
    def makeSpam():
        return Spam()

    @staticmethod
    def makeBakedBeans():
        return BakedBeans()

    @staticmethod
    def makeEgg():
        return Egg()
</code></pre>
<p>But I get the error:</p>
<pre><code>NameError: name 'IngredientFactory' is not defined
</code></pre>
<p>For some reason the dictionary can't be created.
Where am I going wrong here?</p>
</div>
<div class="post-text" itemprop="text">
<p>Place your mapping at the end of the class, and reference the methods directly, since they're in the same namespace:</p>
<pre><code>choice = {
    IngredientType.SPAM: makeSpam,
    IngredientType.BAKED_BEANS: makeBakedBeans,
    IngredientType.EGG: makeEgg
}
</code></pre>
<p>A class object is not created until all the code in the class body, so you can't access the class itself. However, since the class body is processed in a dedicated namespace, you can access any attribute you've defined up to that point (which is why the mapping has to come at the end). Note also that while you can access globals and built-ins, you can't access the namespaces of enclosing classes or functions.</p>
<p>Here's the detailed but still introductory explanation from the official docs explaining how classes are executed: <a href="https://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python is not Java and doesn't require everything to be in a class. Here your <code>IngredientFactory</code> class has no states and only staticmethods, so it's actually just a singleton namespace, which in python is canonically done using the module as singleton namespace and plain functions. Also since Python classes are already callable, wrapping the instanciation in a function doesn't make sense. The simple, straightforwrad pythonic implementation would be:</p>
<pre><code># ingredients.py

class IngredientType(Enum):
    SPAM        = auto() # Some spam
    BAKE_BEANS  = auto() # Baked beans
    EGG         = auto() # Fried egg

class Ingredient(object):
    pass    

class Spam(Ingredient):
    pass

class Beans(Ingredient):
    pass

class Egg(Ingredient):
    pass


_choice = {
        IngredientType.SPAM: Spam,
        IngredientType.BAKED_BEANS: Beans,
        IngredientType.EGG: Egg
    }

def make(ingredient_type):
    cls = _choice[ingredient_type]
    return cls()
</code></pre>
<p>And the client code:</p>
<pre><code>import ingredients
egg = ingredients.make(ingredients.IngredientType.EGG)

# or much more simply:

egg = ingredients.Egg()
</code></pre>
<p>FWIW the <code>IngredientType</code> enum doesn't bring much here, and even makes things more complicated that they have to be - you could just use plain strings:</p>
<pre><code># ingredients.py

class Ingredient(object):
    pass    

class Spam(Ingredient):
    pass

class Beans(Ingredient):
    pass

class Egg(Ingredient):
    pass


_choice = {
        "spam": Spam,
        "beans": Beans,
        "egg": Egg
    }

def make(ingredient_type):
    cls = _choice[ingredient_type]
    return cls()
</code></pre>
<p>And the client code:</p>
<pre><code>import ingredients
egg = ingredients.make("egg")
</code></pre>
<p>Or if you really want to use an <code>Enum</code>, you can at least get rid of the <code>choices</code> dict by using the classes themselves as values for the enum as suggested by MadPhysicist:</p>
<pre><code># ingredients.py

class Ingredient(object):
    pass    

class Spam(Ingredient):
    pass

class Beans(Ingredient):
    pass

class Egg(Ingredient):
    pass

class IngredientType(Enum):
    SPAM = Spam
    BEANS = Beans
    EGG = Egg

    @staticmethod
    def make(ingredient_type):
        return ingredient_type.value()
</code></pre>
<p>and the client code</p>
<pre><code> from ingredients import IngredientType
 egg = IngredientType.make(IngredientType.EGG)
</code></pre>
<p>But I really don't see any benefit here either</p>
<p>EDIT: you mention:</p>
<blockquote>
<p>I am trying to implement the factory pattern, with the intent of hiding the creation of objects away. The user of the factory then just handles 'Ingredients' without knowledge of the concrete type</p>
</blockquote>
<p>The user still have to specify what kind of ingredients he wants (the <code>ingredient_type</code> argument) so I'm not sure I understand the benefit here. What's your <strong>real</strong> use case actually ? (the problem with made up / dumbed down examples is that they don't tell the whole story).</p>
</div>
<div class="post-text" itemprop="text">
<p>After looking at <a href="https://python-3-patterns-idioms-test.readthedocs.io/en/latest/Factory.html" rel="nofollow noreferrer">Bruce Eckel's book</a> I came up with this:</p>
<pre><code>#Based on Bruce Eckel's book Python 3 example
# A simple static factory method.
from __future__ import generators
import random
from enum import Enum, auto

class ShapeType(Enum):
    CIRCLE  = auto() # Some circles
    SQUARE  = auto() # some squares

class Shape(object):
    pass

class Circle(Shape):
    def draw(self): print("Circle.draw")
    def erase(self): print("Circle.erase")

class Square(Shape):
    def draw(self): print("Square.draw")
    def erase(self): print("Square.erase")

class ShapeFactory(object):

    @staticmethod
    def create(type):
        #return eval(type + "()") # simple alternative
        if type in ShapeFactory.choice:
            return ShapeFactory.choice[type]()

        assert 0, "Bad shape creation: " + type    

    choice = { ShapeType.CIRCLE:  Circle,
               ShapeType.SQUARE:  Square                
             }

# Test factory
# Generate shape name strings:
def shapeNameGen(n):

    types = list(ShapeType)

    for i in range(n):
        yield random.choice(types)

shapes = \
  [ ShapeFactory.create(i) for i in shapeNameGen(7)]

for shape in shapes:
    shape.draw()
    shape.erase()
</code></pre>
<p>This gets the user to select a class type from the enumeration, and blocks any other type. It also means user's are less likely to write 'bad strings' with spelling mistakes. They just use the enums.
The output from the test is then, something like this:</p>
<pre><code>Circle.draw
Circle.erase
Circle.draw
Circle.erase
Square.draw
Square.erase
Square.draw
Square.erase
Circle.draw
Circle.erase
Circle.draw
Circle.erase
Square.draw
Square.erase
</code></pre>
</div>
<span class="comment-copy">Why in the world would you want to do it like this?</span>
<span class="comment-copy">At the time of class parsing/defining, <code>IngredientFactory</code> doesn't yet exist. Until Python parser leaves the last indent under the <code>IngredientFactory</code> class definition it won't be available for reference.</span>
<span class="comment-copy">And where is the code actually raising the error?</span>
<span class="comment-copy">Line 4 of IngredientFactory it gives me the error.</span>
<span class="comment-copy">Is this the wrong way to making a factory?</span>
<span class="comment-copy">So the <code>choice</code> variable exists inside the class still? But at the end? As I still get an error: <code>NameError: name 'MakeSpam' is not defined</code></span>
<span class="comment-copy">@DogBreath. That's because you didn't type your method names correctly. Python is case sensitive. Notice that the answer has the correct capitalization: e.g. <code>makeSpam</code>.</span>
<span class="comment-copy">I'm getting a bit lost :~</span>
<span class="comment-copy">Why are you lost?</span>
<span class="comment-copy">@DogBreath this should be <code>IngredientFactory.choice</code> (within the staticmethod, I mean). Using classmethods instead you could use <code>cls.choices</code></span>
<span class="comment-copy">At that point, you can just stick a reference to the class directly into the enum and skip on having a second lookup table entirely.</span>
<span class="comment-copy">@MadPhysicist possibly yes - I haven't used python3 <code>Enum</code> so far.</span>
<span class="comment-copy">but really it has a definite Rube Goldberg smell...</span>
<span class="comment-copy">@DogBreath "you guess" ??? You are the one asking how to implement this but you don't know why you want to do so ??? And who is supposed to decide what kind of egg will actually be created anyway ?</span>
<span class="comment-copy">Note that if your point is to allow to swap implementation based on platform, settings or something similar, there are much simpler ways - you can have a look at how <code>os.path</code> works for example. Remember that 1/ in Python everything is an object (including classes, modules etc) and 2/ all top-level code is executed at import time, so you can conditionnally swap which class / function / module is bound to a name (cf <code>os.path</code> once again).</span>
