<div class="post-text" itemprop="text">
<p>Im trying to create 2 lists form a list of lists, the following code is a working easy example, but it makes sense to think there is a command that can be used instead of creating the for loop for splitting. </p>
<pre><code>def add_five(x):
    return x,x + 5
result1=[]
result2=[]
nums = [11, 22, 33, 44, 55]
result = list(map(add_five, nums))
print(result)
for n in range(len(result)):
    result1.append(result[n][0])
    result2.append(result[n][1])
print(result1,result2)
</code></pre>
<p>The list of lists is:</p>
<pre><code>[(11, 16), (22, 27), (33, 38), (44, 49), (55, 60)]
result1=[11, 22, 33, 44, 55] 
result2=[16, 27, 38, 49, 60]
</code></pre>
<p>Is there a command that can help aviod using the for loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehensions to extract the <em>n</em>th element of each <code>tuple</code>:</p>
<pre><code>L = [(11, 16), (22, 27), (33, 38), (44, 49), (55, 60)]

result1 = [i[0] for i in L]
result2 = [i[1] for i in L]
</code></pre>
<p>Functionally, you can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> for the equivalent:</p>
<pre><code>from operator import itemgetter

result1 = list(map(itemgetter(0), L))
result2 = list(map(itemgetter(1), L))
</code></pre>
<p>If you <em>don't</em> know the size of your tuples in advance, the recommended solution is <code>zip</code>, which will output a list of tuples, each tuple representing a tuple index:</p>
<pre><code>results = list(zip(*L))

[(11, 22, 33, 44, 55), (16, 27, 38, 49, 60)]
</code></pre>
<p>You can even use sequence unpacking here without forming the full list:</p>
<pre><code>result1, result2 = zip(*L)
</code></pre>
</div>
<span class="comment-copy">Look into the builtin function <code>zip</code>, which is its own inverse.</span>
