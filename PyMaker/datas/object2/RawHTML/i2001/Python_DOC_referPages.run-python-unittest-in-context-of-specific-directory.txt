<div class="post-text" itemprop="text">
<p>In my python application, I open mp3 files with relative paths from where the program was started. To keep it simple, I made a minimal reproduction of the problem I have in my project <a href="https://github.com/CoreyCole/unittest-py" rel="nofollow noreferrer">here</a>.</p>
<p>Basically, I have a structure like this:</p>
<pre><code>src
└─ main.py
test
└─ test_main.py
</code></pre>
<p>In <code>main.py</code> I have a simple function that prints and returns the current working directory:</p>
<pre class="lang-python prettyprint-override"><code>def get_cwd() -&gt; str:
    directory = os.path.basename(os.getcwd())
    print('Current directory =', directory)
    return directory
</code></pre>
<p>So if I <code>cd</code> into the <code>src</code> folder and run <code>python main.py</code> I see:</p>
<pre class="lang-none prettyprint-override"><code>Current directory = src
</code></pre>
<p>This is the desired behavior, as in my program the file paths to the mp3 files are relative to <code>src</code>.</p>
<p>The problem arises when I try to write tests. I can't seem to get a test like this to pass, no matter what I pass to <code>--start-directory</code> and <code>--top-level-directory</code>:</p>
<pre class="lang-python prettyprint-override"><code>def test_get_cwd(self):
    print('testing get_cwd()')
    current_dir = get_cwd()
    self.assertIsNotNone(current_dir)
    self.assertEqual(current_dir, 'src')
</code></pre>
<p><strong>The question:</strong> How can I run my tests as if they were running in the context of a specific directory if they are saved to a different directory?</p>
<p>Constraints:</p>
<ul>
<li>the tests must import using absolute paths, as in my example: <code>from
src.main import get_cwd</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There is a <code>os</code> function to change the directory, try adding <code>os.chdir('src')</code> to your test.</p>
<pre><code>import unittest
import os

from src.main import get_cwd


class TestMain(unittest.TestCase):

    def test_get_cwd(self):
        os.chdir('src')
        print('testing get_cwd()')
        current_dir = get_cwd()
        self.assertIsNotNone(current_dir)
        self.assertEqual(current_dir, 'src')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An option is to <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">mock</a> the value given by <code>os.path.basename</code> with a return value of <code>"src"</code></p>
<pre><code>import unittest
from mock import patch

from src.main import get_cwd


class TestMain(unittest.TestCase):

    @patch('os.path.basename')
    def test_get_cwd(self, basename):
        basename.return_value = "src"
        print('testing get_cwd()')
        current_dir = get_cwd()
        self.assertIsNotNone(current_dir)
        self.assertEqual(current_dir, 'src')
</code></pre>
</div>
<span class="comment-copy">Yes! This works and fits my real program's constraints. Thank you @javrd!</span>
<span class="comment-copy">That would work for this simple example, but in my real project, I need the <b>real</b> cwd to be <code>src</code> so that the program can find the mp3 files with the same file paths as when it runs normally. The example I made was just to minimally reproduce my problem, I'm not actually using <code>os.getcwd()</code> in my real program, I just need it to return the expected directory so I know it can find the mp3 files with the same relative file paths.</span>
<span class="comment-copy">I think it should work. Maybe you have to mock something more, but if the path to yours mp3 is fixed depending on your workspace, I don't see why not mocking these path in your controlled test case.</span>
<span class="comment-copy">It won't work for my real program. I have code that loads up mp3s using relative file paths like <code>audio/example.mp3</code> where the full path is <code>src/audio/example.mp3</code>. Mocking what cwd or basename returns will not help this problem.</span>
