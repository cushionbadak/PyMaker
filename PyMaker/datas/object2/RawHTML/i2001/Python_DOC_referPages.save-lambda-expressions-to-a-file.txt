<div class="post-text" itemprop="text">
<p>I am implementing an Evolution Strategy algorithm in Python 3. I have created a class called Individual that reads the configuration from a file (YAML format) which looks like the following:</p>
<pre><code>num_of_genes: 3
pre_init_gene:
    gene1: 1.0
    gene2: 1.0
    gene3: 1.0
metrics:
    - metric1
    - metric2
obj_funcs:
    obj_fun1: 'lambda x,y: x+y'
    obj_fun2: 'lambda x: (x**3)/2'
</code></pre>
<p>The idea is that the individual would read this file to get its configuration. 
I know I can save my lambda expression as a string and then call eval on it.</p>
<p>However, is there a more Pythonic solution for this problem? I do not feel much comfortable with OO in Python, but I am open for suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would adhere to the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Zen of
Python</a> in particular
"Explicit is better than implicit" and "Readability counts".</p>
<p>So having your functions as readable strings defining lambda's is a
good idea, although, for security reasons, calling <code>eval</code> on the loaded string
representation of the lambda might not be. This
again depends on who has modification access to the file and on which
system they run.</p>
<p>In general you should not care too much if someone can
(non-inadvertedly) inject something resulting in recursive removal of
all files on a system, if they have login access rights with which
they can do so anyway.  However if e.g. the software runs on a remote
system and these files can be edited via some web interface, or if the
file changes can be made by someone else than the person using the
files, this is something you should take into account.</p>
<p>If the lambdas come from a fixed set, you can just use
their string representation as a lookup:</p>
<pre><code>lambdas = {}
for l in [
   'lambda x,y: x+y',
   'lambda x: (x**3)/2',
   # some more
]:
   lambdas[l] = eval(l)
</code></pre>
<p>You can then use the string loaded from your configuration YAML to get
the actual lambda and that string cannot be tampered with, as it has
to match the available set of lambdas you provided. You can of course
load the actual lambda strings from a file that only you can change,
instead of hard-coding them in the source code. </p>
<p>This is IMO more
explicit than dumping the actual lambda resulting in YAML looking like:</p>
<pre><code>!!python/name:__main__.%3Clambda%3E
</code></pre>
<p>, something which requires unsafe loading of the YAML document anyway.</p>
<p>If you need to be more flexible, than using pre-defined lambdas, but
don't want the insecurity of using <code>eval</code>, then another possibility is
to use Python's <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">AST
module</a>. That module
allows for safe evaluation of unary and binary operators, but can be
extended to handle only those function (e.g. some mathematical
functions) that you want to allow in your lambda. I have done similar
extension in my Python Object Notation module
(<a href="https://pypi.org/project/pon/" rel="nofollow noreferrer">PON</a>) adding <a href="https://bitbucket.org/ruamel/pon/src/81f3d50c98bf69e1e03068d22aefed28c0494f20/__init__.py#lines-141" rel="nofollow noreferrer">datetime and
dedenting</a>
capabilities to the AST evaluated input.</p>
<hr/>
<p>Something else is that you should IMO improve on your YAML. Instead of
using  <code>gene1</code>, <code>gene2</code> as keys in  mapping, use a sequence and tag the items:</p>
<pre><code>pre_init_gene:
    - !Gene 1.0
    - !Gene 1.0
    - !Gene 1.0
</code></pre>
<p>or, alternatively tag the sequence:</p>
<pre><code>pre_init_gene: !Genes
    - 1.0
    - 1.0
    - 1.0
</code></pre>
<p>Your lambdas have the same "problem" and I would do something like:</p>
<pre><code>obj_funcs:
   - !Lambda 'x, y: x+y'
   - !Lambda 'x: (x**3)/2'
</code></pre>
<p>where the object implementing the <code>from_yaml</code> <code>classmethod</code> for the
tag <code>!Lambda</code> transparently does the eval or AST evaluation.</p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>cloudpickle</code> you can dump a lambda to <code>bytes</code>. Then you need to convert <code>bytes</code> to <code>str</code> to be written to a file. </p>
<pre><code>import cloudpickle
import base64


def lambda2str(expr):
    b = cloudpickle.dumps(expr)
    s = base64.b64encode(b).decode()
    return s


def str2lambda(s):
    b = base64.b64decode(s)
    expr = cloudpickle.loads(b)
    return expr


e = lambda x, y: x + y
s = lambda2str(e)      
print(s)           # =&gt; gASVNAEAAAAAAACMF2Nsb3VkcGlja2xlLmNsb3VkcGlja2xllIwOX2ZpbGxfZnVuY3Rpb26Uk5QoaACMD19tYWtlX3NrZWxfZnVuY5STlGgAjA1fYnVpbHRpbl90eXBllJOUjAhDb2RlVHlwZZSFlFKUKEsCSwBLAksCS0NDCHwAfAEXAFMAlE6FlCmMAXiUjAF5lIaUjCovVXNlcnMvYmxvd25oaXRoZXJtYS9wcm9qZWN0cy90ZXN0L3Rlc3QucHmUjAg8bGFtYmRhPpRLEUMAlCkpdJRSlEr/////fZSHlFKUf

# store s in file, read s from file

e2 = str2lambda(s)
print(e2(1, 1))    # =&gt; 2
</code></pre>
<p>Note that what base64 does is to avoid things like <code>\n</code> in the encoded string which will poison the file structure. <code>decode()</code> is simply converting <code>bytes</code> to <code>str</code> so that it can be written to a file.</p>
<p>This is not a concise representation but a safe one. If your working environment is safe, feel free to use your readable version!</p>
</div>
<span class="comment-copy">do these functions have to be lambda expressions? I've done a similar trick (defining functions in config files) which I did by making a <code>functions</code> package and defining each function underneath it, then <code>obj_funcs: {obj_fun1: "functions.function_one", ...}</code></span>
<span class="comment-copy">Is it important that the actual lamba expression can be changed in the YAML document, or is this more/exclusively for documentation purposes?</span>
<span class="comment-copy">What do you mean by "I can save my lambda expressions as a string"? From that YAML document you would be <b>loading</b> them, resulting in a Python string. Where would you be saving them to before calling eval? (The equivalent of saving a datastructure to a YAML document is called <b>dumping</b>).</span>
<span class="comment-copy">@AdamSmith: I like your suggestion. I believe it works better whenever people have some Python knowledge. However, in my case, the person who will use my program does not know how to program in Python. Anyway, thanks for your suggestion!</span>
<span class="comment-copy">@alexandredias3d Your user won't know Python, but will know the lambda calculus? What a bizarrely specific use case!</span>
<span class="comment-copy">I liked your idea of using AST to provide readability and safety at the same time. I will definitely read about that. However, I am not sure if I understood your suggestion to improve the YAML: this tag requires that I implement a class with a method called from_yaml to tell how the YAML should read that specif tag, right? If that is true, in your opinion, do you think I should do this even when I am interested just in the values? Like the case with <code>metric</code>, for example, where it is just a list of values, would you create a tag for it? Thanks for your time!</span>
<span class="comment-copy">@alexandredias3d I think tags are underused in many applications that load YAML, and that to often keys are abused to indicate what type the value is supposed to be. The <code>!Gene</code> example with one float parameter might be too much, but for the lambda string on which you are going to call <code>eval</code> or some AST processing, there it makes more sense IMO to use a tag and get an intelligent type (you can always delay the actual processing until you try to access the computed value).</span>
<span class="comment-copy">I like your idea of dumping a coded lambda function into a file. In this case, I need the expression to be readable and easy to change, as the user of my program might not know much about Python. Anyway, thanks for commenting! I will take your solution into account whenever I have a unsafe environment.</span>
