<div class="post-text" itemprop="text">
<p>The first code snippet:</p>
<pre><code>class A:
    def __init__(self):
        print(self.__dict__)
    def __getattr__(self, name):
        print("get")
    def __setattr__(self, name, value):
        print("set")

    # def __getattribute__(self, name):
    #     print("getatrr")

a = A()
</code></pre>
<p>It prints <code>{}</code> and the function <code>__getattr__</code> isn't invoked, which means the attribute<code>__dict__</code> exists.</p>
<p>The second snippet:</p>
<pre><code>class A:
    def __init__(self):
        print(self.__dict__)
    def __getattr__(self, name):
        print("get")
    def __setattr__(self, name, value):
        print("set")

    def __getattribute__(self, name):
        print("getatrr")

a = A()
</code></pre>
<p>It prints <code>getatrr</code> and <code>None</code>, which means the attribute <code>__dict__</code> doesn't exist.</p>
<p>Why is <code>__dict__</code> <code>{}</code> in the first case, but <code>None</code> in the second case?</p>
</div>
<div class="post-text" itemprop="text">
<p>the issue is that when you define this:</p>
<pre><code>def __getattribute__(self, name):
    print("getatrr")
</code></pre>
<p>you're overriding <code>__getattribute__</code> which is supposed to <em>return</em> something. Since you're not returning anything, you get <code>None</code> for every attribute you'll try.</p>
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer">Documentation</a> states:</p>
<blockquote>
<p>This method should return the (computed) attribute value or raise an AttributeError exception</p>
</blockquote>
<p>A viable way to define it is to call <code>object.__getattribute__</code> in the fallback case (in my example, I have added a small test on <code>__dict__</code> which prints:</p>
<pre><code>def __getattribute__(self, name):
    if name == "__dict__":
        print("get attribute invoked with __dict__")
    return object.__getattribute__(self,name)
</code></pre>
<p>In the end, the hard attribute lookup work is done with <code>object.__getattribute__</code> that invokes python runtime.</p>
</div>
<span class="comment-copy"><code>__dict__</code> always exists. Have you read what <code>__getattr__</code> and <code>__getattribute__</code> actually do? <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__getattr__</a></span>
<span class="comment-copy"><code>__getattribute__</code> is always invoked, <code>__getattr__</code> is invoked as a fallback when the attribute cannot be retrieved "in the normal ways". <code>getattr</code> calls <code>__getattribute__</code>. <code>__getattr__</code> should be called <code>__missingattr__</code> and <code>__getattribute__</code> should be named <code>__getattr__</code> to match with the <code>getattr</code> builtin.</span>
<span class="comment-copy">@ freakish, the second case prints <code>None</code> for Python3.5</span>
<span class="comment-copy">because you're supposed to return something, not just print</span>
<span class="comment-copy">How to check <code>name</code> doesn't exist and raise an AttributeError exception in <code>__getattribute__</code>?</span>
<span class="comment-copy">And how does <code>object.__getattribute__</code> implemented to avoid  infinite recursion?</span>
<span class="comment-copy">check if <code>name</code> is in <code>__dict__</code> :) and <code>object.__getattribute__</code> is the real method looking for attribute, no recursion. At some point, someone has to get the job done</span>
<span class="comment-copy">Checking if <code>name</code> is in <code>self.__dict__</code> will cause recursion, I think.</span>
<span class="comment-copy"><code>object.__getattribute__</code> is the real method looking for attribute, how to understand? I don't think <code>object</code> has attribute tables of sub-class.</span>
