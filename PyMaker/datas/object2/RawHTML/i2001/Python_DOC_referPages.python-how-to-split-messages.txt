<div class="post-text" itemprop="text">
<p>In discord chat there is a limit of 2000 characters per message so is there any way to bypass it?</p>
<p>like example in below code when someone types <code>!ping</code> bot sends a embed message. So is it possible to make it split message after or before a certain line bot hides that messages and gives option to view or click next page or something.</p>
<pre><code>@bot.command(pass_context=True)
async def ping(ctx):
    embed=discord.Embed(title="Something Title", description="something anything goes here")
    await bot.say(embed=embed)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can split your text yourself or use the easy way as suggestend py @Prashant Godhani <a href="https://stackoverflow.com/a/52903618/7505395">here</a> and use the <a href="https://docs.python.org/3/library/textwrap.html#textwrap.wrap" rel="nofollow noreferrer">textwrap.wrap() function</a>:</p>
<pre><code># easy way
import textwrap
import lorem

def sayLongLine(text, wrap_at=200):
    for line in textwrap.wrap(text, wrap_at):
        # use await bot.say - maybe add a delay if you have max says/second
        print(line) 

sayLongLine(lorem.paragraph(), 40)
</code></pre>
<hr/>
<p>If you'd rather replicate the functionality of the textwrap module yourself you can do so by splitting your text at spaces into words and combining the words until they would overshoot the length you are allowed to use. Put that word in the next sentence, join all current words back together and store it in a list. Loop until done, add last parts if needed and return the list:</p>
<pre><code># slightly more complex self-made wrapper:
import lorem
print("----------------------")

def sayLongLineSplitted(text,wrap_at=200):
    """Splits text at spaces and joins it to strings that are as long as 
    possible without overshooting wrap_at.

    Returns a list of strings shorter then wrap_at."""
    splitted = text.split(" ")
    def gimme():
        """Yields sentences of correct lenght."""
        len_parts = 0
        parts = []   
        for p in splitted: 
            len_p = len(p)
            if len_parts + len_p &lt; wrap_at:
                parts.append(p)
                len_parts += len_p + 1  
            else:
                yield ' '.join(parts).strip()
                parts = [p]
                len_parts = len_p 
        if parts:
            yield ' '.join(parts).strip()

    return list(gimme()) 


for part in sayLongLineSplitted(lorem.paragraph(),40):
    print(part)
</code></pre>
<p>Output of self-made wrapper:</p>
<pre><code># 234567890123456789012345678901234567890

Ut velit magnam sed sed. Eius modi
quiquia numquam. Quaerat eius tempora
tempora consectetur etincidunt est. Sit
dolor quaerat quaerat amet voluptatem
dolorem dolore. Sit adipisci non
etincidunt est aliquam etincidunt sit.
Quaerat porro sed sit.
</code></pre>
<p>Output of <code>textwrap</code>-example: </p>
<pre><code># 234567890123456789012345678901234567890

Etincidunt aliquam etincidunt velit 
numquam. Quisquam porro labore velit. 
Modi modi porro quaerat dolor etincidunt 
quisquam. Ut ipsum quiquia non quisquam 
magnam ut sit. Voluptatem non non 
dolorem. Tempora quaerat neque quaerat 
dolorem velit magnam ipsum. 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use await bot.say many times.</p>
<p>for line splitting use <a href="https://docs.python.org/2/library/textwrap.html" rel="nofollow noreferrer">python textwrap</a> library that is amazing for line splitting. please refer <a href="https://www.geeksforgeeks.org/textwrap-text-wrapping-filling-python/" rel="nofollow noreferrer">this</a> example and than use bot.say many time in loop.</p>
</div>
<span class="comment-copy">So just this function <code>def sayLongLineSplitted</code>  should be added to bot.  do i need to add anything to my bot command <code>@bot.command(pass_context=True) async def ping(ctx):</code> ?</span>
<span class="comment-copy">@Demotry  the split function <code>sayLongLineSplitted()</code> splits your text into ok-length parts. you need to call the bot for each part of this list in order once.</span>
