<div class="post-text" itemprop="text">
<p>I have two modules in the same package, <code>module1.py</code> and <code>module2.py</code>.</p>
<p>In <code>module1.py</code> I have a function reading command-line args with <code>argparse</code>:</p>
<pre><code>import argparse

def parse_arguments_module1():
    parser = argparse.ArgumentParser()
    optional = parser._action_groups.pop()
    required = parser.add_argument_group('required arguments')
    required.add_argument('--argA', help='argA', required=True)
    required.add_argument('--argB', help='argB', required=True)
    optional.add_argument('--argC', help='argC')
    optional.add_argument('--argD', help='argD')
    parser._action_groups.append(optional)
    args = parser.parse_args()
    return args
</code></pre>
<p>Now suppose in <code>module2.py</code> I import <code>parse_arguments_module1()</code> from <code>module1.py</code> and use it (this works):</p>
<pre><code>from module1 import parse_arguments_module1

if __name__ == '__main__':
    args = parse_arguments_module1()
    print(args)
</code></pre>
<p>Use:</p>
<pre><code>python3 module2.py --argA A --argB B --argC C
</code></pre>
<p>Output:</p>
<blockquote>
<p>Namespace(argA='A', argB='B', argC='C', argD=None)</p>
</blockquote>
<p>The question is: how to read arguments in <code>module2.py</code> (<code>required</code> and/or <code>optional</code>) <em>additional</em> to those of <code>module1.py</code>? (I.e. have <code>args</code> in <code>main</code> contain more arguments, just for <code>module2.py</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd need to use <a href="https://docs.python.org/3/library/argparse.html#partial-parsing" rel="nofollow noreferrer"><em>partial parsing</em></a> with <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_known_args" rel="nofollow noreferrer"><code>parser.parse_known_args()</code></a> to achieve what you want, and / or pass your arguments as a list, explicitly.</p>
<p>Normally, without arguments <code>parser.parse_args()</code> takes all values from <code>sys.argv[1:]</code> (so everything but the first element) as the input to parse. If there are elements in that list that can't be parsed, then an error message is printed and <code>sys.exit(1)</code> is called; your script would exit.</p>
<p>So if you want <em>some</em> arguments on <code>sys.argv</code> to go to one parser, and the remainder to another, you want to use <code>parser.parse_known_args()</code> and pass the remainder to the other parser.</p>
<p>I'd split out creating and configuring the <code>ArgumentParser()</code> instances from parsing; so in <code>module1</code> do:</p>
<pre><code>def module1_argument_parser():
    parser = argparse.ArgumentParser()
    optional = parser._action_groups.pop()
    required = parser.add_argument_group('required arguments')
    required.add_argument('--argA', help='argA', required=True)
    required.add_argument('--argB', help='argB', required=True)
    optional.add_argument('--argC', help='argC')
    optional.add_argument('--argD', help='argD')
    parser._action_groups.append(optional)
    return parser

def parse_arguments_module1(args=None):
    parser = module1_argument_parser()
    return parser.parse_args(args)

if __name__ == '__main__':
    args = parse_arguments_module1()
    print(args)
</code></pre>
<p>and in <code>module2</code>, use the same structure, but re-use the parser from <code>module1</code>:</p>
<pre><code>from module1 import module1_argument_parser

def module2_argument_parser():
    parser = argparse.ArgumentParser()
    # create argument switches, etc.
    return parser

def parse_arguments_module2(args=None):
    parser = module2_argument_parser()
    return parser.parse_args(args)

if __name__ == '__main__':
    module1_parser = module1_argument_parser()
    module1_args, remainder = module1_parser.parse_known_args()
    module2_args = parse_arguments_module2(remainder)
    print(module1_args)
    print(module2_args)
</code></pre>
</div>
