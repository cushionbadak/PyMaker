<div class="post-text" itemprop="text">
<p>It's not hard to code <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">argparse</a> so it sets up a <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">basicConfig</a> with a lower <code>level</code> if the user supplies, say, a <code>--verbose</code> flag. Numerous StackOverflow questions address this.</p>
<p>But it seems like a lot of coding, for what seems like a pretty everyday use case. I would've thought somebody would've written a nice library that can set up an <code>ArgParser</code> to allow users to specify all sorts of <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">logging</a> options from the command line, with just a couple of lines of code.</p>
<p>I've also recently started using <a href="https://www.jetbrains.com/pycharm/" rel="nofollow noreferrer">PyCharm</a>, and was surprised that, out of the box, messages sent to <code>logger.debug</code> and even <code>logger.info</code> don't appear in the console. I imagined there'd be some PyCharm-related library I could import, to set up logging in some easily configurable, PyCharm-friendly way, when my program is being run within PyCharm.</p>
<p>Am I expecting too much, am I overlooking a Python feature, or am I just having a bad Google day? Do standard libraries exist for these things?</p>
<p>(A note for the off-topic police: I've asked whether <em>standard</em> libraries exist, and not for 'recommendations'.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I've found a couple of standard ways to configure logging from files. Hopefully PyCharm will eventually have plug-ins with nice GUIs for creating these files.</p>
<h1><code>fileConfig()</code>â€”The Simplest Way</h1>
<p>Use a <a href="https://docs.python.org/3/library/argparse.html#filetype-objects" rel="nofollow noreferrer">FileType argument</a> for ArgParse, for use as the logger's <a href="https://docs.python.org/3/library/logging.config.html#logging.config.fileConfig" rel="nofollow noreferrer"><code>fileConfig()</code></a>.</p>
<pre><code>import argparse
import logging
import logging.config

argument_parser = argparse.ArgumentParser()
argument_parser.add('--logging-conf-path', type=argparse.FileType('r'), 
        help='path to logging configuration file',
        default='./logging.conf',
)
args = argument_parser.parse_args()
if args.logging_conf_path:
    logging.config.fileConfig(args.logging_conf_path.name)  
</code></pre>
<p>It does come with this caveat, though:</p>
<blockquote>
<p><strong>Note:</strong> The <a href="https://docs.python.org/3/library/logging.config.html#logging.config.fileConfig" rel="nofollow noreferrer"><code>fileConfig()</code></a> API is older than the <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" rel="nofollow noreferrer"><code>dictConfig()</code></a> API and does not provide functionality to cover certain aspects of logging. For example, you cannot configure <a href="https://docs.python.org/3/library/logging.html#logging.Filter" rel="nofollow noreferrer"><code>Filter</code></a> objects, which provide for filtering of messages beyond simple integer levels, using <a href="https://docs.python.org/3/library/logging.config.html#logging.config.fileConfig" rel="nofollow noreferrer"><code>fileConfig()</code></a>. If you need to have instances of <a href="https://docs.python.org/3/library/logging.html#logging.Filter" rel="nofollow noreferrer"><code>Filter</code></a> in your logging configuration, you will need to use <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" rel="nofollow noreferrer"><code>dictConfig()</code></a>. Note that future enhancements to configuration functionality will be added to <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" rel="nofollow noreferrer"><code>dictConfig()</code></a>, so itâ€™s worth considering transitioning to this newer API when itâ€™s convenient to do so.</p>
</blockquote>
<p>But here's an <a href="https://docs.python.org/3/howto/logging.html#configuring-logging" rel="nofollow noreferrer">example</a> of a logging.conf file, which follows the <a href="https://docs.python.org/3/library/logging.config.html#logging-config-fileformat" rel="nofollow noreferrer">logging configuration file format</a> (which is where the caveat is noted):</p>
<pre><code>[loggers]
keys=root,simpleExample

[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

[logger_root]
level=DEBUG
handlers=consoleHandler

[logger_simpleExample]
level=DEBUG
handlers=consoleHandler
qualname=simpleExample
propagate=0

[handler_consoleHandler]
class=StreamHandler
level=DEBUG
formatter=simpleFormatter
args=(sys.stdout,)

[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
datefmt=
</code></pre>
<h1><code>dictConfig()</code>â€”The Complete Way</h1>
<p>This uses the <code>dictConfig()</code> recommended in the caveat above. Since my program already uses YAML files for configuration, I read the dict using <a href="https://pyyaml.org/" rel="nofollow noreferrer">PyYAML</a></p>
<pre><code>import argparse
import logging
import logging.config
import yaml

argument_parser = argparse.ArgumentParser()
argument_parser.add('--logging-yaml-path', type=argparse.FileType('r'), 
        help='path to logging configuration file',
        default='./logging.yaml',
)
args = argument_parser.parse_args()
if args.logging_yaml_path:
    log_config = yaml.load(args.logging_yaml_path)
    logging.config.dictConfig(log_config)
</code></pre>
<p>And here's an example of a logging.yaml file, which follows the <a href="https://docs.python.org/3/library/logging.config.html#logging-config-dictschema" rel="nofollow noreferrer">logging configuration dictionary schema</a>:</p>
<pre><code>version: 1
formatters:
  brief:
    format: '%(message)s'
  default:
    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'
    datefmt: '%Y-%m-%d %H:%M:%S'
handlers:
  console:
    class: logging.StreamHandler
    level: WARN
    formatter: brief
    stream: ext://sys.stdout
  file:
    class : logging.handlers.TimedRotatingFileHandler
    formatter: default
    filename: ./gmartian.log
    when: w0
    backupCount: 6
root:
  level: INFO
  handlers:
  - console
  - file
</code></pre>
</div>
<span class="comment-copy">Anything on Pypi?  That's as close to being 'standard' without being part of the main Python distribution.</span>
<span class="comment-copy">I'm a little puzzled about your goal.  Even if you found a parser that accepted a bunch of the logging parameters, how would you incorporate that with parsing application specific values?  Using the <code>parents</code> mechanism?  A standalone parser that uses <code>parse_known_args</code>?  <a href="https://stackoverflow.com/questions/52929014/python-read-command-line-args-with-argparse-in-addition-to-those-coming-from-an" title="python read command line args with argparse in addition to those coming from an">stackoverflow.com/questions/52929014/â€¦</a></span>
<span class="comment-copy">To be honest, I don't think that <code>parser = ArgumentParser(); parser.add_argument('--verbose', action='count', default=0); levels = [logging.ERROR, logging.WARN, logging.INFO, logging.DEBUG]; logging.basicConfig(level=levels[parser.parse_args().verbose])</code> deserves a special library just for that, recalling the <code>npm left-pad</code> story. However, there are lots of third-party libraries that are wrapping the stdlib code, what comes to mind is <code>click</code> with the <code>click-log</code> plugin, or <code>pycli</code>; you can try them out.</span>
<span class="comment-copy">@hpaulj: Something like that, yeah. I'm not exactly sure about what the details would be, but I've written utility libraries that accept <code>ArgParsers</code> myself, and I imagined this is something a buncho' bright people would've already done the thinking for.</span>
<span class="comment-copy">@hoefling: If it were just that, I'd agree with you. But there's more to the logging module than levels: filenames, formatters, etc. In any case, the only way I know to get PyCharm to display what I send to <code>logger.debug</code> or even <code>logger.info</code> is to write more code, and that smells. But maybe my code-nose is oversensitive. ðŸ¤·</span>
