<div class="post-text" itemprop="text">
<p>This problem has been intriguing, even though it's not necessarily neat.
I have the following code:</p>
<pre><code>import random

def d(m):
    return random.randint(1, m)

print(3*d(6))
</code></pre>
<p>This will print the returned value of d(6) and multiply that by 3. What I would like to have is to define a set of symbols so I can set that 3*d(6) will instead return: d(6) + d(6) + d(6). Alternatively is it possible to set the expression '3d6' to return what I want in a general case for XdY?</p>
<p>Is this solvable with wrappers / addition of symbols or do I have to go deeper and change stuff in the interpreter?</p>
<p>I'm trying to make the program read more naturally for the gaming genre.  In tabletop gaming, people say "2d6", which means 'throw two 6-sided dice'.  This has a different probability density function compared to 2*d(6).</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot have <code>3*d(6)</code> produce the effect of <code>d(6)+d(6)+d(6)</code> <em>and</em> have <code>d(6)</code> return an int. If you were creating objects representing probability distributions or something like that, you could overload <code>__rmul__</code> the way you want, but not with ints.</p>
<p>You can't have <code>3d6</code> evaluate to what you want either. <code>3d6</code> is not a valid Python token. You would have to alter and recompile the Python source code to produce your own Python variant with altered syntax, and it'd be a lot of work with little benefit.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're asking to redefine language elements, which would require altering the parser and action rules.  Yes, you can define a class and override the basic operations, but I fear that you'll get yourself into some untenable language situations.  <code>3d6</code> requires re-engineering Python; <code>3*d(6)</code> allows your class to take over, if carefully designed, but is still fraught with traps for you.  Since you had to ask this question in the first place ...</p>
<p>Instead, you should be thinking about how to program simple routines to do what you want with the given input.  For instance, you might want a function</p>
<pre><code>def roll(d_str):
</code></pre>
<p>which could take string input such as "3d6", "d20 + 1", and "2d8 + d10".  It would then perform the requested random generation and return the result of the roll as a simple integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't do this with a function call that returns an integer, but you could manage something similar with a class. The class can define a <code>__mul__</code> method that implements multiplication in any way it wants.</p>
<p>Here's a possible way to do it, where the <code>d</code> class is an object representing the abstract die roll (not a specific result), and you can roll the die by calling the instance:</p>
<pre><code>class d:
    def __init__(self, sides, count=1, offset=0):
        self.sides = sides
        self.count = count
        self.offset = offset

    def __mul__(self, num):
        return d(self.sides, self.count*num, self.offset*num)
    __rmul__ = __mul__

    def __add__(self, num):
        return d(self.sides, self.count, self.offset + num)
    __radd__ = __add__

    def __call__(self):
        return sum(random.randint(1, self.sides) for _ in range(self.count)) + self.offset
</code></pre>
<p>Use:</p>
<pre><code>x = 3*d(6) + 4
print(x()) # prints a number between 7 and 22 (with 14-15 being the most common)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a custom class and overload the * and + operations.</p>
<pre><code>class D:
    def __init__(self, sides):
        self.sides = sides

    def roll(self):
        return random.randint(1, self.sides)

    def __rmul__(self, other):
        if isinstance(other, int):
            return sum(self.roll() for _ in range(other))
        return NotImplemented

    def __mul__(self, other):
        if isinstance(other, D):
            return self.roll() * other.roll()
        return self.roll() * other

    def __add__(self, other):
        return self.roll() + other

    def __radd__(self, other):
        return self + other
</code></pre>
<p>Then you can do various arithmetic with D objects with this behaviour.</p>
<pre><code>&gt;&gt;&gt; D(6) * D(6)  # roll two dice and multiply the results
10
&gt;&gt;&gt; [3 * D(6) for n in range(20)]  # roll 3d6 20 times.
[8, 11, 12, 11, 16, 9, 11, 17, 6, 12, 8, 14, 9, 11, 13, 7, 11, 17, 8, 13]
</code></pre>
<p>If you want to roll a single die, you must either use the <code>roll()</code> method or multiply by 1.</p>
<pre><code>&gt;&gt;&gt; 1*D(6)
4
</code></pre>
<p>Note that since <code>__mul__</code> and <code>__rmul__</code> are different, there's a different behaviour, depending on whether the D object is on the right or left side of the operator.</p>
<pre><code>&gt;&gt;&gt; D(6) * 10  # rolls a single d6 and multiplies by 10
40
&gt;&gt;&gt; 10 * D(6)  # rolls 10 d6 and add the results
33
&gt;&gt;&gt; 2 * D(6) * 100  # rolls two dice and multiply the sum by 100
700
</code></pre>
<p>To get closer to the syntax you want, you can create D objects and call them <code>d4</code>, <code>d6</code> etc. A new random number will be generated each time you use a + or * operation on the name die.</p>
<pre><code>&gt;&gt;&gt; d4, d10, d20 = D(6), D(10), D(20)
&gt;&gt;&gt; 2*d4 + d20 + 7
32
&gt;&gt;&gt; 1*d20, 1*d20, 1*d20
(19, 3, 12)
</code></pre>
<p>See the python docs on <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">Emulating numeric types</a> for further explanation of these special operator methods.</p>
</div>
<span class="comment-copy">You can use a generator expression, which creates a for loop. <code>sum(d(6) for _ in range(2))</code>.</span>
<span class="comment-copy">Make a class and define its <code>__mul__</code> and other necessary methods.</span>
<span class="comment-copy">This can be generalized further to operations like <code>3*d(6) + 4*d(4) + d(12)</code> by storing lists of dice and multiplicities instead of just single sides and count numbers, or by storing a probability distribution.</span>
