<div class="post-text" itemprop="text">
<p>I understand why a <code>tuple</code> which contains a mutable object like <code>list</code> is not hashable, since <code>list</code> items in the tuple can still be updated.</p>
<p><strong>example:</strong></p>
<pre><code># hashable
tuple_test = (1,2,3)
print(tuple_test.__hash__())
</code></pre>
<p>While this is not hashable:</p>
<pre><code># Not hashable

tuple_test2 = (1,2, [1,2])
print(tuple_test2.__hash__())
</code></pre>
<p>The above make sense to me.</p>
<p>But when I create a <code>namedtuple</code> with <code>list</code> items it is still hashable:</p>
<pre><code># hashable
named_tuple = namedtuple("TestTuple", 'name age')
</code></pre>
<p>and when I add a <code>list</code>:</p>
<pre><code># still hashable
named_tuple = namedtuple("TestTuple", ["name", "age"])
print(named_tuple(name="adam", age=20).__hash__())
</code></pre>
<p>Why this difference between tuples and namedtuples?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But when I create a namedtuple with list as items it is still
  hashable...</p>
</blockquote>
<p>You never do that. You create a named-tuple with a <code>str</code>, <code>'adam'</code> and an <code>int</code>, <code>20</code></p>
<p>The following:</p>
<pre><code>named_tuple = namedtuple("TestTuple", 'name age')
</code></pre>
<p>And</p>
<pre><code>named_tuple = namedtuple("TestTuple", ["name", "age"])
</code></pre>
<p>Do <strong>not</strong> create <code>namedtuple</code> objects, they create <code>namedtuple</code> <em>classes</em>. According to the <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noreferrer">docs</a>:</p>
<blockquote>
<p>Returns a new tuple subclass named typename.</p>
</blockquote>
<p>In other words, <code>collections.namedtuple</code> is a factory function that returns a <em>class</em>. If you create instances of those classes, their instances follow the same rules as regular <code>tuple</code> instances.</p>
<p>So consider:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; TestTuple = namedtuple('TestTuple', ['name', 'age'])
&gt;&gt;&gt; type(TestTuple)
&lt;class 'type'&gt;
&gt;&gt;&gt; class A: pass
...
&gt;&gt;&gt; type(A)
&lt;class 'type'&gt;
</code></pre>
<p>TestTuple, the return value of the <code>namedtuple</code> factory function, <em>is not a namedtuple instance</em>, it is an instance of <code>type</code>, like all other classes.</p>
<p>When you create instances of this class:</p>
<pre><code>&gt;&gt;&gt; test_tuple = TestTuple('adam',32)
&gt;&gt;&gt; type(test_tuple)
&lt;class '__main__.TestTuple'&gt;
</code></pre>
<p>They follow the usual rules of hashability that regular <code>tuple</code> objects do:</p>
<pre><code>&gt;&gt;&gt; hash(test_tuple)
5589201399616687819
&gt;&gt;&gt; test_tuple = TestTuple('adam', [32, 31])
&gt;&gt;&gt; hash(test_tuple)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<p>Note, the fieldnames argument accepts either a sequence (e.g. a list) of fieldnames, or for convenience, a space/comma-delimited string of fieldnames, so also from the docs:</p>
<blockquote>
<p>...
  The field_names are a sequence of strings such as ['x', 'y'].
  Alternatively, field_names can be a single string with each fieldname
  separated by whitespace and/or commas, for example 'x y' or 'x, y'.</p>
</blockquote>
</div>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/11324271/what-is-the-default-hash-in-python" title="what is the default hash in python">stackoverflow.com/questions/11324271/â€¦</a></span>
<span class="comment-copy">"But when I create a namedtuple with list as items it is still hashable," Where do you do that? You create a named-tuple with a string, <code>'adam'</code> and an <code>int</code>, <code>20</code>...?</span>
<span class="comment-copy">Creating a <code>namedtuple</code> <i>class</i> via a <code>list</code> is not at all the same as creating an <i>instance</i> that <i>contains</i> a list.</span>
<span class="comment-copy">Write <code>hash(x)</code>, not <code>x.__hash__()</code>.</span>
