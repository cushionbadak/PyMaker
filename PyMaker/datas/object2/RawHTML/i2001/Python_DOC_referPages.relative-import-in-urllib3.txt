<div class="post-text" itemprop="text">
<p>I'm studying how python loads modules.</p>
<p>I'm starting from <code>requests</code> that loads <code>urllib3</code>.</p>
<p>I have found <a href="https://github.com/urllib3/urllib3/blob/cd7cfa613b2678e700597d098ce9bbdc934863e6/src/urllib3/exceptions.py#L2-L4" rel="nofollow noreferrer">those line</a>:</p>
<pre><code>from .packages.six.moves.http_client import (
  IncompleteRead as httplib_IncompleteRead
)
</code></pre>
<p>in file called <code>src/urllib3/exceptions.py</code></p>
<p>That import is a relative one, so I'm looking for the folder <code>src/urllib3/packages/six/moves/http_client.py</code> or <code>src/urllib3/packages/six/moves/http_client/__init__.py</code></p>
<p>Those files don't exist.</p>
<p>Thankfully <code>src/urllib3/packages/six.py</code> defines a new module loader, so the import <code>.packages.six.moves.http_client</code> requires <code>http_client</code> core python module instead.</p>
<p>But I don't understand how the <code>src/urllib3/packages/six.py</code> is loaded.
I've not found that kind of import.</p>
<p>Is there a way to know which module loads <code>src/urllib3/packages/six.py</code> directly?</p>
<p>I have tried with <code>__name__</code> global variable as suggested <a href="https://stackoverflow.com/questions/5286210/is-there-a-way-to-access-parent-modules-in-python/45895490">here</a>. Its value is <code>urllib3.packages.six</code> but <code>urllib3.packages</code> doesn't load that file.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>from .packages.six.moves.http_client import ...</code> expression causes <code>.packages.six</code> to be loaded <em>first</em>. Python always loads all packages in a nested package reference to a module.</p>
<p>So <code>.packages.six.moves.http_client</code> causes Python first to look for <code>urllib3.packages</code>, then for <code>urllib3.packages.six</code>, and so on. The import machinery does so by looking for the full name in <code>sys.modules</code>, and if it is not there, triggers a module search and load for each.</p>
<p>The first time this happens, <code>sys.modules['urllib3.packages.six']</code> doesn't exist yet, the import machinery finds the file <code>urllib3/packages/six.py</code>, imports that, <em>before</em> it'll look for more names.</p>
<p>And, as you discovered, the very act of importing the <code>six.py</code> module file, causes that module to add <code>sys.modules['urllib3.packages.six.moves']</code> and further references to standard library modules.</p>
<p>Python's import machinery is quite a complex beast; the Python reference documentation covers this comprehensively in <a href="https://docs.python.org/3/reference/import.html#regular-packages" rel="nofollow noreferrer"><em>The import system</em></a>; the specific entries to look for are:</p>
<blockquote>
<p>A direct call to <code>__import__()</code> performs only the module search and, if found, the module creation operation. While certain side-effects may occur, <strong>such as the importing of parent packages</strong>, and the updating of various caches (including sys.modules), only the import statement performs a name binding operation.</p>
</blockquote>
<p>and under <a href="https://docs.python.org/3/reference/import.html#regular-packages" rel="nofollow noreferrer"><em>Regular packages</em></a></p>
<blockquote>
<p>Importing <code>parent.one</code> will implicitly execute <code>parent/__init__.py</code> and <code>parent/one/__init__.py.</code> Subsequent imports of <code>parent.two</code> or <code>parent.three</code> will execute <code>parent/two/__init__.py</code> and <code>parent/three/__init__.py</code> respectively.</p>
</blockquote>
<p>and under <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer"><em>The module cache</em></a>:</p>
<blockquote>
<p>The first place checked during import search is <code>sys.modules</code>. This mapping serves as a cache of all modules that have been previously imported, <strong>including the intermediate paths</strong>. So if <code>foo.bar.baz</code> was previously imported, <code>sys.modules</code> will contain entries for <code>foo</code>, <code>foo.bar</code>, and <code>foo.bar.baz</code>. Each key will have as its value the corresponding module object.</p>
</blockquote>
<p><em>(bold emphasis in quoted sections added by me).</em></p>
<p>Note that everything in the <code>urllib3/packages</code> directory is a <em>vendorized</em> package; a project that normally would be installed independently, but which the <code>urllib3</code> project has decided to package up with their own distribution to avoid having to worry about what versions to support. <code>six</code> is such an independent project, you can install it <a href="https://pypi.org/project/six/" rel="nofollow noreferrer">from PyPI</a>.</p>
<p>You can find more information on the <a href="https://six.readthedocs.io/#module-six.moves" rel="nofollow noreferrer"><code>six.moves</code> virtual package</a> in the <a href="https://six.readthedocs.io/" rel="nofollow noreferrer"><code>six</code> project documentation</a>. It's purpose is to make it easier for library developers to write code that is compatible both with Python 2 and Python 3, without having to worry about what standard library name to import on either version.</p>
</div>
<div class="post-text" itemprop="text">
<p>One notable thing about import function in Python is that it can import not only modules themselves but also variables, classes, functions (generally namespaces) from inside them.
In the example, you have provided:</p>
<pre><code>from .packages.six.moves.http_client import (
  IncompleteRead as httplib_IncompleteRead
)
</code></pre>
<p>import statement refers to <strong>moves</strong> variable from <code>src/urllib3/packages/six.py</code> module, which is defined at line 316 of that file and being assigned to an instance of class <strong>_MovedItems</strong>:</p>
<pre><code>moves = _MovedItems(__name__ + ".moves")
</code></pre>
<p>and <strong>http_client</strong> is a property or method of this class instance</p>
</div>
<span class="comment-copy">The most notable is that the parts <i>before</i> the <code>import</code> in a <code>from ... import ...</code> statement must all be modules, those names will be looked up in <code>sys.modules</code> and no attributes will be consulted. So <b>for this specific situation</b>, where <code>urllib3.packages.six</code> installs virtual modules in <code>sys.modules['urllib3.packages.six.moves']</code> and onwards, it doesn't matter one bit that you can import attributes from the final module object.</span>
<span class="comment-copy">Wow, i didn't know that. You made it</span>
