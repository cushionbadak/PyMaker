<div class="post-text" itemprop="text">
<p>The following code tries to create-then-import two modules:</p>
<pre><code># coding: utf-8

import os
import time

# Remove the modules we're about to create if they already exist
def force_unlink(name):
    try:
        os.unlink(name)
    except OSError:
        pass
force_unlink("print1.py")
force_unlink("print1.pyc")
force_unlink("print2.py")
force_unlink("print2.pyc")
time.sleep(1)

# Create module 1 and module 2, then try to import them just afterwards
print("Creating module 1...")
with open("print1.py", "wb+") as fd:
    fd.write(b'print("Imported module 1")')
import print1
print("Creating module 2...")
with open("print2.py", "wb+") as fd:
    fd.write(b'print("Imported module 2")')
import print2
</code></pre>
<p>On Windows, both imports work under Python 2 (2.7), but not under Python 3 (3.5 and 3.6):</p>
<pre><code>$ python2 reproduce.py
Creating module 1...
Imported module 1
Creating module 2...
Imported module 2
$ python3 reproduce.py
Creating module 1...
Imported module 1
Creating module 2...
Traceback (most recent call last):
  File "reproduce.py", line 26, in &lt;module&gt;
    import print2
ImportError: No module named 'print2'
</code></pre>
<p>Adding <code>time.sleep(5)</code> before each <code>import printX</code> call makes it work.</p>
<p>Why is that?</p>
<p><em>Note: This is a simpler version of an <a href="https://github.com/enthought/comtypes/issues/161" rel="nofollow noreferrer">issue</a> I'm trying to figure out.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I think I know what is going on. The new Python 3 import machinery <em>caches</em> the filenames it finds in directories. It will reload the cache when the <code>mtime</code>, the modification time, of the directory changes.</p>
<p>See the <a href="https://github.com/python/cpython/blob/1bf9cc509326bc42cd8cb1650eb9bf64550d817e/Lib/importlib/_bootstrap_external.py#L1356-L1402" rel="nofollow noreferrer"><code>importlib._bootstrap_external.FileFinder.find_spec()</code> method implementation</a>, which contains:</p>
<pre><code>try:
    mtime = _path_stat(self.path or _os.getcwd()).st_mtime
except OSError:
    mtime = -1
if mtime != self._path_mtime:
    self._fill_cache()
    self._path_mtime = mtime
</code></pre>
<p>Here <code>_path_stat</code> is just a <code>os.stat()</code> call, but localised to avoid imports. The <code>_fill_cache()</code> method executes the <code>os.listdir()</code> call.</p>
<p>On some Windows filesystems, the resolution of <code>mtime</code> is notoriously low, up to 2 seconds. For your case, the resolution is apparently still low enough for the cache to <em>not</em> be updated by the time you try to load the second module. Although the NTFS filesystem can record times in 100ns increments, in practice the limiting factor there appears to be the Windows system clock, which I understand is usually limited to a resolution of 15ms. So if you write <code>print2.py</code> within 15ms of writing <code>print1.py</code>, then Python won't notice.</p>
<p>Python does give you the means to clear this cache; use the <a href="https://docs.python.org/3/library/importlib.html#importlib.invalidate_caches" rel="nofollow noreferrer"><code>importlib.invalidate_caches()</code> method</a>; this will reset the <code>_path_mtime</code> attribute on the <code>FileFinder</code> instance back to <code>-1</code>, forcing a new <code>_fill_cache()</code> call.</p>
<p>As the function's documentation states:</p>
<blockquote>
<p>This function should be called if any modules are created/installed while your program is running to guarantee all finders will notice the new moduleâ€™s existence.</p>
</blockquote>
</div>
<span class="comment-copy">The line numbers in your posted code don't match the line numbers in your error message. Can you run the version of the code you posted, and post the results of that?</span>
<span class="comment-copy">@user2357112 The original script had <code>coding: utf-8</code> on top. I added that, but it shouldn't really affect the results.</span>
<span class="comment-copy">Works fine in 3.7 on windows a well.</span>
<span class="comment-copy">Try generating temporary directories to put the files in, then import those. Or try writing the file into a temporary location, then move it into the final location (renames could trigger a different codepath). Or simpler still: write both files, then import them both <i>after</i> writing. Then generate a third and try to import that, and see if that 3rd module now fails. If that confirms there is a cache, try to see where the cache is located, in Python or on Windows. Use <code>os.listdir()</code>. Use <code>os.scandir()</code>, etc.</span>
<span class="comment-copy">Adding <code>time.sleep(5)</code> makes it import correctly, there's some kind of race condition here.</span>
