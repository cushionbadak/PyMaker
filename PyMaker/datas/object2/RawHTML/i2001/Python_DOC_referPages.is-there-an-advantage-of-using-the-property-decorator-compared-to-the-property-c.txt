<div class="post-text" itemprop="text">
<p>I can see two very similar ways of having properties in Python</p>
<h2>(a) Property class</h2>
<pre><code>class Location(object):

    def __init__(self, longitude, latitude):
        self.set_latitude(latitude)
        self.set_longitude(longitude)

    def set_latitude(self, latitude):
        if not (-90 &lt;= latitude &lt;= 90):
            raise ValueError('latitude was {}, but has to be in [-90, 90]'
                             .format(latitude))
        self._latitude = latitude

    def set_longitude(self, longitude):
        if not (-180 &lt;= longitude &lt;= 180):
            raise ValueError('longitude was {}, but has to be in [-180, 180]'
                             .format(longitude))
        self._longitude = longitude

    def get_longitude(self):
        return self._latitude

    def get_latitude(self):
        return self._longitude

    latitude = property(get_latitude, set_latitude)
    longitude = property(get_longitude, set_longitude)
</code></pre>
<h2>(b) Property decorator</h2>
<pre><code>class Location(object):

    def __init__(self, longitude, latitude):
        self.latitude = latitude
        self.longitude = latitude

    @property
    def latitude(self):
        """I'm the 'x' property."""
        return self._latitude

    @property
    def longitude(self):
        """I'm the 'x' property."""
        return self._longitude

    @latitude.setter
    def latitude(self, latitude):
        if not (-90 &lt;= latitude &lt;= 90):
            raise ValueError('latitude was {}, but has to be in [-90, 90]'
                             .format(latitude))
        self._latitude = latitude

    @longitude.setter
    def longitude(self, longitude):
        if not (-180 &lt;= longitude &lt;= 180):
            raise ValueError('longitude was {}, but has to be in [-180, 180]'
                             .format(longitude))
        self._longitude = longitude
</code></pre>
<h2>Question</h2>
<p>Are those two pieces of code identical (e.g. bytecode wise)? Do they show the same behavior? </p>
<p>Are there any official guides which "style" to use?</p>
<p>Are there any real advantages of one over the other?</p>
<h2>What I've tried</h2>
<h3>py_compile + uncompyle6</h3>
<p>I've compiled both:</p>
<pre><code>&gt;&gt;&gt; import py_compile
&gt;&gt;&gt; py_compile.compile('test.py')
</code></pre>
<p>and then decompiled both with <a href="https://pypi.org/project/uncompyle6/" rel="nofollow noreferrer">uncompyle6</a>. But that just returned exactly what I started with (with a bit different formatting)</p>
<h3>import + dis</h3>
<p>I tried</p>
<pre><code>import test  # (a)
import test2  # (b)
dis.dis(test)
dis.dis(test2)
</code></pre>
<p>I'm super confused by the output of <code>test2</code>:</p>
<pre><code>Disassembly of Location:
Disassembly of __init__:
 13           0 LOAD_FAST                2 (latitude)
              2 LOAD_FAST                0 (self)
              4 STORE_ATTR               0 (latitude)

 14           6 LOAD_FAST                2 (latitude)
              8 LOAD_FAST                0 (self)
             10 STORE_ATTR               1 (longitude)
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE
</code></pre>
<p>whereas the first one was way bigger:</p>
<pre><code>Disassembly of Location:
Disassembly of __init__:
 13           0 LOAD_FAST                0 (self)
              2 LOAD_ATTR                0 (set_latitude)
              4 LOAD_FAST                2 (latitude)
              6 CALL_FUNCTION            1
              8 POP_TOP

 14          10 LOAD_FAST                0 (self)
             12 LOAD_ATTR                1 (set_longitude)
             14 LOAD_FAST                1 (longitude)
             16 CALL_FUNCTION            1
             18 POP_TOP
             20 LOAD_CONST               0 (None)
             22 RETURN_VALUE

Disassembly of set_latitude:
 17           0 LOAD_CONST               3 (-90)
              2 LOAD_FAST                1 (latitude)
              4 DUP_TOP
              6 ROT_THREE
              8 COMPARE_OP               1 (&lt;=)
             10 JUMP_IF_FALSE_OR_POP    18
             12 LOAD_CONST               1 (90)
             14 COMPARE_OP               1 (&lt;=)
             16 JUMP_FORWARD             4 (to 22)
        &gt;&gt;   18 ROT_TWO
             20 POP_TOP
        &gt;&gt;   22 POP_JUMP_IF_TRUE        38

 18          24 LOAD_GLOBAL              0 (ValueError)
             26 LOAD_CONST               2 ('latitude was {}, but has to be in [-90, 90]')
             28 LOAD_ATTR                1 (format)
             30 LOAD_FAST                1 (latitude)
             32 CALL_FUNCTION            1
             34 CALL_FUNCTION            1
             36 RAISE_VARARGS            1

 19     &gt;&gt;   38 LOAD_FAST                1 (latitude)
             40 LOAD_FAST                0 (self)
             42 STORE_ATTR               2 (latitude)
             44 LOAD_CONST               0 (None)
             46 RETURN_VALUE

Disassembly of set_longitude:
 22           0 LOAD_CONST               3 (-180)
              2 LOAD_FAST                1 (longitude)
              4 DUP_TOP
              6 ROT_THREE
              8 COMPARE_OP               1 (&lt;=)
             10 JUMP_IF_FALSE_OR_POP    18
             12 LOAD_CONST               1 (180)
             14 COMPARE_OP               1 (&lt;=)
             16 JUMP_FORWARD             4 (to 22)
        &gt;&gt;   18 ROT_TWO
             20 POP_TOP
        &gt;&gt;   22 POP_JUMP_IF_TRUE        38

 23          24 LOAD_GLOBAL              0 (ValueError)
             26 LOAD_CONST               2 ('longitude was {}, but has to be in [-180, 180]')
             28 LOAD_ATTR                1 (format)
             30 LOAD_FAST                1 (longitude)
             32 CALL_FUNCTION            1
             34 CALL_FUNCTION            1
             36 RAISE_VARARGS            1

 24     &gt;&gt;   38 LOAD_FAST                1 (longitude)
             40 LOAD_FAST                0 (self)
             42 STORE_ATTR               2 (longitude)
             44 LOAD_CONST               0 (None)
             46 RETURN_VALUE
</code></pre>
<p>Where does that difference come from? Where is the value range check for the first example?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use the decorator, always. There is <em>no advantage</em> to the other syntax, and only disadvantages.</p>
<h2>The point of decorators</h2>
<p>That's because the decorator syntax was invented specifically to <em>avoid</em> the other syntax. Any examples you find of the <code>name = property(...)</code> variety is usually in code that predates decorators.</p>
<p>Decorator syntax is <em>syntactic sugar</em>; the form</p>
<pre><code>@decorator
def functionname(...):
    # ...
</code></pre>
<p>is executed a lot like</p>
<pre><code>def functionname(...):
    # ...

functionname = decorator(functionname)
</code></pre>
<p>without <code>functionname</code> being assigned to twice (the <code>def functionname(...)</code> part creates a function object and assigns to <code>functionname</code> normally, but with a decorator the function object is created and passed directly to the decorator object).</p>
<p>Python added this feature because when your function body is <em>long</em>, you can't easily see that the function has been wrapped with a decorator. You'd have to scroll down past the function definition to see that, and that's not very helpful when <em>almost everything else</em> you'd want to know about a function is right at the top; the arguments, the name, the docstring are right there.</p>
<p>From the original <a href="https://www.python.org/dev/peps/pep-0318/" rel="nofollow noreferrer">PEP 318 â€“ <em>Decorators for Functions and Methods</em></a> specification:</p>
<blockquote>
<p>The current method of applying a transformation to a function or method places the actual transformation after the function body. For large functions this separates a key component of the function's behavior from the definition of the rest of the function's external interface.</p>
<p>[...]</p>
<p>This becomes less readable with longer methods. It also seems less than pythonic to name the function three times for what is conceptually a single declaration.</p>
</blockquote>
<p>and under <em>Design Goals</em>:</p>
<blockquote>
<p>The new syntax should</p>
<ul>
<li>[...]</li>
<li>move from the end of the function, where it's currently hidden, to the front where it is more in your face</li>
</ul>
</blockquote>
<p>So using</p>
<pre><code>@property
def latitude(self):
    # ...

@latitude.setter
def latitude(self, latitude):
    # ...
</code></pre>
<p>is far more readable and <em>self documenting</em> than </p>
<pre><code>def get_latitude(self):
    # ...

def set_latitude(self, latitude):
    # ...

latitude = property(get_latitude, set_latitude)
</code></pre>
<h2>No namespace pollution</h2>
<p>Next, because the <code>@property</code> decorator replaces the function object you decorate with the decoration result (a <code>property</code> instance), you also avoid <em>namespace pollution</em>. Without <code>@property</code> and <code>@&lt;name&gt;.setter</code> and <code>@&lt;name&gt;.deleter</code>, you have to add <em>3 extra, separate names</em> to your class definition that then no-one will ever use:</p>
<pre><code>&gt;&gt;&gt; [n for n in sorted(vars(Location)) if n[:2] != '__']
['get_latitude', 'get_longitude', 'latitude', 'longitude', 'set_latitude', 'set_longitude']
</code></pre>
<p>Imagine a class with 5, or 10 or even more property definitions. Developers less familiar with the project and an auto-completing IDE will surely get confused by the difference between <code>get_latitude</code>, <code>latitude</code> and <code>set_latitude</code>, and you end up with code that mixes styles and makes it harder to now move away from exposing these methods at the class level.</p>
<p>Sure, you can use <code>del get_latitude, set_latitude</code> right after the <code>latitude = property(...)</code> assignment, but that's yet more extra code to execute for no real purpose.</p>
<h2>Confusing method names</h2>
<p>Although you can avoid having to prefix the accessor names with <code>get_</code> and <code>set_</code> or otherwise differentiate between the names to create a <code>property()</code> object from them, that's still how almost all code that doesn't use the <code>@property</code> decorator syntax ends up naming the accessor methods.</p>
<p>And that can lead to some confusion in tracebacks; an exception raised in one of the accessor methods leads to a traceback with <code>get_latitude</code> or <code>set_latitude</code> in the name, while the preceding line used <code>object.latitude</code>. It may not always be clear to the Python property novice how the two are connected, especially if they missed the <code>latitude = property(...)</code> line further down; see above.</p>
<h2>Accessing to the accessors, how to inherit</h2>
<p>You may point out that you may need access to those functions anyway; for example when overriding just the getter or a setter of for the property in a subclass, while inheriting the other accessor.</p>
<p>But the <code>property</code> object, when accessed on the class, <em>already</em> gives you references to the accessors, via the <code>.fget</code>, <code>.fset</code> and <code>.fdel</code> attributes:</p>
<pre><code>&gt;&gt;&gt; Location.latitude
&lt;property object at 0x10d1c3d18&gt;
&gt;&gt;&gt; Location.latitude.fget
&lt;function Location.get_latitude at 0x10d1c4488&gt;
&gt;&gt;&gt; Location.latitude.fset
&lt;function Location.set_latitude at 0x10d195ea0&gt;
</code></pre>
<p><strong>and</strong> you can reuse the <code>@&lt;name&gt;.getter</code> / <code>@&lt;name&gt;.setter</code> / <code>@&lt;name&gt;.deleter</code> syntax in a subclass without having to remember to create a new <code>property</code> object!</p>
<p>With the old syntax, it was commonplace to try to override just one of the accessors:</p>
<pre><code>class SpecialLocation(Location):
    def set_latitude(self, latitude):
        # ...
</code></pre>
<p>and then wonder why it would not be picked up by the inherited <code>property</code> object.</p>
<p>With the decorator syntax, you'd use:</p>
<pre><code>class SpecialLocation(Location):
    @Location.latitude.setter
    def latitude(self, latitude):
        # ...
</code></pre>
<p>and the <code>SpecialLocation</code> subclass then is given a new <code>property()</code> instance with the getter inherited from <code>Location</code>, and with a new setter.</p>
<h2>TLDR</h2>
<p>Use the decorator syntax. </p>
<ul>
<li>It is self-documenting</li>
<li>It avoids namespace pollution</li>
<li>It makes inheriting accessors from properties cleaner and more straightforward</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The results of the two versions of your code will be almost exactly the same. The property descriptor you have at the end will be functionally identical in both cases. The only difference in the descriptors will be in the function names you can access if you really try (via <code>Location.longitude.fset.__name__</code>), and that you might see in an exception traceback, if something goes wrong.</p>
<p>The only other difference is the presence of the <code>get_foo</code> and <code>set_foo</code> methods after you're done. When you use <code>@property</code>, you won't have those methods cluttering up the namespace. If you build the <code>property</code> object yourself manually, they will remain in the class namespace, and so you can call them directly if you really want to instead of using normal attribute access via the <code>property</code> object.</p>
<p>Unusually the <code>@property</code> syntax is better since it hides the methods, which you usually don't need. The only reason I can think of that you might want to expose them is if you expect to pass the methods as callbacks to some other function (e.g. <code>some_function(*args, callback=foo.set_longitude)</code>). You could just use a <code>lambda</code> though for the callback though (<code>lambda x: setattr(foo, "longitude", x)</code>), so I don't think it's worth polluting a nice API with extraneous getter and setter methods just for this corner case.</p>
</div>
<span class="comment-copy">There is a huge difference: with the first example, a using code doing <code>Location().latitude = 10</code> will bypass any validation that <code>set_latitude</code> is doing. <code>set_latitude</code> would not even be called.</span>
<span class="comment-copy">@DeepSpace Please have a look at the last edit - I made a copy-paste error when creating the question.</span>
<span class="comment-copy">That makes way more sense.</span>
<span class="comment-copy">You forgot to write the getters, though, and your <code>longitude</code> property is using the <code>latitude</code> methods.</span>
<span class="comment-copy">I suggest that when you get both versions working the same (and correctly), that you try using the <a href="https://docs.python.org/3/library/timeit.html#module-timeit" rel="nofollow noreferrer"><code>timeit</code></a> module to see if one is faster than the other and by how muchâ€”what bytecode is being generated may or may not really matter as far as performance goes.</span>
<span class="comment-copy">I think the last point is by far the most important one. I don't see case for the first one and not the severity of the second one</span>
<span class="comment-copy">Thank you for your answer :-) as always, it is a pleasure to learn from you :-)</span>
<span class="comment-copy">Oh, and thanks for explaining why it works. I was super confused why two functions with the same name don't simply override themselves. That was the main point why I didn't like the decorator; I hate magic in my code</span>
