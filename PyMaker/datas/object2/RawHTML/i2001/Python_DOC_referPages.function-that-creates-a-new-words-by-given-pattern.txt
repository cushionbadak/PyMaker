<div class="post-text" itemprop="text">
<p>im trying to create a function that takes a word (capital letters and lowercase letters) and map each character to a new character. the pattern is each vowel (AEIOU) becomes the next vowel in order (A -&gt; E, E - &gt; I). For constant letters becomes the thirds letter (B -&gt; F, C -&gt; G) </p>
<pre><code>&gt;&gt;&gt;'hello'
'lippu'
&gt;&gt;&gt; 'today'
'xuhec'
&gt;&gt;&gt; 'yesterday'
'ciwxivhec'
</code></pre>
<p>I know that i would have to create two lists:</p>
<pre><code>vowels = ['a', 'e', 'i', 'o', 'u']
constants = ['b', 'c','d','f','g','h','j','k','l','m','n','p', 'q','r', 's','t','v','w','x','y', 'z']
</code></pre>
<p>and uses the index() function, to check the current index and add 3 to it, but im stuck after that.</p>
<p>Letters loop back around for cases that extend beyond the list. (x-z, and u)</p>
</div>
<div class="post-text" itemprop="text">
<p>To compute the maps you can use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> (to get the index of the current) together with modulo (for the indices greater than the list length), something like this:</p>
<pre><code>vowels = ['a', 'e', 'i', 'o', 'u']
consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']

vowels_map = {k: vowels[(i + 1) % len(vowels)] for i, k in enumerate(vowels)}
consonants_map = {k: consonants[(i + 3) % len(consonants)] for i, k in enumerate(consonants)}

print(vowels_map)
print(consonants_map)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'u': 'a', 'a': 'e', 'o': 'u', 'e': 'i', 'i': 'o'}
{'s': 'w', 'z': 'd', 'v': 'y', 'm': 'q', 'f': 'j', 'h': 'l', 'd': 'h', 'g': 'k', 'q': 't', 'n': 'r', 'p': 's', 'k': 'n', 't': 'x', 'y': 'c', 'r': 'v', 'w': 'z', 'x': 'b', 'l': 'p', 'b': 'f', 'j': 'm', 'c': 'g'}
</code></pre>
<p>Note that dictionaries have no order, that being said you could use them in the following way:</p>
<pre><code>def replace_from_dict(word, table):
    return ''.join(table[c] for c in word)


words = ['hello',
         'today',
         'yesterday']

for word in words:
    print(replace_from_dict(word, { **vowels_map, **consonants_map }))
</code></pre>
<p><strong>Output</strong> <em>(from using replace_from_dict)</em></p>
<pre><code>lippu
xuhec
ciwxivhec
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use <code>itertools.cycle</code>. First check which category <code>i</code> belongs to either <code>vowel</code> or <code>consonants</code> (not constant). Then create a <code>cycle</code> from that respective list, use <code>while</code> and <code>next</code> until we are at the corresponding letter. If its a <code>vowel</code> we simply append the <code>next</code> value, if its a <code>consonant</code> we advance 2 positions and then append the <code>next</code> value. After use <code>.join()</code> to convert back to string.</p>
<pre><code>from itertools import cycle

vwl = ['a', 'e', 'i', 'o', 'u']
cnst = ['b', 'c','d','f','g','h','j','k','l','m','n','p', 'q','r', 's','t','v','w','x','y', 'z']

s = 'hello'
new = []
for i in s.lower():
    if i in vwl:
        a = cycle(vwl)
        while i != next(a):
            next(a)    
        new.append(next(a))
    if i in cnst:
        b = cycle(cnst)
        while i != next(b):
            next(b)
        for x in range(2):
            next(b)
        new.append(next(b))

res = ''.join(new)
print(res)
# lippu
</code></pre>
<p>Works for words that include edge letters, <code>zumba</code> produces <code>daqfe</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I have defined two dictionaries for edge cases, vowel_dictionary, and a dictionary for letters x/y/z to achieve wrapping. I iterated through the string and if the character is a special character, I use the appropriate dictionary to find the word. However if the character is below 'w' and not a vowel, I just add 4 to its <code>ord</code> value (ASCII value) and convert it char. </p>
<pre><code>def transform(input):
  return_string = ""
  vowel_dictionary = {
    'a': 'e',
    'e': 'i',
    'i': 'o',
    'o': 'u',
    'u': 'a'
  }
  edge_dictionary = {
    'x': 'b',
    'y': 'c',
    'z': 'd'
  }
  for character in input.lower():
    if character in vowel_dictionary:
      return_string += vowel_dictionary[character]
    elif ord(character) &lt;= ord("v"):
      return_string += chr(ord(character) + 4)
    else :
      return_string += edge_dictionary[character]

  return return_string
</code></pre>
<p>I have ran a few tests with the code above:</p>
<p><strong>Tests</strong></p>
<pre><code>transform("hello") # =&gt; lippu

transform("today") # =&gt; xuhec

transform("yesterday") # =&gt; ciwxivhec
</code></pre>
</div>
<span class="comment-copy">What happens to constant letters for example: Z, z: where we can't add 3 to the index?</span>
<span class="comment-copy">@killuminati as well as <code>u</code></span>
<span class="comment-copy">it will start at a again so (z -&gt; d)  (u -&gt; a) @vash_the_stampede @ killuminati</span>
<span class="comment-copy">is z -&gt; c or z -&gt; d?</span>
<span class="comment-copy">oh, I was thinking of using mod (%) to wrap around the list. Will that work? (assuming we are unable to import)</span>
<span class="comment-copy">@errick-michael-santos sorry no longer by PC but hmm if I were not to use cycle I would prob use try except and once stop iteration occurs restart the iter and continue, can show when I return would work the same as the cycle concept just manual going back to the beginning</span>
