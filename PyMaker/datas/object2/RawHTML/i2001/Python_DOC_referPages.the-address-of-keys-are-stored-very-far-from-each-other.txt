<div class="post-text" itemprop="text">
<p>I'd like to explore the hash table,</p>
<pre><code>In [1]: book = {"apple":0.67, "milk":1.49, "avocado":1.49, "python":2}   
In [5]: [hex(id(key)) for key in book]                                                                            
Out[5]: ['0x10ffffc70', '0x10ffffab0', '0x10ffffe68', '0x10ee1cca8']
</code></pre>
<p>The addresses tell that the keys are far away from each other,  especially key "python",<br/>
I assumed that they are adjacent to one another.</p>
<p>How could this happen? Is it running in high performance?                                </p>
</div>
<div class="post-text" itemprop="text">
<p>There are two ways we can interpret your confusion: either you expected the <code>id()</code> to be the hash function for the keys, or you expected keys to be relocated to the hash table and, since in CPython the <code>id()</code> value is a memory location, that the <code>id()</code> values would say something about the hash table size. We can address both by talking about Python's dictionary implementation and how Python deals with objects in general.</p>
<p>Python dictionaries are implemented as a <a href="https://en.wikipedia.org/wiki/Hash_table" rel="nofollow noreferrer">hash table</a>, which is a table of <em>limited size</em>. To store keys, a <em>hash function</em> generates an integer (same integer for equal values), and the key is stored in a slot based on that number using a modulo function:</p>
<pre><code>slot = hash(key) % len(table)
</code></pre>
<p>This can lead to collisions, so having a large range of numbers for the hash function to pick from is going to help reduce the chances there are such collisions. You still have to deal with collisions anyway, but you want to minimise that.</p>
<p>Python does not use the <code>id()</code> function as a hash function here, because that would not produce the same hash for equal values! If you didn't produce the same hash for equal values, then you couldn't use multiple <code>"hello world"</code> strings as a means to find the right slot again, as <code>dictionary["hello world"] = "value"</code> then <code>"hello world" in dictionary</code> would produce different <code>id()</code> values and thus hash to different slots and you would not that the specific string value has already  been used as a key.</p>
<p>Instead, objects are expected to implement a <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code> method</a>, and you can see what that method produces for various objects with the <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer"><code>hash()</code> function</a>.</p>
<p>Because keys stored in a dictionary must remain <em>unchanged</em>, Python won't let you store mutable types in a dictionary. Otherwise, if you can change their value, they would no longer be equal to another such object with the old value and shame hash, and you wouldn't find them in the slot that their new hash would map to.</p>
<p>Note that Python puts all objects in a <a href="https://en.wikipedia.org/wiki/Memory_management#HEAP" rel="nofollow noreferrer">dynamic heap</a>, and uses references everywhere to relate the objects. Dictionaries hold references to keys and values; putting a key into a dictionary does not re-locate the key in memory and the <code>id()</code> of the key won't change. If keys were relocated, then a requirement for the <code>id()</code> function would be violated, the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">documentation</a> states: <em>This is an integer which is guaranteed to be unique and constant for this object during its lifetime</em>.</p>
<p>As for those collisions: Python deals with collisions by looking for a new slot with a fixed formula, finding an empty slot in a predictable but psuedorandom series of slot numbers; see the <a href="https://github.com/python/cpython/blob/7f34d550231e047c88a1817b58bda03a33817490/Objects/dictobject.c#L131-L223" rel="nofollow noreferrer"><code>dictobject.c</code> source code comments</a> if you want to know the details. As the table fills up, Python will dynamically grow the table to fit more elements, so there will always be empty slots.</p>
</div>
<span class="comment-copy">That's not how Python hashes keys...</span>
<span class="comment-copy">@MartijnPieters I don't think the question has anything to do with hashes. I think the OP thinks the keys are physically located (allocated) inside the dictionary.</span>
<span class="comment-copy">hash table is not an array in its nature? @Aran-Fey</span>
<span class="comment-copy">@Aran-Fey: Perhaps, I'll make sure to cover that angle too.</span>
<span class="comment-copy">I deeply appreciate your tutorial, Master Martjin.</span>
