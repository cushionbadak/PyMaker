<div class="post-text" itemprop="text">
<p>I am trying to run a <code>*.py</code> file as a background service in <em>Jupiter notebook</em>.</p>
<pre><code>from IPython.lib import backgroundjobs as bg
jobs = bg.BackgroundJobManager()
jobs.new(%run -i "script.py") # Not working
jobs.new("script.py") # Not working
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ipython/Jupyter background jobs is designed to run either plain code to <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval</code></a> (string), or function. Files and ipython magic commands is not supported.</p>
<p>One thing you can do is to simply read file content and pass it to <code>eval</code>:</p>
<pre><code>from IPython.lib.backgroundjobs import BackgroundJobFunc

with open('script.py') as code:
    job = BackgroundJobFunc(exec, code.read())

result = job.run()
</code></pre>
<p><a href="https://ipython.readthedocs.io/en/stable/api/generated/IPython.lib.backgroundjobs.html?highlight=BackgroundJobManager#IPython.lib.backgroundjobs.BackgroundJobManager" rel="nofollow noreferrer"><code>BackgroundJobManager</code></a> is pretty much the same, but a little bit "smarter".</p>
<p>Side note: all background machinery behind this interfaces runs in threads of the same process and share interpreter state and output. So, just keep in mind:</p>
<ul>
<li>this is not suited for computational-heavy scripts</li>
<li>never run untrusted code this way â€” this applies to <code>eval</code> overall, but in this case you can into situation when you'll never get GIL back to your "frontend" thread</li>
<li>avoid scripts that use stdout, most probably those will clutch with your main thread</li>
</ul>
</div>
