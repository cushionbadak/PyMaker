<div class="post-text" itemprop="text">
<p>I have a nested list of the form:</p>
<pre><code>[[[a, [a1, a2, a3]],[b, [b1, b2, b3]], [c, [c1, c2, c3]]]
</code></pre>
<p>How can I get this into unique combinations of the initial elements, of the form: </p>
<pre><code>[[[a, b],[a1, a2, a3, b1, b2, b3]],[[a,c],[a1, a2, a3, c1, c2, c3]], [[b,c],[b1, b2, b3, c1, c2, c3]]]
</code></pre>
<p>I know that's a lot of lists, but I need it in that form. I don't have an idea where to begin.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.combinations</code>:</p>
<pre><code>from itertools import combinations
l = [['a', ['a1', 'a2', 'a3']],['b', ['b1', 'b2', 'b3']], ['c', ['c1', 'c2', 'c3']]]
print([[[i for i, _ in c], [i for _, l in c for i in l]] for c in combinations(l, 2)])
</code></pre>
<p>This outputs:</p>
<p><code>[[['a', 'b'], ['a1', 'a2', 'a3', 'b1', 'b2', 'b3']], [['a', 'c'], ['a1', 'a2', 'a3', 'c1', 'c2', 'c3']], [['b', 'c'], ['b1', 'b2', 'b3', 'c1', 'c2', 'c3']]]
</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Nevermind, I solved it. Here is a working example.</p>
<pre><code>test = [['a', ['a1', 'a2', 'a3']],['b', ['b1', 'b2', 'b3']], ['c', ['c1', 'c2', 'c3']]]

nested_list = []
for (idx1, idx2) in itertools.combinations(range(len(test)), r=2):
    (elem1, elem2), (elem3, elem4) = test[idx1], test[idx2]
    nested_list += [[elem1, elem3], elem2+elem4]

nested_list

[['a', 'b'],
 ['a1', 'a2', 'a3', 'b1', 'b2', 'b3'],
 ['a', 'c'],
 ['a1', 'a2', 'a3', 'c1', 'c2', 'c3'],
 ['b', 'c'],
 ['b1', 'b2', 'b3', 'c1', 'c2', 'c3']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>:</p>
<pre><code>from itertools import combinations, chain

L = [['a', ['a1', 'a2', 'a3']], ['b', ['b1', 'b2', 'b3']], ['c', ['c1', 'c2', 'c3']]]

d = dict(L)

res = {comb: list(chain.from_iterable(map(d.__getitem__, comb))) \
       for comb in combinations(d, 2)}
</code></pre>
<p>Result:</p>
<pre><code>{('a', 'b'): ['a1', 'a2', 'a3', 'b1', 'b2', 'b3'],
 ('a', 'c'): ['a1', 'a2', 'a3', 'c1', 'c2', 'c3'],
 ('b', 'c'): ['b1', 'b2', 'b3', 'c1', 'c2', 'c3']}
</code></pre>
<p>Or, if you prefer nested lists:</p>
<pre><code>res_lst = [[list(comb), list(chain.from_iterable(map(d.__getitem__, comb)))] \
           for comb in combinations(d, 2)]

# [[['a', 'b'], ['a1', 'a2', 'a3', 'b1', 'b2', 'b3']],
#  [['a', 'c'], ['a1', 'a2', 'a3', 'c1', 'c2', 'c3']],
#  [['b', 'c'], ['b1', 'b2', 'b3', 'c1', 'c2', 'c3']]]
</code></pre>
<p>The idea, in both cases, is to reduce the number of Python-level <code>for</code> loops.</p>
</div>
<span class="comment-copy">I beat you to it. See the other answer :)</span>
<span class="comment-copy">Good job, though keep in mind that iterating through indices isn't the Pythonic way.</span>
<span class="comment-copy">You are right, your answer is more elegant than mine, so I will choose it as the correct answer.</span>
