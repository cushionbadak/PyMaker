<div class="post-text" itemprop="text">
<p>I'm serialising <code>__dict__</code> to mongo, but I want to intercept setting
<code>laden</code> t. How can I do that without having to rename the attribute to
<code>_laden</code> in order to use a property with a setter? </p>
<p>I know that I could replace my existing <code>laden</code> attribute with a <code>property</code>, and use a setter this way:</p>
<pre><code>def Swallow:
    def __init__(self):
        self._laden = None

    @property
    def laden(self):
        return self._laden

    @laden.setter
    def laden(self, laden):
        updated = some_new_code(laden)
        self._laden = updated
</code></pre>
<p>But that means that serialising <code>__dict__</code> would store the name <code>_laden</code> in the database, not <code>laden</code>, breaking my existing stored data.</p>
<p>I would really like it to be:</p>
<pre><code>def Swallow:
    def __init__(self):
        self.laden = None

    @property
    def laden(self):
        return self.laden

    @laden.setter
    def laden(self, laden):
        updated = some_new_code(laden)
        self.laden = updated
</code></pre>
<p>But in the latter case the setter calls itself - generally it doesn't work.</p>
<p>Is this achievable? Any thoughts?</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that your real question is this:</p>
<blockquote>
<p>I'm serialising <code>__dict__</code> to mongo, but I want to intercept setting <code>laden</code>. How can I do that without having to rename the attribute to <code>_laden</code> in order to use a property with a setter?</p>
</blockquote>
<p>You can't just assign no the same name on the instance, no. <code>self.laden</code> is and always will be handled by the <code>property</code> object. If you are interested in the technical nitty gritty, then read the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor howto</a>; a <code>property</code> object is a <em>data descriptor</em> which means that all access to <code>instance.name</code> is handled exclusively by the  <code>type(instance).name</code> property object. No exceptions.</p>
<p>You <em>can</em> do any of the following:</p>
<ul>
<li><p>Access the same name in <code>self.__dict__</code>:</p>
<pre><code>@property
def laden(self):
    return self.__dict__['laden']

@laden.setter
def laden(self, laden):
    updated = some_new_code(laden)
    self.__dict__['laden'] = updated
</code></pre>
<p>This bypasses the normal <code>object.attribute</code> paths and goes straight to the source.</p></li>
<li><p>Not use a property; you can intercept attribute setting on instances with the <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__()</code> hook</a>:</p>
<pre><code>def __setattr__(self, name, value):
    if name == 'laden':
        value = some_new_code(laden)
    super().__setattr__(name, value)
</code></pre>
<p>This would intercept all <code>instance.some_name</code> access, but only if <code>some_name</code> is <code>'laden'</code> will you actually do something with that value.</p></li>
<li><p>Define a custom method on a base class that can handle serialisation for you, and add configuration to your class to the method looks for to help it decide what attributes to serialise, or let the method autodetect <code>property</code> objects. That'd let you include a <code>_name</code> to <code>name</code> translation.</p></li>
<li><p>Use a <a href="http://api.mongodb.com/python/current/tools.html" rel="nofollow noreferrer">MongoDB ORM library</a> to handle your object serialisation. I'm sure some of those allow for custom setters for their fields, or at least allow for defining your own custom field types that let you alter values on setting.</p></li>
</ul>
</div>
<span class="comment-copy">I've edited your question to be useful for future visitors; they don't really care how the question evolved, just that they get to see if they have the same problem and what the answer is. 'Edit' markers are no use to them, and for anyone that is following along right now, there is always the post history view and the 'edited' marker at the bottom.</span>
<span class="comment-copy">A truly thorough answer! Thank you for that.</span>
