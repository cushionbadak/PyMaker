<div class="post-text" itemprop="text">
<p>I'm writing a Python Flask app, and would like to set log levels for my own code only. If I set the root logger to DEBUG I get spammed with output, so I thought I'd set up my own logger that I can set the log level for.</p>
<p>This is the code that run on startup:</p>
<pre><code># File: server/__init__.py

import logging
def create_app(config=None):
    log = logging.getLogger("api_log")
    log.setLevel("DEBUG")
    print("Log level: " + logging.getLevelName(log.level)) # Outputs "DEBUG"
    log.debug("Does not show")
    log.warning("Does show")
</code></pre>
<p>For some reason, even after adjusting the log level to <code>DEBUG</code>, the <code>log.debug</code> command doesn't output anything to file. </p>
<p>Can anyone spot what I'm doing wrong? </p>
<p>EDIT #1: When I add a handler, <code>log.addHandler(logging.StreamHandler())</code> in my case, the <code>DEBUG</code> statements are output'ed to the console. I don't understand why I need to create another handler to get the output right. It also messes up my test code output, but I'll create another post for that issue. </p>
</div>
<div class="post-text" itemprop="text">
<p>The following two paragraphs from the <a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="nofollow noreferrer">Logging HOWTO</a> documentation explain why you have to set a handler:</p>
<blockquote>
<p>Loggers have a concept of effective level. If a level is not explicitly set on a logger, the level of its parent is used instead as its effective level. If the parent has no explicit level set, its parent is examined, and so on - all ancestors are searched until an explicitly set level is found. <strong>The root logger always has an explicit level set (WARNING by default).</strong> When deciding whether to process an event, the effective level of the logger is used to determine whether the event is passed to the logger’s handlers.</p>
<p>Child loggers propagate messages up to the handlers associated with their ancestor loggers. Because of this, it is unnecessary to define and configure handlers for all the loggers an application uses. It is sufficient to configure handlers for a top-level logger and create child loggers as needed. (You can, however, turn off propagation by setting the propagate attribute of a logger to False.)</p>
</blockquote>
<p>There are two key points here:</p>
<ol>
<li>A logger passes its messages to a handler to decide if the message should be logged or not.</li>
<li>Before you explicitly set the handler, the default one (with its level set to WARNING) was used.</li>
</ol>
</div>
<span class="comment-copy">see if this helps <a href="https://docs.python.org/2/howto/logging-cookbook.html#logging-to-multiple-destinations" rel="nofollow noreferrer">docs.python.org/2/howto/…</a></span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/46700371/python-logging-root-logger-does-not-show-info-even-if-i-set-the-level-to-info" title="python logging root logger does not show info even if i set the level to info">stackoverflow.com/questions/46700371/…</a></span>
<span class="comment-copy">But why is it that when the OP calls <code>log.setLevel(logging.DEBUG)</code> the level of the default handler is not changed? I find this behavior somewhat perplexing. After experimenting a bit, it seems like <code>log.setLevel(logging.DEBUG)</code> does not affect the <code>lastResort</code> default handler (see code in link I gave in comment above). In fact, <code>logging.root.handlers</code> gives an empty list, which means there is actually no handler other than the one named <code>lastResort</code>. But once we use the default logger, for e.g., by calling <code>logger.error(...)</code>, a <code>StreamHandler</code> will be added and <code>setLevel</code> will apply to it.</span>
<span class="comment-copy">@lightalchemist Other modules could be using that handler. I guess <code>setLevel</code> shouldn't change the inherited handler's level for everyone, just its own handler, if it has one.</span>
