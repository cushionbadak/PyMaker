<div class="post-text" itemprop="text">
<p>I have a function that calls <code>subprocess.check_call()</code> twice. I want to test all their possible outputs. I want to be able to set the first <code>check_call()</code> to return 1 and the second to return 0 and to do so for all possible combinations. The below is what I have so far. I am not sure how to adjust the expected return value</p>
<pre><code>@patch('subprocess.check_call')
def test_hdfs_dir_func(mock_check_call):
    for p, d in list(itertools.product([1, 0], repeat=2)):
        if p or d:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can assign the <code>side_effect</code> of your mock to an iterable and that will return the next value in the iterable each time it's called. In this case, you could do something like this:</p>
<pre><code>import copy
import itertools
import subprocess

from unittest.mock import patch

@patch('subprocess.check_call')
def test_hdfs_dir_func(mock_check_call):
    return_values = itertools.product([0, 1], repeat=2)
    # Flatten the list; only one return value per call
    mock_check_call.side_effect = itertools.chain.from_iterable(copy.copy(return_values))
    for p, d in return_values:
        assert p == subprocess.check_call()
        assert d == subprocess.check_call()
</code></pre>
<p>Note a few things:</p>
<ul>
<li>I don't have your original functions so I put my own calls to <code>check_call</code> in the loop.</li>
<li>I'm using copy on the original <code>itertools.product</code> return value because if I don't, it uses the original iterator. This exhausts that original iterator when what we want is 2 separate lists: one for the mock's side_effect and one for you to loop through in your test.</li>
<li>You can do other neat stuff with <code>side_effect</code>, not just raise. As shown above, you can change the return value for multiple calls: <a href="https://docs.python.org/3/library/unittest.mock-examples.html#side-effect-functions-and-iterables" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock-examples.html#side-effect-functions-and-iterables</a>
<ul>
<li>Not only that, but you can see from the link above that you can also give it a function pointer. That allows you to do even more complex logic when keeping track of multiple mock calls.</li>
</ul></li>
</ul>
</div>
<span class="comment-copy">what about just storing the previous state with a toggle (global variable)</span>
<span class="comment-copy">general note: you don't need to force iteration just do <code>for p, d in itertools.product([1, 0], repeat=2):</code></span>
