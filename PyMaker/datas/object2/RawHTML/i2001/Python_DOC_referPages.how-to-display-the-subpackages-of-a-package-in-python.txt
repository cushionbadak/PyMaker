<div class="post-text" itemprop="text">
<p>I have some third party library called <code>a</code> and from code examples I learned it has a subpackage <code>b1</code>, i.e.,</p>
<pre><code>from a import b1
</code></pre>
<p>Is it possible to see all the subpackages of <code>a</code>? Package <code>a</code> is not pure python and it is not obvious from the file structure to tell the subpackages. I tried <code>dir</code> but it only shows attributes of <code>a</code></p>
<pre><code>import a
dir(a)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the package author provided an explict index of the package modules, then the convention is to define a list named <a href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package" rel="nofollow noreferrer"><code>__all__</code></a> that contains this index. So you could do something like the following to see all the submodules / subpackages of an imported package (example prints all json submodules as determined by the package author):</p>
<pre><code>import json

subs = json.__all__
print(subs)

# OUTPUT
# ['dump', 'dumps', 'load', 'loads', 'JSONDecoder', 'JSONDecodeError', 'JSONEncoder']
</code></pre>
<p>If the package author did not provide an index of the package modules, then it will be much more difficult to sort it out. One approach would be to use <code>dir</code> and then sort or filter the attributes by type in an effort to narrow down to a set likely to be submodules / subpackages. Here is an example that might be useful.</p>
<pre><code>import json

def sort_by_type(t):
    return t[0].__name__

attrs = [(type(getattr(json, attr)), attr) for attr in dir(json)]
attrs.sort(key=sort_by_type)
for t, n in attrs:
    print(t, n)

# OUTPUT
# &lt;class 'json.decoder.JSONDecoder'&gt; _default_decoder
# &lt;class 'json.encoder.JSONEncoder'&gt; _default_encoder
# &lt;class '_frozen_importlib.ModuleSpec'&gt; __spec__
# &lt;class '_frozen_importlib_external.SourceFileLoader'&gt; __loader__
# &lt;class 'dict'&gt; __builtins__
# &lt;class 'function'&gt; detect_encoding
# &lt;class 'function'&gt; dump
# &lt;class 'function'&gt; dumps
# &lt;class 'function'&gt; load
# &lt;class 'function'&gt; loads
# &lt;class 'list'&gt; __all__
# &lt;class 'list'&gt; __path__
# &lt;class 'module'&gt; codecs
# &lt;class 'module'&gt; decoder
# &lt;class 'module'&gt; encoder
# &lt;class 'module'&gt; scanner
# &lt;class 'str'&gt; __author__
# &lt;class 'str'&gt; __cached__
# &lt;class 'str'&gt; __doc__
# &lt;class 'str'&gt; __file__
# &lt;class 'str'&gt; __name__
# &lt;class 'str'&gt; __package__
# &lt;class 'str'&gt; __version__
# &lt;class 'type'&gt; JSONDecodeError
# &lt;class 'type'&gt; JSONDecoder
# &lt;class 'type'&gt; JSONEncoder
</code></pre>
</div>
<span class="comment-copy">Is this an open source library? If so, can you share a link?</span>
<span class="comment-copy">unfortunately it's a commercial one</span>
<span class="comment-copy">unfortunately that package doesn't have <code>__all__</code> defined</span>
<span class="comment-copy">@nos - in that case, it will be fairly tricky. Edited the answer with an approach that may be helpful to get you started with the investigation.</span>
