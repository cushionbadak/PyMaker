<div class="post-text" itemprop="text">
<p>I know that you can cast <code>dict_items</code> into a <code>list</code> to allow item indexing. But I do not know why this operation is not allowed directly. Is it because <code>dict_items</code> objects are generators? If so, when I'm seeing</p>
<pre><code>&gt;&gt;&gt; {"foo": "bar", "baz": "qux"}.items()
dict_items([('foo', 'bar'), ('baz', 'qux')]) 
</code></pre>
<p>is Python evaluating my generator when <code>repr</code> is called?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dict_items</code> do not support indexing because these objects are intended to be set-like, and sets do not support indexing.</p>
<p>They do quack like sets in other ways:</p>
<pre><code>&gt;&gt;&gt; d1 = {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}
&gt;&gt;&gt; d2 = {'k2': 'v2', 'k3': 'not v3'}
&gt;&gt;&gt; d1.items() &amp; d2.items()
{('k2', 'v2')}
&gt;&gt;&gt; d1.items() | d2.items()
{('k1', 'v1'), ('k2', 'v2'), ('k3', 'not v3'), ('k3', 'v3')}
</code></pre>
<p>If any value is not hashable, you lose the ability to treat the dict items views with set operations.</p>
<p>It is not sensible to give indexing support to <code>dict_items</code> views, because the dict does not have an ordering until Python 3.7+, so accessing "the 0th" item would not be well-defined. Even in Python 3.7, where there <em>is</em> a sensible ordering to use for indexing (i.e. the insertion order), it is non-trivial to implement this with <em>O(1)</em> complexity, so it's not supported. The "unwritten rule" is that indexing should be constant-time operation (as it is for list, tuple, dict, str - <a href="https://wiki.python.org/moin/TimeComplexity" rel="noreferrer">see here</a>).</p>
</div>
<span class="comment-copy">Note that you're not <i>casting</i> it to a <code>list</code>; you're creating a new list from it. Whether or not this is efficient depends on the Python implementation.</span>
<span class="comment-copy">There is no built-in named <code>dict_items</code>. I assume you mean the <code>dict</code> method <code>items()</code>.</span>
<span class="comment-copy">@martineau: <code>type({}.items()).__name__</code> -&gt; <code>'dict_items'</code></span>
<span class="comment-copy">I think it's because the object of type <code>dict_items</code> that the <code>dict.items()</code> method returns is a <a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow noreferrer">dictionary view object</a> which are dynamic and reflect changes that may be occurring to the dictionary on-the-flyâ€”so indexing something like that which might change at any moment doesn't make too much sense. If you convert it to a list, the contents of that list would be changed by updates to the dictionary it came from.</span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/52507860/accessing-dictionary-items-by-position-in-python-3-6-efficiently">Accessing dictionary items by position in Python 3.6+ efficiently</a>, specifically <a href="https://stackoverflow.com/a/52507957/9209546">this answer</a>.</span>
<span class="comment-copy">That's actually a much better reason than the one I gave of "It's not supported because there's no support for it" :)</span>
<span class="comment-copy">wim: How did you learn all this about the undocumented type? Just by experiments or perhaps reading the CPython source code?</span>
<span class="comment-copy">Good question..reading the mailing lists, seeing the comments from CPython core developers on bugs.python.org, <a href="https://stackoverflow.com/q/35784258/674039">finding bugs in the implementation</a> etc.</span>
<span class="comment-copy">Good answer. To appreciate <code>it is non-trivial to implement this with O(1) complexity</code>, see <a href="https://stackoverflow.com/a/52507957/9209546">this answer</a> and the comments.</span>
